{
    "00401005": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401005(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint var_280h;\n    uint lpBuffer;\n    int32_t var_10ch;\n    uint lpLibFileName;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentDirectoryA)(0x104, &lpBuffer);\n    if (iVar1 == 0) {\n        var_10ch = 0;\n    }\n    else {\n        fcn.00404f50(&lpBuffer, 0x4161cc);\n        fcn.00404f40(&lpLibFileName, &lpBuffer);\n        fcn.004050bb(arg_8h & 0xffff, &var_280h, 10);\n        fcn.00404f50(&lpLibFileName, &var_280h);\n        fcn.00404f50(&lpLibFileName, \"\\\\Satellite.dll\");\n        var_10ch = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(&lpLibFileName);\n        if (var_10ch == 0) {\n            fcn.00404f40(&lpLibFileName, &lpBuffer);\n            fcn.004050bb(arg_8h & 0x3ff, &var_280h, 10);\n            fcn.00404f50(&lpLibFileName, &var_280h);\n            fcn.00404f50(&lpLibFileName, \"\\\\Satellite.dll\");\n            var_10ch = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(&lpLibFileName);\n            if (var_10ch == 0) {\n                var_10ch = 0;\n            }\n        }\n    }\n    return var_10ch;\n}\n",
        "token_count": 377
    },
    "0040101e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpType\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.0040101e(void)\n\n{\n    uint32_t uVar1;\n    uint lpType;\n    uint var_14h;\n    int32_t lParam;\n    uint var_ch;\n    uint lpName;\n    int32_t hModule;\n    \n    lpName = 1;\n    fcn.004051e0(&lParam, 0, 8, 0x10);\n    hModule = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"ntdll.dll\");\n    if (hModule == 0) {\n        uVar1 = 0;\n    }\n    else {\n        uVar1 = (*_sym.imp.KERNEL32.dll_EnumResourceLanguagesA)(hModule, 0x10, lpName, 0x401037, &lParam);\n        if (((uVar1 == 0) || (2 < lParam)) || (lParam < 1)) {\n            uVar1 = uVar1 & 0xffff0000;\n        }\n        else {\n            uVar1 = uVar1 & 0xffff0000 | var_ch;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 270
    },
    "00401028": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00401028(void)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    uint var_ch;\n    uint var_8h;\n    uint hLibModule;\n    \n    var_8h = 0;\n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"imm32.dll\");\n    if (iVar1 != 0) {\n        pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"ImmReleaseContext\");\n        if (pcVar2 != NULL) {\n            var_8h = (*pcVar2)(0, 0);\n        }\n        (*_sym.imp.KERNEL32.dll_FreeLibrary)(iVar1);\n    }\n    return var_8h;\n}\n",
        "token_count": 160
    },
    "0040102d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040102d(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    var_8h = 0xffffffff;\n    for (var_18h = 0; *(arg_8h + var_18h) != 0; var_18h = var_18h + 1) {\n        uVar1 = var_8h ^ *(arg_8h + var_18h);\n        var_8h = var_8h >> 8 ^\n                 (uVar1 << 0x1f) >> 0x1f & 0x77073096U ^ (uVar1 << 0x1e) >> 0x1f & 0xee0e612cU ^\n                 (uVar1 << 0x1d) >> 0x1f & 0x76dc419U ^ (uVar1 << 0x1c) >> 0x1f & 0xedb8832U ^\n                 (uVar1 << 0x1b) >> 0x1f & 0x1db71064U ^ (uVar1 << 0x1a) >> 0x1f & 0x3b6e20c8U ^\n                 (uVar1 << 0x19) >> 0x1f & 0x76dc4190U ^ (uVar1 << 0x18) >> 0x1f & 0xedb88320U;\n    }\n    return ~var_8h;\n}\n",
        "token_count": 430
    },
    "00401032": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401032(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t iVar1;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*(in_ECX + 0x14) < arg_8h) {\n        fcn.00404169();\n    }\n    if (*(in_ECX + 0x14) - arg_8h < arg_ch) {\n        arg_ch = *(in_ECX + 0x14) - arg_8h;\n    }\n    if (arg_ch != 0) {\n        if (*(in_ECX + 0x18) < 0x10) {\n            var_14h = in_ECX + 4;\n        }\n        else {\n            var_14h = *(in_ECX + 4);\n        }\n        if (*(in_ECX + 0x18) < 0x10) {\n            var_18h = in_ECX + 4;\n        }\n        else {\n            var_18h = *(in_ECX + 4);\n        }\n        fcn.00405250(var_18h + arg_8h, var_14h + arg_8h + arg_ch, (*(in_ECX + 0x14) - arg_8h) - arg_ch);\n        iVar1 = *(in_ECX + 0x14) - arg_ch;\n        *(in_ECX + 0x14) = iVar1;\n        if (*(in_ECX + 0x18) < 0x10) {\n            var_1ch = in_ECX + 4;\n        }\n        else {\n            var_1ch = *(in_ECX + 4);\n        }\n        *(var_1ch + iVar1) = 0;\n    }\n    return in_ECX;\n}\n",
        "token_count": 439
    },
    "00401041": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004038a3)\n// WARNING: Removing unreachable block (ram,0x00403905)\n// WARNING: Removing unreachable block (ram,0x004038b6)\n// WARNING: Removing unreachable block (ram,0x00403918)\n\nvoid __thiscall fcn.00401041(int32_t param_1, uint32_t param_2, int32_t param_3)\n\n{\n    uint arg_8h;\n    uint32_t uVar1;\n    uint *in_FS_OFFSET;\n    uint32_t var_8h;\n    int32_t var_ch;\n    uint var_10h;\n    int32_t var_70h;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_4dh;\n    int32_t var_3ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint32_t var_18h;\n    uint var_14h;\n    uint var_ch_2;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x4139c0;\n    var_ch_2 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch_2;\n    var_18h = var_8h | 0xf;\n    if (var_18h == 0xffffffff) {\n        var_18h = var_8h;\n    }\n    else if ((var_18h / 3 < *(param_1 + 0x18) >> 1) &&\n            (uVar1 = -(*(param_1 + 0x18) >> 1) - 2,  *(param_1 + 0x18) < uVar1 || *(param_1 + 0x18) == uVar1)) {\n        var_18h = (*(param_1 + 0x18) >> 1) + *(param_1 + 0x18);\n    }\n    var_4h = 0;\n    arg_8h = fcn.0040429b(var_18h + 1);\n    var_4h = 0xffffffff;\n    if (var_ch != 0) {\n        if (*(param_1 + 0x18) < 0x10) {\n            var_3ch = param_1 + 4;\n        }\n        else {\n            var_3ch = *(param_1 + 4);\n        }\n        fcn.00404a30(arg_8h, var_3ch, var_ch);\n    }\n    fcn.00401069(1, 0);\n    *(param_1 + 4) = arg_8h;\n    *(param_1 + 0x18) = var_18h;\n    *(param_1 + 0x14) = var_ch;\n    if (*(param_1 + 0x18) < 0x10) {\n        var_70h = param_1 + 4;\n    }\n    else {\n        var_70h = *(param_1 + 4);\n    }\n    *(var_70h + var_ch) = 0;\n    *in_FS_OFFSET = var_ch_2;\n    return;\n}\n",
        "token_count": 734
    },
    "00401046": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040339e)\n// WARNING: Removing unreachable block (ram,0x004033b1)\n\nbool __cdecl fcn.00401046(uint32_t arg_8h, uint arg_ch)\n\n{\n    int32_t in_ECX;\n    uchar *var_2ch;\n    uint32_t var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_12h;\n    uint var_8h;\n    uint var_4h;\n    \n    if (0xfffffffe < arg_8h) {\n        fcn.00404243();\n    }\n    if (*(in_ECX + 0x18) < arg_8h) {\n        fcn.00401041(arg_8h, *(in_ECX + 0x14));\n    }\n    else if ((arg_ch == '\\0') || (0xf < arg_8h)) {\n        if (arg_8h == 0) {\n            *(in_ECX + 0x14) = 0;\n            if (*(in_ECX + 0x18) < 0x10) {\n                var_2ch = in_ECX + 4;\n            }\n            else {\n                var_2ch = *(in_ECX + 4);\n            }\n            *var_2ch = 0;\n        }\n    }\n    else {\n        if (arg_8h < *(in_ECX + 0x14)) {\n            var_28h = arg_8h;\n        }\n        else {\n            var_28h = *(in_ECX + 0x14);\n        }\n        fcn.00401069(1, var_28h);\n    }\n    return arg_8h != 0;\n}\n",
        "token_count": 395
    },
    "004022e0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004022e0(uint arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    uint var_4h;\n    \n    if (arg_ch == 0x110) {\n        uVar1 = 1;\n    }\n    else if ((arg_ch == 0x111) && ((arg_10h == 1 || (arg_10h == 2)))) {\n        (*_sym.imp.USER32.dll_EndDialog)(arg_8h, arg_10h);\n        uVar1 = 1;\n    }\n    else {\n        uVar1 = 0;\n    }\n    return uVar1;\n}\n",
        "token_count": 149
    },
    "0040105f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0040105f(uint arg_8h, uint nCmdShow)\n\n{\n    int32_t iVar1;\n    uint hWnd;\n    \n    *0x41b9ec = arg_8h;\n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x41b9f8, 0x41b988, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 != 0) {\n        (*_sym.imp.USER32.dll_ShowWindow)(iVar1, nCmdShow);\n        (*_sym.imp.USER32.dll_UpdateWindow)(iVar1);\n    }\n    return iVar1 != 0;\n}\n",
        "token_count": 178
    },
    "00401069": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401069(uint arg_8h, int32_t arg_ch)\n\n{\n    uint arg_ch_00;\n    int32_t in_ECX;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_9h;\n    uint var_4h;\n    \n    if ((arg_8h != '\\0') && (0xf < *(in_ECX + 0x18))) {\n        arg_ch_00 = *(in_ECX + 4);\n        if (arg_ch != 0) {\n            fcn.00404a30(in_ECX + 4, arg_ch_00, arg_ch);\n        }\n        fcn.00405240(arg_ch_00);\n    }\n    *(in_ECX + 0x18) = 0xf;\n    *(in_ECX + 0x14) = arg_ch;\n    if (*(in_ECX + 0x18) < 0x10) {\n        var_14h = in_ECX + 4;\n    }\n    else {\n        var_14h = *(in_ECX + 4);\n    }\n    *(var_14h + arg_ch) = 0;\n    return;\n}\n",
        "token_count": 261
    },
    "00401078": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040373e)\n// WARNING: Removing unreachable block (ram,0x00403751)\n\nbool __cdecl fcn.00401078(uint32_t arg_8h, uint arg_ch)\n\n{\n    int32_t in_ECX;\n    ushort *var_28h;\n    uint32_t var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_8h;\n    uint var_4h;\n    \n    if (0x7ffffffe < arg_8h) {\n        fcn.00404243();\n    }\n    if (*(in_ECX + 0x18) < arg_8h) {\n        fcn.004010af(arg_8h, *(in_ECX + 0x14));\n    }\n    else if ((arg_ch == '\\0') || (7 < arg_8h)) {\n        if (arg_8h == 0) {\n            *(in_ECX + 0x14) = 0;\n            if (*(in_ECX + 0x18) < 8) {\n                var_28h = in_ECX + 4;\n            }\n            else {\n                var_28h = *(in_ECX + 4);\n            }\n            *var_28h = 0;\n        }\n    }\n    else {\n        if (arg_8h < *(in_ECX + 0x14)) {\n            var_24h = arg_8h;\n        }\n        else {\n            var_24h = *(in_ECX + 0x14);\n        }\n        fcn.0040107d(1, var_24h);\n    }\n    return arg_8h != 0;\n}\n",
        "token_count": 387
    },
    "0040107d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040107d(uint arg_8h, int32_t arg_ch)\n\n{\n    uint arg_ch_00;\n    int32_t in_ECX;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ah;\n    uint var_4h;\n    \n    if ((arg_8h != '\\0') && (7 < *(in_ECX + 0x18))) {\n        arg_ch_00 = *(in_ECX + 4);\n        if (arg_ch != 0) {\n            fcn.00404a30(in_ECX + 4, arg_ch_00, arg_ch << 1);\n        }\n        fcn.00405240(arg_ch_00);\n    }\n    *(in_ECX + 0x18) = 7;\n    *(in_ECX + 0x14) = arg_ch;\n    if (*(in_ECX + 0x18) < 8) {\n        var_14h = in_ECX + 4;\n    }\n    else {\n        var_14h = *(in_ECX + 4);\n    }\n    *(var_14h + arg_ch * 2) = 0;\n    return;\n}\n",
        "token_count": 263
    },
    "00402370": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00402370(uint arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint16_t extraout_var;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = (*_sym.imp.USER32.dll_GetDlgItem)(arg_8h, 0x3e9);\n    uVar2 = (*_sym.imp.USER32.dll_GetParent)(arg_8h);\n    if (arg_ch == 0x110) {\n        fcn.004010c3(uVar1);\n        return 1;\n    }\n    if (arg_ch == 0x111) {\n        if (arg_10h == 1) {\n            iVar3 = (*_sym.imp.USER32.dll_SendMessageA)(uVar1, 0x147, 0, 0);\n            if (((iVar3 != -1) &&\n                (uVar4 = (*_sym.imp.USER32.dll_SendMessageA)(uVar1, 0x150, iVar3, 0),  uVar4 != 0xffffffff)) &&\n               (uVar4 != *0x41b9f0)) {\n                var_10h._0_2_ = uVar4;\n                *0x41b9f0 = var_10h;\n                *0x41b980 = fcn.00401005(uVar4 & 0xffff | extraout_var << 0x10);\n                if (*0x41b980 == 0) {\n                    *0x41b980 = *0x41b9ec;\n                }\n                (*_sym.imp.USER32.dll_InvalidateRect)(uVar2, 0, 1);\n                (*_sym.imp.USER32.dll_UpdateWindow)(uVar2);\n                (*_sym.imp.USER32.dll_LoadStringA)(*0x41b980, 0x67, 0x41b988, 100);\n                (*_sym.imp.USER32.dll_SendMessageA)(uVar2, 0xc, 0, 0x41b988);\n                uVar1 = (*_sym.imp.USER32.dll_GetMenu)(uVar2);\n                (*_sym.imp.USER32.dll_DestroyMenu)(uVar1);\n                uVar1 = (*_sym.imp.USER32.dll_LoadMenuA)(*0x41b980, 0x6d);\n                (*_sym.imp.USER32.dll_SetMenu)(uVar2, uVar1);\n                (*_sym.imp.USER32.dll_DrawMenuBar)(uVar2);\n            }\n        }\n        else if (arg_10h != 2) goto code_r0x00402509;\n        (*_sym.imp.USER32.dll_EndDialog)(arg_8h, arg_10h);\n        uVar1 = 1;\n    }\n    else {\ncode_r0x00402509:\n        uVar1 = 0;\n    }\n    return uVar1;\n}\n",
        "token_count": 694
    },
    "00401087": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401087(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t iVar1;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*(in_ECX + 0x14) < arg_8h) {\n        fcn.00404169();\n    }\n    if (*(in_ECX + 0x14) - arg_8h < arg_ch) {\n        arg_ch = *(in_ECX + 0x14) - arg_8h;\n    }\n    if (arg_ch != 0) {\n        if (*(in_ECX + 0x18) < 8) {\n            var_14h = in_ECX + 4;\n        }\n        else {\n            var_14h = *(in_ECX + 4);\n        }\n        if (*(in_ECX + 0x18) < 8) {\n            var_18h = in_ECX + 4;\n        }\n        else {\n            var_18h = *(in_ECX + 4);\n        }\n        fcn.00405250(var_18h + arg_8h * 2, var_14h + arg_8h * 2 + arg_ch * 2, ((*(in_ECX + 0x14) - arg_8h) - arg_ch) * 2\n                    );\n        iVar1 = *(in_ECX + 0x14) - arg_ch;\n        *(in_ECX + 0x14) = iVar1;\n        if (*(in_ECX + 0x18) < 8) {\n            var_1ch = in_ECX + 4;\n        }\n        else {\n            var_1ch = *(in_ECX + 4);\n        }\n        *(var_1ch + iVar1 * 2) = 0;\n    }\n    return in_ECX;\n}\n",
        "token_count": 452
    },
    "00401ff0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00401ff0(uint arg_8h, int32_t arg_ch, uint32_t arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    uint var_10ch;\n    uint var_108h;\n    int32_t var_104h;\n    int32_t var_100h;\n    uint var_f4h;\n    uint var_f0h;\n    uint var_ech;\n    uint var_e8h;\n    uint var_e4h;\n    uint var_e0h;\n    uint var_dch;\n    uchar var_d8h;\n    uchar var_d7h;\n    uchar var_d6h;\n    uchar var_d5h;\n    uchar var_d4h [32];\n    uint32_t var_b4h;\n    uint32_t var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint var_68h;\n    \n    var_f0h = 0x14;\n    var_ech = 0;\n    var_e8h = 0;\n    var_e4h = 0;\n    var_e0h = 0;\n    var_dch._0_1_ = 0;\n    var_dch._1_1_ = 0;\n    var_dch._2_1_ = 0;\n    var_dch._3_1_ = 1;\n    var_d8h = 0;\n    var_d7h = 0;\n    var_d6h = 0;\n    var_d5h = 0;\n    fcn.00404d6d(var_d4h, 0x4161a0, 0x20);\n    if (arg_ch == 2) {\n        (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n    }\n    else if (arg_ch == 0xf) {\n        var_f4h = (*_sym.imp.USER32.dll_BeginPaint)(arg_8h, &var_a8h);\n        (*_sym.imp.USER32.dll_GetClientRect)(arg_8h, &var_104h);\n        var_ach = (*_sym.imp.GDI32.dll_CreateFontIndirectA)(&var_f0h);\n        (*_sym.imp.GDI32.dll_SelectObject)(var_f4h, var_ach);\n        var_100h = var_100h + 0x14;\n        var_104h = var_104h + 0x14;\n        (*_sym.imp.USER32.dll_LoadStringA)(*0x41b980, 0x68, &var_68h, 100);\n        uVar1 = fcn.004049a0(&var_68h, &var_104h, 0);\n        (*_sym.imp.USER32.dll_DrawTextA)(var_f4h, &var_68h, uVar1);\n        (*_sym.imp.USER32.dll_EndPaint)(arg_8h, &var_a8h);\n    }\n    else {\n        if (arg_ch != 0x111) {\n            uVar1 = (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n            return uVar1;\n        }\n        var_b0h = arg_10h & 0xffff;\n        var_b4h = arg_10h >> 0x10;\n        if (var_b0h == 0x68) {\n            (*_sym.imp.USER32.dll_DialogBoxParamA)(*0x41b980, 0x67, arg_8h, 0x401050, 0);\n        }\n        else if (var_b0h == 0x69) {\n            (*_sym.imp.USER32.dll_DestroyWindow)(arg_8h);\n        }\n        else {\n            if (var_b0h != 0x81) {\n                uVar1 = (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, 0x111, arg_10h, arg_14h);\n                return uVar1;\n            }\n            (*_sym.imp.USER32.dll_DialogBoxParamA)(*0x41b980, 0x65, arg_8h, 0x401082, 0);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 933
    },
    "004010a5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004010a5(int32_t arg_8h, uint noname_1, uint noname_2, uint arg_14h)\n\n{\n    uint uVar1;\n    uint arg_10h;\n    int32_t iVar2;\n    uint var_44h;\n    uint hResData;\n    uint var_3ch;\n    uint var_38h;\n    uint lpMsg;\n    uint var_2ch;\n    uint hAccTable;\n    uint var_14h;\n    code *var_10h;\n    uint var_ch;\n    uint var_8h;\n    code *var_4h;\n    \n    uVar1 = fcn.004010b9();\n    *0x41b9f0 = uVar1;\n    *0x41b980 = fcn.00401005(uVar1);\n    if (*0x41b980 == 0) {\n        *0x41b980 = arg_8h;\n    }\n    var_14h = 0x416150;\n    (*_sym.imp.USER32.dll_LoadStringA)(*0x41b980, 0x67, 0x41b988, 100);\n    (*_sym.imp.USER32.dll_LoadStringA)(*0x41b980, 0x6d, 0x41b9f8, 100);\n    fcn.004010c8(arg_8h);\n    var_8h = (*_sym.imp.KERNEL32.dll_FindResourceA)(0, 0x1bd, 10);\n    uVar1 = (*_sym.imp.KERNEL32.dll_LoadResource)(0, var_8h);\n    arg_10h = (*_sym.imp.KERNEL32.dll_SizeofResource)(0, var_8h);\n    var_ch = (*_sym.imp.KERNEL32.dll_LockResource)(uVar1);\n    var_10h = fcn.0040106e(0x41611c, \"VirtualAlloc\");\n    var_4h = (*var_10h)(0, arg_10h, 0x1000, 0x40);\n    fcn.00404a30(var_4h, var_ch, arg_10h);\n    fcn.004010b4(var_14h, var_4h, arg_10h);\n    (*var_4h)();\n    iVar2 = fcn.0040105f(arg_8h, arg_14h);\n    if (iVar2 == 0) {\n        var_2ch = 0;\n    }\n    else {\n        hAccTable = (*_sym.imp.USER32.dll_LoadAcceleratorsA)(*0x41b980, 0x6d);\n        while (iVar2 = (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0),  iVar2 != 0) {\n            iVar2 = (*_sym.imp.USER32.dll_TranslateAcceleratorA)(lpMsg, hAccTable, &lpMsg);\n            if (iVar2 == 0) {\n                (*_sym.imp.USER32.dll_TranslateMessage)(&lpMsg);\n                (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n            }\n        }\n    }\n    return var_2ch;\n}\n",
        "token_count": 705
    },
    "004010af": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00403ba3)\n// WARNING: Removing unreachable block (ram,0x00403c05)\n// WARNING: Removing unreachable block (ram,0x00403bb6)\n// WARNING: Removing unreachable block (ram,0x00403c18)\n\nvoid __thiscall fcn.004010af(int32_t param_1, uint32_t param_2, int32_t param_3)\n\n{\n    uint arg_8h;\n    uint32_t uVar1;\n    uint *in_FS_OFFSET;\n    uint32_t var_8h;\n    int32_t var_ch;\n    uint var_10h;\n    int32_t var_64h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    int32_t var_38h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint32_t var_18h;\n    uint var_14h;\n    uint var_ch_2;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x4139d0;\n    var_ch_2 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch_2;\n    var_18h = var_8h | 7;\n    if (var_18h < 0x7fffffff) {\n        if ((var_18h / 3 < *(param_1 + 0x18) >> 1) &&\n           (uVar1 = 0x7ffffffe - (*(param_1 + 0x18) >> 1),  *(param_1 + 0x18) < uVar1 || *(param_1 + 0x18) == uVar1)) {\n            var_18h = (*(param_1 + 0x18) >> 1) + *(param_1 + 0x18);\n        }\n    }\n    else {\n        var_18h = var_8h;\n    }\n    var_4h = 0;\n    arg_8h = fcn.0040429b(var_18h * 2 + 2);\n    var_4h = 0xffffffff;\n    if (var_ch != 0) {\n        if (*(param_1 + 0x18) < 8) {\n            var_38h = param_1 + 4;\n        }\n        else {\n            var_38h = *(param_1 + 4);\n        }\n        fcn.00404a30(arg_8h, var_38h, var_ch << 1);\n    }\n    fcn.0040107d(1, 0);\n    *(param_1 + 4) = arg_8h;\n    *(param_1 + 0x18) = var_18h;\n    *(param_1 + 0x14) = var_ch;\n    if (*(param_1 + 0x18) < 8) {\n        var_64h = param_1 + 4;\n    }\n    else {\n        var_64h = *(param_1 + 4);\n    }\n    *(var_64h + var_ch * 2) = 0;\n    *in_FS_OFFSET = var_ch_2;\n    return;\n}\n",
        "token_count": 749
    },
    "004010b9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.004010b9(void)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint var_100h;\n    uint var_fch;\n    uint lpVersionInformation;\n    uint32_t var_f4h;\n    int32_t var_e8h;\n    int32_t var_5ch;\n    uint var_58h;\n    uint hKey;\n    uint var_50h;\n    \n    var_58h._0_2_ = 0;\n    var_fch = 0x50;\n    lpVersionInformation = 0x94;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    if (iVar1 == 0) {\n        uVar2 = 0;\n    }\n    else {\n        if (var_e8h == 1) {\n            iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)\n                              (0x80000001, \"Default\\\\Control Panel\\\\Desktop\\\\ResourceLocale\", 0, 1, &hKey);\n            if (iVar1 == 0) {\n                iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, 0, 0, &var_5ch, 0, 0);\n                if (((iVar1 == 0) && (var_5ch == 1)) &&\n                   (iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, 0, 0, &var_5ch, &var_50h, &var_fch), \n                   iVar1 == 0)) {\n                    var_58h._0_2_ = fcn.00404e88(&var_50h);\n                }\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n            }\n        }\n        else if (var_e8h == 2) {\n            if (var_f4h < 5) {\n                var_58h._0_2_ = fcn.0040101e();\n                if ((var_58h == 0x409) && (iVar1 = fcn.00401028(),  iVar1 != 0)) {\n                    var_58h._0_2_ = 0xc04;\n                }\n            }\n            else {\n                var_58h._0_2_ = (*_sym.imp.KERNEL32.dll_GetUserDefaultUILanguage)();\n            }\n        }\n        uVar2 = var_58h;\n        if (uVar2 == 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetUserDefaultLangID)();\n            var_58h._0_2_ = uVar2;\n        }\n        uVar2 = uVar2 & 0xffff0000 | var_58h;\n    }\n    return uVar2;\n}\n",
        "token_count": 631
    },
    "004010c3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004010c3(uint hWnd)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t var_364h;\n    uint lpLCData;\n    int32_t hFindFile;\n    uint lpFileName;\n    int32_t lParam;\n    int32_t var_14ch;\n    uint32_t lpFindFileData;\n    uint var_11ch;\n    uint wParam;\n    \n    var_14ch = 0;\n    wParam = 0;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentDirectoryA)(0x104, &lpFileName);\n    if (iVar1 == 0) {\n        var_14ch = 0;\n    }\n    else {\n        uVar2 = fcn.00405038(&lpFileName);\n        if (uVar2 < 0x100) {\n            fcn.00404f50(&lpFileName, \"\\\\*.*\");\n        }\n        hFindFile = (*_sym.imp.KERNEL32.dll_FindFirstFileA)(&lpFileName, &lpFindFileData);\n        if (hFindFile == -1) {\n            (*_sym.imp.KERNEL32.dll_FindClose)(0xffffffff);\n            var_14ch = 0;\n        }\n        else {\n            (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0x14b, 0, 0);\n            do {\n                if ((((lpFindFileData & 0x10) != 0) && (lParam = fcn.00404e88(&var_11ch),  lParam != 0)) &&\n                   (iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)(lParam, 4, &lpLCData, 0xff),  iVar1 != 0)) {\n                    wParam = (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0x143, 0, &lpLCData);\n                    (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0x151, wParam, lParam);\n                    var_14ch = var_14ch + 1;\n                }\n                iVar1 = (*_sym.imp.KERNEL32.dll_FindNextFileA)(hFindFile, &lpFindFileData);\n            } while (iVar1 != 0);\n            (*_sym.imp.KERNEL32.dll_FindClose)(hFindFile);\n            for (var_364h = 0; var_364h <= var_14ch; var_364h = var_364h + 1) {\n                uVar3 = *0x41b9f0;\n                uVar2 = (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0x150, var_364h, 0);\n                if (uVar3 == uVar2) {\n                    (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0x14e, var_364h, 0);\n                }\n            }\n        }\n    }\n    return var_14ch;\n}\n",
        "token_count": 656
    },
    "004059bf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004059bf(code **param_1)\n\n{\n    *param_1 = vtable.exception.0;\n    if (param_1[2] != NULL) {\n        fcn.00406cec(param_1[1]);\n    }\n    return;\n}\n",
        "token_count": 61
    },
    "0040449a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.0040449a(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint arg_8h, uint arg_ch, uint noname_16, uint noname_17, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    uint *var_8h_3;\n    uint *var_ch_2;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    uint var_34h;\n    uint *var_30h;\n    uint var_2ch;\n    uint *var_28h_2;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint *puStack28;\n    uint uStack24;\n    uint uStack20;\n    uchar *puStack16;\n    uchar *var_8h_2;\n    int32_t var_4h_2;\n    \n    var_8h_2 = &stack0xfffffffc;\n    puStack16 = &stack0xffffffc4;\n    if (var_8h_3 == 0x123) {\n        *var_ch_2 = 0x404535;\n        var_34h = 1;\n    }\n    else {\n        pcStack40 = fcn.00404561;\n        uStack36 = *0x41ad6c;\n        uStack32 = var_20h;\n        puStack28 = var_ch_2;\n        uStack24 = var_1ch;\n        uStack20 = var_18h;\n        var_4h_2 = 0;\n        var_28h_2 = *in_FS_OFFSET;\n        *in_FS_OFFSET = &fcn.0040449a::var_28h_2;\n        var_30h = var_8h_3;\n        var_2ch = var_28h;\n        iVar1 = fcn.00406941(*var_8h_3, &fcn.0040449a::var_30h);\n        (**(iVar1 + 0x74))();\n        var_34h = 0;\n        if (var_4h_2 == 0) {\n            *in_FS_OFFSET = var_28h_2;\n        }\n        else {\n            *var_28h_2 = **in_FS_OFFSET;\n            *in_FS_OFFSET = var_28h_2;\n        }\n    }\n    return var_34h;\n}\n",
        "token_count": 667
    },
    "00404561": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00404561(int32_t param_1, int32_t param_2, uint param_3, uint param_4, uint param_5, uint param_6, uint param_7\n                 , uint param_8)\n\n{\n    uint uVar1;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    int32_t arg_20h;\n    int32_t noname_8;\n    code *extraout_var;\n    code *UNRECOVERED_JUMPTABLE;\n    \n    if (*(param_2 + 8) == *0x41ad6c) {\n        if ((*(param_1 + 4) & 0x66) == 0) {\n            noname_8 = 1;\n            arg_20h = *(param_2 + 0x18);\n            fcn.00406866(param_1, *(param_2 + 0x10), param_3, 0, *(param_2 + 0xc), *(param_2 + 0x14), arg_20h, 1);\n            UNRECOVERED_JUMPTABLE = extraout_var;\n            if (*(param_2 + 0x24) == 0) {\n                arg_20h = param_2;\n                noname_8 = param_1;\n                fcn.004043bd(param_2, param_1);\n            }\n            fcn.0040449a(0x123, &stack0xfffffff8, 0, 0, 0, 0, 0, arg_20h, noname_8, unaff_EBX, UNRECOVERED_JUMPTABLE, \n                         unaff_EBP, unaff_retaddr, param_1, param_2, param_3, param_4, param_5, param_6, param_7, \n                         param_8);\n    // WARNING: Could not recover jumptable at 0x0040460b. Too many branches\n    // WARNING: Treating indirect jump as call\n            uVar1 = (*UNRECOVERED_JUMPTABLE)();\n            return uVar1;\n        }\n        *(param_2 + 0x24) = 1;\n    }\n    else {\n        *(param_1 + 4) = *(param_1 + 4) | 8;\n    }\n    return 1;\n}\n",
        "token_count": 522
    },
    "00404613": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00404613(uint32_t arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t *arg_14h, uint32_t *arg_18h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t var_4h;\n    \n    iVar3 = arg_8h;\n    var_4h = *(arg_8h + 0xc);\n    iVar2 = *(arg_8h + 0x10);\n    uVar4 = var_4h;\n    arg_8h = var_4h;\n    if (-1 < arg_ch) {\n        do {\n            if (uVar4 == 0xffffffff) {\n                fcn.00406c70();\n            }\n            uVar4 = uVar4 - 1;\n            iVar1 = iVar2 + uVar4 * 0x14;\n            if (((*(iVar1 + 4) < arg_10h) && (arg_10h <= *(iVar1 + 8))) || (uVar4 == 0xffffffff)) {\n                arg_ch = arg_ch + -1;\n                var_4h = arg_8h;\n                arg_8h = uVar4;\n            }\n        } while (-1 < arg_ch);\n    }\n    uVar4 = uVar4 + 1;\n    *arg_14h = uVar4;\n    *arg_18h = var_4h;\n    if ((*(iVar3 + 0xc) <= var_4h && var_4h != *(iVar3 + 0xc)) || (var_4h < uVar4)) {\n        fcn.00406c70();\n    }\n    return iVar2 + uVar4 * 0x14;\n}\n",
        "token_count": 404
    },
    "004046d6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.004046d6(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    \n    iVar2 = fcn.00406941();\n    if (param_1 == *(iVar2 + 0x88)) {\n        iVar2 = fcn.00406941();\n        *(iVar2 + 0x88) = *(param_1 + 4);\n        return;\n    }\n    iVar2 = fcn.00406941();\n    iVar2 = *(iVar2 + 0x88);\n    do {\n        iVar3 = iVar2;\n        if (*(iVar3 + 4) == 0) {\n            fcn.00407c04(0x416430, 8);\n            pcVar1 = *0x41ad74;\n            if (*0x41ad74 != NULL) {\n                *(unaff_EBP + -4) = 0;\n                (*pcVar1)();\n                *(unaff_EBP + -4) = 0xffffffff;\n            }\n            fcn.00407c04(0x416420, 8);\n            iVar2 = fcn.00406941();\n            if (*(iVar2 + 0x6c) != 0) {\n                *(unaff_EBP + -4) = 0;\n                iVar2 = fcn.00406941();\n                (**(iVar2 + 0x6c))();\n                *(unaff_EBP + -4) = 0xffffffff;\n            }\n            fcn.00408838(10);\n            fcn.0040dc4a(0x16);\n            fcn.00408809(3);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n        iVar2 = *(iVar3 + 4);\n    } while (param_1 != *(iVar3 + 4));\n    *(iVar3 + 4) = *(param_1 + 4);\n    return;\n}\n",
        "token_count": 439
    },
    "00406c23": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00406c23(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00407c04(0x416420, 8);\n    iVar2 = fcn.00406941();\n    if (*(iVar2 + 0x6c) != 0) {\n        *(unaff_EBP + -4) = 0;\n        iVar2 = fcn.00406941();\n        (**(iVar2 + 0x6c))();\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    fcn.00408838(10);\n    fcn.0040dc4a(0x16);\n    fcn.00408809(3);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 213
    },
    "00404880": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_20h_2\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_4h_2\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00404880(uint arg_8h_2, uint noname_1, uint arg_8h)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    int32_t noname_5;\n    uint *noname_4;\n    uint16_t *puVar3;\n    int32_t unaff_EBP;\n    uint var_4h;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint in_stack_00000020;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint in_stack_0000002c;\n    uint in_stack_00000030;\n    uint in_stack_00000034;\n    uint in_stack_00000038;\n    uint in_stack_0000003c;\n    uint in_stack_00000040;\n    uint in_stack_00000044;\n    uint in_stack_00000048;\n    uint in_stack_0000004c;\n    uint in_stack_00000050;\n    uint in_stack_00000054;\n    uint var_34h_2;\n    uint var_34h;\n    uint var_28h;\n    uint var_20h_2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_4h_2;\n    uint noname_8;\n    \n    noname_8 = 0x18;\n    noname_4 = &fcn.00404880::var_4h_2;\n    var_4h_2 = 0x4162a0;\n    fcn.00407c04();\n    *(unaff_EBP + -0x20) = 0;\n    iVar2 = fcn.00406941();\n    iVar2 = *(iVar2 + 100);\n    *(unaff_EBP + -0x1c) = iVar2;\n    if (iVar2 != *0x41addc) {\n        iVar2 = fcn.004073eb();\n        *(unaff_EBP + -0x1c) = iVar2;\n    }\n    if (*(iVar2 + 0x14) == 0) {\n        puVar3 = *(unaff_EBP + 8);\n        uVar1 = *puVar3;\n        while (uVar1 != 0) {\n            uVar1 = *puVar3;\n            if ((0x40 < uVar1) && (uVar1 < 0x5b)) {\n                *puVar3 = uVar1 + 0x20;\n            }\n            puVar3 = puVar3 + 1;\n            uVar1 = *puVar3;\n        }\n        goto code_r0x00404996;\n    }\n    noname_5 = fcn.00406ea4(*(iVar2 + 0x14), 0x100, *(unaff_EBP + 8), 0xffffffff, 0, 0, *(iVar2 + 4), var_4h_2, noname_8\n                            , var_4h, arg_8h_2, noname_1, arg_8h, in_stack_00000010, in_stack_00000014, \n                            in_stack_00000018, in_stack_0000001c, in_stack_00000020, in_stack_00000024, \n                            in_stack_00000028, in_stack_0000002c, in_stack_00000030, in_stack_00000034, \n                            in_stack_00000038, in_stack_0000003c, in_stack_00000040, in_stack_00000044, \n                            in_stack_00000048, in_stack_0000004c, in_stack_00000050, in_stack_00000054);\n    *(unaff_EBP + -0x24) = noname_5;\n    if (noname_5 == 0) goto code_r0x00404996;\n    *(unaff_EBP + -4) = 0;\n    fcn.00407d60();\n    *(unaff_EBP + -0x18) = &fcn.00404880::var_4h_2;\n    *(unaff_EBP + -0x28) = &fcn.00404880::var_4h_2;\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*0x10 == 0x8) {\n        noname_4 = fcn.00405bcb(noname_5 * 2);\n        *(unaff_EBP + -0x20) = 1;\n        if (noname_4 != NULL) goto code_r0x0040495d;\n    }\n    else {\ncode_r0x0040495d:\n        iVar2 = fcn.00406ea4(*(iVar2 + 0x14), 0x100, *(unaff_EBP + 8), 0xffffffff, noname_4, noname_5, *(iVar2 + 4), \n                             var_4h_2, noname_8, var_4h, arg_8h_2, noname_1, arg_8h, in_stack_00000010, \n                             in_stack_00000014, in_stack_00000018, in_stack_0000001c, in_stack_00000020, \n                             in_stack_00000024, in_stack_00000028, in_stack_0000002c, in_stack_00000030, \n                             in_stack_00000034, in_stack_00000038, in_stack_0000003c, in_stack_00000040, \n                             in_stack_00000044, in_stack_00000048, in_stack_0000004c, in_stack_00000050, \n                             in_stack_00000054);\n        if (iVar2 != 0) {\n            fcn.00406d87(*(unaff_EBP + 8), noname_4);\n        }\n    }\n    if (*(unaff_EBP + -0x20) != 0) {\n        fcn.00406cec(noname_4);\n    }\ncode_r0x00404996:\n    *(unaff_EBP + -0x38) = 0x40499e;\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 1534
    },
    "00404d6d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00404d6d(uint *arg_8h, uint8_t *arg_ch, uint32_t arg_10h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    uint *puVar7;\n    \n    iVar3 = fcn.00406941();\n    iVar3 = *(iVar3 + 0x60);\n    if (iVar3 != *0x41c1b8) {\n        iVar3 = fcn.004080ee();\n    }\n    if (*(iVar3 + 8) == 0) {\n        arg_8h = fcn.00407da0(arg_8h, arg_ch, arg_10h);\n    }\n    else {\n        puVar6 = arg_8h;\n        if (arg_10h != 0) {\n            do {\n                uVar1 = *arg_ch;\n                uVar4 = arg_10h - 1;\n                uVar2 = *(uVar1 + 0x1d + iVar3);\n                *puVar6 = uVar1;\n                if ((uVar2 & 4) == 0) {\n                    puVar7 = puVar6 + 1;\n                    arg_ch = arg_ch + 1;\n                    if (uVar1 == 0) {\ncode_r0x00404dd2:\n                        if (uVar4 == 0) {\n                            return arg_8h;\n                        }\n                        for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n                            *puVar7 = 0;\n                            puVar7 = puVar7 + 1;\n                        }\n                        for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n                            *puVar7 = 0;\n                            puVar7 = puVar7 + 1;\n                        }\n                        return arg_8h;\n                    }\n                }\n                else {\n                    if (uVar4 == 0) {\n                        *puVar6 = 0;\n                        return arg_8h;\n                    }\n                    uVar1 = arg_ch[1];\n                    uVar4 = arg_10h - 2;\n                    *(puVar6 + 1) = uVar1;\n                    puVar7 = puVar6 + 2;\n                    arg_ch = arg_ch + 2;\n                    if (uVar1 == 0) {\n                        *puVar6 = 0;\n                        goto code_r0x00404dd2;\n                    }\n                }\n                arg_10h = uVar4;\n                puVar6 = puVar7;\n            } while (uVar4 != 0);\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 632
    },
    "00404e00": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.00404e00(uint8_t *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    \n    iVar1 = fcn.00406941();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x41addc) {\n        iVar1 = fcn.004073eb();\n    }\n    while( true ) {\n        if (*(iVar1 + 0x28) < 2) {\n            uVar2 = *(*(iVar1 + 0x48) + *param_1 * 2) & 8;\n        }\n        else {\n            uVar2 = fcn.0040846b(iVar1, *param_1, 8);\n        }\n        if (uVar2 == 0) break;\n        param_1 = param_1 + 1;\n    }\n    uVar2 = *param_1;\n    puVar5 = param_1 + 1;\n    if ((uVar2 == 0x2d) || (uVar3 = uVar2,  uVar2 == 0x2b)) {\n        uVar3 = *puVar5;\n        puVar5 = param_1 + 2;\n    }\n    iVar1 = 0;\n    while( true ) {\n        if ((uVar3 < 0x30) || (0x39 < uVar3)) {\n            iVar4 = -1;\n        }\n        else {\n            iVar4 = uVar3 - 0x30;\n        }\n        if (iVar4 == -1) break;\n        iVar1 = iVar4 + iVar1 * 10;\n        uVar3 = *puVar5;\n        puVar5 = puVar5 + 1;\n    }\n    if (uVar2 == 0x2d) {\n        iVar1 = -iVar1;\n    }\n    return iVar1;\n}\n",
        "token_count": 438
    },
    "00405038": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint8_t * fcn.00405038(uint32_t *param_1)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint32_t *puVar4;\n    uint32_t *puVar5;\n    uint8_t *puVar6;\n    \n    iVar3 = fcn.00406941();\n    iVar3 = *(iVar3 + 0x60);\n    if (iVar3 != *0x41c1b8) {\n        iVar3 = fcn.004080ee();\n    }\n    if (*(iVar3 + 8) != 0) {\n        puVar6 = NULL;\n        for (; (*param_1 != 0 && (((*(*param_1 + 0x1d + iVar3) & 4) == 0 || (param_1 = param_1 + 1,  *param_1 != 0))));\n            param_1 = param_1 + 1) {\n            puVar6 = puVar6 + 1;\n        }\n        return puVar6;\n    }\n    uVar2 = param_1 & 3;\n    puVar4 = param_1;\n    while (uVar2 != 0) {\n        uVar1 = *puVar4;\n        puVar4 = puVar4 + 1;\n        if (uVar1 == 0) goto code_r0x00404a03;\n        uVar2 = puVar4 & 3;\n    }\n    do {\n        do {\n            puVar5 = puVar4;\n            puVar4 = puVar5 + 1;\n        } while (((*puVar5 ^ 0xffffffff ^ *puVar5 + 0x7efefeff) & 0x81010100) == 0);\n        uVar2 = *puVar5;\n        if (uVar2 == '\\0') {\n            return puVar5 - param_1;\n        }\n        if (uVar2 >> 8 == '\\0') {\n            return puVar5 + (1 - param_1);\n        }\n        if ((uVar2 & 0xff0000) == 0) {\n            return puVar5 + (2 - param_1);\n        }\n    } while ((uVar2 & 0xff000000) != 0);\ncode_r0x00404a03:\n    return puVar4 + (-1 - param_1);\n}\n",
        "token_count": 525
    },
    "0040507d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040507d(char *param_1, uint32_t param_2, int32_t param_3)\n\n{\n    uint64_t uVar1;\n    char *pcVar2;\n    uint32_t in_EAX;\n    char *pcVar3;\n    char cVar4;\n    \n    pcVar2 = param_1;\n    if (param_3 != 0) {\n        *param_1 = '-';\n        param_1 = param_1 + 1;\n        in_EAX = -in_EAX;\n        pcVar2 = param_1;\n    }\n    do {\n        pcVar3 = pcVar2;\n        uVar1 = in_EAX;\n        in_EAX = in_EAX / param_2;\n        cVar4 = uVar1 % param_2;\n        if (uVar1 % param_2 < 10) {\n            cVar4 = cVar4 + '0';\n        }\n        else {\n            cVar4 = cVar4 + 'W';\n        }\n        *pcVar3 = cVar4;\n        pcVar2 = pcVar3 + 1;\n    } while (in_EAX != 0);\n    pcVar3[1] = '\\0';\n    do {\n        cVar4 = *pcVar3;\n        *pcVar3 = *param_1;\n        pcVar3 = pcVar3 + -1;\n        *param_1 = cVar4;\n        param_1 = param_1 + 1;\n    } while (param_1 < pcVar3);\n    return;\n}\n",
        "token_count": 341
    },
    "00406cec": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00406cec(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    int32_t arg_ch;\n    uint var_4h;\n    \n    fcn.00407c04(0x416440, 0xc);\n    arg_ch = *(unaff_EBP + 8);\n    if (arg_ch != 0) {\n        if (*0x41bfc4 == 3) {\n            fcn.0040953e(4);\n            *(unaff_EBP + -4) = 0;\n            arg_8h_00 = fcn.00409655(arg_ch);\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 != 0) {\n                fcn.00409680(arg_8h_00, arg_ch);\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00406d3f();\n            if (*(unaff_EBP + -0x1c) != 0) goto code_r0x00406d57;\n            arg_ch = *(unaff_EBP + 8);\n        }\n        (*_sym.imp.KERNEL32.dll_HeapFree)(*0x41bfb4, 0, arg_ch);\n    }\ncode_r0x00406d57:\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 345
    },
    "null": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid entry0(uint32_t param_1, int32_t param_2)\n\n{\n    code *pcVar1;\n    int16_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint arg_8h;\n    int32_t *piVar5;\n    int32_t unaff_EBP;\n    int32_t unaff_retaddr;\n    uint var_7ch;\n    uint lpStartupInfo;\n    uint var_44h;\n    uint var_40h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_4h;\n    int32_t iStack4;\n    \n    iStack4 = 0x60;\n    var_4h = 0x4162d0;\n    fcn.00407c04();\n    fcn.00407d60();\n    *(unaff_EBP + -0x18) = &entry0::var_4h;\n    var_4h = 0x94;\n    iVar3 = unaff_retaddr;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&entry0::var_4h);\n    *0x41bae4 = iVar3;\n    pcVar1 = _sym.imp.KERNEL32.dll_GetModuleHandleA;\n    *0x41bad4 = param_2;\n    *0x41bae0 = iStack4;\n    *0x41bad8 = param_1 & 0x7fff;\n    if (param_2 != 2) {\n        *0x41bad8 = *0x41bad8 | 0x8000;\n    }\n    *0x41badc = iStack4 * 0x100 + *0x41bae4;\n    piVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(0);\n    if ((*piVar2 == 0x5a4d) && (piVar5 = *(piVar2 + 0x1e) + piVar2,  *piVar5 == 0x4550)) {\n        if (*(piVar5 + 6) == 0x10b) {\n            if (0xe < piVar5[0x1d]) {\n                iVar3 = piVar5[0x3a];\n                goto code_r0x00405727;\n            }\n        }\n        else if ((*(piVar5 + 6) == 0x20b) && (0xe < piVar5[0x21])) {\n            iVar3 = piVar5[0x3e];\ncode_r0x00405727:\n            *(unaff_EBP + -0x1c) = iVar3 != 0;\n            goto code_r0x0040572d;\n        }\n    }\n    *(unaff_EBP + -0x1c) = 0;\ncode_r0x0040572d:\n    iVar3 = fcn.004092fd(1);\n    if (iVar3 == 0) {\n        fcn.004055ec(0x1c);\n    }\n    iVar3 = fcn.00406b34();\n    if (iVar3 == 0) {\n        fcn.004055ec(0x10);\n    }\n    fcn.0040925b();\n    *(unaff_EBP + -4) = 0;\n    iVar3 = fcn.00409011();\n    if (iVar3 < 0) {\n        fcn.004055c7(0x1b);\n    }\n    *0x41c3f4 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n    *0x41ba98 = fcn.00408eef();\n    iVar3 = fcn.00408e4d();\n    if (iVar3 < 0) {\n        fcn.004055c7(8);\n    }\n    iVar3 = fcn.00408c1a();\n    if (iVar3 < 0) {\n        fcn.004055c7(9);\n    }\n    iVar3 = fcn.004086cb(1);\n    *(unaff_EBP + -0x28) = iVar3;\n    if (iVar3 != 0) {\n        fcn.004055c7(iVar3);\n    }\n    *(unaff_EBP + -0x44) = 0;\n    (*_sym.imp.KERNEL32.dll_GetStartupInfoA)(unaff_EBP + -0x70);\n    uVar4 = fcn.00408bbd();\n    *(unaff_EBP + -0x20) = uVar4;\n    uVar4 = *(unaff_EBP + -0x20);\n    arg_8h = (*pcVar1)();\n    uVar4 = fcn.004010a5(arg_8h, 0, 0, uVar4);\n    *(unaff_EBP + -0x2c) = uVar4;\n    if (*(unaff_EBP + -0x1c) == 0) {\n        fcn.004087f8(uVar4);\n    }\n    fcn.0040881a();\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(unaff_EBP + -0x80) = 0x40583a;\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 1250
    },
    "00405b24": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00405b24(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint32_t arg_8h_00;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00407c04(0x416338, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if ((*0x41bfc4 == 3) && (arg_8h_00 <= *0x41bfa4)) {\n        fcn.0040953e(4);\n        *(unaff_EBP + -4) = 0;\n        uVar1 = fcn.0040a279(arg_8h_00);\n        *(unaff_EBP + -0x1c) = uVar1;\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00405b96();\n        if (*(unaff_EBP + -0x1c) != 0) goto code_r0x00405b8d;\n    }\n    if (arg_8h_00 == 0) {\n        arg_8h_00 = 1;\n    }\n    if (*0x41bfc4 != 1) {\n        arg_8h_00 = arg_8h_00 + 0xf & 0xfffffff0;\n    }\n    (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x41bfb4, 0, arg_8h_00);\ncode_r0x00405b8d:\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 380
    },
    "00405d14": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00405d14(uint32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint8_t *unaff_ESI;\n    uint8_t *unaff_EDI;\n    \n    iVar1 = *(unaff_ESI + 4);\n    if ((iVar1 != 0) && (*(iVar1 + 8) != '\\0')) {\n        if ((iVar1 != *(unaff_EDI + 4)) && (iVar1 = fcn.00409570(iVar1 + 8, *(unaff_EDI + 4) + 8),  iVar1 != 0)) {\n            return 0;\n        }\n        if (((((*unaff_EDI & 2) != 0) && ((*unaff_ESI & 8) == 0)) || (((*param_1 & 1) != 0 && ((*unaff_ESI & 1) == 0))))\n           || (((*param_1 & 2) != 0 && ((*unaff_ESI & 2) == 0)))) {\n            return 0;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 243
    },
    "00405d81": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00405d81(uint arg_8h, uint noname_1, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00407c04(0x416358, 0x10);\n    iVar1 = *(unaff_EBP + 8);\n    iVar5 = *(iVar1 + 8);\n    *(unaff_EBP + -0x1c) = iVar5;\n    iVar2 = fcn.00406941();\n    *(iVar2 + 0x84) = *(iVar2 + 0x84) + 1;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = *(unaff_EBP + 0x10);\n    while (iVar5 != *(unaff_EBP + 0x14)) {\n        if ((iVar5 < 0) || (*(iVar2 + 4) <= iVar5)) {\n            fcn.00406c70();\n        }\n        iVar3 = iVar5 * 8;\n        piVar4 = *(iVar2 + 8) + iVar3;\n        iVar5 = *piVar4;\n        *(unaff_EBP + -0x20) = iVar5;\n        *(unaff_EBP + -4) = 1;\n        if (piVar4[1] != 0) {\n            *(iVar1 + 8) = iVar5;\n            fcn.00406ca0(*(*(iVar2 + 8) + 4 + iVar3), iVar1, 0x103);\n        }\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x1c) = iVar5;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00405e34();\n    if (iVar5 != *(unaff_EBP + 0x14)) {\n        fcn.00406c70();\n    }\n    *(iVar1 + 8) = iVar5;\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 531
    },
    "00405e34": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00405e34(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00406941();\n    if (0 < *(iVar1 + 0x84)) {\n        iVar1 = fcn.00406941();\n        *(iVar1 + 0x84) = *(iVar1 + 0x84) + -1;\n    }\n    return;\n}\n",
        "token_count": 87
    },
    "00405ec4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00405ec4(int32_t *param_1)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    \n    iVar1 = *param_1 + in_EAX;\n    if (-1 < param_1[1]) {\n        iVar1 = iVar1 + *(*(param_1[1] + in_EAX) + param_1[2]) + param_1[1];\n    }\n    return iVar1;\n}\n",
        "token_count": 105
    },
    "0040622d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid fcn.0040622d(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_20h;\n    \n    *(unaff_EDI + -4) = *(unaff_EBP + -0x38);\n    fcn.004046d6(*(unaff_EBP + -0x3c));\n    iVar1 = fcn.00406941();\n    *(iVar1 + 0x7c) = *(unaff_EBP + -0x40);\n    iVar1 = fcn.00406941();\n    *(iVar1 + 0x80) = *(unaff_EBP + -0x44);\n    if ((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&\n        ((unaff_ESI[5] == 0x19930520 || (unaff_ESI[5] == 0x19930521)))) &&\n       ((*(unaff_EBP + -0x48) == 0 && (*(unaff_EBP + -0x20) != 0)))) {\n        iVar1 = fcn.004046b5(unaff_ESI[6]);\n        if (iVar1 != 0) {\n            fcn.00404826();\n            fcn.00405e7f(unaff_ESI);\n        }\n    }\n    return;\n}\n",
        "token_count": 357
    },
    "0040629c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040629c(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint arg_ch_00;\n    uint uVar5;\n    uint8_t *extraout_ECX;\n    int32_t *extraout_EDX;\n    int32_t unaff_EBP;\n    int32_t *arg_8h_00;\n    uint var_4h;\n    \n    fcn.00407c04(0x4163b8, 8);\n    puVar1 = *(unaff_EBP + 0xc);\n    iVar4 = *(unaff_EBP + 8);\n    if (((puVar1[1] == 0) || (*(puVar1[1] + 8) == '\\0')) || ((puVar1[2] == 0 && ((*(puVar1 + 3) & 0x80) == 0))))\n    goto code_r0x00406406;\n    uVar2 = *puVar1;\n    arg_8h_00 = extraout_EDX;\n    if (-1 < uVar2) {\n        arg_8h_00 = puVar1[2] + 0xc + extraout_EDX;\n    }\n    *(unaff_EBP + -4) = 0;\n    uVar5 = *(iVar4 + 0x18);\n    if ((uVar2 & 8) == 0) {\n        if ((*extraout_ECX & 1) == 0) {\n            if (*(extraout_ECX + 0x18) == 0) {\n                iVar4 = fcn.0040a798(uVar5, 1);\n                if ((iVar4 == 0) || (iVar4 = fcn.0040a7b4(arg_8h_00, 1),  iVar4 == 0)) {\ncode_r0x004063fd:\n                    fcn.00406c70();\n                }\n                else {\n                    uVar5 = *(extraout_ECX + 0x14);\n                    arg_ch_00 = fcn.00405ec4();\n                    fcn.00405250(arg_8h_00, arg_ch_00, uVar5);\n                }\n            }\n            else {\n                iVar4 = fcn.0040a798(uVar5, 1);\n                if (((iVar4 == 0) || (iVar4 = fcn.0040a7b4(arg_8h_00, 1),  iVar4 == 0)) ||\n                   (iVar4 = fcn.0040a7d0(*(extraout_ECX + 0x18)),  iVar4 == 0)) goto code_r0x004063fd;\n                if ((*extraout_ECX & 4) == 0) {\n                    uVar5 = fcn.00405ec4();\n                    fcn.004043af(arg_8h_00, *(extraout_ECX + 0x18), uVar5);\n                }\n                else {\n                    uVar5 = fcn.00405ec4(1);\n                    fcn.004043b6(arg_8h_00, *(extraout_ECX + 0x18), uVar5);\n                }\n            }\n        }\n        else {\n            iVar3 = fcn.0040a798(uVar5, 1);\n            if ((iVar3 == 0) || (iVar3 = fcn.0040a7b4(arg_8h_00, 1),  iVar3 == 0)) goto code_r0x004063fd;\n            fcn.00405250(arg_8h_00, *(iVar4 + 0x18), *(extraout_ECX + 0x14));\n            if ((*(extraout_ECX + 0x14) == 4) && (*arg_8h_00 != 0)) goto code_r0x00406315;\n        }\n    }\n    else {\n        iVar3 = fcn.0040a798(uVar5, 1);\n        if ((iVar3 == 0) || (iVar3 = fcn.0040a7b4(arg_8h_00, 1),  iVar3 == 0)) goto code_r0x004063fd;\n        *arg_8h_00 = *(iVar4 + 0x18);\ncode_r0x00406315:\n        iVar4 = fcn.00405ec4();\n        *arg_8h_00 = iVar4;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\ncode_r0x00406406:\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 1045
    },
    "00406418": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00406418(int32_t **arg_8h, int32_t arg_ch, uint32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t *arg_8h_00;\n    uint32_t var_14h;\n    int32_t var_10h;\n    int32_t var_4h;\n    \n    if (arg_8h == NULL) {\n        return 0;\n    }\n    arg_8h_00 = *arg_8h;\n    if ((arg_ch == 0) || (*(arg_ch + 8) == '\\0')) {\n        if ((((*arg_8h_00 != -0x1f928c9d) || (arg_8h_00[4] != 3)) ||\n            (((arg_8h_00[5] != 0x19930520 && (arg_8h_00[5] != 0x19930521)) || (arg_8h_00[7] != 0)))) ||\n           (iVar1 = fcn.00406941(),  *(iVar1 + 0x7c) != 0)) {\n            iVar1 = fcn.00406941();\n            *(iVar1 + 0x84) = *(iVar1 + 0x84) + 1;\n            return 1;\n        }\n    }\n    else if (((*arg_8h_00 == -0x1f928c9d) && (arg_8h_00[4] == 3)) &&\n            ((arg_8h_00[5] == 0x19930520 || (arg_8h_00[5] == 0x19930521)))) {\n        if (arg_8h_00[7] == 0) {\n            iVar1 = fcn.00406941();\n            if (*(iVar1 + 0x7c) == 0) {\n                return 0;\n            }\n            iVar1 = fcn.00406941();\n            arg_8h_00 = *(iVar1 + 0x7c);\n        }\n        var_14h = arg_10h | 0x80000000;\n        var_10h = arg_ch;\n        for (var_4h = **(arg_8h_00[7] + 0xc); 0 < var_4h; var_4h = var_4h + -1) {\n            iVar1 = fcn.00405d14(arg_8h_00[7]);\n            if (iVar1 != 0) {\n                iVar1 = fcn.00406941();\n                *(iVar1 + 0x84) = *(iVar1 + 0x84) + 1;\n                if (arg_14h == 0) {\n                    return 1;\n                }\n                fcn.0040629c(arg_8h_00, &var_14h);\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 659
    },
    "0040653d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040653d(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, int32_t arg_1ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint unaff_EBX;\n    int32_t unaff_ESI;\n    uint *unaff_EDI;\n    \n    if (in_ECX != 0) {\n        fcn.0040629c(arg_8h, unaff_EBX);\n    }\n    if (arg_1ch == 0) {\n        arg_1ch = unaff_ESI;\n    }\n    fcn.004043bd(arg_1ch, arg_8h);\n    fcn.00405d81(unaff_ESI, arg_10h, arg_14h, *unaff_EDI);\n    *(unaff_ESI + 8) = unaff_EDI[1] + 1;\n    iVar1 = fcn.004060d8(arg_8h, unaff_ESI, arg_ch, arg_14h, arg_18h, 0x100);\n    if (iVar1 != 0) {\n        fcn.00404378(iVar1);\n    }\n    return;\n}\n",
        "token_count": 278
    },
    "004065a4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl\nfcn.004065a4(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, int32_t arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_retaddr;\n    uint in_stack_00000024;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    if ((*arg_8h != -0x7ffffffd) &&\n       (((iVar1 = fcn.00406941(),  *(iVar1 + 0x74) == 0 ||\n         (iVar1 = fcn.0040449a(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_20h, arg_24h, unaff_ESI, var_8h, var_4h, \n                               unaff_EBP, unaff_retaddr, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, arg_20h, \n                               arg_24h, in_stack_00000024),  iVar1 == 0)) &&\n        (piVar2 = fcn.00404613(arg_18h, arg_20h, arg_1ch, &var_4h, &var_8h),  var_4h < var_8h)))) {\n        do {\n            if (((*piVar2 <= arg_1ch) && (arg_1ch <= piVar2[1])) &&\n               ((iVar1 = *(piVar2[3] * 0x10 + piVar2[4] + -0xc),  iVar1 == 0 || (*(iVar1 + 8) == '\\0')))) {\n                fcn.0040653d(arg_8h, arg_10h, arg_14h, arg_18h, arg_20h, arg_24h);\n            }\n            var_4h = var_4h + 1;\n            piVar2 = piVar2 + 5;\n        } while (var_4h < var_8h);\n    }\n    return;\n}\n",
        "token_count": 547
    },
    "00406662": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.00406662(int32_t *arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h, int32_t arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint var_24h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t *var_10h;\n    uint32_t var_ch;\n    int32_t *var_8h;\n    uchar auStack8 [3];\n    uint var_1h;\n    \n    var_1ch = *(arg_ch + 8);\n    _auStack8 = auStack8;\n    if ((var_1ch < -1) || (*(arg_18h + 4) <= var_1ch)) {\n        fcn.00406c70();\n    }\n    if (*arg_8h == -0x1f928c9d) {\n        if ((arg_8h[4] == 3) && (((arg_8h[5] == 0x19930520 || (arg_8h[5] == 0x19930521)) && (arg_8h[7] == 0)))) {\n            iVar2 = fcn.00406941();\n            if (*(iVar2 + 0x7c) == 0) {\n                return;\n            }\n            iVar2 = fcn.00406941();\n            arg_8h = *(iVar2 + 0x7c);\n            iVar2 = fcn.00406941();\n            arg_10h = *(iVar2 + 0x80);\n            _auStack8 = CONCAT13(1, auStack8);\n            iVar2 = fcn.0040a798(arg_8h, 1);\n            if (iVar2 == 0) {\n                fcn.00406c70();\n            }\n            if (*arg_8h != -0x1f928c9d) goto code_r0x0040683b;\n            if (((arg_8h[4] == 3) && ((arg_8h[5] == 0x19930520 || (arg_8h[5] == 0x19930521)))) && (arg_8h[7] == 0)) {\n                fcn.00406c70();\n            }\n        }\n        iVar2 = var_1ch;\n        if (((*arg_8h == -0x1f928c9d) && (arg_8h[4] == 3)) && ((arg_8h[5] == 0x19930520 || (arg_8h[5] == 0x19930521))))\n        {\n            piVar3 = fcn.00404613(arg_18h, arg_20h, var_1ch, &var_ch, &var_20h);\n            var_8h = piVar3;\n            if (var_ch < var_20h) {\n                do {\n                    if ((*piVar3 == iVar2 || *piVar3 < iVar2) && (iVar2 <= piVar3[1])) {\n                        var_8h = piVar3;\n                        for (var_18h = piVar3[3]; 0 < var_18h; var_18h = var_18h + -1) {\n                            var_10h = *(arg_8h[7] + 0xc);\n                            for (var_14h = *var_10h; var_10h = var_10h + 1,  0 < var_14h; var_14h = var_14h + -1) {\n                                iVar2 = fcn.00405d14(arg_8h[7]);\n                                piVar3 = var_8h;\n                                if (iVar2 != 0) {\n                                    fcn.0040653d(arg_8h, arg_10h, arg_14h, arg_18h, arg_20h, arg_24h);\n                                    goto code_r0x0040680e;\n                                }\n                            }\n                        }\n                    }\ncode_r0x0040680e:\n                    var_ch = var_ch + 1;\n                    piVar3 = piVar3 + 5;\n                    iVar2 = var_1ch;\n                    var_8h = piVar3;\n                } while (var_ch < var_20h);\n            }\n            if (arg_1ch == '\\0') {\n                return;\n            }\n            fcn.00405e7f(arg_8h);\n            return;\n        }\n    }\ncode_r0x0040683b:\n    if (arg_1ch == '\\0') {\n        fcn.004065a4(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, var_1ch, arg_20h, arg_24h);\n        return;\n    }\n    fcn.00407c04(0x416420, 8);\n    iVar2 = fcn.00406941();\n    if (*(iVar2 + 0x6c) != 0) {\n        _auStack8 = 0;\n        iVar2 = fcn.00406941();\n        (**(iVar2 + 0x6c))();\n        _auStack8 = 0xffffffff;\n    }\n    fcn.00408838(10);\n    fcn.0040dc4a(0x16);\n    fcn.00408809(3);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 1281
    },
    "00406866": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.00406866(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint32_t *arg_18h, int32_t arg_1ch, uint arg_20h\n            , uint32_t arg_24h)\n\n{\n    uint uVar1;\n    \n    if ((*arg_18h & 0x1fffffff) != 0x19930520) {\n        fcn.00406c70();\n    }\n    if ((*(arg_8h + 1) & 0x66) == 0) {\n        if (arg_18h[3] != 0) {\n            if (((*arg_8h == -0x1f928c9d) && (0x19930520 < arg_8h[5])) && (*(arg_8h[7] + 8) != NULL)) {\n                uVar1 = (**(arg_8h[7] + 8))(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, arg_20h, arg_24h & 0xff)\n                ;\n                return uVar1;\n            }\n            fcn.00406662(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_24h, arg_1ch, arg_20h);\n        }\n    }\n    else if ((arg_18h[1] != 0) && (arg_1ch == 0)) {\n        fcn.00405d81(arg_ch, arg_14h, arg_18h, 0xffffffff);\n    }\n    return 1;\n}\n",
        "token_count": 377
    },
    "00406911": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00406911(void)\n\n{\n    int32_t arg_8h;\n    code *pcVar1;\n    int32_t *piVar2;\n    \n    if (*0x41ad70 != -1) {\n        (**0x41bab4)(*0x41ad70);\n        *0x41ad70 = -1;\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_DeleteCriticalSection;\n    piVar2 = 0x41b1a8;\n    do {\n        arg_8h = *piVar2;\n        if ((arg_8h != 0) && (piVar2[1] != 1)) {\n            (*pcVar1)(arg_8h);\n            fcn.00406cec(arg_8h);\n            *piVar2 = 0;\n        }\n        piVar2 = piVar2 + 2;\n    } while (piVar2 < 0x41b2c8);\n    piVar2 = 0x41b1a8;\n    do {\n        if ((*piVar2 != 0) && (piVar2[1] == 1)) {\n            (*pcVar1)(*piVar2);\n        }\n        piVar2 = piVar2 + 2;\n    } while (piVar2 < 0x41b2c8);\n    return;\n}\n",
        "token_count": 292
    },
    "00406b34": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00406b34(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint uVar4;\n    \n    iVar2 = fcn.004093d3();\n    if (iVar2 == 0) {\n        fcn.00406911();\n        return 0;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"kernel32.dll\");\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar2 != 0) {\n        *0x41baa8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"FlsAlloc\");\n        *0x41baac = (*pcVar1)(iVar2, \"FlsGetValue\");\n        *0x41bab0 = (*pcVar1)(iVar2, \"FlsSetValue\");\n        *0x41bab4 = (*pcVar1)(iVar2, \"FlsFree\");\n        if (*0x41baac == 0) {\n            *0x41baac = _sym.imp.KERNEL32.dll_TlsGetValue;\n            *0x41bab0 = _sym.imp.KERNEL32.dll_TlsSetValue;\n            *0x41baa8 = 0x406908;\n            *0x41bab4 = _sym.imp.KERNEL32.dll_TlsFree;\n        }\n    }\n    *0x41ad70 = (**0x41baa8)(fcn.004069b2);\n    if (((*0x41ad70 != -1) && (puVar3 = fcn.0040a7e8(1, 0x8c),  puVar3 != NULL)) &&\n       (iVar2 = (**0x41bab0)(*0x41ad70, puVar3),  iVar2 != 0)) {\n        puVar3[0x15] = 0x41b0f8;\n        puVar3[5] = 1;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        puVar3[1] = 0xffffffff;\n        *puVar3 = uVar4;\n        return 1;\n    }\n    fcn.00406911();\n    return 0;\n}\n",
        "token_count": 491
    },
    "00406da3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_58h\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00406da3(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint var_58h;\n    uint lpSystemInfo;\n    int32_t var_48h;\n    uint32_t lpBuffer;\n    int32_t var_24h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    uint var_13h;\n    uint lpflOldProtect;\n    int32_t dwSize;\n    uint32_t lpAddress;\n    \n    fcn.00407d60();\n    iVar1 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(&var_58h, &lpBuffer, 0x1c);\n    if (iVar1 != 0) {\n        (*_sym.imp.KERNEL32.dll_GetSystemInfo)(&lpSystemInfo);\n        uVar4 = (~(var_48h - 1U) & &var_58h) - var_48h;\n        uVar3 = ((-(*0x41bad4 != 1) & 0xfffffff1) + 0x11) * var_48h + var_24h;\n        dwSize = var_48h;\n        if (uVar3 <= uVar4) {\n            lpAddress = uVar4;\n            if (*0x41bad4 != 1) {\n                lpAddress = var_24h;\n                do {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(lpAddress, &lpBuffer, 0x1c);\n                    if (iVar1 == 0) {\n                        return 0;\n                    }\n                    lpAddress = lpAddress + var_1ch;\n                } while ((var_18h & 0x1000) == 0);\n                lpAddress = lpBuffer;\n                if ((var_13h & 1) != 0) {\n                    return 1;\n                }\n                if (uVar4 < lpBuffer) {\n                    return 0;\n                }\n                if (lpBuffer < uVar3) {\n                    lpAddress = uVar3;\n                }\n                (*_sym.imp.KERNEL32.dll_VirtualAlloc)(lpAddress, dwSize, 0x1000, 4);\n            }\n            uVar2 = (*_sym.imp.KERNEL32.dll_VirtualProtect)\n                              (lpAddress, dwSize, (-(*0x41bad4 != 1) & 0x103) + 1, &lpflOldProtect);\n            return uVar2;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 588
    },
    "00406ea4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_40h\n\nvoid __cdecl\nfcn.00406ea4(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint noname_22, uint noname_23, uint arg_8h, uint noname_25, \n            uint lpWideCharStr, uint arg_14h, uint noname_28, uint noname_29, uint CodePage)\n\n{\n    int32_t iVar1;\n    int16_t *piVar2;\n    uchar *arg_8h_00;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint var_34h;\n    uint Locale;\n    uint dwMapFlags;\n    uint lpSrcStr;\n    uint cchSrc;\n    uint lpDestStr;\n    uint cchDest;\n    uint var_18h_2;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_20h_3;\n    uint var_4h;\n    uint uVar4;\n    uint uVar5;\n    uint uStack72;\n    uint uStack68;\n    uint uStack64;\n    uint uStack60;\n    uint var_34h_2;\n    uint uStack52;\n    uint var_2ch_3;\n    uint var_28h_3;\n    uint var_24h_3;\n    uint var_20h_4;\n    uint var_1ch_2;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint var_40h;\n    uint var_4h_2;\n    uint uStack4;\n    \n    uStack4 = 0x24;\n    var_4h_2 = 0x416450;\n    var_40h = 0x406eb0;\n    fcn.00407c04();\n    if (*0x41bab8 == 0) {\n        var_40h = 0;\n        uStack16 = 0;\n        uStack20 = 1;\n        uStack24 = 0x41644c;\n        uStack28 = 0x100;\n        var_1ch_2 = 0;\n        var_20h_4 = 0x406ed1;\n        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringW)();\n        if (iVar1 == 0) {\n            var_40h = 0x406ee3;\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x41bab8 = 2;\n            }\n        }\n        else {\n            *0x41bab8 = 1;\n        }\n    }\n    if (0 < *(unaff_EBP + 0x14)) {\n        iVar1 = *(unaff_EBP + 0x14);\n        piVar2 = *(unaff_EBP + 0x10);\n        do {\n            iVar1 = iVar1 + -1;\n            if (*piVar2 == 0) goto code_r0x00406f0c;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 != 0);\n        iVar1 = -1;\ncode_r0x00406f0c:\n        *(unaff_EBP + 0x14) = *(unaff_EBP + 0x14) + (-1 - iVar1);\n    }\n    if (*0x41bab8 == 1) {\n        var_40h = *(unaff_EBP + 0x1c);\n        uStack16 = *(unaff_EBP + 0x18);\n        uStack20 = *(unaff_EBP + 0x14);\n        uStack24 = *(unaff_EBP + 0x10);\n        uStack28 = *(unaff_EBP + 0xc);\n        var_1ch_2 = *(unaff_EBP + 8);\n        var_20h_4 = 0x406f35;\n        (*_sym.imp.KERNEL32.dll_LCMapStringW)();\n        goto code_r0x004070f4;\n    }\n    if ((*0x41bab8 != 2) && (*0x41bab8 != 0)) goto code_r0x004070f4;\n    *(unaff_EBP + -0x24) = 0;\n    *(unaff_EBP + -0x2c) = 0;\n    *(unaff_EBP + -0x28) = 0;\n    if (*(unaff_EBP + 8) == 0) {\n        *(unaff_EBP + 8) = *0x41bd8c;\n    }\n    if (*(unaff_EBP + 0x20) == 0) {\n        *(unaff_EBP + 0x20) = *0x41bd9c;\n    }\n    var_40h = *(unaff_EBP + 8);\n    uStack16 = 0x406f6e;\n    iVar1 = fcn.0040a8bb(var_40h);\n    if ((*(unaff_EBP + 0x20) != iVar1) && (iVar1 != -1)) {\n        *(unaff_EBP + 0x20) = iVar1;\n    }\n    var_40h = 0;\n    uStack16 = 0;\n    uStack20 = 0;\n    uStack24 = 0;\n    uStack28 = *(unaff_EBP + 0x14);\n    var_1ch_2 = *(unaff_EBP + 0x10);\n    var_20h_4 = 0;\n    var_24h_3 = *(unaff_EBP + 0x20);\n    var_28h_3 = 0x406f90;\n    iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)();\n    *(unaff_EBP + -0x20) = iVar1;\n    if (iVar1 == 0) goto code_r0x004070f4;\n    *(unaff_EBP + -4) = 0;\n    var_28h_3 = 0x406fac;\n    fcn.00407d60();\n    *(unaff_EBP + -0x18) = &fcn.00406ea4::var_24h_3;\n    *(unaff_EBP + -0x1c) = &fcn.00406ea4::var_24h_3;\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + -0x1c) == 0) {\n        var_28h_3 = *(unaff_EBP + -0x20);\n        var_2ch_3 = 0x406fdf;\n        iVar1 = fcn.00405bcb();\n        *(unaff_EBP + -0x1c) = iVar1;\n        if (iVar1 == 0) goto code_r0x004070f4;\n        *(unaff_EBP + -0x2c) = 1;\n    }\n    var_28h_3 = 0;\n    var_2ch_3 = 0;\n    uStack52 = *(unaff_EBP + -0x20);\n    var_34h_2 = *(unaff_EBP + -0x1c);\n    uStack60 = *(unaff_EBP + 0x14);\n    uStack64 = *(unaff_EBP + 0x10);\n    uStack68 = 0;\n    uStack72 = *(unaff_EBP + 0x20);\n    iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)();\n    if (iVar1 == 0) {\ncode_r0x004070d4:\n        arg_8h_00 = *(unaff_EBP + -0x34);\n    }\n    else {\n        arg_8h_00 = &stack0xffffffb8;\n        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringA)\n                          (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), *(unaff_EBP + -0x20), 0, 0);\n        *(unaff_EBP + -0x30) = iVar1;\n        if (iVar1 == 0) goto code_r0x004070d4;\n        *(unaff_EBP + -4) = 1;\n        fcn.00407d60();\n        *(unaff_EBP + -0x18) = &stack0xffffffb8;\n        *(unaff_EBP + -0x34) = &stack0xffffffb8;\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*0x10 == 0x48) {\n            arg_8h_00 = fcn.00405bcb(iVar1);\n            if (arg_8h_00 != NULL) {\n                *(unaff_EBP + -0x28) = 1;\n                goto code_r0x00407076;\n            }\n        }\n        else {\ncode_r0x00407076:\n            iVar3 = (*_sym.imp.KERNEL32.dll_LCMapStringA)\n                              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), *(unaff_EBP + -0x20), \n                               arg_8h_00, iVar1);\n            if (iVar3 != 0) {\n                if ((*(unaff_EBP + 0xd) & 4) == 0) {\n                    if (*(unaff_EBP + 0x1c) == 0) {\n                        uVar5 = 0;\n                        uVar4 = 0;\n                    }\n                    else {\n                        uVar5 = *(unaff_EBP + 0x1c);\n                        uVar4 = *(unaff_EBP + 0x18);\n                    }\n                    uVar5 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                      (*(unaff_EBP + 0x20), 1, arg_8h_00, iVar1, uVar4, uVar5);\n                    *(unaff_EBP + -0x24) = uVar5;\n                }\n                else {\n                    *(unaff_EBP + -0x24) = iVar1;\n                    if (*(unaff_EBP + 0x1c) != 0) {\n                        if (*(unaff_EBP + 0x1c) < iVar1) {\n                            iVar1 = *(unaff_EBP + 0x1c);\n                        }\n                        fcn.00407da0(*(unaff_EBP + 0x18), arg_8h_00, iVar1);\n                    }\n                }\n            }\n        }\n    }\n    if (*(unaff_EBP + -0x28) != 0) {\n        fcn.00406cec(arg_8h_00);\n    }\n    if (*(unaff_EBP + -0x2c) != 0) {\n        fcn.00406cec(*(unaff_EBP + -0x1c));\n    }\ncode_r0x004070f4:\n    *(unaff_EBP + -0x44) = 0x4070fc;\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 2656
    },
    "004072c1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004072c1(int32_t arg_8h, char *arg_ch)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    char *arg_8h_00;\n    int32_t iVar3;\n    \n    arg_8h_00 = arg_ch;\n    fcn.004051e0(arg_8h, 0, 0x90);\n    if (*arg_ch != '\\0') {\n        if ((*arg_ch != '.') || (arg_ch[1] == '\\0')) {\n            arg_ch = NULL;\n            do {\n                uVar2 = fcn.0040c430(arg_8h_00, 0x416628);\n                if (uVar2 == 0) {\n                    return 0xffffffff;\n                }\n                cVar1 = arg_8h_00[uVar2];\n                if (arg_ch == NULL) {\n                    if (0x3f < uVar2) {\n                        return 0xffffffff;\n                    }\n                    iVar3 = arg_8h;\n                    if (cVar1 == '.') {\n                        return 0xffffffff;\n                    }\n                }\n                else if (arg_ch == 0x1) {\n                    if (0x3f < uVar2) {\n                        return 0xffffffff;\n                    }\n                    if (cVar1 == '_') {\n                        return 0xffffffff;\n                    }\n                    iVar3 = arg_8h + 0x40;\n                }\n                else {\n                    if (arg_ch != 0x2) {\n                        return 0xffffffff;\n                    }\n                    if (0xf < uVar2) {\n                        return 0xffffffff;\n                    }\n                    if ((cVar1 != '\\0') && (cVar1 != ',')) {\n                        return 0xffffffff;\n                    }\n                    iVar3 = arg_8h + 0x80;\n                }\n                fcn.00407da0(iVar3, arg_8h_00, uVar2);\n                if ((cVar1 == ',') || (cVar1 == '\\0')) {\n                    return 0;\n                }\n                arg_ch = arg_ch + 1;\n                arg_8h_00 = arg_8h_00 + uVar2 + 1;\n            } while( true );\n        }\n        fcn.00407da0(arg_8h + 0x80, arg_ch + 1, 0xf);\n        *(arg_8h + 0x8f) = 0;\n    }\n    return 0;\n}\n",
        "token_count": 539
    },
    "0040739d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0040739d(uint param_1, int32_t param_2)\n\n{\n    fcn.00404f40(param_1, param_2);\n    if (*(param_2 + 0x40) != '\\0') {\n        fcn.0040729d(param_1, 2, 0x416630, param_2 + 0x40);\n    }\n    if (*(param_2 + 0x80) != '\\0') {\n        fcn.0040729d(param_1, 2, 0x41662c, param_2 + 0x80);\n    }\n    return;\n}\n",
        "token_count": 141
    },
    "004074e5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004074e5(char *arg_8h, uchar *arg_ch, ushort *arg_10h, uint *arg_14h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint var_94h;\n    uint var_4h;\n    \n    var_4h = *0x41ad6c;\n    if (arg_8h != NULL) {\n        if ((*arg_8h == 'C') && (arg_8h[1] == '\\0')) {\n            *arg_ch = 0x43;\n            arg_ch[1] = 0;\n            if (arg_10h != NULL) {\n                *arg_10h = 0;\n                arg_10h[1] = 0;\n                arg_10h[2] = 0;\n            }\n            if (arg_14h != NULL) {\n                *arg_14h = 0;\n            }\n        }\n        else {\n            uVar1 = fcn.004049a0(arg_8h);\n            if ((0x81 < uVar1) ||\n               ((iVar2 = fcn.00409570(0x41ae90, arg_8h),  iVar2 != 0 &&\n                (iVar2 = fcn.00409570(0x41ae08, arg_8h),  iVar2 != 0)))) {\n                iVar2 = fcn.004072c1(&var_94h, arg_8h);\n                if ((iVar2 != 0) || (iVar2 = fcn.0040cbb5(&var_94h, 0x41babc, &var_94h),  iVar2 == 0))\n                goto code_r0x00407636;\n                *0x41bac4 = *0x41bac0;\n                fcn.0040739d(0x41ae90, &var_94h);\n                if ((*arg_8h == '\\0') || (uVar1 = fcn.004049a0(arg_8h),  0x81 < uVar1)) {\n                    arg_8h = 0x41664a;\n                }\n                *0x41ae8a = 0;\n                fcn.00407da0(0x41ae08, arg_8h, 0x82);\n            }\n            if (arg_10h != NULL) {\n                fcn.00404a30(arg_10h, 0x41babc, 6);\n            }\n            if (arg_14h != NULL) {\n                fcn.00404a30(arg_14h, 0x41bac4, 4);\n            }\n            fcn.00404f40(arg_ch, 0x41ae90);\n        }\n    }\ncode_r0x00407636:\n    fcn.0040cd9b();\n    return;\n}\n",
        "token_count": 629
    },
    "00407641": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.00407641(uint param_1)\n\n{\n    uint32_t *puVar1;\n    int32_t arg_8h;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint unaff_EBX;\n    int32_t iVar9;\n    int32_t unaff_ESI;\n    uint unaff_EDI;\n    uint in_stack_fffffe3c;\n    uint in_stack_fffffe40;\n    int32_t in_stack_fffffe44;\n    uint in_stack_fffffe48;\n    uint32_t arg_1ch;\n    uint32_t in_stack_fffffe50;\n    int32_t iStack420;\n    int32_t iStack404;\n    int32_t iStack400;\n    uchar uStack396;\n    uint8_t auStack395 [255];\n    uchar auStack140 [132];\n    uint uStack8;\n    \n    uStack8 = *0x41ad6c;\n    iVar4 = fcn.004074e5(param_1, auStack140, &stack0xfffffe50, &iStack404);\n    if (iVar4 != 0) {\n        iVar9 = unaff_ESI * 0xc;\n        iVar4 = fcn.00409570(auStack140, *(iVar9 + 0x41af1c));\n        if (iVar4 != 0) {\n            iVar4 = fcn.004049a0(auStack140);\n            iVar4 = fcn.00405bcb(iVar4 + 1);\n            if (iVar4 != 0) {\n                arg_8h = *(iVar9 + 0x41af1c);\n                puVar1 = unaff_ESI * 4 + 0x41bd84;\n                arg_1ch = *puVar1;\n                iStack400 = unaff_ESI * 6 + 0x41bdd8;\n                fcn.00404a30(&stack0xfffffe3c, iStack400, 6);\n                iVar3 = *0x41bd9c;\n                uVar5 = fcn.00404f40(iVar4, auStack140);\n                *(iVar9 + 0x41af1c) = uVar5;\n                *puVar1 = in_stack_fffffe50 & 0xffff;\n                fcn.00404a30(iStack400, &stack0xfffffe50, 6);\n                uVar8 = *0x41b2d0;\n                if (unaff_ESI == 2) {\n                    iStack400 = 0;\n                    *0x41bd9c = iStack404;\n                    iStack420 = *0x41ae04;\n                    piVar6 = 0x41ade0;\n                    iVar7 = *0x41ae00;\n                    do {\n                        if (iStack404 == *piVar6) {\n                            if (iStack400 != 0) {\n                                iVar2 = iStack400 * 8;\n                                *0x41ade0 = *(iVar2 + 0x41ade0);\n                                *0x41ade4 = *(iVar2 + 0x41ade4);\n                                *(iVar2 + 0x41ade0) = iVar7;\n                                *(iVar2 + 0x41ade4) = iStack420;\n                            }\n                            break;\n                        }\n                        in_stack_fffffe44 = *piVar6;\n                        iStack400 = iStack400 + 1;\n                        *piVar6 = iVar7;\n                        iVar2 = piVar6[1];\n                        piVar6[1] = iStack420;\n                        piVar6 = piVar6 + 2;\n                        iVar7 = in_stack_fffffe44;\n                        iStack420 = iVar2;\n                    } while (piVar6 < 0x41ae08);\n                    uVar8 = *0x41ade4;\n                    if (iStack400 == 5) {\n                        iVar7 = fcn.0040ce68(1, 0x416568, 0x7f, &uStack396, iStack404, *0x41bd8c, 1, unaff_EDI, \n                                             unaff_EBX, in_stack_fffffe3c, in_stack_fffffe40, in_stack_fffffe44, \n                                             in_stack_fffffe48, arg_1ch, in_stack_fffffe50);\n                        if (iVar7 == 0) {\n                            *0x41ade4 = 0;\n                        }\n                        else {\n                            uVar8 = 0;\n                            do {\n                                auStack395[uVar8 * 2] = auStack395[uVar8 * 2] & 1;\n                                uVar8 = uVar8 + 1;\n                            } while (uVar8 < 0x7f);\n                            iVar7 = fcn.0040cdb0(&uStack396, 0x416468, 0xfe);\n                            *0x41ade4 = iVar7 == 0;\n                        }\n                        *0x41ade0 = *0x41bd9c;\n                        uVar8 = *0x41ade4;\n                    }\n                }\n                *0x41b2d0 = uVar8;\n                if (unaff_ESI == 1) {\n                    *0x41bda0 = iStack404;\n                }\n                iVar7 = (**(iVar9 + 0x41af20))();\n                if (iVar7 == 0) {\n                    if (arg_8h != 0x41ad80) {\n                        fcn.00406cec(arg_8h);\n                    }\n                }\n                else {\n                    *(iVar9 + 0x41af1c) = arg_8h;\n                    fcn.00406cec(iVar4);\n                    *puVar1 = arg_1ch;\n                    *0x41bd9c = iVar3;\n                }\n            }\n        }\n    }\n    fcn.0040cd9b();\n    return;\n}\n",
        "token_count": 1321
    },
    "004078d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004078d0(char *param_1, int32_t param_2)\n\n{\n    bool bVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t iStack152;\n    int32_t iStack144;\n    uchar auStack140 [132];\n    uint uStack8;\n    \n    uStack8 = *0x41ad6c;\n    if (param_2 != 0) {\n        if (param_1 != NULL) {\n            fcn.00407641(param_1);\n        }\n        goto code_r0x00407a0a;\n    }\n    bVar1 = true;\n    iStack144 = 0;\n    if (param_1 != NULL) {\n        if (((*param_1 == 'L') && (param_1[1] == 'C')) && (param_1[2] == '_')) {\n            do {\n                pcVar2 = fcn.0040d070(param_1, 0x41664c);\n                if (((pcVar2 == NULL) || (iVar3 = pcVar2 - param_1,  iVar3 == 0)) || (*pcVar2 == ';'))\n                goto code_r0x00407a0a;\n                iStack152 = 1;\n                puVar5 = 0x41af24;\n                do {\n                    iVar4 = fcn.0040d030(*puVar5, param_1, iVar3);\n                    if ((iVar4 == 0) && (iVar4 = fcn.004049a0(*puVar5),  iVar3 == iVar4)) break;\n                    iStack152 = iStack152 + 1;\n                    puVar5 = puVar5 + 3;\n                } while (puVar5 < 0x41af55);\n                pcVar2 = pcVar2 + 1;\n                iVar3 = fcn.0040c430(pcVar2, 0x416644);\n                if ((iVar3 == 0) && (*pcVar2 != ';')) goto code_r0x00407a0a;\n                if (iStack152 < 6) {\n                    fcn.00407da0(auStack140, pcVar2, iVar3);\n                    auStack140[iVar3] = 0;\n                    iVar4 = fcn.00407641(auStack140);\n                    if (iVar4 != 0) {\n                        iStack144 = iStack144 + 1;\n                    }\n                }\n            } while ((pcVar2[iVar3] != '\\0') && (param_1 = pcVar2 + iVar3 + 1,  *param_1 != '\\0'));\n        }\n        else {\n            iVar3 = fcn.004074e5(param_1, auStack140, 0, 0);\n            if (iVar3 == 0) goto code_r0x00407a0a;\n            puVar5 = 0x41af1c;\n            do {\n                if (puVar5 != 0x41af1c) {\n                    iVar3 = fcn.00409570(auStack140, *puVar5);\n                    if ((iVar3 == 0) || (iVar3 = fcn.00407641(auStack140),  iVar3 != 0)) {\n                        iStack144 = iStack144 + 1;\n                    }\n                    else {\n                        bVar1 = false;\n                    }\n                }\n                puVar5 = puVar5 + 3;\n            } while (puVar5 < 0x41af59);\n            if (bVar1) {\n                fcn.00407426();\n                fcn.00406cec(*0x41af1c);\n                *0x41af1c = 0;\n                goto code_r0x00407a0a;\n            }\n        }\n        if (iStack144 == 0) goto code_r0x00407a0a;\n    }\n    fcn.00407426();\ncode_r0x00407a0a:\n    fcn.0040cd9b();\n    return;\n}\n",
        "token_count": 893
    },
    "00407f62": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_518h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00407f62(void)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uchar uVar4;\n    char cVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint8_t *puVar8;\n    uint unaff_ESI;\n    uint *puVar9;\n    uint noname_8;\n    uint noname_9;\n    uint *noname_2;\n    uint noname_11;\n    uint *noname_4;\n    uint noname_13;\n    uint noname_14;\n    uint noname_15;\n    uint noname_8_00;\n    uint *noname_1;\n    uint noname_10;\n    uint noname_12;\n    uint noname_13_00;\n    uint noname_14_00;\n    uint noname_7;\n    uint *arg_8h;\n    uint var_518h;\n    uint in_stack_fffffae8;\n    uint in_stack_fffffaec;\n    uint in_stack_fffffaf0;\n    uint in_stack_fffffaf4;\n    uint in_stack_fffffaf8;\n    uint in_stack_fffffafc;\n    uint in_stack_fffffb00;\n    uint in_stack_fffffb04;\n    uint var_318h;\n    uint var_218h;\n    uint var_118h;\n    uint lpCPInfo;\n    uint var_12h;\n    uint var_4h;\n    \n    var_4h = *0x41ad6c;\n    arg_8h = &lpCPInfo;\n    noname_7 = *0x41c2c4;\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfo)();\n    if (iVar2 == 1) {\n        uVar3 = 0;\n        do {\n            *(&var_118h + uVar3) = uVar3;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n        var_118h._0_1_ = 0x20;\n        if (var_12h != 0) {\n            puVar8 = &var_12h + 1;\n            do {\n                uVar3 = var_12h;\n                if (uVar3 <= *puVar8) {\n                    uVar6 = (*puVar8 - uVar3) + 1;\n                    puVar9 = &var_118h + uVar3;\n                    for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n                        *puVar9 = 0x20202020;\n                        puVar9 = puVar9 + 1;\n                    }\n                    for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {\n                        *puVar9 = 0x20;\n                        puVar9 = puVar9 + 1;\n                    }\n                }\n                var_12h._0_1_ = puVar8[1];\n                puVar8 = puVar8 + 2;\n            } while (var_12h != 0);\n        }\n        noname_14_00 = 0;\n        puVar9 = &var_518h;\n        noname_10 = 0x100;\n        noname_1 = &var_118h;\n        noname_8_00 = 1;\n        noname_12 = *0x41c2c4;\n        noname_13_00 = *0x41c140;\n        fcn.0040ce68(1, noname_1, 0x100, puVar9, *0x41c2c4, *0x41c140, 0, noname_7, arg_8h, unaff_ESI, var_518h, \n                     in_stack_fffffae8, in_stack_fffffaec, in_stack_fffffaf0, in_stack_fffffaf4);\n        noname_15 = 0;\n        noname_4 = &var_218h;\n        noname_13 = 0x100;\n        noname_11 = 0x100;\n        noname_2 = &var_118h;\n        noname_9 = 0x100;\n        noname_8 = *0x41c140;\n        noname_14 = *0x41c2c4;\n        fcn.0040d2f5(*0x41c140, 0x100, noname_2, 0x100, noname_4, 0x100, *0x41c2c4, 0, noname_8_00, noname_1, noname_10\n                     , puVar9, noname_12, noname_13_00, noname_14_00, noname_7, arg_8h, unaff_ESI, var_518h, \n                     in_stack_fffffae8, in_stack_fffffaec, in_stack_fffffaf0, in_stack_fffffaf4, in_stack_fffffaf8, \n                     in_stack_fffffafc, in_stack_fffffb00, in_stack_fffffb04);\n        fcn.0040d2f5(*0x41c140, 0x200, &var_118h, 0x100, &var_318h, 0x100, *0x41c2c4, 0, noname_8, noname_9, noname_2, \n                     noname_11, noname_4, noname_13, noname_14, noname_15, noname_8_00, noname_1, noname_10, puVar9, \n                     noname_12, noname_13_00, noname_14_00, noname_7, arg_8h, unaff_ESI, var_518h);\n        uVar3 = 0;\n        do {\n            uVar1 = *(&var_518h + uVar3 * 2);\n            if ((uVar1 & 1) == 0) {\n                if ((uVar1 & 2) != 0) {\n                    *(uVar3 + 0x41c1c1) = *(uVar3 + 0x41c1c1) | 0x20;\n                    uVar4 = *(&var_318h + uVar3);\n                    goto code_r0x00408074;\n                }\n                *(uVar3 + 0x41c2e0) = 0;\n            }\n            else {\n                *(uVar3 + 0x41c1c1) = *(uVar3 + 0x41c1c1) | 0x10;\n                uVar4 = *(&var_218h + uVar3);\ncode_r0x00408074:\n                *(uVar3 + 0x41c2e0) = uVar4;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n    }\n    else {\n        uVar3 = 0;\n        do {\n            if ((uVar3 < 0x41) || (0x5a < uVar3)) {\n                if ((0x60 < uVar3) && (uVar3 < 0x7b)) {\n                    *(uVar3 + 0x41c1c1) = *(uVar3 + 0x41c1c1) | 0x20;\n                    cVar5 = uVar3 + -0x20;\n                    goto code_r0x004080b7;\n                }\n                *(uVar3 + 0x41c2e0) = 0;\n            }\n            else {\n                *(uVar3 + 0x41c1c1) = *(uVar3 + 0x41c1c1) | 0x10;\n                cVar5 = uVar3 + ' ';\ncode_r0x004080b7:\n                *(uVar3 + 0x41c2e0) = cVar5;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n    }\n    fcn.0040cd9b();\n    return;\n}\n",
        "token_count": 1876
    },
    "0040815d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040815d(int32_t arg_8h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    uint extraout_ECX_00;\n    int32_t iVar5;\n    uint8_t *puVar6;\n    uint8_t *puVar7;\n    uint *puVar8;\n    uint32_t var_1ch;\n    uint32_t lpCPInfo;\n    uint var_12h;\n    uint var_4h;\n    \n    var_4h = *0x41ad6c;\n    if (arg_8h != 0) {\n        iVar5 = 0;\n        uVar3 = 0;\ncode_r0x0040817f:\n        if (*(uVar3 + 0x41af68) != arg_8h) goto code_r0x00408187;\n        puVar8 = 0x41c1c0;\n        for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar8 = 0;\n            puVar8 = puVar8 + 1;\n        }\n        var_1ch = 0;\n        *puVar8 = 0;\n        puVar6 = iVar5 * 0x30 + 0x41af78;\n        do {\n            uVar2 = *puVar6;\n            puVar7 = puVar6;\n            while ((uVar2 != 0 && (uVar1 = puVar7[1],  uVar1 != 0))) {\n                uVar3 = uVar2;\n                if (uVar3 <= uVar1) {\n                    uVar2 = *(var_1ch + 0x41af60);\n                    do {\n                        *(uVar3 + 0x41c1c1) = *(uVar3 + 0x41c1c1) | uVar2;\n                        uVar3 = uVar3 + 1;\n                    } while (uVar3 <= uVar1);\n                }\n                puVar7 = puVar7 + 2;\n                uVar2 = *puVar7;\n            }\n            var_1ch = var_1ch + 1;\n            puVar6 = puVar6 + 8;\n        } while (var_1ch < 4);\n        *0x41c2c4 = arg_8h;\n        *0x41c1bc = 1;\n        *0x41c140 = fcn.00407f0a();\n        *0x41c2d0 = *(extraout_ECX + 0x41af6c);\n        *0x41c2d4 = *(extraout_ECX + 0x41af70);\n        *0x41c2d8 = *(extraout_ECX + 0x41af74);\n        goto code_r0x004082d4;\n    }\ncode_r0x004082cf:\n    fcn.00407f39();\ncode_r0x004082d4:\n    fcn.00407f62();\ncode_r0x004082e0:\n    fcn.0040cd9b();\n    return;\ncode_r0x00408187:\n    uVar3 = uVar3 + 0x30;\n    iVar5 = iVar5 + 1;\n    if (0xef < uVar3) goto code_r0x00408192;\n    goto code_r0x0040817f;\ncode_r0x00408192:\n    iVar5 = (*_sym.imp.KERNEL32.dll_GetCPInfo)(arg_8h, &lpCPInfo);\n    if (iVar5 != 1) {\n        if (*0x41bac8 == 0) goto code_r0x004082e0;\n        goto code_r0x004082cf;\n    }\n    puVar8 = 0x41c1c0;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *0x41c2c4 = arg_8h;\n    *0x41c140 = 0;\n    if (lpCPInfo < 2) {\n        *0x41c1bc = 0;\n    }\n    else {\n        if (var_12h != '\\0') {\n            puVar6 = &var_12h + 1;\n            do {\n                uVar2 = *puVar6;\n                if (uVar2 == 0) break;\n                for (uVar3 = puVar6[-1]; uVar3 <= uVar2; uVar3 = uVar3 + 1) {\n                    *(uVar3 + 0x41c1c1) = *(uVar3 + 0x41c1c1) | 4;\n                }\n                puVar7 = puVar6 + 1;\n                puVar6 = puVar6 + 2;\n            } while (*puVar7 != 0);\n        }\n        uVar3 = 1;\n        do {\n            *(uVar3 + 0x41c1c1) = *(uVar3 + 0x41c1c1) | 8;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0xff);\n        *0x41c140 = fcn.00407f0a();\n        *0x41c1bc = extraout_ECX_00;\n    }\n    *0x41c2d0 = 0;\n    *0x41c2d4 = 0;\n    *0x41c2d8 = 0;\n    goto code_r0x004082d4;\n}\n",
        "token_count": 1294
    },
    "00408838": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00408838(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uStack296;\n    uchar *puStack292;\n    uint uStack288;\n    uchar auStack272 [260];\n    uchar uStack12;\n    uint uStack8;\n    \n    uStack8 = *0x41ad6c;\n    uVar1 = 0;\n    do {\n        if (param_1 == *(uVar1 * 8 + 0x41b060)) break;\n        uVar1 = uVar1 + 1;\n    } while (uVar1 < 0x13);\n    if (param_1 == *(uVar1 * 8 + 0x41b060)) {\n        if ((*0x41baa0 == 1) || ((*0x41baa0 == 0 && (*0x41acf8 == 1)))) {\n            uStack288 = 0;\n            puStack292 = &stack0x00000004;\n            uStack296 = *(uVar1 * 8 + 0x41b064);\n            uStack296 = fcn.004049a0();\n            (*_sym.imp.KERNEL32.dll_GetStdHandle)();\n            (*_sym.imp.KERNEL32.dll_WriteFile)();\n        }\n        else if (param_1 != 0xfc) {\n            uStack288 = 0x104;\n            puStack292 = &stack0xfffffef0;\n            uStack296 = 0;\n            uStack12 = 0;\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)();\n            if (iVar2 == 0) {\n                fcn.00404f40();\n            }\n            iVar2 = fcn.004049a0();\n            if (0x3c < iVar2 + 1U) {\n                fcn.004049a0();\n                fcn.00407da0();\n            }\n            fcn.004049a0();\n            fcn.004049a0();\n            fcn.00407d60();\n            fcn.00404f40();\n            fcn.00404f50();\n            fcn.00404f50();\n            fcn.00404f50();\n            fcn.0040d6b1(&stack0xfffffed8, \"Microsoft Visual C++ Runtime Library\", 0x12010);\n        }\n    }\n    uStack288 = 0x4089a4;\n    fcn.0040cd9b();\n    return;\n}\n",
        "token_count": 546
    },
    "00408a3e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00408a3e(int32_t arg_8h, uint ExceptionInfo)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t *piVar7;\n    int32_t iVar8;\n    uint var_4h;\n    \n    iVar4 = fcn.00406941();\n    piVar1 = *(iVar4 + 0x54);\n    piVar7 = piVar1;\n    do {\n        if (*piVar7 == arg_8h) break;\n        piVar7 = piVar7 + 3;\n    } while (piVar7 < piVar1 + *0x41b17c * 3);\n    if ((piVar1 + *0x41b17c * 3 <= piVar7) || (*piVar7 != arg_8h)) {\n        piVar7 = NULL;\n    }\n    if ((piVar7 == NULL) || (pcVar2 = piVar7[2],  pcVar2 == NULL)) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_UnhandledExceptionFilter)(ExceptionInfo);\n    }\n    else if (pcVar2 == 0x5) {\n        piVar7[2] = 0;\n        uVar5 = 1;\n    }\n    else {\n        if (pcVar2 != 0x1) {\n            uVar5 = *(iVar4 + 0x58);\n            *(iVar4 + 0x58) = ExceptionInfo;\n            if (piVar7[1] == 8) {\n                if (*0x41b170 < *0x41b174 + *0x41b170) {\n                    iVar6 = *0x41b170 * 0xc;\n                    iVar8 = *0x41b170;\n                    do {\n                        *(iVar6 + 8 + *(iVar4 + 0x54)) = 0;\n                        iVar8 = iVar8 + 1;\n                        iVar6 = iVar6 + 0xc;\n                    } while (iVar8 < *0x41b174 + *0x41b170);\n                }\n                iVar8 = *piVar7;\n                uVar3 = *(iVar4 + 0x5c);\n                if (iVar8 == -0x3fffff72) {\n                    *(iVar4 + 0x5c) = 0x83;\n                }\n                else if (iVar8 == -0x3fffff70) {\n                    *(iVar4 + 0x5c) = 0x81;\n                }\n                else if (iVar8 == -0x3fffff6f) {\n                    *(iVar4 + 0x5c) = 0x84;\n                }\n                else if (iVar8 == -0x3fffff6d) {\n                    *(iVar4 + 0x5c) = 0x85;\n                }\n                else if (iVar8 == -0x3fffff73) {\n                    *(iVar4 + 0x5c) = 0x82;\n                }\n                else if (iVar8 == -0x3fffff71) {\n                    *(iVar4 + 0x5c) = 0x86;\n                }\n                else if (iVar8 == -0x3fffff6e) {\n                    *(iVar4 + 0x5c) = 0x8a;\n                }\n                (*pcVar2)(8, *(iVar4 + 0x5c));\n                *(iVar4 + 0x5c) = uVar3;\n            }\n            else {\n                piVar7[2] = 0;\n                (*pcVar2)(piVar7[1]);\n            }\n            *(iVar4 + 0x58) = uVar5;\n        }\n        uVar5 = 0xffffffff;\n    }\n    return uVar5;\n}\n",
        "token_count": 854
    },
    "00408ce1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00408ce1(uint8_t **arg_8h, int32_t *arg_ch)\n\n{\n    bool bVar1;\n    bool bVar2;\n    uint8_t *in_EAX;\n    uint8_t *puVar3;\n    uint8_t *puVar4;\n    uint8_t uVar5;\n    uint8_t *in_ECX;\n    uint32_t uVar6;\n    int32_t *unaff_ESI;\n    uint var_4h;\n    \n    bVar1 = false;\n    *unaff_ESI = 0;\n    *arg_ch = 1;\n    if (arg_8h != NULL) {\n        *arg_8h = in_ECX;\n        arg_8h = arg_8h + 1;\n    }\n    do {\n        if (*in_EAX == 0x22) {\n            bVar1 = !bVar1;\n            puVar3 = in_EAX + 1;\n            uVar5 = 0x22;\n        }\n        else {\n            *unaff_ESI = *unaff_ESI + 1;\n            if (in_ECX != NULL) {\n                *in_ECX = *in_EAX;\n                in_ECX = in_ECX + 1;\n            }\n            uVar5 = *in_EAX;\n            puVar3 = in_EAX + 1;\n            if ((*(uVar5 + 0x41c1c1) & 4) != 0) {\n                *unaff_ESI = *unaff_ESI + 1;\n                if (in_ECX != NULL) {\n                    *in_ECX = *puVar3;\n                    in_ECX = in_ECX + 1;\n                }\n                puVar3 = in_EAX + 2;\n            }\n            if (uVar5 == 0) {\n                puVar3 = puVar3 + -1;\n                goto code_r0x00408d5a;\n            }\n        }\n        in_EAX = puVar3;\n    } while ((bVar1) || ((uVar5 != 0x20 && (uVar5 != 9))));\n    if (in_ECX != NULL) {\n        in_ECX[-1] = 0;\n    }\ncode_r0x00408d5a:\n    bVar1 = false;\n    while (*puVar3 != 0) {\n        for (; (*puVar3 == 0x20 || (*puVar3 == 9)); puVar3 = puVar3 + 1) {\n        }\n        if (*puVar3 == 0) break;\n        if (arg_8h != NULL) {\n            *arg_8h = in_ECX;\n            arg_8h = arg_8h + 1;\n        }\n        *arg_ch = *arg_ch + 1;\n        while( true ) {\n            bVar2 = true;\n            uVar6 = 0;\n            for (; *puVar3 == 0x5c; puVar3 = puVar3 + 1) {\n                uVar6 = uVar6 + 1;\n            }\n            if (*puVar3 == 0x22) {\n                puVar4 = puVar3;\n                if ((uVar6 & 1) == 0) {\n                    if ((!bVar1) || (puVar4 = puVar3 + 1,  *puVar4 != 0x22)) {\n                        bVar2 = false;\n                        puVar4 = puVar3;\n                    }\n                    bVar1 = !bVar1;\n                }\n                uVar6 = uVar6 >> 1;\n                puVar3 = puVar4;\n            }\n            for (; uVar6 != 0; uVar6 = uVar6 - 1) {\n                if (in_ECX != NULL) {\n                    *in_ECX = 0x5c;\n                    in_ECX = in_ECX + 1;\n                }\n                *unaff_ESI = *unaff_ESI + 1;\n            }\n            uVar5 = *puVar3;\n            if ((uVar5 == 0) || ((!bVar1 && ((uVar5 == 0x20 || (uVar5 == 9)))))) break;\n            if (bVar2) {\n                if (in_ECX == NULL) {\n                    if ((*(uVar5 + 0x41c1c1) & 4) != 0) {\n                        puVar3 = puVar3 + 1;\n                        *unaff_ESI = *unaff_ESI + 1;\n                    }\n                }\n                else {\n                    if ((*(uVar5 + 0x41c1c1) & 4) != 0) {\n                        *in_ECX = uVar5;\n                        in_ECX = in_ECX + 1;\n                        puVar3 = puVar3 + 1;\n                        *unaff_ESI = *unaff_ESI + 1;\n                    }\n                    *in_ECX = *puVar3;\n                    in_ECX = in_ECX + 1;\n                }\n                *unaff_ESI = *unaff_ESI + 1;\n            }\n            puVar3 = puVar3 + 1;\n        }\n        if (in_ECX != NULL) {\n            *in_ECX = 0;\n            in_ECX = in_ECX + 1;\n        }\n        *unaff_ESI = *unaff_ESI + 1;\n    }\n    if (arg_8h != NULL) {\n        *arg_8h = NULL;\n    }\n    *arg_ch = *arg_ch + 1;\n    return;\n}\n",
        "token_count": 1222
    },
    "00409011": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00409011(void)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    uint *puVar3;\n    uint uVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int32_t *piVar9;\n    uchar auStack68 [46];\n    int16_t iStack22;\n    int32_t *piStack20;\n    \n    puVar3 = fcn.00405bcb(0x480);\n    if (puVar3 == NULL) {\n        uVar4 = 0xffffffff;\n    }\n    else {\n        *0x41bfc8 = 0x20;\n        *0x41c020 = puVar3;\n        for (; puVar3 < *0x41c020 + 0x120; puVar3 = puVar3 + 9) {\n            *puVar3 = 0xffffffff;\n            puVar3[2] = 0;\n            *(puVar3 + 1) = 0;\n            *(puVar3 + 5) = 10;\n        }\n        (*_sym.imp.KERNEL32.dll_GetStartupInfoA)(auStack68);\n        if ((iStack22 != 0) && (piStack20 != NULL)) {\n            iVar8 = *piStack20;\n            piStack20 = piStack20 + 1;\n            piVar9 = iVar8 + piStack20;\n            if (0x7ff < iVar8) {\n                iVar8 = 0x800;\n            }\n            iVar6 = iVar8;\n            if (*0x41bfc8 < iVar8) {\n                puVar3 = 0x41c024;\n                do {\n                    puVar5 = fcn.00405bcb(0x480);\n                    iVar6 = *0x41bfc8;\n                    if (puVar5 == NULL) break;\n                    *0x41bfc8 = *0x41bfc8 + 0x20;\n                    *puVar3 = puVar5;\n                    puVar2 = puVar5;\n                    for (; puVar5 < puVar2 + 0x120; puVar5 = puVar5 + 9) {\n                        *puVar5 = 0xffffffff;\n                        puVar5[2] = 0;\n                        *(puVar5 + 1) = 0;\n                        *(puVar5 + 5) = 10;\n                        puVar2 = *puVar3;\n                    }\n                    puVar3 = puVar3 + 1;\n                    iVar6 = iVar8;\n                } while (*0x41bfc8 < iVar8);\n            }\n            uVar7 = 0;\n            if (0 < iVar6) {\n                do {\n                    if (((*piVar9 != -1) && ((*piStack20 & 1) != 0)) &&\n                       (((*piStack20 & 8) != 0 || (iVar8 = (*_sym.imp.KERNEL32.dll_GetFileType)(*piVar9),  iVar8 != 0)))\n                       ) {\n                        piVar1 = *((uVar7 >> 5) * 4 + 0x41c020) + (uVar7 & 0x1f) * 0x24;\n                        *piVar1 = *piVar9;\n                        *(piVar1 + 1) = *piStack20;\n                        iVar8 = fcn.0040d8ca(piVar1 + 3, 4000);\n                        if (iVar8 == 0) {\n                            return 0xffffffff;\n                        }\n                        piVar1[2] = piVar1[2] + 1;\n                    }\n                    piVar9 = piVar9 + 1;\n                    uVar7 = uVar7 + 1;\n                    piStack20 = piStack20 + 1;\n                } while (uVar7 < iVar6);\n            }\n        }\n        iVar8 = 0;\n        do {\n            piVar9 = *0x41c020 + iVar8 * 9;\n            if (*piVar9 == -1) {\n                *(piVar9 + 1) = 0x81;\n                if (iVar8 == 0) {\n                    iVar6 = -10;\n                }\n                else {\n                    iVar6 = -0xb - (iVar8 != 1);\n                }\n                iVar6 = (*_sym.imp.KERNEL32.dll_GetStdHandle)(iVar6);\n                if ((iVar6 == -1) || (uVar7 = (*_sym.imp.KERNEL32.dll_GetFileType)(iVar6),  uVar7 == 0)) {\n                    *(piVar9 + 1) = *(piVar9 + 1) | 0x40;\n                }\n                else {\n                    *piVar9 = iVar6;\n                    if ((uVar7 & 0xff) == 2) {\n                        *(piVar9 + 1) = *(piVar9 + 1) | 0x40;\n                    }\n                    else if ((uVar7 & 0xff) == 3) {\n                        *(piVar9 + 1) = *(piVar9 + 1) | 8;\n                    }\n                    iVar6 = fcn.0040d8ca(piVar9 + 3, 4000);\n                    if (iVar6 == 0) {\n                        return 0xffffffff;\n                    }\n                    piVar9[2] = piVar9[2] + 1;\n                }\n            }\n            else {\n                *(piVar9 + 1) = *(piVar9 + 1) | 0x80;\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 3);\n        (*_sym.imp.KERNEL32.dll_SetHandleCount)(*0x41bfc8);\n        uVar4 = 0;\n    }\n    return uVar4;\n}\n",
        "token_count": 1271
    },
    "004092e3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint fcn.004092e3(void)\n\n{\n    if ((*0x41bad4 == 2) && (4 < *0x41bae0)) {\n        return 1;\n    }\n    return 3;\n}\n",
        "token_count": 50
    },
    "004092fd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint fcn.004092fd(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *0x41bfb4 = (*_sym.imp.KERNEL32.dll_HeapCreate)(param_1 == 0, 0x1000, 0);\n    if (*0x41bfb4 == 0) {\n        return 0;\n    }\n    *0x41bfc4 = fcn.004092e3();\n    if ((*0x41bfc4 == 3) && (iVar1 = fcn.0040960d(0x3f8),  iVar1 == 0)) {\n        (*_sym.imp.KERNEL32.dll_HeapDestroy)(*0x41bfb4);\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 172
    },
    "00409680": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409680(uint32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    uint32_t *puVar3;\n    int32_t *piVar4;\n    char cVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    code *pcVar8;\n    uint8_t uVar9;\n    uint32_t uVar10;\n    uint32_t *puVar11;\n    uint32_t *puVar12;\n    uint32_t *puVar13;\n    uint32_t uVar14;\n    uint32_t uVar15;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    uVar6 = arg_8h[4];\n    puVar13 = arg_ch + -4;\n    uVar15 = arg_ch - arg_8h[3] >> 0xf;\n    piVar4 = uVar15 * 0x204 + 0x144 + uVar6;\n    var_4h = *puVar13 - 1;\n    if ((var_4h & 1) == 0) {\n        puVar11 = var_4h + puVar13;\n        uVar14 = *puVar11;\n        uVar7 = *(arg_ch + -8);\n        if ((uVar14 & 1) == 0) {\n            uVar10 = (uVar14 >> 4) - 1;\n            if (0x3f < uVar10) {\n                uVar10 = 0x3f;\n            }\n            if (puVar11[1] == puVar11[2]) {\n                if (uVar10 < 0x20) {\n                    pcVar2 = uVar10 + 4 + uVar6;\n                    uVar10 = ~(0x80000000U >> (uVar10 & 0x1f));\n                    puVar12 = uVar6 + 0x44 + uVar15 * 4;\n                    *puVar12 = *puVar12 & uVar10;\n                    *pcVar2 = *pcVar2 + -1;\n                    if (*pcVar2 == '\\0') {\n                        *arg_8h = *arg_8h & uVar10;\n                    }\n                }\n                else {\n                    pcVar2 = uVar10 + 4 + uVar6;\n                    uVar10 = ~(0x80000000U >> (uVar10 - 0x20 & 0x1f));\n                    puVar12 = uVar6 + 0xc4 + uVar15 * 4;\n                    *puVar12 = *puVar12 & uVar10;\n                    *pcVar2 = *pcVar2 + -1;\n                    if (*pcVar2 == '\\0') {\n                        arg_8h[1] = arg_8h[1] & uVar10;\n                    }\n                }\n            }\n            var_4h = var_4h + uVar14;\n            *(puVar11[2] + 4) = puVar11[1];\n            *(puVar11[1] + 8) = puVar11[2];\n        }\n        puVar11 = (var_4h >> 4) + -1;\n        if (0x3f < puVar11) {\n            puVar11 = 0x3f;\n        }\n        puVar12 = arg_8h;\n        if ((uVar7 & 1) == 0) {\n            puVar13 = puVar13 - uVar7;\n            puVar12 = (uVar7 >> 4) + -1;\n            if (0x3f < puVar12) {\n                puVar12 = 0x3f;\n            }\n            var_4h = var_4h + uVar7;\n            puVar11 = (var_4h >> 4) + -1;\n            if (0x3f < puVar11) {\n                puVar11 = 0x3f;\n            }\n            if (puVar12 != puVar11) {\n                if (puVar13[1] == puVar13[2]) {\n                    if (puVar12 < 0x20) {\n                        uVar14 = ~(0x80000000U >> (puVar12 & 0x1f));\n                        puVar3 = uVar6 + 0x44 + uVar15 * 4;\n                        *puVar3 = *puVar3 & uVar14;\n                        pcVar2 = puVar12 + uVar6 + 4;\n                        *pcVar2 = *pcVar2 + -1;\n                        if (*pcVar2 == '\\0') {\n                            *arg_8h = *arg_8h & uVar14;\n                        }\n                    }\n                    else {\n                        uVar14 = ~(0x80000000U >> (puVar12 - 0x20 & 0x1f));\n                        puVar3 = uVar6 + 0xc4 + uVar15 * 4;\n                        *puVar3 = *puVar3 & uVar14;\n                        pcVar2 = puVar12 + uVar6 + 4;\n                        *pcVar2 = *pcVar2 + -1;\n                        if (*pcVar2 == '\\0') {\n                            arg_8h[1] = arg_8h[1] & uVar14;\n                        }\n                    }\n                }\n                *(puVar13[2] + 4) = puVar13[1];\n                *(puVar13[1] + 8) = puVar13[2];\n            }\n        }\n        if (((uVar7 & 1) != 0) || (puVar12 != puVar11)) {\n            piVar1 = piVar4 + puVar11 * 2;\n            uVar14 = piVar1[1];\n            puVar13[2] = piVar1;\n            puVar13[1] = uVar14;\n            piVar1[1] = puVar13;\n            *(puVar13[1] + 8) = puVar13;\n            if (puVar13[1] == puVar13[2]) {\n                cVar5 = *(puVar11 + uVar6 + 4);\n                *(puVar11 + uVar6 + 4) = cVar5 + '\\x01';\n                uVar9 = puVar11;\n                if (puVar11 < 0x20) {\n                    if (cVar5 == '\\0') {\n                        *arg_8h = *arg_8h | 0x80000000U >> (uVar9 & 0x1f);\n                    }\n                    puVar11 = uVar6 + 0x44 + uVar15 * 4;\n                    *puVar11 = *puVar11 | 0x80000000U >> (uVar9 & 0x1f);\n                }\n                else {\n                    if (cVar5 == '\\0') {\n                        arg_8h[1] = arg_8h[1] | 0x80000000U >> (uVar9 - 0x20 & 0x1f);\n                    }\n                    puVar11 = uVar6 + 0xc4 + uVar15 * 4;\n                    *puVar11 = *puVar11 | 0x80000000U >> (uVar9 - 0x20 & 0x1f);\n                }\n            }\n        }\n        *puVar13 = var_4h;\n        *((var_4h - 4) + puVar13) = var_4h;\n        *piVar4 = *piVar4 + -1;\n        pcVar8 = _sym.imp.KERNEL32.dll_VirtualFree;\n        if (*piVar4 == 0) {\n            if (*0x41bf98 != NULL) {\n                (*_sym.imp.KERNEL32.dll_VirtualFree)(*0x41bfb0 * 0x8000 + (*0x41bf98)[3], 0x8000, 0x4000);\n                (*0x41bf98)[2] = (*0x41bf98)[2] | 0x80000000U >> (*0x41bfb0 & 0x1f);\n                *((*0x41bf98)[4] + 0xc4 + *0x41bfb0 * 4) = 0;\n                *((*0x41bf98)[4] + 0x43) = *((*0x41bf98)[4] + 0x43) + -1;\n                if (*((*0x41bf98)[4] + 0x43) == '\\0') {\n                    (*0x41bf98)[1] = (*0x41bf98)[1] & 0xfffffffe;\n                }\n                if ((*0x41bf98)[2] == 0xffffffff) {\n                    (*pcVar8)((*0x41bf98)[3], 0, 0x8000);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(*0x41bfb4, 0, (*0x41bf98)[4]);\n                    fcn.00405250(*0x41bf98, *0x41bf98 + 5, (*0x41bf9c * 0x14 - *0x41bf98) + -0x14 + *0x41bfa0);\n                    *0x41bf9c = *0x41bf9c + -1;\n                    if (*0x41bf98 < arg_8h) {\n                        arg_8h = arg_8h + -5;\n                    }\n                    *0x41bfa8 = *0x41bfa0;\n                }\n            }\n            *0x41bf98 = arg_8h;\n            *0x41bfb0 = uVar15;\n        }\n    }\n    return;\n}\n",
        "token_count": 2169
    },
    "00409f05": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00409f05(void)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t **ppiVar4;\n    uint32_t uVar5;\n    int32_t *piVar6;\n    int32_t **ppiVar7;\n    int32_t iVar8;\n    int32_t **ppiVar9;\n    int32_t **ppiVar10;\n    uint32_t *puVar11;\n    uint32_t *puVar12;\n    uint *puVar13;\n    bool bVar14;\n    uint var_138h;\n    uint32_t *var_38h;\n    uint32_t *var_34h;\n    int32_t **var_30h;\n    int32_t **var_2ch;\n    uint32_t var_28h;\n    int32_t **var_24h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    int32_t var_ch;\n    int32_t **var_8h;\n    int32_t *var_4h;\n    \n    iVar3 = (*_sym.imp.KERNEL32.dll_IsBadWritePtr)(*0x41bfa0, *0x41bf9c * 0x14);\n    if (iVar3 != 0) {\n        return 0xffffffff;\n    }\n    var_1ch = 0;\n    puVar11 = *0x41bfa0;\n    if (0 < *0x41bf9c) {\n        do {\n            uVar5 = puVar11[4];\n            var_34h = puVar11;\n            iVar3 = (*_sym.imp.KERNEL32.dll_IsBadWritePtr)(uVar5, 0x41c4);\n            if (iVar3 != 0) {\n                return 0xfffffffe;\n            }\n            var_8h = puVar11[3];\n            var_24h = uVar5 + 0x144;\n            var_20h = puVar11[2];\n            puVar12 = uVar5 + 0xc4;\n            var_10h = 0;\n            var_14h = 0;\n            var_ch = 0;\n            do {\n                var_28h = 0;\n                var_18h = 0;\n                var_4h = NULL;\n                bVar14 = -1 < var_20h;\n                puVar13 = &var_138h;\n                var_38h = puVar12;\n                for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar13 = 0;\n                    puVar13 = puVar13 + 1;\n                }\n                if (bVar14) {\n                    iVar3 = (*_sym.imp.KERNEL32.dll_IsBadWritePtr)(var_8h, 0x8000);\n                    if (iVar3 != 0) {\n                        return 0xfffffffc;\n                    }\n                    iVar3 = 0;\n                    ppiVar9 = var_8h + 0x3ff;\n                    do {\n                        ppiVar4 = ppiVar9 + -0x3fc;\n                        if ((ppiVar9[-0x3fd] != 0xffffffff) || (*ppiVar9 != 0xffffffff)) {\n                            return 0xfffffffb;\n                        }\n                        do {\n                            piVar2 = *ppiVar4;\n                            if ((piVar2 & 1) == 0) {\n                                iVar8 = (piVar2 >> 4) + -1;\n                                if (0x3f < iVar8) {\n                                    iVar8 = 0x3f;\n                                }\n                                (&var_138h)[iVar8] = (&var_138h)[iVar8] + 1;\n                                piVar6 = piVar2;\n                            }\n                            else {\n                                if (0x400 < piVar2 - 1U) {\n                                    return 0xfffffffa;\n                                }\n                                var_4h = var_4h + 1;\n                                piVar6 = piVar2 - 1U;\n                            }\n                            if (((piVar6 < 0x10) || ((piVar6 & 0xf) != 0)) || (0xff0 < piVar6)) {\n                                return 0xfffffff9;\n                            }\n                            ppiVar4 = piVar6 + ppiVar4;\n                            if (ppiVar4[-1] != piVar2) {\n                                return 0xfffffff8;\n                            }\n                        } while (ppiVar4 < ppiVar9);\n                        if (ppiVar4 != ppiVar9) {\n                            return 0xfffffff8;\n                        }\n                        ppiVar9 = ppiVar9 + 0x400;\n                        iVar3 = iVar3 + 1;\n                    } while (iVar3 < 8);\n                    if (*var_24h != var_4h) {\n                        return 0xfffffff7;\n                    }\n                    iVar3 = 0;\n                    ppiVar9 = var_24h;\n                    do {\n                        var_4h = NULL;\n                        var_30h = ppiVar9 + 2;\n                        ppiVar4 = ppiVar9[1];\n                        var_2ch = ppiVar9;\n                        ppiVar10 = var_30h;\n                        if (ppiVar4 != ppiVar9) {\n                            do {\n                                if (var_4h == (&var_138h)[iVar3]) break;\n                                if ((ppiVar4 < var_8h) || (var_8h + 0x2000 <= ppiVar4)) {\n                                    return 0xfffffff6;\n                                }\n                                ppiVar7 = (ppiVar4 & 0xfffff000) + 0xc;\n                                ppiVar1 = (ppiVar4 & 0xfffff000) + 0xffc;\n                                if (ppiVar7 == ppiVar1) {\n                                    return 0xfffffff5;\n                                }\n                                do {\n                                    if (ppiVar7 == ppiVar4) break;\n                                    ppiVar7 = ppiVar7 + (*ppiVar7 & 0xfffffffe);\n                                    ppiVar10 = var_30h;\n                                } while (ppiVar7 != ppiVar1);\n                                if (ppiVar7 == ppiVar1) {\n                                    return 0xfffffff5;\n                                }\n                                iVar8 = (*ppiVar4 >> 4) + -1;\n                                if (0x3f < iVar8) {\n                                    iVar8 = 0x3f;\n                                }\n                                if (iVar8 != iVar3) {\n                                    return 0xfffffff4;\n                                }\n                                if (ppiVar4[2] != var_2ch) {\n                                    return 0xfffffff3;\n                                }\n                                var_4h = var_4h + 1;\n                                var_2ch = ppiVar4;\n                                ppiVar4 = ppiVar4[1];\n                            } while (ppiVar4 != ppiVar9);\n                            if (var_4h != NULL) {\n                                if (iVar3 < 0x20) {\n                                    uVar5 = 0x80000000 >> (iVar3 & 0x1f);\n                                    var_28h = var_28h | uVar5;\n                                    var_10h = var_10h | uVar5;\n                                }\n                                else {\n                                    uVar5 = 0x80000000 >> (iVar3 - 0x20 & 0x1f);\n                                    var_18h = var_18h | uVar5;\n                                    var_14h = var_14h | uVar5;\n                                }\n                            }\n                        }\n                        if ((var_2ch[1] != ppiVar9) || (var_4h != (&var_138h)[iVar3])) {\n                            return 0xfffffff2;\n                        }\n                        if (*ppiVar10 != var_2ch) {\n                            return 0xfffffff1;\n                        }\n                        iVar3 = iVar3 + 1;\n                        puVar11 = var_34h;\n                        puVar12 = var_38h;\n                        ppiVar9 = ppiVar10;\n                    } while (iVar3 < 0x40);\n                }\n                if ((var_28h != puVar12[-0x20]) || (var_18h != *puVar12)) {\n                    return 0xfffffff0;\n                }\n                var_8h = var_8h + 0x2000;\n                var_24h = var_24h + 0x81;\n                var_20h = var_20h << 1;\n                var_ch = var_ch + 1;\n                puVar12 = puVar12 + 1;\n            } while (var_ch < 0x20);\n            if ((var_10h != *puVar11) || (var_14h != puVar11[1])) {\n                return 0xffffffef;\n            }\n            puVar11 = puVar11 + 5;\n            var_1ch = var_1ch + 1;\n            var_38h = puVar12;\n        } while (var_1ch < *0x41bf9c);\n    }\n    return 0;\n}\n",
        "token_count": 2024
    },
    "0040a279": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0040a279(uint32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    int32_t *piVar3;\n    char cVar4;\n    int32_t *piVar5;\n    uint uVar6;\n    uint8_t uVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    uint32_t *puVar10;\n    int32_t iVar11;\n    uint32_t uVar12;\n    int32_t *piVar13;\n    uint32_t *puVar14;\n    uint32_t *puVar15;\n    uint32_t uVar16;\n    int32_t iVar17;\n    bool bVar18;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    uVar8 = arg_8h + 0x17U & 0xfffffff0;\n    iVar9 = (arg_8h + 0x17U >> 4) + -1;\n    puVar10 = *0x41bfa0 + *0x41bf9c * 5;\n    uVar7 = iVar9;\n    if (iVar9 < 0x20) {\n        uVar16 = 0xffffffff >> (uVar7 & 0x1f);\n        var_8h = 0xffffffff;\n    }\n    else {\n        uVar16 = 0;\n        var_8h = 0xffffffff >> (uVar7 - 0x20 & 0x1f);\n    }\n    bVar18 = *0x41bfa8 < puVar10;\n    arg_8h = *0x41bfa8;\n    while ((bVar18 && ((arg_8h[1] & var_8h | *arg_8h & uVar16) == 0))) {\n        arg_8h = arg_8h + 5;\n        bVar18 = arg_8h < puVar10;\n    }\n    puVar14 = *0x41bfa0;\n    if (arg_8h == puVar10) {\n        for (; (puVar14 < *0x41bfa8 && ((puVar14[1] & var_8h | *puVar14 & uVar16) == 0)); puVar14 = puVar14 + 5) {\n        }\n        arg_8h = puVar14;\n        if (puVar14 == *0x41bfa8) {\n            for (; (puVar14 < puVar10 && (puVar14[2] == 0)); puVar14 = puVar14 + 5) {\n            }\n            puVar15 = *0x41bfa0;\n            arg_8h = puVar14;\n            if (puVar14 == puVar10) {\n                for (; (puVar15 < *0x41bfa8 && (puVar15[2] == 0)); puVar15 = puVar15 + 5) {\n                }\n                arg_8h = puVar15;\n                if ((puVar15 == *0x41bfa8) && (arg_8h = fcn.00409998(),  arg_8h == NULL)) {\n                    return NULL;\n                }\n            }\n            uVar6 = fcn.00409a4f(arg_8h);\n            *arg_8h[4] = uVar6;\n            if (*arg_8h[4] == -1) {\n                return NULL;\n            }\n        }\n    }\n    piVar5 = arg_8h[4];\n    var_4h = *piVar5;\n    if ((var_4h == -1) || ((piVar5[var_4h + 0x31] & var_8h | piVar5[var_4h + 0x11] & uVar16) == 0)) {\n        var_4h = 0;\n        puVar10 = piVar5 + 0x11;\n        uVar12 = piVar5[0x31] & var_8h | *puVar10 & uVar16;\n        while (uVar12 == 0) {\n            puVar14 = puVar10 + 0x21;\n            var_4h = var_4h + 1;\n            puVar10 = puVar10 + 1;\n            uVar12 = *puVar14 & var_8h | *puVar10 & uVar16;\n        }\n    }\n    piVar3 = piVar5 + var_4h * 0x81 + 0x51;\n    iVar9 = 0;\n    uVar16 = piVar5[var_4h + 0x11] & uVar16;\n    if (uVar16 == 0) {\n        uVar16 = piVar5[var_4h + 0x31] & var_8h;\n        iVar9 = 0x20;\n    }\n    for (; -1 < uVar16; uVar16 = uVar16 << 1) {\n        iVar9 = iVar9 + 1;\n    }\n    piVar13 = piVar3[iVar9 * 2 + 1];\n    iVar11 = *piVar13 - uVar8;\n    iVar17 = (iVar11 >> 4) + -1;\n    if (0x3f < iVar17) {\n        iVar17 = 0x3f;\n    }\n    *0x41bfa8 = arg_8h;\n    if (iVar17 != iVar9) {\n        if (piVar13[1] == piVar13[2]) {\n            if (iVar9 < 0x20) {\n                pcVar2 = piVar5 + iVar9 + 4;\n                uVar16 = ~(0x80000000U >> (iVar9 & 0x1f));\n                piVar5[var_4h + 0x11] = uVar16 & piVar5[var_4h + 0x11];\n                *pcVar2 = *pcVar2 + -1;\n                if (*pcVar2 == '\\0') {\n                    *arg_8h = *arg_8h & uVar16;\n                }\n            }\n            else {\n                pcVar2 = piVar5 + iVar9 + 4;\n                uVar16 = ~(0x80000000U >> (iVar9 - 0x20 & 0x1f));\n                piVar5[var_4h + 0x31] = piVar5[var_4h + 0x31] & uVar16;\n                *pcVar2 = *pcVar2 + -1;\n                if (*pcVar2 == '\\0') {\n                    arg_8h[1] = arg_8h[1] & uVar16;\n                }\n            }\n        }\n        *(piVar13[2] + 4) = piVar13[1];\n        *(piVar13[1] + 8) = piVar13[2];\n        if (iVar11 == 0) goto code_r0x0040a532;\n        piVar1 = piVar3 + iVar17 * 2;\n        iVar9 = piVar1[1];\n        piVar13[2] = piVar1;\n        piVar13[1] = iVar9;\n        piVar1[1] = piVar13;\n        *(piVar13[1] + 8) = piVar13;\n        if (piVar13[1] == piVar13[2]) {\n            cVar4 = *(iVar17 + 4 + piVar5);\n            *(iVar17 + 4 + piVar5) = cVar4 + '\\x01';\n            uVar7 = iVar17;\n            if (iVar17 < 0x20) {\n                if (cVar4 == '\\0') {\n                    *arg_8h = *arg_8h | 0x80000000U >> (uVar7 & 0x1f);\n                }\n                piVar5[var_4h + 0x11] = piVar5[var_4h + 0x11] | 0x80000000U >> (uVar7 & 0x1f);\n            }\n            else {\n                if (cVar4 == '\\0') {\n                    arg_8h[1] = arg_8h[1] | 0x80000000U >> (uVar7 - 0x20 & 0x1f);\n                }\n                piVar5[var_4h + 0x31] = piVar5[var_4h + 0x31] | 0x80000000U >> (uVar7 - 0x20 & 0x1f);\n            }\n        }\n    }\n    if (iVar11 != 0) {\n        *piVar13 = iVar11;\n        *(iVar11 + -4 + piVar13) = iVar11;\n    }\ncode_r0x0040a532:\n    piVar13 = piVar13 + iVar11;\n    *piVar13 = uVar8 + 1;\n    *(piVar13 + (uVar8 - 4)) = uVar8 + 1;\n    iVar9 = *piVar3;\n    *piVar3 = iVar9 + 1;\n    if (((iVar9 == 0) && (arg_8h == *0x41bf98)) && (var_4h == *0x41bfb0)) {\n        *0x41bf98 = NULL;\n    }\n    *piVar5 = var_4h;\n    return piVar13 + 1;\n}\n",
        "token_count": 2110
    },
    "0040a575": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid __cdecl fcn.0040a575(uint arg_8h, uint arg_ch)\n\n{\n    int32_t arg_ch_00;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint32_t arg_10h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00407c04(0x416ae0, 0x14);\n    arg_ch_00 = *(unaff_EBP + 8);\n    if (arg_ch_00 == 0) {\n        fcn.00405bcb(*(unaff_EBP + 0xc));\n    }\n    else {\n        arg_10h = *(unaff_EBP + 0xc);\n        if (arg_10h == 0) {\n            fcn.00406cec(arg_ch_00);\n        }\n        else if (*0x41bfc4 == 3) {\n            do {\n                *(unaff_EBP + -0x1c) = 0;\n                if (arg_10h < 0xffffffe1) {\n                    fcn.0040953e(4);\n                    *(unaff_EBP + -4) = 0;\n                    iVar1 = fcn.00409655(arg_ch_00);\n                    *(unaff_EBP + -0x20) = iVar1;\n                    if (iVar1 != 0) {\n                        if (arg_10h <= *0x41bfa4) {\n                            iVar1 = fcn.00409b55(iVar1, arg_ch_00, arg_10h);\n                            if (iVar1 == 0) {\n                                iVar1 = fcn.0040a279(arg_10h);\n                                *(unaff_EBP + -0x1c) = iVar1;\n                                if (iVar1 != 0) {\n                                    uVar2 = *(arg_ch_00 + -4) - 1;\n                                    *(unaff_EBP + -0x24) = uVar2;\n                                    if (arg_10h <= uVar2) {\n                                        uVar2 = arg_10h;\n                                    }\n                                    fcn.00404a30(*(unaff_EBP + -0x1c), arg_ch_00, uVar2);\n                                    uVar3 = fcn.00409655(arg_ch_00);\n                                    *(unaff_EBP + -0x20) = uVar3;\n                                    fcn.00409680(uVar3, arg_ch_00);\n                                }\n                            }\n                            else {\n                                *(unaff_EBP + -0x1c) = arg_ch_00;\n                            }\n                        }\n                        if (*(unaff_EBP + -0x1c) == 0) {\n                            if (arg_10h == 0) {\n                                arg_10h = 1;\n                                *(unaff_EBP + 0xc) = 1;\n                            }\n                            arg_10h = arg_10h + 0xf & 0xfffffff0;\n                            *(unaff_EBP + 0xc) = arg_10h;\n                            iVar1 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x41bfb4, 0, arg_10h);\n                            *(unaff_EBP + -0x1c) = iVar1;\n                            if (iVar1 != 0) {\n                                uVar2 = *(arg_ch_00 + -4) - 1;\n                                *(unaff_EBP + -0x24) = uVar2;\n                                if (arg_10h <= uVar2) {\n                                    uVar2 = arg_10h;\n                                }\n                                fcn.00404a30(*(unaff_EBP + -0x1c), arg_ch_00, uVar2);\n                                fcn.00409680(*(unaff_EBP + -0x20), arg_ch_00);\n                            }\n                        }\n                    }\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    fcn.0040a6dd();\n                    if (*(unaff_EBP + -0x20) == 0) {\n                        if (arg_10h == 0) {\n                            arg_10h = 1;\n                        }\n                        arg_10h = arg_10h + 0xf & 0xfffffff0;\n                        *(unaff_EBP + 0xc) = arg_10h;\n                        uVar3 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x41bfb4, 0, arg_ch_00, arg_10h);\n                        *(unaff_EBP + -0x1c) = uVar3;\n                    }\n                }\n            } while (((*(unaff_EBP + -0x1c) == 0) && (*0x41bd80 != 0)) && (iVar1 = fcn.00405c07(arg_10h),  iVar1 != 0));\n        }\n        else {\n            do {\n                iVar1 = 0;\n                if (arg_10h < 0xffffffe1) {\n                    if (arg_10h == 0) {\n                        arg_10h = 1;\n                    }\n                    iVar1 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x41bfb4, 0, arg_ch_00, arg_10h);\n                }\n            } while (((iVar1 == 0) && (*0x41bd80 != 0)) && (iVar1 = fcn.00405c07(arg_10h),  iVar1 != 0));\n        }\n    }\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 1267
    },
    "0040a722": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040a722(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00407c04(0x416af0, 0x10);\n    if (*0x41bfc4 == 3) {\n        fcn.0040953e(4);\n        *(unaff_EBP + -4) = 0;\n        iVar1 = *(unaff_EBP + 8);\n        iVar2 = fcn.00409655(iVar1);\n        *(unaff_EBP + -0x20) = iVar2;\n        if (iVar2 != 0) {\n            *(unaff_EBP + -0x1c) = *(iVar1 + -4) + -9;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0040a78f();\n        if (*(unaff_EBP + -0x20) != 0) goto code_r0x0040a784;\n    }\n    (*_sym.imp.KERNEL32.dll_HeapSize)(*0x41bfb4, 0, *(unaff_EBP + 8));\ncode_r0x0040a784:\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 327
    },
    "0040a7e8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040a7e8(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t arg_8h_00;\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00407c04(0x416b00, 0x10);\n    uVar2 = *(unaff_EBP + 8) * *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x20) = uVar2;\n    if (uVar2 == 0) {\n        uVar2 = 1;\n    }\n    do {\n        iVar3 = 0;\n        *(unaff_EBP + -0x1c) = 0;\n        if (uVar2 < 0xffffffe1) {\n            if (*0x41bfc4 == 3) {\n                uVar2 = uVar2 + 0xf & 0xfffffff0;\n                *(unaff_EBP + 0xc) = uVar2;\n                arg_8h_00 = *(unaff_EBP + -0x20);\n                if (*0x41bfa4 < arg_8h_00) goto code_r0x0040a85d;\n                fcn.0040953e(4);\n                *(unaff_EBP + -4) = 0;\n                uVar1 = fcn.0040a279(arg_8h_00);\n                *(unaff_EBP + -0x1c) = uVar1;\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.0040a892();\n                iVar3 = *(unaff_EBP + -0x1c);\n                if (iVar3 != 0) {\n                    fcn.004051e0(iVar3, 0, *(unaff_EBP + -0x20));\n                    goto code_r0x0040a85d;\n                }\n            }\n            else {\ncode_r0x0040a85d:\n                if (iVar3 != 0) {\ncode_r0x0040a89d:\n                    fcn.00407c3f();\n                    return;\n                }\n            }\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x41bfb4, 8, uVar2);\n        }\n        if (((iVar3 != 0) || (*0x41bd80 == 0)) || (iVar3 = fcn.00405c07(uVar2),  iVar3 == 0)) goto code_r0x0040a89d;\n    } while( true );\n}\n",
        "token_count": 620
    },
    "0040a8fe": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl\nfcn.0040a8fe(uint noname_0, uint noname_1, uint lpMultiByteStr, uint arg_14h_2, uint arg_8h, uint arg_ch, uint noname_6\n            , uint arg_14h)\n\n{\n    uchar *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uchar *arg_ch_00;\n    uint *arg_8h_00;\n    int32_t unaff_EBP;\n    uint CodePage;\n    uint var_4h;\n    uint var_48h_2;\n    uint var_54h;\n    uint cbMultiByte;\n    uint var_3ch_2;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_1ch;\n    uchar *var_18h;\n    uint var_4h_2;\n    uint uStack4;\n    \n    uStack4 = 0x38;\n    var_4h_2 = 0x416b10;\n    var_18h = 0x40a90a;\n    fcn.00407c04();\n    *(unaff_EBP + -0x1c) = *0x41ad6c;\n    *(unaff_EBP + -0x34) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    puVar1 = **(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x40) = puVar1;\n    *(unaff_EBP + -0x3c) = 0;\n    pcVar2 = _sym.imp.KERNEL32.dll_GetCPInfo;\n    if (*(unaff_EBP + 8) == *(unaff_EBP + 0xc)) {\n        arg_8h_00 = *(unaff_EBP + -0x48);\n    }\n    else {\n        var_18h = unaff_EBP + -0x30;\n        var_1ch = *(unaff_EBP + 8);\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetCPInfo)();\n        if ((((iVar3 != 0) && (*(unaff_EBP + -0x30) == 1)) &&\n            (iVar3 = (*pcVar2)(*(unaff_EBP + 0xc), unaff_EBP + -0x30),  iVar3 != 0)) && (*(unaff_EBP + -0x30) == 1)) {\n            *(unaff_EBP + -0x3c) = 1;\n        }\n        if (*(unaff_EBP + -0x3c) == 0) {\n            arg_ch_00 = *(unaff_EBP + -0x38);\n        }\n        else {\n            arg_ch_00 = puVar1;\n            if (puVar1 == 0xffffffff) {\n                iVar3 = fcn.004049a0(*(unaff_EBP + 0x10));\n                arg_ch_00 = iVar3 + 1;\n            }\n            *(unaff_EBP + -0x38) = arg_ch_00;\n        }\n        if (*(unaff_EBP + -0x3c) == 0) {\n            arg_ch_00 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                  (*(unaff_EBP + 8), 1, *(unaff_EBP + 0x10), puVar1, 0, 0);\n            *(unaff_EBP + -0x38) = arg_ch_00;\n            if (arg_ch_00 == NULL) goto code_r0x0040aab6;\n        }\n        arg_8h_00 = &fcn.0040a8fe::var_1ch;\n        *(unaff_EBP + -4) = 0;\n        fcn.00407d60();\n        *(unaff_EBP + -0x18) = &fcn.0040a8fe::var_1ch;\n        *(unaff_EBP + -0x48) = &fcn.0040a8fe::var_1ch;\n        fcn.004051e0(&fcn.0040a8fe::var_1ch, 0, arg_ch_00 * 2);\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*0x10 == 0x10) {\n            arg_8h_00 = fcn.0040a7e8(2, arg_ch_00);\n            if (arg_8h_00 == NULL) goto code_r0x0040aab6;\n            *(unaff_EBP + -0x44) = 1;\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                          (*(unaff_EBP + 8), 1, *(unaff_EBP + 0x10), *(unaff_EBP + -0x40), arg_8h_00, arg_ch_00);\n        if (iVar3 != 0) {\n            if (*(unaff_EBP + 0x18) == 0) {\n                if (*(unaff_EBP + -0x3c) == 0) {\n                    var_18h = NULL;\n                    var_1ch = 0;\n                    arg_ch_00 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                          (*(unaff_EBP + 0xc), 0, arg_8h_00, arg_ch_00, 0, 0);\n                    if (arg_ch_00 == NULL) goto code_r0x0040aaa7;\n                }\n                var_1ch = 1;\n                var_18h = arg_ch_00;\n                iVar3 = fcn.0040a7e8(1, arg_ch_00);\n                *(unaff_EBP + -0x34) = iVar3;\n                if (iVar3 != 0) {\n                    var_18h = NULL;\n                    var_1ch = 0;\n                    iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                      (*(unaff_EBP + 0xc), 0, arg_8h_00, arg_ch_00, iVar3, arg_ch_00);\n                    if (iVar3 == 0) {\n                        var_18h = *(unaff_EBP + -0x34);\n                        var_1ch = 0x40aa91;\n                        fcn.00406cec(var_18h);\n                        *(unaff_EBP + -0x34) = 0;\n                    }\n                    else if (*(unaff_EBP + -0x40) != -1) {\n                        **(unaff_EBP + 0x14) = iVar3;\n                    }\n                }\n            }\n            else {\n                var_18h = NULL;\n                var_1ch = 0;\n                iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                  (*(unaff_EBP + 0xc), 0, arg_8h_00, arg_ch_00, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c)\n                                  );\n                if (iVar3 != 0) {\n                    *(unaff_EBP + -0x34) = *(unaff_EBP + 0x18);\n                }\n            }\n        }\n    }\ncode_r0x0040aaa7:\n    if (*(unaff_EBP + -0x44) != 0) {\n        var_1ch = 0x40aab2;\n        var_18h = arg_8h_00;\n        fcn.00406cec(arg_8h_00);\n    }\ncode_r0x0040aab6:\n    *(unaff_EBP + -0x58) = 0x40aac1;\n    fcn.0040cd9b();\n    *(unaff_EBP + -0x58) = 0x40aac6;\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 1860
    },
    "0040aedd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040aedd(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h)\n\n{\n    char in_AL;\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t *unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    uint noname_1;\n    \n    if (in_AL < '[') {\n        if (in_AL == 'Z') {\ncode_r0x0040b0ce:\n            fcn.0040e3aa();\ncode_r0x0040b133:\n            fcn.0040ae0e();\n            return 1;\n        }\n        if (in_AL < 'N') {\n            if (in_AL != 'M') {\n                if (in_AL == '%') {\n                    **in_ECX = 0x25;\n                    *in_ECX = *in_ECX + 1;\n                    *unaff_EBX = *unaff_EBX + -1;\n                    return 1;\n                }\n                if ((in_AL == 'A') || (in_AL == 'B')) goto code_r0x0040b133;\n                if ((in_AL != 'H') && (in_AL != 'I')) {\n                    return 1;\n                }\n            }\ncode_r0x0040afa5:\n            fcn.0040ae64(arg_14h);\n            return 1;\n        }\n        if (((in_AL == 'S') || (in_AL == 'U')) || (in_AL == 'W')) goto code_r0x0040afa5;\n        if (in_AL != 'X') {\n            if (in_AL != 'Y') {\n                return 1;\n            }\n            goto code_r0x0040afa5;\n        }\n    }\n    else {\n        if ('m' < in_AL) {\n            if (in_AL == 'p') goto code_r0x0040b133;\n            if (in_AL == 'w') goto code_r0x0040afa5;\n            if (in_AL == 'x') {\n                if (arg_14h == 0) {\n                    noname_1 = 0;\n                }\n                else {\n                    noname_1 = 1;\n                }\n                goto code_r0x0040afba;\n            }\n            if (in_AL == 'y') goto code_r0x0040afa5;\n            if (in_AL != 'z') {\n                return 1;\n            }\n            goto code_r0x0040b0ce;\n        }\n        if (in_AL == 'm') goto code_r0x0040afa5;\n        if ((in_AL == 'a') || (in_AL == 'b')) goto code_r0x0040b133;\n        if (in_AL != 'c') {\n            if ((in_AL != 'd') && (in_AL != 'j')) {\n                return 1;\n            }\n            goto code_r0x0040afa5;\n        }\n        iVar1 = fcn.0040b143(arg_8h, arg_14h != 0, arg_ch, in_ECX, unaff_EBX, arg_10h, unaff_EDI, unaff_ESI, unaff_EBP, \n                             unaff_retaddr, arg_8h, arg_ch, arg_10h, arg_14h);\n        if (iVar1 == 0) {\n            return 0;\n        }\n        if (*unaff_EBX == 0) {\n            return 0;\n        }\n        **in_ECX = 0x20;\n        *in_ECX = *in_ECX + 1;\n        *unaff_EBX = *unaff_EBX + -1;\n    }\n    noname_1 = 2;\ncode_r0x0040afba:\n    iVar1 = fcn.0040b143(arg_8h, noname_1, arg_ch, in_ECX, unaff_EBX, arg_10h, unaff_EDI, unaff_ESI, unaff_EBP, \n                         unaff_retaddr, arg_8h, arg_ch, arg_10h, arg_14h);\n    if (iVar1 != 0) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 939
    },
    "0040b143": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_42h\n\nvoid __cdecl\nfcn.0040b143(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint8_t uVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    uint32_t *puVar4;\n    uint8_t **ppuVar5;\n    uint uVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    uint *arg_8h_00;\n    char *pcVar9;\n    int32_t iVar10;\n    char cVar11;\n    uint8_t *puVar12;\n    uint32_t uVar13;\n    uint32_t uVar14;\n    ushort *puVar15;\n    int32_t unaff_EBP;\n    uint var_19h;\n    uint var_10h;\n    uint var_14h;\n    uint var_18h_2;\n    uint var_4h;\n    uint var_54h_2;\n    uint var_48h_2;\n    uint var_42h_2;\n    uint var_38h;\n    uint var_54h;\n    uint var_30h_2;\n    uint var_2ch_2;\n    uint var_48h;\n    uint var_42h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    \n    var_20h = 0x38;\n    var_24h = 0x416c58;\n    fcn.00407c04();\n    if (*(unaff_EBP + 0xc) == 0) {\n        uVar6 = *(*(unaff_EBP + 0x1c) + 0xa0);\n    }\n    else if (*(unaff_EBP + 0xc) == 1) {\n        uVar6 = *(*(unaff_EBP + 0x1c) + 0xa4);\n    }\n    else {\n        uVar6 = *(*(unaff_EBP + 0x1c) + 0xa8);\n    }\n    *(unaff_EBP + -0x20) = uVar6;\n    if (*(*(unaff_EBP + 0x1c) + 0xb0) == 1) {\n        puVar15 = *(unaff_EBP + 0x10);\n    }\n    else {\n        pcVar7 = _sym.imp.KERNEL32.dll_GetDateFormatA;\n        if (*(unaff_EBP + 0xc) == 2) {\n            pcVar7 = _sym.imp.KERNEL32.dll_GetTimeFormatA;\n        }\n        *(unaff_EBP + -0x30) = pcVar7;\n        puVar15 = *(unaff_EBP + 0x10);\n        *(unaff_EBP + -0x48) = puVar15[10] + 0x76c;\n        *(unaff_EBP + -0x46) = puVar15[8] + 1;\n        *(unaff_EBP + -0x42) = puVar15[6];\n        *(unaff_EBP + -0x40) = puVar15[4];\n        *(unaff_EBP + -0x3e) = puVar15[2];\n        *(unaff_EBP + -0x3c) = *puVar15;\n        *(unaff_EBP + -0x3a) = 0;\n        arg_8h_00 = &fcn.0040b143::var_24h;\n        iVar8 = (*pcVar7)(*(*(unaff_EBP + 0x1c) + 0xac), 0, unaff_EBP + -0x48, *(unaff_EBP + -0x20), 0, 0);\n        *(unaff_EBP + -0x2c) = iVar8;\n        if (iVar8 != 0) {\n            *(unaff_EBP + -0x34) = 0;\n            *(unaff_EBP + -4) = 0;\n            fcn.00407d60();\n            *(unaff_EBP + -0x18) = &fcn.0040b143::var_24h;\n            *(unaff_EBP + -0x38) = &fcn.0040b143::var_24h;\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x8) {\n                arg_8h_00 = fcn.00405bcb(*(unaff_EBP + -0x2c));\n                if (arg_8h_00 == NULL) goto code_r0x0040b2a3;\n                *(unaff_EBP + -0x34) = 1;\n            }\n            *(unaff_EBP + -0x24) = arg_8h_00;\n            iVar8 = (**(unaff_EBP + -0x30))\n                              (*(*(unaff_EBP + 0x1c) + 0xac), 0, unaff_EBP + -0x48, *(unaff_EBP + -0x20), arg_8h_00, \n                               *(unaff_EBP + -0x2c));\n            iVar8 = iVar8 + -1;\n            if (0 < iVar8) {\n                piVar2 = *(unaff_EBP + 0x18);\n                piVar3 = *(unaff_EBP + 0x14);\n                do {\n                    if (*piVar2 == 0) break;\n                    **piVar3 = **(unaff_EBP + -0x24);\n                    *piVar3 = *piVar3 + 1;\n                    *(unaff_EBP + -0x24) = *(unaff_EBP + -0x24) + 1;\n                    *piVar2 = *piVar2 + -1;\n                    iVar8 = iVar8 + -1;\n                } while (0 < iVar8);\n            }\n            if (*(unaff_EBP + -0x34) != 0) {\n                fcn.00406cec(arg_8h_00);\n            }\n            goto code_r0x0040b297;\n        }\n    }\ncode_r0x0040b2a3:\n    cVar11 = **(unaff_EBP + -0x20);\n    if (cVar11 != '\\0') {\n        puVar4 = *(unaff_EBP + 0x18);\n        ppuVar5 = *(unaff_EBP + 0x14);\n        while (*puVar4 != 0) {\n            *(unaff_EBP + -0x19) = 0;\n            *(unaff_EBP + -0x28) = 0;\n            pcVar9 = *(unaff_EBP + -0x20);\n            uVar14 = 0;\n            do {\n                uVar13 = uVar14;\n                pcVar9 = pcVar9 + 1;\n                uVar14 = uVar13 + 1;\n            } while (*pcVar9 == cVar11);\n            *(unaff_EBP + -0x24) = pcVar9;\n            if (cVar11 < 'e') {\n                if (cVar11 == 'd') {\n                    if (uVar13 == 0) {\n                        *(unaff_EBP + -0x28) = 1;\n                    }\n                    else if (uVar13 != 1) {\n                        if (uVar13 == 2) {\n                            *(unaff_EBP + -0x19) = 0x61;\n                        }\n                        else if (uVar13 == 3) {\n                            *(unaff_EBP + -0x19) = 0x41;\n                        }\n                        goto code_r0x0040b55b;\n                    }\n                    *(unaff_EBP + -0x19) = 100;\n                    goto code_r0x0040b55b;\n                }\n                if (cVar11 != '\\'') {\n                    if (cVar11 != 'A') {\n                        if (cVar11 == 'H') {\n                            if (uVar13 == 0) {\n                                *(unaff_EBP + -0x28) = 1;\n                            }\n                            else if (uVar14 != 2) goto code_r0x0040b55b;\n                            *(unaff_EBP + -0x19) = 0x48;\n                        }\n                        else if (cVar11 == 'M') {\n                            if (uVar13 == 0) {\n                                *(unaff_EBP + -0x28) = 1;\n                            }\n                            else if (uVar13 != 1) {\n                                if (uVar13 == 2) {\n                                    *(unaff_EBP + -0x19) = 0x62;\n                                }\n                                else if (uVar13 == 3) {\n                                    *(unaff_EBP + -0x19) = 0x42;\n                                }\n                                goto code_r0x0040b55b;\n                            }\n                            *(unaff_EBP + -0x19) = 0x6d;\n                        }\n                        else if (cVar11 == 'a') goto code_r0x0040b304;\n                        goto code_r0x0040b55b;\n                    }\ncode_r0x0040b304:\n                    iVar8 = *(unaff_EBP + -0x20);\n                    iVar10 = fcn.0040e470(iVar8, \"am/pm\");\n                    if (iVar10 == 0) {\n                        iVar8 = iVar8 + 5;\ncode_r0x0040b382:\n                        *(unaff_EBP + -0x24) = iVar8;\n                    }\n                    else {\n                        iVar10 = fcn.0040e470(iVar8, 0x416c48);\n                        if (iVar10 == 0) {\n                            iVar8 = iVar8 + 3;\n                            goto code_r0x0040b382;\n                        }\n                    }\n                    *(unaff_EBP + -0x19) = 0x70;\n                    goto code_r0x0040b55b;\n                }\n                *(unaff_EBP + -0x20) = *(unaff_EBP + -0x20) + uVar14;\n                if ((uVar14 & 1) != 0) {\n                    puVar12 = *(unaff_EBP + -0x20);\n                    while( true ) {\n                        uVar1 = *puVar12;\n                        if ((uVar1 == 0) || (*puVar4 == 0)) goto code_r0x0040b5bb;\n                        if (uVar1 == 0x27) break;\n                        if (((*(*(*(unaff_EBP + 8) + 0x48) + 1 + uVar1 * 2) & 0x80) == 0) || (*puVar4 < 2)) {\n                            puVar12 = *(unaff_EBP + -0x20);\n                        }\n                        else {\n                            puVar12 = *(unaff_EBP + -0x20) + 1;\n                            if (*puVar12 == 0) goto code_r0x0040b297;\n                            **ppuVar5 = uVar1;\n                            *ppuVar5 = *ppuVar5 + 1;\n                            *puVar4 = *puVar4 - 1;\n                        }\n                        **ppuVar5 = *puVar12;\n                        *ppuVar5 = *ppuVar5 + 1;\n                        puVar12 = puVar12 + 1;\n                        *(unaff_EBP + -0x20) = puVar12;\n                        *puVar4 = *puVar4 - 1;\n                    }\n                    *(unaff_EBP + -0x20) = *(unaff_EBP + -0x20) + 1;\n                }\n            }\n            else {\n                if (cVar11 == 'h') {\n                    if (uVar13 == 0) {\n                        *(unaff_EBP + -0x28) = 1;\n                    }\n                    else if (uVar14 != 2) goto code_r0x0040b55b;\n                    *(unaff_EBP + -0x19) = 0x49;\ncode_r0x0040b55b:\n                    if (*(unaff_EBP + -0x19) == '\\0') {\n                        puVar12 = *(unaff_EBP + -0x20);\n                        uVar1 = *puVar12;\n                        if (((*(*(*(unaff_EBP + 8) + 0x48) + 1 + uVar1 * 2) & 0x80) != 0) && (1 < *puVar4)) {\n                            puVar12 = puVar12 + 1;\n                            if (*puVar12 == 0) break;\n                            **ppuVar5 = uVar1;\n                            *ppuVar5 = *ppuVar5 + 1;\n                            *puVar4 = *puVar4 - 1;\n                        }\n                        **ppuVar5 = *puVar12;\n                        *ppuVar5 = *ppuVar5 + 1;\n                        *(unaff_EBP + -0x20) = puVar12 + 1;\n                        *puVar4 = *puVar4 - 1;\n                        goto code_r0x0040b5bb;\n                    }\n                    iVar8 = fcn.0040aedd(*(unaff_EBP + 8), *(unaff_EBP + 0x10), *(unaff_EBP + 0x1c), \n                                         *(unaff_EBP + -0x28));\n                    if (iVar8 == 0) break;\n                }\n                else {\n                    if (cVar11 == 'm') {\n                        if (uVar13 == 0) {\n                            *(unaff_EBP + -0x28) = 1;\n                        }\n                        else if (uVar14 != 2) goto code_r0x0040b55b;\n                        *(unaff_EBP + -0x19) = 0x4d;\n                        goto code_r0x0040b55b;\n                    }\n                    if (cVar11 == 's') {\n                        if (uVar13 == 0) {\n                            *(unaff_EBP + -0x28) = 1;\n                        }\n                        else if (uVar14 != 2) goto code_r0x0040b55b;\n                        *(unaff_EBP + -0x19) = 0x53;\n                        goto code_r0x0040b55b;\n                    }\n                    if (cVar11 != 't') {\n                        if (cVar11 == 'y') {\n                            if (uVar13 == 1) {\n                                *(unaff_EBP + -0x19) = 0x79;\n                            }\n                            else if (uVar13 == 3) {\n                                *(unaff_EBP + -0x19) = 0x59;\n                            }\n                        }\n                        goto code_r0x0040b55b;\n                    }\n                    if (*(puVar15 + 4) < 0xc) {\n                        puVar12 = *(*(unaff_EBP + 0x1c) + 0x98);\n                    }\n                    else {\n                        puVar12 = *(*(unaff_EBP + 0x1c) + 0x9c);\n                    }\n                    if ((uVar14 == 1) && (*puVar4 != 0)) {\n                        uVar1 = *puVar12;\n                        if (((*(*(*(unaff_EBP + 8) + 0x48) + 1 + uVar1 * 2) & 0x80) != 0) && (1 < *puVar4)) {\n                            puVar12 = puVar12 + 1;\n                            if (*puVar12 == 0) break;\n                            **ppuVar5 = uVar1;\n                            *ppuVar5 = *ppuVar5 + 1;\n                            *puVar4 = *puVar4 - 1;\n                        }\n                        **ppuVar5 = *puVar12;\n                        *ppuVar5 = *ppuVar5 + 1;\n                        *puVar4 = *puVar4 - 1;\n                    }\n                    else {\n                        while( true ) {\n                            uVar1 = *puVar12;\n                            if ((uVar1 == 0) || (*puVar4 == 0)) break;\n                            if (((*(*(*(unaff_EBP + 8) + 0x48) + 1 + uVar1 * 2) & 0x80) != 0) && (1 < *puVar4)) {\n                                puVar12 = puVar12 + 1;\n                                if (*puVar12 == 0) goto code_r0x0040b297;\n                                **ppuVar5 = uVar1;\n                                *ppuVar5 = *ppuVar5 + 1;\n                                *puVar4 = *puVar4 - 1;\n                            }\n                            **ppuVar5 = *puVar12;\n                            *ppuVar5 = *ppuVar5 + 1;\n                            puVar12 = puVar12 + 1;\n                            *puVar4 = *puVar4 - 1;\n                        }\n                    }\n                }\n                *(unaff_EBP + -0x20) = *(unaff_EBP + -0x24);\n            }\ncode_r0x0040b5bb:\n            cVar11 = **(unaff_EBP + -0x20);\n            if (cVar11 == '\\0') break;\n            puVar15 = *(unaff_EBP + 0x10);\n        }\n    }\ncode_r0x0040b297:\n    *(unaff_EBP + -0x58) = 0x40b29f;\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 4057
    },
    "0040b5cd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl\nfcn.0040b5cd(int32_t arg_8h, uint8_t *arg_ch, uint32_t arg_10h, uint8_t *arg_14h, uint arg_18h, uint32_t arg_1ch)\n\n{\n    uint8_t uVar1;\n    int32_t arg_10h_00;\n    int32_t iVar2;\n    uint8_t *puVar3;\n    bool bVar4;\n    uint var_4h;\n    \n    arg_10h_00 = arg_1ch;\n    if (arg_1ch == 0) {\n        arg_10h_00 = *(arg_8h + 0x4c);\n    }\n    if (arg_10h != 0) {\n        arg_1ch = arg_10h;\n        if (arg_10h == 0) {\ncode_r0x0040b67c:\n            bVar4 = arg_1ch == 0;\n        }\n        else {\n            do {\n                uVar1 = *arg_14h;\n                if (uVar1 == 0) break;\n                if (uVar1 == 0x25) {\n                    puVar3 = arg_14h + 1;\n                    uVar1 = *puVar3;\n                    if (uVar1 == 0x23) {\n                        puVar3 = arg_14h + 2;\n                    }\n                    iVar2 = fcn.0040aedd(arg_8h, arg_18h, arg_10h_00, uVar1 == 0x23);\n                    if (iVar2 == 0) goto code_r0x0040b67c;\n                }\n                else {\n                    if (((*(*(arg_8h + 0x48) + 1 + uVar1 * 2) & 0x80) != 0) && (1 < arg_1ch)) {\n                        arg_14h = arg_14h + 1;\n                        if (*arg_14h == 0) goto code_r0x0040b67c;\n                        *arg_ch = uVar1;\n                        arg_ch = arg_ch + 1;\n                        arg_1ch = arg_1ch - 1;\n                    }\n                    *arg_ch = *arg_14h;\n                    arg_ch = arg_ch + 1;\n                    arg_1ch = arg_1ch - 1;\n                    puVar3 = arg_14h;\n                }\n                arg_14h = puVar3 + 1;\n            } while (arg_1ch != 0);\n            bVar4 = arg_1ch == 0;\n            if (!bVar4) {\n                *arg_ch = 0;\n                return arg_10h - arg_1ch;\n            }\n        }\n        if (bVar4) {\n            arg_ch = arg_ch + -1;\n        }\n        *arg_ch = 0;\n        arg_10h = 0;\n    }\n    return arg_10h;\n}\n",
        "token_count": 653
    },
    "0040bcd9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0040bcd9(void)\n\n{\n    char *pcVar1;\n    char cVar2;\n    int32_t *arg_8h;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    char *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint *arg_14h;\n    uint *puVar8;\n    uint32_t uVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((*0x41bd94 == 0) && (*0x41bd90 == 0)) {\n        if (((*0x41bf74 != NULL) && (**0x41bf74 == 0)) && (*0x41bf74 != *(*0x41addc + 0x2c))) {\n            fcn.00406cec(*0x41bf74);\n            fcn.00406cec(*0x41bdac);\n        }\n        *0x41bf78 = NULL;\n        *0x41bf74 = NULL;\n        arg_14h = 0x41b39c;\n        *0x41bdac = NULL;\n        puVar8 = *0x41bdac;\n        arg_8h = *0x41bf74;\ncode_r0x0040be86:\n        *0x41bf74 = arg_8h;\n        *0x41bdac = puVar8;\n        *0x41b3d4 = **arg_14h;\n        *0x41b3d8 = 1;\n        uVar6 = 0;\n        *0x41b3cc = arg_14h;\n    }\n    else {\n        arg_14h = fcn.0040a7e8(1, 0x30);\n        if (arg_14h != NULL) {\n            puVar8 = *0x41b3cc;\n            puVar11 = arg_14h;\n            for (iVar7 = 0xc; iVar7 != 0; iVar7 = iVar7 + -1) {\n                *puVar11 = *puVar8;\n                puVar8 = puVar8 + 1;\n                puVar11 = puVar11 + 1;\n            }\n            arg_8h = fcn.00405bcb(4);\n            if (arg_8h != NULL) {\n                *arg_8h = 0;\n                if (*0x41bd94 == 0) {\n                    *0x41bf78 = NULL;\n                    *arg_14h = *0x41b39c;\n                    arg_14h[1] = *0x41b3a0;\n                    arg_14h[2] = *0x41b3a4;\n                }\n                else {\n                    *0x41bf78 = fcn.00405bcb(4);\n                    if (*0x41bf78 == NULL) {\n                        uVar6 = 1;\ncode_r0x0040bde4:\n                        fcn.00406cec(arg_14h);\n                        fcn.00406cec(arg_8h);\n                        return uVar6;\n                    }\n                    **0x41bf78 = 0;\n                    uVar9 = *0x41bdf2;\n                    uVar3 = fcn.0040e4be(1, uVar9, 0xe, arg_14h);\n                    uVar4 = fcn.0040e4be(1, uVar9, 0xf, arg_14h + 1);\n                    uVar9 = fcn.0040e4be(1, uVar9, 0x10, arg_14h + 2);\n                    if ((uVar9 | uVar3 | uVar4) != 0) {\n                        fcn.0040bc7a(arg_14h);\n                        uVar6 = 0xffffffff;\n                        goto code_r0x0040bde4;\n                    }\n                    pcVar5 = arg_14h[2];\n                    while (*pcVar5 != '\\0') {\n                        cVar2 = *pcVar5;\n                        if ((cVar2 < '0') || ('9' < cVar2)) {\n                            pcVar10 = pcVar5;\n                            if (cVar2 != ';') goto code_r0x0040be10;\n                            do {\n                                pcVar1 = pcVar10 + 1;\n                                *pcVar10 = *pcVar1;\n                                pcVar10 = pcVar1;\n                            } while (*pcVar1 != '\\0');\n                        }\n                        else {\n                            *pcVar5 = cVar2 + -0x30;\ncode_r0x0040be10:\n                            pcVar5 = pcVar5 + 1;\n                        }\n                    }\n                }\n                puVar8 = arg_14h;\n                if (((*0x41bf74 != NULL) && (**0x41bf74 == 0)) && (*0x41bf74 != *(*0x41addc + 0x2c))) {\n                    fcn.00406cec(*0x41bf74);\n                    fcn.00406cec(*0x41bdac);\n                }\n                goto code_r0x0040be86;\n            }\n            fcn.00406cec(arg_14h);\n        }\n        uVar6 = 1;\n    }\n    return uVar6;\n}\n",
        "token_count": 1175
    },
    "0040bfb2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0040bfb2(void)\n\n{\n    char *pcVar1;\n    char cVar2;\n    uint *arg_8h;\n    uint *arg_8h_00;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    uint32_t uVar12;\n    uint32_t uVar13;\n    uint32_t uVar14;\n    uint32_t uVar15;\n    uint32_t uVar16;\n    char *pcVar17;\n    uint uVar18;\n    int32_t iVar19;\n    uint32_t uVar20;\n    char *pcVar21;\n    uint *puVar22;\n    uint *puVar23;\n    uint var_4h;\n    \n    if ((*0x41bd90 == 0) && (*0x41bd94 == 0)) {\n        *0x41bf64 = NULL;\n        *0x41bf74 = NULL;\n        *0x41b3cc = 0x41b39c;\n        *0x41bdac = NULL;\ncode_r0x0040c1ea:\n        uVar18 = 0;\n    }\n    else {\n        arg_8h = fcn.0040a7e8(1, 0x30);\n        if (arg_8h != NULL) {\n            arg_8h_00 = fcn.00405bcb(4);\n            if (arg_8h_00 == NULL) {\n                fcn.00406cec(arg_8h);\n            }\n            else {\n                *arg_8h_00 = 0;\n                if (*0x41bd90 == 0) {\n                    puVar22 = 0x41b39c;\n                    puVar23 = arg_8h;\n                    for (iVar19 = 0xc; iVar19 != 0; iVar19 = iVar19 + -1) {\n                        *puVar23 = *puVar22;\n                        puVar22 = puVar22 + 1;\n                        puVar23 = puVar23 + 1;\n                    }\n                    *0x41bf64 = NULL;\ncode_r0x0040c1b7:\n                    *arg_8h = **0x41b3cc;\n                    arg_8h[1] = (*0x41b3cc)[1];\n                    arg_8h[2] = (*0x41b3cc)[2];\n                    *0x41b3cc = arg_8h;\n                    *0x41bdac = arg_8h;\n                    *0x41bf74 = arg_8h_00;\n                    goto code_r0x0040c1ea;\n                }\n                *0x41bf64 = fcn.00405bcb(4);\n                if (*0x41bf64 == NULL) {\n                    fcn.00406cec(arg_8h);\n                    fcn.00406cec(arg_8h_00);\n                }\n                else {\n                    **0x41bf64 = 0;\n                    uVar20 = *0x41bdec;\n                    uVar3 = fcn.0040e4be(1, uVar20, 0x15, arg_8h + 3);\n                    uVar4 = fcn.0040e4be(1, uVar20, 0x14, arg_8h + 4);\n                    uVar5 = fcn.0040e4be(1, uVar20, 0x16, arg_8h + 5);\n                    uVar6 = fcn.0040e4be(1, uVar20, 0x17, arg_8h + 6);\n                    uVar7 = fcn.0040e4be(1, uVar20, 0x18, arg_8h + 7);\n                    uVar8 = fcn.0040e4be(1, uVar20, 0x50, arg_8h + 8);\n                    uVar9 = fcn.0040e4be(1, uVar20, 0x51, arg_8h + 9);\n                    uVar10 = fcn.0040e4be(0, uVar20, 0x1a, arg_8h + 10);\n                    uVar11 = fcn.0040e4be(0, uVar20, 0x19, arg_8h + 0x29);\n                    uVar12 = fcn.0040e4be(0, uVar20, 0x54, arg_8h + 0x2a);\n                    uVar13 = fcn.0040e4be(0, uVar20, 0x55, arg_8h + 0x2b);\n                    uVar14 = fcn.0040e4be(0, uVar20, 0x56, arg_8h + 0xb);\n                    uVar15 = fcn.0040e4be(0, uVar20, 0x57, arg_8h + 0x2d);\n                    uVar16 = fcn.0040e4be(0, uVar20, 0x52, arg_8h + 0x2e);\n                    uVar20 = fcn.0040e4be(0, uVar20, 0x53, arg_8h + 0x2f);\n                    if ((uVar20 | uVar3 | uVar4 | uVar5 | uVar6 | uVar7 | uVar8 | uVar9 | uVar10 | uVar11 | uVar12 |\n                                  uVar13 | uVar14 | uVar15 | uVar16) == 0) {\n                        pcVar17 = arg_8h[7];\n                        while (*pcVar17 != '\\0') {\n                            cVar2 = *pcVar17;\n                            if ((cVar2 < '0') || ('9' < cVar2)) {\n                                pcVar21 = pcVar17;\n                                if (cVar2 != ';') goto code_r0x0040c185;\n                                do {\n                                    pcVar1 = pcVar21 + 1;\n                                    *pcVar21 = *pcVar1;\n                                    pcVar21 = pcVar1;\n                                } while (*pcVar1 != '\\0');\n                            }\n                            else {\n                                *pcVar17 = cVar2 + -0x30;\ncode_r0x0040c185:\n                                pcVar17 = pcVar17 + 1;\n                            }\n                        }\n                        goto code_r0x0040c1b7;\n                    }\n                    fcn.0040bed9(arg_8h);\n                    fcn.00406cec(arg_8h);\n                    fcn.00406cec(arg_8h_00);\n                }\n            }\n        }\n        uVar18 = 1;\n    }\n    return uVar18;\n}\n",
        "token_count": 1546
    },
    "0040c1f1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_12h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040c1f1(void)\n\n{\n    uint8_t *puVar1;\n    char16_t *noname_3;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint8_t *puVar4;\n    uint32_t uVar5;\n    ushort *puVar6;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    int32_t var_24h;\n    uint *var_20h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    uchar auStack24 [2];\n    uint var_12h;\n    uint var_4h;\n    \n    var_4h = *0x41ad6c;\n    var_1ch = 0;\n    if (*0x41bd8c == 0) {\n        *0x41b390 = \n        L\"         (((((                  H\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x81\\x81\\x81\\x81\\x81\\x81\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x10\\x10\\x10\\x10\\x10\\x10\\x82\\x82\\x82\\x82\\x82\\x82\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x10\\x10\\x10\\x10 \"\n        ;\n        *0x41bf60 = NULL;\n        *0x41bf50 = NULL;\n        goto code_r0x0040c3d0;\n    }\n    if ((*0x41bd9c == 0) && (iVar3 = fcn.0040e4be(0, *0x41bde4, 0x1004, 0x41bd9c),  iVar3 != 0)) {\ncode_r0x0040c3a3:\n        fcn.00406cec(var_20h);\n        fcn.00406cec(var_24h);\n    }\n    else {\n        var_20h = fcn.00405bcb(4);\n        var_24h = fcn.00405bcb(0x300);\n        var_1ch = fcn.00405bcb(0x101);\n        if ((var_20h == NULL) || ((var_24h == 0 || (var_1ch == 0)))) goto code_r0x0040c3a3;\n        *var_20h = 0;\n        iVar3 = 0;\n        do {\n            *(iVar3 + var_1ch) = iVar3;\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < 0x100);\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetCPInfo)(*0x41bd9c, &var_18h);\n        if ((iVar3 == 0) || (5 < var_18h)) goto code_r0x0040c3a3;\n        *0x41b3d0 = var_18h & 0xffff;\n        if ((1 < *0x41b3d0) && (var_12h != '\\0')) {\n            puVar4 = &var_12h + 1;\n            do {\n                uVar2 = *puVar4;\n                if (uVar2 == 0) break;\n                for (uVar5 = puVar4[-1]; uVar5 <= uVar2; uVar5 = uVar5 + 1) {\n                    *(uVar5 + var_1ch) = 0;\n                    uVar2 = *puVar4;\n                }\n                puVar1 = puVar4 + 1;\n                puVar4 = puVar4 + 2;\n            } while (*puVar1 != 0);\n        }\n        noname_3 = var_24h + 0x100;\n        iVar3 = fcn.0040ce68(1, var_1ch, 0x100, noname_3, 0, 0, 0, unaff_ESI, unaff_EBX, unaff_EDI, noname_3, var_20h, \n                             var_1ch, var_18h, _auStack24);\n        if (iVar3 == 0) goto code_r0x0040c3a3;\n        *(var_24h + 0xfe) = 0;\n        if ((1 < *0x41b3d0) && (var_12h != '\\0')) {\n            puVar4 = &var_12h + 1;\n            do {\n                if (*puVar4 == 0) break;\n                uVar5 = puVar4[-1];\n                if (uVar5 <= *puVar4) {\n                    puVar6 = var_24h + 0x100 + uVar5 * 2;\n                    do {\n                        *puVar6 = 0x8000;\n                        uVar5 = uVar5 + 1;\n                        puVar6 = puVar6 + 1;\n                    } while (uVar5 <= *puVar4);\n                }\n                puVar1 = puVar4 + 1;\n                puVar4 = puVar4 + 2;\n            } while (*puVar1 != 0);\n        }\n        fcn.00404a30(var_24h, var_24h + 0x200, 0xfe);\n        *0x41b390 = noname_3;\n        *0x41bf50 = var_24h + 0xfe;\n        *0x41bf60 = var_20h;\n    }\n    fcn.00406cec(var_1ch);\ncode_r0x0040c3d0:\n    fcn.0040cd9b();\n    return;\n}\n",
        "token_count": 1440
    },
    "0040c4f0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040c4f0(uint *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint var_ch;\n    uint var_4h;\n    \n    var_4h = *0x41ad6c;\n    if ((param_1 == NULL) || (*param_1 == '\\0')) {\ncode_r0x0040c536:\n        uVar2 = 0x1004;\ncode_r0x0040c541:\n        iVar1 = (**0x41bdd0)(*0x41bdb8, uVar2, &var_ch, 8);\n        if (iVar1 == 0) goto code_r0x0040c55b;\n        param_1 = &var_ch;\n    }\n    else {\n        iVar1 = fcn.00409570(param_1, 0x417f70);\n        if (iVar1 == 0) goto code_r0x0040c536;\n        iVar1 = fcn.00409570(param_1, 0x417f6c);\n        if (iVar1 == 0) {\n            uVar2 = 0xb;\n            goto code_r0x0040c541;\n        }\n    }\n    fcn.00404e00(param_1);\ncode_r0x0040c55b:\n    fcn.0040cd9b();\n    return;\n}\n",
        "token_count": 302
    },
    "0040c584": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040c584(uint32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    \n    iVar5 = 0;\n    iVar6 = 0x1a;\n    do {\n        iVar2 = (iVar6 + iVar5) / 2;\n        uVar1 = *(iVar2 * 0x2c + 0x417170);\n        if (arg_8h == uVar1) {\n            if (arg_ch == 1) {\n                pcVar4 = \"040a\" + iVar2 * 0x2c;\n            }\n            else if (arg_ch == 3) {\n                pcVar4 = iVar2 * 0x2c + 0x417180;\n            }\n            else if (arg_ch == 7) {\n                pcVar4 = iVar2 * 0x2c + 0x417188;\n            }\n            else if (arg_ch == 0xb) {\n                pcVar4 = iVar2 * 0x2c + 0x41718c;\n            }\n            else if (arg_ch == 0x1001) {\n                pcVar4 = *(iVar2 * 0x2c + 0x41717c);\n            }\n            else if (arg_ch == 0x1002) {\n                pcVar4 = *(iVar2 * 0x2c + 0x417184);\n            }\n            else {\n                if (arg_ch != 0x1004) break;\n                pcVar4 = iVar2 * 0x2c + 0x417194;\n            }\n            if ((pcVar4 != NULL) && (0 < arg_14h)) {\n                fcn.00407da0(arg_10h, pcVar4, arg_14h + -1);\n                *(arg_10h + -1 + arg_14h) = 0;\n                return 1;\n            }\n            break;\n        }\n        if (arg_8h < uVar1) {\n            iVar6 = iVar2 + -1;\n        }\n        else {\n            iVar5 = iVar2 + 1;\n        }\n    } while (iVar5 <= iVar6);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return uVar3;\n}\n",
        "token_count": 568
    },
    "0040c74d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040c74d(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint var_7ch;\n    uint var_4h;\n    \n    var_4h = *0x41ad6c;\n    iVar1 = (**0x41bdd0)(arg_8h & 0x3ff | 0x400, 1, &var_7ch, 0x78);\n    if (((iVar1 != 0) && (uVar2 = fcn.0040c667(),  arg_8h != uVar2)) && (arg_ch != 0)) {\n        fcn.004049a0(*0x41bdcc);\n        fcn.0040c69c();\n    }\n    fcn.0040cd9b();\n    return;\n}\n",
        "token_count": 195
    },
    "0040c9d8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040c9d8(uint arg_8h)\n\n{\n    uint arg_8h_00;\n    int32_t iVar1;\n    uint var_7ch;\n    uint var_4h;\n    \n    var_4h = *0x41ad6c;\n    arg_8h_00 = fcn.0040c667();\n    iVar1 = (**0x41bdd0)(arg_8h_00, (-(*0x41bdbc != 0) & 0xfffff002) + 0x1001, &var_7ch, 0x78);\n    if (iVar1 == 0) {\n        *0x41bdb0 = 0;\n        goto code_r0x0040ca96;\n    }\n    iVar1 = fcn.0040e5e5(*0x41bdcc, &var_7ch);\n    if (iVar1 == 0) {\n        if (*0x41bdbc == 0) {\n            iVar1 = 1;\n            goto code_r0x0040ca6a;\n        }\n    }\n    else {\n        if (((*0x41bdbc != 0) || (*0x41bdc8 == 0)) ||\n           (iVar1 = fcn.0040e64e(*0x41bdcc, &var_7ch, *0x41bdc8),  iVar1 != 0)) goto code_r0x0040ca96;\ncode_r0x0040ca6a:\n        iVar1 = fcn.0040c74d(arg_8h_00, iVar1);\n        if (iVar1 == 0) goto code_r0x0040ca96;\n    }\n    *0x41bdb0 = *0x41bdb0 | 4;\n    *0x41bdb4 = arg_8h_00;\n    *0x41bdb8 = arg_8h_00;\ncode_r0x0040ca96:\n    fcn.0040cd9b();\n    return;\n}\n",
        "token_count": 445
    },
    "0040cbb5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint fcn.0040cbb5(char *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t arg_8h;\n    uint uVar2;\n    int16_t *unaff_EBX;\n    int32_t unaff_retaddr;\n    \n    if (*0x41bdd0 == NULL) {\n        if (*0x41bad4 == 2) {\n            *0x41bdd0 = _sym.imp.KERNEL32.dll_GetLocaleInfoA;\n        }\n        else {\n            *0x41bdd0 = fcn.0040c584;\n        }\n    }\n    if (param_1 == NULL) {\ncode_r0x0040cc8f:\n        fcn.0040c4d6();\ncode_r0x0040cc94:\n        if (*0x41bdb0 == 0) {\n            return 0;\n        }\n    }\n    else {\n        *0x41bdc4 = param_1 + 0x40;\n        *0x41bdcc = param_1;\n        if ((*0x41bdc4 != NULL) && (**0x41bdc4 != '\\0')) {\n            fcn.0040c476(0x4177a0, 0x16, 0x41bdc4);\n        }\n        *0x41bdb0 = 0;\n        if ((*0x41bdcc == NULL) || (**0x41bdcc == '\\0')) {\n            if ((*0x41bdc4 == NULL) || (**0x41bdc4 == '\\0')) goto code_r0x0040cc8f;\n            fcn.0040caa3();\n            goto code_r0x0040cc94;\n        }\n        if ((*0x41bdc4 == NULL) || (**0x41bdc4 == '\\0')) {\n            fcn.0040cb60();\n        }\n        else {\n            fcn.0040cada();\n        }\n        if (*0x41bdb0 == 0) {\n            iVar1 = fcn.0040c476(0x417950, 0x40, 0x41bdcc);\n            if (iVar1 != 0) {\n                if ((*0x41bdc4 == NULL) || (**0x41bdc4 == '\\0')) {\n                    fcn.0040cb60();\n                }\n                else {\n                    fcn.0040cada();\n                }\n            }\n            goto code_r0x0040cc94;\n        }\n    }\n    arg_8h = fcn.0040c4f0();\n    if (((arg_8h == 0) || (iVar1 = (*_sym.imp.KERNEL32.dll_IsValidCodePage)(arg_8h & 0xffff),  iVar1 == 0)) ||\n       (iVar1 = (*_sym.imp.KERNEL32.dll_IsValidLocale)(*0x41bdb4, 1),  uVar2 = *0x41bdb4,  iVar1 == 0)) {\ncode_r0x0040cd64:\n        uVar2 = 0;\n    }\n    else {\n        if (unaff_EBX != NULL) {\n            *unaff_EBX = *0x41bdb4;\n            unaff_EBX[1] = *0x41bdb8;\n            unaff_EBX[2] = arg_8h;\n        }\n        if (unaff_retaddr != 0) {\n            if (*unaff_EBX == 0x814) {\n                fcn.00404f40(unaff_retaddr, \"Norwegian-Nynorsk\");\n            }\n            else {\n                iVar1 = (**0x41bdd0)(uVar2, 0x1001, unaff_retaddr, 0x40);\n                if (iVar1 == 0) goto code_r0x0040cd64;\n            }\n            iVar1 = (**0x41bdd0)(*0x41bdb8, 0x1002, unaff_retaddr + 0x40, 0x40);\n            if (iVar1 == 0) goto code_r0x0040cd64;\n            fcn.004050bb(arg_8h, unaff_retaddr + 0x80, 10);\n        }\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 931
    },
    "0040ce68": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_28h_2\n// WARNING: Variable defined which should be unmapped: var_24h_2\n// WARNING: Variable defined which should be unmapped: var_20h_2\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: lpCharType\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n\nvoid __cdecl\nfcn.0040ce68(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint arg_20h_2, \n            uint noname_7, uint arg_8h, uint lpMultiByteStr, uint cbMultiByte, uint arg_14h, uint CodePage, uint arg_1ch\n            , uint arg_20h)\n\n{\n    int32_t iVar1;\n    uint *arg_8h_00;\n    uint uVar2;\n    int32_t noname_1_00;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    int32_t noname_0_00;\n    uint dwInfoType;\n    uint var_ch;\n    uint var_10h;\n    uint var_14h;\n    uint var_18h_2;\n    uint var_4h;\n    uint var_2ch;\n    uint var_28h_2;\n    uint var_24h_2;\n    uint var_20h_2;\n    int32_t lpCharType;\n    int32_t var_38h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    \n    fcn.00407c04();\n    iVar3 = 0;\n    if (*0x41bdd4 == 0) {\n        var_38h = 0x40ce92;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)();\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x41bdd4 = 2;\n            }\n        }\n        else {\n            *0x41bdd4 = 1;\n        }\n    }\n    if ((*0x41bdd4 == 2) || (*0x41bdd4 == 0)) {\n        iVar1 = *(unaff_EBP + 0x1c);\n        if (*(unaff_EBP + 0x1c) == 0) {\n            iVar1 = *0x41bd8c;\n        }\n        noname_0_00 = *(unaff_EBP + 0x18);\n        if (*(unaff_EBP + 0x18) == 0) {\n            noname_0_00 = *0x41bd9c;\n        }\n        noname_1_00 = fcn.0040a8bb(iVar1);\n        if (noname_1_00 != -1) {\n            if (noname_1_00 != noname_0_00) {\n                lpCharType = noname_0_00;\n                var_38h = noname_1_00;\n                iVar3 = fcn.0040a8fe(noname_0_00, noname_1_00, *(unaff_EBP + 0xc), unaff_EBP + 0x10, 0, 0, 0x417f98, \n                                     0x1c);\n                if (iVar3 == 0) goto code_r0x0040d019;\n                *(unaff_EBP + 0xc) = iVar3;\n            }\n            lpCharType = 0x40d00a;\n            var_38h = iVar1;\n            (*_sym.imp.KERNEL32.dll_GetStringTypeA)();\n            if (iVar3 != 0) {\n                lpCharType = iVar3;\n                fcn.00406cec(iVar3);\n            }\n        }\n    }\n    else if (*0x41bdd4 == 1) {\n        *(unaff_EBP + -0x24) = 0;\n        *(unaff_EBP + -0x20) = 0;\n        if (*(unaff_EBP + 0x18) == 0) {\n            *(unaff_EBP + 0x18) = *0x41bd9c;\n        }\n        var_38h = (*(unaff_EBP + 0x20) != 0) * 8 + 1;\n        lpCharType = *(unaff_EBP + 0x18);\n        arg_8h_00 = &fcn.0040ce68::lpCharType;\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        *(unaff_EBP + -0x28) = iVar3;\n        if (iVar3 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.00407d60();\n            *(unaff_EBP + -0x18) = &fcn.0040ce68::lpCharType;\n            *(unaff_EBP + -0x2c) = &fcn.0040ce68::lpCharType;\n            fcn.004051e0(&fcn.0040ce68::lpCharType, 0, iVar3 * 2);\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x20) {\n                arg_8h_00 = fcn.0040a7e8(2, iVar3);\n                if (arg_8h_00 == NULL) goto code_r0x0040d019;\n                *(unaff_EBP + -0x20) = 1;\n            }\n            iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                              (*(unaff_EBP + 0x18), 1, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), arg_8h_00, iVar3);\n            if (iVar3 != 0) {\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)(*(unaff_EBP + 8), arg_8h_00, iVar3, *(unaff_EBP + 0x14))\n                ;\n                *(unaff_EBP + -0x24) = uVar2;\n            }\n            if (*(unaff_EBP + -0x20) != 0) {\n                fcn.00406cec(arg_8h_00);\n            }\n        }\n    }\ncode_r0x0040d019:\n    *(unaff_EBP + -0x3c) = 0x40d021;\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 1565
    },
    "0040d0b0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040d0b0(uint32_t *arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    uint32_t *puVar4;\n    uint32_t *puVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    uint32_t *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    int32_t in_FS_OFFSET;\n    uint lpBuffer;\n    int16_t *var_1ch;\n    uint var_ch;\n    int32_t var_8h;\n    uint32_t *var_4h;\n    \n    puVar4 = arg_8h;\n    pcVar3 = _sym.imp.KERNEL32.dll_InterlockedExchange;\n    puVar8 = arg_8h[2];\n    if ((puVar8 & 3) != 0) {\n        return 0;\n    }\n    var_4h = *(*(in_FS_OFFSET + 0x18) + 8);\n    if ((var_4h <= puVar8) && (puVar8 < *(*(in_FS_OFFSET + 0x18) + 4))) {\n        return 0;\n    }\n    puVar1 = arg_8h + 3;\n    if (*puVar1 == 0xffffffff) {\n        return 1;\n    }\n    uVar10 = 0;\n    arg_8h = NULL;\n    puVar5 = puVar8;\n    do {\n        if ((*puVar5 != 0xffffffff) && (uVar10 <= *puVar5)) {\n            return 0;\n        }\n        if (puVar5[1] != 0) {\n            arg_8h = arg_8h + 1;\n        }\n        uVar10 = uVar10 + 1;\n        puVar5 = puVar5 + 3;\n    } while (uVar10 <= *puVar1);\n    if ((arg_8h != NULL) && ((puVar1 = puVar4[-2],  puVar1 < var_4h || (puVar4 <= puVar1)))) {\n        return 0;\n    }\n    uVar10 = puVar8 & 0xfffff000;\n    iVar12 = 0;\n    if (0 < *0x41be00) {\n        do {\n            if (*(iVar12 * 4 + 0x41be08) == uVar10) {\n                if (iVar12 < 1) {\n                    return 1;\n                }\n                iVar7 = (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x41be48, 1);\n                if (iVar7 != 0) {\n                    return 1;\n                }\n                if (*(iVar12 * 4 + 0x41be08) == uVar10) goto code_r0x0040d2ab;\n                iVar12 = *0x41be00 + -1;\n                if (iVar12 < 0) goto code_r0x0040d299;\n                goto code_r0x0040d289;\n            }\n            iVar12 = iVar12 + 1;\n        } while (iVar12 < *0x41be00);\n    }\n    iVar12 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(puVar8, &lpBuffer, 0x1c);\n    if (iVar12 == 0) {\n        return 0xffffffff;\n    }\n    if (var_8h != 0x1000000) {\n        return 0xffffffff;\n    }\n    if ((var_ch & 0xcc) != 0) {\n        if (((*var_1ch != 0x5a4d) || (piVar6 = *(var_1ch + 0x1e) + var_1ch,  *piVar6 != 0x4550)) ||\n           (*(piVar6 + 6) != 0x10b)) {\n            return 0xffffffff;\n        }\n        uVar9 = *(piVar6 + 5);\n        if (*(piVar6 + 6) == 0) {\n            return 0xffffffff;\n        }\n        uVar2 = *(piVar6 + uVar9 + 0x24);\n        if (((uVar2 <= puVar8 - var_1ch) && (puVar8 - var_1ch < *(piVar6 + uVar9 + 0x20) + uVar2)) &&\n           ((*(piVar6 + uVar9 + 0x3f) & 0x80) != 0)) {\n            return 0;\n        }\n    }\n    iVar7 = (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x41be48, 1);\n    iVar12 = *0x41be00;\n    if (iVar7 != 0) {\n        return 1;\n    }\n    iVar7 = *0x41be00;\n    if (0 < *0x41be00) {\n        puVar8 = *0x41be00 * 4 + 0x41be04;\n        do {\n            if (*puVar8 == uVar10) break;\n            iVar7 = iVar7 + -1;\n            puVar8 = puVar8 + -1;\n        } while (0 < iVar7);\n    }\n    if (iVar7 == 0) {\n        iVar7 = 0xf;\n        if (*0x41be00 < 0x10) {\n            iVar7 = *0x41be00;\n        }\n        iVar11 = 0;\n        if (-1 < iVar7) {\n            do {\n                puVar8 = iVar11 * 4 + 0x41be08;\n                uVar9 = *puVar8;\n                iVar11 = iVar11 + 1;\n                *puVar8 = uVar10;\n                uVar10 = uVar9;\n            } while (iVar11 <= iVar7);\n        }\n        if (iVar12 < 0x10) {\n            *0x41be00 = iVar12 + 1;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x41be48, 0);\n    return 1;\n    while (iVar12 = iVar12 + -1,  -1 < iVar12) {\ncode_r0x0040d289:\n        if (*(iVar12 * 4 + 0x41be08) == uVar10) break;\n    }\n    if (iVar12 < 0) {\ncode_r0x0040d299:\n        if (*0x41be00 < 0x10) {\n            *0x41be00 = *0x41be00 + 1;\n        }\n        iVar12 = *0x41be00 + -1;\n    }\n    else if (iVar12 == 0) goto code_r0x0040d2c3;\ncode_r0x0040d2ab:\n    iVar7 = 0;\n    if (-1 < iVar12) {\n        do {\n            puVar8 = iVar7 * 4 + 0x41be08;\n            uVar9 = *puVar8;\n            iVar7 = iVar7 + 1;\n            *puVar8 = uVar10;\n            uVar10 = uVar9;\n        } while (iVar7 <= iVar12);\n    }\ncode_r0x0040d2c3:\n    (*pcVar3)(0x41be48, 0);\n    return 1;\n}\n",
        "token_count": 1649
    },
    "0040d2f5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_38h_2\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: lpSrcStr\n// WARNING: Variable defined which should be unmapped: var_44h\n// WARNING: Variable defined which should be unmapped: var_40h_2\n// WARNING: Variable defined which should be unmapped: var_3ch_2\n// WARNING: Variable defined which should be unmapped: var_54h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h_2\n// WARNING: Variable defined which should be unmapped: var_20h\n\nvoid __cdecl\nfcn.0040d2f5(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint CodePage, uint arg_24h, uint arg_8h, \n            uint arg_ch, uint arg_10h, uint cchSrc, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *lpMultiByteStr_00;\n    int32_t unaff_EBP;\n    uchar *arg_8h_00;\n    uint var_2ch;\n    uint var_48h;\n    uint var_24h_2;\n    uint var_40h;\n    uint lpWideCharStr;\n    uint lpDestStr;\n    uint cchDest;\n    uint var_20h_2;\n    uint var_24h_3;\n    uint var_28h;\n    uint var_24h;\n    uint Locale;\n    uint dwMapFlags;\n    uint lpMultiByteStr;\n    uint cbMultiByte;\n    uint var_18h_2;\n    uint var_4h;\n    uint uVar5;\n    uint uVar6;\n    uint var_38h_2;\n    uint var_34h;\n    uint var_30h_2;\n    uint var_20h;\n    uint lpSrcStr;\n    uint var_44h;\n    uint var_40h_2;\n    uint var_3ch_2;\n    uint var_38h;\n    uint var_54h;\n    uint var_30h;\n    \n    fcn.00407c04();\n    if (*0x41be4c == 0) {\n        lpSrcStr = 0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringW)();\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x41be4c = 2;\n            }\n        }\n        else {\n            *0x41be4c = 1;\n        }\n    }\n    if (0 < *(unaff_EBP + 0x14)) {\n        iVar1 = *(unaff_EBP + 0x14);\n        pcVar2 = *(unaff_EBP + 0x10);\n        do {\n            iVar1 = iVar1 + -1;\n            if (*pcVar2 == '\\0') goto code_r0x0040d35b;\n            pcVar2 = pcVar2 + 1;\n        } while (iVar1 != 0);\n        iVar1 = -1;\ncode_r0x0040d35b:\n        *(unaff_EBP + 0x14) = *(unaff_EBP + 0x14) + (-1 - iVar1);\n    }\n    if ((*0x41be4c != 2) && (*0x41be4c != 0)) {\n        if (*0x41be4c != 1) goto code_r0x0040d6a8;\n        *(unaff_EBP + -0x2c) = 0;\n        *(unaff_EBP + -0x38) = 0;\n        *(unaff_EBP + -0x34) = 0;\n        if (*(unaff_EBP + 0x20) == 0) {\n            *(unaff_EBP + 0x20) = *0x41bd9c;\n        }\n        lpSrcStr = *(unaff_EBP + 0x20);\n        iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        *(unaff_EBP + -0x30) = iVar1;\n        if (iVar1 == 0) goto code_r0x0040d6a8;\n        *(unaff_EBP + -4) = 1;\n        fcn.00407d60();\n        *(unaff_EBP + -0x18) = &fcn.0040d2f5::lpSrcStr;\n        *(unaff_EBP + -0x1c) = &fcn.0040d2f5::lpSrcStr;\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*(unaff_EBP + -0x1c) == 0) {\n            iVar3 = fcn.00405bcb();\n            *(unaff_EBP + -0x1c) = iVar3;\n            if (iVar3 == 0) goto code_r0x0040d6a8;\n            *(unaff_EBP + -0x38) = 1;\n        }\n        var_30h_2 = 1;\n        var_34h = *(unaff_EBP + 0x20);\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        if (iVar3 != 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, 0, 0);\n            *(unaff_EBP + -0x2c) = iVar3;\n            if (iVar3 != 0) {\n                if ((*(unaff_EBP + 0xd) & 4) == 0) {\n                    *(unaff_EBP + -4) = 2;\n                    fcn.00407d60();\n                    *(unaff_EBP + -0x18) = &fcn.0040d2f5::var_34h;\n                    *(unaff_EBP + -0x20) = &fcn.0040d2f5::var_34h;\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    if (*(unaff_EBP + -0x20) == 0) {\n                        iVar4 = fcn.00405bcb(iVar3 * 2);\n                        *(unaff_EBP + -0x20) = iVar4;\n                        if (iVar4 == 0) goto code_r0x0040d52a;\n                        *(unaff_EBP + -0x34) = 1;\n                    }\n                    iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                                      (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, \n                                       *(unaff_EBP + -0x20), iVar3);\n                    if (iVar1 != 0) {\n                        if (*(unaff_EBP + 0x1c) == 0) {\n                            uVar6 = 0;\n                            uVar5 = 0;\n                        }\n                        else {\n                            uVar6 = *(unaff_EBP + 0x1c);\n                            uVar5 = *(unaff_EBP + 0x18);\n                        }\n                        (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                  (*(unaff_EBP + 0x20), 0, *(unaff_EBP + -0x20), iVar3, uVar5, uVar6, 0, 0);\n                    }\n                }\n                else if ((*(unaff_EBP + 0x1c) != 0) && (iVar3 <= *(unaff_EBP + 0x1c))) {\n                    (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, *(unaff_EBP + 0x18), \n                               *(unaff_EBP + 0x1c));\n                }\n            }\n        }\ncode_r0x0040d52a:\n        if (*(unaff_EBP + -0x34) != 0) {\n            fcn.00406cec(*(unaff_EBP + -0x20));\n        }\n        if (*(unaff_EBP + -0x38) != 0) {\n            fcn.00406cec(*(unaff_EBP + -0x1c));\n        }\n        goto code_r0x0040d6a8;\n    }\n    *(unaff_EBP + -0x28) = 0;\n    *(unaff_EBP + -0x3c) = 0;\n    if (*(unaff_EBP + 8) == 0) {\n        *(unaff_EBP + 8) = *0x41bd8c;\n    }\n    if (*(unaff_EBP + 0x20) == 0) {\n        *(unaff_EBP + 0x20) = *0x41bd9c;\n    }\n    iVar1 = fcn.0040a8bb(*(unaff_EBP + 8));\n    *(unaff_EBP + -0x40) = iVar1;\n    if (iVar1 == -1) goto code_r0x0040d6a8;\n    if (iVar1 == *(unaff_EBP + 0x20)) {\n        lpSrcStr = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n    }\n    else {\n        lpSrcStr = *(unaff_EBP + 0x20);\n        iVar1 = fcn.0040a8fe(lpSrcStr, iVar1, *(unaff_EBP + 0x10), unaff_EBP + 0x14, 0, 0, 0x417fa8, 0x38);\n        *(unaff_EBP + -0x28) = iVar1;\n        if (iVar1 == 0) goto code_r0x0040d6a8;\n        uVar6 = *(unaff_EBP + 0xc);\n        lpSrcStr = *(unaff_EBP + 8);\n        lpMultiByteStr_00 = &fcn.0040d2f5::lpSrcStr;\n        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n        *(unaff_EBP + -0x24) = iVar1;\n        arg_8h_00 = NULL;\n        if (iVar1 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.00407d60();\n            *(unaff_EBP + -0x18) = &fcn.0040d2f5::lpSrcStr;\n            *(unaff_EBP + -0x44) = &fcn.0040d2f5::lpSrcStr;\n            fcn.004051e0();\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x20) {\n                lpMultiByteStr_00 = fcn.00405bcb();\n                arg_8h_00 = lpMultiByteStr_00;\n                if (lpMultiByteStr_00 == NULL) goto code_r0x0040d670;\n                fcn.004051e0();\n                *(unaff_EBP + -0x3c) = 1;\n            }\n            var_30h_2 = *(unaff_EBP + 0xc);\n            var_34h = *(unaff_EBP + 8);\n            iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n            *(unaff_EBP + -0x24) = iVar1;\n            arg_8h_00 = lpMultiByteStr_00;\n            if (iVar1 != 0) {\n                var_30h_2 = *(unaff_EBP + 0x20);\n                var_34h = *(unaff_EBP + -0x40);\n                fcn.0040a8fe(var_34h, var_30h_2, lpMultiByteStr_00, unaff_EBP + -0x24, *(unaff_EBP + 0x18), \n                             *(unaff_EBP + 0x1c), lpSrcStr, uVar6);\n            }\n        }\ncode_r0x0040d670:\n        if (*(unaff_EBP + -0x3c) != 0) {\n            fcn.00406cec(arg_8h_00);\n        }\n    }\n    if (*(unaff_EBP + -0x28) != 0) {\n        fcn.00406cec(*(unaff_EBP + -0x28));\n    }\ncode_r0x0040d6a8:\n    *(unaff_EBP + -0x58) = 0x40d6b0;\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 3067
    },
    "0040d6b1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040d6b1(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint var_10h;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar4 = 0;\n    if (*0x41be50 == NULL) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"user32.dll\");\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if ((iVar2 == 0) ||\n           (*0x41be50 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"MessageBoxA\"),  *0x41be50 == NULL)) {\n            return 0;\n        }\n        *0x41be54 = (*pcVar1)(iVar2, \"GetActiveWindow\");\n        *0x41be58 = (*pcVar1)(iVar2, \"GetLastActivePopup\");\n        if ((*0x41bad4 == 2) && (*0x41be60 = (*pcVar1)(iVar2, \"GetUserObjectInformationA\"),  *0x41be60 != NULL)) {\n            *0x41be5c = (*pcVar1)(iVar2, \"GetProcessWindowStation\");\n        }\n    }\n    if ((*0x41be5c == NULL) ||\n       (((iVar2 = (**0x41be5c)(),  iVar2 != 0 && (iVar2 = (**0x41be60)(iVar2, 1, &var_10h, 0xc, &var_4h),  iVar2 != 0))\n        && ((var_8h & 1) != 0)))) {\n        if (((*0x41be54 != NULL) && (iVar4 = (**0x41be54)(),  iVar4 != 0)) && (*0x41be58 != NULL)) {\n            iVar4 = (**0x41be58)(iVar4);\n        }\n    }\n    else if (*0x41bae0 < 4) {\n        arg_10h = arg_10h | 0x40000;\n    }\n    else {\n        arg_10h = arg_10h | 0x200000;\n    }\n    uVar3 = (**0x41be50)(iVar4, arg_8h, arg_ch, arg_10h);\n    return uVar3;\n}\n",
        "token_count": 557
    },
    "0040d7aa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0040d7aa(uint8_t param_1, uint32_t param_2, uint8_t param_3)\n\n{\n    if ((*(param_1 + 0x41c1c1) & param_3) == 0) {\n        if (param_2 == 0) {\n            param_2 = 0;\n        }\n        else {\n            param_2 = *(*0x41b390 + param_1 * 2) & param_2;\n        }\n        if (param_2 == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 135
    },
    "0040d8ca": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040d8ca(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_4h;\n    \n    fcn.00407c04(0x418068, 0x10);\n    if (*0x41be64 == NULL) {\n        if (*0x41bad4 != 1) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"kernel32.dll\");\n            if (iVar2 != 0) {\n                *0x41be64 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"InitializeCriticalSectionAndSpinCount\");\n                if (*0x41be64 != NULL) goto code_r0x0040d916;\n            }\n        }\n        *0x41be64 = 0x40d8ba;\n    }\ncode_r0x0040d916:\n    pcVar1 = *0x41be64;\n    *(unaff_EBP + -4) = 0;\n    uVar3 = (*pcVar1)(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n    *(unaff_EBP + -0x20) = uVar3;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 340
    },
    "0040dc4a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040dc4a(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    code *extraout_ECX;\n    code *arg_8h_00;\n    int32_t unaff_EBP;\n    code **ppcVar4;\n    code *pcVar5;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00407c04(0x418098, 0x20);\n    *(unaff_EBP + -0x1c) = 0;\n    iVar1 = *(unaff_EBP + 8);\n    if (iVar1 == 2) {\n        ppcVar4 = 0x41be68;\n        pcVar5 = *0x41be68;\ncode_r0x0040dcd7:\n        *(unaff_EBP + -0x1c) = 1;\n        iVar1 = *(unaff_EBP + -0x24);\n    }\n    else {\n        if (((iVar1 != 4) && (iVar1 != 8)) && (iVar1 != 0xb)) {\n            if (iVar1 == 0xf) {\n                ppcVar4 = 0x41be74;\n                pcVar5 = *0x41be74;\n            }\n            else if (iVar1 == 0x15) {\n                ppcVar4 = 0x41be6c;\n                pcVar5 = *0x41be6c;\n            }\n            else {\n                if (iVar1 != 0x16) goto code_r0x0040ddbd;\n                ppcVar4 = 0x41be70;\n                pcVar5 = *0x41be70;\n            }\n            goto code_r0x0040dcd7;\n        }\n        iVar1 = fcn.00406941();\n        *(unaff_EBP + -0x24) = iVar1;\n        iVar2 = fcn.0040da69();\n        ppcVar4 = iVar2 + 8;\n        pcVar5 = *ppcVar4;\n    }\n    arg_8h_00 = NULL;\n    *(unaff_EBP + -0x20) = pcVar5;\n    if (pcVar5 == 0x1) goto code_r0x0040ddbd;\n    if (pcVar5 == NULL) {\n        fcn.00408809(3);\n        arg_8h_00 = extraout_ECX;\n    }\n    if (*(unaff_EBP + -0x1c) != arg_8h_00) {\n        fcn.0040953e(arg_8h_00);\n        arg_8h_00 = NULL;\n    }\n    *(unaff_EBP + -4) = arg_8h_00;\n    iVar2 = *(unaff_EBP + 8);\n    if (((iVar2 == 8) || (iVar2 == 0xb)) || (iVar2 == 4)) {\n        *(unaff_EBP + -0x2c) = *(iVar1 + 0x58);\n        *(iVar1 + 0x58) = arg_8h_00;\n        if (iVar2 == 8) {\n            *(unaff_EBP + -0x30) = *(iVar1 + 0x5c);\n            *(iVar1 + 0x5c) = 0x8c;\n            goto code_r0x0040dd36;\n        }\ncode_r0x0040dd62:\n        *ppcVar4 = arg_8h_00;\n    }\n    else {\ncode_r0x0040dd36:\n        iVar3 = *0x41b170;\n        if (iVar2 != 8) goto code_r0x0040dd62;\n        for (; *(unaff_EBP + -0x28) = iVar3,  iVar3 < *0x41b174 + *0x41b170; iVar3 = iVar3 + 1) {\n            *(*(iVar1 + 0x54) + 8 + iVar3 * 0xc) = arg_8h_00;\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0040dd85();\n    if (*(unaff_EBP + 8) == 8) {\n        (*pcVar5)(8, *(iVar1 + 0x5c));\n    }\n    else {\n        (*pcVar5)(*(unaff_EBP + 8));\n    }\n    iVar2 = *(unaff_EBP + 8);\n    if ((((iVar2 == 8) || (iVar2 == 0xb)) || (iVar2 == 4)) && (*(iVar1 + 0x58) = *(unaff_EBP + -0x2c),  iVar2 == 8)) {\n        *(iVar1 + 0x5c) = *(unaff_EBP + -0x30);\n    }\ncode_r0x0040ddbd:\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 1157
    },
    "0040ddc3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_28h\n\nvoid fcn.0040ddc3(void)\n\n{\n    char cVar1;\n    uint uVar2;\n    code *pcVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    char *pcVar6;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00407c04(0x4180e8, 0x18);\n    *(unaff_EBP + -0x20) = 0;\n    fcn.0040953e(7);\n    *(unaff_EBP + -4) = 0;\n    uVar2 = *0x41bd9c;\n    *(unaff_EBP + -0x28) = *0x41bd9c;\n    *0x41bf2c = 0;\n    *0x41b5ec = 0xffffffff;\n    *0x41b5e0 = 0xffffffff;\n    pcVar4 = fcn.0040e8a7(0x4180e4);\n    *(unaff_EBP + -0x24) = pcVar4;\n    if ((pcVar4 == NULL) || (*pcVar4 == '\\0')) {\n        if (*0x41bf30 != 0) {\n            fcn.00406cec(*0x41bf30);\n            *0x41bf30 = 0;\n        }\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetTimeZoneInformation)(0x41be80);\n        pcVar3 = _sym.imp.KERNEL32.dll_WideCharToMultiByte;\n        if (iVar5 != -1) {\n            *0x41bf2c = 1;\n            *0x41b548 = *0x41be80 * 0x3c;\n            if (*0x41bec6 != 0) {\n                *0x41b548 = *0x41b548 + *0x41bed4 * 0x3c;\n            }\n            if ((*0x41bf1a == 0) || (*0x41bf28 == 0)) {\n                *0x41b54c = 0;\n                *0x41b550 = 0;\n            }\n            else {\n                *0x41b54c = 1;\n                *0x41b550 = (*0x41bf28 - *0x41bed4) * 0x3c;\n            }\n            iVar5 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                              (uVar2, 0, 0x41be84, 0xffffffff, *0x41b5d8, 0x3f, 0, unaff_EBP + -0x1c);\n            if ((iVar5 == 0) || (*(unaff_EBP + -0x1c) != 0)) {\n                **0x41b5d8 = 0;\n            }\n            else {\n                (*0x41b5d8)[0x3f] = 0;\n            }\n            iVar5 = (*pcVar3)(uVar2, 0, 0x41bed8, 0xffffffff, *0x41b5dc, 0x3f, 0, unaff_EBP + -0x1c);\n            if ((iVar5 == 0) || (*(unaff_EBP + -0x1c) != 0)) {\n                **0x41b5dc = 0;\n            }\n            else {\n                (*0x41b5dc)[0x3f] = 0;\n            }\n        }\n    }\n    else {\n        if (*0x41bf30 != 0) {\n            iVar5 = fcn.00409570(pcVar4, *0x41bf30);\n            if (iVar5 == 0) goto code_r0x0040dfc7;\n            if (*0x41bf30 != 0) {\n                fcn.00406cec(*0x41bf30);\n            }\n        }\n        iVar5 = fcn.004049a0(pcVar4);\n        *0x41bf30 = fcn.00405bcb(iVar5 + 1);\n        if (*0x41bf30 != 0) {\n            fcn.00404f40(*0x41bf30, pcVar4);\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0040dfde();\n            fcn.00407da0(*0x41b5d8, pcVar4, 3);\n            (*0x41b5d8)[3] = 0;\n            pcVar6 = pcVar4 + 3;\n            if (*pcVar6 == '-') {\n                *(unaff_EBP + -0x20) = 1;\n                pcVar6 = pcVar4 + 4;\n            }\n            *0x41b548 = fcn.00404e00(pcVar6);\n            *0x41b548 = *0x41b548 * 0xe10;\n            for (; (cVar1 = *pcVar6,  cVar1 == '+' || (('/' < cVar1 && (cVar1 < ':')))); pcVar6 = pcVar6 + 1) {\n            }\n            if (*pcVar6 == ':') {\n                pcVar6 = pcVar6 + 1;\n                iVar5 = fcn.00404e00(pcVar6);\n                *0x41b548 = *0x41b548 + iVar5 * 0x3c;\n                for (; ('/' < *pcVar6 && (*pcVar6 < ':')); pcVar6 = pcVar6 + 1) {\n                }\n                if (*pcVar6 == ':') {\n                    pcVar6 = pcVar6 + 1;\n                    iVar5 = fcn.00404e00(pcVar6);\n                    *0x41b548 = *0x41b548 + iVar5;\n                    for (; ('/' < *pcVar6 && (*pcVar6 < ':')); pcVar6 = pcVar6 + 1) {\n                    }\n                }\n            }\n            if (*(unaff_EBP + -0x20) != 0) {\n                *0x41b548 = -*0x41b548;\n            }\n            *0x41b54c = *pcVar6;\n            if (*0x41b54c == 0) {\n                **0x41b5dc = 0;\n            }\n            else {\n                fcn.00407da0(*0x41b5dc, pcVar6, 3);\n                (*0x41b5dc)[3] = 0;\n            }\n            goto code_r0x0040e065;\n        }\n    }\ncode_r0x0040dfc7:\n    fcn.004047be(unaff_EBP + -0x10, 0xffffffff);\ncode_r0x0040e065:\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 1648
    },
    "0040e06b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.0040e06b(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch, \n            int32_t arg_20h, int32_t arg_24h, int32_t arg_28h)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = arg_10h % 4;\n    if (arg_ch == 1) {\n        if (((iVar2 == 0) && (arg_10h % 100 != 0)) || ((arg_10h + 0x76c) % 400 == 0)) {\n            iVar4 = *(in_EAX * 4 + 0x41b5fc);\n        }\n        else {\n            iVar4 = *(in_EAX * 4 + 0x41b630);\n        }\n        iVar5 = iVar4 + 1;\n        iVar3 = (arg_10h * 0x16d + -0x63db + (arg_10h + -1) / 4 + iVar5 + ((arg_10h + 299) / 400 - (arg_10h + -1) / 100)\n                ) % 7;\n        iVar1 = (arg_14h * 7 - iVar3) + arg_18h;\n        if (iVar3 <= arg_18h) {\n            iVar5 = iVar4 + -6;\n        }\n        iVar5 = iVar5 + iVar1;\n        if (arg_14h == 5) {\n            if (((iVar2 == 0) && (arg_10h % 100 != 0)) || ((arg_10h + 0x76c) % 400 == 0)) {\n                iVar1 = *(in_EAX * 4 + 0x41b600);\n            }\n            else {\n                iVar1 = *(in_EAX * 4 + 0x41b634);\n            }\n            if (iVar1 < iVar5) {\n                iVar5 = iVar5 + -7;\n            }\n        }\n    }\n    else {\n        if (((iVar2 == 0) && (iVar1 = arg_10h / 100,  arg_10h % 100 != 0)) ||\n           (iVar1 = (arg_10h + 0x76c) / 400,  (arg_10h + 0x76c) % 400 == 0)) {\n            iVar5 = *(in_EAX * 4 + 0x41b5fc);\n        }\n        else {\n            iVar5 = *(in_EAX * 4 + 0x41b630);\n        }\n        iVar5 = iVar5 + arg_1ch;\n    }\n    iVar2 = (in_ECX * 0x3c + arg_20h) * 0x3c;\n    if (arg_8h == 1) {\n        *0x41b5e8 = (iVar2 + arg_24h) * 1000 + arg_28h;\n        *0x41b5e0 = arg_10h;\n        *0x41b5e4 = iVar5;\n    }\n    else {\n        *0x41b5f4 = (iVar2 + *0x41b550 + arg_24h) * 1000 + arg_28h;\n        if (*0x41b5f4 < 0) {\n            *0x41b5f4 = *0x41b5f4 + 86400000;\n            *0x41b5f0 = iVar5 + -1;\n        }\n        else {\n            iVar1 = 86400000;\n            *0x41b5f0 = iVar5;\n            if (86399999 < *0x41b5f4) {\n                *0x41b5f4 = *0x41b5f4 + -86400000;\n                *0x41b5f0 = iVar5 + 1;\n            }\n        }\n        *0x41b5ec = arg_10h;\n    }\n    return iVar1;\n}\n",
        "token_count": 968
    },
    "0040e4be": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_84h\n\nvoid __cdecl fcn.0040e4be(int32_t arg_8h, uint arg_ch, uint arg_10h, int32_t *arg_14h)\n\n{\n    char cVar1;\n    bool bVar2;\n    int32_t iVar3;\n    uint *noname_2;\n    int32_t iVar4;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    char *pcVar5;\n    uint var_84h;\n    uint in_stack_ffffff7c;\n    uint in_stack_ffffff80;\n    uint var_4h;\n    \n    if (arg_8h != 1) {\n        if (arg_8h == 0) {\n            pcVar5 = 0x41bf38;\n            iVar3 = fcn.0040ec47(arg_ch, arg_10h, 0x41bf38, 4, 0, unaff_EDI, unaff_ESI, unaff_EBX, var_84h, \n                                 in_stack_ffffff7c, in_stack_ffffff80);\n            if (iVar3 != 0) {\n                *arg_14h = '\\0';\n                do {\n                    cVar1 = *pcVar5;\n                    iVar3 = fcn.0040ea1a(cVar1);\n                    if (iVar3 == 0) break;\n                    pcVar5 = pcVar5 + 2;\n                    *arg_14h = *arg_14h * '\\n' + cVar1 + -0x30;\n                } while (pcVar5 < 0x41bf40);\n            }\n        }\n        goto code_r0x0040e570;\n    }\n    noname_2 = &var_84h;\n    bVar2 = false;\n    iVar3 = fcn.0040ed77(arg_ch, arg_10h, noname_2, 0x80, 0, unaff_EDI, unaff_ESI, unaff_EBX, var_84h, in_stack_ffffff7c\n                         , in_stack_ffffff80);\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (((iVar3 != 0x7a) ||\n            (iVar3 = fcn.0040ed77(arg_ch, arg_10h, 0, 0, 0, unaff_EDI, unaff_ESI, unaff_EBX, var_84h, in_stack_ffffff7c\n                                  , in_stack_ffffff80),  iVar3 == 0)) ||\n           (noname_2 = fcn.00405bcb(iVar3),  noname_2 == NULL)) goto code_r0x0040e570;\n        bVar2 = true;\n        iVar3 = fcn.0040ed77(arg_ch, arg_10h, noname_2, iVar3, 0, unaff_EDI, unaff_ESI, unaff_EBX, var_84h, \n                             in_stack_ffffff7c, in_stack_ffffff80);\n        if (iVar3 != 0) goto code_r0x0040e551;\n    }\n    else {\ncode_r0x0040e551:\n        iVar4 = fcn.00405bcb(iVar3);\n        *arg_14h = iVar4;\n        if (iVar4 != 0) {\n            fcn.00407da0(iVar4, noname_2, iVar3);\n            if (bVar2) {\n                fcn.00406cec(noname_2);\n            }\n            goto code_r0x0040e570;\n        }\n        if (!bVar2) goto code_r0x0040e570;\n    }\n    fcn.00406cec(noname_2);\ncode_r0x0040e570:\n    fcn.0040cd9b();\n    return;\n}\n",
        "token_count": 864
    },
    "0040e5e5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040e5e5(uint8_t *arg_8h, uint8_t *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar1 = fcn.00406941();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x41addc) {\n        iVar1 = fcn.004073eb();\n    }\n    if (*(iVar1 + 0x14) == 0) {\n        iVar2 = fcn.0040e470(arg_8h, arg_ch);\n    }\n    else {\n        do {\n            iVar2 = fcn.0040eebf(iVar1, *arg_8h);\n            arg_8h = arg_8h + 1;\n            iVar3 = fcn.0040eebf(iVar1, *arg_ch);\n            arg_ch = arg_ch + 1;\n            if (iVar2 == 0) break;\n        } while (iVar2 == iVar3);\n        iVar2 = iVar2 - iVar3;\n    }\n    return iVar2;\n}\n",
        "token_count": 256
    },
    "0040e64e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040e64e(uint8_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar1 = fcn.00406941();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x41addc) {\n        iVar1 = fcn.004073eb();\n    }\n    if (arg_10h == 0) {\n        iVar2 = 0;\n    }\n    else if (*(iVar1 + 0x14) == 0) {\n        iVar2 = fcn.0040efb0(arg_8h, arg_ch, arg_10h);\n    }\n    else {\n        do {\n            iVar2 = fcn.0040eebf(iVar1, *arg_8h);\n            arg_8h = arg_8h + 1;\n            iVar3 = fcn.0040eebf(iVar1, *arg_ch);\n            arg_ch = arg_ch + 1;\n            arg_10h = arg_10h + -1;\n            if ((arg_10h == 0) || (iVar2 == 0)) break;\n        } while (iVar2 == iVar3);\n        iVar2 = iVar2 - iVar3;\n    }\n    return iVar2;\n}\n",
        "token_count": 315
    },
    "0040ea1a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.0040ea1a(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.00406941();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x41addc) {\n        iVar1 = fcn.004073eb();\n    }\n    if (1 < *(iVar1 + 0x28)) {\n        uVar2 = fcn.0040846b(iVar1, param_1, 4);\n        return uVar2;\n    }\n    return *(*(iVar1 + 0x48) + param_1 * 2) & 4;\n}\n",
        "token_count": 156
    },
    "0040ec47": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_24h_2\n// WARNING: Variable defined which should be unmapped: var_20h_2\n// WARNING: Variable defined which should be unmapped: var_1ch_2\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_28h\n\nvoid __cdecl\nfcn.0040ec47(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint CodePage, uint noname_5, uint arg_8h, \n            uint arg_ch, uint noname_8, uint noname_9, uint arg_18h)\n\n{\n    int32_t iVar1;\n    uchar *arg_8h_00;\n    int32_t unaff_EBP;\n    uint Locale;\n    uint LCType;\n    uint lpLCData;\n    uint cchData;\n    uint var_34h;\n    uint uVar2;\n    uint var_28h;\n    uint var_24h_2;\n    uint var_20h_2;\n    uint var_1ch_2;\n    uint uStack24;\n    uint uStack20;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    \n    var_18h = 0x18;\n    var_1ch = 0x4182e8;\n    var_20h = 0x40ec53;\n    fcn.00407c04();\n    if (*0x41bf44 == 0) {\n        var_20h = 0;\n        var_24h = 0;\n        uStack20 = 1;\n        uStack24 = 0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)();\n        if (iVar1 == 0) {\n            var_20h = 0x40ec7c;\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x41bf44 = 2;\n            }\n        }\n        else {\n            *0x41bf44 = 1;\n        }\n    }\n    if (*0x41bf44 == 1) {\n        var_20h = *(unaff_EBP + 0x14);\n        var_24h = *(unaff_EBP + 0x10);\n        uStack20 = *(unaff_EBP + 0xc);\n        uStack24 = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)();\n    }\n    else if ((*0x41bf44 == 2) || (*0x41bf44 == 0)) {\n        *(unaff_EBP + -0x1c) = 0;\n        *(unaff_EBP + -0x24) = 0;\n        if (*(unaff_EBP + 0x18) == 0) {\n            *(unaff_EBP + 0x18) = *0x41bd9c;\n        }\n        var_20h = 0;\n        var_24h = 0;\n        uStack20 = *(unaff_EBP + 0xc);\n        uStack24 = *(unaff_EBP + 8);\n        arg_8h_00 = &stack0xffffffe8;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)();\n        *(unaff_EBP + -0x20) = iVar1;\n        if (iVar1 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.00407d60();\n            *(unaff_EBP + -0x18) = &stack0xffffffe8;\n            *(unaff_EBP + -0x28) = &stack0xffffffe8;\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x18) {\n                arg_8h_00 = fcn.00405bcb(*(unaff_EBP + -0x20));\n                if (arg_8h_00 == NULL) goto code_r0x0040ed6e;\n                *(unaff_EBP + -0x24) = 1;\n            }\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)\n                              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), arg_8h_00, *(unaff_EBP + -0x20));\n            if (iVar1 != 0) {\n                if (*(unaff_EBP + 0x14) == 0) {\n                    var_28h = 0;\n                    uVar2 = 0;\n                }\n                else {\n                    var_28h = *(unaff_EBP + 0x14);\n                    uVar2 = *(unaff_EBP + 0x10);\n                }\n                uVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                  (*(unaff_EBP + 0x18), 1, arg_8h_00, 0xffffffff, uVar2, var_28h);\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            if (*(unaff_EBP + -0x24) != 0) {\n                fcn.00406cec(arg_8h_00);\n            }\n        }\n    }\ncode_r0x0040ed6e:\n    *(unaff_EBP + -0x38) = 0x40ed76;\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 1255
    },
    "0040ed77": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_24h_2\n// WARNING: Variable defined which should be unmapped: var_20h_2\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_28h\n\nvoid __cdecl\nfcn.0040ed77(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint CodePage, uint noname_5, uint Locale, \n            uint LCType, uint lpLCData, uint cchData, uint arg_18h)\n\n{\n    int32_t iVar1;\n    uchar *arg_8h;\n    int32_t unaff_EBP;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h;\n    uint var_4h;\n    uint uVar2;\n    uint uVar3;\n    uint var_28h;\n    uint var_24h_2;\n    uint var_20h_2;\n    uint var_34h;\n    uint uStack24;\n    uint uStack20;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    \n    var_18h = 0x18;\n    var_1ch = 0x4182f8;\n    var_20h = 0x40ed83;\n    fcn.00407c04();\n    if (*0x41bf48 == 0) {\n        var_20h = 0;\n        var_24h = 0;\n        uStack20 = 1;\n        uStack24 = 0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)();\n        if (iVar1 == 0) {\n            var_20h = 0x40edac;\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x41bf48 = 2;\n            }\n        }\n        else {\n            *0x41bf48 = 1;\n        }\n    }\n    if ((*0x41bf48 == 2) || (*0x41bf48 == 0)) {\n        var_20h = *(unaff_EBP + 0x14);\n        var_24h = *(unaff_EBP + 0x10);\n        uStack20 = *(unaff_EBP + 0xc);\n        uStack24 = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)();\n    }\n    else if (*0x41bf48 == 1) {\n        *(unaff_EBP + -0x1c) = 0;\n        *(unaff_EBP + -0x20) = 0;\n        if (*(unaff_EBP + 0x18) == 0) {\n            *(unaff_EBP + 0x18) = *0x41bd9c;\n        }\n        var_20h = 0;\n        var_24h = 0;\n        uStack20 = *(unaff_EBP + 0xc);\n        uStack24 = *(unaff_EBP + 8);\n        arg_8h = &stack0xffffffe8;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)();\n        *(unaff_EBP + -0x24) = iVar1;\n        if (iVar1 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.00407d60();\n            *(unaff_EBP + -0x18) = &stack0xffffffe8;\n            *(unaff_EBP + -0x28) = &stack0xffffffe8;\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x18) {\n                arg_8h = fcn.00405bcb(iVar1 * 2);\n                if (arg_8h == NULL) goto code_r0x0040eeae;\n                *(unaff_EBP + -0x20) = 1;\n            }\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), arg_8h, iVar1);\n            if (iVar1 != 0) {\n                if (*(unaff_EBP + 0x14) == 0) {\n                    uVar3 = 0;\n                    uVar2 = 0;\n                }\n                else {\n                    uVar3 = *(unaff_EBP + 0x14);\n                    uVar2 = *(unaff_EBP + 0x10);\n                }\n                uVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                  (*(unaff_EBP + 0x18), 0, arg_8h, 0xffffffff, uVar2, uVar3, 0, 0);\n                *(unaff_EBP + -0x1c) = uVar3;\n            }\n            if (*(unaff_EBP + -0x20) != 0) {\n                fcn.00406cec(arg_8h);\n            }\n        }\n    }\ncode_r0x0040eeae:\n    *(unaff_EBP + -0x38) = 0x40eeb6;\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 1208
    },
    "0040eebf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.0040eebf(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t in_ECX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint noname_3;\n    uint unaff_retaddr;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint in_stack_00000020;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint in_stack_0000002c;\n    uint in_stack_00000030;\n    uint in_stack_00000034;\n    uint32_t var_4h;\n    \n    uVar2 = arg_ch;\n    uVar1 = arg_8h;\n    if ((*(arg_8h + 0x14) == 0) || ((*(arg_8h + 0x24) != 0 && (arg_ch < 0x80)))) {\n        if ((0x40 < arg_ch) && (arg_ch < 0x5b)) {\n            return arg_ch + 0x20;\n        }\n    }\n    else {\n        noname_3 = 1;\n        var_4h = in_ECX;\n        if (arg_ch < 0x100) {\n            if (*(arg_8h + 0x28) < 2) {\n                uVar3 = *(*(arg_8h + 0x48) + arg_ch * 2) & 1;\n            }\n            else {\n                uVar3 = fcn.0040846b(arg_8h, arg_ch, 1);\n            }\n            if (uVar3 == 0) {\n                return uVar2;\n            }\n        }\n        if ((*(*(uVar1 + 0x48) + 1 + (uVar2 >> 8 & 0xffU) * 2) & 0x80) == 0) {\n            arg_8h = arg_8h & 0xffff0000 | uVar2 & 0xff;\n        }\n        else {\n            arg_8h = arg_8h & 0xff000000 | CONCAT11(uVar2, uVar2 >> 8);\n            noname_3 = 2;\n        }\n        iVar4 = fcn.0040d2f5(*(uVar1 + 0x14), 0x100, &arg_8h, noname_3, &var_4h, 3, *(uVar1 + 4), 1, unaff_EDI, \n                             unaff_ESI, unaff_EBX, var_4h, unaff_EBP, unaff_retaddr, arg_8h, arg_ch, in_stack_0000000c, \n                             in_stack_00000010, in_stack_00000014, in_stack_00000018, in_stack_0000001c, \n                             in_stack_00000020, in_stack_00000024, in_stack_00000028, in_stack_0000002c, \n                             in_stack_00000030, in_stack_00000034);\n        if (iVar4 != 0) {\n            if (iVar4 != 1) {\n                return CONCAT11(var_4h, var_4h._1_1_);\n            }\n            return var_4h & 0xff;\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 840
    },
    "0040f011": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040f011(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint in_stack_00000020;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint in_stack_0000002c;\n    uint in_stack_00000030;\n    uint in_stack_00000034;\n    uint in_stack_00000038;\n    uint in_stack_0000003c;\n    uint in_stack_00000040;\n    uint in_stack_00000044;\n    uint in_stack_00000048;\n    uint in_stack_0000004c;\n    uint in_stack_00000050;\n    \n    iVar1 = fcn.00406941();\n    iVar1 = *(iVar1 + 0x60);\n    if (iVar1 != *0x41c1b8) {\n        iVar1 = fcn.004080ee();\n    }\n    if (arg_10h == 0) {\n        return 0;\n    }\n    iVar1 = fcn.0040f10b(*(iVar1 + 0xc), 1, arg_8h, arg_10h, arg_ch, arg_10h, *(iVar1 + 4), unaff_EBP, unaff_retaddr, \n                         arg_8h, arg_ch, arg_10h, in_stack_00000010, in_stack_00000014, in_stack_00000018, \n                         in_stack_0000001c, in_stack_00000020, in_stack_00000024, in_stack_00000028, in_stack_0000002c, \n                         in_stack_00000030, in_stack_00000034, in_stack_00000038, in_stack_0000003c, in_stack_00000040, \n                         in_stack_00000044, in_stack_00000048, in_stack_0000004c, in_stack_00000050);\n    if (iVar1 == 0) {\n        return 0x7fffffff;\n    }\n    return iVar1 + -2;\n}\n",
        "token_count": 514
    },
    "0040f0ef": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0040f0ef(int32_t param_1)\n\n{\n    char *in_EAX;\n    int32_t iVar1;\n    \n    iVar1 = param_1;\n    if (param_1 != 0) {\n        do {\n            iVar1 = iVar1 + -1;\n            if (*in_EAX == '\\0') goto code_r0x0040f103;\n            in_EAX = in_EAX + 1;\n        } while (iVar1 != 0);\n    }\n    iVar1 = iVar1 + -1;\ncode_r0x0040f103:\n    return (param_1 - iVar1) + -1;\n}\n",
        "token_count": 145
    },
    "0040f10b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_44h_2\n// WARNING: Variable defined which should be unmapped: var_40h_3\n// WARNING: Variable defined which should be unmapped: var_3ch_3\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_40h_2\n// WARNING: Variable defined which should be unmapped: var_3ch_2\n// WARNING: Variable defined which should be unmapped: var_5ch\n\nvoid __cdecl\nfcn.0040f10b(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint arg_8h, uint arg_ch, uint lpMultiByteStr, uint cbMultiByte, \n            uint lpString2, uint cchCount2, uint CodePage)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint8_t *puVar4;\n    uint *arg_8h_00;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    int32_t iVar6;\n    uint Locale;\n    uint dwCmpFlags;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint lpCPInfo;\n    uint var_4h_2;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_18h_2;\n    uint var_1ch_2;\n    uint var_20h;\n    uint var_4h;\n    uint var_50h;\n    uint var_44h_2;\n    uint var_40h_3;\n    uint var_3ch_3;\n    uint lpString1;\n    uint var_30h_2;\n    uchar auStack48 [2];\n    uint var_2ah;\n    int32_t var_4ch;\n    uint var_40h_2;\n    uint var_3ch_2;\n    uint var_5ch;\n    uint uVar7;\n    \n    uVar7 = 0x40;\n    fcn.00407c04();\n    *(unaff_EBP + -0x1c) = *0x41ad6c;\n    iVar6 = 0;\n    if (*0x41bf4c == 0) {\n        var_4ch = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_CompareStringW)();\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar2 == 0x78) {\n                *0x41bf4c = 2;\n            }\n        }\n        else {\n            *0x41bf4c = 1;\n        }\n    }\n    if (0 < *(unaff_EBP + 0x14)) {\n        uVar3 = fcn.0040f0ef();\n        *(unaff_EBP + 0x14) = uVar3;\n    }\n    iVar2 = *(unaff_EBP + 0x1c);\n    if (0 < iVar2) {\n        iVar2 = fcn.0040f0ef();\n        *(unaff_EBP + 0x1c) = iVar2;\n    }\n    if ((*0x41bf4c == 2) || (*0x41bf4c == 0)) {\n        *(unaff_EBP + -0x38) = 0;\n        if (*(unaff_EBP + 8) == 0) {\n            *(unaff_EBP + 8) = *0x41bd8c;\n        }\n        iVar2 = *(unaff_EBP + 0x20);\n        if (*(unaff_EBP + 0x20) == 0) {\n            iVar2 = *0x41bd9c;\n        }\n        iVar5 = fcn.0040a8bb(*(unaff_EBP + 8));\n        if (iVar5 == -1) goto code_r0x0040f47e;\n        if (iVar5 != iVar2) {\n            var_4ch = iVar2;\n            iVar6 = fcn.0040a8fe(iVar2, iVar5, *(unaff_EBP + 0x10), unaff_EBP + 0x14, 0, 0, 0x418308, uVar7);\n            if (iVar6 == 0) goto code_r0x0040f47e;\n            var_4ch = iVar2;\n            iVar2 = fcn.0040a8fe(iVar2, iVar5, *(unaff_EBP + 0x18), unaff_EBP + 0x1c, 0, 0, 0x418308, uVar7);\n            *(unaff_EBP + -0x38) = iVar2;\n            if (iVar2 == 0) {\n                fcn.00406cec(iVar6);\n                goto code_r0x0040f47e;\n            }\n            *(unaff_EBP + 0x10) = iVar6;\n            *(unaff_EBP + 0x18) = *(unaff_EBP + -0x38);\n        }\n        var_4ch = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_CompareStringA)();\n        if (iVar6 != 0) {\n            fcn.00406cec(iVar6);\n            stack0xffffffd4 = 0x40f47a;\n            fcn.00406cec(*(unaff_EBP + -0x38));\n        }\n        goto code_r0x0040f47e;\n    }\n    if (*0x41bf4c != 1) goto code_r0x0040f47e;\n    *(unaff_EBP + -0x3c) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    *(unaff_EBP + -0x40) = 0;\n    if (*(unaff_EBP + 0x20) == 0) {\n        *(unaff_EBP + 0x20) = *0x41bd9c;\n    }\n    if ((*(unaff_EBP + 0x14) == 0) || (iVar2 == 0)) {\n        if ((*(unaff_EBP + 0x14) == iVar2) ||\n           (((1 < iVar2 || (1 < *(unaff_EBP + 0x14))) || (iVar6 = (*_sym.imp.KERNEL32.dll_GetCPInfo)(),  iVar6 == 0))))\n        goto code_r0x0040f47e;\n        if (0 < *(unaff_EBP + 0x14)) {\n            if (1 < *(unaff_EBP + -0x30)) {\n                puVar4 = unaff_EBP + -0x2a;\n                uVar1 = *(unaff_EBP + -0x2a);\n                while (((uVar1 != 0 && (puVar4[1] != 0)) &&\n                       ((**(unaff_EBP + 0x10) < *puVar4 || (puVar4[1] < **(unaff_EBP + 0x10)))))) {\n                    puVar4 = puVar4 + 2;\n                    uVar1 = *puVar4;\n                }\n            }\n            goto code_r0x0040f47e;\n        }\n        if (0 < *(unaff_EBP + 0x1c)) {\n            if (1 < *(unaff_EBP + -0x30)) {\n                puVar4 = unaff_EBP + -0x2a;\n                uVar1 = *(unaff_EBP + -0x2a);\n                while (((uVar1 != 0 && (puVar4[1] != 0)) &&\n                       ((**(unaff_EBP + 0x18) < *puVar4 || (puVar4[1] < **(unaff_EBP + 0x18)))))) {\n                    puVar4 = puVar4 + 2;\n                    uVar1 = *puVar4;\n                }\n            }\n            goto code_r0x0040f47e;\n        }\n    }\n    var_4ch = *(unaff_EBP + 0x20);\n    iVar6 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n    *(unaff_EBP + -0x48) = iVar6;\n    if (iVar6 == 0) goto code_r0x0040f47e;\n    *(unaff_EBP + -4) = 0;\n    fcn.00407d60();\n    *(unaff_EBP + -0x18) = &fcn.0040f10b::var_4ch;\n    *(unaff_EBP + -0x34) = &fcn.0040f10b::var_4ch;\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + -0x34) == 0) {\n        iVar2 = fcn.00405bcb();\n        *(unaff_EBP + -0x34) = iVar2;\n        if (iVar2 == 0) goto code_r0x0040f47e;\n        *(unaff_EBP + -0x3c) = 1;\n    }\n    unique0x00007a00 = *(unaff_EBP + 0x14);\n    _auStack48 = *(unaff_EBP + 0x10);\n    var_30h_2 = 1;\n    lpString1 = *(unaff_EBP + 0x20);\n    iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n    if (iVar2 != 0) {\n        arg_8h_00 = &fcn.0040f10b::lpString1;\n        iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                          (*(unaff_EBP + 0x20), 9, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c), 0, 0);\n        *(unaff_EBP + -0x4c) = iVar2;\n        if (iVar2 != 0) {\n            *(unaff_EBP + -4) = 1;\n            fcn.00407d60();\n            *(unaff_EBP + -0x18) = &fcn.0040f10b::lpString1;\n            *(unaff_EBP + -0x50) = &fcn.0040f10b::lpString1;\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x38) {\n                arg_8h_00 = fcn.00405bcb(iVar2 * 2);\n                if (arg_8h_00 == NULL) goto code_r0x0040f3b9;\n                *(unaff_EBP + -0x44) = 1;\n            }\n            iVar5 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                              (*(unaff_EBP + 0x20), 1, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c), arg_8h_00, iVar2);\n            if (iVar5 != 0) {\n                uVar7 = (*_sym.imp.KERNEL32.dll_CompareStringW)\n                                  (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x34), iVar6, arg_8h_00, iVar2);\n                *(unaff_EBP + -0x40) = uVar7;\n            }\n            if (*(unaff_EBP + -0x44) != 0) {\n                fcn.00406cec(arg_8h_00);\n            }\n        }\n    }\ncode_r0x0040f3b9:\n    if (*(unaff_EBP + -0x3c) != 0) {\n        fcn.00406cec(*(unaff_EBP + -0x34));\n    }\ncode_r0x0040f47e:\n    *(unaff_EBP + -0x60) = 0x40f489;\n    fcn.0040cd9b();\n    *(unaff_EBP + -0x60) = 0x40f48e;\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 2894
    },
    "0040f4dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * fcn.0040f4dc(void)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t *unaff_EDI;\n    uint var_4h;\n    \n    iVar3 = 0;\n    if (unaff_EDI != NULL) {\n        iVar1 = *unaff_EDI;\n        piVar2 = unaff_EDI;\n        while (iVar1 != 0) {\n            piVar2 = piVar2 + 1;\n            iVar3 = iVar3 + 1;\n            iVar1 = *piVar2;\n        }\n        piVar2 = fcn.00405bcb(iVar3 * 4 + 4);\n        if (piVar2 == NULL) {\n            fcn.004055c7(9);\n        }\n        iVar3 = *unaff_EDI;\n        piVar4 = piVar2;\n        while (iVar3 != 0) {\n            iVar3 = fcn.0040f712(iVar3);\n            *piVar4 = iVar3;\n            piVar4 = piVar4 + 1;\n            unaff_EDI = unaff_EDI + 1;\n            iVar3 = *unaff_EDI;\n        }\n        *piVar4 = 0;\n        return piVar2;\n    }\n    return unaff_EDI;\n}\n",
        "token_count": 308
    },
    "0040f73d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t * __cdecl fcn.0040f73d(uint32_t *arg_8h, uint32_t arg_ch)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    \n    iVar3 = fcn.00406941();\n    iVar3 = *(iVar3 + 0x60);\n    if (iVar3 != *0x41c1b8) {\n        iVar3 = fcn.004080ee();\n    }\n    if (*(iVar3 + 8) == 0) {\n        uVar7 = arg_8h & 3;\n        while (uVar7 != 0) {\n            if (*arg_8h == arg_ch) {\n                return arg_8h;\n            }\n            if (*arg_8h == 0) {\n                return NULL;\n            }\n            uVar7 = arg_8h + 1 & 3;\n            arg_8h = arg_8h + 1;\n        }\n        while( true ) {\n            while( true ) {\n                uVar7 = *arg_8h;\n                uVar6 = uVar7 ^ CONCAT22(CONCAT11(arg_ch, arg_ch), CONCAT11(arg_ch, arg_ch));\n                uVar4 = uVar7 ^ 0xffffffff ^ uVar7 + 0x7efefeff;\n                puVar5 = arg_8h + 1;\n                if (((uVar6 ^ 0xffffffff ^ uVar6 + 0x7efefeff) & 0x81010100) != 0) break;\n                arg_8h = puVar5;\n                if ((uVar4 & 0x81010100) != 0) {\n                    if ((uVar4 & 0x1010100) != 0) {\n                        return NULL;\n                    }\n                    if ((uVar7 + 0x7efefeff & 0x80000000) == 0) {\n                        return NULL;\n                    }\n                }\n            }\n            uVar7 = *arg_8h;\n            if (uVar7 == arg_ch) {\n                return arg_8h;\n            }\n            if (uVar7 == 0) {\n                return NULL;\n            }\n            uVar2 = uVar7 >> 8;\n            if (uVar2 == arg_ch) {\n                return arg_8h + 1;\n            }\n            if (uVar2 == 0) break;\n            uVar2 = uVar7 >> 0x10;\n            if (uVar2 == arg_ch) {\n                return arg_8h + 2;\n            }\n            if (uVar2 == 0) {\n                return NULL;\n            }\n            uVar2 = uVar7 >> 0x18;\n            if (uVar2 == arg_ch) {\n                return arg_8h + 3;\n            }\n            arg_8h = puVar5;\n            if (uVar2 == 0) {\n                return NULL;\n            }\n        }\n        return NULL;\n    }\n    while( true ) {\n        uVar2 = *arg_8h;\n        uVar7 = uVar2;\n        if (uVar2 == 0) break;\n        if ((*(uVar7 + 0x1d + iVar3) & 4) == 0) {\n            puVar5 = arg_8h;\n            if (arg_ch == uVar7) break;\n        }\n        else {\n            uVar1 = *(arg_8h + 1);\n            if (uVar1 == 0) {\n                return NULL;\n            }\n            puVar5 = arg_8h + 1;\n            if (arg_ch == CONCAT11(uVar2, uVar1)) {\n                return arg_8h;\n            }\n        }\n        arg_8h = puVar5 + 1;\n    }\n    return ~-(arg_ch != uVar7) & arg_8h;\n}\n",
        "token_count": 884
    },
    "004010c8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004010c8(uint arg_8h)\n\n{\n    uint ARG_0;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    ARG_0 = 0x30;\n    var_2ch = 3;\n    var_28h = 0x40109b;\n    var_24h = 0;\n    var_20h = 0;\n    var_1ch = arg_8h;\n    var_18h = (*_sym.imp.USER32.dll_LoadIconA)(*0x41b980, 0x6b);\n    var_14h = (*_sym.imp.USER32.dll_LoadCursorA)(0, 0x7f00);\n    var_10h = 6;\n    var_ch = 0x6d;\n    var_8h = 0x41b9f8;\n    var_4h = (*_sym.imp.USER32.dll_LoadIconA)(*0x41b980, 0x6c);\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&ARG_0);\n    return;\n}\n",
        "token_count": 301
    },
    "00401064": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401064(int32_t arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t in_ECX;\n    int32_t var_40h;\n    int32_t var_3ch;\n    uint var_38h;\n    int32_t var_30h;\n    \n    cVar1 = fcn.00401014(arg_8h);\n    if (cVar1 == '\\0') {\n        cVar1 = fcn.00401078(arg_ch, 0);\n        if (cVar1 != '\\0') {\n            if (*(in_ECX + 0x18) < 8) {\n                var_30h = in_ECX + 4;\n            }\n            else {\n                var_30h = *(in_ECX + 4);\n            }\n            fcn.00404a30(var_30h, arg_8h, arg_ch << 1);\n            *(in_ECX + 0x14) = arg_ch;\n            if (*(in_ECX + 0x18) < 8) {\n                var_40h = in_ECX + 4;\n            }\n            else {\n                var_40h = *(in_ECX + 4);\n            }\n            *(var_40h + arg_ch * 2) = 0;\n        }\n    }\n    else {\n        if (*(in_ECX + 0x18) < 8) {\n            var_3ch = in_ECX + 4;\n        }\n        else {\n            var_3ch = *(in_ECX + 4);\n        }\n        in_ECX = fcn.004010aa(in_ECX, arg_8h - var_3ch >> 1, arg_ch);\n    }\n    return in_ECX;\n}\n",
        "token_count": 387
    },
    "004010aa": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004010aa(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    char cVar1;\n    int32_t in_ECX;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    int32_t var_38h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    if (*(arg_8h + 0x14) < arg_ch) {\n        fcn.00404169();\n    }\n    var_4h = *(arg_8h + 0x14) - arg_ch;\n    if (arg_10h < var_4h) {\n        var_4h = arg_10h;\n    }\n    if (in_ECX == arg_8h) {\n        fcn.00401087(arg_ch + var_4h, *0x4160c8);\n        fcn.00401087(0, arg_ch);\n    }\n    else {\n        cVar1 = fcn.00401078(var_4h, 0);\n        if (cVar1 != '\\0') {\n            if (*(arg_8h + 0x18) < 8) {\n                var_44h = arg_8h + 4;\n            }\n            else {\n                var_44h = *(arg_8h + 4);\n            }\n            if (*(in_ECX + 0x18) < 8) {\n                var_38h = in_ECX + 4;\n            }\n            else {\n                var_38h = *(in_ECX + 4);\n            }\n            fcn.00404a30(var_38h, var_44h + arg_ch * 2, var_4h << 1);\n            *(in_ECX + 0x14) = var_4h;\n            if (*(in_ECX + 0x18) < 8) {\n                var_48h = in_ECX + 4;\n            }\n            else {\n                var_48h = *(in_ECX + 4);\n            }\n            *(var_48h + var_4h * 2) = 0;\n        }\n    }\n    return in_ECX;\n}\n",
        "token_count": 500
    },
    "00409a4f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00409a4f(int32_t arg_8h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = *(arg_8h + 0x10);\n    iVar7 = 0;\n    for (iVar3 = *(arg_8h + 8); -1 < iVar3; iVar3 = iVar3 << 1) {\n        iVar7 = iVar7 + 1;\n    }\n    iVar3 = iVar7 * 0x204 + 0x144 + iVar2;\n    iVar6 = 0x3f;\n    iVar4 = iVar3;\n    do {\n        *(iVar4 + 8) = iVar4;\n        *(iVar4 + 4) = iVar4;\n        iVar4 = iVar4 + 8;\n        iVar6 = iVar6 + -1;\n    } while (iVar6 != 0);\n    uVar8 = iVar7 * 0x8000 + *(arg_8h + 0xc);\n    iVar4 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(uVar8, 0x8000, 0x1000, 4);\n    if (iVar4 == 0) {\n        iVar7 = -1;\n    }\n    else {\n        if (uVar8 <= uVar8 + 0x7000) {\n            piVar5 = uVar8 + 0x10;\n            iVar4 = ((uVar8 + 0x7000) - uVar8 >> 0xc) + 1;\n            do {\n                piVar5[-2] = -1;\n                piVar5[0x3fb] = -1;\n                *piVar5 = piVar5 + 0x3ff;\n                piVar5[-1] = 0xff0;\n                piVar5[1] = piVar5 + -0x401;\n                piVar5[0x3fa] = 0xff0;\n                piVar5 = piVar5 + 0x400;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n        *(iVar3 + 0x1fc) = uVar8 + 0xc;\n        *(uVar8 + 0x14) = iVar3 + 0x1f8;\n        *(iVar3 + 0x200) = uVar8 + 0x700c;\n        *(uVar8 + 0x7010) = iVar3 + 0x1f8;\n        *(iVar2 + 0x44 + iVar7 * 4) = 0;\n        *(iVar2 + 0xc4 + iVar7 * 4) = 1;\n        cVar1 = *(iVar2 + 0x43);\n        *(iVar2 + 0x43) = cVar1 + '\\x01';\n        if (cVar1 == '\\0') {\n            *(arg_8h + 4) = *(arg_8h + 4) | 1;\n        }\n        *(arg_8h + 8) = *(arg_8h + 8) & ~(0x80000000U >> (iVar7 & 0x1f));\n    }\n    return iVar7;\n}\n",
        "token_count": 765
    },
    "00407c58": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.00407c58(int32_t param_1, int32_t param_2, uint param_3)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iStack12;\n    uint uStack8;\n    \n    puVar4 = &stack0xfffffffc;\n    if ((*(param_1 + 4) & 6) == 0) {\n        iStack12 = param_1;\n        uStack8 = param_3;\n        *(param_2 + -4) = &iStack12;\n        iVar5 = *(param_2 + 0xc);\n        iVar3 = *(param_2 + 8);\n        iVar2 = fcn.0040d0b0(param_2);\n        if (iVar2 == 0) {\n            *(param_1 + 4) = *(param_1 + 4) | 8;\n        }\n        else {\n            for (; iVar5 != -1; iVar5 = *(iVar3 + iVar5 * 0xc)) {\n                pcVar1 = *(iVar3 + 4 + iVar5 * 0xc);\n                if (pcVar1 != NULL) {\n                    iVar3 = (*pcVar1)();\n                    param_2 = *(puVar4 + 0xc);\n                    if (iVar3 != 0) {\n                        if (iVar3 < 0) {\n                            return 0;\n                        }\n                        iVar3 = *(param_2 + 8);\n                        fcn.0040477c(param_2);\n                        puVar4 = param_2 + 0x10;\n                        fcn.004047be(param_2, iVar5);\n                        fcn.00404852(1);\n                        *(param_2 + 0xc) = *(iVar3 + extraout_ECX * 4);\n                        param_2 = 0;\n                        iVar5 = 0;\n                        (**(iVar3 + 8 + extraout_ECX * 4))();\n                    }\n                }\n                iVar3 = *(param_2 + 8);\n            }\n        }\n    }\n    else {\n        fcn.004047be(param_2, 0xffffffff, &stack0xfffffffc, &stack0xfffffffc);\n    }\n    return 1;\n}\n",
        "token_count": 512
    },
    "004082fd": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004082fd(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *arg_8h_00;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00407c04(0x416670, 0x14);\n    *(unaff_EBP + -0x20) = 0xffffffff;\n    fcn.0040953e(0xd);\n    *(unaff_EBP + -4) = 0;\n    *0x41bac8 = 0;\n    iVar1 = *(unaff_EBP + 8);\n    if (iVar1 == -2) {\n        *0x41bac8 = 1;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetOEMCP)();\n    }\n    else if (iVar1 == -3) {\n        *0x41bac8 = 1;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetACP)();\n    }\n    else if (iVar1 == -4) {\n        *0x41bac8 = 1;\n        iVar1 = *0x41bd9c;\n    }\n    *(unaff_EBP + 8) = iVar1;\n    arg_8h_00 = *0x41c1b8;\n    if (iVar1 == *0x41c2c4) {\n        *(unaff_EBP + -0x20) = 0;\n    }\n    else {\n        *(unaff_EBP + -0x24) = *0x41c1b8;\n        if ((arg_8h_00 == NULL) || (*arg_8h_00 != 0)) {\n            arg_8h_00 = fcn.00405bcb(0x220);\n            *(unaff_EBP + -0x24) = arg_8h_00;\n        }\n        if (arg_8h_00 != NULL) {\n            iVar1 = fcn.0040815d(*(unaff_EBP + 8));\n            *(unaff_EBP + -0x20) = iVar1;\n            if (iVar1 == 0) {\n                *arg_8h_00 = 0;\n                arg_8h_00[1] = *0x41c2c4;\n                arg_8h_00[2] = *0x41c1bc;\n                arg_8h_00[3] = *0x41c140;\n                for (iVar1 = 0; *(unaff_EBP + -0x1c) = iVar1,  iVar1 < 5; iVar1 = iVar1 + 1) {\n                    *(arg_8h_00 + iVar1 * 2 + 0x10) = *(iVar1 * 2 + 0x41c2d0);\n                }\n                for (iVar1 = 0; *(unaff_EBP + -0x1c) = iVar1,  iVar1 < 0x101; iVar1 = iVar1 + 1) {\n                    *(iVar1 + 0x1c + arg_8h_00) = *(iVar1 + 0x41c1c0);\n                }\n                for (iVar1 = 0; *(unaff_EBP + -0x1c) = iVar1,  *0x41c1b8 = arg_8h_00,  iVar1 < 0x100; iVar1 = iVar1 + 1)\n                {\n                    *(iVar1 + 0x11d + arg_8h_00) = *(iVar1 + 0x41c2e0);\n                }\n            }\n        }\n        if ((*(unaff_EBP + -0x20) == -1) && (arg_8h_00 != *0x41c1b8)) {\n            fcn.00406cec(arg_8h_00);\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00408444();\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 927
    },
    "0040cdb0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint32_t fcn.0040cdb0(uint32_t *param_1, uint32_t *param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint8_t uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint32_t *puVar8;\n    bool bVar9;\n    \n    uVar3 = param_3;\n    if (param_3 != 0) {\n        if (((param_1 | param_2) & 3) == 0) {\n            uVar3 = param_3 & 3;\n            param_3 = param_3 >> 2;\n            bVar9 = param_3 == 0;\n            puVar7 = param_1;\n            puVar8 = param_2;\n            if (!bVar9) {\n                do {\n                    param_1 = puVar7;\n                    param_2 = puVar8;\n                    if (param_3 == 0) break;\n                    param_3 = param_3 - 1;\n                    param_2 = puVar8 + 1;\n                    param_1 = puVar7 + 1;\n                    bVar9 = *puVar7 == *puVar8;\n                    puVar7 = param_1;\n                    puVar8 = param_2;\n                } while (bVar9);\n                if (!bVar9) {\n                    uVar3 = param_1[-1];\n                    uVar1 = param_2[-1];\n                    bVar9 = uVar3 < uVar1;\n                    if (((uVar3 == uVar1) &&\n                        (uVar5 = uVar3 >> 8,  uVar6 = uVar1 >> 8,  bVar9 = uVar5 < uVar6,  uVar5 == uVar6)) &&\n                       (uVar5 = uVar3 >> 0x10,  uVar6 = uVar1 >> 0x10,  bVar9 = uVar5 < uVar6,  uVar5 == uVar6)) {\n                        bVar9 = uVar3 >> 0x18 < uVar1 >> 0x18;\n                    }\n                    goto code_r0x0040ce30;\n                }\n            }\n            if (uVar3 != 0) {\n                uVar1 = *param_1;\n                uVar2 = *param_2;\n                bVar9 = uVar1 < uVar2;\n                if (uVar1 != uVar2) {\ncode_r0x0040ce30:\n                    return (1 - bVar9) - (bVar9 != 0);\n                }\n                uVar4 = uVar3 - 1;\n                if (uVar4 != 0) {\n                    uVar5 = uVar2 >> 8;\n                    uVar6 = uVar1 >> 8;\n                    bVar9 = uVar6 < uVar5;\n                    if (uVar6 != uVar5) goto code_r0x0040ce30;\n                    uVar4 = uVar3 - 2;\n                    if (uVar4 != 0) {\n                        bVar9 = (uVar1 & 0xff0000) < (uVar2 & 0xff0000);\n                        if ((uVar1 & 0xff0000) != (uVar2 & 0xff0000)) goto code_r0x0040ce30;\n                        uVar4 = uVar3 - 3;\n                    }\n                }\n                return uVar4;\n            }\n        }\n        else {\n            if ((param_3 & 1) == 0) goto code_r0x0040cde3;\n            bVar9 = *param_1 < *param_2;\n            if (*param_1 != *param_2) goto code_r0x0040ce30;\n            param_1 = param_1 + 1;\n            param_2 = param_2 + 1;\n            for (param_3 = param_3 - 1; uVar3 = param_3,  param_3 != 0; param_3 = param_3 - 2) {\ncode_r0x0040cde3:\n                bVar9 = *param_1 < *param_2;\n                if ((*param_1 != *param_2) ||\n                   (bVar9 = *(param_1 + 1) < *(param_2 + 1),  *(param_1 + 1) != *(param_2 + 1))) goto code_r0x0040ce30;\n                param_2 = param_2 + 2;\n                param_1 = param_1 + 2;\n            }\n        }\n    }\n    return uVar3;\n}\n",
        "token_count": 1050
    },
    "00404317": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid fcn.00404317(void)\n\n{\n    code *pcVar1;\n    code *var_10h;\n    char *var_4h;\n    \n    if ((*0x41ba94 & 1) == 0) {\n        *0x41ba94 = *0x41ba94 | 1;\n        var_4h = \"bad allocation\";\n        fcn.00405938(&var_4h);\n        *0x41ba88 = vtable.std::bad_alloc.0;\n        fcn.00405d02(0x414a43);\n    }\n    fcn.00405975(0x41ba88);\n    var_10h = vtable.std::bad_alloc.0;\n    fcn.0040558d(&var_10h, 0x41997c);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 197
    },
    "0040c6b9": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040c6b9(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint var_7ch;\n    uint var_4h;\n    \n    var_4h = *0x41ad6c;\n    uVar1 = fcn.0040c667();\n    iVar2 = (**0x41bdd0)(uVar1, (-(*0x41bdc0 != 0) & 0xfffff005) + 0x1002, &var_7ch, 0x78);\n    if (iVar2 == 0) {\n        *0x41bdb0 = 0;\n    }\n    else {\n        iVar2 = fcn.0040e5e5(*0x41bdc4, &var_7ch);\n        if ((iVar2 == 0) && (iVar2 = fcn.0040c566(uVar1),  iVar2 != 0)) {\n            *0x41bdb0 = *0x41bdb0 | 4;\n            *0x41bdb4 = uVar1;\n            *0x41bdb8 = uVar1;\n        }\n    }\n    fcn.0040cd9b();\n    return;\n}\n",
        "token_count": 273
    },
    "0040c7be": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040c7be(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uint arg_ch;\n    uint var_7ch;\n    uint var_4h;\n    \n    var_4h = *0x41ad6c;\n    arg_8h_00 = fcn.0040c667();\n    iVar1 = (**0x41bdd0)(arg_8h_00, (-(*0x41bdc0 != 0) & 0xfffff005) + 0x1002, &var_7ch, 0x78);\n    if (iVar1 == 0) {\n        *0x41bdb0 = 0;\n        goto code_r0x0040c9cb;\n    }\n    iVar1 = fcn.0040e5e5(*0x41bdc4, &var_7ch);\n    if (iVar1 == 0) {\n        iVar1 = (**0x41bdd0)(arg_8h_00, (-(*0x41bdbc != 0) & 0xfffff002) + 0x1001, &var_7ch, 0x78);\n        if (iVar1 != 0) {\n            iVar1 = fcn.0040e5e5(*0x41bdcc, &var_7ch);\n            if (iVar1 == 0) {\n                *0x41bdb0 = *0x41bdb0 | 0x304;\n                *0x41bdb4 = arg_8h_00;\n                *0x41bdb8 = arg_8h_00;\n            }\n            else if ((*0x41bdb0 & 2) == 0) {\n                if ((*0x41bdc8 == 0) || (iVar1 = fcn.0040e64e(*0x41bdcc, &var_7ch, *0x41bdc8),  iVar1 != 0)) {\n                    if (((*0x41bdb0 & 1) == 0) && (iVar1 = fcn.0040c566(arg_8h_00),  iVar1 != 0)) {\n                        *0x41bdb0 = *0x41bdb0 | 1;\n                        *0x41bdb8 = arg_8h_00;\n                    }\n                }\n                else {\n                    *0x41bdb0 = *0x41bdb0 | 2;\n                    *0x41bdb8 = arg_8h_00;\n                    iVar1 = fcn.004049a0(*0x41bdcc);\n                    if (iVar1 == *0x41bdc8) {\n                        *0x41bdb4 = arg_8h_00;\n                    }\n                }\n            }\n            goto code_r0x0040c8e9;\n        }\ncode_r0x0040c91d:\n        *0x41bdb0 = 0;\n        goto code_r0x0040c9cb;\n    }\ncode_r0x0040c8e9:\n    if ((*0x41bdb0 & 0x300) == 0x300) goto code_r0x0040c9cb;\n    iVar1 = (**0x41bdd0)(arg_8h_00, (-(*0x41bdbc != 0) & 0xfffff002) + 0x1001, &var_7ch, 0x78);\n    if (iVar1 == 0) goto code_r0x0040c91d;\n    iVar1 = fcn.0040e5e5(*0x41bdcc, &var_7ch);\n    if (iVar1 == 0) {\n        *0x41bdb0 = *0x41bdb0 | 0x200;\n        if (((*0x41bdbc == 0) && (*0x41bdc8 != 0)) && (iVar1 = fcn.004049a0(*0x41bdcc),  iVar1 == *0x41bdc8)) {\n            arg_ch = 1;\n            goto code_r0x0040c99b;\n        }\n    }\n    else {\n        if (((*0x41bdbc != 0) || (*0x41bdc8 == 0)) ||\n           (iVar1 = fcn.0040e64e(*0x41bdcc, &var_7ch, *0x41bdc8),  iVar1 != 0)) goto code_r0x0040c9cb;\n        arg_ch = 0;\ncode_r0x0040c99b:\n        iVar1 = fcn.0040c74d(arg_8h_00, arg_ch);\n        if (iVar1 == 0) goto code_r0x0040c9cb;\n    }\n    *0x41bdb0 = *0x41bdb0 | 0x100;\n    if (*0x41bdb4 == 0) {\n        *0x41bdb4 = arg_8h_00;\n    }\ncode_r0x0040c9cb:\n    fcn.0040cd9b();\n    return;\n}\n",
        "token_count": 1128
    },
    "0040e733": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h_2\n\nvoid __cdecl fcn.0040e733(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    char *pcVar4;\n    uint var_8h;\n    uint var_ch;\n    uint var_128h_2;\n    uint var_124h_2;\n    uint var_128h;\n    uint lpFilename;\n    uint var_18h_2;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint uStack4;\n    \n    uStack4 = 0x118;\n    var_18h = 0x4182c8;\n    fcn.00407c04();\n    *(unaff_EBP + -0x1c) = *0x41ad6c;\n    pcVar1 = *0x41bf40;\n    if (*0x41bf40 == NULL) {\n        if (*(unaff_EBP + 8) == 1) {\n            pcVar4 = \"Buffer overrun detected!\";\n            *(unaff_EBP + -0x128) =\n                 \"A buffer overrun has been detected which has corrupted the program\\'s\\ninternal state.  The program cannot safely continue execution and must\\nnow be terminated.\\n\"\n            ;\n        }\n        else {\n            pcVar4 = \"Unknown security failure detected!\";\n            *(unaff_EBP + -0x128) =\n                 \"A security error of unknown cause has been detected which has\\ncorrupted the program\\'s internal state.  The program cannot safely\\ncontinue execution and must now be terminated.\\n\"\n            ;\n        }\n        *(unaff_EBP + -0x20) = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, unaff_EBP + -0x124, 0x104);\n        if (iVar2 == 0) {\n            fcn.00404f40(unaff_EBP + -0x124, \"<program name unknown>\");\n        }\n        iVar2 = unaff_EBP + -0x124;\n        iVar3 = fcn.004049a0(iVar2);\n        if (0x3c < iVar3 + 0xbU) {\n            iVar2 = fcn.004049a0(iVar2);\n            iVar2 = iVar2 + unaff_EBP + -0x155;\n            fcn.00407da0(iVar2, 0x416a90, 3);\n        }\n        fcn.004049a0(iVar2);\n        fcn.00407d60();\n        *(unaff_EBP + -0x18) = &var_18h;\n        fcn.00404f40(&var_18h, pcVar4);\n        fcn.00404f50(&var_18h, 0x416a70);\n        fcn.00404f50(&var_18h, \"Program: \");\n        fcn.00404f50(&var_18h, iVar2);\n        fcn.00404f50(&var_18h, 0x416a70);\n        fcn.00404f50(&var_18h, *(unaff_EBP + -0x128));\n        fcn.0040d6b1(&var_18h, \"Microsoft Visual C++ Runtime Library\", 0x12010);\n    }\n    else {\n        *(unaff_EBP + -4) = 0;\n        (*pcVar1)(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    fcn.00408809(3);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 910
    },
    "00404a30": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00404a30(uint *arg_8h, uint *arg_ch, uint32_t arg_10h)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    if ((arg_ch < arg_8h) && (arg_8h < arg_10h + arg_ch)) {\n        arg_ch = (arg_10h - 4) + arg_ch;\n        puVar1 = (arg_10h - 4) + arg_8h;\n        if ((puVar1 & 3) == 0) {\n            uVar3 = arg_10h >> 2;\n            if (uVar3 < 8) goto code_r0x00404bf4;\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + -1;\n                puVar1 = puVar1 + -1;\n            }\n    // switch table (4 cases) at 0x404d18\n            switch(*((arg_10h & 3) * 4 + 0x404d18)) {\n            case 0x404d30:\ncode_r0x00404d30:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                return arg_8h;\n            case 0x404d40:\ncode_r0x00404d40:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                return arg_8h;\n            case 0x404d54:\ncode_r0x00404d54:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                *(puVar1 + 1) = *(arg_ch + 1);\n                return arg_8h;\n            }\n        }\n        else if (arg_10h < 4) {\n    // switch table (4 cases) at 0x404d18\n            switch(*(arg_10h * 4 + 0x404d18)) {\n            case 0x404d30:\n                goto code_r0x00404d30;\n            case 0x404d40:\n                goto code_r0x00404d40;\n            case 0x404d54:\n                goto code_r0x00404d54;\n            }\n        }\n        else {\n            arg_10h = arg_10h - (puVar1 & 3);\n            switch(*((puVar1 & 3) * 4 + 0x404c1c)) {\n            case 0x404c2c:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                arg_ch = arg_ch + -1;\n                uVar3 = arg_10h >> 2;\n                puVar1 = puVar1 - 1;\n                if (uVar3 < 8) {\ncode_r0x00404bf4:\n    // WARNING: Could not recover jumptable at 0x00404bf6. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (1 cases) at 0x404cc8\n                    puVar1 = (**(uVar3 * -4 + 0x404cc8))();\n                    return puVar1;\n                }\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x404d18)) {\n                case 0x404d30:\n                    goto code_r0x00404d30;\n                case 0x404d40:\n                    goto code_r0x00404d40;\n                case 0x404d54:\n                    goto code_r0x00404d54;\n                }\n                break;\n            case 0x404c50:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 2) = *(arg_ch + 2);\n                arg_ch = arg_ch + -2;\n                puVar1 = puVar1 - 2;\n                if (uVar3 < 8) goto code_r0x00404bf4;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x404d18)) {\n                case 0x404d30:\n                    goto code_r0x00404d30;\n                case 0x404d40:\n                    goto code_r0x00404d40;\n                case 0x404d54:\n                    goto code_r0x00404d54;\n                }\n                break;\n            case 0x404c78:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 1) = *(arg_ch + 1);\n                arg_ch = arg_ch + -3;\n                puVar1 = puVar1 - 3;\n                if (uVar3 < 8) goto code_r0x00404bf4;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x404d18)) {\n                case 0x404d30:\n                    goto code_r0x00404d30;\n                case 0x404d40:\n                    goto code_r0x00404d40;\n                case 0x404d54:\n                    goto code_r0x00404d54;\n                }\n            }\n        }\n        return arg_8h;\n    }\n    puVar1 = arg_8h;\n    if ((arg_8h & 3) == 0) {\n        uVar2 = arg_10h >> 2;\n        if (uVar2 < 8) goto code_r0x00404a8c;\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar1 = *arg_ch;\n            arg_ch = arg_ch + 1;\n            puVar1 = puVar1 + 1;\n        }\n    // switch table (4 cases) at 0x404b7c\n        switch(*((arg_10h & 3) * 4 + 0x404b7c)) {\n        case 0x404b94:\ncode_r0x00404b94:\n            *puVar1 = *arg_ch;\n            return arg_8h;\n        case 0x404ba0:\ncode_r0x00404ba0:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            return arg_8h;\n        case 0x404bb4:\ncode_r0x00404bb4:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            *(puVar1 + 2) = *(arg_ch + 2);\n            return arg_8h;\n        }\n    }\n    else if (arg_10h < 4) {\n        switch(*((arg_10h - 4) * 4 + 0x404b8c)) {\n        case 0x404b94:\n            goto code_r0x00404b94;\n        case 0x404ba0:\n            goto code_r0x00404ba0;\n        case 0x404bb4:\n            goto code_r0x00404bb4;\n        }\n    }\n    else {\n        uVar3 = (arg_10h - 4) + (arg_8h & 3);\n        switch(*((arg_8h & 3) * 4 + 0x404a90)) {\n        case 0x404aa0:\n            *arg_8h = *arg_ch;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 2) = *(arg_ch + 2);\n            arg_ch = arg_ch + 3;\n            puVar1 = arg_8h + 3;\n            if (uVar2 < 8) {\ncode_r0x00404a8c:\n    // WARNING: Could not recover jumptable at 0x00404a8c. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (8 cases) at 0x404b10\n                puVar1 = (**(uVar2 * 4 + 0x404b10))();\n                return puVar1;\n            }\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x404b7c)) {\n            case 0x404b94:\n                goto code_r0x00404b94;\n            case 0x404ba0:\n                goto code_r0x00404ba0;\n            case 0x404bb4:\n                goto code_r0x00404bb4;\n            }\n            break;\n        case 0x404acc:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            arg_ch = arg_ch + 2;\n            puVar1 = arg_8h + 2;\n            if (uVar2 < 8) goto code_r0x00404a8c;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x404b7c)) {\n            case 0x404b94:\n                goto code_r0x00404b94;\n            case 0x404ba0:\n                goto code_r0x00404ba0;\n            case 0x404bb4:\n                goto code_r0x00404bb4;\n            }\n            break;\n        case 0x404af0:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            arg_ch = arg_ch + 1;\n            puVar1 = arg_8h + 1;\n            if (uVar2 < 8) goto code_r0x00404a8c;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x404b7c)) {\n            case 0x404b94:\n                goto code_r0x00404b94;\n            case 0x404ba0:\n                goto code_r0x00404ba0;\n            case 0x404bb4:\n                goto code_r0x00404bb4;\n            }\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 2701
    },
    "004051e0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint32_t * fcn.004051e0(uint32_t *param_1, uint8_t param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t *puVar4;\n    \n    if (param_3 == 0) {\n        return param_1;\n    }\n    uVar1 = param_2;\n    puVar4 = param_1;\n    if (3 < param_3) {\n        uVar2 = -param_1 & 3;\n        uVar3 = param_3;\n        if (uVar2 != 0) {\n            uVar3 = param_3 - uVar2;\n            do {\n                *puVar4 = param_2;\n                puVar4 = puVar4 + 1;\n                uVar2 = uVar2 - 1;\n            } while (uVar2 != 0);\n        }\n        uVar1 = uVar1 * 0x1010101;\n        param_3 = uVar3 & 3;\n        uVar3 = uVar3 >> 2;\n        if (uVar3 != 0) {\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar4 = uVar1;\n                puVar4 = puVar4 + 1;\n            }\n            if (param_3 == 0) {\n                return param_1;\n            }\n        }\n    }\n    do {\n        *puVar4 = uVar1;\n        puVar4 = puVar4 + 1;\n        param_3 = param_3 - 1;\n    } while (param_3 != 0);\n    return param_1;\n}\n",
        "token_count": 387
    },
    "00405250": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00405250(uint *arg_8h, uint *arg_ch, uint32_t arg_10h)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    if ((arg_ch < arg_8h) && (arg_8h < arg_10h + arg_ch)) {\n        arg_ch = (arg_10h - 4) + arg_ch;\n        puVar1 = (arg_10h - 4) + arg_8h;\n        if ((puVar1 & 3) == 0) {\n            uVar3 = arg_10h >> 2;\n            if (uVar3 < 8) goto code_r0x00405414;\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + -1;\n                puVar1 = puVar1 + -1;\n            }\n    // switch table (4 cases) at 0x405538\n            switch(*((arg_10h & 3) * 4 + 0x405538)) {\n            case 0x405550:\ncode_r0x00405550:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                return arg_8h;\n            case 0x405560:\ncode_r0x00405560:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                return arg_8h;\n            case 0x405574:\ncode_r0x00405574:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                *(puVar1 + 1) = *(arg_ch + 1);\n                return arg_8h;\n            }\n        }\n        else if (arg_10h < 4) {\n    // switch table (4 cases) at 0x405538\n            switch(*(arg_10h * 4 + 0x405538)) {\n            case 0x405550:\n                goto code_r0x00405550;\n            case 0x405560:\n                goto code_r0x00405560;\n            case 0x405574:\n                goto code_r0x00405574;\n            }\n        }\n        else {\n            arg_10h = arg_10h - (puVar1 & 3);\n            switch(*((puVar1 & 3) * 4 + 0x40543c)) {\n            case 0x40544c:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                arg_ch = arg_ch + -1;\n                uVar3 = arg_10h >> 2;\n                puVar1 = puVar1 - 1;\n                if (uVar3 < 8) {\ncode_r0x00405414:\n    // WARNING: Could not recover jumptable at 0x00405416. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (1 cases) at 0x4054e8\n                    puVar1 = (**(uVar3 * -4 + 0x4054e8))();\n                    return puVar1;\n                }\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x405538)) {\n                case 0x405550:\n                    goto code_r0x00405550;\n                case 0x405560:\n                    goto code_r0x00405560;\n                case 0x405574:\n                    goto code_r0x00405574;\n                }\n                break;\n            case 0x405470:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 2) = *(arg_ch + 2);\n                arg_ch = arg_ch + -2;\n                puVar1 = puVar1 - 2;\n                if (uVar3 < 8) goto code_r0x00405414;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x405538)) {\n                case 0x405550:\n                    goto code_r0x00405550;\n                case 0x405560:\n                    goto code_r0x00405560;\n                case 0x405574:\n                    goto code_r0x00405574;\n                }\n                break;\n            case 0x405498:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 1) = *(arg_ch + 1);\n                arg_ch = arg_ch + -3;\n                puVar1 = puVar1 - 3;\n                if (uVar3 < 8) goto code_r0x00405414;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x405538)) {\n                case 0x405550:\n                    goto code_r0x00405550;\n                case 0x405560:\n                    goto code_r0x00405560;\n                case 0x405574:\n                    goto code_r0x00405574;\n                }\n            }\n        }\n        return arg_8h;\n    }\n    puVar1 = arg_8h;\n    if ((arg_8h & 3) == 0) {\n        uVar2 = arg_10h >> 2;\n        if (uVar2 < 8) goto code_r0x004052ac;\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar1 = *arg_ch;\n            arg_ch = arg_ch + 1;\n            puVar1 = puVar1 + 1;\n        }\n    // switch table (4 cases) at 0x40539c\n        switch(*((arg_10h & 3) * 4 + 0x40539c)) {\n        case 0x4053b4:\ncode_r0x004053b4:\n            *puVar1 = *arg_ch;\n            return arg_8h;\n        case 0x4053c0:\ncode_r0x004053c0:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            return arg_8h;\n        case 0x4053d4:\ncode_r0x004053d4:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            *(puVar1 + 2) = *(arg_ch + 2);\n            return arg_8h;\n        }\n    }\n    else if (arg_10h < 4) {\n        switch(*((arg_10h - 4) * 4 + 0x4053ac)) {\n        case 0x4053b4:\n            goto code_r0x004053b4;\n        case 0x4053c0:\n            goto code_r0x004053c0;\n        case 0x4053d4:\n            goto code_r0x004053d4;\n        }\n    }\n    else {\n        uVar3 = (arg_10h - 4) + (arg_8h & 3);\n        switch(*((arg_8h & 3) * 4 + 0x4052b0)) {\n        case 0x4052c0:\n            *arg_8h = *arg_ch;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 2) = *(arg_ch + 2);\n            arg_ch = arg_ch + 3;\n            puVar1 = arg_8h + 3;\n            if (uVar2 < 8) {\ncode_r0x004052ac:\n    // WARNING: Could not recover jumptable at 0x004052ac. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (8 cases) at 0x405330\n                puVar1 = (**(uVar2 * 4 + 0x405330))();\n                return puVar1;\n            }\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x40539c)) {\n            case 0x4053b4:\n                goto code_r0x004053b4;\n            case 0x4053c0:\n                goto code_r0x004053c0;\n            case 0x4053d4:\n                goto code_r0x004053d4;\n            }\n            break;\n        case 0x4052ec:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            arg_ch = arg_ch + 2;\n            puVar1 = arg_8h + 2;\n            if (uVar2 < 8) goto code_r0x004052ac;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x40539c)) {\n            case 0x4053b4:\n                goto code_r0x004053b4;\n            case 0x4053c0:\n                goto code_r0x004053c0;\n            case 0x4053d4:\n                goto code_r0x004053d4;\n            }\n            break;\n        case 0x405310:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            arg_ch = arg_ch + 1;\n            puVar1 = arg_8h + 1;\n            if (uVar2 < 8) goto code_r0x004052ac;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x40539c)) {\n            case 0x4053b4:\n                goto code_r0x004053b4;\n            case 0x4053c0:\n                goto code_r0x004053c0;\n            case 0x4053d4:\n                goto code_r0x004053d4;\n            }\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 2655
    },
    "00408735": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x004087c7: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x004087cc)\n// WARNING: Removing unreachable block (ram,0x004087f2)\n// WARNING: Removing unreachable block (ram,0x004087d1)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00408735(uint uExitCode, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00407c04(0x416698, 8);\n    fcn.0040953e(8);\n    *(unaff_EBP + -4) = 0;\n    if (*0x41bb14 == 1) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(*(unaff_EBP + 8));\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1);\n    }\n    *0x41bb10 = 1;\n    *0x41bb0c = *(unaff_EBP + 0x10);\n    if (*(unaff_EBP + 0xc) == 0) {\n        if (*0x41c134 != NULL) {\n            while( true ) {\n                *0x41c130 = *0x41c130 + -1;\n                if (*0x41c130 < *0x41c134) break;\n                if (**0x41c130 != NULL) {\n                    (***0x41c130)();\n                }\n            }\n        }\n        fcn.00408695(0x41a828);\n    }\n    fcn.00408695(0x41ab34);\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + 0x10) != 0) {\n        fcn.00409471(8);\n    }\n    return;\n}\n",
        "token_count": 441
    },
    "0040440f": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040440f(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    uint var_4h;\n    \n    uVar1 = fcn.00406866(arg_8h, arg_ch, arg_10h, arg_14h, in_EAX, 0, 0, 0);\n    return uVar1;\n}\n",
        "token_count": 103
    },
    "004050bb": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004050bb(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    \n    if ((arg_10h == 10) && (arg_8h < 0)) {\n        uVar1 = 1;\n        arg_10h = 10;\n    }\n    else {\n        uVar1 = 0;\n    }\n    fcn.0040507d(arg_10h, uVar1);\n    return arg_ch;\n}\n",
        "token_count": 115
    },
    "004050e5": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004050e5(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    \n    uVar1 = 0;\n    if ((arg_10h == 10) && (arg_8h < 0)) {\n        uVar1 = 1;\n    }\n    fcn.0040507d(arg_10h, uVar1);\n    return arg_ch;\n}\n",
        "token_count": 102
    },
    "0040b6f1": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nuint32_t fcn.0040b6f1(void)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    uint32_t uVar12;\n    uint32_t uVar13;\n    uint32_t uVar14;\n    uint32_t uVar15;\n    uint32_t uVar16;\n    uint32_t uVar17;\n    uint32_t uVar18;\n    uint32_t uVar19;\n    uint32_t uVar20;\n    uint32_t uVar21;\n    uint32_t uVar22;\n    uint32_t uVar23;\n    uint32_t uVar24;\n    uint32_t uVar25;\n    uint32_t uVar26;\n    uint32_t uVar27;\n    uint32_t uVar28;\n    uint32_t uVar29;\n    uint32_t uVar30;\n    uint32_t uVar31;\n    uint32_t uVar32;\n    uint32_t uVar33;\n    uint32_t uVar34;\n    uint32_t uVar35;\n    uint32_t uVar36;\n    uint32_t uVar37;\n    uint32_t uVar38;\n    uint32_t uVar39;\n    uint32_t uVar40;\n    uint32_t uVar41;\n    uint32_t uVar42;\n    uint32_t uVar43;\n    uint32_t uVar44;\n    uint32_t arg_ch;\n    int32_t unaff_ESI;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = *0x41bdf6;\n    arg_ch = *0x41bdf8;\n    if (unaff_ESI == 0) {\n        return 0xffffffff;\n    }\n    uVar2 = fcn.0040e4be(1, uVar1, 0x31, unaff_ESI + 4);\n    uVar3 = fcn.0040e4be(1, uVar1, 0x32, unaff_ESI + 8);\n    uVar4 = fcn.0040e4be(1, uVar1, 0x33, unaff_ESI + 0xc);\n    uVar5 = fcn.0040e4be(1, uVar1, 0x34, unaff_ESI + 0x10);\n    uVar6 = fcn.0040e4be(1, uVar1, 0x35, unaff_ESI + 0x14);\n    uVar7 = fcn.0040e4be(1, uVar1, 0x36, unaff_ESI + 0x18);\n    uVar8 = fcn.0040e4be(1, uVar1, 0x37, unaff_ESI);\n    uVar9 = fcn.0040e4be(1, uVar1, 0x2a, unaff_ESI + 0x20);\n    uVar10 = fcn.0040e4be(1, uVar1, 0x2b, unaff_ESI + 0x24);\n    uVar11 = fcn.0040e4be(1, uVar1, 0x2c, unaff_ESI + 0x28);\n    uVar12 = fcn.0040e4be(1, uVar1, 0x2d, unaff_ESI + 0x2c);\n    uVar13 = fcn.0040e4be(1, uVar1, 0x2e, unaff_ESI + 0x30);\n    uVar14 = fcn.0040e4be(1, uVar1, 0x2f, unaff_ESI + 0x34);\n    uVar15 = fcn.0040e4be(1, uVar1, 0x30, unaff_ESI + 0x1c);\n    uVar16 = fcn.0040e4be(1, uVar1, 0x44, unaff_ESI + 0x38);\n    uVar17 = fcn.0040e4be(1, uVar1, 0x45, unaff_ESI + 0x3c);\n    uVar18 = fcn.0040e4be(1, uVar1, 0x46, unaff_ESI + 0x40);\n    uVar19 = fcn.0040e4be(1, uVar1, 0x47, unaff_ESI + 0x44);\n    uVar20 = fcn.0040e4be(1, uVar1, 0x48, unaff_ESI + 0x48);\n    uVar21 = fcn.0040e4be(1, uVar1, 0x49, unaff_ESI + 0x4c);\n    uVar22 = fcn.0040e4be(1, uVar1, 0x4a, unaff_ESI + 0x50);\n    uVar23 = fcn.0040e4be(1, uVar1, 0x4b, unaff_ESI + 0x54);\n    uVar24 = fcn.0040e4be(1, uVar1, 0x4c, unaff_ESI + 0x58);\n    uVar25 = fcn.0040e4be(1, uVar1, 0x4d, unaff_ESI + 0x5c);\n    uVar26 = fcn.0040e4be(1, uVar1, 0x4e, unaff_ESI + 0x60);\n    uVar27 = fcn.0040e4be(1, uVar1, 0x4f, unaff_ESI + 100);\n    uVar28 = fcn.0040e4be(1, uVar1, 0x38, unaff_ESI + 0x68);\n    uVar29 = fcn.0040e4be(1, uVar1, 0x39, unaff_ESI + 0x6c);\n    uVar30 = fcn.0040e4be(1, uVar1, 0x3a, unaff_ESI + 0x70);\n    uVar31 = fcn.0040e4be(1, uVar1, 0x3b, unaff_ESI + 0x74);\n    uVar32 = fcn.0040e4be(1, uVar1, 0x3c, unaff_ESI + 0x78);\n    uVar33 = fcn.0040e4be(1, uVar1, 0x3d, unaff_ESI + 0x7c);\n    uVar34 = fcn.0040e4be(1, uVar1, 0x3e, unaff_ESI + 0x80);\n    uVar35 = fcn.0040e4be(1, uVar1, 0x3f, unaff_ESI + 0x84);\n    uVar36 = fcn.0040e4be(1, uVar1, 0x40, unaff_ESI + 0x88);\n    uVar37 = fcn.0040e4be(1, uVar1, 0x41, unaff_ESI + 0x8c);\n    uVar38 = fcn.0040e4be(1, uVar1, 0x42, unaff_ESI + 0x90);\n    uVar39 = fcn.0040e4be(1, uVar1, 0x43, unaff_ESI + 0x94);\n    uVar40 = fcn.0040e4be(1, uVar1, 0x28, unaff_ESI + 0x98);\n    uVar1 = fcn.0040e4be(1, uVar1, 0x29, unaff_ESI + 0x9c);\n    uVar41 = fcn.0040e4be(1, arg_ch, 0x1f, unaff_ESI + 0xa0);\n    uVar42 = fcn.0040e4be(1, arg_ch, 0x20, unaff_ESI + 0xa4);\n    uVar43 = fcn.0040e4be(1, arg_ch, 0x1003, unaff_ESI + 0xa8);\n    uVar44 = fcn.0040e4be(0, arg_ch, 0x1009, unaff_ESI + 0xb0);\n    *(unaff_ESI + 0xac) = arg_ch;\n    return uVar2 | uVar3 | uVar4 | uVar5 | uVar6 | uVar7 | uVar8 | uVar9 | uVar10 | uVar11 | uVar12 | uVar13 | uVar14 |\n           uVar15 | uVar16 | uVar17 | uVar18 | uVar19 | uVar20 | uVar21 | uVar22 | uVar23 | uVar24 | uVar25 | uVar26 |\n           uVar27 | uVar28 | uVar29 | uVar30 | uVar31 | uVar32 | uVar33 | uVar34 | uVar35 | uVar36 | uVar37 | uVar38 |\n           uVar39 | uVar40 | uVar1 | uVar41 | uVar42 | uVar43 | uVar44;\n}\n",
        "token_count": 2195
    },
    "00408c1a": {
        "rules": [
            "parse credit card information/92c3fd9898ba41b4bad3ffb6188f4688",
            "search for credit card data/212a26c2b8d740cd9f6579dba482d653"
        ],
        "decompiled_code": "\nuint fcn.00408c1a(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    int32_t iVar4;\n    \n    if (*0x41c138 == 0) {\n        fcn.0040844d();\n    }\n    iVar4 = 0;\n    pcVar3 = *0x41ba98;\n    if (*0x41ba98 != NULL) {\n        for (; *pcVar3 != '\\0'; pcVar3 = pcVar3 + iVar2 + 1) {\n            if (*pcVar3 != '=') {\n                iVar4 = iVar4 + 1;\n            }\n            iVar2 = fcn.004049a0(pcVar3);\n        }\n        piVar1 = fcn.00405bcb(iVar4 * 4 + 4);\n        pcVar3 = *0x41ba98;\n        *0x41baf4 = piVar1;\n        if (piVar1 != NULL) {\n            do {\n                if (*pcVar3 == '\\0') {\n                    fcn.00406cec(*0x41ba98);\n                    *0x41ba98 = NULL;\n                    *piVar1 = 0;\n                    *0x41c120 = 1;\n                    return 0;\n                }\n                iVar4 = fcn.004049a0(pcVar3);\n                if (*pcVar3 != '=') {\n                    iVar2 = fcn.00405bcb(iVar4 + 1);\n                    *piVar1 = iVar2;\n                    if (iVar2 == 0) {\n                        fcn.00406cec(*0x41baf4);\n                        *0x41baf4 = NULL;\n                        return 0xffffffff;\n                    }\n                    fcn.00404f40(iVar2, pcVar3);\n                    piVar1 = piVar1 + 1;\n                }\n                pcVar3 = pcVar3 + iVar4 + 1;\n            } while( true );\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 444
    },
    "0040ab46": {
        "rules": [
            "check for PEB NtGlobalFlag flag/02e6ad6983154968a9ea3bb4adc24b9d/10fcbce0171842839e4e3d1dbc7c6301"
        ],
        "decompiled_code": "\nuchar * fcn.0040ab46(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uchar *puVar6;\n    uint *puVar7;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar5 = *0x41b2d4;\n    var_4h = 0;\n    puVar7 = *0x41b2d4 + 0x38;\n    var_8h = 0xc;\n    do {\n        iVar1 = fcn.004049a0(puVar7[0xc]);\n        iVar2 = fcn.004049a0(*puVar7);\n        var_4h = iVar2 + var_4h + 2 + iVar1;\n        puVar7 = puVar7 + 1;\n        var_8h = var_8h + -1;\n    } while (var_8h != 0);\n    puVar3 = fcn.00405bcb(var_4h + 1);\n    if (puVar3 != NULL) {\n        puVar7 = iVar5 + 0x68;\n        iVar5 = 0xc;\n        puVar6 = puVar3;\n        do {\n            *puVar6 = 0x3a;\n            puVar6 = puVar6 + 1;\n            uVar4 = fcn.00404f40(puVar6, puVar7[-0xc]);\n            iVar1 = fcn.004049a0(uVar4);\n            puVar6 = puVar6 + iVar1;\n            *puVar6 = 0x3a;\n            uVar4 = fcn.00404f40(puVar6 + 1, *puVar7);\n            iVar1 = fcn.004049a0(uVar4);\n            puVar6 = puVar6 + 1 + iVar1;\n            puVar7 = puVar7 + 1;\n            iVar5 = iVar5 + -1;\n        } while (iVar5 != 0);\n        *puVar6 = 0;\n    }\n    return puVar3;\n}\n",
        "token_count": 482
    },
    "0040abdb": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\nint32_t fcn.0040abdb(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    int32_t var_10h;\n    uint *var_ch;\n    uint *var_8h;\n    int32_t *var_4h;\n    \n    iVar1 = *0x41b2d4;\n    iVar9 = 0;\n    var_4h = NULL;\n    do {\n        iVar2 = fcn.004049a0(*(var_4h * 4 + 0x1c + iVar1));\n        iVar3 = fcn.004049a0(*(var_4h * 4 + iVar1));\n        var_4h = var_4h + 1;\n        iVar9 = iVar3 + iVar9 + 2 + iVar2;\n    } while (var_4h < 7);\n    var_ch = iVar1 + 0x38;\n    var_8h = 0xc;\n    do {\n        iVar2 = fcn.004049a0(var_ch[0xc]);\n        iVar3 = fcn.004049a0(*var_ch);\n        var_ch = var_ch + 1;\n        var_8h = var_8h + -1;\n        iVar9 = iVar3 + iVar9 + 2 + iVar2;\n    } while (var_8h != NULL);\n    iVar2 = fcn.004049a0(*(iVar1 + 0x98));\n    iVar3 = fcn.004049a0(*(iVar1 + 0x9c));\n    iVar4 = fcn.004049a0(*(iVar1 + 0xa0));\n    iVar5 = fcn.004049a0(*(iVar1 + 0xa4));\n    iVar6 = fcn.004049a0(*(iVar1 + 0xa8));\n    iVar9 = fcn.00405bcb(iVar3 + iVar9 + iVar2 + iVar4 + iVar5 + iVar6 + 0xbd);\n    if (iVar9 != 0) {\n        iVar2 = iVar9 + 0xb8;\n        fcn.00404a30(iVar9, *0x41b2d4, 0xb8);\n        var_4h = NULL;\n        var_8h = iVar1 + 0x1c;\n        do {\n            *(iVar9 + var_4h * 4) = iVar2;\n            uVar7 = fcn.00404f40(iVar2, var_8h[-7]);\n            iVar3 = fcn.004049a0(uVar7);\n            iVar3 = iVar2 + 1 + iVar3;\n            *((iVar9 - iVar1) + var_8h) = iVar3;\n            uVar7 = fcn.00404f40(iVar3, *var_8h);\n            iVar2 = fcn.004049a0(uVar7);\n            var_8h = var_8h + 1;\n            var_4h = var_4h + 1;\n            iVar2 = iVar3 + 1 + iVar2;\n        } while (var_4h < 7);\n        var_4h = iVar9 + 0x68;\n        puVar8 = iVar1 + 0x38;\n        var_10h = 0xc;\n        do {\n            *(puVar8 + (iVar9 - iVar1)) = iVar2;\n            uVar7 = fcn.00404f40(iVar2, *puVar8);\n            iVar3 = fcn.004049a0(uVar7);\n            iVar3 = iVar2 + 1 + iVar3;\n            *var_4h = iVar3;\n            uVar7 = fcn.00404f40(iVar3, puVar8[0xc]);\n            iVar2 = fcn.004049a0(uVar7);\n            puVar8 = puVar8 + 1;\n            var_4h = var_4h + 1;\n            var_10h = var_10h + -1;\n            iVar2 = iVar3 + 1 + iVar2;\n        } while (var_10h != 0);\n        *(iVar9 + 0x98) = iVar2;\n        uVar7 = fcn.00404f40(iVar2, *(iVar1 + 0x98));\n        iVar3 = fcn.004049a0(uVar7);\n        iVar3 = iVar2 + 1 + iVar3;\n        *(iVar9 + 0x9c) = iVar3;\n        uVar7 = fcn.00404f40(iVar3, *(iVar1 + 0x9c));\n        iVar2 = fcn.004049a0(uVar7);\n        iVar2 = iVar3 + 1 + iVar2;\n        *(iVar9 + 0xa0) = iVar2;\n        uVar7 = fcn.00404f40(iVar2, *(iVar1 + 0xa0));\n        iVar3 = fcn.004049a0(uVar7);\n        iVar3 = iVar2 + 1 + iVar3;\n        *(iVar9 + 0xa4) = iVar3;\n        uVar7 = fcn.00404f40(iVar3, *(iVar1 + 0xa4));\n        iVar2 = fcn.004049a0(uVar7);\n        iVar2 = iVar3 + 1 + iVar2;\n        *(iVar9 + 0xa8) = iVar2;\n        fcn.00404f40(iVar2, *(iVar1 + 0xa8));\n    }\n    return iVar9;\n}\n",
        "token_count": 1260
    },
    "0040100a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_98h\n// WARNING: Variable defined which should be unmapped: var_94h\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl\nfcn.0040100a(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint noname_22, uint noname_23, uint noname_24, uint noname_25, \n            uint noname_26, uint noname_27, uint noname_28, uint noname_29, uint noname_30, uint noname_31, \n            uint noname_32, uint noname_33, uint noname_34, uint noname_35, uint noname_36, uint noname_37, \n            uint noname_38, uint noname_39, uint noname_40, uint noname_41, uint noname_42, uint noname_43, \n            uint noname_44, uint arg_8h)\n\n{\n    uint arg_ch;\n    int32_t iVar1;\n    uint *in_FS_OFFSET;\n    int32_t var_8h;\n    int32_t var_ch_2;\n    uint var_34h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint noname_3_00;\n    uint noname_4_00;\n    uint in_stack_ffffff48;\n    uint in_stack_ffffff4c;\n    uint in_stack_ffffff50;\n    int32_t var_98h;\n    uint var_94h;\n    uint var_90h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_50h;\n    uchar *puStack56;\n    int32_t var_2dh;\n    int32_t var_28h_2;\n    int32_t iStack40;\n    int32_t iStack36;\n    int32_t var_1ch_2;\n    int32_t iStack28;\n    int32_t var_14h_2;\n    uint32_t var_10h_2;\n    uint uStack16;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x4139a8;\n    uStack16 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xfffffff0;\n    iStack36 = var_8h;\n    iStack40 = var_8h + *(var_8h + 0x3c);\n    var_1ch_2 = var_8h + *(iStack40 + 0x78);\n    iStack28 = var_8h + *(var_1ch_2 + 0x20);\n    *0x8 = var_8h + *(var_1ch_2 + 0x1c);\n    var_28h_2 = var_8h + *(var_1ch_2 + 0x24);\n    var_10h_2 = 0;\n    do {\n        if (*(var_1ch_2 + 0x18) <= var_10h_2) {\n            var_8h = 0;\ncode_r0x00401b6f:\n            *in_FS_OFFSET = uStack16;\n            return var_8h;\n        }\n        var_14h_2 = var_8h + *(iStack28 + var_10h_2 * 4);\n        puStack56 = &stack0xffffff48;\n        noname_4_00 = 0;\n        noname_3_00 = 0;\n        fcn.00401069(0, 0);\n        arg_ch = fcn.004049a0(var_14h_2);\n        iVar1 = var_14h_2;\n        fcn.00401023(var_14h_2, arg_ch);\n        var_98h = fcn.0040105a(&fcn.0040100a::var_50h, iVar1, arg_ch, noname_3_00, noname_4_00, in_stack_ffffff48, \n                               in_stack_ffffff4c, in_stack_ffffff50);\n        var_4h = 0;\n        if (*(var_98h + 0x18) < 0x10) {\n            var_98h = var_98h + 4;\n        }\n        else {\n            var_98h = *(var_98h + 4);\n        }\n        in_stack_ffffff4c = 0x401b2a;\n        iVar1 = fcn.0040102d(var_98h);\n        var_2dh._0_1_ = '\\x01' - (iVar1 != var_ch_2);\n        var_4h = 0xffffffff;\n        in_stack_ffffff50 = 0;\n        in_stack_ffffff48 = 0x401b4b;\n        fcn.00401069(1, 0);\n        if (var_2dh != '\\0') {\n            var_8h = var_8h + *(stack0xffffffd0 + *(var_28h_2 + var_10h_2 * 2) * 4);\n            goto code_r0x00401b6f;\n        }\n        var_10h_2 = var_10h_2 + 1;\n    } while( true );\n}\n",
        "token_count": 1341
    },
    "0040100f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040100f(int16_t *arg_8h)\n\n{\n    int32_t var_4h;\n    \n    var_4h = 0;\n    for (; *arg_8h != 0; arg_8h = arg_8h + 1) {\n        var_4h = var_4h + 1;\n    }\n    return var_4h;\n}\n",
        "token_count": 92
    },
    "00401014": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00401014(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t in_ECX;\n    int32_t var_ch;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    if (*(in_ECX + 0x18) < 8) {\n        uVar1 = in_ECX + 4;\n        var_8h = uVar1;\n    }\n    else {\n        uVar1 = in_ECX;\n        var_8h = *(in_ECX + 4);\n    }\n    if (var_8h <= arg_8h) {\n        if (*(in_ECX + 0x18) < 8) {\n            var_ch = in_ECX + 4;\n        }\n        else {\n            var_ch = *(in_ECX + 4);\n        }\n        uVar1 = var_ch + *(in_ECX + 0x14) * 2;\n        if (arg_8h < uVar1) {\n            return CONCAT31(uVar1 >> 8, 1);\n        }\n    }\n    return uVar1 & 0xffffff00;\n}\n",
        "token_count": 256
    },
    "00401023": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401023(int32_t arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t in_ECX;\n    int32_t var_44h;\n    int32_t var_40h;\n    uint var_3ch;\n    int32_t var_34h;\n    \n    cVar1 = fcn.00401073(arg_8h);\n    if (cVar1 == '\\0') {\n        cVar1 = fcn.00401046(arg_ch, 0);\n        if (cVar1 != '\\0') {\n            if (*(in_ECX + 0x18) < 0x10) {\n                var_34h = in_ECX + 4;\n            }\n            else {\n                var_34h = *(in_ECX + 4);\n            }\n            fcn.00404a30(var_34h, arg_8h, arg_ch);\n            *(in_ECX + 0x14) = arg_ch;\n            if (*(in_ECX + 0x18) < 0x10) {\n                var_44h = in_ECX + 4;\n            }\n            else {\n                var_44h = *(in_ECX + 4);\n            }\n            *(var_44h + arg_ch) = 0;\n        }\n    }\n    else {\n        if (*(in_ECX + 0x18) < 0x10) {\n            var_40h = in_ECX + 4;\n        }\n        else {\n            var_40h = *(in_ECX + 4);\n        }\n        in_ECX = fcn.00401091(in_ECX, arg_8h - var_40h, arg_ch);\n    }\n    return in_ECX;\n}\n",
        "token_count": 384
    },
    "00402970": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402970(uint noname_0, uint noname_1, uint noname_2, uint arg_14h, int32_t *arg_18h)\n\n{\n    uint var_4h;\n    \n    *arg_18h = *arg_18h + 1;\n    *(arg_18h + 1) = arg_14h;\n    return 1;\n}\n",
        "token_count": 90
    },
    "0040103c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl\nfcn.0040103c(uint arg_8h, uint arg_ch, uint *arg_10h, uint noname_3, uint noname_4, uint noname_5, uint32_t arg_20h, \n            uint32_t arg_24h)\n\n{\n    uint *in_FS_OFFSET;\n    uint *var_a4h;\n    uint *var_a0h;\n    uint *var_9ch;\n    uint var_64h;\n    uint var_60h;\n    uint var_4ch;\n    uint32_t var_48h;\n    uint var_44h;\n    uint *var_40h;\n    uint32_t var_30h;\n    uint32_t var_2ch;\n    uint var_28h;\n    uint *var_24h;\n    uint32_t var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    uStack12 = 0x413911;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    var_4h = 1;\n    fcn.00401055(0x4160cc);\n    var_4h._0_1_ = 2;\n    fcn.0040107d(0, 0);\n    fcn.004010aa(&arg_ch, 0, *0x4160c8);\n    var_4h._0_1_ = 3;\n    for (var_48h = 0; var_48h < arg_20h; var_48h = var_48h + 1) {\n        if (arg_24h < 8) {\n            var_9ch = &arg_10h;\n        }\n        else {\n            var_9ch = arg_10h;\n        }\n        if (var_2ch < 8) {\n            var_a0h = &var_40h;\n        }\n        else {\n            var_a0h = var_40h;\n        }\n        if (var_10h < 8) {\n            var_a4h = &var_24h;\n        }\n        else {\n            var_a4h = var_24h;\n        }\n        *(var_a4h + var_48h * 2) = *(var_9ch + var_48h * 2) ^ *(var_a0h + (var_48h % var_30h) * 2);\n    }\n    fcn.0040107d(0, 0);\n    fcn.004010aa(&var_28h, 0, *0x4160c8);\n    var_4h._0_1_ = 2;\n    fcn.0040107d(1, 0);\n    var_4h._0_1_ = 1;\n    fcn.0040107d(1, 0);\n    var_4h = var_4h._1_3_ << 8;\n    fcn.0040107d(1, 0);\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 690
    },
    "0040104b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_80h\n// WARNING: Variable defined which should be unmapped: var_7ch\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.0040104b(void)\n\n{\n    int32_t iVar1;\n    uint arg_8h;\n    uint arg_ch;\n    uint *in_FS_OFFSET;\n    uint var_60h;\n    uint var_24h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint noname_3;\n    uint noname_4;\n    uint in_stack_ffffff60;\n    uint in_stack_ffffff64;\n    uint in_stack_ffffff68;\n    int32_t var_80h;\n    int32_t var_7ch;\n    uint var_78h;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h_2;\n    uint var_40h;\n    uchar *puStack40;\n    int32_t var_1dh;\n    int32_t iStack28;\n    int32_t var_14h_2;\n    int32_t *var_10h_2;\n    uint uStack16;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x413988;\n    uStack16 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xfffffff0;\n    *NULL = fcn.004010a0();\n    iStack28 = *(*NULL + 0xc);\n    var_14h_2 = *(iStack28 + 0xc);\n    var_10h_2 = *(iStack28 + 0xc);\n    iVar1 = fcn.004010be();\n    if (iVar1 == 0) {\n        do {\n            arg_8h = fcn.00404880(var_10h_2[0xc], var_80h, var_7ch);\n            puStack40 = &stack0xffffff60;\n            noname_4 = 0;\n            noname_3 = 0;\n            fcn.0040107d(0, 0);\n            arg_ch = fcn.0040486a(arg_8h);\n            fcn.00401064(arg_8h, arg_ch);\n            var_7ch = fcn.0040103c(&fcn.0040104b::var_40h, arg_8h, arg_ch, noname_3, noname_4, in_stack_ffffff60, \n                                   in_stack_ffffff64, in_stack_ffffff68);\n            var_4h = 0;\n            if (*(var_7ch + 0x18) < 8) {\n                var_80h = var_7ch + 4;\n            }\n            else {\n                var_80h = *(var_7ch + 4);\n            }\n            in_stack_ffffff64 = 0x401965;\n            iVar1 = fcn.0040102d(var_80h);\n            var_1dh._0_1_ = '\\x01' - (iVar1 != -0xf06ddfe);\n            var_4h = 0xffffffff;\n            in_stack_ffffff68 = 0;\n            var_80h = 1;\n            in_stack_ffffff60 = 0x401988;\n            fcn.0040107d(1, 0);\n            if (var_1dh != '\\0') {\n                iVar1 = var_10h_2[6];\n                goto code_r0x004019ae;\n            }\n            var_10h_2 = *var_10h_2;\n        } while (var_10h_2 != var_14h_2);\n    }\n    iVar1 = 0;\ncode_r0x004019ae:\n    *in_FS_OFFSET = uStack16;\n    return iVar1;\n}\n",
        "token_count": 864
    },
    "00401055": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401055(uint arg_8h)\n\n{\n    uint arg_ch;\n    uint in_ECX;\n    uint var_44h;\n    \n    fcn.0040107d(0, 0);\n    arg_ch = fcn.0040486a(arg_8h);\n    fcn.00401064(arg_8h, arg_ch);\n    return in_ECX;\n}\n",
        "token_count": 88
    },
    "0040105a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl\nfcn.0040105a(uint arg_8h, uint arg_ch, uint *arg_10h, uint noname_3, uint noname_4, uint noname_5, uint32_t arg_20h, \n            uint32_t arg_24h)\n\n{\n    uint *in_FS_OFFSET;\n    uint *var_ach;\n    uint *var_a8h;\n    uint *var_a4h;\n    uint var_64h;\n    uint var_60h;\n    uint var_4ch;\n    uint32_t var_48h;\n    uint var_44h;\n    uint *var_40h;\n    uint32_t var_30h;\n    uint32_t var_2ch;\n    uint var_28h;\n    uint *var_24h;\n    uint32_t var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    uStack12 = 0x413961;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    var_4h = 1;\n    fcn.00401055(0x4160ec);\n    var_4h._0_1_ = 2;\n    fcn.00401069(0, 0);\n    fcn.00401091(&arg_ch, 0, *0x4160e8);\n    var_4h._0_1_ = 3;\n    for (var_48h = 0; var_48h < arg_20h; var_48h = var_48h + 1) {\n        if (arg_24h < 0x10) {\n            var_a4h = &arg_10h;\n        }\n        else {\n            var_a4h = arg_10h;\n        }\n        if (var_2ch < 8) {\n            var_a8h = &var_40h;\n        }\n        else {\n            var_a8h = var_40h;\n        }\n        if (var_10h < 0x10) {\n            var_ach = &var_24h;\n        }\n        else {\n            var_ach = var_24h;\n        }\n        *(var_ach + var_48h) = *(var_a4h + var_48h) ^ *(var_a8h + (var_48h % var_30h) * 2);\n    }\n    fcn.00401069(0, 0);\n    fcn.00401091(&var_28h, 0, *0x4160e8);\n    var_4h._0_1_ = 2;\n    fcn.00401069(1, 0);\n    var_4h._0_1_ = 1;\n    fcn.0040107d(1, 0);\n    var_4h = var_4h._1_3_ << 8;\n    fcn.00401069(1, 0);\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 680
    },
    "0040106e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0040106e(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    code *noname_2;\n    code *pcVar2;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint in_stack_00000020;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint in_stack_0000002c;\n    uint in_stack_00000030;\n    uint in_stack_00000034;\n    uint in_stack_00000038;\n    uint in_stack_0000003c;\n    uint in_stack_00000040;\n    uint in_stack_00000044;\n    uint in_stack_00000048;\n    uint in_stack_0000004c;\n    uint in_stack_00000050;\n    uint in_stack_00000054;\n    uint in_stack_00000058;\n    uint in_stack_0000005c;\n    uint in_stack_00000060;\n    uint in_stack_00000064;\n    uint in_stack_00000068;\n    uint in_stack_0000006c;\n    uint in_stack_00000070;\n    uint in_stack_00000074;\n    uint in_stack_00000078;\n    uint in_stack_0000007c;\n    uint in_stack_00000080;\n    uint in_stack_00000084;\n    uint in_stack_00000088;\n    uint in_stack_0000008c;\n    uint in_stack_00000090;\n    uint in_stack_00000094;\n    uint in_stack_00000098;\n    uint in_stack_0000009c;\n    uint uVar3;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar3 = 0xc405de;\n    uVar1 = fcn.0040104b();\n    noname_2 = fcn.0040100a(uVar1, uVar3, 0, 0, 0, unaff_EBP, unaff_retaddr, arg_8h, arg_ch, in_stack_0000000c, \n                            in_stack_00000010, in_stack_00000014, in_stack_00000018, in_stack_0000001c, \n                            in_stack_00000020, in_stack_00000024, in_stack_00000028, in_stack_0000002c, \n                            in_stack_00000030, in_stack_00000034, in_stack_00000038, in_stack_0000003c, \n                            in_stack_00000040, in_stack_00000044, in_stack_00000048, in_stack_0000004c, \n                            in_stack_00000050, in_stack_00000054, in_stack_00000058, in_stack_0000005c, \n                            in_stack_00000060, in_stack_00000064, in_stack_00000068, in_stack_0000006c, \n                            in_stack_00000070, in_stack_00000074, in_stack_00000078, in_stack_0000007c, \n                            in_stack_00000080, in_stack_00000084, in_stack_00000088, in_stack_0000008c, \n                            in_stack_00000090, in_stack_00000094, in_stack_00000098, in_stack_0000009c);\n    uVar3 = 0xa67c815d;\n    uVar1 = fcn.0040104b();\n    pcVar2 = fcn.0040100a(uVar1, uVar3, noname_2, 0, 0, unaff_EBP, unaff_retaddr, arg_8h, arg_ch, in_stack_0000000c, \n                          in_stack_00000010, in_stack_00000014, in_stack_00000018, in_stack_0000001c, in_stack_00000020\n                          , in_stack_00000024, in_stack_00000028, in_stack_0000002c, in_stack_00000030, \n                          in_stack_00000034, in_stack_00000038, in_stack_0000003c, in_stack_00000040, in_stack_00000044\n                          , in_stack_00000048, in_stack_0000004c, in_stack_00000050, in_stack_00000054, \n                          in_stack_00000058, in_stack_0000005c, in_stack_00000060, in_stack_00000064, in_stack_00000068\n                          , in_stack_0000006c, in_stack_00000070, in_stack_00000074, in_stack_00000078, \n                          in_stack_0000007c, in_stack_00000080, in_stack_00000084, in_stack_00000088, in_stack_0000008c\n                          , in_stack_00000090, in_stack_00000094, in_stack_00000098, in_stack_0000009c);\n    uVar1 = (*noname_2)(arg_8h, 0, 0, arg_ch);\n    uVar1 = (*pcVar2)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 1237
    },
    "00401073": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401073(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    int32_t var_ch;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    if (*(in_ECX + 0x18) < 0x10) {\n        var_8h = in_ECX + 4;\n    }\n    else {\n        var_8h = *(in_ECX + 4);\n    }\n    if (var_8h <= arg_8h) {\n        if (*(in_ECX + 0x18) < 0x10) {\n            var_ch = in_ECX + 4;\n        }\n        else {\n            var_ch = *(in_ECX + 4);\n        }\n        if (arg_8h < var_ch + *(in_ECX + 0x14)) {\n            return 1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 204
    },
    "00401091": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401091(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    char cVar1;\n    int32_t in_ECX;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    int32_t var_38h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    if (*(arg_8h + 0x14) < arg_ch) {\n        fcn.00404169();\n    }\n    var_4h = *(arg_8h + 0x14) - arg_ch;\n    if (arg_10h < var_4h) {\n        var_4h = arg_10h;\n    }\n    if (in_ECX == arg_8h) {\n        fcn.00401032(arg_ch + var_4h, *0x4160e8);\n        fcn.00401032(0, arg_ch);\n    }\n    else {\n        cVar1 = fcn.00401046(var_4h, 0);\n        if (cVar1 != '\\0') {\n            if (*(arg_8h + 0x18) < 0x10) {\n                var_44h = arg_8h + 4;\n            }\n            else {\n                var_44h = *(arg_8h + 4);\n            }\n            if (*(in_ECX + 0x18) < 0x10) {\n                var_38h = in_ECX + 4;\n            }\n            else {\n                var_38h = *(in_ECX + 4);\n            }\n            fcn.00404a30(var_38h, var_44h + arg_ch, var_4h);\n            *(in_ECX + 0x14) = var_4h;\n            if (*(in_ECX + 0x18) < 0x10) {\n                var_48h = in_ECX + 4;\n            }\n            else {\n                var_48h = *(in_ECX + 4);\n            }\n            *(var_48h + var_4h) = 0;\n        }\n    }\n    return in_ECX;\n}\n",
        "token_count": 497
    },
    "004010b4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004010b4(int32_t arg_8h, int32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t var_4h;\n    \n    for (var_4h = 0; var_4h != arg_10h; var_4h = var_4h + 1) {\n        uVar1 = fcn.0040486a(arg_8h);\n        *(arg_ch + var_4h) = *(arg_ch + var_4h) ^ *(arg_8h + (var_4h % uVar1) * 2);\n    }\n    return;\n}\n",
        "token_count": 151
    },
    "00401340": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00401340(uint16_t *arg_8h, uint16_t *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    iVar1 = fcn.0040100f(arg_8h);\n    iVar2 = fcn.0040100f(arg_ch);\n    if (iVar1 == iVar2) {\n        for (var_4h = 0; uVar4 = fcn.0040100f(arg_8h),  var_4h < uVar4; var_4h = var_4h + 1) {\n            var_8h._0_2_ = *arg_8h;\n            var_ch._0_2_ = *arg_ch;\n            if ((0x40 < var_8h) && (var_8h < 0x5b)) {\n                var_8h._0_2_ = var_8h + 0x20;\n            }\n            if ((0x40 < var_ch) && (var_ch < 0x5b)) {\n                var_ch._0_2_ = var_ch + 0x20;\n            }\n            if (var_8h != var_ch) {\n                return 1;\n            }\n            arg_8h = arg_8h + 1;\n            arg_ch = arg_ch + 1;\n        }\n        uVar3 = 0;\n    }\n    else {\n        uVar3 = 1;\n    }\n    return uVar3;\n}\n",
        "token_count": 373
    },
    "00404378": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00404378(code *UNRECOVERED_JUMPTABLE)\n\n{\n    uint *in_FS_OFFSET;\n    \n    *in_FS_OFFSET = **in_FS_OFFSET;\n    // WARNING: Could not recover jumptable at 0x004043a1. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*UNRECOVERED_JUMPTABLE)();\n    return;\n}\n",
        "token_count": 88
    },
    "00404f50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * fcn.00404f50(uint32_t *param_1, uint32_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t *puVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    \n    uVar4 = param_1 & 3;\n    puVar3 = param_1;\n    while (uVar4 != 0) {\n        uVar1 = *puVar3;\n        puVar3 = puVar3 + 1;\n        if (uVar1 == 0) goto code_r0x00404fa3;\n        uVar4 = puVar3 & 3;\n    }\n    do {\n        do {\n            puVar5 = puVar3;\n            puVar3 = puVar5 + 1;\n        } while (((*puVar5 ^ 0xffffffff ^ *puVar5 + 0x7efefeff) & 0x81010100) == 0);\n        uVar4 = *puVar5;\n        if (uVar4 == '\\0') goto code_r0x00404fb5;\n        if (uVar4 >> 8 == '\\0') {\n            puVar5 = puVar5 + 1;\n            goto code_r0x00404fb5;\n        }\n        if ((uVar4 & 0xff0000) == 0) {\n            puVar5 = puVar5 + 2;\n            goto code_r0x00404fb5;\n        }\n    } while ((uVar4 & 0xff000000) != 0);\ncode_r0x00404fa3:\n    puVar5 = puVar3 + -1;\ncode_r0x00404fb5:\n    uVar4 = param_2 & 3;\n    while (uVar4 != 0) {\n        uVar1 = *param_2;\n        uVar4 = uVar1;\n        param_2 = param_2 + 1;\n        if (uVar1 == 0) goto code_r0x00405030;\n        *puVar5 = uVar1;\n        puVar5 = puVar5 + 1;\n        uVar4 = param_2 & 3;\n    }\n    do {\n        uVar2 = *param_2;\n        uVar4 = *param_2;\n        param_2 = param_2 + 1;\n        if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {\n            if (uVar4 == '\\0') {\ncode_r0x00405030:\n                *puVar5 = uVar4;\n                return param_1;\n            }\n            if (uVar4 >> 8 == '\\0') {\n                *puVar5 = uVar4;\n                return param_1;\n            }\n            if ((uVar4 & 0xff0000) == 0) {\n                *puVar5 = uVar4;\n                *(puVar5 + 2) = 0;\n                return param_1;\n            }\n            if ((uVar4 & 0xff000000) == 0) {\n                *puVar5 = uVar4;\n                return param_1;\n            }\n        }\n        *puVar5 = uVar4;\n        puVar5 = puVar5 + 1;\n    } while( true );\n}\n",
        "token_count": 750
    },
    "004049a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nchar * fcn.004049a0(uint32_t *param_1)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    uint32_t *puVar3;\n    uint32_t *puVar4;\n    \n    uVar2 = param_1 & 3;\n    puVar3 = param_1;\n    while (uVar2 != 0) {\n        cVar1 = *puVar3;\n        puVar3 = puVar3 + 1;\n        if (cVar1 == '\\0') goto code_r0x00404a03;\n        uVar2 = puVar3 & 3;\n    }\n    do {\n        do {\n            puVar4 = puVar3;\n            puVar3 = puVar4 + 1;\n        } while (((*puVar4 ^ 0xffffffff ^ *puVar4 + 0x7efefeff) & 0x81010100) == 0);\n        uVar2 = *puVar4;\n        if (uVar2 == '\\0') {\n            return puVar4 - param_1;\n        }\n        if (uVar2 >> 8 == '\\0') {\n            return puVar4 + (1 - param_1);\n        }\n        if ((uVar2 & 0xff0000) == 0) {\n            return puVar4 + (2 - param_1);\n        }\n    } while ((uVar2 & 0xff000000) != 0);\ncode_r0x00404a03:\n    return puVar3 + (-1 - param_1);\n}\n",
        "token_count": 341
    },
    "00405c22": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.00405c22(void)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint unaff_EDI;\n    \n    uVar1 = fcn.0040a722(*0x41c134);\n    if (uVar1 < *0x41c130 + (4 - *0x41c134)) {\n        uVar3 = 0x800;\n        if (uVar1 < 0x800) {\n            uVar3 = uVar1;\n        }\n        iVar2 = fcn.0040a575(*0x41c134, uVar3 + uVar1);\n        if (iVar2 == 0) {\n            iVar2 = fcn.0040a575(*0x41c134, uVar1 + 0x10);\n            if (iVar2 == 0) {\n                return;\n            }\n        }\n        *0x41c130 = iVar2 + (*0x41c130 - *0x41c134 >> 2) * 4;\n        *0x41c134 = iVar2;\n    }\n    **0x41c130 = unaff_EDI;\n    *0x41c130 = *0x41c130 + 1;\n    return;\n}\n",
        "token_count": 281
    },
    "004060d8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004060d8(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t arg_8h_00;\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint arg_10h_00;\n    int32_t unaff_EBP;\n    uint var_50h;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_20h;\n    uint var_4h;\n    \n    fcn.00407c04(0x4163a0, 0x40);\n    arg_8h_00 = *(unaff_EBP + 0xc);\n    iVar3 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x20) = arg_10h_00;\n    *(unaff_EBP + -0x48) = 0;\n    *(unaff_EBP + -0x38) = *(arg_8h_00 + -4);\n    uVar1 = fcn.0040468d(unaff_EBP + -0x50, *(iVar3 + 0x18));\n    *(unaff_EBP + -0x3c) = uVar1;\n    iVar2 = fcn.00406941();\n    *(unaff_EBP + -0x40) = *(iVar2 + 0x7c);\n    iVar2 = fcn.00406941();\n    *(unaff_EBP + -0x44) = *(iVar2 + 0x80);\n    iVar2 = fcn.00406941();\n    *(iVar2 + 0x7c) = iVar3;\n    iVar3 = fcn.00406941();\n    *(iVar3 + 0x80) = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 1;\n    uVar1 = fcn.00404722(arg_8h_00, *(unaff_EBP + 0x14), arg_10h_00, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c));\n    *(unaff_EBP + -0x20) = uVar1;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0040622d();\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 611
    },
    "0040729d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040729d(uint param_1, int32_t param_2)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    \n    if (0 < param_2) {\n        puVar1 = &param_2;\n        iVar2 = param_2;\n        do {\n            puVar1 = puVar1 + 1;\n            fcn.00404f50(param_1, *puVar1);\n            iVar2 = iVar2 + -1;\n        } while (iVar2 != 0);\n    }\n    return;\n}\n",
        "token_count": 123
    },
    "00407426": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuchar * fcn.00407426(void)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    \n    bVar1 = true;\n    if (*0x41af1c == NULL) {\n        *0x41af1c = fcn.00405bcb(0x351);\n        if (*0x41af1c == NULL) {\n            return NULL;\n        }\n    }\n    **0x41af1c = 0;\n    fcn.0040729d(*0x41af1c, 3, *0x41af24, 0x416648, *0x41af28);\n    puVar3 = 0x41af28;\n    do {\n        fcn.00404f50(*0x41af1c, 0x416644);\n        puVar4 = puVar3 + 3;\n        iVar2 = fcn.00409570(*puVar3, *puVar4);\n        if (iVar2 != 0) {\n            bVar1 = false;\n        }\n        fcn.0040729d(*0x41af1c, 3, puVar3[2], 0x416648, *puVar4);\n        puVar3 = puVar4;\n    } while (puVar4 < 0x41af58);\n    if (!bVar1) {\n        return *0x41af1c;\n    }\n    fcn.00406cec(*0x41af1c);\n    *0x41af1c = NULL;\n    return *0x41af34;\n}\n",
        "token_count": 357
    },
    "00407d60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n\nvoid fcn.00407d60(void)\n\n{\n    uint32_t in_EAX;\n    uchar *puVar1;\n    uint unaff_retaddr;\n    \n    if (in_EAX < 0x1000) {\n        *(&stack0x00000000 + -in_EAX) = unaff_retaddr;\n        return;\n    }\n    puVar1 = &stack0x00000004;\n    do {\n        puVar1 = puVar1 + -0x1000;\n        in_EAX = in_EAX - 0x1000;\n    } while (0xfff < in_EAX);\n    *(puVar1 + (-4 - in_EAX)) = unaff_retaddr;\n    return;\n}\n",
        "token_count": 167
    },
    "0040846b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint32_t __cdecl fcn.0040846b(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint noname_2;\n    int32_t iVar1;\n    uint32_t in_ECX;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint32_t var_4h;\n    \n    if (arg_ch + 1 < 0x101) {\n        arg_ch._2_2_ = *(*(arg_8h + 0x48) + arg_ch * 2);\n    }\n    else {\n        if ((*(*(arg_8h + 0x48) + 1 + (arg_ch >> 8 & 0xffU) * 2) & 0x80) == 0) {\n            var_4h = in_ECX & 0xffff0000 | arg_ch & 0xff;\n            noname_2 = 1;\n        }\n        else {\n            var_4h = CONCAT11(arg_ch, arg_ch >> 8);\n            var_4h = in_ECX & 0xff000000 | var_4h;\n            noname_2 = 2;\n        }\n        iVar1 = fcn.0040ce68(1, &var_4h, noname_2, &arg_ch + 2, *(arg_8h + 4), *(arg_8h + 0x14), 1, var_4h, unaff_EBP, \n                             unaff_retaddr, arg_8h, arg_ch, arg_10h, in_stack_00000010, in_stack_00000014);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return arg_ch._2_2_ & arg_10h;\n}\n",
        "token_count": 429
    },
    "004086cb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004086cb(uint param_1)\n\n{\n    int32_t iVar1;\n    code **ppcVar2;\n    \n    if (*0x41c13c != NULL) {\n        (**0x41c13c)(param_1);\n    }\n    iVar1 = 0;\n    ppcVar2 = 0x41a30c;\n    do {\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n        if (*ppcVar2 != NULL) {\n            iVar1 = (**ppcVar2)();\n        }\n        ppcVar2 = ppcVar2 + 1;\n    } while (ppcVar2 < 0x41a620);\n    if (iVar1 == 0) {\n        fcn.00405d02(0x40929f);\n        ppcVar2 = 0x41a000;\n        do {\n            if (*ppcVar2 != NULL) {\n                (**ppcVar2)();\n            }\n            ppcVar2 = ppcVar2 + 1;\n        } while (ppcVar2 < 0x41a208);\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 260
    },
    "0040925b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0040925b(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00407c04(0x416ab0, 0xc);\n    *(unaff_EBP + -0x1c) = 0x419208;\n    while (*(unaff_EBP + -0x1c) < 0x419308) {\n        *(unaff_EBP + -4) = 0;\n        if (**(unaff_EBP + -0x1c) != NULL) {\n            (***(unaff_EBP + -0x1c))();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(unaff_EBP + -0x1c) = *(unaff_EBP + -0x1c) + 4;\n    }\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 224
    },
    "0040949e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0040949e(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t arg_8h_00;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00407c04(0x416ad0, 8);\n    piVar1 = *(unaff_EBP + 8) * 8 + 0x41b1a8;\n    if (*piVar1 == 0) {\n        arg_8h_00 = fcn.00405bcb(0x18);\n        if (arg_8h_00 == 0) {\n            puVar2 = fcn.0040d955();\n            *puVar2 = 0xc;\n        }\n        else {\n            fcn.0040953e(10);\n            *(unaff_EBP + -4) = 0;\n            if (*piVar1 == 0) {\n                iVar3 = fcn.0040d8ca(arg_8h_00, 4000);\n                if (iVar3 == 0) {\n                    fcn.00406cec(arg_8h_00);\n                    puVar2 = fcn.0040d955();\n                    *puVar2 = 0xc;\n                    fcn.004047be(unaff_EBP + -0x10, 0xffffffff);\n                    goto code_r0x0040952f;\n                }\n                *piVar1 = arg_8h_00;\n            }\n            else {\n                fcn.00406cec(arg_8h_00);\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00409535();\n        }\n    }\ncode_r0x0040952f:\n    fcn.00407c3f();\n    return;\n}\n",
        "token_count": 450
    },
    "00409655": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t fcn.00409655(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *0x41bfa0;\n    while( true ) {\n        if (*0x41bfa0 + *0x41bf9c * 0x14 <= uVar1) {\n            return 0;\n        }\n        if (param_1 - *(uVar1 + 0xc) < 0x100000) break;\n        uVar1 = uVar1 + 0x14;\n    }\n    return uVar1;\n}\n",
        "token_count": 129
    },
    "00409998": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * fcn.00409998(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    \n    if (*0x41bf9c == *0x41bfac) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x41bfb4, 0, *0x41bfa0, (*0x41bfac * 5 + 0x50) * 4);\n        if (iVar2 == 0) {\n            return NULL;\n        }\n        *0x41bfac = *0x41bfac + 0x10;\n        *0x41bfa0 = iVar2;\n    }\n    puVar1 = *0x41bfa0 + *0x41bf9c * 0x14;\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x41bfb4, 8, 0x41c4);\n    puVar1[4] = iVar2;\n    if (iVar2 != 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, 0x100000, 0x2000, 4);\n        puVar1[3] = iVar2;\n        if (iVar2 != 0) {\n            puVar1[2] = 0xffffffff;\n            *puVar1 = 0;\n            puVar1[1] = 0;\n            *0x41bf9c = *0x41bf9c + 1;\n            *puVar1[4] = 0xffffffff;\n            return puVar1;\n        }\n        (*_sym.imp.KERNEL32.dll_HeapFree)(*0x41bfb4, 0, puVar1[4]);\n    }\n    return NULL;\n}\n",
        "token_count": 392
    },
    "0040b692": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040b692(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00406941();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x41addc) {\n        iVar1 = fcn.004073eb();\n    }\n    fcn.0040b5cd(iVar1, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h);\n    return;\n}\n",
        "token_count": 137
    },
    "0040c667": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040c667(uint param_1, char *param_2)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    \n    iVar1 = 0;\n    while (cVar2 = *param_2,  cVar2 != '\\0') {\n        param_2 = param_2 + 1;\n        if ((cVar2 < 'a') || ('f' < cVar2)) {\n            if (('@' < cVar2) && (cVar2 < 'G')) {\n                cVar2 = cVar2 + -7;\n            }\n        }\n        else {\n            cVar2 = cVar2 + -0x27;\n        }\n        iVar1 = (iVar1 + 0xffffffd) * 0x10 + cVar2;\n    }\n    return iVar1;\n}\n",
        "token_count": 185
    },
    "0040d030": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040d030(char *arg_8h, char *arg_ch, uint32_t arg_10h)\n\n{\n    char cVar1;\n    char cVar2;\n    uint8_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    char *pcVar6;\n    char *pcVar7;\n    bool bVar8;\n    \n    uVar4 = arg_10h;\n    pcVar6 = arg_8h;\n    if (arg_10h != 0) {\n        do {\n            if (uVar4 == 0) break;\n            uVar4 = uVar4 - 1;\n            cVar1 = *pcVar6;\n            pcVar6 = pcVar6 + 1;\n        } while (cVar1 != '\\0');\n        iVar5 = arg_10h - uVar4;\n        do {\n            pcVar6 = arg_ch;\n            pcVar7 = arg_8h;\n            if (iVar5 == 0) break;\n            iVar5 = iVar5 + -1;\n            pcVar7 = arg_8h + 1;\n            pcVar6 = arg_ch + 1;\n            cVar1 = *arg_ch;\n            cVar2 = *arg_8h;\n            arg_ch = pcVar6;\n            arg_8h = pcVar7;\n        } while (cVar1 == cVar2);\n        uVar3 = pcVar6[-1];\n        arg_10h = 0;\n        bVar8 = uVar3 == pcVar7[-1];\n        if (uVar3 < pcVar7[-1] || bVar8) {\n            if (bVar8) {\n                return 0;\n            }\n            arg_10h = 0xfffffffe;\n        }\n        arg_10h = ~arg_10h;\n    }\n    return arg_10h;\n}\n",
        "token_count": 415
    },
    "0040d955": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040d955(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00406941();\n    return iVar1 + 8;\n}\n",
        "token_count": 42
    },
    "0040d95e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040d95e(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00406941();\n    return iVar1 + 0xc;\n}\n",
        "token_count": 44
    },
    "0040da69": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0040da69(uint param_1, uint32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t unaff_ESI;\n    \n    uVar1 = param_2;\n    do {\n        if (*(uVar1 + 4) == unaff_ESI) break;\n        uVar1 = uVar1 + 0xc;\n    } while (uVar1 < param_2 + *0x41b17c * 0xc);\n    if ((param_2 + *0x41b17c * 0xc <= uVar1) || (*(uVar1 + 4) != unaff_ESI)) {\n        uVar1 = 0;\n    }\n    return uVar1;\n}\n",
        "token_count": 167
    },
    "0040e223": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nbool fcn.0040e223(void)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t *unaff_EBX;\n    uint32_t uVar6;\n    \n    if (*0x41b54c == 0) {\n        return false;\n    }\n    iVar1 = unaff_EBX[5];\n    if ((iVar1 != *0x41b5e0) || (iVar1 != *0x41b5ec)) {\n        if (*0x41bf2c == 0) {\n            fcn.0040e06b(1, 1, iVar1, 1, 0, 0, 0, 0, 0);\n            fcn.0040e06b(0, 1, iVar1, 5, 0, 0, 0, 0, 0);\n        }\n        else {\n            if (*0x41bf18 != 0) {\n                uVar6 = *0x41bf1e;\n                uVar3 = 0;\n                uVar4 = 0;\n            }\n            else {\n                uVar3 = *0x41bf1c;\n                uVar6 = 0;\n                uVar4 = *0x41bf1e;\n            }\n            fcn.0040e06b(1, *0x41bf18 == 0, iVar1, uVar4, uVar3, uVar6, *0x41bf22, *0x41bf24, *0x41bf26);\n            if (*0x41bec4 != 0) {\n                uVar6 = *0x41beca;\n                uVar3 = 0;\n                uVar4 = 0;\n            }\n            else {\n                uVar3 = *0x41bec8;\n                uVar6 = 0;\n                uVar4 = *0x41beca;\n            }\n            fcn.0040e06b(0, *0x41bec4 == 0, iVar1, uVar4, uVar3, uVar6, *0x41bece, *0x41bed0, *0x41bed2);\n        }\n    }\n    iVar1 = unaff_EBX[7];\n    if (*0x41b5e4 < *0x41b5f0) {\n        if ((iVar1 < *0x41b5e4) || (*0x41b5f0 < iVar1)) {\n            return false;\n        }\n        if ((*0x41b5e4 < iVar1) && (iVar1 < *0x41b5f0)) {\n            return true;\n        }\n    }\n    else {\n        if (iVar1 < *0x41b5f0) {\n            return true;\n        }\n        if (*0x41b5e4 < iVar1) {\n            return true;\n        }\n        if ((*0x41b5f0 < iVar1) && (iVar1 < *0x41b5e4)) {\n            return false;\n        }\n    }\n    iVar5 = ((unaff_EBX[2] * 0x3c + unaff_EBX[1]) * 0x3c + *unaff_EBX) * 1000;\n    if (iVar1 == *0x41b5e4) {\n        bVar2 = *0x41b5e8 <= iVar5;\n    }\n    else {\n        bVar2 = iVar5 < *0x41b5f4;\n    }\n    return bVar2;\n}\n",
        "token_count": 796
    },
    "0040e470": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040e470(char *arg_8h, char *arg_ch)\n\n{\n    char cVar1;\n    char cVar2;\n    uint8_t uVar3;\n    uint8_t uVar5;\n    uint32_t uVar4;\n    \n    uVar4 = 0xff;\n    do {\n        do {\n            cVar2 = uVar4;\n            if (cVar2 == '\\0') goto code_r0x0040e4b6;\n            cVar2 = *arg_ch;\n            arg_ch = arg_ch + 1;\n            cVar1 = *arg_8h;\n            uVar4 = CONCAT11(cVar1, cVar2);\n            arg_8h = arg_8h + 1;\n        } while (uVar4 >> 8 == cVar2);\n        uVar3 = cVar1 + 0xbf;\n        uVar3 = uVar3 + (-(uVar3 < 0x1a) & 0x20U) + 0x41;\n        uVar4 = CONCAT11(cVar2 + 0xbfU + (-(cVar2 + 0xbfU < 0x1a) & 0x20U) + 'A', uVar3);\n        uVar5 = uVar4 >> 8;\n    } while (uVar3 == uVar5);\n    cVar2 = (uVar3 < uVar5) * -2 + '\\x01';\ncode_r0x0040e4b6:\n    return cVar2;\n}\n",
        "token_count": 342
    },
    "0040efb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040efb0(uint8_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    bool bVar3;\n    \n    if (arg_10h != 0) {\n        do {\n            uVar2 = *arg_8h;\n            uVar1 = *arg_ch;\n            if ((uVar2 == 0) || (uVar1 == 0)) break;\n            arg_8h = arg_8h + 1;\n            arg_ch = arg_ch + 1;\n            if ((0x40 < uVar2) && (uVar2 < 0x5b)) {\n                uVar2 = uVar2 + 0x20;\n            }\n            if ((0x40 < uVar1) && (uVar1 < 0x5b)) {\n                uVar1 = uVar1 + 0x20;\n            }\n            bVar3 = uVar2 < uVar1;\n            if (uVar2 != uVar1) goto code_r0x0040f001;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n        arg_10h = 0;\n        bVar3 = uVar2 < uVar1;\n        if (uVar2 != uVar1) {\ncode_r0x0040f001:\n            arg_10h = -1;\n            if (!bVar3) {\n                arg_10h = 1;\n            }\n        }\n    }\n    return arg_10h;\n}\n",
        "token_count": 365
    },
    "0040f05f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0040f05f(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint var_8h;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_WideCharToMultiByte;\n    var_4h = 0;\n    iVar2 = **0x41bafc;\n    piVar3 = *0x41bafc;\n    while( true ) {\n        if (iVar2 == 0) {\n            return 0;\n        }\n        iVar2 = (*pcVar1)(0, 0, iVar2, 0xffffffff, 0, 0, 0, 0);\n        if ((iVar2 == 0) || (var_4h = fcn.00405bcb(iVar2),  var_4h == 0)) break;\n        iVar2 = (*pcVar1)(0, 0, *piVar3, 0xffffffff, var_4h, iVar2, 0, 0);\n        if (iVar2 == 0) {\n            fcn.00406cec(var_4h);\n            return 0xffffffff;\n        }\n        iVar2 = fcn.0040f53d(&var_4h, 0);\n        if ((iVar2 < 0) && (var_4h != 0)) {\n            fcn.00406cec(var_4h);\n            var_4h = 0;\n        }\n        piVar3 = piVar3 + 1;\n        iVar2 = *piVar3;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 359
    },
    "0040f53d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040f53d(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uchar *puVar4;\n    bool bVar5;\n    uint var_10h;\n    uint var_ch;\n    uint lpValue;\n    uint var_4h;\n    \n    var_10h = 0;\n    if (arg_8h == NULL) {\n        return 0xffffffff;\n    }\n    arg_8h_00 = *arg_8h;\n    if (arg_8h_00 == 0) {\n        return 0xffffffff;\n    }\n    iVar1 = fcn.0040f73d(arg_8h_00, 0x3d);\n    if (iVar1 == 0) {\n        return 0xffffffff;\n    }\n    if (arg_8h_00 == iVar1) {\n        return 0xffffffff;\n    }\n    bVar5 = *(iVar1 + 1) == '\\0';\n    if (*0x41baf4 == *0x41baf8) {\n        *0x41baf4 = fcn.0040f4dc();\n    }\n    if (*0x41baf4 == NULL) {\n        if ((arg_ch != 0) && (*0x41bafc != NULL)) {\n            iVar2 = fcn.0040f05f();\n            if (iVar2 != 0) {\n                return 0xffffffff;\n            }\n            goto code_r0x0040f5f2;\n        }\n        if (!bVar5) {\n            *0x41baf4 = fcn.00405bcb(4);\n            if (*0x41baf4 == NULL) {\n                return 0xffffffff;\n            }\n            **0x41baf4 = 0;\n            if (*0x41bafc == NULL) {\n                *0x41bafc = fcn.00405bcb(4);\n                if (*0x41bafc == NULL) {\n                    return 0xffffffff;\n                }\n                **0x41bafc = 0;\n            }\n            goto code_r0x0040f5f2;\n        }\ncode_r0x0040f5c0:\n        var_10h = 0;\n    }\n    else {\ncode_r0x0040f5f2:\n        piVar3 = *0x41baf4;\n        iVar2 = fcn.0040f48f(arg_8h_00);\n        if ((iVar2 < 0) || (*piVar3 == 0)) {\n            if (bVar5) {\n                fcn.00406cec(arg_8h_00);\n                *arg_8h = 0;\n                goto code_r0x0040f5c0;\n            }\n            if (iVar2 < 0) {\n                iVar2 = -iVar2;\n            }\n            piVar3 = fcn.0040a575(*0x41baf4, iVar2 * 4 + 8);\n            if (piVar3 == NULL) {\n                return 0xffffffff;\n            }\n            piVar3[iVar2] = arg_8h_00;\n            (piVar3 + iVar2)[1] = 0;\n            *arg_8h = 0;\ncode_r0x0040f68f:\n            *0x41baf4 = piVar3;\n        }\n        else {\n            piVar3 = piVar3 + iVar2;\n            fcn.00406cec(*piVar3);\n            if (bVar5) {\n                for (; *piVar3 != 0; piVar3 = piVar3 + 1) {\n                    *piVar3 = piVar3[1];\n                    iVar2 = iVar2 + 1;\n                }\n                piVar3 = fcn.0040a575(*0x41baf4, iVar2 << 2);\n                if (piVar3 != NULL) goto code_r0x0040f68f;\n            }\n            else {\n                *piVar3 = arg_8h_00;\n                *arg_8h = 0;\n            }\n        }\n        if (arg_ch != 0) {\n            iVar2 = fcn.004049a0(arg_8h_00);\n            iVar2 = fcn.00405bcb(iVar2 + 2);\n            if (iVar2 != 0) {\n                fcn.00404f40(iVar2, arg_8h_00);\n                puVar4 = (iVar2 - arg_8h_00) + iVar1;\n                *puVar4 = 0;\n                iVar1 = (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(iVar2, ~-bVar5 & puVar4 + 1);\n                if (iVar1 == 0) {\n                    var_10h = 0xffffffff;\n                }\n                fcn.00406cec(iVar2);\n            }\n        }\n        if (bVar5) {\n            fcn.00406cec(arg_8h_00);\n        }\n    }\n    return var_10h;\n}\n",
        "token_count": 1135
    },
    "004010a0": {
        "rules": [
            "PEB access"
        ],
        "decompiled_code": "\nuint fcn.004010a0(void)\n\n{\n    int32_t in_FS_OFFSET;\n    uint var_4h;\n    \n    return *(in_FS_OFFSET + 0x30);\n}\n",
        "token_count": 41
    },
    "0040429b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0040429b(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.00405bcb(param_1);\n        if (iVar1 != 0) break;\n        iVar1 = fcn.00405c07(param_1);\n        if (iVar1 == 0) {\n            fcn.00404317();\n        }\n    }\n    return;\n}\n",
        "token_count": 96
    },
    "004046b5": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.004046b5(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    iVar1 = fcn.00406941();\n    piVar2 = *(iVar1 + 0x88);\n    while( true ) {\n        if (piVar2 == NULL) {\n            return 1;\n        }\n        if (*piVar2 == param_1) break;\n        piVar2 = piVar2[1];\n    }\n    return 0;\n}\n",
        "token_count": 114
    },
    "00404e88": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.00404e88(uint8_t *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    \n    iVar1 = fcn.00406941();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x41addc) {\n        iVar1 = fcn.004073eb();\n    }\n    while( true ) {\n        if (*(iVar1 + 0x28) < 2) {\n            uVar2 = *(*(iVar1 + 0x48) + *param_1 * 2) & 8;\n        }\n        else {\n            uVar2 = fcn.0040846b(iVar1, *param_1, 8);\n        }\n        if (uVar2 == 0) break;\n        param_1 = param_1 + 1;\n    }\n    uVar2 = *param_1;\n    puVar5 = param_1 + 1;\n    if ((uVar2 == 0x2d) || (uVar3 = uVar2,  uVar2 == 0x2b)) {\n        uVar3 = *puVar5;\n        puVar5 = param_1 + 2;\n    }\n    iVar1 = 0;\n    while( true ) {\n        if ((uVar3 < 0x30) || (0x39 < uVar3)) {\n            iVar4 = -1;\n        }\n        else {\n            iVar4 = uVar3 - 0x30;\n        }\n        if (iVar4 == -1) break;\n        iVar1 = iVar4 + iVar1 * 10;\n        uVar3 = *puVar5;\n        puVar5 = puVar5 + 1;\n    }\n    if (uVar2 == 0x2d) {\n        iVar1 = -iVar1;\n    }\n    return iVar1;\n}\n",
        "token_count": 438
    },
    "00406d87": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint16_t * fcn.00406d87(int16_t *param_1, int16_t *param_2)\n\n{\n    int16_t iVar1;\n    int16_t *piVar2;\n    \n    piVar2 = param_1;\n    do {\n        iVar1 = *param_2;\n        *piVar2 = iVar1;\n        piVar2 = piVar2 + 1;\n        param_2 = param_2 + 1;\n    } while (iVar1 != 0);\n    return param_1;\n}\n",
        "token_count": 117
    },
    "0040c69c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040c69c(uint param_1, char *param_2)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    while( true ) {\n        cVar1 = *param_2;\n        param_2 = param_2 + 1;\n        if (((cVar1 < 'A') || ('Z' < cVar1)) && ((cVar1 < 'a' || ('z' < cVar1)))) break;\n        iVar2 = iVar2 + 1;\n    }\n    return iVar2;\n}\n",
        "token_count": 132
    },
    "00408653": {
        "rules": [
            "link function at runtime on Windows",
            "terminate process"
        ],
        "decompiled_code": "\nvoid fcn.00408653(void)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    uint unaff_retaddr;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"mscoree.dll\");\n    if (iVar1 != 0) {\n        pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"CorExitProcess\");\n        if (pcVar2 != NULL) {\n            (*pcVar2)(unaff_retaddr);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_ExitProcess)(unaff_retaddr);\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 152
    },
    "004010be": {
        "rules": [
            "create new key via CryptAcquireContext"
        ],
        "decompiled_code": "\nuint fcn.004010be(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint phProv;\n    \n    phProv = 0;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_CryptAcquireContextA)(&phProv, 0, 0, 1, 0);\n    if (iVar1 == 0) {\n        uVar2 = 0;\n    }\n    else {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_CryptAcquireContextA)(&phProv, 0, 0, 1, 8);\n        if (iVar1 == 0) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = 1;\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 174
    },
    "0040a8bb": {
        "rules": [
            "get geographical location"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a8bb(uint Locale)\n\n{\n    int32_t iVar1;\n    uint lpLCData;\n    uchar var_6h;\n    uint var_4h;\n    \n    var_4h = *0x41ad6c;\n    var_6h = 0;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)(Locale, 0x1004, &lpLCData, 6);\n    if (iVar1 != 0) {\n        fcn.00404e00(&lpLCData);\n    }\n    fcn.0040cd9b();\n    return;\n}\n",
        "token_count": 139
    }
}