{
    "null": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00402d10": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint8_t * __cdecl fcn.00402d10(int32_t arg_8h, uint32_t arg_ch, uint8_t **arg_10h)\n\n{\n    char cVar1;\n    uint8_t uVar3;\n    uint32_t uVar2;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint8_t *puVar7;\n    uint8_t *puVar8;\n    uint *puVar9;\n    uint uStack276;\n    int32_t iStack272;\n    uint8_t *puStack268;\n    uint auStack264 [15];\n    uchar uStack203;\n    \n    iVar6 = 0;\n    puVar9 = auStack264;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar9 = 0x80808080;\n        puVar9 = puVar9 + 1;\n    }\n    iStack272 = 0;\n    uVar2 = 0;\n    do {\n        *(auStack264 + \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[uVar2]) = uVar2;\n        uVar2 = uVar2 + 1;\n    } while (uVar2 < 0x40);\n    uVar2 = 0;\n    uVar5 = 0;\n    uStack203 = 0;\n    if (arg_ch != 0) {\n        do {\n            if (*(auStack264 + *(uVar5 + arg_8h)) != -0x80) {\n                uVar2 = uVar2 + 1;\n            }\n            uVar5 = uVar5 + 1;\n        } while (uVar5 < arg_ch);\n        if (((uVar2 != 0) && ((uVar2 & 3) == 0)) && (puStack268 = fcn.00407684((uVar2 >> 2) * 3),  puStack268 != NULL))\n        {\n            iVar4 = 0;\n            uVar2 = 0;\n            puVar7 = puStack268;\n            do {\n                cVar1 = *(auStack264 + *(uVar2 + arg_8h));\n                puVar8 = puVar7;\n                if (cVar1 != -0x80) {\n                    if (*(uVar2 + arg_8h) == 0x3d) {\n                        iVar6 = iVar6 + 1;\n                        iStack272 = iVar6;\n                    }\n                    *(&uStack276 + iVar4) = cVar1;\n                    iVar4 = iVar4 + 1;\n                    if (iVar4 == 4) {\n                        uVar3 = uStack276 >> 8;\n                        *puVar7 = uVar3 >> 4 | uStack276 << 2;\n                        puVar7[1] = uStack276._2_1_ >> 2 | uVar3 << 4;\n                        puVar7[2] = uStack276._2_1_ << 6 | uStack276._3_1_;\n                        puVar8 = puVar7 + 3;\n                        iVar4 = 0;\n                        iVar6 = iStack272;\n                        if (iStack272 != 0) {\n                            if (iStack272 == 1) {\n                                *arg_10h = puVar7 + (2 - puStack268);\n                                return puStack268;\n                            }\n                            if (iStack272 != 2) {\n                                fcn.00407696(puStack268);\n                                return NULL;\n                            }\n                            *arg_10h = puVar7 + (1 - puStack268);\n                            return puStack268;\n                        }\n                    }\n                }\n                uVar2 = uVar2 + 1;\n                puVar7 = puVar8;\n                if (arg_ch <= uVar2) {\n                    *arg_10h = puVar8 + -puStack268;\n                    return puStack268;\n                }\n            } while( true );\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 884
    },
    "00403420": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00403420(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    int32_t **ppiVar7;\n    int32_t *unaff_EBP;\n    uint *puVar8;\n    uint *puVar9;\n    \n    iVar5 = *param_1;\n    if (param_2 < *(iVar5 + -0xc)) {\n        param_2 = *(iVar5 + -0xc);\n    }\n    if (1 < *(iVar5 + -4)) {\n        puVar2 = *param_1;\n        ppiVar7 = puVar2 + -4;\n        iVar5 = puVar2[-3];\n        puVar3 = (**(**ppiVar7 + 0x10))();\n        iVar4 = (***puVar3)(param_2, 1);\n        if (iVar4 == 0) {\n            iVar4 = fcn.00403130();\n        }\n        if (iVar5 < param_2) {\n            param_2 = iVar5;\n        }\n        puVar3 = iVar4 + 0x10;\n        puVar9 = puVar3;\n        puVar8 = puVar2;\n        for (uVar6 = param_2 + 1U >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {\n            *puVar9 = *puVar8;\n            puVar9 = puVar9 + 1;\n            puVar8 = puVar8 + 1;\n        }\n        for (uVar6 = param_2 + 1U & 3; uVar6 != 0; uVar6 = uVar6 - 1) {\n            *puVar9 = *puVar8;\n            puVar8 = puVar8 + 1;\n            puVar9 = puVar9 + 1;\n        }\n        *(iVar4 + 4) = iVar5;\n        piVar1 = puVar2 + -1;\n        LOCK();\n        iVar5 = *piVar1;\n        *piVar1 = *piVar1 + -1;\n        if (iVar5 == 1 || iVar5 + -1 < 0) {\n            (**(**ppiVar7 + 4))(ppiVar7);\n        }\n        *unaff_EBP = puVar3;\n        return;\n    }\n    iVar5 = *(iVar5 + -8);\n    if (iVar5 < param_2) {\n        if (iVar5 < 0x401) {\n            iVar5 = iVar5 * 2;\n        }\n        else {\n            iVar5 = iVar5 + 0x400;\n        }\n        if (iVar5 < param_2) {\n            iVar5 = param_2;\n        }\n        iVar5 = (**(**(*param_1 + -0x10) + 8))(*param_1 + -0x10, iVar5, 1);\n        if (iVar5 == 0) {\n            iVar5 = fcn.00403130();\n        }\n        *param_1 = iVar5 + 0x10;\n        return;\n    }\n    return;\n}\n",
        "token_count": 716
    },
    "00403bf0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * __cdecl\nfcn.00403bf0(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint arg_ch)\n\n{\n    char cVar1;\n    uint8_t uVar2;\n    int32_t *piVar3;\n    uint8_t *puVar4;\n    char *pcVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    uint *in_FS_OFFSET;\n    int32_t *var_8h;\n    char *var_ch;\n    uint var_10h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint var_ch_2;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x41e418;\n    var_ch_2 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch_2;\n    iVar9 = 0;\n    var_14h = 0;\n    pcVar5 = var_ch;\n    do {\n        cVar1 = *pcVar5;\n        pcVar5 = pcVar5 + 1;\n    } while (cVar1 != '\\0');\n    iVar6 = pcVar5 - (var_ch + 1);\n    iVar8 = *(*(*var_8h + 4) + 0x18 + var_8h);\n    if ((0 < iVar8) && (iVar6 < iVar8)) {\n        iVar9 = iVar8 - iVar6;\n    }\n    fcn.00403620(var_8h);\n    if (var_1ch == '\\0') {\n        var_14h = 4;\n        goto code_r0x00403dae;\n    }\n    var_4h = 1;\n    if ((*(*(*var_8h + 4) + 0x10 + var_8h) & 0x1c0) == 0x40) {\ncode_r0x00403cdd:\n        iVar8 = (**(**(*(*var_8h + 4) + 0x28 + var_8h) + 0x1c))(var_ch, iVar6);\n        if (iVar8 == iVar6) {\n            for (; 0 < iVar9; iVar9 = iVar9 + -1) {\n                uVar2 = *(*(*var_8h + 4) + 0x30 + var_8h);\n                piVar3 = *(var_8h + *(*var_8h + 4) + 0x28);\n                if ((*piVar3[9] == 0) || (uVar7 = *piVar3[9],  *piVar3[0xd] + uVar7 <= uVar7)) {\n                    uVar7 = (**(*piVar3 + 4))(uVar2);\n                }\n                else {\n                    *piVar3[0xd] = *piVar3[0xd] + -1;\n                    puVar4 = *piVar3[9];\n                    *piVar3[9] = puVar4 + 1;\n                    *puVar4 = uVar2;\n                    uVar7 = uVar2;\n                }\n                if (uVar7 == 0xffffffff) {\n                    var_14h = 4;\n                    *(var_8h + *(*var_8h + 4) + 0x18) = 0;\n                    goto code_r0x00403dae;\n                }\n            }\n        }\n        else {\n            var_14h = 4;\n        }\n    }\n    else {\n        for (; 0 < iVar9; iVar9 = iVar9 + -1) {\n            uVar2 = *(*(*var_8h + 4) + 0x30 + var_8h);\n            piVar3 = *(var_8h + *(*var_8h + 4) + 0x28);\n            if ((*piVar3[9] == 0) || (uVar7 = *piVar3[9],  *piVar3[0xd] + uVar7 <= uVar7)) {\n                uVar7 = (**(*piVar3 + 4))(uVar2);\n            }\n            else {\n                *piVar3[0xd] = *piVar3[0xd] + -1;\n                puVar4 = *piVar3[9];\n                *piVar3[9] = puVar4 + 1;\n                *puVar4 = uVar2;\n                uVar7 = uVar2;\n            }\n            if (uVar7 == 0xffffffff) {\n                var_14h = 4;\n                break;\n            }\n        }\n        if (var_14h == 0) goto code_r0x00403cdd;\n    }\n    *(var_8h + *(*var_8h + 4) + 0x18) = 0;\ncode_r0x00403dae:\n    var_4h = 0;\n    if (var_14h != 0) {\n        var_14h = *(var_8h + *(*var_8h + 4) + 8) | var_14h;\n        if (*(var_8h + *(*var_8h + 4) + 0x28) == 0) {\n            var_14h = var_14h | 4;\n        }\n        fcn.00415064(var_14h, 0);\n    }\n    var_4h = 0xffffffff;\n    fcn.00403980();\n    *in_FS_OFFSET = var_ch_2;\n    return var_8h;\n}\n",
        "token_count": 1315
    },
    "00403f10": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * __thiscall fcn.00403f10(int32_t *param_1, uint8_t param_2)\n\n{\n    int32_t *piVar1;\n    uint8_t *puVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x41e438;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    uVar4 = 0;\n    fcn.00403620(param_1);\n    if (var_1ch == '\\0') {\n        uVar4 = 4;\n    }\n    else {\n        piVar1 = *(*(*param_1 + 4) + 0x28 + param_1);\n        var_4h = 1;\n        if ((*piVar1[9] == 0) || (uVar3 = *piVar1[9],  *piVar1[0xd] + uVar3 <= uVar3)) {\n            uVar3 = (**(*piVar1 + 4))(var_8h);\n        }\n        else {\n            *piVar1[0xd] = *piVar1[0xd] + -1;\n            puVar2 = *piVar1[9];\n            *piVar1[9] = puVar2 + 1;\n            *puVar2 = var_8h;\n            uVar3 = var_8h;\n        }\n        if (uVar3 == 0xffffffff) {\n            uVar4 = 4;\n        }\n    }\n    var_4h = 0;\n    if (uVar4 != 0) {\n        uVar4 = *(param_1 + *(*param_1 + 4) + 8) | uVar4;\n        if (*(param_1 + *(*param_1 + 4) + 0x28) == 0) {\n            uVar4 = uVar4 | 4;\n        }\n        fcn.00415064(uVar4, 0);\n    }\n    var_4h = 0xffffffff;\n    fcn.00403980();\n    *in_FS_OFFSET = var_ch;\n    return param_1;\n}\n",
        "token_count": 564
    },
    "00405420": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint fcn.00405420(uint param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint uVar7;\n    uint32_t uVar8;\n    uint uVar9;\n    uint uVar10;\n    uint uVar11;\n    code *pcVar12;\n    uint32_t unaff_EBP;\n    char *pcVar13;\n    uint32_t uStack412;\n    code *pcStack408;\n    code *pcStack404;\n    char *pcStack400;\n    uint uStack396;\n    char16_t *pcStack392;\n    uchar *puStack388;\n    code *pcStack384;\n    char16_t *pcStack380;\n    char *pcStack376;\n    uint uStack372;\n    char16_t *pcStack368;\n    code *pcStack364;\n    code *pcStack360;\n    char16_t *pcStack356;\n    uint uStack352;\n    uint uStack348;\n    char16_t *pcStack344;\n    uint uStack340;\n    uint32_t uStack336;\n    char16_t *pcStack332;\n    char *pcStack328;\n    uchar *puStack324;\n    uint uStack320;\n    char *pcStack316;\n    uint32_t uStack296;\n    char *pcStack292;\n    char *pcStack288;\n    uint uStack284;\n    uint uStack280;\n    uint uStack276;\n    uint uStack272;\n    uint uStack268;\n    uint uStack264;\n    char *pcStack260;\n    char *pcStack256;\n    uint uStack252;\n    uchar *puStack248;\n    uint uStack244;\n    uint uStack240;\n    uint uStack236;\n    uint uStack232;\n    uint uStack228;\n    uchar auStack176 [32];\n    uchar auStack144 [20];\n    uint uStack124;\n    uint uStack120;\n    uint uStack116;\n    char *pcStack112;\n    char *pcStack108;\n    \n    uStack228 = 0x7f00;\n    uStack232 = 0;\n    uStack124 = 3;\n    uStack120 = 0x404c30;\n    uStack116 = 0;\n    pcStack112 = NULL;\n    pcStack108 = param_1;\n    uStack236 = 0x40545a;\n    pcStack112 = (*_sym.imp.USER32.dll_LoadIconA)();\n    uStack236 = 0x7f00;\n    uStack240 = 0;\n    uStack244 = 0x40546d;\n    uStack116 = (*_sym.imp.USER32.dll_LoadCursorA)();\n    uStack244 = 0;\n    puStack248 = 0x40547b;\n    uStack116 = (*_sym.imp.GDI32.dll_GetStockObject)();\n    puStack248 = &stack0xffffff70;\n    pcStack112 = \"CountLinesProg\";\n    pcStack108 = \"CountLinesProg\";\n    uStack252 = 0x4054a0;\n    iVar3 = (*_sym.imp.USER32.dll_RegisterClassA)();\n    if (iVar3 == 0) {\n        uStack252 = 0x10;\n        pcStack256 = \"CountLinesProg\";\n        pcStack260 = \"This program requires Windows NT!\";\n        uStack264 = 0;\n        uStack268 = 0x4054b4;\n        (*_sym.imp.USER32.dll_MessageBoxA)();\n        return 0;\n    }\n    uStack252 = 0;\n    pcStack256 = param_1;\n    pcStack260 = NULL;\n    uStack264 = 0;\n    uStack268 = 0x80000000;\n    uStack272 = 0x80000000;\n    uStack276 = 0x80000000;\n    uStack280 = 0x80000000;\n    uStack284 = 0xff0000;\n    pcStack288 = \"Count C++ Lines\";\n    pcStack292 = \"CountLinesProg\";\n    uStack296 = 0;\n    (*_sym.imp.USER32.dll_CreateWindowExA)();\n    (*_sym.imp.USER32.dll_ShowWindow)();\n    (*_sym.imp.USER32.dll_UpdateWindow)();\n    pcStack316 = 0x405503;\n    fcn.00402e80();\n    iVar4 = fcn.004045c0();\n    if (iVar4 != 0) {\n        pcStack316 = 0x40551a;\n        (*_sym.imp.KERNEL32.dll_ExitProcess)();\n    }\n    do {\n        pcStack316 = 0x405526;\n        pcStack316 = fcn.00408299(0);\n        uStack320 = 0x40552c;\n        fcn.0040826a();\n        uVar5 = fcn.00408277();\n        uVar5 = uVar5 & 0x80000003;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffffc) + 1;\n        }\n    } while (uVar5 + 1 < 4);\n    pcStack316 = \"GLUCO\";\n    uStack320 = 0x405558;\n    fcn.004044e0();\n    uStack320 = 0x41f728;\n    puStack324 = 0x405569;\n    fcn.004044e0();\n    puStack324 = &stack0xffffff50;\n    pcStack328 = &stack0xffffff88;\n    pcStack332 = &stack0xffffff0c;\n    uStack336 = 0x405583;\n    fcn.00404520();\n    puStack324 = 0x41f714;\n    pcStack328 = 0x405598;\n    fcn.004044e0();\n    pcStack328 = \"8192\";\n    pcStack332 = 0x4055a2;\n    uVar5 = fcn.00401100();\n    pcStack332 = L\"4096\";\n    uStack336 = 0x4055ae;\n    uVar6 = fcn.00401100();\n    uStack336 = 0x41f700;\n    uStack340 = 0x4055ba;\n    uStack296 = fcn.00401100();\n    pcVar12 = _sym.imp.KERNEL32.dll_LoadLibraryW;\n    pcStack328 = 0x41f6f0;\n    pcStack332 = L\"KERNEL32.DLL\";\n    uStack336 = 0x4055d3;\n    uStack336 = (*_sym.imp.KERNEL32.dll_LoadLibraryW)();\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    uStack340 = 0x4055dc;\n    (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    uStack340 = 0x41f6c4;\n    pcStack344 = L\"KERNEL32.DLL\";\n    uStack348 = 0x4055ec;\n    uStack348 = (*pcVar12)();\n    uStack352 = 0x4055ef;\n    uVar7 = (*pcVar1)();\n    uStack352 = 0x41f6b4;\n    pcStack356 = L\"KERNEL32.DLL\";\n    pcStack360 = 0x4055ff;\n    pcStack360 = (*pcVar12)();\n    pcStack364 = 0x405602;\n    pcStack328 = (*pcVar1)();\n    pcStack364 = 0x41f6a4;\n    pcStack368 = L\"KERNEL32.DLL\";\n    uStack372 = 0x405612;\n    uStack372 = (*pcVar12)();\n    pcStack376 = 0x405615;\n    pcStack332 = (*pcVar1)();\n    pcStack376 = \"VirtualAllocExNuma\";\n    pcStack380 = L\"KERNEL32.DLL\";\n    pcStack384 = 0x405625;\n    pcStack384 = (*pcVar12)();\n    puStack388 = 0x405628;\n    pcStack360 = (*pcVar1)();\n    puStack388 = pcStack332;\n    if (unaff_EBP < 0x10) {\n        puStack388 = &stack0xfffffeb4;\n    }\n    pcStack392 = L\"KERNEL32.DLL\";\n    uStack396 = 0x405643;\n    uStack396 = (*pcVar12)();\n    pcStack400 = 0x405646;\n    pcStack376 = (*pcVar1)();\n    pcStack400 = pcStack316;\n    if (uStack296 < 0x10) {\n        pcStack400 = &stack0xfffffec4;\n    }\n    pcStack404 = 0x8b05;\n    pcStack408 = NULL;\n    uStack412 = 0x405665;\n    uVar8 = (*pcStack360)();\n    uStack412 = uVar8;\n    uVar9 = (*pcStack364)(0);\n    uVar10 = (*pcStack384)(0, uVar8);\n    uVar9 = (*pcStack384)(uVar9);\n    uVar11 = fcn.00402d10(uVar9, uVar10, &stack0xfffffe64);\n    uVar9 = 0;\n    pcVar13 = pcStack400;\n    uVar10 = (*pcStack408)(0, uVar10, uVar6 | uVar5, pcStack400, 0);\n    pcVar12 = (*pcStack404)(uVar10);\n    fcn.004043b0(*0x4270c0, uVar11, pcVar12, pcVar13);\n    (*pcVar12)();\n    fcn.00417a34(0, 0xffffffff);\n    fcn.00417a34(0, 0xffffffff);\n    pcVar2 = _sym.imp.USER32.dll_GetMessageA;\n    iVar4 = (*_sym.imp.USER32.dll_GetMessageA)(&stack0xfffffed8, 0, 0, 0);\n    pcVar1 = _sym.imp.USER32.dll_TranslateMessage;\n    pcVar12 = _sym.imp.USER32.dll_DispatchMessageA;\n    while (iVar4 != 0) {\n        (*pcVar1)(&stack0xfffffec8);\n        (*pcVar12)(&stack0xfffffec4);\n        iVar4 = (*pcVar2)(&stack0xfffffec0, 0, 0, 0);\n    }\n    if (0xf < uStack412) {\n        fcn.00418300(uVar9);\n    }\n    uStack412 = 0xf;\n    if (0xf < pcStack384) {\n        fcn.00418300(pcStack404);\n    }\n    pcStack384 = 0xf;\n    puStack388 = NULL;\n    pcStack404 = pcStack404 & 0xffffff00;\n    if (0xf < pcStack316) {\n        fcn.00418300(uStack336);\n    }\n    uStack320 = 0;\n    pcStack316 = 0xf;\n    uStack336 = uStack336 & 0xffffff00;\n    if (0xf < pcStack260) {\n        fcn.00418300(uStack280);\n    }\n    return uVar7;\n}\n",
        "token_count": 2447
    },
    "00405c63": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00405c63(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    \n    if (*(param_1 + 0xc) == 0) {\n        return 0;\n    }\n    piVar1 = param_1 + 4;\n    if (*piVar1 == 0) {\n        iVar2 = fcn.004182d5(0x140);\n        *piVar1 = iVar2;\n    }\n    iVar2 = *piVar1;\n    *piVar1 = *(param_1 + 8);\n    *(param_1 + 8) = iVar2;\n    uVar3 = (*_sym.imp.KERNEL32.dll_FindNextFileA)(*(param_1 + 0xc), iVar2);\n    return uVar3;\n}\n",
        "token_count": 188
    },
    "00405e49": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00405e49(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    uVar2 = 0;\n    if (param_1[1] != 0) {\n        iVar1 = (**(*param_1 + 0x38))(0x10);\n        if (((iVar1 != 0) && (iVar1 = param_1[1],  *(iVar1 + 0x2c) == '.')) &&\n           ((*(iVar1 + 0x2d) == '\\0' || ((*(iVar1 + 0x2d) == '.' && (*(iVar1 + 0x2e) == '\\0')))))) {\n            uVar2 = 1;\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 176
    },
    "004065fb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid fcn.004065fb(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint lpVersionInformation;\n    uint var_94h;\n    uint var_88h;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    puVar2 = &var_94h;\n    for (iVar1 = 0x24; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 168
    },
    "0040688e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_48h\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl\nfcn.0040688e(int32_t *arg_8h, int32_t arg_ch, uint noname_2, uint noname_3, uint32_t arg_18h, uint32_t *arg_1ch, \n            uint *arg_20h, uint noname_7, int32_t *arg_28h)\n\n{\n    uint16_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint16_t *puVar4;\n    code *pcVar5;\n    int32_t *piVar6;\n    uint32_t *puVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t *piVar11;\n    uint var_48h;\n    uint *var_44h;\n    uint *var_40h;\n    uint *var_34h;\n    uint var_30h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    \n    puVar7 = arg_1ch;\n    piVar6 = arg_8h;\n    iVar10 = 0;\n    var_30h._0_2_ = 0;\n    if (arg_8h == NULL) {\n        return -0x7ff8ffa9;\n    }\n    if (arg_1ch == NULL) {\n        return -0x7ffdfff8;\n    }\n    uVar2 = arg_1ch[2];\n    if (5 < uVar2) {\n        return -0x7ffdfff2;\n    }\n    arg_8h = NULL;\n    if (arg_1ch[3] != 0) {\n        arg_1ch = arg_1ch[1];\n        do {\n            uVar3 = *arg_1ch;\n            if (uVar2 <= uVar3) {\n                return -0x7ffdfff2;\n            }\n            arg_1ch = arg_1ch + 1;\n            arg_8h = arg_8h + 1;\n            (&var_44h)[uVar3] = *puVar7 + iVar10;\n            iVar10 = iVar10 + 0x10;\n        } while (arg_8h < puVar7[3]);\n    }\n    if (arg_8h < uVar2) {\n        iVar10 = arg_8h * 0x10 + *puVar7;\n        iVar9 = uVar2 - arg_8h;\n        piVar11 = &var_48h + (uVar2 - arg_8h);\n        do {\n            *piVar11 = iVar10;\n            iVar10 = iVar10 + 0x10;\n            piVar11 = piVar11 + -1;\n            iVar9 = iVar9 + -1;\n        } while (iVar9 != 0);\n    }\n    iVar10 = -0x7ffdfffd;\n    if (arg_28h == NULL) {\n        arg_28h = &arg_18h;\n    }\n    if (arg_20h == NULL) {\n        arg_20h = &var_30h;\n    }\n    (*_sym.imp.OLEAUT32.dll_VariantClear)(&var_10h);\n    pcVar5 = _sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime;\n    if (0x12 < arg_ch + 0x139aU) goto code_r0x00406e16;\n    // switch table (19 cases) at 0x406e29\n    switch(*((arg_ch + 0x139aU) * 4 + 0x406e29)) {\n    case 0x406973:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 100))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3]);\n            goto code_r0x00406e16;\n        }\n        break;\n    case 0x40699c:\n        if (puVar7[2] == 2) {\n            if (*var_44h != 3) {\n                iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_44h, 0, 3);\n                if (iVar10 < 0) goto code_r0x004069c2;\n                var_44h = &var_10h;\n            }\n            arg_18h = var_44h[2];\n            if (*var_40h != 3) {\n                iVar10 = (*pcVar5)(&var_10h, var_40h, 0, 3);\n                if (iVar10 < 0) {\ncode_r0x004069f0:\n                    *arg_28h = 1;\n                    goto code_r0x00406e16;\n                }\n                var_40h = &var_10h;\n            }\n            iVar10 = (**(*piVar6 + 0x60))(piVar6, arg_18h, var_40h[2], arg_20h);\n            goto code_r0x00406e16;\n        }\n        break;\n    case 0x406a13:\n        if (puVar7[2] == 2) {\n            if (*var_44h != 3) {\n                iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_44h, 0, 3);\n                if (iVar10 < 0) goto code_r0x004069c2;\n                var_44h = &var_10h;\n            }\n            iVar10 = (**(*piVar6 + 0x5c))(piVar6, var_44h[2], *var_40h, var_40h[1], var_40h[2], var_40h[3], arg_20h);\n            goto code_r0x00406e16;\n        }\n        break;\n    case 0x406a5c:\n        if (puVar7[2] == 5) {\n            iVar10 = 0;\n            do {\n                puVar4 = (&var_44h)[iVar10];\n                uVar1 = *puVar4;\n                if (((uVar1 & 0x4000) == 0) || ((uVar1 & 0xf) == 0)) {\n                    *arg_28h = iVar10;\n                    break;\n                }\n                if ((uVar1 & 0xc) == 0) {\n                    iVar9 = *(puVar4 + 4);\n                }\n                else {\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(*(puVar4 + 4));\n                    puVar4 = (&var_44h)[iVar10];\n                    **(puVar4 + 4) = 3;\n                    iVar9 = *(puVar4 + 4) + 8;\n                }\n                (&var_20h)[iVar10] = iVar9;\n                iVar10 = iVar10 + 1;\n            } while (iVar10 < 4);\n            iVar10 = (**(*piVar6 + 0x58))\n                               (piVar6, var_20h, var_1ch, var_18h, var_14h, *var_34h, var_34h[1], var_34h[2], var_34h[3]\n                               );\n            goto code_r0x00406e16;\n        }\n        break;\n    case 0x406ad2:\n        if (puVar7[2] == 2) {\n            if (*var_44h != 3) {\n                iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_44h, 0, 3);\n                if (iVar10 < 0) goto code_r0x004069c2;\n                var_44h = &var_10h;\n            }\n            iVar10 = (**(*piVar6 + 0x54))(piVar6, var_44h[2], *var_40h, var_40h[1], var_40h[2], var_40h[3]);\n            goto code_r0x00406e16;\n        }\n        break;\n    case 0x406b1c:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x50))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\ncode_r0x00406b3f:\n            if (-1 < iVar10) {\n                *arg_20h = 8;\n            }\n            goto code_r0x00406e16;\n        }\n        break;\n    case 0x406b56:\n        iVar10 = (**(*piVar6 + 0x4c))(piVar6, arg_20h);\n        goto code_r0x00406e16;\n    case 0x406b64:\n        iVar10 = (**(*piVar6 + 0x48))(piVar6, arg_20h);\n        goto code_r0x00406e16;\n    case 0x406b72:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x44))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00406b3f;\n        }\n        break;\n    case 0x406b97:\n        if (puVar7[2] == 2) {\n            uVar1 = *var_44h;\n            if (((uVar1 & 0x4000) != 0) && ((uVar1 & 0xc) == 0)) {\n                iVar10 = -0x7ffdfffb;\ncode_r0x004069c2:\n                *arg_28h = 0;\n                goto code_r0x00406e16;\n            }\n            if (uVar1 == 0x400c) {\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(var_44h[2]);\n                *var_44h[2] = 8;\n                puVar8 = var_44h[2] + 8;\n            }\n            else if (uVar1 == 0x4008) {\n                puVar8 = var_44h[2];\n            }\n            else {\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(var_44h);\n                puVar8 = var_44h + 2;\n                *var_44h = 8;\n            }\n            iVar10 = (**(*piVar6 + 0x40))(piVar6, puVar8, *var_40h, var_40h[1], var_40h[2], var_40h[3], arg_20h + 2);\n            goto code_r0x00406c0d;\n        }\n        break;\n    case 0x406c24:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x3c))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00406b3f;\n        }\n        break;\n    case 0x406c4c:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x38))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h);\n            goto code_r0x00406e16;\n        }\n        break;\n    case 0x406c70:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x34))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h);\n            goto code_r0x00406e16;\n        }\n        break;\n    case 0x406c94:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x30))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00406b3f;\n        }\n        break;\n    case 0x406cbc:\n        if ((arg_18h & 2) == 0) {\n            if ((arg_18h & 4) == 0) goto code_r0x00406d40;\n            if (puVar7[2] == 2) {\n                var_20h = *var_44h;\n                var_1ch = var_44h[1];\n                var_18h = var_44h[2];\n                var_14h = var_44h[3];\n                if (*var_40h != 8) {\n                    iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_40h, 0, 3);\n                    if (iVar10 < 0) goto code_r0x004069f0;\n                    var_40h = &var_10h;\n                }\n                iVar10 = (**(*piVar6 + 0x6c))(piVar6, var_20h, var_1ch, var_18h, var_14h, var_40h[2]);\n                goto code_r0x00406e16;\n            }\n        }\n        else if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x2c))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00406b3f;\n        }\n        break;\n    case 0x406d40:\ncode_r0x00406d40:\n        if ((arg_18h & 2) == 0) {\n            if ((arg_18h & 4) == 0) goto code_r0x00406dc4;\n            if (puVar7[2] == 2) {\n                var_20h = *var_44h;\n                var_1ch = var_44h[1];\n                var_18h = var_44h[2];\n                var_14h = var_44h[3];\n                if (*var_40h != 8) {\n                    iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_40h, 0, 3);\n                    if (iVar10 < 0) goto code_r0x004069f0;\n                    var_40h = &var_10h;\n                }\n                iVar10 = (**(*piVar6 + 0x68))(piVar6, var_20h, var_1ch, var_18h, var_14h, var_40h[2]);\n                goto code_r0x00406e16;\n            }\n        }\n        else if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x28))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00406b3f;\n        }\n        break;\n    case 0x406dc4:\ncode_r0x00406dc4:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x24))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00406e08;\n        }\n        break;\n    case 0x406de9:\n        iVar10 = (**(*piVar6 + 0x20))(piVar6, arg_20h + 2);\ncode_r0x00406c0d:\n        if (-1 < iVar10) {\n            *arg_20h = 3;\n        }\n        goto code_r0x00406e16;\n    case 0x406dfb:\n        iVar10 = (**(*piVar6 + 0x1c))(piVar6, arg_20h + 2);\ncode_r0x00406e08:\n        if (-1 < iVar10) {\n            *arg_20h = 9;\n        }\n        goto code_r0x00406e16;\n    }\n    iVar10 = -0x7ffdfff2;\ncode_r0x00406e16:\n    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_10h);\n    return iVar10;\n}\n",
        "token_count": 3874
    },
    "00406e75": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nuint __cdecl fcn.00406e75(uint noname_0, int32_t arg_ch, uint32_t arg_10h, uint noname_3, int32_t arg_18h)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint var_1h;\n    \n    uVar3 = 0;\n    if (arg_10h != 0) {\n        do {\n            bVar1 = false;\n            uVar4 = 0;\n            do {\n                iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(*(arg_ch + uVar3 * 4), *(uVar4 + 0x427530));\n                if (iVar2 == 0) {\n                    bVar1 = true;\n                    *(arg_18h + uVar3 * 4) = *(uVar4 + 0x4274e0);\n                }\n                uVar4 = uVar4 + 4;\n            } while (uVar4 < 0x4c);\n            if (!bVar1) {\n                return 0x80020006;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < arg_10h);\n    }\n    return 0;\n}\n",
        "token_count": 303
    },
    "00406f1d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00406f1d(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0xc) == 0) {\n        return 0;\n    }\n    uVar1 = (**(**(param_1 + 0xc) + 0xc))(*(param_1 + 0xc), 0);\n    return uVar1;\n}\n",
        "token_count": 90
    },
    "00406f32": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00406f32(int32_t arg_8h, int32_t **arg_ch, int32_t *arg_10h, int32_t **arg_14h)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    \n    if ((arg_8h == 0) || (arg_ch == NULL)) {\n        iVar3 = -0x7ff8ffa9;\n    }\n    else if (arg_14h == NULL) {\n        iVar3 = -0x7fffbffd;\n    }\n    else {\n        *arg_14h = NULL;\n        if ((((*arg_10h == 0) && (arg_10h[1] == 0)) && (arg_10h[2] == 0xc0)) && (arg_10h[3] == 0x46000000)) {\ncode_r0x00406fe2:\n            piVar4 = arg_ch[1] + arg_8h;\n            (**(*piVar4 + 4))(piVar4);\n            *arg_14h = piVar4;\n            iVar3 = 0;\n        }\n        else {\n            piVar4 = arg_ch[2];\n            while (piVar4 != NULL) {\n                piVar2 = *arg_ch;\n                if ((piVar2 == NULL) ||\n                   (((*piVar2 == *arg_10h && (piVar2[1] == arg_10h[1])) &&\n                    ((piVar2[2] == arg_10h[2] && (piVar2[3] == arg_10h[3])))))) {\n                    if (piVar4 == 0x1) goto code_r0x00406fe2;\n                    iVar3 = (*piVar4)(arg_8h, arg_10h, arg_14h, arg_ch[1]);\n                    if (iVar3 == 0) {\n                        return 0;\n                    }\n                    if ((piVar2 != NULL) && (iVar3 < 0)) {\n                        return iVar3;\n                    }\n                }\n                ppiVar1 = arg_ch + 5;\n                arg_ch = arg_ch + 3;\n                piVar4 = *ppiVar1;\n            }\n            iVar3 = -0x7fffbffe;\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 527
    },
    "004071c5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004071c5(code **param_1)\n\n{\n    uint uVar1;\n    \n    *param_1 = vtable.CGdiObject.0;\n    if (param_1[1] == NULL) {\n        return 0;\n    }\n    uVar1 = fcn.0041c720();\n    uVar1 = (*_sym.imp.GDI32.dll_DeleteObject)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 99
    },
    "004071ec": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004071ec(uint32_t *param_1, uint32_t param_2, uint32_t param_3)\n\n{\n    if (param_2 < 4) {\n        param_2 = 4;\n    }\n    if (param_3 < 2) {\n        param_3 = 0x40;\n    }\n    param_1[3] = 0;\n    param_1[2] = 0;\n    *param_1 = param_2;\n    param_1[1] = param_3;\n    return;\n}\n",
        "token_count": 126
    },
    "00407230": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00407230(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    \n    if (param_1[3] == 0) {\n        iVar1 = fcn.00417e76(param_1 + 2, param_1[1], *param_1);\n        iVar3 = param_1[1];\n        piVar2 = iVar1 + 4 + *param_1 * (iVar3 + -1);\n        if (-1 < iVar3 + -1) {\n            do {\n                *piVar2 = param_1[3];\n                param_1[3] = piVar2;\n                piVar2 = piVar2 - *param_1;\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n    }\n    param_1[3] = *param_1[3];\n    return;\n}\n",
        "token_count": 215
    },
    "00407271": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00407271(code **param_1)\n\n{\n    uint uVar1;\n    \n    *param_1 = vtable.CMenu.0;\n    if (param_1[1] == NULL) {\n        return 0;\n    }\n    uVar1 = fcn.0041ba8b();\n    uVar1 = (*_sym.imp.USER32.dll_DestroyMenu)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 97
    },
    "004075dd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004075dd(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint32_t arg_8h_00;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x4206e8, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if ((*0x42c3ac == 3) && (arg_8h_00 <= *0x42c398)) {\n        fcn.0040a06b(4);\n        *(unaff_EBP + -4) = 0;\n        uVar1 = fcn.0040a92e(arg_8h_00);\n        *(unaff_EBP + -0x1c) = uVar1;\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0040764f();\n        if (*(unaff_EBP + -0x1c) != 0) goto code_r0x00407646;\n    }\n    if (arg_8h_00 == 0) {\n        arg_8h_00 = 1;\n    }\n    if (*0x42c3ac != 1) {\n        arg_8h_00 = arg_8h_00 + 0xf & 0xfffffff0;\n    }\n    (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x42c3a8, 0, arg_8h_00);\ncode_r0x00407646:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 376
    },
    "00407696": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00407696(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    int32_t arg_ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x4206f8, 0xc);\n    arg_ch = *(unaff_EBP + 8);\n    if (arg_ch != 0) {\n        if (*0x42c3ac == 3) {\n            fcn.0040a06b(4);\n            *(unaff_EBP + -4) = 0;\n            arg_8h_00 = fcn.0040a14f(arg_ch);\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 != 0) {\n                fcn.0040a17a(arg_8h_00, arg_ch);\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.004076e9();\n            if (*(unaff_EBP + -0x1c) != 0) goto code_r0x00407701;\n            arg_ch = *(unaff_EBP + 8);\n        }\n        (*_sym.imp.KERNEL32.dll_HeapFree)(*0x42c3a8, 0, arg_ch);\n    }\ncode_r0x00407701:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 347
    },
    "00407707": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_58h\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00407707(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint var_58h;\n    uint lpSystemInfo;\n    int32_t var_48h;\n    uint32_t lpBuffer;\n    int32_t var_24h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    uint var_13h;\n    uint lpflOldProtect;\n    int32_t dwSize;\n    uint32_t lpAddress;\n    \n    fcn.004079f0();\n    iVar1 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(&var_58h, &lpBuffer, 0x1c);\n    if (iVar1 != 0) {\n        (*_sym.imp.KERNEL32.dll_GetSystemInfo)(&lpSystemInfo);\n        uVar4 = (~(var_48h - 1U) & &var_58h) - var_48h;\n        uVar3 = ((-(*0x42ab68 != 1) & 0xfffffff1) + 0x11) * var_48h + var_24h;\n        dwSize = var_48h;\n        if (uVar3 <= uVar4) {\n            lpAddress = uVar4;\n            if (*0x42ab68 != 1) {\n                lpAddress = var_24h;\n                do {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(lpAddress, &lpBuffer, 0x1c);\n                    if (iVar1 == 0) {\n                        return 0;\n                    }\n                    lpAddress = lpAddress + var_1ch;\n                } while ((var_18h & 0x1000) == 0);\n                lpAddress = lpBuffer;\n                if ((var_13h & 1) != 0) {\n                    return 1;\n                }\n                if (uVar4 < lpBuffer) {\n                    return 0;\n                }\n                if (lpBuffer < uVar3) {\n                    lpAddress = uVar3;\n                }\n                (*_sym.imp.KERNEL32.dll_VirtualAlloc)(lpAddress, dwSize, 0x1000, 4);\n            }\n            uVar2 = (*_sym.imp.KERNEL32.dll_VirtualProtect)\n                              (lpAddress, dwSize, (-(*0x42ab68 != 1) & 0x103) + 1, &lpflOldProtect);\n            return uVar2;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 587
    },
    "00407a2d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00407a2d(uint *arg_8h, uint8_t *arg_ch)\n\n{\n    uint8_t uVar1;\n    uint uVar2;\n    uint *puVar3;\n    uint8_t uVar4;\n    uint16_t uVar5;\n    int32_t iVar6;\n    uint16_t uVar7;\n    uint8_t *puVar8;\n    bool bVar9;\n    \n    iVar6 = fcn.0040af1e();\n    iVar6 = *(iVar6 + 0x60);\n    if (iVar6 != *0x42c3c4) {\n        iVar6 = fcn.00409726();\n    }\n    if (*(iVar6 + 8) != 0) {\n        while( true ) {\n            uVar4 = *arg_8h;\n            uVar5 = uVar4;\n            puVar3 = arg_8h + 1;\n            if ((*(uVar4 + 0x1d + iVar6) & 4) != 0) {\n                if (*puVar3 == 0) {\n                    uVar5 = 0;\n                }\n                else {\n                    uVar5 = CONCAT11(uVar4, *puVar3);\n                    puVar3 = arg_8h + 2;\n                }\n            }\n            arg_8h = puVar3;\n            uVar4 = *arg_ch;\n            uVar7 = uVar4;\n            puVar8 = arg_ch + 1;\n            if ((*(uVar4 + 0x1d + iVar6) & 4) != 0) {\n                uVar1 = *puVar8;\n                if (uVar1 == 0) {\n                    uVar7 = 0;\n                }\n                else {\n                    puVar8 = arg_ch + 2;\n                    uVar7 = CONCAT11(uVar4, uVar1);\n                }\n            }\n            if (uVar7 != uVar5) break;\n            arg_ch = puVar8;\n            if (uVar5 == 0) {\n                return 0;\n            }\n        }\n        return (-(uVar7 < uVar5) & 2) - 1;\n    }\n    if ((arg_8h & 3) != 0) {\n        if ((arg_8h & 1) != 0) {\n            uVar4 = *arg_8h;\n            arg_8h = arg_8h + 1;\n            bVar9 = uVar4 < *arg_ch;\n            if (uVar4 != *arg_ch) goto code_r0x0040aeb4;\n            arg_ch = arg_ch + 1;\n            if (uVar4 == 0) {\n                return 0;\n            }\n            if ((arg_8h & 2) == 0) goto code_r0x0040ae80;\n        }\n        uVar5 = *arg_8h;\n        arg_8h = arg_8h + 2;\n        uVar4 = uVar5;\n        bVar9 = uVar4 < *arg_ch;\n        if (uVar4 != *arg_ch) goto code_r0x0040aeb4;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        uVar4 = uVar5 >> 8;\n        bVar9 = uVar4 < arg_ch[1];\n        if (uVar4 != arg_ch[1]) goto code_r0x0040aeb4;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        arg_ch = arg_ch + 2;\n    }\ncode_r0x0040ae80:\n    while( true ) {\n        uVar2 = *arg_8h;\n        uVar4 = uVar2;\n        bVar9 = uVar4 < *arg_ch;\n        if (uVar4 != *arg_ch) break;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        uVar4 = uVar2 >> 8;\n        bVar9 = uVar4 < arg_ch[1];\n        if (uVar4 != arg_ch[1]) break;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        uVar4 = uVar2 >> 0x10;\n        bVar9 = uVar4 < arg_ch[2];\n        if (uVar4 != arg_ch[2]) break;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        uVar4 = uVar2 >> 0x18;\n        bVar9 = uVar4 < arg_ch[3];\n        if (uVar4 != arg_ch[3]) break;\n        arg_ch = arg_ch + 4;\n        arg_8h = arg_8h + 1;\n        if (uVar4 == 0) {\n            return 0;\n        }\n    }\ncode_r0x0040aeb4:\n    return bVar9 * -2 + 1;\n}\n",
        "token_count": 1099
    },
    "00407b48": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00407b48(uint8_t *arg_8h, uint8_t *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar1 = fcn.0040af1e();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x427c8c) {\n        iVar1 = fcn.0040bf89();\n    }\n    if (*(iVar1 + 0x14) == 0) {\n        iVar2 = fcn.0040bc50(arg_8h, arg_ch);\n    }\n    else {\n        do {\n            iVar2 = fcn.0040bb66(iVar1, *arg_8h);\n            arg_8h = arg_8h + 1;\n            iVar3 = fcn.0040bb66(iVar1, *arg_ch);\n            arg_ch = arg_ch + 1;\n            if (iVar2 == 0) break;\n        } while (iVar2 == iVar3);\n        iVar2 = iVar2 - iVar3;\n    }\n    return iVar2;\n}\n",
        "token_count": 258
    },
    "00407bb1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407bb1(uint8_t *arg_8h, uchar *arg_ch, uchar *arg_10h, int32_t arg_14h, uchar *arg_18h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint8_t *arg_ch_00;\n    uint32_t uVar3;\n    uint8_t *var_8h;\n    uint8_t *var_4h;\n    \n    var_4h = NULL;\n    iVar2 = fcn.004089d0(arg_8h);\n    if ((iVar2 == 0) || (arg_8h[1] != 0x3a)) {\n        arg_ch_00 = arg_8h;\n        if (arg_ch != NULL) {\n            *arg_ch = 0;\n        }\n    }\n    else {\n        if (arg_ch != NULL) {\n            fcn.0040c7a1(arg_ch, arg_8h, 2);\n            arg_ch[2] = 0;\n        }\n        arg_ch_00 = arg_8h + 2;\n    }\n    arg_8h = NULL;\n    var_8h = arg_ch_00;\n    if (*arg_ch_00 != 0) {\n        do {\n            uVar1 = *var_8h;\n            if ((*(uVar1 + 0x42c3e1) & 4) == 0) {\n                if ((uVar1 == 0x2f) || (uVar1 == 0x5c)) {\n                    arg_8h = var_8h + 1;\n                }\n                else if (uVar1 == 0x2e) {\n                    var_4h = var_8h;\n                }\n            }\n            else {\n                var_8h = var_8h + 1;\n            }\n            var_8h = var_8h + 1;\n        } while (*var_8h != 0);\n        if (arg_8h != NULL) {\n            if (arg_10h != NULL) {\n                uVar3 = arg_8h - arg_ch_00;\n                if (0xfe < uVar3) {\n                    uVar3 = 0xff;\n                }\n                fcn.0040c7a1(arg_10h, arg_ch_00, uVar3);\n                arg_10h[uVar3] = 0;\n            }\n            goto code_r0x00407c79;\n        }\n    }\n    arg_8h = arg_ch_00;\n    if (arg_10h != NULL) {\n        *arg_10h = 0;\n    }\ncode_r0x00407c79:\n    if ((var_4h == NULL) || (var_4h < arg_8h)) {\n        if (arg_14h != 0) {\n            uVar3 = 0xff;\n            if (var_8h - arg_8h < 0xff) {\n                uVar3 = var_8h - arg_8h;\n            }\n            fcn.0040c7a1(arg_14h, arg_8h, uVar3);\n            *(uVar3 + arg_14h) = 0;\n        }\n        if (arg_18h != NULL) {\n            *arg_18h = 0;\n        }\n    }\n    else {\n        if (arg_14h != 0) {\n            uVar3 = var_4h - arg_8h;\n            if (0xfe < uVar3) {\n                uVar3 = 0xff;\n            }\n            fcn.0040c7a1(arg_14h, arg_8h, uVar3);\n            *(uVar3 + arg_14h) = 0;\n        }\n        if (arg_18h != NULL) {\n            uVar3 = 0xff;\n            if (var_8h - var_4h < 0xff) {\n                uVar3 = var_8h - var_4h;\n            }\n            fcn.0040c7a1(arg_18h, var_4h, uVar3);\n            arg_18h[uVar3] = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 927
    },
    "00407f4f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.00407f4f(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint arg_8h, uint arg_ch, uint noname_16, uint noname_17, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    uint *var_8h_3;\n    uint *var_ch_2;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    uint var_34h;\n    uint *var_30h;\n    uint var_2ch;\n    uint *var_28h_2;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint *puStack28;\n    uint uStack24;\n    uint uStack20;\n    uchar *puStack16;\n    uchar *var_8h_2;\n    int32_t var_4h_2;\n    \n    var_8h_2 = &stack0xfffffffc;\n    puStack16 = &stack0xffffffc4;\n    if (var_8h_3 == 0x123) {\n        *var_ch_2 = 0x407fea;\n        var_34h = 1;\n    }\n    else {\n        pcStack40 = fcn.00408016;\n        uStack36 = *0x427850;\n        uStack32 = var_20h;\n        puStack28 = var_ch_2;\n        uStack24 = var_1ch;\n        uStack20 = var_18h;\n        var_4h_2 = 0;\n        var_28h_2 = *in_FS_OFFSET;\n        *in_FS_OFFSET = &fcn.00407f4f::var_28h_2;\n        var_30h = var_8h_3;\n        var_2ch = var_28h;\n        iVar1 = fcn.0040af1e(*var_8h_3, &fcn.00407f4f::var_30h);\n        (**(iVar1 + 0x74))();\n        var_34h = 0;\n        if (var_4h_2 == 0) {\n            *in_FS_OFFSET = var_28h_2;\n        }\n        else {\n            *var_28h_2 = **in_FS_OFFSET;\n            *in_FS_OFFSET = var_28h_2;\n        }\n    }\n    return var_34h;\n}\n",
        "token_count": 670
    },
    "00408016": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.00408016(int32_t param_1, int32_t param_2, uint param_3, uint param_4, uint param_5, uint param_6, uint param_7\n                 , uint param_8)\n\n{\n    uint uVar1;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    int32_t arg_20h;\n    int32_t noname_8;\n    code *extraout_var;\n    code *UNRECOVERED_JUMPTABLE;\n    \n    if (*(param_2 + 8) == *0x427850) {\n        if ((*(param_1 + 4) & 0x66) == 0) {\n            noname_8 = 1;\n            arg_20h = *(param_2 + 0x18);\n            fcn.0040d823(param_1, *(param_2 + 0x10), param_3, 0, *(param_2 + 0xc), *(param_2 + 0x14), arg_20h, 1);\n            UNRECOVERED_JUMPTABLE = extraout_var;\n            if (*(param_2 + 0x24) == 0) {\n                arg_20h = param_2;\n                noname_8 = param_1;\n                fcn.00407e8c(param_2, param_1);\n            }\n            fcn.00407f4f(0x123, &stack0xfffffff8, 0, 0, 0, 0, 0, arg_20h, noname_8, unaff_EBX, UNRECOVERED_JUMPTABLE, \n                         unaff_EBP, unaff_retaddr, param_1, param_2, param_3, param_4, param_5, param_6, param_7, \n                         param_8);\n    // WARNING: Could not recover jumptable at 0x004080c0. Too many branches\n    // WARNING: Treating indirect jump as call\n            uVar1 = (*UNRECOVERED_JUMPTABLE)();\n            return uVar1;\n        }\n        *(param_2 + 0x24) = 1;\n    }\n    else {\n        *(param_1 + 4) = *(param_1 + 4) | 8;\n    }\n    return 1;\n}\n",
        "token_count": 524
    },
    "004080c8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004080c8(uint32_t arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t *arg_14h, uint32_t *arg_18h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t var_4h;\n    \n    iVar3 = arg_8h;\n    var_4h = *(arg_8h + 0xc);\n    iVar2 = *(arg_8h + 0x10);\n    uVar4 = var_4h;\n    arg_8h = var_4h;\n    if (-1 < arg_ch) {\n        do {\n            if (uVar4 == 0xffffffff) {\n                fcn.0040d8fa();\n            }\n            uVar4 = uVar4 - 1;\n            iVar1 = iVar2 + uVar4 * 0x14;\n            if (((*(iVar1 + 4) < arg_10h) && (arg_10h <= *(iVar1 + 8))) || (uVar4 == 0xffffffff)) {\n                arg_ch = arg_ch + -1;\n                var_4h = arg_8h;\n                arg_8h = uVar4;\n            }\n        } while (-1 < arg_ch);\n    }\n    uVar4 = uVar4 + 1;\n    *arg_14h = uVar4;\n    *arg_18h = var_4h;\n    if ((*(iVar3 + 0xc) <= var_4h && var_4h != *(iVar3 + 0xc)) || (var_4h < uVar4)) {\n        fcn.0040d8fa();\n    }\n    return iVar2 + uVar4 * 0x14;\n}\n",
        "token_count": 407
    },
    "0040818b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0040818b(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    \n    iVar2 = fcn.0040af1e();\n    if (param_1 == *(iVar2 + 0x88)) {\n        iVar2 = fcn.0040af1e();\n        *(iVar2 + 0x88) = *(param_1 + 4);\n        return;\n    }\n    iVar2 = fcn.0040af1e();\n    iVar2 = *(iVar2 + 0x88);\n    do {\n        iVar3 = iVar2;\n        if (*(iVar3 + 4) == 0) {\n            fcn.00408fec(0x420b88, 8);\n            pcVar1 = *0x428094;\n            if (*0x428094 != NULL) {\n                *(unaff_EBP + -4) = 0;\n                (*pcVar1)();\n                *(unaff_EBP + -4) = 0xffffffff;\n            }\n            fcn.00408fec(0x420b78, 8);\n            iVar2 = fcn.0040af1e();\n            if (*(iVar2 + 0x6c) != 0) {\n                *(unaff_EBP + -4) = 0;\n                iVar2 = fcn.0040af1e();\n                (**(iVar2 + 0x6c))();\n                *(unaff_EBP + -4) = 0xffffffff;\n            }\n            fcn.0040da58(10);\n            fcn.0041372e(0x16);\n            fcn.00409c2b(3);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n        iVar2 = *(iVar3 + 4);\n    } while (param_1 != *(iVar3 + 4));\n    *(iVar3 + 4) = *(param_1 + 4);\n    return;\n}\n",
        "token_count": 449
    },
    "0040d8c5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0040d8c5(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00408fec(0x420b78, 8);\n    iVar2 = fcn.0040af1e();\n    if (*(iVar2 + 0x6c) != 0) {\n        *(unaff_EBP + -4) = 0;\n        iVar2 = fcn.0040af1e();\n        (**(iVar2 + 0x6c))();\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    fcn.0040da58(10);\n    fcn.0041372e(0x16);\n    fcn.00409c2b(3);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 221
    },
    "00408a7b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid __cdecl fcn.00408a7b(uint arg_8h, uint arg_ch)\n\n{\n    int32_t arg_ch_00;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint32_t arg_10h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x4207a0, 0x14);\n    arg_ch_00 = *(unaff_EBP + 8);\n    if (arg_ch_00 == 0) {\n        fcn.00407684(*(unaff_EBP + 0xc));\n    }\n    else {\n        arg_10h = *(unaff_EBP + 0xc);\n        if (arg_10h == 0) {\n            fcn.00407696(arg_ch_00);\n        }\n        else if (*0x42c3ac == 3) {\n            do {\n                *(unaff_EBP + -0x1c) = 0;\n                if (arg_10h < 0xffffffe1) {\n                    fcn.0040a06b(4);\n                    *(unaff_EBP + -4) = 0;\n                    iVar1 = fcn.0040a14f(arg_ch_00);\n                    *(unaff_EBP + -0x20) = iVar1;\n                    if (iVar1 != 0) {\n                        if (arg_10h <= *0x42c398) {\n                            iVar1 = fcn.0040a64f(iVar1, arg_ch_00, arg_10h);\n                            if (iVar1 == 0) {\n                                iVar1 = fcn.0040a92e(arg_10h);\n                                *(unaff_EBP + -0x1c) = iVar1;\n                                if (iVar1 != 0) {\n                                    uVar2 = *(arg_ch_00 + -4) - 1;\n                                    *(unaff_EBP + -0x24) = uVar2;\n                                    if (arg_10h <= uVar2) {\n                                        uVar2 = arg_10h;\n                                    }\n                                    fcn.004085f0(*(unaff_EBP + -0x1c), arg_ch_00, uVar2);\n                                    uVar3 = fcn.0040a14f(arg_ch_00);\n                                    *(unaff_EBP + -0x20) = uVar3;\n                                    fcn.0040a17a(uVar3, arg_ch_00);\n                                }\n                            }\n                            else {\n                                *(unaff_EBP + -0x1c) = arg_ch_00;\n                            }\n                        }\n                        if (*(unaff_EBP + -0x1c) == 0) {\n                            if (arg_10h == 0) {\n                                arg_10h = 1;\n                                *(unaff_EBP + 0xc) = 1;\n                            }\n                            arg_10h = arg_10h + 0xf & 0xfffffff0;\n                            *(unaff_EBP + 0xc) = arg_10h;\n                            iVar1 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x42c3a8, 0, arg_10h);\n                            *(unaff_EBP + -0x1c) = iVar1;\n                            if (iVar1 != 0) {\n                                uVar2 = *(arg_ch_00 + -4) - 1;\n                                *(unaff_EBP + -0x24) = uVar2;\n                                if (arg_10h <= uVar2) {\n                                    uVar2 = arg_10h;\n                                }\n                                fcn.004085f0(*(unaff_EBP + -0x1c), arg_ch_00, uVar2);\n                                fcn.0040a17a(*(unaff_EBP + -0x20), arg_ch_00);\n                            }\n                        }\n                    }\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    fcn.00408be3();\n                    if (*(unaff_EBP + -0x20) == 0) {\n                        if (arg_10h == 0) {\n                            arg_10h = 1;\n                        }\n                        arg_10h = arg_10h + 0xf & 0xfffffff0;\n                        *(unaff_EBP + 0xc) = arg_10h;\n                        uVar3 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x42c3a8, 0, arg_ch_00, arg_10h);\n                        *(unaff_EBP + -0x1c) = uVar3;\n                    }\n                }\n            } while (((*(unaff_EBP + -0x1c) == 0) && (*0x42ad04 != 0)) && (iVar1 = fcn.0040ac2a(arg_10h),  iVar1 != 0));\n        }\n        else {\n            do {\n                iVar1 = 0;\n                if (arg_10h < 0xffffffe1) {\n                    if (arg_10h == 0) {\n                        arg_10h = 1;\n                    }\n                    iVar1 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x42c3a8, 0, arg_ch_00, arg_10h);\n                }\n            } while (((iVar1 == 0) && (*0x42ad04 != 0)) && (iVar1 = fcn.0040ac2a(arg_10h),  iVar1 != 0));\n        }\n    }\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 1279
    },
    "00408c93": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint8_t * fcn.00408c93(uint8_t *param_1, uint8_t *param_2)\n\n{\n    int32_t iVar1;\n    uint8_t *puVar2;\n    \n    iVar1 = fcn.0040af1e();\n    iVar1 = *(iVar1 + 0x60);\n    if (iVar1 != *0x42c3c4) {\n        iVar1 = fcn.00409726();\n    }\n    if (param_2 <= param_1) {\n        return NULL;\n    }\n    if (*(iVar1 + 8) == 0) {\n        return param_2 + -1;\n    }\n    puVar2 = param_2 + -1;\n    do {\n        puVar2 = puVar2 + -1;\n        if (puVar2 < param_1) break;\n    } while ((*(*puVar2 + 0x1d + iVar1) & 4) != 0);\n    return param_2 + (-1 - (param_2 - puVar2 & 1U));\n}\n",
        "token_count": 233
    },
    "00408ce2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint64_t __cdecl fcn.00408ce2(int32_t arg_8h)\n\n{\n    uint64_t uVar1;\n    int32_t *in_EAX;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    bool bVar6;\n    int64_t iVar7;\n    ulong uVar8;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    int32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_ch = in_EAX[5];\n    var_8h = var_ch >> 0x1f;\n    if ((var_8h < 0) ||\n       ((((-1 < var_ch || var_8h < 0 && (var_ch < 0x45)) || (0 < var_8h)) || ((-1 < var_8h && (0x44c < var_ch)))))) {\ncode_r0x00408f28:\n        _var_ch = -1;\n    }\n    else {\n        iVar4 = in_EAX[4];\n        if ((iVar4 < 0) || (0xb < iVar4)) {\n            uVar2 = iVar4 / 0xc;\n            iVar4 = iVar4 % 0xc;\n            bVar6 = CARRY4(var_ch, uVar2);\n            var_ch = var_ch + uVar2;\n            in_EAX[4] = iVar4;\n            var_8h = var_8h + (uVar2 >> 0x1f) + bVar6;\n            if (iVar4 < 0) {\n                bVar6 = var_ch != 0;\n                var_ch = var_ch - 1;\n                in_EAX[4] = iVar4 + 0xc;\n                var_8h = var_8h + -1 + bVar6;\n            }\n            if ((((var_8h < 0) || ((var_8h < 1 && (var_ch < 0x45)))) || (0 < var_8h)) ||\n               ((-1 < var_8h && (0x44c < var_ch)))) goto code_r0x00408f28;\n        }\n        iVar4 = in_EAX[4];\n        var_14h = *(iVar4 * 4 + 0x4282d4);\n        var_10h = var_14h >> 0x1f;\n        iVar7 = fcn.0040eed0(var_ch, var_8h, 4, 0);\n        if ((iVar7 == 0) && (uVar2 = var_ch,  iVar7 = fcn.0040eed0(var_ch, var_8h, 100, 0),  iVar7 != 0)) {\ncode_r0x00408dd7:\n            if (1 < iVar4) {\n                bVar6 = 0xfffffffe < var_14h;\n                var_14h = var_14h + 1;\n                var_10h = var_10h + bVar6;\n            }\n        }\n        else {\n            uVar2 = var_ch + 0x76c;\n            iVar7 = fcn.0040eed0();\n            if (iVar7 == 0) goto code_r0x00408dd7;\n        }\n        iVar5 = var_ch - 1;\n        iVar4 = var_8h - (var_ch == 0);\n        iVar7 = fcn.004092f0(var_ch + 299, var_8h + (0xfffffed4 < var_ch), 400, 0, uVar2);\n        uVar2 = iVar7 + in_EAX[3];\n        var_4h = iVar7 + in_EAX[3] >> 0x20;\n        uVar8 = fcn.004092f0(iVar5, iVar4, 100, 0);\n        var_4h = (var_4h - (uVar8 >> 0x20)) - (uVar2 < uVar8);\n        iVar7 = fcn.004092f0(iVar5, iVar4, 4, 0);\n        uVar1 = iVar7 + CONCAT44(var_4h, uVar2 - uVar8);\n        var_4h = uVar1 >> 0x20;\n        iVar7 = fcn.004092b0(var_ch, var_8h, 0x16d, 0);\n        iVar7 = iVar7 + (uVar1 & 0xffffffff | var_4h << 0x20) + CONCAT44(var_10h, var_14h);\n        uVar2 = iVar7;\n        var_4h = uVar2 - 0x63df;\n        iVar7 = fcn.004092b0(var_4h, (iVar7 >> 0x20) - (uVar2 < 0x63df), 0x18, 0);\n        iVar7 = fcn.004092b0(iVar7 + in_EAX[2], 0x3c, 0);\n        _var_ch = fcn.004092b0(iVar7 + in_EAX[1], 0x3c, 0);\n        _var_ch = _var_ch + *in_EAX;\n        if (arg_8h == 0) {\n            piVar3 = fcn.0040e62d(&var_ch);\ncode_r0x00408f14:\n            if (piVar3 == NULL) goto code_r0x00408f28;\n        }\n        else {\n            fcn.0040ee39();\n            _var_ch = _var_ch + *0x4281f0;\n            piVar3 = fcn.00409d0a(&var_ch);\n            if (piVar3 == NULL) goto code_r0x00408f28;\n            if ((0 < in_EAX[8]) || ((in_EAX[8] < 0 && (0 < piVar3[8])))) {\n                _var_ch = _var_ch + *0x4281f8;\n                piVar3 = fcn.00409d0a(&var_ch);\n                goto code_r0x00408f14;\n            }\n        }\n        for (iVar4 = 9; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *in_EAX = *piVar3;\n            piVar3 = piVar3 + 1;\n            in_EAX = in_EAX + 1;\n        }\n    }\n    return _var_ch;\n}\n",
        "token_count": 1463
    },
    "00408f3f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00408f3f(int32_t arg_8h, char *lpFilePart, uint32_t nBufferLength)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    \n    pcVar1 = lpFilePart;\n    if ((lpFilePart == NULL) || (*lpFilePart == '\\0')) {\n        iVar2 = fcn.0040f0a4(arg_8h, nBufferLength);\n        return iVar2;\n    }\n    iVar2 = arg_8h;\n    if (arg_8h == 0) {\n        iVar2 = fcn.00407684(0x104);\n        if (iVar2 == 0) {\n            puVar3 = fcn.00409c85();\n            *puVar3 = 0xc;\n            return 0;\n        }\n        nBufferLength = 0x104;\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetFullPathNameA)(pcVar1, nBufferLength, iVar2, &lpFilePart);\n    if (nBufferLength <= uVar4) {\n        if (arg_8h == 0) {\n            fcn.00407696(iVar2);\n        }\n        puVar3 = fcn.00409c85();\n        *puVar3 = 0x22;\n        return 0;\n    }\n    if (uVar4 == 0) {\n        if (arg_8h == 0) {\n            fcn.00407696(iVar2);\n        }\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        fcn.00409c97(uVar5);\n        return 0;\n    }\n    return iVar2;\n}\n",
        "token_count": 396
    },
    "00409158": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint32_t * __cdecl fcn.00409158(uint32_t *arg_8h, uint32_t arg_ch)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    \n    iVar3 = fcn.0040af1e();\n    iVar3 = *(iVar3 + 0x60);\n    if (iVar3 != *0x42c3c4) {\n        iVar3 = fcn.00409726();\n    }\n    if (*(iVar3 + 8) == 0) {\n        uVar7 = arg_8h & 3;\n        while (uVar7 != 0) {\n            if (*arg_8h == arg_ch) {\n                return arg_8h;\n            }\n            if (*arg_8h == 0) {\n                return NULL;\n            }\n            uVar7 = arg_8h + 1 & 3;\n            arg_8h = arg_8h + 1;\n        }\n        while( true ) {\n            while( true ) {\n                uVar7 = *arg_8h;\n                uVar6 = uVar7 ^ CONCAT22(CONCAT11(arg_ch, arg_ch), CONCAT11(arg_ch, arg_ch));\n                uVar4 = uVar7 ^ 0xffffffff ^ uVar7 + 0x7efefeff;\n                puVar5 = arg_8h + 1;\n                if (((uVar6 ^ 0xffffffff ^ uVar6 + 0x7efefeff) & 0x81010100) != 0) break;\n                arg_8h = puVar5;\n                if ((uVar4 & 0x81010100) != 0) {\n                    if ((uVar4 & 0x1010100) != 0) {\n                        return NULL;\n                    }\n                    if ((uVar7 + 0x7efefeff & 0x80000000) == 0) {\n                        return NULL;\n                    }\n                }\n            }\n            uVar7 = *arg_8h;\n            if (uVar7 == arg_ch) {\n                return arg_8h;\n            }\n            if (uVar7 == 0) {\n                return NULL;\n            }\n            uVar2 = uVar7 >> 8;\n            if (uVar2 == arg_ch) {\n                return arg_8h + 1;\n            }\n            if (uVar2 == 0) break;\n            uVar2 = uVar7 >> 0x10;\n            if (uVar2 == arg_ch) {\n                return arg_8h + 2;\n            }\n            if (uVar2 == 0) {\n                return NULL;\n            }\n            uVar2 = uVar7 >> 0x18;\n            if (uVar2 == arg_ch) {\n                return arg_8h + 3;\n            }\n            arg_8h = puVar5;\n            if (uVar2 == 0) {\n                return NULL;\n            }\n        }\n        return NULL;\n    }\n    while( true ) {\n        uVar2 = *arg_8h;\n        uVar7 = uVar2;\n        if (uVar2 == 0) break;\n        if ((*(uVar7 + 0x1d + iVar3) & 4) == 0) {\n            puVar5 = arg_8h;\n            if (arg_ch == uVar7) break;\n        }\n        else {\n            uVar1 = *(arg_8h + 1);\n            if (uVar1 == 0) {\n                return NULL;\n            }\n            puVar5 = arg_8h + 1;\n            if (arg_ch == CONCAT11(uVar2, uVar1)) {\n                return arg_8h;\n            }\n        }\n        arg_8h = puVar5 + 1;\n    }\n    return ~-(arg_ch != uVar7) & arg_8h;\n}\n",
        "token_count": 884
    },
    "0040939a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040939a(uint lpMem, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint32_t arg_10h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x4207b0, 0x10);\n    arg_10h = *(unaff_EBP + 0xc);\n    if (arg_10h < 0xffffffe1) {\n        if (*0x42c3ac == 3) {\n            fcn.0040a06b(4);\n            *(unaff_EBP + -4) = 0;\n            uVar2 = *(unaff_EBP + 8);\n            iVar1 = fcn.0040a14f(uVar2);\n            *(unaff_EBP + -0x20) = iVar1;\n            if (((iVar1 != 0) && (*(unaff_EBP + -0x1c) = 0,  arg_10h <= *0x42c398)) &&\n               (iVar1 = fcn.0040a64f(iVar1, uVar2, arg_10h),  iVar1 != 0)) {\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00409418();\n            if (*(unaff_EBP + -0x20) != 0) goto code_r0x0040943e;\n            if (arg_10h == 0) {\n                arg_10h = 1;\n            }\n            arg_10h = arg_10h + 0xf & 0xfffffff0;\n        }\n        else if (arg_10h == 0) {\n            arg_10h = 1;\n        }\n        uVar2 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x42c3a8, 0x10, *(unaff_EBP + 8), arg_10h);\n        *(unaff_EBP + -0x1c) = uVar2;\n    }\ncode_r0x0040943e:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 526
    },
    "00409444": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00409444(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x4207c0, 0x10);\n    if (*0x42c3ac == 3) {\n        fcn.0040a06b(4);\n        *(unaff_EBP + -4) = 0;\n        iVar1 = *(unaff_EBP + 8);\n        iVar2 = fcn.0040a14f(iVar1);\n        *(unaff_EBP + -0x20) = iVar2;\n        if (iVar2 != 0) {\n            *(unaff_EBP + -0x1c) = *(iVar1 + -4) + -9;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.004094b1();\n        if (*(unaff_EBP + -0x20) != 0) goto code_r0x004094a6;\n    }\n    (*_sym.imp.KERNEL32.dll_HeapSize)(*0x42c3a8, 0, *(unaff_EBP + 8));\ncode_r0x004094a6:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 327
    },
    "004094ba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.004094ba(uint8_t *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    \n    iVar1 = fcn.0040af1e();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x427c8c) {\n        iVar1 = fcn.0040bf89();\n    }\n    while( true ) {\n        if (*(iVar1 + 0x28) < 2) {\n            uVar2 = *(*(iVar1 + 0x48) + *param_1 * 2) & 8;\n        }\n        else {\n            uVar2 = fcn.0040f638(iVar1, *param_1, 8);\n        }\n        if (uVar2 == 0) break;\n        param_1 = param_1 + 1;\n    }\n    uVar2 = *param_1;\n    puVar5 = param_1 + 1;\n    if ((uVar2 == 0x2d) || (uVar3 = uVar2,  uVar2 == 0x2b)) {\n        uVar3 = *puVar5;\n        puVar5 = param_1 + 2;\n    }\n    iVar1 = 0;\n    while( true ) {\n        if ((uVar3 < 0x30) || (0x39 < uVar3)) {\n            iVar4 = -1;\n        }\n        else {\n            iVar4 = uVar3 - 0x30;\n        }\n        if (iVar4 == -1) break;\n        iVar1 = iVar4 + iVar1 * 10;\n        uVar3 = *puVar5;\n        puVar5 = puVar5 + 1;\n    }\n    if (uVar2 == 0x2d) {\n        iVar1 = -iVar1;\n    }\n    return iVar1;\n}\n",
        "token_count": 441
    },
    "0040959a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_518h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040959a(void)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uchar uVar4;\n    char cVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint8_t *puVar8;\n    uint unaff_ESI;\n    uint *puVar9;\n    uint noname_8;\n    uint noname_9;\n    uint *noname_2;\n    uint noname_11;\n    uint *noname_4;\n    uint noname_13;\n    uint noname_14;\n    uint noname_15;\n    uint noname_8_00;\n    uint *noname_1;\n    uint noname_10;\n    uint noname_12;\n    uint noname_13_00;\n    uint noname_14_00;\n    uint noname_7;\n    uint *arg_8h;\n    uint var_518h;\n    uint in_stack_fffffae8;\n    uint in_stack_fffffaec;\n    uint in_stack_fffffaf0;\n    uint in_stack_fffffaf4;\n    uint in_stack_fffffaf8;\n    uint in_stack_fffffafc;\n    uint in_stack_fffffb00;\n    uint in_stack_fffffb04;\n    uint var_318h;\n    uint var_218h;\n    uint var_118h;\n    uint lpCPInfo;\n    uint var_12h;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    arg_8h = &lpCPInfo;\n    noname_7 = *0x42c4e4;\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfo)();\n    if (iVar2 == 1) {\n        uVar3 = 0;\n        do {\n            *(&var_118h + uVar3) = uVar3;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n        var_118h._0_1_ = 0x20;\n        if (var_12h != 0) {\n            puVar8 = &var_12h + 1;\n            do {\n                uVar3 = var_12h;\n                if (uVar3 <= *puVar8) {\n                    uVar6 = (*puVar8 - uVar3) + 1;\n                    puVar9 = &var_118h + uVar3;\n                    for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n                        *puVar9 = 0x20202020;\n                        puVar9 = puVar9 + 1;\n                    }\n                    for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {\n                        *puVar9 = 0x20;\n                        puVar9 = puVar9 + 1;\n                    }\n                }\n                var_12h._0_1_ = puVar8[1];\n                puVar8 = puVar8 + 2;\n            } while (var_12h != 0);\n        }\n        noname_14_00 = 0;\n        puVar9 = &var_518h;\n        noname_10 = 0x100;\n        noname_1 = &var_118h;\n        noname_8_00 = 1;\n        noname_12 = *0x42c4e4;\n        noname_13_00 = *0x42c3c0;\n        fcn.0040fb26(1, noname_1, 0x100, puVar9, *0x42c4e4, *0x42c3c0, 0, noname_7, arg_8h, unaff_ESI, var_518h, \n                     in_stack_fffffae8, in_stack_fffffaec, in_stack_fffffaf0, in_stack_fffffaf4);\n        noname_15 = 0;\n        noname_4 = &var_218h;\n        noname_13 = 0x100;\n        noname_11 = 0x100;\n        noname_2 = &var_118h;\n        noname_9 = 0x100;\n        noname_8 = *0x42c3c0;\n        noname_14 = *0x42c4e4;\n        fcn.0040f76a(*0x42c3c0, 0x100, noname_2, 0x100, noname_4, 0x100, *0x42c4e4, 0, noname_8_00, noname_1, noname_10\n                     , puVar9, noname_12, noname_13_00, noname_14_00, noname_7, arg_8h, unaff_ESI, var_518h, \n                     in_stack_fffffae8, in_stack_fffffaec, in_stack_fffffaf0, in_stack_fffffaf4, in_stack_fffffaf8, \n                     in_stack_fffffafc, in_stack_fffffb00, in_stack_fffffb04);\n        fcn.0040f76a(*0x42c3c0, 0x200, &var_118h, 0x100, &var_318h, 0x100, *0x42c4e4, 0, noname_8, noname_9, noname_2, \n                     noname_11, noname_4, noname_13, noname_14, noname_15, noname_8_00, noname_1, noname_10, puVar9, \n                     noname_12, noname_13_00, noname_14_00, noname_7, arg_8h, unaff_ESI, var_518h);\n        uVar3 = 0;\n        do {\n            uVar1 = *(&var_518h + uVar3 * 2);\n            if ((uVar1 & 1) == 0) {\n                if ((uVar1 & 2) != 0) {\n                    *(uVar3 + 0x42c3e1) = *(uVar3 + 0x42c3e1) | 0x20;\n                    uVar4 = *(&var_318h + uVar3);\n                    goto code_r0x004096ac;\n                }\n                *(uVar3 + 0x42c500) = 0;\n            }\n            else {\n                *(uVar3 + 0x42c3e1) = *(uVar3 + 0x42c3e1) | 0x10;\n                uVar4 = *(&var_218h + uVar3);\ncode_r0x004096ac:\n                *(uVar3 + 0x42c500) = uVar4;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n    }\n    else {\n        uVar3 = 0;\n        do {\n            if ((uVar3 < 0x41) || (0x5a < uVar3)) {\n                if ((0x60 < uVar3) && (uVar3 < 0x7b)) {\n                    *(uVar3 + 0x42c3e1) = *(uVar3 + 0x42c3e1) | 0x20;\n                    cVar5 = uVar3 + -0x20;\n                    goto code_r0x004096ef;\n                }\n                *(uVar3 + 0x42c500) = 0;\n            }\n            else {\n                *(uVar3 + 0x42c3e1) = *(uVar3 + 0x42c3e1) | 0x10;\n                cVar5 = uVar3 + ' ';\ncode_r0x004096ef:\n                *(uVar3 + 0x42c500) = cVar5;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n    }\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 1871
    },
    "00409795": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409795(int32_t arg_8h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    uint extraout_ECX_00;\n    int32_t iVar5;\n    uint8_t *puVar6;\n    uint8_t *puVar7;\n    uint *puVar8;\n    uint32_t var_1ch;\n    uint32_t lpCPInfo;\n    uint var_12h;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    if (arg_8h != 0) {\n        iVar5 = 0;\n        uVar3 = 0;\ncode_r0x004097b7:\n        if (*(uVar3 + 0x427898) != arg_8h) goto code_r0x004097bf;\n        puVar8 = 0x42c3e0;\n        for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar8 = 0;\n            puVar8 = puVar8 + 1;\n        }\n        var_1ch = 0;\n        *puVar8 = 0;\n        puVar6 = iVar5 * 0x30 + 0x4278a8;\n        do {\n            uVar2 = *puVar6;\n            puVar7 = puVar6;\n            while ((uVar2 != 0 && (uVar1 = puVar7[1],  uVar1 != 0))) {\n                uVar3 = uVar2;\n                if (uVar3 <= uVar1) {\n                    uVar2 = *(var_1ch + 0x427890);\n                    do {\n                        *(uVar3 + 0x42c3e1) = *(uVar3 + 0x42c3e1) | uVar2;\n                        uVar3 = uVar3 + 1;\n                    } while (uVar3 <= uVar1);\n                }\n                puVar7 = puVar7 + 2;\n                uVar2 = *puVar7;\n            }\n            var_1ch = var_1ch + 1;\n            puVar6 = puVar6 + 8;\n        } while (var_1ch < 4);\n        *0x42c4e4 = arg_8h;\n        *0x42c3c8 = 1;\n        *0x42c3c0 = fcn.00409542();\n        *0x42c4f0 = *(extraout_ECX + 0x42789c);\n        *0x42c4f4 = *(extraout_ECX + 0x4278a0);\n        *0x42c4f8 = *(extraout_ECX + 0x4278a4);\n        goto code_r0x0040990c;\n    }\ncode_r0x00409907:\n    fcn.00409571();\ncode_r0x0040990c:\n    fcn.0040959a();\ncode_r0x00409918:\n    fcn.0040895e();\n    return;\ncode_r0x004097bf:\n    uVar3 = uVar3 + 0x30;\n    iVar5 = iVar5 + 1;\n    if (0xef < uVar3) goto code_r0x004097ca;\n    goto code_r0x004097b7;\ncode_r0x004097ca:\n    iVar5 = (*_sym.imp.KERNEL32.dll_GetCPInfo)(arg_8h, &lpCPInfo);\n    if (iVar5 != 1) {\n        if (*0x42ab5c == 0) goto code_r0x00409918;\n        goto code_r0x00409907;\n    }\n    puVar8 = 0x42c3e0;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *0x42c4e4 = arg_8h;\n    *0x42c3c0 = 0;\n    if (lpCPInfo < 2) {\n        *0x42c3c8 = 0;\n    }\n    else {\n        if (var_12h != '\\0') {\n            puVar6 = &var_12h + 1;\n            do {\n                uVar2 = *puVar6;\n                if (uVar2 == 0) break;\n                for (uVar3 = puVar6[-1]; uVar3 <= uVar2; uVar3 = uVar3 + 1) {\n                    *(uVar3 + 0x42c3e1) = *(uVar3 + 0x42c3e1) | 4;\n                }\n                puVar7 = puVar6 + 1;\n                puVar6 = puVar6 + 2;\n            } while (*puVar7 != 0);\n        }\n        uVar3 = 1;\n        do {\n            *(uVar3 + 0x42c3e1) = *(uVar3 + 0x42c3e1) | 8;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0xff);\n        *0x42c3c0 = fcn.00409542();\n        *0x42c3c8 = extraout_ECX_00;\n    }\n    *0x42c4f0 = 0;\n    *0x42c4f4 = 0;\n    *0x42c4f8 = 0;\n    goto code_r0x0040990c;\n}\n",
        "token_count": 1293
    },
    "0040a09c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint fcn.0040a09c(void)\n\n{\n    if ((*0x42ab68 == 2) && (4 < *0x42ab74)) {\n        return 1;\n    }\n    return 3;\n}\n",
        "token_count": 50
    },
    "0040a0b6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint fcn.0040a0b6(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *0x42c3a8 = (*_sym.imp.KERNEL32.dll_HeapCreate)(param_1 == 0, 0x1000, 0);\n    if (*0x42c3a8 == 0) {\n        return 0;\n    }\n    *0x42c3ac = fcn.0040a09c();\n    if ((*0x42c3ac == 3) && (iVar1 = fcn.0040a107(0x3f8),  iVar1 == 0)) {\n        (*_sym.imp.KERNEL32.dll_HeapDestroy)(*0x42c3a8);\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 179
    },
    "0040a17a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a17a(uint32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    uint32_t *puVar3;\n    int32_t *piVar4;\n    char cVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    code *pcVar8;\n    uint8_t uVar9;\n    uint32_t uVar10;\n    uint32_t *puVar11;\n    uint32_t *puVar12;\n    uint32_t *puVar13;\n    uint32_t uVar14;\n    uint32_t uVar15;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    uVar6 = arg_8h[4];\n    puVar13 = arg_ch + -4;\n    uVar15 = arg_ch - arg_8h[3] >> 0xf;\n    piVar4 = uVar15 * 0x204 + 0x144 + uVar6;\n    var_4h = *puVar13 - 1;\n    if ((var_4h & 1) == 0) {\n        puVar11 = var_4h + puVar13;\n        uVar14 = *puVar11;\n        uVar7 = *(arg_ch + -8);\n        if ((uVar14 & 1) == 0) {\n            uVar10 = (uVar14 >> 4) - 1;\n            if (0x3f < uVar10) {\n                uVar10 = 0x3f;\n            }\n            if (puVar11[1] == puVar11[2]) {\n                if (uVar10 < 0x20) {\n                    pcVar2 = uVar10 + 4 + uVar6;\n                    uVar10 = ~(0x80000000U >> (uVar10 & 0x1f));\n                    puVar12 = uVar6 + 0x44 + uVar15 * 4;\n                    *puVar12 = *puVar12 & uVar10;\n                    *pcVar2 = *pcVar2 + -1;\n                    if (*pcVar2 == '\\0') {\n                        *arg_8h = *arg_8h & uVar10;\n                    }\n                }\n                else {\n                    pcVar2 = uVar10 + 4 + uVar6;\n                    uVar10 = ~(0x80000000U >> (uVar10 - 0x20 & 0x1f));\n                    puVar12 = uVar6 + 0xc4 + uVar15 * 4;\n                    *puVar12 = *puVar12 & uVar10;\n                    *pcVar2 = *pcVar2 + -1;\n                    if (*pcVar2 == '\\0') {\n                        arg_8h[1] = arg_8h[1] & uVar10;\n                    }\n                }\n            }\n            var_4h = var_4h + uVar14;\n            *(puVar11[2] + 4) = puVar11[1];\n            *(puVar11[1] + 8) = puVar11[2];\n        }\n        puVar11 = (var_4h >> 4) + -1;\n        if (0x3f < puVar11) {\n            puVar11 = 0x3f;\n        }\n        puVar12 = arg_8h;\n        if ((uVar7 & 1) == 0) {\n            puVar13 = puVar13 - uVar7;\n            puVar12 = (uVar7 >> 4) + -1;\n            if (0x3f < puVar12) {\n                puVar12 = 0x3f;\n            }\n            var_4h = var_4h + uVar7;\n            puVar11 = (var_4h >> 4) + -1;\n            if (0x3f < puVar11) {\n                puVar11 = 0x3f;\n            }\n            if (puVar12 != puVar11) {\n                if (puVar13[1] == puVar13[2]) {\n                    if (puVar12 < 0x20) {\n                        uVar14 = ~(0x80000000U >> (puVar12 & 0x1f));\n                        puVar3 = uVar6 + 0x44 + uVar15 * 4;\n                        *puVar3 = *puVar3 & uVar14;\n                        pcVar2 = puVar12 + uVar6 + 4;\n                        *pcVar2 = *pcVar2 + -1;\n                        if (*pcVar2 == '\\0') {\n                            *arg_8h = *arg_8h & uVar14;\n                        }\n                    }\n                    else {\n                        uVar14 = ~(0x80000000U >> (puVar12 - 0x20 & 0x1f));\n                        puVar3 = uVar6 + 0xc4 + uVar15 * 4;\n                        *puVar3 = *puVar3 & uVar14;\n                        pcVar2 = puVar12 + uVar6 + 4;\n                        *pcVar2 = *pcVar2 + -1;\n                        if (*pcVar2 == '\\0') {\n                            arg_8h[1] = arg_8h[1] & uVar14;\n                        }\n                    }\n                }\n                *(puVar13[2] + 4) = puVar13[1];\n                *(puVar13[1] + 8) = puVar13[2];\n            }\n        }\n        if (((uVar7 & 1) != 0) || (puVar12 != puVar11)) {\n            piVar1 = piVar4 + puVar11 * 2;\n            uVar14 = piVar1[1];\n            puVar13[2] = piVar1;\n            puVar13[1] = uVar14;\n            piVar1[1] = puVar13;\n            *(puVar13[1] + 8) = puVar13;\n            if (puVar13[1] == puVar13[2]) {\n                cVar5 = *(puVar11 + uVar6 + 4);\n                *(puVar11 + uVar6 + 4) = cVar5 + '\\x01';\n                uVar9 = puVar11;\n                if (puVar11 < 0x20) {\n                    if (cVar5 == '\\0') {\n                        *arg_8h = *arg_8h | 0x80000000U >> (uVar9 & 0x1f);\n                    }\n                    puVar11 = uVar6 + 0x44 + uVar15 * 4;\n                    *puVar11 = *puVar11 | 0x80000000U >> (uVar9 & 0x1f);\n                }\n                else {\n                    if (cVar5 == '\\0') {\n                        arg_8h[1] = arg_8h[1] | 0x80000000U >> (uVar9 - 0x20 & 0x1f);\n                    }\n                    puVar11 = uVar6 + 0xc4 + uVar15 * 4;\n                    *puVar11 = *puVar11 | 0x80000000U >> (uVar9 - 0x20 & 0x1f);\n                }\n            }\n        }\n        *puVar13 = var_4h;\n        *((var_4h - 4) + puVar13) = var_4h;\n        *piVar4 = *piVar4 + -1;\n        pcVar8 = _sym.imp.KERNEL32.dll_VirtualFree;\n        if (*piVar4 == 0) {\n            if (*0x42c38c != NULL) {\n                (*_sym.imp.KERNEL32.dll_VirtualFree)(*0x42c3a4 * 0x8000 + (*0x42c38c)[3], 0x8000, 0x4000);\n                (*0x42c38c)[2] = (*0x42c38c)[2] | 0x80000000U >> (*0x42c3a4 & 0x1f);\n                *((*0x42c38c)[4] + 0xc4 + *0x42c3a4 * 4) = 0;\n                *((*0x42c38c)[4] + 0x43) = *((*0x42c38c)[4] + 0x43) + -1;\n                if (*((*0x42c38c)[4] + 0x43) == '\\0') {\n                    (*0x42c38c)[1] = (*0x42c38c)[1] & 0xfffffffe;\n                }\n                if ((*0x42c38c)[2] == 0xffffffff) {\n                    (*pcVar8)((*0x42c38c)[3], 0, 0x8000);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(*0x42c3a8, 0, (*0x42c38c)[4]);\n                    fcn.004072a0(*0x42c38c, *0x42c38c + 5, (*0x42c390 * 0x14 - *0x42c38c) + -0x14 + *0x42c394);\n                    *0x42c390 = *0x42c390 + -1;\n                    if (*0x42c38c < arg_8h) {\n                        arg_8h = arg_8h + -5;\n                    }\n                    *0x42c39c = *0x42c394;\n                }\n            }\n            *0x42c38c = arg_8h;\n            *0x42c3a4 = uVar15;\n        }\n    }\n    return;\n}\n",
        "token_count": 2190
    },
    "0040a92e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0040a92e(uint32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    int32_t *piVar3;\n    char cVar4;\n    int32_t *piVar5;\n    uint uVar6;\n    uint8_t uVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    uint32_t *puVar10;\n    int32_t iVar11;\n    uint32_t uVar12;\n    int32_t *piVar13;\n    uint32_t *puVar14;\n    uint32_t *puVar15;\n    uint32_t uVar16;\n    int32_t iVar17;\n    bool bVar18;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    uVar8 = arg_8h + 0x17U & 0xfffffff0;\n    iVar9 = (arg_8h + 0x17U >> 4) + -1;\n    puVar10 = *0x42c394 + *0x42c390 * 5;\n    uVar7 = iVar9;\n    if (iVar9 < 0x20) {\n        uVar16 = 0xffffffff >> (uVar7 & 0x1f);\n        var_8h = 0xffffffff;\n    }\n    else {\n        uVar16 = 0;\n        var_8h = 0xffffffff >> (uVar7 - 0x20 & 0x1f);\n    }\n    bVar18 = *0x42c39c < puVar10;\n    arg_8h = *0x42c39c;\n    while ((bVar18 && ((arg_8h[1] & var_8h | *arg_8h & uVar16) == 0))) {\n        arg_8h = arg_8h + 5;\n        bVar18 = arg_8h < puVar10;\n    }\n    puVar14 = *0x42c394;\n    if (arg_8h == puVar10) {\n        for (; (puVar14 < *0x42c39c && ((puVar14[1] & var_8h | *puVar14 & uVar16) == 0)); puVar14 = puVar14 + 5) {\n        }\n        arg_8h = puVar14;\n        if (puVar14 == *0x42c39c) {\n            for (; (puVar14 < puVar10 && (puVar14[2] == 0)); puVar14 = puVar14 + 5) {\n            }\n            puVar15 = *0x42c394;\n            arg_8h = puVar14;\n            if (puVar14 == puVar10) {\n                for (; (puVar15 < *0x42c39c && (puVar15[2] == 0)); puVar15 = puVar15 + 5) {\n                }\n                arg_8h = puVar15;\n                if ((puVar15 == *0x42c39c) && (arg_8h = fcn.0040a492(),  arg_8h == NULL)) {\n                    return NULL;\n                }\n            }\n            uVar6 = fcn.0040a549(arg_8h);\n            *arg_8h[4] = uVar6;\n            if (*arg_8h[4] == -1) {\n                return NULL;\n            }\n        }\n    }\n    piVar5 = arg_8h[4];\n    var_4h = *piVar5;\n    if ((var_4h == -1) || ((piVar5[var_4h + 0x31] & var_8h | piVar5[var_4h + 0x11] & uVar16) == 0)) {\n        var_4h = 0;\n        puVar10 = piVar5 + 0x11;\n        uVar12 = piVar5[0x31] & var_8h | *puVar10 & uVar16;\n        while (uVar12 == 0) {\n            puVar14 = puVar10 + 0x21;\n            var_4h = var_4h + 1;\n            puVar10 = puVar10 + 1;\n            uVar12 = *puVar14 & var_8h | *puVar10 & uVar16;\n        }\n    }\n    piVar3 = piVar5 + var_4h * 0x81 + 0x51;\n    iVar9 = 0;\n    uVar16 = piVar5[var_4h + 0x11] & uVar16;\n    if (uVar16 == 0) {\n        uVar16 = piVar5[var_4h + 0x31] & var_8h;\n        iVar9 = 0x20;\n    }\n    for (; -1 < uVar16; uVar16 = uVar16 << 1) {\n        iVar9 = iVar9 + 1;\n    }\n    piVar13 = piVar3[iVar9 * 2 + 1];\n    iVar11 = *piVar13 - uVar8;\n    iVar17 = (iVar11 >> 4) + -1;\n    if (0x3f < iVar17) {\n        iVar17 = 0x3f;\n    }\n    *0x42c39c = arg_8h;\n    if (iVar17 != iVar9) {\n        if (piVar13[1] == piVar13[2]) {\n            if (iVar9 < 0x20) {\n                pcVar2 = piVar5 + iVar9 + 4;\n                uVar16 = ~(0x80000000U >> (iVar9 & 0x1f));\n                piVar5[var_4h + 0x11] = uVar16 & piVar5[var_4h + 0x11];\n                *pcVar2 = *pcVar2 + -1;\n                if (*pcVar2 == '\\0') {\n                    *arg_8h = *arg_8h & uVar16;\n                }\n            }\n            else {\n                pcVar2 = piVar5 + iVar9 + 4;\n                uVar16 = ~(0x80000000U >> (iVar9 - 0x20 & 0x1f));\n                piVar5[var_4h + 0x31] = piVar5[var_4h + 0x31] & uVar16;\n                *pcVar2 = *pcVar2 + -1;\n                if (*pcVar2 == '\\0') {\n                    arg_8h[1] = arg_8h[1] & uVar16;\n                }\n            }\n        }\n        *(piVar13[2] + 4) = piVar13[1];\n        *(piVar13[1] + 8) = piVar13[2];\n        if (iVar11 == 0) goto code_r0x0040abe7;\n        piVar1 = piVar3 + iVar17 * 2;\n        iVar9 = piVar1[1];\n        piVar13[2] = piVar1;\n        piVar13[1] = iVar9;\n        piVar1[1] = piVar13;\n        *(piVar13[1] + 8) = piVar13;\n        if (piVar13[1] == piVar13[2]) {\n            cVar4 = *(iVar17 + 4 + piVar5);\n            *(iVar17 + 4 + piVar5) = cVar4 + '\\x01';\n            uVar7 = iVar17;\n            if (iVar17 < 0x20) {\n                if (cVar4 == '\\0') {\n                    *arg_8h = *arg_8h | 0x80000000U >> (uVar7 & 0x1f);\n                }\n                piVar5[var_4h + 0x11] = piVar5[var_4h + 0x11] | 0x80000000U >> (uVar7 & 0x1f);\n            }\n            else {\n                if (cVar4 == '\\0') {\n                    arg_8h[1] = arg_8h[1] | 0x80000000U >> (uVar7 - 0x20 & 0x1f);\n                }\n                piVar5[var_4h + 0x31] = piVar5[var_4h + 0x31] | 0x80000000U >> (uVar7 - 0x20 & 0x1f);\n            }\n        }\n    }\n    if (iVar11 != 0) {\n        *piVar13 = iVar11;\n        *(iVar11 + -4 + piVar13) = iVar11;\n    }\ncode_r0x0040abe7:\n    piVar13 = piVar13 + iVar11;\n    *piVar13 = uVar8 + 1;\n    *(piVar13 + (uVar8 - 4)) = uVar8 + 1;\n    iVar9 = *piVar3;\n    *piVar3 = iVar9 + 1;\n    if (((iVar9 == 0) && (arg_8h == *0x42c38c)) && (var_4h == *0x42c3a4)) {\n        *0x42c38c = NULL;\n    }\n    *piVar5 = var_4h;\n    return piVar13 + 1;\n}\n",
        "token_count": 2110
    },
    "0040ac45": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040ac45(uint32_t *arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    uint32_t *puVar4;\n    uint32_t *puVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    uint32_t *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    int32_t in_FS_OFFSET;\n    uint lpBuffer;\n    int16_t *var_1ch;\n    uint var_ch;\n    int32_t var_8h;\n    uint32_t *var_4h;\n    \n    puVar4 = arg_8h;\n    pcVar3 = _sym.imp.KERNEL32.dll_InterlockedExchange;\n    puVar8 = arg_8h[2];\n    if ((puVar8 & 3) != 0) {\n        return 0;\n    }\n    var_4h = *(*(in_FS_OFFSET + 0x18) + 8);\n    if ((var_4h <= puVar8) && (puVar8 < *(*(in_FS_OFFSET + 0x18) + 4))) {\n        return 0;\n    }\n    puVar1 = arg_8h + 3;\n    if (*puVar1 == 0xffffffff) {\n        return 1;\n    }\n    uVar10 = 0;\n    arg_8h = NULL;\n    puVar5 = puVar8;\n    do {\n        if ((*puVar5 != 0xffffffff) && (uVar10 <= *puVar5)) {\n            return 0;\n        }\n        if (puVar5[1] != 0) {\n            arg_8h = arg_8h + 1;\n        }\n        uVar10 = uVar10 + 1;\n        puVar5 = puVar5 + 3;\n    } while (uVar10 <= *puVar1);\n    if ((arg_8h != NULL) && ((puVar1 = puVar4[-2],  puVar1 < var_4h || (puVar4 <= puVar1)))) {\n        return 0;\n    }\n    uVar10 = puVar8 & 0xfffff000;\n    iVar12 = 0;\n    if (0 < *0x42ad08) {\n        do {\n            if (*(iVar12 * 4 + 0x42ad10) == uVar10) {\n                if (iVar12 < 1) {\n                    return 1;\n                }\n                iVar7 = (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x42ad50, 1);\n                if (iVar7 != 0) {\n                    return 1;\n                }\n                if (*(iVar12 * 4 + 0x42ad10) == uVar10) goto code_r0x0040ae40;\n                iVar12 = *0x42ad08 + -1;\n                if (iVar12 < 0) goto code_r0x0040ae2e;\n                goto code_r0x0040ae1e;\n            }\n            iVar12 = iVar12 + 1;\n        } while (iVar12 < *0x42ad08);\n    }\n    iVar12 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(puVar8, &lpBuffer, 0x1c);\n    if (iVar12 == 0) {\n        return 0xffffffff;\n    }\n    if (var_8h != 0x1000000) {\n        return 0xffffffff;\n    }\n    if ((var_ch & 0xcc) != 0) {\n        if (((*var_1ch != 0x5a4d) || (piVar6 = *(var_1ch + 0x1e) + var_1ch,  *piVar6 != 0x4550)) ||\n           (*(piVar6 + 6) != 0x10b)) {\n            return 0xffffffff;\n        }\n        uVar9 = *(piVar6 + 5);\n        if (*(piVar6 + 6) == 0) {\n            return 0xffffffff;\n        }\n        uVar2 = *(piVar6 + uVar9 + 0x24);\n        if (((uVar2 <= puVar8 - var_1ch) && (puVar8 - var_1ch < *(piVar6 + uVar9 + 0x20) + uVar2)) &&\n           ((*(piVar6 + uVar9 + 0x3f) & 0x80) != 0)) {\n            return 0;\n        }\n    }\n    iVar7 = (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x42ad50, 1);\n    iVar12 = *0x42ad08;\n    if (iVar7 != 0) {\n        return 1;\n    }\n    iVar7 = *0x42ad08;\n    if (0 < *0x42ad08) {\n        puVar8 = *0x42ad08 * 4 + 0x42ad0c;\n        do {\n            if (*puVar8 == uVar10) break;\n            iVar7 = iVar7 + -1;\n            puVar8 = puVar8 + -1;\n        } while (0 < iVar7);\n    }\n    if (iVar7 == 0) {\n        iVar7 = 0xf;\n        if (*0x42ad08 < 0x10) {\n            iVar7 = *0x42ad08;\n        }\n        iVar11 = 0;\n        if (-1 < iVar7) {\n            do {\n                puVar8 = iVar11 * 4 + 0x42ad10;\n                uVar9 = *puVar8;\n                iVar11 = iVar11 + 1;\n                *puVar8 = uVar10;\n                uVar10 = uVar9;\n            } while (iVar11 <= iVar7);\n        }\n        if (iVar12 < 0x10) {\n            *0x42ad08 = iVar12 + 1;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x42ad50, 0);\n    return 1;\n    while (iVar12 = iVar12 + -1,  -1 < iVar12) {\ncode_r0x0040ae1e:\n        if (*(iVar12 * 4 + 0x42ad10) == uVar10) break;\n    }\n    if (iVar12 < 0) {\ncode_r0x0040ae2e:\n        if (*0x42ad08 < 0x10) {\n            *0x42ad08 = *0x42ad08 + 1;\n        }\n        iVar12 = *0x42ad08 + -1;\n    }\n    else if (iVar12 == 0) goto code_r0x0040ae58;\ncode_r0x0040ae40:\n    iVar7 = 0;\n    if (-1 < iVar12) {\n        do {\n            puVar8 = iVar7 * 4 + 0x42ad10;\n            uVar9 = *puVar8;\n            iVar7 = iVar7 + 1;\n            *puVar8 = uVar10;\n            uVar10 = uVar9;\n        } while (iVar7 <= iVar12);\n    }\ncode_r0x0040ae58:\n    (*pcVar3)(0x42ad50, 0);\n    return 1;\n}\n",
        "token_count": 1646
    },
    "0040af01": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0040af01(void)\n\n{\n    int32_t arg_8h;\n    code *pcVar1;\n    int32_t *piVar2;\n    \n    if (*0x427c20 != -1) {\n        (**0x42ad60)(*0x427c20);\n        *0x427c20 = -1;\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_DeleteCriticalSection;\n    piVar2 = 0x427af0;\n    do {\n        arg_8h = *piVar2;\n        if ((arg_8h != 0) && (piVar2[1] != 1)) {\n            (*pcVar1)(arg_8h);\n            fcn.00407696(arg_8h);\n            *piVar2 = 0;\n        }\n        piVar2 = piVar2 + 2;\n    } while (piVar2 < 0x427c10);\n    piVar2 = 0x427af0;\n    do {\n        if ((*piVar2 != 0) && (piVar2[1] == 1)) {\n            (*pcVar1)(*piVar2);\n        }\n        piVar2 = piVar2 + 2;\n    } while (piVar2 < 0x427c10);\n    return;\n}\n",
        "token_count": 285
    },
    "0040b0d6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.0040b0d6(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint uVar4;\n    \n    iVar2 = fcn.00409f18();\n    if (iVar2 == 0) {\n        fcn.0040af01();\n        return 0;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"kernel32.dll\");\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar2 != 0) {\n        *0x42ad54 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"FlsAlloc\");\n        *0x42ad58 = (*pcVar1)(iVar2, \"FlsGetValue\");\n        *0x42ad5c = (*pcVar1)(iVar2, \"FlsSetValue\");\n        *0x42ad60 = (*pcVar1)(iVar2, \"FlsFree\");\n        if (*0x42ad58 == 0) {\n            *0x42ad58 = _sym.imp.KERNEL32.dll_TlsGetValue;\n            *0x42ad5c = _sym.imp.KERNEL32.dll_TlsSetValue;\n            *0x42ad54 = 0x40aef8;\n            *0x42ad60 = _sym.imp.KERNEL32.dll_TlsFree;\n        }\n    }\n    *0x427c20 = (**0x42ad54)(0x40af8f);\n    if (((*0x427c20 != -1) && (puVar3 = fcn.0040f6af(1, 0x8c),  puVar3 != NULL)) &&\n       (iVar2 = (**0x42ad5c)(*0x427c20, puVar3),  iVar2 != 0)) {\n        puVar3[0x15] = 0x428138;\n        puVar3[5] = 1;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        puVar3[1] = 0xffffffff;\n        *puVar3 = uVar4;\n        return 1;\n    }\n    fcn.0040af01();\n    return 0;\n}\n",
        "token_count": 493
    },
    "0040b335": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0040b335(int32_t param_1)\n\n{\n    int32_t *in_EAX;\n    int32_t unaff_EDI;\n    \n    if (((*(unaff_EDI + 0xc) & 0x40) == 0) || (*(unaff_EDI + 8) != 0)) {\n        do {\n            if (param_1 < 1) {\n                return;\n            }\n            param_1 = param_1 + -1;\n            fcn.0040b2de();\n        } while (*in_EAX != -1);\n    }\n    else {\n        *in_EAX = *in_EAX + param_1;\n    }\n    return;\n}\n",
        "token_count": 152
    },
    "0040b36c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Type propagation algorithm not settling\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040b36c(uint param_1, uint8_t *param_2, int32_t **param_3)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    int32_t **ppiVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    int32_t *piVar8;\n    int32_t extraout_ECX;\n    int32_t iVar9;\n    uint8_t uVar10;\n    char *arg_ch;\n    bool bVar11;\n    int64_t iVar12;\n    int32_t *piStack600;\n    int32_t *piStack596;\n    int32_t iStack588;\n    int32_t iStack584;\n    uint uStack580;\n    int32_t iStack576;\n    int32_t iStack572;\n    int32_t *piStack568;\n    int32_t iStack564;\n    int32_t *piStack560;\n    int32_t iStack556;\n    uchar uStack552;\n    char cStack551;\n    int32_t iStack548;\n    int32_t iStack544;\n    int32_t *piStack540;\n    int32_t *piStack536;\n    uint32_t uStack532;\n    int32_t aiStack528 [127];\n    uint uStack17;\n    uint uStack8;\n    \n    uStack8 = *0x427850;\n    iStack544 = 0;\n    iStack548 = 0;\n    piStack568 = NULL;\n    uVar10 = *param_2;\n    iVar7 = 0;\n    puVar2 = param_2;\n    ppiVar3 = param_3;\n    do {\n        if ((uVar10 == 0) || (param_2 = puVar2 + 1,  iStack548 < 0)) {\n            fcn.0040895e();\n            return;\n        }\n        if ((uVar10 < ' ') || ('x' < uVar10)) {\n            uVar5 = 0;\n        }\n        else {\n            uVar5 = *(uVar10 + 0x420850) & 0xf;\n        }\n        iStack584 = *(iVar7 + 0x420870 + uVar5 * 8) >> 4;\n        param_3 = ppiVar3;\n    // switch table (8 cases) at 0x40bb46\n        switch(iStack584) {\n        case 0:\ncode_r0x0040b588:\n            iStack564 = 0;\n            if ((*(*0x428330 + 1 + uVar10 * 2) & 0x80) != 0) {\n                fcn.0040b2de();\n                param_2 = puVar2 + 2;\n            }\n            fcn.0040b2de();\n            break;\n        case 1:\n            piStack536 = 0xffffffff;\n            uStack580 = 0;\n            iStack572 = 0;\n            piStack560 = NULL;\n            iStack556 = 0;\n            uStack532 = 0;\n            iStack564 = 0;\n            break;\n        case 2:\n            if (uVar10 == 0x20) {\n                uStack532 = uStack532 | 2;\n            }\n            else if (uVar10 == 0x23) {\n                uStack532 = uStack532 | 0x80;\n            }\n            else if (uVar10 == 0x2b) {\n                uStack532 = uStack532 | 1;\n            }\n            else if (uVar10 == 0x2d) {\n                uStack532 = uStack532 | 4;\n            }\n            else if (uVar10 == 0x30) {\n                uStack532 = uStack532 | 8;\n            }\n            break;\n        case 3:\n            if (uVar10 == 0x2a) {\n                piStack560 = *ppiVar3;\n                param_3 = ppiVar3 + 1;\n                if (piStack560 < 0) {\n                    uStack532 = uStack532 | 4;\n                    piStack560 = -piStack560;\n                }\n            }\n            else {\n                piStack560 = uVar10 + -0x30 + piStack560 * 10;\n            }\n            break;\n        case 4:\n            piStack536 = NULL;\n            break;\n        case 5:\n            if (uVar10 == 0x2a) {\n                piStack536 = *ppiVar3;\n                param_3 = ppiVar3 + 1;\n                if (piStack536 < 0) {\n                    piStack536 = 0xffffffff;\n                }\n            }\n            else {\n                piStack536 = uVar10 + -0x30 + piStack536 * 10;\n            }\n            break;\n        case 6:\n            if (uVar10 == 0x49) {\n                uVar1 = *param_2;\n                if ((uVar1 == 0x36) && (puVar2[2] == 0x34)) {\n                    param_2 = puVar2 + 3;\n                    uStack532 = uStack532 | 0x8000;\n                }\n                else if ((uVar1 == 0x33) && (puVar2[2] == 0x32)) {\n                    param_2 = puVar2 + 3;\n                    uStack532 = uStack532 & 0xffff7fff;\n                }\n                else if (((((uVar1 != 100) && (uVar1 != 0x69)) && (uVar1 != 0x6f)) &&\n                         ((uVar1 != 0x75 && (uVar1 != 0x78)))) && (uVar1 != 0x58)) {\n                    iStack584 = 0;\n                    goto code_r0x0040b588;\n                }\n            }\n            else if (uVar10 == 0x68) {\n                uStack532 = uStack532 | 0x20;\n            }\n            else if (uVar10 == 0x6c) {\n                uStack532 = uStack532 | 0x10;\n            }\n            else if (uVar10 == 0x77) {\n                uStack532 = uStack532 | 0x800;\n            }\n            break;\n        case 7:\n            if (uVar10 < 'h') {\n                if (uVar10 < 'e') {\n                    if (uVar10 < 'Y') {\n                        if (uVar10 != 0x58) {\n                            if (uVar10 == 0x43) {\n                                if ((uStack532 & 0x830) == 0) {\n                                    uStack532 = uStack532 | 0x800;\n                                }\n                                goto code_r0x0040b691;\n                            }\n                            if ((uVar10 != 0x45) && (uVar10 != 0x47)) {\n                                if (uVar10 == 0x53) {\n                                    if ((uStack532 & 0x830) == 0) {\n                                        uStack532 = uStack532 | 0x800;\n                                    }\n                                    goto code_r0x0040b614;\n                                }\n                                goto code_r0x0040ba09;\n                            }\n                            uStack580 = 1;\n                            uVar10 = uVar10 + 0x20;\n                            goto code_r0x0040b665;\n                        }\ncode_r0x0040b8af:\n                        iStack576 = 7;\ncode_r0x0040b8b2:\n                        iStack544 = 0x10;\n                        if ((uStack532 & 0x80) != 0) {\n                            cStack551 = iStack576 + 'Q';\n                            uStack552 = 0x30;\n                            iStack556 = 2;\n                        }\n                        goto code_r0x0040b6e2;\n                    }\n                    if (uVar10 == 0x5a) {\n                        param_3 = ppiVar3 + 1;\n                        piVar8 = *ppiVar3;\n                        piVar6 = *0x427c24;\n                        piVar4 = *0x427c24;\n                        if ((piVar8 == NULL) || (piStack540 = piVar8[1],  piVar4 = *0x427c24,  piStack540 == NULL))\n                        goto code_r0x0040b823;\n                        iStack544 = *piVar8;\n                        if ((uStack532 & 0x800) == 0) {\n                            iStack564 = 0;\n                        }\n                        else {\n                            iStack544 = iStack544 / 2;\n                            iStack564 = 1;\n                        }\n                    }\n                    else if (uVar10 == 99) {\ncode_r0x0040b691:\n                        if ((uStack532 & 0x810) == 0) {\n                            aiStack528[0]._0_1_ = *ppiVar3;\n                            iStack544 = 1;\n                        }\n                        else {\n                            iStack544 = fcn.00410377(aiStack528, *ppiVar3);\n                            if (iStack544 < 0) {\n                                iStack572 = 1;\n                            }\n                        }\n                        param_3 = ppiVar3 + 1;\n                        piStack540 = aiStack528;\n                    }\n                    else if (uVar10 == 100) goto code_r0x0040b6d7;\n                }\n                else {\ncode_r0x0040b665:\n                    uStack532 = uStack532 | 0x40;\n                    piVar8 = aiStack528;\n                    piVar6 = aiStack528;\n                    if (piStack536 < 0) {\n                        piStack536 = 0x6;\n                    }\n                    else if (piStack536 == NULL) {\n                        if (uVar10 == 0x67) {\n                            piStack536 = 0x1;\n                        }\n                    }\n                    else {\n                        if (0x200 < piStack536) {\n                            piStack536 = 0x200;\n                        }\n                        if ((0xa3 < piStack536) &&\n                           (piStack540 = aiStack528,  piStack568 = fcn.00407684(piStack536 + 0x15d), \n                           piVar8 = piStack568,  piVar6 = piStack568,  piStack568 == NULL)) {\n                            piStack536 = 0xa3;\n                            piVar8 = aiStack528;\n                            piVar6 = piStack540;\n                        }\n                    }\n                    piStack540 = piVar6;\n                    piStack600 = *ppiVar3;\n                    param_3 = ppiVar3 + 2;\n                    piStack596 = ppiVar3[1];\n                    (**0x428310)(&piStack600, piVar8, uVar10, piStack536, uStack580);\n                    uVar5 = uStack532 & 0x80;\n                    if ((uVar5 != 0) && (piStack536 == NULL)) {\n                        (**0x42831c)(piVar8);\n                    }\n                    if ((uVar10 == 0x67) && (uVar5 == 0)) {\n                        (**0x428314)(piVar8);\n                    }\n                    piVar6 = piVar8;\n                    piVar4 = piStack540;\n                    if (*piVar8 == '-') {\n                        uStack532 = uStack532 | 0x100;\n                        piVar6 = piVar8 + 1;\n                        piVar4 = piVar8 + 1;\n                    }\ncode_r0x0040b823:\n                    piStack540 = piVar4;\n                    iStack544 = fcn.004089d0(piVar6);\n                }\ncode_r0x0040ba09:\n                uVar5 = uStack532;\n                if (iStack572 == 0) {\n                    if ((uStack532 & 0x40) != 0) {\n                        if ((uStack532 & 0x100) == 0) {\n                            if ((uStack532 & 1) == 0) {\n                                if ((uStack532 & 2) == 0) goto code_r0x0040ba41;\n                                uStack552 = 0x20;\n                            }\n                            else {\n                                uStack552 = 0x2b;\n                            }\n                        }\n                        else {\n                            uStack552 = 0x2d;\n                        }\n                        iStack556 = 1;\n                    }\ncode_r0x0040ba41:\n                    arg_ch = piStack560 + (-iStack544 - iStack556);\n                    if ((uStack532 & 0xc) == 0) {\n                        fcn.0040b311(0x20, arg_ch, param_1);\n                    }\n                    fcn.0040b335(iStack556);\n                    if (((uVar5 & 8) != 0) && ((uVar5 & 4) == 0)) {\n                        fcn.0040b311(0x30, arg_ch, param_1);\n                    }\n                    if ((iStack564 == 0) || (iStack544 < 1)) {\n                        fcn.0040b335(iStack544);\n                    }\n                    else {\n                        iStack588 = iStack544;\n                        piVar8 = piStack540;\n                        do {\n                            iStack588 = iStack588 + -1;\n                            iVar7 = fcn.00410377(&uStack17 + 1, *piVar8);\n                            piVar8 = piVar8 + 2;\n                            if (iVar7 < 1) break;\n                            fcn.0040b335(iVar7);\n                        } while (iStack588 != 0);\n                    }\n                    if ((uStack532 & 4) != 0) {\n                        fcn.0040b311(0x20, arg_ch, param_1);\n                    }\n                }\n            }\n            else {\n                if (uVar10 == 0x69) {\ncode_r0x0040b6d7:\n                    uStack532 = uStack532 | 0x40;\ncode_r0x0040b6db:\n                    iStack544 = 10;\ncode_r0x0040b6e2:\n                    if ((uStack532 & 0x8000) == 0) {\n                        param_3 = ppiVar3 + 1;\n                        if ((uStack532 & 0x20) == 0) {\n                            piVar8 = *ppiVar3;\n                            if ((uStack532 & 0x40) == 0) {\n                                piVar6 = NULL;\n                                goto code_r0x0040b953;\n                            }\n                        }\n                        else if ((uStack532 & 0x40) == 0) {\n                            piVar8 = *ppiVar3;\n                        }\n                        else {\n                            piVar8 = *ppiVar3;\n                        }\n                        piVar6 = piVar8 >> 0x1f;\n                    }\n                    else {\n                        piVar8 = *ppiVar3;\n                        piVar6 = ppiVar3[1];\n                        param_3 = ppiVar3 + 2;\n                    }\ncode_r0x0040b953:\n                    if ((((uStack532 & 0x40) != 0) && (piVar6 < 1)) && (piVar6 < 0)) {\n                        bVar11 = piVar8 != NULL;\n                        piVar8 = -piVar8;\n                        piVar6 = -(piVar6 + bVar11);\n                        uStack532 = uStack532 | 0x100;\n                    }\n                    if ((uStack532 & 0x8000) == 0) {\n                        piVar6 = NULL;\n                    }\n                    iVar12 = CONCAT44(piVar6, piVar8);\n                    if (piStack536 < 0) {\n                        piStack536 = 0x1;\n                    }\n                    else {\n                        uStack532 = uStack532 & 0xfffffff7;\n                        if (0x200 < piStack536) {\n                            piStack536 = 0x200;\n                        }\n                    }\n                    if ((piVar8 | piVar6) == 0) {\n                        iStack556 = 0;\n                    }\n                    piVar8 = &uStack17;\n                    while( true ) {\n                        iVar7 = iVar12;\n                        piVar6 = piStack536 + -1;\n                        if ((piStack536 < 1) && (iVar12 == 0)) break;\n                        piStack536 = piVar6;\n                        iVar12 = fcn.004103b0();\n                        iVar9 = extraout_ECX + 0x30;\n                        if (0x39 < iVar9) {\n                            iVar9 = iVar9 + iStack576;\n                        }\n                        *piVar8 = iVar9;\n                        piVar8 = piVar8 + -1;\n                        iStack588 = iVar7;\n                    }\n                    iStack544 = &uStack17 + -piVar8;\n                    piStack540 = piVar8 + 1;\n                    piStack536 = piVar6;\n                    if (((uStack532 & 0x200) != 0) && ((*piStack540 != '0' || (iStack544 == 0)))) {\n                        *piVar8 = '0';\n                        iStack544 = &uStack17 + -piVar8 + 1;\n                        piStack540 = piVar8;\n                    }\n                    goto code_r0x0040ba09;\n                }\n                if (uVar10 != 0x6e) {\n                    if (uVar10 == 0x6f) {\n                        iStack544 = 8;\n                        if ((uStack532 & 0x80) != 0) {\n                            uStack532 = uStack532 | 0x200;\n                        }\n                        goto code_r0x0040b6e2;\n                    }\n                    if (uVar10 == 0x70) {\n                        piStack536 = 0x8;\n                        goto code_r0x0040b8af;\n                    }\n                    if (uVar10 == 0x73) {\ncode_r0x0040b614:\n                        piVar8 = piStack536;\n                        if (piStack536 == 0xffffffff) {\n                            piVar8 = 0x7fffffff;\n                        }\n                        param_3 = ppiVar3 + 1;\n                        piStack540 = *ppiVar3;\n                        if ((uStack532 & 0x810) == 0) {\n                            piVar6 = piStack540;\n                            if (piStack540 == NULL) {\n                                piVar6 = *0x427c24;\n                                piStack540 = *0x427c24;\n                            }\n                            for (; (piVar8 != NULL && (piVar8 = piVar8 + -1,  *piVar6 != '\\0')); piVar6 = piVar6 + 1) {\n                            }\n                            iStack544 = piVar6 - piStack540;\n                        }\n                        else {\n                            if (piStack540 == NULL) {\n                                piStack540 = *0x427c28;\n                            }\n                            iStack564 = 1;\n                            for (piVar6 = piStack540; (piVar8 != NULL && (piVar8 = piVar8 + -1,  *piVar6 != 0));\n                                piVar6 = piVar6 + 2) {\n                            }\n                            iStack544 = piVar6 - piStack540 >> 1;\n                        }\n                        goto code_r0x0040ba09;\n                    }\n                    if (uVar10 != 0x75) {\n                        if (uVar10 != 0x78) goto code_r0x0040ba09;\n                        iStack576 = 0x27;\n                        goto code_r0x0040b8b2;\n                    }\n                    goto code_r0x0040b6db;\n                }\n                param_3 = ppiVar3 + 1;\n                if ((uStack532 & 0x20) == 0) {\n                    **ppiVar3 = iStack548;\n                }\n                else {\n                    **ppiVar3 = iStack548;\n                }\n                iStack572 = 1;\n            }\n            if (piStack568 != NULL) {\n                fcn.00407696(piStack568);\n                piStack568 = NULL;\n            }\n        }\n        uVar10 = *param_2;\n        iVar7 = iStack584;\n        puVar2 = param_2;\n        ppiVar3 = param_3;\n    } while( true );\n}\n",
        "token_count": 4472
    },
    "0040bb66": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.0040bb66(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t in_ECX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint noname_3;\n    uint unaff_retaddr;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint in_stack_00000020;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint in_stack_0000002c;\n    uint in_stack_00000030;\n    uint in_stack_00000034;\n    uint32_t var_4h;\n    \n    uVar2 = arg_ch;\n    uVar1 = arg_8h;\n    if ((*(arg_8h + 0x14) == 0) || ((*(arg_8h + 0x24) != 0 && (arg_ch < 0x80)))) {\n        if ((0x40 < arg_ch) && (arg_ch < 0x5b)) {\n            return arg_ch + 0x20;\n        }\n    }\n    else {\n        noname_3 = 1;\n        var_4h = in_ECX;\n        if (arg_ch < 0x100) {\n            if (*(arg_8h + 0x28) < 2) {\n                uVar3 = *(*(arg_8h + 0x48) + arg_ch * 2) & 1;\n            }\n            else {\n                uVar3 = fcn.0040f638(arg_8h, arg_ch, 1);\n            }\n            if (uVar3 == 0) {\n                return uVar2;\n            }\n        }\n        if ((*(*(uVar1 + 0x48) + 1 + (uVar2 >> 8 & 0xffU) * 2) & 0x80) == 0) {\n            arg_8h = arg_8h & 0xffff0000 | uVar2 & 0xff;\n        }\n        else {\n            arg_8h = arg_8h & 0xff000000 | CONCAT11(uVar2, uVar2 >> 8);\n            noname_3 = 2;\n        }\n        iVar4 = fcn.0040f76a(*(uVar1 + 0x14), 0x100, &arg_8h, noname_3, &var_4h, 3, *(uVar1 + 4), 1, unaff_EDI, \n                             unaff_ESI, unaff_EBX, var_4h, unaff_EBP, unaff_retaddr, arg_8h, arg_ch, in_stack_0000000c, \n                             in_stack_00000010, in_stack_00000014, in_stack_00000018, in_stack_0000001c, \n                             in_stack_00000020, in_stack_00000024, in_stack_00000028, in_stack_0000002c, \n                             in_stack_00000030, in_stack_00000034);\n        if (iVar4 != 0) {\n            if (iVar4 != 1) {\n                return CONCAT11(var_4h, var_4h._1_1_);\n            }\n            return var_4h & 0xff;\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 839
    },
    "0040be5f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040be5f(int32_t arg_8h, char *arg_ch)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    char *arg_8h_00;\n    int32_t iVar3;\n    \n    arg_8h_00 = arg_ch;\n    fcn.00409040(arg_8h, 0, 0x90);\n    if (*arg_ch != '\\0') {\n        if ((*arg_ch != '.') || (arg_ch[1] == '\\0')) {\n            arg_ch = NULL;\n            do {\n                uVar2 = fcn.0040fe30(arg_8h_00, 0x420aa8);\n                if (uVar2 == 0) {\n                    return 0xffffffff;\n                }\n                cVar1 = arg_8h_00[uVar2];\n                if (arg_ch == NULL) {\n                    if (0x3f < uVar2) {\n                        return 0xffffffff;\n                    }\n                    iVar3 = arg_8h;\n                    if (cVar1 == '.') {\n                        return 0xffffffff;\n                    }\n                }\n                else if (arg_ch == 0x1) {\n                    if (0x3f < uVar2) {\n                        return 0xffffffff;\n                    }\n                    if (cVar1 == '_') {\n                        return 0xffffffff;\n                    }\n                    iVar3 = arg_8h + 0x40;\n                }\n                else {\n                    if (arg_ch != 0x2) {\n                        return 0xffffffff;\n                    }\n                    if (0xf < uVar2) {\n                        return 0xffffffff;\n                    }\n                    if ((cVar1 != '\\0') && (cVar1 != ',')) {\n                        return 0xffffffff;\n                    }\n                    iVar3 = arg_8h + 0x80;\n                }\n                fcn.00411100(iVar3, arg_8h_00, uVar2);\n                if ((cVar1 == ',') || (cVar1 == '\\0')) {\n                    return 0;\n                }\n                arg_ch = arg_ch + 1;\n                arg_8h_00 = arg_8h_00 + uVar2 + 1;\n            } while( true );\n        }\n        fcn.00411100(arg_8h + 0x80, arg_ch + 1, 0xf);\n        *(arg_8h + 0x8f) = 0;\n    }\n    return 0;\n}\n",
        "token_count": 538
    },
    "0040bf3b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0040bf3b(uint param_1, int32_t param_2)\n\n{\n    fcn.0040fce0(param_1, param_2);\n    if (*(param_2 + 0x40) != '\\0') {\n        fcn.0040be3b(param_1, 2, 0x420ab0, param_2 + 0x40);\n    }\n    if (*(param_2 + 0x80) != '\\0') {\n        fcn.0040be3b(param_1, 2, 0x420aac, param_2 + 0x80);\n    }\n    return;\n}\n",
        "token_count": 144
    },
    "0040c083": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040c083(char *arg_8h, uchar *arg_ch, ushort *arg_10h, uint *arg_14h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint var_94h;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    if (arg_8h != NULL) {\n        if ((*arg_8h == 'C') && (arg_8h[1] == '\\0')) {\n            *arg_ch = 0x43;\n            arg_ch[1] = 0;\n            if (arg_10h != NULL) {\n                *arg_10h = 0;\n                arg_10h[1] = 0;\n                arg_10h[2] = 0;\n            }\n            if (arg_14h != NULL) {\n                *arg_14h = 0;\n            }\n        }\n        else {\n            uVar1 = fcn.004089d0(arg_8h);\n            if ((0x81 < uVar1) ||\n               ((iVar2 = fcn.0040ae70(0x427d40, arg_8h),  iVar2 != 0 &&\n                (iVar2 = fcn.0040ae70(0x427cb8, arg_8h),  iVar2 != 0)))) {\n                iVar2 = fcn.0040be5f(&var_94h, arg_8h);\n                if ((iVar2 != 0) || (iVar2 = fcn.00411963(&var_94h, 0x42ad64, &var_94h),  iVar2 == 0))\n                goto code_r0x0040c1d4;\n                *0x42ad6c = *0x42ad68;\n                fcn.0040bf3b(0x427d40, &var_94h);\n                if ((*arg_8h == '\\0') || (uVar1 = fcn.004089d0(arg_8h),  0x81 < uVar1)) {\n                    arg_8h = 0x41f636;\n                }\n                *0x427d3a = 0;\n                fcn.00411100(0x427cb8, arg_8h, 0x82);\n            }\n            if (arg_10h != NULL) {\n                fcn.004085f0(arg_10h, 0x42ad64, 6);\n            }\n            if (arg_14h != NULL) {\n                fcn.004085f0(arg_14h, 0x42ad6c, 4);\n            }\n            fcn.0040fce0(arg_ch, 0x427d40);\n        }\n    }\ncode_r0x0040c1d4:\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 635
    },
    "0040c1df": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid fcn.0040c1df(uint param_1)\n\n{\n    uint32_t *puVar1;\n    int32_t arg_8h;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint unaff_EBX;\n    int32_t iVar9;\n    int32_t unaff_ESI;\n    uint unaff_EDI;\n    uint in_stack_fffffe3c;\n    uint in_stack_fffffe40;\n    int32_t in_stack_fffffe44;\n    uint in_stack_fffffe48;\n    uint32_t arg_1ch;\n    uint32_t in_stack_fffffe50;\n    int32_t iStack420;\n    int32_t iStack404;\n    int32_t iStack400;\n    uchar uStack396;\n    uint8_t auStack395 [255];\n    uchar auStack140 [132];\n    uint uStack8;\n    \n    uStack8 = *0x427850;\n    iVar4 = fcn.0040c083(param_1, auStack140, &stack0xfffffe50, &iStack404);\n    if (iVar4 != 0) {\n        iVar9 = unaff_ESI * 0xc;\n        iVar4 = fcn.0040ae70(auStack140, *(iVar9 + 0x427dcc));\n        if (iVar4 != 0) {\n            iVar4 = fcn.004089d0(auStack140);\n            iVar4 = fcn.00407684(iVar4 + 1);\n            if (iVar4 != 0) {\n                arg_8h = *(iVar9 + 0x427dcc);\n                puVar1 = unaff_ESI * 4 + 0x42af70;\n                arg_1ch = *puVar1;\n                iStack400 = unaff_ESI * 6 + 0x42afcc;\n                fcn.004085f0(&stack0xfffffe3c, iStack400, 6);\n                iVar3 = *0x42af88;\n                uVar5 = fcn.0040fce0(iVar4, auStack140);\n                *(iVar9 + 0x427dcc) = uVar5;\n                *puVar1 = in_stack_fffffe50 & 0xffff;\n                fcn.004085f0(iStack400, &stack0xfffffe50, 6);\n                uVar8 = *0x428328;\n                if (unaff_ESI == 2) {\n                    iStack400 = 0;\n                    *0x42af88 = iStack404;\n                    iStack420 = *0x427cb4;\n                    piVar6 = 0x427c90;\n                    iVar7 = *0x427cb0;\n                    do {\n                        if (iStack404 == *piVar6) {\n                            if (iStack400 != 0) {\n                                iVar2 = iStack400 * 8;\n                                *0x427c90 = *(iVar2 + 0x427c90);\n                                *0x427c94 = *(iVar2 + 0x427c94);\n                                *(iVar2 + 0x427c90) = iVar7;\n                                *(iVar2 + 0x427c94) = iStack420;\n                            }\n                            break;\n                        }\n                        in_stack_fffffe44 = *piVar6;\n                        iStack400 = iStack400 + 1;\n                        *piVar6 = iVar7;\n                        iVar2 = piVar6[1];\n                        piVar6[1] = iStack420;\n                        piVar6 = piVar6 + 2;\n                        iVar7 = in_stack_fffffe44;\n                        iStack420 = iVar2;\n                    } while (piVar6 < 0x427cb8);\n                    uVar8 = *0x427c94;\n                    if (iStack400 == 5) {\n                        iVar7 = fcn.0040fb26(1, 0x4209e8, 0x7f, &uStack396, iStack404, *0x42af78, 1, unaff_EDI, \n                                             unaff_EBX, in_stack_fffffe3c, in_stack_fffffe40, in_stack_fffffe44, \n                                             in_stack_fffffe48, arg_1ch, in_stack_fffffe50);\n                        if (iVar7 == 0) {\n                            *0x427c94 = 0;\n                        }\n                        else {\n                            uVar8 = 0;\n                            do {\n                                auStack395[uVar8 * 2] = auStack395[uVar8 * 2] & 1;\n                                uVar8 = uVar8 + 1;\n                            } while (uVar8 < 0x7f);\n                            iVar7 = fcn.004090a0(&uStack396, \n                                                 L\"        h((((                  H\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x10\\x10\\x10\\x10\\x10\\x10\\x10\u0181\u0181\u0181\u0181\u0181\u0181\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\\x10\\x10\\x10\\x10\\x10\\x10\u0182\u0182\u0182\u0182\u0182\u0182\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\\x10\\x10\\x10\\x10 \"\n                                                 , 0xfe);\n                            *0x427c94 = iVar7 == 0;\n                        }\n                        *0x427c90 = *0x42af88;\n                        uVar8 = *0x427c94;\n                    }\n                }\n                *0x428328 = uVar8;\n                if (unaff_ESI == 1) {\n                    *0x42af8c = iStack404;\n                }\n                iVar7 = (**(iVar9 + 0x427dd0))();\n                if (iVar7 == 0) {\n                    if (arg_8h != 0x427c30) {\n                        fcn.00407696(arg_8h);\n                    }\n                }\n                else {\n                    *(iVar9 + 0x427dcc) = arg_8h;\n                    fcn.00407696(iVar4);\n                    *puVar1 = arg_1ch;\n                    *0x42af88 = iVar3;\n                }\n            }\n        }\n    }\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 1477
    },
    "0040c46e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040c46e(char *param_1, int32_t param_2)\n\n{\n    bool bVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t iStack152;\n    int32_t iStack144;\n    uchar auStack140 [132];\n    uint uStack8;\n    \n    uStack8 = *0x427850;\n    if (param_2 != 0) {\n        if (param_1 != NULL) {\n            fcn.0040c1df(param_1);\n        }\n        goto code_r0x0040c5a8;\n    }\n    bVar1 = true;\n    iStack144 = 0;\n    if (param_1 != NULL) {\n        if (((*param_1 == 'L') && (param_1[1] == 'C')) && (param_1[2] == '_')) {\n            do {\n                pcVar2 = fcn.00411b60(param_1, 0x420ac8);\n                if (((pcVar2 == NULL) || (iVar3 = pcVar2 - param_1,  iVar3 == 0)) || (*pcVar2 == ';'))\n                goto code_r0x0040c5a8;\n                iStack152 = 1;\n                puVar5 = 0x427dd4;\n                do {\n                    iVar4 = fcn.00411b20(*puVar5, param_1, iVar3);\n                    if ((iVar4 == 0) && (iVar4 = fcn.004089d0(*puVar5),  iVar3 == iVar4)) break;\n                    iStack152 = iStack152 + 1;\n                    puVar5 = puVar5 + 3;\n                } while (puVar5 < 0x427e05);\n                pcVar2 = pcVar2 + 1;\n                iVar3 = fcn.0040fe30(pcVar2, 0x4206e0);\n                if ((iVar3 == 0) && (*pcVar2 != ';')) goto code_r0x0040c5a8;\n                if (iStack152 < 6) {\n                    fcn.00411100(auStack140, pcVar2, iVar3);\n                    auStack140[iVar3] = 0;\n                    iVar4 = fcn.0040c1df(auStack140);\n                    if (iVar4 != 0) {\n                        iStack144 = iStack144 + 1;\n                    }\n                }\n            } while ((pcVar2[iVar3] != '\\0') && (param_1 = pcVar2 + iVar3 + 1,  *param_1 != '\\0'));\n        }\n        else {\n            iVar3 = fcn.0040c083(param_1, auStack140, 0, 0);\n            if (iVar3 == 0) goto code_r0x0040c5a8;\n            puVar5 = 0x427dcc;\n            do {\n                if (puVar5 != 0x427dcc) {\n                    iVar3 = fcn.0040ae70(auStack140, *puVar5);\n                    if ((iVar3 == 0) || (iVar3 = fcn.0040c1df(auStack140),  iVar3 != 0)) {\n                        iStack144 = iStack144 + 1;\n                    }\n                    else {\n                        bVar1 = false;\n                    }\n                }\n                puVar5 = puVar5 + 3;\n            } while (puVar5 < 0x427e09);\n            if (bVar1) {\n                fcn.0040bfc4();\n                fcn.00407696(*0x427dcc);\n                *0x427dcc = 0;\n                goto code_r0x0040c5a8;\n            }\n        }\n        if (iStack144 == 0) goto code_r0x0040c5a8;\n    }\n    fcn.0040bfc4();\ncode_r0x0040c5a8:\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 902
    },
    "0040c7a1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0040c7a1(uint *arg_8h, uint8_t *arg_ch, uint32_t arg_10h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    uint *puVar7;\n    \n    iVar3 = fcn.0040af1e();\n    iVar3 = *(iVar3 + 0x60);\n    if (iVar3 != *0x42c3c4) {\n        iVar3 = fcn.00409726();\n    }\n    if (*(iVar3 + 8) == 0) {\n        arg_8h = fcn.00411100(arg_8h, arg_ch, arg_10h);\n    }\n    else {\n        puVar6 = arg_8h;\n        if (arg_10h != 0) {\n            do {\n                uVar1 = *arg_ch;\n                uVar4 = arg_10h - 1;\n                uVar2 = *(uVar1 + 0x1d + iVar3);\n                *puVar6 = uVar1;\n                if ((uVar2 & 4) == 0) {\n                    puVar7 = puVar6 + 1;\n                    arg_ch = arg_ch + 1;\n                    if (uVar1 == 0) {\ncode_r0x0040c806:\n                        if (uVar4 == 0) {\n                            return arg_8h;\n                        }\n                        for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n                            *puVar7 = 0;\n                            puVar7 = puVar7 + 1;\n                        }\n                        for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n                            *puVar7 = 0;\n                            puVar7 = puVar7 + 1;\n                        }\n                        return arg_8h;\n                    }\n                }\n                else {\n                    if (uVar4 == 0) {\n                        *puVar6 = 0;\n                        return arg_8h;\n                    }\n                    uVar1 = arg_ch[1];\n                    uVar4 = arg_10h - 2;\n                    *(puVar6 + 1) = uVar1;\n                    puVar7 = puVar6 + 2;\n                    arg_ch = arg_ch + 2;\n                    if (uVar1 == 0) {\n                        *puVar6 = 0;\n                        goto code_r0x0040c806;\n                    }\n                }\n                arg_10h = uVar4;\n                puVar6 = puVar7;\n            } while (uVar4 != 0);\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 634
    },
    "0040c97d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint fcn.0040c97d(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t arg_10h;\n    \n    uVar2 = 0;\n    if (((param_1[3] & 3) == 2) && ((param_1[3] & 0x108U) != 0)) {\n        arg_10h = *param_1 - param_1[2];\n        if (0 < arg_10h) {\n            iVar1 = fcn.004101fe(param_1[4], param_1[2], arg_10h);\n            if (iVar1 == arg_10h) {\n                if (param_1[3] < '\\0') {\n                    param_1[3] = param_1[3] & 0xfffffffd;\n                }\n            }\n            else {\n                param_1[3] = param_1[3] | 0x20;\n                uVar2 = 0xffffffff;\n            }\n        }\n    }\n    param_1[1] = 0;\n    *param_1 = param_1[2];\n    return uVar2;\n}\n",
        "token_count": 260
    },
    "0040cee6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0040cee6(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    uint *puVar4;\n    uint *puVar5;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x420b18, 0x10);\n    puVar4 = NULL;\n    *(unaff_EBP + -0x1c) = 0;\n    fcn.0040a06b(1);\n    *(unaff_EBP + -4) = 0;\n    iVar3 = 0;\n    do {\n        *(unaff_EBP + -0x20) = iVar3;\n        if (*0x42c380 <= iVar3) {\ncode_r0x0040cfd5:\n            if (puVar4 != NULL) {\n                puVar4[1] = 0;\n                puVar4[3] = 0;\n                puVar4[2] = 0;\n                *puVar4 = 0;\n                puVar4[7] = 0;\n                puVar4[4] = 0xffffffff;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0040cfff();\n            fcn.00409027();\n            return;\n        }\n        iVar1 = *(*0x42b360 + iVar3 * 4);\n        if (iVar1 == 0) {\n            iVar3 = iVar3 * 4;\n            uVar2 = fcn.00407684(0x38);\n            *(iVar3 + *0x42b360) = uVar2;\n            if (*(iVar3 + *0x42b360) != 0) {\n                iVar1 = fcn.0040fe86(*(iVar3 + *0x42b360) + 0x20, 4000);\n                if (iVar1 == 0) {\n                    fcn.00407696(*(iVar3 + *0x42b360));\n                    *(iVar3 + *0x42b360) = 0;\n                }\n                else {\n                    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(*(iVar3 + *0x42b360) + 0x20);\n                    puVar5 = *(iVar3 + *0x42b360);\ncode_r0x0040cfd2:\n                    *(unaff_EBP + -0x1c) = puVar5;\n                    puVar4 = puVar5;\n                }\n            }\n            goto code_r0x0040cfd5;\n        }\n        if ((*(iVar1 + 0xc) & 0x83) == 0) {\n            if (((2 < iVar3) && (iVar3 < 0x14)) && (iVar1 = fcn.00409fcb(iVar3 + 0x10),  iVar1 == 0))\n            goto code_r0x0040cfd5;\n            fcn.0040cc28(iVar3, *(*0x42b360 + iVar3 * 4));\n            puVar5 = *(*0x42b360 + iVar3 * 4);\n            if ((*(puVar5 + 3) & 0x83) == 0) goto code_r0x0040cfd2;\n            fcn.0040cc7a(iVar3, puVar5);\n        }\n        iVar3 = iVar3 + 1;\n    } while( true );\n}\n",
        "token_count": 785
    },
    "0040d008": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.0040d008(uint32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint8_t *unaff_ESI;\n    uint8_t *unaff_EDI;\n    \n    iVar1 = *(unaff_ESI + 4);\n    if ((iVar1 != 0) && (*(iVar1 + 8) != '\\0')) {\n        if ((iVar1 != *(unaff_EDI + 4)) && (iVar1 = fcn.0040ae70(iVar1 + 8, *(unaff_EDI + 4) + 8),  iVar1 != 0)) {\n            return 0;\n        }\n        if (((((*unaff_EDI & 2) != 0) && ((*unaff_ESI & 8) == 0)) || (((*param_1 & 1) != 0 && ((*unaff_ESI & 1) == 0))))\n           || (((*param_1 & 2) != 0 && ((*unaff_ESI & 2) == 0)))) {\n            return 0;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 244
    },
    "0040d075": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040d075(uint arg_8h, uint noname_1, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x420b28, 0x10);\n    iVar1 = *(unaff_EBP + 8);\n    iVar5 = *(iVar1 + 8);\n    *(unaff_EBP + -0x1c) = iVar5;\n    iVar2 = fcn.0040af1e();\n    *(iVar2 + 0x84) = *(iVar2 + 0x84) + 1;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = *(unaff_EBP + 0x10);\n    while (iVar5 != *(unaff_EBP + 0x14)) {\n        if ((iVar5 < 0) || (*(iVar2 + 4) <= iVar5)) {\n            fcn.0040d8fa();\n        }\n        iVar3 = iVar5 * 8;\n        piVar4 = *(iVar2 + 8) + iVar3;\n        iVar5 = *piVar4;\n        *(unaff_EBP + -0x20) = iVar5;\n        *(unaff_EBP + -4) = 1;\n        if (piVar4[1] != 0) {\n            *(iVar1 + 8) = iVar5;\n            fcn.0040d930(*(*(iVar2 + 8) + 4 + iVar3), iVar1, 0x103);\n        }\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x1c) = iVar5;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0040d128();\n    if (iVar5 != *(unaff_EBP + 0x14)) {\n        fcn.0040d8fa();\n    }\n    *(iVar1 + 8) = iVar5;\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 533
    },
    "0040d128": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0040d128(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040af1e();\n    if (0 < *(iVar1 + 0x84)) {\n        iVar1 = fcn.0040af1e();\n        *(iVar1 + 0x84) = *(iVar1 + 0x84) + -1;\n    }\n    return;\n}\n",
        "token_count": 91
    },
    "0040d188": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040d188(int32_t *param_1)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    \n    iVar1 = *param_1 + in_EAX;\n    if (-1 < param_1[1]) {\n        iVar1 = iVar1 + *(*(param_1[1] + in_EAX) + param_1[2]) + param_1[1];\n    }\n    return iVar1;\n}\n",
        "token_count": 105
    },
    "0040d30f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid fcn.0040d30f(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_20h;\n    \n    *(unaff_EDI + -4) = *(unaff_EBP + -0x38);\n    fcn.0040818b(*(unaff_EBP + -0x3c));\n    iVar1 = fcn.0040af1e();\n    *(iVar1 + 0x7c) = *(unaff_EBP + -0x40);\n    iVar1 = fcn.0040af1e();\n    *(iVar1 + 0x80) = *(unaff_EBP + -0x44);\n    if ((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&\n        ((unaff_ESI[5] == 0x19930520 || (unaff_ESI[5] == 0x19930521)))) &&\n       ((*(unaff_EBP + -0x48) == 0 && (*(unaff_EBP + -0x20) != 0)))) {\n        iVar1 = fcn.0040816a(unaff_ESI[6]);\n        if (iVar1 != 0) {\n            fcn.00407896();\n            fcn.0040d143(unaff_ESI);\n        }\n    }\n    return;\n}\n",
        "token_count": 361
    },
    "0040d37e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040d37e(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint arg_ch_00;\n    uint uVar5;\n    uint8_t *extraout_ECX;\n    int32_t *extraout_EDX;\n    int32_t unaff_EBP;\n    int32_t *arg_8h_00;\n    uint var_4h;\n    \n    fcn.00408fec(0x420b68, 8);\n    puVar1 = *(unaff_EBP + 0xc);\n    iVar4 = *(unaff_EBP + 8);\n    if (((puVar1[1] == 0) || (*(puVar1[1] + 8) == '\\0')) || ((puVar1[2] == 0 && ((*(puVar1 + 3) & 0x80) == 0))))\n    goto code_r0x0040d4e8;\n    uVar2 = *puVar1;\n    arg_8h_00 = extraout_EDX;\n    if (-1 < uVar2) {\n        arg_8h_00 = puVar1[2] + 0xc + extraout_EDX;\n    }\n    *(unaff_EBP + -4) = 0;\n    uVar5 = *(iVar4 + 0x18);\n    if ((uVar2 & 8) == 0) {\n        if ((*extraout_ECX & 1) == 0) {\n            if (*(extraout_ECX + 0x18) == 0) {\n                iVar4 = fcn.00412633(uVar5, 1);\n                if ((iVar4 == 0) || (iVar4 = fcn.0041264f(arg_8h_00, 1),  iVar4 == 0)) {\ncode_r0x0040d4df:\n                    fcn.0040d8fa();\n                }\n                else {\n                    uVar5 = *(extraout_ECX + 0x14);\n                    arg_ch_00 = fcn.0040d188();\n                    fcn.004072a0(arg_8h_00, arg_ch_00, uVar5);\n                }\n            }\n            else {\n                iVar4 = fcn.00412633(uVar5, 1);\n                if (((iVar4 == 0) || (iVar4 = fcn.0041264f(arg_8h_00, 1),  iVar4 == 0)) ||\n                   (iVar4 = fcn.0041266b(*(extraout_ECX + 0x18)),  iVar4 == 0)) goto code_r0x0040d4df;\n                if ((*extraout_ECX & 4) == 0) {\n                    uVar5 = fcn.0040d188();\n                    fcn.00407e85(arg_8h_00, *(extraout_ECX + 0x18), uVar5);\n                }\n                else {\n                    uVar5 = fcn.0040d188(1);\n                    fcn.00407e85(arg_8h_00, *(extraout_ECX + 0x18), uVar5);\n                }\n            }\n        }\n        else {\n            iVar3 = fcn.00412633(uVar5, 1);\n            if ((iVar3 == 0) || (iVar3 = fcn.0041264f(arg_8h_00, 1),  iVar3 == 0)) goto code_r0x0040d4df;\n            fcn.004072a0(arg_8h_00, *(iVar4 + 0x18), *(extraout_ECX + 0x14));\n            if ((*(extraout_ECX + 0x14) == 4) && (*arg_8h_00 != 0)) goto code_r0x0040d3f7;\n        }\n    }\n    else {\n        iVar3 = fcn.00412633(uVar5, 1);\n        if ((iVar3 == 0) || (iVar3 = fcn.0041264f(arg_8h_00, 1),  iVar3 == 0)) goto code_r0x0040d4df;\n        *arg_8h_00 = *(iVar4 + 0x18);\ncode_r0x0040d3f7:\n        iVar4 = fcn.0040d188();\n        *arg_8h_00 = iVar4;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\ncode_r0x0040d4e8:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 1052
    },
    "0040d4fa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040d4fa(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, int32_t arg_1ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint unaff_EBX;\n    int32_t unaff_ESI;\n    uint *unaff_EDI;\n    \n    if (in_ECX != 0) {\n        fcn.0040d37e(arg_8h, unaff_EBX);\n    }\n    if (arg_1ch == 0) {\n        arg_1ch = unaff_ESI;\n    }\n    fcn.00407e8c(arg_1ch, arg_8h);\n    fcn.0040d075(unaff_ESI, arg_10h, arg_14h, *unaff_EDI);\n    *(unaff_ESI + 8) = unaff_EDI[1] + 1;\n    iVar1 = fcn.0040d1ba(arg_8h, unaff_ESI, arg_ch, arg_14h, arg_18h, 0x100);\n    if (iVar1 != 0) {\n        fcn.00407e55(iVar1);\n    }\n    return;\n}\n",
        "token_count": 284
    },
    "0040d561": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl\nfcn.0040d561(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, int32_t arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_retaddr;\n    uint in_stack_00000024;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    if ((*arg_8h != -0x7ffffffd) &&\n       (((iVar1 = fcn.0040af1e(),  *(iVar1 + 0x74) == 0 ||\n         (iVar1 = fcn.00407f4f(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_20h, arg_24h, unaff_ESI, var_8h, var_4h, \n                               unaff_EBP, unaff_retaddr, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, arg_20h, \n                               arg_24h, in_stack_00000024),  iVar1 == 0)) &&\n        (piVar2 = fcn.004080c8(arg_18h, arg_20h, arg_1ch, &var_4h, &var_8h),  var_4h < var_8h)))) {\n        do {\n            if (((*piVar2 <= arg_1ch) && (arg_1ch <= piVar2[1])) &&\n               ((iVar1 = *(piVar2[3] * 0x10 + piVar2[4] + -0xc),  iVar1 == 0 || (*(iVar1 + 8) == '\\0')))) {\n                fcn.0040d4fa(arg_8h, arg_10h, arg_14h, arg_18h, arg_20h, arg_24h);\n            }\n            var_4h = var_4h + 1;\n            piVar2 = piVar2 + 5;\n        } while (var_4h < var_8h);\n    }\n    return;\n}\n",
        "token_count": 552
    },
    "0040d61f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.0040d61f(int32_t *arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h, int32_t arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint var_24h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t *var_10h;\n    uint32_t var_ch;\n    int32_t *var_8h;\n    uchar auStack8 [3];\n    uint var_1h;\n    \n    var_1ch = *(arg_ch + 8);\n    _auStack8 = auStack8;\n    if ((var_1ch < -1) || (*(arg_18h + 4) <= var_1ch)) {\n        fcn.0040d8fa();\n    }\n    if (*arg_8h == -0x1f928c9d) {\n        if ((arg_8h[4] == 3) && (((arg_8h[5] == 0x19930520 || (arg_8h[5] == 0x19930521)) && (arg_8h[7] == 0)))) {\n            iVar2 = fcn.0040af1e();\n            if (*(iVar2 + 0x7c) == 0) {\n                return;\n            }\n            iVar2 = fcn.0040af1e();\n            arg_8h = *(iVar2 + 0x7c);\n            iVar2 = fcn.0040af1e();\n            arg_10h = *(iVar2 + 0x80);\n            _auStack8 = CONCAT13(1, auStack8);\n            iVar2 = fcn.00412633(arg_8h, 1);\n            if (iVar2 == 0) {\n                fcn.0040d8fa();\n            }\n            if (*arg_8h != -0x1f928c9d) goto code_r0x0040d7f8;\n            if (((arg_8h[4] == 3) && ((arg_8h[5] == 0x19930520 || (arg_8h[5] == 0x19930521)))) && (arg_8h[7] == 0)) {\n                fcn.0040d8fa();\n            }\n        }\n        iVar2 = var_1ch;\n        if (((*arg_8h == -0x1f928c9d) && (arg_8h[4] == 3)) && ((arg_8h[5] == 0x19930520 || (arg_8h[5] == 0x19930521))))\n        {\n            piVar3 = fcn.004080c8(arg_18h, arg_20h, var_1ch, &var_ch, &var_20h);\n            var_8h = piVar3;\n            if (var_ch < var_20h) {\n                do {\n                    if ((*piVar3 == iVar2 || *piVar3 < iVar2) && (iVar2 <= piVar3[1])) {\n                        var_8h = piVar3;\n                        for (var_18h = piVar3[3]; 0 < var_18h; var_18h = var_18h + -1) {\n                            var_10h = *(arg_8h[7] + 0xc);\n                            for (var_14h = *var_10h; var_10h = var_10h + 1,  0 < var_14h; var_14h = var_14h + -1) {\n                                iVar2 = fcn.0040d008(arg_8h[7]);\n                                piVar3 = var_8h;\n                                if (iVar2 != 0) {\n                                    fcn.0040d4fa(arg_8h, arg_10h, arg_14h, arg_18h, arg_20h, arg_24h);\n                                    goto code_r0x0040d7cb;\n                                }\n                            }\n                        }\n                    }\ncode_r0x0040d7cb:\n                    var_ch = var_ch + 1;\n                    piVar3 = piVar3 + 5;\n                    iVar2 = var_1ch;\n                    var_8h = piVar3;\n                } while (var_ch < var_20h);\n            }\n            if (arg_1ch == '\\0') {\n                return;\n            }\n            fcn.0040d143(arg_8h);\n            return;\n        }\n    }\ncode_r0x0040d7f8:\n    if (arg_1ch == '\\0') {\n        fcn.0040d561(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, var_1ch, arg_20h, arg_24h);\n        return;\n    }\n    fcn.00408fec(0x420b78, 8);\n    iVar2 = fcn.0040af1e();\n    if (*(iVar2 + 0x6c) != 0) {\n        _auStack8 = 0;\n        iVar2 = fcn.0040af1e();\n        (**(iVar2 + 0x6c))();\n        _auStack8 = 0xffffffff;\n    }\n    fcn.0040da58(10);\n    fcn.0041372e(0x16);\n    fcn.00409c2b(3);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 1304
    },
    "0040d823": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.0040d823(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint32_t *arg_18h, int32_t arg_1ch, uint arg_20h\n            , uint32_t arg_24h)\n\n{\n    uint uVar1;\n    \n    if ((*arg_18h & 0x1fffffff) != 0x19930520) {\n        fcn.0040d8fa();\n    }\n    if ((*(arg_8h + 1) & 0x66) == 0) {\n        if (arg_18h[3] != 0) {\n            if (((*arg_8h == -0x1f928c9d) && (0x19930520 < arg_8h[5])) && (*(arg_8h[7] + 8) != NULL)) {\n                uVar1 = (**(arg_8h[7] + 8))(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, arg_20h, arg_24h & 0xff)\n                ;\n                return uVar1;\n            }\n            fcn.0040d61f(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_24h, arg_1ch, arg_20h);\n        }\n    }\n    else if ((arg_18h[1] != 0) && (arg_1ch == 0)) {\n        fcn.0040d075(arg_ch, arg_14h, arg_18h, 0xffffffff);\n    }\n    return 1;\n}\n",
        "token_count": 381
    },
    "0040da58": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0040da58(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uStack296;\n    uchar *puStack292;\n    uint uStack288;\n    uchar auStack272 [260];\n    uchar uStack12;\n    uint uStack8;\n    \n    uStack8 = *0x427850;\n    uVar1 = 0;\n    do {\n        if (param_1 == *(uVar1 * 8 + 0x4280a0)) break;\n        uVar1 = uVar1 + 1;\n    } while (uVar1 < 0x13);\n    if (param_1 == *(uVar1 * 8 + 0x4280a0)) {\n        if ((*0x42ab50 == 1) || ((*0x42ab50 == 0 && (*0x427848 == 1)))) {\n            uStack288 = 0;\n            puStack292 = &stack0x00000004;\n            uStack296 = *(uVar1 * 8 + 0x4280a4);\n            uStack296 = fcn.004089d0();\n            (*_sym.imp.KERNEL32.dll_GetStdHandle)();\n            (*_sym.imp.KERNEL32.dll_WriteFile)();\n        }\n        else if (param_1 != 0xfc) {\n            uStack288 = 0x104;\n            puStack292 = &stack0xfffffef0;\n            uStack296 = 0;\n            uStack12 = 0;\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)();\n            if (iVar2 == 0) {\n                fcn.0040fce0();\n            }\n            iVar2 = fcn.004089d0();\n            if (0x3c < iVar2 + 1U) {\n                fcn.004089d0();\n                fcn.00411100();\n            }\n            fcn.004089d0();\n            fcn.004089d0();\n            fcn.004079f0();\n            fcn.0040fce0();\n            fcn.0040fcf0();\n            fcn.0040fcf0();\n            fcn.0040fcf0();\n            fcn.0041269b(&stack0xfffffed8, \"Microsoft Visual C++ Runtime Library\", 0x12010);\n        }\n    }\n    uStack288 = 0x40dbc4;\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 543
    },
    "0040dc08": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040dc08(int32_t arg_8h, uint ExceptionInfo)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t *piVar7;\n    int32_t iVar8;\n    uint var_4h;\n    \n    iVar4 = fcn.0040af1e();\n    piVar1 = *(iVar4 + 0x54);\n    piVar7 = piVar1;\n    do {\n        if (*piVar7 == arg_8h) break;\n        piVar7 = piVar7 + 3;\n    } while (piVar7 < piVar1 + *0x4281bc * 3);\n    if ((piVar1 + *0x4281bc * 3 <= piVar7) || (*piVar7 != arg_8h)) {\n        piVar7 = NULL;\n    }\n    if ((piVar7 == NULL) || (pcVar2 = piVar7[2],  pcVar2 == NULL)) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_UnhandledExceptionFilter)(ExceptionInfo);\n    }\n    else if (pcVar2 == 0x5) {\n        piVar7[2] = 0;\n        uVar5 = 1;\n    }\n    else {\n        if (pcVar2 != 0x1) {\n            uVar5 = *(iVar4 + 0x58);\n            *(iVar4 + 0x58) = ExceptionInfo;\n            if (piVar7[1] == 8) {\n                if (*0x4281b0 < *0x4281b4 + *0x4281b0) {\n                    iVar6 = *0x4281b0 * 0xc;\n                    iVar8 = *0x4281b0;\n                    do {\n                        *(iVar6 + 8 + *(iVar4 + 0x54)) = 0;\n                        iVar8 = iVar8 + 1;\n                        iVar6 = iVar6 + 0xc;\n                    } while (iVar8 < *0x4281b4 + *0x4281b0);\n                }\n                iVar8 = *piVar7;\n                uVar3 = *(iVar4 + 0x5c);\n                if (iVar8 == -0x3fffff72) {\n                    *(iVar4 + 0x5c) = 0x83;\n                }\n                else if (iVar8 == -0x3fffff70) {\n                    *(iVar4 + 0x5c) = 0x81;\n                }\n                else if (iVar8 == -0x3fffff6f) {\n                    *(iVar4 + 0x5c) = 0x84;\n                }\n                else if (iVar8 == -0x3fffff6d) {\n                    *(iVar4 + 0x5c) = 0x85;\n                }\n                else if (iVar8 == -0x3fffff73) {\n                    *(iVar4 + 0x5c) = 0x82;\n                }\n                else if (iVar8 == -0x3fffff71) {\n                    *(iVar4 + 0x5c) = 0x86;\n                }\n                else if (iVar8 == -0x3fffff6e) {\n                    *(iVar4 + 0x5c) = 0x8a;\n                }\n                (*pcVar2)(8, *(iVar4 + 0x5c));\n                *(iVar4 + 0x5c) = uVar3;\n            }\n            else {\n                piVar7[2] = 0;\n                (*pcVar2)(piVar7[1]);\n            }\n            *(iVar4 + 0x58) = uVar5;\n        }\n        uVar5 = 0xffffffff;\n    }\n    return uVar5;\n}\n",
        "token_count": 860
    },
    "0040de90": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040de90(uint8_t **arg_8h, int32_t *arg_ch)\n\n{\n    bool bVar1;\n    bool bVar2;\n    uint8_t *in_EAX;\n    uint8_t *puVar3;\n    uint8_t *puVar4;\n    uint8_t uVar5;\n    uint8_t *in_ECX;\n    uint32_t uVar6;\n    int32_t *unaff_ESI;\n    uint var_4h;\n    \n    bVar1 = false;\n    *unaff_ESI = 0;\n    *arg_ch = 1;\n    if (arg_8h != NULL) {\n        *arg_8h = in_ECX;\n        arg_8h = arg_8h + 1;\n    }\n    do {\n        if (*in_EAX == 0x22) {\n            bVar1 = !bVar1;\n            puVar3 = in_EAX + 1;\n            uVar5 = 0x22;\n        }\n        else {\n            *unaff_ESI = *unaff_ESI + 1;\n            if (in_ECX != NULL) {\n                *in_ECX = *in_EAX;\n                in_ECX = in_ECX + 1;\n            }\n            uVar5 = *in_EAX;\n            puVar3 = in_EAX + 1;\n            if ((*(uVar5 + 0x42c3e1) & 4) != 0) {\n                *unaff_ESI = *unaff_ESI + 1;\n                if (in_ECX != NULL) {\n                    *in_ECX = *puVar3;\n                    in_ECX = in_ECX + 1;\n                }\n                puVar3 = in_EAX + 2;\n            }\n            if (uVar5 == 0) {\n                puVar3 = puVar3 + -1;\n                goto code_r0x0040df09;\n            }\n        }\n        in_EAX = puVar3;\n    } while ((bVar1) || ((uVar5 != 0x20 && (uVar5 != 9))));\n    if (in_ECX != NULL) {\n        in_ECX[-1] = 0;\n    }\ncode_r0x0040df09:\n    bVar1 = false;\n    while (*puVar3 != 0) {\n        for (; (*puVar3 == 0x20 || (*puVar3 == 9)); puVar3 = puVar3 + 1) {\n        }\n        if (*puVar3 == 0) break;\n        if (arg_8h != NULL) {\n            *arg_8h = in_ECX;\n            arg_8h = arg_8h + 1;\n        }\n        *arg_ch = *arg_ch + 1;\n        while( true ) {\n            bVar2 = true;\n            uVar6 = 0;\n            for (; *puVar3 == 0x5c; puVar3 = puVar3 + 1) {\n                uVar6 = uVar6 + 1;\n            }\n            if (*puVar3 == 0x22) {\n                puVar4 = puVar3;\n                if ((uVar6 & 1) == 0) {\n                    if ((!bVar1) || (puVar4 = puVar3 + 1,  *puVar4 != 0x22)) {\n                        bVar2 = false;\n                        puVar4 = puVar3;\n                    }\n                    bVar1 = !bVar1;\n                }\n                uVar6 = uVar6 >> 1;\n                puVar3 = puVar4;\n            }\n            for (; uVar6 != 0; uVar6 = uVar6 - 1) {\n                if (in_ECX != NULL) {\n                    *in_ECX = 0x5c;\n                    in_ECX = in_ECX + 1;\n                }\n                *unaff_ESI = *unaff_ESI + 1;\n            }\n            uVar5 = *puVar3;\n            if ((uVar5 == 0) || ((!bVar1 && ((uVar5 == 0x20 || (uVar5 == 9)))))) break;\n            if (bVar2) {\n                if (in_ECX == NULL) {\n                    if ((*(uVar5 + 0x42c3e1) & 4) != 0) {\n                        puVar3 = puVar3 + 1;\n                        *unaff_ESI = *unaff_ESI + 1;\n                    }\n                }\n                else {\n                    if ((*(uVar5 + 0x42c3e1) & 4) != 0) {\n                        *in_ECX = uVar5;\n                        in_ECX = in_ECX + 1;\n                        puVar3 = puVar3 + 1;\n                        *unaff_ESI = *unaff_ESI + 1;\n                    }\n                    *in_ECX = *puVar3;\n                    in_ECX = in_ECX + 1;\n                }\n                *unaff_ESI = *unaff_ESI + 1;\n            }\n            puVar3 = puVar3 + 1;\n        }\n        if (in_ECX != NULL) {\n            *in_ECX = 0;\n            in_ECX = in_ECX + 1;\n        }\n        *unaff_ESI = *unaff_ESI + 1;\n    }\n    if (arg_8h != NULL) {\n        *arg_8h = NULL;\n    }\n    *arg_ch = *arg_ch + 1;\n    return;\n}\n",
        "token_count": 1220
    },
    "0040e1c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.0040e1c0(void)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    uint *puVar3;\n    uint uVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int32_t *piVar9;\n    uchar auStack68 [46];\n    int16_t iStack22;\n    int32_t *piStack20;\n    \n    puVar3 = fcn.00407684(0x480);\n    if (puVar3 == NULL) {\n        uVar4 = 0xffffffff;\n    }\n    else {\n        *0x42b254 = 0x20;\n        *0x42b260 = puVar3;\n        for (; puVar3 < *0x42b260 + 0x120; puVar3 = puVar3 + 9) {\n            *puVar3 = 0xffffffff;\n            puVar3[2] = 0;\n            *(puVar3 + 1) = 0;\n            *(puVar3 + 5) = 10;\n        }\n        (*_sym.imp.KERNEL32.dll_GetStartupInfoA)(auStack68);\n        if ((iStack22 != 0) && (piStack20 != NULL)) {\n            iVar8 = *piStack20;\n            piStack20 = piStack20 + 1;\n            piVar9 = iVar8 + piStack20;\n            if (0x7ff < iVar8) {\n                iVar8 = 0x800;\n            }\n            iVar6 = iVar8;\n            if (*0x42b254 < iVar8) {\n                puVar3 = 0x42b264;\n                do {\n                    puVar5 = fcn.00407684(0x480);\n                    iVar6 = *0x42b254;\n                    if (puVar5 == NULL) break;\n                    *0x42b254 = *0x42b254 + 0x20;\n                    *puVar3 = puVar5;\n                    puVar2 = puVar5;\n                    for (; puVar5 < puVar2 + 0x120; puVar5 = puVar5 + 9) {\n                        *puVar5 = 0xffffffff;\n                        puVar5[2] = 0;\n                        *(puVar5 + 1) = 0;\n                        *(puVar5 + 5) = 10;\n                        puVar2 = *puVar3;\n                    }\n                    puVar3 = puVar3 + 1;\n                    iVar6 = iVar8;\n                } while (*0x42b254 < iVar8);\n            }\n            uVar7 = 0;\n            if (0 < iVar6) {\n                do {\n                    if (((*piVar9 != -1) && ((*piStack20 & 1) != 0)) &&\n                       (((*piStack20 & 8) != 0 || (iVar8 = (*_sym.imp.KERNEL32.dll_GetFileType)(*piVar9),  iVar8 != 0)))\n                       ) {\n                        piVar1 = *((uVar7 >> 5) * 4 + 0x42b260) + (uVar7 & 0x1f) * 0x24;\n                        *piVar1 = *piVar9;\n                        *(piVar1 + 1) = *piStack20;\n                        iVar8 = fcn.0040fe86(piVar1 + 3, 4000);\n                        if (iVar8 == 0) {\n                            return 0xffffffff;\n                        }\n                        piVar1[2] = piVar1[2] + 1;\n                    }\n                    piVar9 = piVar9 + 1;\n                    uVar7 = uVar7 + 1;\n                    piStack20 = piStack20 + 1;\n                } while (uVar7 < iVar6);\n            }\n        }\n        iVar8 = 0;\n        do {\n            piVar9 = *0x42b260 + iVar8 * 9;\n            if (*piVar9 == -1) {\n                *(piVar9 + 1) = 0x81;\n                if (iVar8 == 0) {\n                    iVar6 = -10;\n                }\n                else {\n                    iVar6 = -0xb - (iVar8 != 1);\n                }\n                iVar6 = (*_sym.imp.KERNEL32.dll_GetStdHandle)(iVar6);\n                if ((iVar6 == -1) || (uVar7 = (*_sym.imp.KERNEL32.dll_GetFileType)(iVar6),  uVar7 == 0)) {\n                    *(piVar9 + 1) = *(piVar9 + 1) | 0x40;\n                }\n                else {\n                    *piVar9 = iVar6;\n                    if ((uVar7 & 0xff) == 2) {\n                        *(piVar9 + 1) = *(piVar9 + 1) | 0x40;\n                    }\n                    else if ((uVar7 & 0xff) == 3) {\n                        *(piVar9 + 1) = *(piVar9 + 1) | 8;\n                    }\n                    iVar6 = fcn.0040fe86(piVar9 + 3, 4000);\n                    if (iVar6 == 0) {\n                        return 0xffffffff;\n                    }\n                    piVar9[2] = piVar9[2] + 1;\n                }\n            }\n            else {\n                *(piVar9 + 1) = *(piVar9 + 1) | 0x80;\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 3);\n        (*_sym.imp.KERNEL32.dll_SetHandleCount)(*0x42b254);\n        uVar4 = 0;\n    }\n    return uVar4;\n}\n",
        "token_count": 1263
    },
    "0040e62d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0040e62d(int64_t *arg_8h)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    int64_t iVar7;\n    int64_t iVar8;\n    int64_t iVar9;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    bVar1 = false;\n    iVar5 = *(arg_8h + 4);\n    iVar4 = *arg_8h;\n    iVar8 = *arg_8h;\n    iVar2 = fcn.0040af1e();\n    if (((iVar5 < 0) || (0x1000 < iVar5)) || ((0xfff < iVar5 && (iVar4 != 0)))) {\n        return NULL;\n    }\n    if (*(iVar2 + 0x44) == 0) {\n        iVar3 = fcn.00407684(0x24);\n        *(iVar2 + 0x44) = iVar3;\n        if (iVar3 != 0) goto code_r0x0040e693;\n        piVar6 = 0x42ae90;\n    }\n    else {\ncode_r0x0040e693:\n        piVar6 = *(iVar2 + 0x44);\n    }\n    iVar4 = fcn.004092f0(iVar4, iVar5, 0x1e13380, 0);\n    var_4h = iVar4 + 0x46;\n    iVar5 = iVar4 + 0x45;\n    iVar7 = fcn.004092b0(iVar4, iVar4 >> 0x1f, 0xfffffe93, 0xffffffff);\n    iVar7 = fcn.004092b0(iVar7 - (((iVar4 + 0x171) / 400 - iVar5 / 100) + -0x11 + iVar5 / 4), 0x15180, 0);\n    iVar7 = iVar7 + iVar8;\n    iVar2 = iVar7;\n    if ((iVar7 < 0x100000000) && (iVar7 < 0)) {\n        iVar7 = iVar7 + 0x1e13380;\n        var_4h = iVar5;\n        if (((iVar5 % 4 != 0) || (iVar5 % 100 == 0)) && ((iVar4 + 0x7b1) % 400 != 0)) goto code_r0x0040e78f;\n        iVar7 = CONCAT44((iVar7 >> 0x20) + (0xfffeae7f < iVar7), iVar2 + 0x1e28500);\n    }\n    else if (((var_4h % 4 != 0) || (var_4h % 100 == 0)) && ((iVar4 + 0x7b2) % 400 != 0)) goto code_r0x0040e78f;\n    bVar1 = true;\ncode_r0x0040e78f:\n    piVar6[5] = var_4h;\n    iVar5 = fcn.004092f0(iVar7, 0x15180, 0);\n    piVar6[7] = iVar5;\n    iVar8 = fcn.004092b0(iVar5, iVar5 >> 0x1f, 0xfffeae80, 0xffffffff);\n    iVar5 = 0x4282a0;\n    if (!bVar1) {\n        iVar5 = 0x4282d4;\n    }\n    iVar2 = 1;\n    iVar4 = *(iVar5 + 4);\n    while (iVar4 < piVar6[7]) {\n        iVar2 = iVar2 + 1;\n        iVar4 = *(iVar5 + iVar2 * 4);\n    }\n    piVar6[4] = iVar2 + -1;\n    piVar6[3] = piVar6[7] - *(iVar5 + (iVar2 + -1) * 4);\n    iVar5 = fcn.004092f0(*arg_8h, *(arg_8h + 4), 0x15180, 0);\n    piVar6[6] = (iVar5 + 4) % 7;\n    iVar5 = fcn.004092f0(iVar8 + iVar7, 0xe10, 0);\n    piVar6[2] = iVar5;\n    iVar9 = fcn.004092b0(iVar5, iVar5 >> 0x1f, 0xfffff1f0, 0xffffffff);\n    iVar9 = iVar8 + iVar7 + iVar9;\n    iVar5 = fcn.004092f0(iVar9, 0x3c, 0);\n    piVar6[1] = iVar5;\n    *piVar6 = iVar9 + iVar5 * -0x3c;\n    piVar6[8] = 0;\n    return piVar6;\n}\n",
        "token_count": 1129
    },
    "0040e852": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_28h\n\nvoid fcn.0040e852(void)\n\n{\n    char cVar1;\n    code *pcVar2;\n    uint uVar3;\n    char *arg_8h;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    char *pcVar5;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00408fec(0x4211b0, 0x18);\n    *(unaff_EBP + -0x20) = 0;\n    fcn.0040a06b(7);\n    *(unaff_EBP + -4) = 0;\n    uVar3 = *0x42af88;\n    *(unaff_EBP + -0x28) = *0x42af88;\n    *0x42af64 = 0;\n    *0x428294 = 0xffffffff;\n    *0x428288 = 0xffffffff;\n    arg_8h = fcn.004127d8(0x4211ac);\n    *(unaff_EBP + -0x24) = arg_8h;\n    if ((arg_8h == NULL) || (*arg_8h == '\\0')) {\n        if (*0x42af68 != 0) {\n            fcn.00407696(*0x42af68);\n            *0x42af68 = 0;\n        }\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetTimeZoneInformation)(0x42aeb8);\n        pcVar2 = _sym.imp.KERNEL32.dll_WideCharToMultiByte;\n        if (iVar4 != -1) {\n            *0x42af64 = 1;\n            *0x4281f0 = *0x42aeb8 * 0x3c;\n            if (*0x42aefe != 0) {\n                *0x4281f0 = *0x4281f0 + *0x42af0c * 0x3c;\n            }\n            if ((*0x42af52 == 0) || (*0x42af60 == 0)) {\n                *0x4281f4 = 0;\n                *0x4281f8 = 0;\n            }\n            else {\n                *0x4281f4 = 1;\n                *0x4281f8 = (*0x42af60 - *0x42af0c) * 0x3c;\n            }\n            iVar4 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                              (uVar3, 0, 0x42aebc, 0xffffffff, *0x428280, 0x3f, 0, unaff_EBP + -0x1c);\n            if ((iVar4 == 0) || (*(unaff_EBP + -0x1c) != 0)) {\n                **0x428280 = 0;\n            }\n            else {\n                (*0x428280)[0x3f] = 0;\n            }\n            iVar4 = (*pcVar2)(uVar3, 0, 0x42af10, 0xffffffff, *0x428284, 0x3f, 0, unaff_EBP + -0x1c);\n            if ((iVar4 == 0) || (*(unaff_EBP + -0x1c) != 0)) {\n                **0x428284 = 0;\n            }\n            else {\n                (*0x428284)[0x3f] = 0;\n            }\n        }\n    }\n    else {\n        if (*0x42af68 != 0) {\n            iVar4 = fcn.0040ae70(arg_8h, *0x42af68);\n            if (iVar4 == 0) goto code_r0x0040ea56;\n            if (*0x42af68 != 0) {\n                fcn.00407696(*0x42af68);\n            }\n        }\n        iVar4 = fcn.004089d0(arg_8h);\n        *0x42af68 = fcn.00407684(iVar4 + 1);\n        if (*0x42af68 != 0) {\n            fcn.0040fce0(*0x42af68, arg_8h);\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0040ea6d();\n            fcn.00411100(*0x428280, arg_8h, 3);\n            (*0x428280)[3] = 0;\n            pcVar5 = arg_8h + 3;\n            if (*pcVar5 == '-') {\n                *(unaff_EBP + -0x20) = 1;\n                pcVar5 = arg_8h + 4;\n            }\n            *0x4281f0 = fcn.004094ba(pcVar5);\n            *0x4281f0 = *0x4281f0 * 0xe10;\n            for (; (cVar1 = *pcVar5,  cVar1 == '+' || (('/' < cVar1 && (cVar1 < ':')))); pcVar5 = pcVar5 + 1) {\n            }\n            if (*pcVar5 == ':') {\n                pcVar5 = pcVar5 + 1;\n                iVar4 = fcn.004094ba(pcVar5);\n                *0x4281f0 = *0x4281f0 + iVar4 * 0x3c;\n                for (; ('/' < *pcVar5 && (*pcVar5 < ':')); pcVar5 = pcVar5 + 1) {\n                }\n                if (*pcVar5 == ':') {\n                    pcVar5 = pcVar5 + 1;\n                    iVar4 = fcn.004094ba(pcVar5);\n                    *0x4281f0 = *0x4281f0 + iVar4;\n                    for (; ('/' < *pcVar5 && (*pcVar5 < ':')); pcVar5 = pcVar5 + 1) {\n                    }\n                }\n            }\n            if (*(unaff_EBP + -0x20) != 0) {\n                *0x4281f0 = -*0x4281f0;\n            }\n            *0x4281f4 = *pcVar5;\n            if (*0x4281f4 == 0) {\n                **0x428284 = 0;\n            }\n            else {\n                fcn.00411100(*0x428284, pcVar5, 3);\n                (*0x428284)[3] = 0;\n            }\n            goto code_r0x0040eaf4;\n        }\n    }\ncode_r0x0040ea56:\n    fcn.0040782e(unaff_EBP + -0x10, 0xffffffff);\ncode_r0x0040eaf4:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 1632
    },
    "0040eafa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.0040eafa(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch, \n            int32_t arg_20h, int32_t arg_24h, int32_t arg_28h)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = arg_10h % 4;\n    if (arg_ch == 1) {\n        if (((iVar2 == 0) && (arg_10h % 100 != 0)) || ((arg_10h + 0x76c) % 400 == 0)) {\n            iVar4 = *(in_EAX * 4 + 0x42829c);\n        }\n        else {\n            iVar4 = *(in_EAX * 4 + 0x4282d0);\n        }\n        iVar5 = iVar4 + 1;\n        iVar3 = (arg_10h * 0x16d + -0x63db + (arg_10h + -1) / 4 + iVar5 + ((arg_10h + 299) / 400 - (arg_10h + -1) / 100)\n                ) % 7;\n        iVar1 = (arg_14h * 7 - iVar3) + arg_18h;\n        if (iVar3 <= arg_18h) {\n            iVar5 = iVar4 + -6;\n        }\n        iVar5 = iVar5 + iVar1;\n        if (arg_14h == 5) {\n            if (((iVar2 == 0) && (arg_10h % 100 != 0)) || ((arg_10h + 0x76c) % 400 == 0)) {\n                iVar1 = *(in_EAX * 4 + 0x4282a0);\n            }\n            else {\n                iVar1 = *(in_EAX * 4 + 0x4282d4);\n            }\n            if (iVar1 < iVar5) {\n                iVar5 = iVar5 + -7;\n            }\n        }\n    }\n    else {\n        if (((iVar2 == 0) && (iVar1 = arg_10h / 100,  arg_10h % 100 != 0)) ||\n           (iVar1 = (arg_10h + 0x76c) / 400,  (arg_10h + 0x76c) % 400 == 0)) {\n            iVar5 = *(in_EAX * 4 + 0x42829c);\n        }\n        else {\n            iVar5 = *(in_EAX * 4 + 0x4282d0);\n        }\n        iVar5 = iVar5 + arg_1ch;\n    }\n    iVar2 = (in_ECX * 0x3c + arg_20h) * 0x3c;\n    if (arg_8h == 1) {\n        *0x428290 = (iVar2 + arg_24h) * 1000 + arg_28h;\n        *0x428288 = arg_10h;\n        *0x42828c = iVar5;\n    }\n    else {\n        *0x42829c = (iVar2 + *0x4281f8 + arg_24h) * 1000 + arg_28h;\n        if (*0x42829c < 0) {\n            *0x42829c = *0x42829c + 86400000;\n            *0x428298 = iVar5 + -1;\n        }\n        else {\n            iVar1 = 86400000;\n            *0x428298 = iVar5;\n            if (86399999 < *0x42829c) {\n                *0x42829c = *0x42829c + -86400000;\n                *0x428298 = iVar5 + 1;\n            }\n        }\n        *0x428294 = arg_10h;\n    }\n    return iVar1;\n}\n",
        "token_count": 937
    },
    "0040ef82": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040ef82(uint32_t lpRootPathName)\n\n{\n    int32_t iVar1;\n    \n    if (lpRootPathName != 0) {\n        lpRootPathName = CONCAT12(0x5c, CONCAT11(0x3a, lpRootPathName + '@'));\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetDriveTypeA)(&lpRootPathName);\n        if ((iVar1 == 0) || (iVar1 == 1)) {\n            return 0;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 125
    },
    "0040f25f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040f25f(int32_t arg_8h, int32_t *arg_ch, uint arg_10h)\n\n{\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (arg_8h != 0) {\n        fcn.00412c2b(&var_8h, arg_10h);\n        *arg_ch = var_8h;\n        arg_ch[1] = var_4h;\n        return;\n    }\n    fcn.00412c68(&arg_8h, arg_10h);\n    *arg_ch = arg_8h;\n    return;\n}\n",
        "token_count": 145
    },
    "0040f2ba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040f2ba(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t *in_EAX;\n    uchar *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uchar *unaff_EBX;\n    \n    if (arg_10h != '\\0') {\n        fcn.0040f29d();\n    }\n    if (*in_EAX == 0x2d) {\n        *unaff_EBX = 0x2d;\n        unaff_EBX = unaff_EBX + 1;\n    }\n    puVar1 = unaff_EBX;\n    if (0 < arg_8h) {\n        puVar1 = unaff_EBX + 1;\n        *unaff_EBX = *puVar1;\n        *puVar1 = *0x428444;\n    }\n    puVar1 = fcn.0040fce0(puVar1 + arg_8h + (arg_10h == '\\0'), \"e+000\");\n    if (arg_ch != 0) {\n        *puVar1 = 0x45;\n    }\n    if (*in_EAX[3] != '0') {\n        iVar2 = in_EAX[1] + -1;\n        if (iVar2 < 0) {\n            iVar2 = -iVar2;\n            puVar1[1] = 0x2d;\n        }\n        if (99 < iVar2) {\n            iVar3 = iVar2 / 100;\n            iVar2 = iVar2 % 100;\n            puVar1[2] = puVar1[2] + iVar3;\n        }\n        if (9 < iVar2) {\n            iVar3 = iVar2 / 10;\n            iVar2 = iVar2 % 10;\n            puVar1[3] = puVar1[3] + iVar3;\n        }\n        puVar1[4] = puVar1[4] + iVar2;\n    }\n    return;\n}\n",
        "token_count": 442
    },
    "0040f3d4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuchar * __cdecl fcn.0040f3d4(uchar *arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_EAX;\n    uchar *puVar3;\n    \n    iVar1 = in_EAX[1];\n    if ((arg_10h != '\\0') && (iVar1 + -1 == arg_ch)) {\n        iVar2 = *in_EAX;\n        arg_8h[(iVar2 == 0x2d) + iVar1 + -1] = 0x30;\n        (arg_8h + (iVar2 == 0x2d) + iVar1 + -1)[1] = 0;\n    }\n    puVar3 = arg_8h;\n    if (*in_EAX == 0x2d) {\n        *arg_8h = 0x2d;\n        puVar3 = arg_8h + 1;\n    }\n    if (in_EAX[1] < 1) {\n        fcn.0040f29d();\n        *puVar3 = 0x30;\n        puVar3 = puVar3 + 1;\n    }\n    else {\n        puVar3 = puVar3 + in_EAX[1];\n    }\n    if (0 < arg_ch) {\n        fcn.0040f29d();\n        *puVar3 = *0x428444;\n        iVar1 = in_EAX[1];\n        if (iVar1 < 0) {\n            if ((arg_10h != '\\0') || (SBORROW4(arg_ch, -iVar1) == arg_ch + iVar1 < 0)) {\n                arg_ch = -iVar1;\n            }\n            fcn.0040f29d();\n            fcn.00409040(puVar3 + 1, 0x30, arg_ch);\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 430
    },
    "0040f6af": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040f6af(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t arg_8h_00;\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x421240, 0x10);\n    uVar2 = *(unaff_EBP + 8) * *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x20) = uVar2;\n    if (uVar2 == 0) {\n        uVar2 = 1;\n    }\n    do {\n        iVar3 = 0;\n        *(unaff_EBP + -0x1c) = 0;\n        if (uVar2 < 0xffffffe1) {\n            if (*0x42c3ac == 3) {\n                uVar2 = uVar2 + 0xf & 0xfffffff0;\n                *(unaff_EBP + 0xc) = uVar2;\n                arg_8h_00 = *(unaff_EBP + -0x20);\n                if (*0x42c398 < arg_8h_00) goto code_r0x0040f724;\n                fcn.0040a06b(4);\n                *(unaff_EBP + -4) = 0;\n                uVar1 = fcn.0040a92e(arg_8h_00);\n                *(unaff_EBP + -0x1c) = uVar1;\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.0040f759();\n                iVar3 = *(unaff_EBP + -0x1c);\n                if (iVar3 != 0) {\n                    fcn.00409040(iVar3, 0, *(unaff_EBP + -0x20));\n                    goto code_r0x0040f724;\n                }\n            }\n            else {\ncode_r0x0040f724:\n                if (iVar3 != 0) {\ncode_r0x0040f764:\n                    fcn.00409027();\n                    return;\n                }\n            }\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x42c3a8, 8, uVar2);\n        }\n        if (((iVar3 != 0) || (*0x42ad04 == 0)) || (iVar3 = fcn.0040ac2a(uVar2),  iVar3 == 0)) goto code_r0x0040f764;\n    } while( true );\n}\n",
        "token_count": 612
    },
    "0040f76a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_38h_2\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: lpSrcStr\n// WARNING: Variable defined which should be unmapped: var_44h\n// WARNING: Variable defined which should be unmapped: var_40h_2\n// WARNING: Variable defined which should be unmapped: var_3ch_2\n// WARNING: Variable defined which should be unmapped: var_54h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h_2\n// WARNING: Variable defined which should be unmapped: var_20h\n\nvoid __cdecl\nfcn.0040f76a(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint CodePage, uint arg_24h, uint arg_8h, \n            uint arg_ch, uint arg_10h, uint cchSrc, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *lpMultiByteStr_00;\n    int32_t unaff_EBP;\n    uchar *arg_8h_00;\n    uint var_2ch;\n    uint var_48h;\n    uint var_24h_2;\n    uint var_40h;\n    uint lpWideCharStr;\n    uint lpDestStr;\n    uint cchDest;\n    uint var_20h_2;\n    uint var_24h_3;\n    uint var_28h;\n    uint var_24h;\n    uint Locale;\n    uint dwMapFlags;\n    uint lpMultiByteStr;\n    uint cbMultiByte;\n    uint var_18h_2;\n    uint var_4h;\n    uint uVar5;\n    uint uVar6;\n    uint var_38h_2;\n    uint var_34h;\n    uint var_30h_2;\n    uint var_20h;\n    uint lpSrcStr;\n    uint var_44h;\n    uint var_40h_2;\n    uint var_3ch_2;\n    uint var_38h;\n    uint var_54h;\n    uint var_30h;\n    \n    fcn.00408fec();\n    if (*0x42af90 == 0) {\n        lpSrcStr = 0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringW)();\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x42af90 = 2;\n            }\n        }\n        else {\n            *0x42af90 = 1;\n        }\n    }\n    if (0 < *(unaff_EBP + 0x14)) {\n        iVar1 = *(unaff_EBP + 0x14);\n        pcVar2 = *(unaff_EBP + 0x10);\n        do {\n            iVar1 = iVar1 + -1;\n            if (*pcVar2 == '\\0') goto code_r0x0040f7d0;\n            pcVar2 = pcVar2 + 1;\n        } while (iVar1 != 0);\n        iVar1 = -1;\ncode_r0x0040f7d0:\n        *(unaff_EBP + 0x14) = *(unaff_EBP + 0x14) + (-1 - iVar1);\n    }\n    if ((*0x42af90 != 2) && (*0x42af90 != 0)) {\n        if (*0x42af90 != 1) goto code_r0x0040fb1d;\n        *(unaff_EBP + -0x2c) = 0;\n        *(unaff_EBP + -0x38) = 0;\n        *(unaff_EBP + -0x34) = 0;\n        if (*(unaff_EBP + 0x20) == 0) {\n            *(unaff_EBP + 0x20) = *0x42af88;\n        }\n        lpSrcStr = *(unaff_EBP + 0x20);\n        iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        *(unaff_EBP + -0x30) = iVar1;\n        if (iVar1 == 0) goto code_r0x0040fb1d;\n        *(unaff_EBP + -4) = 1;\n        fcn.004079f0();\n        *(unaff_EBP + -0x18) = &fcn.0040f76a::lpSrcStr;\n        *(unaff_EBP + -0x1c) = &fcn.0040f76a::lpSrcStr;\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*(unaff_EBP + -0x1c) == 0) {\n            iVar3 = fcn.00407684();\n            *(unaff_EBP + -0x1c) = iVar3;\n            if (iVar3 == 0) goto code_r0x0040fb1d;\n            *(unaff_EBP + -0x38) = 1;\n        }\n        var_30h_2 = 1;\n        var_34h = *(unaff_EBP + 0x20);\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        if (iVar3 != 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, 0, 0);\n            *(unaff_EBP + -0x2c) = iVar3;\n            if (iVar3 != 0) {\n                if ((*(unaff_EBP + 0xd) & 4) == 0) {\n                    *(unaff_EBP + -4) = 2;\n                    fcn.004079f0();\n                    *(unaff_EBP + -0x18) = &fcn.0040f76a::var_34h;\n                    *(unaff_EBP + -0x20) = &fcn.0040f76a::var_34h;\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    if (*(unaff_EBP + -0x20) == 0) {\n                        iVar4 = fcn.00407684(iVar3 * 2);\n                        *(unaff_EBP + -0x20) = iVar4;\n                        if (iVar4 == 0) goto code_r0x0040f99f;\n                        *(unaff_EBP + -0x34) = 1;\n                    }\n                    iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                                      (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, \n                                       *(unaff_EBP + -0x20), iVar3);\n                    if (iVar1 != 0) {\n                        if (*(unaff_EBP + 0x1c) == 0) {\n                            uVar6 = 0;\n                            uVar5 = 0;\n                        }\n                        else {\n                            uVar6 = *(unaff_EBP + 0x1c);\n                            uVar5 = *(unaff_EBP + 0x18);\n                        }\n                        (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                  (*(unaff_EBP + 0x20), 0, *(unaff_EBP + -0x20), iVar3, uVar5, uVar6, 0, 0);\n                    }\n                }\n                else if ((*(unaff_EBP + 0x1c) != 0) && (iVar3 <= *(unaff_EBP + 0x1c))) {\n                    (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, *(unaff_EBP + 0x18), \n                               *(unaff_EBP + 0x1c));\n                }\n            }\n        }\ncode_r0x0040f99f:\n        if (*(unaff_EBP + -0x34) != 0) {\n            fcn.00407696(*(unaff_EBP + -0x20));\n        }\n        if (*(unaff_EBP + -0x38) != 0) {\n            fcn.00407696(*(unaff_EBP + -0x1c));\n        }\n        goto code_r0x0040fb1d;\n    }\n    *(unaff_EBP + -0x28) = 0;\n    *(unaff_EBP + -0x3c) = 0;\n    if (*(unaff_EBP + 8) == 0) {\n        *(unaff_EBP + 8) = *0x42af78;\n    }\n    if (*(unaff_EBP + 0x20) == 0) {\n        *(unaff_EBP + 0x20) = *0x42af88;\n    }\n    iVar1 = fcn.00412fb3(*(unaff_EBP + 8));\n    *(unaff_EBP + -0x40) = iVar1;\n    if (iVar1 == -1) goto code_r0x0040fb1d;\n    if (iVar1 == *(unaff_EBP + 0x20)) {\n        lpSrcStr = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n    }\n    else {\n        lpSrcStr = *(unaff_EBP + 0x20);\n        iVar1 = fcn.00412ff6(lpSrcStr, iVar1, *(unaff_EBP + 0x10), unaff_EBP + 0x14, 0, 0, 0x421250, 0x38);\n        *(unaff_EBP + -0x28) = iVar1;\n        if (iVar1 == 0) goto code_r0x0040fb1d;\n        uVar6 = *(unaff_EBP + 0xc);\n        lpSrcStr = *(unaff_EBP + 8);\n        lpMultiByteStr_00 = &fcn.0040f76a::lpSrcStr;\n        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n        *(unaff_EBP + -0x24) = iVar1;\n        arg_8h_00 = NULL;\n        if (iVar1 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.004079f0();\n            *(unaff_EBP + -0x18) = &fcn.0040f76a::lpSrcStr;\n            *(unaff_EBP + -0x44) = &fcn.0040f76a::lpSrcStr;\n            fcn.00409040();\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x20) {\n                lpMultiByteStr_00 = fcn.00407684();\n                arg_8h_00 = lpMultiByteStr_00;\n                if (lpMultiByteStr_00 == NULL) goto code_r0x0040fae5;\n                fcn.00409040();\n                *(unaff_EBP + -0x3c) = 1;\n            }\n            var_30h_2 = *(unaff_EBP + 0xc);\n            var_34h = *(unaff_EBP + 8);\n            iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n            *(unaff_EBP + -0x24) = iVar1;\n            arg_8h_00 = lpMultiByteStr_00;\n            if (iVar1 != 0) {\n                var_30h_2 = *(unaff_EBP + 0x20);\n                var_34h = *(unaff_EBP + -0x40);\n                fcn.00412ff6(var_34h, var_30h_2, lpMultiByteStr_00, unaff_EBP + -0x24, *(unaff_EBP + 0x18), \n                             *(unaff_EBP + 0x1c), lpSrcStr, uVar6);\n            }\n        }\ncode_r0x0040fae5:\n        if (*(unaff_EBP + -0x3c) != 0) {\n            fcn.00407696(arg_8h_00);\n        }\n    }\n    if (*(unaff_EBP + -0x28) != 0) {\n        fcn.00407696(*(unaff_EBP + -0x28));\n    }\ncode_r0x0040fb1d:\n    *(unaff_EBP + -0x58) = 0x40fb25;\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 3033
    },
    "0040fb26": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_28h_2\n// WARNING: Variable defined which should be unmapped: var_24h_2\n// WARNING: Variable defined which should be unmapped: var_20h_2\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: lpCharType\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n\nvoid __cdecl\nfcn.0040fb26(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint arg_20h_2, \n            uint noname_7, uint arg_8h, uint lpMultiByteStr, uint cbMultiByte, uint arg_14h, uint CodePage, uint arg_1ch\n            , uint arg_20h)\n\n{\n    int32_t iVar1;\n    uint *arg_8h_00;\n    uint uVar2;\n    int32_t noname_1_00;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    int32_t noname_0_00;\n    uint dwInfoType;\n    uint var_ch;\n    uint var_10h;\n    uint var_14h;\n    uint var_18h_2;\n    uint var_4h;\n    uint var_2ch;\n    uint var_28h_2;\n    uint var_24h_2;\n    uint var_20h_2;\n    int32_t lpCharType;\n    int32_t var_38h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    \n    fcn.00408fec();\n    iVar3 = 0;\n    if (*0x42af94 == 0) {\n        var_38h = 0x40fb50;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)();\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x42af94 = 2;\n            }\n        }\n        else {\n            *0x42af94 = 1;\n        }\n    }\n    if ((*0x42af94 == 2) || (*0x42af94 == 0)) {\n        iVar1 = *(unaff_EBP + 0x1c);\n        if (*(unaff_EBP + 0x1c) == 0) {\n            iVar1 = *0x42af78;\n        }\n        noname_0_00 = *(unaff_EBP + 0x18);\n        if (*(unaff_EBP + 0x18) == 0) {\n            noname_0_00 = *0x42af88;\n        }\n        noname_1_00 = fcn.00412fb3(iVar1);\n        if (noname_1_00 != -1) {\n            if (noname_1_00 != noname_0_00) {\n                lpCharType = noname_0_00;\n                var_38h = noname_1_00;\n                iVar3 = fcn.00412ff6(noname_0_00, noname_1_00, *(unaff_EBP + 0xc), unaff_EBP + 0x10, 0, 0, 0x421278, \n                                     0x1c);\n                if (iVar3 == 0) goto code_r0x0040fcd7;\n                *(unaff_EBP + 0xc) = iVar3;\n            }\n            lpCharType = 0x40fcc8;\n            var_38h = iVar1;\n            (*_sym.imp.KERNEL32.dll_GetStringTypeA)();\n            if (iVar3 != 0) {\n                lpCharType = iVar3;\n                fcn.00407696(iVar3);\n            }\n        }\n    }\n    else if (*0x42af94 == 1) {\n        *(unaff_EBP + -0x24) = 0;\n        *(unaff_EBP + -0x20) = 0;\n        if (*(unaff_EBP + 0x18) == 0) {\n            *(unaff_EBP + 0x18) = *0x42af88;\n        }\n        var_38h = (*(unaff_EBP + 0x20) != 0) * 8 + 1;\n        lpCharType = *(unaff_EBP + 0x18);\n        arg_8h_00 = &fcn.0040fb26::lpCharType;\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        *(unaff_EBP + -0x28) = iVar3;\n        if (iVar3 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.004079f0();\n            *(unaff_EBP + -0x18) = &fcn.0040fb26::lpCharType;\n            *(unaff_EBP + -0x2c) = &fcn.0040fb26::lpCharType;\n            fcn.00409040(&fcn.0040fb26::lpCharType, 0, iVar3 * 2);\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x20) {\n                arg_8h_00 = fcn.0040f6af(2, iVar3);\n                if (arg_8h_00 == NULL) goto code_r0x0040fcd7;\n                *(unaff_EBP + -0x20) = 1;\n            }\n            iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                              (*(unaff_EBP + 0x18), 1, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), arg_8h_00, iVar3);\n            if (iVar3 != 0) {\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)(*(unaff_EBP + 8), arg_8h_00, iVar3, *(unaff_EBP + 0x14))\n                ;\n                *(unaff_EBP + -0x24) = uVar2;\n            }\n            if (*(unaff_EBP + -0x20) != 0) {\n                fcn.00407696(arg_8h_00);\n            }\n        }\n    }\ncode_r0x0040fcd7:\n    *(unaff_EBP + -0x3c) = 0x40fcdf;\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 1556
    },
    "0040fe86": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040fe86(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_4h;\n    \n    fcn.00408fec(0x4212b0, 0x10);\n    if (*0x42af98 == NULL) {\n        if (*0x42ab68 != 1) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"kernel32.dll\");\n            if (iVar2 != 0) {\n                *0x42af98 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"InitializeCriticalSectionAndSpinCount\");\n                if (*0x42af98 != NULL) goto code_r0x0040fed2;\n            }\n        }\n        *0x42af98 = 0x40fe76;\n    }\ncode_r0x0040fed2:\n    pcVar1 = *0x42af98;\n    *(unaff_EBP + -4) = 0;\n    uVar3 = (*pcVar1)(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n    *(unaff_EBP + -0x20) = uVar3;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 337
    },
    "004109fa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.004109fa(void)\n\n{\n    char *pcVar1;\n    char cVar2;\n    int32_t *arg_8h;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    char *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint *arg_14h;\n    uint *puVar8;\n    uint32_t uVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((*0x42af80 == 0) && (*0x42af7c == 0)) {\n        if (((*0x42b24c != NULL) && (**0x42b24c == 0)) && (*0x42b24c != *(*0x427c8c + 0x2c))) {\n            fcn.00407696(*0x42b24c);\n            fcn.00407696(*0x42afa4);\n        }\n        *0x42b250 = NULL;\n        *0x42b24c = NULL;\n        arg_14h = 0x428404;\n        *0x42afa4 = NULL;\n        puVar8 = *0x42afa4;\n        arg_8h = *0x42b24c;\ncode_r0x00410ba7:\n        *0x42b24c = arg_8h;\n        *0x42afa4 = puVar8;\n        *0x428444 = **arg_14h;\n        *0x428448 = 1;\n        uVar6 = 0;\n        *0x428434 = arg_14h;\n    }\n    else {\n        arg_14h = fcn.0040f6af(1, 0x30);\n        if (arg_14h != NULL) {\n            puVar8 = *0x428434;\n            puVar11 = arg_14h;\n            for (iVar7 = 0xc; iVar7 != 0; iVar7 = iVar7 + -1) {\n                *puVar11 = *puVar8;\n                puVar8 = puVar8 + 1;\n                puVar11 = puVar11 + 1;\n            }\n            arg_8h = fcn.00407684(4);\n            if (arg_8h != NULL) {\n                *arg_8h = 0;\n                if (*0x42af80 == 0) {\n                    *0x42b250 = NULL;\n                    *arg_14h = *0x428404;\n                    arg_14h[1] = *0x428408;\n                    arg_14h[2] = *0x42840c;\n                }\n                else {\n                    *0x42b250 = fcn.00407684(4);\n                    if (*0x42b250 == NULL) {\n                        uVar6 = 1;\ncode_r0x00410b05:\n                        fcn.00407696(arg_14h);\n                        fcn.00407696(arg_8h);\n                        return uVar6;\n                    }\n                    **0x42b250 = 0;\n                    uVar9 = *0x42afe6;\n                    uVar3 = fcn.004133b1(1, uVar9, 0xe, arg_14h);\n                    uVar4 = fcn.004133b1(1, uVar9, 0xf, arg_14h + 1);\n                    uVar9 = fcn.004133b1(1, uVar9, 0x10, arg_14h + 2);\n                    if ((uVar9 | uVar3 | uVar4) != 0) {\n                        fcn.0041099b(arg_14h);\n                        uVar6 = 0xffffffff;\n                        goto code_r0x00410b05;\n                    }\n                    pcVar5 = arg_14h[2];\n                    while (*pcVar5 != '\\0') {\n                        cVar2 = *pcVar5;\n                        if ((cVar2 < '0') || ('9' < cVar2)) {\n                            pcVar10 = pcVar5;\n                            if (cVar2 != ';') goto code_r0x00410b31;\n                            do {\n                                pcVar1 = pcVar10 + 1;\n                                *pcVar10 = *pcVar1;\n                                pcVar10 = pcVar1;\n                            } while (*pcVar1 != '\\0');\n                        }\n                        else {\n                            *pcVar5 = cVar2 + -0x30;\ncode_r0x00410b31:\n                            pcVar5 = pcVar5 + 1;\n                        }\n                    }\n                }\n                puVar8 = arg_14h;\n                if (((*0x42b24c != NULL) && (**0x42b24c == 0)) && (*0x42b24c != *(*0x427c8c + 0x2c))) {\n                    fcn.00407696(*0x42b24c);\n                    fcn.00407696(*0x42afa4);\n                }\n                goto code_r0x00410ba7;\n            }\n            fcn.00407696(arg_14h);\n        }\n        uVar6 = 1;\n    }\n    return uVar6;\n}\n",
        "token_count": 1159
    },
    "00410ca0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.00410ca0(void)\n\n{\n    char *pcVar1;\n    char cVar2;\n    uint *arg_8h;\n    uint *arg_8h_00;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    uint32_t uVar12;\n    uint32_t uVar13;\n    uint32_t uVar14;\n    uint32_t uVar15;\n    uint32_t uVar16;\n    char *pcVar17;\n    uint uVar18;\n    int32_t iVar19;\n    uint32_t uVar20;\n    char *pcVar21;\n    uint *puVar22;\n    uint *puVar23;\n    uint var_4h;\n    \n    if ((*0x42af7c == 0) && (*0x42af80 == 0)) {\n        *0x42b248 = NULL;\n        *0x42b24c = NULL;\n        *0x428434 = 0x428404;\n        *0x42afa4 = NULL;\ncode_r0x00410ed8:\n        uVar18 = 0;\n    }\n    else {\n        arg_8h = fcn.0040f6af(1, 0x30);\n        if (arg_8h != NULL) {\n            arg_8h_00 = fcn.00407684(4);\n            if (arg_8h_00 == NULL) {\n                fcn.00407696(arg_8h);\n            }\n            else {\n                *arg_8h_00 = 0;\n                if (*0x42af7c == 0) {\n                    puVar22 = 0x428404;\n                    puVar23 = arg_8h;\n                    for (iVar19 = 0xc; iVar19 != 0; iVar19 = iVar19 + -1) {\n                        *puVar23 = *puVar22;\n                        puVar22 = puVar22 + 1;\n                        puVar23 = puVar23 + 1;\n                    }\n                    *0x42b248 = NULL;\ncode_r0x00410ea5:\n                    *arg_8h = **0x428434;\n                    arg_8h[1] = (*0x428434)[1];\n                    arg_8h[2] = (*0x428434)[2];\n                    *0x428434 = arg_8h;\n                    *0x42afa4 = arg_8h;\n                    *0x42b24c = arg_8h_00;\n                    goto code_r0x00410ed8;\n                }\n                *0x42b248 = fcn.00407684(4);\n                if (*0x42b248 == NULL) {\n                    fcn.00407696(arg_8h);\n                    fcn.00407696(arg_8h_00);\n                }\n                else {\n                    **0x42b248 = 0;\n                    uVar20 = *0x42afe0;\n                    uVar3 = fcn.004133b1(1, uVar20, 0x15, arg_8h + 3);\n                    uVar4 = fcn.004133b1(1, uVar20, 0x14, arg_8h + 4);\n                    uVar5 = fcn.004133b1(1, uVar20, 0x16, arg_8h + 5);\n                    uVar6 = fcn.004133b1(1, uVar20, 0x17, arg_8h + 6);\n                    uVar7 = fcn.004133b1(1, uVar20, 0x18, arg_8h + 7);\n                    uVar8 = fcn.004133b1(1, uVar20, 0x50, arg_8h + 8);\n                    uVar9 = fcn.004133b1(1, uVar20, 0x51, arg_8h + 9);\n                    uVar10 = fcn.004133b1(0, uVar20, 0x1a, arg_8h + 10);\n                    uVar11 = fcn.004133b1(0, uVar20, 0x19, arg_8h + 0x29);\n                    uVar12 = fcn.004133b1(0, uVar20, 0x54, arg_8h + 0x2a);\n                    uVar13 = fcn.004133b1(0, uVar20, 0x55, arg_8h + 0x2b);\n                    uVar14 = fcn.004133b1(0, uVar20, 0x56, arg_8h + 0xb);\n                    uVar15 = fcn.004133b1(0, uVar20, 0x57, arg_8h + 0x2d);\n                    uVar16 = fcn.004133b1(0, uVar20, 0x52, arg_8h + 0x2e);\n                    uVar20 = fcn.004133b1(0, uVar20, 0x53, arg_8h + 0x2f);\n                    if ((uVar20 | uVar3 | uVar4 | uVar5 | uVar6 | uVar7 | uVar8 | uVar9 | uVar10 | uVar11 | uVar12 |\n                                  uVar13 | uVar14 | uVar15 | uVar16) == 0) {\n                        pcVar17 = arg_8h[7];\n                        while (*pcVar17 != '\\0') {\n                            cVar2 = *pcVar17;\n                            if ((cVar2 < '0') || ('9' < cVar2)) {\n                                pcVar21 = pcVar17;\n                                if (cVar2 != ';') goto code_r0x00410e73;\n                                do {\n                                    pcVar1 = pcVar21 + 1;\n                                    *pcVar21 = *pcVar1;\n                                    pcVar21 = pcVar1;\n                                } while (*pcVar1 != '\\0');\n                            }\n                            else {\n                                *pcVar17 = cVar2 + -0x30;\ncode_r0x00410e73:\n                                pcVar17 = pcVar17 + 1;\n                            }\n                        }\n                        goto code_r0x00410ea5;\n                    }\n                    fcn.00410bc7(arg_8h);\n                    fcn.00407696(arg_8h);\n                    fcn.00407696(arg_8h_00);\n                }\n            }\n        }\n        uVar18 = 1;\n    }\n    return uVar18;\n}\n",
        "token_count": 1511
    },
    "00410edf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_12h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00410edf(void)\n\n{\n    uint8_t *puVar1;\n    char16_t *noname_3;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint8_t *puVar4;\n    uint32_t uVar5;\n    ushort *puVar6;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    int32_t var_24h;\n    uint *var_20h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    uchar auStack24 [2];\n    uint var_12h;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    var_1ch = 0;\n    if (*0x42af78 == 0) {\n        *0x428330 = \n        L\"         (((((                  H\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x81\\x81\\x81\\x81\\x81\\x81\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x10\\x10\\x10\\x10\\x10\\x10\\x82\\x82\\x82\\x82\\x82\\x82\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x10\\x10\\x10\\x10 \"\n        ;\n        *0x42b244 = NULL;\n        *0x42b240 = NULL;\n        goto code_r0x004110be;\n    }\n    if ((*0x42af88 == 0) && (iVar3 = fcn.004133b1(0, *0x42afd8, 0x1004, 0x42af88),  iVar3 != 0)) {\ncode_r0x00411091:\n        fcn.00407696(var_20h);\n        fcn.00407696(var_24h);\n    }\n    else {\n        var_20h = fcn.00407684(4);\n        var_24h = fcn.00407684(0x300);\n        var_1ch = fcn.00407684(0x101);\n        if ((var_20h == NULL) || ((var_24h == 0 || (var_1ch == 0)))) goto code_r0x00411091;\n        *var_20h = 0;\n        iVar3 = 0;\n        do {\n            *(iVar3 + var_1ch) = iVar3;\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < 0x100);\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetCPInfo)(*0x42af88, &var_18h);\n        if ((iVar3 == 0) || (5 < var_18h)) goto code_r0x00411091;\n        *0x428440 = var_18h & 0xffff;\n        if ((1 < *0x428440) && (var_12h != '\\0')) {\n            puVar4 = &var_12h + 1;\n            do {\n                uVar2 = *puVar4;\n                if (uVar2 == 0) break;\n                for (uVar5 = puVar4[-1]; uVar5 <= uVar2; uVar5 = uVar5 + 1) {\n                    *(uVar5 + var_1ch) = 0;\n                    uVar2 = *puVar4;\n                }\n                puVar1 = puVar4 + 1;\n                puVar4 = puVar4 + 2;\n            } while (*puVar1 != 0);\n        }\n        noname_3 = var_24h + 0x100;\n        iVar3 = fcn.0040fb26(1, var_1ch, 0x100, noname_3, 0, 0, 0, unaff_ESI, unaff_EBX, unaff_EDI, noname_3, var_20h, \n                             var_1ch, var_18h, _auStack24);\n        if (iVar3 == 0) goto code_r0x00411091;\n        *(var_24h + 0xfe) = 0;\n        if ((1 < *0x428440) && (var_12h != '\\0')) {\n            puVar4 = &var_12h + 1;\n            do {\n                if (*puVar4 == 0) break;\n                uVar5 = puVar4[-1];\n                if (uVar5 <= *puVar4) {\n                    puVar6 = var_24h + 0x100 + uVar5 * 2;\n                    do {\n                        *puVar6 = 0x8000;\n                        uVar5 = uVar5 + 1;\n                        puVar6 = puVar6 + 1;\n                    } while (uVar5 <= *puVar4);\n                }\n                puVar1 = puVar4 + 1;\n                puVar4 = puVar4 + 2;\n            } while (*puVar1 != 0);\n        }\n        fcn.004085f0(var_24h, var_24h + 0x200, 0xfe);\n        *0x428330 = noname_3;\n        *0x42b240 = var_24h + 0xfe;\n        *0x42b244 = var_20h;\n    }\n    fcn.00407696(var_1ch);\ncode_r0x004110be:\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 1397
    },
    "0041129e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041129e(uint *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint var_ch;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    if ((param_1 == NULL) || (*param_1 == '\\0')) {\ncode_r0x004112e4:\n        uVar2 = 0x1004;\ncode_r0x004112ef:\n        iVar1 = (**0x42afc8)(*0x42afb0, uVar2, &var_ch, 8);\n        if (iVar1 == 0) goto code_r0x00411309;\n        param_1 = &var_ch;\n    }\n    else {\n        iVar1 = fcn.0040ae70(param_1, 0x422710);\n        if (iVar1 == 0) goto code_r0x004112e4;\n        iVar1 = fcn.0040ae70(param_1, 0x42270c);\n        if (iVar1 == 0) {\n            uVar2 = 0xb;\n            goto code_r0x004112ef;\n        }\n    }\n    fcn.004094ba(param_1);\ncode_r0x00411309:\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 290
    },
    "00411332": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00411332(uint32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    \n    iVar5 = 0;\n    iVar6 = 0x1a;\n    do {\n        iVar2 = (iVar6 + iVar5) / 2;\n        uVar1 = *(iVar2 * 0x2c + 0x421910);\n        if (arg_8h == uVar1) {\n            if (arg_ch == 1) {\n                pcVar4 = \"040a\" + iVar2 * 0x2c;\n            }\n            else if (arg_ch == 3) {\n                pcVar4 = iVar2 * 0x2c + 0x421920;\n            }\n            else if (arg_ch == 7) {\n                pcVar4 = iVar2 * 0x2c + 0x421928;\n            }\n            else if (arg_ch == 0xb) {\n                pcVar4 = iVar2 * 0x2c + 0x42192c;\n            }\n            else if (arg_ch == 0x1001) {\n                pcVar4 = *(iVar2 * 0x2c + 0x42191c);\n            }\n            else if (arg_ch == 0x1002) {\n                pcVar4 = *(iVar2 * 0x2c + 0x421924);\n            }\n            else {\n                if (arg_ch != 0x1004) break;\n                pcVar4 = iVar2 * 0x2c + 0x421934;\n            }\n            if ((pcVar4 != NULL) && (0 < arg_14h)) {\n                fcn.00411100(arg_10h, pcVar4, arg_14h + -1);\n                *(arg_10h + -1 + arg_14h) = 0;\n                return 1;\n            }\n            break;\n        }\n        if (arg_8h < uVar1) {\n            iVar6 = iVar2 + -1;\n        }\n        else {\n            iVar5 = iVar2 + 1;\n        }\n    } while (iVar5 <= iVar6);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return uVar3;\n}\n",
        "token_count": 566
    },
    "004114fb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004114fb(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint var_7ch;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    iVar1 = (**0x42afc8)(arg_8h & 0x3ff | 0x400, 1, &var_7ch, 0x78);\n    if (((iVar1 != 0) && (uVar2 = fcn.00411415(),  arg_8h != uVar2)) && (arg_ch != 0)) {\n        fcn.004089d0(*0x42afc4);\n        fcn.0041144a();\n    }\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 188
    },
    "00411786": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00411786(uint arg_8h)\n\n{\n    uint arg_8h_00;\n    int32_t iVar1;\n    uint var_7ch;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    arg_8h_00 = fcn.00411415();\n    iVar1 = (**0x42afc8)(arg_8h_00, (-(*0x42afb4 != 0) & 0xfffff002) + 0x1001, &var_7ch, 0x78);\n    if (iVar1 == 0) {\n        *0x42afa8 = 0;\n        goto code_r0x00411844;\n    }\n    iVar1 = fcn.00407b48(*0x42afc4, &var_7ch);\n    if (iVar1 == 0) {\n        if (*0x42afb4 == 0) {\n            iVar1 = 1;\n            goto code_r0x00411818;\n        }\n    }\n    else {\n        if (((*0x42afb4 != 0) || (*0x42afc0 == 0)) ||\n           (iVar1 = fcn.004134d8(*0x42afc4, &var_7ch, *0x42afc0),  iVar1 != 0)) goto code_r0x00411844;\ncode_r0x00411818:\n        iVar1 = fcn.004114fb(arg_8h_00, iVar1);\n        if (iVar1 == 0) goto code_r0x00411844;\n    }\n    *0x42afa8 = *0x42afa8 | 4;\n    *0x42afac = arg_8h_00;\n    *0x42afb0 = arg_8h_00;\ncode_r0x00411844:\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 423
    },
    "00411963": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint fcn.00411963(char *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t arg_8h;\n    uint uVar2;\n    int16_t *unaff_EBX;\n    int32_t unaff_retaddr;\n    \n    if (*0x42afc8 == NULL) {\n        if (*0x42ab68 == 2) {\n            *0x42afc8 = _sym.imp.KERNEL32.dll_GetLocaleInfoA;\n        }\n        else {\n            *0x42afc8 = fcn.00411332;\n        }\n    }\n    if (param_1 == NULL) {\ncode_r0x00411a3d:\n        fcn.00411284();\ncode_r0x00411a42:\n        if (*0x42afa8 == 0) {\n            return 0;\n        }\n    }\n    else {\n        *0x42afbc = param_1 + 0x40;\n        *0x42afc4 = param_1;\n        if ((*0x42afbc != NULL) && (**0x42afbc != '\\0')) {\n            fcn.00411224(0x421f40, 0x16, 0x42afbc);\n        }\n        *0x42afa8 = 0;\n        if ((*0x42afc4 == NULL) || (**0x42afc4 == '\\0')) {\n            if ((*0x42afbc == NULL) || (**0x42afbc == '\\0')) goto code_r0x00411a3d;\n            fcn.00411851();\n            goto code_r0x00411a42;\n        }\n        if ((*0x42afbc == NULL) || (**0x42afbc == '\\0')) {\n            fcn.0041190e();\n        }\n        else {\n            fcn.00411888();\n        }\n        if (*0x42afa8 == 0) {\n            iVar1 = fcn.00411224(0x4220f0, 0x40, 0x42afc4);\n            if (iVar1 != 0) {\n                if ((*0x42afbc == NULL) || (**0x42afbc == '\\0')) {\n                    fcn.0041190e();\n                }\n                else {\n                    fcn.00411888();\n                }\n            }\n            goto code_r0x00411a42;\n        }\n    }\n    arg_8h = fcn.0041129e();\n    if (((arg_8h == 0) || (iVar1 = (*_sym.imp.KERNEL32.dll_IsValidCodePage)(arg_8h & 0xffff),  iVar1 == 0)) ||\n       (iVar1 = (*_sym.imp.KERNEL32.dll_IsValidLocale)(*0x42afac, 1),  uVar2 = *0x42afac,  iVar1 == 0)) {\ncode_r0x00411b12:\n        uVar2 = 0;\n    }\n    else {\n        if (unaff_EBX != NULL) {\n            *unaff_EBX = *0x42afac;\n            unaff_EBX[1] = *0x42afb0;\n            unaff_EBX[2] = arg_8h;\n        }\n        if (unaff_retaddr != 0) {\n            if (*unaff_EBX == 0x814) {\n                fcn.0040fce0(unaff_retaddr, \"Norwegian-Nynorsk\");\n            }\n            else {\n                iVar1 = (**0x42afc8)(uVar2, 0x1001, unaff_retaddr, 0x40);\n                if (iVar1 == 0) goto code_r0x00411b12;\n            }\n            iVar1 = (**0x42afc8)(*0x42afb0, 0x1002, unaff_retaddr + 0x40, 0x40);\n            if (iVar1 == 0) goto code_r0x00411b12;\n            fcn.00413595(arg_8h, unaff_retaddr + 0x80, 10);\n        }\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 909
    },
    "00411ba0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00411ba0(uint32_t param_1, uint param_2)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint uVar4;\n    \n    if (param_1 < *0x42b254) {\n        piVar1 = (param_1 >> 5) * 4 + 0x42b260;\n        iVar3 = (param_1 & 0x1f) * 0x24;\n        if (*(iVar3 + *piVar1) == -1) {\n            if (*0x427848 == 1) {\n                if (param_1 == 0) {\n                    uVar4 = 0xfffffff6;\n                }\n                else if (param_1 == 1) {\n                    uVar4 = 0xfffffff5;\n                }\n                else {\n                    if (param_1 != 2) goto code_r0x00411bf9;\n                    uVar4 = 0xfffffff4;\n                }\n                (*_sym.imp.KERNEL32.dll_SetStdHandle)(uVar4, param_2);\n            }\ncode_r0x00411bf9:\n            *(iVar3 + *piVar1) = param_2;\n            return 0;\n        }\n    }\n    puVar2 = fcn.00409c85();\n    *puVar2 = 9;\n    puVar2 = fcn.00409c8e();\n    *puVar2 = 0;\n    return 0xffffffff;\n}\n",
        "token_count": 333
    },
    "00411c1c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00411c1c(uint32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint uVar5;\n    \n    if (param_1 < *0x42b254) {\n        piVar1 = (param_1 >> 5) * 4 + 0x42b260;\n        iVar4 = (param_1 & 0x1f) * 0x24;\n        piVar2 = *piVar1 + iVar4;\n        if (((*(piVar2 + 1) & 1) != 0) && (*piVar2 != -1)) {\n            if (*0x427848 == 1) {\n                if (param_1 == 0) {\n                    uVar5 = 0xfffffff6;\n                }\n                else if (param_1 == 1) {\n                    uVar5 = 0xfffffff5;\n                }\n                else {\n                    if (param_1 != 2) goto code_r0x00411c78;\n                    uVar5 = 0xfffffff4;\n                }\n                (*_sym.imp.KERNEL32.dll_SetStdHandle)(uVar5, 0);\n            }\ncode_r0x00411c78:\n            *(iVar4 + *piVar1) = 0xffffffff;\n            return 0;\n        }\n    }\n    puVar3 = fcn.00409c85();\n    *puVar3 = 9;\n    puVar3 = fcn.00409c8e();\n    *puVar3 = 0;\n    return 0xffffffff;\n}\n",
        "token_count": 363
    },
    "00411f1a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00411f1a(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x422750, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x42b254) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x42b260;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.00411cdc(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\ncode_r0x00411f9a:\n                puVar3 = fcn.00409c85();\n                *puVar3 = 9;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.00411c9b(arg_8h_00);\n                iVar4 = (*_sym.imp.KERNEL32.dll_FlushFileBuffers)(uVar2);\n                if (iVar4 == 0) {\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    *(unaff_EBP + -0x1c) = uVar2;\n                }\n                else {\n                    *(unaff_EBP + -0x1c) = 0;\n                }\n                if (*(unaff_EBP + -0x1c) != 0) {\n                    puVar3 = fcn.00409c8e();\n                    *puVar3 = *(unaff_EBP + -0x1c);\n                    goto code_r0x00411f9a;\n                }\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00411fba();\n            goto code_r0x00411fd0;\n        }\n    }\n    puVar3 = fcn.00409c85();\n    *puVar3 = 9;\ncode_r0x00411fd0:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 589
    },
    "00412071": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpBuffer\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00412071(uint32_t arg_8h, char *arg_ch, char *nNumberOfBytesToRead)\n\n{\n    int32_t *piVar1;\n    uint8_t *puVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char *pcVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    char *pcVar8;\n    int32_t iVar9;\n    int32_t lpNumberOfBytesRead;\n    char *var_8h;\n    uint lpBuffer;\n    \n    var_8h = NULL;\n    if (nNumberOfBytesToRead != NULL) {\n        piVar1 = (arg_8h >> 5) * 4 + 0x42b260;\n        iVar9 = (arg_8h & 0x1f) * 0x24;\n        uVar3 = *(*piVar1 + iVar9 + 4);\n        if ((uVar3 & 2) == 0) {\n            pcVar8 = arg_ch;\n            if (((uVar3 & 0x48) != 0) && (*(*piVar1 + iVar9 + 5) != '\\n')) {\n                nNumberOfBytesToRead = nNumberOfBytesToRead + -1;\n                *arg_ch = *(*piVar1 + 5 + iVar9);\n                pcVar8 = arg_ch + 1;\n                var_8h = 0x1;\n                *(*piVar1 + 5 + iVar9) = 10;\n            }\n            iVar6 = (*_sym.imp.KERNEL32.dll_ReadFile)\n                              (*(*piVar1 + iVar9), pcVar8, nNumberOfBytesToRead, &lpNumberOfBytesRead, 0);\n            if (iVar6 == 0) {\n                iVar9 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                if (iVar9 == 5) {\n                    puVar7 = fcn.00409c85();\n                    *puVar7 = 9;\n                    puVar7 = fcn.00409c8e();\n                    *puVar7 = 5;\n                }\n                else {\n                    if (iVar9 == 0x6d) {\n                        return 0;\n                    }\n                    fcn.00409c97(iVar9);\n                }\n                return -1;\n            }\n            if ((*(*piVar1 + 4 + iVar9) & 0x80) == 0) {\n                return var_8h + lpNumberOfBytesRead;\n            }\n            if ((lpNumberOfBytesRead == 0) || (*arg_ch != '\\n')) {\n                puVar2 = *piVar1 + 4 + iVar9;\n                *puVar2 = *puVar2 & 0xfb;\n            }\n            else {\n                puVar2 = *piVar1 + 4 + iVar9;\n                *puVar2 = *puVar2 | 4;\n            }\n            var_8h = arg_ch + var_8h + lpNumberOfBytesRead;\n            nNumberOfBytesToRead = arg_ch;\n            pcVar8 = arg_ch;\n            if (arg_ch < var_8h) {\n                do {\n                    cVar4 = *nNumberOfBytesToRead;\n                    if (cVar4 == '\\x1a') {\n                        if ((*(*piVar1 + 4 + iVar9) & 0x40) == 0) {\n                            puVar2 = *piVar1 + 4 + iVar9;\n                            *puVar2 = *puVar2 | 2;\n                        }\n                        break;\n                    }\n                    if (cVar4 == '\\r') {\n                        if (nNumberOfBytesToRead < var_8h + -1) {\n                            if (nNumberOfBytesToRead[1] == '\\n') {\n                                pcVar5 = nNumberOfBytesToRead + 2;\n                                goto code_r0x004121fe;\n                            }\ncode_r0x00412218:\n                            nNumberOfBytesToRead = nNumberOfBytesToRead + 1;\n                            *pcVar8 = '\\r';\n                        }\n                        else {\n                            pcVar5 = nNumberOfBytesToRead + 1;\n                            iVar6 = (*_sym.imp.KERNEL32.dll_ReadFile)\n                                              (*(*piVar1 + iVar9), &lpBuffer, 1, &lpNumberOfBytesRead, 0);\n                            if (((iVar6 == 0) && (iVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar6 != 0)) ||\n                               (lpNumberOfBytesRead == 0)) goto code_r0x00412218;\n                            if ((*(*piVar1 + 4 + iVar9) & 0x48) == 0) {\n                                if ((pcVar8 == arg_ch) && (lpBuffer == '\\n')) goto code_r0x004121fe;\n                                fcn.0040ff11(arg_8h, 0xffffffff, 1);\n                                if (lpBuffer == '\\n') goto code_r0x0041221c;\n                                goto code_r0x00412218;\n                            }\n                            if (lpBuffer == '\\n') {\ncode_r0x004121fe:\n                                nNumberOfBytesToRead = pcVar5;\n                                *pcVar8 = '\\n';\n                            }\n                            else {\n                                *pcVar8 = '\\r';\n                                *(*piVar1 + 5 + iVar9) = lpBuffer;\n                                nNumberOfBytesToRead = pcVar5;\n                            }\n                        }\n                        pcVar8 = pcVar8 + 1;\n                        pcVar5 = nNumberOfBytesToRead;\n                    }\n                    else {\n                        *pcVar8 = cVar4;\n                        pcVar8 = pcVar8 + 1;\n                        pcVar5 = nNumberOfBytesToRead + 1;\n                    }\ncode_r0x0041221c:\n                    nNumberOfBytesToRead = pcVar5;\n                } while (nNumberOfBytesToRead < var_8h);\n            }\n            return pcVar8 - arg_ch;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1321
    },
    "004122f7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.004122f7(uint *arg_8h, uint32_t *arg_ch, uint lpFileName, uint32_t arg_14h, uint arg_18h)\n\n{\n    int32_t *piVar1;\n    uint8_t *puVar2;\n    uint8_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    uint32_t arg_8h_00;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint uVar8;\n    int32_t *piVar9;\n    int32_t in_ECX;\n    bool bVar10;\n    uint lpSecurityAttributes;\n    uint var_18h;\n    uint32_t var_14h;\n    uint32_t dwDesiredAccess;\n    uint dwCreationDisposition;\n    uint32_t dwShareMode;\n    char var_2h;\n    uint var_1h;\n    \n    bVar10 = -1 < arg_14h;\n    lpSecurityAttributes = 0xc;\n    var_18h = 0;\n    if (bVar10) {\n        var_1h._0_1_ = 0;\n    }\n    else {\n        var_1h._0_1_ = 0x10;\n    }\n    var_14h = bVar10;\n    if (((arg_14h & 0x8000) == 0) && (((arg_14h & 0x4000) != 0 || (*0x42b010 != 0x8000)))) {\n        var_1h._0_1_ = var_1h | 0x80;\n    }\n    uVar4 = arg_14h & 3;\n    if (uVar4 == 0) {\n        dwDesiredAccess = 0x80000000;\n    }\n    else if (uVar4 == 1) {\n        dwDesiredAccess = 0x40000000;\n    }\n    else {\n        if (uVar4 != 2) goto code_r0x0041237e;\n        dwDesiredAccess = 0xc0000000;\n    }\n    if (in_ECX == 0x10) {\n        dwShareMode = 0;\n    }\n    else if (in_ECX == 0x20) {\n        dwShareMode = 1;\n    }\n    else if (in_ECX == 0x30) {\n        dwShareMode = 2;\n    }\n    else {\n        if (in_ECX != 0x40) {\ncode_r0x0041237e:\n            puVar5 = fcn.00409c85();\n            *puVar5 = 0x16;\n            puVar5 = fcn.00409c8e();\n            *puVar5 = 0;\n            return 0xffffffff;\n        }\n        dwShareMode = 3;\n    }\n    uVar4 = arg_14h & 0x700;\n    if (uVar4 < 0x401) {\n        if ((uVar4 == 0x400) || (uVar4 == 0)) {\n            dwCreationDisposition = 3;\n        }\n        else if (uVar4 == 0x100) {\n            dwCreationDisposition = 4;\n        }\n        else {\n            if (uVar4 == 0x200) goto code_r0x00412425;\n            if (uVar4 != 0x300) goto code_r0x0041240b;\n            dwCreationDisposition = 2;\n        }\n    }\n    else {\n        if (uVar4 != 0x500) {\n            if (uVar4 == 0x600) {\ncode_r0x00412425:\n                dwCreationDisposition = 5;\n                goto code_r0x00412435;\n            }\n            if (uVar4 != 0x700) {\ncode_r0x0041240b:\n                puVar5 = fcn.00409c85();\n                *puVar5 = 0x16;\n                puVar5 = fcn.00409c8e();\n                *puVar5 = 0;\n                return 0xffffffff;\n            }\n        }\n        dwCreationDisposition = 1;\n    }\ncode_r0x00412435:\n    uVar4 = 0x80;\n    if (((arg_14h & 0x100) != 0) && (-1 < (~*0x42ab64 & arg_18h))) {\n        uVar4 = 1;\n    }\n    if ((arg_14h & 0x40) != 0) {\n        dwDesiredAccess._0_3_ = CONCAT12(1, dwDesiredAccess);\n        dwDesiredAccess = dwDesiredAccess | dwDesiredAccess;\n        uVar4 = uVar4 | 0x4000000;\n        if (*0x42ab68 == 2) {\n            dwShareMode = dwShareMode | 4;\n        }\n    }\n    if ((arg_14h & 0x1000) != 0) {\n        uVar4 = uVar4 | 0x100;\n    }\n    if ((arg_14h & 0x20) == 0) {\n        if ((arg_14h & 0x10) != 0) {\n            uVar4 = uVar4 | 0x10000000;\n        }\n    }\n    else {\n        uVar4 = uVar4 | 0x8000000;\n    }\n    arg_8h_00 = fcn.00411d9e();\n    if (arg_8h_00 == 0xffffffff) {\n        puVar5 = fcn.00409c85();\n        *puVar5 = 0x18;\n        puVar5 = fcn.00409c8e();\n        *puVar5 = 0;\n    }\n    else {\n        *arg_8h = 1;\n        *arg_ch = arg_8h_00;\n        iVar6 = (*_sym.imp.KERNEL32.dll_CreateFileA)\n                          (lpFileName, dwDesiredAccess, dwShareMode, &lpSecurityAttributes, dwCreationDisposition, uVar4\n                           , 0);\n        if (iVar6 != -1) {\n            iVar7 = (*_sym.imp.KERNEL32.dll_GetFileType)(iVar6);\n            if (iVar7 != 0) {\n                if (iVar7 == 2) {\n                    var_1h._0_1_ = var_1h | 0x40;\n                }\n                else if (iVar7 == 3) {\n                    var_1h._0_1_ = var_1h | 8;\n                }\n                fcn.00411ba0(arg_8h_00, iVar6);\n                uVar3 = var_1h | 1;\n                piVar1 = (arg_8h_00 >> 5) * 4 + 0x42b260;\n                iVar6 = (arg_8h_00 & 0x1f) * 0x24;\n                var_1h._0_1_ = var_1h & 0x48;\n                *(iVar6 + 4 + *piVar1) = uVar3;\n                if (((var_1h == 0) && (uVar3 < '\\0')) && ((arg_14h & 2) != 0)) {\n                    dwDesiredAccess = fcn.0040ff11(arg_8h_00, 0xffffffff, 2);\n                    if (dwDesiredAccess == -1) {\n                        piVar9 = fcn.00409c8e();\n                        if (*piVar9 == 0x83) goto code_r0x00412577;\n                    }\n                    else {\n                        var_2h = '\\0';\n                        iVar7 = fcn.00412071(arg_8h_00, &var_2h, 1);\n                        if ((((iVar7 != 0) || (var_2h != '\\x1a')) ||\n                            (iVar7 = fcn.004135bf(arg_8h_00, dwDesiredAccess),  iVar7 != -1)) &&\n                           (iVar7 = fcn.0040ff11(arg_8h_00, 0, 0),  iVar7 != -1)) goto code_r0x00412577;\n                    }\n                    fcn.0040c834(arg_8h_00);\n                    return 0xffffffff;\n                }\ncode_r0x00412577:\n                if (var_1h != 0) {\n                    return arg_8h_00;\n                }\n                if ((arg_14h & 8) == 0) {\n                    return arg_8h_00;\n                }\n                puVar2 = iVar6 + 4 + *piVar1;\n                *puVar2 = *puVar2 | 0x20;\n                return arg_8h_00;\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar6);\n        }\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        fcn.00409c97(uVar8);\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 2014
    },
    "00412623": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.00412623(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) != 0) {\n        fcn.00411d7c(*(unaff_EBP + -0x20));\n    }\n    return;\n}\n",
        "token_count": 80
    },
    "0041269b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0041269b(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint var_10h;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar4 = 0;\n    if (*0x42aff4 == NULL) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"user32.dll\");\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if ((iVar2 == 0) || (*0x42aff4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x4227e4),  *0x42aff4 == NULL))\n        {\n            return 0;\n        }\n        *0x42aff8 = (*pcVar1)(iVar2, \"GetActiveWindow\");\n        *0x42affc = (*pcVar1)(iVar2, 0x4227c0);\n        if ((*0x42ab68 == 2) && (*0x42b004 = (*pcVar1)(iVar2, \"GetUserObjectInformationA\"),  *0x42b004 != NULL)) {\n            *0x42b000 = (*pcVar1)(iVar2, \"GetProcessWindowStation\");\n        }\n    }\n    if ((*0x42b000 == NULL) ||\n       (((iVar2 = (**0x42b000)(),  iVar2 != 0 && (iVar2 = (**0x42b004)(iVar2, 1, &var_10h, 0xc, &var_4h),  iVar2 != 0))\n        && ((var_8h & 1) != 0)))) {\n        if (((*0x42aff8 != NULL) && (iVar4 = (**0x42aff8)(),  iVar4 != 0)) && (*0x42affc != NULL)) {\n            iVar4 = (**0x42affc)(iVar4);\n        }\n    }\n    else if (*0x42ab74 < 4) {\n        arg_10h = arg_10h | 0x40000;\n    }\n    else {\n        arg_10h = arg_10h | 0x200000;\n    }\n    uVar3 = (**0x42aff4)(iVar4, arg_8h, arg_ch, arg_10h);\n    return uVar3;\n}\n",
        "token_count": 557
    },
    "00412794": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.00412794(uint8_t param_1, uint32_t param_2, uint8_t param_3)\n\n{\n    if ((*(param_1 + 0x42c3e1) & param_3) == 0) {\n        if (param_2 == 0) {\n            param_2 = 0;\n        }\n        else {\n            param_2 = *(*0x428330 + param_1 * 2) & param_2;\n        }\n        if (param_2 == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 132
    },
    "00412859": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.00412859(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.0040af1e();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x427c8c) {\n        iVar1 = fcn.0040bf89();\n    }\n    if (1 < *(iVar1 + 0x28)) {\n        uVar2 = fcn.0040f638(iVar1, param_1, 1);\n        return uVar2;\n    }\n    return *(*(iVar1 + 0x48) + param_1 * 2) & 1;\n}\n",
        "token_count": 158
    },
    "00412893": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.00412893(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.0040af1e();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x427c8c) {\n        iVar1 = fcn.0040bf89();\n    }\n    if (1 < *(iVar1 + 0x28)) {\n        uVar2 = fcn.0040f638(iVar1, param_1, 2);\n        return uVar2;\n    }\n    return *(*(iVar1 + 0x48) + param_1 * 2) & 2;\n}\n",
        "token_count": 158
    },
    "004128cd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.004128cd(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.0040af1e();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x427c8c) {\n        iVar1 = fcn.0040bf89();\n    }\n    if (1 < *(iVar1 + 0x28)) {\n        uVar2 = fcn.0040f638(iVar1, param_1, 4);\n        return uVar2;\n    }\n    return *(*(iVar1 + 0x48) + param_1 * 2) & 4;\n}\n",
        "token_count": 158
    },
    "00412907": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.00412907(int32_t param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    iVar2 = param_2 / 0x20;\n    uVar1 = *(param_1 + iVar2 * 4) & ~(-1 << (0x1fU - param_2 % 0x20 & 0x1f));\n    while( true ) {\n        if (uVar1 != 0) {\n            return 0;\n        }\n        iVar2 = iVar2 + 1;\n        if (2 < iVar2) break;\n        uVar1 = *(param_1 + iVar2 * 4);\n    }\n    return 1;\n}\n",
        "token_count": 163
    },
    "00412a2c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00412a2c(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint8_t uVar3;\n    uint *puVar4;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    uVar3 = arg_ch % 0x20;\n    iVar2 = 0;\n    var_4h = 0;\n    do {\n        uVar1 = *(arg_8h + iVar2 * 4);\n        *(arg_8h + iVar2 * 4) = uVar1 >> (uVar3 & 0x1f) | var_4h;\n        var_4h = (uVar1 & ~(-1 << (uVar3 & 0x1f))) << (0x20 - uVar3 & 0x1f);\n        iVar2 = iVar2 + 1;\n    } while (iVar2 < 3);\n    iVar2 = 2;\n    puVar4 = arg_8h + (2 - arg_ch / 0x20) * 4;\n    do {\n        if (iVar2 < arg_ch / 0x20) {\n            *(arg_8h + iVar2 * 4) = 0;\n        }\n        else {\n            *(arg_8h + iVar2 * 4) = *puVar4;\n        }\n        iVar2 = iVar2 + -1;\n        puVar4 = puVar4 + -1;\n    } while (-1 < iVar2);\n    return;\n}\n",
        "token_count": 353
    },
    "00412ff6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl\nfcn.00412ff6(uint noname_0, uint noname_1, uint lpMultiByteStr, uint arg_14h_2, uint arg_8h, uint arg_ch, uint noname_6\n            , uint arg_14h)\n\n{\n    uchar *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uchar *arg_ch_00;\n    uint *arg_8h_00;\n    int32_t unaff_EBP;\n    uint CodePage;\n    uint var_4h;\n    uint var_48h_2;\n    uint var_54h;\n    uint cbMultiByte;\n    uint var_3ch_2;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_1ch;\n    uchar *var_18h;\n    uint var_4h_2;\n    uint uStack4;\n    \n    uStack4 = 0x38;\n    var_4h_2 = 0x4227f0;\n    var_18h = 0x413002;\n    fcn.00408fec();\n    *(unaff_EBP + -0x1c) = *0x427850;\n    *(unaff_EBP + -0x34) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    puVar1 = **(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x40) = puVar1;\n    *(unaff_EBP + -0x3c) = 0;\n    pcVar2 = _sym.imp.KERNEL32.dll_GetCPInfo;\n    if (*(unaff_EBP + 8) == *(unaff_EBP + 0xc)) {\n        arg_8h_00 = *(unaff_EBP + -0x48);\n    }\n    else {\n        var_18h = unaff_EBP + -0x30;\n        var_1ch = *(unaff_EBP + 8);\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetCPInfo)();\n        if ((((iVar3 != 0) && (*(unaff_EBP + -0x30) == 1)) &&\n            (iVar3 = (*pcVar2)(*(unaff_EBP + 0xc), unaff_EBP + -0x30),  iVar3 != 0)) && (*(unaff_EBP + -0x30) == 1)) {\n            *(unaff_EBP + -0x3c) = 1;\n        }\n        if (*(unaff_EBP + -0x3c) == 0) {\n            arg_ch_00 = *(unaff_EBP + -0x38);\n        }\n        else {\n            arg_ch_00 = puVar1;\n            if (puVar1 == 0xffffffff) {\n                iVar3 = fcn.004089d0(*(unaff_EBP + 0x10));\n                arg_ch_00 = iVar3 + 1;\n            }\n            *(unaff_EBP + -0x38) = arg_ch_00;\n        }\n        if (*(unaff_EBP + -0x3c) == 0) {\n            arg_ch_00 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                  (*(unaff_EBP + 8), 1, *(unaff_EBP + 0x10), puVar1, 0, 0);\n            *(unaff_EBP + -0x38) = arg_ch_00;\n            if (arg_ch_00 == NULL) goto code_r0x004131ae;\n        }\n        arg_8h_00 = &fcn.00412ff6::var_1ch;\n        *(unaff_EBP + -4) = 0;\n        fcn.004079f0();\n        *(unaff_EBP + -0x18) = &fcn.00412ff6::var_1ch;\n        *(unaff_EBP + -0x48) = &fcn.00412ff6::var_1ch;\n        fcn.00409040(&fcn.00412ff6::var_1ch, 0, arg_ch_00 * 2);\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*0x10 == 0x10) {\n            arg_8h_00 = fcn.0040f6af(2, arg_ch_00);\n            if (arg_8h_00 == NULL) goto code_r0x004131ae;\n            *(unaff_EBP + -0x44) = 1;\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                          (*(unaff_EBP + 8), 1, *(unaff_EBP + 0x10), *(unaff_EBP + -0x40), arg_8h_00, arg_ch_00);\n        if (iVar3 != 0) {\n            if (*(unaff_EBP + 0x18) == 0) {\n                if (*(unaff_EBP + -0x3c) == 0) {\n                    var_18h = NULL;\n                    var_1ch = 0;\n                    arg_ch_00 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                          (*(unaff_EBP + 0xc), 0, arg_8h_00, arg_ch_00, 0, 0);\n                    if (arg_ch_00 == NULL) goto code_r0x0041319f;\n                }\n                var_1ch = 1;\n                var_18h = arg_ch_00;\n                iVar3 = fcn.0040f6af(1, arg_ch_00);\n                *(unaff_EBP + -0x34) = iVar3;\n                if (iVar3 != 0) {\n                    var_18h = NULL;\n                    var_1ch = 0;\n                    iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                      (*(unaff_EBP + 0xc), 0, arg_8h_00, arg_ch_00, iVar3, arg_ch_00);\n                    if (iVar3 == 0) {\n                        var_18h = *(unaff_EBP + -0x34);\n                        var_1ch = 0x413189;\n                        fcn.00407696(var_18h);\n                        *(unaff_EBP + -0x34) = 0;\n                    }\n                    else if (*(unaff_EBP + -0x40) != -1) {\n                        **(unaff_EBP + 0x14) = iVar3;\n                    }\n                }\n            }\n            else {\n                var_18h = NULL;\n                var_1ch = 0;\n                iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                  (*(unaff_EBP + 0xc), 0, arg_8h_00, arg_ch_00, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c)\n                                  );\n                if (iVar3 != 0) {\n                    *(unaff_EBP + -0x34) = *(unaff_EBP + 0x18);\n                }\n            }\n        }\n    }\ncode_r0x0041319f:\n    if (*(unaff_EBP + -0x44) != 0) {\n        var_1ch = 0x4131aa;\n        var_18h = arg_8h_00;\n        fcn.00407696(arg_8h_00);\n    }\ncode_r0x004131ae:\n    *(unaff_EBP + -0x58) = 0x4131b9;\n    fcn.0040895e();\n    *(unaff_EBP + -0x58) = 0x4131be;\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 1842
    },
    "004131bf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint32_t fcn.004131bf(uint32_t param_1, char **param_2)\n\n{\n    char *pcVar1;\n    \n    if (param_1 != 0xffffffff) {\n        pcVar1 = param_2[3];\n        if (((pcVar1 & 1) != 0) || ((pcVar1 < '\\0' && ((pcVar1 & 2) == 0)))) {\n            if (param_2[2] == NULL) {\n                fcn.004102a9(param_2);\n            }\n            if (*param_2 == param_2[2]) {\n                if (param_2[1] != NULL) {\n                    return 0xffffffff;\n                }\n                *param_2 = *param_2 + 1;\n            }\n            *param_2 = *param_2 + -1;\n            pcVar1 = *param_2;\n            if ((*(param_2 + 3) & 0x40) == 0) {\n                *pcVar1 = param_1;\n            }\n            else if (*pcVar1 != param_1) {\n                *param_2 = pcVar1 + 1;\n                return 0xffffffff;\n            }\n            param_2[1] = param_2[1] + 1;\n            param_2[3] = param_2[3] & 0xffffffef | 1;\n            return param_1 & 0xff;\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 324
    },
    "004133b1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_84h\n\nvoid __cdecl fcn.004133b1(int32_t arg_8h, uint arg_ch, uint arg_10h, int32_t *arg_14h)\n\n{\n    char cVar1;\n    bool bVar2;\n    int32_t iVar3;\n    uint *noname_2;\n    int32_t iVar4;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    char *pcVar5;\n    uint var_84h;\n    uint in_stack_ffffff7c;\n    uint in_stack_ffffff80;\n    uint var_4h;\n    \n    if (arg_8h != 1) {\n        if (arg_8h == 0) {\n            pcVar5 = 0x42b008;\n            iVar3 = fcn.004141ff(arg_ch, arg_10h, 0x42b008, 4, 0, unaff_EDI, unaff_ESI, unaff_EBX, var_84h, \n                                 in_stack_ffffff7c, in_stack_ffffff80);\n            if (iVar3 != 0) {\n                *arg_14h = '\\0';\n                do {\n                    cVar1 = *pcVar5;\n                    iVar3 = fcn.004128cd(cVar1);\n                    if (iVar3 == 0) break;\n                    pcVar5 = pcVar5 + 2;\n                    *arg_14h = *arg_14h * '\\n' + cVar1 + -0x30;\n                } while (pcVar5 < 0x42b010);\n            }\n        }\n        goto code_r0x00413463;\n    }\n    noname_2 = &var_84h;\n    bVar2 = false;\n    iVar3 = fcn.0041432f(arg_ch, arg_10h, noname_2, 0x80, 0, unaff_EDI, unaff_ESI, unaff_EBX, var_84h, in_stack_ffffff7c\n                         , in_stack_ffffff80);\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (((iVar3 != 0x7a) ||\n            (iVar3 = fcn.0041432f(arg_ch, arg_10h, 0, 0, 0, unaff_EDI, unaff_ESI, unaff_EBX, var_84h, in_stack_ffffff7c\n                                  , in_stack_ffffff80),  iVar3 == 0)) ||\n           (noname_2 = fcn.00407684(iVar3),  noname_2 == NULL)) goto code_r0x00413463;\n        bVar2 = true;\n        iVar3 = fcn.0041432f(arg_ch, arg_10h, noname_2, iVar3, 0, unaff_EDI, unaff_ESI, unaff_EBX, var_84h, \n                             in_stack_ffffff7c, in_stack_ffffff80);\n        if (iVar3 != 0) goto code_r0x00413444;\n    }\n    else {\ncode_r0x00413444:\n        iVar4 = fcn.00407684(iVar3);\n        *arg_14h = iVar4;\n        if (iVar4 != 0) {\n            fcn.00411100(iVar4, noname_2, iVar3);\n            if (bVar2) {\n                fcn.00407696(noname_2);\n            }\n            goto code_r0x00413463;\n        }\n        if (!bVar2) goto code_r0x00413463;\n    }\n    fcn.00407696(noname_2);\ncode_r0x00413463:\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 849
    },
    "004134d8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004134d8(uint8_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar1 = fcn.0040af1e();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x427c8c) {\n        iVar1 = fcn.0040bf89();\n    }\n    if (arg_10h == 0) {\n        iVar2 = 0;\n    }\n    else if (*(iVar1 + 0x14) == 0) {\n        iVar2 = fcn.00414470(arg_8h, arg_ch, arg_10h);\n    }\n    else {\n        do {\n            iVar2 = fcn.0040bb66(iVar1, *arg_8h);\n            arg_8h = arg_8h + 1;\n            iVar3 = fcn.0040bb66(iVar1, *arg_ch);\n            arg_ch = arg_ch + 1;\n            arg_10h = arg_10h + -1;\n            if ((arg_10h == 0) || (iVar2 == 0)) break;\n        } while (iVar2 == iVar3);\n        iVar2 = iVar2 - iVar3;\n    }\n    return iVar2;\n}\n",
        "token_count": 316
    },
    "00413557": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00413557(char *param_1, uint32_t param_2, int32_t param_3)\n\n{\n    uint64_t uVar1;\n    char *pcVar2;\n    uint32_t in_EAX;\n    char *pcVar3;\n    char cVar4;\n    \n    pcVar2 = param_1;\n    if (param_3 != 0) {\n        *param_1 = '-';\n        param_1 = param_1 + 1;\n        in_EAX = -in_EAX;\n        pcVar2 = param_1;\n    }\n    do {\n        pcVar3 = pcVar2;\n        uVar1 = in_EAX;\n        in_EAX = in_EAX / param_2;\n        cVar4 = uVar1 % param_2;\n        if (uVar1 % param_2 < 10) {\n            cVar4 = cVar4 + '0';\n        }\n        else {\n            cVar4 = cVar4 + 'W';\n        }\n        *pcVar3 = cVar4;\n        pcVar2 = pcVar3 + 1;\n    } while (in_EAX != 0);\n    pcVar3[1] = '\\0';\n    do {\n        cVar4 = *pcVar3;\n        *pcVar3 = *param_1;\n        pcVar3 = pcVar3 + -1;\n        *param_1 = cVar4;\n        param_1 = param_1 + 1;\n    } while (param_1 < pcVar3);\n    return;\n}\n",
        "token_count": 340
    },
    "0041372e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041372e(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    code *extraout_ECX;\n    code *arg_8h_00;\n    int32_t unaff_EBP;\n    code **ppcVar4;\n    code *pcVar5;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x422820, 0x20);\n    *(unaff_EBP + -0x1c) = 0;\n    iVar1 = *(unaff_EBP + 8);\n    if (iVar1 == 2) {\n        ppcVar4 = 0x42b014;\n        pcVar5 = *0x42b014;\ncode_r0x004137bb:\n        *(unaff_EBP + -0x1c) = 1;\n        iVar1 = *(unaff_EBP + -0x24);\n    }\n    else {\n        if (((iVar1 != 4) && (iVar1 != 8)) && (iVar1 != 0xb)) {\n            if (iVar1 == 0xf) {\n                ppcVar4 = 0x42b020;\n                pcVar5 = *0x42b020;\n            }\n            else if (iVar1 == 0x15) {\n                ppcVar4 = 0x42b018;\n                pcVar5 = *0x42b018;\n            }\n            else {\n                if (iVar1 != 0x16) goto code_r0x004138a1;\n                ppcVar4 = 0x42b01c;\n                pcVar5 = *0x42b01c;\n            }\n            goto code_r0x004137bb;\n        }\n        iVar1 = fcn.0040af1e();\n        *(unaff_EBP + -0x24) = iVar1;\n        iVar2 = fcn.00413700();\n        ppcVar4 = iVar2 + 8;\n        pcVar5 = *ppcVar4;\n    }\n    arg_8h_00 = NULL;\n    *(unaff_EBP + -0x20) = pcVar5;\n    if (pcVar5 == 0x1) goto code_r0x004138a1;\n    if (pcVar5 == NULL) {\n        fcn.00409c2b(3);\n        arg_8h_00 = extraout_ECX;\n    }\n    if (*(unaff_EBP + -0x1c) != arg_8h_00) {\n        fcn.0040a06b(arg_8h_00);\n        arg_8h_00 = NULL;\n    }\n    *(unaff_EBP + -4) = arg_8h_00;\n    iVar2 = *(unaff_EBP + 8);\n    if (((iVar2 == 8) || (iVar2 == 0xb)) || (iVar2 == 4)) {\n        *(unaff_EBP + -0x2c) = *(iVar1 + 0x58);\n        *(iVar1 + 0x58) = arg_8h_00;\n        if (iVar2 == 8) {\n            *(unaff_EBP + -0x30) = *(iVar1 + 0x5c);\n            *(iVar1 + 0x5c) = 0x8c;\n            goto code_r0x0041381a;\n        }\ncode_r0x00413846:\n        *ppcVar4 = arg_8h_00;\n    }\n    else {\ncode_r0x0041381a:\n        iVar3 = *0x4281b0;\n        if (iVar2 != 8) goto code_r0x00413846;\n        for (; *(unaff_EBP + -0x28) = iVar3,  iVar3 < *0x4281b4 + *0x4281b0; iVar3 = iVar3 + 1) {\n            *(*(iVar1 + 0x54) + 8 + iVar3 * 0xc) = arg_8h_00;\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00413869();\n    if (*(unaff_EBP + 8) == 8) {\n        (*pcVar5)(8, *(iVar1 + 0x5c));\n    }\n    else {\n        (*pcVar5)(*(unaff_EBP + 8));\n    }\n    iVar2 = *(unaff_EBP + 8);\n    if ((((iVar2 == 8) || (iVar2 == 0xb)) || (iVar2 == 4)) && (*(iVar1 + 0x58) = *(unaff_EBP + -0x2c),  iVar2 == 8)) {\n        *(iVar1 + 0x5c) = *(unaff_EBP + -0x30);\n    }\ncode_r0x004138a1:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 1153
    },
    "004138a7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004138a7(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint in_stack_00000020;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint in_stack_0000002c;\n    uint in_stack_00000030;\n    uint in_stack_00000034;\n    uint in_stack_00000038;\n    uint in_stack_0000003c;\n    uint in_stack_00000040;\n    uint in_stack_00000044;\n    uint in_stack_00000048;\n    uint in_stack_0000004c;\n    uint in_stack_00000050;\n    \n    iVar1 = fcn.0040af1e();\n    iVar1 = *(iVar1 + 0x60);\n    if (iVar1 != *0x42c3c4) {\n        iVar1 = fcn.00409726();\n    }\n    if (arg_10h == 0) {\n        return 0;\n    }\n    iVar1 = fcn.00414559(*(iVar1 + 0xc), 1, arg_8h, arg_10h, arg_ch, arg_10h, *(iVar1 + 4), unaff_EBP, unaff_retaddr, \n                         arg_8h, arg_ch, arg_10h, in_stack_00000010, in_stack_00000014, in_stack_00000018, \n                         in_stack_0000001c, in_stack_00000020, in_stack_00000024, in_stack_00000028, in_stack_0000002c, \n                         in_stack_00000030, in_stack_00000034, in_stack_00000038, in_stack_0000003c, in_stack_00000040, \n                         in_stack_00000044, in_stack_00000048, in_stack_0000004c, in_stack_00000050);\n    if (iVar1 == 0) {\n        return 0x7fffffff;\n    }\n    return iVar1 + -2;\n}\n",
        "token_count": 514
    },
    "00413b3d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00413e13)\n// WARNING: Removing unreachable block (ram,0x00413d8d)\n// WARNING: Removing unreachable block (ram,0x00413eef)\n// WARNING: Removing unreachable block (ram,0x00413d9f)\n// WARNING: Removing unreachable block (ram,0x00413da7)\n// WARNING: Removing unreachable block (ram,0x00413dad)\n// WARNING: Removing unreachable block (ram,0x00413db0)\n// WARNING: Removing unreachable block (ram,0x00413db7)\n// WARNING: Removing unreachable block (ram,0x00413dc1)\n// WARNING: Removing unreachable block (ram,0x00413e8b)\n// WARNING: Removing unreachable block (ram,0x00413e85)\n// WARNING: Removing unreachable block (ram,0x00413e91)\n// WARNING: Removing unreachable block (ram,0x00413eae)\n// WARNING: Removing unreachable block (ram,0x00413eb0)\n// WARNING: Removing unreachable block (ram,0x00413eb8)\n// WARNING: Removing unreachable block (ram,0x00413ebb)\n// WARNING: Removing unreachable block (ram,0x00413ec0)\n// WARNING: Removing unreachable block (ram,0x00413ec3)\n// WARNING: Removing unreachable block (ram,0x00413ef8)\n// WARNING: Removing unreachable block (ram,0x00413eca)\n// WARNING: Removing unreachable block (ram,0x00413ed1)\n// WARNING: Removing unreachable block (ram,0x00413f0f)\n// WARNING: Removing unreachable block (ram,0x00413f16)\n// WARNING: Removing unreachable block (ram,0x00413f1e)\n\nvoid __cdecl\nfcn.00413b3d(uint arg_8h, uint arg_ch, char *arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    char cVar1;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_19h;\n    uint var_14h;\n    uint var_eh;\n    uint var_ah;\n    uint var_4h;\n    \n    for (; (((cVar1 = *arg_10h,  cVar1 == ' ' || (cVar1 == '\\t')) || (cVar1 == '\\n')) || (cVar1 == '\\r'));\n        arg_10h = arg_10h + 1) {\n    }\n    // WARNING: Could not recover jumptable at 0x00413ba0. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (12 cases) at 0x413f41\n    (**0x413f41)();\n    return;\n}\n",
        "token_count": 691
    },
    "00413f71": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.00413f71(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h, int32_t arg_14h, uint32_t arg_18h, int16_t *arg_1ch)\n\n{\n    int16_t *piVar1;\n    char cVar2;\n    uint32_t uVar3;\n    int16_t *piVar4;\n    int16_t *piVar5;\n    int16_t iVar6;\n    int32_t iVar7;\n    char *pcVar8;\n    int16_t *var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint uStack40;\n    uint uStack36;\n    uint var_1ch;\n    uchar var_18h;\n    uchar var_17h;\n    uchar var_16h;\n    uchar var_15h;\n    uchar var_14h;\n    uchar var_13h;\n    uchar var_12h;\n    uchar var_11h;\n    ushort var_10h;\n    uint var_eh;\n    uint32_t var_ah;\n    uchar var_6h;\n    char var_5h;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    uVar3 = arg_10h & 0x7fff;\n    var_1ch._0_1_ = 0xcc;\n    var_1ch._1_1_ = 0xcc;\n    var_1ch._2_1_ = 0xcc;\n    var_1ch._3_1_ = 0xcc;\n    var_18h = 0xcc;\n    var_17h = 0xcc;\n    var_16h = 0xcc;\n    var_15h = 0xcc;\n    var_14h = 0xcc;\n    var_13h = 0xcc;\n    var_12h = 0xfb;\n    var_11h = 0x3f;\n    if ((arg_10h & 0x8000) == 0) {\n        *(arg_1ch + 1) = 0x20;\n    }\n    else {\n        *(arg_1ch + 1) = 0x2d;\n    }\n    if (((uVar3 == 0) && (arg_ch == 0)) && (arg_8h == 0)) {\ncode_r0x004140e7:\n        *(arg_1ch + 2) = 0x30;\ncode_r0x004141ea:\n        *arg_1ch = 0;\n        *(arg_1ch + 1) = 0x20;\n        *(arg_1ch + 3) = 1;\n        *(arg_1ch + 5) = 0;\n    }\n    else {\n        if (uVar3 == 0x7fff) {\n            *arg_1ch = 1;\n            if (((arg_ch == 0x80000000) && (arg_8h == 0)) || ((arg_ch & 0x40000000) != 0)) {\n                if (((arg_10h & 0x8000) == 0) || (arg_ch != 0xc0000000)) {\n                    if ((arg_ch != 0x80000000) || (arg_8h != 0)) goto code_r0x0041405d;\n                    pcVar8 = \"1#INF\";\n                }\n                else {\n                    if (arg_8h != 0) {\ncode_r0x0041405d:\n                        pcVar8 = \"1#QNAN\";\n                        goto code_r0x00414062;\n                    }\n                    pcVar8 = \"1#IND\";\n                }\n                fcn.0040fce0(arg_1ch + 2, pcVar8);\n                *(arg_1ch + 3) = 5;\n            }\n            else {\n                pcVar8 = \"1#SNAN\";\ncode_r0x00414062:\n                fcn.0040fce0(arg_1ch + 2, pcVar8);\n                *(arg_1ch + 3) = 6;\n            }\n            goto code_r0x004141cc;\n        }\n        var_10h = 0;\n        iVar6 = ((uVar3 >> 8) + (arg_ch >> 0x18) * 2) * 0x4d + -0x134312f4 + uVar3 * 0x4d10 >> 0x10;\n        var_6h = uVar3;\n        var_5h = uVar3 >> 8;\n        var_eh = arg_8h;\n        var_ah = arg_ch;\n        fcn.00414d92(&var_10h, -iVar6, 1);\n        if (0x3ffe < CONCAT11(var_5h, var_6h)) {\n            iVar6 = iVar6 + 1;\n            fcn.00414b60(&var_10h, &var_1ch);\n        }\n        *arg_1ch = iVar6;\n        if (((arg_18h & 1) != 0) && (arg_14h = arg_14h + iVar6,  arg_14h < 1)) goto code_r0x004140e7;\n        if (0x15 < arg_14h) {\n            arg_14h = 0x15;\n        }\n        iVar7 = CONCAT11(var_5h, var_6h) - 0x3ffe;\n        var_6h = 0;\n        var_5h = '\\0';\n        arg_10h = 8;\n        do {\n            fcn.00413a04(&var_10h);\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n        if (iVar7 < 0) {\n            for (uVar3 = -iVar7 & 0xff; uVar3 != 0; uVar3 = uVar3 - 1) {\n                fcn.00413a32(&var_10h);\n            }\n        }\n        arg_10h = arg_14h + 1;\n        piVar4 = arg_1ch + 2;\n        var_30h = piVar4;\n        if (0 < arg_10h) {\n            do {\n                var_ah._2_2_ = var_ah >> 0x10;\n                var_eh._2_2_ = var_eh >> 0x10;\n                var_28h = CONCAT22(var_eh, var_10h);\n                uStack40 = CONCAT22(var_ah, var_eh._2_2_);\n                uStack36 = CONCAT13(var_5h, CONCAT12(var_6h, var_ah._2_2_));\n                fcn.00413a04(&var_10h);\n                fcn.00413a04(&var_10h);\n                fcn.004139a6(&var_10h, &var_28h);\n                fcn.00413a04(&var_10h);\n                piVar4 = var_30h + 1;\n                arg_10h = arg_10h + -1;\n                *var_30h = var_5h + '0';\n                var_5h = '\\0';\n                var_30h = piVar4;\n            } while (arg_10h != 0);\n        }\n        piVar5 = piVar4 + -1;\n        piVar1 = arg_1ch + 2;\n        if (*(piVar4 + -1) < '5') {\n            for (; (piVar1 <= piVar5 && (*piVar5 == '0')); piVar5 = piVar5 + -1) {\n            }\n            if (piVar5 < piVar1) {\n                *piVar1 = 0x30;\n                goto code_r0x004141ea;\n            }\n        }\n        else {\n            for (; (piVar1 <= piVar5 && (*piVar5 == '9')); piVar5 = piVar5 + -1) {\n                *piVar5 = 0x30;\n            }\n            if (piVar5 < piVar1) {\n                piVar5 = piVar5 + 1;\n                *arg_1ch = *arg_1ch + 1;\n            }\n            *piVar5 = *piVar5 + '\\x01';\n        }\n        cVar2 = (piVar5 - arg_1ch) + -3;\n        *(arg_1ch + 3) = cVar2;\n        *(cVar2 + 4 + arg_1ch) = 0;\n    }\ncode_r0x004141cc:\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 1931
    },
    "004141ff": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_24h_2\n// WARNING: Variable defined which should be unmapped: var_20h_2\n// WARNING: Variable defined which should be unmapped: var_1ch_2\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_28h\n\nvoid __cdecl\nfcn.004141ff(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint CodePage, uint noname_5, uint arg_8h, \n            uint arg_ch, uint noname_8, uint noname_9, uint arg_18h)\n\n{\n    int32_t iVar1;\n    uchar *arg_8h_00;\n    int32_t unaff_EBP;\n    uint Locale;\n    uint LCType;\n    uint lpLCData;\n    uint cchData;\n    uint var_34h;\n    uint uVar2;\n    uint var_28h;\n    uint var_24h_2;\n    uint var_20h_2;\n    uint var_1ch_2;\n    uint uStack24;\n    uint uStack20;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    \n    var_18h = 0x18;\n    var_1ch = 0x422850;\n    var_20h = 0x41420b;\n    fcn.00408fec();\n    if (*0x42b028 == 0) {\n        var_20h = 0;\n        var_24h = 0;\n        uStack20 = 1;\n        uStack24 = 0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)();\n        if (iVar1 == 0) {\n            var_20h = 0x414234;\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x42b028 = 2;\n            }\n        }\n        else {\n            *0x42b028 = 1;\n        }\n    }\n    if (*0x42b028 == 1) {\n        var_20h = *(unaff_EBP + 0x14);\n        var_24h = *(unaff_EBP + 0x10);\n        uStack20 = *(unaff_EBP + 0xc);\n        uStack24 = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)();\n    }\n    else if ((*0x42b028 == 2) || (*0x42b028 == 0)) {\n        *(unaff_EBP + -0x1c) = 0;\n        *(unaff_EBP + -0x24) = 0;\n        if (*(unaff_EBP + 0x18) == 0) {\n            *(unaff_EBP + 0x18) = *0x42af88;\n        }\n        var_20h = 0;\n        var_24h = 0;\n        uStack20 = *(unaff_EBP + 0xc);\n        uStack24 = *(unaff_EBP + 8);\n        arg_8h_00 = &stack0xffffffe8;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)();\n        *(unaff_EBP + -0x20) = iVar1;\n        if (iVar1 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.004079f0();\n            *(unaff_EBP + -0x18) = &stack0xffffffe8;\n            *(unaff_EBP + -0x28) = &stack0xffffffe8;\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x18) {\n                arg_8h_00 = fcn.00407684(*(unaff_EBP + -0x20));\n                if (arg_8h_00 == NULL) goto code_r0x00414326;\n                *(unaff_EBP + -0x24) = 1;\n            }\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)\n                              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), arg_8h_00, *(unaff_EBP + -0x20));\n            if (iVar1 != 0) {\n                if (*(unaff_EBP + 0x14) == 0) {\n                    var_28h = 0;\n                    uVar2 = 0;\n                }\n                else {\n                    var_28h = *(unaff_EBP + 0x14);\n                    uVar2 = *(unaff_EBP + 0x10);\n                }\n                uVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                  (*(unaff_EBP + 0x18), 1, arg_8h_00, 0xffffffff, uVar2, var_28h);\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            if (*(unaff_EBP + -0x24) != 0) {\n                fcn.00407696(arg_8h_00);\n            }\n        }\n    }\ncode_r0x00414326:\n    *(unaff_EBP + -0x38) = 0x41432e;\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 1241
    },
    "0041432f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_24h_2\n// WARNING: Variable defined which should be unmapped: var_20h_2\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_28h\n\nvoid __cdecl\nfcn.0041432f(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint CodePage, uint noname_5, uint Locale, \n            uint LCType, uint lpLCData, uint cchData, uint arg_18h)\n\n{\n    int32_t iVar1;\n    uchar *arg_8h;\n    int32_t unaff_EBP;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h;\n    uint var_4h;\n    uint uVar2;\n    uint uVar3;\n    uint var_28h;\n    uint var_24h_2;\n    uint var_20h_2;\n    uint var_34h;\n    uint uStack24;\n    uint uStack20;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    \n    var_18h = 0x18;\n    var_1ch = 0x422860;\n    var_20h = 0x41433b;\n    fcn.00408fec();\n    if (*0x42b02c == 0) {\n        var_20h = 0;\n        var_24h = 0;\n        uStack20 = 1;\n        uStack24 = 0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)();\n        if (iVar1 == 0) {\n            var_20h = 0x414364;\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x42b02c = 2;\n            }\n        }\n        else {\n            *0x42b02c = 1;\n        }\n    }\n    if ((*0x42b02c == 2) || (*0x42b02c == 0)) {\n        var_20h = *(unaff_EBP + 0x14);\n        var_24h = *(unaff_EBP + 0x10);\n        uStack20 = *(unaff_EBP + 0xc);\n        uStack24 = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)();\n    }\n    else if (*0x42b02c == 1) {\n        *(unaff_EBP + -0x1c) = 0;\n        *(unaff_EBP + -0x20) = 0;\n        if (*(unaff_EBP + 0x18) == 0) {\n            *(unaff_EBP + 0x18) = *0x42af88;\n        }\n        var_20h = 0;\n        var_24h = 0;\n        uStack20 = *(unaff_EBP + 0xc);\n        uStack24 = *(unaff_EBP + 8);\n        arg_8h = &stack0xffffffe8;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)();\n        *(unaff_EBP + -0x24) = iVar1;\n        if (iVar1 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.004079f0();\n            *(unaff_EBP + -0x18) = &stack0xffffffe8;\n            *(unaff_EBP + -0x28) = &stack0xffffffe8;\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x18) {\n                arg_8h = fcn.00407684(iVar1 * 2);\n                if (arg_8h == NULL) goto code_r0x00414466;\n                *(unaff_EBP + -0x20) = 1;\n            }\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), arg_8h, iVar1);\n            if (iVar1 != 0) {\n                if (*(unaff_EBP + 0x14) == 0) {\n                    uVar3 = 0;\n                    uVar2 = 0;\n                }\n                else {\n                    uVar3 = *(unaff_EBP + 0x14);\n                    uVar2 = *(unaff_EBP + 0x10);\n                }\n                uVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                  (*(unaff_EBP + 0x18), 0, arg_8h, 0xffffffff, uVar2, uVar3, 0, 0);\n                *(unaff_EBP + -0x1c) = uVar3;\n            }\n            if (*(unaff_EBP + -0x20) != 0) {\n                fcn.00407696(arg_8h);\n            }\n        }\n    }\ncode_r0x00414466:\n    *(unaff_EBP + -0x38) = 0x41446e;\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 1203
    },
    "0041453d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t fcn.0041453d(int32_t param_1)\n\n{\n    char *in_EAX;\n    int32_t iVar1;\n    \n    iVar1 = param_1;\n    if (param_1 != 0) {\n        do {\n            iVar1 = iVar1 + -1;\n            if (*in_EAX == '\\0') goto code_r0x00414551;\n            in_EAX = in_EAX + 1;\n        } while (iVar1 != 0);\n    }\n    iVar1 = iVar1 + -1;\ncode_r0x00414551:\n    return (param_1 - iVar1) + -1;\n}\n",
        "token_count": 142
    },
    "00414559": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_44h_2\n// WARNING: Variable defined which should be unmapped: var_40h_3\n// WARNING: Variable defined which should be unmapped: var_3ch_3\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_40h_2\n// WARNING: Variable defined which should be unmapped: var_3ch_2\n// WARNING: Variable defined which should be unmapped: var_5ch\n\nvoid __cdecl\nfcn.00414559(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint arg_8h, uint arg_ch, uint lpMultiByteStr, uint cbMultiByte, \n            uint lpString2, uint cchCount2, uint CodePage)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint8_t *puVar4;\n    uint *arg_8h_00;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    int32_t iVar6;\n    uint Locale;\n    uint dwCmpFlags;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint lpCPInfo;\n    uint var_4h_2;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_18h_2;\n    uint var_1ch_2;\n    uint var_20h;\n    uint var_4h;\n    uint var_50h;\n    uint var_44h_2;\n    uint var_40h_3;\n    uint var_3ch_3;\n    uint lpString1;\n    uint var_30h_2;\n    uchar auStack48 [2];\n    uint var_2ah;\n    int32_t var_4ch;\n    uint var_40h_2;\n    uint var_3ch_2;\n    uint var_5ch;\n    uint uVar7;\n    \n    uVar7 = 0x40;\n    fcn.00408fec();\n    *(unaff_EBP + -0x1c) = *0x427850;\n    iVar6 = 0;\n    if (*0x42b030 == 0) {\n        var_4ch = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_CompareStringW)();\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar2 == 0x78) {\n                *0x42b030 = 2;\n            }\n        }\n        else {\n            *0x42b030 = 1;\n        }\n    }\n    if (0 < *(unaff_EBP + 0x14)) {\n        uVar3 = fcn.0041453d();\n        *(unaff_EBP + 0x14) = uVar3;\n    }\n    iVar2 = *(unaff_EBP + 0x1c);\n    if (0 < iVar2) {\n        iVar2 = fcn.0041453d();\n        *(unaff_EBP + 0x1c) = iVar2;\n    }\n    if ((*0x42b030 == 2) || (*0x42b030 == 0)) {\n        *(unaff_EBP + -0x38) = 0;\n        if (*(unaff_EBP + 8) == 0) {\n            *(unaff_EBP + 8) = *0x42af78;\n        }\n        iVar2 = *(unaff_EBP + 0x20);\n        if (*(unaff_EBP + 0x20) == 0) {\n            iVar2 = *0x42af88;\n        }\n        iVar5 = fcn.00412fb3(*(unaff_EBP + 8));\n        if (iVar5 == -1) goto code_r0x004148cc;\n        if (iVar5 != iVar2) {\n            var_4ch = iVar2;\n            iVar6 = fcn.00412ff6(iVar2, iVar5, *(unaff_EBP + 0x10), unaff_EBP + 0x14, 0, 0, 0x422870, uVar7);\n            if (iVar6 == 0) goto code_r0x004148cc;\n            var_4ch = iVar2;\n            iVar2 = fcn.00412ff6(iVar2, iVar5, *(unaff_EBP + 0x18), unaff_EBP + 0x1c, 0, 0, 0x422870, uVar7);\n            *(unaff_EBP + -0x38) = iVar2;\n            if (iVar2 == 0) {\n                fcn.00407696(iVar6);\n                goto code_r0x004148cc;\n            }\n            *(unaff_EBP + 0x10) = iVar6;\n            *(unaff_EBP + 0x18) = *(unaff_EBP + -0x38);\n        }\n        var_4ch = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_CompareStringA)();\n        if (iVar6 != 0) {\n            fcn.00407696(iVar6);\n            stack0xffffffd4 = 0x4148c8;\n            fcn.00407696(*(unaff_EBP + -0x38));\n        }\n        goto code_r0x004148cc;\n    }\n    if (*0x42b030 != 1) goto code_r0x004148cc;\n    *(unaff_EBP + -0x3c) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    *(unaff_EBP + -0x40) = 0;\n    if (*(unaff_EBP + 0x20) == 0) {\n        *(unaff_EBP + 0x20) = *0x42af88;\n    }\n    if ((*(unaff_EBP + 0x14) == 0) || (iVar2 == 0)) {\n        if ((*(unaff_EBP + 0x14) == iVar2) ||\n           (((1 < iVar2 || (1 < *(unaff_EBP + 0x14))) || (iVar6 = (*_sym.imp.KERNEL32.dll_GetCPInfo)(),  iVar6 == 0))))\n        goto code_r0x004148cc;\n        if (0 < *(unaff_EBP + 0x14)) {\n            if (1 < *(unaff_EBP + -0x30)) {\n                puVar4 = unaff_EBP + -0x2a;\n                uVar1 = *(unaff_EBP + -0x2a);\n                while (((uVar1 != 0 && (puVar4[1] != 0)) &&\n                       ((**(unaff_EBP + 0x10) < *puVar4 || (puVar4[1] < **(unaff_EBP + 0x10)))))) {\n                    puVar4 = puVar4 + 2;\n                    uVar1 = *puVar4;\n                }\n            }\n            goto code_r0x004148cc;\n        }\n        if (0 < *(unaff_EBP + 0x1c)) {\n            if (1 < *(unaff_EBP + -0x30)) {\n                puVar4 = unaff_EBP + -0x2a;\n                uVar1 = *(unaff_EBP + -0x2a);\n                while (((uVar1 != 0 && (puVar4[1] != 0)) &&\n                       ((**(unaff_EBP + 0x18) < *puVar4 || (puVar4[1] < **(unaff_EBP + 0x18)))))) {\n                    puVar4 = puVar4 + 2;\n                    uVar1 = *puVar4;\n                }\n            }\n            goto code_r0x004148cc;\n        }\n    }\n    var_4ch = *(unaff_EBP + 0x20);\n    iVar6 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n    *(unaff_EBP + -0x48) = iVar6;\n    if (iVar6 == 0) goto code_r0x004148cc;\n    *(unaff_EBP + -4) = 0;\n    fcn.004079f0();\n    *(unaff_EBP + -0x18) = &fcn.00414559::var_4ch;\n    *(unaff_EBP + -0x34) = &fcn.00414559::var_4ch;\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + -0x34) == 0) {\n        iVar2 = fcn.00407684();\n        *(unaff_EBP + -0x34) = iVar2;\n        if (iVar2 == 0) goto code_r0x004148cc;\n        *(unaff_EBP + -0x3c) = 1;\n    }\n    unique0x00007a00 = *(unaff_EBP + 0x14);\n    _auStack48 = *(unaff_EBP + 0x10);\n    var_30h_2 = 1;\n    lpString1 = *(unaff_EBP + 0x20);\n    iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n    if (iVar2 != 0) {\n        arg_8h_00 = &fcn.00414559::lpString1;\n        iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                          (*(unaff_EBP + 0x20), 9, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c), 0, 0);\n        *(unaff_EBP + -0x4c) = iVar2;\n        if (iVar2 != 0) {\n            *(unaff_EBP + -4) = 1;\n            fcn.004079f0();\n            *(unaff_EBP + -0x18) = &fcn.00414559::lpString1;\n            *(unaff_EBP + -0x50) = &fcn.00414559::lpString1;\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x38) {\n                arg_8h_00 = fcn.00407684(iVar2 * 2);\n                if (arg_8h_00 == NULL) goto code_r0x00414807;\n                *(unaff_EBP + -0x44) = 1;\n            }\n            iVar5 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                              (*(unaff_EBP + 0x20), 1, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c), arg_8h_00, iVar2);\n            if (iVar5 != 0) {\n                uVar7 = (*_sym.imp.KERNEL32.dll_CompareStringW)\n                                  (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x34), iVar6, arg_8h_00, iVar2);\n                *(unaff_EBP + -0x40) = uVar7;\n            }\n            if (*(unaff_EBP + -0x44) != 0) {\n                fcn.00407696(arg_8h_00);\n            }\n        }\n    }\ncode_r0x00414807:\n    if (*(unaff_EBP + -0x3c) != 0) {\n        fcn.00407696(*(unaff_EBP + -0x34));\n    }\ncode_r0x004148cc:\n    *(unaff_EBP + -0x60) = 0x4148d7;\n    fcn.0040895e();\n    *(unaff_EBP + -0x60) = 0x4148dc;\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 2832
    },
    "0041492a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * fcn.0041492a(void)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t *unaff_EDI;\n    uint var_4h;\n    \n    iVar3 = 0;\n    if (unaff_EDI != NULL) {\n        iVar1 = *unaff_EDI;\n        piVar2 = unaff_EDI;\n        while (iVar1 != 0) {\n            piVar2 = piVar2 + 1;\n            iVar3 = iVar3 + 1;\n            iVar1 = *piVar2;\n        }\n        piVar2 = fcn.00407684(iVar3 * 4 + 4);\n        if (piVar2 == NULL) {\n            fcn.004083c4(9);\n        }\n        iVar3 = *unaff_EDI;\n        piVar4 = piVar2;\n        while (iVar3 != 0) {\n            iVar3 = fcn.00409c5a(iVar3);\n            *piVar4 = iVar3;\n            piVar4 = piVar4 + 1;\n            unaff_EDI = unaff_EDI + 1;\n            iVar3 = *unaff_EDI;\n        }\n        *piVar4 = 0;\n        return piVar2;\n    }\n    return unaff_EDI;\n}\n",
        "token_count": 307
    },
    "00414b60": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00414b60(int32_t *arg_8h, int32_t *arg_ch)\n\n{\n    int16_t iVar1;\n    uint16_t uVar2;\n    int32_t *piVar3;\n    uint16_t uVar4;\n    int32_t iVar5;\n    uint16_t uVar6;\n    uint32_t uVar7;\n    uint16_t uVar8;\n    int32_t var_28h;\n    uint16_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint *var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar3 = arg_ch;\n    var_4h = *0x427850;\n    var_1ch = 0;\n    var_10h._0_1_ = 0;\n    var_10h._1_1_ = 0;\n    var_10h._2_2_ = 0;\n    var_ch._0_2_ = 0;\n    var_ch._2_2_ = 0;\n    var_8h._0_2_ = 0;\n    var_8h._2_1_ = 0;\n    var_8h._3_1_ = 0;\n    uVar6 = *(arg_ch + 10) & 0x7fff;\n    uVar4 = *(arg_8h + 10) & 0x7fff;\n    uVar8 = (*(arg_ch + 10) ^ *(arg_8h + 10)) & 0x8000;\n    uVar2 = uVar6 + uVar4;\n    if (((uVar4 < 0x7fff) && (uVar6 < 0x7fff)) && (uVar2 < 0xbffe)) {\n        if (uVar2 < 0x3fc0) {\ncode_r0x00414c0d:\n            arg_8h[2] = 0;\n            arg_8h[1] = 0;\n            *arg_8h = 0;\n            goto code_r0x00414d85;\n        }\n        if (uVar4 == 0) {\n            uVar2 = uVar2 + 1;\n            arg_8h._0_2_ = 0;\n            if ((((arg_8h[2] & 0x7fffffffU) != 0) || (arg_8h[1] != 0)) || (*arg_8h != 0)) goto code_r0x00414bf7;\n        }\n        else {\ncode_r0x00414bf7:\n            if (((uVar6 == 0) && (uVar2 = uVar2 + 1,  (arg_ch[2] & 0x7fffffffU) == 0)) &&\n               ((arg_ch[1] == 0 && (*arg_ch == 0)))) goto code_r0x00414c0d;\n            var_18h = 0;\n            var_14h = &var_ch;\n            arg_ch = 0x5;\n            do {\n                if (0 < arg_ch) {\n                    var_24h = var_18h * 2 + arg_8h;\n                    var_20h = piVar3 + 2;\n                    var_28h = arg_ch;\n                    do {\n                        iVar5 = fcn.00413985(var_14h[-1], *var_20h * *var_24h, var_14h + -1);\n                        if (iVar5 != 0) {\n                            *var_14h = *var_14h + 1;\n                        }\n                        var_24h = var_24h + 1;\n                        var_20h = var_20h + -2;\n                        var_28h = var_28h + -1;\n                    } while (var_28h != 0);\n                }\n                var_14h = var_14h + 2;\n                var_18h = var_18h + 1;\n                arg_ch = arg_ch + -1;\n            } while (0 < arg_ch);\n            arg_8h._0_2_ = uVar2 + 0xc002;\n            if (arg_8h < 1) {\ncode_r0x00414cc1:\n                arg_8h._0_2_ = arg_8h - 1;\n                if (arg_8h < 0) {\n                    uVar7 = -arg_8h;\n                    arg_8h._0_2_ = 0;\n                    do {\n                        if ((var_10h & 1) != 0) {\n                            var_1ch = var_1ch + 1;\n                        }\n                        fcn.00413a32(&var_10h);\n                        uVar7 = uVar7 - 1;\n                    } while (uVar7 != 0);\n                    if (var_1ch != 0) {\n                        var_10h._0_1_ = var_10h | 1;\n                    }\n                }\n            }\n            else {\n                do {\n                    if ((var_8h._3_1_ & 0x80) != 0) break;\n                    fcn.00413a04(&var_10h);\n                    arg_8h._0_2_ = arg_8h - 1;\n                } while (0 < arg_8h);\n                if (arg_8h < 1) goto code_r0x00414cc1;\n            }\n            if ((0x8000 < CONCAT11(var_10h._1_1_, var_10h)) ||\n               ((CONCAT22(var_10h._2_2_, CONCAT11(var_10h._1_1_, var_10h)) & 0x1ffff) == 0x18000)) {\n                if (CONCAT22(var_ch, var_10h._2_2_) == -1) {\n                    var_10h._2_2_ = 0;\n                    var_ch._0_2_ = 0;\n                    if (CONCAT22(var_8h, var_ch._2_2_) == -1) {\n                        var_ch._2_2_ = 0;\n                        var_8h._0_2_ = 0;\n                        if (CONCAT11(var_8h._3_1_, var_8h._2_1_) == -1) {\n                            arg_8h._0_2_ = arg_8h + 1;\n                            var_8h._2_1_ = 0;\n                            var_8h._3_1_ = 0x80;\n                        }\n                        else {\n                            iVar1 = CONCAT11(var_8h._3_1_, var_8h._2_1_) + 1;\n                            var_8h._2_1_ = iVar1;\n                            var_8h._3_1_ = iVar1 >> 8;\n                        }\n                    }\n                    else {\n                        iVar5 = CONCAT22(var_8h, var_ch._2_2_) + 1;\n                        var_ch._2_2_ = iVar5;\n                        var_8h._0_2_ = iVar5 >> 0x10;\n                    }\n                }\n                else {\n                    iVar5 = CONCAT22(var_ch, var_10h._2_2_) + 1;\n                    var_10h._2_2_ = iVar5;\n                    var_ch._0_2_ = iVar5 >> 0x10;\n                }\n            }\n            if (0x7ffe < arg_8h) goto code_r0x00414d6a;\n            *arg_8h = var_10h._2_2_;\n            *(arg_8h + 2) = CONCAT22(var_ch._2_2_, var_ch);\n            *(arg_8h + 6) = CONCAT13(var_8h._3_1_, CONCAT12(var_8h._2_1_, var_8h));\n            arg_8h._0_2_ = arg_8h | uVar8;\n        }\n        *(arg_8h + 10) = arg_8h;\n    }\n    else {\ncode_r0x00414d6a:\n        arg_8h[1] = 0;\n        *arg_8h = 0;\n        arg_8h[2] = (-(uVar8 != 0) & 0x80000000) + 0x7fff8000;\n    }\ncode_r0x00414d85:\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 1913
    },
    "00414f5e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00414f5e(code **param_1)\n\n{\n    code *pcVar1;\n    \n    *param_1 = vtable.std::ios_base.0;\n    if ((param_1[1] == NULL) ||\n       (pcVar1 = param_1[1] + 0x42b06c,  *pcVar1 = *pcVar1 + -1,  param_1[1][0x42b06c] < '\\x01')) {\n        fcn.00414f1c();\n        pcVar1 = param_1[9];\n        if (pcVar1 != NULL) {\n            fcn.00414e91();\n            fcn.00418300(pcVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 169
    },
    "004170c8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004170c8(code **param_1)\n\n{\n    *param_1 = vtable.exception.0;\n    if (param_1[2] != NULL) {\n        fcn.00407696(param_1[1]);\n    }\n    return;\n}\n",
        "token_count": 62
    },
    "00415a3f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00415a3f(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    \n    *(param_1 + 0x54) = param_3 == 1;\n    *(param_1 + 0x4c) = 0;\n    fcn.00415906();\n    if (param_2 != 0) {\n        fcn.004154d4(param_2 + 8, param_2, param_2 + 4, param_2 + 8, param_2, param_2 + 4);\n    }\n    *(param_1 + 0x58) = param_2;\n    *(param_1 + 0x50) = *0x42b080;\n    uVar1 = *0x42b080;\n    *(param_1 + 0x3c) = 0;\n    *(param_1 + 0x40) = uVar1;\n    return;\n}\n",
        "token_count": 225
    },
    "0041613d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_30h\n\nvoid fcn.0041613d(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    iVar1 = extraout_ECX[0xf];\n    *(unaff_EBP + -0x10) = *0x427850;\n    if ((iVar1 != 0) && (*(extraout_ECX + 0x13) != '\\0')) {\n        (**(*extraout_ECX + 4))(0xffffffff);\n        fcn.00416117(8, 0);\n        *(unaff_EBP + -4) = 0;\n        do {\n            iVar1 = *(unaff_EBP + -0x28);\n            if (*(unaff_EBP + -0x14) < 0x10) {\n                iVar1 = unaff_EBP + -0x28;\n            }\n            iVar1 = (**(*extraout_ECX[0xf] + 0x18))\n                              (extraout_ECX + 0x14, iVar1, iVar1 + *(unaff_EBP + -0x18), unaff_EBP + -0x30);\n            if (iVar1 == 0) {\n                *(extraout_ECX + 0x13) = 0;\n            }\n            else if (iVar1 != 1) goto code_r0x00416206;\n            iVar1 = *(unaff_EBP + -0x28);\n            if (*(unaff_EBP + -0x14) < 0x10) {\n                iVar1 = unaff_EBP + -0x28;\n            }\n            iVar1 = *(unaff_EBP + -0x30) - iVar1;\n            if (iVar1 != 0) {\n                iVar2 = *(unaff_EBP + -0x28);\n                if (*(unaff_EBP + -0x14) < 0x10) {\n                    iVar2 = unaff_EBP + -0x28;\n                }\n                iVar2 = fcn.00417342(iVar2, iVar1, 1, extraout_ECX[0x16]);\n                if (iVar1 != iVar2) goto code_r0x00416206;\n            }\n            if (*(extraout_ECX + 0x13) == '\\0') goto code_r0x00416206;\n            fcn.00415f06(8, 0);\n        } while( true );\n    }\ncode_r0x00416219:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0040895e();\n    return;\ncode_r0x00416206:\n    fcn.004035c0(1, 0);\n    goto code_r0x00416219;\n}\n",
        "token_count": 720
    },
    "0041660a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041660a(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.std::basic_filebuf_char__struct_std::char_traits_char__.0;\n    *(unaff_EBP + -4) = 0;\n    if (*(extraout_ECX + 0x15) != '\\0') {\n        fcn.004165bd();\n    }\n    if (extraout_ECX[0x12] != NULL) {\n        fcn.00415c3a(1);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00415725();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 240
    },
    "004167f2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004167f2(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    \n    if (*0x42b18c == NULL) {\n        fcn.00416ed3(fcn.004167af);\n    }\n    piVar1 = fcn.004182d5(8);\n    if (piVar1 == NULL) {\n        piVar1 = NULL;\n    }\n    else {\n        *piVar1 = *0x42b18c;\n        piVar1[1] = param_1;\n    }\n    *0x42b18c = piVar1;\n    return;\n}\n",
        "token_count": 141
    },
    "00416ae7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.00416ae7(uint32_t arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint noname_3;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint in_stack_00000020;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    piVar2 = arg_ch;\n    if (arg_ch == NULL) {\n        iVar3 = fcn.004110e2();\n        var_ch = *(iVar3 + 8);\n        iVar3 = fcn.004110c9();\n    }\n    else {\n        var_ch = *arg_ch;\n        iVar3 = arg_ch[1];\n    }\n    if (var_ch != 0) {\n        if (arg_8h < 0x100) {\n            if (piVar2 == NULL) {\n                iVar4 = fcn.00412859(arg_8h);\n                if (iVar4 == 0) {\n                    return arg_8h;\n                }\n            }\n            else if ((*(piVar2[2] + arg_8h * 2) & 1) == 0) {\n                return arg_8h;\n            }\n        }\n        iVar4 = fcn.0041039e();\n        uVar1 = arg_8h >> 8 & 0xff;\n        if ((*(iVar4 + 1 + uVar1 * 2) & 0x80) == 0) {\n            arg_ch = arg_ch & 0xffff0000 | arg_8h & 0xff;\n            noname_3 = 1;\n        }\n        else {\n            arg_ch._0_2_ = CONCAT11(arg_8h, uVar1);\n            arg_ch = arg_ch & 0xff000000 | arg_ch;\n            noname_3 = 2;\n        }\n        iVar3 = fcn.0040f76a(var_ch, 0x100, &arg_ch, noname_3, &var_4h, 3, iVar3, 1, unaff_EDI, unaff_EBX, unaff_ESI, \n                             iVar3, var_ch, arg_8h >> 8, var_4h, unaff_EBP, unaff_retaddr, arg_8h, arg_ch, \n                             in_stack_0000000c, in_stack_00000010, in_stack_00000014, in_stack_00000018, \n                             in_stack_0000001c, in_stack_00000020, in_stack_00000024, in_stack_00000028);\n        if (iVar3 != 0) {\n            if (iVar3 == 1) {\n                arg_8h = var_4h & 0xff;\n            }\n            else {\n                arg_8h = CONCAT11(var_4h, var_4h._1_1_);\n            }\n        }\n        return arg_8h;\n    }\n    if (arg_8h < 0x41) {\n        return arg_8h;\n    }\n    if (0x5a < arg_8h) {\n        return arg_8h;\n    }\n    return arg_8h + 0x20;\n}\n",
        "token_count": 899
    },
    "00416c7e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.00416c7e(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) == 0) {\n        uVar1 = fcn.0040bca4();\n        (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(uVar1);\n    }\n    else {\n        fcn.00409fb6(0xc);\n    }\n    return;\n}\n",
        "token_count": 110
    },
    "00416d2a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.00416d2a(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) == 0) {\n        uVar1 = fcn.0040bca4();\n        (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(uVar1);\n    }\n    else {\n        fcn.00409fb6(0xc);\n    }\n    return;\n}\n",
        "token_count": 110
    },
    "00416d47": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.00416d47(uint32_t arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t noname_6;\n    int32_t iVar4;\n    uint noname_3;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    bool bVar5;\n    uint unaff_retaddr;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint in_stack_00000020;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint in_stack_0000002c;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    piVar2 = arg_ch;\n    if (arg_ch == NULL) {\n        iVar3 = fcn.004110e2();\n        iVar3 = *(iVar3 + 8);\n        noname_6 = fcn.004110c9();\n    }\n    else {\n        iVar3 = *arg_ch;\n        noname_6 = arg_ch[1];\n    }\n    if (iVar3 == 0) {\n        if ((0x60 < arg_8h) && (arg_8h < 0x7b)) {\n            arg_8h = arg_8h - 0x20;\n        }\n    }\n    else {\n        if (arg_8h < 0x100) {\n            if (piVar2 == NULL) {\n                iVar4 = fcn.00412893(arg_8h);\n                bVar5 = iVar4 == 0;\n            }\n            else {\n                bVar5 = (*(piVar2[2] + arg_8h * 2) & 2) == 0;\n            }\n            if (bVar5) {\n                return arg_8h;\n            }\n        }\n        iVar4 = fcn.0041039e();\n        uVar1 = arg_8h >> 8 & 0xff;\n        if ((*(iVar4 + 1 + uVar1 * 2) & 0x80) == 0) {\n            arg_ch = arg_ch & 0xffff0000 | arg_8h & 0xff;\n            noname_3 = 1;\n        }\n        else {\n            arg_ch._0_2_ = CONCAT11(arg_8h, uVar1);\n            arg_ch = arg_ch & 0xff000000 | arg_ch;\n            noname_3 = 2;\n        }\n        iVar3 = fcn.0040f76a(iVar3, 0x200, &arg_ch, noname_3, &var_4h, 3, noname_6, 1, unaff_EBX, unaff_EDI, unaff_ESI, \n                             noname_6, arg_8h >> 8, var_4h, unaff_EBP, unaff_retaddr, arg_8h, arg_ch, in_stack_0000000c\n                             , in_stack_00000010, in_stack_00000014, in_stack_00000018, in_stack_0000001c, \n                             in_stack_00000020, in_stack_00000024, in_stack_00000028, in_stack_0000002c);\n        if (iVar3 != 0) {\n            if (iVar3 == 1) {\n                arg_8h = var_4h & 0xff;\n            }\n            else {\n                arg_8h = CONCAT11(var_4h, var_4h._1_1_);\n            }\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 909
    },
    "00416eb6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.00416eb6(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) == 0) {\n        uVar1 = fcn.0040bca4();\n        (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(uVar1);\n    }\n    else {\n        fcn.00409fb6(0xc);\n    }\n    return;\n}\n",
        "token_count": 109
    },
    "0041715f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041715f(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint32_t uVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x422ad8, 0x10);\n    *(unaff_EBP + -0x1c) = 0;\n    uVar1 = *(unaff_EBP + 0x10);\n    if ((uVar1 != 4) &&\n       (((*(unaff_EBP + 0x14) < 2 || (0x7fffffff < *(unaff_EBP + 0x14))) || ((uVar1 != 0 && (uVar1 != 0x40))))))\n    goto code_r0x0041722b;\n    *(unaff_EBP + 0x14) = *(unaff_EBP + 0x14) & 0xfffffffe;\n    piVar2 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x20) = piVar2;\n    fcn.0040cbf9(piVar2);\n    *(unaff_EBP + -4) = 0;\n    fcn.0040c97d(piVar2);\n    fcn.0040c952(piVar2);\n    *(piVar2 + 3) = *(piVar2 + 3) & 0xc2f3;\n    if ((uVar1 & 4) == 0) {\n        piVar3 = *(unaff_EBP + 0xc);\n        if (piVar3 != NULL) {\n            piVar2[3] = piVar2[3] | 0x500;\n            goto code_r0x00417211;\n        }\n        piVar3 = fcn.00407684(*(unaff_EBP + 0x14));\n        *(unaff_EBP + 0xc) = piVar3;\n        if (piVar3 != NULL) {\n            *(piVar2 + 3) = *(piVar2 + 3) | 0x408;\n            goto code_r0x00417211;\n        }\n        *0x42ad70 = *0x42ad70 + 1;\n        *(unaff_EBP + -0x1c) = 0xffffffff;\n    }\n    else {\n        piVar2[3] = piVar2[3] | 4;\n        piVar3 = piVar2 + 5;\n        *(unaff_EBP + 0xc) = piVar3;\n        *(unaff_EBP + 0x14) = 2;\ncode_r0x00417211:\n        piVar2[6] = *(unaff_EBP + 0x14);\n        piVar2[2] = piVar3;\n        *piVar2 = piVar3;\n        piVar2[1] = 0;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00417231();\ncode_r0x0041722b:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 739
    },
    "0041723b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0041723b(char *arg_8h, uint32_t arg_ch, uint32_t arg_10h, int32_t *arg_14h)\n\n{\n    int32_t iVar1;\n    uint32_t arg_10h_00;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    uVar3 = arg_ch * arg_10h;\n    if (uVar3 == 0) {\n        arg_10h = 0;\n    }\n    else {\n        uVar2 = uVar3;\n        if ((*(arg_14h + 3) & 0x10c) == 0) {\n            var_4h = 0x1000;\n        }\n        else {\n            var_4h = arg_14h[6];\n        }\n        do {\n            if (((arg_14h[3] & 0x108U) == 0) || (uVar4 = arg_14h[1],  uVar4 == 0)) {\n                if (var_4h <= uVar2) {\n                    if (((arg_14h[3] & 0x108U) != 0) && (iVar1 = fcn.0040c97d(arg_14h),  iVar1 != 0)) {\ncode_r0x00417330:\n                        return (uVar3 - uVar2) / arg_ch;\n                    }\n                    uVar4 = uVar2;\n                    if (var_4h != 0) {\n                        uVar4 = uVar2 - uVar2 % var_4h;\n                    }\n                    arg_10h_00 = fcn.004101fe(arg_14h[4], arg_8h, uVar4);\n                    if ((arg_10h_00 == 0xffffffff) || (uVar2 = uVar2 - arg_10h_00,  arg_10h_00 < uVar4)) {\n                        arg_14h[3] = arg_14h[3] | 0x20;\n                        goto code_r0x00417330;\n                    }\n                    goto code_r0x004172f0;\n                }\n                iVar1 = fcn.0040b1c5(*arg_8h, arg_14h);\n                if (iVar1 == -1) goto code_r0x00417330;\n                arg_8h = arg_8h + 1;\n                var_4h = arg_14h[6];\n                uVar2 = uVar2 - 1;\n                if (var_4h < 1) {\n                    var_4h = 1;\n                }\n            }\n            else {\n                arg_10h_00 = uVar2;\n                if (uVar4 <= uVar2) {\n                    arg_10h_00 = uVar4;\n                }\n                fcn.004085f0(*arg_14h, arg_8h, arg_10h_00);\n                arg_14h[1] = arg_14h[1] - arg_10h_00;\n                *arg_14h = *arg_14h + arg_10h_00;\n                uVar2 = uVar2 - arg_10h_00;\ncode_r0x004172f0:\n                arg_8h = arg_8h + arg_10h_00;\n            }\n        } while (uVar2 != 0);\n    }\n    return arg_10h;\n}\n",
        "token_count": 782
    },
    "00417408": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.00417408(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    if (((*(param_1 + 0xc) & 0x83) == 0) || (((param_3 != 0 && (param_3 != 1)) && (param_3 != 2)))) {\n        puVar3 = fcn.00409c85();\n        *puVar3 = 0x16;\n        iVar2 = -1;\n    }\n    else {\n        *(param_1 + 0xc) = *(param_1 + 0xc) & 0xffffffef;\n        if (param_3 == 1) {\n            iVar2 = fcn.004176d4(param_1);\n            param_2 = param_2 + iVar2;\n            param_3 = 0;\n        }\n        fcn.0040c97d(param_1);\n        uVar1 = *(param_1 + 0xc);\n        if (uVar1 < '\\0') {\n            *(param_1 + 0xc) = uVar1 & 0xfffffffc;\n        }\n        else if ((((uVar1 & 1) != 0) && ((uVar1 & 8) != 0)) && ((uVar1 & 0x400) == 0)) {\n            *(param_1 + 0x18) = 0x200;\n        }\n        iVar2 = fcn.0040ff85(*(param_1 + 0x10), param_2, param_3);\n        iVar2 = (iVar2 != -1) - 1;\n    }\n    return iVar2;\n}\n",
        "token_count": 389
    },
    "004176d4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004176d4(char **arg_8h)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    uint8_t uVar3;\n    char **ppcVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    char *pcVar7;\n    char *pcVar8;\n    char *pcVar9;\n    int32_t iVar10;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    ppcVar4 = arg_8h;\n    pcVar7 = arg_8h[4];\n    if (arg_8h[1] < 0) {\n        arg_8h[1] = NULL;\n    }\n    var_4h = fcn.0040ff85(pcVar7, 0, 1);\n    if (var_4h < 0) {\ncode_r0x00417771:\n        var_8h = -1;\n    }\n    else {\n        pcVar8 = arg_8h[3];\n        if ((pcVar8 & 0x108) == 0) {\n            return var_4h - arg_8h[1];\n        }\n        pcVar9 = *arg_8h;\n        pcVar2 = arg_8h[2];\n        var_8h = pcVar9 - pcVar2;\n        if ((pcVar8 & 3) == 0) {\n            if (-1 < pcVar8) {\n                puVar5 = fcn.00409c85();\n                *puVar5 = 0x16;\n                goto code_r0x00417771;\n            }\n        }\n        else if (((*(*((pcVar7 >> 5) * 4 + 0x42b260) + 4 + (pcVar7 & 0x1f) * 0x24) & 0x80) != 0) &&\n                (pcVar8 = pcVar2,  pcVar2 < pcVar9)) {\n            do {\n                if (*pcVar8 == '\\n') {\n                    var_8h = var_8h + 1;\n                }\n                pcVar8 = pcVar8 + 1;\n            } while (pcVar8 < *arg_8h);\n        }\n        if (var_4h != 0) {\n            if ((*(arg_8h + 3) & 1) != 0) {\n                if (arg_8h[1] == NULL) {\n                    var_8h = 0;\n                }\n                else {\n                    pcVar8 = arg_8h[1] + (pcVar9 - pcVar2);\n                    piVar1 = (pcVar7 >> 5) * 4 + 0x42b260;\n                    iVar10 = (pcVar7 & 0x1f) * 0x24;\n                    if ((*(iVar10 + 4 + *piVar1) & 0x80) != 0) {\n                        iVar6 = fcn.0040ff85(pcVar7, 0, 2);\n                        if (iVar6 == var_4h) {\n                            pcVar7 = arg_8h[2];\n                            pcVar9 = pcVar8 + pcVar7;\n                            arg_8h = pcVar8;\n                            for (; pcVar7 < pcVar9; pcVar7 = pcVar7 + 1) {\n                                if (*pcVar7 == '\\n') {\n                                    arg_8h = arg_8h + 1;\n                                }\n                            }\n                            uVar3 = *(ppcVar4 + 0xd) & 0x20;\n                        }\n                        else {\n                            fcn.0040ff85(pcVar7, var_4h, 0);\n                            pcVar7 = 0x200;\n                            if (((0x200 < pcVar8) || ((arg_8h[3] & 8) == 0)) || ((arg_8h[3] & 0x400) != 0)) {\n                                pcVar7 = arg_8h[6];\n                            }\n                            uVar3 = *(iVar10 + 4 + *piVar1) & 4;\n                            arg_8h = pcVar7;\n                        }\n                        pcVar8 = arg_8h;\n                        if (uVar3 != 0) {\n                            pcVar8 = arg_8h + 1;\n                        }\n                    }\n                    arg_8h = pcVar8;\n                    var_4h = var_4h - arg_8h;\n                }\n            }\n            var_8h = var_8h + var_4h;\n        }\n    }\n    return var_8h;\n}\n",
        "token_count": 1028
    },
    "00417836": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00417836(int32_t arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    int64_t iVar3;\n    int64_t iVar4;\n    \n    iVar4 = CONCAT44(arg_10h, arg_ch);\n    if (((*(arg_8h + 0xc) & 0x83) == 0) || (((arg_14h != 0 && (arg_14h != 1)) && (arg_14h != 2)))) {\n        puVar2 = fcn.00409c85();\n        *puVar2 = 0x16;\n    }\n    else {\n        *(arg_8h + 0xc) = *(arg_8h + 0xc) & 0xffffffef;\n        if (arg_14h == 1) {\n            iVar3 = fcn.004174f8(arg_8h);\n            iVar4 = iVar3 + iVar4;\n            arg_14h = 0;\n        }\n        arg_10h = iVar4 >> 0x20;\n        arg_ch = iVar4;\n        fcn.0040c97d(arg_8h);\n        uVar1 = *(arg_8h + 0xc);\n        if (uVar1 < '\\0') {\n            *(arg_8h + 0xc) = uVar1 & 0xfffffffc;\n        }\n        else if ((((uVar1 & 1) != 0) && ((uVar1 & 8) != 0)) && ((uVar1 & 0x400) == 0)) {\n            *(arg_8h + 0x18) = 0x200;\n        }\n        iVar4 = fcn.004132f3(*(arg_8h + 0x10), arg_ch, arg_10h, arg_14h);\n        if (iVar4 != -1) {\n            return 0;\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 449
    },
    "004179d9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.004179d9(int32_t param_1)\n\n{\n    int32_t in_EAX;\n    \n    if (in_EAX != 0) {\n        do {\n            if (param_1 != 0) {\n                fcn.004034f0();\n            }\n            param_1 = param_1 + 4;\n            in_EAX = in_EAX + -1;\n        } while (in_EAX != 0);\n    }\n    return;\n}\n",
        "token_count": 103
    },
    "00417e76": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.00417e76(uint *param_1, int32_t param_2, int32_t param_3)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    \n    if ((param_2 != 0) && (param_3 != 0)) {\n        puVar2 = fcn.004182d5(param_2 * param_3 + 4);\n        *puVar2 = *param_1;\n        *param_1 = puVar2;\n        return;\n    }\n    fcn.004179a8();\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 143
    },
    "00417ebd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00417ebd(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    \n    if (param_2 == 0) {\n        param_2 = 0x11;\n    }\n    if (*(param_1 + 4) != 0) {\n        fcn.00418300(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    if (param_3 != 0) {\n        uVar1 = fcn.004182d5(param_2 << 2);\n        *(param_1 + 4) = uVar1;\n        fcn.00409040(uVar1, 0, param_2 << 2);\n    }\n    *(param_1 + 8) = param_2;\n    return;\n}\n",
        "token_count": 194
    },
    "004180b2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004180b2(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    \n    if (*(param_1 + 0x10) == 0) {\n        iVar2 = fcn.00417e76(param_1 + 0x14, *(param_1 + 0x18), 0xc);\n        iVar4 = *(param_1 + 0x18);\n        puVar3 = iVar2 + -8 + iVar4 * 0xc;\n        if (-1 < iVar4 + -1) {\n            do {\n                *puVar3 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar3;\n                puVar3 = puVar3 + -3;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n    }\n    puVar3 = *(param_1 + 0x10);\n    uVar1 = *puVar3;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    *(param_1 + 0x10) = uVar1;\n    puVar3[1] = 0;\n    puVar3[2] = 0;\n    return;\n}\n",
        "token_count": 304
    },
    "0041846b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041846b(int32_t param_1)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowLongA)(*(param_1 + 0x1c), 0xfffffff0);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00418482. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0x78))();\n    return;\n}\n",
        "token_count": 130
    },
    "00418485": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00418485(int32_t param_1)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowLongA)(*(param_1 + 0x1c), 0xffffffec);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0041849c. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0x7c))();\n    return;\n}\n",
        "token_count": 130
    },
    "0041849f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041849f(int32_t param_1)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_IsWindowEnabled)(*(param_1 + 0x1c));\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x004184b4. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0xa4))();\n    return;\n}\n",
        "token_count": 124
    },
    "004184ba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004184ba(int32_t param_1, uint param_2)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(*(param_1 + 0x1c), param_2);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x004184d5. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0xa8))();\n    return;\n}\n",
        "token_count": 132
    },
    "004184db": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004184db(int32_t arg_8h, uint X, uint Y, uint cx, uint cy, uint uFlags)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        if (arg_8h != 0) {\n            arg_8h = *(arg_8h + 0x1c);\n        }\n        (*_sym.imp.USER32.dll_SetWindowPos)(*(in_ECX + 0x1c), arg_8h, X, Y, cx, cy, uFlags);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00418511. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x4c) + 0x9c))();\n    return;\n}\n",
        "token_count": 197
    },
    "00418517": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00418517(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    if ((param_1 != 0) && (*(param_1 + 0x4c) == 0)) {\n        uVar1 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x1c));\n        iVar2 = fcn.00417f85(uVar1);\n        if ((iVar2 != 0) && (*(iVar2 + 0x48) != 0)) {\n            (**(**(iVar2 + 0x48) + 0x9c))(param_1, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 158
    },
    "00418695": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00418695(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    uint32_t arg_ch_00;\n    int32_t *piVar4;\n    \n    if (arg_ch == 0xfffffffe) {\n        iVar1 = fcn.0041d221();\n        iVar1 = (**(**(iVar1 + 0x1038) + 4))();\n        return iVar1;\n    }\n    if (arg_ch == 0xfffffffd) {\n        iVar1 = *(arg_10h + 0x30);\n        arg_ch = 0;\n        puVar2 = (**(*in_ECX + 0x2c))();\n        do {\n            if (puVar2 == NULL) {\n                return arg_ch;\n            }\n            if (arg_ch != 0) {\n                return arg_ch;\n            }\n            piVar4 = puVar2[1];\n            while (((piVar4[1] != 0 && (piVar4[2] != 0)) && (arg_ch == 0))) {\n                if (arg_8h == piVar4[1]) {\n                    if (iVar1 == 0) {\n                        if (*piVar4 == 0) {\ncode_r0x00418721:\n                            *(arg_10h + 4) = piVar4[2];\n                            arg_ch = 1;\n                        }\n                    }\n                    else if ((*piVar4 != 0) && (iVar3 = fcn.004062bf(iVar1, *piVar4),  iVar3 != 0))\n                    goto code_r0x00418721;\n                }\n                piVar4 = piVar4 + 3;\n            }\n            puVar2 = *puVar2;\n        } while( true );\n    }\n    if (arg_ch != 0xffffffff) {\n        arg_ch_00 = arg_ch >> 0x10;\n        arg_ch = arg_ch & 0xffff;\n        if (arg_ch_00 != 0) goto code_r0x0041875a;\n    }\n    arg_ch_00 = 0x111;\ncode_r0x0041875a:\n    puVar2 = (**(*in_ECX + 0x28))();\n    while( true ) {\n        if (puVar2 == NULL) {\n            return 0;\n        }\n        iVar1 = fcn.00418dc7(puVar2[1], arg_ch_00, arg_ch, arg_8h);\n        if (iVar1 != 0) break;\n        puVar2 = *puVar2;\n    }\n    iVar1 = fcn.0041857f(in_ECX, arg_8h, arg_ch, *(iVar1 + 0x14), arg_10h, *(iVar1 + 0x10), arg_14h);\n    return iVar1;\n}\n",
        "token_count": 659
    },
    "00418a32": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t __cdecl\nfcn.00418a32(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t *piVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    arg_8h_00 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &stack0xffffffec;\n    if (arg_8h_00 == 0) {\n        iVar1 = 0;\n    }\n    else {\n        iVar1 = fcn.00417f85(arg_8h_00);\n        if (iVar1 == 0) {\n            iVar1 = fcn.00417f85(arg_8h_00);\n            if (iVar1 == 0) {\n                uVar2 = fcn.004182c3(0x41c1e6);\n                *(unaff_EBP + -4) = 0;\n                *(unaff_EBP + 8) = uVar2;\n                iVar1 = fcn.00407230();\n                if (iVar1 == 0) {\n                    fcn.0041798e();\n                }\n                (**(extraout_ECX + 0x14))(iVar1);\n                piVar3 = fcn.004180fd(arg_8h_00);\n                uVar2 = *(unaff_EBP + 8);\n                *(unaff_EBP + -4) = 0xffffffff;\n                *piVar3 = iVar1;\n                fcn.004182c3(uVar2);\n                piVar3 = *(extraout_ECX + 0x58) + iVar1;\n                *piVar3 = arg_8h_00;\n                if (*(extraout_ECX + 0x5c) == 2) {\n                    piVar3[1] = arg_8h_00;\n                }\n            }\n            else {\n                piVar3 = *(extraout_ECX + 0x58) + iVar1;\n                *piVar3 = arg_8h_00;\n                if (*(extraout_ECX + 0x5c) == 2) {\n                    piVar3[1] = arg_8h_00;\n                }\n            }\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1;\n}\n",
        "token_count": 613
    },
    "00418af4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00418af4(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (param_1 != 0) {\n        var_8h = -(*(param_1 + 0x44) != 0);\n        while (var_8h != 0) {\n            fcn.00417fff(&var_8h, &var_ch, &var_4h);\n            puVar1 = *(param_1 + 0x58) + var_4h;\n            *puVar1 = 0;\n            if (*(param_1 + 0x5c) == 2) {\n                puVar1[1] = 0;\n            }\n            (**(param_1 + 0x18))(var_4h);\n        }\n        fcn.00417f09();\n        fcn.00407216();\n    }\n    return;\n}\n",
        "token_count": 220
    },
    "00418c8f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpWndClass\n\nuint __cdecl\nfcn.00418c8f(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    uint lpWndClass;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    iVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &lpWndClass;\n    iVar4 = (*_sym.imp.USER32.dll_GetClassInfoA)(*(iVar1 + 0x10), *(iVar1 + 0x24), unaff_EBP + -0x40);\n    if (iVar4 != 0) {\n        uVar5 = 1;\n        goto code_r0x00418d6f;\n    }\n    iVar3 = (*_sym.imp.USER32.dll_RegisterClassA)(iVar1);\n    if (iVar3 == 0) {\ncode_r0x00418d14:\n        uVar5 = 0;\n    }\n    else {\n        *(unaff_EBP + -0x18) = 1;\n        iVar4 = fcn.0041d221();\n        if (*(iVar4 + 0x14) != '\\0') {\n            fcn.0041d72b(1);\n            *(unaff_EBP + -4) = 0;\n            iVar4 = fcn.0041d221();\n            pcVar2 = _sym.imp.KERNEL32.dll_lstrlenA;\n            *(unaff_EBP + -0x14) = iVar4 + 0x34;\n            iVar4 = (*pcVar2)(iVar4 + 0x34);\n            iVar6 = (*pcVar2)(*(iVar1 + 0x24));\n            if (0xfff < iVar4 + 2 + iVar6) goto code_r0x00418d14;\n            uVar7 = (*pcVar2)(*(unaff_EBP + -0x14));\n            uVar5 = *(iVar1 + 0x24);\n            *(unaff_EBP + 8) = uVar7;\n            iVar4 = (*pcVar2)(uVar5);\n            pcVar2 = _sym.imp.KERNEL32.dll_lstrcatA;\n            if (*(unaff_EBP + 8) + 2 + iVar4 < 0x1000) {\n                (*_sym.imp.KERNEL32.dll_lstrcatA)(*(unaff_EBP + -0x14), *(iVar1 + 0x24));\n                *(unaff_EBP + 10) = 10;\n                *(unaff_EBP + 0xb) = 0;\n                (*pcVar2)(*(unaff_EBP + -0x14), unaff_EBP + 10);\n            }\n            else {\n                uVar5 = *(iVar1 + 0x10);\n                *(unaff_EBP + -0x18) = 0;\n                (*_sym.imp.USER32.dll_UnregisterClassA)(*(iVar1 + 0x24), uVar5);\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0041d78e(1);\n        }\n        uVar5 = *(unaff_EBP + -0x18);\n    }\ncode_r0x00418d6f:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar5;\n}\n",
        "token_count": 932
    },
    "00418dc7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00418dc7(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    while( true ) {\n        if (arg_8h[4] == 0) {\n            return NULL;\n        }\n        if ((((arg_ch == *arg_8h) && (arg_10h == arg_8h[1])) && (arg_8h[2] <= arg_14h)) &&\n           (arg_14h < arg_8h[3] || arg_14h == arg_8h[3])) break;\n        arg_8h = arg_8h + 6;\n    }\n    return arg_8h;\n}\n",
        "token_count": 168
    },
    "00419d25": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00419d25(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    iVar1 = fcn.0041d247();\n    if ((*(iVar1 + 0x14) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.004182c3(0x41c1e6);\n        iVar3 = fcn.004182d5(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.004189ae(0x41fbd8, 0x41d8f3, 0x41e0de, 0x1c, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x14) = uVar4;\n        fcn.004182c3(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x14);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 372
    },
    "00419e49": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.00419e49(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar1 = fcn.0041d669(0x41ccb5);\n    iVar2 = fcn.0041d221();\n    if ((*(iVar2 + 0x14) != '\\0') && (*(iVar1 + 0x28) != 0)) {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar1 + 0x28));\n        *(iVar1 + 0x28) = 0;\n    }\n    if (*(iVar1 + 0x14) != 0) {\n        *(iVar1 + 0x14) = 0;\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 170
    },
    "00419ee6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00419ee6(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint var_30h;\n    uint var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    \n    iVar2 = fcn.0041841f();\n    if (iVar2 == 0) goto code_r0x00419f31;\n    if (*(iVar2 + 0x1c) == param_1) {\n        iVar3 = fcn.0041d221();\n        if (*(iVar3 + 0x14) == '\\0') {\n            iVar3 = fcn.0041d221();\n            if (iVar2 == *(iVar3 + 4)) {\n                iVar3 = fcn.0041cc09();\n                if (iVar3 == 0) goto code_r0x00419f26;\n            }\n            fcn.0041e3b6(0);\n        }\ncode_r0x00419f26:\n        *(iVar2 + 0x1c) = 0;\n    }\n    if (*(iVar2 + 0x20) == param_1) {\n        *(iVar2 + 0x20) = 0;\n    }\ncode_r0x00419f31:\n    if (param_1[0x11] != NULL) {\n        (**(*param_1[0x11] + 0x50))();\n        param_1[0x11] = 0;\n    }\n    if (param_1[0x12] != NULL) {\n        (**(*param_1[0x12] + 4))(1);\n    }\n    param_1[0x12] = 0;\n    if ((*(param_1 + 0xe) & 1) != 0) {\n        iVar2 = fcn.0041d247();\n        iVar2 = *(iVar2 + 0x3c);\n        if ((iVar2 != 0) && (*(iVar2 + 0x1c) != 0)) {\n            fcn.00409040(&var_30h, 0, 0x30);\n            var_28h = param_1[7];\n            var_30h = 0x28;\n            var_2ch = 1;\n            var_24h = var_28h;\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x1c), 0x405, 0, &var_30h);\n        }\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongA;\n    iVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(param_1[7], 0xfffffffc);\n    fcn.00419cfe();\n    iVar3 = (*pcVar1)(param_1[7], 0xfffffffc);\n    if (iVar3 == iVar2) {\n        piVar4 = (**(*param_1 + 0xf0))();\n        if (*piVar4 != 0) {\n            (*_sym.imp.USER32.dll_SetWindowLongA)(param_1[7], 0xfffffffc, *piVar4);\n        }\n    }\n    fcn.00419e1b();\n    (**(*param_1 + 0x114))();\n    return;\n}\n",
        "token_count": 743
    },
    "0041a1c2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0041a1c2(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *in_ECX;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    if (*(in_ECX + 8) != '\\0') {\n        var_4h = NULL;\n        iVar1 = (**(*in_ECX + 0xe4))(arg_8h, arg_ch, &var_4h);\n        if (-1 < iVar1) {\n            return var_4h;\n        }\n    }\n    piVar2 = fcn.00419cfe();\n    return piVar2;\n}\n",
        "token_count": 165
    },
    "0041a2fd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_40h\n\nuint fcn.0041a2fd(void)\n\n{\n    int32_t *arg_8h;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint *puVar4;\n    uint *puVar5;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h_2;\n    uint var_14h;\n    uint var_18h;\n    uint var_10h;\n    uint var_40h;\n    uint var_24h;\n    uint var_14h_2;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    *(unaff_EBP + -0x10) = &stack0xffffffc0;\n    iVar1 = fcn.0041d669(0x41ccb5);\n    puVar4 = iVar1 + 0x58;\n    puVar5 = unaff_EBP + -0x40;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n    }\n    iVar3 = *(unaff_EBP + 0x10);\n    arg_8h = *(unaff_EBP + 8);\n    *(iVar1 + 0x58) = *(unaff_EBP + 0xc);\n    *(iVar1 + 0x60) = *(unaff_EBP + 0x14);\n    *(iVar1 + 100) = *(unaff_EBP + 0x18);\n    *(unaff_EBP + -0x14) = iVar1;\n    *(iVar1 + 0x5c) = iVar3;\n    *(unaff_EBP + -4) = 0;\n    if ((iVar3 == 2) && (arg_8h[0x12] != 0)) {\n        (**(*arg_8h[0x12] + 0x60))(0);\n    }\n    *(unaff_EBP + 8) = 0;\n    if (iVar3 == 0x110) {\n        fcn.004195fc(arg_8h, unaff_EBP + -0x24, unaff_EBP + 8);\n    }\n    uVar2 = (**(*arg_8h + 0x108))(iVar3, *(unaff_EBP + 0x14), *(unaff_EBP + 0x18));\n    *(unaff_EBP + 0x18) = uVar2;\n    if (iVar3 == 0x110) {\n        fcn.0041a284(arg_8h, unaff_EBP + -0x24);\n    }\n    uVar2 = *(unaff_EBP + 0x18);\n    puVar4 = unaff_EBP + -0x40;\n    puVar5 = iVar1 + 0x58;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 775
    },
    "0041a435": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041a435(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CWnd.0;\n    *(unaff_EBP + -4) = 0;\n    if ((((extraout_ECX[7] != NULL) && (extraout_ECX != 0x42a8a8)) && (extraout_ECX != 0x42a8f8)) &&\n       ((extraout_ECX != 0x42a948 && (extraout_ECX != 0x42a998)))) {\n        fcn.00419ff7();\n    }\n    if (extraout_ECX[0x12] != NULL) {\n        (**(*extraout_ECX[0x12] + 4))(1);\n    }\n    pcVar1 = extraout_ECX[0x13];\n    if ((pcVar1 != NULL) && (*(pcVar1 + 0x24) == extraout_ECX)) {\n        *(pcVar1 + 0x24) = 0;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00418572();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 357
    },
    "0041a554": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041a554(uint arg_8h, uint Msg, uint wParam, uint lParam, int32_t arg_18h, int32_t arg_1ch)\n\n{\n    code *pcVar1;\n    int32_t arg_8h_00;\n    int32_t iVar2;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    for (arg_8h_00 = (*_sym.imp.USER32.dll_GetTopWindow)(arg_8h); arg_8h_00 != 0;\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetWindow)(arg_8h_00, 2)) {\n        if (arg_1ch == 0) {\n            (*_sym.imp.USER32.dll_SendMessageA)(arg_8h_00, Msg, wParam, lParam);\n        }\n        else {\n            iVar2 = fcn.00419dc8(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.0041a2fd(iVar2, *(iVar2 + 0x1c), Msg, wParam, lParam);\n            }\n        }\n        if (arg_18h != 0) {\n            iVar2 = (*pcVar1)(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.0041a554(arg_8h_00, Msg, wParam, lParam, arg_18h, arg_1ch);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 331
    },
    "0041ac69": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041ac69(int32_t arg_8h, uint arg_ch, int32_t *arg_10h)\n\n{\n    char cVar1;\n    int32_t *piVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint *puVar7;\n    int32_t iVar8;\n    code **ppcVar9;\n    code *pcVar10;\n    uint var_13ch;\n    uint var_10ch;\n    uchar var_dh;\n    uint32_t var_ch;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    iVar4 = fcn.0041d669(0x41ccb5);\n    if (arg_8h != 3) {\n        (*_sym.imp.USER32.dll_CallNextHookEx)(*(iVar4 + 0x28), arg_8h, arg_ch, arg_10h);\n        goto code_r0x0041ae7b;\n    }\n    piVar2 = *(iVar4 + 0x14);\n    iVar8 = *arg_10h;\n    iVar5 = fcn.0041d221();\n    cVar1 = *(iVar5 + 0x14);\n    if ((piVar2 != NULL) || (((*(iVar8 + 0x23) & 0x40) == 0 && (cVar1 == '\\0')))) {\n        if (*0x42ab28 == 0) {\ncode_r0x0041ad2c:\n            if (piVar2 == NULL) {\n                if (*0x42a9e8 == 0) {\n                    fcn.00409040(&var_13ch, 0, 0x30);\n                    var_13ch = 0x30;\n                    *0x42a9e8 = (*_sym.imp.USER32.dll_GetClassInfoExA)(0, \"#32768\", &var_13ch);\n                    if (*0x42a9e8 != 0) goto code_r0x0041adb2;\n                    iVar8 = (*_sym.imp.USER32.dll_GetClassNameA)(arg_ch, &var_10ch, 0x100);\n                    if (iVar8 != 0) {\n                        var_dh = 0;\n                        iVar8 = fcn.00407a2d(&var_10ch, \"#32768\");\n                        if (iVar8 == 0) goto code_r0x0041ae51;\n                    }\n                }\n                else {\ncode_r0x0041adb2:\n                    iVar3 = (*_sym.imp.USER32.dll_GetClassLongA)(arg_ch, 0xffffffe0);\n                    if (iVar3 == *0x42a9e8) goto code_r0x0041ae51;\n                }\n                var_ch = (*_sym.imp.USER32.dll_GetWindowLongA)(arg_ch, 0xfffffffc);\n                pcVar10 = _sym.imp.USER32.dll_GetPropA;\n                if ((var_ch != 0) && (iVar8 = (*_sym.imp.USER32.dll_GetPropA)(arg_ch, \"AfxOldWndProc423\"),  iVar8 == 0))\n                {\n                    (*_sym.imp.USER32.dll_SetPropA)(arg_ch, \"AfxOldWndProc423\", var_ch);\n                    uVar6 = (*pcVar10)(arg_ch, \"AfxOldWndProc423\");\n                    if (uVar6 == var_ch) {\n                        (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(\"AfxOldWndProc423\");\n                        (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, 0x41ab11);\n                    }\n                }\n            }\n            else {\n                fcn.00419de2(arg_ch);\n                (**(*piVar2 + 0x50))();\n                ppcVar9 = (**(*piVar2 + 0xf0))();\n                pcVar10 = (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, fcn.0041a3ea);\n                if (pcVar10 != fcn.0041a3ea) {\n                    *ppcVar9 = pcVar10;\n                }\n                *(iVar4 + 0x14) = 0;\n            }\n        }\n        else {\n            uVar6 = (*_sym.imp.USER32.dll_GetClassLongA)(arg_ch, 0xffffffe6);\n            if ((uVar6 & 0x10000) == 0) {\n                puVar7 = *(iVar8 + 0x28);\n                if (puVar7 < 0x10000) {\n                    var_ch = var_ch & 0xffffff00;\n                    (*_sym.imp.KERNEL32.dll_GlobalGetAtomNameA)(*(iVar8 + 0x28), &var_ch, 5);\n                    puVar7 = &var_ch;\n                }\n                iVar8 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(puVar7, 0x420504);\n                if (iVar8 != 0) goto code_r0x0041ad2c;\n            }\n        }\n    }\ncode_r0x0041ae51:\n    (*_sym.imp.USER32.dll_CallNextHookEx)(*(iVar4 + 0x28), 3, arg_ch, arg_10h);\n    if (cVar1 != '\\0') {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar4 + 0x28));\n        *(iVar4 + 0x28) = 0;\n    }\ncode_r0x0041ae7b:\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 1238
    },
    "0041ae88": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0041ae88(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    \n    iVar1 = fcn.0041d669(0x41ccb5);\n    if (*(iVar1 + 0x14) != unaff_retaddr) {\n        if (*(iVar1 + 0x28) == 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n            iVar3 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(5, fcn.0041ac69, 0, uVar2);\n            *(iVar1 + 0x28) = iVar3;\n            if (iVar3 == 0) {\n                fcn.0041798e();\n            }\n        }\n        *(iVar1 + 0x14) = unaff_retaddr;\n    }\n    return;\n}\n",
        "token_count": 204
    },
    "0041b00d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING (jumptable): Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_74h\n\nuint __cdecl fcn.0041b00d(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint uVar8;\n    int32_t *arg_8h_00;\n    uint *puVar9;\n    uint *puVar10;\n    int32_t unaff_EBP;\n    int16_t iVar11;\n    uint *in_FS_OFFSET;\n    int32_t *in_stack_ffffff70;\n    uint in_stack_ffffff84;\n    uint var_74h;\n    uint var_58h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    *(unaff_EBP + -0x10) = 0;\n    uVar7 = *(unaff_EBP + 8);\n    if (uVar7 == 0x111) {\n        iVar4 = (**(*arg_8h_00 + 0xe8))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n        if (iVar4 == 0) goto code_r0x0041b1f8;\ncode_r0x0041b4a8:\n        *(unaff_EBP + -0x10) = 1;\n        goto code_r0x0041b500;\n    }\n    if (uVar7 == 0x4e) {\n        if (**(unaff_EBP + 0x10) == 0) goto code_r0x0041b1f8;\n        iVar4 = (**(*arg_8h_00 + 0xec))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), unaff_EBP + -0x10);\ncode_r0x0041b4cc:\n        if (iVar4 == 0) goto code_r0x0041b1f8;\n        goto code_r0x0041b500;\n    }\n    puVar9 = *(unaff_EBP + 0x10);\n    if (uVar7 == 6) {\n        in_stack_ffffff84 = fcn.00419da1(puVar9);\n        fcn.0041aa3a(arg_8h_00, *(unaff_EBP + 0xc), in_stack_ffffff84);\n    }\n    iVar11 = puVar9;\n    if ((uVar7 == 0x20) &&\n       (in_stack_ffffff70 = arg_8h_00,  iVar4 = fcn.0041aa9b(arg_8h_00, iVar11, puVar9 >> 0x10),  iVar4 != 0))\n    goto code_r0x0041b4a8;\n    if (((arg_8h_00[0x12] != 0) && (0 < *(arg_8h_00[0x12] + 0x70))) &&\n       ((((0x1ff < uVar7 && (uVar7 < 0x20a)) || ((0xff < uVar7 && (uVar7 < 0x110)))) ||\n        ((0x280 < uVar7 && (uVar7 < 0x292)))))) {\n        in_stack_ffffff70 = *(unaff_EBP + 0xc);\n        iVar4 = (**(*arg_8h_00[0x12] + 0x94))(uVar7, in_stack_ffffff70, puVar9, unaff_EBP + -0x10);\n        if (iVar4 == 0) goto code_r0x0041b0ff;\n        goto code_r0x0041b500;\n    }\ncode_r0x0041b0ff:\n    uVar5 = (**(*arg_8h_00 + 0x28))();\n    *(unaff_EBP + -0x14) = uVar5;\n    uVar7 = *(unaff_EBP + 8);\n    fcn.0041d72b(7);\n    iVar4 = ((uVar5 ^ uVar7) & 0x1ff) * 0xc;\n    iVar6 = *(unaff_EBP + -0x14);\n    if ((*(unaff_EBP + 8) != *(iVar4 + 0x429078)) || (iVar6 != *(iVar4 + 0x429080))) {\n        *(iVar4 + 0x429078) = *(unaff_EBP + 8);\n        *(iVar4 + 0x429080) = iVar6;\n        while (iVar6 != 0) {\n            if (*(unaff_EBP + 8) < 0xc000) {\n                iVar6 = fcn.00418dc7(*(*(unaff_EBP + -0x14) + 4), *(unaff_EBP + 8), in_stack_ffffff70, 0);\n                *(unaff_EBP + 0x10) = iVar6;\n                if (iVar6 != 0) {\n                    *(iVar4 + 0x42907c) = iVar6;\n                    fcn.0041d78e(7);\n                    goto code_r0x0041b190;\n                }\n            }\n            else {\n                iVar6 = *(*(unaff_EBP + -0x14) + 4);\n                while( true ) {\n                    iVar6 = fcn.00418dc7(iVar6, 0xc000, 0, in_stack_ffffff84);\n                    *(unaff_EBP + 0x10) = iVar6;\n                    if (iVar6 == 0) break;\n                    if (**(*(unaff_EBP + 0x10) + 0x10) == *(unaff_EBP + 8)) {\n                        *(iVar4 + 0x42907c) = *(unaff_EBP + 0x10);\n                        fcn.0041d78e(7);\n                        goto code_r0x0041b4ef;\n                    }\n                    iVar6 = *(unaff_EBP + 0x10) + 0x18;\n                }\n            }\n            iVar6 = **(unaff_EBP + -0x14);\n            *(unaff_EBP + -0x14) = iVar6;\n        }\n        *(iVar4 + 0x42907c) = 0;\n        fcn.0041d78e(7);\ncode_r0x0041b1f8:\n        uVar8 = 0;\n        goto code_r0x0041b1fa;\n    }\n    iVar4 = *(iVar4 + 0x42907c);\n    *(unaff_EBP + 0x10) = iVar4;\n    fcn.0041d78e(7);\n    if (iVar4 == 0) goto code_r0x0041b1f8;\n    if (0xbfff < *(unaff_EBP + 8)) {\ncode_r0x0041b4ef:\n        uVar8 = (**(*(unaff_EBP + 0x10) + 0x14))(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x0041b4fd;\n    }\ncode_r0x0041b190:\n    pcVar1 = *(*(unaff_EBP + 0x10) + 0x14);\n    iVar4 = *(*(unaff_EBP + 0x10) + 0x10);\n    iVar3 = puVar9 >> 0x10;\n    // switch table (65 cases) at 0x41b514\n    switch(iVar4) {\n    case 1:\n        puVar9 = *(unaff_EBP + 0xc);\n        fcn.0041c63e(puVar9);\n        goto code_r0x0041b319;\n    case 2:\n    case 3:\n    case 4:\n    case 0x18:\n    case 0x19:\n        puVar9 = *(unaff_EBP + 0xc);\n        goto code_r0x0041b319;\n    case 5:\n    case 0xc:\n        uVar5 = puVar9 >> 0x10;\n        puVar9 = puVar9 & 0xffff;\n        uVar7 = *(unaff_EBP + 0xc);\n        uVar5 = fcn.00419da1(uVar7, puVar9, uVar5);\n        goto code_r0x0041b33d;\n    case 6:\n        uVar7 = fcn.00419da1(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x0041b452;\n    case 7:\n    case 0xd:\ncode_r0x0041b319:\n        uVar8 = (*pcVar1)(puVar9);\n        goto code_r0x0041b4fd;\n    case 8:\n        fcn.0041c3ce();\n        uVar8 = puVar9[1];\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x20) = uVar8;\n        fcn.004195b9();\n        uVar8 = *puVar9;\n        uVar2 = puVar9[2];\n        *(unaff_EBP + -4) = 1;\n        *(unaff_EBP + -0x58) = uVar8;\n        iVar4 = fcn.00419dc8(uVar8);\n        if (iVar4 == 0) {\n            if ((arg_8h_00[0x12] != 0) && (iVar4 = fcn.00417f85(*(unaff_EBP + -0x58)),  iVar4 != 0)) {\n                *(unaff_EBP + -0x28) = iVar4;\n            }\n            iVar4 = unaff_EBP + -0x74;\n        }\n        uVar8 = (*pcVar1)(unaff_EBP + -0x24, iVar4, uVar2);\n        *(unaff_EBP + -0x20) = 0;\n        *(unaff_EBP + -0x58) = 0;\n        *(unaff_EBP + -0x10) = uVar8;\n        *(unaff_EBP + -4) = 0;\n        fcn.0041a435();\n        goto code_r0x0041b2e8;\n    case 9:\n        fcn.0041c3ce();\n        uVar8 = puVar9[2];\n        *(unaff_EBP + -0x20) = puVar9[1];\n        *(unaff_EBP + -4) = 2;\n        uVar8 = (*pcVar1)(unaff_EBP + -0x24, uVar8);\n        *(unaff_EBP + -0x20) = 0;\n        *(unaff_EBP + -0x10) = uVar8;\ncode_r0x0041b2e8:\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0041c67d();\n        break;\n    case 10:\n        uVar7 = fcn.00419da1(puVar9, *(unaff_EBP + 0xc) >> 0x10);\n        goto code_r0x0041b338;\n    case 0xb:\n        puVar9 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0041b452;\n    case 0xe:\n    case 0x2c:\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0041b452;\n    case 0xf:\n        puVar9 = fcn.0041ba63(puVar9);\n        uVar7 = *(unaff_EBP + 0xc) >> 0x10;\ncode_r0x0041b338:\n        uVar5 = *(unaff_EBP + 0xc);\ncode_r0x0041b33d:\n        uVar8 = (*pcVar1)(uVar5, uVar7, puVar9);\n        goto code_r0x0041b4fd;\n    case 0x10:\n        (*pcVar1)();\n        break;\n    case 0x11:\n        puVar9 = *(unaff_EBP + 0xc);\n        goto code_r0x0041b472;\n    case 0x12:\n    case 0x1b:\n    case 0x2a:\n    case 0x2f:\n        goto code_r0x0041b465;\n    case 0x13:\n        puVar9 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0041b468;\n    case 0x14:\n        puVar9 = iVar3;\n        uVar7 = iVar11;\n        goto code_r0x0041b468;\n    case 0x15:\n    case 0x16:\n        puVar10 = puVar9 >> 0x10;\n        uVar7 = puVar9 & 0xffff;\n        goto code_r0x0041b496;\n    case 0x17:\n        fcn.00419da1(puVar9);\ncode_r0x0041b465:\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0041b468;\n    case 0x1a:\n    case 0x25:\n    case 0x2e:\n        uVar8 = (*pcVar1)();\n        goto code_r0x0041b4fd;\n    case 0x1c:\n        puVar10 = *(unaff_EBP + 0xc);\n        uVar7 = fcn.00419da1(puVar10);\n        fcn.00419da1(puVar9, uVar7);\n        uVar5 = arg_8h_00[7] == puVar9;\n        goto code_r0x0041b49a;\n    case 0x1d:\n        puVar9 = *(unaff_EBP + 0xc);\n        fcn.0041c63e(puVar9);\n        goto code_r0x0041b472;\n    case 0x1e:\n        puVar9 = *(unaff_EBP + 0xc);\n        fcn.0041ba63(puVar9);\n        goto code_r0x0041b472;\n    case 0x1f:\n        puVar10 = puVar9 >> 0x10;\n        uVar7 = puVar9 & 0xffff;\n        uVar5 = fcn.0041ba63(*(unaff_EBP + 0xc), uVar7, puVar10);\n        goto code_r0x0041b49a;\n    case 0x20:\n        puVar9 = *(unaff_EBP + 0xc);\n        goto code_r0x0041b3d5;\n    case 0x21:\ncode_r0x0041b3d5:\n        fcn.00419da1(puVar9);\n        goto code_r0x0041b472;\n    case 0x22:\n        puVar10 = puVar9 >> 0x10;\n        uVar7 = puVar9 & 0xffff;\n        goto code_r0x0041b3f1;\n    case 0x23:\n        uVar7 = iVar11;\n        puVar10 = iVar3;\ncode_r0x0041b3f1:\n        uVar5 = fcn.00419da1(*(unaff_EBP + 0xc), uVar7, puVar10);\n        goto code_r0x0041b49a;\n    case 0x24:\n        uVar7 = fcn.00419da1(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x0041b468;\n    case 0x26:\n        puVar10 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = fcn.00419da1(puVar9, puVar10);\n        goto code_r0x0041b482;\n    case 0x27:\n    case 0x28:\n        *(unaff_EBP + 8) = *(unaff_EBP + 0xc);\n        *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc) >> 0x10;\n        if (iVar4 == 0x27) {\n            uVar7 = fcn.00419da1(puVar9);\n            uVar5 = *(unaff_EBP + 0xc);\n            puVar10 = puVar9;\n            goto code_r0x0041b49a;\n        }\n        puVar9 = *(unaff_EBP + 0xc);\n        uVar7 = *(unaff_EBP + 8);\ncode_r0x0041b468:\n        (*pcVar1)(uVar7, puVar9);\n        break;\n    case 0x29:\n    case 0x30:\ncode_r0x0041b472:\n        (*pcVar1)(puVar9);\n        break;\n    case 0x2b:\n    case 0x33:\n        (*pcVar1)(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x0041b4a8;\n    case 0x2d:\n        uVar7 = iVar11;\n        puVar9 = iVar3;\ncode_r0x0041b452:\n        uVar8 = (*pcVar1)(uVar7, puVar9);\ncode_r0x0041b4fd:\n        *(unaff_EBP + -0x10) = uVar8;\n        break;\n    case 0x31:\n        uVar7 = *(unaff_EBP + 0xc) >> 0x10;\n        puVar10 = puVar9;\ncode_r0x0041b482:\n        uVar5 = *(unaff_EBP + 0xc);\n        goto code_r0x0041b49a;\n    case 0x32:\n        uVar7 = iVar11;\n        puVar10 = iVar3;\ncode_r0x0041b496:\n        uVar5 = *(unaff_EBP + 0xc);\ncode_r0x0041b49a:\n        (*pcVar1)(uVar5, uVar7, puVar10);\n        break;\n    case 0x34:\n        iVar4 = (*pcVar1)(*(unaff_EBP + 0xc), *(unaff_EBP + 0xc) >> 0x10, puVar9 & 0xffff, puVar9 >> 0x10);\n        *(unaff_EBP + -0x10) = iVar4;\n        goto code_r0x0041b4cc;\n    case 0x41:\n        iVar4 = (*pcVar1)();\n        *(unaff_EBP + -0x10) = iVar4;\n        if (iVar4 != 0) goto code_r0x0041b1f8;\n    }\ncode_r0x0041b500:\n    if (*(unaff_EBP + 0x14) != NULL) {\n        **(unaff_EBP + 0x14) = *(unaff_EBP + -0x10);\n    }\n    uVar8 = 1;\ncode_r0x0041b1fa:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar8;\n}\n",
        "token_count": 4415
    },
    "0041b9e7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0041b9e7(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    iVar1 = fcn.0041d247();\n    if ((*(iVar1 + 0x18) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.004182c3(0x41c1e6);\n        iVar3 = fcn.004182d5(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.004189ae(0x420684, 0x41e106, 0x41e0de, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x18) = uVar4;\n        fcn.004182c3(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x18);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 367
    },
    "0041bacb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041bacb(uint lpString2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalLock;\n    if (*(in_ECX + 0x70) != 0) {\n        var_4h = in_ECX;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(in_ECX + 0x70));\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(*(iVar2 + 2) + iVar2, lpString2);\n        if ((iVar2 == 0) && (iVar2 = sub.WINSPOOL.DRV_OpenPrinterA(lpString2, &var_4h, 0),  iVar2 != 0)) {\n            if (*(in_ECX + 0x6c) != 0) {\n                fcn.0041c1b6(*(in_ECX + 0x6c));\n            }\n            uVar3 = sub.WINSPOOL.DRV_DocumentPropertiesA(0, var_4h, lpString2, 0, 0, 0);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x42, uVar3);\n            *(in_ECX + 0x6c) = uVar3;\n            uVar3 = (*pcVar1)(uVar3);\n            iVar2 = sub.WINSPOOL.DRV_DocumentPropertiesA(0, var_4h, lpString2, uVar3, 0, 2);\n            if (iVar2 != 1) {\n                fcn.0041c1b6(*(in_ECX + 0x6c));\n                *(in_ECX + 0x6c) = 0;\n            }\n            sub.WINSPOOL.DRV_ClosePrinter(var_4h);\n        }\n    }\n    return;\n}\n",
        "token_count": 436
    },
    "0041bb69": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041bb69(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    if ((arg_ch == 0) || (arg_8h == 0)) {\n        iVar1 = 0;\n    }\n    else {\n        if ((*(in_ECX + 0x18) & 1) == 0) {\n            fcn.0041c0f2(4, *(in_ECX + 0x14));\n        }\n        uVar3 = *(in_ECX + 0x2c) - *(in_ECX + 0x28);\n        if (arg_ch < uVar3) {\n            uVar3 = arg_ch;\n        }\n        fcn.004085f0(arg_8h, *(in_ECX + 0x28), uVar3);\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + uVar3;\n        arg_8h = arg_8h + uVar3;\n        uVar3 = arg_ch - uVar3;\n        if (uVar3 != 0) {\n            iVar1 = uVar3 - uVar3 % *(in_ECX + 0x20);\n            var_8h = 0;\n            var_4h = iVar1;\n            do {\n                iVar2 = (**(**(in_ECX + 0x24) + 0x34))(arg_8h, var_4h);\n                arg_8h = arg_8h + iVar2;\n                var_8h = var_8h + iVar2;\n                var_4h = var_4h - iVar2;\n                if (iVar2 == 0) break;\n            } while (var_4h != 0);\n            uVar3 = uVar3 - var_8h;\n            if ((uVar3 != 0) && (var_8h == iVar1)) {\n                uVar4 = 0;\n                if (*(in_ECX + 8) == 0) {\n                    if ((*(in_ECX + 0xc) != 0) || (var_4h = *(in_ECX + 0x20),  *(in_ECX + 0x20) < uVar3)) {\n                        var_4h = uVar3;\n                    }\n                    var_8h = *(in_ECX + 0x30);\n                    do {\n                        iVar1 = (**(**(in_ECX + 0x24) + 0x34))(var_8h, var_4h);\n                        var_8h = var_8h + iVar1;\n                        var_4h = var_4h - iVar1;\n                        uVar4 = uVar4 + iVar1;\n                        if ((iVar1 == 0) || (var_4h == 0)) break;\n                    } while (uVar4 < uVar3);\n                    iVar1 = *(in_ECX + 0x30);\n                    *(in_ECX + 0x2c) = iVar1 + uVar4;\n                }\n                else {\n                    (**(**(in_ECX + 0x24) + 0x50))(0, *(in_ECX + 0x20), in_ECX + 0x30, in_ECX + 0x2c);\n                    iVar1 = *(in_ECX + 0x30);\n                }\n                uVar4 = *(in_ECX + 0x2c) - iVar1;\n                *(in_ECX + 0x28) = iVar1;\n                if (uVar3 < uVar4) {\n                    uVar4 = uVar3;\n                }\n                fcn.004085f0(arg_8h, iVar1, uVar4);\n                *(in_ECX + 0x28) = *(in_ECX + 0x28) + uVar4;\n                uVar3 = uVar3 - uVar4;\n            }\n        }\n        iVar1 = arg_ch - uVar3;\n    }\n    return iVar1;\n}\n",
        "token_count": 934
    },
    "0041bd0d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041bd0d(uint32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    uint32_t arg_8h_00;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint unaff_EBX;\n    int32_t iVar4;\n    uint unaff_ESI;\n    int32_t iVar6;\n    uint var_8h;\n    uint32_t var_4h;\n    uint32_t uVar5;\n    \n    if ((*(in_ECX + 0x18) & 1) != 0) {\n        uVar5 = *(in_ECX + 0x28);\n        piVar1 = in_ECX + 0x2c;\n        var_4h = *piVar1 - uVar5;\n        uVar2 = arg_8h + var_4h;\n        if (*(in_ECX + 8) == 0) {\n            arg_8h_00 = *(in_ECX + 0x30);\n            if (arg_8h_00 < uVar5) {\n                if (0 < var_4h) {\n                    fcn.004072a0(arg_8h_00, uVar5, var_4h);\n                    arg_8h_00 = *(in_ECX + 0x30);\n                    *(in_ECX + 0x28) = arg_8h_00;\n                    *piVar1 = arg_8h_00 + var_4h;\n                }\n                uVar5 = arg_8h;\n                if (*(in_ECX + 0xc) == 0) {\n                    uVar5 = *(in_ECX + 0x20);\n                }\n                iVar4 = uVar5 - var_4h;\n                iVar6 = var_4h + arg_8h_00;\n                do {\n                    iVar3 = (**(**(in_ECX + 0x24) + 0x34))(iVar6, iVar4);\n                    var_4h = var_4h + iVar3;\n                    iVar6 = iVar6 + iVar3;\n                    iVar4 = iVar4 - iVar3;\n                    if ((iVar3 == 0) || (iVar4 == 0)) break;\n                } while (var_4h < arg_8h);\n                *(in_ECX + 0x28) = *(in_ECX + 0x30);\n                *(in_ECX + 0x2c) = *(in_ECX + 0x30) + var_4h;\n            }\n        }\n        else {\n            if (var_4h != 0) {\n                (**(**(in_ECX + 0x24) + 0x28))(-var_4h, -var_4h >> 0x1f, 1);\n            }\n            (**(**(in_ECX + 0x24) + 0x50))(0, *(in_ECX + 0x20), in_ECX + 0x30, piVar1);\n            *(in_ECX + 0x28) = *(in_ECX + 0x30);\n        }\n        if (uVar2 <= *(in_ECX + 0x2c) - *(in_ECX + 0x28)) {\n            return;\n        }\n        unaff_EBX = 0;\n        unaff_ESI = 3;\n    }\n    fcn.0041c0f2(unaff_ESI, unaff_EBX);\n    return;\n}\n",
        "token_count": 768
    },
    "0041bdf5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0041bdf5(uint arg_8h, uint *arg_ch)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    uint *var_8h;\n    int32_t var_4h;\n    \n    puVar2 = arg_ch;\n    *arg_ch = 1;\n    fcn.00406461(&arg_ch + 3);\n    if (arg_ch._3_1_ == -1) {\n        fcn.00406362(&arg_8h + 2);\n        if (arg_8h._2_2_ == -2) {\n            *puVar2 = 2;\n            fcn.00406461(&arg_ch + 3);\n            if (arg_ch._3_1_ != -1) goto code_r0x0041be43;\n            fcn.00406362(&arg_8h + 2);\n        }\n        if (arg_8h._2_2_ == 0xffff) {\n            fcn.004063a5(&arg_ch);\n            puVar2 = arg_ch;\n            if (arg_ch == 0xffffffff) {\n                fcn.004064a0(&var_8h);\n                if ((var_4h != 0) || (puVar2 = var_8h,  0x7fffffff < var_8h)) {\n                    fcn.0041c0f2(1, 0);\n                    pcVar1 = swi(3);\n                    puVar2 = (*pcVar1)();\n                    return puVar2;\n                }\n            }\n        }\n        else {\n            puVar2 = arg_8h._2_2_;\n        }\n    }\n    else {\ncode_r0x0041be43:\n        puVar2 = arg_ch >> 0x18;\n    }\n    return puVar2;\n}\n",
        "token_count": 401
    },
    "0041bf1f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041bf1f(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    uint32_t arg_10h;\n    int32_t iVar1;\n    \n    if ((arg_ch != 0) && (arg_8h != 0)) {\n        if ((~*(in_ECX + 0x18) & 1) == 0) {\n            fcn.0041c0f2(2, *(in_ECX + 0x14));\n        }\n        arg_10h = *(in_ECX + 0x2c) - *(in_ECX + 0x28);\n        if (arg_ch < arg_10h) {\n            arg_10h = arg_ch;\n        }\n        fcn.004085f0(*(in_ECX + 0x28), arg_8h, arg_10h);\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + arg_10h;\n        arg_ch = arg_ch - arg_10h;\n        if (arg_ch != 0) {\n            fcn.0041bc96();\n            iVar1 = arg_ch - arg_ch % *(in_ECX + 0x20);\n            (**(**(in_ECX + 0x24) + 0x38))(arg_8h + arg_10h, iVar1);\n            if (*(in_ECX + 8) != 0) {\n                (**(**(in_ECX + 0x24) + 0x50))(1, *(in_ECX + 0x20), in_ECX + 0x30, in_ECX + 0x2c);\n                *(in_ECX + 0x28) = *(in_ECX + 0x30);\n            }\n            fcn.004085f0(*(in_ECX + 0x28), arg_8h + arg_10h + iVar1, arg_ch - iVar1);\n            *(in_ECX + 0x28) = *(in_ECX + 0x28) + (arg_ch - iVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 474
    },
    "0041c5c2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0041c5c2(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    iVar1 = fcn.0041d247();\n    if ((*(iVar1 + 0x1c) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.004182c3(0x41c1e6);\n        iVar3 = fcn.004182d5(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.004189ae(0x420548, 0x41e059, 0x41e0de, 4, 2);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x1c) = uVar4;\n        fcn.004182c3(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x1c);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 370
    },
    "0041c67d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041c67d(code **param_1)\n\n{\n    uint uVar1;\n    \n    *param_1 = vtable.CDC.0;\n    if (param_1[1] != NULL) {\n        uVar1 = fcn.0041c64c();\n        (*_sym.imp.GDI32.dll_DeleteDC)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 88
    },
    "0041c696": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0041c696(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    iVar1 = fcn.0041d247();\n    if ((*(iVar1 + 0x20) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.004182c3(0x41c1e6);\n        iVar3 = fcn.004182d5(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.004189ae(0x420520, 0x41e075, 0x41e0de, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x20) = uVar4;\n        fcn.004182c3(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x20);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 365
    },
    "0041c80a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0041c80a(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = fcn.004062d7();\n    if (piVar1 != NULL) {\n        iVar2 = (**(*piVar1 + 0x120))();\n        if ((iVar2 != 0) && (piVar1[0x1f] != 0)) {\n    // WARNING: Could not recover jumptable at 0x0041c830. Too many branches\n    // WARNING: Treating indirect jump as call\n            (**(*piVar1[0x1f] + 100))();\n            return;\n        }\n    }\n    return;\n}\n",
        "token_count": 156
    },
    "0041ca08": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0041c93b)\n// WARNING: Removing unreachable block (ram,0x0041c98c)\n\nvoid fcn.0041ca08(uint param_1, uint32_t param_2, int32_t param_3)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iStack276;\n    int32_t iStack272;\n    uchar auStack268 [259];\n    uchar uStack9;\n    uint uStack8;\n    \n    uStack8 = 0x41ca10;\n    iVar4 = fcn.0041d221();\n    if (*(iVar4 + 4) != NULL) {\n    // WARNING: Could not recover jumptable at 0x0041ca1c. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(**(iVar4 + 4) + 0x98))();\n        return;\n    }\n    uStack8 = *0x427850;\n    fcn.0041c80a(0);\n    iVar4 = fcn.0041c837(0, &stack0xfffffef0);\n    if (iVar4 != iStack272) {\n        (*_sym.imp.USER32.dll_EnableWindow)(iVar4, 1);\n    }\n    if ((iVar4 == 0) || (piVar1 = (*_sym.imp.USER32.dll_SendMessageA)(iVar4, 0x376, 0, 0),  piVar1 == NULL)) {\n        piVar1 = NULL;\n    }\n    iStack276 = 0;\n    if ((piVar1 != NULL) && (iStack276 = *piVar1,  param_3 != 0)) {\n        *piVar1 = param_3 + 0x30000;\n    }\n    if (((param_2 & 0xf0) == 0) && ((uVar2 = param_2 & 0xf,  uVar2 < 2 || ((2 < uVar2 && (uVar2 < 5)))))) {\n        param_2 = param_2 | 0x30;\n    }\n    auStack268[0] = 0;\n    iVar3 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, &stack0xfffffef4, 0x104);\n    if (iVar3 == 0x104) {\n        uStack9 = 0;\n    }\n    (*_sym.imp.USER32.dll_MessageBoxA)(iVar4, param_1, &stack0xfffffef4, param_2);\n    if (piVar1 != NULL) {\n        *piVar1 = iStack276;\n    }\n    if (iStack272 != 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(iStack272, 1);\n    }\n    fcn.0041c80a(1);\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 654
    },
    "0041ca8c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041ca8c(int32_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    \n    iVar4 = 0;\n    uVar1 = *arg_ch;\n    puVar5 = arg_ch;\n    while (uVar1 != 0) {\n        if (*puVar5 == 0x25) {\n            uVar1 = puVar5[1];\n            if ((uVar1 < '1') || ('9' < uVar1)) {\n                if ((uVar1 < 'A') || ('Z' < uVar1)) goto code_r0x0041cae5;\n                if (uVar1 < ':') goto code_r0x0041cac3;\n                iVar3 = uVar1 + -0x38;\n            }\n            else {\ncode_r0x0041cac3:\n                iVar3 = uVar1 + -0x31;\n            }\n            puVar5 = puVar5 + 2;\n            if (arg_14h <= iVar3) goto code_r0x0041caf4;\n            iVar3 = *(arg_10h + iVar3 * 4);\n            if (iVar3 != 0) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(iVar3);\n                iVar4 = iVar4 + iVar3;\n            }\n        }\n        else {\ncode_r0x0041cae5:\n            if ((*(*puVar5 + 0x42c3e1) & 4) != 0) {\n                iVar4 = iVar4 + 1;\n                puVar5 = puVar5 + 1;\n            }\n            puVar5 = puVar5 + 1;\ncode_r0x0041caf4:\n            iVar4 = iVar4 + 1;\n        }\n        uVar1 = *puVar5;\n    }\n    puVar5 = fcn.00403590(iVar4);\n    do {\n        while( true ) {\n            if (*arg_ch == 0) {\n                fcn.00405e82(puVar5 - *arg_8h);\n                return;\n            }\n            uVar1 = *arg_ch;\n            if (uVar1 == 0x25) break;\ncode_r0x0041cb5f:\n            if ((*(uVar1 + 0x42c3e1) & 4) != 0) {\n                *puVar5 = uVar1;\n                puVar5 = puVar5 + 1;\n                arg_ch = arg_ch + 1;\n            }\n            *puVar5 = *arg_ch;\n            puVar5 = puVar5 + 1;\n            arg_ch = arg_ch + 1;\n        }\n        uVar2 = arg_ch[1];\n        if ((uVar2 < '1') || ('9' < uVar2)) {\n            if ((uVar2 < 'A') || ('Z' < uVar2)) goto code_r0x0041cb5f;\n            if (uVar2 < ':') goto code_r0x0041cb2f;\n            iVar4 = uVar2 + -0x38;\n        }\n        else {\ncode_r0x0041cb2f:\n            iVar4 = uVar2 + -0x31;\n        }\n        arg_ch = arg_ch + 2;\n        if (iVar4 < arg_14h) {\n            iVar4 = *(arg_10h + iVar4 * 4);\n            if (iVar4 != 0) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyA)(puVar5, iVar4);\n                iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(puVar5);\n                puVar5 = puVar5 + iVar4;\n            }\n        }\n        else {\n            *puVar5 = 0x3f;\n            puVar5 = puVar5 + 1;\n        }\n    } while( true );\n}\n",
        "token_count": 901
    },
    "0041d032": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041d032(code **param_1)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    \n    *param_1 = vtable.AFX_MODULE_THREAD_STATE.0;\n    if (param_1[0xf] != NULL) {\n        (**(*param_1[0xf] + 0x138))();\n    }\n    if (param_1[5] != NULL) {\n        (***param_1[5])(1);\n    }\n    if (param_1[6] != NULL) {\n        (***param_1[6])(1);\n    }\n    if (param_1[7] != NULL) {\n        (***param_1[7])(1);\n    }\n    if (param_1[8] != NULL) {\n        (***param_1[8])(1);\n    }\n    if (param_1[9] != NULL) {\n        (***param_1[9])(1);\n    }\n    pcVar2 = param_1[0xe];\n    if (pcVar2 != NULL) {\n        while (*(pcVar2 + 0xc) != 0) {\n            uVar1 = fcn.00417c8d();\n            fcn.00418300(uVar1);\n            pcVar2 = param_1[0xe];\n        }\n    }\n    if (param_1[0xc] != NULL) {\n        (**(*param_1[0xc] + 4))(1);\n    }\n    if (param_1[0xd] != NULL) {\n        (**(*param_1[0xd] + 4))(1);\n    }\n    if (param_1[0xe] != NULL) {\n        (**(*param_1[0xe] + 4))(1);\n    }\n    return;\n}\n",
        "token_count": 390
    },
    "0041d2a2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0041d2a2(int32_t param_1)\n\n{\n    if (param_1 != 0) {\n    // WARNING: Could not recover jumptable at 0x0041d2a9. Too many branches\n    // WARNING: Treating indirect jump as call\n        (*_sym.imp.KERNEL32.dll_LocalFree)();\n        return;\n    }\n    return;\n}\n",
        "token_count": 87
    },
    "0041d460": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041d460(int32_t *param_1)\n\n{\n    uint var_4h;\n    \n    if (*param_1 != 0) {\n        if (*param_1 != NULL) {\n            (****param_1)(1);\n        }\n    }\n    return;\n}\n",
        "token_count": 66
    },
    "0041d669": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.0041d669(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    if (*extraout_ECX == 0) {\n        if (*0x428e38 == 0) {\n            *(unaff_EBP + -0x10) = 0x428e3c;\n            *(unaff_EBP + -4) = 0;\n            *0x428e38 = fcn.0041d4a1();\n            *(unaff_EBP + -4) = 0xffffffff;\n        }\n        iVar1 = fcn.0041d2b2();\n        *extraout_ECX = iVar1;\n    }\n    iVar1 = fcn.0041d3be(*extraout_ECX);\n    if (iVar1 == 0) {\n        iVar1 = (**(unaff_EBP + 8))();\n        fcn.0041d546(*extraout_ECX, iVar1);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1;\n}\n",
        "token_count": 334
    },
    "0041d707": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t fcn.0041d707(void)\n\n{\n    if (*0x429068 == 0) {\n        *0x429068 = 1;\n        (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(0x428eb4);\n    }\n    return *0x429068;\n}\n",
        "token_count": 66
    },
    "0041d72b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0041d72b(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    \n    if (*0x429068 == 0) {\n        fcn.0041d707();\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_EnterCriticalSection;\n    piVar1 = param_1 * 4 + 0x428e70;\n    if (*piVar1 == 0) {\n        (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(0x428eb4);\n        if (*piVar1 == 0) {\n            (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(param_1 * 0x18 + 0x428ed0);\n            *piVar1 = *piVar1 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(0x428eb4);\n    }\n    (*pcVar2)(param_1 * 0x18 + 0x428ed0);\n    return;\n}\n",
        "token_count": 224
    },
    "0041dedb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041dedb(code **param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    *param_1 = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.2.0;\n    param_1[1] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.1.0;\n    param_1[4] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.0;\n    param_1[5] = 0xc0000001;\n    fcn.00406f1d();\n    iVar2 = fcn.0041d221();\n    iVar2 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(iVar2 + 0x2c);\n    if (iVar2 != 0) {\n        return;\n    }\n    iVar2 = fcn.0041d221();\n    if (*(iVar2 + 0x30) == 0) {\n        fcn.0041cc29(1);\n        iVar2 = fcn.0041d221();\n        iVar2 = *(iVar2 + 4);\n        if ((iVar2 == 0) || (*(iVar2 + 0x1c) == 0)) {\n            iVar2 = fcn.0041d221();\n            if (*(iVar2 + 0x14) == '\\0') {\n                fcn.0041e3b6(0);\n            }\n        }\n        else {\n            iVar1 = fcn.0041849f();\n            if (iVar1 != 0) {\n    // WARNING: Could not recover jumptable at 0x0041cc6d. Too many branches\n    // WARNING: Treating indirect jump as call\n                (**(**(iVar2 + 0x1c) + 0x60))();\n                return;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 416
    },
    "0041e21a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0041e21a(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    if (param_1[2] != 0) {\n        iVar1 = (**(*param_1[2] + 8))(param_1[2]);\n        return iVar1;\n    }\n    if (param_1[1] == 0) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(param_1 + 1);\n    if (iVar1 == 0) {\n        (**(*param_1 + 0x10))();\n    }\n    return iVar1;\n}\n",
        "token_count": 150
    },
    "0041e2dd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041e2dd(uint arg_8h)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    uint var_8h;\n    int32_t var_4h;\n    \n    piVar2 = (**(*in_ECX + 0x38))();\n    do {\n        for (piVar3 = piVar2[1]; *piVar3 != 0; piVar3 = piVar3 + 2) {\n        }\n        for (piVar3 = piVar3 + 1; *piVar3 != -1; piVar3 = piVar3 + 2) {\n            puVar1 = *(in_ECX + *piVar3);\n            if (puVar1 != NULL) {\n                var_4h = 0;\n                iVar4 = (***puVar1)(puVar1, arg_8h, &var_4h);\n                if ((iVar4 == 0) && (var_4h != 0)) {\n                    return var_4h;\n                }\n            }\n        }\n        piVar2 = *piVar2;\n        if (piVar2 == NULL) {\n            return 0;\n        }\n    } while( true );\n}\n",
        "token_count": 294
    },
    "00409925": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00409925(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *arg_8h_00;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x4207e0, 0x14);\n    *(unaff_EBP + -0x20) = 0xffffffff;\n    fcn.0040a06b(0xd);\n    *(unaff_EBP + -4) = 0;\n    *0x42ab5c = 0;\n    iVar1 = *(unaff_EBP + 8);\n    if (iVar1 == -2) {\n        *0x42ab5c = 1;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetOEMCP)();\n    }\n    else if (iVar1 == -3) {\n        *0x42ab5c = 1;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetACP)();\n    }\n    else if (iVar1 == -4) {\n        *0x42ab5c = 1;\n        iVar1 = *0x42af88;\n    }\n    *(unaff_EBP + 8) = iVar1;\n    arg_8h_00 = *0x42c3c4;\n    if (iVar1 == *0x42c4e4) {\n        *(unaff_EBP + -0x20) = 0;\n    }\n    else {\n        *(unaff_EBP + -0x24) = *0x42c3c4;\n        if ((arg_8h_00 == NULL) || (*arg_8h_00 != 0)) {\n            arg_8h_00 = fcn.00407684(0x220);\n            *(unaff_EBP + -0x24) = arg_8h_00;\n        }\n        if (arg_8h_00 != NULL) {\n            iVar1 = fcn.00409795(*(unaff_EBP + 8));\n            *(unaff_EBP + -0x20) = iVar1;\n            if (iVar1 == 0) {\n                *arg_8h_00 = 0;\n                arg_8h_00[1] = *0x42c4e4;\n                arg_8h_00[2] = *0x42c3c8;\n                arg_8h_00[3] = *0x42c3c0;\n                for (iVar1 = 0; *(unaff_EBP + -0x1c) = iVar1,  iVar1 < 5; iVar1 = iVar1 + 1) {\n                    *(arg_8h_00 + iVar1 * 2 + 0x10) = *(iVar1 * 2 + 0x42c4f0);\n                }\n                for (iVar1 = 0; *(unaff_EBP + -0x1c) = iVar1,  iVar1 < 0x101; iVar1 = iVar1 + 1) {\n                    *(iVar1 + 0x1c + arg_8h_00) = *(iVar1 + 0x42c3e0);\n                }\n                for (iVar1 = 0; *(unaff_EBP + -0x1c) = iVar1,  *0x42c3c4 = arg_8h_00,  iVar1 < 0x100; iVar1 = iVar1 + 1)\n                {\n                    *(iVar1 + 0x11d + arg_8h_00) = *(iVar1 + 0x42c500);\n                }\n            }\n        }\n        if ((*(unaff_EBP + -0x20) == -1) && (arg_8h_00 != *0x42c3c4)) {\n            fcn.00407696(arg_8h_00);\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00409a6c();\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 931
    },
    "0040c647": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040c647(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *arg_8h_00;\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00408fec(0x420ad0, 0x14);\n    if ((-1 < *(unaff_EBP + 8)) && (*(unaff_EBP + 8) < 6)) {\n        fcn.0040a06b(0xc);\n        *(unaff_EBP + -4) = 0;\n        if (*(unaff_EBP + 0xc) == 0) {\n            fcn.0040c46e();\n            fcn.0040782e(unaff_EBP + -0x10, 0xffffffff);\n        }\n        else {\n            arg_8h_00 = fcn.00407684(0x54);\n            *(unaff_EBP + -0x24) = arg_8h_00;\n            if (arg_8h_00 == NULL) {\n                *(unaff_EBP + -0x1c) = 0;\n            }\n            else {\n                iVar1 = fcn.0040c46e();\n                *(unaff_EBP + -0x1c) = iVar1;\n                if (iVar1 != 0) {\n                    *arg_8h_00 = 0;\n                    arg_8h_00[1] = *0x42af88;\n                    arg_8h_00[2] = *0x42af8c;\n                    for (iVar1 = 0; *(unaff_EBP + -0x20) = iVar1,  iVar1 < 6; iVar1 = iVar1 + 1) {\n                        arg_8h_00[iVar1 + 3] = *(iVar1 * 4 + 0x42af70);\n                    }\n                    arg_8h_00[9] = *0x428328;\n                    arg_8h_00[10] = *0x428440;\n                    arg_8h_00[0xb] = *0x42b24c;\n                    arg_8h_00[0xc] = *0x42b250;\n                    arg_8h_00[0xd] = *0x42b248;\n                    arg_8h_00[0xe] = *0x428434;\n                    arg_8h_00[0xf] = *0x42afa4;\n                    arg_8h_00[0x10] = *0x42b244;\n                    arg_8h_00[0x11] = *0x42b240;\n                    arg_8h_00[0x12] = *0x428330;\n                    arg_8h_00[0x13] = *0x428340;\n                    arg_8h_00[0x14] = *0x42afa0;\n                    if ((**0x427c8c == 0) && (*0x427c8c != 0x427c38)) {\n                        fcn.0040bcaa(*0x427c8c);\n                    }\n                    *0x427c8c = arg_8h_00;\n                    fcn.0040bd7a();\n                }\n            }\n            if ((*(unaff_EBP + -0x1c) == 0) && (arg_8h_00 != NULL)) {\n                fcn.00407696(arg_8h_00);\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0040c790();\n        }\n    }\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 859
    },
    "004135bf": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004135bf(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    uint *puVar6;\n    uint var_100ch;\n    uint var_1008h;\n    uint var_1004h;\n    uint uStack40;\n    int32_t iStack36;\n    int32_t iStack32;\n    uint *puStack28;\n    uint *puStack24;\n    int32_t iStack20;\n    uint var_4h;\n    \n    fcn.004079f0();\n    iStack20 = 0;\n    puStack24 = arg_8h;\n    puStack28 = 0x4135e3;\n    iVar1 = fcn.0040ff11();\n    if (iVar1 != -1) {\n        iStack20 = 0;\n        puStack24 = arg_8h;\n        puStack28 = 0x413602;\n        iVar2 = fcn.0040ff11();\n        if (iVar2 != -1) {\n            iVar2 = arg_ch - iVar2;\n            if (iVar2 < 1) {\n                if (iVar2 < 0) {\n                    iStack20 = 0;\n                    puStack24 = arg_ch;\n                    puStack28 = arg_8h;\n                    iStack32 = 0x4136a1;\n                    fcn.0040ff11();\n                    iStack32 = arg_8h;\n                    iStack36 = 0x4136a9;\n                    iStack20 = fcn.00411c9b();\n                    puStack24 = 0x4136b3;\n                    iVar2 = (*_sym.imp.KERNEL32.dll_SetEndOfFile)();\n                    if (iVar2 == 0) {\n                        iStack20 = 0x4136c5;\n                        puVar6 = fcn.00409c85();\n                        *puVar6 = 0xd;\n                        iStack20 = 0x4136d0;\n                        puVar6 = fcn.00409c8e();\n                        iStack20 = 0x4136d8;\n                        uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        *puVar6 = uVar3;\n                    }\n                }\n            }\n            else {\n                iStack20 = 0x1000;\n                puStack28 = &fcn.004135bf::var_1004h;\n                puStack24 = NULL;\n                iStack32 = 0x41362a;\n                fcn.00409040();\n                iStack32 = 0x8000;\n                iStack36 = arg_8h;\n                uStack40 = 0x413637;\n                uVar3 = fcn.004144d1();\n                do {\n                    iStack20 = 0x1000;\n                    if (iVar2 < 0x1000) {\n                        iStack20 = iVar2;\n                    }\n                    puStack24 = &fcn.004135bf::var_1004h;\n                    puStack28 = arg_8h;\n                    iStack32 = 0x413658;\n                    iVar4 = fcn.00410030();\n                    if (iVar4 == -1) {\n                        iStack20 = 0x41366d;\n                        piVar5 = fcn.00409c8e();\n                        if (*piVar5 == 5) {\n                            iStack20 = 0x413677;\n                            puVar6 = fcn.00409c85();\n                            *puVar6 = 0xd;\n                        }\n                        break;\n                    }\n                    iVar2 = iVar2 - iVar4;\n                } while (0 < iVar2);\n                puStack24 = arg_8h;\n                puStack28 = 0x41368e;\n                iStack20 = uVar3;\n                fcn.004144d1();\n            }\n            iStack20 = 0;\n            puStack28 = arg_8h;\n            iStack32 = 0x4136ea;\n            puStack24 = iVar1;\n            fcn.0040ff11();\n        }\n    }\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 938
    },
    "00401100": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/77a25ea9f6f245cfb8807f7953974472",
            "validate payment card number using luhn algorithm with no lookup table/101d11b5106849ad963488c88a9294b9"
        ],
        "decompiled_code": "\nint32_t fcn.00401100(char *param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    cVar1 = *param_1;\n    while (cVar1 != '\\0') {\n        param_1 = param_1 + 1;\n        iVar2 = cVar1 + -0x30 + iVar2 * 10;\n        cVar1 = *param_1;\n    }\n    return iVar2;\n}\n",
        "token_count": 108
    },
    "004033b0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.004033b0(int32_t *param_1, uint *param_2, uint32_t param_3, uint *param_4)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    \n    if (param_2 != NULL) goto code_r0x004033cf;\n    if (param_3 == 0) goto code_r0x004033cf;\n    do {\n        fcn.004010c0();\ncode_r0x004033cf:\n        iVar1 = (***param_4)(param_3, 1);\n        if (iVar1 == 0) {\n            iVar1 = fcn.00403130();\n        }\n        *param_1 = iVar1 + 0x10;\n    } while ((param_3 < 0) || (*(iVar1 + 8) < param_3));\n    *(iVar1 + 4) = param_3;\n    *(param_3 + *param_1) = 0;\n    puVar3 = *param_1;\n    for (uVar2 = param_3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {\n        *puVar3 = *param_2;\n        param_2 = param_2 + 1;\n        puVar3 = puVar3 + 1;\n    }\n    for (param_3 = param_3 & 3; param_3 != 0; param_3 = param_3 - 1) {\n        *puVar3 = *param_2;\n        param_2 = param_2 + 1;\n        puVar3 = puVar3 + 1;\n    }\n    return param_1;\n}\n",
        "token_count": 386
    },
    "00403470": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nulong fcn.00403470(int32_t **param_1)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    int32_t **ppiVar6;\n    int32_t **ppiVar7;\n    ulong uVar8;\n    \n    piVar2 = (**(**param_1 + 0x10))();\n    ppiVar6 = param_1 + 3;\n    if ((-1 < param_1[3]) && (piVar2 == *param_1)) {\n        LOCK();\n        piVar2 = *ppiVar6;\n        *ppiVar6 = *ppiVar6 + 1;\n        return CONCAT44(piVar2, param_1);\n    }\n    iVar3 = (***piVar2)(param_1[1], 1);\n    if (iVar3 == 0) {\n        fcn.004010c0(0x8007000e);\n        pcVar1 = swi(3);\n        uVar8 = (*pcVar1)();\n        return uVar8;\n    }\n    *(iVar3 + 4) = param_1[1];\n    uVar4 = param_1[1] + 1;\n    ppiVar6 = param_1 + 4;\n    ppiVar7 = iVar3 + 0x10;\n    for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *ppiVar7 = *ppiVar6;\n        ppiVar6 = ppiVar6 + 1;\n        ppiVar7 = ppiVar7 + 1;\n    }\n    for (uVar5 = uVar4 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *ppiVar7 = *ppiVar6;\n        ppiVar6 = ppiVar6 + 1;\n        ppiVar7 = ppiVar7 + 1;\n    }\n    return CONCAT44(uVar4, iVar3);\n}\n",
        "token_count": 466
    },
    "004035c0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004035c0(int32_t param_1, char param_2, uint32_t param_3)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uint *puVar4;\n    \n    if ((param_2 != '\\0') && (0xf < *(param_1 + 0x18))) {\n        puVar1 = *(param_1 + 4);\n        if (param_3 != 0) {\n            puVar3 = puVar1;\n            puVar4 = param_1 + 4;\n            for (uVar2 = param_3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar4 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar4 = puVar4 + 1;\n            }\n            for (uVar2 = param_3 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar4 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar4 = puVar4 + 1;\n            }\n        }\n        fcn.00418300(puVar1);\n    }\n    *(param_1 + 0x14) = param_3;\n    *(param_1 + 0x18) = 0xf;\n    *(param_1 + 4 + param_3) = 0;\n    return;\n}\n",
        "token_count": 342
    },
    "00403730": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.00403730(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    uint *puVar6;\n    uint *in_FS_OFFSET;\n    uint32_t var_8h;\n    uint32_t var_ch;\n    uint var_10h;\n    uint var_14h;\n    uint var_ch_2;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x41e3e0;\n    var_ch_2 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch_2;\n    uVar4 = var_8h | 0xf;\n    if (uVar4 != 0xffffffff) {\n        uVar1 = *(in_ECX + 0x18);\n        uVar3 = uVar1 >> 1;\n        var_8h = uVar4;\n        if ((uVar4 / 3 < uVar3) && (uVar1 <= -uVar3 - 2)) {\n            var_8h = uVar3 + uVar1;\n        }\n    }\n    var_4h = 0;\n    puVar2 = fcn.004182d5(var_8h + 1);\n    if (var_ch != 0) {\n        if (*(in_ECX + 0x18) < 0x10) {\n            puVar5 = in_ECX + 4;\n        }\n        else {\n            puVar5 = *(in_ECX + 4);\n        }\n        puVar6 = puVar2;\n        for (uVar4 = var_ch >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar6 = *puVar5;\n            puVar5 = puVar5 + 1;\n            puVar6 = puVar6 + 1;\n        }\n        for (uVar4 = var_ch & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar6 = *puVar5;\n            puVar5 = puVar5 + 1;\n            puVar6 = puVar6 + 1;\n        }\n    }\n    if (0xf < *(in_ECX + 0x18)) {\n        fcn.00418300(*(in_ECX + 4));\n    }\n    puVar5 = in_ECX + 4;\n    *puVar5 = 0;\n    *puVar5 = puVar2;\n    *(in_ECX + 0x18) = var_8h;\n    *(in_ECX + 0x14) = var_ch;\n    if (0xf < var_8h) {\n        puVar5 = puVar2;\n    }\n    *(puVar5 + var_ch) = 0;\n    *in_FS_OFFSET = var_ch_2;\n    return;\n}\n",
        "token_count": 718
    },
    "004039f0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004039f0(int32_t *param_1, uint *param_2, uint32_t param_3)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *extraout_EDX;\n    uint32_t unaff_ESI;\n    uint32_t uVar3;\n    uint32_t unaff_EDI;\n    uint *arg_8h;\n    uint *unaff_retaddr;\n    uint32_t in_stack_ffffffec;\n    \n    if (param_3 == 0) {\n        fcn.004030c0();\n        return;\n    }\n    if (param_2 != NULL) goto code_r0x00403a18;\n    do {\n        fcn.004010c0();\n        param_2 = extraout_EDX;\ncode_r0x00403a18:\n        iVar1 = *param_1;\n        uVar3 = param_2 - iVar1;\n        uVar2 = *(iVar1 + -0xc);\n        if ((1U - *(iVar1 + -4) | *(iVar1 + -8) - param_3) < 0) {\n            param_2 = unaff_retaddr;\n            in_stack_ffffffec = param_3;\n            fcn.00403420(param_3, unaff_EDI, unaff_ESI);\n            unaff_retaddr = param_2;\n        }\n        unaff_ESI = unaff_EDI;\n        unaff_EDI = in_stack_ffffffec;\n        arg_8h = *param_1;\n        if (uVar2 < uVar3) {\n            for (uVar2 = param_3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *arg_8h = *param_2;\n                param_2 = param_2 + 1;\n                arg_8h = arg_8h + 1;\n            }\n            for (uVar2 = param_3 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *arg_8h = *param_2;\n                param_2 = param_2 + 1;\n                arg_8h = arg_8h + 1;\n            }\n        }\n        else {\n            fcn.004072a0(arg_8h, arg_8h + uVar3, param_3);\n        }\n        in_stack_ffffffec = unaff_EDI;\n    } while ((param_3 < 0) || (*(*param_1 + -8) < param_3));\n    *(*param_1 + -0xc) = param_3;\n    *(param_3 + *param_1) = 0;\n    return;\n}\n",
        "token_count": 601
    },
    "00403a90": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nbool __thiscall fcn.00403a90(int32_t param_1, uint32_t param_2, uint param_3, uint param_4, uint param_5, uint param_6)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint *puVar4;\n    uint *puVar5;\n    uint unaff_retaddr;\n    char cVar6;\n    \n    if (param_2 == 0xffffffff) {\n        fcn.00415368();\n    }\n    uVar2 = *(param_1 + 0x18);\n    if (param_2 <= uVar2) {\n        if ((cVar6 != '\\0') && (param_2 < 0x10)) {\n            uVar3 = *(param_1 + 0x14);\n            if (param_2 < *(param_1 + 0x14)) {\n                uVar3 = param_2;\n            }\n            if (0xf < uVar2) {\n                puVar1 = *(param_1 + 4);\n                if (uVar3 != 0) {\n                    puVar4 = puVar1;\n                    puVar5 = param_1 + 4;\n                    for (uVar2 = uVar3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {\n                        *puVar5 = *puVar4;\n                        puVar4 = puVar4 + 1;\n                        puVar5 = puVar5 + 1;\n                    }\n                    for (uVar2 = uVar3 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {\n                        *puVar5 = *puVar4;\n                        puVar4 = puVar4 + 1;\n                        puVar5 = puVar5 + 1;\n                    }\n                }\n                fcn.00418300(puVar1);\n            }\n            *(param_1 + 0x14) = uVar3;\n            *(param_1 + 0x18) = 0xf;\n            *(uVar3 + 4 + param_1) = 0;\n            return param_2 != 0;\n        }\n        if (param_2 == 0) {\n            *(param_1 + 0x14) = 0;\n            if (0xf < uVar2) {\n                **(param_1 + 4) = 0;\n                return false;\n            }\n            *(param_1 + 4) = 0;\n        }\n        return param_2 != 0;\n    }\n    fcn.00403730(param_2, *(param_1 + 0x14), unaff_ESI, unaff_EBP, unaff_retaddr, param_2, param_3, param_4, param_5, \n                 param_6);\n    return param_2 != 0;\n}\n",
        "token_count": 650
    },
    "00403b60": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00403b60(int32_t *param_1, uint32_t param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    int32_t unaff_EBX;\n    uint *puVar4;\n    uint *unaff_retaddr;\n    \n    iVar1 = *param_1;\n    uVar3 = *(iVar1 + -0xc);\n    param_3 = uVar3 + param_3;\n    if ((1U - *(iVar1 + -4) | *(iVar1 + -8) - param_3) < 0) {\n        fcn.00403420(param_3);\n    }\n    if (param_2 - iVar1 <= uVar3) {\n        unaff_retaddr = *param_1 + (param_2 - iVar1);\n    }\n    puVar4 = *param_1 + unaff_EBX;\n    for (uVar3 = param_2 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar4 = *unaff_retaddr;\n        unaff_retaddr = unaff_retaddr + 1;\n        puVar4 = puVar4 + 1;\n    }\n    for (param_2 = param_2 & 3; param_2 != 0; param_2 = param_2 - 1) {\n        *puVar4 = *unaff_retaddr;\n        unaff_retaddr = unaff_retaddr + 1;\n        puVar4 = puVar4 + 1;\n    }\n    if ((-1 < param_3) && (param_3 <= *(*param_1 + -8))) {\n        *(*param_1 + -0xc) = param_3;\n        *(param_3 + *param_1) = 0;\n        return;\n    }\n    fcn.004010c0(0x80070057);\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 453
    },
    "00403e00": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00403e00(int32_t param_1, int32_t param_2, uint32_t param_3, uint32_t param_4)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint *puVar6;\n    uint unaff_EDI;\n    int32_t unaff_retaddr;\n    \n    if (*(param_2 + 0x14) < param_3) {\n        fcn.004152cd();\n    }\n    uVar1 = *(param_2 + 0x14) - param_3;\n    uVar4 = param_4;\n    if (uVar1 < param_4) {\n        uVar4 = uVar1;\n    }\n    if (-*(param_1 + 0x14) - 1U <= uVar4) {\n        fcn.00415368();\n    }\n    if (uVar4 != 0) {\n        uVar1 = *(param_1 + 0x14) + uVar4;\n        if (uVar1 == 0xffffffff) {\n            fcn.00415368();\n        }\n        if (*(param_1 + 0x18) < uVar1) {\n            fcn.00403730(uVar1, *(param_1 + 0x14), unaff_EBP, unaff_EDI, unaff_ESI, unaff_EBX, unaff_retaddr, param_2, \n                         param_3, param_4);\n        }\n        else if (uVar1 == 0) {\n            *(param_1 + 0x14) = 0;\n            if (*(param_1 + 0x18) < 0x10) {\n                *(param_1 + 4) = 0;\n                return param_1;\n            }\n            **(param_1 + 4) = 0;\n            return param_1;\n        }\n        if (uVar1 != 0) {\n            if (*(param_2 + 0x18) < 0x10) {\n                param_2 = param_2 + 4;\n            }\n            else {\n                param_2 = *(param_2 + 4);\n            }\n            puVar5 = param_1 + 4;\n            puVar2 = puVar5;\n            if (0xf < *(param_1 + 0x18)) {\n                puVar2 = *puVar5;\n            }\n            puVar6 = unaff_retaddr + param_2;\n            puVar2 = *(param_1 + 0x14) + puVar2;\n            for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar2 = *puVar6;\n                puVar6 = puVar6 + 1;\n                puVar2 = puVar2 + 1;\n            }\n            for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n                *puVar2 = *puVar6;\n                puVar6 = puVar6 + 1;\n                puVar2 = puVar2 + 1;\n            }\n            *(param_1 + 0x14) = uVar1;\n            if (0xf < *(param_1 + 0x18)) {\n                puVar5 = *puVar5;\n            }\n            *(puVar5 + uVar1) = 0;\n        }\n    }\n    return param_1;\n}\n",
        "token_count": 817
    },
    "004040a0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.004040a0(int32_t param_1, int32_t param_2, uint32_t param_3, uint32_t param_4)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint32_t noname_0;\n    uint unaff_ESI;\n    uint *puVar3;\n    uint unaff_EDI;\n    int32_t *piVar4;\n    uint unaff_retaddr;\n    \n    if (*(param_2 + 0x14) < param_3) {\n        fcn.004152cd();\n    }\n    noname_0 = *(param_2 + 0x14) - param_3;\n    if (param_4 < noname_0) {\n        noname_0 = param_4;\n    }\n    if (param_1 != param_2) {\n        if (noname_0 == 0xffffffff) {\n            fcn.00415368();\n        }\n        if (*(param_1 + 0x18) < noname_0) {\n            fcn.00403730(noname_0, *(param_1 + 0x14), unaff_EDI, unaff_ESI, unaff_EBP, unaff_EBX, unaff_retaddr, param_2\n                         , param_3, param_4);\n        }\n        else if (noname_0 == 0) {\n            *(param_1 + 0x14) = 0;\n            if (*(param_1 + 0x18) < 0x10) {\n                *(param_1 + 4) = 0;\n                return param_1;\n            }\n            **(param_1 + 4) = 0;\n            return param_1;\n        }\n        if (noname_0 != 0) {\n            if (*(param_2 + 0x18) < 0x10) {\n                param_2 = param_2 + 4;\n            }\n            else {\n                param_2 = *(param_2 + 4);\n            }\n            piVar1 = param_1 + 4;\n            piVar4 = piVar1;\n            if (0xf < *(param_1 + 0x18)) {\n                piVar4 = *piVar1;\n            }\n            puVar3 = param_3 + param_2;\n            for (uVar2 = noname_0 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *piVar4 = *puVar3;\n                puVar3 = puVar3 + 1;\n                piVar4 = piVar4 + 1;\n            }\n            for (uVar2 = noname_0 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *piVar4 = *puVar3;\n                puVar3 = puVar3 + 1;\n                piVar4 = piVar4 + 1;\n            }\n            *(param_1 + 0x14) = noname_0;\n            if (0xf < *(param_1 + 0x18)) {\n                piVar1 = *piVar1;\n            }\n            *(piVar1 + noname_0) = 0;\n        }\n        return param_1;\n    }\n    fcn.004036b0(noname_0 + param_3, 0xffffffff);\n    fcn.004036b0(0, param_3);\n    return param_1;\n}\n",
        "token_count": 784
    },
    "004041d0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.004041d0(int32_t param_1, uint *param_2, uint32_t param_3, uint param_4)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint32_t uVar4;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    \n    uVar4 = *(param_1 + 0x18);\n    if (uVar4 < 0x10) {\n        puVar1 = param_1 + 4;\n    }\n    else {\n        puVar1 = *(param_1 + 4);\n    }\n    if (puVar1 <= param_2) {\n        puVar1 = param_1 + 4;\n        puVar3 = puVar1;\n        if (0xf < uVar4) {\n            puVar3 = *puVar1;\n        }\n        if (param_2 < *(param_1 + 0x14) + puVar3) {\n            if (0xf < uVar4) {\n                puVar1 = *puVar1;\n            }\n            iVar2 = fcn.004040a0(param_1, param_2 - puVar1, param_3);\n            return iVar2;\n        }\n    }\n    if (param_3 == 0xffffffff) {\n        fcn.00415368();\n    }\n    if (*(param_1 + 0x18) < param_3) {\n        fcn.00403730(param_3, *(param_1 + 0x14), unaff_EBP, unaff_EDI, unaff_ESI, unaff_EBX, unaff_retaddr, param_2, \n                     param_3, param_4);\n    }\n    else if (param_3 == 0) {\n        *(param_1 + 0x14) = 0;\n        if (*(param_1 + 0x18) < 0x10) {\n            *(param_1 + 4) = 0;\n            return param_1;\n        }\n        **(param_1 + 4) = 0;\n        return param_1;\n    }\n    if (param_3 != 0) {\n        if (*(param_1 + 0x18) < 0x10) {\n            puVar1 = param_1 + 4;\n        }\n        else {\n            puVar1 = *(param_1 + 4);\n        }\n        for (uVar4 = param_3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar1 = *param_2;\n            param_2 = param_2 + 1;\n            puVar1 = puVar1 + 1;\n        }\n        for (uVar4 = param_3 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar1 = *param_2;\n            param_2 = param_2 + 1;\n            puVar1 = puVar1 + 1;\n        }\n        *(param_1 + 0x14) = param_3;\n        if (0xf < *(param_1 + 0x18)) {\n            *(*(param_1 + 4) + param_3) = 0;\n            return param_1;\n        }\n        *(param_1 + 4 + param_3) = 0;\n    }\n    return param_1;\n}\n",
        "token_count": 782
    },
    "004072a0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.004072a0(uint *arg_8h, uint *arg_ch, uint32_t arg_10h)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    if ((arg_ch < arg_8h) && (arg_8h < arg_10h + arg_ch)) {\n        arg_ch = (arg_10h - 4) + arg_ch;\n        puVar1 = (arg_10h - 4) + arg_8h;\n        if ((puVar1 & 3) == 0) {\n            uVar3 = arg_10h >> 2;\n            if (uVar3 < 8) goto code_r0x00407464;\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + -1;\n                puVar1 = puVar1 + -1;\n            }\n    // switch table (4 cases) at 0x407588\n            switch(*((arg_10h & 3) * 4 + 0x407588)) {\n            case 0x4075a0:\ncode_r0x004075a0:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                return arg_8h;\n            case 0x4075b0:\ncode_r0x004075b0:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                return arg_8h;\n            case 0x4075c4:\ncode_r0x004075c4:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                *(puVar1 + 1) = *(arg_ch + 1);\n                return arg_8h;\n            }\n        }\n        else if (arg_10h < 4) {\n    // switch table (4 cases) at 0x407588\n            switch(*(arg_10h * 4 + 0x407588)) {\n            case 0x4075a0:\n                goto code_r0x004075a0;\n            case 0x4075b0:\n                goto code_r0x004075b0;\n            case 0x4075c4:\n                goto code_r0x004075c4;\n            }\n        }\n        else {\n            arg_10h = arg_10h - (puVar1 & 3);\n            switch(*((puVar1 & 3) * 4 + 0x40748c)) {\n            case 0x40749c:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                arg_ch = arg_ch + -1;\n                uVar3 = arg_10h >> 2;\n                puVar1 = puVar1 - 1;\n                if (uVar3 < 8) {\ncode_r0x00407464:\n    // WARNING: Could not recover jumptable at 0x00407466. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (1 cases) at 0x407538\n                    puVar1 = (**(uVar3 * -4 + 0x407538))();\n                    return puVar1;\n                }\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x407588)) {\n                case 0x4075a0:\n                    goto code_r0x004075a0;\n                case 0x4075b0:\n                    goto code_r0x004075b0;\n                case 0x4075c4:\n                    goto code_r0x004075c4;\n                }\n                break;\n            case 0x4074c0:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 2) = *(arg_ch + 2);\n                arg_ch = arg_ch + -2;\n                puVar1 = puVar1 - 2;\n                if (uVar3 < 8) goto code_r0x00407464;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x407588)) {\n                case 0x4075a0:\n                    goto code_r0x004075a0;\n                case 0x4075b0:\n                    goto code_r0x004075b0;\n                case 0x4075c4:\n                    goto code_r0x004075c4;\n                }\n                break;\n            case 0x4074e8:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 1) = *(arg_ch + 1);\n                arg_ch = arg_ch + -3;\n                puVar1 = puVar1 - 3;\n                if (uVar3 < 8) goto code_r0x00407464;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x407588)) {\n                case 0x4075a0:\n                    goto code_r0x004075a0;\n                case 0x4075b0:\n                    goto code_r0x004075b0;\n                case 0x4075c4:\n                    goto code_r0x004075c4;\n                }\n            }\n        }\n        return arg_8h;\n    }\n    puVar1 = arg_8h;\n    if ((arg_8h & 3) == 0) {\n        uVar2 = arg_10h >> 2;\n        if (uVar2 < 8) goto code_r0x004072fc;\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar1 = *arg_ch;\n            arg_ch = arg_ch + 1;\n            puVar1 = puVar1 + 1;\n        }\n    // switch table (4 cases) at 0x4073ec\n        switch(*((arg_10h & 3) * 4 + 0x4073ec)) {\n        case 0x407404:\ncode_r0x00407404:\n            *puVar1 = *arg_ch;\n            return arg_8h;\n        case 0x407410:\ncode_r0x00407410:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            return arg_8h;\n        case 0x407424:\ncode_r0x00407424:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            *(puVar1 + 2) = *(arg_ch + 2);\n            return arg_8h;\n        }\n    }\n    else if (arg_10h < 4) {\n        switch(*((arg_10h - 4) * 4 + 0x4073fc)) {\n        case 0x407404:\n            goto code_r0x00407404;\n        case 0x407410:\n            goto code_r0x00407410;\n        case 0x407424:\n            goto code_r0x00407424;\n        }\n    }\n    else {\n        uVar3 = (arg_10h - 4) + (arg_8h & 3);\n        switch(*((arg_8h & 3) * 4 + 0x407300)) {\n        case 0x407310:\n            *arg_8h = *arg_ch;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 2) = *(arg_ch + 2);\n            arg_ch = arg_ch + 3;\n            puVar1 = arg_8h + 3;\n            if (uVar2 < 8) {\ncode_r0x004072fc:\n    // WARNING: Could not recover jumptable at 0x004072fc. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (8 cases) at 0x407380\n                puVar1 = (**(uVar2 * 4 + 0x407380))();\n                return puVar1;\n            }\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x4073ec)) {\n            case 0x407404:\n                goto code_r0x00407404;\n            case 0x407410:\n                goto code_r0x00407410;\n            case 0x407424:\n                goto code_r0x00407424;\n            }\n            break;\n        case 0x40733c:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            arg_ch = arg_ch + 2;\n            puVar1 = arg_8h + 2;\n            if (uVar2 < 8) goto code_r0x004072fc;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x4073ec)) {\n            case 0x407404:\n                goto code_r0x00407404;\n            case 0x407410:\n                goto code_r0x00407410;\n            case 0x407424:\n                goto code_r0x00407424;\n            }\n            break;\n        case 0x407360:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            arg_ch = arg_ch + 1;\n            puVar1 = arg_8h + 1;\n            if (uVar2 < 8) goto code_r0x004072fc;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x4073ec)) {\n            case 0x407404:\n                goto code_r0x00407404;\n            case 0x407410:\n                goto code_r0x00407410;\n            case 0x407424:\n                goto code_r0x00407424;\n            }\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 2652
    },
    "004085f0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.004085f0(uint *arg_8h, uint *arg_ch, uint32_t arg_10h)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    if ((arg_ch < arg_8h) && (arg_8h < arg_10h + arg_ch)) {\n        arg_ch = (arg_10h - 4) + arg_ch;\n        puVar1 = (arg_10h - 4) + arg_8h;\n        if ((puVar1 & 3) == 0) {\n            uVar3 = arg_10h >> 2;\n            if (uVar3 < 8) goto code_r0x004087b4;\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + -1;\n                puVar1 = puVar1 + -1;\n            }\n    // switch table (4 cases) at 0x4088d8\n            switch(*((arg_10h & 3) * 4 + 0x4088d8)) {\n            case 0x4088f0:\ncode_r0x004088f0:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                return arg_8h;\n            case 0x408900:\ncode_r0x00408900:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                return arg_8h;\n            case 0x408914:\ncode_r0x00408914:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                *(puVar1 + 1) = *(arg_ch + 1);\n                return arg_8h;\n            }\n        }\n        else if (arg_10h < 4) {\n    // switch table (4 cases) at 0x4088d8\n            switch(*(arg_10h * 4 + 0x4088d8)) {\n            case 0x4088f0:\n                goto code_r0x004088f0;\n            case 0x408900:\n                goto code_r0x00408900;\n            case 0x408914:\n                goto code_r0x00408914;\n            }\n        }\n        else {\n            arg_10h = arg_10h - (puVar1 & 3);\n            switch(*((puVar1 & 3) * 4 + 0x4087dc)) {\n            case 0x4087ec:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                arg_ch = arg_ch + -1;\n                uVar3 = arg_10h >> 2;\n                puVar1 = puVar1 - 1;\n                if (uVar3 < 8) {\ncode_r0x004087b4:\n    // WARNING: Could not recover jumptable at 0x004087b6. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (1 cases) at 0x408888\n                    puVar1 = (**(uVar3 * -4 + 0x408888))();\n                    return puVar1;\n                }\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x4088d8)) {\n                case 0x4088f0:\n                    goto code_r0x004088f0;\n                case 0x408900:\n                    goto code_r0x00408900;\n                case 0x408914:\n                    goto code_r0x00408914;\n                }\n                break;\n            case 0x408810:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 2) = *(arg_ch + 2);\n                arg_ch = arg_ch + -2;\n                puVar1 = puVar1 - 2;\n                if (uVar3 < 8) goto code_r0x004087b4;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x4088d8)) {\n                case 0x4088f0:\n                    goto code_r0x004088f0;\n                case 0x408900:\n                    goto code_r0x00408900;\n                case 0x408914:\n                    goto code_r0x00408914;\n                }\n                break;\n            case 0x408838:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 1) = *(arg_ch + 1);\n                arg_ch = arg_ch + -3;\n                puVar1 = puVar1 - 3;\n                if (uVar3 < 8) goto code_r0x004087b4;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x4088d8)) {\n                case 0x4088f0:\n                    goto code_r0x004088f0;\n                case 0x408900:\n                    goto code_r0x00408900;\n                case 0x408914:\n                    goto code_r0x00408914;\n                }\n            }\n        }\n        return arg_8h;\n    }\n    puVar1 = arg_8h;\n    if ((arg_8h & 3) == 0) {\n        uVar2 = arg_10h >> 2;\n        if (uVar2 < 8) goto code_r0x0040864c;\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar1 = *arg_ch;\n            arg_ch = arg_ch + 1;\n            puVar1 = puVar1 + 1;\n        }\n    // switch table (4 cases) at 0x40873c\n        switch(*((arg_10h & 3) * 4 + 0x40873c)) {\n        case 0x408754:\ncode_r0x00408754:\n            *puVar1 = *arg_ch;\n            return arg_8h;\n        case 0x408760:\ncode_r0x00408760:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            return arg_8h;\n        case 0x408774:\ncode_r0x00408774:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            *(puVar1 + 2) = *(arg_ch + 2);\n            return arg_8h;\n        }\n    }\n    else if (arg_10h < 4) {\n        switch(*((arg_10h - 4) * 4 + 0x40874c)) {\n        case 0x408754:\n            goto code_r0x00408754;\n        case 0x408760:\n            goto code_r0x00408760;\n        case 0x408774:\n            goto code_r0x00408774;\n        }\n    }\n    else {\n        uVar3 = (arg_10h - 4) + (arg_8h & 3);\n        switch(*((arg_8h & 3) * 4 + 0x408650)) {\n        case 0x408660:\n            *arg_8h = *arg_ch;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 2) = *(arg_ch + 2);\n            arg_ch = arg_ch + 3;\n            puVar1 = arg_8h + 3;\n            if (uVar2 < 8) {\ncode_r0x0040864c:\n    // WARNING: Could not recover jumptable at 0x0040864c. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (8 cases) at 0x4086d0\n                puVar1 = (**(uVar2 * 4 + 0x4086d0))();\n                return puVar1;\n            }\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x40873c)) {\n            case 0x408754:\n                goto code_r0x00408754;\n            case 0x408760:\n                goto code_r0x00408760;\n            case 0x408774:\n                goto code_r0x00408774;\n            }\n            break;\n        case 0x40868c:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            arg_ch = arg_ch + 2;\n            puVar1 = arg_8h + 2;\n            if (uVar2 < 8) goto code_r0x0040864c;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x40873c)) {\n            case 0x408754:\n                goto code_r0x00408754;\n            case 0x408760:\n                goto code_r0x00408760;\n            case 0x408774:\n                goto code_r0x00408774;\n            }\n            break;\n        case 0x4086b0:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            arg_ch = arg_ch + 1;\n            puVar1 = arg_8h + 1;\n            if (uVar2 < 8) goto code_r0x0040864c;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x40873c)) {\n            case 0x408754:\n                goto code_r0x00408754;\n            case 0x408760:\n                goto code_r0x00408760;\n            case 0x408774:\n                goto code_r0x00408774;\n            }\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 2648
    },
    "00409040": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint32_t * fcn.00409040(uint32_t *param_1, uint8_t param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t *puVar4;\n    \n    if (param_3 == 0) {\n        return param_1;\n    }\n    uVar1 = param_2;\n    puVar4 = param_1;\n    if (3 < param_3) {\n        uVar2 = -param_1 & 3;\n        uVar3 = param_3;\n        if (uVar2 != 0) {\n            uVar3 = param_3 - uVar2;\n            do {\n                *puVar4 = param_2;\n                puVar4 = puVar4 + 1;\n                uVar2 = uVar2 - 1;\n            } while (uVar2 != 0);\n        }\n        uVar1 = uVar1 * 0x1010101;\n        param_3 = uVar3 & 3;\n        uVar3 = uVar3 >> 2;\n        if (uVar3 != 0) {\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar4 = uVar1;\n                puVar4 = puVar4 + 1;\n            }\n            if (param_3 == 0) {\n                return param_1;\n            }\n        }\n    }\n    do {\n        *puVar4 = uVar1;\n        puVar4 = puVar4 + 1;\n        param_3 = param_3 - 1;\n    } while (param_3 != 0);\n    return param_1;\n}\n",
        "token_count": 386
    },
    "004090a0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint32_t fcn.004090a0(uint32_t *param_1, uint32_t *param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint8_t uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint32_t *puVar8;\n    bool bVar9;\n    \n    uVar3 = param_3;\n    if (param_3 != 0) {\n        if (((param_1 | param_2) & 3) == 0) {\n            uVar3 = param_3 & 3;\n            param_3 = param_3 >> 2;\n            bVar9 = param_3 == 0;\n            puVar7 = param_1;\n            puVar8 = param_2;\n            if (!bVar9) {\n                do {\n                    param_1 = puVar7;\n                    param_2 = puVar8;\n                    if (param_3 == 0) break;\n                    param_3 = param_3 - 1;\n                    param_2 = puVar8 + 1;\n                    param_1 = puVar7 + 1;\n                    bVar9 = *puVar7 == *puVar8;\n                    puVar7 = param_1;\n                    puVar8 = param_2;\n                } while (bVar9);\n                if (!bVar9) {\n                    uVar3 = param_1[-1];\n                    uVar1 = param_2[-1];\n                    bVar9 = uVar3 < uVar1;\n                    if (((uVar3 == uVar1) &&\n                        (uVar5 = uVar3 >> 8,  uVar6 = uVar1 >> 8,  bVar9 = uVar5 < uVar6,  uVar5 == uVar6)) &&\n                       (uVar5 = uVar3 >> 0x10,  uVar6 = uVar1 >> 0x10,  bVar9 = uVar5 < uVar6,  uVar5 == uVar6)) {\n                        bVar9 = uVar3 >> 0x18 < uVar1 >> 0x18;\n                    }\n                    goto code_r0x00409120;\n                }\n            }\n            if (uVar3 != 0) {\n                uVar1 = *param_1;\n                uVar2 = *param_2;\n                bVar9 = uVar1 < uVar2;\n                if (uVar1 != uVar2) {\ncode_r0x00409120:\n                    return (1 - bVar9) - (bVar9 != 0);\n                }\n                uVar4 = uVar3 - 1;\n                if (uVar4 != 0) {\n                    uVar5 = uVar2 >> 8;\n                    uVar6 = uVar1 >> 8;\n                    bVar9 = uVar6 < uVar5;\n                    if (uVar6 != uVar5) goto code_r0x00409120;\n                    uVar4 = uVar3 - 2;\n                    if (uVar4 != 0) {\n                        bVar9 = (uVar1 & 0xff0000) < (uVar2 & 0xff0000);\n                        if ((uVar1 & 0xff0000) != (uVar2 & 0xff0000)) goto code_r0x00409120;\n                        uVar4 = uVar3 - 3;\n                    }\n                }\n                return uVar4;\n            }\n        }\n        else {\n            if ((param_3 & 1) == 0) goto code_r0x004090d3;\n            bVar9 = *param_1 < *param_2;\n            if (*param_1 != *param_2) goto code_r0x00409120;\n            param_1 = param_1 + 1;\n            param_2 = param_2 + 1;\n            for (param_3 = param_3 - 1; uVar3 = param_3,  param_3 != 0; param_3 = param_3 - 2) {\ncode_r0x004090d3:\n                bVar9 = *param_1 < *param_2;\n                if ((*param_1 != *param_2) ||\n                   (bVar9 = *(param_1 + 1) < *(param_2 + 1),  *(param_1 + 1) != *(param_2 + 1))) goto code_r0x00409120;\n                param_2 = param_2 + 2;\n                param_1 = param_1 + 2;\n            }\n        }\n    }\n    return uVar3;\n}\n",
        "token_count": 1042
    },
    "00411467": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00411467(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint var_7ch;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    uVar1 = fcn.00411415();\n    iVar2 = (**0x42afc8)(uVar1, (-(*0x42afb8 != 0) & 0xfffff005) + 0x1002, &var_7ch, 0x78);\n    if (iVar2 == 0) {\n        *0x42afa8 = 0;\n    }\n    else {\n        iVar2 = fcn.00407b48(*0x42afbc, &var_7ch);\n        if ((iVar2 == 0) && (iVar2 = fcn.00411314(uVar1),  iVar2 != 0)) {\n            *0x42afa8 = *0x42afa8 | 4;\n            *0x42afac = uVar1;\n            *0x42afb0 = uVar1;\n        }\n    }\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 261
    },
    "0041156c": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041156c(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uint arg_ch;\n    uint var_7ch;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    arg_8h_00 = fcn.00411415();\n    iVar1 = (**0x42afc8)(arg_8h_00, (-(*0x42afb8 != 0) & 0xfffff005) + 0x1002, &var_7ch, 0x78);\n    if (iVar1 == 0) {\n        *0x42afa8 = 0;\n        goto code_r0x00411779;\n    }\n    iVar1 = fcn.00407b48(*0x42afbc, &var_7ch);\n    if (iVar1 == 0) {\n        iVar1 = (**0x42afc8)(arg_8h_00, (-(*0x42afb4 != 0) & 0xfffff002) + 0x1001, &var_7ch, 0x78);\n        if (iVar1 != 0) {\n            iVar1 = fcn.00407b48(*0x42afc4, &var_7ch);\n            if (iVar1 == 0) {\n                *0x42afa8 = *0x42afa8 | 0x304;\n                *0x42afac = arg_8h_00;\n                *0x42afb0 = arg_8h_00;\n            }\n            else if ((*0x42afa8 & 2) == 0) {\n                if ((*0x42afc0 == 0) || (iVar1 = fcn.004134d8(*0x42afc4, &var_7ch, *0x42afc0),  iVar1 != 0)) {\n                    if (((*0x42afa8 & 1) == 0) && (iVar1 = fcn.00411314(arg_8h_00),  iVar1 != 0)) {\n                        *0x42afa8 = *0x42afa8 | 1;\n                        *0x42afb0 = arg_8h_00;\n                    }\n                }\n                else {\n                    *0x42afa8 = *0x42afa8 | 2;\n                    *0x42afb0 = arg_8h_00;\n                    iVar1 = fcn.004089d0(*0x42afc4);\n                    if (iVar1 == *0x42afc0) {\n                        *0x42afac = arg_8h_00;\n                    }\n                }\n            }\n            goto code_r0x00411697;\n        }\ncode_r0x004116cb:\n        *0x42afa8 = 0;\n        goto code_r0x00411779;\n    }\ncode_r0x00411697:\n    if ((*0x42afa8 & 0x300) == 0x300) goto code_r0x00411779;\n    iVar1 = (**0x42afc8)(arg_8h_00, (-(*0x42afb4 != 0) & 0xfffff002) + 0x1001, &var_7ch, 0x78);\n    if (iVar1 == 0) goto code_r0x004116cb;\n    iVar1 = fcn.00407b48(*0x42afc4, &var_7ch);\n    if (iVar1 == 0) {\n        *0x42afa8 = *0x42afa8 | 0x200;\n        if (((*0x42afb4 == 0) && (*0x42afc0 != 0)) && (iVar1 = fcn.004089d0(*0x42afc4),  iVar1 == *0x42afc0)) {\n            arg_ch = 1;\n            goto code_r0x00411749;\n        }\n    }\n    else {\n        if (((*0x42afb4 != 0) || (*0x42afc0 == 0)) ||\n           (iVar1 = fcn.004134d8(*0x42afc4, &var_7ch, *0x42afc0),  iVar1 != 0)) goto code_r0x00411779;\n        arg_ch = 0;\ncode_r0x00411749:\n        iVar1 = fcn.004114fb(arg_8h_00, arg_ch);\n        if (iVar1 == 0) goto code_r0x00411779;\n    }\n    *0x42afa8 = *0x42afa8 | 0x100;\n    if (*0x42afac == 0) {\n        *0x42afac = arg_8h_00;\n    }\ncode_r0x00411779:\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 1077
    },
    "0040ddc9": {
        "rules": [
            "parse credit card information/92c3fd9898ba41b4bad3ffb6188f4688",
            "search for credit card data/212a26c2b8d740cd9f6579dba482d653"
        ],
        "decompiled_code": "\nuint fcn.0040ddc9(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    int32_t iVar4;\n    \n    if (*0x42c3bc == 0) {\n        fcn.00409a75();\n    }\n    iVar4 = 0;\n    pcVar3 = *0x42ab48;\n    if (*0x42ab48 != NULL) {\n        for (; *pcVar3 != '\\0'; pcVar3 = pcVar3 + iVar2 + 1) {\n            if (*pcVar3 != '=') {\n                iVar4 = iVar4 + 1;\n            }\n            iVar2 = fcn.004089d0(pcVar3);\n        }\n        piVar1 = fcn.00407684(iVar4 * 4 + 4);\n        pcVar3 = *0x42ab48;\n        *0x42ab88 = piVar1;\n        if (piVar1 != NULL) {\n            do {\n                if (*pcVar3 == '\\0') {\n                    fcn.00407696(*0x42ab48);\n                    *0x42ab48 = NULL;\n                    *piVar1 = 0;\n                    *0x42c3b0 = 1;\n                    return 0;\n                }\n                iVar4 = fcn.004089d0(pcVar3);\n                if (*pcVar3 != '=') {\n                    iVar2 = fcn.00407684(iVar4 + 1);\n                    *piVar1 = iVar2;\n                    if (iVar2 == 0) {\n                        fcn.00407696(*0x42ab88);\n                        *0x42ab88 = NULL;\n                        return 0xffffffff;\n                    }\n                    fcn.0040fce0(iVar2, pcVar3);\n                    piVar1 = piVar1 + 1;\n                }\n                pcVar3 = pcVar3 + iVar4 + 1;\n            } while( true );\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 442
    },
    "004032e0": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nint32_t fcn.004032e0(uint *param_1)\n\n{\n    char cVar1;\n    int32_t arg_8h;\n    int32_t iVar2;\n    \n    arg_8h = fcn.00407e42(*param_1, 0x41f55c);\n    iVar2 = 0;\n    if (arg_8h != 0) {\n        iVar2 = 0;\n        do {\n            while( true ) {\n                cVar1 = fcn.00407d96(arg_8h);\n                if (cVar1 != '\\n') break;\n                iVar2 = iVar2 + 1;\n            }\n        } while (cVar1 != -1);\n        fcn.00407d45(arg_8h);\n    }\n    return iVar2;\n}\n",
        "token_count": 175
    },
    "00410030": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nvoid fcn.00410030(uint32_t param_1, char *param_2, uint32_t param_3)\n\n{\n    int32_t *piVar1;\n    char cVar2;\n    char *pcVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int32_t iStack1060;\n    int32_t iStack1056;\n    int32_t iStack1052;\n    char *pcStack1048;\n    int32_t iStack1044;\n    int32_t iStack1040;\n    char acStack1036 [1028];\n    uint uStack8;\n    \n    uStack8 = *0x427850;\n    iStack1052 = 0;\n    iStack1056 = 0;\n    if (param_3 == 0) goto code_r0x004101ea;\n    piVar1 = (param_1 >> 5) * 4 + 0x42b260;\n    iVar8 = (param_1 & 0x1f) * 0x24;\n    if ((*(*piVar1 + 4 + iVar8) & 0x20) != 0) {\n        fcn.00413270(param_1, 0, 0, 2);\n    }\n    if ((*(*piVar1 + iVar8 + 1) & 0x80) == 0) {\n        iVar5 = (*_sym.imp.KERNEL32.dll_WriteFile)(*(*piVar1 + iVar8), param_2, param_3, &iStack1060, 0);\n        if (iVar5 == 0) {\n            iStack1040 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        else {\n            iStack1040 = 0;\n            iStack1052 = iStack1060;\n        }\ncode_r0x0041014c:\n        if (iStack1052 != 0) goto code_r0x004101ea;\n        if (iStack1040 != 0) {\n            if (iStack1040 == 5) {\n                puVar6 = fcn.00409c85();\n                *puVar6 = 9;\n                puVar6 = fcn.00409c8e();\n                *puVar6 = 5;\n            }\n            else {\n                fcn.00409c97(iStack1040);\n            }\n            goto code_r0x004101ea;\n        }\n    }\n    else {\n        pcStack1048 = param_2;\n        iStack1040 = 0;\n        if (param_3 != 0) {\n            do {\n                uVar7 = pcStack1048 - param_2;\n                pcVar4 = acStack1036;\n                iStack1044 = 0;\n                do {\n                    if (param_3 <= uVar7) break;\n                    pcVar3 = pcStack1048 + 1;\n                    cVar2 = *pcStack1048;\n                    uVar7 = uVar7 + 1;\n                    if (cVar2 == '\\n') {\n                        iStack1056 = iStack1056 + 1;\n                        *pcVar4 = '\\r';\n                        pcVar4 = pcVar4 + 1;\n                        iStack1044 = iStack1044 + 1;\n                    }\n                    *pcVar4 = cVar2;\n                    pcVar4 = pcVar4 + 1;\n                    iStack1044 = iStack1044 + 1;\n                    pcStack1048 = pcVar3;\n                } while (iStack1044 < 0x400);\n                iVar5 = (*_sym.imp.KERNEL32.dll_WriteFile)\n                                  (*(*piVar1 + iVar8), acStack1036, pcVar4 - acStack1036, &iStack1060, 0);\n                if (iVar5 == 0) {\n                    iStack1040 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    goto code_r0x0041014c;\n                }\n                iStack1052 = iStack1052 + iStack1060;\n                if ((iStack1060 < pcVar4 - acStack1036) || (param_3 <= pcStack1048 - param_2)) goto code_r0x0041014c;\n            } while( true );\n        }\n    }\n    if (((*(*piVar1 + 4 + iVar8) & 0x40) == 0) || (*param_2 != '\\x1a')) {\n        puVar6 = fcn.00409c85();\n        *puVar6 = 0x1c;\n        puVar6 = fcn.00409c8e();\n        *puVar6 = 0;\n    }\ncode_r0x004101ea:\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 1055
    },
    "00413595": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00413595(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    \n    if ((arg_10h == 10) && (arg_8h < 0)) {\n        uVar1 = 1;\n        arg_10h = 10;\n    }\n    else {\n        uVar1 = 0;\n    }\n    fcn.00413557(arg_10h, uVar1);\n    return arg_ch;\n}\n",
        "token_count": 114
    },
    "004174f8": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nuint64_t __cdecl fcn.004174f8(char **arg_8h)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    uint64_t uVar3;\n    char **ppcVar4;\n    char *arg_ch;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    char *pcVar8;\n    char *pcVar9;\n    int32_t arg_10h;\n    int32_t iVar10;\n    int64_t iVar11;\n    int64_t iVar12;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    char *var_4h;\n    \n    ppcVar4 = arg_8h;\n    pcVar7 = arg_8h[4];\n    if (arg_8h[1] < 0) {\n        arg_8h[1] = NULL;\n    }\n    iVar11 = fcn.004132f3(pcVar7, 0, 0, 1);\n    arg_10h = iVar11 >> 0x20;\n    arg_ch = iVar11;\n    if ((iVar11 < 0x100000000) && (iVar11 < 0)) {\ncode_r0x004175b5:\n        uVar3 = 0xffffffffffffffff;\n    }\n    else {\n        if ((*(arg_8h + 3) & 0x108) == 0) {\n            return iVar11 - arg_8h[1];\n        }\n        pcVar6 = *arg_8h;\n        pcVar9 = arg_8h[2];\n        var_4h = pcVar6 + -pcVar9;\n        if ((arg_8h[3] & 3) == 0) {\n            if (-1 < arg_8h[3]) {\n                puVar5 = fcn.00409c85();\n                *puVar5 = 0x16;\n                goto code_r0x004175b5;\n            }\n        }\n        else if (((*(*((pcVar7 >> 5) * 4 + 0x42b260) + 4 + (pcVar7 & 0x1f) * 0x24) & 0x80) != 0) &&\n                (pcVar8 = pcVar9,  pcVar9 < pcVar6)) {\n            do {\n                if (*pcVar8 == '\\n') {\n                    var_4h = var_4h + 1;\n                }\n                pcVar8 = pcVar8 + 1;\n            } while (pcVar8 < *arg_8h);\n        }\n        if (iVar11 == 0) {\n            uVar3 = ZEXT48(var_4h);\n        }\n        else {\n            if (((*(arg_8h + 3) & 1) != 0) && (arg_8h[1] != NULL)) {\n                pcVar6 = arg_8h[1] + (pcVar6 - pcVar9);\n                piVar1 = (pcVar7 >> 5) * 4 + 0x42b260;\n                iVar10 = (pcVar7 & 0x1f) * 0x24;\n                if ((*(iVar10 + 4 + *piVar1) & 0x80) != 0) {\n                    iVar12 = fcn.004132f3(pcVar7, 0, 0, 2);\n                    if (iVar12 == iVar11) {\n                        pcVar7 = arg_8h[2];\n                        pcVar9 = pcVar6 + pcVar7;\n                        arg_8h = pcVar6;\n                        for (; pcVar7 < pcVar9; pcVar7 = pcVar7 + 1) {\n                            if (*pcVar7 == '\\n') {\n                                arg_8h = arg_8h + 1;\n                            }\n                        }\n                        uVar2 = *(ppcVar4 + 0xd) & 0x20;\n                    }\n                    else {\n                        fcn.004132f3(pcVar7, arg_ch, arg_10h, 0);\n                        pcVar7 = 0x200;\n                        if (((0x200 < pcVar6) || ((arg_8h[3] & 8) == 0)) || ((arg_8h[3] & 0x400) != 0)) {\n                            pcVar7 = arg_8h[6];\n                        }\n                        uVar2 = *(iVar10 + 4 + *piVar1) & 4;\n                        arg_8h = pcVar7;\n                    }\n                    pcVar6 = arg_8h;\n                    if (uVar2 != 0) {\n                        pcVar6 = arg_8h + 1;\n                    }\n                }\n                arg_8h = pcVar6;\n                iVar11 = CONCAT44(arg_10h - (arg_ch < arg_8h), arg_ch + -arg_8h);\n            }\n            uVar3 = iVar11 - 8;\n        }\n    }\n    return uVar3;\n}\n",
        "token_count": 1106
    },
    "00403510": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.00403510(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if ((*(param_1 + *(*param_1 + 4) + 8) & 6) == 0) {\n        iVar1 = (**(**(param_1 + *(*param_1 + 4) + 0x28) + 0x2c))();\n        if (iVar1 == -1) {\n            uVar2 = 4;\n        }\n    }\n    if (uVar2 != 0) {\n        uVar2 = *(param_1 + *(*param_1 + 4) + 8) | uVar2;\n        if (*(param_1 + *(*param_1 + 4) + 0x28) == 0) {\n            uVar2 = uVar2 | 4;\n        }\n        fcn.00415064(uVar2, 0);\n    }\n    return param_1;\n}\n",
        "token_count": 231
    },
    "004042c0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.004042c0(int32_t param_1, int32_t param_2, uint param_3, uint param_4)\n\n{\n    char *pcVar1;\n    uchar uVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    uint32_t arg_8h;\n    int32_t noname_7;\n    uint32_t unaff_EBX;\n    uint unaff_EBP;\n    int32_t iVar6;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    uint in_stack_fffffff8;\n    \n    noname_7 = 0;\n    do {\n        pcVar1 = noname_7 + param_1;\n        noname_7 = noname_7 + 1;\n    } while (*pcVar1 != '\\0');\n    iVar6 = 0;\n    iVar3 = 0;\n    do {\n        *(iVar3 + param_2) = iVar3;\n        iVar3 = iVar3 + 1;\n    } while (iVar3 < 0x22e5);\n    iVar3 = 0;\n    do {\n        iVar6 = (*(iVar3 + param_2) + *(iVar3 % noname_7 + param_1) + iVar6) % 0x22e5;\n        piVar4 = fcn.00403bf0(0x42b0e8, \"sdzcsdXAXZSFSFSFFFZCxsdfdEADSDZZCD\", unaff_EDI, unaff_ESI, unaff_EBP, unaff_EBX\n                              , in_stack_fffffff8, noname_7, unaff_retaddr, param_1, param_2, param_3, param_4);\n        fcn.00403f10(10);\n        unaff_EBX = 0;\n        if (((*(*(*piVar4 + 4) + 8 + piVar4) & 6) == 0) &&\n           (iVar5 = (**(**(piVar4 + *(*piVar4 + 4) + 0x28) + 0x2c))(),  iVar5 == -1)) {\n            unaff_EBX = 4;\n        }\n        if (unaff_EBX != 0) {\n            arg_8h = *(piVar4 + *(*piVar4 + 4) + 8) | unaff_EBX;\n            if (*(piVar4 + *(*piVar4 + 4) + 0x28) == 0) {\n                arg_8h = arg_8h | 4;\n            }\n            fcn.00415064(arg_8h, 0);\n        }\n        uVar2 = *(iVar3 + param_2);\n        *(iVar3 + param_2) = *(param_2 + iVar6);\n        iVar3 = iVar3 + 1;\n        *(param_2 + iVar6) = uVar2;\n    } while (iVar3 < 0x22e5);\n    return 0;\n}\n",
        "token_count": 669
    },
    "00405b93": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00405b93(int32_t *param_1)\n\n{\n    if (param_1[1] != 0) {\n        fcn.00418300(param_1[1]);\n        param_1[1] = 0;\n    }\n    if (param_1[2] != 0) {\n        fcn.00418300(param_1[2]);\n        param_1[2] = 0;\n    }\n    if ((param_1[3] != 0) && (param_1[3] != -1)) {\n        (**(*param_1 + 0x48))();\n        param_1[3] = 0;\n    }\n    return;\n}\n",
        "token_count": 156
    },
    "00405c9d": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.00405c9d(int32_t arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    uint *in_ECX;\n    int64_t iVar1;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_4h;\n    \n    var_24h = arg_1ch;\n    var_20h = arg_18h;\n    var_1ch = arg_14h;\n    var_18h = arg_10h;\n    var_14h = arg_ch + -1;\n    var_10h = arg_8h + -0x76c;\n    var_4h = arg_20h;\n    iVar1 = fcn.00408f32(&var_24h);\n    *in_ECX = iVar1;\n    in_ECX[1] = iVar1 >> 0x20;\n    if (iVar1 == -1) {\n        fcn.004010c0(0x80070057);\n    }\n    return;\n}\n",
        "token_count": 282
    },
    "00405e82": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00405e82(int32_t *param_1, int32_t param_2)\n\n{\n    if ((param_2 == -1) && (param_2 = *param_1,  param_2 != 0)) {\n        param_2 = fcn.004089d0(param_2);\n    }\n    fcn.00403020(param_2);\n    return;\n}\n",
        "token_count": 91
    },
    "00405f5b": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00405f5b(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uchar *arg_8h;\n    uchar *puVar4;\n    uchar *puVar5;\n    \n    fcn.00405b93();\n    if (param_2 == 0) {\n        param_2 = 0x41f970;\n    }\n    else {\n        uVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(param_2);\n        if (0x103 < uVar3) {\n            uVar2 = 0xa0;\n            goto code_r0x00405fb2;\n        }\n    }\n    iVar1 = fcn.004182d5(0x140);\n    *(param_1 + 8) = iVar1;\n    (*_sym.imp.KERNEL32.dll_lstrcpyA)(iVar1 + 0x2c, param_2);\n    iVar1 = (*_sym.imp.KERNEL32.dll_FindFirstFileA)(param_2, *(param_1 + 8));\n    *(param_1 + 0xc) = iVar1;\n    if (iVar1 != -1) {\n        arg_8h = fcn.00405f1e(0x104);\n        iVar1 = fcn.00408f3f(arg_8h, param_2, 0x104);\n        if (iVar1 == 0) {\n            fcn.00403020(0);\n            fcn.00405b93();\n            (*_sym.imp.KERNEL32.dll_SetLastError)(0x7b);\n            return 0;\n        }\n        puVar4 = fcn.00408c28(arg_8h, 0x5c);\n        puVar5 = fcn.00408c28(arg_8h, 0x2f);\n        if ((puVar5 != NULL) || (puVar5 = arg_8h,  puVar4 != NULL)) {\n            if (puVar4 == NULL) {\n                puVar4 = arg_8h;\n            }\n            if (puVar5 < puVar4) {\n                *puVar4 = 0;\n            }\n            else {\n                *puVar5 = 0;\n            }\n        }\n        fcn.00405e82(0xffffffff);\n        return 1;\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    fcn.00405b93();\ncode_r0x00405fb2:\n    (*_sym.imp.KERNEL32.dll_SetLastError)(uVar2);\n    return 0;\n}\n",
        "token_count": 583
    },
    "004078e4": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.004078e4(int32_t param_1, int32_t param_2, uint param_3)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iStack12;\n    uint uStack8;\n    \n    puVar4 = &stack0xfffffffc;\n    if ((*(param_1 + 4) & 6) == 0) {\n        iStack12 = param_1;\n        uStack8 = param_3;\n        *(param_2 + -4) = &iStack12;\n        iVar5 = *(param_2 + 0xc);\n        iVar3 = *(param_2 + 8);\n        iVar2 = fcn.0040ac45(param_2);\n        if (iVar2 == 0) {\n            *(param_1 + 4) = *(param_1 + 4) | 8;\n        }\n        else {\n            for (; iVar5 != -1; iVar5 = *(iVar3 + iVar5 * 0xc)) {\n                pcVar1 = *(iVar3 + 4 + iVar5 * 0xc);\n                if (pcVar1 != NULL) {\n                    iVar3 = (*pcVar1)();\n                    param_2 = *(puVar4 + 0xc);\n                    if (iVar3 != 0) {\n                        if (iVar3 < 0) {\n                            return 0;\n                        }\n                        iVar3 = *(param_2 + 8);\n                        fcn.004077ec(param_2);\n                        puVar4 = param_2 + 0x10;\n                        fcn.0040782e(param_2, iVar5);\n                        fcn.004078c2(1);\n                        *(param_2 + 0xc) = *(iVar3 + extraout_ECX * 4);\n                        param_2 = 0;\n                        iVar5 = 0;\n                        (**(iVar3 + 8 + extraout_ECX * 4))();\n                    }\n                }\n                iVar3 = *(param_2 + 8);\n            }\n        }\n    }\n    else {\n        fcn.0040782e(param_2, 0xffffffff, &stack0xfffffffc, &stack0xfffffffc);\n    }\n    return 1;\n}\n",
        "token_count": 512
    },
    "0040b1c5": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040b1c5(uint32_t arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t arg_8h_00;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    piVar2 = arg_ch;\n    uVar1 = arg_ch[3];\n    arg_8h_00 = arg_ch[4];\n    if (((uVar1 & 0x82) == 0) || ((uVar1 & 0x40) != 0)) {\ncode_r0x0040b2d1:\n        arg_ch[3] = uVar1 | 0x20;\n    }\n    else {\n        if ((uVar1 & 1) != 0) {\n            arg_ch[1] = 0;\n            if ((uVar1 & 0x10) == 0) goto code_r0x0040b2d1;\n            *arg_ch = arg_ch[2];\n            arg_ch[3] = uVar1 & 0xfffffffe;\n        }\n        uVar1 = arg_ch[3];\n        arg_ch[1] = 0;\n        arg_ch = NULL;\n        piVar2[3] = uVar1 & 0xffffffef | 2;\n        if (((uVar1 & 0x10c) == 0) &&\n           (((piVar2 != 0x427e30 && (piVar2 != 0x427e50)) || (iVar3 = fcn.004102ed(arg_8h_00),  iVar3 == 0)))) {\n            fcn.004102a9(piVar2);\n        }\n        if ((*(piVar2 + 3) & 0x108) == 0) {\n            iVar3 = 1;\n            arg_ch = fcn.004101fe(arg_8h_00, &arg_8h, 1);\n        }\n        else {\n            iVar4 = piVar2[2];\n            iVar3 = *piVar2;\n            *piVar2 = iVar4 + 1;\n            iVar3 = iVar3 - iVar4;\n            piVar2[1] = piVar2[6] + -1;\n            if (iVar3 < 1) {\n                if (arg_8h_00 == 0xffffffff) {\n                    iVar4 = 0x4281c0;\n                }\n                else {\n                    iVar4 = *((arg_8h_00 >> 5) * 4 + 0x42b260) + (arg_8h_00 & 0x1f) * 0x24;\n                }\n                if ((*(iVar4 + 4) & 0x20) != 0) {\n                    fcn.0040ff85(arg_8h_00, 0, 2);\n                }\n            }\n            else {\n                arg_ch = fcn.004101fe(arg_8h_00, iVar4, iVar3);\n            }\n            *piVar2[2] = arg_8h;\n        }\n        if (arg_ch == iVar3) {\n            return arg_8h & 0xff;\n        }\n        piVar2[3] = piVar2[3] | 0x20;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 731
    },
    "0040cc9d": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t fcn.0040cc9d(uint8_t **param_1)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    uint8_t *puVar3;\n    int32_t iVar4;\n    \n    puVar3 = param_1[3];\n    if (((puVar3 & 0x83) != 0) && ((puVar3 & 0x40) == 0)) {\n        if ((puVar3 & 2) == 0) {\n            param_1[3] = puVar3 | 1;\n            if ((puVar3 & 0x10c) == 0) {\n                fcn.004102a9(param_1);\n            }\n            else {\n                *param_1 = param_1[2];\n            }\n            puVar3 = fcn.0041224c(param_1[4], param_1[2], param_1[6]);\n            param_1[1] = puVar3;\n            if ((puVar3 != NULL) && (puVar3 != 0xffffffff)) {\n                if ((param_1[3] & 0x82) == 0) {\n                    puVar2 = param_1[4];\n                    if (puVar2 == 0xffffffff) {\n                        iVar4 = 0x4281c0;\n                    }\n                    else {\n                        iVar4 = *((puVar2 >> 5) * 4 + 0x42b260) + (puVar2 & 0x1f) * 0x24;\n                    }\n                    if ((*(iVar4 + 4) & 0x82) == 0x82) {\n                        param_1[3] = param_1[3] | 0x2000;\n                    }\n                }\n                if (((param_1[6] == 0x200) && ((param_1[3] & 8) != 0)) && ((param_1[3] & 0x400) == 0)) {\n                    param_1[6] = 0x1000;\n                }\n                param_1[1] = puVar3 + -1;\n                uVar1 = **param_1;\n                *param_1 = *param_1 + 1;\n                return uVar1;\n            }\n            param_1[3] = param_1[3] | (-(puVar3 != NULL) & 0x10) + 0x10;\n            param_1[1] = NULL;\n        }\n        else {\n            param_1[3] = puVar3 | 0x20;\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 581
    },
    "00411d9e": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00411d9e(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00408fec(0x422738, 0x14);\n    *(unaff_EBP + -0x1c) = 0xffffffff;\n    iVar2 = fcn.00409fcb(0xb);\n    if (iVar2 != 0) {\n        fcn.0040a06b(0xb);\n        *(unaff_EBP + -4) = 0;\n        for (iVar2 = 0; *(unaff_EBP + -0x24) = iVar2,  iVar2 < 0x40; iVar2 = iVar2 + 1) {\n            puVar4 = *(iVar2 * 4 + 0x42b260);\n            if (puVar4 == NULL) {\n                puVar4 = fcn.00407684(0x480);\n                *(unaff_EBP + -0x20) = puVar4;\n                if (puVar4 != NULL) {\n                    piVar1 = iVar2 * 4 + 0x42b260;\n                    *piVar1 = puVar4;\n                    *0x42b254 = *0x42b254 + 0x20;\n                    while (puVar4 < *piVar1 + 0x480) {\n                        *(puVar4 + 1) = 0;\n                        *puVar4 = 0xffffffff;\n                        *(puVar4 + 5) = 10;\n                        puVar4[2] = 0;\n                        puVar4 = puVar4 + 9;\n                        *(unaff_EBP + -0x20) = puVar4;\n                    }\n                    *(unaff_EBP + -0x1c) = iVar2 << 5;\n                    iVar2 = fcn.00411cdc(iVar2 << 5);\n                    if (iVar2 == 0) {\n                        *(unaff_EBP + -0x1c) = 0xffffffff;\n                    }\n                }\n                break;\n            }\n            for (; *(unaff_EBP + -0x20) = puVar4,  puVar4 < *(iVar2 * 4 + 0x42b260) + 0x480; puVar4 = puVar4 + 9) {\n                if ((*(puVar4 + 1) & 1) == 0) {\n                    if (puVar4[2] == 0) {\n                        fcn.0040a06b(10);\n                        *(unaff_EBP + -4) = 1;\n                        if (puVar4[2] == 0) {\n                            iVar3 = fcn.0040fe86(puVar4 + 3, 4000);\n                            if (iVar3 == 0) {\n                                fcn.0040782e(unaff_EBP + -0x10, 0xffffffff);\n                                goto code_r0x00411f0b;\n                            }\n                            puVar4[2] = puVar4[2] + 1;\n                        }\n                        *(unaff_EBP + -4) = 0;\n                        fcn.00411e77();\n                    }\n                    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(puVar4 + 3);\n                    if ((*(puVar4 + 1) & 1) == 0) {\n                        *puVar4 = 0xffffffff;\n                        *(unaff_EBP + -0x1c) = (puVar4 - *(iVar2 * 4 + 0x42b260)) / 0x24 + iVar2 * 0x20;\n                        break;\n                    }\n                    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar4 + 3);\n                }\n            }\n            if (*(unaff_EBP + -0x1c) != -1) break;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00411f11();\n    }\ncode_r0x00411f0b:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 964
    },
    "00415948": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nint32_t __cdecl fcn.00415948(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    fcn.004166ca(0);\n    iVar1 = *0x42b07c;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = iVar1;\n    uVar2 = fcn.004153ff();\n    iVar3 = fcn.0041677a(uVar2);\n    if ((iVar3 == 0) && (iVar3 = iVar1,  iVar1 == 0)) {\n        iVar3 = fcn.0041563d(unaff_EBP + -0x10);\n        if (iVar3 == -1) {\n            fcn.004170eb(\"bad cast\");\n            fcn.00408230(unaff_EBP + -0x20, 0x4248bc);\n        }\n        iVar3 = *(unaff_EBP + -0x10);\n        *0x42b07c = iVar3;\n        fcn.00414e18();\n        fcn.004167f2();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004166ed();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar3;\n}\n",
        "token_count": 395
    },
    "00415f66": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00415f66(int32_t param_1, int32_t param_2)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint unaff_retaddr;\n    \n    if (param_2 == -1) {\n        fcn.00415368();\n    }\n    cVar1 = fcn.00403a90(param_2, 0);\n    if (cVar1 != '\\0') {\n        if (*(param_1 + 0x18) < 0x10) {\n            iVar2 = param_1 + 4;\n        }\n        else {\n            iVar2 = *(param_1 + 4);\n        }\n        fcn.004153c5(iVar2, param_2, unaff_retaddr);\n        fcn.004034d0(param_2);\n    }\n    return param_1;\n}\n",
        "token_count": 192
    },
    "00417fff": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00417fff(int32_t param_1, int32_t **param_2, int32_t *param_3, int32_t *param_4)\n\n{\n    int32_t **ppiVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    \n    piVar3 = *param_2;\n    if (piVar3 != NULL) {\n        if (piVar3 == 0xffffffff) {\n            uVar4 = 0;\n            if (*(param_1 + 8) != 0) {\n                ppiVar1 = *(param_1 + 4);\n                while (piVar3 = *ppiVar1,  piVar3 == NULL) {\n                    uVar4 = uVar4 + 1;\n                    ppiVar1 = ppiVar1 + 1;\n                    if (*(param_1 + 8) <= uVar4) {\n                        *param_2 = NULL;\n                        return;\n                    }\n                }\n            }\n        }\n        piVar5 = *piVar3;\n        if (piVar5 == NULL) {\n            uVar4 = *(param_1 + 8);\n            uVar2 = (piVar3[1] >> 4) % uVar4 + 1;\n            if (uVar2 < uVar4) {\n                ppiVar1 = *(param_1 + 4) + uVar2 * 4;\n                do {\n                    piVar5 = *ppiVar1;\n                    if (piVar5 != NULL) break;\n                    uVar2 = uVar2 + 1;\n                    ppiVar1 = ppiVar1 + 1;\n                } while (uVar2 < uVar4);\n            }\n        }\n        *param_2 = piVar5;\n        *param_3 = piVar3[1];\n        *param_4 = piVar3[2];\n    }\n    return;\n}\n",
        "token_count": 434
    },
    "0041ca2a": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint __cdecl fcn.0041ca2a(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    piVar1 = fcn.00418200(extraout_ECX);\n    iVar2 = (**(*piVar1 + 0xc))();\n    *(unaff_EBP + -0x10) = iVar2 + 0x10;\n    *(unaff_EBP + -4) = 0;\n    fcn.00405961(*(unaff_EBP + 8));\n    iVar2 = *(unaff_EBP + 0x10);\n    if (iVar2 == -1) {\n        iVar2 = *(unaff_EBP + 8);\n    }\n    uVar3 = fcn.0041ca08(*(unaff_EBP + -0x10), *(unaff_EBP + 0xc), iVar2);\n    fcn.004010e0();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 340
    },
    "0041d4a1": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.0041d4a1(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uStack12;\n    \n    param_1[5] = 0;\n    param_1[6] = 0;\n    param_1[6] = 4;\n    param_1[1] = 0;\n    param_1[2] = 1;\n    param_1[3] = 0;\n    param_1[4] = 0;\n    iVar3 = (*_sym.imp.KERNEL32.dll_TlsAlloc)();\n    *param_1 = iVar3;\n    if (iVar3 == -1) {\n        uStack12 = 0x428bf0;\n        fcn.00408230(&stack0xfffffff4, 0x423f40);\n        pcVar1 = swi(3);\n        piVar2 = (*pcVar1)();\n        return piVar2;\n    }\n    uStack12 = 0x41d4df;\n    (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)();\n    return param_1;\n}\n",
        "token_count": 261
    },
    "004048f0": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.004048f0(void)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    char *pcVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint *in_FS_OFFSET;\n    uchar *puStack424;\n    int32_t *piStack420;\n    uchar *puStack416;\n    uchar *puStack412;\n    char *pcStack408;\n    uchar *puStack404;\n    char *pcStack400;\n    uchar *puStack396;\n    char *pcStack392;\n    uchar *puStack388;\n    uchar *puStack368;\n    int32_t iStack364;\n    uint uStack360;\n    uint uStack356;\n    uchar *puStack352;\n    int32_t iStack348;\n    int32_t **ppiStack344;\n    int32_t iStack320;\n    int32_t iStack316;\n    int32_t iStack312;\n    uint uStack304;\n    uint uStack300;\n    uint uStack296;\n    char *pcStack292;\n    uint uStack288;\n    uint uStack284;\n    uint uStack280;\n    uint uStack276;\n    uint uStack76;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x41e4c6;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    uStack304 = 0;\n    uStack300 = 0;\n    uStack296 = 0x428a90;\n    pcStack292 = \"Select folder.\";\n    uStack288 = 5;\n    uStack284 = 0x402f00;\n    uStack280 = 0;\n    uStack276 = 0;\n    iVar3 = (*_sym.imp.SHELL32.dll_SHBrowseForFolderA)();\n    if (iVar3 != 0) {\n        ppiStack344 = 0x40495f;\n        iStack312 = iVar3;\n        piVar4 = fcn.00418200();\n        ppiStack344 = 0x404966;\n        iVar5 = (**(*piVar4 + 0xc))();\n        iVar5 = iVar5 + 0x10;\n        uStack8 = 0;\n        ppiStack344 = 0x404979;\n        piVar4 = fcn.00418200();\n        ppiStack344 = 0x404980;\n        iStack320 = (**(*piVar4 + 0xc))();\n        iStack320 = iStack320 + 0x10;\n        ppiStack344 = &stack0xfffffec4;\n        uStack8 = CONCAT31(uStack8._1_3_, 1);\n        iStack348 = 0x40499a;\n        (*_sym.imp.SHELL32.dll_SHGetMalloc)();\n        if (iStack316 != 0) {\n            ppiStack344 = &stack0xfffffeec;\n            *0x428b9c = 0;\n            *0x428b98 = 3;\n            iVar8 = 0;\n            puStack352 = 0x4049c2;\n            iStack348 = iVar3;\n            (*_sym.imp.SHELL32.dll_SHGetPathFromIDListA)();\n            puStack352 = &stack0xfffffee4;\n            uStack356 = 0x4049cd;\n            (*_sym.imp.KERNEL32.dll_SetCurrentDirectoryA)();\n            uStack356 = 0x428a90;\n            uStack360 = 0x104;\n            iStack364 = 0x4049dd;\n            (*_sym.imp.KERNEL32.dll_GetCurrentDirectoryA)();\n            pcVar6 = &stack0xfffffed8;\n            do {\n                cVar1 = *pcVar6;\n                pcVar6 = pcVar6 + 1;\n            } while (cVar1 != '\\0');\n            iStack364 = pcVar6 - &stack0xfffffed9;\n            puStack368 = &stack0xfffffed8;\n            fcn.004039f0();\n            fcn.00417a34(0, 0xffffffff);\n            puStack388 = 0x404a16;\n            fcn.00417a34(0, 0xffffffff);\n            puStack388 = &stack0xfffffe90;\n            pcStack392 = 0x404a20;\n            fcn.004046d0();\n            iVar3 = *0x428bc4;\n            iVar9 = iVar8;\n            if ((0 < *0x428bc4) && (iVar10 = 0,  0 < *0x428bc4)) {\n                do {\n                    if ((iVar10 < 0) || (*0x428bc4 <= iVar10)) goto code_r0x00404c2b;\n                    pcStack392 = 0x404a5a;\n                    fcn.00404030();\n                    pcStack392 = &stack0xfffffe8c;\n                    puStack396 = 0x404a64;\n                    iVar7 = fcn.004031f0();\n                    if (iVar7 != 0) {\n                        pcStack392 = &stack0xfffffe8c;\n                        puStack396 = 0x404a75;\n                        iVar7 = fcn.004032e0();\n                        *0x428b9c = *0x428b9c + iVar7;\n                    }\n                    iVar10 = iVar10 + 1;\n                } while (iVar10 < iVar3);\n            }\n            puStack388 = &stack0xfffffec0;\n            puStack396 = &stack0xfffffe94;\n            pcStack392 = \"The folder, %s\";\n            pcStack400 = 0x404a9f;\n            fcn.00403ef0();\n            puStack388 = &stack0xfffffe94;\n            pcStack392 = *0x428bb0;\n            puStack396 = 0x404ab8;\n            fcn.00417b76();\n            puStack396 = *0x428b9c;\n            puStack404 = &stack0xfffffe8c;\n            pcStack400 = \"Contains %d lines of C or C++ code.\";\n            pcStack408 = 0x404acd;\n            fcn.00403ef0();\n            puStack396 = &stack0xfffffe8c;\n            pcStack400 = *0x428bb0;\n            puStack404 = 0x404ae5;\n            fcn.00417b76();\n            puStack404 = 0x13;\n            pcStack408 = \"The C or C++ Files:\";\n            puStack412 = 0x404af5;\n            fcn.004039f0();\n            puStack412 = &stack0xfffffe7c;\n            puStack416 = *0x428bb0;\n            piStack420 = 0x404b0b;\n            fcn.00417b76();\n            iVar3 = *0x428bc4;\n            if ((0 < *0x428bc4) && (iVar10 = 0,  0 < *0x428bc4)) {\n                do {\n                    if ((iVar10 < 0) || (*0x428bc4 <= iVar10)) {\ncode_r0x00404c2b:\n                        puStack424 = 0x428d20;\n                        piStack420 = iVar9;\n                        fcn.00408230(&stack0xfffffe58, 0x423f84);\n                        pcVar2 = swi(3);\n                        (*pcVar2)();\n                        return;\n                    }\n                    puStack416 = *0x428bc0 + iVar10 * 4;\n                    puStack424 = 0x404b46;\n                    fcn.00404030();\n                    puStack424 = &stack0xfffffe6c;\n                    iVar7 = fcn.004031f0();\n                    iVar8 = iVar9;\n                    if (iVar7 != 0) {\n                        *0x428b98 = *0x428b98 + 1;\n                        puStack424 = &stack0xfffffe6c;\n                        puStack416 = *0x428bb0;\n                        fcn.00417b76();\n                        iVar8 = *(puStack412 + -0xc);\n                        if (*(puStack412 + -0xc) < iVar9) {\n                            iVar8 = iVar9;\n                        }\n                    }\n                    iVar10 = iVar10 + 1;\n                    iVar9 = iVar8;\n                } while (iVar10 < iVar3);\n            }\n            piStack420 = NULL;\n            puStack424 = NULL;\n            *0x428ba0 = iVar8 + 4;\n            (*_sym.imp.USER32.dll_SendMessageA)(uStack76, 0x401);\n            (*_sym.imp.USER32.dll_InvalidateRect)(uStack76, 0, 1);\n            (**(*piStack420 + 0x14))(piStack420, puStack416);\n        }\n        ppiStack344 = iStack320 + -0x10;\n        uStack8 = uStack8 & 0xffffff00;\n        piVar4 = iStack320 + -4;\n        LOCK();\n        iVar3 = *piVar4;\n        *piVar4 = *piVar4 + -1;\n        if (iVar3 == 1 || iVar3 + -1 < 0) {\n            iStack348 = 0x404be9;\n            (**(**ppiStack344 + 4))();\n        }\n        ppiStack344 = iVar5 + -0x10;\n        uStack8 = 0xffffffff;\n        piVar4 = iVar5 + -4;\n        LOCK();\n        iVar3 = *piVar4;\n        *piVar4 = *piVar4 + -1;\n        if (iVar3 == 1 || iVar3 + -1 < 0) {\n            iStack348 = 0x404c12;\n            (**(**ppiStack344 + 4))();\n        }\n    }\n    *in_FS_OFFSET = uStack16;\n    return;\n}\n",
        "token_count": 2217
    },
    "00410445": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nuint32_t fcn.00410445(void)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    uint32_t uVar12;\n    uint32_t uVar13;\n    uint32_t uVar14;\n    uint32_t uVar15;\n    uint32_t uVar16;\n    uint32_t uVar17;\n    uint32_t uVar18;\n    uint32_t uVar19;\n    uint32_t uVar20;\n    uint32_t uVar21;\n    uint32_t uVar22;\n    uint32_t uVar23;\n    uint32_t uVar24;\n    uint32_t uVar25;\n    uint32_t uVar26;\n    uint32_t uVar27;\n    uint32_t uVar28;\n    uint32_t uVar29;\n    uint32_t uVar30;\n    uint32_t uVar31;\n    uint32_t uVar32;\n    uint32_t uVar33;\n    uint32_t uVar34;\n    uint32_t uVar35;\n    uint32_t uVar36;\n    uint32_t uVar37;\n    uint32_t uVar38;\n    uint32_t uVar39;\n    uint32_t uVar40;\n    uint32_t uVar41;\n    uint32_t uVar42;\n    uint32_t uVar43;\n    uint32_t uVar44;\n    uint32_t arg_ch;\n    int32_t unaff_ESI;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = *0x42afea;\n    arg_ch = *0x42afec;\n    if (unaff_ESI == 0) {\n        return 0xffffffff;\n    }\n    uVar2 = fcn.004133b1(1, uVar1, 0x31, unaff_ESI + 4);\n    uVar3 = fcn.004133b1(1, uVar1, 0x32, unaff_ESI + 8);\n    uVar4 = fcn.004133b1(1, uVar1, 0x33, unaff_ESI + 0xc);\n    uVar5 = fcn.004133b1(1, uVar1, 0x34, unaff_ESI + 0x10);\n    uVar6 = fcn.004133b1(1, uVar1, 0x35, unaff_ESI + 0x14);\n    uVar7 = fcn.004133b1(1, uVar1, 0x36, unaff_ESI + 0x18);\n    uVar8 = fcn.004133b1(1, uVar1, 0x37, unaff_ESI);\n    uVar9 = fcn.004133b1(1, uVar1, 0x2a, unaff_ESI + 0x20);\n    uVar10 = fcn.004133b1(1, uVar1, 0x2b, unaff_ESI + 0x24);\n    uVar11 = fcn.004133b1(1, uVar1, 0x2c, unaff_ESI + 0x28);\n    uVar12 = fcn.004133b1(1, uVar1, 0x2d, unaff_ESI + 0x2c);\n    uVar13 = fcn.004133b1(1, uVar1, 0x2e, unaff_ESI + 0x30);\n    uVar14 = fcn.004133b1(1, uVar1, 0x2f, unaff_ESI + 0x34);\n    uVar15 = fcn.004133b1(1, uVar1, 0x30, unaff_ESI + 0x1c);\n    uVar16 = fcn.004133b1(1, uVar1, 0x44, unaff_ESI + 0x38);\n    uVar17 = fcn.004133b1(1, uVar1, 0x45, unaff_ESI + 0x3c);\n    uVar18 = fcn.004133b1(1, uVar1, 0x46, unaff_ESI + 0x40);\n    uVar19 = fcn.004133b1(1, uVar1, 0x47, unaff_ESI + 0x44);\n    uVar20 = fcn.004133b1(1, uVar1, 0x48, unaff_ESI + 0x48);\n    uVar21 = fcn.004133b1(1, uVar1, 0x49, unaff_ESI + 0x4c);\n    uVar22 = fcn.004133b1(1, uVar1, 0x4a, unaff_ESI + 0x50);\n    uVar23 = fcn.004133b1(1, uVar1, 0x4b, unaff_ESI + 0x54);\n    uVar24 = fcn.004133b1(1, uVar1, 0x4c, unaff_ESI + 0x58);\n    uVar25 = fcn.004133b1(1, uVar1, 0x4d, unaff_ESI + 0x5c);\n    uVar26 = fcn.004133b1(1, uVar1, 0x4e, unaff_ESI + 0x60);\n    uVar27 = fcn.004133b1(1, uVar1, 0x4f, unaff_ESI + 100);\n    uVar28 = fcn.004133b1(1, uVar1, 0x38, unaff_ESI + 0x68);\n    uVar29 = fcn.004133b1(1, uVar1, 0x39, unaff_ESI + 0x6c);\n    uVar30 = fcn.004133b1(1, uVar1, 0x3a, unaff_ESI + 0x70);\n    uVar31 = fcn.004133b1(1, uVar1, 0x3b, unaff_ESI + 0x74);\n    uVar32 = fcn.004133b1(1, uVar1, 0x3c, unaff_ESI + 0x78);\n    uVar33 = fcn.004133b1(1, uVar1, 0x3d, unaff_ESI + 0x7c);\n    uVar34 = fcn.004133b1(1, uVar1, 0x3e, unaff_ESI + 0x80);\n    uVar35 = fcn.004133b1(1, uVar1, 0x3f, unaff_ESI + 0x84);\n    uVar36 = fcn.004133b1(1, uVar1, 0x40, unaff_ESI + 0x88);\n    uVar37 = fcn.004133b1(1, uVar1, 0x41, unaff_ESI + 0x8c);\n    uVar38 = fcn.004133b1(1, uVar1, 0x42, unaff_ESI + 0x90);\n    uVar39 = fcn.004133b1(1, uVar1, 0x43, unaff_ESI + 0x94);\n    uVar40 = fcn.004133b1(1, uVar1, 0x28, unaff_ESI + 0x98);\n    uVar1 = fcn.004133b1(1, uVar1, 0x29, unaff_ESI + 0x9c);\n    uVar41 = fcn.004133b1(1, arg_ch, 0x1f, unaff_ESI + 0xa0);\n    uVar42 = fcn.004133b1(1, arg_ch, 0x20, unaff_ESI + 0xa4);\n    uVar43 = fcn.004133b1(1, arg_ch, 0x1003, unaff_ESI + 0xa8);\n    uVar44 = fcn.004133b1(0, arg_ch, 0x1009, unaff_ESI + 0xb0);\n    *(unaff_ESI + 0xac) = arg_ch;\n    return uVar2 | uVar3 | uVar4 | uVar5 | uVar6 | uVar7 | uVar8 | uVar9 | uVar10 | uVar11 | uVar12 | uVar13 | uVar14 |\n           uVar15 | uVar16 | uVar17 | uVar18 | uVar19 | uVar20 | uVar21 | uVar22 | uVar23 | uVar24 | uVar25 | uVar26 |\n           uVar27 | uVar28 | uVar29 | uVar30 | uVar31 | uVar32 | uVar33 | uVar34 | uVar35 | uVar36 | uVar37 | uVar38 |\n           uVar39 | uVar40 | uVar1 | uVar41 | uVar42 | uVar43 | uVar44;\n}\n",
        "token_count": 2146
    },
    "004168b3": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004168b3(int32_t *param_1)\n\n{\n    int32_t *arg_ch;\n    \n    if (param_1[0x14] != 0) {\n        if (param_1[0x15] < 0x10) {\n            arg_ch = param_1 + 0x10;\n        }\n        else {\n            arg_ch = param_1[0x10];\n        }\n        fcn.0040c647(0, arg_ch);\n    }\n    fcn.004035c0(1, 0);\n    fcn.004035c0(1, 0);\n    fcn.004035c0(1, 0);\n    fcn.004035c0(1, 0);\n    fcn.00416adc(*param_1 * 0x18 + 0x42b128);\n    return;\n}\n",
        "token_count": 195
    },
    "004062eb": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004062eb(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    ushort unaff_SI;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        fcn.0041c0f2(2, *(param_1 + 0x14));\n    }\n    uVar1 = *(param_1 + 0x28) + 2;\n    if (*(param_1 + 0x2c) <= uVar1 && uVar1 != *(param_1 + 0x2c)) {\n        fcn.0041bc96();\n    }\n    **(param_1 + 0x28) = unaff_SI;\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 2;\n    return param_1;\n}\n",
        "token_count": 197
    },
    "00406327": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00406327(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint unaff_ESI;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        fcn.0041c0f2(2, *(param_1 + 0x14));\n    }\n    uVar1 = *(param_1 + 0x28) + 4;\n    if (*(param_1 + 0x2c) <= uVar1 && uVar1 != *(param_1 + 0x2c)) {\n        fcn.0041bc96();\n    }\n    **(param_1 + 0x28) = unaff_ESI;\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 4;\n    return param_1;\n}\n",
        "token_count": 199
    },
    "00406362": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00406362(int32_t param_1)\n\n{\n    ushort *unaff_ESI;\n    \n    if ((*(param_1 + 0x18) & 1) == 0) {\n        fcn.0041c0f2(4, *(param_1 + 0x14));\n    }\n    if (*(param_1 + 0x2c) < *(param_1 + 0x28) + 2U) {\n        fcn.0041bd0d((*(param_1 + 0x28) - *(param_1 + 0x2c)) + 2);\n    }\n    *unaff_ESI = **(param_1 + 0x28);\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 2;\n    return param_1;\n}\n",
        "token_count": 195
    },
    "004063a5": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004063a5(int32_t param_1)\n\n{\n    uint *unaff_ESI;\n    \n    if ((*(param_1 + 0x18) & 1) == 0) {\n        fcn.0041c0f2(4, *(param_1 + 0x14));\n    }\n    if (*(param_1 + 0x2c) < *(param_1 + 0x28) + 4U) {\n        fcn.0041bd0d((*(param_1 + 0x28) - *(param_1 + 0x2c)) + 4);\n    }\n    *unaff_ESI = **(param_1 + 0x28);\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 4;\n    return param_1;\n}\n",
        "token_count": 196
    },
    "004063e7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004063e7(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uchar unaff_SI;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        fcn.0041c0f2(2, *(param_1 + 0x14));\n    }\n    uVar1 = *(param_1 + 0x28) + 1;\n    if (*(param_1 + 0x2c) <= uVar1 && uVar1 != *(param_1 + 0x2c)) {\n        fcn.0041bc96();\n    }\n    **(param_1 + 0x28) = unaff_SI;\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 1;\n    return param_1;\n}\n",
        "token_count": 198
    },
    "0040641f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040641f(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint unaff_ESI;\n    uint unaff_retaddr;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        fcn.0041c0f2(2, *(param_1 + 0x14));\n    }\n    uVar2 = *(param_1 + 0x28) + 8;\n    if (*(param_1 + 0x2c) <= uVar2 && uVar2 != *(param_1 + 0x2c)) {\n        fcn.0041bc96();\n    }\n    puVar1 = *(param_1 + 0x28);\n    *puVar1 = unaff_ESI;\n    puVar1[1] = unaff_retaddr;\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 8;\n    return param_1;\n}\n",
        "token_count": 235
    },
    "00406461": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00406461(int32_t param_1)\n\n{\n    uchar *unaff_ESI;\n    \n    if ((*(param_1 + 0x18) & 1) == 0) {\n        fcn.0041c0f2(4, *(param_1 + 0x14));\n    }\n    if (*(param_1 + 0x2c) < *(param_1 + 0x28) + 1U) {\n        fcn.0041bd0d((*(param_1 + 0x28) - *(param_1 + 0x2c)) + 1);\n    }\n    *unaff_ESI = **(param_1 + 0x28);\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 1;\n    return param_1;\n}\n",
        "token_count": 195
    },
    "004064a0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004064a0(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint *unaff_ESI;\n    \n    if ((*(param_1 + 0x18) & 1) == 0) {\n        fcn.0041c0f2(4, *(param_1 + 0x14));\n    }\n    if (*(param_1 + 0x2c) < *(param_1 + 0x28) + 8U) {\n        fcn.0041bd0d((*(param_1 + 0x28) - *(param_1 + 0x2c)) + 8);\n    }\n    puVar1 = *(param_1 + 0x28);\n    *unaff_ESI = *puVar1;\n    unaff_ESI[1] = puVar1[1];\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 8;\n    return param_1;\n}\n",
        "token_count": 227
    },
    "0040ae70": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040ae70(uint *arg_8h, uint8_t *arg_ch)\n\n{\n    uint16_t uVar1;\n    uint uVar2;\n    uint8_t uVar3;\n    bool bVar4;\n    \n    if ((arg_8h & 3) != 0) {\n        if ((arg_8h & 1) != 0) {\n            uVar3 = *arg_8h;\n            arg_8h = arg_8h + 1;\n            bVar4 = uVar3 < *arg_ch;\n            if (uVar3 != *arg_ch) goto code_r0x0040aeb4;\n            arg_ch = arg_ch + 1;\n            if (uVar3 == 0) {\n                return 0;\n            }\n            if ((arg_8h & 2) == 0) goto code_r0x0040ae80;\n        }\n        uVar1 = *arg_8h;\n        arg_8h = arg_8h + 2;\n        uVar3 = uVar1;\n        bVar4 = uVar3 < *arg_ch;\n        if (uVar3 != *arg_ch) goto code_r0x0040aeb4;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        uVar3 = uVar1 >> 8;\n        bVar4 = uVar3 < arg_ch[1];\n        if (uVar3 != arg_ch[1]) goto code_r0x0040aeb4;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        arg_ch = arg_ch + 2;\n    }\ncode_r0x0040ae80:\n    while( true ) {\n        uVar2 = *arg_8h;\n        uVar3 = uVar2;\n        bVar4 = uVar3 < *arg_ch;\n        if (uVar3 != *arg_ch) break;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        uVar3 = uVar2 >> 8;\n        bVar4 = uVar3 < arg_ch[1];\n        if (uVar3 != arg_ch[1]) break;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        uVar3 = uVar2 >> 0x10;\n        bVar4 = uVar3 < arg_ch[2];\n        if (uVar3 != arg_ch[2]) break;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        uVar3 = uVar2 >> 0x18;\n        bVar4 = uVar3 < arg_ch[3];\n        if (uVar3 != arg_ch[3]) break;\n        arg_ch = arg_ch + 4;\n        arg_8h = arg_8h + 1;\n        if (uVar3 == 0) {\n            return 0;\n        }\n    }\ncode_r0x0040aeb4:\n    return bVar4 * -2 + 1;\n}\n",
        "token_count": 676
    },
    "0040c8b7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040c8b7(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x420ae0, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x42b254) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x42b260;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.00411cdc(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                puVar3 = fcn.00409c85();\n                *puVar3 = 9;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.0040c834(arg_8h_00);\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0040c92e();\n            goto code_r0x0040c94c;\n        }\n    }\n    puVar3 = fcn.00409c85();\n    *puVar3 = 9;\n    puVar3 = fcn.00409c8e();\n    *puVar3 = 0;\ncode_r0x0040c94c:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 470
    },
    "0040ff85": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040ff85(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x4212c0, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x42b254) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x42b260;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.00411cdc(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                puVar3 = fcn.00409c85();\n                *puVar3 = 9;\n                puVar3 = fcn.00409c8e();\n                *puVar3 = 0;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.0040ff11(arg_8h_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0041000c();\n            goto code_r0x0041002a;\n        }\n    }\n    puVar3 = fcn.00409c85();\n    *puVar3 = 9;\n    puVar3 = fcn.00409c8e();\n    *puVar3 = 0;\ncode_r0x0041002a:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 520
    },
    "004101fe": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004101fe(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x4212d0, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x42b254) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x42b260;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.00411cdc(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                puVar3 = fcn.00409c85();\n                *puVar3 = 9;\n                puVar3 = fcn.00409c8e();\n                *puVar3 = 0;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.00410030(arg_8h_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00410285();\n            goto code_r0x004102a3;\n        }\n    }\n    puVar3 = fcn.00409c85();\n    *puVar3 = 9;\n    puVar3 = fcn.00409c8e();\n    *puVar3 = 0;\ncode_r0x004102a3:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 517
    },
    "00411c9b": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint fcn.00411c9b(uint32_t param_1)\n\n{\n    uint *puVar1;\n    \n    if ((param_1 < *0x42b254) &&\n       (puVar1 = *((param_1 >> 5) * 4 + 0x42b260) + (param_1 & 0x1f) * 0x24,  (*(puVar1 + 1) & 1) != 0)) {\n        return *puVar1;\n    }\n    puVar1 = fcn.00409c85();\n    *puVar1 = 9;\n    puVar1 = fcn.00409c8e();\n    *puVar1 = 0;\n    return 0xffffffff;\n}\n",
        "token_count": 163
    },
    "0041224c": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041224c(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x422770, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x42b254) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x42b260;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.00411cdc(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                puVar3 = fcn.00409c85();\n                *puVar3 = 9;\n                puVar3 = fcn.00409c8e();\n                *puVar3 = 0;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.00412071(arg_8h_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.004122d3();\n            goto code_r0x004122f1;\n        }\n    }\n    puVar3 = fcn.00409c85();\n    *puVar3 = 9;\n    puVar3 = fcn.00409c8e();\n    *puVar3 = 0;\ncode_r0x004122f1:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 517
    },
    "00412e4b": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t fcn.00412e4b(void)\n\n{\n    uint32_t uVar1;\n    uint16_t uVar2;\n    uint16_t unaff_BX;\n    \n    uVar1 = 0;\n    if ((unaff_BX & 1) != 0) {\n        uVar1 = 0x10;\n    }\n    if ((unaff_BX & 4) != 0) {\n        uVar1 = uVar1 | 8;\n    }\n    if ((unaff_BX & 8) != 0) {\n        uVar1 = uVar1 | 4;\n    }\n    if ((unaff_BX & 0x10) != 0) {\n        uVar1 = uVar1 | 2;\n    }\n    if ((unaff_BX & 0x20) != 0) {\n        uVar1 = uVar1 | 1;\n    }\n    if ((unaff_BX & 2) != 0) {\n        uVar1 = uVar1 | 0x80000;\n    }\n    uVar2 = unaff_BX & 0xc00;\n    if ((unaff_BX & 0xc00) != 0) {\n        if (uVar2 == 0x400) {\n            uVar1 = uVar1 | 0x100;\n        }\n        else if (uVar2 == 0x800) {\n            uVar1 = uVar1 | 0x200;\n        }\n        else if (uVar2 == 0xc00) {\n            uVar1 = uVar1 | 0x300;\n        }\n    }\n    if ((unaff_BX & 0x300) == 0) {\n        uVar1 = uVar1 | 0x20000;\n    }\n    else if ((unaff_BX & 0x300) == 0x200) {\n        uVar1 = uVar1 | 0x10000;\n    }\n    if ((unaff_BX & 0x1000) != 0) {\n        uVar1 = uVar1 | 0x40000;\n    }\n    return uVar1;\n}\n",
        "token_count": 474
    },
    "004132f3": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004132f3(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint *puVar2;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    ulong uVar4;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x422810, 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x42b254) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x42b260;\n        iVar3 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar3) & 1) != 0) {\n            fcn.00411cdc(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar3) & 1) == 0) {\n                puVar2 = fcn.00409c85();\n                *puVar2 = 9;\n                puVar2 = fcn.00409c8e();\n                *puVar2 = 0;\n                *(unaff_EBP + -0x20) = 0xffffffff;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar4 = fcn.00413270(arg_8h_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n                *(unaff_EBP + -0x20) = uVar4;\n                *(unaff_EBP + -0x1c) = uVar4 >> 0x20;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0041338b();\n            goto code_r0x004133ab;\n        }\n    }\n    puVar2 = fcn.00409c85();\n    *puVar2 = 9;\n    puVar2 = fcn.00409c8e();\n    *puVar2 = 0;\ncode_r0x004133ab:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 579
    },
    "00415c3a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00415c3a(uint param_1)\n\n{\n    uint32_t unaff_ESI;\n    \n    fcn.004035c0(1, 0);\n    if ((unaff_ESI & 1) != 0) {\n        fcn.00418300(param_1);\n    }\n    return param_1;\n}\n",
        "token_count": 78
    },
    "004199fa": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nbool __cdecl fcn.004199fa(uint32_t arg_8h)\n\n{\n    uint noname_8;\n    uint noname_11;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint32_t uVar3;\n    uint unaff_EDI;\n    bool bVar4;\n    uint *noname_0;\n    uint32_t var_34h;\n    uint var_30h;\n    uint in_stack_ffffffd0;\n    uint in_stack_ffffffd4;\n    uint var_24h;\n    uint in_stack_ffffffdc;\n    uint var_1ch;\n    uint var_18h;\n    uint in_stack_ffffffe8;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_4h = fcn.0041d221();\n    arg_8h = arg_8h & ~*(var_4h + 0x18);\n    if (arg_8h == 0) {\n        bVar4 = true;\n    }\n    else {\n        uVar3 = 0;\n        fcn.00409040(&var_34h, 0, 0x28);\n        var_30h = _sym.imp.USER32.dll_DefWindowProcA;\n        iVar1 = fcn.0041d221();\n        noname_11 = *0x428e18;\n        noname_8 = *(iVar1 + 8);\n        noname_0 = 0x8;\n        var_ch = 8;\n        if ((arg_8h & 1) != 0) {\n            noname_0 = &var_34h;\n            var_34h = 0xb;\n            iVar1 = fcn.00418c8f(noname_0, unaff_EDI, unaff_ESI, unaff_EBX, 0xb, var_30h, in_stack_ffffffd0, \n                                 in_stack_ffffffd4, noname_8, in_stack_ffffffdc, *0x428e18, var_18h, in_stack_ffffffe8, \n                                 \"AfxWnd70s\", 8, var_8h, var_4h, unaff_EBP);\n            if (iVar1 != 0) {\n                uVar3 = 1;\n            }\n        }\n        if ((arg_8h & 0x20) != 0) {\n            var_34h = var_34h | 0x8b;\n            iVar1 = fcn.00418c8f(&var_34h, noname_0, unaff_EDI, unaff_ESI, unaff_EBX, var_34h, var_30h, \n                                 in_stack_ffffffd0, in_stack_ffffffd4, noname_8, in_stack_ffffffdc, noname_11, var_18h, \n                                 in_stack_ffffffe8, \"AfxOleControl70s\", var_ch, var_8h, var_4h);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 0x20;\n            }\n        }\n        if ((arg_8h & 2) != 0) {\n            var_34h = 0;\n            iVar1 = fcn.00418c8f(&var_34h, noname_0, unaff_EDI, unaff_ESI, unaff_EBX, 0, var_30h, in_stack_ffffffd0, \n                                 in_stack_ffffffd4, noname_8, in_stack_ffffffdc, noname_11, 0x10, in_stack_ffffffe8, \n                                 \"AfxControlBar70s\", var_ch, var_8h, var_4h);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 2;\n            }\n        }\n        if ((arg_8h & 4) != 0) {\n            var_34h = 8;\n            iVar1 = fcn.004199b9(&var_34h, \"AfxMDIFrame70s\", 0x7a01);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 4;\n            }\n        }\n        if ((arg_8h & 8) != 0) {\n            var_34h = 0xb;\n            iVar1 = fcn.004199b9(&var_34h, \"AfxFrameOrView70s\", 0x7a02);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 8;\n            }\n        }\n        if ((arg_8h & 0x10) != 0) {\n            var_8h = 0xff;\n            uVar2 = fcn.00419524(&var_ch, 0x3fc0);\n            uVar3 = uVar3 | uVar2;\n            arg_8h = arg_8h & 0xffffc03f;\n        }\n        if ((arg_8h & 0x40) != 0) {\n            var_8h = 0x10;\n            uVar2 = fcn.00419524(&var_ch, 0x40);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x80) != 0) {\n            var_8h = 2;\n            uVar2 = fcn.00419524(&var_ch, 0x80);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x100) != 0) {\n            var_8h = 8;\n            uVar2 = fcn.00419524(&var_ch, 0x100);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x200) != 0) {\n            var_8h = 0x20;\n            uVar2 = fcn.00419524(&var_ch, 0x200);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x400) != 0) {\n            var_8h = 1;\n            uVar2 = fcn.00419524(&var_ch, 0x400);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x800) != 0) {\n            var_8h = 0x40;\n            uVar2 = fcn.00419524(&var_ch, 0x800);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x1000) != 0) {\n            var_8h = 4;\n            uVar2 = fcn.00419524(&var_ch, 0x1000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x2000) != 0) {\n            var_8h = 0x80;\n            uVar2 = fcn.00419524(&var_ch, 0x2000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x4000) != 0) {\n            var_8h = 0x800;\n            uVar2 = fcn.00419524(&var_ch, 0x4000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x8000) != 0) {\n            var_8h = 0x400;\n            uVar2 = fcn.00419524(&var_ch, 0x8000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x10000) != 0) {\n            var_8h = 0x200;\n            uVar2 = fcn.00419524(&var_ch, 0x10000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x20000) != 0) {\n            var_8h = 0x100;\n            uVar2 = fcn.00419524(&var_ch, 0x20000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x40000) != 0) {\n            var_8h = 0x8000;\n            uVar2 = fcn.00419524(&var_ch, 0x40000);\n            uVar3 = uVar3 | uVar2;\n        }\n        *(var_4h + 0x18) = *(var_4h + 0x18) | uVar3;\n        if ((*(var_4h + 0x18) & 0x3fc0) == 0x3fc0) {\n            *(var_4h + 0x18) = *(var_4h + 0x18) | 0x10;\n            uVar3 = uVar3 | 0x10;\n        }\n        bVar4 = (uVar3 & arg_8h) == arg_8h;\n    }\n    return bVar4;\n}\n",
        "token_count": 2248
    },
    "0041bc96": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041bc96(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar3 = *(param_1 + 0x28);\n    if ((*(param_1 + 0x18) & 1) == 0) {\n        piVar1 = param_1 + 0x30;\n        iVar2 = *piVar1;\n        if (*(param_1 + 8) == 0) {\n            if (iVar3 != iVar2) {\n                (**(**(param_1 + 0x24) + 0x38))(iVar2, iVar3 - iVar2);\n            }\n        }\n        else {\n            if (iVar3 != iVar2) {\n                (**(**(param_1 + 0x24) + 0x50))(2, iVar3 - iVar2, 0, 0);\n            }\n            (**(**(param_1 + 0x24) + 0x50))(1, *(param_1 + 0x20), piVar1, param_1 + 0x2c);\n        }\n        iVar3 = *piVar1;\n    }\n    else {\n        if (*(param_1 + 0x2c) != iVar3) {\n            iVar3 = iVar3 - *(param_1 + 0x2c);\n            (**(**(param_1 + 0x24) + 0x28))(iVar3, iVar3 >> 0x1f, 1);\n        }\n        iVar3 = *(param_1 + 0x2c);\n    }\n    *(param_1 + 0x28) = iVar3;\n    return;\n}\n",
        "token_count": 376
    },
    "0041d2b2": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0041d2b2(int32_t param_1)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint8_t *puVar6;\n    int32_t iVar7;\n    uint uStack48;\n    uchar *puStack44;\n    int32_t iStack40;\n    uint uStack36;\n    int32_t iStack32;\n    int32_t iStack28;\n    uint hMem;\n    uint lpCriticalSection;\n    \n    iVar4 = param_1 + 0x1c;\n    iStack32 = 0x41d2c9;\n    iStack28 = iVar4;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)();\n    iVar2 = *(param_1 + 4);\n    iVar7 = *(param_1 + 8);\n    if ((iVar2 <= iVar7) || ((*(*(param_1 + 0x10) + iVar7 * 8) & 1) != 0)) {\n        iVar7 = 1;\n        if (1 < iVar2) {\n            puVar6 = *(param_1 + 0x10);\n            do {\n                puVar6 = puVar6 + 8;\n                if ((*puVar6 & 1) == 0) break;\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < iVar2);\n            if (iVar7 < iVar2) goto code_r0x0041d394;\n        }\n        iVar2 = iVar2 + 0x20;\n        iStack32 = *(param_1 + 0x10);\n        if (iStack32 == 0) {\n            iStack32 = iVar2 * 8;\n            uStack36 = 2;\n            iStack40 = 0x41d31a;\n            iStack40 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)();\n        }\n        else {\n            uStack36 = 0x41d323;\n            uStack48 = (*_sym.imp.KERNEL32.dll_GlobalHandle)();\n            iStack40 = 0x41d32d;\n            uStack36 = uStack48;\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)();\n            iStack40 = 0x2002;\n            puStack44 = iVar2 * 8;\n            iStack40 = (*_sym.imp.KERNEL32.dll_GlobalReAlloc)();\n        }\n        if (iStack40 == 0) {\n            iStack40 = *(param_1 + 0x10);\n            if (iStack40 != 0) {\n                puStack44 = 0x41d353;\n                puStack44 = (*_sym.imp.KERNEL32.dll_GlobalHandle)();\n                uStack48 = 0x41d35a;\n                (*_sym.imp.KERNEL32.dll_GlobalLock)();\n            }\n            puStack44 = 0x41d363;\n            iStack40 = iVar4;\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)();\n            uStack48 = 0x428bf0;\n            puStack44 = &stack0xfffffffc;\n            fcn.00408230(&stack0xffffffd0, 0x423f40);\n            pcVar3 = swi(3);\n            iVar4 = (*pcVar3)();\n            return iVar4;\n        }\n        puStack44 = 0x41d36f;\n        iVar5 = (*_sym.imp.KERNEL32.dll_GlobalLock)();\n        iStack32 = (iVar2 - *(param_1 + 4)) * 8;\n        iStack40 = iVar5 + *(param_1 + 4) * 8;\n        uStack36 = 0;\n        puStack44 = 0x41d388;\n        fcn.00409040();\n        *(param_1 + 4) = iVar2;\n        *(param_1 + 0x10) = iVar5;\n    }\ncode_r0x0041d394:\n    if (*(param_1 + 0xc) <= iVar7) {\n        *(param_1 + 0xc) = iVar7 + 1;\n    }\n    puVar1 = *(param_1 + 0x10) + iVar7 * 8;\n    *puVar1 = *puVar1 | 1;\n    *(param_1 + 8) = iVar7 + 1;\n    uStack36 = 0x41d3b7;\n    iStack32 = iVar4;\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)();\n    return iVar7;\n}\n",
        "token_count": 995
    },
    "00409d0a": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\nuint32_t * __cdecl fcn.00409d0a(uint32_t *arg_8h)\n\n{\n    uint32_t *arg_8h_00;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    bool bVar4;\n    int64_t iVar5;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    uVar3 = arg_8h[1];\n    if (((uVar3 < 0) || (0x1000 < uVar3)) || ((0xfff < uVar3 && (*arg_8h != 0)))) {\n        arg_8h_00 = NULL;\n    }\n    else {\n        fcn.0040ee39();\n        uVar3 = arg_8h[1];\n        uVar2 = *arg_8h;\n        if ((uVar3 < 0) || ((uVar3 < 1 && (uVar2 < 0x3f481)))) {\n            arg_8h_00 = fcn.0040e62d(arg_8h);\n            if ((*0x4281f4 == 0) || (iVar1 = fcn.0040ee85(arg_8h_00),  iVar1 == 0)) {\n                uVar3 = *arg_8h_00;\n                var_8h = uVar3 - *0x4281f0;\n                var_4h = ((uVar3 >> 0x1f) - (*0x4281f0 >> 0x1f)) - (uVar3 < *0x4281f0);\n            }\n            else {\n                uVar2 = *0x4281f0 + *0x4281f8;\n                uVar3 = *arg_8h_00;\n                var_8h = uVar3 - uVar2;\n                var_4h = ((uVar3 >> 0x1f) - (uVar2 >> 0x1f)) - (uVar3 < uVar2);\n                arg_8h_00[8] = 1;\n            }\n            uVar3 = fcn.0040eed0(var_8h, var_4h, 0x3c, 0);\n            *arg_8h_00 = uVar3;\n            if (uVar3 < 0) {\n                *arg_8h_00 = uVar3 + 0x3c;\n                bVar4 = 0x3b < var_8h;\n                var_8h = var_8h - 0x3c;\n                var_4h = var_4h + -1 + bVar4;\n            }\n            _var_8h = fcn.004092f0(var_8h, var_4h, 0x3c, 0);\n            _var_8h = _var_8h + arg_8h_00[1];\n            uVar3 = fcn.0040eed0(_var_8h, 0x3c, 0);\n            arg_8h_00[1] = uVar3;\n            if (uVar3 < 0) {\n                arg_8h_00[1] = uVar3 + 0x3c;\n                _var_8h = _var_8h + -0x3c;\n            }\n            iVar5 = fcn.004092f0(_var_8h, 0x3c, 0);\n            _var_8h = iVar5 + arg_8h_00[2];\n            uVar3 = fcn.0040eed0(_var_8h, 0x18, 0);\n            arg_8h_00[2] = uVar3;\n            if (uVar3 < 0) {\n                arg_8h_00[2] = uVar3 + 0x18;\n                _var_8h = _var_8h + -0x18;\n            }\n            iVar5 = fcn.004092f0(_var_8h, 0x18, 0);\n            iVar1 = iVar5;\n            if ((iVar5 < 0x100000000) && (iVar5 < 0)) {\n                arg_8h_00[6] = (arg_8h_00[6] + 7 + iVar1) % 7;\n                arg_8h_00[3] = arg_8h_00[3] + iVar1;\n                if (arg_8h_00[3] < 1) {\n                    arg_8h_00[5] = arg_8h_00[5] - 1;\n                    arg_8h_00[3] = arg_8h_00[3] + 0x1f;\n                    arg_8h_00[7] = 0x16c;\n                    arg_8h_00[4] = 0xb;\n                }\n                else {\n                    arg_8h_00[7] = arg_8h_00[7] + iVar1;\n                }\n            }\n        }\n        else {\n            var_8h = uVar2 - *0x4281f0;\n            var_4h = (uVar3 - (*0x4281f0 >> 0x1f)) - (uVar2 < *0x4281f0);\n            arg_8h_00 = fcn.0040e62d(&var_8h);\n            if ((*0x4281f4 != 0) && (iVar1 = fcn.0040ee85(arg_8h_00),  iVar1 != 0)) {\n                bVar4 = var_8h < *0x4281f8;\n                var_8h = var_8h - *0x4281f8;\n                var_4h = (var_4h - (*0x4281f8 >> 0x1f)) - bVar4;\n                arg_8h_00 = fcn.0040e62d(&var_8h);\n                arg_8h_00[8] = 1;\n            }\n        }\n    }\n    return arg_8h_00;\n}\n",
        "token_count": 1370
    },
    "00409b57": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x00409be9: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x00409bee)\n// WARNING: Removing unreachable block (ram,0x00409c14)\n// WARNING: Removing unreachable block (ram,0x00409bf3)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00409b57(uint uExitCode, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00408fec(0x420808, 8);\n    fcn.0040a06b(8);\n    *(unaff_EBP + -4) = 0;\n    if (*0x42aba8 == 1) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(*(unaff_EBP + 8));\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1);\n    }\n    *0x42aba4 = 1;\n    *0x42aba0 = *(unaff_EBP + 0x10);\n    if (*(unaff_EBP + 0xc) == 0) {\n        if (*0x42c3b8 != NULL) {\n            while( true ) {\n                *0x42c3b4 = *0x42c3b4 + -1;\n                if (*0x42c3b4 < *0x42c3b8) break;\n                if (**0x42c3b4 != NULL) {\n                    (***0x42c3b4)();\n                }\n            }\n        }\n        fcn.00409ad5(0x4270a8);\n    }\n    fcn.00409ad5(0x4270b4);\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + 0x10) != 0) {\n        fcn.00409fb6(8);\n    }\n    return;\n}\n",
        "token_count": 460
    },
    "00412939": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nvoid fcn.00412939(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    puVar3 = param_1 + (param_2 / 0x20) * 4;\n    iVar1 = fcn.00413985(*puVar3, 1 << (0x1fU - param_2 % 0x20 & 0x1f), puVar3);\n    iVar2 = param_2 / 0x20 + -1;\n    if (-1 < iVar2) {\n        puVar3 = param_1 + iVar2 * 4;\n        do {\n            if (iVar1 == 0) {\n                return;\n            }\n            iVar1 = fcn.00413985(*puVar3, 1, puVar3);\n            iVar2 = iVar2 + -1;\n            puVar3 = puVar3 + -1;\n        } while (-1 < iVar2);\n    }\n    return;\n}\n",
        "token_count": 229
    },
    "00407ede": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00407ede(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    uint var_4h;\n    \n    uVar1 = fcn.0040d823(arg_8h, arg_ch, arg_10h, arg_14h, in_EAX, 0, 0, 0);\n    return uVar1;\n}\n",
        "token_count": 103
    },
    "00413a5f": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00413a5f(char *arg_8h, int32_t arg_ch, uint32_t *arg_10h)\n\n{\n    int16_t iVar1;\n    uint32_t *puVar2;\n    uint32_t uVar3;\n    uint var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    puVar2 = arg_10h;\n    var_4h = *0x427850;\n    iVar1 = 0x404e;\n    *arg_10h = 0;\n    arg_10h[1] = 0;\n    arg_10h[2] = 0;\n    if (arg_ch != 0) {\n        arg_10h = arg_ch;\n        do {\n            var_10h = *puVar2;\n            var_ch = puVar2[1];\n            var_8h = puVar2[2];\n            fcn.00413a04(puVar2);\n            fcn.00413a04(puVar2);\n            fcn.004139a6(puVar2, &var_10h);\n            fcn.00413a04(puVar2);\n            var_10h = *arg_8h;\n            var_ch = 0;\n            var_8h = 0;\n            fcn.004139a6(puVar2, &var_10h);\n            arg_8h = arg_8h + 1;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != NULL);\n    }\n    if (puVar2[2] == 0) {\n        do {\n            iVar1 = iVar1 + -0x10;\n            uVar3 = puVar2[1] >> 0x10;\n            puVar2[1] = *puVar2 >> 0x10 | puVar2[1] << 0x10;\n            *puVar2 = *puVar2 << 0x10;\n        } while (uVar3 == 0);\n        puVar2[2] = uVar3;\n    }\n    while ((puVar2[2] & 0x8000) == 0) {\n        fcn.00413a04(puVar2);\n        iVar1 = iVar1 + -1;\n    }\n    *(puVar2 + 10) = iVar1;\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 555
    },
    "00419cc9": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t fcn.00419cc9(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.0041d669(0x41ccb5);\n    uVar2 = (*_sym.imp.USER32.dll_GetMessageTime)();\n    *(iVar1 + 0x68) = uVar2;\n    uVar2 = (*_sym.imp.USER32.dll_GetMessagePos)();\n    *(iVar1 + 0x70) = uVar2 >> 0x10;\n    *(iVar1 + 0x6c) = uVar2;\n    return iVar1 + 0x58;\n}\n",
        "token_count": 140
    },
    "0041b618": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041b618(uint32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, int32_t *arg_14h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint var_ch;\n    int32_t *var_8h;\n    int32_t var_4h;\n    \n    if (arg_8h < 0x112) {\n        if (arg_8h == 0x111) {\n            iVar2 = fcn.00418695(0, arg_ch >> 0x10 | 0xbd110000, 0, 0);\n            if (iVar2 == 0) {\n                return 0;\n            }\n            if (arg_14h != NULL) {\n                *arg_14h = 1;\n                return 1;\n            }\n            return 1;\n        }\n        if (0x2a < arg_8h) {\n            if ((arg_8h < 0x30) || (arg_8h == 0x39)) goto code_r0x0041b6ac;\n            if (arg_8h == 0x4e) {\n                var_8h = arg_14h;\n                var_4h = arg_10h;\n                uVar1 = fcn.00418695(0, *(arg_10h + 8) & 0xffff | 0xbc4e0000, &var_8h, 0);\n                return uVar1;\n            }\n        }\n    }\n    else if ((0x113 < arg_8h) && ((arg_8h < 0x116 || (arg_8h == 0x210)))) {\ncode_r0x0041b6ac:\n        uVar1 = fcn.0041b00d(arg_8h + 0xbc00, arg_ch, arg_10h, arg_14h);\n        return uVar1;\n    }\n    if ((0x131 < arg_8h) && (arg_8h < 0x139)) {\n        var_4h = arg_8h - 0x132;\n        var_8h = arg_ch;\n        uVar1 = fcn.0041b00d(0xbc19, 0, &var_ch, arg_14h);\n        if (*arg_14h != 0) {\n            return uVar1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 537
    },
    "0041d7d3": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid fcn.0041d7d3(void)\n\n{\n    uint8_t uVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iStack148;\n    int32_t iStack144;\n    uint8_t *puStack140;\n    uchar auStack136 [128];\n    uint uStack8;\n    \n    uStack8 = *0x427850;\n    uVar2 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n    iVar5 = uVar2;\n    iStack148 = uVar2 >> 0x10;\n    if (0x20 < iVar5) {\n        iVar5 = 0x20;\n    }\n    iVar6 = iVar5 + 0xf >> 4;\n    iVar7 = ((iVar5 + -4) / 2 + iVar6 * 0x10) - iVar5;\n    if (0xc < iVar7) {\n        iVar7 = 0xc;\n    }\n    if (0x20 < iStack148) {\n        iStack148 = 0x20;\n    }\n    fcn.00409040(auStack136, 0xff, 0x80);\n    puVar4 = auStack136 + (iStack148 + -6 >> 1) * iVar6 * 2;\n    puStack140 = 0x41faf4;\n    iStack144 = 5;\n    do {\n        uVar1 = *puStack140;\n        uVar3 = puStack140 & 0xffff0000;\n        puStack140 = puStack140 + 1;\n        uVar3 = ~((uVar3 | uVar1) << (iVar7 & 0x1f));\n        *puVar4 = uVar3 >> 8;\n        puVar4[1] = uVar3;\n        puVar4 = puVar4 + iVar6 * 2;\n        iStack144 = iStack144 + -1;\n    } while (iStack144 != 0);\n    *0x428e28 = (*_sym.imp.GDI32.dll_CreateBitmap)(iVar5, iStack148, 1, 1, auStack136);\n    if (*0x428e28 == 0) {\n        *0x428e28 = (*_sym.imp.USER32.dll_LoadBitmapA)(0, 0x7fe3);\n    }\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 551
    },
    "0040a549": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040a549(int32_t arg_8h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = *(arg_8h + 0x10);\n    iVar7 = 0;\n    for (iVar3 = *(arg_8h + 8); -1 < iVar3; iVar3 = iVar3 << 1) {\n        iVar7 = iVar7 + 1;\n    }\n    iVar3 = iVar7 * 0x204 + 0x144 + iVar2;\n    iVar6 = 0x3f;\n    iVar4 = iVar3;\n    do {\n        *(iVar4 + 8) = iVar4;\n        *(iVar4 + 4) = iVar4;\n        iVar4 = iVar4 + 8;\n        iVar6 = iVar6 + -1;\n    } while (iVar6 != 0);\n    uVar8 = iVar7 * 0x8000 + *(arg_8h + 0xc);\n    iVar4 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(uVar8, 0x8000, 0x1000, 4);\n    if (iVar4 == 0) {\n        iVar7 = -1;\n    }\n    else {\n        if (uVar8 <= uVar8 + 0x7000) {\n            piVar5 = uVar8 + 0x10;\n            iVar4 = ((uVar8 + 0x7000) - uVar8 >> 0xc) + 1;\n            do {\n                piVar5[-2] = -1;\n                piVar5[0x3fb] = -1;\n                *piVar5 = piVar5 + 0x3ff;\n                piVar5[-1] = 0xff0;\n                piVar5[1] = piVar5 + -0x401;\n                piVar5[0x3fa] = 0xff0;\n                piVar5 = piVar5 + 0x400;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n        *(iVar3 + 0x1fc) = uVar8 + 0xc;\n        *(uVar8 + 0x14) = iVar3 + 0x1f8;\n        *(iVar3 + 0x200) = uVar8 + 0x700c;\n        *(uVar8 + 0x7010) = iVar3 + 0x1f8;\n        *(iVar2 + 0x44 + iVar7 * 4) = 0;\n        *(iVar2 + 0xc4 + iVar7 * 4) = 1;\n        cVar1 = *(iVar2 + 0x43);\n        *(iVar2 + 0x43) = cVar1 + '\\x01';\n        if (cVar1 == '\\0') {\n            *(arg_8h + 4) = *(arg_8h + 4) | 1;\n        }\n        *(arg_8h + 8) = *(arg_8h + 8) & ~(0x80000000U >> (iVar7 & 0x1f));\n    }\n    return iVar7;\n}\n",
        "token_count": 764
    },
    "00412d1c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00412d1c(uint32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint16_t uVar1;\n    uint32_t uVar2;\n    uint16_t uVar3;\n    uint16_t uVar4;\n    uint32_t var_4h;\n    \n    uVar1 = *(arg_ch + 6);\n    var_4h = 0x80000000;\n    uVar3 = uVar1 >> 4;\n    uVar4 = uVar3 & 0x7ff;\n    uVar2 = *arg_ch;\n    if ((uVar3 & 0x7ff) == 0) {\n        if (((arg_ch[1] & 0xfffff) == 0) && (uVar2 == 0)) {\n            arg_8h[1] = 0;\n            *arg_8h = 0;\n            *(arg_8h + 2) = 0;\n            return;\n        }\n        uVar4 = uVar4 + 0x3c01;\n        var_4h = 0;\n    }\n    else if (uVar4 == 0x7ff) {\n        uVar4 = 0x7fff;\n    }\n    else {\n        uVar4 = uVar4 + 0x3c00;\n    }\n    arg_8h[1] = uVar2 >> 0x15 | (arg_ch[1] & 0xfffff) << 0xb | var_4h;\n    *arg_8h = uVar2 << 0xb;\n    while (var_4h == 0) {\n        uVar2 = arg_8h[1];\n        uVar4 = uVar4 - 1;\n        arg_8h[1] = uVar2 << 1 | *arg_8h >> 0x1f;\n        *arg_8h = *arg_8h * 2;\n        var_4h = uVar2 << 1 & 0x80000000;\n    }\n    *(arg_8h + 2) = uVar1 & 0x8000 | uVar4;\n    return;\n}\n",
        "token_count": 481
    },
    "00413a04": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b"
        ],
        "decompiled_code": "\nvoid fcn.00413a04(uint32_t *param_1)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    \n    uVar1 = *param_1;\n    uVar2 = param_1[1];\n    *param_1 = uVar1 * 2;\n    param_1[1] = uVar2 * 2 | uVar1 >> 0x1f;\n    param_1[2] = param_1[2] << 1 | uVar2 >> 0x1f;\n    return;\n}\n",
        "token_count": 126
    },
    "00408c28": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\nuint8_t * __cdecl fcn.00408c28(uint8_t *arg_8h, uint32_t arg_ch)\n\n{\n    uint8_t uVar1;\n    uint16_t uVar2;\n    int32_t iVar3;\n    uint8_t uVar4;\n    uint8_t *puVar5;\n    uint8_t *puVar6;\n    bool bVar7;\n    \n    puVar5 = NULL;\n    iVar3 = fcn.0040af1e();\n    iVar3 = *(iVar3 + 0x60);\n    if (iVar3 != *0x42c3c4) {\n        iVar3 = fcn.00409726();\n    }\n    if (*(iVar3 + 8) != 0) {\n        do {\n            uVar4 = *arg_8h;\n            if ((*(uVar4 + 0x1d + iVar3) & 4) == 0) {\n                bVar7 = arg_ch == uVar4;\ncode_r0x00408c83:\n                puVar6 = arg_8h;\n                if (bVar7) {\n                    puVar5 = arg_8h;\n                }\n            }\n            else {\n                puVar6 = arg_8h + 1;\n                uVar1 = *puVar6;\n                if (uVar1 == 0) {\n                    bVar7 = puVar5 == NULL;\n                    arg_8h = puVar6;\n                    uVar4 = uVar1;\n                    goto code_r0x00408c83;\n                }\n                uVar2 = CONCAT11(uVar4, uVar1);\n                uVar4 = uVar1;\n                if (arg_ch == uVar2) {\n                    puVar5 = arg_8h;\n                }\n            }\n            arg_8h = puVar6 + 1;\n            if (uVar4 == 0) {\n                return puVar5;\n            }\n        } while( true );\n    }\n    iVar3 = -1;\n    do {\n        puVar5 = arg_8h;\n        if (iVar3 == 0) break;\n        iVar3 = iVar3 + -1;\n        puVar5 = arg_8h + 1;\n        uVar4 = *arg_8h;\n        arg_8h = puVar5;\n    } while (uVar4 != 0);\n    iVar3 = -(iVar3 + 1);\n    puVar5 = puVar5 + -1;\n    do {\n        puVar6 = puVar5;\n        if (iVar3 == 0) break;\n        iVar3 = iVar3 + -1;\n        puVar6 = puVar5 + -1;\n        uVar4 = *puVar5;\n        puVar5 = puVar6;\n    } while (arg_ch != uVar4);\n    puVar6 = puVar6 + 1;\n    if (*puVar6 != arg_ch) {\n        puVar6 = NULL;\n    }\n    return puVar6;\n}\n",
        "token_count": 647
    },
    "00412aa7": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00412aa7(uint16_t *arg_8h, uint32_t *arg_ch, int32_t *arg_10h)\n\n{\n    uint16_t uVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint var_18h;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    uVar1 = arg_8h[5];\n    var_ch = *(arg_8h + 3);\n    var_8h = *(arg_8h + 1);\n    var_4h = *arg_8h << 0x10;\n    uVar5 = uVar1 & 0x7fff;\n    iVar6 = uVar5 - 0x3fff;\n    if (iVar6 == -0x3fff) {\n        iVar6 = 0;\n        uVar5 = fcn.00412a13();\n        uVar2 = uVar5;\n        if (uVar5 != 0) {\ncode_r0x00412bbf:\n            uVar3 = 0;\n            goto code_r0x00412bc1;\n        }\n    }\n    else {\n        fcn.004129f8(&var_18h, &var_ch);\n        iVar4 = fcn.00412986(&var_ch, arg_10h[2]);\n        if (iVar4 != 0) {\n            iVar6 = uVar5 - 0x3ffe;\n        }\n        iVar4 = arg_10h[1];\n        if (iVar6 < iVar4 - arg_10h[2]) {\n            var_ch = 0;\n            var_8h = 0;\n            uVar5 = var_ch;\n            uVar2 = var_8h;\n        }\n        else {\n            if (iVar4 < iVar6) {\n                if (*arg_10h <= iVar6) {\n                    var_8h = 0;\n                    var_4h = 0;\n                    var_ch = 0x80000000;\n                    fcn.00412a2c(&var_ch, arg_10h[3]);\n                    iVar6 = arg_10h[5] + *arg_10h;\n                    uVar3 = 1;\n                    goto code_r0x00412bc1;\n                }\n                var_ch = var_ch & 0x7fffffff;\n                iVar6 = arg_10h[5] + iVar6;\n                fcn.00412a2c(&var_ch, arg_10h[3]);\n                goto code_r0x00412bbf;\n            }\n            fcn.004129f8(&var_ch, &var_18h);\n            fcn.00412a2c(&var_ch, iVar4 - iVar6);\n            fcn.00412986(&var_ch, arg_10h[2]);\n            fcn.00412a2c(&var_ch, arg_10h[3] + 1);\n            uVar5 = var_ch;\n            uVar2 = var_8h;\n        }\n    }\n    var_8h = uVar2;\n    var_ch = uVar5;\n    iVar6 = 0;\n    uVar3 = 2;\ncode_r0x00412bc1:\n    var_ch = iVar6 << (0x1fU - arg_10h[3] & 0x1f) | -((uVar1 & 0x8000) != 0) & 0x80000000 | var_ch;\n    if (arg_10h[4] == 0x40) {\n        arg_ch[1] = var_ch;\n        *arg_ch = var_8h;\n    }\n    else if (arg_10h[4] == 0x20) {\n        *arg_ch = var_ch;\n    }\n    return uVar3;\n}\n",
        "token_count": 864
    },
    "0040cd7e": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0040cd7e(uint arg_8h, char *arg_ch, uint arg_10h, uint *arg_14h)\n\n{\n    char cVar1;\n    bool bVar2;\n    bool bVar3;\n    bool bVar4;\n    int32_t iVar5;\n    uint32_t arg_ch_00;\n    uint32_t uVar6;\n    uint var_8h;\n    uint var_4h;\n    \n    cVar1 = *arg_ch;\n    bVar4 = false;\n    bVar3 = false;\n    if (cVar1 == 'a') {\n        arg_ch_00 = 0x109;\n    }\n    else {\n        if (cVar1 == 'r') {\n            arg_ch_00 = 0;\n            uVar6 = *0x42aff0 | 1;\n            goto code_r0x0040cdbf;\n        }\n        if (cVar1 != 'w') {\n            return NULL;\n        }\n        arg_ch_00 = 0x301;\n    }\n    uVar6 = *0x42aff0 | 2;\ncode_r0x0040cdbf:\n    bVar2 = true;\ncode_r0x0040ce9e:\n    arg_ch = arg_ch + 1;\n    cVar1 = *arg_ch;\n    if ((cVar1 == '\\0') || (!bVar2)) {\n        iVar5 = fcn.004125de(arg_8h, arg_ch_00, arg_10h, 0x1a4);\n        if (iVar5 < 0) {\n            return NULL;\n        }\n        *0x42ad70 = *0x42ad70 + 1;\n        arg_14h[3] = uVar6;\n        arg_14h[1] = 0;\n        *arg_14h = 0;\n        arg_14h[2] = 0;\n        arg_14h[7] = 0;\n        arg_14h[4] = iVar5;\n        return arg_14h;\n    }\n    if (cVar1 < 'U') {\n        if (cVar1 == 'T') {\n            if ((arg_ch_00 & 0x1000) == 0) {\n                arg_ch_00 = arg_ch_00 | 0x1000;\n                goto code_r0x0040ce9e;\n            }\n        }\n        else if (cVar1 == '+') {\n            if ((arg_ch_00 & 2) == 0) {\n                arg_ch_00 = arg_ch_00 & 0xfffffffe | 2;\n                uVar6 = uVar6 & 0xfffffffc | 0x80;\n                goto code_r0x0040ce9e;\n            }\n        }\n        else if (cVar1 == 'D') {\n            if ((arg_ch_00 & 0x40) == 0) {\n                arg_ch_00 = arg_ch_00 | 0x40;\n                goto code_r0x0040ce9e;\n            }\n        }\n        else if (cVar1 == 'R') {\n            if (!bVar3) {\n                bVar3 = true;\n                arg_ch_00 = arg_ch_00 | 0x10;\n                goto code_r0x0040ce9e;\n            }\n        }\n        else if ((cVar1 == 'S') && (!bVar3)) {\n            bVar3 = true;\n            arg_ch_00 = arg_ch_00 | 0x20;\n            goto code_r0x0040ce9e;\n        }\n    }\n    else {\n        if (cVar1 == 'b') {\n            if ((arg_ch_00 & 0xc000) != 0) goto code_r0x0040ce80;\n            arg_ch_00 = arg_ch_00 | 0x8000;\n            goto code_r0x0040ce9e;\n        }\n        if (cVar1 == 'c') {\n            if (!bVar4) {\n                bVar4 = true;\n                uVar6 = uVar6 | 0x4000;\n                goto code_r0x0040ce9e;\n            }\n        }\n        else {\n            if (cVar1 != 'n') {\n                if ((cVar1 != 't') || ((arg_ch_00 & 0xc000) != 0)) goto code_r0x0040ce80;\n                arg_ch_00 = arg_ch_00 | 0x4000;\n                goto code_r0x0040ce9e;\n            }\n            if (!bVar4) {\n                bVar4 = true;\n                uVar6 = uVar6 & 0xffffbfff;\n                goto code_r0x0040ce9e;\n            }\n        }\n    }\ncode_r0x0040ce80:\n    bVar2 = false;\n    goto code_r0x0040ce9e;\n}\n",
        "token_count": 1072
    },
    "0040e4ac": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h_2\n\nvoid __cdecl fcn.0040e4ac(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    char *pcVar4;\n    uint var_8h;\n    uint var_ch;\n    uint var_128h_2;\n    uint var_124h_2;\n    uint var_128h;\n    uint lpFilename;\n    uint var_18h_2;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint uStack4;\n    \n    uStack4 = 0x118;\n    var_18h = 0x421160;\n    fcn.00408fec();\n    *(unaff_EBP + -0x1c) = *0x427850;\n    pcVar1 = *0x42ae8c;\n    if (*0x42ae8c == NULL) {\n        if (*(unaff_EBP + 8) == 1) {\n            pcVar4 = \"Buffer overrun detected!\";\n            *(unaff_EBP + -0x128) =\n                 \"A buffer overrun has been detected which has corrupted the program\\'s\\ninternal state.  The program cannot safely continue execution and must\\nnow be terminated.\\n\"\n            ;\n        }\n        else {\n            pcVar4 = \"Unknown security failure detected!\";\n            *(unaff_EBP + -0x128) =\n                 \"A security error of unknown cause has been detected which has\\ncorrupted the program\\'s internal state.  The program cannot safely\\ncontinue execution and must now be terminated.\\n\"\n            ;\n        }\n        *(unaff_EBP + -0x20) = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, unaff_EBP + -0x124, 0x104);\n        if (iVar2 == 0) {\n            fcn.0040fce0(unaff_EBP + -0x124, \"<program name unknown>\");\n        }\n        iVar2 = unaff_EBP + -0x124;\n        iVar3 = fcn.004089d0(iVar2);\n        if (0x3c < iVar3 + 0xbU) {\n            iVar2 = fcn.004089d0(iVar2);\n            iVar2 = iVar2 + unaff_EBP + -0x155;\n            fcn.00411100(iVar2, 0x420f80, 3);\n        }\n        fcn.004089d0(iVar2);\n        fcn.004079f0();\n        *(unaff_EBP + -0x18) = &var_18h;\n        fcn.0040fce0(&var_18h, pcVar4);\n        fcn.0040fcf0(&var_18h, 0x420f60);\n        fcn.0040fcf0(&var_18h, \"Program: \");\n        fcn.0040fcf0(&var_18h, iVar2);\n        fcn.0040fcf0(&var_18h, 0x420f60);\n        fcn.0040fcf0(&var_18h, *(unaff_EBP + -0x128));\n        fcn.0041269b(&var_18h, \"Microsoft Visual C++ Runtime Library\", 0x12010);\n    }\n    else {\n        *(unaff_EBP + -4) = 0;\n        (*pcVar1)(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    fcn.00409c2b(3);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 912
    },
    "004102ed": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nuint8_t fcn.004102ed(uint32_t param_1)\n\n{\n    if (*0x42b254 <= param_1) {\n        return 0;\n    }\n    return *(*((param_1 >> 5) * 4 + 0x42b260) + 4 + (param_1 & 0x1f) * 0x24) & 0x40;\n}\n",
        "token_count": 89
    },
    "00411cdc": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00411cdc(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00408fec(0x422728, 8);\n    uVar2 = *(unaff_EBP + 8);\n    iVar1 = *((uVar2 >> 5) * 4 + 0x42b260) + (uVar2 & 0x1f) * 0x24;\n    if (*(iVar1 + 8) == 0) {\n        fcn.0040a06b(10);\n        *(unaff_EBP + -4) = 0;\n        if (*(iVar1 + 8) == 0) {\n            iVar3 = fcn.0040fe86(iVar1 + 0xc, 4000);\n            if (iVar3 == 0) {\n                fcn.0040782e(unaff_EBP + -0x10, 0xffffffff);\n                goto code_r0x00411d6a;\n            }\n            *(iVar1 + 8) = *(iVar1 + 8) + 1;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00411d73();\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(*((uVar2 >> 5) * 4 + 0x42b260) + 0xc + (uVar2 & 0x1f) * 0x24);\ncode_r0x00411d6a:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 396
    },
    "00411d7c": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nvoid fcn.00411d7c(uint32_t param_1)\n\n{\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(*((param_1 >> 5) * 4 + 0x42b260) + 0xc + (param_1 & 0x1f) * 0x24);\n    return;\n}\n",
        "token_count": 76
    },
    "00413270": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00413270(uint32_t arg_8h, uint arg_ch, uint arg_10h, uint dwMoveMethod)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint lDistanceToMove;\n    uint lpDistanceToMoveHigh;\n    \n    lpDistanceToMoveHigh = arg_10h;\n    iVar2 = fcn.00411c9b(arg_8h);\n    if (iVar2 == -1) {\n        puVar3 = fcn.00409c85();\n        *puVar3 = 9;\ncode_r0x004132ca:\n        iVar2 = -1;\n        lpDistanceToMoveHigh = 0xffffffff;\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_SetFilePointer)(iVar2, arg_ch, &lpDistanceToMoveHigh, dwMoveMethod);\n        if (iVar2 == -1) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar4 != 0) {\n                fcn.00409c97(iVar4);\n                goto code_r0x004132ca;\n            }\n        }\n        puVar1 = *((arg_8h >> 5) * 4 + 0x42b260) + 4 + (arg_8h & 0x1f) * 0x24;\n        *puVar1 = *puVar1 & 0xfd;\n    }\n    return CONCAT44(lpDistanceToMoveHigh, iVar2);\n}\n",
        "token_count": 344
    },
    "004144d1": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nint32_t fcn.004144d1(uint32_t param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    uint8_t *puVar2;\n    uint8_t uVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    \n    piVar1 = (param_1 >> 5) * 4 + 0x42b260;\n    iVar5 = (param_1 & 0x1f) * 0x24;\n    uVar3 = *(*piVar1 + 4 + iVar5);\n    if (param_2 == 0x8000) {\n        puVar2 = *piVar1 + 4 + iVar5;\n        *puVar2 = *puVar2 & 0x7f;\n    }\n    else {\n        if (param_2 != 0x4000) {\n            puVar4 = fcn.00409c85();\n            *puVar4 = 0x16;\n            return -1;\n        }\n        puVar2 = *piVar1 + 4 + iVar5;\n        *puVar2 = *puVar2 | 0x80;\n    }\n    return (-((uVar3 & 0x80) != 0) & 0xffffc000) + 0x8000;\n}\n",
        "token_count": 291
    },
    "0041c1b6": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nvoid fcn.0041c1b6(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    if (param_1 != 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GlobalFlags)(param_1);\n        for (uVar1 = uVar1 & 0xff; uVar1 != 0; uVar1 = uVar1 - 1) {\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(param_1);\n        }\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(param_1);\n    }\n    return;\n}\n",
        "token_count": 133
    },
    "004036b0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.004036b0(int32_t param_1, uint32_t param_2, uint32_t param_3)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint *puVar5;\n    \n    if (*(param_1 + 0x14) < param_2) {\n        fcn.004152cd();\n    }\n    uVar2 = *(param_1 + 0x14) - param_2;\n    if (uVar2 < param_3) {\n        param_3 = uVar2;\n    }\n    if (param_3 != 0) {\n        puVar5 = param_1 + 4;\n        puVar4 = puVar5;\n        puVar1 = puVar5;\n        if (0xf < *(param_1 + 0x18)) {\n            puVar4 = *puVar5;\n            puVar1 = *puVar5;\n        }\n        fcn.004072a0(puVar4 + param_2, puVar1 + param_3 + param_2, uVar2 - param_3);\n        iVar3 = *(param_1 + 0x14) - param_3;\n        *(param_1 + 0x14) = iVar3;\n        if (0xf < *(param_1 + 0x18)) {\n            puVar5 = *puVar5;\n        }\n        *(puVar5 + iVar3) = 0;\n    }\n    return param_1;\n}\n",
        "token_count": 346
    },
    "00404030": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.00404030(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t **ppiVar5;\n    \n    iVar3 = *param_2;\n    iVar4 = *param_1;\n    ppiVar1 = iVar3 + -0x10;\n    ppiVar5 = iVar4 + -0x10;\n    if (ppiVar1 != ppiVar5) {\n        piVar2 = iVar4 + -4;\n        if ((-1 < *(iVar4 + -4)) && (*ppiVar1 == *ppiVar5)) {\n            iVar4 = fcn.00403470(ppiVar1);\n            LOCK();\n            iVar3 = *piVar2;\n            *piVar2 = *piVar2 + -1;\n            if (iVar3 == 1 || iVar3 + -1 < 0) {\n                (**(**ppiVar5 + 4))(ppiVar5);\n            }\n            *param_1 = iVar4 + 0x10;\n            return param_1;\n        }\n        fcn.004039f0(iVar3, *(iVar3 + -0xc));\n    }\n    return param_1;\n}\n",
        "token_count": 294
    },
    "00404520": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "PEB access"
        ],
        "decompiled_code": "\nuint fcn.00404520(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    uint unaff_EBX;\n    uint32_t unaff_ESI;\n    uint *in_FS_OFFSET;\n    uint unaff_retaddr;\n    uint uVar2;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x41e458;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    fcn.004040a0(param_2, 0, 0xffffffff);\n    uVar2 = 0;\n    uVar1 = fcn.00403e00(unaff_retaddr, 0, 0xffffffff);\n    *0x18 = 0xf;\n    *0x14 = 0;\n    *0x4 = 0;\n    fcn.004040a0(uVar1, 0, 0xffffffff);\n    if (0xf < unaff_ESI) {\n        fcn.00418300(uVar2);\n    }\n    *in_FS_OFFSET = unaff_EBX;\n    return 0;\n}\n",
        "token_count": 262
    },
    "004045c0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "PEB access",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint fcn.004045c0(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint unaff_ESI;\n    uint32_t unaff_EDI;\n    uint *in_FS_OFFSET;\n    uint uStack84;\n    uint uStack80;\n    uint uStack76;\n    char16_t *pcStack72;\n    uchar *puStack68;\n    char *pcStack64;\n    uint uStack60;\n    uchar *puStack44;\n    uchar uStack36;\n    uint32_t uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x41e458;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    uStack60 = 0x14;\n    pcStack64 = \"CryptAcquireContextA\";\n    uStack16 = 0xf;\n    uStack20 = 0;\n    uStack36 = 0;\n    puStack68 = 0x4045fd;\n    fcn.004041d0();\n    uStack12 = 0;\n    if (uStack24 < 0x10) {\n        puStack44 = &stack0xffffffd4;\n    }\n    pcStack72 = L\"ADVAPI32.DLL\";\n    uStack76 = 0x404622;\n    puStack68 = puStack44;\n    uStack76 = (*_sym.imp.KERNEL32.dll_LoadLibraryW)();\n    uStack80 = 0x404629;\n    pcVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    uStack80 = 0;\n    uStack84 = 1;\n    pcStack64 = NULL;\n    iVar2 = (*pcVar1)(&stack0xffffffc0, 0, 0);\n    if (iVar2 == 0) {\n        if (0xf < unaff_EDI) {\n            fcn.00418300(uStack76);\n            *in_FS_OFFSET = unaff_ESI;\n            return 0;\n        }\n    }\n    else {\n        iVar2 = (*pcVar1)(&stack0xffffffac, 0, 0, 1, 8);\n        if (iVar2 != 0) {\n            if (0xf < unaff_EDI) {\n                fcn.00418300(uStack76);\n            }\n            *in_FS_OFFSET = unaff_ESI;\n            return 1;\n        }\n        if (0xf < unaff_EDI) {\n            fcn.00418300(uStack76);\n        }\n    }\n    *in_FS_OFFSET = unaff_ESI;\n    return 0;\n}\n",
        "token_count": 597
    },
    "004079f0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n\nvoid fcn.004079f0(void)\n\n{\n    uint32_t in_EAX;\n    uchar *puVar1;\n    uint unaff_retaddr;\n    \n    if (in_EAX < 0x1000) {\n        *(&stack0x00000000 + -in_EAX) = unaff_retaddr;\n        return;\n    }\n    puVar1 = &stack0x00000004;\n    do {\n        puVar1 = puVar1 + -0x1000;\n        in_EAX = in_EAX - 0x1000;\n    } while (0xfff < in_EAX);\n    *(puVar1 + (-4 - in_EAX)) = unaff_retaddr;\n    return;\n}\n",
        "token_count": 167
    },
    "004082d2": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004082d2(void)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint unaff_EDI;\n    \n    uVar1 = fcn.00409444(*0x42c3b8);\n    if (uVar1 < *0x42c3b4 + (4 - *0x42c3b8)) {\n        uVar3 = 0x800;\n        if (uVar1 < 0x800) {\n            uVar3 = uVar1;\n        }\n        iVar2 = fcn.00408a7b(*0x42c3b8, uVar3 + uVar1);\n        if (iVar2 == 0) {\n            iVar2 = fcn.00408a7b(*0x42c3b8, uVar1 + 0x10);\n            if (iVar2 == 0) {\n                return;\n            }\n        }\n        *0x42c3b4 = iVar2 + (*0x42c3b4 - *0x42c3b8 >> 2) * 4;\n        *0x42c3b8 = iVar2;\n    }\n    **0x42c3b4 = unaff_EDI;\n    *0x42c3b4 = *0x42c3b4 + 1;\n    return;\n}\n",
        "token_count": 306
    },
    "0040a14f": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint32_t fcn.0040a14f(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *0x42c394;\n    while( true ) {\n        if (*0x42c394 + *0x42c390 * 0x14 <= uVar1) {\n            return 0;\n        }\n        if (param_1 - *(uVar1 + 0xc) < 0x100000) break;\n        uVar1 = uVar1 + 0x14;\n    }\n    return uVar1;\n}\n",
        "token_count": 128
    },
    "0040bc50": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040bc50(char *arg_8h, char *arg_ch)\n\n{\n    char cVar1;\n    char cVar2;\n    uint8_t uVar3;\n    uint8_t uVar5;\n    uint32_t uVar4;\n    \n    uVar4 = 0xff;\n    do {\n        do {\n            cVar2 = uVar4;\n            if (cVar2 == '\\0') goto code_r0x0040bc96;\n            cVar2 = *arg_ch;\n            arg_ch = arg_ch + 1;\n            cVar1 = *arg_8h;\n            uVar4 = CONCAT11(cVar1, cVar2);\n            arg_8h = arg_8h + 1;\n        } while (uVar4 >> 8 == cVar2);\n        uVar3 = cVar1 + 0xbf;\n        uVar3 = uVar3 + (-(uVar3 < 0x1a) & 0x20U) + 0x41;\n        uVar4 = CONCAT11(cVar2 + 0xbfU + (-(cVar2 + 0xbfU < 0x1a) & 0x20U) + 'A', uVar3);\n        uVar5 = uVar4 >> 8;\n    } while (uVar3 == uVar5);\n    cVar2 = (uVar3 < uVar5) * -2 + '\\x01';\ncode_r0x0040bc96:\n    return cVar2;\n}\n",
        "token_count": 338
    },
    "0040f368": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040f368(uint *arg_8h, int32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t var_2ch;\n    uint var_1ch;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    fcn.00412dd6(*arg_8h, arg_8h[1], &var_2ch, &var_1ch);\n    fcn.00412ca5((0 < arg_10h) + (var_2ch == 0x2d) + arg_ch, arg_10h + 1, &var_2ch);\n    fcn.0040f2ba(arg_10h, arg_14h, 0);\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 190
    },
    "0040f470": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040f470(uint *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint var_1ch;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    fcn.00412dd6(*arg_8h, arg_8h[1], &var_2ch, &var_1ch);\n    fcn.00412ca5((var_2ch == 0x2d) + arg_ch, var_28h + arg_10h, &var_2ch);\n    fcn.0040f3d4(arg_ch, arg_10h, 0);\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 185
    },
    "0040f4d2": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040f4d2(uint *arg_8h, int32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    char *arg_8h_00;\n    int32_t iVar1;\n    char *pcVar2;\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint var_1ch;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    fcn.00412dd6(*arg_8h, arg_8h[1], &var_2ch, &var_1ch);\n    iVar1 = var_28h + -1;\n    arg_8h_00 = (var_2ch == 0x2d) + arg_ch;\n    fcn.00412ca5(arg_8h_00, arg_10h, &var_2ch);\n    var_28h = var_28h + -1;\n    if ((var_28h < -4) || (arg_10h <= var_28h)) {\n        fcn.0040f2ba(arg_10h, arg_14h, 1);\n    }\n    else {\n        if (iVar1 < var_28h) {\n            do {\n                pcVar2 = arg_8h_00;\n                arg_8h_00 = pcVar2 + 1;\n            } while (*pcVar2 != '\\0');\n            pcVar2[-1] = '\\0';\n        }\n        fcn.0040f3d4(arg_ch, arg_10h, 1);\n    }\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 372
    },
    "0041498b": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop",
            "set environment variable"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041498b(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uchar *puVar4;\n    bool bVar5;\n    uint var_10h;\n    uint var_ch;\n    uint lpValue;\n    uint var_4h;\n    \n    var_10h = 0;\n    if (arg_8h == NULL) {\n        return 0xffffffff;\n    }\n    arg_8h_00 = *arg_8h;\n    if (arg_8h_00 == 0) {\n        return 0xffffffff;\n    }\n    iVar1 = fcn.00409158(arg_8h_00, 0x3d);\n    if (iVar1 == 0) {\n        return 0xffffffff;\n    }\n    if (arg_8h_00 == iVar1) {\n        return 0xffffffff;\n    }\n    bVar5 = *(iVar1 + 1) == '\\0';\n    if (*0x42ab88 == *0x42ab8c) {\n        *0x42ab88 = fcn.0041492a();\n    }\n    if (*0x42ab88 == NULL) {\n        if ((arg_ch != 0) && (*0x42ab90 != NULL)) {\n            iVar2 = fcn.004138f5();\n            if (iVar2 != 0) {\n                return 0xffffffff;\n            }\n            goto code_r0x00414a40;\n        }\n        if (!bVar5) {\n            *0x42ab88 = fcn.00407684(4);\n            if (*0x42ab88 == NULL) {\n                return 0xffffffff;\n            }\n            **0x42ab88 = 0;\n            if (*0x42ab90 == NULL) {\n                *0x42ab90 = fcn.00407684(4);\n                if (*0x42ab90 == NULL) {\n                    return 0xffffffff;\n                }\n                **0x42ab90 = 0;\n            }\n            goto code_r0x00414a40;\n        }\ncode_r0x00414a0e:\n        var_10h = 0;\n    }\n    else {\ncode_r0x00414a40:\n        piVar3 = *0x42ab88;\n        iVar2 = fcn.004148dd(arg_8h_00);\n        if ((iVar2 < 0) || (*piVar3 == 0)) {\n            if (bVar5) {\n                fcn.00407696(arg_8h_00);\n                *arg_8h = 0;\n                goto code_r0x00414a0e;\n            }\n            if (iVar2 < 0) {\n                iVar2 = -iVar2;\n            }\n            piVar3 = fcn.00408a7b(*0x42ab88, iVar2 * 4 + 8);\n            if (piVar3 == NULL) {\n                return 0xffffffff;\n            }\n            piVar3[iVar2] = arg_8h_00;\n            (piVar3 + iVar2)[1] = 0;\n            *arg_8h = 0;\ncode_r0x00414add:\n            *0x42ab88 = piVar3;\n        }\n        else {\n            piVar3 = piVar3 + iVar2;\n            fcn.00407696(*piVar3);\n            if (bVar5) {\n                for (; *piVar3 != 0; piVar3 = piVar3 + 1) {\n                    *piVar3 = piVar3[1];\n                    iVar2 = iVar2 + 1;\n                }\n                piVar3 = fcn.00408a7b(*0x42ab88, iVar2 << 2);\n                if (piVar3 != NULL) goto code_r0x00414add;\n            }\n            else {\n                *piVar3 = arg_8h_00;\n                *arg_8h = 0;\n            }\n        }\n        if (arg_ch != 0) {\n            iVar2 = fcn.004089d0(arg_8h_00);\n            iVar2 = fcn.00407684(iVar2 + 2);\n            if (iVar2 != 0) {\n                fcn.0040fce0(iVar2, arg_8h_00);\n                puVar4 = (iVar2 - arg_8h_00) + iVar1;\n                *puVar4 = 0;\n                iVar1 = (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(iVar2, ~-bVar5 & puVar4 + 1);\n                if (iVar1 == 0) {\n                    var_10h = 0xffffffff;\n                }\n                fcn.00407696(iVar2);\n            }\n        }\n        if (bVar5) {\n            fcn.00407696(arg_8h_00);\n        }\n    }\n    return var_10h;\n}\n",
        "token_count": 1105
    },
    "00414d92": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00414d92(ushort *arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint *arg_ch_00;\n    uint var_10h;\n    ushort uStack16;\n    ushort uStack14;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    iVar4 = 0x428420;\n    if (arg_ch != 0) {\n        if (arg_ch < 0) {\n            arg_ch = -arg_ch;\n            iVar4 = 0x428580;\n        }\n        if (arg_10h == 0) {\n            *arg_8h = 0;\n        }\n        while (arg_ch != 0) {\n            uVar1 = arg_ch >> 3;\n            uVar3 = arg_ch & 7;\n            iVar4 = iVar4 + 0x54;\n            arg_ch = uVar1;\n            if (uVar3 != 0) {\n                arg_ch_00 = iVar4 + uVar3 * 0xc;\n                if (0x7fff < *arg_ch_00) {\n                    var_10h._0_2_ = *arg_ch_00;\n                    var_10h._2_2_ = *arg_ch_00 >> 0x10;\n                    uStack16 = arg_ch_00[1];\n                    uStack14 = arg_ch_00[1] >> 0x10;\n                    uStack12 = arg_ch_00[2];\n                    iVar2 = CONCAT22(uStack16, var_10h._2_2_) + -1;\n                    var_10h._2_2_ = iVar2;\n                    uStack16 = iVar2 >> 0x10;\n                    arg_ch_00 = &var_10h;\n                }\n                fcn.00414b60(arg_8h, arg_ch_00);\n            }\n        }\n    }\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 478
    },
    "00415f06": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00415f06(int32_t param_1, uint32_t param_2)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint unaff_retaddr;\n    \n    if (-*(param_1 + 0x14) - 1U <= param_2) {\n        fcn.00415368();\n    }\n    if (param_2 != 0) {\n        iVar3 = *(param_1 + 0x14) + param_2;\n        cVar1 = fcn.00403a90(iVar3, 0);\n        if (cVar1 != '\\0') {\n            if (*(param_1 + 0x18) < 0x10) {\n                iVar2 = param_1 + 4;\n            }\n            else {\n                iVar2 = *(param_1 + 4);\n            }\n            fcn.004153c5(*(param_1 + 0x14) + iVar2, param_2, unaff_retaddr);\n            fcn.004034d0(iVar3);\n        }\n    }\n    return param_1;\n}\n",
        "token_count": 253
    },
    "004197df": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004197df(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_60h;\n    uint lprcSrc;\n    int32_t lpPoints;\n    int32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t lprcDst;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = fcn.0041846b();\n    if (arg_8h == 0) {\n        if ((var_4h & 0x40000000) == 0) {\n            iVar5 = (*_sym.imp.USER32.dll_GetWindow)(*(in_ECX + 0x1c), 4);\n        }\n        else {\n            iVar5 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x1c));\n        }\n        if ((iVar5 != 0) && (iVar4 = (*_sym.imp.USER32.dll_SendMessageA)(iVar5, 0x36b, 0, 0),  iVar4 != 0)) {\n            iVar5 = iVar4;\n        }\n    }\n    else {\n        iVar5 = *(arg_8h + 0x1c);\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetWindowRect;\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x1c), &var_28h);\n    if ((var_4h & 0x40000000) == 0) {\n        if ((iVar5 != 0) &&\n           ((uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar5, 0xfffffff0),  (uVar2 & 0x10000000) == 0 ||\n            ((uVar2 & 0x20000000) != 0)))) {\n            iVar5 = 0;\n        }\n        if (iVar5 == 0) {\n            iVar5 = fcn.004062d7();\n            if (iVar5 != 0) {\n                iVar5 = *(iVar5 + 0x1c);\n            }\n            uVar3 = fcn.0040678e(iVar5, 1);\n            fcn.004067f9(uVar3, iVar5);\n            pcVar1 = _sym.imp.USER32.dll_CopyRect;\n            (*_sym.imp.USER32.dll_CopyRect)(&lpPoints, &lprcSrc);\n            (*pcVar1)(&lprcDst, &lprcSrc);\n        }\n        else {\n            (*pcVar1)(iVar5, &lpPoints);\n            uVar3 = fcn.0040678e(iVar5, 2);\n            fcn.004067f9(uVar3, iVar5);\n            (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, &lprcSrc);\n        }\n    }\n    else {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x1c));\n        pcVar1 = _sym.imp.USER32.dll_GetClientRect;\n        (*_sym.imp.USER32.dll_GetClientRect)(uVar3, &lprcDst);\n        (*pcVar1)(iVar5, &lpPoints);\n        (*_sym.imp.USER32.dll_MapWindowPoints)(iVar5, uVar3, &lpPoints, 2);\n    }\n    iVar5 = (lpPoints + var_30h) / 2 - (var_20h - var_28h) / 2;\n    iVar4 = (var_34h + var_2ch) / 2 - (var_1ch - var_24h) / 2;\n    if ((lprcDst <= iVar5) && (lprcDst = iVar5,  var_10h < (var_20h - var_28h) + iVar5)) {\n        lprcDst = (var_10h - var_20h) + var_28h;\n    }\n    if ((var_14h <= iVar4) && (var_14h = iVar4,  var_ch < (var_1ch - var_24h) + iVar4)) {\n        var_14h = (var_24h - var_1ch) + var_ch;\n    }\n    fcn.004184db(0, lprcDst, var_14h, 0xffffffff, 0xffffffff, 0x15);\n    return;\n}\n",
        "token_count": 1082
    },
    "0041c135": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get graphical window text"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041c135(uint hWnd, uint lpString2)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint lpString1;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString2);\n    if (uVar1 < 0x101) {\n        uVar2 = (*_sym.imp.USER32.dll_GetWindowTextA)(hWnd, &lpString1, 0x100);\n        if (uVar2 == uVar1) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(&lpString1, lpString2);\n            if (iVar3 == 0) goto code_r0x0041c190;\n        }\n    }\n    (*_sym.imp.USER32.dll_SetWindowTextA)(hWnd, lpString2);\ncode_r0x0041c190:\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 233
    },
    "0041e11b": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.0041e11b(void)\n\n{\n    uint uVar1;\n    uint var_18h;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetOEMCP)(&var_18h);\n    (*_sym.imp.KERNEL32.dll_GetCPInfo)(uVar1);\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 100
    },
    "00401130": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nuint32_t fcn.00401130(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    code *pcVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    \n    pcVar4 = _sym.imp.USER32.dll_SendMessageA;\n    (*_sym.imp.USER32.dll_SendMessageA)(0, 0x36b, 0x1561a, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    iVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    pcVar3 = _sym.imp.USER32.dll_CreateWindowExW;\n    pcVar2 = _sym.imp.USER32.dll_InSendMessage;\n    if (iVar5 == 0) {\n        (*_sym.imp.USER32.dll_CreateWindowExW)\n                  (0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                   , 0);\n    }\n    else {\n        iVar5 = (*_sym.imp.USER32.dll_InSendMessage)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    uVar7 = 0x1561a;\n    uVar6 = 0x36b;\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    (*pcVar4)(0, 0x36b, 0x1561a, 0);\n    iVar5 = (*pcVar1)();\n    if (iVar5 == 0) {\n        (*pcVar3)(0, L\"uitfffXDDaszsfffff\", L\"gfsgfsxxxcddfsszxsswee\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac, 0, 0, 0\n                  , 0);\n    }\n    else {\n        iVar5 = (*pcVar2)();\n        if (iVar5 != 0) {\n            (*pcVar4)(0, 0x15623, 0x15605, 0);\n        }\n    }\n    return (~uVar6 | ~uVar7) & (uVar6 | uVar7);\n}\n",
        "token_count": 12607
    },
    "00402bf0": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nuint fcn.00402bf0(int32_t param_1, int32_t param_2, uchar *param_3, uchar *param_4)\n\n{\n    uchar uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iStack8;\n    \n    iStack8 = param_4;\n    iVar4 = 0;\n    iVar3 = 0;\n    if (param_4 != NULL) {\n        param_4 = param_3;\n        do {\n            iVar4 = (iVar4 + 1) % 0x22e5;\n            iVar3 = (*(iVar4 + param_1) + iVar3) % 0x22e5;\n            uVar1 = *(iVar4 + param_1);\n            *(iVar4 + param_1) = *(iVar3 + param_1);\n            *(iVar3 + param_1) = uVar1;\n            uVar1 = *((*(iVar4 + param_1) + *(iVar3 + param_1)) % 0x22e5 + param_1);\n            (*_sym.imp.USER32.dll_SendMessageA)(0, 0x36b, 0x1561a, 0);\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar2 == 0) {\n                (*_sym.imp.USER32.dll_CreateWindowExW)\n                          (0, L\"fdghcCCSzxsdEEAGSFDgxxgf\", L\"uyfuyrfyuffffddd\", 0x800000, 0x36b, 0x377, 0xada7, 0x104ac\n                           , 0, 0, 0, 0);\n            }\n            else {\n                iVar2 = (*_sym.imp.USER32.dll_InSendMessage)();\n                if (iVar2 != 0) {\n                    (*_sym.imp.USER32.dll_SendMessageA)(0, 0x15623, 0x15605, 0);\n                }\n            }\n            uVar1 = fcn.00401130(uVar1, param_4[param_2 - param_3]);\n            *param_4 = uVar1;\n            param_4 = param_4 + 1;\n            iStack8 = iStack8 + -1;\n        } while (iStack8 != 0);\n    }\n    return 0;\n}\n",
        "token_count": 524
    },
    "00402e80": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771"
        ],
        "decompiled_code": "\nvoid fcn.00402e80(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t unaff_ESI;\n    int32_t unaff_EDI;\n    uchar *puVar3;\n    int32_t iStack32;\n    int32_t iStack28;\n    int32_t iStack24;\n    int32_t iStack20;\n    uchar auStack16 [12];\n    uint uStack4;\n    \n    iVar2 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    pcVar1 = _sym.imp.USER32.dll_GetWindowRect;\n    puVar3 = auStack16;\n    (*_sym.imp.USER32.dll_GetWindowRect)(iVar2, puVar3);\n    (*pcVar1)(uStack4, &stack0xffffffd8);\n    (*_sym.imp.USER32.dll_SetWindowPos)\n              (uStack4, 0, (iStack24 - iStack32) / 2 - (unaff_EDI - iVar2) / 2, \n               (iStack20 - iStack28) / 2 - (unaff_ESI - puVar3) / 2, 0, 0, 1);\n    return;\n}\n",
        "token_count": 262
    },
    "004034d0": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004034d0(int32_t param_1, int32_t param_2)\n\n{\n    *(param_1 + 0x14) = param_2;\n    if (0xf < *(param_1 + 0x18)) {\n        *(*(param_1 + 4) + param_2) = 0;\n        return;\n    }\n    *(param_1 + 4 + param_2) = 0;\n    return;\n}\n",
        "token_count": 105
    },
    "00404400": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00404400(int32_t param_1, uint param_2)\n\n{\n    *(param_1 + 0x14) = 0;\n    *(param_1 + 0x18) = 0xf;\n    *(param_1 + 4) = 0;\n    fcn.004040a0(param_2, 0, 0xffffffff);\n    return param_1;\n}\n",
        "token_count": 96
    },
    "004044e0": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.004044e0(int32_t param_1, char *param_2)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    *(param_1 + 0x18) = 0xf;\n    *(param_1 + 0x14) = 0;\n    *(param_1 + 4) = 0;\n    pcVar2 = param_2;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.004041d0(param_2, pcVar2 - (param_2 + 1));\n    return param_1;\n}\n",
        "token_count": 162
    },
    "00415185": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00415185(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.004182d5(4);\n    if (iVar1 == 0) {\n        uVar2 = 0;\n    }\n    else {\n        uVar2 = fcn.00416aa2();\n    }\n    *(param_1 + 0x24) = uVar2;\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0x201;\n    *(param_1 + 0x14) = 6;\n    *(param_1 + 0x18) = 0;\n    *(param_1 + 0x1c) = 0;\n    *(param_1 + 0x20) = 0;\n    fcn.00415064(0, 0);\n    return;\n}\n",
        "token_count": 209
    },
    "00416926": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\ncode ** __cdecl fcn.00416926(uint arg_8h)\n\n{\n    uchar uVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    extraout_ECX[1] = 0x1;\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[2] = NULL;\n    extraout_ECX[3] = NULL;\n    extraout_ECX[4] = NULL;\n    uVar1 = *(unaff_EBP + 8);\n    *extraout_ECX = vtable.std::locale::_Locimp.0;\n    *(extraout_ECX + 5) = uVar1;\n    fcn.004044e0(0x422a38);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 259
    },
    "00418079": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00418079(code **param_1, code *param_2)\n\n{\n    *param_1 = vtable.CMapPtrToPtr.0;\n    if (param_2 < 1) {\n        param_2 = 0xa;\n    }\n    param_1[1] = NULL;\n    param_1[2] = 0x11;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[5] = NULL;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 131
    },
    "00418558": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00418558(int32_t param_1)\n\n{\n    *(param_1 + 4) = 1;\n    *(param_1 + 8) = 0;\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 0x14) = 1;\n    *(param_1 + 0x18) = 0;\n    return;\n}\n",
        "token_count": 107
    },
    "004187d0": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004187d0(code **param_1)\n\n{\n    *param_1 = vtable.CCmdUI.0;\n    param_1[8] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    param_1[9] = NULL;\n    param_1[4] = NULL;\n    param_1[3] = NULL;\n    param_1[5] = NULL;\n    param_1[7] = NULL;\n    param_1[6] = NULL;\n    return;\n}\n",
        "token_count": 126
    },
    "004189ae": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** __cdecl fcn.004189ae(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    code *pcVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    pcVar1 = *(unaff_EBP + 8);\n    *extraout_ECX = vtable.CHandleMap.0;\n    uVar2 = *(pcVar1 + 4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.004071ec(uVar2, 0x40);\n    *(unaff_EBP + -4) = 0;\n    fcn.00418079(10);\n    *(unaff_EBP + -4) = 1;\n    fcn.00418079(4);\n    *(unaff_EBP + -4) = 2;\n    fcn.00417ebd(7, 0);\n    uVar2 = *(unaff_EBP + -0xc);\n    extraout_ECX[5] = *(unaff_EBP + 0xc);\n    extraout_ECX[6] = *(unaff_EBP + 0x10);\n    extraout_ECX[0x16] = *(unaff_EBP + 0x14);\n    pcVar3 = *(unaff_EBP + 0x18);\n    extraout_ECX[0x15] = pcVar1;\n    extraout_ECX[0x17] = pcVar3;\n    *in_FS_OFFSET = uVar2;\n    return extraout_ECX;\n}\n",
        "token_count": 452
    },
    "0041d546": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041d546(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *in_ECX;\n    uint lpCriticalSection;\n    \n    puVar1 = in_ECX + 7;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(puVar1);\n    if ((arg_8h < 1) || (in_ECX[3] <= arg_8h)) goto code_r0x0041d640;\n    iVar2 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*in_ECX);\n    if (iVar2 == 0) {\n        iVar2 = fcn.0041d28a(0x10);\n        if (iVar2 == 0) {\n            iVar2 = 0;\n        }\n        else {\n            iVar2 = fcn.0041d498();\n        }\n        *(iVar2 + 8) = 0;\n        *(iVar2 + 0xc) = 0;\n        *(iVar2 + in_ECX[6]) = in_ECX[5];\n        in_ECX[5] = iVar2;\ncode_r0x0041d5c1:\n        if (*(iVar2 + 0xc) == 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0, in_ECX[3] << 2);\n        }\n        else {\n            iVar3 = (*_sym.imp.KERNEL32.dll_LocalReAlloc)(*(iVar2 + 0xc), in_ECX[3] << 2, 2);\n        }\n        if (iVar3 == 0) {\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar1);\n            iVar3 = fcn.0041798e();\n        }\n        *(iVar2 + 0xc) = iVar3;\n        fcn.00409040(iVar3 + *(iVar2 + 8) * 4, 0, (in_ECX[3] - *(iVar2 + 8)) * 4);\n        *(iVar2 + 8) = in_ECX[3];\n        (*_sym.imp.KERNEL32.dll_TlsSetValue)(*in_ECX, iVar2);\n    }\n    else if ((*(iVar2 + 8) <= arg_8h) && (arg_ch != 0)) goto code_r0x0041d5c1;\n    if ((*(iVar2 + 0xc) != 0) && (arg_8h < *(iVar2 + 8))) {\n        *(*(iVar2 + 0xc) + arg_8h * 4) = arg_ch;\n    }\ncode_r0x0041d640:\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar1);\n    return;\n}\n",
        "token_count": 614
    },
    "00403070": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00403070(int32_t *param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00407684(param_2);\n    if (iVar1 == 0) {\n        iVar1 = fcn.004010c0(0x8007000e);\n    }\n    *param_1 = iVar1;\n    return;\n}\n",
        "token_count": 91
    },
    "004030c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004030c0(int32_t *param_1)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    \n    iVar4 = *param_1;\n    ppiVar1 = iVar4 + -0x10;\n    piVar3 = *ppiVar1;\n    if (*(iVar4 + -0xc) != 0) {\n        piVar2 = iVar4 + -4;\n        if (*(iVar4 + -4) < 0) {\n            if (*(iVar4 + -8) < 0) {\n                fcn.004010c0(0x80070057);\n                iVar4 = extraout_ECX;\n            }\n            *(iVar4 + -0xc) = 0;\n            **param_1 = 0;\n            return;\n        }\n        LOCK();\n        iVar4 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        if (iVar4 == 1 || iVar4 + -1 < 0) {\n            (**(**ppiVar1 + 4))(ppiVar1);\n        }\n        iVar4 = (**(*piVar3 + 0xc))();\n        *param_1 = iVar4 + 0x10;\n    }\n    return;\n}\n",
        "token_count": 300
    },
    "004031f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.004031f0(uint *param_1)\n\n{\n    int32_t iVar1;\n    uchar auStack256 [256];\n    \n    fcn.00407bb1(*param_1, 0, 0, 0, auStack256);\n    iVar1 = fcn.00407b48(auStack256, 0x41f558);\n    if (iVar1 != 0) {\n        iVar1 = fcn.00407b48(auStack256, \".cpp\");\n        if (iVar1 != 0) {\n            iVar1 = fcn.00407b48(auStack256, \".dsp\");\n            if (iVar1 != 0) {\n                iVar1 = fcn.00407b48(auStack256, \".dsw\");\n                if (iVar1 != 0) {\n                    iVar1 = fcn.00407b48(auStack256, 0x41f53c);\n                    if (iVar1 != 0) {\n                        iVar1 = fcn.00407b48(auStack256, \".hpp\");\n                        if (iVar1 != 0) {\n                            iVar1 = fcn.00407b48(auStack256, 0x41f530);\n                            if (iVar1 != 0) {\n                                iVar1 = fcn.00407b48(auStack256, \".vcproj\");\n                                if (iVar1 != 0) {\n                                    return 0;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return 1;\n}\n",
        "token_count": 332
    },
    "00403370": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.00403370(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (**(*param_2 + 0xc))();\n    *param_1 = iVar1 + 0x10;\n    return param_1;\n}\n",
        "token_count": 75
    },
    "004034f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.004034f0(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = fcn.00418200();\n    iVar2 = (**(*piVar1 + 0xc))();\n    *param_1 = iVar2 + 0x10;\n    return param_1;\n}\n",
        "token_count": 88
    },
    "00403570": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.00403570(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00403470(*param_2 + -0x10);\n    *param_1 = iVar1 + 0x10;\n    return param_1;\n}\n",
        "token_count": 80
    },
    "00403620": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t ** __thiscall fcn.00403620(int32_t **param_1, int32_t *param_2)\n\n{\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x41e3f8;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    *param_1 = param_2;\n    if (*(*(*param_2 + 4) + 0x28 + param_2) != 0) {\n        fcn.004151f8();\n    }\n    uStack4 = 0;\n    if ((*(*(*param_2 + 4) + 8 + param_2) == 0) && (*(param_2 + *(*param_2 + 4) + 0x2c) != 0)) {\n        fcn.00403510();\n    }\n    *(param_1 + 1) = *(*(*param_2 + 4) + 8 + param_2) == 0;\n    *in_FS_OFFSET = uStack12;\n    return param_1;\n}\n",
        "token_count": 265
    },
    "00403870": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.00403870(int32_t *param_1, int32_t *param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    \n    if (param_3 < 0) {\n        param_3 = 0;\n    }\n    iVar2 = *param_1;\n    iVar1 = *(iVar2 + -0xc);\n    if (iVar1 <= param_3) {\n        iVar2 = fcn.00403470(iVar2 + -0x10);\n        *param_2 = iVar2 + 0x10;\n        return param_2;\n    }\n    uVar3 = (**(**(iVar2 + -0x10) + 0x10))();\n    fcn.004033b0((iVar2 - param_3) + iVar1, param_3, uVar3);\n    return param_2;\n}\n",
        "token_count": 211
    },
    "00403900": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00403900(int32_t *param_1, int32_t param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    if (param_2 == 0) {\n        fcn.004010c0(0x80070057);\n    }\n    iVar2 = fcn.00407b18(param_2, param_2);\n    if ((1U - *(*param_1 + -4) | *(*param_1 + -8) - iVar2) < 0) {\n        fcn.00403420(iVar2);\n    }\n    fcn.00407ac1(*param_1, param_2, param_2);\n    if ((-1 < iVar2) && (iVar2 <= *(*param_1 + -8))) {\n        *(*param_1 + -0xc) = iVar2;\n        *(iVar2 + *param_1) = 0;\n        return;\n    }\n    fcn.004010c0(0x80070057);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 246
    },
    "00403980": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00403980(int32_t **param_1)\n\n{\n    char cVar1;\n    uint *in_FS_OFFSET;\n    int32_t **ppiVar2;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x41e3f8;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    uStack4 = 0;\n    ppiVar2 = param_1;\n    cVar1 = fcn.004153c0();\n    if ((cVar1 == '\\0') && ((*(*(**param_1 + 4) + 0x10 + *param_1) & 2) != 0)) {\n        fcn.00403510();\n    }\n    uStack4 = 0xffffffff;\n    if (*(*(**param_1 + 4) + 0x28 + *param_1) != 0) {\n        fcn.00415201(ppiVar2);\n    }\n    *in_FS_OFFSET = uStack12;\n    return;\n}\n",
        "token_count": 241
    },
    "004043b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.004043b0(void)\n\n{\n    uint in_stack_000022ec;\n    uint in_stack_000022f0;\n    uint in_stack_000022f4;\n    uint in_stack_000022f8;\n    \n    fcn.004079f0();\n    fcn.004042c0(in_stack_000022ec, *0x10);\n    fcn.00402bf0(*0x10, in_stack_000022f0, in_stack_000022f4, in_stack_000022f8);\n    return 0;\n}\n",
        "token_count": 124
    },
    "004046d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.004046d0(void)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t unaff_EBX;\n    int32_t iVar8;\n    int32_t *in_FS_OFFSET;\n    uchar *arg_8h;\n    uchar auStack44 [4];\n    uchar auStack40 [12];\n    int32_t iStack28;\n    uint uStack20;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x41e498;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    fcn.00405ea7();\n    uStack4 = 0;\n    piVar2 = fcn.00418200();\n    ppiVar3 = (**(*piVar2 + 0xc))();\n    uStack4._0_1_ = 1;\n    iVar4 = fcn.00403470();\n    arg_8h = auStack44;\n    uStack4 = CONCAT31(uStack4._1_3_, 2);\n    puVar5 = fcn.00403870();\n    iVar6 = fcn.00407a2d(*puVar5, 0x41f5c0);\n    piVar2 = unaff_EBX + -4;\n    LOCK();\n    iVar8 = *piVar2;\n    *piVar2 = *piVar2 + -1;\n    if (iVar8 == 1 || iVar8 + -1 < 0) {\n        (**(**(unaff_EBX + -0x10) + 4))(unaff_EBX + -0x10);\n    }\n    iVar8 = iVar4 + 0x10;\n    if (iVar6 != 0) {\n        fcn.00403b60(\"\\\\*.*\", 4);\n        iVar8 = uStack12;\n    }\n    iVar4 = fcn.00405f5b(iVar8, 0);\n    while (iVar4 != 0) {\n        iVar4 = fcn.00405c63();\n        iVar6 = fcn.00405e49();\n        if (iVar6 == 0) {\n            iVar6 = (**(unaff_EBX + 0x38))(0x10);\n            if (iVar6 == 0) {\n                arg_8h = auStack40;\n                uVar7 = fcn.004060e4(arg_8h);\n                uStack8 = CONCAT31(uStack8._1_3_, 4);\n                fcn.00404030(uVar7);\n                uStack12 = CONCAT31(uStack12._1_3_, 2);\n                ppiVar1 = ppiVar3 + 3;\n                LOCK();\n                piVar2 = *ppiVar1;\n                *ppiVar1 = *ppiVar1 + -1;\n                if (piVar2 == 0x1 || piVar2 + -1 < 0) {\n                    (**(**ppiVar3 + 4))(ppiVar3);\n                }\n                fcn.00417b76(*0x428bc4, &stack0xffffffc8);\n            }\n            else {\n                arg_8h = auStack44;\n                uVar7 = fcn.004060e4(arg_8h);\n                uStack8 = CONCAT31(uStack8._1_3_, 3);\n                fcn.00404030(uVar7);\n                uStack12 = CONCAT31(uStack12._1_3_, 2);\n                piVar2 = unaff_EBX + -4;\n                LOCK();\n                iVar6 = *piVar2;\n                *piVar2 = *piVar2 + -1;\n                if (iVar6 == 1 || iVar6 + -1 < 0) {\n                    (**(**(unaff_EBX + -0x10) + 4))(unaff_EBX + -0x10);\n                }\n                fcn.004046d0(&stack0xffffffc0);\n            }\n        }\n    }\n    fcn.00405b93();\n    uStack20._0_1_ = 1;\n    piVar2 = iVar8 + -4;\n    LOCK();\n    iVar4 = *piVar2;\n    *piVar2 = *piVar2 + -1;\n    if (iVar4 == 1 || iVar4 + -1 < 0) {\n        (**(**(iVar8 + -0x10) + 4))(iVar8 + -0x10);\n    }\n    uStack20 = uStack20._1_3_ << 8;\n    piVar2 = arg_8h + -4;\n    LOCK();\n    iVar8 = *piVar2;\n    *piVar2 = *piVar2 + -1;\n    if (iVar8 == 1 || iVar8 + -1 < 0) {\n        (**(**(arg_8h + -0x10) + 4))(arg_8h + -0x10);\n    }\n    uStack20 = 0xffffffff;\n    fcn.00405ecb();\n    *in_FS_OFFSET = iStack28;\n    return;\n}\n",
        "token_count": 1169
    },
    "004057cf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004057cf(uint hModule, uint hResInfo, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint16_t *puVar2;\n    uint16_t *puVar3;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadResource)(hModule, hResInfo);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    puVar2 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar1);\n    if (puVar2 != NULL) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_SizeofResource)(hModule, hResInfo);\n        puVar3 = iVar1 + puVar2;\n        for (arg_10h = arg_10h & 0xf; arg_10h != 0; arg_10h = arg_10h - 1) {\n            if (puVar3 <= puVar2) {\n                return 0;\n            }\n            puVar2 = puVar2 + *puVar2 + 1;\n        }\n        if (puVar2 < puVar3) {\n            return -(*puVar2 != 0) & puVar2;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 275
    },
    "0040582b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040582b(uint param_1, uint32_t param_2)\n\n{\n    int32_t hResInfo;\n    \n    hResInfo = (*_sym.imp.KERNEL32.dll_FindResourceA)(param_1);\n    if (hResInfo == 0) {\n        return;\n    }\n    fcn.004057cf((param_2 >> 4) + 1 & 0xffff, hResInfo, 6);\n    return;\n}\n",
        "token_count": 102
    },
    "004060e4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nuint __cdecl fcn.004060e4(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    uint uVar4;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    *(unaff_EBP + -0x10) = 0;\n    fcn.00403570(extraout_ECX + 4);\n    iVar1 = *(unaff_EBP + -0x10);\n    iVar2 = *(iVar1 + -0xc);\n    *(unaff_EBP + -4) = 0;\n    pcVar3 = fcn.00408c93(iVar1, iVar2 + iVar1);\n    if ((*pcVar3 != '\\\\') && (*pcVar3 != '/')) {\n        *(unaff_EBP + -0x14) = *(extraout_ECX + 5);\n        fcn.00405939(*(unaff_EBP + -0x14));\n    }\n    uVar4 = (**(*extraout_ECX + 0xc))(unaff_EBP + -0x14);\n    *(unaff_EBP + -4) = 1;\n    fcn.0041cede(uVar4);\n    *(unaff_EBP + -4) = 0;\n    fcn.004010e0();\n    fcn.00403570(unaff_EBP + -0x10);\n    fcn.004010e0();\n    uVar4 = *(unaff_EBP + 8);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar4;\n}\n",
        "token_count": 445
    },
    "0040625b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040625b(uint param_1)\n\n{\n    fcn.00409040(param_1, 0, 0x18);\n    return param_1;\n}\n",
        "token_count": 43
    },
    "004062bf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool fcn.004062bf(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004090a0(param_1, param_2, 0x10);\n    return iVar1 == 0;\n}\n",
        "token_count": 60
    },
    "004067f9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004067f9(int32_t arg_8h, uint32_t *arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    uint32_t pvParam;\n    uint32_t uStack16;\n    uint32_t uStack12;\n    uint32_t uStack8;\n    \n    iVar2 = fcn.00406648();\n    if (iVar2 == 0) {\n        if ((((arg_8h == 0x12340042) && (arg_ch != NULL)) && (0x27 < *arg_ch)) &&\n           (iVar2 = (*_sym.imp.USER32.dll_SystemParametersInfoA)(0x30, 0, &pvParam, 0),  iVar2 != 0)) {\n            arg_ch[1] = 0;\n            arg_ch[2] = 0;\n            pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n            uVar4 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0);\n            arg_ch[3] = uVar4;\n            uVar4 = (*pcVar1)(1);\n            arg_ch[5] = pvParam;\n            arg_ch[6] = uStack16;\n            arg_ch[7] = uStack12;\n            arg_ch[8] = uStack8;\n            uVar3 = 1;\n            arg_ch[4] = uVar4;\n            arg_ch[9] = 1;\n            if (0x47 < *arg_ch) {\n                (*_sym.imp.KERNEL32.dll_lstrcpynA)(arg_ch + 10, \"DISPLAY\", 0x20);\n            }\n        }\n        else {\n            uVar3 = 0;\n        }\n    }\n    else {\n        uVar3 = (**0x42a888)(arg_8h, arg_ch);\n    }\n    return uVar3;\n}\n",
        "token_count": 420
    },
    "00407ac1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00407ac1(uchar *arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    uchar *var_20h;\n    int32_t var_1ch;\n    uchar *var_18h;\n    uint var_14h;\n    \n    var_1ch = 0x7fffffff;\n    var_14h = 0x42;\n    var_18h = arg_8h;\n    var_20h = arg_8h;\n    uVar1 = fcn.0040b36c(&var_20h, arg_ch, arg_10h);\n    if (arg_8h != NULL) {\n        var_1ch = var_1ch + -1;\n        if (var_1ch < 0) {\n            fcn.0040b1c5(0, &var_20h);\n        }\n        else {\n            *var_20h = 0;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 223
    },
    "00407b18": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407b18(uint arg_8h, uint arg_ch)\n\n{\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    \n    var_18h = 0;\n    var_20h = 0;\n    var_1ch = 0x7fffffff;\n    var_14h = 0x42;\n    fcn.0040b36c(&var_20h, arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 119
    },
    "00407de6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00407de6(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t arg_14h;\n    uint *puVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x420728, 0x10);\n    arg_14h = fcn.0040cee6();\n    *(unaff_EBP + -0x1c) = arg_14h;\n    if (arg_14h == 0) {\n        puVar1 = fcn.00409c85();\n        *puVar1 = 0x18;\n    }\n    else {\n        *(unaff_EBP + -4) = 0;\n        uVar2 = fcn.0040cd7e(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), arg_14h);\n        *(unaff_EBP + -0x20) = uVar2;\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00407e38();\n    }\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 306
    },
    "00407e42": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00407e42(uint param_1, uint param_2)\n\n{\n    fcn.00407de6(param_1, param_2, 0x40);\n    return;\n}\n",
        "token_count": 45
    },
    "00407e55": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00407e55(code *UNRECOVERED_JUMPTABLE)\n\n{\n    uint *in_FS_OFFSET;\n    \n    *in_FS_OFFSET = **in_FS_OFFSET;\n    // WARNING: Could not recover jumptable at 0x00407e7e. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*UNRECOVERED_JUMPTABLE)();\n    return;\n}\n",
        "token_count": 90
    },
    "0040922c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.0040922c(void)\n\n{\n    uint64_t uVar1;\n    uint32_t uVar2;\n    bool bVar3;\n    float fVar4;\n    float10 in_ST0;\n    uint32_t uStack32;\n    float fStack28;\n    \n    uVar1 = ROUND(in_ST0);\n    uStack32 = uVar1;\n    fStack28 = uVar1 >> 0x20;\n    fVar4 = in_ST0;\n    if ((uStack32 != 0) || (fVar4 = fStack28,  (uVar1 & 0x7fffffff00000000) != 0)) {\n        if (fVar4 < 0) {\n            uVar2 = 0x80000000 < (in_ST0 - uVar1 ^ 0x80000000);\n            bVar3 = CARRY4(uStack32, uVar2);\n            uStack32 = uStack32 + uVar2;\n            fStack28 = fStack28 + bVar3;\n        }\n        else {\n            uVar2 = 0x80000000 < in_ST0 - uVar1;\n            bVar3 = uStack32 < uVar2;\n            uStack32 = uStack32 - uVar2;\n            fStack28 = fStack28 - bVar3;\n        }\n    }\n    return CONCAT44(fStack28, uStack32);\n}\n",
        "token_count": 306
    },
    "00409aed": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00409aed(uint param_1)\n\n{\n    int32_t iVar1;\n    code **ppcVar2;\n    \n    if (*0x427878 != NULL) {\n        (**0x427878)(param_1);\n    }\n    iVar1 = 0;\n    ppcVar2 = 0x427088;\n    do {\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n        if (*ppcVar2 != NULL) {\n            iVar1 = (**ppcVar2)();\n        }\n        ppcVar2 = ppcVar2 + 1;\n    } while (ppcVar2 < 0x42709c);\n    if (iVar1 == 0) {\n        fcn.004083b2(0x40e402);\n        ppcVar2 = 0x427000;\n        do {\n            if (*ppcVar2 != NULL) {\n                (**ppcVar2)();\n            }\n            ppcVar2 = ppcVar2 + 1;\n        } while (ppcVar2 < 0x427084);\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 252
    },
    "00409c85": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00409c85(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040af1e();\n    return iVar1 + 8;\n}\n",
        "token_count": 44
    },
    "00409c8e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00409c8e(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040af1e();\n    return iVar1 + 0xc;\n}\n",
        "token_count": 46
    },
    "00409fcb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.00409fcb(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t arg_8h_00;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00408fec(0x420818, 8);\n    piVar1 = *(unaff_EBP + 8) * 8 + 0x427af0;\n    if (*piVar1 == 0) {\n        arg_8h_00 = fcn.00407684(0x18);\n        if (arg_8h_00 == 0) {\n            puVar2 = fcn.00409c85();\n            *puVar2 = 0xc;\n        }\n        else {\n            fcn.0040a06b(10);\n            *(unaff_EBP + -4) = 0;\n            if (*piVar1 == 0) {\n                iVar3 = fcn.0040fe86(arg_8h_00, 4000);\n                if (iVar3 == 0) {\n                    fcn.00407696(arg_8h_00);\n                    puVar2 = fcn.00409c85();\n                    *puVar2 = 0xc;\n                    fcn.0040782e(unaff_EBP + -0x10, 0xffffffff);\n                    goto code_r0x0040a05c;\n                }\n                *piVar1 = arg_8h_00;\n            }\n            else {\n                fcn.00407696(arg_8h_00);\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0040a062();\n        }\n    }\ncode_r0x0040a05c:\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 447
    },
    "0040a492": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * fcn.0040a492(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    \n    if (*0x42c390 == *0x42c3a0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x42c3a8, 0, *0x42c394, (*0x42c3a0 * 5 + 0x50) * 4);\n        if (iVar2 == 0) {\n            return NULL;\n        }\n        *0x42c3a0 = *0x42c3a0 + 0x10;\n        *0x42c394 = iVar2;\n    }\n    puVar1 = *0x42c394 + *0x42c390 * 0x14;\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x42c3a8, 8, 0x41c4);\n    puVar1[4] = iVar2;\n    if (iVar2 != 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, 0x100000, 0x2000, 4);\n        puVar1[3] = iVar2;\n        if (iVar2 != 0) {\n            puVar1[2] = 0xffffffff;\n            *puVar1 = 0;\n            puVar1[1] = 0;\n            *0x42c390 = *0x42c390 + 1;\n            *puVar1[4] = 0xffffffff;\n            return puVar1;\n        }\n        (*_sym.imp.KERNEL32.dll_HeapFree)(*0x42c3a8, 0, puVar1[4]);\n    }\n    return NULL;\n}\n",
        "token_count": 397
    },
    "0040be3b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040be3b(uint param_1, int32_t param_2)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    \n    if (0 < param_2) {\n        puVar1 = &param_2;\n        iVar2 = param_2;\n        do {\n            puVar1 = puVar1 + 1;\n            fcn.0040fcf0(param_1, *puVar1);\n            iVar2 = iVar2 + -1;\n        } while (iVar2 != 0);\n    }\n    return;\n}\n",
        "token_count": 125
    },
    "0040bfc4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuchar * fcn.0040bfc4(void)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    \n    bVar1 = true;\n    if (*0x427dcc == NULL) {\n        *0x427dcc = fcn.00407684(0x351);\n        if (*0x427dcc == NULL) {\n            return NULL;\n        }\n    }\n    **0x427dcc = 0;\n    fcn.0040be3b(*0x427dcc, 3, *0x427dd4, 0x420ac4, *0x427dd8);\n    puVar3 = 0x427dd8;\n    do {\n        fcn.0040fcf0(*0x427dcc, 0x4206e0);\n        puVar4 = puVar3 + 3;\n        iVar2 = fcn.0040ae70(*puVar3, *puVar4);\n        if (iVar2 != 0) {\n            bVar1 = false;\n        }\n        fcn.0040be3b(*0x427dcc, 3, puVar3[2], 0x420ac4, *puVar4);\n        puVar3 = puVar4;\n    } while (puVar4 < 0x427e08);\n    if (!bVar1) {\n        return *0x427dcc;\n    }\n    fcn.00407696(*0x427dcc);\n    *0x427dcc = NULL;\n    return *0x427de4;\n}\n",
        "token_count": 346
    },
    "0040d1ba": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040d1ba(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t arg_8h_00;\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint arg_10h_00;\n    int32_t unaff_EBP;\n    uint var_50h;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_20h;\n    uint var_4h;\n    \n    fcn.00408fec(0x420b50, 0x40);\n    arg_8h_00 = *(unaff_EBP + 0xc);\n    iVar3 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x20) = arg_10h_00;\n    *(unaff_EBP + -0x48) = 0;\n    *(unaff_EBP + -0x38) = *(arg_8h_00 + -4);\n    uVar1 = fcn.00408142(unaff_EBP + -0x50, *(iVar3 + 0x18));\n    *(unaff_EBP + -0x3c) = uVar1;\n    iVar2 = fcn.0040af1e();\n    *(unaff_EBP + -0x40) = *(iVar2 + 0x7c);\n    iVar2 = fcn.0040af1e();\n    *(unaff_EBP + -0x44) = *(iVar2 + 0x80);\n    iVar2 = fcn.0040af1e();\n    *(iVar2 + 0x7c) = iVar3;\n    iVar3 = fcn.0040af1e();\n    *(iVar3 + 0x80) = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 1;\n    uVar1 = fcn.004081d7(arg_8h_00, *(unaff_EBP + 0x14), arg_10h_00, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c));\n    *(unaff_EBP + -0x20) = uVar1;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0040d30f();\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 617
    },
    "0040e3be": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0040e3be(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x420fa0, 0xc);\n    *(unaff_EBP + -0x1c) = 0x423bd4;\n    while (*(unaff_EBP + -0x1c) < 0x423bd4) {\n        *(unaff_EBP + -4) = 0;\n        if (**(unaff_EBP + -0x1c) != NULL) {\n            (***(unaff_EBP + -0x1c))();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(unaff_EBP + -0x1c) = *(unaff_EBP + -0x1c) + 4;\n    }\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 224
    },
    "0040ecb2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nbool fcn.0040ecb2(void)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t *unaff_EBX;\n    uint32_t uVar6;\n    \n    if (*0x4281f4 == 0) {\n        return false;\n    }\n    iVar1 = unaff_EBX[5];\n    if ((iVar1 != *0x428288) || (iVar1 != *0x428294)) {\n        if (*0x42af64 == 0) {\n            fcn.0040eafa(1, 1, iVar1, 1, 0, 0, 0, 0, 0);\n            fcn.0040eafa(0, 1, iVar1, 5, 0, 0, 0, 0, 0);\n        }\n        else {\n            if (*0x42af50 != 0) {\n                uVar6 = *0x42af56;\n                uVar3 = 0;\n                uVar4 = 0;\n            }\n            else {\n                uVar3 = *0x42af54;\n                uVar6 = 0;\n                uVar4 = *0x42af56;\n            }\n            fcn.0040eafa(1, *0x42af50 == 0, iVar1, uVar4, uVar3, uVar6, *0x42af5a, *0x42af5c, *0x42af5e);\n            if (*0x42aefc != 0) {\n                uVar6 = *0x42af02;\n                uVar3 = 0;\n                uVar4 = 0;\n            }\n            else {\n                uVar3 = *0x42af00;\n                uVar6 = 0;\n                uVar4 = *0x42af02;\n            }\n            fcn.0040eafa(0, *0x42aefc == 0, iVar1, uVar4, uVar3, uVar6, *0x42af06, *0x42af08, *0x42af0a);\n        }\n    }\n    iVar1 = unaff_EBX[7];\n    if (*0x42828c < *0x428298) {\n        if ((iVar1 < *0x42828c) || (*0x428298 < iVar1)) {\n            return false;\n        }\n        if ((*0x42828c < iVar1) && (iVar1 < *0x428298)) {\n            return true;\n        }\n    }\n    else {\n        if (iVar1 < *0x428298) {\n            return true;\n        }\n        if (*0x42828c < iVar1) {\n            return true;\n        }\n        if ((*0x428298 < iVar1) && (iVar1 < *0x42828c)) {\n            return false;\n        }\n    }\n    iVar5 = ((unaff_EBX[2] * 0x3c + unaff_EBX[1]) * 0x3c + *unaff_EBX) * 1000;\n    if (iVar1 == *0x42828c) {\n        bVar2 = *0x428290 <= iVar5;\n    }\n    else {\n        bVar2 = iVar5 < *0x42829c;\n    }\n    return bVar2;\n}\n",
        "token_count": 758
    },
    "0040efb9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040efb9(uint32_t lpFileName, int32_t arg_ch, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint32_t uVar3;\n    uint lpFilePart;\n    uint lpBuffer;\n    uint var_4h;\n    \n    uVar3 = lpFileName;\n    var_4h = *0x427850;\n    if (lpFileName == 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentDirectoryA)(0x104, &lpBuffer);\n    }\n    else {\n        iVar1 = fcn.0040ef82(lpFileName);\n        if (iVar1 == 0) {\n            puVar2 = fcn.00409c8e();\n            *puVar2 = 0xf;\n            puVar2 = fcn.00409c85();\n            *puVar2 = 0xd;\n            goto code_r0x0040eff5;\n        }\n        lpFileName = CONCAT12(0x2e, CONCAT11(0x3a, uVar3 + '@'));\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetFullPathNameA)(&lpFileName, 0x104, &lpBuffer, &lpFilePart);\n    }\n    if ((iVar1 != 0) && (uVar3 = iVar1 + 1,  uVar3 < 0x105)) {\n        if (arg_ch == 0) {\n            if (uVar3 <= arg_10h) {\n                uVar3 = arg_10h;\n            }\n            iVar1 = fcn.00407684(uVar3);\n            if (iVar1 == 0) {\n                puVar2 = fcn.00409c85();\n                *puVar2 = 0xc;\n                goto code_r0x0040eff5;\n            }\n        }\n        else {\n            iVar1 = arg_ch;\n            if (arg_10h < uVar3) {\n                puVar2 = fcn.00409c85();\n                *puVar2 = 0x22;\n                goto code_r0x0040eff5;\n            }\n        }\n        fcn.0040fce0(iVar1, &lpBuffer);\n    }\ncode_r0x0040eff5:\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 512
    },
    "0040f0a4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040f0a4(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x4211e0, 0xc);\n    fcn.0040a06b(7);\n    *(unaff_EBP + -4) = 0;\n    uVar1 = fcn.0040efb9(0, *(unaff_EBP + 8), *(unaff_EBP + 0xc));\n    *(unaff_EBP + -0x1c) = uVar1;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0040f0e1();\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 206
    },
    "0040f638": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint32_t __cdecl fcn.0040f638(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint noname_2;\n    int32_t iVar1;\n    uint32_t in_ECX;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint32_t var_4h;\n    \n    if (arg_ch + 1 < 0x101) {\n        arg_ch._2_2_ = *(*(arg_8h + 0x48) + arg_ch * 2);\n    }\n    else {\n        if ((*(*(arg_8h + 0x48) + 1 + (arg_ch >> 8 & 0xffU) * 2) & 0x80) == 0) {\n            var_4h = in_ECX & 0xffff0000 | arg_ch & 0xff;\n            noname_2 = 1;\n        }\n        else {\n            var_4h = CONCAT11(arg_ch, arg_ch >> 8);\n            var_4h = in_ECX & 0xff000000 | var_4h;\n            noname_2 = 2;\n        }\n        iVar1 = fcn.0040fb26(1, &var_4h, noname_2, &arg_ch + 2, *(arg_8h + 4), *(arg_8h + 0x14), 1, var_4h, unaff_EBP, \n                             unaff_retaddr, arg_8h, arg_ch, arg_10h, in_stack_00000010, in_stack_00000014);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return arg_ch._2_2_ & arg_10h;\n}\n",
        "token_count": 429
    },
    "0040fcf0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * fcn.0040fcf0(uint32_t *param_1, uint32_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t *puVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    \n    uVar4 = param_1 & 3;\n    puVar3 = param_1;\n    while (uVar4 != 0) {\n        uVar1 = *puVar3;\n        puVar3 = puVar3 + 1;\n        if (uVar1 == 0) goto code_r0x0040fd43;\n        uVar4 = puVar3 & 3;\n    }\n    do {\n        do {\n            puVar5 = puVar3;\n            puVar3 = puVar5 + 1;\n        } while (((*puVar5 ^ 0xffffffff ^ *puVar5 + 0x7efefeff) & 0x81010100) == 0);\n        uVar4 = *puVar5;\n        if (uVar4 == '\\0') goto code_r0x0040fd55;\n        if (uVar4 >> 8 == '\\0') {\n            puVar5 = puVar5 + 1;\n            goto code_r0x0040fd55;\n        }\n        if ((uVar4 & 0xff0000) == 0) {\n            puVar5 = puVar5 + 2;\n            goto code_r0x0040fd55;\n        }\n    } while ((uVar4 & 0xff000000) != 0);\ncode_r0x0040fd43:\n    puVar5 = puVar3 + -1;\ncode_r0x0040fd55:\n    uVar4 = param_2 & 3;\n    while (uVar4 != 0) {\n        uVar1 = *param_2;\n        uVar4 = uVar1;\n        param_2 = param_2 + 1;\n        if (uVar1 == 0) goto code_r0x0040fdd0;\n        *puVar5 = uVar1;\n        puVar5 = puVar5 + 1;\n        uVar4 = param_2 & 3;\n    }\n    do {\n        uVar2 = *param_2;\n        uVar4 = *param_2;\n        param_2 = param_2 + 1;\n        if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {\n            if (uVar4 == '\\0') {\ncode_r0x0040fdd0:\n                *puVar5 = uVar4;\n                return param_1;\n            }\n            if (uVar4 >> 8 == '\\0') {\n                *puVar5 = uVar4;\n                return param_1;\n            }\n            if ((uVar4 & 0xff0000) == 0) {\n                *puVar5 = uVar4;\n                *(puVar5 + 2) = 0;\n                return param_1;\n            }\n            if ((uVar4 & 0xff000000) == 0) {\n                *puVar5 = uVar4;\n                return param_1;\n            }\n        }\n        *puVar5 = uVar4;\n        puVar5 = puVar5 + 1;\n    } while( true );\n}\n",
        "token_count": 755
    },
    "0040fce0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * fcn.0040fce0(uint32_t *param_1, uint32_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t *puVar4;\n    \n    uVar3 = param_2 & 3;\n    puVar4 = param_1;\n    while (uVar3 != 0) {\n        uVar1 = *param_2;\n        uVar3 = uVar1;\n        param_2 = param_2 + 1;\n        if (uVar1 == 0) goto code_r0x0040fdd0;\n        *puVar4 = uVar1;\n        puVar4 = puVar4 + 1;\n        uVar3 = param_2 & 3;\n    }\n    do {\n        uVar2 = *param_2;\n        uVar3 = *param_2;\n        param_2 = param_2 + 1;\n        if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {\n            if (uVar3 == '\\0') {\ncode_r0x0040fdd0:\n                *puVar4 = uVar3;\n                return param_1;\n            }\n            if (uVar3 >> 8 == '\\0') {\n                *puVar4 = uVar3;\n                return param_1;\n            }\n            if ((uVar3 & 0xff0000) == 0) {\n                *puVar4 = uVar3;\n                *(puVar4 + 2) = 0;\n                return param_1;\n            }\n            if ((uVar3 & 0xff000000) == 0) {\n                *puVar4 = uVar3;\n                return param_1;\n            }\n        }\n        *puVar4 = uVar3;\n        puVar4 = puVar4 + 1;\n    } while( true );\n}\n",
        "token_count": 441
    },
    "00410377": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00410377(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040af1e();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x427c8c) {\n        iVar1 = fcn.0040bf89();\n    }\n    fcn.00410317(iVar1, param_1, param_2);\n    return;\n}\n",
        "token_count": 103
    },
    "004110e2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004110e2(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040af1e();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x427c8c) {\n        iVar1 = fcn.0040bf89();\n    }\n    return iVar1 + 0xc;\n}\n",
        "token_count": 85
    },
    "00411415": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00411415(uint param_1, char *param_2)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    \n    iVar1 = 0;\n    while (cVar2 = *param_2,  cVar2 != '\\0') {\n        param_2 = param_2 + 1;\n        if ((cVar2 < 'a') || ('f' < cVar2)) {\n            if (('@' < cVar2) && (cVar2 < 'G')) {\n                cVar2 = cVar2 + -7;\n            }\n        }\n        else {\n            cVar2 = cVar2 + -0x27;\n        }\n        iVar1 = (iVar1 + 0xffffffd) * 0x10 + cVar2;\n    }\n    return iVar1;\n}\n",
        "token_count": 184
    },
    "00411b20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00411b20(char *arg_8h, char *arg_ch, uint32_t arg_10h)\n\n{\n    char cVar1;\n    char cVar2;\n    uint8_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    char *pcVar6;\n    char *pcVar7;\n    bool bVar8;\n    \n    uVar4 = arg_10h;\n    pcVar6 = arg_8h;\n    if (arg_10h != 0) {\n        do {\n            if (uVar4 == 0) break;\n            uVar4 = uVar4 - 1;\n            cVar1 = *pcVar6;\n            pcVar6 = pcVar6 + 1;\n        } while (cVar1 != '\\0');\n        iVar5 = arg_10h - uVar4;\n        do {\n            pcVar6 = arg_ch;\n            pcVar7 = arg_8h;\n            if (iVar5 == 0) break;\n            iVar5 = iVar5 + -1;\n            pcVar7 = arg_8h + 1;\n            pcVar6 = arg_ch + 1;\n            cVar1 = *arg_ch;\n            cVar2 = *arg_8h;\n            arg_ch = pcVar6;\n            arg_8h = pcVar7;\n        } while (cVar1 == cVar2);\n        uVar3 = pcVar6[-1];\n        arg_10h = 0;\n        bVar8 = uVar3 == pcVar7[-1];\n        if (uVar3 < pcVar7[-1] || bVar8) {\n            if (bVar8) {\n                return 0;\n            }\n            arg_10h = 0xfffffffe;\n        }\n        arg_10h = ~arg_10h;\n    }\n    return arg_10h;\n}\n",
        "token_count": 415
    },
    "004125de": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004125de(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x422780, 0x14);\n    *(unaff_EBP + -0x1c) = 0;\n    *(unaff_EBP + -4) = 0;\n    uVar1 = fcn.004122f7(unaff_EBP + -0x1c, unaff_EBP + -0x20, *(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x14)\n                        );\n    *(unaff_EBP + -0x24) = uVar1;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00412623();\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 259
    },
    "00412bff": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00412bff(uint param_1, uint param_2)\n\n{\n    fcn.00412aa7(param_1, param_2, 0x42844c);\n    return;\n}\n",
        "token_count": 46
    },
    "00412c15": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00412c15(uint param_1, uint param_2)\n\n{\n    fcn.00412aa7(param_1, param_2, 0x428464);\n    return;\n}\n",
        "token_count": 46
    },
    "00412c2b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00412c2b(uint arg_8h, uint arg_ch)\n\n{\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    fcn.00413b3d(&var_10h, &var_14h, arg_ch, 0, 0, 0, 0);\n    fcn.00412bff(&var_10h, arg_8h);\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 124
    },
    "00412c68": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00412c68(uint arg_8h, uint arg_ch)\n\n{\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    fcn.00413b3d(&var_10h, &var_14h, arg_ch, 0, 0, 0, 0);\n    fcn.00412c15(&var_10h, arg_8h);\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 124
    },
    "00412ca5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00412ca5(char *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    char *arg_ch_00;\n    char *arg_8h_00;\n    char *pcVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    char cVar4;\n    \n    arg_8h_00 = arg_8h;\n    pcVar3 = *(arg_10h + 0xc);\n    arg_ch_00 = arg_8h + 1;\n    *arg_8h = '0';\n    pcVar1 = arg_ch_00;\n    if (0 < arg_ch) {\n        arg_8h = arg_ch;\n        arg_ch = 0;\n        do {\n            cVar4 = *pcVar3;\n            if (cVar4 == '\\0') {\n                cVar4 = '0';\n            }\n            else {\n                pcVar3 = pcVar3 + 1;\n            }\n            *pcVar1 = cVar4;\n            pcVar1 = pcVar1 + 1;\n            arg_8h = arg_8h + -1;\n        } while (arg_8h != NULL);\n    }\n    *pcVar1 = '\\0';\n    if ((-1 < arg_ch) && ('4' < *pcVar3)) {\n        while (pcVar1 = pcVar1 + -1,  *pcVar1 == '9') {\n            *pcVar1 = '0';\n        }\n        *pcVar1 = *pcVar1 + '\\x01';\n    }\n    if (*arg_8h_00 == '1') {\n        *(arg_10h + 4) = *(arg_10h + 4) + 1;\n    }\n    else {\n        iVar2 = fcn.004089d0(arg_ch_00);\n        fcn.004072a0(arg_8h_00, arg_ch_00, iVar2 + 1);\n    }\n    return;\n}\n",
        "token_count": 438
    },
    "00412dd6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00412dd6(uint arg_8h, uint noname_1, int32_t *arg_10h, int32_t arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint in_stack_ffffffb8;\n    ushort uVar4;\n    uint var_2ch;\n    uchar var_28h [24];\n    uint var_10h;\n    uint uStack16;\n    ushort uStack12;\n    uint var_4h;\n    \n    uVar4 = in_stack_ffffffb8 >> 0x10;\n    var_4h = *0x427850;\n    fcn.00412d1c(&var_10h, &arg_8h);\n    iVar3 = fcn.00413f71(var_10h, uStack16, CONCAT22(uVar4, uStack12), 0x11, 0, &var_2ch);\n    iVar2 = arg_14h;\n    piVar1 = arg_10h;\n    arg_10h[2] = iVar3;\n    *arg_10h = var_2ch._2_1_;\n    arg_10h[1] = var_2ch;\n    fcn.0040fce0(arg_14h, var_28h);\n    piVar1[3] = iVar2;\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 329
    },
    "00413700": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.00413700(uint param_1, uint32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t unaff_ESI;\n    \n    uVar1 = param_2;\n    do {\n        if (*(uVar1 + 4) == unaff_ESI) break;\n        uVar1 = uVar1 + 0xc;\n    } while (uVar1 < param_2 + *0x4281bc * 0xc);\n    if ((param_2 + *0x4281bc * 0xc <= uVar1) || (*(uVar1 + 4) != unaff_ESI)) {\n        uVar1 = 0;\n    }\n    return uVar1;\n}\n",
        "token_count": 164
    },
    "004138f5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.004138f5(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint var_8h;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_WideCharToMultiByte;\n    var_4h = 0;\n    iVar2 = **0x42ab90;\n    piVar3 = *0x42ab90;\n    while( true ) {\n        if (iVar2 == 0) {\n            return 0;\n        }\n        iVar2 = (*pcVar1)(0, 0, iVar2, 0xffffffff, 0, 0, 0, 0);\n        if ((iVar2 == 0) || (var_4h = fcn.00407684(iVar2),  var_4h == 0)) break;\n        iVar2 = (*pcVar1)(0, 0, *piVar3, 0xffffffff, var_4h, iVar2, 0, 0);\n        if (iVar2 == 0) {\n            fcn.00407696(var_4h);\n            return 0xffffffff;\n        }\n        iVar2 = fcn.0041498b(&var_4h, 0);\n        if ((iVar2 < 0) && (var_4h != 0)) {\n            fcn.00407696(var_4h);\n            var_4h = 0;\n        }\n        piVar3 = piVar3 + 1;\n        iVar2 = *piVar3;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 356
    },
    "00414470": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00414470(uint8_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    bool bVar3;\n    \n    if (arg_10h != 0) {\n        do {\n            uVar2 = *arg_8h;\n            uVar1 = *arg_ch;\n            if ((uVar2 == 0) || (uVar1 == 0)) break;\n            arg_8h = arg_8h + 1;\n            arg_ch = arg_ch + 1;\n            if ((0x40 < uVar2) && (uVar2 < 0x5b)) {\n                uVar2 = uVar2 + 0x20;\n            }\n            if ((0x40 < uVar1) && (uVar1 < 0x5b)) {\n                uVar1 = uVar1 + 0x20;\n            }\n            bVar3 = uVar2 < uVar1;\n            if (uVar2 != uVar1) goto code_r0x004144c1;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n        arg_10h = 0;\n        bVar3 = uVar2 < uVar1;\n        if (uVar2 != uVar1) {\ncode_r0x004144c1:\n            arg_10h = -1;\n            if (!bVar3) {\n                arg_10h = 1;\n            }\n        }\n    }\n    return arg_10h;\n}\n",
        "token_count": 363
    },
    "00415ca6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t * __cdecl fcn.00415ca6(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    *(unaff_EBP + -0x10) = 0;\n    if (*(unaff_EBP + 0x10) != 0) {\n        *extraout_ECX = 0x422a00;\n        extraout_ECX[1] = vtable.std::basic_ios_char__struct_std::char_traits_char__.0;\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x10) = 1;\n    }\n    uVar1 = *(unaff_EBP + 0xc);\n    *(extraout_ECX + *(*extraout_ECX + 4)) = vtable.std::basic_ostream_char__struct_std::char_traits_char__.0;\n    fcn.00415c5a(*(unaff_EBP + 8), uVar1);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 350
    },
    "00416bd0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00416bd0(uint arg_8h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint arg_10h;\n    uint var_4h;\n    \n    fcn.00408fec(0x422a40, 0x1c);\n    uVar2 = fcn.0040bca4();\n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(uVar2);\n    iVar3 = fcn.0040bc9e();\n    if (iVar3 == 0) {\n        *(unaff_EBP + -0x1c) = 0;\n    }\n    else {\n        uVar2 = fcn.0040bca4();\n        (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(uVar2);\n        fcn.0040a06b(0xc);\n        *(unaff_EBP + -0x1c) = 1;\n    }\n    *(unaff_EBP + -4) = 0;\n    iVar3 = fcn.004110e2();\n    *(unaff_EBP + -0x2c) = *(iVar3 + 4);\n    uVar2 = fcn.004110c9();\n    *(unaff_EBP + -0x28) = uVar2;\n    iVar3 = fcn.00407684(0x200);\n    *(unaff_EBP + -0x24) = iVar3;\n    if (iVar3 == 0) {\n        uVar2 = fcn.0041039e();\n        *(unaff_EBP + -0x24) = uVar2;\n        *(unaff_EBP + -0x20) = 0;\n    }\n    else {\n        arg_10h = 0x200;\n        uVar2 = fcn.0041039e();\n        fcn.004085f0(*(unaff_EBP + -0x24), uVar2, arg_10h);\n        *(unaff_EBP + -0x20) = 1;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00416c7e();\n    puVar1 = *(unaff_EBP + 8);\n    *puVar1 = *(unaff_EBP + -0x2c);\n    puVar1[1] = *(unaff_EBP + -0x28);\n    puVar1[2] = *(unaff_EBP + -0x24);\n    puVar1[3] = *(unaff_EBP + -0x20);\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 638
    },
    "00416c9b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00416c9b(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *arg_ch_00;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x422a50, 0xc);\n    arg_ch_00 = *(unaff_EBP + 0xc);\n    if (arg_ch_00 == NULL) {\n        iVar1 = fcn.004110e2();\n        iVar1 = *(iVar1 + 8);\n    }\n    else {\n        iVar1 = *arg_ch_00;\n    }\n    if (iVar1 != 0) {\n        uVar2 = fcn.0040bca4();\n        (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(uVar2);\n        iVar1 = fcn.0040bc9e();\n        if (iVar1 == 0) {\n            *(unaff_EBP + -0x1c) = 0;\n        }\n        else {\n            uVar2 = fcn.0040bca4();\n            (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(uVar2);\n            fcn.0040a06b(0xc);\n            *(unaff_EBP + -0x1c) = 1;\n        }\n        *(unaff_EBP + -4) = 0;\n        uVar2 = fcn.00416ae7(*(unaff_EBP + 8), arg_ch_00);\n        *(unaff_EBP + 8) = uVar2;\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00416d2a();\n    }\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 415
    },
    "00417342": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00417342(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint unaff_retaddr;\n    uint var_1ch;\n    uint var_4h;\n    uint noname_1;\n    \n    noname_1 = 0xc;\n    fcn.00408fec();\n    fcn.0040cbf9(*(unaff_EBP + 0x14));\n    *(unaff_EBP + -4) = 0;\n    uVar1 = fcn.0041723b(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n    *(unaff_EBP + -0x1c) = uVar1;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00417384(0x422ae8, noname_1, unaff_retaddr, arg_8h);\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 272
    },
    "00417497": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00417497(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00408fec(0x422b08, 0xc);\n    fcn.0040cbf9(*(unaff_EBP + 8));\n    *(unaff_EBP + -4) = 0;\n    uVar1 = fcn.00417408(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n    *(unaff_EBP + -0x1c) = uVar1;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004174d6(0x422b08);\n    fcn.00409027();\n    return;\n}\n",
        "token_count": 224
    },
    "004179fa": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004179fa(void)\n\n{\n    int32_t in_EAX;\n    \n    if (in_EAX != 0) {\n        do {\n            fcn.00403390();\n            in_EAX = in_EAX + -1;\n        } while (in_EAX != 0);\n    }\n    return;\n}\n",
        "token_count": 71
    },
    "00417a34": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417a34(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t in_ECX;\n    int32_t iVar5;\n    \n    iVar2 = arg_8h;\n    iVar5 = 0;\n    if (arg_8h < 0) {\ncode_r0x00417b0c:\n        iVar5 = fcn.004179a8();\n    }\n    else {\n        if (-1 < arg_ch) {\n            *(in_ECX + 0x10) = arg_ch;\n        }\n        if (arg_8h == 0) {\n            fcn.004179fa(*(in_ECX + 4));\n            fcn.00418300(*(in_ECX + 4));\n            *(in_ECX + 0xc) = 0;\n            *(in_ECX + 8) = 0;\n            goto code_r0x00417b50;\n        }\n        iVar5 = *(in_ECX + 4);\n        if (iVar5 == 0) {\n            uVar4 = fcn.004182d5(arg_8h << 2);\n            *(in_ECX + 4) = uVar4;\n            fcn.004179d9(uVar4);\n            *(in_ECX + 0xc) = arg_8h;\ncode_r0x00417a99:\n            *(in_ECX + 8) = arg_8h;\n            return;\n        }\n        iVar1 = *(in_ECX + 0xc);\n        if (arg_8h <= iVar1) {\n            iVar2 = *(in_ECX + 8);\n            if (iVar2 < arg_8h) {\n                fcn.004179d9(iVar5 + iVar2 * 4);\n            }\n            else if (arg_8h < iVar2) {\n                fcn.004179fa(iVar5 + arg_8h * 4);\n            }\n            goto code_r0x00417a99;\n        }\n        iVar5 = *(in_ECX + 0x10);\n        if (iVar5 == 0) {\n            iVar5 = *(in_ECX + 8) / 8;\n            if (iVar5 < 4) {\ncode_r0x00417af6:\n                iVar5 = 4;\n            }\n            else if (iVar5 < 0x401) {\n                if (iVar5 < 4) goto code_r0x00417af6;\n            }\n            else {\n                iVar5 = 0x400;\n            }\n        }\n        iVar3 = iVar5 + iVar1;\n        if (iVar5 + iVar1 <= arg_8h) {\n            iVar3 = arg_8h;\n        }\n        arg_8h = iVar3;\n        iVar5 = arg_8h;\n        if (arg_8h < iVar1) goto code_r0x00417b0c;\n    }\n    iVar5 = fcn.004182d5(iVar5 << 2);\n    fcn.004085f0(iVar5, *(in_ECX + 4), *(in_ECX + 8) << 2);\n    fcn.004179d9(iVar5 + *(in_ECX + 8) * 4);\n    fcn.00418300(*(in_ECX + 4));\n    *(in_ECX + 8) = iVar2;\n    *(in_ECX + 0xc) = arg_8h;\ncode_r0x00417b50:\n    *(in_ECX + 4) = iVar5;\n    return;\n}\n",
        "token_count": 801
    },
    "00417cb1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417cb1(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    int32_t iVar5;\n    \n    iVar1 = arg_8h;\n    iVar5 = 0;\n    if (arg_8h < 0) {\ncode_r0x00417d6b:\n        fcn.004179a8();\n    }\n    else {\n        if (-1 < arg_ch) {\n            *(in_ECX + 0x10) = arg_ch;\n        }\n        if (arg_8h == 0) {\n            fcn.00418300(*(in_ECX + 4));\n            *(in_ECX + 0xc) = 0;\n            *(in_ECX + 8) = 0;\n            goto code_r0x00417dac;\n        }\n        if (*(in_ECX + 4) == 0) {\n            uVar3 = fcn.004182d5(arg_8h);\n            *(in_ECX + 4) = uVar3;\n            fcn.00409040(uVar3, 0, arg_8h);\n            *(in_ECX + 0xc) = arg_8h;\ncode_r0x00417d06:\n            *(in_ECX + 8) = arg_8h;\n            return;\n        }\n        iVar5 = *(in_ECX + 0xc);\n        if (arg_8h <= iVar5) {\n            iVar1 = *(in_ECX + 8);\n            if (iVar1 < arg_8h) {\n                fcn.00409040(iVar1 + *(in_ECX + 4), 0, arg_8h - iVar1);\n            }\n            goto code_r0x00417d06;\n        }\n        iVar4 = *(in_ECX + 0x10);\n        if (iVar4 == 0) {\n            iVar4 = *(in_ECX + 8) / 8;\n            if (iVar4 < 4) {\ncode_r0x00417d57:\n                iVar4 = 4;\n            }\n            else if (iVar4 < 0x401) {\n                if (iVar4 < 4) goto code_r0x00417d57;\n            }\n            else {\n                iVar4 = 0x400;\n            }\n        }\n        iVar2 = iVar4 + iVar5;\n        if (iVar4 + iVar5 <= arg_8h) {\n            iVar2 = arg_8h;\n        }\n        arg_8h = iVar2;\n        if (arg_8h < iVar5) goto code_r0x00417d6b;\n    }\n    iVar5 = fcn.004182d5(arg_8h);\n    fcn.004085f0(iVar5, *(in_ECX + 4), *(in_ECX + 8));\n    fcn.00409040(*(in_ECX + 8) + iVar5, 0, iVar1 - *(in_ECX + 8));\n    fcn.00418300(*(in_ECX + 4));\n    *(in_ECX + 8) = iVar1;\n    *(in_ECX + 0xc) = arg_8h;\ncode_r0x00417dac:\n    *(in_ECX + 4) = iVar5;\n    return;\n}\n",
        "token_count": 750
    },
    "004180fd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.004180fd(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = arg_8h;\n    puVar2 = fcn.00417f4d(arg_8h, &arg_8h, &var_4h);\n    if (puVar2 == NULL) {\n        if (*(in_ECX + 4) == 0) {\n            fcn.00417ebd(*(in_ECX + 8), 1);\n        }\n        puVar2 = fcn.004180b2();\n        puVar2[1] = iVar1;\n        *puVar2 = *(arg_8h * 4 + *(in_ECX + 4));\n        *(arg_8h * 4 + *(in_ECX + 4)) = puVar2;\n    }\n    return puVar2 + 2;\n}\n",
        "token_count": 217
    },
    "004183c9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004183c9(uint param_1, uchar *param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    ushort *puVar2;\n    \n    if (param_2 != NULL) {\n        iVar1 = fcn.0041d221();\n        puVar2 = fcn.0040582b(*(iVar1 + 0xc), param_1);\n        if (puVar2 != NULL) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, puVar2 + 1, *puVar2, param_2, param_3 + -1, 0, 0)\n            ;\n            param_2[iVar1] = 0;\n            return iVar1;\n        }\n        *param_2 = 0;\n    }\n    return 0;\n}\n",
        "token_count": 191
    },
    "00418572": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00418572(int32_t param_1)\n\n{\n    if (*(param_1 + 0x10) != 0) {\n    // WARNING: Could not recover jumptable at 0x0041857b. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(*(param_1 + 0x10) + 0x1c))();\n        return;\n    }\n    return;\n}\n",
        "token_count": 98
    },
    "0041857f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl\nfcn.0041857f(uint arg_8h, uint *arg_ch, uint noname_2, code *arg_14h, uint *arg_18h, int32_t arg_1ch, uint *arg_20h)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 1;\n    if (arg_20h != NULL) {\n        *arg_20h = arg_8h;\n        arg_20h[1] = arg_14h;\n        return 1;\n    }\n    if (0xb < arg_1ch - 0x35U) {\n        return 0;\n    }\n    // switch table (12 cases) at 0x418665\n    switch(*((arg_1ch - 0x35U) * 4 + 0x418665)) {\n    case 0x4185b6:\n        (*arg_14h)();\n        break;\n    case 0x4185c1:\n        uVar1 = (*arg_14h)();\n        break;\n    case 0x4185cc:\n        arg_18h = arg_ch;\n        goto code_r0x00418646;\n    case 0x4185d1:\n        arg_18h = arg_ch;\n        goto code_r0x00418651;\n    case 0x4185d6:\n        (*arg_14h)(arg_18h[1], *arg_18h);\n        break;\n    case 0x4185e6:\n        uVar1 = (*arg_14h)(arg_18h[1], *arg_18h);\n        break;\n    case 0x4185f6:\n        (*arg_14h)(arg_ch, arg_18h[1], *arg_18h);\n        break;\n    case 0x418609:\n        uVar1 = (*arg_14h)(arg_ch, arg_18h[1], *arg_18h);\n        break;\n    case 0x41861c:\n        (*arg_14h)(arg_18h);\n        goto code_r0x00418635;\n    case 0x418628:\n        (*arg_14h)(arg_18h, arg_ch);\ncode_r0x00418635:\n        uVar1 = arg_18h[7] == 0;\n        arg_18h[7] = 0;\n        break;\n    case 0x418643:\ncode_r0x00418646:\n        (*arg_14h)(arg_18h);\n        break;\n    case 0x41864e:\ncode_r0x00418651:\n        uVar1 = (*arg_14h)(arg_18h);\n    }\n    return uVar1;\n}\n",
        "token_count": 598
    },
    "00419dc8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00419dc8(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint32_t unaff_retaddr;\n    \n    iVar1 = fcn.00419d25(0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if (*(iVar1 + 0x20) != 0) {\n        for (puVar2 = *(*(iVar1 + 0x20) + ((unaff_retaddr >> 4) % *(iVar1 + 0x24)) * 4); puVar2 != NULL;\n            puVar2 = *puVar2) {\n            if (puVar2[1] == unaff_retaddr) {\n                return puVar2[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 177
    },
    "0041ba71": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0041ba71(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint32_t unaff_retaddr;\n    \n    iVar1 = fcn.0041b9e7(0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if (*(iVar1 + 0x20) != 0) {\n        for (puVar2 = *(*(iVar1 + 0x20) + ((unaff_retaddr >> 4) % *(iVar1 + 0x24)) * 4); puVar2 != NULL;\n            puVar2 = *puVar2) {\n            if (puVar2[1] == unaff_retaddr) {\n                return puVar2[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 179
    },
    "0041cc19": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041cc19(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0041d221();\n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(iVar1 + 0x2c);\n    return;\n}\n",
        "token_count": 58
    },
    "0041d247": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041d247(void)\n\n{\n    fcn.0041d221();\n    fcn.0041d669(0x41d1e1);\n    return;\n}\n",
        "token_count": 42
    },
    "00405cfd": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405cfd(uint16_t *arg_8h, uint arg_ch)\n\n{\n    uint *in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*arg_8h < 0x76c) {\n        *in_ECX = 0;\n        in_ECX[1] = 0;\n    }\n    else {\n        fcn.00405c9d(*arg_8h, arg_8h[1], arg_8h[3], arg_8h[4], arg_8h[5], arg_8h[6], arg_ch);\n        *in_ECX = in_ECX;\n        in_ECX[1] = in_ECX;\n    }\n    return;\n}\n",
        "token_count": 168
    },
    "00405ea7": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.00405ea7(code **param_1)\n\n{\n    *param_1 = vtable.CFileFind.0;\n    fcn.004034f0();\n    param_1[1] = NULL;\n    param_1[2] = NULL;\n    param_1[3] = NULL;\n    *(param_1 + 5) = 0x5c;\n    return param_1;\n}\n",
        "token_count": 95
    },
    "00417915": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00417915(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *(param_1 + 0xc) = 1;\n    iVar1 = fcn.004183c9(*(param_1 + 0x94), param_1 + 0x14, 0x80);\n    *(param_1 + 0x10) = iVar1 != 0;\n    return;\n}\n",
        "token_count": 97
    },
    "00417c4b": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00417c4b(int32_t param_1)\n\n{\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 8) = 0;\n    *(param_1 + 4) = 0;\n    fcn.00417ea7();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 103
    },
    "00417f09": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00417f09(int32_t param_1)\n\n{\n    if (*(param_1 + 4) != 0) {\n        fcn.00418300(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    fcn.00417ea7();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 121
    },
    "0041de92": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.0041de92(code **param_1)\n\n{\n    param_1[5] = NULL;\n    param_1[2] = NULL;\n    param_1[3] = NULL;\n    *param_1 = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.2.0;\n    param_1[1] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.1.0;\n    param_1[4] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.0;\n    fcn.0041cc19();\n    return param_1;\n}\n",
        "token_count": 145
    },
    "00404190": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00404190(char *param_1)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    if (param_1 == NULL) {\n        fcn.004039f0(0, 0);\n        return;\n    }\n    pcVar2 = param_1;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.004039f0(param_1, pcVar2 - (param_1 + 1));\n    return;\n}\n",
        "token_count": 131
    },
    "00404430": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00404430(char *param_1)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    pcVar2 = param_1;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.004041d0(param_1, pcVar2 - (param_1 + 1));\n    return;\n}\n",
        "token_count": 102
    },
    "00404460": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00404460(uint param_1, char *param_2)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    if (param_2 == NULL) {\n        fcn.004039f0(0, 0);\n        return param_1;\n    }\n    pcVar2 = param_2;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.004039f0(param_2, pcVar2 - (param_2 + 1));\n    return param_1;\n}\n",
        "token_count": 145
    },
    "004044a0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.004044a0(uint param_1, char *param_2)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    if (param_2 == NULL) {\n        fcn.00403b60(0, 0);\n        return param_1;\n    }\n    pcVar2 = param_2;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.00403b60(param_2, pcVar2 - (param_2 + 1));\n    return param_1;\n}\n",
        "token_count": 146
    },
    "0040816a": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.0040816a(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    iVar1 = fcn.0040af1e();\n    piVar2 = *(iVar1 + 0x88);\n    while( true ) {\n        if (piVar2 == NULL) {\n            return 1;\n        }\n        if (*piVar2 == param_1) break;\n        piVar2 = piVar2[1];\n    }\n    return 0;\n}\n",
        "token_count": 116
    },
    "00409c97": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00409c97(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.0040af1e();\n    *(iVar1 + 0xc) = param_1;\n    uVar2 = 0;\n    do {\n        if (param_1 == *(uVar2 * 8 + 0x427988)) {\n            iVar1 = fcn.0040af1e();\n            *(iVar1 + 8) = *(uVar2 * 8 + 0x42798c);\n            return;\n        }\n        uVar2 = uVar2 + 1;\n    } while (uVar2 < 0x2d);\n    if ((0x12 < param_1) && (param_1 < 0x25)) {\n        iVar1 = fcn.0040af1e();\n        *(iVar1 + 8) = 0xd;\n        return;\n    }\n    if ((0xbb < param_1) && (param_1 < 0xcb)) {\n        iVar1 = fcn.0040af1e();\n        *(iVar1 + 8) = 8;\n        return;\n    }\n    iVar1 = fcn.0040af1e();\n    *(iVar1 + 8) = 0x16;\n    return;\n}\n",
        "token_count": 297
    },
    "0041144a": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0041144a(uint param_1, char *param_2)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    while( true ) {\n        cVar1 = *param_2;\n        param_2 = param_2 + 1;\n        if (((cVar1 < 'A') || ('Z' < cVar1)) && ((cVar1 < 'a' || ('z' < cVar1)))) break;\n        iVar2 = iVar2 + 1;\n    }\n    return iVar2;\n}\n",
        "token_count": 131
    },
    "00414ecb": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00414ecb(int32_t param_1)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    uint var_4h;\n    \n    fcn.004166ca(2);\n    *(param_1 + 4) = 1;\n    do {\n        iVar2 = *(*(param_1 + 4) * 4 + 0x42b044);\n        if ((iVar2 == 0) || (iVar2 == param_1)) break;\n        *(param_1 + 4) = *(param_1 + 4) + 1;\n    } while (*(param_1 + 4) < 8);\n    *(*(param_1 + 4) * 4 + 0x42b044) = param_1;\n    pcVar1 = *(param_1 + 4) + 0x42b06c;\n    *pcVar1 = *pcVar1 + '\\x01';\n    fcn.004166ed();\n    return;\n}\n",
        "token_count": 223
    },
    "00414f1c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00414f1c(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint *puVar2;\n    \n    fcn.00414ea9(0);\n    puVar2 = *(param_1 + 0x1c);\n    while (puVar2 != NULL) {\n        puVar1 = *puVar2;\n        fcn.00418300(puVar2);\n        puVar2 = puVar1;\n    }\n    *(param_1 + 0x1c) = 0;\n    puVar2 = *(param_1 + 0x20);\n    while (puVar2 != NULL) {\n        puVar1 = *puVar2;\n        fcn.00418300(puVar2);\n        puVar2 = puVar1;\n    }\n    *(param_1 + 0x20) = 0;\n    return;\n}\n",
        "token_count": 198
    },
    "0041682b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid fcn.0041682b(void)\n\n{\n    uint uVar1;\n    uint *puVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    code *pcVar3;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00408a5c();\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    *extraout_ECX = vtable.std::locale::_Locimp.0;\n    *(unaff_EBP + -4) = 1;\n    fcn.004166ca(0);\n    pcVar3 = extraout_ECX[3];\n    *(unaff_EBP + -4) = 2;\n    while (pcVar3 != NULL) {\n        pcVar3 = pcVar3 + -1;\n        if (*(extraout_ECX[2] + pcVar3 * 4) != 0) {\n            puVar2 = fcn.00414e40();\n            if (puVar2 != NULL) {\n                (***puVar2)(1);\n            }\n        }\n    }\n    fcn.00407696(extraout_ECX[2]);\n    *(unaff_EBP + -4) = 1;\n    fcn.004166ed();\n    fcn.004035c0(1, 0);\n    uVar1 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.std::locale::facet.0;\n    *in_FS_OFFSET = uVar1;\n    return;\n}\n",
        "token_count": 404
    },
    "00417ea7": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00417ea7(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    \n    if (param_1 != NULL) {\n        do {\n            piVar1 = *param_1;\n            fcn.00418300(param_1);\n            param_1 = piVar1;\n        } while (piVar1 != NULL);\n    }\n    return;\n}\n",
        "token_count": 89
    },
    "00417f4d": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00417f4d(int32_t param_1, uint32_t param_2, uint32_t *param_3, uint32_t *param_4)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    \n    *param_4 = param_2 >> 4;\n    uVar2 = (param_2 >> 4) % *(param_1 + 8);\n    *param_3 = uVar2;\n    if (*(param_1 + 4) != 0) {\n        for (puVar1 = *(*(param_1 + 4) + uVar2 * 4); puVar1 != NULL; puVar1 = *puVar1) {\n            if (puVar1[1] == param_2) {\n                return puVar1;\n            }\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 193
    },
    "00417f85": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00417f85(int32_t param_1, uint32_t param_2)\n\n{\n    uint *puVar1;\n    \n    if (*(param_1 + 4) != 0) {\n        for (puVar1 = *(*(param_1 + 4) + ((param_2 >> 4) % *(param_1 + 8)) * 4); puVar1 != NULL; puVar1 = *puVar1) {\n            if (puVar1[1] == param_2) {\n                return puVar1[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 139
    },
    "00417fbc": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00417fbc(int32_t param_1, uint32_t param_2)\n\n{\n    uint *puVar1;\n    uint *puVar2;\n    uint *puVar3;\n    \n    if (*(param_1 + 4) == 0) {\n        puVar2 = NULL;\n    }\n    else {\n        puVar3 = *(param_1 + 4) + ((param_2 >> 4) % *(param_1 + 8)) * 4;\n        puVar1 = *puVar3;\n        while (puVar2 = puVar1,  puVar2 != NULL) {\n            if (puVar2[1] == param_2) {\n                *puVar3 = *puVar2;\n                fcn.00417f34(puVar2);\n                return 0x1;\n            }\n            puVar3 = puVar2;\n            puVar1 = *puVar2;\n        }\n    }\n    return puVar2;\n}\n",
        "token_count": 219
    },
    "004182d5": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.004182d5(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.00407684(param_1);\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n        if (*0x4272ec == NULL) break;\n        iVar1 = (**0x4272ec)(param_1);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 115
    },
    "00419707": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.00419707(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint unaff_retaddr;\n    \n    iVar1 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(param_1 + 4));\n    iVar3 = 0;\n    if (0 < iVar1) {\n        do {\n            iVar2 = fcn.00406ed5(iVar3);\n            if (iVar2 == 0) {\n                iVar2 = (*_sym.imp.USER32.dll_GetMenuItemID)(*(param_1 + 4), iVar3);\n                if (iVar2 == param_1) {\n                    iVar1 = fcn.0041ba71(*(param_1 + 4));\n                    return iVar1;\n                }\n            }\n            else {\n                iVar2 = fcn.00419707(iVar2, unaff_retaddr);\n                if (iVar2 != 0) {\n                    return iVar2;\n                }\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < iVar1);\n    }\n    return 0;\n}\n",
        "token_count": 248
    },
    "0041a091": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041a091(uint hDlg, uint nIDDlgItem, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.USER32.dll_GetDlgItem)(hDlg, nIDDlgItem);\n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    if (iVar2 != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_GetTopWindow)(iVar2);\n        if ((iVar3 != 0) && (iVar3 = fcn.0041a091(iVar2, nIDDlgItem, arg_10h),  iVar3 != 0)) {\n            return;\n        }\n        if (arg_10h == 0) {\n            fcn.00419da1();\n            return;\n        }\n        iVar2 = fcn.00419dc8(iVar2);\n        if (iVar2 != 0) {\n            return;\n        }\n    }\n    iVar2 = (*pcVar1)(hDlg);\n    while( true ) {\n        if (iVar2 == 0) {\n            return;\n        }\n        iVar3 = fcn.0041a091(iVar2, nIDDlgItem, arg_10h);\n        if (iVar3 != 0) break;\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2);\n    }\n    return;\n}\n",
        "token_count": 318
    },
    "0041a21d": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0041a21d(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint var_1ch;\n    \n    pcVar1 = _sym.imp.USER32.dll_PeekMessageA;\n    while( true ) {\n        iVar2 = (*pcVar1)(&var_1ch, 0, 0x121, 0x121, 1);\n        if (iVar2 == 0) break;\n        (*_sym.imp.USER32.dll_DispatchMessageA)(&var_1ch);\n    }\n    fcn.00419cfe();\n    return;\n}\n",
        "token_count": 134
    },
    "0041a938": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0041a938(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    if ((param_1 != 0) && (iVar1 = *(param_1 + 0x1c),  *(param_1 + 0x1c) != 0)) {\n        do {\n            iVar3 = iVar1;\n            iVar1 = fcn.0041a8f3(iVar3);\n        } while (iVar1 != 0);\n        uVar2 = fcn.00419da1(iVar3);\n        return uVar2;\n    }\n    return 0;\n}\n",
        "token_count": 150
    },
    "0041c233": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041c233(int32_t hWnd, uint lpPoint, uint arg_10h)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint lpRect;\n    \n    (*_sym.imp.USER32.dll_ClientToScreen)(hWnd, &lpPoint);\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    uVar5 = 5;\n    do {\n        hWnd = (*pcVar1)(hWnd, uVar5);\n        if (hWnd == 0) {\n            return 0;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(hWnd);\n        if ((iVar2 != 0) &&\n           (uVar3 = (*_sym.imp.USER32.dll_GetWindowLongA)(hWnd, 0xfffffff0),  (uVar3 & 0x10000000) != 0)) {\n            (*_sym.imp.USER32.dll_GetWindowRect)(hWnd, &lpRect);\n            iVar4 = (*_sym.imp.USER32.dll_PtInRect)(&lpRect, lpPoint, arg_10h);\n            if (iVar4 != 0) {\n                return hWnd;\n            }\n        }\n        uVar5 = 2;\n    } while( true );\n}\n",
        "token_count": 300
    },
    "0041c837": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.0041c837(int32_t param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    \n    pcVar2 = _sym.imp.USER32.dll_GetParent;\n    iVar3 = param_1;\n    if (param_1 != 0) goto code_r0x0041c866;\n    iVar3 = fcn.0041c7fe();\n    if ((iVar3 == 0) && (iVar3 = fcn.004062d7(),  iVar3 == 0)) {\n        iVar3 = 0;\n        iVar5 = iVar3;\n        iVar6 = iVar3;\n    }\n    else {\n        for (iVar3 = *(iVar3 + 0x1c); iVar5 = iVar3,  iVar6 = iVar3,  iVar3 != 0; iVar3 = (*pcVar2)(iVar3)) {\ncode_r0x0041c866:\n            uVar4 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar3, 0xfffffff0);\n            iVar5 = iVar3;\n            iVar6 = iVar3;\n            if ((uVar4 & 0x40000000) == 0) break;\n        }\n    }\n    while (iVar1 = iVar5,  iVar1 != 0) {\n        iVar5 = (*pcVar2)(iVar1);\n        iVar3 = iVar1;\n    }\n    if ((param_1 == 0) && (iVar6 != 0)) {\n        iVar6 = (*_sym.imp.USER32.dll_GetLastActivePopup)(iVar6);\n    }\n    if (param_2 != NULL) {\n        if (((iVar3 == 0) || (iVar5 = (*_sym.imp.USER32.dll_IsWindowEnabled)(iVar3),  iVar5 == 0)) || (iVar3 == iVar6))\n        {\n            *param_2 = 0;\n        }\n        else {\n            *param_2 = iVar3;\n            (*_sym.imp.USER32.dll_EnableWindow)(iVar3, 0);\n        }\n    }\n    return iVar6;\n}\n",
        "token_count": 486
    },
    "0041d4e3": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041d4e3(int32_t arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    uint lpCriticalSection;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 0x1c);\n    if ((0 < arg_8h) && (arg_8h < *(in_ECX + 0xc))) {\n        for (iVar3 = *(in_ECX + 0x14); iVar3 != 0; iVar3 = *(iVar3 + 4)) {\n            if (arg_8h < *(iVar3 + 8)) {\n                puVar2 = *(*(iVar3 + 0xc) + arg_8h * 4);\n                if (puVar2 != NULL) {\n                    (***puVar2)(1);\n                }\n                *(*(iVar3 + 0xc) + arg_8h * 4) = 0;\n            }\n        }\n        puVar1 = *(in_ECX + 0x10) + arg_8h * 8;\n        *puVar1 = *puVar1 & 0xfffffffe;\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 0x1c);\n    }\n    return;\n}\n",
        "token_count": 297
    },
    "00406648": {
        "rules": [
            "link function at runtime on Windows",
            "link many functions at runtime"
        ],
        "decompiled_code": "\nbool fcn.00406648(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    if (*0x42a894 != 0) {\n        return *0x42a888 != 0;\n    }\n    *0x42a898 = fcn.004065fb();\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"USER32\");\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (((((iVar2 != 0) && (*0x42a878 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x41ffc4),  *0x42a878 != 0)) &&\n         (*0x42a87c = (*pcVar1)(iVar2, \"MonitorFromWindow\"),  *0x42a87c != 0)) &&\n        ((*0x42a880 = (*pcVar1)(iVar2, \"MonitorFromRect\"),  *0x42a880 != 0 &&\n         (*0x42a884 = (*pcVar1)(iVar2, \"MonitorFromPoint\"),  *0x42a884 != 0)))) &&\n       ((*0x42a88c = (*pcVar1)(iVar2, \"EnumDisplayMonitors\"),  *0x42a88c != 0 &&\n        ((*0x42a888 = (*pcVar1)(iVar2, \"GetMonitorInfoA\"),  *0x42a888 != 0 &&\n         (*0x42a890 = (*pcVar1)(iVar2, \"EnumDisplayDevicesA\"),  *0x42a890 != 0)))))) {\n        *0x42a894 = 1;\n        return true;\n    }\n    *0x42a878 = 0;\n    *0x42a87c = 0;\n    *0x42a880 = 0;\n    *0x42a884 = 0;\n    *0x42a888 = 0;\n    *0x42a88c = 0;\n    *0x42a890 = 0;\n    *0x42a894 = 1;\n    return false;\n}\n",
        "token_count": 469
    },
    "00409a93": {
        "rules": [
            "link function at runtime on Windows",
            "terminate process"
        ],
        "decompiled_code": "\nvoid fcn.00409a93(void)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    uint unaff_retaddr;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"mscoree.dll\");\n    if (iVar1 != 0) {\n        pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"CorExitProcess\");\n        if (pcVar2 != NULL) {\n            (*pcVar2)(unaff_retaddr);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_ExitProcess)(unaff_retaddr);\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 153
    },
    "00419524": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint32_t fcn.00419524(void)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint32_t unaff_ESI;\n    uint32_t uVar5;\n    uint unaff_EDI;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"COMCTL32.DLL\");\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"COMCTL32.DLL\");\n    uVar5 = uVar2;\n    if (uVar2 != 0) {\n        pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2, 0x4203a8);\n        uVar5 = 0;\n        if (pcVar3 == NULL) {\n            if ((unaff_ESI & 0x3fc0) == unaff_ESI) {\n                (*_sym.imp.COMCTL32.dll_InitCommonControls)();\n                uVar5 = 0x3fc0;\n            }\n        }\n        else {\n            iVar4 = (*pcVar3)(unaff_EDI);\n            if ((iVar4 != 0) && (uVar5 = unaff_ESI,  iVar1 == 0)) {\n                (*_sym.imp.COMCTL32.dll_InitCommonControls)();\n                uVar5 = unaff_ESI | 0x3fc0;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_FreeLibrary)(uVar2);\n    }\n    return uVar5;\n}\n",
        "token_count": 334
    },
    "00412fb3": {
        "rules": [
            "get geographical location"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00412fb3(uint Locale)\n\n{\n    int32_t iVar1;\n    uint lpLCData;\n    uchar var_6h;\n    uint var_4h;\n    \n    var_4h = *0x427850;\n    var_6h = 0;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)(Locale, 0x1004, &lpLCData, 6);\n    if (iVar1 != 0) {\n        fcn.004094ba(&lpLCData);\n    }\n    fcn.0040895e();\n    return;\n}\n",
        "token_count": 134
    },
    "0041cf8f": {
        "rules": [
            "set application hook"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041cf8f(code **param_1)\n\n{\n    code *pcVar1;\n    \n    pcVar1 = _sym.imp.USER32.dll_UnhookWindowsHookEx;\n    *param_1 = vtable._AFX_THREAD_STATE.0;\n    if (param_1[0xb] != NULL) {\n        (*pcVar1)(param_1[0xb]);\n    }\n    if (param_1[10] != NULL) {\n        (*pcVar1)(param_1[10]);\n    }\n    if (param_1[3] != NULL) {\n        fcn.00407696(param_1[3]);\n    }\n    return;\n}\n",
        "token_count": 147
    },
    "0041d3be": {
        "rules": [
            "get thread local storage value"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0041d3be(uint *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_retaddr;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(param_1 + 7);\n    if ((0 < unaff_retaddr) && (unaff_retaddr < param_1[3])) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*param_1);\n        if ((iVar1 != 0) && (unaff_retaddr < *(iVar1 + 8))) {\n            uVar2 = *(*(iVar1 + 0xc) + unaff_retaddr * 4);\n            goto code_r0x0041d3f5;\n        }\n    }\n    uVar2 = 0;\ncode_r0x0041d3f5:\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(param_1 + 7);\n    return uVar2;\n}\n",
        "token_count": 215
    }
}