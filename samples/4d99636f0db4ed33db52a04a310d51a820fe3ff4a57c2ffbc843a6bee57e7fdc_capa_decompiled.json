{
    "null": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid main(ulong argc)\n\n{\n    char cVar1;\n    char cVar2;\n    int32_t iVar3;\n    ulong *puVar4;\n    uint32_t *puVar5;\n    int64_t iVar6;\n    ulong uVar7;\n    int64_t arg1;\n    uchar *arg2;\n    char *pcVar8;\n    uchar *arg2_00;\n    char *arg2_01;\n    ulong unaff_RBX;\n    ulong unaff_RSI;\n    ulong in_R8;\n    int64_t iVar9;\n    ulong in_R9;\n    ulong uStack32;\n    \n    // [00] -r-x section size 135168 named .text\n    puVar4 = fcn.14000a1a8();\n    puVar5 = fcn.14000a1a0();\n    puVar4 = fcn.140004f50(*puVar5, *puVar4);\n    uStack32 = 0x14000254f;\n    iVar6 = fcn.140008450();\n    iVar6 = -iVar6;\n    *(&stack0x00003008 + iVar6) = *0x140032010 ^ &stack0xffffffffffffffe8 + iVar6;\n    *(&stack0xffffffffffffffe0 + iVar6) = 0x140002573;\n    uVar7 = fcn.14000b22c(2);\n    *(&stack0xffffffffffffffe0 + iVar6) = 0x14000257d;\n    fcn.14000ed84(uVar7, 0);\n    *(&stack0xffffffffffffffe0 + iVar6) = 0x140002584;\n    arg1 = fcn.1400018d0(0);\n    if (arg1 == 0) goto code_r0x0001400027ba;\n    uVar7 = *puVar4;\n    *(&stack0xffffffffffffffe0 + iVar6) = 0x1400025a1;\n    iVar3 = fcn.1400028a0(&stack0x00000008 + iVar6, uVar7);\n    if (iVar3 == 0) goto code_r0x0001400027ba;\n    *(&stack0xffffffffffffffe0 + iVar6) = 0x1400025b7;\n    iVar3 = fcn.1400027e0(&stack0x00002008 + iVar6, &stack0x00000008 + iVar6);\n    if (iVar3 == 0) goto code_r0x0001400027ba;\n    arg2_00 = &stack0x00000008 + iVar6;\n    *(&stack0xffffffffffffffe0 + iVar6) = 0x1400025cd;\n    iVar3 = fcn.140002ac0(&stack0x00001008 + iVar6, arg2_00);\n    if (iVar3 == 0) goto code_r0x0001400027ba;\n    *(&stack0x00003050 + iVar6) = unaff_RSI;\n    *(&stack0xffffffffffffffe0 + iVar6) = 0x1400025e5;\n    arg2 = fcn.140004290(\"_MEIPASS2\");\n    *(&stack0xffffffffffffffe0 + iVar6) = 0x1400025f4;\n    fcn.140004910(\"_MEIPASS2\", arg2_00, in_R8, in_R9);\n    *(&stack0xffffffffffffffe0 + iVar6) = 0x140002601;\n    iVar3 = fcn.1400017c0(arg1, &stack0x00000008 + iVar6);\n    if (iVar3 == 0) {\n        *(&stack0xffffffffffffffe0 + iVar6) = 0x140002615;\n        iVar3 = fcn.1400017c0(arg1, &stack0x00002008 + iVar6);\n        if (iVar3 == 0) {\n            *(&stack0xffffffffffffffe0 + iVar6) = 0x140002632;\n            fcn.1400019e0(\"Cannot open self %s or archive %s\\n\", &stack0x00000008 + iVar6, &stack0x00002008 + iVar6, \n                          in_R9);\n            goto code_r0x0001400027ba;\n        }\n    }\n    *(&stack0x00003048 + iVar6) = unaff_RBX;\n    *(arg1 + 0x4080) = argc;\n    *(arg1 + 0x4088) = puVar4;\n    if (arg2 == NULL) {\n        *(&stack0xffffffffffffffe0 + iVar6) = 0x14000265c;\n        iVar3 = fcn.140002310(arg1);\n        if (iVar3 == 0) {\n            arg2 = &stack0x00001008 + iVar6;\n            goto code_r0x00014000266c;\n        }\n    }\n    else {\ncode_r0x00014000266c:\n        in_R8 = 0;\n        *(&stack0xffffffffffffffe0 + iVar6) = 0x140002679;\n        uVar7 = fcn.1400052b0(0, arg2, 0, in_R9);\n        *(&stack0xffffffffffffffe0 + iVar6) = 0x140002685;\n        (*_sym.imp.KERNEL32.dll_SetDllDirectoryW)(uVar7);\n        *(&stack0xffffffffffffffe0 + iVar6) = 0x14000268d;\n        fcn.14000a248(uVar7);\n        if (arg2 != NULL) {\n            pcVar8 = &stack0x00001008 + iVar6;\n            iVar9 = arg2 - pcVar8;\n            do {\n                cVar1 = *pcVar8;\n                cVar2 = pcVar8[iVar9];\n                if (cVar1 != cVar2) break;\n                pcVar8 = pcVar8 + 1;\n            } while (cVar2 != '\\0');\n            if (cVar1 != cVar2) {\n                pcVar8 = arg1 + 0x2078;\n                *(&stack0xffffffffffffffe0 + iVar6) = 0x1400026d9;\n                iVar3 = fcn.140002010(pcVar8, 0x1000, 0x1400225d4, arg2);\n                if (0xfff < iVar3) goto code_r0x0001400027ba;\n                *(arg1 + 0x4078) = 1;\n                iVar9 = (arg1 + 0x3078) - pcVar8;\n                do {\n                    cVar1 = *pcVar8;\n                    pcVar8[iVar9] = cVar1;\n                    pcVar8 = pcVar8 + 1;\n                } while (cVar1 != '\\0');\n            }\n            *(&stack0xffffffffffffffe0 + iVar6) = 0x140002716;\n            fcn.140002280(arg1);\n            *(&stack0xffffffffffffffe0 + iVar6) = 0x14000271e;\n            fcn.140002100(arg1);\n            *(&stack0xffffffffffffffe0 + iVar6) = 0x140002728;\n            fcn.140002270(arg1);\n            goto code_r0x0001400027ba;\n        }\n    }\n    *(&stack0xffffffffffffffe0 + iVar6) = 0x140002732;\n    iVar3 = fcn.140002160(arg1);\n    if (iVar3 == 0) {\n        pcVar8 = arg1 + 0x2078;\n        arg2_01 = &stack0x00001008 + iVar6;\n        if (*pcVar8 != '\\0') {\n            arg2_01 = pcVar8;\n        }\n        *(&stack0xffffffffffffffe0 + iVar6) = 0x140002757;\n        fcn.1400048a0(\"_MEIPASS2\", arg2_01, in_R8, in_R9);\n        *(&stack0xffffffffffffffe0 + iVar6) = 0x140002763;\n        fcn.140004290(\"_MEIPASS2\");\n        *(&stack0xffffffffffffffe0 + iVar6) = 0x14000276b;\n        iVar3 = fcn.140004b60(arg1);\n        if (iVar3 != -1) {\n            *(&stack0xffffffffffffffe0 + iVar6) = 0x14000277a;\n            fcn.140008d30();\n            *(&stack0xffffffffffffffe0 + iVar6) = 0x14000278d;\n            fcn.140004950(&stack0x00000008 + iVar6, arg1, argc, puVar4);\n            if (*(arg1 + 0x4078) == 1) {\n                *(&stack0xffffffffffffffe0 + iVar6) = 0x1400027a0;\n                fcn.140004540(pcVar8);\n            }\n            *(&stack0xffffffffffffffe0 + iVar6) = 0x1400027a8;\n            fcn.140001890(arg1);\n        }\n    }\ncode_r0x0001400027ba:\n    *(&stack0xffffffffffffffe0 + iVar6) = 0x1400027ca;\n    fcn.140008410(*(&stack0x00003008 + iVar6) ^ &stack0xffffffffffffffe8 + iVar6);\n    return;\n}\n",
        "token_count": 2075
    },
    "14000139": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nulong fcn.140001390(int64_t arg1, int64_t arg2)\n\n{\n    int64_t arg3;\n    int32_t iVar1;\n    uint32_t uVar2;\n    ulong uVar3;\n    int64_t arg4;\n    int64_t iVar4;\n    ulong in_R9;\n    int64_t arg4_00;\n    \n    uVar3 = fcn.140001230(arg1, arg2);\n    iVar1 = fcn.140003ff0(arg1);\n    if (iVar1 == -1) {\n        return 0xffffffff;\n    }\n    arg3 = arg2 + 0x12;\n    arg4 = fcn.140004340(arg1 + 0x2078, arg3);\n    uVar2 = sub.WS2_32.dll_ntohl(*(arg2 + 0xc));\n    if (arg4 == 0) {\n        fcn.1400019a0(\"fopen\", \"%s could not be extracted!\\n\", arg3, in_R9);\n        uVar3 = 0xffffffff;\n    }\n    else {\n        arg4_00 = arg4;\n        iVar4 = fcn.14000b088(uVar3, uVar2, 1, arg4);\n        if ((iVar4 == 1) || (uVar2 == 0)) {\n            fcn.14000a2dc(arg4);\n            fcn.14000a248(uVar3);\n            uVar3 = 0;\n        }\n        else {\n            fcn.1400019a0(\"fwrite\", \"Failed to write all bytes for %s\\n\", arg3, arg4_00);\n            uVar3 = 0xffffffff;\n        }\n    }\n    return uVar3;\n}\n",
        "token_count": 378
    },
    "14000167": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nulong fcn.140001670(int64_t *arg1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int64_t iVar3;\n    int64_t iVar4;\n    uint64_t arg2;\n    ulong uVar5;\n    ulong in_R9;\n    \n    if (*arg1 == 0) {\n        iVar3 = fcn.1400029b0(arg1 + 0xf, 0x1400223e0);\n        *arg1 = iVar3;\n        if (iVar3 == 0) {\n            return 0xffffffff;\n        }\n    }\n    uVar1 = fcn.140001130(arg1);\n    if (uVar1 < 1) {\n        fcn.14000a95c(*arg1, 0, 2);\n        uVar1 = fcn.14000ae40(*arg1);\n    }\n    iVar2 = fcn.140001480(arg1, uVar1);\n    if (iVar2 != -1) {\n        *(arg1 + 0x407c) = 0;\n        *0x140032b14 = sub.WS2_32.dll_ntohl(*(arg1 + 0x34));\n        iVar2 = sub.WS2_32.dll_ntohl(*(arg1 + 0x2c));\n        uVar5 = 0;\n        fcn.14000a95c(*arg1, iVar2 + *(arg1 + 1), 0);\n        uVar1 = sub.WS2_32.dll_ntohl();\n        iVar3 = fcn.14000a250(uVar1);\n        arg1[2] = iVar3;\n        if (iVar3 != 0) {\n            uVar1 = sub.WS2_32.dll_ntohl(*(arg1 + 6));\n            iVar3 = *arg1;\n            uVar5 = 1;\n            arg2 = uVar1;\n            iVar4 = fcn.14000a620(arg1[2], arg2, 1, iVar3);\n            if (iVar4 == 0) {\n                fcn.1400019a0(\"fread\", \"Could not read from file.\", uVar5, iVar3);\n                return 0xffffffff;\n            }\n            uVar1 = sub.WS2_32.dll_ntohl();\n            arg1[3] = uVar1 + arg1[2];\n            iVar2 = fcn.14000a374(*arg1);\n            if (iVar2 == 0) {\n                if (*arg1 != 0) {\n                    fcn.14000a2dc(*arg1);\n                    *arg1 = 0;\n                }\n                return 0;\n            }\n            fcn.1400019e0(\"Error on file\\n.\", arg2, uVar5, iVar3);\n            return 0xffffffff;\n        }\n        fcn.1400019a0(\"malloc\", \"Could not allocate buffer for TOC.\", uVar5, in_R9);\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 651
    },
    "140001b6": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.140001b60(int64_t *param_1, ulong param_2)\n\n{\n    uint8_t *puVar1;\n    char cVar2;\n    int64_t iVar3;\n    int32_t iVar4;\n    int64_t iVar5;\n    uchar *puVar6;\n    int64_t iVar7;\n    uint8_t *puVar8;\n    uint64_t arg2;\n    char *pcVar9;\n    uchar *arg2_00;\n    ulong unaff_RDI;\n    uint32_t uVar10;\n    ulong arg4;\n    ulong unaff_R14;\n    int64_t aiStackX8 [3];\n    uint8_t auStackX38 [2];\n    ulong var_3f50h;\n    ulong var_4f50h;\n    char acStack16424 [4096];\n    uchar auStack12328 [4096];\n    uchar auStack8232 [4096];\n    uchar auStack4136 [4096];\n    uint64_t uStack40;\n    ulong uStack32;\n    uint64_t arg3;\n    \n    uStack32 = 0x140001b76;\n    iVar5 = fcn.140008450();\n    iVar5 = -iVar5;\n    uStack40 = *0x140032010 ^ &stack0xffffffffffffffe8 + iVar5;\n    iVar7 = *param_1;\n    *(&stack0xffffffffffffffe0 + iVar5) = 0x140001bab;\n    iVar4 = fcn.140002010(&stack0xffffffffffffbfd8, 0x1000, 0x1400225d4, param_2);\n    if (0xfff < iVar4) goto code_r0x000140001cbc;\n    *(&stack0xffffffffffffffe0 + iVar5) = 0x140001bc7;\n    puVar6 = fcn.1400091e0(&stack0xffffffffffffbfd8, 0x3a);\n    if (puVar6 == NULL) goto code_r0x000140001cbc;\n    pcVar9 = puVar6 + 1;\n    *puVar6 = 0;\n    iVar3 = iVar5 - pcVar9;\n    do {\n        cVar2 = *pcVar9;\n        pcVar9[&stack0x00000038 + iVar3] = cVar2;\n        pcVar9 = pcVar9 + 1;\n    } while (cVar2 != '\\0');\n    if ((acStack16424[0] == '\\0') || ((&stack0x00000038)[iVar5] == '\\0')) goto code_r0x000140001cbc;\n    *(&stack0x00005078 + iVar5) = unaff_RDI;\n    *(&stack0x00005080 + iVar5) = unaff_R14;\n    *(&stack0xffffffffffffffe0 + iVar5) = 0x140001c27;\n    fcn.140002820(&stack0xffffffffffffefd8, &stack0xffffffffffffbfd8);\n    *(&stack0x00000018 + iVar5) = &stack0x00000038 + iVar5;\n    *(&stack0x00000010 + iVar5) = 0x140022624;\n    arg4 = 0x140022624;\n    *(&stack0x00000008 + iVar5) = &stack0xffffffffffffefd8;\n    puVar6 = iVar7 + 0x1078;\n    *(&stack0xffffffffffffffe0 + iVar5) = 0x140001c66;\n    iVar4 = fcn.140002070(&stack0xffffffffffffdfd8, \"%s%s%s%s%s\", puVar6, 0x140022624);\n    if (iVar4 == 0) {\ncode_r0x000140001c6a:\n        *(&stack0xffffffffffffffe0 + iVar5) = 0x140001c72;\n        iVar4 = fcn.140003ff0(iVar7);\n        if (iVar4 != -1) {\n            puVar6 = &stack0x00000038 + iVar5;\n            *(&stack0xffffffffffffffe0 + iVar5) = 0x140001c8f;\n            iVar4 = fcn.140003ed0(&stack0xffffffffffffdfd8, iVar7 + 0x2078);\n            if (iVar4 != -1) goto code_r0x000140001cbc;\n        }\n        arg2_00 = &stack0x00000038 + iVar5;\n        pcVar9 = \"Error copying %s\\n\";\n    }\n    else {\n        arg4 = 0x140022624;\n        *(&stack0x00000028 + iVar5) = &stack0x00000038 + iVar5;\n        puVar6 = iVar7 + 0x1078;\n        *(&stack0x00000020 + iVar5) = 0x140022624;\n        *(&stack0x00000018 + iVar5) = &stack0xffffffffffffefd8;\n        *(&stack0x00000010 + iVar5) = 0x140022624;\n        *(&stack0x00000008 + iVar5) = 0x14002264c;\n        *(&stack0xffffffffffffffe0 + iVar5) = 0x140001d1f;\n        iVar4 = fcn.140002070(&stack0xffffffffffffdfd8, \"%s%s%s%s%s%s%s\", puVar6, 0x140022624);\n        if (iVar4 == 0) goto code_r0x000140001c6a;\n        arg4 = 0x140022624;\n        puVar6 = iVar7 + 0x1078;\n        *(&stack0x00000008 + iVar5) = &stack0xffffffffffffbfd8;\n        *(&stack0xffffffffffffffe0 + iVar5) = 0x140001d50;\n        iVar4 = fcn.140002070(&stack0xffffffffffffcfd8, \"%s%s%s.pkg\", puVar6, 0x140022624);\n        if (iVar4 == 0) {\ncode_r0x000140001dae:\n            *(&stack0xffffffffffffffe0 + iVar5) = 0x140001dbd;\n            iVar7 = fcn.140001e70(param_1, &stack0xffffffffffffcfd8);\n            if (iVar7 != 0) {\n                arg2 = *(iVar7 + 0x10);\n                if (arg2 < *(iVar7 + 0x18)) {\n                    do {\n                        puVar8 = arg2 + 0x12;\n                        puVar6 = &stack0x00000038 + (iVar5 - puVar8);\n                        do {\n                            puVar1 = puVar8 + puVar6;\n                            uVar10 = *puVar8 - *puVar1;\n                            arg3 = uVar10;\n                            if (uVar10 != 0) break;\n                            puVar8 = puVar8 + 1;\n                        } while (*puVar1 != 0);\n                        if (uVar10 == 0) {\n                            *(&stack0xffffffffffffffe0 + iVar5) = 0x140001e25;\n                            iVar4 = fcn.140001390(iVar7, arg2);\n                            if (iVar4 != 0) {\n                                *(&stack0xffffffffffffffe0 + iVar5) = 0x140001e55;\n                                fcn.1400019e0(\"Error extracting %s\\n\", &stack0x00000038 + iVar5, arg3, puVar6);\n                                *(&stack0xffffffffffffffe0 + iVar5) = 0x140001e5d;\n                                fcn.140001890(iVar7);\n                                break;\n                            }\n                        }\n                        *(&stack0xffffffffffffffe0 + iVar5) = 0x140001e34;\n                        arg2 = fcn.140001630(iVar7, arg2);\n                    } while (arg2 < *(iVar7 + 0x18));\n                }\n                goto code_r0x000140001cbc;\n            }\n        }\n        else {\n            arg4 = 0x140022624;\n            puVar6 = iVar7 + 0x1078;\n            *(&stack0x00000008 + iVar5) = &stack0xffffffffffffbfd8;\n            *(&stack0xffffffffffffffe0 + iVar5) = 0x140001d7d;\n            iVar4 = fcn.140002070(&stack0xffffffffffffcfd8, \"%s%s%s.exe\", puVar6, 0x140022624);\n            if (iVar4 == 0) goto code_r0x000140001dae;\n            arg4 = 0x140022624;\n            puVar6 = iVar7 + 0x1078;\n            *(&stack0x00000008 + iVar5) = &stack0xffffffffffffbfd8;\n            *(&stack0xffffffffffffffe0 + iVar5) = 0x140001daa;\n            iVar4 = fcn.140002070(&stack0xffffffffffffcfd8, \"%s%s%s\", puVar6, 0x140022624);\n            if (iVar4 == 0) goto code_r0x000140001dae;\n        }\n        arg2_00 = &stack0xffffffffffffcfd8;\n        pcVar9 = \"Archive not found: %s\\n\";\n    }\n    *(&stack0xffffffffffffffe0 + iVar5) = 0x140001ca9;\n    fcn.1400019e0(pcVar9, arg2_00, puVar6, arg4);\ncode_r0x000140001cbc:\n    *(&stack0xffffffffffffffe0 + iVar5) = 0x140001ccb;\n    fcn.140008410(uStack40 ^ &stack0xffffffffffffffe8 + iVar5);\n    return;\n}\n",
        "token_count": 2150
    },
    "140001e7": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint64_t fcn.140001e70(int64_t *arg1, int64_t arg2)\n\n{\n    char cVar1;\n    char cVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int64_t *piVar5;\n    char *pcVar6;\n    ulong arg2_00;\n    int64_t iVar7;\n    ulong arg3;\n    int64_t iVar8;\n    \n    iVar3 = fcn.140003ff0(*arg1);\n    if (iVar3 == -1) {\n        return 0;\n    }\n    piVar5 = arg1 + 1;\n    iVar3 = 1;\n    if (arg1[1] != 0) {\n        iVar8 = 1;\n        do {\n            pcVar6 = *piVar5 + 0x78;\n            iVar7 = arg2 - pcVar6;\n            do {\n                cVar1 = *pcVar6;\n                cVar2 = pcVar6[iVar7];\n                if (cVar1 != cVar2) break;\n                pcVar6 = pcVar6 + 1;\n            } while (cVar2 != '\\0');\n            if (cVar1 == cVar2) {\n                return *piVar5;\n            }\n            iVar8 = iVar8 + 1;\n            iVar3 = iVar3 + 1;\n            piVar5 = arg1 + iVar8;\n        } while (arg1[iVar8] != 0);\n    }\n    iVar8 = fcn.1400018d0();\n    if (iVar8 == 0) {\n        return 0;\n    }\n    arg3 = 0x1400225d4;\n    arg2_00 = 0x1000;\n    iVar7 = arg2;\n    iVar4 = fcn.140002010(iVar8 + 0x78, 0x1000, 0x1400225d4, arg2);\n    if (iVar4 < 0x1000) {\n        iVar7 = *arg1 + 0x1078;\n        arg3 = 0x1400225d4;\n        arg2_00 = 0x1000;\n        iVar4 = fcn.140002010(iVar8 + 0x1078, 0x1000, 0x1400225d4, iVar7);\n        if (iVar4 < 0x1000) {\n            iVar7 = *arg1 + 0x2078;\n            arg3 = 0x1400225d4;\n            arg2_00 = 0x1000;\n            iVar4 = fcn.140002010(iVar8 + 0x2078, 0x1000, 0x1400225d4, iVar7);\n            if (iVar4 < 0x1000) {\n                *(iVar8 + 0x4078) = *(*arg1 + 0x4078);\n                iVar4 = fcn.140001670(iVar8);\n                if (iVar4 == 0) {\n                    arg1[iVar3] = iVar8;\n                    return iVar8;\n                }\n                fcn.1400019a0(\"malloc\", \"Error opening archive %s\\n\", arg2, iVar7);\n                goto code_r0x000140001fe4;\n            }\n        }\n    }\n    fcn.1400019e0(\"Archive path exceeds PATH_MAX\\n\", arg2_00, arg3, iVar7);\ncode_r0x000140001fe4:\n    fcn.140001890(iVar8);\n    return 0;\n}\n",
        "token_count": 774
    },
    "14000216": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.140002160(int64_t arg1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint64_t arg2;\n    int64_t iVar3;\n    uchar auStack216 [32];\n    int64_t aiStack184 [20];\n    uint64_t uStack24;\n    \n    uStack24 = *0x140032010 ^ auStack216;\n    arg2 = *(arg1 + 0x10);\n    fcn.140009280(aiStack184, 0, 0xa0);\n    aiStack184[0] = arg1;\n    if (arg2 < *(arg1 + 0x18)) {\n        do {\n            uVar1 = *(arg2 + 0x11) - 0x5a;\n            if ((uVar1 < 0x1f) && ((0x40000101U >> (uVar1 & 0x1f) & 1) != 0)) {\n                iVar2 = fcn.140001390(arg1, arg2);\n                if (iVar2 != 0) break;\n            }\n            else if ((*(arg2 + 0x11) == 100) && (iVar2 = fcn.140001b60(aiStack184, arg2 + 0x12),  iVar2 == -1)) break;\n            arg2 = fcn.140001630(arg1, arg2);\n        } while (arg2 < *(arg1 + 0x18));\n    }\n    iVar3 = 1;\n    while (aiStack184[1] != 0) {\n        fcn.140001890(aiStack184[1]);\n        iVar3 = iVar3 + 1;\n        aiStack184[1] = aiStack184[iVar3];\n    }\n    fcn.140008410(uStack24 ^ auStack216);\n    return;\n}\n",
        "token_count": 404
    },
    "140009cd": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuchar fcn.140009cd4(void)\n\n{\n    if (*0x140032040 != 0xffffffff) {\n        fcn.140009f94(*0x140032040);\n        *0x140032040 = 0xffffffff;\n    }\n    return 1;\n}\n",
        "token_count": 61
    },
    "14000c1d": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nulong fcn.14000c1dc(int64_t arg1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    cVar1 = fcn.14000c2c0(arg1);\n    if (cVar1 != '\\0') {\n        if ((((*(*(arg1 + 0x468) + 0x14) >> 0xc & 1) == 0) || (*(*(arg1 + 0x468) + 8) != 0)) &&\n           (iVar2 = fcn.140017a0c(*(arg1 + 0x41), *(arg1 + 0x468)),  iVar2 == -1)) {\n            *(arg1 + 0x28) = 0xffffffff;\n        }\n        else {\n            *(arg1 + 0x28) = *(arg1 + 0x28) + 1;\n        }\n        return 1;\n    }\n    puVar3 = fcn.1400139ac();\n    *puVar3 = 0x16;\n    fcn.14001388c();\n    return 0;\n}\n",
        "token_count": 248
    },
    "14001122": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nulong fcn.140011220(int64_t arg1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    int64_t iVar4;\n    \n    if (arg1 != 0) {\n        fcn.14000b29c(arg1);\n        LOCK();\n        *(arg1 + 0x14) = *(arg1 + 0x14) & 0xffffffe7;\n        iVar1 = fcn.14000f878(arg1);\n        if ((iVar1 == -1) || (iVar1 = fcn.14000f878(arg1),  iVar1 == -2)) {\n            iVar4 = 0x140032270;\n        }\n        else {\n            iVar1 = fcn.14000f878(arg1);\n            uVar2 = fcn.14000f878(arg1);\n            iVar4 = (uVar2 & 0x3f) * 0x40 + *((iVar1 >> 6) * 8 + 0x14003c780);\n        }\n        *(iVar4 + 0x38) = *(iVar4 + 0x38) & 0xfd;\n        fcn.14000b2a8(arg1);\n        return 0;\n    }\n    puVar3 = fcn.1400139ac();\n    *puVar3 = 0x16;\n    fcn.14001388c();\n    return 0x16;\n}\n",
        "token_count": 316
    },
    "1400149c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint64_t fcn.1400149c4(uint8_t **arg1)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int64_t iVar6;\n    ulong var_10h;\n    \n    if (arg1 == NULL) {\n        puVar5 = fcn.1400139ac();\n        *puVar5 = 0x16;\n        fcn.14001388c();\n    }\n    else if (((*(arg1 + 0x14) >> 0xd & 1) != 0) && ((*(arg1 + 0x14) >> 0xc & 1) == 0)) {\n        if ((*(arg1 + 0x14) >> 1 & 1) == 0) {\n            LOCK();\n            *(arg1 + 0x14) = *(arg1 + 0x14) | 1;\n            if ((*(arg1 + 0x14) & 0x4c0) == 0) {\n                fcn.14001ba10(arg1);\n            }\n            *arg1 = arg1[1];\n            uVar2 = fcn.14000f878(arg1);\n            uVar3 = fcn.14001429c(uVar2, arg1[1], *(arg1 + 4));\n            *(arg1 + 2) = uVar3;\n            if (1 < *(arg1 + 2) + 1U) {\n                if ((*(arg1 + 0x14) & 6) == 0) {\n                    iVar4 = fcn.14000f878(arg1);\n                    if ((iVar4 == -1) || (iVar4 = fcn.14000f878(arg1),  iVar4 == -2)) {\n                        iVar6 = 0x140032270;\n                    }\n                    else {\n                        iVar4 = fcn.14000f878(arg1);\n                        uVar2 = fcn.14000f878(arg1);\n                        iVar6 = (uVar2 & 0x3f) * 0x40 + *((iVar4 >> 6) * 8 + 0x14003c780);\n                    }\n                    if ((*(iVar6 + 0x38) & 0x82) == 0x82) {\n                        LOCK();\n                        *(arg1 + 0x14) = *(arg1 + 0x14) | 0x20;\n                    }\n                }\n                if (((*(arg1 + 4) == 0x200) && ((*(arg1 + 0x14) >> 6 & 1) != 0)) && ((*(arg1 + 0x14) >> 8 & 1) == 0)) {\n                    *(arg1 + 4) = 0x1000;\n                }\n                *(arg1 + 2) = *(arg1 + 2) + -1;\n                uVar1 = **arg1;\n                *arg1 = *arg1 + 1;\n                return uVar1;\n            }\n            LOCK();\n            *(arg1 + 0x14) = *(arg1 + 0x14) | (-(*(arg1 + 2) != 0) & 8) + 8;\n            *(arg1 + 2) = 0;\n        }\n        else {\n            LOCK();\n            *(arg1 + 0x14) = *(arg1 + 0x14) | 0x10;\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 777
    },
    "140016d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuchar fcn.140016d04(void)\n\n{\n    if (*0x1400322b0 != 0xffffffff) {\n        fcn.140015d68(*0x1400322b0);\n        *0x1400322b0 = 0xffffffff;\n    }\n    return 1;\n}\n",
        "token_count": 67
    },
    "1400180a": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_11h\n// WARNING: Variable defined which should be unmapped: var_1dh\n// WARNING: Variable defined which should be unmapped: var_25h\n// WARNING: Variable defined which should be unmapped: var_31h\n\nvoid fcn.1400180ac(ulong arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    code *pcVar1;\n    char cVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t in_stack_00000028;\n    uint32_t in_stack_00000030;\n    int32_t in_stack_00000038;\n    uchar auStack200 [32];\n    ulong uStack168;\n    int32_t iStack152;\n    int32_t iStack148;\n    uint auStack144 [2];\n    int64_t iStack136;\n    uchar auStack128 [8];\n    uint32_t uStack120;\n    int32_t iStack112;\n    uint32_t uStack108;\n    int32_t iStack100;\n    uint64_t var_51h;\n    ulong var_49h;\n    ulong var_41h;\n    ulong var_31h;\n    ulong var_25h;\n    ulong var_1dh;\n    ulong var_11h;\n    \n    *NULL = *0x140032010 ^ auStack200;\n    uVar5 = arg1 - 0x76c;\n    if ((((((uVar5 < 0x46) || (0x44c < uVar5)) || (0xb < arg2 - 1U)) || (iVar6 = arg2 + -1,  arg3 < 1)) ||\n        ((*(iVar6 * 4 + 0x14002d13c) - *(iVar6 * 4 + 0x14002d138) < arg3 &&\n         (((cVar2 = fcn.140017de4(uVar5, 0x14002d138),  cVar2 == '\\0' || (iVar6 != 1)) || (0x1d < arg3)))))) ||\n       (((0x17 < arg4 || (0x3b < in_stack_00000028)) || (0x3b < in_stack_00000030)))) {\n        puVar4 = fcn.1400139ac();\n        *puVar4 = 0x16;\n    }\n    else {\n        arg3._0_4_ = arg3 + *(arg2 * 4 + 0x14002d134);\n        cVar2 = fcn.140017de4(uVar5, 0x14002d138);\n        if ((cVar2 != '\\0') && (2 < arg2)) {\n            arg3._0_4_ = arg3 + 1;\n        }\n        fcn.14001e524();\n        iStack152 = 0;\n        auStack144[0] = 0;\n        iStack148 = 0;\n        iVar3 = fcn.14001da58(&iStack152);\n        if (iVar3 != 0) {\n            uStack168 = 0;\n            fcn.1400138ac(0, 0, 0, 0);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n        iVar3 = fcn.14001da88(auStack144);\n        if (iVar3 != 0) {\n            uStack168 = 0;\n            fcn.1400138ac(0, 0, 0, 0);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n        iVar3 = fcn.14001dab8(&iStack148);\n        if (iVar3 != 0) {\n            uStack168 = 0;\n            fcn.1400138ac(0, 0, 0, 0);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n        iVar3 = arg1 + -0x76d;\n        iStack136 = (((((iVar3 >> 0x1f & 3U) + iVar3 >> 2) + -0x11 + ((arg1 + -0x641) / 400 - iVar3 / 100) +\n                       (uVar5 + -0x46) * 0x16d + arg3) * 0x18 + arg4) * 0x3c + in_stack_00000028) * 0x3c + iStack148 +\n                    in_stack_00000030;\n        if (((in_stack_00000038 != 1) &&\n            (uStack120 = arg4,  iStack112 = iVar6,  uStack108 = uVar5,  iStack100 = arg3,  in_stack_00000038 == -1)) &&\n           (iStack152 != 0)) {\n            fcn.14001e560(auStack128);\n        }\n    }\n    fcn.140008410(stack0xffffffffffffffa8 ^ auStack200);\n    return;\n}\n",
        "token_count": 1131
    },
    "14000113": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t fcn.140001130(ulong *arg1)\n\n{\n    int32_t iVar1;\n    char cStackX8;\n    char cStackX9;\n    int32_t aiStackX16 [6];\n    \n    aiStackX16[0] = 0;\n    fcn.14000a95c(*arg1, 0, 0);\n    fcn.14000a620(&cStackX8, 1, 2, *arg1);\n    if ((cStackX8 == 'M') && (cStackX9 == 'Z')) {\n        fcn.14000a95c(*arg1, 0x3c, 0);\n        fcn.14000a620(aiStackX16, 4, 1, *arg1);\n        fcn.14000a95c(*arg1, aiStackX16[0] + 0x18, 0);\n        fcn.14000a620(&cStackX8, 2, 1, *arg1);\n        if (cStackX8 == '\\v') {\n            if (cStackX9 == '\\x01') {\n                iVar1 = 0x98;\n            }\n            else {\n                if (cStackX9 != '\\x02') {\n                    return -1;\n                }\n                iVar1 = 0xa8;\n            }\n            fcn.14000a95c(*arg1, aiStackX16[0] + iVar1, 0);\n            fcn.14000a620(aiStackX16, 4, 1, *arg1);\n            if (aiStackX16[0] == 0) {\n                aiStackX16[0] = -1;\n            }\n            return aiStackX16[0];\n        }\n    }\n    return -1;\n}\n",
        "token_count": 393
    },
    "14000123": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint64_t fcn.140001230(int64_t *arg1, int64_t arg2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int64_t iVar3;\n    int64_t iVar4;\n    ulong uVar5;\n    uint64_t uVar6;\n    ulong in_R8;\n    ulong in_R9;\n    int64_t arg4;\n    \n    if (*arg1 == 0) {\n        uVar5 = 0x1400223e0;\n        iVar3 = fcn.1400029b0(arg1 + 0xf, 0x1400223e0);\n        *arg1 = iVar3;\n        if (iVar3 == 0) {\n            fcn.1400019e0(\"Cannot open archive file\\n\", uVar5, in_R8, in_R9);\n            return 0;\n        }\n    }\n    iVar1 = sub.WS2_32.dll_ntohl(*(arg2 + 4));\n    uVar5 = 0;\n    uVar6 = iVar1 + *(arg1 + 1);\n    fcn.14000a95c(*arg1, uVar6, 0);\n    uVar2 = sub.WS2_32.dll_ntohl();\n    iVar3 = fcn.14000a250(uVar2);\n    if (iVar3 == 0) {\n        fcn.1400019e0(\"Could not allocate read buffer\\n\", uVar6, uVar5, in_R9);\n        return 0;\n    }\n    uVar2 = sub.WS2_32.dll_ntohl(*(arg2 + 8));\n    arg4 = *arg1;\n    uVar5 = 1;\n    uVar6 = uVar2;\n    iVar4 = fcn.14000a620(iVar3, uVar6, 1, arg4);\n    if (iVar4 == 0) {\n        fcn.1400019e0(\"Could not read from file\\n\", uVar6, uVar5, arg4);\n        fcn.14000a248(iVar3);\n        return 0;\n    }\n    iVar4 = iVar3;\n    if (*(arg2 + 0x10) == '\\x01') {\n        iVar4 = fcn.140001040(iVar3, arg2);\n        fcn.14000a248(iVar3);\n        if (iVar4 == 0) {\n            fcn.1400019e0(\"Error decompressing %s\\n\", arg2 + 0x12, uVar5, arg4);\n            return 0;\n        }\n    }\n    if (*arg1 != 0) {\n        fcn.14000a2dc(*arg1);\n        *arg1 = 0;\n    }\n    return iVar4;\n}\n",
        "token_count": 605
    },
    "14000148": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.140001480(ulong *arg1, ulong arg2)\n\n{\n    ulong uVar1;\n    uint uVar2;\n    uint uVar3;\n    uint uVar4;\n    uint uVar5;\n    uint uVar6;\n    uint uVar7;\n    uint uVar8;\n    uint uVar9;\n    uint uVar10;\n    int32_t iVar11;\n    int64_t iVar12;\n    uint *arg2_00;\n    uchar auStack152 [32];\n    uint auStack120 [2];\n    uint auStack112 [22];\n    uint64_t uStack24;\n    \n    uStack24 = *0x140032010 ^ auStack152;\n    arg2_00 = auStack112;\n    iVar11 = fcn.14000a95c(*arg1, arg2 - 0x60U, 0);\n    if ((iVar11 == 0) && (iVar12 = fcn.14000a620(auStack120, 0x60, 1, *arg1),  iVar12 != 0)) {\n        do {\n            iVar11 = fcn.14000a1c0(\"MEI\\f\\v\\n\\v\\x0e\", arg2_00, 8);\n            if (iVar11 == 0) {\n                uVar2 = arg2_00[1];\n                uVar3 = arg2_00[2];\n                uVar4 = arg2_00[3];\n                uVar5 = arg2_00[4];\n                uVar6 = arg2_00[5];\n                uVar7 = arg2_00[6];\n                uVar8 = arg2_00[7];\n                *(arg1 + 4) = *arg2_00;\n                *(arg1 + 0x24) = uVar2;\n                *(arg1 + 5) = uVar3;\n                *(arg1 + 0x2c) = uVar4;\n                uVar2 = arg2_00[8];\n                uVar3 = arg2_00[9];\n                uVar4 = arg2_00[10];\n                uVar9 = arg2_00[0xb];\n                *(arg1 + 6) = uVar5;\n                *(arg1 + 0x34) = uVar6;\n                *(arg1 + 7) = uVar7;\n                *(arg1 + 0x3c) = uVar8;\n                uVar6 = arg2_00[0xc];\n                uVar7 = arg2_00[0xd];\n                uVar8 = arg2_00[0xe];\n                uVar10 = arg2_00[0xf];\n                *(arg1 + 8) = uVar2;\n                *(arg1 + 0x44) = uVar3;\n                *(arg1 + 9) = uVar4;\n                *(arg1 + 0x4c) = uVar9;\n                uVar2 = arg2_00[0x10];\n                uVar3 = arg2_00[0x11];\n                uVar4 = arg2_00[0x12];\n                uVar5 = arg2_00[0x13];\n                *(arg1 + 10) = uVar6;\n                *(arg1 + 0x54) = uVar7;\n                *(arg1 + 0xb) = uVar8;\n                *(arg1 + 0x5c) = uVar10;\n                uVar1 = *(arg2_00 + 0x14);\n                *(arg1 + 0xc) = uVar2;\n                *(arg1 + 100) = uVar3;\n                *(arg1 + 0xd) = uVar4;\n                *(arg1 + 0x6c) = uVar5;\n                arg1[0xe] = uVar1;\n                iVar11 = sub.WS2_32.dll_ntohl(*(arg1 + 5));\n                *(arg1 + 1) = (((arg2_00 - (*0x20 + -0x78)) + (arg2 - 0x60U)) - iVar11) + 0x58;\n                break;\n            }\n            arg2_00 = arg2_00 + -1;\n        } while (auStack120 <= arg2_00);\n    }\n    fcn.140008410(uStack24 ^ auStack152);\n    return;\n}\n",
        "token_count": 955
    },
    "14000158": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nchar * fcn.140001580(int64_t arg1, int64_t arg2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    char *pcVar4;\n    int64_t arg2_00;\n    int64_t arg3;\n    int64_t in_R8;\n    ulong in_R9;\n    int64_t iVar5;\n    \n    puVar3 = *(arg1 + 0x10);\n    arg3 = -1;\n    do {\n        iVar5 = arg3;\n        arg3 = iVar5 + 1;\n    } while (*(arg3 + arg2) != '\\0');\n    arg2_00 = arg2;\n    if (puVar3 < *(arg1 + 0x18)) {\n        do {\n            if ((*(puVar3 + 0x11) == 'o') &&\n               (arg2_00 = arg2,  in_R8 = arg3,  iVar1 = fcn.14000a1c0(puVar3 + 0x12, arg2, arg3),  iVar1 == 0)) {\n                pcVar4 = puVar3 + iVar5 + 0x13;\n                if (*pcVar4 == '\\0') {\n                    return pcVar4;\n                }\n                return puVar3 + iVar5 + 0x14;\n            }\n            uVar2 = sub.WS2_32.dll_ntohl(*puVar3);\n            puVar3 = uVar2 + puVar3;\n            if (puVar3 < *(arg1 + 0x10)) {\n                fcn.1400019e0(\"Cannot read Table of Contents.\\n\", arg2_00, in_R8, in_R9);\n                puVar3 = *(arg1 + 0x18);\n            }\n        } while (puVar3 < *(arg1 + 0x18));\n    }\n    return NULL;\n}\n",
        "token_count": 418
    },
    "1400017c": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.1400017c0(int64_t *arg1, char *arg2)\n\n{\n    char cVar1;\n    int64_t iVar2;\n    int32_t iVar3;\n    uint64_t uVar4;\n    char *pcVar5;\n    int64_t *arg1_00;\n    \n    uVar4 = 0xffffffffffffffff;\n    do {\n        uVar4 = uVar4 + 1;\n    } while (arg2[uVar4] != '\\0');\n    if (uVar4 < 0x1000) {\n        pcVar5 = arg2;\n        do {\n            cVar1 = *pcVar5;\n            pcVar5[arg1 + (0x78 - arg2)] = cVar1;\n            pcVar5 = pcVar5 + 1;\n        } while (cVar1 != '\\0');\n        arg1_00 = arg1 + 0x20f;\n        fcn.140002820(arg1_00, arg2);\n        *(arg1 + 0x80f) = 0;\n        iVar2 = 0x3078 - arg1_00;\n        do {\n            cVar1 = *arg1_00;\n            *(arg1 + iVar2 + arg1_00) = cVar1;\n            arg1_00 = arg1_00 + 1;\n        } while (cVar1 != '\\0');\n        iVar3 = fcn.140001670(arg1);\n        if (iVar3 == 0) {\n            return 1;\n        }\n        if (*arg1 != 0) {\n            fcn.14000a2dc(*arg1);\n            *arg1 = 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 374
    },
    "14000227": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.140002270(int64_t arg1)\n\n{\n    if (*(arg1 + 0x407c) == 1) {\n        (**0x140032ba8)(\n                       \"import sys; sys.stdout.flush();                 (sys.__stdout__.flush if sys.__stdout__                 is not sys.stdout else (lambda: None))()\"\n                       );\n        (**0x140032ba8)(\n                       \"import sys; sys.stderr.flush();                 (sys.__stderr__.flush if sys.__stderr__                 is not sys.stderr else (lambda: None))()\"\n                       );\n    // WARNING: Could not recover jumptable at 0x00014000369b. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**0x140032b60)();\n        return;\n    }\n    return;\n}\n",
        "token_count": 173
    },
    "1400027e": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.1400027e0(int64_t arg1, char *arg2)\n\n{\n    char cVar1;\n    int64_t iVar2;\n    int64_t iVar3;\n    \n    iVar3 = arg1 - arg2;\n    do {\n        cVar1 = *arg2;\n        arg2[iVar3] = cVar1;\n        arg2 = arg2 + 1;\n    } while (cVar1 != '\\0');\n    iVar3 = -1;\n    do {\n        iVar2 = iVar3;\n        iVar3 = iVar2 + 1;\n    } while (*(arg1 + 1 + iVar2) != '\\0');\n    *(iVar2 + -2 + arg1) = 0x676b70;\n    return 1;\n}\n",
        "token_count": 166
    },
    "14000282": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.140002820(ushort *arg1, ulong arg2)\n\n{\n    int64_t iVar1;\n    int32_t iVar2;\n    int64_t iVar3;\n    uchar *puVar4;\n    \n    iVar2 = fcn.140002010(arg1, 0x1000, 0x1400225d4, arg2);\n    if (0xfff < iVar2) {\n        return 0;\n    }\n    iVar1 = -1;\n    do {\n        iVar3 = iVar1;\n        iVar1 = iVar3 + 1;\n    } while (*(arg1 + iVar3 + 1) != '\\0');\n    if (*(iVar3 + arg1) == '\\\\') {\n        *(iVar3 + arg1) = 0;\n    }\n    puVar4 = fcn.140009420(arg1, 0x5c);\n    if (puVar4 != NULL) {\n        *puVar4 = 0;\n        return 1;\n    }\n    *arg1 = 0x2e;\n    return 1;\n}\n",
        "token_count": 230
    },
    "140002ad": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint64_t fcn.140002ad0(int64_t arg1, ulong arg2, int64_t arg3)\n\n{\n    int64_t iVar1;\n    int32_t iVar2;\n    uint64_t uVar3;\n    uint64_t uVar5;\n    int64_t iVar6;\n    uint64_t uVar4;\n    \n    iVar2 = fcn.140002010(arg1, 0x1000, 0x1400225d4, arg2);\n    uVar5 = iVar2;\n    if (uVar5 < 0xfff) {\n        if (*((uVar5 - 1) + arg1) != '\\\\') {\n            *(uVar5 + arg1) = 0x5c;\n            uVar5 = uVar5 + 2;\n        }\n        uVar5 = 0x1000 - uVar5;\n        uVar3 = 0xffffffffffffffff;\n        do {\n            uVar4 = uVar3;\n            uVar3 = uVar4 + 1;\n        } while (*(arg3 + uVar3) != '\\0');\n        if (uVar3 < uVar5) {\n            if (*(uVar4 + arg3) == '\\\\') {\n                fcn.14000edb0(arg1, arg3, uVar5);\n                iVar1 = -1;\n                do {\n                    iVar6 = iVar1;\n                    iVar1 = iVar6 + 1;\n                } while (*(arg1 + 1 + iVar6) != '\\0');\n                *(iVar6 + arg1) = 0;\n            }\n            else {\n                fcn.14000edb0(arg1, arg3, uVar5);\n            }\n        }\n        else {\n            arg1 = 0;\n        }\n        return arg1;\n    }\n    return 0;\n}\n",
        "token_count": 389
    },
    "1400036b": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.1400036b0(int64_t arg1, ulong arg2)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    ulong uVar3;\n    int64_t iVar4;\n    uint64_t arg2_00;\n    int64_t iVar5;\n    char *arg3;\n    uint32_t uVar6;\n    char *arg4;\n    uint64_t arg4_00;\n    \n    iVar5 = -1;\n    do {\n        iVar5 = iVar5 + 1;\n    } while (*(arg1 + 0x3078 + iVar5) != '\\0');\n    arg4 = \"strict\";\n    arg3 = \"utf-8\";\n    iVar2 = (**0x140032c68)();\n    if (iVar2 != 0) {\n        (**0x140032c38)(\"_MEIPASS\", iVar2);\n        uVar3 = (**0x140032bb8)(\"marshal\");\n        uVar3 = (**0x140032c00)(uVar3);\n        uVar3 = (**0x140032c08)(uVar3, \"loads\");\n        arg2_00 = *(arg1 + 0x10);\n        if (arg2_00 < *(arg1 + 0x18)) {\n            do {\n                if ((*(arg2_00 + 0x11) + 0xb3U & 0xdf) == 0) {\n                    iVar5 = fcn.140001230(arg1, arg2_00);\n                    if (*0x140032b14 < 0x25) {\n                        iVar1 = sub.WS2_32.dll_ntohl(*(arg2_00 + 0xc));\n                        iVar2 = iVar5 + 0xc;\n                        uVar6 = iVar1 - 0xc;\n                    }\n                    else {\n                        iVar1 = sub.WS2_32.dll_ntohl(*(arg2_00 + 0xc));\n                        iVar2 = iVar5 + 0x10;\n                        uVar6 = iVar1 - 0x10;\n                    }\n                    arg4_00 = uVar6;\n                    iVar4 = (**0x140032bf0)(uVar3, 0x1400238b0);\n                    if ((iVar4 == 0) || (iVar4 = (**0x140032bb0)(arg2_00 + 0x12, iVar4),  iVar4 == 0)) {\n                        fcn.1400019e0(\"mod is NULL - %s\", arg2_00 + 0x12, iVar2, arg4_00);\n                    }\n                    iVar2 = (**0x140032c18)();\n                    if (iVar2 != 0) {\n                        (**0x140032c20)();\n                        (**0x140032c10)();\n                    }\n                    fcn.14000a248(iVar5);\n                }\n                arg2_00 = fcn.140001630(arg1, arg2_00);\n            } while (arg2_00 < *(arg1 + 0x18));\n        }\n        return 0;\n    }\n    fcn.1400019e0(\"Failed to get _MEIPASS as PyObject.\\n\", iVar5, arg3, arg4);\n    return 0xffffffff;\n}\n",
        "token_count": 698
    },
    "14000383": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.140003830(int64_t arg1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    ulong uVar3;\n    ulong arg2;\n    uint64_t netlong;\n    int64_t iVar4;\n    ulong arg2_00;\n    uint64_t arg3;\n    char *arg4;\n    \n    netlong = *(arg1 + 0x10);\n    if (netlong < *(arg1 + 0x18)) {\n        do {\n            if (*(netlong + 0x11) == 'z') {\n                iVar1 = sub.WS2_32.dll_ntohl(*(netlong + 4));\n                iVar2 = *(arg1 + 8);\n                iVar4 = -1;\n                do {\n                    iVar4 = iVar4 + 1;\n                } while (*(arg1 + 0x78 + iVar4) != '\\0');\n                arg4 = \"strict\";\n                uVar3 = (**0x140032c68)();\n                arg3 = iVar1 + iVar2;\n                arg2_00 = uVar3;\n                arg2 = (**0x140032c58)(\"%U?%d\");\n                (**0x140032b70)(uVar3);\n                iVar4 = (**0x140032c50)(\"path\");\n                if (iVar4 == 0) {\n                    fcn.1400019e0(\"Installing PYZ: Could not get sys.path\\n\", arg2_00, arg3, arg4);\n                    (**0x140032b70)(arg2);\n                }\n                else {\n                    iVar2 = (**0x140032bd8)(iVar4);\n                    if (iVar2 != 0) {\n                        fcn.1400019e0(\"Failed to append to sys.path\\n\", arg2, arg3, arg4);\n                    }\n                }\n            }\n            netlong = fcn.140001630(arg1, netlong);\n        } while (netlong < *(arg1 + 0x18));\n    }\n    return 0;\n}\n",
        "token_count": 435
    },
    "14000393": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.140003930(int64_t param_1)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    int64_t iVar3;\n    int64_t iVar4;\n    char *noname_2;\n    uchar *arg3;\n    int64_t arg4;\n    uchar auStackX24 [16];\n    ulong uStack16;\n    \n    uStack16 = 0x140003940;\n    iVar2 = fcn.140008450();\n    iVar2 = -iVar2;\n    *(&stack0x00002058 + iVar2) = *0x140032010 ^ &stack0xfffffffffffffff8 + iVar2;\n    arg4 = param_1 + 0x38;\n    *(&stack0xfffffffffffffff0 + iVar2) = 0x140003972;\n    iVar1 = fcn.140002010(&stack0x00000018 + iVar2, 0x40, 0x1400225d4, arg4);\n    if (iVar1 < 0x40) {\n        if (*(param_1 + 0x4078) != 0) {\n            noname_2 = \"ucrtbase.dll\";\n            iVar4 = param_1 + 0x2078;\n            *(&stack0xfffffffffffffff0 + iVar2) = 0x1400039ba;\n            iVar3 = fcn.140002ad0(&stack0x00000058 + iVar2, iVar4, \"ucrtbase.dll\");\n            if (iVar3 == 0) {\n                noname_2 = 0x1000;\n                iVar4 = param_1 + 0x2078;\n                *(&stack0xfffffffffffffff0 + iVar2) = 0x1400039d8;\n                fcn.1400019e0(\"Path of ucrtbase.dll (%s) length exceeds buffer[%d] space\\n\", iVar4, 0x1000, arg4);\n            }\n            *(&stack0xfffffffffffffff0 + iVar2) = 0x1400039e2;\n            iVar1 = fcn.140002940(&stack0x00000058 + iVar2);\n            if (iVar1 != 0) {\n                *(&stack0xfffffffffffffff0 + iVar2) = 0x1400039f0;\n                fcn.140004b10(&stack0x00000058 + iVar2, iVar4, noname_2, arg4);\n            }\n        }\n        arg3 = &stack0x00000018 + iVar2;\n        iVar4 = param_1 + 0x3078;\n        *(&stack0xfffffffffffffff0 + iVar2) = 0x140003a09;\n        iVar3 = fcn.140002ad0(&stack0x00001058 + iVar2, iVar4, arg3);\n        if (iVar3 == 0) {\n            arg3 = 0x1000;\n            iVar4 = param_1 + 0x3078;\n            *(&stack0xfffffffffffffff0 + iVar2) = 0x140003a27;\n            fcn.1400019e0(\"Path of DLL (%s) length exceeds buffer[%d] space\\n\", iVar4, 0x1000, arg4);\n        }\n        *(&stack0xfffffffffffffff0 + iVar2) = 0x140003a34;\n        iVar4 = fcn.140004b10(&stack0x00001058 + iVar2, iVar4, arg3, arg4);\n        if (iVar4 == 0) {\n            *(&stack0xfffffffffffffff0 + iVar2) = 0x140003a54;\n            fcn.140001a40(\"LoadLibrary\", \"Error loading Python DLL \\'%s\\'.\\n\", &stack0x00001058 + iVar2, arg4);\n        }\n        else {\n            *(&stack0xfffffffffffffff0 + iVar2) = 0x140003a67;\n            fcn.140002ba0(iVar4, *0x140032b14, arg3, arg4);\n        }\n    }\n    else {\n        *(&stack0xfffffffffffffff0 + iVar2) = 0x140003991;\n        fcn.1400019e0(\"Reported length (%d) of DLL name (%s) length exceeds buffer[%d] space\\n\", iVar1, param_1 + 0x38, \n                      0x40);\n    }\n    *(&stack0xfffffffffffffff0 + iVar2) = 0x140003a77;\n    fcn.140008410(*(&stack0x00002058 + iVar2) ^ &stack0xfffffffffffffff8 + iVar2);\n    return;\n}\n",
        "token_count": 1011
    },
    "140003a9": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.140003a90(int64_t param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    char cVar1;\n    bool bVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int64_t iVar5;\n    int64_t iVar6;\n    uint *puVar7;\n    uint64_t netlong;\n    ulong uVar8;\n    ulong uStack16;\n    \n    uStack16 = 0x140003aaa;\n    iVar5 = fcn.140008450();\n    iVar5 = -iVar5;\n    *(&stack0x00002028 + iVar5) = *0x140032010 ^ &stack0xfffffffffffffff8 + iVar5;\n    bVar2 = false;\n    netlong = *(param_1 + 0x10);\n    **0x140032b20 = 1;\n    **0x140032b18 = 1;\n    **0x140032b48 = 1;\n    **0x140032b50 = 1;\n    **0x140032b40 = 1;\n    **0x140032b38 = 0;\n    if (netlong < *(param_1 + 0x18)) {\n        do {\n            if (*(netlong + 0x11) == 'o') {\n                *(&stack0xfffffffffffffff0 + iVar5) = 0x140003b3c;\n                iVar3 = fcn.14000a1c0(netlong + 0x12, \"pyi-\", 4);\n                if (iVar3 != 0) {\n                    cVar1 = *(netlong + 0x12);\n                    puVar7 = *0x140032b28;\n                    if (cVar1 == 'O') {\ncode_r0x000140003b9a:\n                        *puVar7 = 1;\n                    }\n                    else if (cVar1 == 'W') {\n                        uVar8 = 0x1000;\n                        *(&stack0xfffffffffffffff0 + iVar5) = 0x140003b7c;\n                        iVar6 = fcn.14000f41c(&stack0x00000018 + iVar5, netlong + 0x14, 0x1000);\n                        if (iVar6 == -1) {\n                            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c91;\n                            fcn.1400019e0(\"Failed to convert Wflag %s using mbstowcs (invalid multibyte string)\\n\", \n                                          netlong + 0x14, uVar8, param_4);\n                            goto code_r0x000140003c58;\n                        }\n                        *(&stack0xfffffffffffffff0 + iVar5) = 0x140003b91;\n                        (**0x140032c28)(&stack0x00000018 + iVar5);\n                    }\n                    else if (cVar1 == 'u') {\n                        bVar2 = true;\n                    }\n                    else {\n                        puVar7 = *0x140032b38;\n                        if (cVar1 == 'v') goto code_r0x000140003b9a;\n                    }\n                }\n            }\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003bab;\n            netlong = fcn.140001630(param_1, netlong);\n        } while (netlong < *(param_1 + 0x18));\n        if (bVar2) {\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003bc7;\n            uVar8 = fcn.14000b22c(0);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003bcf;\n            uVar4 = fcn.14000f878(uVar8);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003bdb;\n            fcn.14000f4a8(uVar4, 0x8000);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003be5;\n            uVar8 = fcn.14000b22c(1);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003bed;\n            uVar4 = fcn.14000f878(uVar8);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003bf9;\n            fcn.14000f4a8(uVar4, 0x8000);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c03;\n            uVar8 = fcn.14000b22c(1);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c0b;\n            fcn.14000f834(uVar8);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c15;\n            uVar8 = fcn.14000b22c(2);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c1d;\n            fcn.14000f834(uVar8);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c24;\n            uVar8 = fcn.14000b22c(0);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c2e;\n            fcn.14000ed84(uVar8, 0);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c38;\n            uVar8 = fcn.14000b22c(1);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c42;\n            fcn.14000ed84(uVar8, 0);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c4c;\n            uVar8 = fcn.14000b22c(2);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c56;\n            fcn.14000ed84(uVar8, 0);\n        }\n    }\ncode_r0x000140003c58:\n    *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c68;\n    fcn.140008410(*(&stack0x00002028 + iVar5) ^ &stack0xfffffffffffffff8 + iVar5);\n    return;\n}\n",
        "token_count": 1417
    },
    "140003ff": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nulong fcn.140003ff0(int64_t arg1)\n\n{\n    int32_t iVar1;\n    ulong arg2;\n    ulong in_R8;\n    ulong in_R9;\n    \n    if (*(arg1 + 0x4078) != 1) {\n        arg2 = fcn.140001580(arg1, \"pyi-runtime-tmpdir\");\n        iVar1 = fcn.140004050(arg1 + 0x2078);\n        if (iVar1 == 0) {\n            fcn.1400019e0(\"INTERNAL ERROR: cannot create temporary directory!\\n\", arg2, in_R8, in_R9);\n            return 0xffffffff;\n        }\n        *(arg1 + 0x4078) = 1;\n    }\n    return 0;\n}\n",
        "token_count": 170
    },
    "14000429": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.140004290(ulong param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    ulong uVar3;\n    char *arg1;\n    uchar auStackX32 [8];\n    ulong uStack8;\n    \n    uStack8 = 0x14000429a;\n    iVar2 = fcn.140008450();\n    iVar2 = -iVar2;\n    *(&stack0x00004020 + iVar2) = *0x140032010 ^ &stack0x00000000 + iVar2;\n    *(&stack0xfffffffffffffff8 + iVar2) = 0x1400042bc;\n    uVar3 = fcn.1400052b0(0, param_1, 0, param_4);\n    *(&stack0xfffffffffffffff8 + iVar2) = 0x1400042d0;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetEnvironmentVariableW)(uVar3, &stack0x00000020 + iVar2, 0x2000);\n    if (iVar1 != 0) {\n        *(&stack0xfffffffffffffff8 + iVar2) = 0x1400042ed;\n        (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(&stack0x00000020 + iVar2, &stack0x00002020 + iVar2);\n        *(&stack0xfffffffffffffff8 + iVar2) = 0x1400042fc;\n        arg1 = fcn.1400053b0(0, &stack0x00000020 + iVar2, 0, param_4);\n        if ((arg1 != NULL) && (*arg1 != '\\0')) {\n            *(&stack0xfffffffffffffff8 + iVar2) = 0x14000430e;\n            fcn.14000f1c8(arg1);\n            *(&stack0xfffffffffffffff8 + iVar2) = 0x14000431e;\n            fcn.140008410(*(&stack0x00004020 + iVar2) ^ &stack0x00000000 + iVar2);\n            return;\n        }\n    }\n    *(&stack0xfffffffffffffff8 + iVar2) = 0x140004338;\n    fcn.140008410(*(&stack0x00004020 + iVar2) ^ &stack0x00000000 + iVar2);\n    return;\n}\n",
        "token_count": 531
    },
    "14000434": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.140004340(ulong param_1, ulong param_2)\n\n{\n    char *pcVar1;\n    char cVar2;\n    int32_t iVar3;\n    int64_t iVar4;\n    int64_t iVar5;\n    uchar *puVar6;\n    int64_t iVar7;\n    ushort *puVar8;\n    ulong unaff_RDI;\n    uint64_t uVar9;\n    ulong arg3;\n    uchar auStackX24 [16];\n    ulong uStack16;\n    \n    uStack16 = 0x14000434c;\n    iVar4 = fcn.140008450();\n    iVar4 = -iVar4;\n    *(&stack0x00004048 + iVar4) = *0x140032010 ^ &stack0xfffffffffffffff8 + iVar4;\n    *(&stack0xfffffffffffffff0 + iVar4) = 0x14000437d;\n    iVar3 = fcn.140002010(&stack0x00000048 + iVar4, 0x1000, 0x1400225d4, param_1);\n    if (iVar3 < 0x1000) {\n        *(&stack0xfffffffffffffff0 + iVar4) = 0x1400043a4;\n        iVar3 = fcn.140002010(&stack0x00001048 + iVar4, 0x1000, 0x1400225d4, param_2);\n        if (iVar3 < 0x1000) {\n            *(&stack0x00004078 + iVar4) = unaff_RDI;\n            uVar9 = 0xffffffffffffffff;\n            do {\n                uVar9 = uVar9 + 1;\n            } while ((&stack0x00000049)[uVar9 + iVar4 + -1] != '\\0');\n            *(&stack0xfffffffffffffff0 + iVar4) = 0x1400043dd;\n            iVar5 = fcn.14000ef48(&stack0x00001048 + iVar4, 0x140022624);\n            if (iVar5 != 0) {\n                while( true ) {\n                    iVar7 = -1;\n                    do {\n                        iVar7 = iVar7 + 1;\n                    } while (*(iVar5 + iVar7) != '\\0');\n                    uVar9 = uVar9 + 1 + iVar7;\n                    if (0xffe < uVar9) goto code_r0x0001400044c3;\n                    puVar8 = &stack0x00000047 + iVar4;\n                    do {\n                        pcVar1 = puVar8 + 1;\n                        puVar8 = puVar8 + 1;\n                    } while (*pcVar1 != '\\0');\n                    *puVar8 = *0x140022624;\n                    puVar6 = &stack0x00000047 + iVar4;\n                    do {\n                        pcVar1 = puVar6 + 1;\n                        puVar6 = puVar6 + 1;\n                    } while (*pcVar1 != '\\0');\n                    iVar7 = 0;\n                    do {\n                        cVar2 = *(iVar5 + iVar7);\n                        puVar6[iVar7] = cVar2;\n                        iVar7 = iVar7 + 1;\n                    } while (cVar2 != '\\0');\n                    *(&stack0xfffffffffffffff0 + iVar4) = 0x14000446d;\n                    iVar5 = fcn.14000ef48(0, 0x140022624);\n                    if (iVar5 == 0) break;\n                    *(&stack0xfffffffffffffff0 + iVar4) = 0x14000448d;\n                    fcn.1400052b0(&stack0x00002048 + iVar4, &stack0x00000048 + iVar4, 0x1000, param_2);\n                    *(&stack0xfffffffffffffff0 + iVar4) = 0x14000449f;\n                    iVar3 = fcn.14000ed7c(&stack0x00002048 + iVar4, &stack0x00000018 + iVar4);\n                    if (iVar3 < 0) {\n                        *(&stack0xfffffffffffffff0 + iVar4) = 0x1400044b4;\n                        fcn.1400050e0(&stack0x00002048 + iVar4);\n                    }\n                }\n            }\n            arg3 = 0x1000;\n            *(&stack0xfffffffffffffff0 + iVar4) = 0x1400044f4;\n            fcn.1400052b0(&stack0x00002048 + iVar4, &stack0x00000048 + iVar4, 0x1000, param_2);\n            *(&stack0xfffffffffffffff0 + iVar4) = 0x140004506;\n            iVar3 = fcn.14000ed7c(&stack0x00002048 + iVar4, &stack0x00000018 + iVar4);\n            if (iVar3 == 0) {\n                *(&stack0xfffffffffffffff0 + iVar4) = 0x14000451b;\n                fcn.1400019e0(\"WARNING: file already exists but should not: %s\\n\", &stack0x00000048 + iVar4, arg3, \n                              param_2);\n            }\n            *(&stack0xfffffffffffffff0 + iVar4) = 0x14000452c;\n            fcn.1400029b0(&stack0x00000048 + iVar4, 0x140023b0c);\n        }\n    }\ncode_r0x0001400044c3:\n    *(&stack0xfffffffffffffff0 + iVar4) = 0x1400044d3;\n    fcn.140008410(*(&stack0x00004048 + iVar4) ^ &stack0xfffffffffffffff8 + iVar4);\n    return;\n}\n",
        "token_count": 1259
    },
    "140004b7": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.140004b70(int64_t param_1, int64_t param_2, uint8_t *param_3)\n\n{\n    int16_t *piVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int64_t iVar4;\n    int64_t iVar5;\n    int64_t iVar6;\n    uchar auStackX24 [16];\n    ulong uStack16;\n    \n    uStack16 = 0x140004b7c;\n    iVar4 = fcn.140008450();\n    iVar4 = -iVar4;\n    *(&stack0x00001028 + iVar4) = *0x140032010 ^ &stack0xfffffffffffffff8 + iVar4;\n    if (((*(param_3 + 0x24) != *0x140023ac4) || (*(param_3 + 0x26) != *0x140023ac6)) &&\n       ((*(param_3 + 0x24) != *0x140023ac8 ||\n        ((*(param_3 + 0x26) != *0x140023aca || (*(param_3 + 0x28) != *0x140023acc)))))) {\n        *(param_1 + param_2 * 2) = 0;\n        iVar5 = param_1 + -2;\n        do {\n            piVar1 = iVar5 + 2;\n            iVar5 = iVar5 + 2;\n        } while (*piVar1 != 0);\n        iVar6 = 0;\n        do {\n            iVar2 = *(param_3 + iVar6 * 2 + 0x24);\n            *(iVar5 + iVar6 * 2) = iVar2;\n            iVar6 = iVar6 + 1;\n        } while (iVar2 != 0);\n        if ((*param_3 & 0x10) == 0) {\n            *(&stack0xfffffffffffffff0 + iVar4) = 0x140004c41;\n            iVar3 = fcn.140010e08(param_1);\n            if (iVar3 != 0) {\n                *(&stack0xfffffffffffffff0 + iVar4) = 0x140004c50;\n                (*_sym.imp.KERNEL32.dll_Sleep)(100);\n                *(&stack0xfffffffffffffff0 + iVar4) = 0x140004c58;\n                fcn.140010e08(param_1);\n            }\n        }\n        else {\n            *(&stack0xfffffffffffffff0 + iVar4) = 0x140004c2d;\n            fcn.1400053b0(&stack0x00000018 + iVar4, param_1, 0x1000, param_3);\n            *(&stack0xfffffffffffffff0 + iVar4) = 0x140004c37;\n            fcn.140004540(&stack0x00000018 + iVar4);\n        }\n    }\n    *(&stack0xfffffffffffffff0 + iVar4) = 0x140004c68;\n    fcn.140008410(*(&stack0x00001028 + iVar4) ^ &stack0xfffffffffffffff8 + iVar4);\n    return;\n}\n",
        "token_count": 680
    },
    "14000571": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.140005710(uint8_t **arg1, ulong arg2)\n\n{\n    uint8_t uVar1;\n    ulong *puVar2;\n    char cVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    char *pcVar7;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    uint16_t uVar10;\n    int64_t iVar11;\n    uint32_t uVar12;\n    uint32_t uVar13;\n    uint32_t uVar14;\n    uint64_t uVar15;\n    int32_t iVar16;\n    uint8_t *puVar17;\n    uint32_t uVar18;\n    uint64_t uVar19;\n    uint8_t *arg2_00;\n    uint32_t uVar20;\n    uint32_t uVar21;\n    int32_t iStackX24;\n    uint32_t uStackX32;\n    ulong var_30h;\n    ulong var_38h;\n    ushort uStack104;\n    uchar uStack102;\n    uchar uStack101;\n    uint32_t uStack100;\n    uint uStack96;\n    uint32_t uStack92;\n    uchar var_50h [4];\n    ulong var_4ch;\n    ulong var_40h;\n    \n    if ((((((arg1 == NULL) || (arg1[6] == NULL)) || (arg1[7] == NULL)) ||\n         ((puVar2 = arg1[5],  puVar2 == NULL || (*puVar2 != arg1)))) || (0x1f < *(puVar2 + 1) - 0x3f34U)) ||\n       ((arg1[2] == NULL || ((*arg1 == NULL && (*(arg1 + 1) != 0)))))) {\n        return -2;\n    }\n    if (*(puVar2 + 1) == 0x3f3f) {\n        *(puVar2 + 1) = 0x3f40;\n    }\n    uVar13 = *(arg1 + 3);\n    iVar4 = *(puVar2 + 1);\n    puVar17 = arg1[2];\n    uVar14 = *(arg1 + 1);\n    arg2_00 = *arg1;\n    uVar21 = *(puVar2 + 9);\n    uVar12 = *(puVar2 + 0x4c);\n    iStackX24 = 0;\n    uStackX32 = uVar13;\n    uStack100 = uVar13;\n    _var_50h = puVar17;\n    uStack92 = uVar14;\n    do {\n        if (0x1e < iVar4 - 0x3f34U) {\n            return -2;\n        }\n        uVar19 = 0;\n        uVar8 = 0;\n    // switch table (31 cases) at 0x140006e94\n        switch(*((iVar4 - 0x3f34U) * 4 + 0x140006e94) + 0x140000000) {\n        case 0x14000581d:\n            if (*(puVar2 + 2) == 0) {\n                *(puVar2 + 1) = 0x3f40;\n            }\n            else {\n                for (; uVar12 < 0x10; uVar12 = uVar12 + 8) {\n                    if (uVar14 == 0) goto code_r0x000140006d44;\n                    uVar14 = uVar14 - 1;\n                    uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                    arg2_00 = arg2_00 + 1;\n                }\n                if (((*(puVar2 + 2) & 2) == 0) || (uVar21 != 0x8b1f)) {\n                    *(puVar2 + 3) = 0;\n                    if (puVar2[5] != 0) {\n                        *(puVar2[5] + 0x40) = 0xffffffff;\n                    }\n                    if (((*(puVar2 + 2) & 1) == 0) ||\n                       (uVar8 = (uVar21 & 0xff) * 0x100 + (uVar21 >> 8), \n                       uVar8 != ((uVar8 - uVar8 / 0x1f >> 1) + uVar8 / 0x1f >> 4) * 0x1f)) {\n                        arg1[4] = \"incorrect header check\";\n                        *(puVar2 + 1) = 0x3f51;\n                    }\n                    else {\n                        if ((uVar21 & 0xf) != 8) goto code_r0x000140005908;\n                        uVar12 = uVar12 - 4;\n                        uVar8 = (uVar21 >> 4 & 0xf) + 8;\n                        if (*(puVar2 + 6) == 0) {\n                            *(puVar2 + 6) = uVar8;\n                        }\n                        if ((uVar8 < 0x10) && (uVar8 < *(puVar2 + 6) || uVar8 == *(puVar2 + 6))) {\n                            *(puVar2 + 0x1c) = 1 << uVar8;\n                            uVar5 = fcn.140007350(0, 0, 0);\n                            uVar12 = 0;\n                            *(puVar2 + 4) = uVar5;\n                            *(arg1 + 0x4c) = uVar5;\n                            *(puVar2 + 1) = ~(uVar21 >> 0xc) & 2 | 0x3f3d;\n                            uVar21 = 0;\n                            puVar17 = _var_50h;\n                            uVar13 = uStackX32;\n                        }\n                        else {\n                            arg1[4] = \"invalid window size\";\n                            *(puVar2 + 1) = 0x3f51;\n                            uVar21 = uVar21 >> 4;\n                        }\n                    }\n                }\n                else {\n                    if (*(puVar2 + 6) == 0) {\n                        *(puVar2 + 6) = 0xf;\n                    }\n                    uVar5 = fcn.140007640(0, 0, 0);\n                    *(puVar2 + 4) = uVar5;\n                    uStack104 = 0x8b1f;\n                    uVar5 = fcn.140007640(*(puVar2 + 4), &uStack104, 2);\n                    *(puVar2 + 4) = uVar5;\n                    uVar21 = 0;\n                    uVar12 = 0;\n                    *(puVar2 + 1) = 0x3f35;\n                    puVar17 = _var_50h;\n                    uVar13 = uStackX32;\n                }\n            }\n            break;\n        case 0x1400059b5:\n            for (; uVar12 < 0x10; uVar12 = uVar12 + 8) {\n                if (uVar14 == 0) goto code_r0x000140006d44;\n                uVar14 = uVar14 - 1;\n                uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                arg2_00 = arg2_00 + 1;\n            }\n            *(puVar2 + 3) = uVar21;\n            if (uVar21 == '\\b') {\n                if ((uVar21 & 0xe000) == 0) {\n                    if (puVar2[5] != NULL) {\n                        *puVar2[5] = uVar21 >> 8 & 1;\n                    }\n                    if (((*(puVar2 + 3) & 0x200) != 0) && ((*(puVar2 + 2) & 4) != 0)) {\n                        uStack104 = uVar21;\n                        uVar5 = fcn.140007640(*(puVar2 + 4), &uStack104, 2);\n                        *(puVar2 + 4) = uVar5;\n                    }\n                    *(puVar2 + 1) = 0x3f36;\n                    uVar21 = uVar8;\n                    uVar12 = uVar8;\n                    do {\n                        if (uVar14 == 0) goto code_r0x000140006d44;\n                        uVar14 = uVar14 - 1;\n                        uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                        arg2_00 = arg2_00 + 1;\n                        uVar12 = uVar12 + 8;\njoined_r0x000140005a6a:\n                    } while (uVar12 < 0x20);\n                    if (puVar2[5] != 0) {\n                        *(puVar2[5] + 4) = uVar21;\n                    }\n                    if (((*(puVar2 + 3) & 0x200) != 0) && ((*(puVar2 + 2) & 4) != 0)) {\n                        uStack104 = uVar21;\n                        uStack102 = uVar21 >> 0x10;\n                        uStack101 = uVar21 >> 0x18;\n                        uVar5 = fcn.140007640(*(puVar2 + 4), &uStack104, 4);\n                        *(puVar2 + 4) = uVar5;\n                    }\n                    *(puVar2 + 1) = 0x3f37;\n                    uVar21 = uVar8;\n                    uVar12 = uVar8;\n                    do {\n                        if (uVar14 == 0) goto code_r0x000140006d44;\n                        uVar14 = uVar14 - 1;\n                        uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                        arg2_00 = arg2_00 + 1;\n                        uVar12 = uVar12 + 8;\njoined_r0x000140005af6:\n                    } while (uVar12 < 0x10);\n                    if (puVar2[5] != 0) {\n                        *(puVar2[5] + 8) = uVar21 & 0xff;\n                        *(puVar2[5] + 0xc) = uVar21 >> 8;\n                    }\n                    if (((*(puVar2 + 3) & 0x200) != 0) && ((*(puVar2 + 2) & 4) != 0)) {\n                        uStack104 = uVar21;\n                        uVar5 = fcn.140007640(*(puVar2 + 4), &uStack104, 2);\n                        *(puVar2 + 4) = uVar5;\n                    }\n                    *(puVar2 + 1) = 0x3f38;\n                    uVar21 = uVar8;\n                    uVar12 = uVar8;\n                    goto code_r0x000140005b77;\n                }\n                arg1[4] = \"unknown header flags set\";\n                *(puVar2 + 1) = 0x3f51;\n            }\n            else {\ncode_r0x000140005908:\n                arg1[4] = \"unknown compression method\";\n                *(puVar2 + 1) = 0x3f51;\n            }\n            break;\n        case 0x140005a67:\n            goto joined_r0x000140005a6a;\n        case 0x140005af3:\n            goto joined_r0x000140005af6;\n        case 0x140005b77:\ncode_r0x000140005b77:\n            if ((*(puVar2 + 3) & 0x400) == 0) {\n                uVar8 = uVar21;\n                if (puVar2[5] != 0) {\n                    *(puVar2[5] + 0x10) = 0;\n                }\n            }\n            else {\n                for (; uVar12 < 0x10; uVar12 = uVar12 + 8) {\n                    if (uVar14 == 0) goto code_r0x000140006d44;\n                    uVar14 = uVar14 - 1;\n                    uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                    arg2_00 = arg2_00 + 1;\n                }\n                *(puVar2 + 10) = uVar21;\n                if (puVar2[5] != 0) {\n                    *(puVar2[5] + 0x18) = uVar21;\n                }\n                uVar12 = uVar8;\n                if (((*(puVar2 + 3) & 0x200) != 0) && ((*(puVar2 + 2) & 4) != 0)) {\n                    uStack104 = uVar21;\n                    uVar5 = fcn.140007640(*(puVar2 + 4), &uStack104, 2);\n                    *(puVar2 + 4) = uVar5;\n                }\n            }\n            uVar21 = uVar8;\n            *(puVar2 + 1) = 0x3f39;\n        case 0x140005c08:\n            if ((*(puVar2 + 3) & 0x400) == 0) {\ncode_r0x000140005c96:\n                *(puVar2 + 10) = 0;\n                *(puVar2 + 1) = 0x3f3a;\ncode_r0x000140005ca2:\n                if ((*(puVar2 + 3) & 0x800) == 0) {\n                    if (puVar2[5] != 0) {\n                        *(puVar2[5] + 0x20) = 0;\n                    }\ncode_r0x000140005d3b:\n                    *(puVar2 + 10) = 0;\n                    *(puVar2 + 1) = 0x3f3b;\ncode_r0x000140005d47:\n                    uVar19 = 0;\n                    if ((*(puVar2 + 3) & 0x1000) == 0) {\n                        if (puVar2[5] != 0) {\n                            *(puVar2[5] + 0x30) = 0;\n                        }\ncode_r0x000140005ddb:\n                        *(puVar2 + 1) = 0x3f3c;\n                        puVar17 = _var_50h;\n                        uVar13 = uStackX32;\ncode_r0x000140005def:\n                        if ((*(puVar2 + 3) & 0x200) != 0) {\n                            for (; uVar12 < 0x10; uVar12 = uVar12 + 8) {\n                                if (uVar14 == 0) goto code_r0x000140006d44;\n                                uVar14 = uVar14 - 1;\n                                uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                                arg2_00 = arg2_00 + 1;\n                            }\n                            if (((*(puVar2 + 2) & 4) != 0) && (uVar21 != *(puVar2 + 4))) {\n                                arg1[4] = \"header crc mismatch\";\n                                *(puVar2 + 1) = 0x3f51;\n                                break;\n                            }\n                            uVar21 = 0;\n                            uVar12 = uVar21;\n                        }\n                        if (puVar2[5] != 0) {\n                            *(puVar2[5] + 0x3c) = *(puVar2 + 3) >> 9 & 1;\n                            *(puVar2[5] + 0x40) = 1;\n                        }\n                        uVar5 = fcn.140007640(0, 0, 0);\n                        *(puVar2 + 4) = uVar5;\n                        *(arg1 + 0x4c) = uVar5;\ncode_r0x000140005e80:\n                        *(puVar2 + 1) = 0x3f3f;\n                        puVar17 = _var_50h;\n                        uVar13 = uStackX32;\n                        break;\n                    }\n                    if (uVar14 != 0) {\n                        do {\n                            uVar13 = uVar19 + 1;\n                            uVar15 = uVar13;\n                            uVar1 = arg2_00[uVar19];\n                            iVar11 = puVar2[5];\n                            if (((iVar11 != 0) && (*(iVar11 + 0x30) != 0)) && (*(puVar2 + 10) < *(iVar11 + 0x38))) {\n                                *(*(puVar2 + 10) + *(iVar11 + 0x30)) = uVar1;\n                                *(puVar2 + 10) = *(puVar2 + 10) + 1;\n                            }\n                        } while ((uVar1 != 0) && (uVar19 = uVar15,  uVar13 < uVar14));\n                        if (((*(puVar2 + 3) & 0x200) != 0) && ((*(puVar2 + 2) & 4) != 0)) {\n                            uVar5 = fcn.140007640(*(puVar2 + 4), arg2_00, uVar15);\n                            *(puVar2 + 4) = uVar5;\n                        }\n                        uVar14 = uVar14 - uVar13;\n                        arg2_00 = arg2_00 + uVar15;\n                        if (uVar1 == 0) goto code_r0x000140005ddb;\n                    }\n                }\n                else if (uVar14 != 0) {\n                    do {\n                        uVar13 = uVar19 + 1;\n                        uVar15 = uVar13;\n                        uVar1 = arg2_00[uVar19];\n                        iVar11 = puVar2[5];\n                        if (((iVar11 != 0) && (*(iVar11 + 0x20) != 0)) && (*(puVar2 + 10) < *(iVar11 + 0x28))) {\n                            *(*(puVar2 + 10) + *(iVar11 + 0x20)) = uVar1;\n                            *(puVar2 + 10) = *(puVar2 + 10) + 1;\n                        }\n                    } while ((uVar1 != 0) && (uVar19 = uVar15,  uVar13 < uVar14));\n                    if (((*(puVar2 + 3) & 0x200) != 0) && ((*(puVar2 + 2) & 4) != 0)) {\n                        uVar5 = fcn.140007640(*(puVar2 + 4), arg2_00, uVar15);\n                        *(puVar2 + 4) = uVar5;\n                    }\n                    uVar14 = uVar14 - uVar13;\n                    arg2_00 = arg2_00 + uVar15;\n                    if (uVar1 == 0) goto code_r0x000140005d3b;\n                }\n            }\n            else {\n                uVar13 = *(puVar2 + 10);\n                uVar8 = uVar13;\n                if (uVar14 < uVar13) {\n                    uVar8 = uVar14;\n                }\n                if (uVar8 != 0) {\n                    iVar11 = puVar2[5];\n                    if ((iVar11 != 0) && (*(iVar11 + 0x10) != 0)) {\n                        uVar13 = *(iVar11 + 0x18) - uVar13;\n                        uVar18 = uVar8;\n                        if (*(iVar11 + 0x1c) < uVar8 + uVar13) {\n                            uVar18 = *(iVar11 + 0x1c) - uVar13;\n                        }\n                        fcn.140009570(uVar13 + *(iVar11 + 0x10), arg2_00, uVar18);\n                    }\n                    if (((*(puVar2 + 3) & 0x200) != 0) && ((*(puVar2 + 2) & 4) != 0)) {\n                        uVar5 = fcn.140007640(*(puVar2 + 4), arg2_00, uVar8);\n                        *(puVar2 + 4) = uVar5;\n                    }\n                    uVar14 = uVar14 - uVar8;\n                    arg2_00 = arg2_00 + uVar8;\n                    *(puVar2 + 10) = *(puVar2 + 10) - uVar8;\n                }\n                if (*(puVar2 + 10) == 0) goto code_r0x000140005c96;\n            }\ncode_r0x000140006d44:\n            uVar13 = uStack100;\n            arg1[2] = _var_50h;\n            *(arg1 + 3) = uStackX32;\n            *arg1 = arg2_00;\n            *(arg1 + 1) = uVar14;\n            *(puVar2 + 0x4c) = uVar12;\n            *(puVar2 + 9) = uVar21;\n            if (((*(puVar2 + 0x34) == 0) &&\n                (((uStack100 == *(arg1 + 3) || (0x3f50 < *(puVar2 + 1))) || ((0x3f4d < *(puVar2 + 1) && (arg2 == 4))))))\n               || (iVar4 = fcn.140007250(arg1, arg1[2], uStack100 - *(arg1 + 3)),  iVar4 == 0)) {\n                uVar13 = uVar13 - *(arg1 + 3);\n                uStack92 = uStack92 - *(arg1 + 1);\n                *(arg1 + 0xc) = *(arg1 + 0xc) + uStack92;\n                *(arg1 + 0x1c) = *(arg1 + 0x1c) + uVar13;\n                *(puVar2 + 0x24) = *(puVar2 + 0x24) + uVar13;\n                if (((*(puVar2 + 2) & 4) != 0) && (uVar13 != 0)) {\n                    if (*(puVar2 + 3) == 0) {\n                        uVar5 = fcn.140007350(*(puVar2 + 4), arg1[2] - uVar13, uVar13);\n                    }\n                    else {\n                        uVar5 = fcn.140007640(*(puVar2 + 4), arg1[2] - uVar13, uVar13);\n                    }\n                    *(puVar2 + 4) = uVar5;\n                    *(arg1 + 0x4c) = uVar5;\n                }\n                iVar4 = *(puVar2 + 1);\n                if ((iVar4 == 0x3f47) || (iVar4 == 0x3f42)) {\n                    iVar16 = 0x100;\n                }\n                else {\n                    iVar16 = 0;\n                }\n                iVar6 = 0;\n                if (iVar4 == 0x3f3f) {\n                    iVar6 = 0x80;\n                }\n                *(arg1 + 9) = iVar6 + iVar16 + (-(*(puVar2 + 0xc) != 0) & 0x40) + *(puVar2 + 0x4c);\n                if (((uStack92 != 0) || (uVar13 != 0)) && (arg2 != 4)) {\n                    return iStackX24;\n                }\n                if (iStackX24 != 0) {\n                    return iStackX24;\n                }\n                return -5;\n            }\n            *(puVar2 + 1) = 0x3f52;\ncode_r0x000140006ceb:\n            return -4;\n        case 0x140005ca2:\n            goto code_r0x000140005ca2;\n        case 0x140005d47:\n            goto code_r0x000140005d47;\n        case 0x140005def:\n            goto code_r0x000140005def;\n        case 0x140005eae:\n            for (; uVar12 < 0x20; uVar12 = uVar12 + 8) {\n                if (uVar14 == 0) goto code_r0x000140006d44;\n                uVar14 = uVar14 - 1;\n                uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                arg2_00 = arg2_00 + 1;\n            }\n            iVar4 = (uVar21 >> 8 & 0xff00) + ((uVar21 & 0xff00) + uVar21 * 0x10000) * 0x100 + (uVar21 >> 0x18);\n            *(puVar2 + 4) = iVar4;\n            *(arg1 + 0x4c) = iVar4;\n            *(puVar2 + 1) = 0x3f3e;\n            uVar21 = uVar8;\n            uVar12 = uVar8;\n        case 0x140005f10:\n            if (*(puVar2 + 0x14) == 0) {\n                arg1[2] = puVar17;\n                *(arg1 + 3) = uVar13;\n                *arg1 = arg2_00;\n                *(arg1 + 1) = uVar14;\n                *(puVar2 + 9) = uVar21;\n                *(puVar2 + 0x4c) = uVar12;\n                return 2;\n            }\n            uVar5 = fcn.140007350(0, 0, 0);\n            *(puVar2 + 4) = uVar5;\n            *(arg1 + 0x4c) = uVar5;\n            *(puVar2 + 1) = 0x3f3f;\n            puVar17 = _var_50h;\n            uVar13 = uStackX32;\ncode_r0x000140005f46:\n            if (1 < arg2 - 5U) {\ncode_r0x000140005f55:\n                if (*(puVar2 + 0xc) == 0) {\n                    for (; uVar12 < 3; uVar12 = uVar12 + 8) {\n                        if (uVar14 == 0) goto code_r0x000140006d44;\n                        uVar14 = uVar14 - 1;\n                        uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                        arg2_00 = arg2_00 + 1;\n                    }\n                    *(puVar2 + 0xc) = uVar21 & 1;\n                    uVar8 = uVar21 >> 1 & 3;\n                    if (uVar8 == 0) {\n                        *(puVar2 + 1) = 0x3f41;\n                    }\n                    else {\n                        if (uVar8 != 1) {\n                            if (uVar8 == 2) {\n                                uVar12 = uVar12 - 3;\n                                *(puVar2 + 1) = 0x3f44;\n                                uVar21 = uVar21 >> 3;\n                            }\n                            else {\n                                if (uVar8 != 3) goto code_r0x00014000603c;\n                                arg1[4] = \"invalid block type\";\n                                uVar12 = uVar12 - 3;\n                                *(puVar2 + 1) = 0x3f51;\n                                uVar21 = uVar21 >> 3;\n                            }\n                            break;\n                        }\n                        puVar2[0xc] = 0x140023da0;\n                        puVar2[0xd] = 0x1400245a0;\n                        *(puVar2 + 0xe) = 9;\n                        *(puVar2 + 0x74) = 5;\n                        *(puVar2 + 1) = 0x3f47;\n                        if (arg2 == 6) {\n                            uVar21 = uVar21 >> 3;\n                            uVar12 = uVar12 - 3;\n                            goto code_r0x000140006d44;\n                        }\n                    }\ncode_r0x00014000603c:\n                    uVar12 = uVar12 - 3;\n                    uVar21 = uVar21 >> 3;\n                }\n                else {\n                    *(puVar2 + 1) = 0x3f4e;\n                    uVar8 = uVar12 & 7;\n                    uVar12 = uVar12 - uVar8;\n                    uVar21 = uVar21 >> uVar8;\n                }\n                break;\n            }\n            goto code_r0x000140006d44;\n        case 0x140005f46:\n            goto code_r0x000140005f46;\n        case 0x140005f55:\n            goto code_r0x000140005f55;\n        case 0x140006048:\n            uVar21 = uVar21 >> (uVar12 & 7);\n            for (uVar12 = uVar12 - (uVar12 & 7); uVar12 < 0x20; uVar12 = uVar12 + 8) {\n                if (uVar14 == 0) goto code_r0x000140006d44;\n                uVar14 = uVar14 - 1;\n                uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                arg2_00 = arg2_00 + 1;\n            }\n            if ((uVar21 & 0xffff) == ~uVar21 >> 0x10) {\n                *(puVar2 + 10) = uVar21 & 0xffff;\n                *(puVar2 + 1) = 0x3f42;\n                uVar21 = uVar8;\n                uVar12 = uVar8;\n                if (arg2 != 6) goto code_r0x0001400060bd;\n                goto code_r0x000140006d44;\n            }\n            arg1[4] = \"invalid stored block lengths\";\n            *(puVar2 + 1) = 0x3f51;\n            break;\n        case 0x1400060bd:\ncode_r0x0001400060bd:\n            *(puVar2 + 1) = 0x3f43;\n        case 0x1400060c5:\n            uVar8 = *(puVar2 + 10);\n            if (uVar8 == 0) {\n                *(puVar2 + 1) = 0x3f3f;\n                break;\n            }\n            if (uVar14 < uVar8) {\n                uVar8 = uVar14;\n            }\n            if (uVar13 < uVar8) {\n                uVar8 = uVar13;\n            }\n            uVar19 = uVar8;\n            if (uVar8 != 0) {\n                fcn.140009570(puVar17, arg2_00, uVar19);\n                arg2_00 = arg2_00 + uVar19;\n                uStackX32 = uStackX32 - uVar8;\n                _var_50h = _var_50h + uVar19;\n                uVar14 = uVar14 - uVar8;\n                *(puVar2 + 10) = *(puVar2 + 10) - uVar8;\n                puVar17 = _var_50h;\n                uVar13 = uStackX32;\n                break;\n            }\n            goto code_r0x000140006d44;\n        case 0x14000612c:\n            for (; uVar12 < 0xe; uVar12 = uVar12 + 8) {\n                if (uVar14 == 0) goto code_r0x000140006d44;\n                uVar14 = uVar14 - 1;\n                uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                arg2_00 = arg2_00 + 1;\n            }\n            uVar12 = uVar12 - 0xe;\n            uVar18 = uVar21 >> 5;\n            uVar8 = (uVar21 & 0x1f) + 0x101;\n            uVar20 = uVar21 >> 10;\n            *(puVar2 + 0x7c) = uVar8;\n            uVar21 = uVar21 >> 0xe;\n            uVar18 = (uVar18 & 0x1f) + 1;\n            *(puVar2 + 0x10) = uVar18;\n            *(puVar2 + 0xf) = (uVar20 & 0xf) + 4;\n            if ((uVar8 < 0x11f) && (uVar18 < 0x1f)) {\n                *(puVar2 + 0x84) = 0;\n                *(puVar2 + 1) = 0x3f45;\n                goto code_r0x0001400061b0;\n            }\n            arg1[4] = \"too many length or distance symbols\";\n            *(puVar2 + 1) = 0x3f51;\n            break;\n        case 0x1400061b0:\ncode_r0x0001400061b0:\n            if (*(puVar2 + 0x84) < *(puVar2 + 0xf)) {\n                do {\n                    for (; uVar12 < 3; uVar12 = uVar12 + 8) {\n                        if (uVar14 == 0) goto code_r0x000140006d44;\n                        uVar14 = uVar14 - 1;\n                        uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                        arg2_00 = arg2_00 + 1;\n                    }\n                    uVar10 = uVar21;\n                    uVar21 = uVar21 >> 3;\n                    uVar12 = uVar12 - 3;\n                    *(puVar2 + *(*(puVar2 + 0x84) * 2 + 0x140024620) * 2 + 0x90) = uVar10 & 7;\n                    *(puVar2 + 0x84) = *(puVar2 + 0x84) + 1;\n                } while (*(puVar2 + 0x84) < *(puVar2 + 0xf));\n            }\n            uVar13 = *(puVar2 + 0x84);\n            while (uVar13 < 0x13) {\n                *(puVar2 + *(*(puVar2 + 0x84) * 2 + 0x140024620) * 2 + 0x90) = 0;\n                *(puVar2 + 0x84) = *(puVar2 + 0x84) + 1;\n                uVar13 = *(puVar2 + 0x84);\n            }\n            *(puVar2 + 0xe) = 7;\n            puVar2[0xc] = puVar2 + 0xaa;\n            puVar2[0x11] = puVar2 + 0xaa;\n            iStackX24 = fcn.140007980(0, puVar2 + 0x12, 0x13, puVar2 + 0x11);\n            if (iStackX24 == 0) {\n                *(puVar2 + 0x84) = 0;\n                *(puVar2 + 1) = 0x3f46;\n                uVar13 = uStackX32;\n                goto code_r0x0001400062f6;\n            }\n            arg1[4] = \"invalid code lengths set\";\n            *(puVar2 + 1) = 0x3f51;\n            puVar17 = _var_50h;\n            uVar13 = uStackX32;\n            break;\n        case 0x1400062f6:\ncode_r0x0001400062f6:\n            puVar17 = _var_50h;\n            if (*(puVar2 + 0x84) < *(puVar2 + 0x10) + *(puVar2 + 0x7c)) {\n                do {\n                    uStack96 = *(puVar2[0xc] + ((1 << (*(puVar2 + 0xe) & 0x1f)) - 1U & uVar21) * 4);\n                    if (uVar12 < (uStack96 >> 8 & 0xff)) {\n                        do {\n                            if (uVar14 == 0) goto code_r0x000140006d44;\n                            uVar14 = uVar14 - 1;\n                            uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                            arg2_00 = arg2_00 + 1;\n                            uVar12 = uVar12 + 8;\n                            uStack96 = *(puVar2[0xc] + ((1 << (*(puVar2 + 0xe) & 0x1f)) - 1U & uVar21) * 4);\n                        } while (uVar12 < (uStack96 >> 8 & 0xff));\n                    }\n                    uVar10 = uStack96 >> 0x10;\n                    if (0xf < uVar10) {\n                        uStack96._1_1_ = uStack96 >> 8;\n                        if (uVar10 == 0x10) {\n                            for (; uVar12 < (uStack96 >> 8 & 0xff) + 2; uVar12 = uVar12 + 8) {\n                                if (uVar14 == 0) goto code_r0x000140006d44;\n                                uVar14 = uVar14 - 1;\n                                uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                                arg2_00 = arg2_00 + 1;\n                            }\n                            uVar12 = uVar12 - uStack96._1_1_;\n                            uVar21 = uVar21 >> (uStack96._1_1_ & 0x1f);\n                            if (*(puVar2 + 0x84) != 0) {\n                                uVar8 = uVar21 & 3;\n                                uVar21 = uVar21 >> 2;\n                                iVar16 = uVar8 + 3;\n                                uVar12 = uVar12 - 2;\n                                uVar15 = *(puVar2 + (*(puVar2 + 0x84) - 1) * 2 + 0x90);\n                                goto code_r0x0001400064c4;\n                            }\n                        }\n                        else {\n                            if (uVar10 == 0x11) {\n                                for (; uVar12 < uStack96._1_1_ + 3; uVar12 = uVar12 + 8) {\n                                    if (uVar14 == 0) goto code_r0x000140006d44;\n                                    uVar14 = uVar14 - 1;\n                                    uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                                    arg2_00 = arg2_00 + 1;\n                                }\n                                iVar4 = -3;\n                                uVar21 = uVar21 >> (uStack96._1_1_ & 0x1f);\n                                iVar16 = (uVar21 & 7) + 3;\n                                uVar21 = uVar21 >> 3;\n                            }\n                            else {\n                                for (; uVar12 < uStack96._1_1_ + 7; uVar12 = uVar12 + 8) {\n                                    if (uVar14 == 0) goto code_r0x000140006d44;\n                                    uVar14 = uVar14 - 1;\n                                    uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                                    arg2_00 = arg2_00 + 1;\n                                }\n                                iVar4 = -7;\n                                uVar21 = uVar21 >> (uStack96._1_1_ & 0x1f);\n                                iVar16 = (uVar21 & 0x7f) + 0xb;\n                                uVar21 = uVar21 >> 7;\n                            }\n                            uVar12 = uVar12 + (iVar4 - uStack96._1_1_);\n                            uVar15 = uVar19;\ncode_r0x0001400064c4:\n                            if (*(puVar2 + 0x84) + iVar16 <= *(puVar2 + 0x10) + *(puVar2 + 0x7c)) {\n                                do {\n                                    *(puVar2 + *(puVar2 + 0x84) * 2 + 0x90) = uVar15;\n                                    *(puVar2 + 0x84) = *(puVar2 + 0x84) + 1;\n                                    uVar8 = *(puVar2 + 0x84);\n                                    iVar16 = iVar16 + -1;\n                                } while (iVar16 != 0);\n                                goto code_r0x000140006508;\n                            }\n                        }\n                        arg1[4] = \"invalid bit length repeat\";\n                        *(puVar2 + 1) = 0x3f51;\n                        goto code_r0x000140005e90;\n                    }\n                    uVar8 = uStack96 >> 8 & 0xff;\n                    uVar12 = uVar12 - uVar8;\n                    uVar21 = uVar21 >> (uVar8 & 0x1f);\n                    *(puVar2 + *(puVar2 + 0x84) * 2 + 0x90) = uVar10;\n                    *(puVar2 + 0x84) = *(puVar2 + 0x84) + 1;\n                    uVar8 = *(puVar2 + 0x84);\ncode_r0x000140006508:\n                } while (uVar8 < *(puVar2 + 0x10) + *(puVar2 + 0x7c));\n            }\n            if (*(puVar2 + 1) != 0x3f51) {\n                if (*(puVar2 + 0x52) == 0) {\n                    arg1[4] = \"invalid code -- missing end-of-block\";\n                    *(puVar2 + 1) = 0x3f51;\n                }\n                else {\n                    *(puVar2 + 0xe) = 9;\n                    puVar2[0x11] = puVar2 + 0xaa;\n                    puVar2[0xc] = puVar2 + 0xaa;\n                    iStackX24 = fcn.140007980(1, puVar2 + 0x12, *(puVar2 + 0x7c), puVar2 + 0x11);\n                    if (iStackX24 == 0) {\n                        puVar2[0xd] = puVar2[0x11];\n                        *(puVar2 + 0x74) = 6;\n                        iStackX24 = fcn.140007980(2, *(puVar2 + 0x7c) * 2 + 0x90 + puVar2, *(puVar2 + 0x10), \n                                                  puVar2 + 0x11);\n                        if (iStackX24 == 0) {\n                            *(puVar2 + 1) = 0x3f47;\n                            puVar17 = _var_50h;\n                            uVar13 = uStackX32;\n                            if (arg2 != 6) goto code_r0x000140006651;\n                            goto code_r0x000140006d44;\n                        }\n                        pcVar7 = \"invalid distances set\";\n                    }\n                    else {\n                        pcVar7 = \"invalid literal/lengths set\";\n                    }\n                    arg1[4] = pcVar7;\n                    *(puVar2 + 1) = 0x3f51;\n                    puVar17 = _var_50h;\n                    uVar13 = uStackX32;\n                }\n            }\n            break;\n        case 0x140006651:\ncode_r0x000140006651:\n            *(puVar2 + 1) = 0x3f48;\n        case 0x140006659:\n            if ((5 < uVar14) && (0x101 < uVar13)) {\n                arg1[2] = puVar17;\n                *(arg1 + 3) = uVar13;\n                *arg1 = arg2_00;\n                *(arg1 + 1) = uVar14;\n                *(puVar2 + 9) = uVar21;\n                *(puVar2 + 0x4c) = uVar12;\n                fcn.140007e90(arg1, uStack100);\n                _var_50h = arg1[2];\n                uStackX32 = *(arg1 + 3);\n                arg2_00 = *arg1;\n                uVar14 = *(arg1 + 1);\n                uVar12 = *(puVar2 + 0x4c);\n                puVar17 = _var_50h;\n                uVar13 = uStackX32;\n                uVar21 = *(puVar2 + 9);\n                if (*(puVar2 + 1) == 0x3f3f) {\n                    *(puVar2 + 0x1be4) = 0xffffffff;\n                }\n                break;\n            }\n            *(puVar2 + 0x1be4) = 0;\n            uVar13 = *(puVar2[0xc] + ((1 << (*(puVar2 + 0xe) & 0x1f)) - 1U & uVar21) * 4);\n            if (uVar12 < (uVar13 >> 8 & 0xff)) {\n                do {\n                    if (uVar14 == 0) goto code_r0x000140006d44;\n                    uVar14 = uVar14 - 1;\n                    uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                    arg2_00 = arg2_00 + 1;\n                    uVar12 = uVar12 + 8;\n                    uVar13 = *(puVar2[0xc] + ((1 << (*(puVar2 + 0xe) & 0x1f)) - 1U & uVar21) * 4);\n                } while (uVar12 < (uVar13 >> 8 & 0xff));\n            }\n            cVar3 = uVar13;\n            uVar8 = uVar13;\n            if ((cVar3 != '\\0') && ((uVar13 & 0xf0) == 0)) {\n                uVar1 = uVar13 >> 8;\n                uVar8 = *(puVar2[0xc] +\n                         ((((1 << (cVar3 + uVar1 & 0x1f)) - 1U & uVar21) >> (uVar1 & 0x1f)) + (uVar13 >> 0x10)) * 4);\n                uStack96 = uVar13;\n                if (uVar12 < (uVar8 >> 8 & 0xff) + (uVar13 >> 8 & 0xff)) {\n                    do {\n                        if (uVar14 == 0) goto code_r0x000140006d44;\n                        uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                        uVar14 = uVar14 - 1;\n                        arg2_00 = arg2_00 + 1;\n                        uVar12 = uVar12 + 8;\n                        uVar8 = *(puVar2[0xc] +\n                                 ((((1 << (cVar3 + uVar1 & 0x1f)) - 1U & uVar21) >> (uVar1 & 0x1f)) + (uVar13 >> 0x10))\n                                 * 4);\n                    } while (uVar12 < (uVar8 >> 8 & 0xff) + uVar1);\n                }\n                uVar21 = uVar21 >> (uVar1 & 0x1f);\n                uVar12 = uVar12 - uVar1;\n                *(puVar2 + 0x1be4) = uVar1;\n            }\n            uVar13 = uVar8 >> 8 & 0xff;\n            *(puVar2 + 0x1be4) = *(puVar2 + 0x1be4) + uVar13;\n            uVar12 = uVar12 - uVar13;\n            uVar21 = uVar21 >> (uVar13 & 0x1f);\n            *(puVar2 + 10) = uVar8 >> 0x10;\n            puVar17 = _var_50h;\n            if (uVar8 == '\\0') {\n                *(puVar2 + 1) = 0x3f4d;\n                uVar13 = uStackX32;\n                break;\n            }\n            if ((uVar8 & 0x20) != 0) {\n                *(puVar2 + 0x1be4) = 0xffffffff;\n                goto code_r0x000140005e80;\n            }\n            if ((uVar8 & 0x40) != 0) {\n                arg1[4] = \"invalid literal/length code\";\n                *(puVar2 + 1) = 0x3f51;\n                uVar13 = uStackX32;\n                break;\n            }\n            *(puVar2 + 1) = 0x3f49;\n            *(puVar2 + 0xb) = uVar8 & 0xf;\ncode_r0x000140006871:\n            uVar13 = *(puVar2 + 0xb);\n            if (uVar13 != 0) {\n                for (; uVar12 < uVar13; uVar12 = uVar12 + 8) {\n                    if (uVar14 == 0) goto code_r0x000140006d44;\n                    uVar14 = uVar14 - 1;\n                    uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                    arg2_00 = arg2_00 + 1;\n                }\n                uVar12 = uVar12 - uVar13;\n                uVar8 = (1 << (uVar13 & 0x1f)) - 1U & uVar21;\n                uVar21 = uVar21 >> (uVar13 & 0x1f);\n                *(puVar2 + 10) = *(puVar2 + 10) + uVar8;\n                *(puVar2 + 0x1be4) = *(puVar2 + 0x1be4) + uVar13;\n            }\n            *(puVar2 + 0x37d) = *(puVar2 + 10);\n            *(puVar2 + 1) = 0x3f4a;\ncode_r0x0001400068d4:\n            uVar13 = *(puVar2[0xd] + ((1 << (*(puVar2 + 0x74) & 0x1f)) - 1U & uVar21) * 4);\n            if (uVar12 < (uVar13 >> 8 & 0xff)) {\n                do {\n                    if (uVar14 == 0) goto code_r0x000140006d44;\n                    uVar14 = uVar14 - 1;\n                    uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                    arg2_00 = arg2_00 + 1;\n                    uVar12 = uVar12 + 8;\n                    uVar13 = *(puVar2[0xd] + ((1 << (*(puVar2 + 0x74) & 0x1f)) - 1U & uVar21) * 4);\n                } while (uVar12 < (uVar13 >> 8 & 0xff));\n            }\n            uVar8 = uVar13;\n            if ((uVar13 & 0xf0) == 0) {\n                uVar1 = uVar13 >> 8;\n                uVar8 = *(puVar2[0xd] +\n                         ((((1 << (uVar13 + uVar1 & 0x1f)) - 1U & uVar21) >> (uVar1 & 0x1f)) + (uVar13 >> 0x10)) * 4);\n                uStack96 = uVar13;\n                if (uVar12 < (uVar8 >> 8 & 0xff) + (uVar13 >> 8 & 0xff)) {\n                    do {\n                        if (uVar14 == 0) goto code_r0x000140006d44;\n                        uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                        uVar14 = uVar14 - 1;\n                        arg2_00 = arg2_00 + 1;\n                        uVar12 = uVar12 + 8;\n                        uVar8 = *(puVar2[0xd] +\n                                 ((((1 << (uVar13 + uVar1 & 0x1f)) - 1U & uVar21) >> (uVar1 & 0x1f)) + (uVar13 >> 0x10))\n                                 * 4);\n                    } while (uVar12 < (uVar8 >> 8 & 0xff) + uVar1);\n                }\n                uVar21 = uVar21 >> (uVar1 & 0x1f);\n                uVar12 = uVar12 - uVar1;\n                *(puVar2 + 0x1be4) = *(puVar2 + 0x1be4) + uVar1;\n            }\n            uVar13 = uVar8 >> 8 & 0xff;\n            *(puVar2 + 0x1be4) = *(puVar2 + 0x1be4) + uVar13;\n            uVar12 = uVar12 - uVar13;\n            uVar21 = uVar21 >> (uVar13 & 0x1f);\n            puVar17 = _var_50h;\n            if ((uVar8 & 0x40) != 0) {\n                arg1[4] = \"invalid distance code\";\n                *(puVar2 + 1) = 0x3f51;\n                uVar13 = uStackX32;\n                break;\n            }\n            *(puVar2 + 0x54) = uVar8 >> 0x10;\n            *(puVar2 + 1) = 0x3f4b;\n            *(puVar2 + 0xb) = uVar8 & 0xf;\n            uVar13 = uStackX32;\ncode_r0x000140006a61:\n            uVar8 = *(puVar2 + 0xb);\n            if (uVar8 != 0) {\n                for (; uVar12 < uVar8; uVar12 = uVar12 + 8) {\n                    if (uVar14 == 0) goto code_r0x000140006d44;\n                    uVar14 = uVar14 - 1;\n                    uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                    arg2_00 = arg2_00 + 1;\n                }\n                uVar12 = uVar12 - uVar8;\n                uVar18 = (1 << (uVar8 & 0x1f)) - 1U & uVar21;\n                uVar21 = uVar21 >> (uVar8 & 0x1f);\n                *(puVar2 + 0x54) = *(puVar2 + 0x54) + uVar18;\n                *(puVar2 + 0x1be4) = *(puVar2 + 0x1be4) + uVar8;\n            }\n            *(puVar2 + 1) = 0x3f4c;\ncode_r0x000140006ab5:\n            if (uVar13 != 0) {\n                uVar8 = *(puVar2 + 0x54);\n                if (uStack100 - uVar13 < uVar8) {\n                    uVar8 = uVar8 - (uStack100 - uVar13);\n                    if ((*(puVar2 + 7) <= uVar8 && uVar8 != *(puVar2 + 7)) && (*(puVar2 + 0x37c) != 0)) {\n                        arg1[4] = \"invalid distance too far back\";\n                        *(puVar2 + 1) = 0x3f51;\n                        break;\n                    }\n                    uVar18 = *(puVar2 + 0x3c);\n                    if (uVar18 < uVar8) {\n                        uVar8 = uVar8 - uVar18;\n                        uVar18 = *(puVar2 + 0x34) - uVar8;\n                    }\n                    else {\n                        uVar18 = uVar18 - uVar8;\n                    }\n                    iVar11 = uVar18 + puVar2[8];\n                    uVar18 = *(puVar2 + 10);\n                    if (uVar18 < uVar8) goto code_r0x000140006b24;\n                }\n                else {\n                    iVar11 = puVar17 - uVar8;\n                    uVar18 = *(puVar2 + 10);\ncode_r0x000140006b24:\n                    uVar8 = uVar18;\n                    uVar18 = uVar8;\n                }\n                if (uVar13 < uVar8) {\n                    uVar8 = uVar13;\n                }\n                uStackX32 = uVar13 - uVar8;\n                iVar11 = iVar11 - puVar17;\n                *(puVar2 + 10) = uVar18 - uVar8;\n                do {\n                    *puVar17 = puVar17[iVar11];\n                    puVar17 = puVar17 + 1;\n                    uVar8 = uVar8 - 1;\n                } while (uVar8 != 0);\n                uVar13 = uStackX32;\n                _var_50h = puVar17;\n                if (*(puVar2 + 10) == 0) {\n                    *(puVar2 + 1) = 0x3f48;\n                }\n                break;\n            }\n            goto code_r0x000140006d44;\n        case 0x140006871:\n            goto code_r0x000140006871;\n        case 0x1400068d4:\n            goto code_r0x0001400068d4;\n        case 0x140006a61:\n            goto code_r0x000140006a61;\n        case 0x140006ab5:\n            goto code_r0x000140006ab5;\n        case 0x140006b6b:\n            if (uVar13 == 0) goto code_r0x000140006d44;\n            *puVar17 = *(puVar2 + 10);\n            puVar17 = puVar17 + 1;\n            uStackX32 = uVar13 - 1;\n            *(puVar2 + 1) = 0x3f48;\n            uVar13 = uStackX32;\n            _var_50h = puVar17;\n            break;\n        case 0x140006b97:\n            uVar18 = uVar21;\n            uVar20 = uVar12;\n            if (*(puVar2 + 2) != 0) {\n                for (; uVar12 < 0x20; uVar12 = uVar12 + 8) {\n                    if (uVar14 == 0) goto code_r0x000140006d44;\n                    uVar14 = uVar14 - 1;\n                    uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                    arg2_00 = arg2_00 + 1;\n                }\n                uVar18 = uStack100 - uVar13;\n                *(arg1 + 0x1c) = *(arg1 + 0x1c) + uVar18;\n                *(puVar2 + 0x24) = *(puVar2 + 0x24) + uVar18;\n                if (((*(puVar2 + 2) & 4) != 0) && (uVar18 != 0)) {\n                    if (*(puVar2 + 3) == 0) {\n                        uVar5 = fcn.140007350(*(puVar2 + 4), puVar17 - uVar18, uVar18);\n                    }\n                    else {\n                        uVar5 = fcn.140007640(*(puVar2 + 4), puVar17 - uVar18, uVar18);\n                    }\n                    *(puVar2 + 4) = uVar5;\n                    *(arg1 + 0x4c) = uVar5;\n                    puVar17 = _var_50h;\n                    uVar13 = uStackX32;\n                }\n                uVar18 = uVar8;\n                uVar20 = uVar8;\n                uStack100 = uVar13;\n                if ((*(puVar2 + 2) & 4) != 0) {\n                    uVar9 = uVar21;\n                    if (*(puVar2 + 3) == 0) {\n                        uVar9 = ((uVar21 & 0xff00) + uVar21 * 0x10000) * 0x100 + (uVar21 >> 8 & 0xff00) +\n                                (uVar21 >> 0x18);\n                    }\n                    if (uVar9 != *(puVar2 + 4)) {\n                        arg1[4] = \"incorrect data check\";\n                        *(puVar2 + 1) = 0x3f51;\n                        break;\n                    }\n                }\n            }\n            uVar12 = uVar20;\n            uVar21 = uVar18;\n            *(puVar2 + 1) = 0x3f4f;\n        case 0x140006c77:\n            uVar18 = uVar21;\n            uVar20 = uVar12;\n            if ((*(puVar2 + 2) != 0) && (*(puVar2 + 3) != 0)) {\n                for (; uVar12 < 0x20; uVar12 = uVar12 + 8) {\n                    if (uVar14 == 0) goto code_r0x000140006d44;\n                    uVar14 = uVar14 - 1;\n                    uVar21 = uVar21 + (*arg2_00 << (uVar12 & 0x1f));\n                    arg2_00 = arg2_00 + 1;\n                }\n                uVar18 = uVar8;\n                uVar20 = uVar8;\n                if (uVar21 != *(puVar2 + 0x24)) {\n                    arg1[4] = \"incorrect length check\";\n                    *(puVar2 + 1) = 0x3f51;\n                    break;\n                }\n            }\n            uVar12 = uVar20;\n            uVar21 = uVar18;\n            *(puVar2 + 1) = 0x3f50;\ncode_r0x000140006d1e:\n            iStackX24 = 1;\n            goto code_r0x000140006d44;\n        case 0x140006d1e:\n            goto code_r0x000140006d1e;\n        case 0x140006d29:\n            iStackX24 = -3;\n            goto code_r0x000140006d44;\n        case 0x140006da9:\n            goto code_r0x000140006ceb;\n        }\ncode_r0x000140005e90:\n        iVar4 = *(puVar2 + 1);\n    } while( true );\n}\n",
        "token_count": 14234
    },
    "140006f1": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.140006f10(int64_t arg1)\n\n{\n    int64_t *piVar1;\n    \n    if ((((arg1 != 0) && (*(arg1 + 0x30) != 0)) && (*(arg1 + 0x38) != NULL)) &&\n       (((piVar1 = *(arg1 + 0x28),  piVar1 != NULL && (*piVar1 == arg1)) && (*(piVar1 + 1) - 0x3f34U < 0x20)))) {\n        if (piVar1[8] != 0) {\n            (**(arg1 + 0x38))(*(arg1 + 0x40));\n        }\n        (**(arg1 + 0x38))(*(arg1 + 0x40), *(arg1 + 0x28));\n        *(arg1 + 0x28) = 0;\n        return 0;\n    }\n    return 0xfffffffe;\n}\n",
        "token_count": 211
    },
    "14000708": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.140007080(int64_t arg1, ulong arg2)\n\n{\n    int64_t *piVar1;\n    ulong uVar2;\n    int32_t iVar3;\n    \n    if ((((arg1 == 0) || (*(arg1 + 0x30) == 0)) || (*(arg1 + 0x38) == NULL)) ||\n       (((piVar1 = *(arg1 + 0x28),  piVar1 == NULL || (*piVar1 != arg1)) || (0x1f < *(piVar1 + 1) - 0x3f34U)))) {\n        return 0xfffffffe;\n    }\n    iVar3 = 0;\n    if (arg2 < 0) {\n        arg2._0_4_ = -arg2;\n    }\n    else {\n        iVar3 = (arg2 >> 4) + 5;\n        if (arg2 < 0x30) {\n            arg2._0_4_ = arg2 & 0xf;\n        }\n    }\n    if ((arg2 == 0) || (arg2 - 8 < 8)) {\n        if ((piVar1[8] != 0) && (*(piVar1 + 6) != arg2)) {\n            (**(arg1 + 0x38))(*(arg1 + 0x40));\n            piVar1[8] = 0;\n        }\n        *(piVar1 + 2) = iVar3;\n        *(piVar1 + 6) = arg2;\n        if ((((*(arg1 + 0x30) != 0) && (*(arg1 + 0x38) != 0)) && (piVar1 = *(arg1 + 0x28),  piVar1 != NULL)) &&\n           ((*piVar1 == arg1 && (*(piVar1 + 1) - 0x3f34U < 0x20)))) {\n            *(piVar1 + 0x34) = 0;\n            *(piVar1 + 0x3c) = 0;\n            uVar2 = fcn.1400071a0(arg1);\n            return uVar2;\n        }\n    }\n    return 0xfffffffe;\n}\n",
        "token_count": 482
    },
    "1400071a": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.1400071a0(int64_t arg1)\n\n{\n    int64_t *piVar1;\n    int64_t *piVar2;\n    \n    if ((((arg1 != 0) && (*(arg1 + 0x30) != 0)) && (*(arg1 + 0x38) != 0)) &&\n       (((piVar2 = *(arg1 + 0x28),  piVar2 != NULL && (*piVar2 == arg1)) && (*(piVar2 + 1) - 0x3f34U < 0x20)))) {\n        *(piVar2 + 0x24) = 0;\n        *(arg1 + 0x1c) = 0;\n        *(arg1 + 0xc) = 0;\n        *(arg1 + 0x20) = 0;\n        if (*(piVar2 + 2) != 0) {\n            *(arg1 + 0x4c) = *(piVar2 + 2) & 1;\n        }\n        piVar1 = piVar2 + 0xaa;\n        piVar2[1] = 0x3f34;\n        piVar2[0x11] = piVar1;\n        piVar2[0xd] = piVar1;\n        piVar2[0xc] = piVar1;\n        *(piVar2 + 0x14) = 0;\n        *(piVar2 + 0x1c) = 0x8000;\n        piVar2[5] = 0;\n        piVar2[9] = 0;\n        *(piVar2 + 0x37c) = 1;\n        *(piVar2 + 0x1be4) = 0xffffffff;\n        return 0;\n    }\n    return 0xfffffffe;\n}\n",
        "token_count": 399
    },
    "14000725": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.140007250(int64_t arg1, int64_t arg2, uint64_t arg3)\n\n{\n    int64_t iVar1;\n    int32_t iVar2;\n    int64_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    \n    iVar1 = *(arg1 + 0x28);\n    uVar4 = arg3 & 0xffffffff;\n    if (*(iVar1 + 0x40) == 0) {\n        iVar3 = (**(arg1 + 0x30))(*(arg1 + 0x40), 1 << (*(iVar1 + 0x30) & 0x1f));\n        *(iVar1 + 0x40) = iVar3;\n        if (iVar3 == 0) {\n            return 1;\n        }\n    }\n    if (*(iVar1 + 0x34) == 0) {\n        *(iVar1 + 0x34) = 1 << (*(iVar1 + 0x30) & 0x1f);\n        *(iVar1 + 0x38) = 0;\n    }\n    uVar5 = *(iVar1 + 0x34);\n    if (uVar4 < uVar5) {\n        uVar5 = uVar5 - *(iVar1 + 0x3c);\n        if (uVar4 < uVar5) {\n            uVar5 = uVar4;\n        }\n        fcn.140009570(*(iVar1 + 0x3c) + *(iVar1 + 0x40), arg2 - (arg3 & 0xffffffff), uVar5);\n        uVar4 = uVar4 - uVar5;\n        if (uVar4 == 0) {\n            *(iVar1 + 0x3c) = *(iVar1 + 0x3c) + uVar5;\n            iVar2 = *(iVar1 + 0x3c);\n            if (*(iVar1 + 0x3c) == *(iVar1 + 0x34)) {\n                iVar2 = 0;\n            }\n            *(iVar1 + 0x3c) = iVar2;\n            if (*(iVar1 + 0x34) <= *(iVar1 + 0x38)) {\n                return 0;\n            }\n            iVar2 = *(iVar1 + 0x38) + uVar5;\n        }\n        else {\n            fcn.140009570(*(iVar1 + 0x40), arg2 - uVar4, uVar4);\n            iVar2 = *(iVar1 + 0x34);\n            *(iVar1 + 0x3c) = uVar4;\n        }\n    }\n    else {\n        fcn.140009570(*(iVar1 + 0x40), arg2 - uVar5, uVar5);\n        iVar2 = *(iVar1 + 0x34);\n        *(iVar1 + 0x3c) = 0;\n    }\n    *(iVar1 + 0x38) = iVar2;\n    return 0;\n}\n",
        "token_count": 657
    },
    "14000735": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint32_t fcn.140007350(ulong arg1, uint8_t *arg2, ulong arg3)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    int32_t iVar14;\n    int32_t iVar15;\n    int32_t iVar16;\n    int32_t iVar17;\n    int32_t iVar18;\n    uint32_t uVar19;\n    int32_t iVar20;\n    int64_t iVar21;\n    uint64_t uVar22;\n    uint32_t uVar23;\n    uint64_t uVar24;\n    \n    uVar22 = arg3;\n    uVar23 = arg1 >> 0x10;\n    arg1._0_4_ = arg1 & 0xffff;\n    if (uVar22 == 1) {\n        arg1._0_4_ = arg1 + *arg2;\n        uVar19 = arg1 - 0xfff1;\n        if (arg1 < 0xfff1) {\n            uVar19 = arg1;\n        }\n        uVar23 = uVar23 + uVar19;\n        uVar3 = uVar23 - 0xfff1;\n        if (uVar23 < 0xfff1) {\n            uVar3 = uVar23;\n        }\n        return uVar3 << 0x10 | uVar19;\n    }\n    if (arg2 == NULL) {\n        return 1;\n    }\n    if (uVar22 < 0x10) {\n        for (; uVar22 != 0; uVar22 = uVar22 - 1) {\n            uVar2 = *arg2;\n            arg2 = arg2 + 1;\n            arg1._0_4_ = arg1 + uVar2;\n            uVar23 = uVar23 + arg1;\n        }\n        uVar19 = arg1 - 0xfff1;\n        if (arg1 < 0xfff1) {\n            uVar19 = arg1;\n        }\n        return ((uVar23 / 0xfff1) * 0xf + uVar23) * 0x10000 | uVar19;\n    }\n    if (0x15af < uVar22) {\n        iVar21 = SUB168(ZEXT816(0x79baa6bb6398b6f7) * ZEXT816(uVar22) >> 0x40, 0);\n        uVar24 = (uVar22 - iVar21 >> 1) + iVar21 >> 0xc;\n        uVar22 = uVar22 + uVar24 * -0x15b0;\n        do {\n            iVar20 = 0x15b;\n            do {\n                iVar4 = arg1 + *arg2;\n                iVar5 = iVar4 + arg2[1];\n                iVar6 = iVar5 + arg2[2];\n                iVar7 = iVar6 + arg2[3];\n                iVar8 = iVar7 + arg2[4];\n                iVar9 = iVar8 + arg2[5];\n                iVar10 = iVar9 + arg2[6];\n                iVar11 = iVar10 + arg2[7];\n                iVar12 = iVar11 + arg2[8];\n                iVar13 = iVar12 + arg2[9];\n                iVar14 = iVar13 + arg2[10];\n                iVar15 = iVar14 + arg2[0xb];\n                iVar16 = iVar15 + arg2[0xc];\n                iVar17 = iVar16 + arg2[0xd];\n                iVar18 = iVar17 + arg2[0xe];\n                puVar1 = arg2 + 0xf;\n                arg2 = arg2 + 0x10;\n                arg1._0_4_ = iVar18 + *puVar1;\n                uVar23 = uVar23 + iVar4 + iVar5 + iVar6 + iVar7 + iVar8 + iVar9 + iVar10 + iVar11 + iVar12 + iVar13 +\n                         iVar14 + iVar15 + iVar16 + iVar17 + iVar18 + arg1;\n                iVar20 = iVar20 + -1;\n            } while (iVar20 != 0);\n            arg1._0_4_ = arg1 % 0xfff1;\n            uVar23 = uVar23 % 0xfff1;\n            uVar24 = uVar24 - 1;\n        } while (uVar24 != 0);\n    }\n    if (uVar22 != 0) {\n        if (0xf < uVar22) {\n            uVar24 = uVar22 >> 4;\n            uVar22 = uVar22 + uVar24 * -0x10;\n            do {\n                iVar20 = arg1 + *arg2;\n                iVar4 = iVar20 + arg2[1];\n                iVar5 = iVar4 + arg2[2];\n                iVar6 = iVar5 + arg2[3];\n                iVar7 = iVar6 + arg2[4];\n                iVar8 = iVar7 + arg2[5];\n                iVar9 = iVar8 + arg2[6];\n                iVar10 = iVar9 + arg2[7];\n                iVar11 = iVar10 + arg2[8];\n                iVar12 = iVar11 + arg2[9];\n                iVar13 = iVar12 + arg2[10];\n                iVar14 = iVar13 + arg2[0xb];\n                iVar15 = iVar14 + arg2[0xc];\n                iVar16 = iVar15 + arg2[0xd];\n                iVar17 = iVar16 + arg2[0xe];\n                puVar1 = arg2 + 0xf;\n                arg2 = arg2 + 0x10;\n                arg1._0_4_ = iVar17 + *puVar1;\n                uVar23 = uVar23 + iVar20 + iVar4 + iVar5 + iVar6 + iVar7 + iVar8 + iVar9 + iVar10 + iVar11 + iVar12 +\n                         iVar13 + iVar14 + iVar15 + iVar16 + iVar17 + arg1;\n                uVar24 = uVar24 - 1;\n            } while (uVar24 != 0);\n        }\n        for (; uVar22 != 0; uVar22 = uVar22 - 1) {\n            uVar2 = *arg2;\n            arg2 = arg2 + 1;\n            arg1._0_4_ = arg1 + uVar2;\n            uVar23 = uVar23 + arg1;\n        }\n        arg1._0_4_ = arg1 % 0xfff1;\n        uVar23 = uVar23 % 0xfff1;\n    }\n    return uVar23 << 0x10 | arg1;\n}\n",
        "token_count": 1493
    },
    "14000798": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_17h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.140007980(ulong arg1, uint16_t *arg2, uint64_t arg3, int64_t *arg4)\n\n{\n    int64_t iVar1;\n    int16_t *piVar2;\n    uint16_t uVar3;\n    code *pcVar4;\n    char cVar5;\n    uint8_t uVar6;\n    ushort uVar7;\n    uint16_t *puVar8;\n    uint32_t uVar9;\n    int64_t iVar10;\n    uint64_t uVar11;\n    uint64_t uVar12;\n    uint64_t uVar13;\n    uint8_t uVar14;\n    int32_t iVar15;\n    uint32_t uVar16;\n    uint32_t uVar17;\n    uint32_t uVar18;\n    uint64_t uVar19;\n    uint32_t uVar20;\n    int32_t iVar21;\n    uint32_t uVar22;\n    bool bVar23;\n    bool bVar24;\n    uint32_t *in_stack_00000028;\n    int64_t in_stack_00000030;\n    uchar auStack248 [32];\n    uint uStack216;\n    uint32_t uStack212;\n    uint32_t uStack208;\n    uint32_t uStack204;\n    uint32_t uStack200;\n    int32_t iStack196;\n    uint32_t uStack192;\n    int64_t iStack184;\n    int64_t iStack176;\n    int64_t *piStack160;\n    uint16_t *puStack152;\n    uint16_t auStack136 [5];\n    ulong var_75h;\n    ulong var_69h;\n    ulong var_61h;\n    ulong var_59h;\n    ulong var_51h;\n    ulong var_49h;\n    uint64_t var_41h;\n    ulong var_39h;\n    ulong var_17h;\n    \n    stack0xffffffffffffffb8 = *0x140032010 ^ auStack248;\n    uVar12 = 0;\n    arg3 = arg3 & 0xffffffff;\n    uVar19 = uVar12;\n    do {\n        iStack196 = arg1;\n        piStack160 = arg4;\n        puStack152 = arg2;\n        if (0x1f < uVar19 * 2) {\n            fcn.140008820();\n            pcVar4 = swi(3);\n            (*pcVar4)();\n            return;\n        }\n        uVar20 = uVar19 + 1;\n        auStack136[uVar19] = 0;\n        uVar19 = uVar20;\n    } while (uVar20 < 0x10);\n    uVar20 = arg3;\n    puVar8 = arg2;\n    if (uVar20 != 0) {\n        do {\n            auStack136[*puVar8] = auStack136[*puVar8] + 1;\n            arg3 = arg3 - 1;\n            puVar8 = puVar8 + 1;\n        } while (arg3 != 0);\n    }\n    uVar9 = 0xd;\n    uVar19 = 0xf;\n    do {\n        uVar18 = uVar19;\n        uVar17 = 0xffffffff;\n        if (auStack136[uVar19] != 0) break;\n        if (auStack136[uVar9 + 1] != 0) {\n            uVar18 = uVar18 - 1;\n            break;\n        }\n        if (auStack136[uVar9] != 0) {\n            uVar18 = uVar18 - 2;\n            break;\n        }\n        if (auStack136[uVar9 - 1] != 0) {\n            uVar18 = uVar18 - 3;\n            break;\n        }\n        if (auStack136[uVar9 - 2] != 0) {\n            uVar18 = uVar18 - 4;\n            break;\n        }\n        uVar18 = uVar18 - 5;\n        uVar19 = uVar18;\n        uVar9 = uVar9 - 5;\n    } while (uVar18 != 0);\n    uVar9 = *in_stack_00000028;\n    if (uVar18 < *in_stack_00000028) {\n        uVar9 = uVar18;\n    }\n    if (uVar18 == 0) {\n        uStack216 = 0x140;\n        **arg4 = 0x140;\n        *arg4 = *arg4 + 4;\n        **arg4 = 0x140;\n        *arg4 = *arg4 + 4;\n        *in_stack_00000028 = 1;\n    }\n    else {\n        uVar22 = 1;\n        if (1 < uVar18) {\n            puVar8 = auStack136;\n            do {\n                puVar8 = puVar8 + 1;\n                if (*puVar8 != 0) break;\n                uVar22 = uVar22 + 1;\n            } while (uVar22 < uVar18);\n        }\n        uVar19 = 1;\n        iVar15 = 1;\n        uStack200 = uVar9;\n        if (uVar9 < uVar22) {\n            uStack200 = uVar22;\n        }\n        do {\n            iVar15 = iVar15 * 2 - auStack136[uVar19];\n            if (iVar15 < 0) goto code_r0x000140007ad1;\n            uVar9 = uVar19 + 1;\n            uVar19 = uVar9;\n        } while (uVar9 < 0x10);\n        if ((iVar15 < 1) || ((arg1 != 0 && (uVar18 == 1)))) {\n            var_61h._3_2_ = 0;\n            iVar10 = 0xe;\n            uVar19 = uVar12;\n            do {\n                *(&var_61h + uVar19 + 5) = *(auStack136 + uVar19 + 2) + *(&var_61h + uVar19 + 3);\n                uVar19 = uVar19 + 2;\n                iVar10 = iVar10 + -1;\n            } while (iVar10 != 0);\n            puVar8 = arg2;\n            uVar19 = uVar12;\n            if (uVar20 != 0) {\n                do {\n                    if (*puVar8 != 0) {\n                        *(in_stack_00000030 + *(&var_61h + *puVar8 * 2 + 1) * 2) = uVar19;\n                        piVar2 = &var_61h + *puVar8 * 2 + 1;\n                        *piVar2 = *piVar2 + 1;\n                    }\n                    uVar9 = uVar19 + 1;\n                    puVar8 = puVar8 + 1;\n                    uVar19 = uVar9;\n                } while (uVar9 < uVar20);\n            }\n            if (arg1 == 0) {\n                iStack184 = in_stack_00000030;\n                uVar19 = 0x14;\n                iStack176 = in_stack_00000030;\n            }\n            else if (arg1 == 1) {\n                uVar19 = 0x101;\n                iStack176 = 0x140026970;\n                iStack184 = 0x1400269b0;\n            }\n            else {\n                iStack176 = 0x1400269f0;\n                iStack184 = 0x140026a30;\n                uVar19 = uVar12;\n            }\n            iVar10 = *arg4;\n            uVar20 = 1 << (uStack200 & 0x1f);\n            uVar13 = uVar20;\n            uStack204 = 0;\n            uStack208 = 0;\n            uStack212 = uVar19;\n            uStack192 = uVar20 - 1;\n            if (arg1 == 1) {\n                uVar19 = uVar12;\n                uVar11 = uVar12;\n                if (uVar20 < 0x355) {\ncode_r0x000140007c80:\n                    cVar5 = uVar22;\n                    uVar14 = uVar19;\n                    uVar6 = cVar5 - uVar14;\n                    uVar3 = *(in_stack_00000030 + uVar11 * 2);\n                    if (uVar3 + 1 < uStack212) {\n                        uStack216 = uVar6 << 8;\n                        uStack216 = uStack216 | uVar3 << 0x10;\n                    }\n                    else {\n                        if (uVar3 < uStack212) {\n                            uStack216 = CONCAT31(uVar6, 0x60);\n                            uVar7 = 0;\n                        }\n                        else {\n                            iVar1 = (uVar3 - uStack212) * 2;\n                            uStack216._0_2_ = CONCAT11(uVar6, *(iVar1 + iStack184));\n                            uVar7 = *(iVar1 + iStack176);\n                        }\n                        uStack216 = CONCAT22(uVar7, uStack216);\n                    }\n                    uVar9 = uVar12;\n                    iVar15 = 1 << (cVar5 - uVar14 & 0x1f);\n                    uVar11 = (uVar9 >> (uVar14 & 0x1f)) + uVar13;\n                    uVar12 = uVar13;\n                    do {\n                        uVar11 = uVar11 - iVar15;\n                        *(iVar10 + uVar11 * 4) = uStack216;\n                        uVar16 = uVar12 - iVar15;\n                        uVar12 = uVar16;\n                    } while (uVar16 != 0);\n                    for (uVar16 = 1 << (cVar5 - 1U & 0x1f); (uVar9 & uVar16) != 0; uVar16 = uVar16 >> 1) {\n                    }\n                    if (uVar16 == 0) {\n                        uVar12 = 0;\n                    }\n                    else {\n                        uVar12 = (uVar9 & uVar16 - 1) + uVar16;\n                    }\n                    uStack204 = uStack204 + 1;\n                    puVar8 = auStack136 + uVar22;\n                    *puVar8 = *puVar8 - 1;\n                    if (*puVar8 == 0) {\n                        if (uVar22 == uVar18) goto code_r0x000140007e3b;\n                        uVar22 = arg2[*(in_stack_00000030 + uStack204 * 2)];\n                    }\n                    uVar11 = uStack204;\n                    if (uStack200 < uVar22) {\n                        uVar9 = uStack192 & uVar12;\n                        if (uVar9 != uVar17) {\n                            iVar10 = iVar10 + uVar13 * 4;\n                            if (uStack208 == 0) {\n                                uStack208 = uStack200;\n                            }\n                            iVar21 = uVar22 - uStack208;\n                            uVar17 = uStack208 + iVar21;\n                            for (iVar15 = 1 << (iVar21 & 0x1f);\n                                (uVar17 < uVar18 && (uVar19 = uVar17,  0 < iVar15 - auStack136[uVar19]));\n                                iVar15 = (iVar15 - auStack136[uVar19]) * 2) {\n                                iVar21 = iVar21 + 1;\n                                uVar17 = uVar17 + 1;\n                            }\n                            uVar17 = 1 << (iVar21 & 0x1f);\n                            uVar13 = uVar17;\n                            uVar20 = uVar20 + uVar17;\n                            if (arg1 == 1) {\n                                bVar23 = uVar20 < 0x354;\n                                bVar24 = uVar20 == 0x354;\ncode_r0x000140007df6:\n                                if (!bVar23 && !bVar24) goto code_r0x000140007ad1;\n                            }\n                            else if (arg1 == 2) {\n                                bVar23 = uVar20 < 0x250;\n                                bVar24 = uVar20 == 0x250;\n                                goto code_r0x000140007df6;\n                            }\n                            iVar1 = uVar9 * 4;\n                            *(iVar1 + *arg4) = iVar21;\n                            *(iVar1 + 1 + *arg4) = uStack200;\n                            *(*arg4 + 2 + iVar1) = iVar10 - *arg4 >> 2;\n                            uVar17 = uVar9;\n                        }\n                        uVar19 = uStack208;\n                        uVar11 = uStack204;\n                    }\n                    goto code_r0x000140007c80;\n                }\n            }\n            else {\n                uVar12 = 0;\n                uVar19 = 0;\n                uVar11 = 0;\n                uVar17 = 0xffffffff;\n                if ((arg1 != 2) || (uVar20 < 0x251)) goto code_r0x000140007c80;\n            }\n        }\n    }\ncode_r0x000140007ad1:\n    fcn.140008410(stack0xffffffffffffffb8 ^ auStack248);\n    return;\ncode_r0x000140007e3b:\n    if (uVar12 != 0) {\n        uStack216._0_2_ = CONCAT11(cVar5 - uVar14, 0x40);\n        uStack216 = uStack216;\n        *(iVar10 + uVar12 * 4) = uStack216;\n    }\n    *arg4 = *arg4 + uVar20 * 4;\n    *in_stack_00000028 = uStack200;\n    goto code_r0x000140007ad1;\n}\n",
        "token_count": 3046
    },
    "140007e9": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.140007e90(uint8_t **arg1, ulong arg2)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    uint uVar6;\n    uint8_t *puVar7;\n    uint8_t *puVar8;\n    int64_t iVar9;\n    int64_t iVar10;\n    uint8_t *puVar11;\n    uint32_t uVar12;\n    char *pcVar13;\n    uint32_t uVar14;\n    uint64_t uVar15;\n    uint32_t uVar16;\n    uint32_t uVar17;\n    uint32_t uVar18;\n    uint8_t *puVar19;\n    uint8_t *puVar20;\n    uint8_t *puVar21;\n    uint8_t *puVar22;\n    uint8_t *puVar23;\n    int64_t iVar24;\n    char cVar25;\n    uint32_t uVar26;\n    int32_t iVar27;\n    uint8_t *puVar28;\n    int32_t iStack88;\n    \n    puVar7 = arg1[5];\n    iVar2 = *(arg1 + 3);\n    puVar8 = arg1[2];\n    puVar19 = *arg1;\n    iVar9 = *(puVar7 + 0x68);\n    iVar10 = *(puVar7 + 0x60);\n    puVar28 = puVar19 + (*(arg1 + 1) - 5);\n    uVar3 = *(puVar7 + 0x3c);\n    uVar18 = *(puVar7 + 0x48);\n    uVar26 = *(puVar7 + 0x4c);\n    iStack88 = puVar8 - (arg2 - iVar2);\n    iVar27 = *(puVar7 + 0x34);\n    uVar4 = *(puVar7 + 0x38);\n    puVar11 = *(puVar7 + 0x40);\n    uVar5 = *(puVar7 + 0x70);\n    uVar6 = *(puVar7 + 0x74);\n    puVar21 = puVar8;\ncode_r0x000140007f43:\n    if (uVar26 < 0xf) {\n        uVar1 = *puVar19;\n        puVar23 = puVar19 + 1;\n        puVar19 = puVar19 + 2;\n        uVar18 = uVar18 + (uVar1 << (uVar26 & 0x1f)) + (*puVar23 << (uVar26 + 8 & 0x1f));\n        uVar26 = uVar26 + 0x10;\n    }\n    uVar16 = *(iVar10 + ((1 << (uVar5 & 0x1f)) - 1U & uVar18) * 4);\n    uVar14 = uVar16 >> 8 & 0xff;\n    uVar18 = uVar18 >> (uVar14 & 0x1f);\n    uVar26 = uVar26 - uVar14;\n    cVar25 = uVar16;\n    while (cVar25 != '\\0') {\n        puVar23 = puVar21;\n        if ((uVar16 & 0x10) != 0) {\n            uVar14 = uVar16 >> 0x10;\n            uVar16 = uVar16 & 0xf;\n            puVar20 = puVar19;\n            if (uVar16 != 0) {\n                if (uVar26 < uVar16) {\n                    uVar1 = *puVar19;\n                    puVar19 = puVar19 + 1;\n                    uVar18 = uVar18 + (uVar1 << (uVar26 & 0x1f));\n                    uVar26 = uVar26 + 8;\n                }\n                uVar12 = (1 << uVar16) - 1U & uVar18;\n                uVar18 = uVar18 >> uVar16;\n                uVar14 = uVar14 + uVar12;\n                uVar26 = uVar26 - uVar16;\n                puVar20 = puVar19;\n            }\n            if (uVar26 < 0xf) {\n                uVar1 = *puVar20;\n                puVar19 = puVar20 + 1;\n                puVar20 = puVar20 + 2;\n                uVar18 = uVar18 + (uVar1 << (uVar26 & 0x1f)) + (*puVar19 << (uVar26 + 8 & 0x1f));\n                uVar26 = uVar26 + 0x10;\n            }\n            uVar16 = *(iVar9 + ((1 << (uVar6 & 0x1f)) - 1U & uVar18) * 4);\n            uVar12 = uVar16 >> 8 & 0xff;\n            uVar18 = uVar18 >> (uVar12 & 0x1f);\n            uVar26 = uVar26 - uVar12;\n            goto joined_r0x000140008051;\n        }\n        if ((uVar16 & 0x40) != 0) {\n            if ((uVar16 & 0x20) == 0) {\n                arg1[4] = \"invalid literal/length code\";\n                *(puVar7 + 8) = 0x3f51;\n            }\n            else {\n                *(puVar7 + 8) = 0x3f3f;\n            }\n            goto code_r0x000140008315;\n        }\n        uVar16 = *(iVar10 + (((1 << (uVar16 & 0x1f)) - 1U & uVar18) + (uVar16 >> 0x10)) * 4);\n        uVar14 = uVar16 >> 8 & 0xff;\n        uVar18 = uVar18 >> (uVar14 & 0x1f);\n        uVar26 = uVar26 - uVar14;\n        cVar25 = uVar16;\n    }\n    *puVar21 = uVar16 >> 0x10;\n    puVar23 = puVar21 + 1;\n    goto code_r0x0001400082a6;\njoined_r0x000140008051:\n    if ((uVar16 & 0x10) != 0) goto code_r0x000140008089;\n    if ((uVar16 & 0x40) != 0) {\n        pcVar13 = \"invalid distance code\";\n        goto code_r0x0001400082ed;\n    }\n    uVar16 = *(iVar9 + (((1 << (uVar16 & 0x1f)) - 1U & uVar18) + (uVar16 >> 0x10)) * 4);\n    uVar12 = uVar16 >> 8 & 0xff;\n    uVar18 = uVar18 >> (uVar12 & 0x1f);\n    uVar26 = uVar26 - uVar12;\n    goto joined_r0x000140008051;\ncode_r0x000140008089:\n    uVar17 = uVar16 & 0xf;\n    puVar19 = puVar20;\n    uVar12 = uVar26;\n    if (uVar26 < uVar17) {\n        puVar19 = puVar20 + 1;\n        uVar18 = uVar18 + (*puVar20 << (uVar26 & 0x1f));\n        uVar12 = uVar26 + 8;\n        if (uVar12 < uVar17) {\n            uVar1 = *puVar19;\n            puVar19 = puVar20 + 2;\n            uVar18 = uVar18 + (uVar1 << (uVar12 & 0x1f));\n            uVar12 = uVar26 + 0x10;\n        }\n    }\n    uVar26 = uVar12 - uVar17;\n    uVar12 = (1 << uVar17) - 1U & uVar18;\n    uVar18 = uVar18 >> uVar17;\n    uVar12 = (uVar16 >> 0x10) + uVar12;\n    uVar16 = puVar21 - iStack88;\n    if (uVar12 <= uVar16) {\n        puVar23 = puVar21 + -uVar12;\n        do {\n            puVar22 = puVar21;\n            puVar20 = puVar23;\n            *puVar22 = *puVar20;\n            uVar14 = uVar14 - 3;\n            puVar22[1] = puVar20[1];\n            puVar22[2] = puVar20[2];\n            puVar21 = puVar22 + 3;\n            puVar23 = puVar20 + 3;\n        } while (2 < uVar14);\n        puVar23 = puVar21;\n        if (uVar14 != 0) {\n            *puVar21 = puVar20[3];\n            puVar23 = puVar22 + 4;\n            if (1 < uVar14) {\n                puVar22[4] = puVar20[4];\n                puVar23 = puVar22 + 5;\n            }\n        }\n        goto code_r0x0001400082a6;\n    }\n    uVar16 = uVar12 - uVar16;\n    if ((uVar4 < uVar16) && (*(puVar7 + 0x1be0) != 0)) {\n        pcVar13 = \"invalid distance too far back\";\n        puVar20 = puVar19;\ncode_r0x0001400082ed:\n        arg1[4] = pcVar13;\n        *(puVar7 + 8) = 0x3f51;\n        puVar19 = puVar20;\ncode_r0x000140008315:\n        arg1[2] = puVar23;\n        *arg1 = puVar19 + -(uVar26 >> 3);\n        iVar27 = uVar26 - (uVar26 & 0xfffffff8);\n        *(arg1 + 1) = (puVar28 - (puVar19 + -(uVar26 >> 3))) + 5;\n        *(arg1 + 3) = ((puVar8 + (iVar2 - 0x101)) - puVar23) + 0x101;\n        *(puVar7 + 0x48) = uVar18 & (1 << (iVar27 & 0x1f)) - 1U;\n        *(puVar7 + 0x4c) = iVar27;\n        return;\n    }\n    if (uVar3 == 0) {\n        puVar20 = puVar11 + (iVar27 - uVar16);\n        if (uVar16 < uVar14) {\n            uVar14 = uVar14 - uVar16;\n            do {\n                uVar1 = *puVar20;\n                puVar20 = puVar20 + 1;\n                *puVar21 = uVar1;\n                puVar21 = puVar21 + 1;\n                uVar16 = uVar16 - 1;\n            } while (uVar16 != 0);\ncode_r0x0001400081c5:\n            puVar20 = puVar21 + -uVar12;\n        }\n    }\n    else if (uVar3 < uVar16) {\n        uVar17 = uVar16 - uVar3;\n        puVar20 = puVar11 + ((uVar3 - uVar16) + iVar27);\n        if (uVar17 < uVar14) {\n            uVar14 = uVar14 - uVar17;\n            iVar24 = (puVar11 + ((uVar3 - uVar16) + iVar27)) - puVar21;\n            do {\n                *puVar21 = puVar21[iVar24];\n                puVar21 = puVar21 + 1;\n                uVar17 = uVar17 - 1;\n            } while (uVar17 != 0);\n            puVar20 = puVar11;\n            if (uVar3 < uVar14) {\n                uVar14 = uVar14 - uVar3;\n                puVar23 = puVar11;\n                uVar16 = uVar3;\n                do {\n                    uVar1 = *puVar23;\n                    puVar23 = puVar23 + 1;\n                    *puVar21 = uVar1;\n                    puVar21 = puVar21 + 1;\n                    uVar16 = uVar16 - 1;\n                } while (uVar16 != 0);\n                goto code_r0x0001400081c5;\n            }\n        }\n    }\n    else {\n        puVar20 = puVar11 + (uVar3 - uVar16);\n        if (uVar16 < uVar14) {\n            uVar14 = uVar14 - uVar16;\n            do {\n                uVar1 = *puVar20;\n                puVar20 = puVar20 + 1;\n                *puVar21 = uVar1;\n                puVar21 = puVar21 + 1;\n                uVar16 = uVar16 - 1;\n            } while (uVar16 != 0);\n            goto code_r0x0001400081c5;\n        }\n    }\n    if (2 < uVar14) {\n        uVar15 = (uVar14 - 3) / 3 + 1;\n        do {\n            uVar14 = uVar14 - 3;\n            *puVar21 = *puVar20;\n            puVar21[1] = puVar20[1];\n            puVar23 = puVar20 + 2;\n            puVar20 = puVar20 + 3;\n            puVar21[2] = *puVar23;\n            puVar21 = puVar21 + 3;\n            uVar15 = uVar15 - 1;\n        } while (uVar15 != 0);\n    }\n    puVar23 = puVar21;\n    if (uVar14 != 0) {\n        *puVar21 = *puVar20;\n        puVar23 = puVar21 + 1;\n        if (1 < uVar14) {\n            puVar21[1] = puVar20[1];\n            puVar23 = puVar21 + 2;\n        }\n    }\ncode_r0x0001400082a6:\n    if ((puVar28 <= puVar19) || (puVar21 = puVar23,  puVar8 + (iVar2 - 0x101) <= puVar23)) goto code_r0x000140008315;\n    goto code_r0x000140007f43;\n}\n",
        "token_count": 3214
    },
    "14000a9d": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint64_t fcn.14000a9d0(char **arg1)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    int64_t arg2;\n    char *pcVar4;\n    uint64_t uVar5;\n    int64_t iVar6;\n    int64_t iVar7;\n    \n    if (arg1 == NULL) {\n        puVar3 = fcn.1400139ac();\n        *puVar3 = 0x16;\n        fcn.14001388c();\n    }\n    else {\n        uVar2 = fcn.14000f878(arg1);\n        if (*(arg1 + 2) < 0) {\n            *(arg1 + 2) = 0;\n        }\n        arg2 = fcn.140014b58(uVar2 & 0xffffffff, 0, 1);\n        if (-1 < arg2) {\n            if ((*(arg1 + 0x14) & 0xc0) == 0) {\n                return arg2 - *(arg1 + 2);\n            }\n            iVar7 = uVar2 >> 6;\n            iVar6 = (uVar2 & 0x3f) * 0x40;\n            cVar1 = *(iVar6 + 0x39 + *(iVar7 * 8 + 0x14003c780));\n            uVar5 = *arg1 - arg1[1];\n            if ((*(arg1 + 0x14) & 3) == 0) {\n                if ((*(arg1 + 0x14) >> 2 & 1) == 0) {\n                    puVar3 = fcn.1400139ac();\n                    *puVar3 = 0x16;\n                    return 0xffffffffffffffff;\n                }\n            }\n            else {\n                if ((cVar1 == '\\x01') && ((*(iVar6 + 0x3d + *(iVar7 * 8 + 0x14003c780)) & 2) != 0)) {\n                    uVar5 = fcn.14000acc0(arg1);\n                    return uVar5;\n                }\n                if ((*(iVar6 + 0x38 + *(iVar7 * 8 + 0x14003c780)) & 0x80) != 0) {\n                    pcVar4 = arg1[1];\n                    iVar6 = *arg1 - pcVar4;\n                    if (*arg1 <= pcVar4 && pcVar4 != *arg1) {\n                        iVar6 = 0;\n                    }\n                    if (iVar6 != 0) {\n                        iVar7 = 0;\n                        do {\n                            if (*pcVar4 == '\\n') {\n                                uVar5 = uVar5 + 1;\n                            }\n                            pcVar4 = pcVar4 + 1;\n                            iVar7 = iVar7 + 1;\n                        } while (iVar7 != iVar6);\n                    }\n                }\n            }\n            if (arg2 == 0) {\n                return uVar5;\n            }\n            if ((*(arg1 + 0x14) & 1) == 0) {\n                if (cVar1 == '\\x01') {\n                    uVar5 = uVar5 >> 1;\n                }\n                return uVar5 + arg2;\n            }\n            uVar5 = fcn.14000ab48(arg1, arg2, uVar5);\n            return uVar5;\n        }\n    }\n    return 0xffffffffffffffff;\n}\n",
        "token_count": 753
    },
    "14000b8e": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.14000b8e8(ulong *arg1)\n\n{\n    ulong arg1_00;\n    uint8_t uVar1;\n    uint64_t uVar2;\n    uchar auStack1272 [32];\n    uchar *puStack1240;\n    ulong uStack1232;\n    ulong uStack1224;\n    uint64_t uStack1216;\n    uchar auStack1208 [16];\n    char cStack1192;\n    uchar auStack1176 [1120];\n    uint64_t uStack56;\n    uint64_t uStack24;\n    \n    uStack24 = *0x140032010 ^ auStack1272;\n    arg1_00 = **arg1;\n    uVar1 = fcn.140015928(arg1_00);\n    fcn.14000b858(&uStack1216, *arg1[1]);\n    puStack1240 = auStack1208;\n    uStack1224 = **arg1;\n    uStack1232 = *arg1[4];\n    fcn.14000b75c(auStack1176, &uStack1224, *arg1[2], *arg1[3]);\n    fcn.14000bb4c(auStack1176);\n    uVar2 = uStack56;\n    fcn.140012a5c(uStack56);\n    uStack56 = 0;\n    if (cStack1192 != '\\0') {\n        *(uStack1216 + 0x3a8) = *(uStack1216 + 0x3a8) & 0xfffffffd;\n        uVar2 = uStack1216;\n    }\n    fcn.1400159f8(uVar2 & 0xffffffffffffff00 | uVar1, arg1_00);\n    fcn.140008410(uStack24 ^ auStack1272);\n    return;\n}\n",
        "token_count": 404
    },
    "14000c24": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint64_t fcn.14000c24c(int64_t arg1)\n\n{\n    uchar uVar1;\n    int64_t iVar2;\n    int64_t iVar3;\n    char cVar4;\n    uint *puVar5;\n    uint64_t uVar6;\n    \n    cVar4 = fcn.14000c354(arg1);\n    if (cVar4 == '\\0') {\n        puVar5 = fcn.1400139ac();\n        *puVar5 = 0x16;\n        uVar6 = fcn.14001388c();\n        uVar6 = uVar6 & 0xffffffffffffff00;\n    }\n    else {\n        iVar2 = *(arg1 + 0x468);\n        uVar1 = *(arg1 + 0x41);\n        iVar3 = *(iVar2 + 8);\n        if (*(iVar2 + 0x10) == iVar3) {\n            if (*(iVar2 + 0x18) == '\\0') {\n                *(arg1 + 0x28) = 0xffffffff;\n            }\n            else {\n                *(arg1 + 0x28) = *(arg1 + 0x28) + 1;\n            }\n        }\n        else {\n            *(arg1 + 0x28) = *(arg1 + 0x28) + 1;\n            *(iVar2 + 0x10) = *(iVar2 + 0x10) + 1;\n            ***(arg1 + 0x468) = uVar1;\n            **(arg1 + 0x468) = **(arg1 + 0x468) + 1;\n        }\n        uVar6 = CONCAT71(iVar3 >> 8, 1);\n    }\n    return uVar6;\n}\n",
        "token_count": 383
    },
    "14000c3e": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint64_t fcn.14000c3ec(uint8_t *arg1)\n\n{\n    int32_t *arg4;\n    uint8_t *arg1_00;\n    uint8_t uVar1;\n    char cVar2;\n    char *pcVar3;\n    bool bVar4;\n    uint32_t uVar5;\n    uint64_t in_RAX;\n    uint *puVar6;\n    char *pcVar7;\n    uint64_t uVar8;\n    ulong uVar9;\n    ushort *arg2;\n    uint32_t uVar10;\n    int64_t arg3;\n    ushort uStackX8;\n    uchar uStackX10;\n    \n    uVar1 = arg1[0x41];\n    pcVar7 = in_RAX & 0xffffffffffffff00;\n    if (uVar1 != 0x46) {\n        if (uVar1 == 0x4e) {\n            if ((*arg1 & 8) == 0) {\n                *(arg1 + 0x2c) = 8;\ncode_r0x00014000c424:\n                puVar6 = fcn.1400139ac();\n                *puVar6 = 0x16;\n                uVar8 = fcn.14001388c();\n                return uVar8 & 0xffffffffffffff00;\n            }\n        }\n        else {\n            if (*(arg1 + 0x3c) != 0) goto code_r0x00014000c424;\n            if (uVar1 == 0x49) {\n                pcVar3 = *(arg1 + 0x18);\n                cVar2 = *pcVar3;\n                if ((cVar2 == '3') && (pcVar3[1] == '2')) {\n                    pcVar7 = pcVar3 + 2;\n                    *(arg1 + 0x3c) = 10;\n                    *(arg1 + 0x18) = pcVar7;\n                }\n                else if ((cVar2 == '6') && (pcVar3[1] == '4')) {\n                    pcVar7 = pcVar3 + 2;\n                    *(arg1 + 0x3c) = 0xb;\n                    *(arg1 + 0x18) = pcVar7;\n                }\n                else if ((cVar2 + 0xa8U < 0x21) && (pcVar7 = cVar2 + 0xa8U,  (0x120821001U >> (pcVar7 & 0x3f) & 1) != 0)\n                        ) {\n                    *(arg1 + 0x3c) = 9;\n                }\n            }\n            else if (uVar1 == 0x4c) {\n                *(arg1 + 0x3c) = 8;\n            }\n            else if (uVar1 == 0x54) {\n                *(arg1 + 0x3c) = 0xd;\n            }\n            else if (uVar1 == 0x68) {\n                pcVar7 = *(arg1 + 0x18);\n                if (*pcVar7 == 'h') {\n                    pcVar7 = pcVar7 + 1;\n                    *(arg1 + 0x3c) = 1;\n                    *(arg1 + 0x18) = pcVar7;\n                }\n                else {\n                    *(arg1 + 0x3c) = 2;\n                }\n            }\n            else if (uVar1 == 0x6a) {\n                *(arg1 + 0x3c) = 5;\n            }\n            else if (uVar1 == 0x6c) {\n                pcVar7 = *(arg1 + 0x18);\n                if (*pcVar7 == 'l') {\n                    pcVar7 = pcVar7 + 1;\n                    *(arg1 + 0x3c) = 4;\n                    *(arg1 + 0x18) = pcVar7;\n                }\n                else {\n                    *(arg1 + 0x3c) = 3;\n                }\n            }\n            else if (uVar1 == 0x74) {\n                *(arg1 + 0x3c) = 7;\n            }\n            else {\n                if (uVar1 != 0x77) {\n                    uVar8 = CONCAT71(pcVar7 >> 8, 1);\n                    if (uVar1 != 0x7a) {\n                        return uVar8;\n                    }\n                    *(arg1 + 0x3c) = 6;\n                    return uVar8;\n                }\n                *(arg1 + 0x3c) = 0xc;\n            }\n        }\ncode_r0x00014000c560:\n        return CONCAT71(pcVar7 >> 8, 1);\n    }\n    if ((*arg1 & 8) != 0) goto code_r0x00014000c560;\n    *(arg1 + 0x2c) = 7;\n    uVar5 = arg1[0x41];\n    uVar8 = uVar5;\n    cVar2 = '\\x01';\n    if (uVar5 < 0x65) {\n        if (uVar5 == 100) {\ncode_r0x00014000c980:\n            *(arg1 + 0x30) = *(arg1 + 0x30) | 0x10;\ncode_r0x00014000c984:\n            uVar9 = 10;\ncode_r0x00014000c98c:\n            uVar8 = fcn.14000d708(arg1, uVar9);\n        }\n        else {\n            if (uVar5 == 0x41) goto code_r0x00014000c993;\n            if (uVar5 == 0x43) {\ncode_r0x00014000c8f9:\n                uVar8 = fcn.14000d5ac(arg1);\n            }\n            else {\n                if (uVar5 < 0x45) goto code_r0x00014000c99c;\n                if (uVar5 < 0x48) goto code_r0x00014000c993;\n                if (uVar5 == 0x53) {\ncode_r0x00014000c93c:\n                    uVar8 = fcn.14000d984(arg1);\n                }\n                else {\n                    if (uVar5 == 0x58) goto code_r0x00014000c951;\n                    if (uVar5 != 0x5a) {\n                        if (uVar5 != 0x61) {\n                            if (uVar5 != 99) goto code_r0x00014000c99c;\n                            goto code_r0x00014000c8f9;\n                        }\n                        goto code_r0x00014000c993;\n                    }\n                    uVar8 = fcn.14000d04c(arg1);\n                }\n            }\n        }\n    }\n    else {\n        if (0x67 < uVar5) {\n            if (uVar5 == 0x69) goto code_r0x00014000c980;\n            if (uVar5 == 0x6e) {\n                uVar8 = fcn.14000d8a8(arg1);\n                goto code_r0x00014000c998;\n            }\n            if (uVar5 == 0x6f) {\n                if ((*(arg1 + 0x30) >> 5 & 1) != 0) {\n                    *(arg1 + 0x30) = *(arg1 + 0x30) | 0x80;\n                }\n                uVar9 = 8;\n            }\n            else if (uVar5 == 0x70) {\n                *(arg1 + 0x38) = 0x10;\n                *(arg1 + 0x3c) = 0xb;\ncode_r0x00014000c951:\n                uVar9 = 0x10;\n            }\n            else {\n                if (uVar5 == 0x73) goto code_r0x00014000c93c;\n                if (uVar5 == 0x75) goto code_r0x00014000c984;\n                if (uVar5 != 0x78) goto code_r0x00014000c99c;\n                uVar9 = 0x10;\n            }\n            goto code_r0x00014000c98c;\n        }\ncode_r0x00014000c993:\n        uVar8 = fcn.14000d14c(arg1);\n    }\ncode_r0x00014000c998:\n    if (uVar8 == '\\0') {\ncode_r0x00014000c99c:\n        return uVar8 & 0xffffffffffffff00;\n    }\n    if (arg1[0x40] != 0) goto code_r0x00014000cae5;\n    uVar5 = *(arg1 + 0x30);\n    uStackX8 = 0;\n    arg3 = 0;\n    uStackX10 = 0;\n    if ((uVar5 >> 4 & 1) != 0) {\n        if ((uVar5 >> 6 & 1) == 0) {\n            if ((uVar5 & 1) == 0) {\n                if ((uVar5 >> 1 & 1) == 0) goto code_r0x00014000c9f5;\n                uStackX8 = 0x20;\n            }\n            else {\n                uStackX8 = 0x2b;\n            }\n        }\n        else {\n            uStackX8 = 0x2d;\n        }\n        arg3 = 1;\n    }\ncode_r0x00014000c9f5:\n    uVar1 = arg1[0x41];\n    if (((uVar1 + 0xa8 & 0xdf) == 0) && ((uVar5 >> 5 & 1) != 0)) {\n        bVar4 = true;\n    }\n    else {\n        bVar4 = false;\n    }\n    if ((bVar4) || ((uVar1 + 0xbf & 0xdf) == 0)) {\n        *(&uStackX8 + arg3) = 0x30;\n        if ((uVar1 != 0x58) && (uVar1 != 0x41)) {\n            cVar2 = '\\0';\n        }\n        *(&uStackX8 + arg3 + 1) = (-cVar2 & 0xe0U) + 0x78;\n        arg3 = arg3 + 2;\n    }\n    uVar10 = (*(arg1 + 0x34) - *(arg1 + 0x50)) - arg3;\n    if ((uVar5 & 0xc) == 0) {\n        fcn.14000b60c(arg1 + 0x468, CONCAT71(uVar5 >> 8, 0x20), uVar10, arg1 + 0x28);\n    }\n    arg4 = arg1 + 0x28;\n    arg1_00 = arg1 + 0x468;\n    arg2 = &uStackX8;\n    fcn.14000de08(arg1_00, arg2, arg3, arg4);\n    if (((*(arg1 + 0x30) >> 3 & 1) != 0) && ((*(arg1 + 0x30) >> 2 & 1) == 0)) {\n        fcn.14000b60c(arg1_00, CONCAT71(arg2 >> 8, 0x30), uVar10, arg4);\n    }\n    uVar9 = 0;\n    uVar8 = fcn.14000db68(arg1);\n    if ((-1 < *arg4) && (uVar8 = *(arg1 + 0x30) >> 2,  (*(arg1 + 0x30) >> 2 & 1) != 0)) {\n        uVar8 = fcn.14000b60c(arg1_00, CONCAT71(uVar9 >> 8, 0x20), uVar10, arg4);\n    }\ncode_r0x00014000cae5:\n    return uVar8 & 0xffffffffffffff00 | 1;\n}\n",
        "token_count": 2687
    },
    "14000c88": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint64_t fcn.14000c888(int64_t arg1)\n\n{\n    int32_t *arg4;\n    int64_t arg1_00;\n    char cVar1;\n    bool bVar2;\n    char cVar3;\n    uint32_t uVar4;\n    uint64_t uVar5;\n    ulong uVar6;\n    ushort *arg2;\n    uint32_t uVar7;\n    int64_t arg3;\n    ushort uStackX8;\n    uchar uStackX10;\n    \n    uVar4 = *(arg1 + 0x41);\n    uVar5 = uVar4;\n    cVar3 = '\\x01';\n    if (uVar4 < 0x65) {\n        if (uVar4 == 100) {\ncode_r0x00014000c980:\n            *(arg1 + 0x30) = *(arg1 + 0x30) | 0x10;\ncode_r0x00014000c984:\n            uVar6 = 10;\ncode_r0x00014000c98c:\n            uVar5 = fcn.14000d708(arg1, uVar6);\n        }\n        else {\n            if (uVar4 == 0x41) goto code_r0x00014000c993;\n            if (uVar4 == 0x43) {\ncode_r0x00014000c8f9:\n                uVar5 = fcn.14000d5ac(arg1);\n            }\n            else {\n                if (uVar4 < 0x45) goto code_r0x00014000c99c;\n                if (uVar4 < 0x48) goto code_r0x00014000c993;\n                if (uVar4 == 0x53) {\ncode_r0x00014000c93c:\n                    uVar5 = fcn.14000d984(arg1);\n                }\n                else {\n                    if (uVar4 == 0x58) goto code_r0x00014000c951;\n                    if (uVar4 != 0x5a) {\n                        if (uVar4 != 0x61) {\n                            if (uVar4 != 99) goto code_r0x00014000c99c;\n                            goto code_r0x00014000c8f9;\n                        }\n                        goto code_r0x00014000c993;\n                    }\n                    uVar5 = fcn.14000d04c(arg1);\n                }\n            }\n        }\n    }\n    else {\n        if (0x67 < uVar4) {\n            if (uVar4 == 0x69) goto code_r0x00014000c980;\n            if (uVar4 == 0x6e) {\n                uVar5 = fcn.14000d8a8(arg1);\n                goto code_r0x00014000c998;\n            }\n            if (uVar4 == 0x6f) {\n                if ((*(arg1 + 0x30) >> 5 & 1) != 0) {\n                    *(arg1 + 0x30) = *(arg1 + 0x30) | 0x80;\n                }\n                uVar6 = 8;\n            }\n            else if (uVar4 == 0x70) {\n                *(arg1 + 0x38) = 0x10;\n                *(arg1 + 0x3c) = 0xb;\ncode_r0x00014000c951:\n                uVar6 = 0x10;\n            }\n            else {\n                if (uVar4 == 0x73) goto code_r0x00014000c93c;\n                if (uVar4 == 0x75) goto code_r0x00014000c984;\n                if (uVar4 != 0x78) goto code_r0x00014000c99c;\n                uVar6 = 0x10;\n            }\n            goto code_r0x00014000c98c;\n        }\ncode_r0x00014000c993:\n        uVar5 = fcn.14000d14c(arg1);\n    }\ncode_r0x00014000c998:\n    if (uVar5 == '\\0') {\ncode_r0x00014000c99c:\n        return uVar5 & 0xffffffffffffff00;\n    }\n    if (*(arg1 + 0x40) != '\\0') goto code_r0x00014000cae5;\n    uVar4 = *(arg1 + 0x30);\n    uStackX8 = 0;\n    arg3 = 0;\n    uStackX10 = 0;\n    if ((uVar4 >> 4 & 1) != 0) {\n        if ((uVar4 >> 6 & 1) == 0) {\n            if ((uVar4 & 1) == 0) {\n                if ((uVar4 >> 1 & 1) == 0) goto code_r0x00014000c9f5;\n                uStackX8 = 0x20;\n            }\n            else {\n                uStackX8 = 0x2b;\n            }\n        }\n        else {\n            uStackX8 = 0x2d;\n        }\n        arg3 = 1;\n    }\ncode_r0x00014000c9f5:\n    cVar1 = *(arg1 + 0x41);\n    if (((cVar1 + 0xa8U & 0xdf) == 0) && ((uVar4 >> 5 & 1) != 0)) {\n        bVar2 = true;\n    }\n    else {\n        bVar2 = false;\n    }\n    if ((bVar2) || ((cVar1 + 0xbfU & 0xdf) == 0)) {\n        *(&uStackX8 + arg3) = 0x30;\n        if ((cVar1 != 'X') && (cVar1 != 'A')) {\n            cVar3 = '\\0';\n        }\n        *(&uStackX8 + arg3 + 1) = (-cVar3 & 0xe0U) + 0x78;\n        arg3 = arg3 + 2;\n    }\n    uVar7 = (*(arg1 + 0x34) - *(arg1 + 0x50)) - arg3;\n    if ((uVar4 & 0xc) == 0) {\n        fcn.14000b60c(arg1 + 0x468, CONCAT71(uVar4 >> 8, 0x20), uVar7, arg1 + 0x28);\n    }\n    arg4 = arg1 + 0x28;\n    arg1_00 = arg1 + 0x468;\n    arg2 = &uStackX8;\n    fcn.14000de08(arg1_00, arg2, arg3, arg4);\n    if (((*(arg1 + 0x30) >> 3 & 1) != 0) && ((*(arg1 + 0x30) >> 2 & 1) == 0)) {\n        fcn.14000b60c(arg1_00, CONCAT71(arg2 >> 8, 0x30), uVar7, arg4);\n    }\n    uVar6 = 0;\n    uVar5 = fcn.14000db68(arg1);\n    if ((-1 < *arg4) && (uVar4 = *(arg1 + 0x30) >> 2,  uVar5 = uVar4,  (uVar4 & 1) != 0)) {\n        uVar5 = fcn.14000b60c(arg1_00, CONCAT71(uVar6 >> 8, 0x20), uVar7, arg4);\n    }\ncode_r0x00014000cae5:\n    return uVar5 & 0xffffffffffffff00 | 1;\n}\n",
        "token_count": 1722
    },
    "14000c56": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint64_t fcn.14000c568(uint8_t *arg1)\n\n{\n    int32_t *arg4;\n    uint8_t *arg1_00;\n    uint8_t uVar1;\n    char cVar2;\n    char *pcVar3;\n    bool bVar4;\n    uint32_t uVar5;\n    uint64_t in_RAX;\n    uint *puVar6;\n    char *pcVar7;\n    uint64_t uVar8;\n    ulong uVar9;\n    ushort *arg2;\n    uint32_t uVar10;\n    int64_t arg3;\n    ushort uStackX8;\n    uchar uStackX10;\n    \n    uVar1 = arg1[0x41];\n    pcVar7 = in_RAX & 0xffffffffffffff00;\n    if (uVar1 != 0x46) {\n        if (uVar1 == 0x4e) {\n            if ((*arg1 & 8) == 0) {\n                *(arg1 + 0x2c) = 8;\ncode_r0x00014000c5a0:\n                puVar6 = fcn.1400139ac();\n                *puVar6 = 0x16;\n                uVar8 = fcn.14001388c();\n                return uVar8 & 0xffffffffffffff00;\n            }\n        }\n        else {\n            if (*(arg1 + 0x3c) != 0) goto code_r0x00014000c5a0;\n            if (uVar1 == 0x49) {\n                pcVar3 = *(arg1 + 0x18);\n                cVar2 = *pcVar3;\n                if ((cVar2 == '3') && (pcVar3[1] == '2')) {\n                    pcVar7 = pcVar3 + 2;\n                    *(arg1 + 0x3c) = 10;\n                    *(arg1 + 0x18) = pcVar7;\n                }\n                else if ((cVar2 == '6') && (pcVar3[1] == '4')) {\n                    pcVar7 = pcVar3 + 2;\n                    *(arg1 + 0x3c) = 0xb;\n                    *(arg1 + 0x18) = pcVar7;\n                }\n                else if ((cVar2 + 0xa8U < 0x21) && (pcVar7 = cVar2 + 0xa8U,  (0x120821001U >> (pcVar7 & 0x3f) & 1) != 0)\n                        ) {\n                    *(arg1 + 0x3c) = 9;\n                }\n            }\n            else if (uVar1 == 0x4c) {\n                *(arg1 + 0x3c) = 8;\n            }\n            else if (uVar1 == 0x54) {\n                *(arg1 + 0x3c) = 0xd;\n            }\n            else if (uVar1 == 0x68) {\n                pcVar7 = *(arg1 + 0x18);\n                if (*pcVar7 == 'h') {\n                    pcVar7 = pcVar7 + 1;\n                    *(arg1 + 0x3c) = 1;\n                    *(arg1 + 0x18) = pcVar7;\n                }\n                else {\n                    *(arg1 + 0x3c) = 2;\n                }\n            }\n            else if (uVar1 == 0x6a) {\n                *(arg1 + 0x3c) = 5;\n            }\n            else if (uVar1 == 0x6c) {\n                pcVar7 = *(arg1 + 0x18);\n                if (*pcVar7 == 'l') {\n                    pcVar7 = pcVar7 + 1;\n                    *(arg1 + 0x3c) = 4;\n                    *(arg1 + 0x18) = pcVar7;\n                }\n                else {\n                    *(arg1 + 0x3c) = 3;\n                }\n            }\n            else if (uVar1 == 0x74) {\n                *(arg1 + 0x3c) = 7;\n            }\n            else {\n                if (uVar1 != 0x77) {\n                    uVar8 = CONCAT71(pcVar7 >> 8, 1);\n                    if (uVar1 != 0x7a) {\n                        return uVar8;\n                    }\n                    *(arg1 + 0x3c) = 6;\n                    return uVar8;\n                }\n                *(arg1 + 0x3c) = 0xc;\n            }\n        }\ncode_r0x00014000c6dc:\n        return CONCAT71(pcVar7 >> 8, 1);\n    }\n    if ((*arg1 & 8) != 0) goto code_r0x00014000c6dc;\n    *(arg1 + 0x2c) = 7;\n    uVar5 = arg1[0x41];\n    uVar8 = uVar5;\n    cVar2 = '\\x01';\n    if (uVar5 < 0x65) {\n        if (uVar5 == 100) {\ncode_r0x00014000cbfc:\n            *(arg1 + 0x30) = *(arg1 + 0x30) | 0x10;\ncode_r0x00014000cc00:\n            uVar9 = 10;\ncode_r0x00014000cc08:\n            uVar8 = fcn.14000d708(arg1, uVar9);\n        }\n        else {\n            if (uVar5 == 0x41) goto code_r0x00014000cc0f;\n            if (uVar5 == 0x43) {\ncode_r0x00014000cb75:\n                uVar8 = fcn.14000d5ac(arg1);\n            }\n            else {\n                if (uVar5 < 0x45) goto code_r0x00014000cc18;\n                if (uVar5 < 0x48) goto code_r0x00014000cc0f;\n                if (uVar5 == 0x53) {\ncode_r0x00014000cbb8:\n                    uVar8 = fcn.14000d984(arg1);\n                }\n                else {\n                    if (uVar5 == 0x58) goto code_r0x00014000cbcd;\n                    if (uVar5 != 0x5a) {\n                        if (uVar5 != 0x61) {\n                            if (uVar5 != 99) goto code_r0x00014000cc18;\n                            goto code_r0x00014000cb75;\n                        }\n                        goto code_r0x00014000cc0f;\n                    }\n                    uVar8 = fcn.14000d04c(arg1);\n                }\n            }\n        }\n    }\n    else {\n        if (0x67 < uVar5) {\n            if (uVar5 == 0x69) goto code_r0x00014000cbfc;\n            if (uVar5 == 0x6e) {\n                uVar8 = fcn.14000d8a8(arg1);\n                goto code_r0x00014000cc14;\n            }\n            if (uVar5 == 0x6f) {\n                if ((*(arg1 + 0x30) >> 5 & 1) != 0) {\n                    *(arg1 + 0x30) = *(arg1 + 0x30) | 0x80;\n                }\n                uVar9 = 8;\n            }\n            else if (uVar5 == 0x70) {\n                *(arg1 + 0x38) = 0x10;\n                *(arg1 + 0x3c) = 0xb;\ncode_r0x00014000cbcd:\n                uVar9 = 0x10;\n            }\n            else {\n                if (uVar5 == 0x73) goto code_r0x00014000cbb8;\n                if (uVar5 == 0x75) goto code_r0x00014000cc00;\n                if (uVar5 != 0x78) goto code_r0x00014000cc18;\n                uVar9 = 0x10;\n            }\n            goto code_r0x00014000cc08;\n        }\ncode_r0x00014000cc0f:\n        uVar8 = fcn.14000d14c(arg1);\n    }\ncode_r0x00014000cc14:\n    if (uVar8 == '\\0') {\ncode_r0x00014000cc18:\n        return uVar8 & 0xffffffffffffff00;\n    }\n    if (arg1[0x40] != 0) goto code_r0x00014000cd61;\n    uVar5 = *(arg1 + 0x30);\n    uStackX8 = 0;\n    arg3 = 0;\n    uStackX10 = 0;\n    if ((uVar5 >> 4 & 1) != 0) {\n        if ((uVar5 >> 6 & 1) == 0) {\n            if ((uVar5 & 1) == 0) {\n                if ((uVar5 >> 1 & 1) == 0) goto code_r0x00014000cc71;\n                uStackX8 = 0x20;\n            }\n            else {\n                uStackX8 = 0x2b;\n            }\n        }\n        else {\n            uStackX8 = 0x2d;\n        }\n        arg3 = 1;\n    }\ncode_r0x00014000cc71:\n    uVar1 = arg1[0x41];\n    if (((uVar1 + 0xa8 & 0xdf) == 0) && ((uVar5 >> 5 & 1) != 0)) {\n        bVar4 = true;\n    }\n    else {\n        bVar4 = false;\n    }\n    if ((bVar4) || ((uVar1 + 0xbf & 0xdf) == 0)) {\n        *(&uStackX8 + arg3) = 0x30;\n        if ((uVar1 != 0x58) && (uVar1 != 0x41)) {\n            cVar2 = '\\0';\n        }\n        *(&uStackX8 + arg3 + 1) = (-cVar2 & 0xe0U) + 0x78;\n        arg3 = arg3 + 2;\n    }\n    uVar10 = (*(arg1 + 0x34) - *(arg1 + 0x50)) - arg3;\n    if ((uVar5 & 0xc) == 0) {\n        fcn.14000b690(arg1 + 0x468, CONCAT71(uVar5 >> 8, 0x20), uVar10, arg1 + 0x28);\n    }\n    arg4 = arg1 + 0x28;\n    arg1_00 = arg1 + 0x468;\n    arg2 = &uStackX8;\n    fcn.14000df00(arg1_00, arg2, arg3, arg4);\n    if (((*(arg1 + 0x30) >> 3 & 1) != 0) && ((*(arg1 + 0x30) >> 2 & 1) == 0)) {\n        fcn.14000b690(arg1_00, CONCAT71(arg2 >> 8, 0x30), uVar10, arg4);\n    }\n    uVar9 = 0;\n    uVar8 = fcn.14000dc40(arg1);\n    if ((-1 < *arg4) && (uVar8 = *(arg1 + 0x30) >> 2,  (*(arg1 + 0x30) >> 2 & 1) != 0)) {\n        uVar8 = fcn.14000b690(arg1_00, CONCAT71(uVar9 >> 8, 0x20), uVar10, arg4);\n    }\ncode_r0x00014000cd61:\n    return uVar8 & 0xffffffffffffff00 | 1;\n}\n",
        "token_count": 2679
    },
    "14000cb0": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint64_t fcn.14000cb04(int64_t arg1)\n\n{\n    int32_t *arg4;\n    int64_t arg1_00;\n    char cVar1;\n    bool bVar2;\n    char cVar3;\n    uint32_t uVar4;\n    uint64_t uVar5;\n    ulong uVar6;\n    ushort *arg2;\n    uint32_t uVar7;\n    int64_t arg3;\n    ushort uStackX8;\n    uchar uStackX10;\n    \n    uVar4 = *(arg1 + 0x41);\n    uVar5 = uVar4;\n    cVar3 = '\\x01';\n    if (uVar4 < 0x65) {\n        if (uVar4 == 100) {\ncode_r0x00014000cbfc:\n            *(arg1 + 0x30) = *(arg1 + 0x30) | 0x10;\ncode_r0x00014000cc00:\n            uVar6 = 10;\ncode_r0x00014000cc08:\n            uVar5 = fcn.14000d708(arg1, uVar6);\n        }\n        else {\n            if (uVar4 == 0x41) goto code_r0x00014000cc0f;\n            if (uVar4 == 0x43) {\ncode_r0x00014000cb75:\n                uVar5 = fcn.14000d5ac(arg1);\n            }\n            else {\n                if (uVar4 < 0x45) goto code_r0x00014000cc18;\n                if (uVar4 < 0x48) goto code_r0x00014000cc0f;\n                if (uVar4 == 0x53) {\ncode_r0x00014000cbb8:\n                    uVar5 = fcn.14000d984(arg1);\n                }\n                else {\n                    if (uVar4 == 0x58) goto code_r0x00014000cbcd;\n                    if (uVar4 != 0x5a) {\n                        if (uVar4 != 0x61) {\n                            if (uVar4 != 99) goto code_r0x00014000cc18;\n                            goto code_r0x00014000cb75;\n                        }\n                        goto code_r0x00014000cc0f;\n                    }\n                    uVar5 = fcn.14000d04c(arg1);\n                }\n            }\n        }\n    }\n    else {\n        if (0x67 < uVar4) {\n            if (uVar4 == 0x69) goto code_r0x00014000cbfc;\n            if (uVar4 == 0x6e) {\n                uVar5 = fcn.14000d8a8(arg1);\n                goto code_r0x00014000cc14;\n            }\n            if (uVar4 == 0x6f) {\n                if ((*(arg1 + 0x30) >> 5 & 1) != 0) {\n                    *(arg1 + 0x30) = *(arg1 + 0x30) | 0x80;\n                }\n                uVar6 = 8;\n            }\n            else if (uVar4 == 0x70) {\n                *(arg1 + 0x38) = 0x10;\n                *(arg1 + 0x3c) = 0xb;\ncode_r0x00014000cbcd:\n                uVar6 = 0x10;\n            }\n            else {\n                if (uVar4 == 0x73) goto code_r0x00014000cbb8;\n                if (uVar4 == 0x75) goto code_r0x00014000cc00;\n                if (uVar4 != 0x78) goto code_r0x00014000cc18;\n                uVar6 = 0x10;\n            }\n            goto code_r0x00014000cc08;\n        }\ncode_r0x00014000cc0f:\n        uVar5 = fcn.14000d14c(arg1);\n    }\ncode_r0x00014000cc14:\n    if (uVar5 == '\\0') {\ncode_r0x00014000cc18:\n        return uVar5 & 0xffffffffffffff00;\n    }\n    if (*(arg1 + 0x40) != '\\0') goto code_r0x00014000cd61;\n    uVar4 = *(arg1 + 0x30);\n    uStackX8 = 0;\n    arg3 = 0;\n    uStackX10 = 0;\n    if ((uVar4 >> 4 & 1) != 0) {\n        if ((uVar4 >> 6 & 1) == 0) {\n            if ((uVar4 & 1) == 0) {\n                if ((uVar4 >> 1 & 1) == 0) goto code_r0x00014000cc71;\n                uStackX8 = 0x20;\n            }\n            else {\n                uStackX8 = 0x2b;\n            }\n        }\n        else {\n            uStackX8 = 0x2d;\n        }\n        arg3 = 1;\n    }\ncode_r0x00014000cc71:\n    cVar1 = *(arg1 + 0x41);\n    if (((cVar1 + 0xa8U & 0xdf) == 0) && ((uVar4 >> 5 & 1) != 0)) {\n        bVar2 = true;\n    }\n    else {\n        bVar2 = false;\n    }\n    if ((bVar2) || ((cVar1 + 0xbfU & 0xdf) == 0)) {\n        *(&uStackX8 + arg3) = 0x30;\n        if ((cVar1 != 'X') && (cVar1 != 'A')) {\n            cVar3 = '\\0';\n        }\n        *(&uStackX8 + arg3 + 1) = (-cVar3 & 0xe0U) + 0x78;\n        arg3 = arg3 + 2;\n    }\n    uVar7 = (*(arg1 + 0x34) - *(arg1 + 0x50)) - arg3;\n    if ((uVar4 & 0xc) == 0) {\n        fcn.14000b690(arg1 + 0x468, CONCAT71(uVar4 >> 8, 0x20), uVar7, arg1 + 0x28);\n    }\n    arg4 = arg1 + 0x28;\n    arg1_00 = arg1 + 0x468;\n    arg2 = &uStackX8;\n    fcn.14000df00(arg1_00, arg2, arg3, arg4);\n    if (((*(arg1 + 0x30) >> 3 & 1) != 0) && ((*(arg1 + 0x30) >> 2 & 1) == 0)) {\n        fcn.14000b690(arg1_00, CONCAT71(arg2 >> 8, 0x30), uVar7, arg4);\n    }\n    uVar6 = 0;\n    uVar5 = fcn.14000dc40(arg1);\n    if ((-1 < *arg4) && (uVar4 = *(arg1 + 0x30) >> 2,  uVar5 = uVar4,  (uVar4 & 1) != 0)) {\n        uVar5 = fcn.14000b690(arg1_00, CONCAT71(uVar6 >> 8, 0x20), uVar7, arg4);\n    }\ncode_r0x00014000cd61:\n    return uVar5 & 0xffffffffffffff00 | 1;\n}\n",
        "token_count": 1709
    },
    "14000c6e": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.14000c6e4(uint8_t *arg1)\n\n{\n    int32_t *arg4;\n    uint8_t *arg1_00;\n    int16_t iVar1;\n    uint32_t uVar2;\n    int16_t *piVar3;\n    bool bVar4;\n    char cVar5;\n    char cVar6;\n    uint16_t uVar7;\n    uint *puVar8;\n    ulong uVar9;\n    uchar *arg2;\n    uint64_t uVar10;\n    uint32_t uVar11;\n    int64_t arg3;\n    uchar auStack104 [32];\n    ulong uStack72;\n    uint32_t uStack56;\n    ushort uStack52;\n    uint64_t uStack48;\n    \n    if (*(arg1 + 0x42) != 0x46) {\n        if (*(arg1 + 0x42) == 0x4e) {\n            if ((*arg1 & 8) == 0) {\n                *(arg1 + 0x2c) = 8;\ncode_r0x00014000c71f:\n                uStack48 = 0x14000c724;\n                puVar8 = fcn.1400139ac();\n                *puVar8 = 0x16;\n                uStack48 = 0x14000c72f;\n                fcn.14001388c();\n                return 0;\n            }\n        }\n        else {\n            if (*(arg1 + 0x3c) != 0) goto code_r0x00014000c71f;\n            iVar1 = *(arg1 + 0x42);\n            if (iVar1 == 0x49) {\n                piVar3 = *(arg1 + 0x18);\n                iVar1 = *piVar3;\n                if ((iVar1 == 0x33) && (piVar3[1] == 0x32)) {\n                    *(arg1 + 0x3c) = 10;\n                    *(arg1 + 0x18) = piVar3 + 2;\n                }\n                else if ((iVar1 == 0x36) && (piVar3[1] == 0x34)) {\n                    *(arg1 + 0x3c) = 0xb;\n                    *(arg1 + 0x18) = piVar3 + 2;\n                }\n                else if ((iVar1 - 0x58U < 0x21) && ((0x120821001U >> (iVar1 - 0x58U & 0x3f) & 1) != 0)) {\n                    *(arg1 + 0x3c) = 9;\n                }\n            }\n            else if (iVar1 == 0x4c) {\n                *(arg1 + 0x3c) = 8;\n            }\n            else if (iVar1 == 0x54) {\n                *(arg1 + 0x3c) = 0xd;\n            }\n            else if (iVar1 == 0x68) {\n                if (**(arg1 + 0x18) == 0x68) {\n                    *(arg1 + 0x3c) = 1;\n                    *(arg1 + 0x18) = *(arg1 + 0x18) + 1;\n                }\n                else {\n                    *(arg1 + 0x3c) = 2;\n                }\n            }\n            else if (iVar1 == 0x6a) {\n                *(arg1 + 0x3c) = 5;\n            }\n            else if (iVar1 == 0x6c) {\n                if (**(arg1 + 0x18) == 0x6c) {\n                    *(arg1 + 0x3c) = 4;\n                    *(arg1 + 0x18) = *(arg1 + 0x18) + 1;\n                }\n                else {\n                    *(arg1 + 0x3c) = 3;\n                }\n            }\n            else if (iVar1 == 0x74) {\n                *(arg1 + 0x3c) = 7;\n            }\n            else {\n                if (iVar1 != 0x77) {\n                    if (iVar1 == 0x7a) {\n                        *(arg1 + 0x3c) = 6;\n                        return 1;\n                    }\n                    return 1;\n                }\n                *(arg1 + 0x3c) = 0xc;\n            }\n        }\n        return 1;\n    }\n    if ((*arg1 & 8) != 0) {\n        return 1;\n    }\n    *(arg1 + 0x2c) = 7;\n    uStack48 = *0x140032010 ^ &stack0xffffffffffffff98;\n    uVar7 = *(arg1 + 0x42);\n    cVar5 = '\\x01';\n    if (uVar7 < 0x65) {\n        if (uVar7 == 100) {\ncode_r0x00014000ce8f:\n            *(arg1 + 0x30) = *(arg1 + 0x30) | 0x10;\ncode_r0x00014000ce93:\n            uVar9 = 10;\ncode_r0x00014000ce9b:\n            cVar6 = fcn.14000d708(arg1, uVar9);\n        }\n        else {\n            if (uVar7 == 0x41) goto code_r0x00014000cea2;\n            if (uVar7 == 0x43) {\ncode_r0x00014000ce08:\n                cVar6 = fcn.14000d660(arg1);\n            }\n            else {\n                if (uVar7 < 0x45) goto code_r0x00014000d01e;\n                if (uVar7 < 0x48) goto code_r0x00014000cea2;\n                if (uVar7 == 0x53) {\ncode_r0x00014000ce4b:\n                    cVar6 = fcn.14000da14(arg1);\n                }\n                else {\n                    if (uVar7 == 0x58) goto code_r0x00014000ce60;\n                    if (uVar7 != 0x5a) {\n                        if (uVar7 != 0x61) {\n                            if (uVar7 != 99) goto code_r0x00014000d01e;\n                            goto code_r0x00014000ce08;\n                        }\n                        goto code_r0x00014000cea2;\n                    }\n                    cVar6 = fcn.14000d0cc(arg1);\n                }\n            }\n        }\n    }\n    else {\n        if (0x67 < uVar7) {\n            if (uVar7 == 0x69) goto code_r0x00014000ce8f;\n            if (uVar7 == 0x6e) {\n                cVar6 = fcn.14000d8a8(arg1);\n                goto code_r0x00014000cea7;\n            }\n            if (uVar7 == 0x6f) {\n                if ((*(arg1 + 0x30) >> 5 & 1) != 0) {\n                    *(arg1 + 0x30) = *(arg1 + 0x30) | 0x80;\n                }\n                uVar9 = 8;\n            }\n            else if (uVar7 == 0x70) {\n                *(arg1 + 0x38) = 0x10;\n                *(arg1 + 0x3c) = 0xb;\ncode_r0x00014000ce60:\n                uVar9 = 0x10;\n            }\n            else {\n                if (uVar7 == 0x73) goto code_r0x00014000ce4b;\n                if (uVar7 == 0x75) goto code_r0x00014000ce93;\n                if (uVar7 != 0x78) goto code_r0x00014000d01e;\n                uVar9 = 0x10;\n            }\n            goto code_r0x00014000ce9b;\n        }\ncode_r0x00014000cea2:\n        cVar6 = fcn.14000d368(arg1);\n    }\ncode_r0x00014000cea7:\n    if ((cVar6 == '\\0') || (arg1[0x40] != 0)) goto code_r0x00014000d01e;\n    uVar2 = *(arg1 + 0x30);\n    uStack56 = 0;\n    uStack52 = 0;\n    arg3 = 0;\n    if ((uVar2 >> 4 & 1) != 0) {\n        if ((uVar2 >> 6 & 1) == 0) {\n            if ((uVar2 & 1) == 0) {\n                if ((uVar2 >> 1 & 1) != 0) {\n                    uStack56 = 0x20;\n                    arg3 = 1;\n                }\n                goto code_r0x00014000cf0c;\n            }\n            uVar7 = 0x2b;\n        }\n        else {\n            uVar7 = 0x2d;\n        }\n        uStack56 = uVar7;\n        arg3 = 1;\n    }\ncode_r0x00014000cf0c:\n    iVar1 = *(arg1 + 0x42);\n    if (((iVar1 - 0x58U & 0xffdf) == 0) && ((uVar2 >> 5 & 1) != 0)) {\n        bVar4 = true;\n    }\n    else {\n        bVar4 = false;\n    }\n    if ((bVar4) || ((iVar1 - 0x41U & 0xffdf) == 0)) {\n        *(&stack0xffffffffffffffc8 + arg3 * 2) = 0x30;\n        if ((iVar1 != 0x58) && (iVar1 != 0x41)) {\n            cVar5 = '\\0';\n        }\n        *(&stack0xffffffffffffffc8 + (arg3 + 1) * 2) = (-cVar5 & 0xe0U) + 0x78;\n        arg3 = arg3 + 2;\n    }\n    uVar11 = (*(arg1 + 0x34) - *(arg1 + 0x50)) - arg3;\n    if ((uVar2 & 0xc) == 0) {\n        fcn.14000b6ec(arg1 + 0x468, uVar2 & 0xffffff00 | 0x20, uVar11, arg1 + 0x28);\n    }\n    uStack72 = *(arg1 + 0x10);\n    arg4 = arg1 + 0x28;\n    arg1_00 = arg1 + 0x468;\n    arg2 = &stack0xffffffffffffffc8;\n    fcn.14000dfbc(arg1_00, arg2, arg3, arg4);\n    if (((*(arg1 + 0x30) >> 3 & 1) != 0) && ((*(arg1 + 0x30) >> 2 & 1) == 0)) {\n        fcn.14000b6ec(arg1_00, arg2 & 0xffffffffffffff00 | 0x30, uVar11, arg4);\n    }\n    uVar10 = 0;\n    fcn.14000dd18(arg1);\n    if ((-1 < *arg4) && ((*(arg1 + 0x30) >> 2 & 1) != 0)) {\n        fcn.14000b6ec(arg1_00, uVar10 & 0xffffffffffffff00 | 0x20, uVar11, arg4);\n    }\ncode_r0x00014000d01e:\n    uVar9 = fcn.140008410(uStack48 ^ &stack0xffffffffffffff98);\n    return uVar9;\n}\n",
        "token_count": 2638
    },
    "14000cd8": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.14000cd80(int64_t arg1)\n\n{\n    int32_t *arg4;\n    int64_t arg1_00;\n    int16_t iVar1;\n    uint32_t uVar2;\n    bool bVar3;\n    char cVar4;\n    char cVar5;\n    uint16_t uVar6;\n    ulong arg2;\n    uint32_t *arg2_00;\n    uint64_t uVar7;\n    uint32_t uVar8;\n    int64_t arg3;\n    uchar auStack104 [32];\n    ulong uStack72;\n    uint32_t uStack56;\n    ushort uStack52;\n    uint64_t uStack48;\n    \n    uStack48 = *0x140032010 ^ auStack104;\n    uVar6 = *(arg1 + 0x42);\n    cVar4 = '\\x01';\n    if (uVar6 < 0x65) {\n        if (uVar6 == 100) {\ncode_r0x00014000ce8f:\n            *(arg1 + 0x30) = *(arg1 + 0x30) | 0x10;\ncode_r0x00014000ce93:\n            arg2 = 10;\ncode_r0x00014000ce9b:\n            cVar5 = fcn.14000d708(arg1, arg2);\n        }\n        else {\n            if (uVar6 == 0x41) goto code_r0x00014000cea2;\n            if (uVar6 == 0x43) {\ncode_r0x00014000ce08:\n                cVar5 = fcn.14000d660(arg1);\n            }\n            else {\n                if (uVar6 < 0x45) goto code_r0x00014000d01e;\n                if (uVar6 < 0x48) goto code_r0x00014000cea2;\n                if (uVar6 == 0x53) {\ncode_r0x00014000ce4b:\n                    cVar5 = fcn.14000da14(arg1);\n                }\n                else {\n                    if (uVar6 == 0x58) goto code_r0x00014000ce60;\n                    if (uVar6 != 0x5a) {\n                        if (uVar6 != 0x61) {\n                            if (uVar6 != 99) goto code_r0x00014000d01e;\n                            goto code_r0x00014000ce08;\n                        }\n                        goto code_r0x00014000cea2;\n                    }\n                    cVar5 = fcn.14000d0cc(arg1);\n                }\n            }\n        }\n    }\n    else {\n        if (0x67 < uVar6) {\n            if (uVar6 == 0x69) goto code_r0x00014000ce8f;\n            if (uVar6 == 0x6e) {\n                cVar5 = fcn.14000d8a8(arg1);\n                goto code_r0x00014000cea7;\n            }\n            if (uVar6 == 0x6f) {\n                if ((*(arg1 + 0x30) >> 5 & 1) != 0) {\n                    *(arg1 + 0x30) = *(arg1 + 0x30) | 0x80;\n                }\n                arg2 = 8;\n            }\n            else if (uVar6 == 0x70) {\n                *(arg1 + 0x38) = 0x10;\n                *(arg1 + 0x3c) = 0xb;\ncode_r0x00014000ce60:\n                arg2 = 0x10;\n            }\n            else {\n                if (uVar6 == 0x73) goto code_r0x00014000ce4b;\n                if (uVar6 == 0x75) goto code_r0x00014000ce93;\n                if (uVar6 != 0x78) goto code_r0x00014000d01e;\n                arg2 = 0x10;\n            }\n            goto code_r0x00014000ce9b;\n        }\ncode_r0x00014000cea2:\n        cVar5 = fcn.14000d368(arg1);\n    }\ncode_r0x00014000cea7:\n    if ((cVar5 == '\\0') || (*(arg1 + 0x40) != '\\0')) goto code_r0x00014000d01e;\n    uVar2 = *(arg1 + 0x30);\n    uStack56 = 0;\n    uStack52 = 0;\n    arg3 = 0;\n    if ((uVar2 >> 4 & 1) != 0) {\n        if ((uVar2 >> 6 & 1) == 0) {\n            if ((uVar2 & 1) == 0) {\n                if ((uVar2 >> 1 & 1) != 0) {\n                    uStack56 = 0x20;\n                    arg3 = 1;\n                }\n                goto code_r0x00014000cf0c;\n            }\n            uVar6 = 0x2b;\n        }\n        else {\n            uVar6 = 0x2d;\n        }\n        uStack56 = uVar6;\n        arg3 = 1;\n    }\ncode_r0x00014000cf0c:\n    iVar1 = *(arg1 + 0x42);\n    if (((iVar1 - 0x58U & 0xffdf) == 0) && ((uVar2 >> 5 & 1) != 0)) {\n        bVar3 = true;\n    }\n    else {\n        bVar3 = false;\n    }\n    if ((bVar3) || ((iVar1 - 0x41U & 0xffdf) == 0)) {\n        *(&uStack56 + arg3 * 2) = 0x30;\n        if ((iVar1 != 0x58) && (iVar1 != 0x41)) {\n            cVar4 = '\\0';\n        }\n        *(&uStack56 + (arg3 + 1) * 2) = (-cVar4 & 0xe0U) + 0x78;\n        arg3 = arg3 + 2;\n    }\n    uVar8 = (*(arg1 + 0x34) - *(arg1 + 0x50)) - arg3;\n    if ((uVar2 & 0xc) == 0) {\n        fcn.14000b6ec(arg1 + 0x468, uVar2 & 0xffffff00 | 0x20, uVar8, arg1 + 0x28);\n    }\n    uStack72 = *(arg1 + 0x10);\n    arg4 = arg1 + 0x28;\n    arg1_00 = arg1 + 0x468;\n    arg2_00 = &uStack56;\n    fcn.14000dfbc(arg1_00, arg2_00, arg3, arg4);\n    if (((*(arg1 + 0x30) >> 3 & 1) != 0) && ((*(arg1 + 0x30) >> 2 & 1) == 0)) {\n        fcn.14000b6ec(arg1_00, arg2_00 & 0xffffffffffffff00 | 0x30, uVar8, arg4);\n    }\n    uVar7 = 0;\n    fcn.14000dd18(arg1);\n    if ((-1 < *arg4) && ((*(arg1 + 0x30) >> 2 & 1) != 0)) {\n        fcn.14000b6ec(arg1_00, uVar7 & 0xffffffffffffff00 | 0x20, uVar8, arg4);\n    }\ncode_r0x00014000d01e:\n    fcn.140008410(uStack48 ^ auStack104);\n    return;\n}\n",
        "token_count": 1746
    },
    "14000d70": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint64_t fcn.14000d708(int64_t arg1, ulong arg2)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    uint64_t uVar3;\n    int32_t iVar4;\n    int64_t iVar5;\n    \n    iVar4 = *(arg1 + 0x3c);\n    iVar5 = 4;\n    if (iVar4 < 6) {\n        if (iVar4 != 5) {\n            if (iVar4 == 0) goto code_r0x00014000d746;\n            if (iVar4 == 1) {\n                iVar5 = 1;\n                goto code_r0x00014000d746;\n            }\n            iVar4 = iVar4 + -2;\n            if (iVar4 == 0) {\n                iVar5 = 2;\n                goto code_r0x00014000d746;\n            }\ncode_r0x00014000d739:\n            if (iVar4 == 1) goto code_r0x00014000d746;\n            if (iVar4 != 2) {\n                iVar5 = 0;\n                goto code_r0x00014000d746;\n            }\n        }\n    }\n    else if (((iVar4 != 6) && (iVar4 != 7)) && (iVar4 = iVar4 + -9,  iVar4 != 0)) goto code_r0x00014000d739;\n    iVar5 = 8;\ncode_r0x00014000d746:\n    if (iVar5 == 1) {\n        *(arg1 + 0x20) = *(arg1 + 0x20) + 8;\n        if ((*(arg1 + 0x30) >> 4 & 1) == 0) {\n            uVar3 = *(*(arg1 + 0x20) + -8);\n        }\n        else {\n            uVar3 = *(*(arg1 + 0x20) + -8);\n        }\n    }\n    else if (iVar5 == 2) {\n        *(arg1 + 0x20) = *(arg1 + 0x20) + 8;\n        if ((*(arg1 + 0x30) >> 4 & 1) == 0) {\n            uVar3 = *(*(arg1 + 0x20) + -8);\n        }\n        else {\n            uVar3 = *(*(arg1 + 0x20) + -8);\n        }\n    }\n    else if (iVar5 == 4) {\n        *(arg1 + 0x20) = *(arg1 + 0x20) + 8;\n        if ((*(arg1 + 0x30) >> 4 & 1) == 0) {\n            uVar3 = *(*(arg1 + 0x20) + -8);\n        }\n        else {\n            uVar3 = *(*(arg1 + 0x20) + -8);\n        }\n    }\n    else {\n        if (iVar5 != 8) {\n            puVar2 = fcn.1400139ac();\n            *puVar2 = 0x16;\n            uVar3 = fcn.14001388c();\n            return uVar3 & 0xffffffffffffff00;\n        }\n        *(arg1 + 0x20) = *(arg1 + 0x20) + 8;\n        uVar3 = *(*(arg1 + 0x20) + -8);\n    }\n    if (((*(arg1 + 0x30) >> 4 & 1) != 0) && (uVar3 < 0)) {\n        uVar3 = -uVar3;\n        *(arg1 + 0x30) = *(arg1 + 0x30) | 0x40;\n    }\n    if (*(arg1 + 0x38) < 0) {\n        *(arg1 + 0x38) = 1;\n    }\n    else {\n        *(arg1 + 0x30) = *(arg1 + 0x30) & 0xfffffff7;\n        if (0x200 < *(arg1 + 0x38)) {\n            *(arg1 + 0x38) = 0x200;\n        }\n    }\n    if (uVar3 == 0) {\n        *(arg1 + 0x30) = *(arg1 + 0x30) & 0xffffffdf;\n    }\n    if (iVar5 == 8) {\n        fcn.14000b570(arg1, uVar3, arg2);\n    }\n    else {\n        fcn.14000b4d4(arg1, uVar3 & 0xffffffff, arg2);\n    }\n    uVar1 = *(arg1 + 0x30);\n    if (((uVar1 >> 7 & 1) != 0) && ((*(arg1 + 0x50) == 0 || (**(arg1 + 0x48) != '0')))) {\n        *(arg1 + 0x48) = *(arg1 + 0x48) + -1;\n        **(arg1 + 0x48) = 0x30;\n        *(arg1 + 0x50) = *(arg1 + 0x50) + 1;\n    }\n    return CONCAT71(uVar1 >> 0xf, 1);\n}\n",
        "token_count": 1161
    },
    "14001234": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00014001218c)\n// WARNING: Removing unreachable block (ram,0x000140012187)\n// WARNING: Removing unreachable block (ram,0x0001400121f5)\n\nvoid fcn.140012340(ulong arg1)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int16_t *piVar3;\n    int32_t *piVar4;\n    code *pcVar5;\n    \n    piVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    if ((((piVar3 != NULL) && (*piVar3 == 0x5a4d)) && (piVar4 = *(piVar3 + 0x1e) + piVar3,  *piVar4 == 0x4550)) &&\n       (((*(piVar4 + 6) == 0x20b && (0xe < piVar4[0x21])) && (piVar4[0x3e] != 0)))) {\n        fcn.14001225c(arg1);\n    }\n    fcn.1400189dc(2);\n    if (*0x14003c730 == '\\0') {\n        *0x14003c720 = 1;\n        uVar2 = *0x140032010 & 0x3f;\n        uVar1 = 0x40 - uVar2 & 0x3f;\n        if (*0x14003c728 != ((0 >> uVar1 | 0 << 0x40 - uVar1) ^ *0x140032010)) {\n            pcVar5 = (*0x140032010 ^ *0x14003c728) >> uVar2 | (*0x140032010 ^ *0x14003c728) << 0x40 - uVar2;\n            (**0x140022310)(pcVar5);\n            (*pcVar5)(0, 0, 0);\n        }\n        fcn.140012810(0x14003c740);\n        fcn.140011fd4(0x140022378, 0x1400223a0);\n        fcn.140011fd4(0x1400223a8, 0x1400223b0);\n        *0x14003c730 = '\\x01';\n    }\n    fcn.140018a30(2);\n    fcn.140012210(arg1);\n    pcVar5 = swi(3);\n    (*pcVar5)();\n    return;\n}\n",
        "token_count": 555
    },
    "140012a0": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.140012a0c(void)\n\n{\n    code *pcVar1;\n    char cVar2;\n    ulong uVar3;\n    code **ppcVar4;\n    bool bVar5;\n    \n    ppcVar4 = 0x140027740;\n    do {\n        pcVar1 = *ppcVar4;\n        if (pcVar1 != NULL) {\n            (**0x140022310)(pcVar1);\n            cVar2 = (*pcVar1)();\n            if (cVar2 == '\\0') break;\n        }\n        ppcVar4 = ppcVar4 + 2;\n    } while (ppcVar4 != 0x140027830);\n    if (ppcVar4 == 0x140027830) {\n        uVar3 = 1;\n    }\n    else {\n        if (ppcVar4 != 0x140027740) {\n            ppcVar4 = ppcVar4 + -1;\n            do {\n                if ((ppcVar4[-1] != NULL) && (pcVar1 = *ppcVar4,  pcVar1 != NULL)) {\n                    (**0x140022310)(pcVar1);\n                    (*pcVar1)(0);\n                }\n                bVar5 = ppcVar4 != 0x140027748;\n                ppcVar4 = ppcVar4 + -2;\n            } while (bVar5);\n        }\n        uVar3 = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 325
    },
    "14000a95": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint fcn.14000a95c(int64_t arg1, ulong arg2, uint64_t arg3)\n\n{\n    uint uVar1;\n    uint *puVar2;\n    \n    if ((arg1 == 0) || (2 < (arg3 & 0xffffffff))) {\n        puVar2 = fcn.1400139ac();\n        *puVar2 = 0x16;\n        fcn.14001388c();\n        uVar1 = 0xffffffff;\n    }\n    else {\n        fcn.14000b29c(arg1);\n        uVar1 = fcn.14000a864(arg1, arg2, arg3 & 0xffffffff);\n        fcn.14000b2a8(arg1);\n    }\n    return uVar1;\n}\n",
        "token_count": 169
    },
    "1400102e": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.1400102e8(int64_t arg1, int32_t *arg2)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int64_t iVar5;\n    ulong uVar6;\n    uchar auStack664 [32];\n    ulong uStack632;\n    uint uStack624;\n    int32_t iStack616;\n    uchar auStack612 [8];\n    uchar auStack604 [8];\n    uchar auStack596 [12];\n    int32_t iStack584;\n    uchar auStack572 [548];\n    uint64_t uStack24;\n    \n    uStack24 = *0x140032010 ^ auStack664;\n    if ((arg2 == NULL) || (arg1 == 0)) {\n        puVar4 = fcn.1400139ac();\n        *puVar4 = 0x16;\n        fcn.14001388c();\n        goto code_r0x000140010002;\n    }\n    uStack624 = 0;\n    uStack632 = 0;\n    iVar5 = (*_sym.imp.KERNEL32.dll_FindFirstFileExW)(arg1, 0, &iStack616, 0);\n    if (iVar5 != -1) {\n        if (iStack616 == 0x80) {\n            iStack616 = 0;\n        }\n        *arg2 = iStack616;\n        uVar6 = fcn.140010230(auStack612);\n        *(arg2 + 2) = uVar6;\n        uVar6 = fcn.140010230(auStack604);\n        *(arg2 + 4) = uVar6;\n        uVar6 = fcn.140010230(auStack596);\n        *(arg2 + 6) = uVar6;\n        arg2[8] = iStack584;\n        iVar3 = fcn.140018b6c(arg2 + 9, 0x104, auStack572);\n        if (iVar3 != 0) {\n            uStack632 = 0;\n            fcn.1400138ac(0, 0, 0, 0);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n        goto code_r0x000140010002;\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    if (uVar2 < 2) {\ncode_r0x000140010068:\n        puVar4 = fcn.1400139ac();\n        *puVar4 = 0x16;\n    }\n    else {\n        if (3 < uVar2) {\n            if (uVar2 == 8) {\n                puVar4 = fcn.1400139ac();\n                *puVar4 = 0xc;\n                goto code_r0x000140010002;\n            }\n            if (uVar2 != 0x12) goto code_r0x000140010068;\n        }\n        puVar4 = fcn.1400139ac();\n        *puVar4 = 2;\n    }\ncode_r0x000140010002:\n    fcn.140008410(uStack24 ^ auStack664);\n    return;\n}\n",
        "token_count": 707
    },
    "1400102f": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.1400102f0(int64_t arg1, int32_t *arg2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint *puVar4;\n    ulong uVar5;\n    uchar auStack664 [32];\n    ulong uStack632;\n    int32_t iStack616;\n    uchar auStack612 [8];\n    uchar auStack604 [8];\n    uchar auStack596 [12];\n    int32_t iStack584;\n    uchar auStack572 [548];\n    uint64_t uStack24;\n    \n    uStack24 = *0x140032010 ^ auStack664;\n    if (((arg1 == 0) || (arg1 == -1)) || (arg2 == NULL)) {\n        puVar4 = fcn.1400139ac();\n        *puVar4 = 0x16;\n        fcn.14001388c();\n        goto code_r0x000140010144;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(arg1, &iStack616);\n    if (iVar2 != 0) {\n        if (iStack616 == 0x80) {\n            iStack616 = 0;\n        }\n        *arg2 = iStack616;\n        uVar5 = fcn.140010230(auStack612);\n        *(arg2 + 2) = uVar5;\n        uVar5 = fcn.140010230(auStack604);\n        *(arg2 + 4) = uVar5;\n        uVar5 = fcn.140010230(auStack596);\n        *(arg2 + 6) = uVar5;\n        arg2[8] = iStack584;\n        iVar2 = fcn.140018b6c(arg2 + 9, 0x104, auStack572);\n        if (iVar2 != 0) {\n            uStack632 = 0;\n            fcn.1400138ac(0, 0, 0, 0);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n        goto code_r0x000140010144;\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    if (uVar3 < 2) {\ncode_r0x000140010199:\n        puVar4 = fcn.1400139ac();\n        *puVar4 = 0x16;\n    }\n    else {\n        if (3 < uVar3) {\n            if (uVar3 == 8) {\n                puVar4 = fcn.1400139ac();\n                *puVar4 = 0xc;\n                goto code_r0x000140010144;\n            }\n            if (uVar3 != 0x12) goto code_r0x000140010199;\n        }\n        puVar4 = fcn.1400139ac();\n        *puVar4 = 2;\n    }\ncode_r0x000140010144:\n    fcn.140008410(uStack24 ^ auStack664);\n    return;\n}\n",
        "token_count": 679
    },
    "1400019a": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nvoid fcn.1400019a0(ulong arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    ulong uStackX24;\n    ulong uStackX32;\n    \n    uStackX24 = arg3;\n    uStackX32 = arg4;\n    fcn.140001a90(arg2, &uStackX24);\n    fcn.14000b2b4(arg1);\n    return;\n}\n",
        "token_count": 95
    },
    "140001a4": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nvoid fcn.140001a40(ulong arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    uint uVar1;\n    ulong arg3_00;\n    ulong uStackX24;\n    ulong uStackX32;\n    \n    uStackX24 = arg3;\n    uStackX32 = arg4;\n    fcn.140001a90(arg2, &uStackX24);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    arg3_00 = fcn.140004e70(uVar1);\n    fcn.140001970(\"%s: %s\", arg1, arg3_00, arg4);\n    return;\n}\n",
        "token_count": 151
    },
    "1400029b": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nvoid fcn.1400029b0(ulong arg1, ulong arg2)\n\n{\n    ulong in_R9;\n    uchar auStack616 [32];\n    uchar auStack584 [32];\n    uchar auStack552 [528];\n    uint64_t uStack24;\n    \n    uStack24 = *0x140032010 ^ auStack616;\n    fcn.1400052b0(auStack552, arg1, 0x104, in_R9);\n    fcn.1400052b0(auStack584, arg2, 10, in_R9);\n    fcn.14000f1bc(auStack552, auStack584);\n    fcn.140008410(uStack24 ^ auStack616);\n    return;\n}\n",
        "token_count": 162
    },
    "140004e7": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nvoid fcn.140004e70(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    uint64_t arg3;\n    ulong arg4;\n    int64_t iStackX32;\n    ulong uStack8;\n    \n    uStack8 = 0x140004e7a;\n    iVar2 = fcn.140008450();\n    iVar2 = -iVar2;\n    *(&stack0x00002040 + iVar2) = *0x140032010 ^ &stack0x00000000 + iVar2;\n    if (param_1 == 0) {\n        *(&stack0xfffffffffffffff8 + iVar2) = 0x140004e9b;\n        param_1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    }\n    *(&stack0x00000030 + iVar2) = 0;\n    *(&stack0x00000028 + iVar2) = 0x1000;\n    arg4 = 0x400;\n    *(&stack0x00000020 + iVar2) = &stack0x00000040 + iVar2;\n    arg3 = param_1;\n    *(&stack0xfffffffffffffff8 + iVar2) = 0x140004ecc;\n    iVar1 = (*_sym.imp.KERNEL32.dll_FormatMessageW)(0x1000, 0);\n    if (iVar1 == 0) {\n        *(&stack0xfffffffffffffff8 + iVar2) = 0x140004ee3;\n        fcn.140001a40(0x140023b60, \"No error messages generated.\\n\", arg3, arg4);\n        *(&stack0xfffffffffffffff8 + iVar2) = 0x140004efa;\n        fcn.140008410(*(&stack0x00002040 + iVar2) ^ &stack0x00000000 + iVar2);\n        return;\n    }\n    *(&stack0xfffffffffffffff8 + iVar2) = 0x140004f19;\n    fcn.1400053b0(0x14003ad00, &stack0x00000040 + iVar2, 0x1000, arg4);\n    *(&stack0xfffffffffffffff8 + iVar2) = 0x140004f3c;\n    fcn.140008410(*(&stack0x00002040 + iVar2) ^ &stack0x00000000 + iVar2);\n    return;\n}\n",
        "token_count": 530
    },
    "14000f1b": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nint64_t fcn.14000f1bc(int16_t *arg1, int16_t *arg2)\n\n{\n    uint *puVar1;\n    int64_t iVar2;\n    int64_t iStackX8;\n    \n    if (((arg1 == NULL) || (arg2 == NULL)) || (*arg2 == 0)) {\n        puVar1 = fcn.1400139ac();\n        *puVar1 = 0x16;\n        fcn.14001388c();\n    }\n    else if (*arg1 == 0) {\n        puVar1 = fcn.1400139ac();\n        *puVar1 = 0x16;\n    }\n    else {\n        fcn.140013ba0(&iStackX8);\n        if (iStackX8 != 0) {\n            iVar2 = fcn.1400188b8(arg1, arg2, 0x40, iStackX8);\n            if (iVar2 == 0) {\n                fcn.140013bfc(iStackX8);\n            }\n            fcn.14000b2a8(iStackX8);\n            return iVar2;\n        }\n        puVar1 = fcn.1400139ac();\n        *puVar1 = 0x18;\n    }\n    return 0;\n}\n",
        "token_count": 283
    },
    "140013a4": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nulong fcn.140013a40(ulong arg1)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    uint32_t auStackX8 [2];\n    uchar auStackX16 [8];\n    uint32_t auStackX24 [2];\n    uint32_t auStackX32 [2];\n    uint32_t *apuStack24 [3];\n    \n    auStackX8[0] = arg1;\n    if (arg1 == 0xfffffffe) {\n        puVar1 = fcn.14001398c();\n        *puVar1 = 0;\n        puVar1 = fcn.1400139ac();\n        *puVar1 = 9;\n    }\n    else {\n        if (((-1 < arg1) && (arg1 < *0x14003cb80)) &&\n           ((*(*((arg1 >> 6) * 8 + 0x14003c780) + 0x38 + (arg1 & 0x3f) * 0x40) & 1) != 0)) {\n            apuStack24[0] = auStackX8;\n            auStackX24[0] = arg1;\n            auStackX32[0] = arg1;\n            uVar2 = fcn.1400139cc(auStackX16, auStackX32, apuStack24, auStackX24);\n            return uVar2;\n        }\n        puVar1 = fcn.14001398c();\n        *puVar1 = 0;\n        puVar1 = fcn.1400139ac();\n        *puVar1 = 9;\n        fcn.14001388c();\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 373
    },
    "14000405": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nvoid fcn.140004050(ulong param_1, int64_t param_2, ulong param_3, ulong param_4)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int64_t iVar3;\n    int64_t arg2;\n    ulong uVar4;\n    ulong uVar5;\n    int64_t noname_0;\n    int32_t iVar6;\n    uint64_t arg4;\n    int64_t iStackX8;\n    uchar auStackX16 [8];\n    ulong uStack32;\n    \n    uStack32 = 0x140004068;\n    iVar3 = fcn.140008450();\n    iVar3 = -iVar3;\n    *(&stack0x00003048 + iVar3) = *0x140032010 ^ &stack0xffffffffffffffe8 + iVar3;\n    if (param_2 == 0) {\n        arg2 = *(&stack0x00000008 + iVar3);\n    }\n    else {\n        *(&stack0xffffffffffffffe0 + iVar3) = 0x140004094;\n        arg2 = fcn.140004290(0x140023a64);\n        *(&stack0xffffffffffffffe0 + iVar3) = 0x1400040a9;\n        fcn.140002a20(&stack0x00000038 + iVar3, 0x1000);\n        *(&stack0xffffffffffffffe0 + iVar3) = 0x1400040ba;\n        uVar4 = fcn.1400052b0(0, 0x140023a64, 0, param_4);\n        *(&stack0xffffffffffffffe0 + iVar3) = 0x1400040cc;\n        uVar5 = fcn.1400052b0(0, &stack0x00000038 + iVar3, 0, param_4);\n        *(&stack0xffffffffffffffe0 + iVar3) = 0x1400040da;\n        fcn.14000ff60(uVar4, uVar5);\n        *(&stack0xffffffffffffffe0 + iVar3) = 0x1400040e2;\n        fcn.14000a248(uVar4);\n        *(&stack0xffffffffffffffe0 + iVar3) = 0x1400040ea;\n        fcn.14000a248(uVar5);\n    }\n    *(&stack0xffffffffffffffe0 + iVar3) = 0x140004104;\n    (*_sym.imp.KERNEL32.dll_GetTempPathW)(0x1000, &stack0x00001048 + iVar3);\n    *(&stack0xffffffffffffffe0 + iVar3) = 0x140004109;\n    uVar1 = sub.KERNEL32.dll_GetCurrentProcessId();\n    arg4 = uVar1;\n    *(&stack0xffffffffffffffe0 + iVar3) = 0x140004122;\n    fcn.140004c80(&stack0x00000010 + iVar3, 0x10, 0x140023a68, arg4);\n    iVar6 = 0;\n    do {\n        *(&stack0xffffffffffffffe0 + iVar3) = 0x140004142;\n        uVar4 = fcn.140011204(&stack0x00001048 + iVar3, &stack0x00000010 + iVar3);\n        *(&stack0xffffffffffffffe0 + iVar3) = 0x14000414d;\n        iVar2 = fcn.1400050e0(uVar4);\n        if (iVar2 == 0) {\n            *(&stack0xffffffffffffffe0 + iVar3) = 0x1400041ea;\n            fcn.1400053b0(param_1, uVar4, 0x1000, arg4);\n            *(&stack0xffffffffffffffe0 + iVar3) = 0x1400041f2;\n            fcn.14000a248(uVar4);\n            if (param_2 != 0) {\n                *(&stack0xffffffffffffffe0 + iVar3) = 0x140004208;\n                noname_0 = fcn.1400052b0(0, 0x140023a64, 0, arg4);\n                if (arg2 == 0) {\n                    *(&stack0xffffffffffffffe0 + iVar3) = 0x14000424e;\n                    (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableW)(noname_0, 0);\n                }\n                else {\n                    *(&stack0xffffffffffffffe0 + iVar3) = 0x14000421d;\n                    uVar4 = fcn.1400052b0(0, arg2, 0, arg4);\n                    *(&stack0xffffffffffffffe0 + iVar3) = 0x14000422b;\n                    fcn.14000ff60(noname_0, uVar4);\n                    *(&stack0xffffffffffffffe0 + iVar3) = 0x140004233;\n                    fcn.14000a248(noname_0);\n                    *(&stack0xffffffffffffffe0 + iVar3) = 0x14000423b;\n                    fcn.14000a248(uVar4);\n                    noname_0 = arg2;\n                }\n                *(&stack0xffffffffffffffe0 + iVar3) = 0x140004256;\n                fcn.14000a248(noname_0);\n            }\n            goto code_r0x00014000425b;\n        }\n        *(&stack0xffffffffffffffe0 + iVar3) = 0x14000415d;\n        fcn.14000a248(uVar4);\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 5);\n    if (param_2 != 0) {\n        *(&stack0xffffffffffffffe0 + iVar3) = 0x14000417a;\n        uVar4 = fcn.1400052b0(0, 0x140023a64, 0, arg4);\n        if (arg2 == 0) {\n            *(&stack0xffffffffffffffe0 + iVar3) = 0x1400041ca;\n            (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableW)(uVar4, 0);\n            *(&stack0xffffffffffffffe0 + iVar3) = 0x1400041d2;\n            fcn.14000a248(uVar4);\n        }\n        else {\n            *(&stack0xffffffffffffffe0 + iVar3) = 0x14000418f;\n            uVar5 = fcn.1400052b0(0, arg2, 0, arg4);\n            *(&stack0xffffffffffffffe0 + iVar3) = 0x14000419d;\n            fcn.14000ff60(uVar4, uVar5);\n            *(&stack0xffffffffffffffe0 + iVar3) = 0x1400041a5;\n            fcn.14000a248(uVar4);\n            *(&stack0xffffffffffffffe0 + iVar3) = 0x1400041ad;\n            fcn.14000a248(uVar5);\n            *(&stack0xffffffffffffffe0 + iVar3) = 0x1400041b5;\n            fcn.14000a248(arg2);\n        }\n    }\ncode_r0x00014000425b:\n    *(&stack0xffffffffffffffe0 + iVar3) = 0x14000426b;\n    fcn.140008410(*(&stack0x00003048 + iVar3) ^ &stack0xffffffffffffffe8 + iVar3);\n    return;\n}\n",
        "token_count": 1673
    },
    "14000519": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353"
        ],
        "decompiled_code": "\nint64_t fcn.140005190(int64_t arg1, ulong lpMultiByteStr, ulong arg3, ulong arg4)\n\n{\n    int32_t iVar1;\n    int64_t lpWideCharStr;\n    int64_t arg2;\n    ulong uVar2;\n    ulong uVar3;\n    \n    uVar3 = 0xffffffff;\n    uVar2 = lpMultiByteStr;\n    iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0xfde9, 0, lpMultiByteStr, 0xffffffff, 0, 0);\n    if (iVar1 == 0) {\n        fcn.140001a40(0x140023d18, \"Failed to get wchar_t buffer size.\\n\", uVar2, uVar3);\n    }\n    else {\n        lpWideCharStr = fcn.14000a240(iVar1 + 1, 2);\n        if (lpWideCharStr == 0) {\n            fcn.140001a40(\"win32_utils_from_utf8\", \"Out of memory.\", uVar2, uVar3);\n        }\n        else {\n            uVar3 = 0xffffffff;\n            uVar2 = 0;\n            iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0xfde9);\n            if (iVar1 == 0) {\n                fcn.140001a40(0x140023d18, \"Failed to decode wchar_t from UTF-8\\n\", lpMultiByteStr, uVar3);\n            }\n            else {\n                arg2 = fcn.140005620(lpWideCharStr, uVar2, lpMultiByteStr, uVar3);\n                fcn.14000a248(lpWideCharStr);\n                if (arg2 != 0) {\n                    if (arg1 != 0) {\n                        fcn.1400112f0(arg1, arg2, arg3);\n                        fcn.14000a248(arg2);\n                        return arg1;\n                    }\n                    return arg2;\n                }\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 456
    },
    "1400052b": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353"
        ],
        "decompiled_code": "\nint64_t fcn.1400052b0(int64_t arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    int32_t iVar1;\n    ulong uVar2;\n    ulong arg4_00;\n    \n    if (arg1 == 0) {\n        arg4_00 = 0xffffffff;\n        uVar2 = arg2;\n        arg3._0_4_ = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0xfde9, 0, arg2, 0xffffffff, 0, 0);\n        if (arg3 == 0) {\n            fcn.140001a40(0x140023d18, \"Failed to get wchar_t buffer size.\\n\", uVar2, arg4_00);\n            return 0;\n        }\n        arg1 = fcn.14000a240(arg3 + 1, 2);\n        if (arg1 == 0) {\n            fcn.140001a40(\"win32_utils_from_utf8\", \"Out of memory.\", uVar2, arg4_00);\n            return 0;\n        }\n    }\n    uVar2 = 0xffffffff;\n    iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0xfde9, 0, arg2, 0xffffffff, arg1, arg3);\n    if (iVar1 == 0) {\n        fcn.140001a40(0x140023d18, \"Failed to decode wchar_t from UTF-8\\n\", arg2, uVar2);\n        return 0;\n    }\n    return arg1;\n}\n",
        "token_count": 354
    },
    "14001650": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353"
        ],
        "decompiled_code": "\nvoid fcn.140016504(ulong arg1, ulong arg2, ulong arg3)\n\n{\n    ulong arg2_00;\n    uchar auStack24 [16];\n    \n    arg2_00 = fcn.140012c58(auStack24, arg1, arg2);\n    fcn.140012f80(0, arg2_00, arg3);\n    return;\n}\n",
        "token_count": 85
    },
    "14001939": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353"
        ],
        "decompiled_code": "\nuint64_t fcn.140019394(uint64_t arg1, ulong arg2)\n\n{\n    uint64_t arg2_00;\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint64_t uVar4;\n    int64_t iVar5;\n    int64_t *piVar6;\n    uint64_t uVar7;\n    int64_t *piVar8;\n    uint32_t uVar9;\n    uint64_t uVar10;\n    int64_t iVar11;\n    bool bVar12;\n    \n    uVar7 = 0;\n    uVar9 = 0;\n    if (arg1 == 0) {\n        puVar3 = fcn.1400139ac();\n        *puVar3 = 0x16;\n        return 0xffffffffffffffff;\n    }\n    uVar4 = fcn.1400091e0(arg1, 0x3d);\n    uVar10 = arg1;\n    if ((uVar4 == 0) || (uVar4 == arg1)) {\ncode_r0x000140018c7f:\n        puVar3 = fcn.1400139ac();\n        uVar9 = 0xffffffff;\n        *puVar3 = 0x16;\n    }\n    else {\n        bVar12 = *(uVar4 + 1) == '\\0';\n        if (*0x14003c700 == *0x14003c718) {\n            *0x14003c700 = fcn.1400191b4(*0x14003c700);\n        }\n        if (*0x14003c700 == NULL) {\n            if ((arg2 != 0) && (*0x14003c708 != 0)) {\n                iVar5 = fcn.140011f60();\n                if (iVar5 != 0) goto code_r0x000140018d1e;\n                goto code_r0x000140018c7f;\n            }\n            if (!bVar12) {\n                *0x14003c700 = fcn.140012bb4(1, 8);\n                fcn.140012a5c(0);\n                if (*0x14003c700 != NULL) {\n                    if (*0x14003c708 == 0) {\n                        *0x14003c708 = fcn.140012bb4(1, 8);\n                        fcn.140012a5c(0);\n                        if (*0x14003c708 == 0) goto code_r0x000140018ce4;\n                    }\ncode_r0x000140018d1e:\n                    if (*0x14003c700 != NULL) goto code_r0x000140018d23;\n                }\ncode_r0x000140018ce4:\n                uVar9 = 0xffffffff;\n            }\n        }\n        else {\ncode_r0x000140018d23:\n            piVar6 = *0x14003c700;\n            iVar11 = uVar4 - arg1;\n            iVar5 = **0x14003c700;\n            piVar8 = *0x14003c700;\n            while (iVar5 != 0) {\n                iVar2 = fcn.14001f4e8(arg1, *piVar8, iVar11);\n                if ((iVar2 == 0) && ((*(iVar11 + *piVar8) == '=' || (*(iVar11 + *piVar8) == '\\0')))) {\n                    iVar5 = piVar8 - piVar6 >> 3;\n                    goto code_r0x000140018d6f;\n                }\n                piVar8 = piVar8 + 1;\n                iVar5 = *piVar8;\n            }\n            iVar5 = -(piVar8 - piVar6 >> 3);\ncode_r0x000140018d6f:\n            if ((-1 < iVar5) && (*piVar6 != 0)) {\n                fcn.140012a5c(piVar6[iVar5]);\n                if (bVar12) {\n                    for (; piVar6[iVar5] != 0; iVar5 = iVar5 + 1) {\n                        piVar6[iVar5] = piVar6[iVar5 + 1];\n                    }\n                    piVar6 = fcn.14001b608(piVar6, iVar5, 8);\n                    fcn.140012a5c(0);\n                    if (piVar6 != NULL) {\n                        *0x14003c700 = piVar6;\n                    }\n                }\n                else {\n                    piVar6[iVar5] = arg1;\n                    uVar10 = uVar7;\n                }\ncode_r0x000140018e28:\n                if (arg2 != 0) {\n                    iVar5 = -1;\n                    do {\n                        iVar11 = iVar5;\n                        iVar5 = iVar11 + 1;\n                    } while (*(arg1 + iVar11 + 1) != '\\0');\n                    iVar5 = fcn.140012bb4(iVar11 + 3, 1);\n                    if (iVar5 != 0) {\n                        iVar2 = fcn.140012afc(iVar5, iVar11 + 3, arg1);\n                        if (iVar2 != 0) {\n                            fcn.1400138ac(0, 0, 0, 0, 0);\n                            pcVar1 = swi(3);\n                            uVar7 = (*pcVar1)();\n                            return uVar7;\n                        }\n                        uVar4 = uVar4 + 1 + (iVar5 - arg1);\n                        *(uVar4 - 1) = 0;\n                        if (bVar12) {\n                            uVar4 = uVar7;\n                        }\n                        iVar2 = (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(iVar5, uVar4);\n                        if (iVar2 == 0) {\n                            puVar3 = fcn.1400139ac();\n                            uVar7 = 0xffffffff;\n                            *puVar3 = 0x2a;\n                        }\n                    }\n                    fcn.140012a5c(iVar5);\n                }\n                goto code_r0x000140018c96;\n            }\n            if (!bVar12) {\n                arg2_00 = -iVar5 + 2;\n                if ((-iVar5 <= arg2_00) && (arg2_00 < 0x1fffffffffffffff)) {\n                    piVar6 = fcn.14001b608(piVar6, arg2_00, 8);\n                    fcn.140012a5c(0);\n                    if (piVar6 != NULL) {\n                        piVar6[-iVar5] = arg1;\n                        piVar6[1 - iVar5] = 0;\n                        uVar10 = uVar7;\n                        *0x14003c700 = piVar6;\n                        goto code_r0x000140018e28;\n                    }\n                }\n                uVar9 = 0xffffffff;\n            }\n        }\n    }\n    uVar7 = uVar9;\ncode_r0x000140018c96:\n    fcn.140012a5c(uVar10);\n    return uVar7;\n}\n",
        "token_count": 1541
    },
    "14001982": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353"
        ],
        "decompiled_code": "\nulong fcn.140019824(uint64_t *arg1, uchar *arg2, uint64_t arg3, ulong arg4)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int64_t arg3_00;\n    int64_t iVar4;\n    uint64_t uVar6;\n    ulong uVar7;\n    int64_t iVar5;\n    \n    fcn.1400189dc(0xb);\n    uVar7 = 0;\n    if (arg1 != NULL) {\n        *arg1 = 0;\n        if (arg2 == NULL) {\ncode_r0x000140019767:\n            if (arg3 == 0) goto code_r0x00014001976c;\ncode_r0x000140019773:\n            bVar1 = false;\n        }\n        else {\n            if (arg3 == 0) {\n                if (arg2 == NULL) goto code_r0x000140019767;\n                goto code_r0x000140019773;\n            }\ncode_r0x00014001976c:\n            bVar1 = true;\n        }\n        if (bVar1) {\n            if (arg2 != NULL) {\n                *arg2 = 0;\n            }\n            arg3_00 = fcn.1400195e4(arg4);\n            if (arg3_00 != 0) {\n                iVar4 = -1;\n                do {\n                    iVar5 = iVar4;\n                    iVar4 = iVar5 + 1;\n                } while (*(arg3_00 + iVar4) != '\\0');\n                uVar6 = iVar5 + 2;\n                *arg1 = uVar6;\n                if (arg3 != 0) {\n                    if (arg3 < uVar6) {\n                        uVar7 = 0x22;\n                    }\n                    else {\n                        iVar2 = fcn.140012afc(arg2, arg3, arg3_00);\n                        if (iVar2 != 0) {\n                            uVar7 = fcn.1400138ac(0, 0, 0, 0, 0);\n                            return uVar7;\n                        }\n                    }\n                }\n            }\n            goto code_r0x0001400197c3;\n        }\n    }\n    puVar3 = fcn.1400139ac();\n    uVar7 = 0x16;\n    *puVar3 = 0x16;\n    fcn.14001388c();\ncode_r0x0001400197c3:\n    fcn.140018a30(0xb);\n    return uVar7;\n}\n",
        "token_count": 562
    },
    "140014b5": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong fcn.140014b58(ulong arg1, ulong arg2, uint64_t arg3)\n\n{\n    uint *puVar1;\n    int64_t iVar2;\n    ulong uVar3;\n    int64_t iVar4;\n    \n    if (arg1 == 0xfffffffe) {\n        puVar1 = fcn.14001398c();\n        *puVar1 = 0;\n        puVar1 = fcn.1400139ac();\n        *puVar1 = 9;\n    }\n    else {\n        if ((-1 < arg1) && (arg1 < *0x14003cb80)) {\n            iVar4 = arg1 >> 6;\n            iVar2 = (arg1 & 0x3f) * 0x40;\n            if ((*(*(iVar4 * 8 + 0x14003c780) + 0x38 + iVar2) & 1) != 0) {\n                fcn.140010498(arg1 & 0xffffffff);\n                uVar3 = 0xffffffffffffffff;\n                if ((*(*(iVar4 * 8 + 0x14003c780) + 0x38 + iVar2) & 1) == 0) {\n                    puVar1 = fcn.1400139ac();\n                    *puVar1 = 9;\n                    puVar1 = fcn.14001398c();\n                    *puVar1 = 0;\n                }\n                else {\n                    uVar3 = fcn.140014abc(arg1, arg2, arg3 & 0xffffffff);\n                }\n                fcn.14001057c(arg1);\n                return uVar3;\n            }\n        }\n        puVar1 = fcn.14001398c();\n        *puVar1 = 0;\n        puVar1 = fcn.1400139ac();\n        *puVar1 = 9;\n        fcn.14001388c();\n    }\n    return 0xffffffffffffffff;\n}\n",
        "token_count": 422
    },
    "140020b7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t fcn.140020b7c(ulong arg1, ulong arg2)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    \n    uVar1 = fcn.140021210();\n    uVar5 = 0;\n    uVar2 = 0;\n    if ((uVar1 & 0x80) != 0) {\n        uVar2 = 0x10;\n    }\n    if ((uVar1 & 0x200) != 0) {\n        uVar2 = uVar2 | 8;\n    }\n    if ((uVar1 >> 10 & 1) != 0) {\n        uVar2 = uVar2 | 4;\n    }\n    if ((uVar1 & 0x800) != 0) {\n        uVar2 = uVar2 | 2;\n    }\n    if ((uVar1 & 0x1000) != 0) {\n        uVar2 = uVar2 | 1;\n    }\n    if ((uVar1 & 0x100) != 0) {\n        uVar2 = uVar2 | 0x80000;\n    }\n    uVar3 = uVar1 & 0x6000;\n    if (uVar3 != 0) {\n        if (uVar3 == 0x2000) {\n            uVar2 = uVar2 | 0x100;\n        }\n        else if (uVar3 == 0x4000) {\n            uVar2 = uVar2 | 0x200;\n        }\n        else if (uVar3 == 0x6000) {\n            uVar2 = uVar2 | 0x300;\n        }\n    }\n    uVar1 = uVar1 & 0x8040;\n    if (uVar1 == 0x40) {\n        uVar2 = uVar2 | 0x2000000;\n    }\n    else if (uVar1 == 0x8000) {\n        uVar2 = uVar2 | 0x3000000;\n    }\n    else if (uVar1 == 0x8040) {\n        uVar2 = uVar2 | 0x1000000;\n    }\n    uVar1 = ~(arg2 & 0x300031f) & uVar2;\n    uVar3 = uVar1 | arg1 & arg2 & 0x300031f;\n    if (uVar3 != uVar2) {\n        uVar4 = 0;\n        if ((uVar3 & 0x10) != 0) {\n            uVar4 = 0x80;\n        }\n        if ((uVar3 & 8) != 0) {\n            uVar4 = uVar4 | 0x200;\n        }\n        if ((uVar3 & 4) != 0) {\n            uVar4 = uVar4 | 0x400;\n        }\n        if ((uVar3 & 2) != 0) {\n            uVar4 = uVar4 | 0x800;\n        }\n        if ((uVar3 & 1) != 0) {\n            uVar4 = uVar4 | 0x1000;\n        }\n        if ((uVar1 & 0x80000) != 0) {\n            uVar4 = uVar4 | 0x100;\n        }\n        uVar2 = uVar3 & 0x300;\n        if (uVar2 != 0) {\n            if (uVar2 == 0x100) {\n                uVar4 = uVar4 | 0x2000;\n            }\n            else if (uVar2 == 0x200) {\n                uVar4 = uVar4 | 0x4000;\n            }\n            else if (uVar2 == 0x300) {\n                uVar4 = uVar4 | 0x6000;\n            }\n        }\n        uVar3 = uVar3 & 0x3000000;\n        if (uVar3 == 0x1000000) {\n            uVar4 = uVar4 | 0x8040;\n        }\n        else if (uVar3 == 0x2000000) {\n            uVar4 = uVar4 | 0x40;\n        }\n        else if (uVar3 == 0x3000000) {\n            uVar4 = uVar4 | 0x8000;\n        }\n        if ((*0x140032af0 == '\\0') || ((uVar4 & 0x40) == 0)) {\n            uVar4 = uVar4 & 0xffffffbf;\n            fcn.140021220(uVar4);\n        }\n        else {\n            fcn.140021220(uVar4);\n        }\n        if ((uVar4 & 0x80) != 0) {\n            uVar5 = 0x10;\n        }\n        if ((uVar4 & 0x200) != 0) {\n            uVar5 = uVar5 | 8;\n        }\n        if ((uVar4 >> 10 & 1) != 0) {\n            uVar5 = uVar5 | 4;\n        }\n        if ((uVar4 >> 0xb & 1) != 0) {\n            uVar5 = uVar5 | 2;\n        }\n        if ((uVar4 >> 0xc & 1) != 0) {\n            uVar5 = uVar5 | 1;\n        }\n        if ((uVar4 & 0x100) != 0) {\n            uVar5 = uVar5 | 0x80000;\n        }\n        uVar1 = uVar4 & 0x6000;\n        uVar2 = uVar5;\n        if (uVar1 != 0) {\n            if (uVar1 == 0x2000) {\n                uVar2 = uVar5 | 0x100;\n            }\n            else if (uVar1 == 0x4000) {\n                uVar2 = uVar5 | 0x200;\n            }\n            else if (uVar1 == 0x6000) {\n                uVar2 = uVar5 | 0x300;\n            }\n        }\n        uVar4 = uVar4 & 0x8040;\n        if (uVar4 == 0x40) {\n            uVar2 = uVar2 | 0x2000000;\n        }\n        else if (uVar4 == 0x8000) {\n            uVar2 = uVar2 | 0x3000000;\n        }\n        else if (uVar4 == 0x8040) {\n            uVar2 = uVar2 | 0x1000000;\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 1509
    },
    "14000764": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint32_t fcn.140007640(ulong arg1, uint32_t *arg2, ulong arg3)\n\n{\n    uint8_t uVar1;\n    uint64_t uVar2;\n    uint32_t uVar3;\n    uint64_t uVar4;\n    \n    uVar4 = arg3;\n    if (arg2 == NULL) {\n        return 0;\n    }\n    arg1._0_4_ = ~arg1;\n    for (; (uVar4 != 0 && ((arg2 & 3) != 0)); arg2 = arg2 + 1) {\n        arg1._0_4_ = *((*arg2 ^ arg1) * 4 + 0x140024860) ^ arg1 >> 8;\n        uVar4 = uVar4 - 1;\n    }\n    if (0x1f < uVar4) {\n        uVar2 = uVar4 >> 5;\n        uVar4 = uVar4 + uVar2 * -0x20;\n        do {\n            arg1._0_4_ = arg1 ^ *arg2;\n            uVar3 = *((arg1 >> 0x10) * 4 + 0x140024c60) ^ *((arg1 >> 8) * 4 + 0x140025060) ^\n                    *((arg1 >> 0x18) * 4 + 0x140024860) ^ *((arg1 & 0xff) * 4 + 0x140025460) ^ arg2[1];\n            uVar3 = *((uVar3 >> 0x10) * 4 + 0x140024c60) ^ *((uVar3 >> 8) * 4 + 0x140025060) ^\n                    *((uVar3 >> 0x18) * 4 + 0x140024860) ^ *((uVar3 & 0xff) * 4 + 0x140025460) ^ arg2[2];\n            uVar3 = *((uVar3 >> 0x10) * 4 + 0x140024c60) ^ *((uVar3 >> 8) * 4 + 0x140025060) ^\n                    *((uVar3 >> 0x18) * 4 + 0x140024860) ^ *((uVar3 & 0xff) * 4 + 0x140025460) ^ arg2[3];\n            uVar3 = *((uVar3 >> 0x10) * 4 + 0x140024c60) ^ *((uVar3 >> 8) * 4 + 0x140025060) ^\n                    *((uVar3 >> 0x18) * 4 + 0x140024860) ^ *((uVar3 & 0xff) * 4 + 0x140025460) ^ arg2[4];\n            uVar3 = *((uVar3 >> 0x10) * 4 + 0x140024c60) ^ *((uVar3 >> 8) * 4 + 0x140025060) ^\n                    *((uVar3 >> 0x18) * 4 + 0x140024860) ^ *((uVar3 & 0xff) * 4 + 0x140025460) ^ arg2[5];\n            uVar3 = *((uVar3 >> 0x10) * 4 + 0x140024c60) ^ *((uVar3 >> 8) * 4 + 0x140025060) ^\n                    *((uVar3 >> 0x18) * 4 + 0x140024860) ^ *((uVar3 & 0xff) * 4 + 0x140025460) ^ arg2[6];\n            uVar3 = *((uVar3 >> 0x10) * 4 + 0x140024c60) ^ *((uVar3 >> 8) * 4 + 0x140025060) ^\n                    *((uVar3 >> 0x18) * 4 + 0x140024860) ^ *((uVar3 & 0xff) * 4 + 0x140025460) ^ arg2[7];\n            arg2 = arg2 + 8;\n            arg1._0_4_ = *((uVar3 >> 0x10) * 4 + 0x140024c60) ^ *((uVar3 >> 8) * 4 + 0x140025060) ^\n                         *((uVar3 >> 0x18) * 4 + 0x140024860) ^ *((uVar3 & 0xff) * 4 + 0x140025460);\n            uVar2 = uVar2 - 1;\n        } while (uVar2 != 0);\n    }\n    if (3 < uVar4) {\n        uVar2 = uVar4 >> 2;\n        uVar4 = uVar4 + uVar2 * -4;\n        do {\n            arg1._0_4_ = arg1 ^ *arg2;\n            arg2 = arg2 + 1;\n            arg1._0_4_ = *((arg1 >> 0x10) * 4 + 0x140024c60) ^ *((arg1 >> 8) * 4 + 0x140025060) ^\n                         *((arg1 >> 0x18) * 4 + 0x140024860) ^ *((arg1 & 0xff) * 4 + 0x140025460);\n            uVar2 = uVar2 - 1;\n        } while (uVar2 != 0);\n    }\n    for (; uVar4 != 0; uVar4 = uVar4 - 1) {\n        uVar1 = *arg2;\n        arg2 = arg2 + 1;\n        arg1._0_4_ = *((uVar1 ^ arg1) * 4 + 0x140024860) ^ arg1 >> 8;\n    }\n    return ~arg1;\n}\n",
        "token_count": 1313
    },
    "14000900": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00014000911d)\n// WARNING: Removing unreachable block (ram,0x000140009082)\n// WARNING: Removing unreachable block (ram,0x000140009024)\n// WARNING: Could not reconcile some variable overlaps\n\nulong fcn.140009000(ulong noname_0, ulong arg2)\n\n{\n    int32_t *piVar1;\n    uint32_t *puVar2;\n    int64_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint8_t in_XCR0;\n    ulong var_20h;\n    ulong var_bp_18h;\n    ulong var_bp_10h;\n    ulong var_8h;\n    \n    var_bp_18h._0_4_ = 0;\n    *0x14003202c = 2;\n    piVar1 = cpuid_basic_info(0);\n    *0x140032028 = 1;\n    puVar2 = cpuid_Version_info(1);\n    uVar4 = puVar2[3];\n    uVar5 = *0x14003c2dc;\n    if ((piVar1[2] ^ 0x49656e69U | piVar1[3] ^ 0x6c65746eU | piVar1[1] ^ 0x756e6547U) == 0) {\n        *0x140032030 = 0xffffffffffffffff;\n        uVar6 = *puVar2 & 0xfff3ff0;\n        if ((((uVar6 == 0x106c0) || (uVar6 == 0x20660)) || (uVar6 == 0x20670)) ||\n           ((uVar5 = *0x14003c2dc | 4,  uVar6 - 0x30650 < 0x21 && ((0x100010001U >> (uVar6 - 0x30650 & 0x3f) & 1) != 0))\n           )) {\n            uVar5 = *0x14003c2dc | 5;\n        }\n    }\n    *0x14003c2dc = uVar5;\n    if (((piVar1[1] ^ 0x68747541U | piVar1[2] ^ 0x69746e65U | piVar1[3] ^ 0x444d4163U) == 0) &&\n       (0x600eff < (*puVar2 & 0xff00f00))) {\n        *0x14003c2dc = *0x14003c2dc | 4;\n    }\n    if (6 < *piVar1) {\n        iVar3 = cpuid_Extended_Feature_Enumeration_info(7);\n        var_bp_18h._0_4_ = *(iVar3 + 4);\n        if ((var_bp_18h >> 9 & 1) != 0) {\n            *0x14003c2dc = *0x14003c2dc | 2;\n        }\n    }\n    if ((uVar4 >> 0x14 & 1) != 0) {\n        *0x140032028 = 2;\n        *0x14003202c = 6;\n        if ((((uVar4 >> 0x1b & 1) != 0) && ((uVar4 >> 0x1c & 1) != 0)) && ((in_XCR0 & 6) == 6)) {\n            *0x14003202c = 0xe;\n            *0x140032028 = 3;\n            if ((var_bp_18h & 0x20) != 0) {\n                *0x140032028 = 5;\n                *0x14003202c = 0x2e;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 855
    },
    "14001a0b": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_bp_18h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.14001a0b4(int64_t *arg1, int64_t *arg2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int64_t iVar4;\n    int64_t iVar5;\n    uint64_t uVar6;\n    int64_t *piVar7;\n    uint64_t uVar8;\n    uint64_t uVar9;\n    uint64_t uVar10;\n    int64_t iVar11;\n    uchar auStack184 [32];\n    ulong uStack152;\n    int64_t iStack136;\n    uchar auStack128 [16];\n    ulong uStack112;\n    int64_t iStack104;\n    int64_t *piStack96;\n    int64_t var_50h;\n    uint64_t var_48h;\n    uint64_t var_40h;\n    ulong var_38h;\n    ulong var_30h;\n    ulong var_28h;\n    ulong var_20h;\n    ulong var_bp_18h;\n    ulong var_10h;\n    \n    var_40h = *0x140032010 ^ auStack184;\n    uVar8 = 0;\n    piStack96 = arg2;\n    if (arg2 == NULL) {\n        puVar3 = fcn.1400139ac();\n        *puVar3 = 0x16;\n        fcn.14001388c();\n    }\n    else {\n        *arg2 = 0;\n        iVar4 = *arg1;\n        auStack128 = ZEXT816(0);\n        uStack112 = 0;\n        while (iVar4 != 0) {\n            var_48h = CONCAT26(var_48h._6_2_, 0x3f002a);\n            iVar4 = fcn.140017b3c(*arg1, &var_48h);\n            if (iVar4 == 0) {\n                iVar2 = fcn.140019d28(*arg1, 0, 0, auStack128);\n            }\n            else {\n                iVar2 = fcn.140019e3c(*arg1, iVar4, auStack128);\n            }\n            if (iVar2 != 0) {\n                goto code_r0x000140019caf;\n            }\n            arg1 = arg1 + 1;\n            iVar4 = *arg1;\n        }\n        var_48h = 0;\n        iVar4 = (auStack128._8_8_ - auStack128._0_8_ >> 3) + 1;\n        uVar6 = (auStack128._8_8_ - auStack128._0_8_) + 7U >> 3;\n        if (auStack128._8_8_ < auStack128._0_8_) {\n            uVar6 = uVar8;\n        }\n        piVar7 = auStack128._0_8_;\n        uVar9 = uVar8;\n        uVar10 = uVar8;\n        if (uVar6 != 0) {\n            do {\n                iVar5 = -1;\n                do {\n                    iVar5 = iVar5 + 1;\n                } while (*(*piVar7 + iVar5 * 2) != 0);\n                piVar7 = piVar7 + 1;\n                uVar10 = uVar10 + 1 + iVar5;\n                uVar9 = uVar9 + 1;\n                var_48h = uVar10;\n            } while (uVar9 != uVar6);\n        }\n        iVar5 = fcn.140011824(iVar4, var_48h);\n        if (iVar5 != 0) {\n            iStack136 = iVar5 + iVar4 * 8;\n            var_50h = iStack136;\n            if (auStack128._0_8_ != auStack128._8_8_) {\n                iStack104 = iVar5 - auStack128._0_8_;\n                piVar7 = auStack128._0_8_;\n                do {\n                    iVar4 = -1;\n                    do {\n                        iVar11 = iVar4;\n                        iVar4 = iVar11 + 1;\n                    } while (*(*piVar7 + iVar4 * 2) != 0);\n                    iVar11 = iVar11 + 2;\n                    iVar2 = fcn.140019a00(iStack136, var_48h - (iStack136 - var_50h >> 1), *piVar7, iVar11);\n                    if (iVar2 != 0) {\n                        uStack152 = 0;\n                        fcn.1400138ac(0, 0, 0, 0);\n                        pcVar1 = swi(3);\n                        (*pcVar1)();\n                        return;\n                    }\n                    *(iStack104 + piVar7) = iStack136;\n                    piVar7 = piVar7 + 1;\n                    iStack136 = iStack136 + iVar11 * 2;\n                } while (piVar7 != auStack128._8_8_);\n            }\n            *piStack96 = iVar5;\n        }\n        fcn.140012a5c(0);\ncode_r0x000140019caf:\n        uVar6 = auStack128._8_8_ + (7 - auStack128._0_8_) >> 3;\n        if (auStack128._8_8_ < auStack128._0_8_) {\n            uVar6 = uVar8;\n        }\n        piVar7 = auStack128._0_8_;\n        if (uVar6 != 0) {\n            do {\n                fcn.140012a5c(*piVar7);\n                uVar8 = uVar8 + 1;\n                piVar7 = piVar7 + 1;\n            } while (uVar8 != uVar6);\n        }\n        fcn.140012a5c(auStack128._0_8_);\n    }\n    fcn.140008410(var_40h ^ auStack184);\n    return;\n}\n",
        "token_count": 1387
    },
    "14000e57": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Could not reconcile some variable overlaps\n\nulong fcn.14000e57c(int64_t arg1, int32_t *arg2)\n\n{\n    char cVar1;\n    ushort uVar2;\n    uint *puVar3;\n    int64_t iVar4;\n    ulong uVar5;\n    ulong uVar6;\n    int32_t aiStackX16 [2];\n    ulong var_38h;\n    int32_t iStack88;\n    int32_t iStack84;\n    int32_t iStack80;\n    int32_t iStack76;\n    int32_t iStack72;\n    int32_t iStack68;\n    int32_t iStack64;\n    int32_t iStack60;\n    ulong var_30h;\n    int32_t iStack48;\n    int32_t iStack44;\n    ulong var_20h;\n    ulong var_10h;\n    \n    uVar6 = 0;\n    if (arg2 == NULL) {\ncode_r0x00014000e5a2:\n        puVar3 = fcn.14001398c();\n        *puVar3 = 0;\n        puVar3 = fcn.1400139ac();\n        *puVar3 = 0x16;\n        fcn.14001388c();\n        return 0xffffffff;\n    }\n    fcn.140009280(&iStack88, 0, 0x30);\n    *arg2 = iStack88;\n    arg2[1] = iStack84;\n    arg2[2] = iStack80;\n    arg2[3] = iStack76;\n    arg2[4] = iStack72;\n    arg2[5] = iStack68;\n    arg2[6] = iStack64;\n    arg2[7] = iStack60;\n    arg2[8] = var_30h;\n    arg2[9] = var_30h._4_4_;\n    arg2[10] = iStack48;\n    arg2[0xb] = iStack44;\n    if (arg1 == 0) goto code_r0x00014000e5a2;\n    iVar4 = fcn.140017b3c(arg1, 0x140027610);\n    if (iVar4 != 0) {\n        puVar3 = fcn.1400139ac();\n        *puVar3 = 2;\n        puVar3 = fcn.14001398c();\n        *puVar3 = 2;\n        return 0xffffffff;\n    }\n    iVar4 = (*_sym.imp.KERNEL32.dll_CreateFileW)(arg1);\n    if (iVar4 == -1) {\n        cVar1 = fcn.14000ec18(arg1);\n        if (cVar1 == '\\0') {\n            fcn.14001393c(2);\n        }\n        else {\n            uVar2 = fcn.14000e9dc(0x10, arg1);\n            *(arg2 + 6) = uVar2;\n            *(arg2 + 2) = 1;\n            aiStackX16[0] = 0;\n            cVar1 = fcn.14000eb08(arg1, aiStackX16);\n            if (cVar1 != '\\0') {\n                arg2[4] = aiStackX16[0] + -1;\n                *arg2 = aiStackX16[0] + -1;\n                uVar5 = fcn.1400180ac(0x7bc, 1, 1, 0);\n                *(arg2 + 8) = uVar5;\n                *(arg2 + 6) = uVar5;\n                *(arg2 + 10) = uVar5;\n                goto code_r0x00014000e68d;\n            }\n        }\n    }\n    else {\n        cVar1 = fcn.14000e73c(arg1, 0xffffffff, iVar4, arg2);\n        if (cVar1 != '\\0') goto code_r0x00014000e68d;\n    }\n    fcn.140009280(&iStack88, 0, 0x30);\n    uVar6 = 0xffffffff;\n    *arg2 = iStack88;\n    arg2[1] = iStack84;\n    arg2[2] = iStack80;\n    arg2[3] = iStack76;\n    arg2[4] = iStack72;\n    arg2[5] = iStack68;\n    arg2[6] = iStack64;\n    arg2[7] = iStack60;\n    arg2[8] = var_30h;\n    arg2[9] = var_30h._4_4_;\n    arg2[10] = iStack48;\n    arg2[0xb] = iStack44;\ncode_r0x00014000e68d:\n    if (iVar4 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar4);\n        return uVar6;\n    }\n    return uVar6;\n}\n",
        "token_count": 1128
    },
    "14001049": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nvoid fcn.140010498(ulong arg1)\n\n{\n    // WARNING: Could not recover jumptable at 0x0001400104b4. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)((arg1 & 0x3f) * 0x40 + *((arg1 >> 6) * 8 + 0x14003c780));\n    return;\n}\n",
        "token_count": 100
    },
    "14001057": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nvoid fcn.14001057c(ulong arg1)\n\n{\n    // WARNING: Could not recover jumptable at 0x000140010598. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)((arg1 & 0x3f) * 0x40 + *((arg1 >> 6) * 8 + 0x14003c780));\n    return;\n}\n",
        "token_count": 100
    },
    "14001080": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nuint64_t fcn.140010804(ulong noname_0, uint32_t *arg2, ulong noname_2, uint32_t *arg4)\n\n{\n    uint8_t uVar1;\n    uint64_t uVar2;\n    \n    fcn.1400189dc(*arg2);\n    uVar1 = *0x140032010 & 0x3f;\n    uVar2 = *0x140032010 ^ *0x14003c4c8;\n    fcn.140018a30(*arg4);\n    return uVar2 >> uVar1 | uVar2 << 0x40 - uVar1;\n}\n",
        "token_count": 143
    },
    "140014ab": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nint64_t fcn.140014abc(ulong arg1, ulong arg2, ulong arg3)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int64_t iVar4;\n    uint *puVar5;\n    int64_t iStackX32;\n    \n    iVar4 = fcn.14001078c(arg1 & 0xffffffff);\n    if (iVar4 == -1) {\n        puVar5 = fcn.1400139ac();\n        *puVar5 = 9;\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_SetFilePointerEx)(iVar4, arg2, &iStackX32, arg3);\n        if (iVar2 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            fcn.14001393c(uVar3);\n        }\n        else if (iStackX32 != -1) {\n            puVar1 = *((arg1 >> 6) * 8 + 0x14003c780) + 0x38 + (arg1 & 0x3f) * 0x40;\n            *puVar1 = *puVar1 & 0xfd;\n            return iStackX32;\n        }\n    }\n    return -1;\n}\n",
        "token_count": 290
    },
    "14000b29": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.14000b29c(int64_t arg1)\n\n{\n    // WARNING: Could not recover jumptable at 0x00014000b2a0. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(arg1 + 0x30);\n    return;\n}\n",
        "token_count": 78
    },
    "14000b2a": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.14000b2a8(int64_t arg1)\n\n{\n    // WARNING: Could not recover jumptable at 0x00014000b2ac. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(arg1 + 0x30);\n    return;\n}\n",
        "token_count": 79
    },
    "14000163": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint64_t fcn.140001630(int64_t arg1, uint *netlong)\n\n{\n    uint32_t uVar1;\n    uint64_t uVar2;\n    uint *arg2;\n    ulong in_R8;\n    ulong in_R9;\n    \n    arg2 = netlong;\n    uVar1 = sub.WS2_32.dll_ntohl(*netlong);\n    uVar2 = uVar1 + netlong;\n    if (uVar2 < *(arg1 + 0x10)) {\n        fcn.1400019e0(\"Cannot read Table of Contents.\\n\", arg2, in_R8, in_R9);\n        uVar2 = *(arg1 + 0x18);\n    }\n    return uVar2;\n}\n",
        "token_count": 163
    },
    "14000189": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140001890(int64_t *arg1)\n\n{\n    if (arg1 != NULL) {\n        if (arg1[2] != 0) {\n            fcn.14000a248(arg1[2]);\n        }\n        if (*arg1 != 0) {\n            fcn.14000a2dc(*arg1);\n            *arg1 = 0;\n        }\n        fcn.14000a248(arg1);\n    }\n    return;\n}\n",
        "token_count": 103
    },
    "1400018d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t fcn.1400018d0(ulong param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    int64_t iVar1;\n    \n    iVar1 = fcn.14000a240(1, 0x4090);\n    if (iVar1 == 0) {\n        fcn.1400019a0(\"calloc\", \"Cannot allocate memory for ARCHIVE_STATUS\\n\", param_3, param_4);\n    }\n    return iVar1;\n}\n",
        "token_count": 110
    },
    "14000197": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140001970(ulong arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    ulong uStackX16;\n    ulong uStackX24;\n    ulong uStackX32;\n    \n    uStackX16 = arg2;\n    uStackX24 = arg3;\n    uStackX32 = arg4;\n    fcn.140001a90(arg1, &uStackX16);\n    return;\n}\n",
        "token_count": 96
    },
    "1400019e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.1400019e0(ulong arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    ulong arg1_00;\n    uint32_t uVar1;\n    ulong uStackX16;\n    ulong uStackX24;\n    ulong uStackX32;\n    \n    uStackX16 = arg2;\n    uStackX24 = arg3;\n    uStackX32 = arg4;\n    uVar1 = sub.KERNEL32.dll_GetCurrentProcessId();\n    arg1_00 = fcn.14000b22c(2);\n    fcn.140001920(arg1_00, \"[%d] \", uVar1, arg4);\n    fcn.140001a90(arg1, &uStackX16);\n    return;\n}\n",
        "token_count": 168
    },
    "140001a9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140001a90(ulong param_1, ulong param_2)\n\n{\n    uint64_t uVar1;\n    uchar *puVar2;\n    int64_t iVar3;\n    uint64_t *puVar4;\n    int64_t iVar5;\n    ulong arg1;\n    ulong uStackX32;\n    ulong uStack16;\n    \n    uStack16 = 0x140001aa0;\n    iVar3 = fcn.140008450();\n    iVar3 = -iVar3;\n    *(&stack0x00001028 + iVar3) = *0x140032010 ^ &stack0xfffffffffffffff8 + iVar3;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140001ac0;\n    puVar4 = fcn.140001910();\n    *(&stack0x00000020 + iVar3) = param_2;\n    *(&stack0x00000018 + iVar3) = 0;\n    uVar1 = *puVar4;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140001ae8;\n    fcn.14000e108(uVar1 | 1, &stack0x00000028 + iVar3, 0x800, param_1);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140001b00;\n    iVar5 = fcn.140005190(&stack0x00000828 + iVar3, &stack0x00000028 + iVar3, 0x800, param_1);\n    if (iVar5 == 0) {\n        *(&stack0xfffffffffffffff0 + iVar3) = 0x140001b1e;\n        arg1 = fcn.14000b22c(2);\n        puVar2 = &stack0x00000028;\n    }\n    else {\n        *(&stack0xfffffffffffffff0 + iVar3) = 0x140001b0f;\n        arg1 = fcn.14000b22c(2);\n        puVar2 = &stack0x00000828;\n    }\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140001b32;\n    fcn.140001920(arg1, 0x1400225d4, puVar2 + iVar3, param_1);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140001b42;\n    fcn.140008410(*(&stack0x00001028 + iVar3) ^ &stack0xfffffffffffffff8 + iVar3);\n    return;\n}\n",
        "token_count": 560
    },
    "14000207": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140002070(ulong arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    int32_t iVar1;\n    uint64_t *puVar2;\n    ulong uStackX24;\n    ulong uStackX32;\n    uchar auStack136 [32];\n    ulong uStack104;\n    ulong *puStack96;\n    uchar auStack88 [48];\n    uint64_t uStack40;\n    \n    uStack40 = *0x140032010 ^ auStack136;\n    puStack96 = &uStackX24;\n    uStackX24 = arg3;\n    uStackX32 = arg4;\n    puVar2 = fcn.140001910();\n    uStack104 = 0;\n    iVar1 = fcn.14000e108(*puVar2 | 1, arg1, 0x1000, arg2);\n    if (iVar1 < 0) {\n        iVar1 = -1;\n    }\n    if (iVar1 < 0x1000) {\n        fcn.14000ed24(arg1, auStack88);\n    }\n    fcn.140008410(uStack40 ^ auStack136);\n    return;\n}\n",
        "token_count": 258
    },
    "14000210": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140002100(int64_t arg1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int64_t iVar3;\n    int64_t iVar4;\n    int64_t iVar5;\n    ulong uVar6;\n    int64_t iVar7;\n    uint64_t arg2;\n    ulong uVar8;\n    ulong in_RDX;\n    ulong uVar9;\n    ulong unaff_RBP;\n    ulong unaff_RDI;\n    ulong in_R8;\n    char *arg3;\n    int64_t arg3_00;\n    ulong in_R9;\n    int64_t arg4;\n    ulong unaff_R14;\n    uchar auStackX8 [32];\n    ulong uStack32;\n    \n    iVar1 = fcn.140003930();\n    if (iVar1 == 0) {\n        *(arg1 + 0x407c) = 1;\n        iVar1 = fcn.140003d30(arg1, in_RDX, in_R8, in_R9);\n        if (((iVar1 == 0) && (iVar1 = fcn.1400036b0(arg1, in_RDX),  iVar1 == 0)) &&\n           (iVar1 = fcn.140003830(arg1),  iVar1 == 0)) {\n            uStack32 = 0x14000236f;\n            iVar3 = fcn.140008450();\n            iVar3 = -iVar3;\n            *(&stack0x00001008 + iVar3) = *0x140032010 ^ &stack0xffffffffffffffe8 + iVar3;\n            arg2 = *(arg1 + 0x10);\n            *(&stack0xffffffffffffffe0 + iVar3) = 0x140002398;\n            iVar4 = (**0x140032bc0)(\"__main__\");\n            if (iVar4 == 0) {\n                *(&stack0xffffffffffffffe0 + iVar3) = 0x1400023ac;\n                fcn.1400019e0(\"Could not get __main__ module.\", in_RDX, in_R8, in_R9);\n            }\n            else {\n                *(&stack0x00001050 + iVar3) = unaff_R14;\n                *(&stack0xffffffffffffffe0 + iVar3) = 0x1400023c5;\n                iVar5 = (**0x140032c00)(iVar4);\n                if (iVar5 == 0) {\n                    *(&stack0xffffffffffffffe0 + iVar3) = 0x1400023d9;\n                    fcn.1400019e0(\"Could not get __main__ module\\'s dict.\", in_RDX, in_R8, in_R9);\n                }\n                else {\n                    *(&stack0x00001040 + iVar3) = unaff_RBP;\n                    *(&stack0x00001048 + iVar3) = unaff_RDI;\n                    if (arg2 < *(arg1 + 0x18)) {\n                        do {\n                            if (*(arg2 + 0x11) == 's') {\n                                *(&stack0xffffffffffffffe0 + iVar3) = 0x140002415;\n                                uVar8 = fcn.140001230(arg1, arg2);\n                                arg4 = arg2 + 0x12;\n                                uVar9 = 0x1000;\n                                arg3 = \"%s.py\";\n                                *(&stack0xffffffffffffffe0 + iVar3) = 0x140002432;\n                                iVar1 = fcn.140002010(&stack0x00000008 + iVar3, 0x1000, \"%s.py\", arg4);\n                                if (0xfff < iVar1) {\n                                    *(&stack0xffffffffffffffe0 + iVar3) = 0x14000252f;\n                                    fcn.1400019e0(\"Name exceeds PATH_MAX\\n\", uVar9, arg3, arg4);\n                                    break;\n                                }\n                                *(&stack0xffffffffffffffe0 + iVar3) = 0x140002448;\n                                uVar6 = (**0x140032be8)(&stack0x00000008 + iVar3);\n                                *(&stack0xffffffffffffffe0 + iVar3) = 0x14000245e;\n                                uVar9 = uVar6;\n                                (**0x140032bc8)(iVar4, \"__file__\");\n                                *(&stack0xffffffffffffffe0 + iVar3) = 0x140002467;\n                                (**0x140032b70)(uVar6);\n                                uVar2 = *(arg2 + 0xc);\n                                *(&stack0xffffffffffffffe0 + iVar3) = 0x14000246f;\n                                uVar2 = sub.WS2_32.dll_ntohl(uVar2);\n                                *(&stack0xffffffffffffffe0 + iVar3) = 0x14000247a;\n                                iVar7 = (**0x140032c78)(uVar8, uVar2);\n                                if (iVar7 == 0) {\n                                    *(&stack0xffffffffffffffe0 + iVar3) = 0x140002518;\n                                    fcn.1400019e0(\"Failed to unmarshal code object for %s\\n\", arg2 + 0x12, uVar9, arg4);\n                                    *(&stack0xffffffffffffffe0 + iVar3) = 0x14000251e;\n                                    (**0x140032c20)();\n                                    break;\n                                }\n                                *(&stack0xffffffffffffffe0 + iVar3) = 0x140002492;\n                                arg3_00 = iVar5;\n                                iVar7 = (**0x140032c70)(iVar7, iVar5);\n                                if (iVar7 == 0) {\n                                    *(&stack0xffffffffffffffe0 + iVar3) = 0x1400024f3;\n                                    (**0x140032c20)();\n                                    *(&stack0xffffffffffffffe0 + iVar3) = 0x140002503;\n                                    fcn.1400019e0(\"Failed to execute script %s\\n\", arg2 + 0x12, arg3_00, arg4);\n                                    break;\n                                }\n                                *(&stack0xffffffffffffffe0 + iVar3) = 0x14000249f;\n                                fcn.14000a248(uVar8);\n                            }\n                            *(&stack0xffffffffffffffe0 + iVar3) = 0x1400024aa;\n                            arg2 = fcn.140001630(arg1, arg2);\n                        } while (arg2 < *(arg1 + 0x18));\n                    }\n                }\n            }\n            *(&stack0xffffffffffffffe0 + iVar3) = 0x1400024e1;\n            uVar8 = fcn.140008410(*(&stack0x00001008 + iVar3) ^ &stack0xffffffffffffffe8 + iVar3);\n            return uVar8;\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 1493
    },
    "14000228": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140002280(int64_t param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    int64_t iVar1;\n    int64_t arg3;\n    int64_t iVar2;\n    int64_t arg2;\n    uchar auStackX24 [16];\n    ulong uStack16;\n    \n    uStack16 = 0x14000228c;\n    iVar1 = fcn.140008450();\n    iVar1 = -iVar1;\n    *(&stack0x00001018 + iVar1) = *0x140032010 ^ &stack0xfffffffffffffff8 + iVar1;\n    *(&stack0xfffffffffffffff0 + iVar1) = 0x1400022b0;\n    arg3 = fcn.140001580(param_1, \"pyi-windows-manifest-filename\");\n    if (arg3 != 0) {\n        arg2 = param_1 + 0x3078;\n        *(&stack0xfffffffffffffff0 + iVar1) = 0x1400022c9;\n        iVar2 = fcn.140002ad0(&stack0x00000018 + iVar1, arg2, arg3);\n        if (iVar2 == 0) {\n            arg3 = 0x1000;\n            arg2 = param_1 + 0x3078;\n            *(&stack0xfffffffffffffff0 + iVar1) = 0x1400022e7;\n            fcn.1400019e0(\"Path of manifest-file (%s) length exceeds buffer[%d] space\\n\", arg2, 0x1000, param_4);\n        }\n        *(&stack0xfffffffffffffff0 + iVar1) = 0x1400022f1;\n        fcn.140004ce0(&stack0x00000018 + iVar1, arg2, arg3, param_4);\n    }\n    *(&stack0xfffffffffffffff0 + iVar1) = 0x140002301;\n    fcn.140008410(*(&stack0x00001018 + iVar1) ^ &stack0xfffffffffffffff8 + iVar1);\n    return;\n}\n",
        "token_count": 461
    },
    "14000231": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140002310(int64_t arg1)\n\n{\n    char cVar1;\n    uint64_t netlong;\n    \n    netlong = *(arg1 + 0x10);\n    if (netlong < *(arg1 + 0x18)) {\n        do {\n            cVar1 = *(netlong + 0x11);\n            if ((((cVar1 == 'b') || (cVar1 == 'x')) || (cVar1 == 'Z')) || (cVar1 == 'd')) {\n                return 1;\n            }\n            netlong = fcn.140001630(arg1, netlong);\n        } while (netlong < *(arg1 + 0x18));\n    }\n    return 0;\n}\n",
        "token_count": 160
    },
    "1400028a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.1400028a0(ulong param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    int64_t iVar3;\n    uchar *arg2;\n    ulong uVar4;\n    uchar auStackX24 [16];\n    ulong uStack16;\n    \n    uStack16 = 0x1400028ac;\n    iVar2 = fcn.140008450();\n    iVar2 = -iVar2;\n    *(&stack0x00002018 + iVar2) = *0x140032010 ^ &stack0xfffffffffffffff8 + iVar2;\n    uVar4 = 0x1000;\n    *(&stack0xfffffffffffffff0 + iVar2) = 0x1400028d7;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(0, &stack0x00000018 + iVar2);\n    if (iVar1 == 0) {\n        *(&stack0xfffffffffffffff0 + iVar2) = 0x1400028ee;\n        fcn.140001a40(0x140022840, \"Failed to get executable path.\", uVar4, param_4);\n    }\n    else {\n        uVar4 = 0x1000;\n        arg2 = &stack0x00000018 + iVar2;\n        *(&stack0xfffffffffffffff0 + iVar2) = 0x140002905;\n        iVar3 = fcn.1400053b0(param_1, arg2, 0x1000, param_4);\n        if (iVar3 == 0) {\n            *(&stack0xfffffffffffffff0 + iVar2) = 0x140002916;\n            fcn.1400019e0(\"Failed to convert executable path to UTF-8.\", arg2, uVar4, param_4);\n        }\n    }\n    *(&stack0xfffffffffffffff0 + iVar2) = 0x14000292f;\n    fcn.140008410(*(&stack0x00002018 + iVar2) ^ &stack0xfffffffffffffff8 + iVar2);\n    return;\n}\n",
        "token_count": 468
    },
    "14000294": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140002940(ulong param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    int64_t iVar1;\n    uchar auStackX32 [8];\n    ulong uStack8;\n    \n    uStack8 = 0x14000294a;\n    iVar1 = fcn.140008450();\n    iVar1 = -iVar1;\n    *(&stack0x00002060 + iVar1) = *0x140032010 ^ &stack0x00000000 + iVar1;\n    *(&stack0xfffffffffffffff8 + iVar1) = 0x140002972;\n    fcn.1400052b0(&stack0x00000050 + iVar1, param_1, 0x1000, param_4);\n    *(&stack0xfffffffffffffff8 + iVar1) = 0x140002981;\n    fcn.14000ed7c(&stack0x00000050 + iVar1, &stack0x00000020 + iVar1);\n    *(&stack0xfffffffffffffff8 + iVar1) = 0x14000299a;\n    fcn.140008410(*(&stack0x00002060 + iVar1) ^ &stack0x00000000 + iVar1);\n    return;\n}\n",
        "token_count": 278
    },
    "140002a2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140002a20(ulong param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    int64_t iVar1;\n    int64_t arg2;\n    uchar auStackX8 [32];\n    ulong uStack32;\n    \n    uStack32 = 0x140002a2e;\n    iVar1 = fcn.140008450();\n    iVar1 = -iVar1;\n    *(&stack0x00002018 + iVar1) = *0x140032010 ^ &stack0xffffffffffffffe8 + iVar1;\n    *(&stack0xffffffffffffffe0 + iVar1) = 0x140002a5f;\n    fcn.1400052b0(&stack0x00000008 + iVar1, param_3, 0x1000, param_4);\n    *(&stack0xffffffffffffffe0 + iVar1) = 0x140002a71;\n    arg2 = fcn.14000eff4(0, &stack0x00000008 + iVar1, 0x1000);\n    if (arg2 != 0) {\n        *(&stack0xffffffffffffffe0 + iVar1) = 0x140002a87;\n        fcn.1400053b0(param_1, arg2, param_2, param_4);\n        *(&stack0xffffffffffffffe0 + iVar1) = 0x140002a92;\n        fcn.14000a248(arg2);\n    }\n    *(&stack0xffffffffffffffe0 + iVar1) = 0x140002aaa;\n    fcn.140008410(*(&stack0x00002018 + iVar1) ^ &stack0xffffffffffffffe8 + iVar1);\n    return;\n}\n",
        "token_count": 383
    },
    "140002ba": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140002ba0(ulong arg1, ulong noname_1, ulong arg3, ulong arg4)\n\n{\n    *0x140032b48 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_DontWriteBytecodeFlag\");\n    if (*0x140032b48 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_DontWriteBytecodeFlag\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032b30 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_FileSystemDefaultEncoding\");\n    if (*0x140032b30 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_FileSystemDefaultEncoding\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032b18 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_FrozenFlag\");\n    if (*0x140032b18 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_FrozenFlag\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032b40 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_IgnoreEnvironmentFlag\");\n    if (*0x140032b40 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_IgnoreEnvironmentFlag\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032b20 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_NoSiteFlag\");\n    if (*0x140032b20 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_NoSiteFlag\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032b50 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_NoUserSiteDirectory\");\n    if (*0x140032b50 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_NoUserSiteDirectory\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032b28 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_OptimizeFlag\");\n    if (*0x140032b28 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_OptimizeFlag\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032b38 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_VerboseFlag\");\n    if (*0x140032b38 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_VerboseFlag\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032be0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_BuildValue\");\n    if (*0x140032be0 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_BuildValue\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032b70 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_DecRef\");\n    if (*0x140032b70 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_DecRef\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032b60 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_Finalize\");\n    if (*0x140032b60 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_Finalize\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032b68 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_IncRef\");\n    if (*0x140032b68 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_IncRef\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032b58 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_Initialize\");\n    if (*0x140032b58 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_Initialize\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032b88 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_SetPath\");\n    if (*0x140032b88 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_SetPath\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032b90 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_GetPath\");\n    if (*0x140032b90 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_GetPath\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032b78 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_SetProgramName\");\n    if (*0x140032b78 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_SetProgramName\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032b80 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_SetPythonHome\");\n    if (*0x140032b80 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_SetPythonHome\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c08 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyDict_GetItemString\");\n    if (*0x140032c08 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyDict_GetItemString\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c10 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyErr_Clear\");\n    if (*0x140032c10 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyErr_Clear\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c18 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyErr_Occurred\");\n    if (*0x140032c18 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyErr_Occurred\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c20 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyErr_Print\");\n    if (*0x140032c20 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyErr_Print\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c80 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyErr_Fetch\");\n    if (*0x140032c80 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyErr_Fetch\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032bc0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyImport_AddModule\");\n    if (*0x140032bc0 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyImport_AddModule\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032bb0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyImport_ExecCodeModule\");\n    if (*0x140032bb0 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyImport_ExecCodeModule\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032bb8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyImport_ImportModule\");\n    if (*0x140032bb8 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyImport_ImportModule\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032bd8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyList_Append\");\n    if (*0x140032bd8 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyList_Append\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032bd0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyList_New\");\n    if (*0x140032bd0 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyList_New\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c30 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyLong_AsLong\");\n    if (*0x140032c30 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyLong_AsLong\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c00 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyModule_GetDict\");\n    if (*0x140032c00 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyModule_GetDict\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032bf0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyObject_CallFunction\");\n    if (*0x140032bf0 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyObject_CallFunction\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032bf8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyObject_CallFunctionObjArgs\");\n    if (*0x140032bf8 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyObject_CallFunctionObjArgs\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032bc8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyObject_SetAttrString\");\n    if (*0x140032bc8 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyObject_SetAttrString\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c90 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyObject_GetAttrString\");\n    if (*0x140032c90 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyObject_GetAttrString\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c88 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyObject_Str\");\n    if (*0x140032c88 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyObject_Str\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032ba8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyRun_SimpleString\");\n    if (*0x140032ba8 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyRun_SimpleString\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c28 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PySys_AddWarnOption\");\n    if (*0x140032c28 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PySys_AddWarnOption\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032ba0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PySys_SetArgvEx\");\n    if (*0x140032ba0 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PySys_SetArgvEx\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c50 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PySys_GetObject\");\n    if (*0x140032c50 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PySys_GetObject\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c38 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PySys_SetObject\");\n    if (*0x140032c38 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PySys_SetObject\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032b98 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PySys_SetPath\");\n    if (*0x140032b98 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PySys_SetPath\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c70 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyEval_EvalCode\");\n    if (*0x140032c70 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyEval_EvalCode\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c78 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyMarshal_ReadObjectFromString\");\n    if (*0x140032c78 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyMarshal_ReadObjectFromString\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032be8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyUnicode_FromString\");\n    if (*0x140032be8 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyUnicode_FromString\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c40 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_DecodeLocale\");\n    if (*0x140032c40 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for Py_DecodeLocale\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c48 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyMem_RawFree\");\n    if (*0x140032c48 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyMem_RawFree\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c58 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyUnicode_FromFormat\");\n    if (*0x140032c58 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyUnicode_FromFormat\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c68 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyUnicode_Decode\");\n    if (*0x140032c68 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyUnicode_Decode\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c60 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyUnicode_DecodeFSDefault\");\n    if (*0x140032c60 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyUnicode_DecodeFSDefault\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    *0x140032c98 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyUnicode_AsUTF8\");\n    if (*0x140032c98 == 0) {\n        fcn.140001a40(0x1400228e0, \"Failed to get address for PyUnicode_AsUTF8\\n\", arg3, arg4);\n        return 0xffffffff;\n    }\n    return 0;\n}\n",
        "token_count": 4269
    },
    "140003ca": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140003ca0(int64_t arg1)\n\n{\n    int64_t *piVar1;\n    int64_t arg1_00;\n    int64_t *piVar2;\n    int64_t *arg1_01;\n    ulong arg2;\n    ulong in_R8;\n    ulong in_R9;\n    \n    arg2 = *(arg1 + 0x4088);\n    arg1_01 = fcn.1400054a0(*(arg1 + 0x4080), arg2);\n    if (arg1_01 == NULL) {\n        fcn.1400019e0(\"Failed to convert argv to wchar_t\\n\", arg2, in_R8, in_R9);\n        return 0xffffffff;\n    }\n    (**0x140032ba0)(*(arg1 + 0x4080), arg1_01, 0);\n    arg1_00 = *arg1_01;\n    piVar2 = arg1_01;\n    while (arg1_00 != 0) {\n        fcn.14000a248(arg1_00);\n        piVar1 = piVar2 + 1;\n        piVar2 = piVar2 + 1;\n        arg1_00 = *piVar1;\n    }\n    fcn.14000a248(arg1_01);\n    return 0;\n}\n",
        "token_count": 291
    },
    "140003d3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140003d30(int64_t arg1, ulong noname_1, ulong noname_2, ulong arg4)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int64_t iVar3;\n    int64_t iVar4;\n    int64_t iVar5;\n    ulong uVar6;\n    ulong arg3;\n    \n    iVar5 = arg1 + 0x78;\n    uVar6 = 0x1000;\n    iVar3 = fcn.1400052b0(0x140038cd0, iVar5, 0x1000, arg4);\n    if (iVar3 == 0) {\n        fcn.1400019e0(\"Failed to convert progname to wchar_t\\n\", iVar5, uVar6, arg4);\n        return 0xffffffff;\n    }\n    (**0x140032b78)(0x140038cd0);\n    iVar5 = arg1 + 0x3078;\n    uVar6 = 0x1000;\n    iVar3 = iVar5;\n    iVar4 = fcn.1400052b0(0x140036cc0, iVar5, 0x1000, arg4);\n    if (iVar4 == 0) {\n        fcn.1400019e0(\"Failed to convert pyhome to wchar_t\\n\", iVar3, uVar6, arg4);\n        return 0xffffffff;\n    }\n    (**0x140032b80)(0x140036cc0);\n    iVar3 = iVar5;\n    uVar1 = fcn.140002010(0x140032ca0, 0x200e, \"%s%cbase_library.zip%c%s\", iVar5);\n    if (0x200d < uVar1) {\n        fcn.1400019e0(\"sys.path (based on %s) exceeds buffer[%d] space\\n\", iVar5, 0x200e, iVar3);\n        return 0xffffffff;\n    }\n    arg3 = 0x1000;\n    uVar6 = 0x140032ca0;\n    iVar5 = fcn.1400052b0(0x140034cb0, 0x140032ca0, 0x1000, iVar3);\n    if (iVar5 == 0) {\n        fcn.1400019e0(\"Failed to convert pypath to wchar_t\\n\", uVar6, arg3, iVar3);\n        return 0xffffffff;\n    }\n    (**0x140032b90)();\n    (**0x140032b88)(0x140034cb0);\n    fcn.140003a90(arg1);\n    (**0x140032b58)();\n    (**0x140032b98)(0x140034cb0);\n    iVar2 = fcn.140003ca0(arg1);\n    if (iVar2 == 0) {\n        iVar5 = (**0x140032c18)();\n        if (iVar5 == 0) {\n            return 0;\n        }\n        fcn.1400019e0(\"Error detected starting Python VM.\", uVar6, arg3, iVar3);\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 687
    },
    "140003ed": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140003ed0(ulong param_1, ulong param_2, ulong param_3)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    int64_t arg1;\n    int64_t arg4;\n    int64_t iVar3;\n    int64_t iVar4;\n    uchar auStackX8 [32];\n    ulong uStack32;\n    \n    uStack32 = 0x140003ede;\n    iVar2 = fcn.140008450();\n    iVar2 = -iVar2;\n    *(&stack0x00001008 + iVar2) = *0x140032010 ^ &stack0xffffffffffffffe8 + iVar2;\n    *(&stack0xffffffffffffffe0 + iVar2) = 0x140003f05;\n    arg1 = fcn.1400029b0(param_1, 0x1400223e0);\n    *(&stack0xffffffffffffffe0 + iVar2) = 0x140003f13;\n    arg4 = fcn.140004340(param_2, param_3);\n    if (arg1 == 0) {\n        arg1 = arg4;\n        if (arg4 == 0) goto code_r0x000140003fd1;\n    }\n    else if (arg4 != 0) {\n        *(&stack0xffffffffffffffe0 + iVar2) = 0x140003f32;\n        iVar1 = fcn.14000a348(arg1);\n        while (iVar1 == 0) {\n            *(&stack0xffffffffffffffe0 + iVar2) = 0x140003f58;\n            iVar3 = fcn.14000a620(&stack0x00000008 + iVar2, 1, 0x1000, arg1);\n            if (iVar3 != 0) {\n                *(&stack0xffffffffffffffe0 + iVar2) = 0x140003f83;\n                iVar4 = fcn.14000b088(&stack0x00000008 + iVar2, 1, iVar3, arg4);\n                iVar3 = arg4;\n                if (iVar4 != 0) {\n                    *(&stack0xffffffffffffffe0 + iVar2) = 0x140003f90;\n                    iVar1 = fcn.14000a374(arg4);\n                    if (iVar1 == 0) goto code_r0x000140003f94;\n                }\ncode_r0x000140003fa5:\n                *(&stack0xffffffffffffffe0 + iVar2) = 0x140003faa;\n                fcn.140011220(iVar3);\n                break;\n            }\n            *(&stack0xffffffffffffffe0 + iVar2) = 0x140003f65;\n            iVar1 = fcn.14000a374(arg1);\n            iVar3 = arg1;\n            if (iVar1 != 0) goto code_r0x000140003fa5;\ncode_r0x000140003f94:\n            *(&stack0xffffffffffffffe0 + iVar2) = 0x140003f9c;\n            iVar1 = fcn.14000a348(arg1);\n        }\n        *(&stack0xffffffffffffffe0 + iVar2) = 0x140003fb5;\n        fcn.14000a2dc(arg1);\n        *(&stack0xffffffffffffffe0 + iVar2) = 0x140003fbd;\n        fcn.14000a2dc(arg4);\n        goto code_r0x000140003fd1;\n    }\n    *(&stack0xffffffffffffffe0 + iVar2) = 0x140003fce;\n    fcn.14000a2dc(arg1);\ncode_r0x000140003fd1:\n    *(&stack0xffffffffffffffe0 + iVar2) = 0x140003fe1;\n    fcn.140008410(*(&stack0x00001008 + iVar2) ^ &stack0xffffffffffffffe8 + iVar2);\n    return;\n}\n",
        "token_count": 866
    },
    "1400048a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.1400048a0(ulong arg1, ulong arg2, ulong noname_2, ulong arg4)\n\n{\n    uint uVar1;\n    ulong noname_0;\n    ulong arg2_00;\n    \n    noname_0 = fcn.1400052b0(0, arg1, 0, arg4);\n    arg2_00 = fcn.1400052b0(0, arg2, 0, arg4);\n    uVar1 = fcn.14000ff60(noname_0, arg2_00);\n    fcn.14000a248(noname_0);\n    fcn.14000a248(arg2_00);\n    return uVar1;\n}\n",
        "token_count": 158
    },
    "14000491": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "set environment variable"
        ],
        "decompiled_code": "\nuint fcn.140004910(ulong arg1, ulong noname_1, ulong noname_2, ulong arg4)\n\n{\n    uint uVar1;\n    ulong arg1_00;\n    \n    arg1_00 = fcn.1400052b0(0, arg1, 0, arg4);\n    uVar1 = (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableW)(arg1_00, 0);\n    fcn.14000a248(arg1_00);\n    return uVar1;\n}\n",
        "token_count": 116
    },
    "14000495": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140004950(ulong param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int64_t iVar3;\n    ulong uVar4;\n    uchar *arg3;\n    ulong arg4;\n    uint auStackX24 [4];\n    ulong uStack16;\n    \n    uStack16 = 0x140004960;\n    iVar3 = fcn.140008450();\n    iVar3 = -iVar3;\n    *(&stack0x000020f8 + iVar3) = *0x140032010 ^ &stack0xfffffffffffffff8 + iVar3;\n    *(&stack0x00000048 + iVar3) = 0;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140004991;\n    fcn.1400052b0(&stack0x000000f8 + iVar3, param_1, 0x1000, param_4);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x1400049a0;\n    fcn.140010c1c(0x16, 1);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x1400049aa;\n    fcn.140010c1c(2, 1);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x1400049b4;\n    fcn.140010c1c(0xf, 1);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x1400049be;\n    fcn.140010c1c(0x15, 1);\n    *(&stack0x00000050 + iVar3) = 0x18;\n    *(&stack0x00000058 + iVar3) = 0;\n    *(&stack0x00000060 + iVar3) = 1;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x1400049dd;\n    (*_sym.imp.KERNEL32.dll_GetStartupInfoW)();\n    *(&stack0x00000090 + iVar3) = 0;\n    *(&stack0x00000098 + iVar3) = ZEXT816(0);\n    *(&stack0x000000c4 + iVar3) = 0x101;\n    *(&stack0x000000c8 + iVar3) = 1;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140004a0b;\n    uVar4 = fcn.14000b22c(0);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140004a13;\n    uVar1 = fcn.14000f878(uVar4);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140004a1a;\n    uVar4 = fcn.14001078c(uVar1);\n    *(&stack0x000000d8 + iVar3) = uVar4;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140004a29;\n    uVar4 = fcn.14000b22c(1);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140004a31;\n    uVar1 = fcn.14000f878(uVar4);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140004a38;\n    uVar4 = fcn.14001078c(uVar1);\n    *(&stack0x000000e0 + iVar3) = uVar4;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140004a48;\n    uVar4 = fcn.14000b22c(2);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140004a50;\n    uVar1 = fcn.14000f878(uVar4);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140004a57;\n    uVar4 = fcn.14001078c(uVar1);\n    *(&stack0x000000e8 + iVar3) = uVar4;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140004a65;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetCommandLineW)();\n    arg4 = 0;\n    arg3 = &stack0x00000050 + iVar3;\n    *(&stack0x00000040 + iVar3) = &stack0x00000068 + iVar3;\n    *(&stack0x00000038 + iVar3) = &stack0x00000088 + iVar3;\n    *(&stack0x00000030 + iVar3) = 0;\n    *(&stack0x00000028 + iVar3) = 0;\n    *(&stack0x00000020 + iVar3) = 0;\n    *(&stack0x00000018 + iVar3) = 1;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140004aa7;\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateProcessW)(&stack0x000000f8 + iVar3, uVar4);\n    if (iVar2 == 0) {\n        *(&stack0xfffffffffffffff0 + iVar3) = 0x140004ae2;\n        fcn.140001a40(0x140023b30, \"Error creating child process!\\n\", arg3, arg4);\n    }\n    else {\n        *(&stack0xfffffffffffffff0 + iVar3) = 0x140004ab9;\n        (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*(&stack0x00000068 + iVar3), 0xffffffff);\n        *(&stack0xfffffffffffffff0 + iVar3) = 0x140004ac9;\n        (*_sym.imp.KERNEL32.dll_GetExitCodeProcess)(*(&stack0x00000068 + iVar3), &stack0x00000048 + iVar3);\n    }\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140004af5;\n    fcn.140008410(*(&stack0x000020f8 + iVar3) ^ &stack0xfffffffffffffff8 + iVar3);\n    return;\n}\n",
        "token_count": 1389
    },
    "140004b1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140004b10(ulong arg1, ulong noname_1, ulong noname_2, ulong arg4)\n\n{\n    ulong arg1_00;\n    ulong uVar1;\n    \n    arg1_00 = fcn.1400052b0(0, arg1, 0, arg4);\n    uVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryExW)(arg1_00, 0, 8);\n    fcn.14000a248(arg1_00);\n    return uVar1;\n}\n",
        "token_count": 120
    },
    "140004f5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t * fcn.140004f50(ulong arg1, int64_t arg2)\n\n{\n    int32_t iVar1;\n    int64_t *arg1_00;\n    int64_t iVar2;\n    char *arg1_01;\n    char *arg2_00;\n    uint64_t uVar3;\n    uint32_t uVar4;\n    uint64_t uVar6;\n    int64_t *piVar7;\n    ulong arg3;\n    ulong uVar8;\n    ulong arg4;\n    uint64_t uVar5;\n    \n    arg1_00 = fcn.14000a240(arg1 + 1, 8);\n    if (arg1_00 == NULL) {\n        return NULL;\n    }\n    uVar3 = 0;\n    if (0 < arg1) {\n        uVar5 = uVar3;\n        uVar6 = uVar3;\n        piVar7 = arg1_00;\n        do {\n            uVar8 = *((arg2 - arg1_00) + piVar7);\n            arg4 = 0xffffffff;\n            arg3 = uVar8;\n            iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0xfde9, 0, uVar8, 0xffffffff, 0, 0, 0, 0);\n            if (iVar1 == 0) {\n                arg2_00 = \"Failed to get UTF-8 buffer size.\\n\";\ncode_r0x00014000507f:\n                arg1_01 = 0x140023c20;\ncode_r0x000140005086:\n                fcn.140001a40(arg1_01, arg2_00, arg3, arg4);\n                *piVar7 = 0;\n                if (-1 < uVar6) {\n                    do {\n                        fcn.14000a248(arg1_00[uVar3]);\n                        uVar3 = uVar3 + 1;\n                    } while (uVar3 <= uVar6);\n                }\n                fcn.14000a248(arg1_00);\n                return NULL;\n            }\n            iVar2 = fcn.14000a240(iVar1 + 1, 1);\n            if (iVar2 == 0) {\n                arg2_00 = \"Out of memory.\";\n                arg1_01 = \"win32_utils_to_utf8\";\n                goto code_r0x000140005086;\n            }\n            arg4 = 0xffffffff;\n            iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0xfde9);\n            if (iVar1 == 0) {\n                arg2_00 = \"Failed to encode wchar_t as UTF-8.\\n\";\n                arg3 = uVar8;\n                goto code_r0x00014000507f;\n            }\n            *piVar7 = iVar2;\n            uVar4 = uVar5 + 1;\n            uVar5 = uVar4;\n            piVar7 = piVar7 + 1;\n            uVar6 = uVar6 + 1;\n        } while (uVar4 < arg1);\n    }\n    arg1_00[arg1] = 0;\n    return arg1_00;\n}\n",
        "token_count": 698
    },
    "1400050e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.1400050e0(ulong arg1)\n\n{\n    int32_t iVar1;\n    uchar auStack120 [32];\n    uint auStack88 [2];\n    uchar auStack80 [8];\n    uint uStack72;\n    uint uStack64;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint uStack48;\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    ulong uStack32;\n    uint64_t uStack24;\n    \n    uStack24 = *0x140032010 ^ auStack120;\n    auStack88[0] = 0x18;\n    uStack64 = str.D:_A__FA___S_1_3_4_._0_4_;\n    uStack60 = str.D:_A__FA___S_1_3_4_._4_4_;\n    uStack56 = str.D:_A__FA___S_1_3_4_._8_4_;\n    uStack52 = str.D:_A__FA___S_1_3_4_._12_4_;\n    uStack72 = 0;\n    uStack32 = str.D:_A__FA___S_1_3_4_._32_8_;\n    uStack48 = str.D:_A__FA___S_1_3_4_._16_4_;\n    uStack44 = str.D:_A__FA___S_1_3_4_._20_4_;\n    uStack40 = str.D:_A__FA___S_1_3_4_._24_4_;\n    uStack36 = str.D:_A__FA___S_1_3_4_._28_4_;\n    iVar1 = sub.ADVAPI32.dll_ConvertStringSecurityDescriptorToSecurityDescriptorW(&uStack64, 1, auStack80);\n    if (iVar1 == 0) {\n        fcn.140008410(uStack24 ^ auStack120);\n        return;\n    }\n    (*_sym.imp.KERNEL32.dll_CreateDirectoryW)(arg1, auStack88);\n    fcn.140008410(uStack24 ^ auStack120);\n    return;\n}\n",
        "token_count": 478
    },
    "1400053b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t fcn.1400053b0(int64_t arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    int32_t iVar1;\n    ulong uVar2;\n    ulong arg4_00;\n    \n    if (arg1 == 0) {\n        arg4_00 = 0xffffffff;\n        uVar2 = arg2;\n        arg3._0_4_ = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0xfde9, 0, arg2, 0xffffffff, 0, 0, 0, 0);\n        if (arg3 == 0) {\n            fcn.140001a40(0x140023c20, \"Failed to get UTF-8 buffer size.\\n\", uVar2, arg4_00);\n            return 0;\n        }\n        arg1 = fcn.14000a240(arg3 + 1, 1);\n        if (arg1 == 0) {\n            fcn.140001a40(\"win32_utils_to_utf8\", \"Out of memory.\", uVar2, arg4_00);\n            return 0;\n        }\n    }\n    uVar2 = 0xffffffff;\n    iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0xfde9, 0, arg2, 0xffffffff, arg1, arg3, 0, 0);\n    if (iVar1 == 0) {\n        fcn.140001a40(0x140023c20, \"Failed to encode wchar_t as UTF-8.\\n\", arg2, uVar2);\n        arg1 = 0;\n    }\n    return arg1;\n}\n",
        "token_count": 370
    },
    "1400054a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t * fcn.1400054a0(ulong arg1, int64_t arg2)\n\n{\n    int32_t iVar1;\n    int64_t *arg1_00;\n    int64_t iVar2;\n    char *arg1_01;\n    char *arg2_00;\n    uint64_t uVar3;\n    uint32_t uVar4;\n    uint64_t uVar6;\n    int64_t *piVar7;\n    ulong arg3;\n    ulong uVar8;\n    ulong arg4;\n    uint64_t uVar5;\n    \n    arg1_00 = fcn.14000a240(arg1 + 1, 8);\n    if (arg1_00 == NULL) {\n        return NULL;\n    }\n    uVar3 = 0;\n    if (0 < arg1) {\n        uVar5 = uVar3;\n        uVar6 = uVar3;\n        piVar7 = arg1_00;\n        do {\n            uVar8 = *((arg2 - arg1_00) + piVar7);\n            arg4 = 0xffffffff;\n            arg3 = uVar8;\n            iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0xfde9, 0, uVar8, 0xffffffff, 0, 0);\n            if (iVar1 == 0) {\n                arg2_00 = \"Failed to get wchar_t buffer size.\\n\";\ncode_r0x0001400055b8:\n                arg1_01 = 0x140023d18;\ncode_r0x0001400055bf:\n                fcn.140001a40(arg1_01, arg2_00, arg3, arg4);\n                *piVar7 = 0;\n                if (-1 < uVar6) {\n                    do {\n                        fcn.14000a248(arg1_00[uVar3]);\n                        uVar3 = uVar3 + 1;\n                    } while (uVar3 <= uVar6);\n                }\n                fcn.14000a248(arg1_00);\n                return NULL;\n            }\n            iVar2 = fcn.14000a240(iVar1 + 1, 2);\n            if (iVar2 == 0) {\n                arg2_00 = \"Out of memory.\";\n                arg1_01 = \"win32_utils_from_utf8\";\n                goto code_r0x0001400055bf;\n            }\n            arg4 = 0xffffffff;\n            iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0xfde9);\n            if (iVar1 == 0) {\n                arg2_00 = \"Failed to decode wchar_t from UTF-8\\n\";\n                arg3 = uVar8;\n                goto code_r0x0001400055b8;\n            }\n            *piVar7 = iVar2;\n            uVar4 = uVar5 + 1;\n            uVar5 = uVar4;\n            piVar7 = piVar7 + 1;\n            uVar6 = uVar6 + 1;\n        } while (uVar4 < arg1);\n    }\n    arg1_00[arg1] = 0;\n    return arg1_00;\n}\n",
        "token_count": 695
    },
    "14000562": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t fcn.140005620(ulong lpWideCharStr, ulong noname_1, ulong noname_2, ulong arg4)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    ulong uVar3;\n    ulong arg4_00;\n    \n    arg4_00 = 0xffffffff;\n    uVar3 = lpWideCharStr;\n    iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, lpWideCharStr, 0xffffffff, 0, 0, 0, 0);\n    if (iVar1 != 0) {\n        iVar2 = fcn.14000a240(iVar1 + 1, 1);\n        if (iVar2 == 0) {\n            fcn.140001a40(\"win32_wcs_to_mbs\", \"Out of memory.\", uVar3, arg4_00);\n            iVar2 = 0;\n        }\n        else {\n            uVar3 = 0xffffffff;\n            iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, lpWideCharStr, 0xffffffff, iVar2, iVar1, 0, 0);\n            if (iVar1 == 0) {\n                fcn.140001a40(0x140023c20, \"Failed to encode filename as ANSI.\\n\", lpWideCharStr, uVar3);\n                iVar2 = 0;\n            }\n        }\n        return iVar2;\n    }\n    fcn.140001a40(0x140023c20, \"Failed to get ANSI buffer size.\\n\", uVar3, arg4_00);\n    return 0;\n}\n",
        "token_count": 369
    },
    "14000707": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.140007070(int64_t arg1, char *arg2, ulong arg3)\n\n{\n    int32_t iVar1;\n    int64_t *piVar2;\n    \n    if (((arg2 != NULL) && (*arg2 == '1')) && (arg3 == 0x58)) {\n        if (arg1 != 0) {\n            *(arg1 + 0x20) = 0;\n            if (*(arg1 + 0x30) == 0) {\n                *(arg1 + 0x40) = 0;\n                *(arg1 + 0x30) = 0x140007960;\n            }\n            if (*(arg1 + 0x38) == 0) {\n                *(arg1 + 0x38) = 0x140007970;\n            }\n            piVar2 = (**(arg1 + 0x30))(*(arg1 + 0x40), 1, 0x1bf0);\n            if (piVar2 == NULL) {\n                iVar1 = -4;\n            }\n            else {\n                *(arg1 + 0x28) = piVar2;\n                *piVar2 = arg1;\n                piVar2[8] = 0;\n                *(piVar2 + 1) = 0x3f34;\n                iVar1 = fcn.140007080(arg1, 0xf);\n                if (iVar1 != 0) {\n                    (**(arg1 + 0x38))(*(arg1 + 0x40), piVar2);\n                    *(arg1 + 0x28) = 0;\n                }\n            }\n            return iVar1;\n        }\n        return -2;\n    }\n    return -6;\n}\n",
        "token_count": 377
    },
    "140012a9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t fcn.140012a9c(uint64_t arg1)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    uint *puVar3;\n    \n    if (arg1 < 0xffffffffffffffe1) {\n        if (arg1 == 0) {\n            arg1 = 1;\n        }\n        do {\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x14003cf98, 0, arg1);\n            if (iVar2 != 0) {\n                return iVar2;\n            }\n            iVar1 = fcn.14001240c();\n        } while ((iVar1 != 0) && (iVar1 = fcn.14001b7bc(arg1),  iVar1 != 0));\n    }\n    puVar3 = fcn.1400139ac();\n    *puVar3 = 0xc;\n    return 0;\n}\n",
        "token_count": 199
    },
    "140012a5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140012a5c(int64_t lpMem)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    \n    if ((lpMem != 0) && (iVar2 = (*_sym.imp.KERNEL32.dll_HeapFree)(*0x14003cf98, 0, lpMem),  iVar2 == 0)) {\n        puVar1 = fcn.1400139ac();\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar4 = fcn.1400138f4(uVar3);\n        *puVar1 = uVar4;\n    }\n    return;\n}\n",
        "token_count": 155
    },
    "140008f6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140008f60(void)\n\n{\n    code *pcVar1;\n    code **ppcVar2;\n    \n    for (ppcVar2 = 0x14002eff0; ppcVar2 < 0x14002eff0; ppcVar2 = ppcVar2 + 1) {\n        pcVar1 = *ppcVar2;\n        if (pcVar1 != NULL) {\n            fcn.140008ff8(pcVar1);\n            (*pcVar1)();\n        }\n    }\n    return;\n}\n",
        "token_count": 118
    },
    "140009d4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140009d40(void)\n\n{\n    uint64_t uVar1;\n    \n    uVar1 = *0x14003c380;\n    while (uVar1 != 0) {\n        uVar1 = uVar1 - 1;\n        (*_sym.imp.KERNEL32.dll_DeleteCriticalSection)(uVar1 * 0x28 + 0x14003c358);\n        *0x14003c380 = *0x14003c380 - 1;\n    }\n    return 1;\n}\n",
        "token_count": 114
    },
    "14000ae4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint64_t fcn.14000ae40(int64_t arg1)\n\n{\n    uint *puVar1;\n    uint64_t uVar2;\n    \n    if (arg1 == 0) {\n        puVar1 = fcn.1400139ac();\n        *puVar1 = 0x16;\n        fcn.14001388c();\n        uVar2 = 0xffffffff;\n    }\n    else {\n        fcn.14000b29c(arg1);\n        uVar2 = fcn.14000a9d0(arg1);\n        if (0x7fffffff < uVar2) {\n            puVar1 = fcn.1400139ac();\n            *puVar1 = 0x16;\n            uVar2 = 0xffffffff;\n        }\n        fcn.14000b2a8(arg1);\n        uVar2 = uVar2 & 0xffffffff;\n    }\n    return uVar2;\n}\n",
        "token_count": 203
    },
    "14000b37": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.14000b374(ulong noname_0, ulong *arg2, ulong arg3, ulong *arg4)\n\n{\n    uint uVar1;\n    \n    fcn.14000b29c(*arg2);\n    uVar1 = fcn.14000b8e8(arg3);\n    fcn.14000b2a8(*arg4);\n    return uVar1;\n}\n",
        "token_count": 89
    },
    "14000e07": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.14000e07c(ulong arg1, int64_t arg2, int64_t arg3, ulong arg4, ulong arg_30h)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    int64_t var_10h;\n    ulong var_18h;\n    ulong var_20h;\n    int64_t var_28h;\n    ulong var_40h;\n    int64_t var_38h;\n    int64_t var_30h;\n    ulong *var_28h_2;\n    ulong *var_20h_2;\n    ulong *var_18h_2;\n    ulong *var_10h_2;\n    ulong *var_8h;\n    \n    var_40h = arg_30h;\n    var_10h = arg2;\n    var_18h = arg4;\n    var_20h = arg1;\n    var_28h = arg3;\n    if ((arg2 == 0) || (arg3 == 0)) {\n        puVar1 = fcn.1400139ac();\n        *puVar1 = 0x16;\n        fcn.14001388c();\n        uVar2 = 0xffffffff;\n    }\n    else {\n        var_28h_2 = &var_10h;\n        var_20h_2 = &var_18h;\n        var_18h_2 = &var_20h;\n        var_10h_2 = &var_28h;\n        var_8h = &var_40h;\n        var_38h = arg2;\n        var_30h = arg2;\n        uVar2 = fcn.14000b374(&arg_30h, &var_30h, &var_28h_2, &var_38h);\n    }\n    return uVar2;\n}\n",
        "token_count": 402
    },
    "14000ef7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.14000ef78(ulong arg1, ulong arg2, uint64_t arg3)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    \n    if (arg3 == 0) {\n        puVar2 = fcn.1400139ac();\n        *puVar2 = 0x16;\n        fcn.14001388c();\n    }\n    else if ((arg3 < 0x100000000) &&\n            (uVar1 = (*_sym.imp.KERNEL32.dll_GetFullPathNameW)(arg2, arg3 & 0xffffffff, arg1, 0),  uVar1 < arg3)) {\n        if (uVar1 != 0) {\n            return arg1;\n        }\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        fcn.14001393c(uVar1);\n    }\n    else {\n        puVar2 = fcn.1400139ac();\n        *puVar2 = 0x22;\n    }\n    return 0;\n}\n",
        "token_count": 228
    },
    "14000f43": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.14000f438(uint *arg1)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    \n    if (arg1 == NULL) {\n        puVar1 = fcn.1400139ac();\n        *puVar1 = 0x16;\n        fcn.14001388c();\n        uVar2 = 0x16;\n    }\n    else {\n        *arg1 = *0x14003cd58;\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 116
    },
    "14000ff9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.14000ff98(ulong lpPathName)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    ulong uVar3;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_RemoveDirectoryW)();\n    if (iVar1 == 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        fcn.14001393c(uVar2);\n        uVar3 = 0xffffffff;\n    }\n    else {\n        uVar3 = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 123
    },
    "140010e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140010e08(ulong lpFileName)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    ulong uVar3;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_DeleteFileW)();\n    if (iVar1 == 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        fcn.14001393c(uVar2);\n        uVar3 = 0xffffffff;\n    }\n    else {\n        uVar3 = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 122
    },
    "140011f6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t fcn.140011f60(ulong param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    \n    iVar2 = *0x14003c700;\n    if (*0x14003c700 == 0) {\n        if ((*0x14003c708 == 0) || (iVar1 = fcn.140011a8c(),  iVar1 != 0)) {\n            iVar2 = 0;\n        }\n        else {\n            iVar1 = fcn.140011da4(param_1, param_2, param_3, param_4);\n            iVar2 = *0x14003c700;\n            if (iVar1 != 0) {\n                iVar2 = 0;\n            }\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 189
    },
    "140011a4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t fcn.140011a44(ulong param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    \n    iVar2 = *0x14003c708;\n    if (*0x14003c708 == 0) {\n        if ((*0x14003c700 == 0) || (iVar1 = fcn.140011af8(),  iVar1 != 0)) {\n            iVar2 = 0;\n        }\n        else {\n            iVar1 = fcn.140011e78(param_1, param_2, param_3, param_4);\n            iVar2 = *0x14003c708;\n            if (iVar1 != 0) {\n                iVar2 = 0;\n            }\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 188
    },
    "140011f2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140011f28(int64_t *arg1)\n\n{\n    if (*arg1 != *0x14003c718) {\n        fcn.140011d60(*arg1);\n    }\n    return;\n}\n",
        "token_count": 50
    },
    "140011f4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140011f44(int64_t *arg1)\n\n{\n    if (*arg1 != *0x14003c710) {\n        fcn.140011d60(*arg1);\n    }\n    return;\n}\n",
        "token_count": 50
    },
    "140011fa": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140011fa8(void)\n\n{\n    if (*0x14003c710 == 0) {\n        *0x14003c710 = fcn.140011a44();\n    }\n    return;\n}\n",
        "token_count": 49
    },
    "140011af": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140011af8(ulong param_1)\n\n{\n    int64_t iVar1;\n    ulong uVar2;\n    int64_t arg1;\n    int64_t iVar3;\n    \n    uVar2 = 0;\n    if (*0x14003c708 == 0) {\n        arg1 = fcn.14001ac4c(param_1);\n        if (arg1 == 0) {\n            uVar2 = 0xffffffff;\n        }\n        else {\n            iVar3 = fcn.140011c5c(arg1);\n            iVar1 = iVar3;\n            if (iVar3 == 0) {\n                uVar2 = 0xffffffff;\n                iVar3 = *0x14003c708;\n                iVar1 = *0x14003c710;\n            }\n            *0x14003c710 = iVar1;\n            *0x14003c708 = iVar3;\n            fcn.140012a5c(0);\n        }\n        fcn.140012a5c(arg1);\n    }\n    else {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 245
    },
    "14001288": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.14001288c(ulong arg1, ulong arg2)\n\n{\n    ulong uStackX8;\n    ulong uStackX16;\n    ulong var_20h_2;\n    ulong var_28h;\n    ulong var_20h;\n    ulong *var_18h;\n    ulong *var_bp_10h;\n    \n    var_18h = &uStackX8;\n    var_bp_10h = &uStackX16;\n    var_28h._0_4_ = 2;\n    var_20h._0_4_ = 2;\n    uStackX8 = arg1;\n    uStackX16 = arg2;\n    fcn.140012448(&var_20h_2, &var_20h, &var_18h, &var_28h);\n    return;\n}\n",
        "token_count": 192
    },
    "140012a2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140012a20(void)\n\n{\n    code *pcVar1;\n    code **ppcVar2;\n    bool bVar3;\n    \n    ppcVar2 = 0x140027828;\n    do {\n        pcVar1 = *ppcVar2;\n        if (pcVar1 != NULL) {\n            (**0x140022310)(pcVar1);\n            (*pcVar1)(0);\n        }\n        bVar3 = ppcVar2 != 0x140027748;\n        ppcVar2 = ppcVar2 + -2;\n    } while (bVar3);\n    return 1;\n}\n",
        "token_count": 138
    },
    "14001653": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.140016534(uint16_t *arg1, uint8_t *arg2, uint64_t arg3, ulong arg4)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint uVar3;\n    int64_t iStack40;\n    int64_t aiStack32 [2];\n    char cStack16;\n    \n    if ((arg2 != NULL) && (arg3 != 0)) {\n        if (*arg2 != 0) {\n            fcn.14000b858(&iStack40, arg4);\n            if (*(aiStack32[0] + 0x138) == 0) {\n                if (arg1 != NULL) {\n                    *arg1 = *arg2;\n                }\n                uVar3 = 1;\n            }\n            else {\n                iVar1 = fcn.140018954(*arg2, aiStack32);\n                uVar3 = 1;\n                if (iVar1 == 0) {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                      (*(aiStack32[0] + 0xc), 9, arg2, 1, arg1, arg1 != NULL);\n                    if (iVar1 != 0) goto code_r0x000140016662;\n                }\n                else {\n                    iVar1 = *(aiStack32[0] + 8);\n                    if ((((1 < iVar1) && (iVar1 <= arg3)) &&\n                        (iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                           (*(aiStack32[0] + 0xc), 9, arg2, iVar1, arg1, arg1 != NULL),  iVar1 != 0)) ||\n                       ((*(aiStack32[0] + 8) <= arg3 && (arg2[1] != 0)))) {\n                        uVar3 = *(aiStack32[0] + 8);\n                        goto code_r0x000140016662;\n                    }\n                }\n                puVar2 = fcn.1400139ac();\n                uVar3 = 0xffffffff;\n                *puVar2 = 0x2a;\n            }\ncode_r0x000140016662:\n            if (cStack16 == '\\0') {\n                return uVar3;\n            }\n            *(iStack40 + 0x3a8) = *(iStack40 + 0x3a8) & 0xfffffffd;\n            return uVar3;\n        }\n        if (arg1 != NULL) {\n            *arg1 = 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 563
    },
    "140016d2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140016d28(int64_t arg1, int64_t *arg2)\n\n{\n    int64_t iVar1;\n    \n    if ((*arg2 != *0x14003cd50) && ((*0x14003242c & *(arg1 + 0x3a8)) == 0)) {\n        iVar1 = fcn.14001b530();\n        *arg2 = iVar1;\n    }\n    return;\n}\n",
        "token_count": 96
    },
    "140016d5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140016d5c(int64_t arg1, int64_t *arg2)\n\n{\n    int64_t iVar1;\n    \n    if ((*arg2 != *0x140032668) && ((*0x14003242c & *(arg1 + 0x3a8)) == 0)) {\n        iVar1 = fcn.14001a7e0();\n        *arg2 = iVar1;\n    }\n    return;\n}\n",
        "token_count": 98
    },
    "140017b7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.140017b74(uint16_t *arg1, uint16_t *arg2)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint16_t uVar3;\n    uint16_t uVar4;\n    int64_t iVar5;\n    int64_t iStack40;\n    int64_t aiStack32 [2];\n    char cStack16;\n    \n    if (*0x14003c734 == 0) {\n        if ((arg1 != NULL) && (arg2 != NULL)) {\n            iVar5 = arg1 - arg2;\n            do {\n                uVar4 = *(iVar5 + arg2);\n                if (uVar4 - 0x41 < 0x1a) {\n                    uVar4 = uVar4 + 0x20;\n                }\n                uVar3 = *arg2;\n                if (uVar3 - 0x41 < 0x1a) {\n                    uVar3 = uVar3 + 0x20;\n                }\n                arg2 = arg2 + 1;\n            } while ((uVar4 != 0) && (uVar4 == uVar3));\n            return uVar4 - uVar3;\n        }\n        puVar2 = fcn.1400139ac();\n        *puVar2 = 0x16;\n        fcn.14001388c();\n        return 0x7fffffff;\n    }\n    fcn.14000b858(&iStack40, 0);\n    if ((arg1 == NULL) || (arg2 == NULL)) {\n        puVar2 = fcn.1400139ac();\n        *puVar2 = 0x16;\n        fcn.14001388c();\n        iVar1 = 0x7fffffff;\n    }\n    else {\n        if (*(aiStack32[0] + 0x138) == 0) {\n            iVar5 = arg1 - arg2;\n            do {\n                uVar4 = *(iVar5 + arg2);\n                if (uVar4 - 0x41 < 0x1a) {\n                    uVar4 = uVar4 + 0x20;\n                }\n                uVar3 = *arg2;\n                if (uVar3 - 0x41 < 0x1a) {\n                    uVar3 = uVar3 + 0x20;\n                }\n                arg2 = arg2 + 1;\n            } while ((uVar4 != 0) && (uVar4 == uVar3));\n        }\n        else {\n            do {\n                uVar4 = fcn.14001d944(*arg1, aiStack32);\n                arg1 = arg1 + 1;\n                uVar3 = fcn.14001d944(*arg2, aiStack32);\n                arg2 = arg2 + 1;\n                if (uVar4 == 0) break;\n            } while (uVar4 == uVar3);\n        }\n        iVar1 = uVar4 - uVar3;\n    }\n    if (cStack16 != '\\0') {\n        *(iStack40 + 0x3a8) = *(iStack40 + 0x3a8) & 0xfffffffd;\n    }\n    return iVar1;\n}\n",
        "token_count": 702
    },
    "1400180b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.1400180b4(ulong noname_0, ulong *arg2, ulong arg3, ulong *arg4)\n\n{\n    uint uVar1;\n    \n    fcn.14000b29c(*arg2);\n    uVar1 = fcn.1400180f4(arg3);\n    fcn.14000b2a8(*arg4);\n    return uVar1;\n}\n",
        "token_count": 89
    },
    "1400184e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.1400184e0(ulong lpFileName, ulong lpBuffer, ulong arg3)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    \n    if (arg3 == 0) {\n        puVar2 = fcn.1400139ac();\n        *puVar2 = 0x16;\n        fcn.14001388c();\n    }\n    else {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetFullPathNameW)(lpFileName, arg3, lpBuffer, 0);\n        if (uVar1 < arg3) {\n            if (uVar1 != 0) {\n                return lpBuffer;\n            }\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            fcn.14001393c(uVar1);\n        }\n        else {\n            puVar2 = fcn.1400139ac();\n            *puVar2 = 0x22;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 214
    },
    "1400189f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.1400189f8(void)\n\n{\n    uint64_t uVar1;\n    \n    uVar1 = *0x14003cf68;\n    while (uVar1 != 0) {\n        uVar1 = uVar1 - 1;\n        (*_sym.imp.KERNEL32.dll_DeleteCriticalSection)(uVar1 * 0x28 + 0x14003cd60);\n        *0x14003cf68 = *0x14003cf68 - 1;\n    }\n    return 1;\n}\n",
        "token_count": 115
    },
    "14001ae2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.14001ae20(int64_t *arg1)\n\n{\n    if (arg1 != NULL) {\n        if (*arg1 != *0x140032990) {\n            fcn.140012a5c(*arg1);\n        }\n        if (arg1[1] != *0x140032998) {\n            fcn.140012a5c(arg1[1]);\n        }\n        if (arg1[2] != *0x1400329a0) {\n            fcn.140012a5c(arg1[2]);\n        }\n        if (arg1[0xb] != *0x1400329e8) {\n            fcn.140012a5c(arg1[0xb]);\n        }\n        if (arg1[0xc] != *0x1400329f0) {\n            fcn.140012a5c(arg1[0xc]);\n        }\n    }\n    return;\n}\n",
        "token_count": 203
    },
    "14001b60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t fcn.14001b608(int64_t arg1, uint64_t arg2, uint64_t arg3)\n\n{\n    uint *puVar1;\n    uint64_t uVar2;\n    int64_t iVar3;\n    \n    if ((arg2 == 0) || (arg3 <= 0xffffffffffffffe0 / arg2)) {\n        if (arg1 == 0) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = fcn.14001fb50(arg1);\n        }\n        arg2 = arg2 * arg3;\n        iVar3 = fcn.14001fb8c(arg1, arg2);\n        if ((iVar3 != 0) && (uVar2 < arg2)) {\n            fcn.140009280(iVar3 + uVar2, 0, arg2 - uVar2);\n        }\n    }\n    else {\n        puVar1 = fcn.1400139ac(arg1, 0xffffffffffffffe0 % arg2);\n        *puVar1 = 0xc;\n        iVar3 = 0;\n    }\n    return iVar3;\n}\n",
        "token_count": 247
    },
    "14001da5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.14001da58(uint *arg1)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    \n    if (arg1 == NULL) {\n        puVar1 = fcn.1400139ac();\n        *puVar1 = 0x16;\n        fcn.14001388c();\n        uVar2 = 0x16;\n    }\n    else {\n        *arg1 = *0x14003cfac;\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 116
    },
    "14001da8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.14001da88(uint *arg1)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    \n    if (arg1 == NULL) {\n        puVar1 = fcn.1400139ac();\n        *puVar1 = 0x16;\n        fcn.14001388c();\n        uVar2 = 0x16;\n    }\n    else {\n        *arg1 = *0x14003cfb0;\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 117
    },
    "14001dab": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.14001dab8(uint *arg1)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    \n    if (arg1 == NULL) {\n        puVar1 = fcn.1400139ac();\n        *puVar1 = 0x16;\n        fcn.14001388c();\n        uVar2 = 0x16;\n    }\n    else {\n        *arg1 = *0x14003cfa8;\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 118
    },
    "14001fc1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file"
        ],
        "decompiled_code": "\nvoid fcn.14001fc10(void)\n\n{\n    *0x140032ae0 = (*_sym.imp.KERNEL32.dll_CreateFileW)(L\"CONOUT$\", 0x40000000, 3, 0, 3, 0, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "14002114": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140021140(ulong param_1, ulong param_2, ulong param_3)\n\n{\n    fcn.140021160(param_1, param_2, param_3, 0x1b);\n    return;\n}\n",
        "token_count": 54
    },
    "14000454": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid fcn.140004540(ulong param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    int16_t *piVar1;\n    int16_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    uint uVar5;\n    uint uVar6;\n    uint uVar7;\n    uint uVar8;\n    uint uVar9;\n    uint uVar10;\n    uint *puVar11;\n    int32_t iVar12;\n    int64_t iVar13;\n    int64_t iVar14;\n    uint *puVar15;\n    uchar *puVar16;\n    uint *puVar17;\n    uint *puVar18;\n    int64_t iVar19;\n    int64_t iVar20;\n    ulong var_53b0h;\n    uint auStack21112 [139];\n    uint uStack20554;\n    uchar auStack12344 [4112];\n    int16_t aiStack8232 [4104];\n    uint64_t uStack24;\n    ulong uStack16;\n    \n    uStack16 = 0x140004562;\n    iVar13 = fcn.140008450();\n    iVar13 = -iVar13;\n    uStack24 = *0x140032010 ^ &stack0xfffffffffffffff8 + iVar13;\n    *(&stack0xfffffffffffffff0 + iVar13) = 0x14000458b;\n    fcn.1400052b0(&stack0xffffffffffffdfd8, param_1, 0x1000, param_4);\n    iVar19 = 0;\n    do {\n        piVar1 = &stack0xffffffffffffdfd8 + iVar19;\n        *(&stack0xffffffffffffafb8 + iVar19) = *piVar1;\n        iVar19 = iVar19 + 2;\n    } while (*piVar1 != 0);\n    iVar19 = -1;\n    do {\n        iVar14 = iVar19;\n        iVar19 = iVar14 + 1;\n    } while (*(&stack0xffffffffffffafb8 + iVar19 * 2) != 0);\n    if ((*(&stack0xffffffffffffafb6 + iVar19 * 2) != 0x2f) && (*(&stack0xffffffffffffafb6 + iVar19 * 2) != 0x5c)) {\n        puVar17 = &stack0xffffffffffffafb6;\n        do {\n            piVar1 = puVar17 + 2;\n            puVar17 = puVar17 + 2;\n        } while (*piVar1 != 0);\n        iVar19 = iVar14 + 2;\n        *puVar17 = *0x140023ad0;\n    }\n    puVar17 = &stack0xffffffffffffafb6;\n    do {\n        piVar1 = puVar17 + 2;\n        puVar17 = puVar17 + 2;\n    } while (*piVar1 != 0);\n    *puVar17 = *0x140023ad4;\n    *(&stack0xfffffffffffffff0 + iVar13) = 0x140004625;\n    iVar14 = fcn.1400102e8(&stack0xffffffffffffafb8, &stack0xffffffffffffad88);\n    if (iVar14 != -1) {\n        iVar20 = 4;\n        puVar17 = &stack0x00000018 + iVar13;\n        puVar11 = &stack0xffffffffffffad88;\n        do {\n            puVar18 = puVar11;\n            puVar15 = puVar17;\n            uVar3 = puVar18[1];\n            uVar4 = puVar18[2];\n            uVar5 = puVar18[3];\n            uVar6 = puVar18[4];\n            uVar7 = puVar18[5];\n            uVar8 = puVar18[6];\n            uVar9 = puVar18[7];\n            *puVar15 = *puVar18;\n            puVar15[1] = uVar3;\n            puVar15[2] = uVar4;\n            puVar15[3] = uVar5;\n            uVar3 = puVar18[8];\n            uVar4 = puVar18[9];\n            uVar5 = puVar18[10];\n            uVar10 = puVar18[0xb];\n            puVar15[4] = uVar6;\n            puVar15[5] = uVar7;\n            puVar15[6] = uVar8;\n            puVar15[7] = uVar9;\n            uVar6 = puVar18[0xc];\n            uVar7 = puVar18[0xd];\n            uVar8 = puVar18[0xe];\n            uVar9 = puVar18[0xf];\n            puVar15[8] = uVar3;\n            puVar15[9] = uVar4;\n            puVar15[10] = uVar5;\n            puVar15[0xb] = uVar10;\n            uVar3 = puVar18[0x10];\n            uVar4 = puVar18[0x11];\n            uVar5 = puVar18[0x12];\n            uVar10 = puVar18[0x13];\n            puVar15[0xc] = uVar6;\n            puVar15[0xd] = uVar7;\n            puVar15[0xe] = uVar8;\n            puVar15[0xf] = uVar9;\n            uVar6 = puVar18[0x14];\n            uVar7 = puVar18[0x15];\n            uVar8 = puVar18[0x16];\n            uVar9 = puVar18[0x17];\n            puVar15[0x10] = uVar3;\n            puVar15[0x11] = uVar4;\n            puVar15[0x12] = uVar5;\n            puVar15[0x13] = uVar10;\n            uVar3 = puVar18[0x18];\n            uVar4 = puVar18[0x19];\n            uVar5 = puVar18[0x1a];\n            uVar10 = puVar18[0x1b];\n            puVar15[0x14] = uVar6;\n            puVar15[0x15] = uVar7;\n            puVar15[0x16] = uVar8;\n            puVar15[0x17] = uVar9;\n            uVar6 = puVar18[0x1c];\n            uVar7 = puVar18[0x1d];\n            uVar8 = puVar18[0x1e];\n            uVar9 = puVar18[0x1f];\n            puVar15[0x18] = uVar3;\n            puVar15[0x19] = uVar4;\n            puVar15[0x1a] = uVar5;\n            puVar15[0x1b] = uVar10;\n            puVar15[0x1c] = uVar6;\n            puVar15[0x1d] = uVar7;\n            puVar15[0x1e] = uVar8;\n            puVar15[0x1f] = uVar9;\n            iVar20 = iVar20 + -1;\n            puVar17 = puVar15 + 0x20;\n            puVar11 = puVar18 + 0x20;\n        } while (iVar20 != 0);\n        uVar7 = puVar18[0x21];\n        uVar8 = puVar18[0x22];\n        uVar9 = puVar18[0x23];\n        uVar3 = puVar18[0x24];\n        uVar4 = puVar18[0x25];\n        uVar5 = puVar18[0x26];\n        uVar6 = puVar18[0x27];\n        puVar15[0x20] = puVar18[0x20];\n        puVar15[0x21] = uVar7;\n        puVar15[0x22] = uVar8;\n        puVar15[0x23] = uVar9;\n        uVar7 = puVar18[0x28];\n        uVar8 = puVar18[0x29];\n        uVar9 = puVar18[0x2a];\n        uVar10 = puVar18[0x2b];\n        puVar15[0x24] = uVar3;\n        puVar15[0x25] = uVar4;\n        puVar15[0x26] = uVar5;\n        puVar15[0x27] = uVar6;\n        puVar15[0x28] = uVar7;\n        puVar15[0x29] = uVar8;\n        puVar15[0x2a] = uVar9;\n        puVar15[0x2b] = uVar10;\n        *(&stack0xfffffffffffffff0 + iVar13) = 0x1400046cd;\n        fcn.140004b70(&stack0xffffffffffffafb8, iVar19, &stack0x00000018 + iVar13);\n        *(&stack0xfffffffffffffff0 + iVar13) = 0x1400046dc;\n        iVar12 = fcn.1400102f0(iVar14, &stack0xffffffffffffad88);\n        while (iVar12 == 0) {\n            iVar20 = 4;\n            puVar17 = &stack0x00000018 + iVar13;\n            puVar11 = &stack0xffffffffffffad88;\n            do {\n                puVar18 = puVar11;\n                puVar15 = puVar17;\n                uVar3 = puVar18[1];\n                uVar4 = puVar18[2];\n                uVar5 = puVar18[3];\n                uVar6 = puVar18[4];\n                uVar7 = puVar18[5];\n                uVar8 = puVar18[6];\n                uVar9 = puVar18[7];\n                *puVar15 = *puVar18;\n                puVar15[1] = uVar3;\n                puVar15[2] = uVar4;\n                puVar15[3] = uVar5;\n                uVar3 = puVar18[8];\n                uVar4 = puVar18[9];\n                uVar5 = puVar18[10];\n                uVar10 = puVar18[0xb];\n                puVar15[4] = uVar6;\n                puVar15[5] = uVar7;\n                puVar15[6] = uVar8;\n                puVar15[7] = uVar9;\n                uVar6 = puVar18[0xc];\n                uVar7 = puVar18[0xd];\n                uVar8 = puVar18[0xe];\n                uVar9 = puVar18[0xf];\n                puVar15[8] = uVar3;\n                puVar15[9] = uVar4;\n                puVar15[10] = uVar5;\n                puVar15[0xb] = uVar10;\n                uVar3 = puVar18[0x10];\n                uVar4 = puVar18[0x11];\n                uVar5 = puVar18[0x12];\n                uVar10 = puVar18[0x13];\n                puVar15[0xc] = uVar6;\n                puVar15[0xd] = uVar7;\n                puVar15[0xe] = uVar8;\n                puVar15[0xf] = uVar9;\n                uVar6 = puVar18[0x14];\n                uVar7 = puVar18[0x15];\n                uVar8 = puVar18[0x16];\n                uVar9 = puVar18[0x17];\n                puVar15[0x10] = uVar3;\n                puVar15[0x11] = uVar4;\n                puVar15[0x12] = uVar5;\n                puVar15[0x13] = uVar10;\n                uVar3 = puVar18[0x18];\n                uVar4 = puVar18[0x19];\n                uVar5 = puVar18[0x1a];\n                uVar10 = puVar18[0x1b];\n                puVar15[0x14] = uVar6;\n                puVar15[0x15] = uVar7;\n                puVar15[0x16] = uVar8;\n                puVar15[0x17] = uVar9;\n                uVar6 = puVar18[0x1c];\n                uVar7 = puVar18[0x1d];\n                uVar8 = puVar18[0x1e];\n                uVar9 = puVar18[0x1f];\n                puVar15[0x18] = uVar3;\n                puVar15[0x19] = uVar4;\n                puVar15[0x1a] = uVar5;\n                puVar15[0x1b] = uVar10;\n                puVar15[0x1c] = uVar6;\n                puVar15[0x1d] = uVar7;\n                puVar15[0x1e] = uVar8;\n                puVar15[0x1f] = uVar9;\n                iVar20 = iVar20 + -1;\n                puVar17 = puVar15 + 0x20;\n                puVar11 = puVar18 + 0x20;\n            } while (iVar20 != 0);\n            uVar3 = puVar18[0x21];\n            uVar4 = puVar18[0x22];\n            uVar5 = puVar18[0x23];\n            uVar6 = puVar18[0x24];\n            uVar7 = puVar18[0x25];\n            uVar8 = puVar18[0x26];\n            uVar9 = puVar18[0x27];\n            puVar15[0x20] = puVar18[0x20];\n            puVar15[0x21] = uVar3;\n            puVar15[0x22] = uVar4;\n            puVar15[0x23] = uVar5;\n            uVar3 = puVar18[0x28];\n            uVar4 = puVar18[0x29];\n            uVar5 = puVar18[0x2a];\n            uVar10 = puVar18[0x2b];\n            puVar15[0x24] = uVar6;\n            puVar15[0x25] = uVar7;\n            puVar15[0x26] = uVar8;\n            puVar15[0x27] = uVar9;\n            puVar15[0x28] = uVar3;\n            puVar15[0x29] = uVar4;\n            puVar15[0x2a] = uVar5;\n            puVar15[0x2b] = uVar10;\n            if (((*(&stack0x0000003c + iVar13) != *0x140023ac4) || (*(&stack0x0000003e + iVar13) != *0x140023ac6)) &&\n               ((*(&stack0x0000003c + iVar13) != *0x140023ac8 ||\n                ((*(&stack0x0000003e + iVar13) != *0x140023aca || (*(&stack0x00000040 + iVar13) != *0x140023acc)))))) {\n                *(&stack0xffffffffffffafb8 + iVar19 * 2) = 0;\n                puVar16 = &stack0xffffffffffffafb6;\n                do {\n                    piVar1 = puVar16 + 2;\n                    puVar16 = puVar16 + 2;\n                } while (*piVar1 != 0);\n                iVar20 = 0;\n                do {\n                    iVar2 = *(&stack0x0000003c + iVar20 * 2 + iVar13);\n                    *(puVar16 + iVar20 * 2) = iVar2;\n                    iVar20 = iVar20 + 1;\n                } while (iVar2 != 0);\n                if ((auStack21112[0] & 0x10) == 0) {\n                    *(&stack0xfffffffffffffff0 + iVar13) = 0x14000482e;\n                    iVar12 = fcn.140010e08(&stack0xffffffffffffafb8);\n                    if (iVar12 != 0) {\n                        *(&stack0xfffffffffffffff0 + iVar13) = 0x14000483d;\n                        (*_sym.imp.KERNEL32.dll_Sleep)(100);\n                        *(&stack0xfffffffffffffff0 + iVar13) = 0x140004849;\n                        fcn.140010e08(&stack0xffffffffffffafb8);\n                    }\n                }\n                else {\n                    *(&stack0xfffffffffffffff0 + iVar13) = 0x140004814;\n                    fcn.1400053b0(&stack0xffffffffffffcfc8, &stack0xffffffffffffafb8, 0x1000, param_4);\n                    *(&stack0xfffffffffffffff0 + iVar13) = 0x140004820;\n                    fcn.140004540(&stack0xffffffffffffcfc8);\n                }\n            }\n            *(&stack0xfffffffffffffff0 + iVar13) = 0x140004858;\n            iVar12 = fcn.1400102f0(iVar14, &stack0xffffffffffffad88);\n        }\n        *(&stack0xfffffffffffffff0 + iVar13) = 0x140004868;\n        fcn.1400102c0(iVar14);\n    }\n    *(&stack0xfffffffffffffff0 + iVar13) = 0x140004874;\n    fcn.14000ff98(&stack0xffffffffffffdfd8);\n    *(&stack0xfffffffffffffff0 + iVar13) = 0x140004883;\n    fcn.140008410(uStack24 ^ &stack0xfffffffffffffff8 + iVar13);\n    return;\n}\n",
        "token_count": 3931
    },
    "140004ce": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nulong fcn.140004ce0(ulong lpMultiByteStr, ulong noname_1, ulong noname_2, ulong arg4)\n\n{\n    int32_t iVar1;\n    int64_t arg1;\n    ulong uVar2;\n    code *pcVar3;\n    code *pcVar4;\n    int64_t iVar5;\n    ulong arg4_00;\n    ulong uStack72;\n    int64_t iStack64;\n    ulong uStack56;\n    ulong uStack48;\n    ulong uStack40;\n    ulong uStack32;\n    ulong uStack24;\n    \n    iVar5 = 0;\n    arg4_00 = 0xffffffff;\n    uVar2 = lpMultiByteStr;\n    iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0xfde9, 0, lpMultiByteStr, 0xffffffff, 0, 0);\n    if (iVar1 == 0) {\n        fcn.140001a40(0x140023d18, \"Failed to get wchar_t buffer size.\\n\", uVar2, arg4_00);\n        arg1 = iVar5;\n    }\n    else {\n        arg1 = fcn.14000a240(iVar1 + 1, 2);\n        if (arg1 == 0) {\n            fcn.140001a40(\"win32_utils_from_utf8\", \"Out of memory.\", uVar2, arg4_00);\n            arg1 = iVar5;\n        }\n        else {\n            uVar2 = 0xffffffff;\n            iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0xfde9, 0, lpMultiByteStr, 0xffffffff, arg1, iVar1);\n            if (iVar1 == 0) {\n                fcn.140001a40(0x140023d18, \"Failed to decode wchar_t from UTF-8\\n\", lpMultiByteStr, uVar2);\n                arg1 = iVar5;\n            }\n        }\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x140023bc8);\n    pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2, \"CreateActCtxW\");\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2, \"ActivateActCtx\");\n    if ((pcVar3 != NULL) && (pcVar4 != NULL)) {\n        uStack72 = 0x1000000038;\n        uStack56 = 0;\n        uStack48 = 0;\n        uStack40 = 0;\n        uStack32 = 0;\n        uStack24 = 0;\n        iStack64 = arg1;\n        *0x140032000 = (*pcVar3)(&uStack72);\n        fcn.14000a248(arg1);\n        if ((*0x140032000 != -1) && (iVar1 = (*pcVar4)(*0x140032000, 0x14003acf0),  iVar1 != 0)) {\n            return 1;\n        }\n        *0x140032000 = 0xffffffffffffffff;\n        fcn.140004e70(0);\n    }\n    return 0;\n}\n",
        "token_count": 703
    },
    "140002ac": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nulong fcn.140002ac0(ushort *arg1, ulong arg2)\n\n{\n    int64_t iVar1;\n    int32_t iVar2;\n    int64_t iVar3;\n    uchar *puVar4;\n    \n    iVar2 = fcn.140002010(arg1, 0x1000, 0x1400225d4, arg2);\n    if (0xfff < iVar2) {\n        return 0;\n    }\n    iVar1 = -1;\n    do {\n        iVar3 = iVar1;\n        iVar1 = iVar3 + 1;\n    } while (*(arg1 + iVar3 + 1) != '\\0');\n    if (*(iVar3 + arg1) == '\\\\') {\n        *(iVar3 + arg1) = 0;\n    }\n    puVar4 = fcn.140009420(arg1, 0x5c);\n    if (puVar4 != NULL) {\n        *puVar4 = 0;\n        return 1;\n    }\n    *arg1 = 0x2e;\n    return 1;\n}\n",
        "token_count": 231
    },
    "14000a25": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint64_t fcn.14000a250(uint64_t arg1)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    uint *puVar3;\n    \n    if (arg1 < 0xffffffffffffffe1) {\n        if (arg1 == 0) {\n            arg1 = 1;\n        }\n        do {\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x14003cf98, 0, arg1);\n            if (iVar2 != 0) {\n                return iVar2;\n            }\n            iVar1 = fcn.14001240c();\n        } while ((iVar1 != 0) && (iVar1 = fcn.14001b7bc(arg1),  iVar1 != 0));\n    }\n    puVar3 = fcn.1400139ac();\n    *puVar3 = 0xc;\n    return 0;\n}\n",
        "token_count": 198
    },
    "14000ae3": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint64_t fcn.14000ae38(char **arg1)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    int64_t arg2;\n    char *pcVar4;\n    uint64_t uVar5;\n    int64_t iVar6;\n    int64_t iVar7;\n    \n    if (arg1 == NULL) {\n        puVar3 = fcn.1400139ac();\n        *puVar3 = 0x16;\n        fcn.14001388c();\n    }\n    else {\n        uVar2 = fcn.14000f878(arg1);\n        if (*(arg1 + 2) < 0) {\n            *(arg1 + 2) = 0;\n        }\n        arg2 = fcn.140014b58(uVar2 & 0xffffffff, 0, 1);\n        if (-1 < arg2) {\n            if ((*(arg1 + 0x14) & 0xc0) == 0) {\n                return arg2 - *(arg1 + 2);\n            }\n            iVar7 = uVar2 >> 6;\n            iVar6 = (uVar2 & 0x3f) * 0x40;\n            cVar1 = *(iVar6 + 0x39 + *(iVar7 * 8 + 0x14003c780));\n            uVar5 = *arg1 - arg1[1];\n            if ((*(arg1 + 0x14) & 3) == 0) {\n                if ((*(arg1 + 0x14) >> 2 & 1) == 0) {\n                    puVar3 = fcn.1400139ac();\n                    *puVar3 = 0x16;\n                    return 0xffffffffffffffff;\n                }\n            }\n            else {\n                if ((cVar1 == '\\x01') && ((*(iVar6 + 0x3d + *(iVar7 * 8 + 0x14003c780)) & 2) != 0)) {\n                    uVar5 = fcn.14000acc0(arg1);\n                    return uVar5;\n                }\n                if ((*(iVar6 + 0x38 + *(iVar7 * 8 + 0x14003c780)) & 0x80) != 0) {\n                    pcVar4 = arg1[1];\n                    iVar6 = *arg1 - pcVar4;\n                    if (*arg1 <= pcVar4 && pcVar4 != *arg1) {\n                        iVar6 = 0;\n                    }\n                    if (iVar6 != 0) {\n                        iVar7 = 0;\n                        do {\n                            if (*pcVar4 == '\\n') {\n                                uVar5 = uVar5 + 1;\n                            }\n                            pcVar4 = pcVar4 + 1;\n                            iVar7 = iVar7 + 1;\n                        } while (iVar7 != iVar6);\n                    }\n                }\n            }\n            if (arg2 == 0) {\n                return uVar5;\n            }\n            if ((*(arg1 + 0x14) & 1) == 0) {\n                if (cVar1 == '\\x01') {\n                    uVar5 = uVar5 >> 1;\n                }\n                return uVar5 + arg2;\n            }\n            uVar5 = fcn.14000ab48(arg1, arg2, uVar5);\n            return uVar5;\n        }\n    }\n    return 0xffffffffffffffff;\n}\n",
        "token_count": 751
    },
    "1400122f": {
        "rules": [
            "parse PE header"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00014001219d)\n// WARNING: Removing unreachable block (ram,0x00014001213f)\n// WARNING: Removing unreachable block (ram,0x000140012164)\n// WARNING: Removing unreachable block (ram,0x00014001217e)\n// WARNING: Removing unreachable block (ram,0x00014001218c)\n// WARNING: Removing unreachable block (ram,0x000140012193)\n// WARNING: Removing unreachable block (ram,0x0001400121f5)\n\nvoid fcn.1400122f0(ulong arg1)\n\n{\n    code *pcVar1;\n    int16_t *piVar2;\n    int32_t *piVar3;\n    \n    piVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    if ((((piVar2 != NULL) && (*piVar2 == 0x5a4d)) && (piVar3 = *(piVar2 + 0x1e) + piVar2,  *piVar3 == 0x4550)) &&\n       (((*(piVar3 + 6) == 0x20b && (0xe < piVar3[0x21])) && (piVar3[0x3e] != 0)))) {\n        fcn.14001225c(arg1);\n    }\n    fcn.1400189dc(2);\n    if (*0x14003c730 == '\\0') {\n        *0x14003c720 = 1;\n        fcn.140011fd4(0x1400223a8, 0x1400223b0);\n        *0x14003c730 = '\\x01';\n    }\n    fcn.140018a30(2);\n    fcn.140012210(arg1);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 415
    }
}