{
    "10002eb8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.10002eb8(code **param_1)\n\n{\n    *param_1 = vtable.std::exception.0;\n    if (param_1[2] != NULL) {\n        fcn.10003dbb(param_1[1]);\n    }\n    return;\n}\n",
        "token_count": 65
    },
    "100010c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.100010c0(uint32_t param_1)\n\n{\n    code *pcVar1;\n    uint32_t arg_8h;\n    \n    if (param_1 == 0) {\n        arg_8h = 0;\n    }\n    else {\n        arg_8h = param_1;\n        if (0xffffffff / param_1 == 0) {\n            param_1 = 0;\n            fcn.10002deb(&param_1);\n            fcn.10003494(&stack0xfffffff0, 0x10016d10);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n    }\n    fcn.1000342f(arg_8h);\n    return;\n}\n",
        "token_count": 165
    },
    "10001220": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.10001220(int32_t param_1, char param_2, int32_t param_3)\n\n{\n    uint arg_10h;\n    \n    if ((param_2 != '\\0') && (0xf < *(param_1 + 0x18))) {\n        arg_10h = *(param_1 + 4);\n        if (param_3 != 0) {\n            fcn.10002fc5(param_1 + 4, 0x10, arg_10h, param_3);\n        }\n        fcn.10002fba(arg_10h);\n    }\n    *(param_1 + 0x14) = param_3;\n    *(param_1 + 0x18) = 0xf;\n    *(param_1 + 4 + param_3) = 0;\n    return;\n}\n",
        "token_count": 189
    },
    "10001470": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __thiscall fcn.10001470(int32_t param_1, uint32_t param_2, char param_3)\n\n{\n    uint32_t uVar1;\n    uint arg_10h;\n    uint32_t arg_14h;\n    \n    if (param_2 == 0xffffffff) {\n        fcn.1000eb02();\n    }\n    uVar1 = *(param_1 + 0x18);\n    if (uVar1 < param_2) {\n        fcn.10001300(param_2, *(param_1 + 0x14));\n        return param_2 != 0;\n    }\n    if ((param_3 != '\\0') && (param_2 < 0x10)) {\n        arg_14h = *(param_1 + 0x14);\n        if (param_2 < *(param_1 + 0x14)) {\n            arg_14h = param_2;\n        }\n        if (0xf < uVar1) {\n            arg_10h = *(param_1 + 4);\n            if (arg_14h != 0) {\n                fcn.10002fc5(param_1 + 4, 0x10, arg_10h, arg_14h);\n            }\n            fcn.10002fba(arg_10h);\n        }\n        *(param_1 + 0x14) = arg_14h;\n        *(param_1 + 0x18) = 0xf;\n        *(param_1 + 4 + arg_14h) = 0;\n        return param_2 != 0;\n    }\n    if (param_2 == 0) {\n        *(param_1 + 0x14) = 0;\n        if (0xf < uVar1) {\n            **(param_1 + 4) = 0;\n            return false;\n        }\n        *(param_1 + 4) = 0;\n    }\n    return param_2 != 0;\n}\n",
        "token_count": 434
    },
    "100018a0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.100018a0(int32_t param_1, uint32_t param_2, char param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t extraout_ECX;\n    uint32_t extraout_ECX_00;\n    int32_t *in_FS_OFFSET;\n    code *pcStack164;\n    uchar auStack120 [24];\n    code *pcStack96;\n    uchar auStack52 [16];\n    int32_t iStack36;\n    uint uStack16;\n    int32_t iStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x10013a08;\n    iStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    *(param_1 + 8) = param_2 & 0x17;\n    uVar1 = *(param_1 + 0xc) & param_2 & 0x17;\n    if (uVar1 != 0) {\n        if (param_3 != '\\0') {\n            pcStack164 = 0x100018f4;\n            fcn.10003494(0, 0);\n            uVar1 = extraout_ECX;\n        }\n        if ((uVar1 & 4) != 0) {\n            pcStack164 = 0x10014244;\n            fcn.10001860();\n            uStack16 = 0;\n            fcn.100017b0(&stack0xffffff88);\n            pcStack164 = vtable.std::ios_base::failure.0;\n            fcn.10003494(&stack0xffffff5c, 0x10016e1c);\n            uVar1 = extraout_ECX_00;\n        }\n        if ((uVar1 & 2) != 0) {\n            pcStack164 = 0x1001422c;\n            fcn.10001860();\n            uStack16 = 1;\n            fcn.100017b0(&stack0xffffff88);\n            pcStack164 = vtable.std::ios_base::failure.0;\n            fcn.10003494(&stack0xffffff5c, 0x10016e1c);\n        }\n        pcStack164 = 0x10014214;\n        fcn.10001860();\n        uStack16 = 2;\n        fcn.100017b0(&stack0xffffffcc);\n        pcStack96 = vtable.std::ios_base::failure.0;\n        fcn.10003494(&stack0xffffffa0, 0x10016e1c);\n    }\n    *in_FS_OFFSET = iStack36;\n    return;\n}\n",
        "token_count": 588
    },
    "10001a70": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.10001a70(int32_t param_1, uint32_t param_2, char param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t extraout_ECX;\n    uint32_t extraout_ECX_00;\n    int32_t **in_FS_OFFSET;\n    code *pcStack164;\n    uchar auStack120 [24];\n    code *apcStack96 [11];\n    uchar auStack52 [16];\n    int32_t *piStack36;\n    uint uStack16;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    if (*(param_1 + 0x28) == 0) {\n        param_2 = param_2 | 4;\n    }\n    uStack4 = 0xffffffff;\n    uStack8 = 0x10013a08;\n    piStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &piStack12;\n    *(param_1 + 8) = param_2 & 0x17;\n    uVar1 = *(param_1 + 0xc) & param_2 & 0x17;\n    if (uVar1 != 0) {\n        if (param_3 != '\\0') {\n            pcStack164 = 0x100018f4;\n            fcn.10003494(0, 0);\n            uVar1 = extraout_ECX;\n        }\n        if ((uVar1 & 4) != 0) {\n            pcStack164 = 0x10014244;\n            fcn.10001860();\n            uStack16 = 0;\n            fcn.100017b0(auStack120);\n            pcStack164 = vtable.std::ios_base::failure.0;\n            fcn.10003494(&pcStack164, 0x10016e1c);\n            uVar1 = extraout_ECX_00;\n        }\n        if ((uVar1 & 2) != 0) {\n            pcStack164 = 0x1001422c;\n            fcn.10001860();\n            uStack16 = 1;\n            fcn.100017b0(auStack120);\n            pcStack164 = vtable.std::ios_base::failure.0;\n            fcn.10003494(&pcStack164, 0x10016e1c);\n        }\n        pcStack164 = 0x10014214;\n        fcn.10001860();\n        uStack16 = 2;\n        fcn.100017b0(auStack52);\n        apcStack96[0] = vtable.std::ios_base::failure.0;\n        fcn.10003494(apcStack96, 0x10016e1c);\n    }\n    *in_FS_OFFSET = piStack36;\n    return;\n}\n",
        "token_count": 617
    },
    "10001a90": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.10001a90(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if ((*(param_1 + *(*param_1 + 4) + 8) & 6) == 0) {\n        iVar1 = (**(**(param_1 + *(*param_1 + 4) + 0x28) + 0x30))();\n        if (iVar1 == -1) {\n            uVar2 = 4;\n        }\n    }\n    if (uVar2 != 0) {\n        uVar2 = *(param_1 + *(*param_1 + 4) + 8) | uVar2;\n        if (*(param_1 + *(*param_1 + 4) + 0x28) == 0) {\n            uVar2 = uVar2 | 4;\n        }\n        fcn.100018a0(uVar2, 0);\n    }\n    return param_1;\n}\n",
        "token_count": 232
    },
    "10001ae0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t ** __thiscall fcn.10001ae0(int32_t **param_1, int32_t *param_2)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x10013a68;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x10019130 ^ &stack0xffffffe8;\n    *in_FS_OFFSET = &piStack12;\n    *param_1 = param_2;\n    if (*(*(*param_2 + 4) + 0x28 + param_2) != 0) {\n        fcn.1000e9cf(uVar1);\n    }\n    uStack4 = 0;\n    if ((*(param_2 + *(*param_2 + 4) + 8) == 0) && (*(param_2 + *(*param_2 + 4) + 0x2c) != 0)) {\n        fcn.10001a90();\n    }\n    *(param_1 + 1) = *(*(*param_2 + 4) + 8 + param_2) == 0;\n    *in_FS_OFFSET = piStack12;\n    return param_1;\n}\n",
        "token_count": 302
    },
    "10001c40": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * fcn.10001c40(int32_t *param_1, char *param_2)\n\n{\n    char cVar1;\n    uint8_t uVar2;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    uint8_t *puVar5;\n    char *pcVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    int32_t *in_FS_OFFSET;\n    int32_t *var_8h;\n    char *var_ch_2;\n    uint var_10h;\n    uint var_ch;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    int32_t var_ch_3;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x10013ae8;\n    var_ch_3 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch_3;\n    var_14h = 0;\n    pcVar6 = var_ch_2;\n    do {\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    iVar7 = pcVar6 - (var_ch_2 + 1);\n    var_18h = *(*(*var_8h + 4) + 0x18 + var_8h);\n    if ((var_18h < 1) || (var_18h <= iVar7)) {\n        var_18h = 0;\n    }\n    else {\n        var_18h = var_18h - iVar7;\n    }\n    fcn.10001ae0(var_8h);\n    if (var_1ch == '\\0') {\n        var_14h = 4;\n        goto code_r0x10001d5c;\n    }\n    var_4h = 1;\n    if ((*(*(*var_8h + 4) + 0x10 + var_8h) & 0x1c0) == 0x40) {\ncode_r0x10001d2b:\n        iVar9 = (**(**(*(*var_8h + 4) + 0x28 + var_8h) + 0x20))(var_ch_2, iVar7);\n        if (iVar9 == iVar7) {\n            for (; 0 < var_18h; var_18h = var_18h + -1) {\n                uVar2 = *(*(*var_8h + 4) + 0x30 + var_8h);\n                piVar3 = *(var_8h + *(*var_8h + 4) + 0x28);\n                if ((*piVar3[9] == 0) || (piVar4 = piVar3[0xd],  *piVar4 < 1)) {\n                    uVar8 = (**(*piVar3 + 4))(uVar2);\n                }\n                else {\n                    *piVar4 = *piVar4 + -1;\n                    puVar5 = *piVar3[9];\n                    *piVar3[9] = puVar5 + 1;\n                    *puVar5 = uVar2;\n                    uVar8 = uVar2;\n                }\n                if (uVar8 == 0xffffffff) {\n                    var_14h = 4;\n                    break;\n                }\n            }\n        }\n        else {\n            var_14h = 4;\n        }\n    }\n    else {\n        for (; 0 < var_18h; var_18h = var_18h + -1) {\n            uVar2 = *(*(*var_8h + 4) + 0x30 + var_8h);\n            piVar3 = *(var_8h + *(*var_8h + 4) + 0x28);\n            if ((*piVar3[9] == 0) || (piVar4 = piVar3[0xd],  *piVar4 < 1)) {\n                uVar8 = (**(*piVar3 + 4))(uVar2);\n            }\n            else {\n                *piVar4 = *piVar4 + -1;\n                puVar5 = *piVar3[9];\n                *piVar3[9] = puVar5 + 1;\n                *puVar5 = uVar2;\n                uVar8 = uVar2;\n            }\n            if (uVar8 == 0xffffffff) {\n                var_14h = 4;\n                break;\n            }\n        }\n        if (var_14h == 0) goto code_r0x10001d2b;\n    }\n    *(var_8h + *(*var_8h + 4) + 0x18) = 0;\ncode_r0x10001d5c:\n    var_4h = 0;\n    if (var_14h != 0) {\n        var_14h = *(var_8h + *(*var_8h + 4) + 8) | var_14h;\n        if (*(var_8h + *(*var_8h + 4) + 0x28) == 0) {\n            var_14h = var_14h | 4;\n        }\n        fcn.100018a0(var_14h, 0);\n    }\n    var_4h = 0xffffffff;\n    fcn.10001bd0();\n    *in_FS_OFFSET = var_ch_3;\n    return var_8h;\n}\n",
        "token_count": 1242
    },
    "10001e50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * __thiscall fcn.10001e50(int32_t *param_1, uint8_t param_2)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    uint8_t *puVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    int32_t *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    uint var_ch;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_ch_2;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x10013b18;\n    var_ch_2 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch_2;\n    uVar5 = 0;\n    fcn.10001ae0(param_1);\n    if (var_1ch == '\\0') {\n        uVar5 = 4;\n    }\n    else {\n        piVar1 = *(*(*param_1 + 4) + 0x28 + param_1);\n        var_4h = 1;\n        if ((*piVar1[9] == 0) || (piVar2 = piVar1[0xd],  *piVar2 < 1)) {\n            uVar4 = (**(*piVar1 + 4))(var_8h);\n        }\n        else {\n            *piVar2 = *piVar2 + -1;\n            puVar3 = *piVar1[9];\n            *piVar1[9] = puVar3 + 1;\n            *puVar3 = var_8h;\n            uVar4 = var_8h;\n        }\n        if (uVar4 == 0xffffffff) {\n            uVar5 = 4;\n        }\n    }\n    var_4h = 0;\n    if (uVar5 != 0) {\n        uVar5 = *(param_1 + *(*param_1 + 4) + 8) | uVar5;\n        if (*(param_1 + *(*param_1 + 4) + 0x28) == 0) {\n            uVar5 = uVar5 | 4;\n        }\n        fcn.100018a0(uVar5, 0);\n    }\n    var_4h = 0xffffffff;\n    fcn.10001bd0();\n    *in_FS_OFFSET = var_ch_2;\n    return param_1;\n}\n",
        "token_count": 577
    },
    "10001f80": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.10001f80(int32_t param_1, int32_t param_2, uint8_t *param_3)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    uint64_t uVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    uint8_t *puVar6;\n    uint8_t uVar7;\n    uint8_t uVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    int32_t iStack4;\n    \n    uVar7 = *param_3;\n    uVar8 = param_3[1];\n    iStack4 = 0;\n    if (0 < param_2) {\n        uVar11 = uVar7;\n        uVar10 = uVar8;\n        do {\n            uVar3 = (uVar11 + 1) % 0x32c;\n            uVar11 = uVar3 & 0xff;\n            uVar7 = uVar3;\n            uVar3 = (*(uVar11 + *0x1001a4c0) + uVar10) % 0x32c;\n            uVar10 = uVar3 & 0xff;\n            uVar8 = uVar3;\n            fcn.10001040();\n            uVar1 = *(uVar11 + *0x1001a4c0);\n            uVar2 = *(*0x1001a4c0 + uVar10);\n            piVar4 = fcn.10001c40(0x1001afd8, 0x10014259);\n            fcn.10001e50(10);\n            uVar9 = 0;\n            if (((*(piVar4 + *(*piVar4 + 4) + 8) & 6) == 0) &&\n               (iVar5 = (**(**(piVar4 + *(*piVar4 + 4) + 0x28) + 0x30))(),  iVar5 == -1)) {\n                uVar9 = 4;\n            }\n            if (uVar9 != 0) {\n                uVar9 = *(piVar4 + *(*piVar4 + 4) + 8) | uVar9;\n                if (*(piVar4 + *(*piVar4 + 4) + 0x28) == 0) {\n                    uVar9 = uVar9 | 4;\n                }\n                fcn.100018a0(uVar9, 0);\n            }\n            iVar5 = iStack4 - *0x10019054;\n            iStack4 = iStack4 + 1;\n            puVar6 = param_1 + iVar5;\n            *puVar6 = *puVar6 ^ *((uVar2 + uVar1) % 0x32c + *0x1001a4c0);\n        } while (iStack4 < param_2);\n    }\n    param_3[1] = uVar8;\n    *param_3 = uVar7;\n    return;\n}\n",
        "token_count": 670
    },
    "100024d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool fcn.100024d0(int32_t *param_1, int32_t *param_2)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    \n    uVar1 = param_2[2];\n    if (uVar1 == 0) {\n        return true;\n    }\n    uVar2 = param_2[3];\n    if ((uVar2 & 0x2000000) != 0) {\n        if ((*param_2 == param_2[1]) &&\n           (((param_2[4] != 0 || (*(*param_1 + 0x38) == param_1[0xc])) || (uVar1 % param_1[0xc] == 0)))) {\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(*param_2, uVar1, 0x4000);\n        }\n        return true;\n    }\n    uVar4 = *((((uVar2 >> 0x1e & 1) + (uVar2 >> 0x1d & 1) * 2) * 2 - (uVar2 >> 0x1f)) * 4 + 0x100190d4);\n    if ((uVar2 & 0x4000000) != 0) {\n        uVar4 = uVar4 | 0x200;\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_VirtualProtect)(*param_2, uVar1, uVar4, &param_2);\n    return iVar3 != 0;\n}\n",
        "token_count": 357
    },
    "10002710": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool fcn.10002710(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    int32_t *piVar6;\n    \n    iVar1 = param_1[1];\n    if (*(*param_1 + 0xa4) == 0) {\n        return param_2 == 0;\n    }\n    iVar2 = *(*param_1 + 0xa0);\n    piVar4 = iVar2 + iVar1;\n    iVar2 = *(iVar2 + iVar1);\n    while (iVar2 != 0) {\n        uVar5 = 0;\n        piVar6 = piVar4 + 2;\n        if ((piVar4[1] - 8U & 0xfffffffe) != 0) {\n            do {\n                if ((*piVar6 & 0xfffff000) == 0x3000) {\n                    piVar3 = (*piVar6 & 0xfff) + iVar2 + iVar1;\n                    *piVar3 = *piVar3 + param_2;\n                }\n                uVar5 = uVar5 + 1;\n                piVar6 = piVar6 + 2;\n            } while (uVar5 < piVar4[1] - 8U >> 1);\n        }\n        piVar4 = piVar4 + piVar4[1];\n        iVar2 = *piVar4;\n    }\n    return true;\n}\n",
        "token_count": 344
    },
    "100027a0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * fcn.100027a0(int32_t *param_1)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t *unaff_EBP;\n    int32_t iVar5;\n    uint32_t *puVar6;\n    int32_t unaff_ESI;\n    int32_t *piVar7;\n    int32_t *piVar8;\n    uint32_t *puVar9;\n    \n    iVar5 = param_1[1];\n    if (*(*param_1 + 0x84) == 0) {\n        return 0x1;\n    }\n    piVar7 = *(*param_1 + 0x80) + iVar5;\n    iVar2 = (*_sym.imp.KERNEL32.dll_IsBadReadPtr)(piVar7, 0x14);\n    piVar8 = piVar7;\n    if (iVar2 == 0) {\n        while (piVar8[3] != 0) {\n            iVar2 = (*param_1[7])(piVar8[3] + iVar5, param_1[10]);\n            if (iVar2 == 0) {\n                (*_sym.imp.KERNEL32.dll_SetLastError)(0x7e);\n                return NULL;\n            }\n            iVar3 = fcn.100022e0(param_1[2], param_1[3] * 4 + 4);\n            if (iVar3 == 0) {\n                (*param_1[9])(iVar2, param_1[10]);\n                (*_sym.imp.KERNEL32.dll_SetLastError)(0xe);\n                return NULL;\n            }\n            param_1[2] = iVar3;\n            *(iVar3 + param_1[3] * 4) = iVar2;\n            param_1[3] = param_1[3] + 1;\n            if (*piVar8 == 0) {\n                puVar6 = iVar5 + piVar8[4];\n                puVar9 = puVar6;\n            }\n            else {\n                puVar6 = iVar5 + *piVar8;\n                puVar9 = piVar8[4] + unaff_ESI;\n            }\n            uVar4 = *puVar6;\n            iVar5 = unaff_ESI;\n            while (uVar4 != 0) {\n                if (uVar4 < 0) {\n                    uVar4 = (*param_1[8])(iVar2, uVar4 & 0xffff);\n                }\n                else {\n                    uVar4 = (*param_1[8])(iVar2, uVar4 + 2 + iVar5, param_1[10]);\n                }\n                *puVar9 = uVar4;\n                if (uVar4 == 0) {\n                    (*param_1[9])(iVar2, param_1[10]);\n                    (*_sym.imp.KERNEL32.dll_SetLastError)(0x7f);\n                    return NULL;\n                }\n                puVar1 = puVar6 + 1;\n                puVar6 = puVar6 + 1;\n                puVar9 = puVar9 + 1;\n                uVar4 = *puVar1;\n            }\n            piVar8 = unaff_EBP + 5;\n            iVar2 = (*_sym.imp.KERNEL32.dll_IsBadReadPtr)(piVar8, 0x14);\n            unaff_ESI = iVar5;\n            unaff_EBP = piVar8;\n            if (iVar2 != 0) {\n                return piVar7;\n            }\n        }\n    }\n    return piVar7;\n}\n",
        "token_count": 785
    },
    "10002980": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.10002980(int32_t *param_1, uint32_t param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    uint16_t *puVar6;\n    \n    iVar1 = param_1[1];\n    if (*(*param_1 + 0x7c) == 0) {\n        (*_sym.imp.KERNEL32.dll_SetLastError)(0x7f);\n        return 0;\n    }\n    iVar4 = *(*param_1 + 0x78);\n    iVar3 = *(iVar4 + 0x18 + iVar1);\n    iVar4 = iVar4 + iVar1;\n    if ((iVar3 == 0) || (*(iVar4 + 0x14) == 0)) {\n        (*_sym.imp.KERNEL32.dll_SetLastError)(0x7f);\n        return 0;\n    }\n    if (param_2 >> 0x10 == 0) {\n        if ((param_2 & 0xffff) < *(iVar4 + 0x10)) goto code_r0x10002a33;\n        uVar2 = (param_2 & 0xffff) - *(iVar4 + 0x10);\n    }\n    else {\n        piVar5 = *(iVar4 + 0x20) + iVar1;\n        puVar6 = *(iVar4 + 0x24) + iVar1;\n        uVar2 = 0;\n        if (iVar3 == 0) goto code_r0x10002a33;\n        while (iVar3 = fcn.10002340(param_2, *piVar5 + iVar1),  iVar3 != 0) {\n            uVar2 = uVar2 + 1;\n            piVar5 = piVar5 + 1;\n            puVar6 = puVar6 + 1;\n            if (*(iVar4 + 0x18) <= uVar2) {\n                (*_sym.imp.KERNEL32.dll_SetLastError)(0x7f);\n                return 0;\n            }\n        }\n        uVar2 = *puVar6;\n    }\n    if (uVar2 < *(iVar4 + 0x14) || uVar2 == *(iVar4 + 0x14)) {\n        return *(*(iVar4 + 0x1c) + uVar2 * 4 + iVar1) + iVar1;\n    }\ncode_r0x10002a33:\n    (*_sym.imp.KERNEL32.dll_SetLastError)(0x7f);\n    return 0;\n}\n",
        "token_count": 570
    },
    "10002a70": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.10002a70(int32_t *param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    if (param_1 != NULL) {\n        if (param_1[4] != 0) {\n            (*(*(*param_1 + 0x28) + param_1[1]))(param_1[1], 0, 0);\n        }\n        if (param_1[2] != 0) {\n            if (0 < param_1[3]) {\n                iVar2 = 0;\n                do {\n                    if (*(param_1[2] + iVar2 * 4) != 0) {\n                        (*param_1[9])(*(param_1[2] + iVar2 * 4), param_1[10]);\n                    }\n                    iVar2 = iVar2 + 1;\n                } while (iVar2 < param_1[3]);\n            }\n            fcn.100022a0(param_1[2]);\n        }\n        if (param_1[1] != 0) {\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(param_1[1], 0, 0x8000);\n        }\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 309
    },
    "10002b00": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * fcn.10002b00(uint param_1, uint param_2)\n\n{\n    uint16_t uVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint uVar6;\n    int32_t *piVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t *piVar10;\n    uint unaff_EBX;\n    uint32_t uVar11;\n    int32_t unaff_ESI;\n    int32_t *piVar12;\n    int32_t *noname_6;\n    int32_t iVar13;\n    int32_t *noname_7;\n    int32_t *piStack36;\n    int32_t iStack32;\n    int32_t iStack28;\n    int32_t iStack24;\n    int32_t iStack20;\n    int32_t *piStack12;\n    uint uStack8;\n    int16_t *piStack4;\n    \n    uVar11 = 0;\n    iVar4 = fcn.10002380(param_2, 0x40);\n    if (iVar4 == 0) {\n        return NULL;\n    }\n    if (*piStack4 == 0x5a4d) {\n        iVar9 = *(piStack4 + 0x1e) + 0xf8;\n        iVar4 = fcn.10002380();\n        if (iVar4 == 0) {\n            return NULL;\n        }\n        piVar12 = *(piStack4 + 0x1e) + piStack4;\n        if (((*piVar12 == 0x4550) && (*(piVar12 + 1) == 0x14c)) && ((piVar12[0xe] & 1U) == 0)) {\n            uVar5 = *(piVar12 + 6);\n            if (uVar5 != 0) {\n                piVar10 = piVar12 + *(piVar12 + 5) + 0x24;\n                do {\n                    uVar2 = piVar10[1];\n                    if (uVar2 == 0) {\n                        uVar2 = piVar12[0xe];\n                    }\n                    if (uVar11 < *piVar10 + uVar2) {\n                        uVar11 = *piVar10 + uVar2;\n                    }\n                    piVar10 = piVar10 + 10;\n                    uVar5 = uVar5 - 1;\n                } while (uVar5 != 0);\n            }\n            (*_sym.imp.KERNEL32.dll_GetNativeSystemInfo)(&stack0xffffffcc);\n            pcVar3 = _sym.imp.KERNEL32.dll_VirtualAlloc;\n            uVar5 = piVar12[0x14] + -1 + unaff_ESI & ~(unaff_ESI - 1U);\n            if (uVar5 == (unaff_ESI + -1 + uVar11 & ~(unaff_ESI - 1U))) {\n                iVar13 = 4;\n                iVar4 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(piVar12[0xd], uVar5, 0x3000);\n                if ((iVar4 != 0) || (iVar4 = (*pcVar3)(0, uVar5, 0x3000, 4),  iVar4 != 0)) {\n                    piVar10 = 0x8;\n                    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x34);\n                    piVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n                    if (piVar7 != NULL) {\n                        piVar7[1] = iVar4;\n                        uVar1 = *(piVar12 + 0x16);\n                        piVar7[7] = iStack32;\n                        piVar7[5] = uVar1 >> 0xd & 1;\n                        piVar7[10] = iStack20;\n                        piVar7[8] = iStack28;\n                        piVar7[9] = iStack24;\n                        piVar7[0xc] = iVar13;\n                        iVar13 = fcn.10002380(piStack36, piVar12[0x15]);\n                        if (iVar13 != 0) {\n                            iVar8 = (*pcVar3)(iVar4, piVar12[0x15], 0x1000, 4);\n                            uVar6 = 0x10002cba;\n                            fcn.10002280(iVar8, piStack12, piVar12[0x15]);\n                            iVar13 = piStack12[0xf];\n                            *piVar7 = iVar8 + iVar13;\n                            *(iVar8 + iVar13 + 0x34) = iVar4;\n                            iVar13 = 0x10002cdc;\n                            noname_6 = piVar12;\n                            noname_7 = piVar7;\n                            iVar8 = fcn.100023a0();\n                            piStack36 = piStack12;\n                            if (iVar8 != 0) {\n                                iVar8 = *(*piVar7 + 0x34) - piVar12[0xd];\n                                if (iVar8 == 0) {\n                                    piVar7[6] = 1;\n                                }\n                                else {\n                                    piVar10 = piVar7;\n                                    iVar13 = fcn.10002710();\n                                    piVar7[6] = iVar13;\n                                    iVar13 = iVar8;\n                                }\n                                piStack36 = piVar7;\n                                iVar8 = fcn.100027a0();\n                                if (iVar8 != 0) {\n                                    piStack36 = 0x10002d19;\n                                    iVar9 = fcn.10002580(0x10002d19, 0x10002d19, piVar10, iVar13, uVar6, uStack8, \n                                                         noname_6, noname_7, param_2, iVar9, unaff_EBX);\n                                    if ((iVar9 != 0) && (piStack36 = piVar7,  iVar9 = fcn.100026d0(piVar7),  iVar9 != 0)\n                                       ) {\n                                        iVar9 = *(*piVar7 + 0x28);\n                                        if (iVar9 == 0) {\n                                            piVar7[0xb] = 0;\n                                            return piVar7;\n                                        }\n                                        if (piVar7[5] == 0) {\n                                            piVar7[0xb] = iVar9 + iVar4;\n                                            return piVar7;\n                                        }\n                                        iVar4 = (*(iVar4 + iVar9))(0x10000000, 1, 0);\n                                        if (iVar4 != 0) {\n                                            piVar7[4] = 1;\n                                            return piVar7;\n                                        }\n                                        (*_sym.imp.KERNEL32.dll_SetLastError)(0x45a);\n                                    }\n                                }\n                            }\n                        }\n                        fcn.10002a70(piVar7, piStack36);\n                        return NULL;\n                    }\n                    (*_sym.imp.KERNEL32.dll_VirtualFree)(iVar4, 0, 0x8000);\n                }\n                (*_sym.imp.KERNEL32.dll_SetLastError)(0xe);\n                return NULL;\n            }\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_SetLastError)(0xc1);\n    return NULL;\n}\n",
        "token_count": 1601
    },
    "10003405": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.10003405(uint arg_8h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    int32_t in_ECX;\n    uint in_EDX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    ushort in_ES;\n    ushort in_CS;\n    ushort in_SS;\n    ushort in_DS;\n    ushort in_FS;\n    ushort in_GS;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint unaff_retaddr;\n    int32_t var_328h;\n    uint var_324h;\n    uint var_320h;\n    \n    if (in_ECX == *0x10019130) {\n        return;\n    }\n    *0x1001a610 = (in_NT & 1) * 0x4000 | SBORROW4(&stack0xfffffffc, 0x328) * 0x800 | (in_IF & 1) * 0x200 |\n                  (in_TF & 1) * 0x100 | (&var_328h < 0) * 0x80 | (*0x10 == 0x32c) * 0x40 | (in_AF & 1) * 0x10 |\n                  ((POPCOUNT(&var_328h & 0xff) & 1U) == 0) * 4 | &stack0xfffffffc < 0x328 | (in_ID & 1) * 0x200000 |\n                  (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n    *0x1001a614 = &arg_8h;\n    *0x1001a550 = 0x10001;\n    *0x1001a4f8 = 0xc0000409;\n    *0x1001a4fc = 1;\n    var_328h = *0x10019130;\n    var_324h = *0x10019134;\n    *0x1001a504 = unaff_retaddr;\n    *0x1001a5dc = in_GS;\n    *0x1001a5e0 = in_FS;\n    *0x1001a5e4 = in_ES;\n    *0x1001a5e8 = in_DS;\n    *0x1001a5ec = unaff_EDI;\n    *0x1001a5f0 = unaff_ESI;\n    *0x1001a5f4 = unaff_EBX;\n    *0x1001a5f8 = in_EDX;\n    *0x1001a5fc = in_ECX;\n    *0x1001a600 = in_EAX;\n    *0x1001a604 = unaff_EBP;\n    *0x1001a608 = unaff_retaddr;\n    *0x1001a60c = in_CS;\n    *0x1001a618 = in_SS;\n    *0x1001a548 = (*_sym.imp.KERNEL32.dll_IsDebuggerPresent)();\n    fcn.1000807b(1);\n    (*_sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter)(0);\n    (*_sym.imp.KERNEL32.dll_UnhandledExceptionFilter)(0x100142f4);\n    if (*0x1001a548 == 0) {\n        fcn.1000807b(1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0xc0000409);\n    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1);\n    return;\n}\n",
        "token_count": 867
    },
    "100036ef": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.100036ef(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_8h, uint arg_ch, uint noname_17, uint noname_18, uint arg_18h, uint arg_1ch, \n            uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    uint *var_8h_3;\n    uint *var_ch_2;\n    uint var_10h_2;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    uint var_38h;\n    uint *var_34h;\n    uint var_30h;\n    code *var_2ch;\n    uint *var_28h_2;\n    code *pcStack40;\n    uint32_t uStack36;\n    uint uStack32;\n    uint *puStack28;\n    uint uStack24;\n    uint uStack20;\n    uchar *puStack16;\n    uchar *var_8h_2;\n    int32_t var_4h_2;\n    \n    var_8h_2 = &stack0xfffffffc;\n    puStack16 = &stack0xffffffc0;\n    if (var_8h_3 == 0x123) {\n        *var_ch_2 = 0x1000379a;\n        var_38h = 1;\n    }\n    else {\n        pcStack40 = fcn.100037c6;\n        uStack36 = *0x10019130 ^ &fcn.100036ef::var_28h_2;\n        uStack32 = var_24h;\n        puStack28 = var_ch_2;\n        uStack24 = var_20h;\n        uStack20 = var_1ch;\n        var_4h_2 = 0;\n        var_28h_2 = *in_FS_OFFSET;\n        *in_FS_OFFSET = &fcn.100036ef::var_28h_2;\n        var_34h = var_8h_3;\n        var_30h = var_10h_2;\n        iVar1 = fcn.10006cda();\n        var_2ch = *(iVar1 + 0x80);\n        (*var_2ch)(*var_8h_3, &fcn.100036ef::var_34h);\n        var_38h = 0;\n        if (var_4h_2 == 0) {\n            *in_FS_OFFSET = var_28h_2;\n        }\n        else {\n            *var_28h_2 = **in_FS_OFFSET;\n            *in_FS_OFFSET = var_28h_2;\n        }\n    }\n    return var_38h;\n}\n",
        "token_count": 720
    },
    "100059c4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x10005ab7: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x10005abc)\n// WARNING: Removing unreachable block (ram,0x10005aea)\n// WARNING: Removing unreachable block (ram,0x10005ac2)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.100059c4(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t unaff_EBP;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.100055bc(0x10017160, 0x18);\n    fcn.10004ac5(8);\n    *(unaff_EBP + -4) = 0;\n    if (*0x1001a9a8 != 1) {\n        *0x1001a9a4 = 1;\n        *0x1001a9a0 = *(unaff_EBP + 0x10);\n        if (*(unaff_EBP + 0xc) == 0) {\n            piVar1 = fcn.10006a8e(*0x1001c268);\n            *(unaff_EBP + -0x28) = piVar1;\n            if (piVar1 != NULL) {\n                piVar2 = fcn.10006a8e(*0x1001c264);\n                *(unaff_EBP + -0x24) = piVar2;\n                *(unaff_EBP + -0x1c) = piVar1;\n                *(unaff_EBP + -0x20) = piVar2;\n                while( true ) {\n                    piVar2 = piVar2 + -1;\n                    *(unaff_EBP + -0x24) = piVar2;\n                    if (piVar2 < piVar1) break;\n                    iVar3 = fcn.10006a85();\n                    if (*piVar2 != iVar3) {\n                        if (piVar2 < piVar1) break;\n                        pcVar4 = fcn.10006a8e(*piVar2);\n                        iVar3 = fcn.10006a85();\n                        *piVar2 = iVar3;\n                        (*pcVar4)();\n                        iVar3 = fcn.10006a8e(*0x1001c268);\n                        piVar1 = fcn.10006a8e(*0x1001c264);\n                        if ((*(unaff_EBP + -0x1c) != iVar3) || (*(unaff_EBP + -0x20) != piVar1)) {\n                            *(unaff_EBP + -0x1c) = iVar3;\n                            *(unaff_EBP + -0x28) = iVar3;\n                            *(unaff_EBP + -0x20) = piVar1;\n                            *(unaff_EBP + -0x24) = piVar1;\n                            piVar2 = piVar1;\n                        }\n                        piVar1 = *(unaff_EBP + -0x28);\n                    }\n                }\n            }\n            fcn.100058fe(0x100141a4);\n        }\n        fcn.100058fe(0x100141ac);\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    if (*(unaff_EBP + 0x10) != 0) {\n        fcn.100049eb(8);\n    }\n    return;\n}\n",
        "token_count": 811
    },
    "10005e3f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.10005e3f(uint arg_8h, uint noname_1, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.100055bc(0x10017180, 0x10);\n    iVar1 = *(unaff_EBP + 0x10);\n    iVar2 = *(unaff_EBP + 8);\n    if (*(iVar1 + 4) < 0x81) {\n        iVar5 = *(iVar2 + 8);\n    }\n    else {\n        iVar5 = *(iVar2 + 8);\n    }\n    *(unaff_EBP + -0x1c) = iVar5;\n    iVar3 = fcn.10006cda();\n    *(iVar3 + 0x90) = *(iVar3 + 0x90) + 1;\n    *(unaff_EBP + -4) = 0;\n    while (iVar5 != *(unaff_EBP + 0x14)) {\n        if ((iVar5 < 0) || (*(iVar1 + 4) <= iVar5)) {\n            fcn.1000706a();\n        }\n        iVar3 = iVar5 * 8;\n        piVar4 = *(iVar1 + 8) + iVar3;\n        iVar5 = *piVar4;\n        *(unaff_EBP + -0x20) = iVar5;\n        *(unaff_EBP + -4) = 1;\n        if (piVar4[1] != 0) {\n            *(iVar2 + 8) = iVar5;\n            fcn.100070c0(*(*(iVar1 + 8) + 4 + iVar3), iVar2, 0x103);\n        }\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x1c) = iVar5;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.10005f05();\n    if (iVar5 != *(unaff_EBP + 0x14)) {\n        fcn.1000706a();\n    }\n    *(iVar2 + 8) = iVar5;\n    fcn.10005601();\n    return;\n}\n",
        "token_count": 566
    },
    "10005f05": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.10005f05(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.10006cda();\n    if (0 < *(iVar1 + 0x90)) {\n        iVar1 = fcn.10006cda();\n        *(iVar1 + 0x90) = *(iVar1 + 0x90) + -1;\n    }\n    return;\n}\n",
        "token_count": 89
    },
    "100061e0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.100061e0(uint noname_0, uint noname_1, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_1ch;\n    \n    *(unaff_EDI + -4) = *(unaff_EBP + -0x24);\n    fcn.1000392d(*(unaff_EBP + -0x28));\n    iVar1 = fcn.10006cda();\n    *(iVar1 + 0x88) = *(unaff_EBP + -0x2c);\n    iVar1 = fcn.10006cda();\n    *(iVar1 + 0x8c) = *(unaff_EBP + -0x30);\n    if ((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&\n        ((iVar1 = unaff_ESI[5],  iVar1 == 0x19930520 || ((iVar1 == 0x19930521 || (iVar1 == 0x19930522)))))) &&\n       ((*(unaff_EBP + -0x34) == 0 && (*(unaff_EBP + -0x1c) != 0)))) {\n        iVar1 = fcn.10003906(unaff_ESI[6]);\n        if (iVar1 != 0) {\n            fcn.10005f65(unaff_ESI);\n        }\n    }\n    return;\n}\n",
        "token_count": 381
    },
    "100084e4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.100084e4(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) != 0) {\n        fcn.100049eb(0);\n    }\n    return;\n}\n",
        "token_count": 64
    },
    "100086bd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.100086bd(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    uint uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    uint var_14h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.10006a85();\n    var_4h = 0;\n    if (*0x1001ae50 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"USER32.DLL\");\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if (iVar2 == 0) {\n            return 0;\n        }\n        arg_8h_00 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"MessageBoxA\");\n        if (arg_8h_00 == 0) {\n            return 0;\n        }\n        *0x1001ae50 = fcn.10006a13(arg_8h_00);\n        uVar3 = (*pcVar4)(iVar2, \"GetActiveWindow\");\n        *0x1001ae54 = fcn.10006a13(uVar3);\n        uVar3 = (*pcVar4)(iVar2, \"GetLastActivePopup\");\n        *0x1001ae58 = fcn.10006a13(uVar3);\n        uVar3 = (*pcVar4)(iVar2, \"GetUserObjectInformationA\");\n        *0x1001ae60 = fcn.10006a13(uVar3);\n        if (*0x1001ae60 != 0) {\n            uVar3 = (*pcVar4)(iVar2, \"GetProcessWindowStation\");\n            *0x1001ae5c = fcn.10006a13(uVar3);\n        }\n    }\n    if ((*0x1001ae5c != iVar1) && (*0x1001ae60 != iVar1)) {\n        pcVar4 = fcn.10006a8e(*0x1001ae5c);\n        pcVar5 = fcn.10006a8e(*0x1001ae60);\n        if (((pcVar4 != NULL) && (pcVar5 != NULL)) &&\n           (((iVar2 = (*pcVar4)(),  iVar2 == 0 || (iVar2 = (*pcVar5)(iVar2, 1, &var_14h, 0xc, &var_8h),  iVar2 == 0)) ||\n            ((var_ch & 1) == 0)))) {\n            arg_10h = arg_10h | 0x200000;\n            goto code_r0x100087ff;\n        }\n    }\n    if ((((*0x1001ae54 != iVar1) && (pcVar4 = fcn.10006a8e(*0x1001ae54),  pcVar4 != NULL)) &&\n        (var_4h = (*pcVar4)(),  var_4h != 0)) &&\n       ((*0x1001ae58 != iVar1 && (pcVar4 = fcn.10006a8e(*0x1001ae58),  pcVar4 != NULL)))) {\n        var_4h = (*pcVar4)(var_4h);\n    }\ncode_r0x100087ff:\n    pcVar4 = fcn.10006a8e(*0x1001ae50);\n    if (pcVar4 == NULL) {\n        return 0;\n    }\n    uVar3 = (*pcVar4)(var_4h, arg_8h, arg_ch, arg_10h);\n    return uVar3;\n}\n",
        "token_count": 842
    },
    "10010079": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.10010079(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.1000899a(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.std::basic_filebuf_char__struct_std::char_traits_char__.0;\n    *(unaff_EBP + -4) = 0;\n    if (*(extraout_ECX + 0x12) != '\\0') {\n        fcn.1000fea7();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.1000f0b2();\n    fcn.10008a39();\n    return;\n}\n",
        "token_count": 179
    },
    "10003dbb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.10003dbb(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.100055bc(0x100170c0, 0xc);\n    iVar1 = *(unaff_EBP + 8);\n    if (iVar1 != 0) {\n        if (*0x1001c278 == 3) {\n            fcn.10004ac5(4);\n            *(unaff_EBP + -4) = 0;\n            arg_8h_00 = fcn.10004af8(iVar1);\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 != 0) {\n                fcn.10004b28(arg_8h_00, iVar1);\n            }\n            *(unaff_EBP + -4) = 0xfffffffe;\n            fcn.10003e11();\n            if (*(unaff_EBP + -0x1c) != 0) goto code_r0x10003e43;\n            iVar1 = *(unaff_EBP + 8);\n        }\n        iVar1 = (*_sym.imp.KERNEL32.dll_HeapFree)(*0x1001a974, 0, iVar1);\n        if (iVar1 == 0) {\n            puVar2 = fcn.100040f7();\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar3 = main(uVar3);\n            *puVar2 = uVar3;\n        }\n    }\ncode_r0x10003e43:\n    fcn.10005601();\n    return;\n}\n",
        "token_count": 425
    },
    "null": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "10012171": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.10012171(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.100055bc(0x100179b8, 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == 0xfffffffe) {\n        puVar2 = fcn.1000410a();\n        *puVar2 = 0;\n        puVar2 = fcn.100040f7();\n        *puVar2 = 9;\n    }\n    else {\n        if ((-1 < arg_8h_00) && (arg_8h_00 < *0x1001c148)) {\n            piVar1 = (arg_8h_00 >> 5) * 4 + 0x1001c160;\n            iVar4 = (arg_8h_00 & 0x1f) * 0x40;\n            if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n                fcn.1001388a(arg_8h_00);\n                *(unaff_EBP + -4) = 0;\n                if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                    puVar2 = fcn.100040f7();\n                    *puVar2 = 9;\n                    puVar2 = fcn.1000410a();\n                    *puVar2 = 0;\n                    *(unaff_EBP + -0x1c) = 0xffffffff;\n                }\n                else {\n                    uVar3 = fcn.10011a3e(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                    *(unaff_EBP + -0x1c) = uVar3;\n                }\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.10012243(0x100179b8);\n                goto code_r0x1001223d;\n            }\n        }\n        puVar2 = fcn.1000410a();\n        *puVar2 = 0;\n        puVar2 = fcn.100040f7();\n        *puVar2 = 9;\n        fcn.1000407f(0, 0, 0, 0, 0);\n    }\ncode_r0x1001223d:\n    fcn.10005601();\n    return;\n}\n",
        "token_count": 633
    },
    "1001276a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.1001276a(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.100055bc(0x10017a18, 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == 0xfffffffe) {\n        puVar2 = fcn.1000410a();\n        *puVar2 = 0;\n        puVar2 = fcn.100040f7();\n        *puVar2 = 9;\n    }\n    else {\n        if ((-1 < arg_8h_00) && (arg_8h_00 < *0x1001c148)) {\n            piVar1 = (arg_8h_00 >> 5) * 4 + 0x1001c160;\n            iVar4 = (arg_8h_00 & 0x1f) * 0x40;\n            if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n                fcn.1001388a(arg_8h_00);\n                *(unaff_EBP + -4) = 0;\n                if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                    puVar2 = fcn.100040f7();\n                    *puVar2 = 9;\n                    puVar2 = fcn.1000410a();\n                    *puVar2 = 0;\n                    *(unaff_EBP + -0x1c) = 0xffffffff;\n                }\n                else {\n                    uVar3 = fcn.100126f5(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                    *(unaff_EBP + -0x1c) = uVar3;\n                }\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.1001283c(0x10017a18);\n                goto code_r0x10012836;\n            }\n        }\n        puVar2 = fcn.1000410a();\n        *puVar2 = 0;\n        puVar2 = fcn.100040f7();\n        *puVar2 = 9;\n        fcn.1000407f(0, 0, 0, 0, 0);\n    }\ncode_r0x10012836:\n    fcn.10005601();\n    return;\n}\n",
        "token_count": 632
    },
    "10001300": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.10001300(int32_t param_1, uint32_t param_2, int32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint *arg_8h;\n    int32_t arg_10h;\n    uint *puVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t *in_FS_OFFSET;\n    uint32_t var_8h;\n    int32_t var_ch_2;\n    uint var_10h;\n    uint var_ch;\n    uint var_14h;\n    int32_t var_ch_3;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x100139a0;\n    var_ch_3 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch_3;\n    uVar4 = var_8h | 0xf;\n    if (uVar4 != 0xffffffff) {\n        uVar1 = *(param_1 + 0x18);\n        uVar3 = uVar1 >> 1;\n        var_8h = uVar4;\n        if ((uVar4 / 3 < uVar3) && (uVar1 <= -uVar3 - 2)) {\n            var_8h = uVar3 + uVar1;\n        }\n    }\n    var_4h = 0;\n    arg_8h = fcn.100010c0(var_8h + 1, 0);\n    if (var_ch_2 != 0) {\n        if (*(param_1 + 0x18) < 0x10) {\n            arg_10h = param_1 + 4;\n        }\n        else {\n            arg_10h = *(param_1 + 4);\n        }\n        fcn.10002fc5(arg_8h, var_8h + 1, arg_10h, var_ch_2);\n    }\n    if (0xf < *(param_1 + 0x18)) {\n        fcn.10002fba(*(param_1 + 4));\n    }\n    puVar2 = param_1 + 4;\n    *puVar2 = 0;\n    *puVar2 = arg_8h;\n    *(param_1 + 0x18) = var_8h;\n    *(param_1 + 0x14) = var_ch_2;\n    if (0xf < var_8h) {\n        puVar2 = arg_8h;\n    }\n    *(puVar2 + var_ch_2) = 0;\n    *in_FS_OFFSET = var_ch_3;\n    return;\n}\n",
        "token_count": 582
    },
    "1000f7bc": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.1000f7bc(int32_t arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    \n    if (arg_8h == -1) {\n        fcn.1000eb02();\n    }\n    cVar1 = fcn.10001470(arg_8h, 0);\n    if (cVar1 != '\\0') {\n        fcn.1000f1a9(0, arg_8h, arg_ch);\n        fcn.100011d0(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 125
    },
    "1000fef2": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl fcn.1000fef2(uint arg_8h)\n\n{\n    uint arg_8h_00;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.1000899a(0x14);\n    fcn.1001047d(0);\n    iVar2 = *0x1001af74;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = iVar2;\n    arg_8h_00 = fcn.1000ec2a();\n    iVar1 = fcn.1000ed1e(arg_8h_00);\n    if ((iVar1 == 0) && (iVar2 == 0)) {\n        iVar2 = fcn.1000faf3(unaff_EBP + -0x10, *(unaff_EBP + 8));\n        if (iVar2 == -1) {\n            fcn.10002edb(\"bad cast\");\n            fcn.10003494(unaff_EBP + -0x20, 0x100176e8);\n        }\n        iVar2 = *(unaff_EBP + -0x10);\n        *0x1001af74 = iVar2;\n        fcn.1000ec61();\n        fcn.1001061e(iVar2);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.100104a5();\n    fcn.10008a39();\n    return;\n}\n",
        "token_count": 412
    },
    "10010111": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl fcn.10010111(uint arg_8h)\n\n{\n    uint arg_8h_00;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.1000899a(0x14);\n    fcn.1001047d(0);\n    iVar2 = *0x1001af78;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = iVar2;\n    arg_8h_00 = fcn.1000ec2a();\n    iVar1 = fcn.1000ed1e(arg_8h_00);\n    if ((iVar1 == 0) && (iVar2 == 0)) {\n        iVar2 = fcn.1000ff8f(unaff_EBP + -0x10, *(unaff_EBP + 8));\n        if (iVar2 == -1) {\n            fcn.10002edb(\"bad cast\");\n            fcn.10003494(unaff_EBP + -0x20, 0x100176e8);\n        }\n        iVar2 = *(unaff_EBP + -0x10);\n        *0x1001af78 = iVar2;\n        fcn.1000ec61();\n        fcn.1001061e(iVar2);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.100104a5();\n    fcn.10008a39();\n    return;\n}\n",
        "token_count": 412
    },
    "10010a8f": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.10010a8f(uint arg_8h)\n\n{\n    uint8_t **ppuVar1;\n    uint8_t **arg_8h_00;\n    uint *puVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.100055bc(0x10017890, 0xc);\n    *(unaff_EBP + -0x1c) = 0;\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == NULL) {\n        puVar2 = fcn.100040f7();\n        *puVar2 = 0x16;\n        fcn.1000407f(0, 0, 0, 0, 0);\n        goto code_r0x10010b82;\n    }\n    fcn.10011656(arg_8h_00);\n    *(unaff_EBP + -4) = 0;\n    if ((*(arg_8h_00 + 3) & 0x40) == 0) {\n        uVar3 = fcn.1001185f(arg_8h_00);\n        if ((uVar3 == 0xffffffff) || (uVar3 == 0xfffffffe)) {\n            iVar4 = 0x100194d0;\n        }\n        else {\n            iVar4 = (uVar3 & 0x1f) * 0x40 + *((uVar3 >> 5) * 4 + 0x1001c160);\n        }\n        if ((*(iVar4 + 0x24) & 0x7f) == 0) {\n            if ((uVar3 == 0xffffffff) || (uVar3 == 0xfffffffe)) {\n                iVar4 = 0x100194d0;\n            }\n            else {\n                iVar4 = (uVar3 & 0x1f) * 0x40 + *((uVar3 >> 5) * 4 + 0x1001c160);\n            }\n            if ((*(iVar4 + 0x24) & 0x80) == 0) goto code_r0x10010b55;\n        }\n        puVar2 = fcn.100040f7();\n        *puVar2 = 0x16;\n        fcn.1000407f(0, 0, 0, 0, 0);\n        *(unaff_EBP + -0x1c) = 0xffffffff;\n    }\ncode_r0x10010b55:\n    if (*(unaff_EBP + -0x1c) == 0) {\n        ppuVar1 = arg_8h_00 + 1;\n        *ppuVar1 = *ppuVar1 + -1;\n        if (*ppuVar1 < 0) {\n            uVar3 = fcn.10011734(arg_8h_00);\n        }\n        else {\n            uVar3 = **arg_8h_00;\n            *arg_8h_00 = *arg_8h_00 + 1;\n        }\n        *(unaff_EBP + -0x1c) = uVar3;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.10010b8b();\ncode_r0x10010b82:\n    fcn.10005601();\n    return;\n}\n",
        "token_count": 788
    },
    "10010b93": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.10010b93(uint arg_8h, uint arg_ch)\n\n{\n    uint8_t **ppuVar1;\n    uint8_t uVar2;\n    uint8_t **arg_8h_00;\n    uint *puVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.100055bc(0x100178b0, 0xc);\n    *(unaff_EBP + -0x1c) = 0;\n    arg_8h_00 = *(unaff_EBP + 0xc);\n    if (arg_8h_00 == NULL) {\n        puVar3 = fcn.100040f7();\n        *puVar3 = 0x16;\n        fcn.1000407f(0, 0, 0, 0, 0);\n        goto code_r0x10010c8e;\n    }\n    fcn.10011656(arg_8h_00);\n    *(unaff_EBP + -4) = 0;\n    if ((*(arg_8h_00 + 3) & 0x40) == 0) {\n        uVar4 = fcn.1001185f(arg_8h_00);\n        if ((uVar4 == 0xffffffff) || (uVar4 == 0xfffffffe)) {\n            iVar5 = 0x100194d0;\n        }\n        else {\n            iVar5 = (uVar4 & 0x1f) * 0x40 + *((uVar4 >> 5) * 4 + 0x1001c160);\n        }\n        if ((*(iVar5 + 0x24) & 0x7f) == 0) {\n            if ((uVar4 == 0xffffffff) || (uVar4 == 0xfffffffe)) {\n                iVar5 = 0x100194d0;\n            }\n            else {\n                iVar5 = (uVar4 & 0x1f) * 0x40 + *((uVar4 >> 5) * 4 + 0x1001c160);\n            }\n            if ((*(iVar5 + 0x24) & 0x80) == 0) goto code_r0x10010c59;\n        }\n        puVar3 = fcn.100040f7();\n        *puVar3 = 0x16;\n        fcn.1000407f(0, 0, 0, 0, 0);\n        *(unaff_EBP + -0x1c) = 0xffffffff;\n    }\ncode_r0x10010c59:\n    if (*(unaff_EBP + -0x1c) == 0) {\n        ppuVar1 = arg_8h_00 + 1;\n        *ppuVar1 = *ppuVar1 + -1;\n        if (*ppuVar1 < 0) {\n            uVar4 = fcn.10011891(*(unaff_EBP + 8), arg_8h_00);\n        }\n        else {\n            uVar2 = *(unaff_EBP + 8);\n            **arg_8h_00 = uVar2;\n            uVar4 = uVar2;\n            *arg_8h_00 = *arg_8h_00 + 1;\n        }\n        *(unaff_EBP + -0x1c) = uVar4;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.10010c97();\ncode_r0x10010c8e:\n    fcn.10005601();\n    return;\n}\n",
        "token_count": 834
    },
    "10001050": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.10001050(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    int32_t arg_8h;\n    uint arg_ch;\n    \n    arg_ch = 0x3000;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0, param_2, 0x3000, 0x40, 0);\n    arg_8h = sub.KERNEL32.dll_VirtualAllocExNuma(uVar1);\n    if (arg_8h != 0) {\n        *0x10019054 = 0;\n    }\n    fcn.100030a0(arg_8h, arg_ch, param_2);\n    return arg_8h;\n}\n",
        "token_count": 163
    },
    "10001140": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.10001140(uint param_1, int32_t param_2, uchar *param_3)\n\n{\n    uint64_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    \n    *0x1001a4c0 = fcn.1000352f(0x32c);\n    uVar3 = 0;\n    iVar2 = 0;\n    do {\n        *(*0x1001a4c0 + iVar2) = iVar2;\n        iVar2 = iVar2 + 1;\n    } while (iVar2 < 0x32c);\n    iVar2 = 0;\n    *param_3 = 0;\n    param_3[1] = 0;\n    do {\n        fcn.10001040();\n        uVar1 = (uVar3 & 0xff) + 1;\n        uVar3 = uVar1 % param_2;\n        iVar2 = iVar2 + 1;\n    } while (iVar2 < 0x32c);\n    return uVar1 / param_2;\n}\n",
        "token_count": 237
    },
    "100011f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.100011f0(uint param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    fcn.10002fc5(param_1, param_2, param_3, param_4);\n    return param_1;\n}\n",
        "token_count": 61
    },
    "10001270": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.10001270(int32_t param_1, uint *param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint *puVar5;\n    \n    uVar1 = param_2;\n    if (*(param_1 + 0x14) < param_2) {\n        fcn.1000eb3a();\n    }\n    uVar2 = *(param_1 + 0x14) - param_2;\n    if (uVar2 < param_3) {\n        param_3 = uVar2;\n    }\n    if (param_3 != 0) {\n        puVar5 = param_1 + 4;\n        puVar4 = puVar5;\n        param_2 = puVar5;\n        if (0xf < *(param_1 + 0x18)) {\n            puVar4 = *puVar5;\n            param_2 = *puVar5;\n        }\n        fcn.10003042(puVar4 + uVar1, *(param_1 + 0x18) - uVar1, param_2 + param_3 + uVar1, uVar2 - param_3);\n        iVar3 = *(param_1 + 0x14) - param_3;\n        *(param_1 + 0x14) = iVar3;\n        if (0xf < *(param_1 + 0x18)) {\n            puVar5 = *puVar5;\n        }\n        *(iVar3 + puVar5) = 0;\n    }\n    return param_1;\n}\n",
        "token_count": 370
    },
    "10001590": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.10001590(int32_t param_1, int32_t param_2, uint32_t param_3, uint32_t param_4)\n\n{\n    int32_t *arg_8h;\n    int32_t *piVar1;\n    uint32_t arg_14h;\n    \n    if (*(param_2 + 0x14) < param_3) {\n        fcn.1000eb3a();\n    }\n    arg_14h = *(param_2 + 0x14) - param_3;\n    if (param_4 < arg_14h) {\n        arg_14h = param_4;\n    }\n    if (param_1 != param_2) {\n        if (arg_14h == 0xffffffff) {\n            fcn.1000eb02();\n        }\n        if (*(param_1 + 0x18) < arg_14h) {\n            fcn.10001300(arg_14h, *(param_1 + 0x14));\n        }\n        else if (arg_14h == 0) {\n            *(param_1 + 0x14) = 0;\n            if (*(param_1 + 0x18) < 0x10) {\n                *(param_1 + 4) = 0;\n                return param_1;\n            }\n            **(param_1 + 4) = 0;\n            return param_1;\n        }\n        if (arg_14h != 0) {\n            if (*(param_2 + 0x18) < 0x10) {\n                param_2 = param_2 + 4;\n            }\n            else {\n                param_2 = *(param_2 + 4);\n            }\n            piVar1 = param_1 + 4;\n            arg_8h = piVar1;\n            if (0xf < *(param_1 + 0x18)) {\n                arg_8h = *piVar1;\n            }\n            fcn.10002fc5(arg_8h, *(param_1 + 0x18), param_2 + param_3, arg_14h);\n            *(param_1 + 0x14) = arg_14h;\n            if (0xf < *(param_1 + 0x18)) {\n                piVar1 = *piVar1;\n            }\n            *(piVar1 + arg_14h) = 0;\n        }\n        return param_1;\n    }\n    fcn.10001270(arg_14h + param_3, 0xffffffff);\n    fcn.10001270(0, param_3);\n    return param_1;\n}\n",
        "token_count": 579
    },
    "10001670": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.10001670(int32_t param_1, uint *param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t *arg_8h;\n    uint *puVar4;\n    int32_t *piVar5;\n    \n    if (param_2 != NULL) {\n        uVar1 = *(param_1 + 0x18);\n        puVar2 = param_1 + 4;\n        puVar4 = puVar2;\n        if (0xf < uVar1) {\n            puVar4 = *puVar2;\n        }\n        if (puVar4 <= param_2) {\n            puVar4 = puVar2;\n            if (0xf < uVar1) {\n                puVar4 = *puVar2;\n            }\n            if (param_2 < *(param_1 + 0x14) + puVar4) {\n                if (0xf < uVar1) {\n                    puVar2 = *puVar2;\n                }\n                iVar3 = fcn.10001590(param_1, param_2 - puVar2, param_3);\n                return iVar3;\n            }\n        }\n    }\n    if (param_3 == 0xffffffff) {\n        fcn.1000eb02();\n    }\n    if (*(param_1 + 0x18) < param_3) {\n        fcn.10001300(param_3, *(param_1 + 0x14));\n    }\n    else if (param_3 == 0) {\n        *(param_1 + 0x14) = 0;\n        if (*(param_1 + 0x18) < 0x10) {\n            *(param_1 + 4) = 0;\n            return param_1;\n        }\n        **(param_1 + 4) = 0;\n        return param_1;\n    }\n    if (param_3 != 0) {\n        piVar5 = param_1 + 4;\n        arg_8h = piVar5;\n        if (0xf < *(param_1 + 0x18)) {\n            arg_8h = *piVar5;\n        }\n        fcn.10002fc5(arg_8h, *(param_1 + 0x18), param_2, param_3);\n        *(param_1 + 0x14) = param_3;\n        if (0xf < *(param_1 + 0x18)) {\n            piVar5 = *piVar5;\n        }\n        *(piVar5 + param_3) = 0;\n    }\n    return param_1;\n}\n",
        "token_count": 594
    },
    "100017b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.100017b0(code **param_1, uint param_2)\n\n{\n    uint32_t *puVar1;\n    uint32_t **in_FS_OFFSET;\n    uint32_t *puStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x100139c8;\n    puStack12 = *in_FS_OFFSET;\n    puVar1 = *0x10019130 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &puStack12;\n    fcn.10002dda();\n    *param_1 = vtable.std::runtime_error.0;\n    param_1[8] = NULL;\n    param_1[9] = 0xf;\n    uStack4 = 0;\n    *(param_1 + 4) = 0;\n    fcn.10001590(param_2, 0, 0xffffffff);\n    *in_FS_OFFSET = puVar1;\n    return param_1;\n}\n",
        "token_count": 227
    },
    "100019d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.100019d0(code **param_1, int32_t param_2)\n\n{\n    uint32_t *puVar1;\n    uint32_t **in_FS_OFFSET;\n    uint32_t *puStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x10013a38;\n    puStack12 = *in_FS_OFFSET;\n    puVar1 = *0x10019130 ^ &stack0xffffffe8;\n    *in_FS_OFFSET = &puStack12;\n    fcn.10002e5b(param_2);\n    *param_1 = vtable.std::runtime_error.0;\n    param_1[9] = 0xf;\n    param_1[8] = NULL;\n    uStack8 = 0;\n    *(param_1 + 4) = 0;\n    fcn.10001590(param_2 + 0xc, 0, 0xffffffff);\n    *in_FS_OFFSET = puVar1;\n    return param_1;\n}\n",
        "token_count": 239
    },
    "10001bd0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.10001bd0(int32_t **param_1)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x10013ab8;\n    piStack12 = *in_FS_OFFSET;\n    uVar2 = *0x10019130 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    uStack4 = 0;\n    cVar1 = fcn.1000ebe6(uVar2);\n    if (cVar1 == '\\0') {\n        fcn.10001b70();\n    }\n    uStack4 = 0xffffffff;\n    if (*(*(**param_1 + 4) + 0x28 + *param_1) != 0) {\n        fcn.1000e9d8();\n    }\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 228
    },
    "10002220": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.10002220(int32_t param_1)\n\n{\n    int32_t aiStack28 [7];\n    \n    if (param_1 == 0) {\n        return param_1;\n    }\n    (*_sym.imp.KERNEL32.dll_VirtualQuery)(param_1, aiStack28, 0x1c);\n    return aiStack28[0];\n}\n",
        "token_count": 84
    },
    "10002250": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.10002250(uint param_1, uint param_2, int32_t param_3)\n\n{\n    if (param_3 != 0) {\n        fcn.10003a00(param_1, param_2, param_3);\n        return param_1;\n    }\n    return param_1;\n}\n",
        "token_count": 72
    },
    "100022e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t fcn.100022e0(uint32_t param_1, uint32_t param_2)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    \n    uVar1 = param_1;\n    if ((param_1 != 0) && (uVar1 = fcn.10002220(param_1),  param_2 <= uVar1)) {\n        return param_1;\n    }\n    uVar2 = fcn.100022c0(param_2);\n    if ((param_1 != 0) && (uVar2 != 0)) {\n        fcn.10002280(uVar2, param_1, uVar1);\n        fcn.100022a0(param_1);\n    }\n    return uVar2;\n}\n",
        "token_count": 172
    },
    "100023a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "allocate memory",
            "allocate RW memory"
        ],
        "decompiled_code": "\nuint fcn.100023a0(int32_t param_1, uint param_2, int32_t param_3, int32_t *param_4)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    int32_t iStack8;\n    \n    pcVar3 = _sym.imp.KERNEL32.dll_VirtualAlloc;\n    iVar2 = param_4[1];\n    iVar5 = *param_4;\n    piVar1 = *(iVar5 + 0x14) + iVar5;\n    iStack8 = 0;\n    if (*(iVar5 + 6) != 0) {\n        do {\n            piVar6 = piVar1 + 10;\n            if (*piVar6 == 0) {\n                iVar5 = *(param_3 + 0x38);\n                if (0 < iVar5) {\n                    iVar4 = (*pcVar3)(piVar1[9] + iVar2, iVar5, 0x1000, 4);\n                    if (iVar4 == 0) {\n                        return 0;\n                    }\n                    piVar1[8] = piVar1[9] + iVar2;\n                    fcn.10002250(piVar1[9] + iVar2, 0, iVar5);\n                }\n            }\n            else {\n                iVar5 = fcn.10002380(param_2, piVar1[0xb] + *piVar6);\n                if ((iVar5 == 0) || (iVar5 = (*pcVar3)(piVar1[9] + iVar2, *piVar6, 0x1000, 4),  iVar5 == 0)) {\n                    return 0;\n                }\n                iVar5 = piVar1[9];\n                fcn.10002280(iVar5 + iVar2, piVar1[0xb] + param_1, *piVar6);\n                piVar1[8] = iVar5 + iVar2;\n            }\n            iStack8 = iStack8 + 1;\n            piVar1 = piVar6;\n        } while (iStack8 < *(*param_4 + 6));\n    }\n    return 1;\n}\n",
        "token_count": 499
    },
    "10002580": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nbool __cdecl\nfcn.10002580(int32_t *noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6\n            , uint noname_7, uint noname_8, uint noname_9, uint arg_30h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t unaff_EDI;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int32_t iStack28;\n    uint32_t uStack24;\n    uint32_t uStack20;\n    uint32_t uStack16;\n    int32_t iStack12;\n    uint32_t uStack4;\n    \n    iVar1 = *noname_0;\n    iVar2 = *(iVar1 + 0x14) + 0x18 + iVar1;\n    uStack20 = *(iVar2 + 8);\n    uVar3 = ~(noname_0[0xc] - 1U) & uStack20;\n    piVar5 = noname_0;\n    uStack16 = uVar3;\n    uStack20 = fcn.100024a0(noname_0, iVar2);\n    uStack16 = *(iVar2 + 0x24);\n    iStack12 = 0;\n    iVar6 = 1;\n    if (1 < *(iVar1 + 6)) {\n        do {\n            uStack4 = *(iVar2 + 0x30);\n            uVar4 = ~(noname_0[0xc] - 1U) & uStack4;\n            piVar5 = noname_0;\n            iVar1 = fcn.100024a0();\n            if ((uVar3 == uVar4) || (uVar4 < iStack28 + iVar6)) {\n                uVar4 = *(iVar2 + 0x4c);\n                if (((uVar4 & 0x2000000) == 0) || ((uStack24 & 0x2000000) == 0)) {\n                    uStack24 = (uVar4 | uStack24) & 0xfdffffff;\n                }\n                else {\n                    uStack24 = uStack24 | uVar4;\n                }\n                iStack28 = (iVar1 - iVar6) + iStack12;\n                uVar4 = uVar3;\n            }\n            else {\n                piVar5 = noname_0;\n                iVar1 = fcn.100024d0();\n                iVar6 = unaff_EDI;\n                if (iVar1 == 0) {\n                    return false;\n                }\n            }\n            iVar6 = iVar6 + 1;\n            uVar3 = uVar4;\n            iVar2 = iVar2 + 0x28;\n        } while (iVar6 < *(*noname_0 + 6));\n    }\n    iStack12 = 1;\n    iVar2 = fcn.100024d0(noname_0, &iStack28, piVar5);\n    return iVar2 != 0;\n}\n",
        "token_count": 685
    },
    "100026d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.100026d0(int32_t *param_1)\n\n{\n    code **ppcVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    code **ppcVar4;\n    \n    iVar2 = param_1[1];\n    if ((*(*param_1 + 0xc0) != 0) && (ppcVar4 = *(*(*param_1 + 0xc0) + 0xc + iVar2),  ppcVar4 != NULL)) {\n        pcVar3 = *ppcVar4;\n        while (pcVar3 != NULL) {\n            (*pcVar3)(iVar2, 1, 0);\n            ppcVar1 = ppcVar4 + 1;\n            ppcVar4 = ppcVar4 + 1;\n            pcVar3 = *ppcVar1;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 196
    },
    "10007cbe": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x10007cd2)\n// WARNING: Removing unreachable block (ram,0x10007cd8)\n// WARNING: Removing unreachable block (ram,0x10007cda)\n\nvoid fcn.10007cbe(void)\n\n{\n    return;\n}\n",
        "token_count": 64
    },
    "1000eb72": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.1000eb72(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.1000899a(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    arg_8h_00 = *(unaff_EBP + 8);\n    fcn.10002e5b(arg_8h_00);\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.std::logic_error.0;\n    fcn.10001750(arg_8h_00 + 0xc);\n    fcn.10008a39();\n    return;\n}\n",
        "token_count": 200
    },
    "1000f76a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.1000f76a(uint32_t arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    \n    if (-*(in_ECX + 0x14) - 1U <= arg_8h) {\n        fcn.1000eb02();\n    }\n    if (arg_8h != 0) {\n        iVar2 = *(in_ECX + 0x14) + arg_8h;\n        cVar1 = fcn.10001470(iVar2, 0);\n        if (cVar1 != '\\0') {\n            fcn.1000f1a9(*(in_ECX + 0x14), arg_8h, arg_ch);\n            fcn.100011d0(iVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 191
    },
    "1001021c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.1001021c(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint arg_ch_00;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.1000899a(8);\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    *(unaff_EBP + -0x10) = 0;\n    if (*(unaff_EBP + 0x10) != 0) {\n        *extraout_ECX = 0x10016554;\n        extraout_ECX[1] = vtable.std::basic_ios_char__struct_std::char_traits_char__.0;\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x10) = 1;\n    }\n    arg_ch_00 = *(unaff_EBP + 0xc);\n    *(extraout_ECX + *(*extraout_ECX + 4)) = vtable.std::basic_ostream_char__struct_std::char_traits_char__.0;\n    fcn.100101cc(*(unaff_EBP + 8), arg_ch_00);\n    fcn.10008a39();\n    return;\n}\n",
        "token_count": 312
    },
    "10003686": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.10003686(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = fcn.1000692d(arg_8h, arg_ch, arg_10h, arg_14h, in_EAX, 0, 0, 0);\n    return uVar1;\n}\n",
        "token_count": 110
    },
    "100104a5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.100104a5(int32_t *param_1)\n\n{\n    if (*param_1 < 4) {\n        fcn.100102a6(*param_1 * 0x18 + 0x1001b018);\n    }\n    return;\n}\n",
        "token_count": 63
    },
    "100022c0": {
        "rules": [
            "allocate memory",
            "allocate RW memory"
        ],
        "decompiled_code": "\nvoid fcn.100022c0(uint param_1)\n\n{\n    (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, param_1, 0x3000, 4);\n    return;\n}\n",
        "token_count": 47
    },
    "100011d0": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.100011d0(int32_t param_1, int32_t param_2)\n\n{\n    *(param_1 + 0x14) = param_2;\n    if (0xf < *(param_1 + 0x18)) {\n        *(*(param_1 + 4) + param_2) = 0;\n        return;\n    }\n    *(param_1 + 4 + param_2) = 0;\n    return;\n}\n",
        "token_count": 105
    },
    "10001750": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.10001750(int32_t param_1, uint param_2)\n\n{\n    *(param_1 + 0x14) = 0;\n    *(param_1 + 0x18) = 0xf;\n    *(param_1 + 4) = 0;\n    fcn.10001590(param_2, 0, 0xffffffff);\n    return param_1;\n}\n",
        "token_count": 95
    },
    "10001860": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.10001860(int32_t param_1, char *param_2)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    *(param_1 + 0x18) = 0xf;\n    *(param_1 + 0x14) = 0;\n    *(param_1 + 4) = 0;\n    pcVar2 = param_2;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.10001670(param_2, pcVar2 - (param_2 + 1));\n    return param_1;\n}\n",
        "token_count": 160
    },
    "1000c382": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\n// WARNING: Type propagation algorithm not settling\n\nint32_t __cdecl fcn.1000c382(int32_t *arg_8h, int32_t *arg_ch, int32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    \n    if (arg_10h == 0) {\n        return 0;\n    }\n    if (arg_10h == 1) {\n        uVar1 = *arg_8h;\n        uVar2 = *arg_ch;\n    }\n    else if (arg_10h == 2) {\n        uVar1 = *arg_8h;\n        uVar2 = *arg_ch;\n        if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar1 = *(arg_8h + 1);\n        uVar2 = *(arg_ch + 1);\n    }\n    else if (arg_10h == 3) {\n        uVar1 = *arg_8h;\n        uVar2 = *arg_ch;\n        if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar1 = *(arg_8h + 1);\n        uVar2 = *(arg_ch + 1);\n        if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar1 = *(arg_8h + 2);\n        uVar2 = *(arg_ch + 2);\n    }\n    else {\n        if (arg_10h != 4) {\ncode_r0x1000c834:\n    // switch table (32 cases) at 0x1000d982\n            switch(arg_10h) {\n            case 0:\n                break;\n            case 1:\n                goto code_r0x1000d015;\n            case 2:\n                goto code_r0x1000d421;\n            case 3:\n                goto code_r0x1000d842;\n            case 4:\n                goto code_r0x1000cba6;\n            case 5:\n                goto code_r0x1000cf86;\n            case 6:\n                goto code_r0x1000d392;\n            case 7:\n                goto code_r0x1000d7b3;\n            case 8:\n                goto code_r0x1000cb17;\n            case 9:\n                goto code_r0x1000cef6;\n            case 10:\n                goto code_r0x1000d302;\n            case 0xb:\n                goto code_r0x1000d724;\n            case 0xc:\n                goto code_r0x1000ca87;\n            case 0xd:\n                goto code_r0x1000ce67;\n            case 0xe:\n                goto code_r0x1000d273;\n            case 0xf:\n                goto code_r0x1000d694;\n            case 0x10:\n                goto code_r0x1000c9f8;\n            case 0x11:\n                goto code_r0x1000cdd8;\n            case 0x12:\n                goto code_r0x1000d1e4;\n            case 0x13:\n                goto code_r0x1000d605;\n            case 0x14:\n                goto code_r0x1000c969;\n            case 0x15:\n                goto code_r0x1000cd49;\n            case 0x16:\n                goto code_r0x1000d155;\n            case 0x17:\n                goto code_r0x1000d576;\n            case 0x1a:\n                goto code_r0x1000d0c6;\n            case 0x1b:\n                goto code_r0x1000d4e7;\n            case 0x1c:\n                uVar1 = *(arg_8h + arg_10h + -0x1c);\n                if (uVar1 == *(arg_ch + arg_10h + -0x1c)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0x1c);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x1b);\n                    uVar1 = *(arg_ch + arg_10h + -0x1b);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x1a);\n                    uVar1 = *(arg_ch + arg_10h + -0x1a);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0x19) - *(arg_ch + arg_10h + -0x19);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\n            case 0x18:\n                uVar1 = *(arg_8h + arg_10h + -0x18);\n                if (uVar1 == *(arg_ch + arg_10h + -0x18)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0x18);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x17);\n                    uVar1 = *(arg_ch + arg_10h + -0x17);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x16);\n                    uVar1 = *(arg_ch + arg_10h + -0x16);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0x15) - *(arg_ch + arg_10h + -0x15);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000c969:\n                uVar1 = *(arg_8h + arg_10h + -0x14);\n                if (uVar1 == *(arg_ch + arg_10h + -0x14)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0x14);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x13);\n                    uVar1 = *(arg_ch + arg_10h + -0x13);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x12);\n                    uVar1 = *(arg_ch + arg_10h + -0x12);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0x11) - *(arg_ch + arg_10h + -0x11);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000c9f8:\n                uVar1 = *(arg_8h + arg_10h + -0x10);\n                if (uVar1 == *(arg_ch + arg_10h + -0x10)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0x10);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0xf);\n                    uVar1 = *(arg_ch + arg_10h + -0xf);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0xe);\n                    uVar1 = *(arg_ch + arg_10h + -0xe);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0xd) - *(arg_ch + arg_10h + -0xd);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000ca87:\n                if (*(arg_8h + arg_10h + -0xc) == *(arg_ch + arg_10h + -0xc)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = *(arg_ch + arg_10h + -0xc);\n                    uVar2 = *(arg_8h + arg_10h + -0xc);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0xb);\n                    uVar1 = *(arg_ch + arg_10h + -0xb);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -10);\n                    uVar1 = *(arg_ch + arg_10h + -10);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -9) - *(arg_ch + arg_10h + -9);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000cb17:\n                uVar1 = *(arg_8h + arg_10h + -8);\n                if (uVar1 == *(arg_ch + arg_10h + -8)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -8);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -7);\n                    uVar1 = *(arg_ch + arg_10h + -7);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -6);\n                    uVar1 = *(arg_ch + arg_10h + -6);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -5) - *(arg_ch + arg_10h + -5);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000cba6:\n                uVar1 = *(arg_8h + arg_10h + -4);\n                if (uVar1 == *(arg_ch + arg_10h + -4)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -4);\n                    if ((uVar1 == uVar2) || (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 == 0)) {\n                        uVar2 = *(arg_8h + arg_10h + -3);\n                        uVar1 = *(arg_ch + arg_10h + -3);\n                        if ((uVar2 == uVar1) || (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 == 0))\n                        {\n                            uVar2 = *(arg_8h + arg_10h + -2);\n                            uVar1 = *(arg_ch + arg_10h + -2);\n                            if (((uVar2 == uVar1) ||\n                                (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 == 0)) &&\n                               (iVar3 = *(arg_8h + arg_10h + -1) - *(arg_ch + arg_10h + -1),  iVar3 != 0)) {\n                                iVar3 = (0 < iVar3) * 2 + -1;\n                            }\n                        }\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\n                break;\n            case 0x1d:\n                uVar1 = *(arg_8h + arg_10h + -0x1d);\n                if (uVar1 == *(arg_ch + arg_10h + -0x1d)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0x1d);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x1c);\n                    uVar1 = *(arg_ch + arg_10h + -0x1c);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x1b);\n                    uVar1 = *(arg_ch + arg_10h + -0x1b);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0x1a) - *(arg_ch + arg_10h + -0x1a);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\n            case 0x19:\n                uVar1 = *(arg_8h + arg_10h + -0x19);\n                if (uVar1 == *(arg_ch + arg_10h + -0x19)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0x19);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x18);\n                    uVar1 = *(arg_ch + arg_10h + -0x18);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x17);\n                    uVar1 = *(arg_ch + arg_10h + -0x17);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0x16) - *(arg_ch + arg_10h + -0x16);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000cd49:\n                uVar1 = *(arg_8h + arg_10h + -0x15);\n                if (uVar1 == *(arg_ch + arg_10h + -0x15)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0x15);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x14);\n                    uVar1 = *(arg_ch + arg_10h + -0x14);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x13);\n                    uVar1 = *(arg_ch + arg_10h + -0x13);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0x12) - *(arg_ch + arg_10h + -0x12);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000cdd8:\n                uVar1 = *(arg_8h + arg_10h + -0x11);\n                if (uVar1 == *(arg_ch + arg_10h + -0x11)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0x11);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x10);\n                    uVar1 = *(arg_ch + arg_10h + -0x10);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0xf);\n                    uVar1 = *(arg_ch + arg_10h + -0xf);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0xe) - *(arg_ch + arg_10h + -0xe);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000ce67:\n                uVar1 = *(arg_8h + arg_10h + -0xd);\n                if (uVar1 == *(arg_ch + arg_10h + -0xd)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0xd);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0xc);\n                    uVar1 = *(arg_ch + arg_10h + -0xc);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0xb);\n                    uVar1 = *(arg_ch + arg_10h + -0xb);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -10) - *(arg_ch + arg_10h + -10);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000cef6:\n                if (*(arg_8h + arg_10h + -9) == *(arg_ch + arg_10h + -9)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = *(arg_ch + arg_10h + -9);\n                    uVar2 = *(arg_8h + arg_10h + -9);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -8);\n                    uVar1 = *(arg_ch + arg_10h + -8);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -7);\n                    uVar1 = *(arg_ch + arg_10h + -7);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -6) - *(arg_ch + arg_10h + -6);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000cf86:\n                uVar1 = *(arg_8h + arg_10h + -5);\n                if (uVar1 == *(arg_ch + arg_10h + -5)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -5);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -4);\n                    uVar1 = *(arg_ch + arg_10h + -4);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -3);\n                    uVar1 = *(arg_ch + arg_10h + -3);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -2) - *(arg_ch + arg_10h + -2);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\njoined_r0x1000d00f:\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000d015:\n                uVar2 = *(arg_ch + arg_10h + -1);\n                uVar1 = *(arg_8h + arg_10h + -1);\n                if (uVar1 == uVar2) {\n                    return 0;\n                }\n                return (0 < uVar1 - uVar2) * 2 + -1;\n            case 0x1e:\n                uVar1 = *(arg_8h + arg_10h + -0x1e);\n                if (uVar1 == *(arg_ch + arg_10h + -0x1e)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0x1e);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x1d);\n                    uVar1 = *(arg_ch + arg_10h + -0x1d);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x1c);\n                    uVar1 = *(arg_ch + arg_10h + -0x1c);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0x1b) - *(arg_ch + arg_10h + -0x1b);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000d0c6:\n                uVar1 = *(arg_8h + arg_10h + -0x1a);\n                if (uVar1 == *(arg_ch + arg_10h + -0x1a)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0x1a);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x19);\n                    uVar1 = *(arg_ch + arg_10h + -0x19);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x18);\n                    uVar1 = *(arg_ch + arg_10h + -0x18);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0x17) - *(arg_ch + arg_10h + -0x17);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000d155:\n                uVar1 = *(arg_8h + arg_10h + -0x16);\n                if (uVar1 == *(arg_ch + arg_10h + -0x16)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0x16);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x15);\n                    uVar1 = *(arg_ch + arg_10h + -0x15);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x14);\n                    uVar1 = *(arg_ch + arg_10h + -0x14);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0x13) - *(arg_ch + arg_10h + -0x13);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000d1e4:\n                uVar1 = *(arg_8h + arg_10h + -0x12);\n                if (uVar1 == *(arg_ch + arg_10h + -0x12)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0x12);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x11);\n                    uVar1 = *(arg_ch + arg_10h + -0x11);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x10);\n                    uVar1 = *(arg_ch + arg_10h + -0x10);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0xf) - *(arg_ch + arg_10h + -0xf);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000d273:\n                uVar1 = *(arg_8h + arg_10h + -0xe);\n                if (uVar1 == *(arg_ch + arg_10h + -0xe)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0xe);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0xd);\n                    uVar1 = *(arg_ch + arg_10h + -0xd);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0xc);\n                    uVar1 = *(arg_ch + arg_10h + -0xc);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0xb) - *(arg_ch + arg_10h + -0xb);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000d302:\n                if (*(arg_8h + arg_10h + -10) == *(arg_ch + arg_10h + -10)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = *(arg_ch + arg_10h + -10);\n                    uVar2 = *(arg_8h + arg_10h + -10);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar1 = *(arg_ch + arg_10h + -9);\n                    uVar2 = *(arg_8h + arg_10h + -9);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar1 = *(arg_ch + arg_10h + -8);\n                    uVar2 = *(arg_8h + arg_10h + -8);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -7) - *(arg_ch + arg_10h + -7);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000d392:\n                uVar1 = *(arg_8h + arg_10h + -6);\n                if (uVar1 == *(arg_ch + arg_10h + -6)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -6);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -5);\n                    uVar1 = *(arg_ch + arg_10h + -5);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -4);\n                    uVar1 = *(arg_ch + arg_10h + -4);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -3) - *(arg_ch + arg_10h + -3);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000d421:\n                if (*(arg_8h + arg_10h + -2) != *(arg_ch + arg_10h + -2)) {\ncode_r0x1000d42f:\n                    uVar1 = *(arg_ch + arg_10h + -2);\n                    uVar2 = *(arg_8h + arg_10h + -2);\n                    if (uVar2 == uVar1) goto code_r0x1000d015;\n                    iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1;\n                    goto joined_r0x1000d00f;\n                }\n                break;\n            case 0x1f:\n                if (*(arg_8h + arg_10h + -0x1f) == *(arg_ch + arg_10h + -0x1f)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = *(arg_ch + arg_10h + -0x1f);\n                    uVar2 = *(arg_8h + arg_10h + -0x1f);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x1e);\n                    uVar1 = *(arg_ch + arg_10h + -0x1e);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x1d);\n                    uVar1 = *(arg_ch + arg_10h + -0x1d);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0x1c) - *(arg_ch + arg_10h + -0x1c);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000d4e7:\n                uVar1 = *(arg_8h + arg_10h + -0x1b);\n                if (uVar1 == *(arg_ch + arg_10h + -0x1b)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0x1b);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x1a);\n                    uVar1 = *(arg_ch + arg_10h + -0x1a);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x19);\n                    uVar1 = *(arg_ch + arg_10h + -0x19);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0x18) - *(arg_ch + arg_10h + -0x18);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000d576:\n                uVar1 = *(arg_8h + arg_10h + -0x17);\n                if (uVar1 == *(arg_ch + arg_10h + -0x17)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0x17);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x16);\n                    uVar1 = *(arg_ch + arg_10h + -0x16);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x15);\n                    uVar1 = *(arg_ch + arg_10h + -0x15);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0x14) - *(arg_ch + arg_10h + -0x14);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000d605:\n                uVar1 = *(arg_8h + arg_10h + -0x13);\n                if (uVar1 == *(arg_ch + arg_10h + -0x13)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0x13);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x12);\n                    uVar1 = *(arg_ch + arg_10h + -0x12);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0x11);\n                    uVar1 = *(arg_ch + arg_10h + -0x11);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0x10) - *(arg_ch + arg_10h + -0x10);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000d694:\n                if (*(arg_8h + arg_10h + -0xf) == *(arg_ch + arg_10h + -0xf)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = *(arg_ch + arg_10h + -0xf);\n                    uVar2 = *(arg_8h + arg_10h + -0xf);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0xe);\n                    uVar1 = *(arg_ch + arg_10h + -0xe);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -0xd);\n                    uVar1 = *(arg_ch + arg_10h + -0xd);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -0xc) - *(arg_ch + arg_10h + -0xc);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000d724:\n                uVar1 = *(arg_8h + arg_10h + -0xb);\n                if (uVar1 == *(arg_ch + arg_10h + -0xb)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -0xb);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -10);\n                    uVar1 = *(arg_ch + arg_10h + -10);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -9);\n                    uVar1 = *(arg_ch + arg_10h + -9);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -8) - *(arg_ch + arg_10h + -8);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000d7b3:\n                uVar1 = *(arg_8h + arg_10h + -7);\n                if (uVar1 == *(arg_ch + arg_10h + -7)) {\n                    iVar3 = 0;\n                }\n                else {\n                    uVar1 = uVar1 & 0xff;\n                    uVar2 = *(arg_ch + arg_10h + -7);\n                    if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -6);\n                    uVar1 = *(arg_ch + arg_10h + -6);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    uVar2 = *(arg_8h + arg_10h + -5);\n                    uVar1 = *(arg_ch + arg_10h + -5);\n                    if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                        return iVar3;\n                    }\n                    iVar3 = *(arg_8h + arg_10h + -4) - *(arg_ch + arg_10h + -4);\n                    if (iVar3 != 0) {\n                        iVar3 = (0 < iVar3) * 2 + -1;\n                    }\n                }\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\ncode_r0x1000d842:\n                uVar2 = *(arg_8h + arg_10h + -3);\n                uVar1 = *(arg_ch + arg_10h + -3);\n                if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n                    return iVar3;\n                }\n                goto code_r0x1000d42f;\n            default:\n                goto code_r0x1000c3c2;\n            }\n            return 0;\n        }\n        uVar1 = *arg_8h;\n        uVar2 = *arg_ch;\n        if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar1 = *(arg_8h + 1);\n        uVar2 = *(arg_ch + 1);\n        if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar1 = *(arg_8h + 2);\n        uVar2 = *(arg_ch + 2);\n        if ((uVar1 != uVar2) && (iVar3 = (uVar1 != uVar2 && -1 < uVar1 - uVar2) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar1 = *(arg_8h + 3);\n        uVar2 = *(arg_ch + 3);\n    }\n    iVar3 = uVar1 - uVar2;\n    if (iVar3 != 0) {\n        iVar3 = (0 < iVar3) * 2 + -1;\n    }\n    return iVar3;\ncode_r0x1000c3c2:\n    if (*arg_8h == *arg_ch) {\n        iVar3 = 0;\n    }\n    else {\n        uVar2 = *arg_8h;\n        uVar1 = *arg_ch;\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar2 = *(arg_8h + 1);\n        uVar1 = *(arg_ch + 1);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar2 = *(arg_8h + 2);\n        uVar1 = *(arg_ch + 2);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        iVar3 = *(arg_8h + 3) - *(arg_ch + 3);\n        if (iVar3 != 0) {\n            iVar3 = (0 < iVar3) * 2 + -1;\n        }\n    }\n    if (iVar3 != 0) {\n        return iVar3;\n    }\n    if (arg_8h[1] == arg_ch[1]) {\n        iVar3 = 0;\n    }\n    else {\n        uVar2 = *(arg_8h + 1);\n        uVar1 = *(arg_ch + 1);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar2 = *(arg_8h + 5);\n        uVar1 = *(arg_ch + 5);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar2 = *(arg_8h + 6);\n        uVar1 = *(arg_ch + 6);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        iVar3 = *(arg_8h + 7) - *(arg_ch + 7);\n        if (iVar3 != 0) {\n            iVar3 = (0 < iVar3) * 2 + -1;\n        }\n    }\n    if (iVar3 != 0) {\n        return iVar3;\n    }\n    if (arg_8h[2] == arg_ch[2]) {\n        iVar3 = 0;\n    }\n    else {\n        uVar2 = *(arg_8h + 2);\n        uVar1 = *(arg_ch + 2);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar2 = *(arg_8h + 9);\n        uVar1 = *(arg_ch + 9);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar2 = *(arg_8h + 10);\n        uVar1 = *(arg_ch + 10);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        iVar3 = *(arg_8h + 0xb) - *(arg_ch + 0xb);\n        if (iVar3 != 0) {\n            iVar3 = (0 < iVar3) * 2 + -1;\n        }\n    }\n    if (iVar3 != 0) {\n        return iVar3;\n    }\n    if (arg_8h[3] == arg_ch[3]) {\n        iVar3 = 0;\n    }\n    else {\n        uVar2 = *(arg_8h + 3);\n        uVar1 = *(arg_ch + 3);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar2 = *(arg_8h + 0xd);\n        uVar1 = *(arg_ch + 0xd);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar2 = *(arg_8h + 0xe);\n        uVar1 = *(arg_ch + 0xe);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        iVar3 = *(arg_8h + 0xf) - *(arg_ch + 0xf);\n        if (iVar3 != 0) {\n            iVar3 = (0 < iVar3) * 2 + -1;\n        }\n    }\n    if (iVar3 != 0) {\n        return iVar3;\n    }\n    if (arg_8h[4] == arg_ch[4]) {\n        iVar3 = 0;\n    }\n    else {\n        uVar1 = *(arg_ch + 4);\n        uVar2 = *(arg_8h + 4);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar2 = *(arg_8h + 0x11);\n        uVar1 = *(arg_ch + 0x11);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar2 = *(arg_8h + 0x12);\n        uVar1 = *(arg_ch + 0x12);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        iVar3 = *(arg_8h + 0x13) - *(arg_ch + 0x13);\n        if (iVar3 != 0) {\n            iVar3 = (0 < iVar3) * 2 + -1;\n        }\n    }\n    if (iVar3 != 0) {\n        return iVar3;\n    }\n    if (arg_8h[5] == arg_ch[5]) {\n        iVar3 = 0;\n    }\n    else {\n        uVar2 = *(arg_8h + 5);\n        uVar1 = *(arg_ch + 5);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar2 = *(arg_8h + 0x15);\n        uVar1 = *(arg_ch + 0x15);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar2 = *(arg_8h + 0x16);\n        uVar1 = *(arg_ch + 0x16);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        iVar3 = *(arg_8h + 0x17) - *(arg_ch + 0x17);\n        if (iVar3 != 0) {\n            iVar3 = (0 < iVar3) * 2 + -1;\n        }\n    }\n    if (iVar3 != 0) {\n        return iVar3;\n    }\n    if (arg_8h[6] == arg_ch[6]) {\n        iVar3 = 0;\n    }\n    else {\n        uVar2 = *(arg_8h + 6);\n        uVar1 = *(arg_ch + 6);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar2 = *(arg_8h + 0x19);\n        uVar1 = *(arg_ch + 0x19);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar2 = *(arg_8h + 0x1a);\n        uVar1 = *(arg_ch + 0x1a);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        iVar3 = *(arg_8h + 0x1b) - *(arg_ch + 0x1b);\n        if (iVar3 != 0) {\n            iVar3 = (0 < iVar3) * 2 + -1;\n        }\n    }\n    if (iVar3 != 0) {\n        return iVar3;\n    }\n    if (arg_8h[7] == arg_ch[7]) {\n        iVar3 = 0;\n    }\n    else {\n        uVar2 = *(arg_8h + 7);\n        uVar1 = *(arg_ch + 7);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar2 = *(arg_8h + 0x1d);\n        uVar1 = *(arg_ch + 0x1d);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        uVar2 = *(arg_8h + 0x1e);\n        uVar1 = *(arg_ch + 0x1e);\n        if ((uVar2 != uVar1) && (iVar3 = (uVar2 != uVar1 && -1 < uVar2 - uVar1) * 2 + -1,  iVar3 != 0)) {\n            return iVar3;\n        }\n        iVar3 = *(arg_8h + 0x1f) - *(arg_ch + 0x1f);\n        if (iVar3 != 0) {\n            iVar3 = (0 < iVar3) * 2 + -1;\n        }\n    }\n    if (iVar3 != 0) {\n        return iVar3;\n    }\n    arg_8h = arg_8h + 8;\n    arg_ch = arg_ch + 8;\n    arg_10h = arg_10h + -0x20;\n    goto code_r0x1000c834;\n}\n",
        "token_count": 16519
    },
    "10002340": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t fcn.10002340(uint8_t *param_1, uint8_t *param_2)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    \n    uVar2 = *param_1;\n    while ((uVar2 != 0 && (uVar2 == *param_2))) {\n        puVar1 = param_1 + 1;\n        param_1 = param_1 + 1;\n        param_2 = param_2 + 1;\n        uVar2 = *puVar1;\n    }\n    return (*param_2 < *param_1) - (*param_1 < *param_2);\n}\n",
        "token_count": 148
    },
    "10013951": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid fcn.10013951(void)\n\n{\n    *0x1001a400 = (*_sym.imp.KERNEL32.dll_CreateFileA)(\"CONOUT$\", 0x40000000, 3, 0, 3, 0, 0);\n    return;\n}\n",
        "token_count": 61
    },
    "10001780": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.10001780(char *param_1)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    pcVar2 = param_1;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.10001670(param_1, pcVar2 - (param_1 + 1));\n    return;\n}\n",
        "token_count": 101
    },
    "10002280": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.10002280(uchar *param_1, int32_t param_2, int32_t param_3)\n\n{\n    if (param_3 != 0) {\n        param_2 = param_2 - param_1;\n        do {\n            *param_1 = param_1[param_2];\n            param_1 = param_1 + 1;\n            param_3 = param_3 + -1;\n        } while (param_3 != 0);\n    }\n    return;\n}\n",
        "token_count": 111
    },
    "10003e49": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.10003e49(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *arg_8h_00;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.100055bc(0x100170e0, 0xc);\n    fcn.10004ac5(0xe);\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = *0x1001a4ec;\n    iVar1 = *(unaff_EBP + 8);\n    iVar2 = *(iVar1 + 4);\n    if (iVar2 != 0) {\n        piVar3 = 0x1001a4e8;\n        do {\n            piVar4 = piVar3;\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 == NULL) goto code_r0x10003e8d;\n            piVar3 = arg_8h_00;\n        } while (*arg_8h_00 != iVar2);\n        piVar4[1] = arg_8h_00[1];\n        fcn.10003dbb(arg_8h_00);\ncode_r0x10003e8d:\n        fcn.10003dbb(*(iVar1 + 4));\n        *(iVar1 + 4) = 0;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.10003eb0();\n    fcn.10005601();\n    return;\n}\n",
        "token_count": 403
    }
}