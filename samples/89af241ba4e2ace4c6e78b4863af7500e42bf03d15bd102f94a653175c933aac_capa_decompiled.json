{
    "00401000": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401000(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    // [00] -r-x section size 16384 named .text\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n    if (iVar1 != -1) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 89
    },
    "00401420": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004015a8) overlaps instruction at (ram,0x004015a4)\n// \n\nuint __cdecl\nfcn.00401420(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h, uint8_t *arg_18h, uint arg_1ch, int32_t arg_20h)\n\n{\n    uint8_t *puVar1;\n    char *pcVar2;\n    char cVar3;\n    uint8_t uVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int32_t *piVar9;\n    uint *puVar10;\n    uint *puVar11;\n    uint8_t in_AF;\n    bool bVar12;\n    unkbyte10 extraout_ST0;\n    unkbyte10 extraout_ST0_00;\n    unkbyte10 Var13;\n    ulong uVar14;\n    uint64_t uVar15;\n    int32_t iStack316;\n    int32_t iStack308;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    bVar12 = false;\n    iStack308 = 0x401451;\n    uVar14 = fcn.00403f30(arg_18h, arg_1ch, arg_8h, 0x20, arg_20h + 0x20);\n    iVar8 = uVar14 >> 0x20;\n    if ((bVar12) || (!bVar12)) {\n        iVar8 = arg_20h + 0x60;\n    }\n    else {\n        *arg_18h = *arg_18h & 0xc3;\n        iStack308 = arg_20h;\n        arg_ch = arg_20h;\n        arg_20h = uVar14 + -0x1bf31dd6;\n        iStack316 = iVar8;\n    }\n    fcn.00403f30(arg_18h, arg_1ch, arg_ch, 0x20, iVar8);\n    fcn.00403f30(arg_18h, arg_1ch, arg_10h, 0x20, arg_20h + 0xa0);\n    puVar10 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n    iVar8 = puVar10[8];\n    fcn.00403f30(puVar10[6], puVar10[7], puVar10[5], 0x20, iVar8 + 0xe0);\n    bVar12 = (POPCOUNT(&stack0xfffffec4 & 0xff) & 1U) != 0;\n    if ((bVar12) && (!bVar12)) {\n        puVar11 = &stack0xfffffec0;\n        cVar3 = '\\x1e';\n        do {\n            puVar10 = puVar10 + -1;\n            puVar11 = puVar11 + -1;\n            *puVar11 = *puVar10;\n            cVar3 = cVar3 + -1;\n        } while ('\\0' < cVar3);\n        uVar5 = in(0x78);\n        return uVar5;\n    }\n    iVar6 = func_0x004013d0();\n    if (iVar6 == -1) {\n        iVar6 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(iVar8 + 0x120) = iVar6 % 5;\n    }\n    else {\n        *(iVar8 + 0x120) = iVar6;\n    }\n    *(puVar10 + -0x43) = 0;\n    puVar11 = puVar10 + -0x10b;\n    for (iVar8 = 0x40; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    *puVar11 = 0;\n    puVar10[-1] = 0x104;\n    *(puVar11 + 2) = 0;\n    uVar15 = fcn.004015d0(0x80000001);\n    Var13 = extraout_ST0;\n    if (uVar15 != 0) {\n        uVar15 = (*_sym.imp.MSVCRT.dll__stricmp)();\n        iVar8 = uVar15;\n        Var13 = extraout_ST0_00;\n        if ((iVar8 == 0) && ((iVar8 < 0 || (iVar8 >= 0)))) {\n            uVar15 = uVar15 & 0xffffffff00000000 | puVar10[8];\n            puVar1 = puVar10[8] + 0x120;\n            *puVar1 = *puVar1 | 0x80;\n        }\n    }\n    piVar9 = uVar15 >> 0x20;\n    *(uVar15 + -0x7ce92414) = Var13;\n    uVar7 = uVar15 - 1;\n    uVar4 = uVar7;\n    in_AF = 9 < (uVar4 & 0xf) | in_AF;\n    uVar4 = uVar4 + in_AF * '\\x06';\n    uVar4 = uVar4 + (0x90 < (uVar4 & 0xf0) | in_AF * (0xf9 < uVar4)) * '`';\n    uVar7 = uVar7 & 0xffffff00 | uVar4;\n    *piVar9 = *piVar9 + 0x458bdf84;\n    puVar1 = uVar7 + 0x12088;\n    *puVar1 = *puVar1 & uVar4;\n    pcVar2 = uVar7 + 0x8b5b5e5f;\n    *pcVar2 = *pcVar2 + uVar4;\n    uVar5 = in(0x5d);\n    return uVar5;\n}\n",
        "token_count": 1322
    },
    "00401710": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nbool fcn.00401710(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EDI;\n    float10 in_ST0;\n    uint *var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    if ((-1 < &var_10ch) && (-1 >= &var_10ch)) {\n        *(unaff_EDI + 0x1c) = in_ST0;\n    }\n    var_10ch = &var_4h;\n    iVar1 = fcn.004015d0(0x80000002, 0x406484, 0x4064c4, &var_8h, &var_10ch);\n    if (iVar1 == 0) {\n        return false;\n    }\n    var_10ch = NULL;\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch);\n    return iVar1 != -1;\n}\n",
        "token_count": 222
    },
    "004019f0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401a88) overlaps instruction at (ram,0x00401a87)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00401a88)\n\nuint __cdecl fcn.004019f0(int32_t *arg_8h)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t *piVar6;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint hObject;\n    \n    hObject = 0xffffffff;\n    iVar3 = (**0x41fabc)(2, 0);\n    if (iVar3 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar5 = &var_128h;\n    for (iVar4 = 0x49; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    iVar4 = (**0x41fac0)(iVar3, &var_12ch);\n    pcVar2 = _sym.imp.MSVCRT.dll__stricmp;\n    uVar1 = hObject;\n    while( true ) {\n        hObject = uVar1;\n        if (iVar4 == 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n            return uVar1;\n        }\n        piVar6 = arg_8h;\n        if ((-1 < iVar4) && (-1 >= iVar4)) {\n            out(0xc4, iVar4);\n            piVar6 = arg_8h + 1;\n            *arg_8h = iVar4;\n        }\n    // WARNING: Bad instruction - Truncating control flow here\n        iVar4 = (*pcVar2)(&var_108h, piVar6);\n        if (iVar4 == 0) break;\n        iVar4 = (**0x41fac4)(iVar3, &var_12ch);\n        arg_8h = piVar6;\n        uVar1 = hObject;\n    }\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n    return var_124h;\n}\n",
        "token_count": 524
    },
    "00402b70": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402be0) overlaps instruction at (ram,0x00402bdc)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00402b70(uint arg_8h, uint32_t arg_ch)\n\n{\n    char cVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uchar *puVar6;\n    uint *unaff_ESI;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    bool bVar12;\n    bool bVar13;\n    char lpBuffer;\n    uint var_22fh;\n    uint var_12ch;\n    uint var_28h;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    uint32_t hFile;\n    \n    puVar6 = &stack0xfffffffc;\n    lpBuffer = '\\0';\n    var_12ch._0_1_ = 0;\n    puVar7 = &var_22fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    bVar12 = false;\n    bVar13 = true;\n    puVar7 = &var_12ch + 1;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    hFile = arg_ch;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    if ((bVar12 || bVar13) || (!bVar12 && !bVar13)) {\n        pcVar9 = &lpBuffer;\n    }\n    else {\n        pcVar9 = puVar7 + 7;\n        *(puVar7 + 3) = *unaff_ESI;\n        arg_ch = arg_ch & 0xffff0000 | CONCAT11(0xdf, arg_ch);\n        puVar6 = 0xfffffdd0;\n    }\n    uVar4 = 0xffffffff;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar4 = ~uVar4;\n    puVar7 = pcVar8 + -uVar4;\n    puVar11 = puVar6 + -300;\n    for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    uVar4 = 0xffffffff;\n    pcVar9 = 0x40604c;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar4 = ~uVar4;\n    iVar3 = -1;\n    pcVar9 = puVar6 + -300;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar3 == 0) break;\n        iVar3 = iVar3 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar4;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(puVar6 + -300, 0, puVar6 + -0x28);\n    if (arg_ch == 0xffffffff) {\n        iVar3 = fcn.00402f60(*(puVar6 + 8));\n        *(puVar6 + -4) = iVar3;\n        if (iVar3 == -1) {\n            return 0;\n        }\n    }\n    uVar2 = *(puVar6 + -4);\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(uVar2, puVar6 + -0x24, puVar6 + -0x1c, puVar6 + -0x14);\n    if (*(puVar6 + 0xc) == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1387
    },
    "00402f90": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402fac) overlaps instruction at (ram,0x00402faa)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.00402f90(void)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    int32_t unaff_EDI;\n    uint *puVar2;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    if ((&stack0xfffffffc < 0x80 || *0x10 == 0x84) || (&stack0xfffffffc >= 0x80 && *0x10 != 0x84)) {\n        in_EAX = fcn.00403510();\n    }\n    *(unaff_EDI + -0x18) = *(unaff_EDI + -0x18) - &stack0xffffff70;\n    if (in_EAX == 0x3f7b0000) {\n        fcn.00403110();\n        return false;\n    }\n    fcn.00403440();\n    iVar1 = fcn.004019f0(0x406078);\n    if (iVar1 != -1) {\n        iVar1 = fcn.004019f0(0x40606c);\n        if (iVar1 == -1) {\n            fcn.00403110();\n        }\n        return false;\n    }\n    fcn.00402760();\n    iVar1 = fcn.00403630();\n    if (iVar1 == 0) {\n        var_20h = 0;\n        var_80h._0_1_ = 0;\n        puVar2 = &var_1fh;\n        for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        *puVar2 = 0;\n        *(puVar2 + 2) = 0;\n        var_60h._0_1_ = 0;\n        puVar2 = &var_80h + 1;\n        for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        *puVar2 = 0;\n        *(puVar2 + 2) = 0;\n        var_40h._0_1_ = 0;\n        puVar2 = &var_60h + 1;\n        for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        *puVar2 = 0;\n        *(puVar2 + 2) = 0;\n        puVar2 = &var_40h + 1;\n        for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        *puVar2 = 0;\n        *(puVar2 + 2) = 0;\n        iVar1 = fcn.00403800(&var_80h, &var_60h, &var_20h, &var_40h);\n        if (iVar1 != 0) {\n            iVar1 = fcn.00403c40(&var_20h);\n            if (iVar1 != 0) {\n                iVar1 = fcn.00401bf0(&var_80h, &var_60h, &var_20h, &var_40h);\n                return iVar1 != 0;\n            }\n            return false;\n        }\n        return false;\n    }\n    return false;\n}\n",
        "token_count": 867
    },
    "00403630": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.00403630(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00402f60(0x406014);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 74
    },
    "00403660": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403660(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.004019f0(0x406080);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x40, 0, iVar1);\n    if (iVar1 != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(arg_8h, iVar1, 0, 0, 0, 2);\n        iVar3 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n        if (iVar3 == 0) {\n            return 0;\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 209
    },
    "00403700": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403728) overlaps instruction at (ram,0x00403727)\n// \n// WARNING: Removing unreachable block (ram,0x00403728)\n\nuint __cdecl fcn.00403700(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    bool bVar2;\n    \n    arg_8h_00 = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n    if (arg_8h_00 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_WriteFile)();\n    bVar2 = iVar1 == 0;\n    if (!bVar2) {\n        if ((!bVar2) && (bVar2)) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        if (*0x41fab4 != 0) {\n            iVar1 = fcn.00403660(arg_8h_00);\n            *0x41fab4 = iVar1 == 0;\n        }\n        fcn.00402b70(0, arg_8h_00);\n        if (((!SCARRY4(&stack0xffffffb8, 8)) && (SCARRY4(&stack0xffffffb8, 8))) || (*0x41fab4 == 0)) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)();\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 350
    },
    "004010a0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.004010a0(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.004033a0(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x406448, acStack1304, &uStack2112);\n    uStack2088 = 0x406500;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x406518;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00402cf0(auStack1564, 0x406444, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1845
    },
    "00403d70": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403eb9) overlaps instruction at (ram,0x00403eb6)\n// \n\nuint __cdecl fcn.00403d70(int16_t *arg_8h)\n\n{\n    char cVar1;\n    ushort uVar2;\n    uint uVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    uint32_t extraout_ECX;\n    uint32_t uVar7;\n    int32_t *in_EDX;\n    char *unaff_EBX;\n    uint *puVar8;\n    uchar *puVar9;\n    uint *unaff_ESI;\n    uint32_t *puVar10;\n    uint *unaff_EDI;\n    uint32_t *puVar11;\n    uint32_t *puVar12;\n    uint *puVar13;\n    ushort in_SS;\n    bool bVar14;\n    bool in_SF;\n    float10 in_ST0;\n    ulong uVar15;\n    uint uStack20;\n    \n    puVar8 = &stack0xfffffffc;\n    puVar9 = &stack0xfffffffc;\n    if ((!in_SF) && (in_SF)) {\n        *(unaff_EDI + 7) = in_ST0;\n        unaff_EDI = unaff_EDI + 5;\n        unaff_ESI = unaff_ESI + 5;\n    }\n    pcVar4 = &stack0xfffffff4;\n    if (*arg_8h != 0x5a4d) {\n        return 0;\n    }\n    if ((SBORROW2(*arg_8h, 0x5a4d)) || (!SBORROW2(*arg_8h, 0x5a4d))) {\n        bVar14 = CARRY4(*(arg_8h + 0x1e), arg_8h);\n        piVar6 = *(arg_8h + 0x1e) + arg_8h;\n        if ((bVar14 || piVar6 == NULL) || (!bVar14 && piVar6 != NULL)) {\n            bVar14 = *piVar6 == 0x4550;\n            goto code_r0x00403dd4;\n        }\n        *unaff_EDI = *unaff_ESI;\n        puVar9 = 0x81e181d0;\n    }\n    else {\n        pcVar4 = CONCAT31(arg_8h >> 8, 0x98);\n        puVar13 = &stack0xfffffff0;\n        puVar9 = &stack0xfffffff0;\n        cVar1 = '\\x13';\n        do {\n            puVar8 = puVar8 + -1;\n            puVar13 = puVar13 + -1;\n            *puVar13 = *puVar8;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        *pcVar4 = *pcVar4 + -0x68;\n        *(unaff_ESI + 0xfff87ff) = *(unaff_ESI + 0xfff87ff) + -0x68;\n        iVar5 = *in_EDX;\n        *in_EDX = 0x488b5d21;\n        *pcVar4 = *pcVar4 + -0x68;\n        *unaff_EBX = *unaff_EBX + (unaff_EBX >> 8);\n        piVar6 = iVar5 + -1;\n        if (piVar6 != NULL && *unaff_EBX == '\\0') {\n    // WARNING: Could not recover jumptable at 0x00403d50. Too many branches\n    // WARNING: Treating indirect jump as call\n            uVar3 = (**(in_EDX + -1))();\n            return uVar3;\n        }\n    }\n    *pcVar4 = *pcVar4 + pcVar4;\n    bVar14 = *pcVar4 == '\\0';\ncode_r0x00403dd4:\n    if (!bVar14) {\n        return 0;\n    }\n    if (piVar6[0x16] != 0) {\n        return 0;\n    }\n    puVar11 = 0x40;\n    if (*(*(puVar9 + 8) + 0x3c) < 0x81) {\n        return 0;\n    }\n    uVar7 = *(*(puVar9 + 8) + 0x3c);\n    if (uVar7 < 0xc0) {\n        puVar11 = uVar7 - 0x80;\n    }\n    puVar12 = puVar11;\n    if ((0xbf < uVar7) && (uVar7 < 0xc0)) {\n        out(0xc4, uVar7);\n        puVar12 = puVar11 + 1;\n        *puVar11 = uVar7;\n    }\n    uVar15 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_();\n    puVar8 = uVar15;\n    if (puVar8 == NULL) {\n        return 0;\n    }\n    bVar14 = puVar12 == NULL;\n    uVar7 = extraout_ECX;\n    puVar11 = NULL;\n    if (!bVar14) {\n        do {\n            iVar5 = uVar15 >> 0x20;\n            puVar8 = uVar15;\n            if (bVar14) {\ncode_r0x00403eb9:\n                iVar5 = (*_sym.imp.MSVCRT.dll_rand)();\n                uVar7 = 0xff;\n                iVar5 = iVar5 % 0xff;\n            }\n            else {\n                uVar2 = uVar7;\n                uVar7 = (uVar7 >> 8 & 0xffff00) << 8 | uVar7 & 0xffff;\n                if (!bVar14) goto code_r0x00403eb9;\n                puVar12 = CONCAT22(uVar2, in_SS);\n                *(uVar7 + 0xffb9) = *(uVar7 + 0xffb9) + uVar15;\n                puVar8 = puVar8 & 0xffff0000 | CONCAT11((uVar15 >> 8) + (uVar15 >> 0x28), uVar15);\n            }\n            uVar15 = CONCAT44(iVar5, puVar8);\n            puVar10 = puVar11 + 1;\n            bVar14 = puVar10 == puVar12;\n            *(puVar11 + puVar8) = iVar5;\n            puVar11 = puVar10;\n        } while (puVar10 < puVar12);\n    }\n    puVar13 = *(puVar9 + 8) + 0x80;\n    for (uVar7 = puVar12 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *puVar13 = *puVar8;\n        puVar8 = puVar8 + 1;\n        puVar13 = puVar13 + 1;\n    }\n    for (uVar7 = puVar12 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *puVar13 = *puVar8;\n        puVar8 = puVar8 + 1;\n        puVar13 = puVar13 + 1;\n    }\n    sub.MSVCRT.dll_void___cdecl_operator_delete_void__();\n    return 1;\n}\n",
        "token_count": 1625
    },
    "null": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00401f90": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2",
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402169) overlaps instruction at (ram,0x00402167)\n// \n\nvoid fcn.00401f90(void)\n\n{\n    char cVar1;\n    uint8_t uVar2;\n    ushort uVar3;\n    int16_t iVar4;\n    uint *puVar5;\n    uint32_t *puVar6;\n    uint8_t *puVar7;\n    uint uVar9;\n    uint32_t uVar10;\n    char extraout_CL;\n    char extraout_CH;\n    char extraout_CH_00;\n    uint8_t extraout_CH_01;\n    char extraout_CH_02;\n    uint8_t extraout_DH;\n    int32_t extraout_EDX;\n    char *unaff_EBX;\n    uint *unaff_EBP;\n    uint32_t unaff_ESI;\n    uint *unaff_EDI;\n    ushort in_SS;\n    bool bVar11;\n    uchar uVar12;\n    uchar uVar13;\n    uint8_t in_AF;\n    bool bVar14;\n    ulong uVar15;\n    uint32_t in_stack_ffffffff;\n    uint32_t arg_14h;\n    uint arg_10h;\n    uchar uVar16;\n    unkbyte3 Var17;\n    uint arg_ch;\n    uint8_t uVar18;\n    uchar uVar19;\n    ushort uVar20;\n    int32_t *piVar8;\n    \n    uVar19 = SUB41(unaff_EBX, 0);\n    uVar20 = unaff_EBX >> 8;\n    arg_14h = in_stack_ffffffff & 0xffffff00 | unaff_EBX >> 0x18;\n    uVar2 = unaff_ESI >> 0x18;\n    arg_ch = CONCAT31(unaff_ESI, unaff_EDI >> 0x18);\n    uVar18 = uVar2;\n    fcn.00404380(0x406520, 10, 0x406028, 10);\n    puVar5 = fcn.00404380(0x406520, 10, 0x406034, 0x12);\n    bVar11 = unaff_EDI < puVar5;\n    bVar14 = unaff_EDI == puVar5;\n    puVar5 = unaff_ESI & 0xffffff | uVar2 << 0x18;\n    uVar12 = 0;\n    Var17 = 0x406520;\n    fcn.00404380(0x406520, 10, 0x406048, 4);\n    if ((!bVar11 && !bVar14) && (bVar11 || bVar14)) {\n        puVar5 = CONCAT13(uVar12, Var17);\n    }\n    fcn.00404380(0x406520, 10, 0x40604c, 0xc);\n    fcn.00404380(0x406520, 10, 0x406058, 7);\n    fcn.00404380(0x406520, 10, 0x406060, 0xb);\n    fcn.00404380(0x406520, 10, 0x40606c, 0xc);\n    fcn.00404380(0x406520, 10, 0x406078, 8);\n    fcn.00404380(0x406520, 10, 0x406080, 0xd);\n    *unaff_EDI = *puVar5;\n    *0x90681874 = *0x90681874 + extraout_CH;\n    fcn.00404380(0x406520, unaff_EDI + 1, puVar5 + 1, unaff_EBP);\n    uVar12 = 0;\n    bVar11 = false;\n    fcn.00404380(0x406520, 10, 0x4060a8, 0x25);\n    if (bVar11) goto code_r0x00402184;\n    while( true ) {\n        if (bVar11) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\ncode_r0x00402184:\n        puVar6 = fcn.00404380(0x406520, 10, 0x4060d0, 10);\n        if ((uVar12) || (!uVar12)) break;\n        puVar7 = puVar6 + 1;\n        if (&stack0xffffffc3 < *puVar6 || puVar7 == NULL) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        puVar7 = (puVar7 & 0xffffff00 | puVar7 & *puVar7) + 0x16;\n        uVar12 = CARRY1(*puVar7, extraout_DH);\n        bVar11 = SCARRY1(*puVar7, extraout_DH);\n        *puVar7 = *puVar7 + extraout_DH;\n    }\n    uVar3 = fcn.00404380(0x406520, 10, 0x4060dc, 0xc);\n    bVar11 = (CONCAT11((uVar3 >> 8) - extraout_CL, uVar3 + '\\x01') - 1U & 0x637b) == 0;\n    fcn.00404380(0x406520, 10, 0x4060e8, 0xd);\n    if ((!bVar11) && (bVar11)) {\n        puVar5 = &stack0xffffffcf;\n        cVar1 = '\\x10';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *unaff_EBP;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    while( true ) {\n        fcn.00404380(0x406520, 10, 0x4060f8, 6);\n        fcn.00404380(0x406520, 10, 0x406100, 5);\n        fcn.00404380(0x406520, 10, 0x406108, 0xd);\n        fcn.00404380(0x406520, 10, 0x406118, 0x19);\n        fcn.00404380(0x406520, 10, 0x406134, 0xf);\n        fcn.00404380(0x406520, 10, 0x406144, 0xe);\n        fcn.00404380(0x406520, 10, 0x406154, 0xd);\n        iVar4 = fcn.00404380(0x406520, 10, 0x406164, 0xc);\n        bVar11 = false;\n        bVar14 = (POPCOUNT(iVar4 + 1U & 0xff) & 1U) == 0;\n        fcn.00404380(0x406520, 10, 0x406170, 0xf);\n        if ((bVar14) || (!bVar14)) break;\n        puVar6 = segment(in_SS, *0x10 + -0x2d);\n        if (bVar11) {\n            return;\n        }\n        if (!bVar14) break;\n        uVar2 = *puVar6 + extraout_CH_00;\n        piVar8 = *puVar6 & 0xffffff00 | uVar2;\n        *piVar8 = *piVar8 - &stack0xffffffd3;\n        *piVar8 = *piVar8 + uVar2;\n    }\n    fcn.00404380(0x406520, 10, 0x406180, 0xb);\n    fcn.00404380(0x406520, 10, 0x40618c, 0xb);\n    fcn.00404380(0x406520, 10, 0x406198, 0xb);\n    fcn.00404380(0x406520, 10, 0x4061a4, 10);\n    fcn.00404380(0x406520, 10, 0x4061b0, 0xc);\n    fcn.00404380(0x406520, 10, 0x4061bc, 0xe);\n    fcn.00404380(0x406520, 10, 0x4061cc, 0x11);\n    bVar11 = false;\n    uVar9 = fcn.00404380(0x406520, 10, 0x4061e0, 0x13);\n    if ((!bVar11) && (bVar11)) {\n        out(0xbd, uVar9);\n        return;\n    }\n    fcn.00404380(0x406520, 10, 0x4061f4, 0x14);\n    uVar15 = fcn.00404380(0x406520, 10, 0x406208, 0x33);\n    bVar11 = false;\n    bVar14 = ((uVar15 >> 0x20 & 0xffffff00 | extraout_CH_01) & uVar15) == 0;\n    uVar12 = 10;\n    uVar16 = 0;\n    uVar3 = 0;\n    arg_10h = 0x40623c;\n    uVar9 = 10;\n    uVar10 = fcn.00404380(0x406520, 10, 0x40623c, 10);\n    if ((!bVar14) && (bVar14)) {\n        unaff_EBX = unaff_EBX + 1;\n        if (bVar11 || unaff_EBX == NULL) goto code_r0x004025f3;\n        in_AF = 9 < (uVar10 & 0xf) | in_AF;\n        piVar8 = (uVar10 & 0xffff0000 | CONCAT11((uVar10 >> 8) + in_AF, uVar10 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar8 = *piVar8 - unaff_EBX;\n    }\n    fcn.00404380(0x406520, 10, 0x406248, 4);\n    cVar1 = *unaff_EBX;\n    *(unaff_EDI + 0x6e) = *(unaff_EDI + 0x6e) - &stack0xffffffd7;\n    puVar7 = extraout_EDX + 10;\n    uVar13 = CARRY1(*puVar7, extraout_CH_02 - cVar1);\n    *puVar7 = *puVar7 + (extraout_CH_02 - cVar1);\n    bVar11 = *puVar7 == 0;\n    uVar10 = fcn.00404380(0x406520, uVar9, arg_10h, CONCAT22(uVar3, CONCAT11(uVar16, uVar12)));\n    if (bVar11) goto code_r0x004025f8;\n    if (!bVar11) goto code_r0x004025f8;\n    unaff_EBX = unaff_EBX + 1;\n    uVar2 = POPCOUNT(unaff_EBX & 0xff);\n    if (uVar13 || unaff_EBX == NULL) goto code_r0x0040263d;\ncode_r0x004025f3:\n    do {\n        in_AF = 9 < (uVar10 & 0xf) | in_AF;\n        piVar8 = (uVar10 & 0xffff0000 | CONCAT11((uVar10 >> 8) + in_AF, uVar10 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar8 = *piVar8 - unaff_EBX;\ncode_r0x004025f8:\n        fcn.00404380(0x406520, 10, 0x406254, 6);\n        uVar13 = 0;\n        uVar2 = 3;\n        arg_14h = 0xc;\n        uVar18 = 0x5c;\n        uVar19 = 0x62;\n        uVar20 = 0x40;\n        arg_ch = 10;\ncode_r0x0040263d:\n        bVar11 = (uVar2 & 1) == 0;\n        fcn.00404380(0x406520, arg_ch, CONCAT22(uVar20, CONCAT11(uVar19, uVar18)), arg_14h);\n        if ((bVar11) || (!bVar11)) break;\n        puVar6 = segment(in_SS, *0x10 + -0xd);\n        uVar10 = *puVar6;\n        if (uVar13) {\n            *(unaff_EDI + 1) = uVar10;\n            goto code_r0x00402690;\n        }\n    } while (bVar11);\n    fcn.00404380(0x406520, 10, 0x406268, 0xc);\ncode_r0x00402690:\n    fcn.00404380(0x406520, 10, 0x4062a0, 0x2a);\n    fcn.00404380(0x406520, 10, 0x4062cc, 0xb);\n    fcn.00404380(0x406520, 10, 0x406328, 0x41);\n    fcn.00404380(0x406520, 10, 0x40636c, 0x33);\n    fcn.00404380(0x406520, 10, 0x4063a0, 0x4b);\n    fcn.00404380(0x406520, 10, 0x4063ec, 0x39);\n    fcn.00404380(0x406520, 10, 0x406428, 8);\n    fcn.00404380(0x406520, 10, 0x406430, 0x14);\n    return;\n}\n",
        "token_count": 3184
    },
    "00402d80": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402ea6) overlaps instruction at (ram,0x00402e9d)\n// \n\nuint __cdecl fcn.00402d80(code *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code cVar2;\n    char *pcVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    code *pcVar7;\n    code *pcVar8;\n    bool bVar9;\n    uchar var_264h;\n    uint var_263h;\n    char var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char *var_20h;\n    code *var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar7 = _sym.imp.MSVCRT.dll_sprintf;\n    var_264h = 0;\n    puVar6 = &var_263h;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    var_160h = '\\0';\n    puVar6 = &var_15fh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_160h, 0x406090, arg_8h);\n    (*pcVar7)(&var_264h, 0x4060a8, arg_8h);\n    var_20h = &var_160h;\n    var_18h = &var_ch;\n    var_14h = &var_4h;\n    var_10h = &var_8h;\n    uVar5 = 0xffffffff;\n    pcVar3 = &var_160h;\n    do {\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        cVar1 = *pcVar3;\n        pcVar3 = pcVar3 + 1;\n    } while (cVar1 != '\\0');\n    var_48h = ~uVar5 - 1;\n    bVar9 = false;\n    uVar5 = 0xffffffff;\n    pcVar7 = arg_8h;\n    do {\n        pcVar8 = pcVar7;\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        pcVar8 = pcVar7 + 1;\n        bVar9 = *pcVar7 != 0x0;\n        cVar2 = *pcVar7;\n        pcVar7 = pcVar8;\n    } while (cVar2 != 0x0);\n    var_34h = 0x4060d0;\n    var_30h = 0x4060dc;\n    var_2ch = 0x4060e8;\n    var_28h = 0x4060f8;\n    var_24h = 0x406100;\n    var_5ch = 2;\n    var_58h = 1;\n    var_54h = 4;\n    var_50h = 4;\n    var_4ch = 4;\n    var_1ch = arg_8h;\n    var_44h = ~uVar5 - 1;\n    var_40h = 4;\n    var_3ch = 4;\n    var_38h = 4;\n    if ((bVar9) || (!bVar9)) {\n        if (4 < (arg_ch != 0)) {\n            return 1;\n        }\n        arg_8h = (arg_ch != 0) * 4;\n        pcVar8 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    }\n    else {\n        *(arg_8h + 0x43d1773a) = *(arg_8h + 0x43d1773a) ^ 0x8327e95e;\n        uVar5 = func_0x8d406f02();\n        pcVar3 = uVar5 ^ 0x9d;\n        *pcVar3 = *pcVar3 + pcVar3;\n        *pcVar3 = *pcVar3 + pcVar3;\n    }\n    do {\n        iVar4 = (*pcVar8)(0x80000002, &var_264h, *(&var_34h + arg_8h), *(&var_5ch + arg_8h), *(&var_20h + arg_8h), \n                          *(&var_48h + arg_8h));\n        if (iVar4 != 0) {\n            return 0;\n        }\n        arg_8h = arg_8h + 4;\n    } while (arg_8h < 0x14);\n    return 1;\n}\n",
        "token_count": 1321
    },
    "00403510": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint64_t fcn.00403510(void)\n\n{\n    uint32_t extraout_EDX;\n    uint var_94h;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    (*_sym.imp.KERNEL32.dll_GetVersionExA)();\n    if (var_90h == 5) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    return extraout_EDX << 0x20;\n}\n",
        "token_count": 152
    },
    "00401670": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nint32_t fcn.00401670(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 48
    },
    "00402760": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402af1) overlaps instruction at (ram,0x00402af0)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nvoid fcn.00402760(void)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    uchar uVar3;\n    code *pcVar4;\n    uint16_t uVar5;\n    uint8_t extraout_AH;\n    ushort uVar6;\n    uint16_t extraout_CX;\n    uint32_t extraout_ECX;\n    uint32_t extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    int32_t extraout_ECX_02;\n    uint extraout_ECX_03;\n    uint extraout_ECX_04;\n    uint extraout_ECX_05;\n    uchar *extraout_ECX_06;\n    uint8_t extraout_DL;\n    uint8_t uVar7;\n    uint16_t extraout_DX;\n    ushort extraout_DX_00;\n    int32_t extraout_EDX;\n    int32_t iVar8;\n    uint extraout_EDX_00;\n    uint extraout_EDX_01;\n    char extraout_DH;\n    uint32_t extraout_EDX_02;\n    uint extraout_EDX_03;\n    ushort uVar9;\n    uint32_t unaff_EBX;\n    uint32_t uVar10;\n    uint *puVar11;\n    uint *puVar12;\n    uint *puVar13;\n    uint16_t *puVar14;\n    uint *puVar15;\n    ushort unaff_BP;\n    int32_t unaff_ESI;\n    uint32_t uVar16;\n    uint unaff_EDI;\n    uchar *puVar17;\n    ushort in_SS;\n    bool bVar18;\n    uint8_t in_AF;\n    bool bVar19;\n    uchar uVar20;\n    char cVar21;\n    char cVar22;\n    bool bVar23;\n    ulong uVar24;\n    uint32_t arg_ch;\n    uint uVar25;\n    uint arg_14h;\n    \n    fcn.00404380(0x406520, 10, 0x406014, 0x11);\n    bVar18 = false;\n    uVar7 = extraout_DL ^ unaff_EBX >> 8 | 0x67;\n    uVar20 = uVar7 < '\\0';\n    bVar19 = uVar7 == 0;\n    arg_14h = 10;\n    uVar25 = 0x406520;\n    uVar24 = fcn.00404380(0x406520, 10, 0x406274, 0xf);\n    iVar8 = uVar24 >> 0x20;\n    uVar10 = unaff_EBX;\n    if ((bVar19) || (!bVar19)) {\ncode_r0x004027bb:\n        arg_ch = 0x1a;\n        fcn.00404380(0x406520, 10, 0x406284, 0x1a);\n        uVar16 = extraout_ECX_00;\n        iVar8 = extraout_EDX;\n        if (!uVar20) {\n            uVar16 = extraout_ECX_00 & 0xffff;\n        }\n    }\n    else {\n        uVar10 = unaff_EBX + 1;\n        if (!bVar18 && uVar10 != 0) {\n            in_AF = 9 < (uVar24 & 0xf) | in_AF;\n            piVar1 = (uVar24 & 0xffff0000 | CONCAT11((uVar24 >> 8) + in_AF, uVar24 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n            *piVar1 = *piVar1 - uVar10;\n            unaff_ESI = unaff_ESI + 1;\n            uVar20 = unaff_ESI < 0;\n            goto code_r0x004027bb;\n        }\n        *(unaff_EBX + 0x67) = *(unaff_EBX + 0x67) ^ uVar24 >> 0x20;\n        uVar16 = extraout_ECX;\n        arg_ch = extraout_ECX;\n    }\n    *(iVar8 + 10) = *(iVar8 + 10) + (uVar16 >> 8);\n    fcn.00404380(0x406520, arg_ch, uVar25, arg_14h);\n    fcn.00404380(0x406520, 10, 0x4062e4, 0xb);\n    fcn.00404380(0x406520, 10, 0x4062f0, 8);\n    fcn.00404380(0x406520, 10, 0x4062f8, 9);\n    while( true ) {\n        uVar5 = fcn.00404380(0x406520, 10, 0x406304, 9);\n        cVar22 = '\\0';\n        uVar5 = ((uVar5 & 0xff | (uVar5 >> 8 & extraout_DX >> 8) << 8) * 2 | extraout_DX) ^ 0x6c00 ^ uVar10;\n        cVar21 = uVar5 < 0;\n        uVar20 = uVar5 == 0;\n        fcn.00404380(0x406520, 10, 0x406310, 9);\n        fcn.00404380(0x406520, 10, 0x40631c, 0xc);\n        if ((uVar20 || cVar22 != cVar21) || (!uVar20 && cVar22 == cVar21)) break;\n        if (extraout_ECX_01 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    uVar24 = fcn.00404380(0x406520, 10, 0x406444, 3);\n    uVar16 = uVar24;\n    if ((cVar22 != cVar21) || (uVar7 = (extraout_ECX_02 << 0x10) >> 0x18,  cVar22 == cVar21)) {\n        uVar7 = extraout_ECX_02 >> 8;\n    }\n    puVar11 = &stack0xffffffd4 ^ *(uVar10 + 0x6a);\n    pcVar2 = (uVar24 >> 0x20) + 10;\n    *pcVar2 = *pcVar2 + (uVar7 | *(unaff_ESI + 0x48));\n    puVar11[-1] = 0x406520;\n    puVar11[-2] = 0x40294a;\n    uVar25 = fcn.00404380(puVar11[-1], *puVar11, puVar11[1], puVar11[2]);\n    puVar12 = puVar11 + 0xf;\n    if ((puVar11 + -1 < 0xffffffc0 && puVar11 != 0xffffffc4) &&\n       (puVar11[0xe] = uVar25,  puVar12 = puVar11 + 0xf,  puVar11 + -1 >= 0xffffffc0 || puVar11 == 0xffffffc4)) {\n        uVar16 = puVar11[0xf];\n        puVar12 = puVar11 + 0x3f;\n    }\n    *(puVar12 + -4) = 0x1b;\n    *(puVar12 + -8) = 0x406454;\n    *(puVar12 + -0xc) = 10;\n    *(puVar12 + -0x10) = 0x406520;\n    *(puVar12 + -0x14) = 0x402977;\n    fcn.00404380(*(puVar12 + -0x10), *(puVar12 + -0xc), *(puVar12 + -8), *(puVar12 + -4));\n    *(puVar12 + -4) = extraout_EDX_00;\n    uVar7 = extraout_EDX_00 + 0x15;\n    bVar18 = uVar7 < extraout_AH;\n    cVar22 = SBORROW1(uVar7, extraout_AH);\n    cVar21 = uVar7 - extraout_AH < '\\0';\n    bVar19 = uVar7 == extraout_AH;\n    *(puVar12 + -4) = 0x12;\n    *(puVar12 + -8) = 0x406470;\n    *(puVar12 + -0xc) = 10;\n    *(puVar12 + -0x10) = 0x406520;\n    *(puVar12 + -0x14) = 0x402997;\n    fcn.00404380(*(puVar12 + -0x10), *(puVar12 + -0xc), *(puVar12 + -8), *(puVar12 + -4));\n    if (!bVar18 && !bVar19) {\n        uVar10 = uVar10 & 0xffff;\n    }\n    *(puVar12 + -0x14) = 0x40;\n    *(puVar12 + -0x18) = 0x406484;\n    *(puVar12 + -0x1c) = 10;\n    puVar13 = puVar12 + -0x20;\n    *(puVar12 + -0x20) = 0x406520;\n    *(puVar12 + -0x24) = 0x4029bc;\n    fcn.00404380(*(puVar12 + -0x20), *(puVar12 + -0x1c), *(puVar12 + -0x18), *(puVar12 + -0x14));\n    if ((bVar19 || cVar22 != cVar21) || (!bVar19 && cVar22 == cVar21)) {\n        puVar13 = puVar12 + -0x24;\n        *(puVar12 + -0x24) = 0xc;\n    }\n    puVar13[-1] = 0x4064c4;\n    puVar13[-2] = 10;\n    puVar13[-3] = 0x406520;\n    puVar13[-4] = 0x4029dd;\n    uVar24 = fcn.00404380(puVar13[-3], puVar13[-2], puVar13[-1], *puVar13);\n    puVar13[8] = uVar24;\n    puVar13[7] = extraout_ECX_03;\n    puVar13[6] = uVar24 >> 0x20;\n    puVar13[8] = 0xb;\n    puVar13[7] = 0x4064d0;\n    puVar13[6] = 10;\n    puVar13[5] = 0x406520;\n    puVar13[4] = 0x402a1c;\n    fcn.00404380(puVar13[5], puVar13[6], puVar13[7], puVar13[8]);\n    *(puVar13 + 0x22) = uVar10;\n    *(puVar13 + 0x1e) = extraout_EDX_01;\n    *(puVar13 + 0x1a) = unaff_EDI;\n    bVar18 = false;\n    bVar19 = (POPCOUNT((uVar10 ^ extraout_CX) & 0xff) & 1U) == 0;\n    puVar17 = *(puVar13 + 0x1a);\n    uVar9 = *(puVar13 + 0x22);\n    puVar13[8] = 4;\n    puVar13[7] = 0x4064dc;\n    puVar13[6] = 10;\n    puVar13[5] = 0x406520;\n    puVar13[4] = 0x402a3f;\n    uVar25 = fcn.00404380(puVar13[5], puVar13[6], puVar13[7], puVar13[8]);\n    puVar12 = puVar13 + 5;\n    if ((bVar19) || (puVar13[4] = uVar25,  puVar12 = puVar13 + 5,  !bVar19)) {\ncode_r0x00402a63:\n        *(puVar12 + -4) = 4;\n        *(puVar12 + -8) = 0x4064e0;\n        *(puVar12 + -0xc) = 10;\n        *(puVar12 + -0x10) = 0x406520;\n        *(puVar12 + -0x14) = 0x402a76;\n        uVar6 = fcn.00404380(*(puVar12 + -0x10), *(puVar12 + -0xc), *(puVar12 + -8), *(puVar12 + -4));\n        *(puVar12 + 0xe) = uVar6;\n        *(puVar12 + 0xc) = extraout_ECX_04;\n        *(puVar12 + 10) = extraout_DX_00;\n        *(puVar12 + 8) = uVar9;\n        *(puVar12 + 6) = puVar12 + 0x10;\n        *(puVar12 + 4) = unaff_BP;\n        *(puVar12 + 2) = uVar16;\n        *puVar12 = puVar17;\n        *(puVar12 + -4) = extraout_ECX_04;\n        puVar17 = puVar17 & 0xffff0000 | *puVar12;\n        uVar16 = uVar16 & 0xffff0000 | *(puVar12 + 2);\n        uVar9 = *(puVar12 + 8);\n        puVar14 = puVar12 + 0x10;\n    }\n    else {\n        segment(in_SS, puVar13 + 0x14);\n        puVar14 = puVar13 + 5 & 0xffff0000 | puVar13 + 0x18;\n        if (!bVar18) {\n            if (bVar19) {\n                pcVar4 = swi(1);\n                (*pcVar4)();\n                return;\n            }\n            puVar12 = (puVar14 ^ uVar16) - 4;\n            *((puVar14 ^ uVar16) - 4) = 0xb7bc9ea5;\n            goto code_r0x00402a63;\n        }\n    }\n    uVar20 = uVar9;\n    *(puVar14 + -4) = 0xc;\n    *(puVar14 + -8) = 0x4064e4;\n    *(puVar14 + -0xc) = 10;\n    *(puVar14 + -0x10) = 0x406520;\n    *(puVar14 + -0x14) = 0x402a97;\n    fcn.00404380(*(puVar14 + -0x10), *(puVar14 + -0xc), *(puVar14 + -8), *(puVar14 + -4));\n    *(puVar14 + -4) = extraout_ECX_05;\n    *(puVar14 + -8) = uVar16;\n    bVar18 = false;\n    bVar23 = false;\n    bVar19 = (((extraout_ECX_05 & 0x4ed ^ 0x3f6f) >> 8) + extraout_DH & 0x5bU) == 0;\n    *(puVar14 + -4) = 4;\n    *(puVar14 + -8) = 0x4064f0;\n    *(puVar14 + -0xc) = 10;\n    puVar15 = puVar14 + -0x10;\n    *(puVar14 + -0x10) = 0x406520;\n    *(puVar14 + -0x14) = 0x402acd;\n    fcn.00404380(*(puVar14 + -0x10), *(puVar14 + -0xc), *(puVar14 + -8), *(puVar14 + -4));\n    uVar10 = extraout_EDX_02;\n    if (!bVar23) {\n        *(puVar14 + -0x12) = extraout_EDX_02;\n        uVar10 = extraout_EDX_02 & 0xffff0000 | *(puVar14 + -0x12);\n        if (bVar23) {\n            uVar20 = in(*(puVar14 + -0x12));\n            *puVar17 = uVar20;\n            uVar20 = 0xbc;\n            if (!bVar18 && !bVar19) {\n                return;\n            }\n            goto code_r0x00402ae6;\n        }\n    }\n    *(puVar14 + -0x14) = 9;\n    *(puVar14 + -0x18) = 0x4064f4;\n    puVar15 = puVar14 + -0x1c;\n    *(puVar14 + -0x1c) = 10;\ncode_r0x00402ae6:\n    puVar15[-1] = 0x56;\n    uVar3 = *extraout_ECX_06;\n    *(uVar10 + 10) = *(uVar10 + 10) + (extraout_ECX_06 >> 8);\n    puVar15[-2] = 0x406520;\n    puVar15[-3] = 0x402b04;\n    fcn.00404380(puVar15[-2], puVar15[-1], *puVar15, puVar15[1]);\n    puVar15[5] = extraout_EDX_03;\n    *(puVar15 + 0x12) = CONCAT11(uVar3, uVar20);\n    puVar15[5] = 0x16;\n    puVar15[4] = 0x406500;\n    puVar15[3] = 10;\n    puVar15[2] = 0x406520;\n    puVar15[1] = 0x402b3b;\n    uVar25 = fcn.00404380(puVar15[2], puVar15[3], puVar15[4], puVar15[5]);\n    puVar15[5] = uVar25;\n    puVar15[5] = 7;\n    puVar15[4] = 0x406518;\n    puVar15[3] = 10;\n    puVar15[2] = 0x406520;\n    puVar15[1] = 0x402b5c;\n    fcn.00404380(puVar15[2], puVar15[3], puVar15[4], puVar15[5]);\n    return;\n}\n",
        "token_count": 4197
    },
    "00401950": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040197d) overlaps instruction at (ram,0x0040197b)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nchar * __cdecl fcn.00401950(char *arg_8h, int32_t arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    char *pcVar4;\n    bool bVar5;\n    \n    pcVar1 = arg_8h + (arg_ch - arg_14h);\n    if (((-1 < pcVar1) && (-1 >= pcVar1)) || (arg_14h != 0)) {\n        if (arg_8h <= pcVar1) {\n            do {\n                if (*arg_8h == *arg_10h) {\n                    bVar5 = true;\n                    iVar2 = arg_14h;\n                    pcVar3 = arg_8h;\n                    pcVar4 = arg_10h;\n                    do {\n                        pcVar4 = pcVar4 + 1;\n                        pcVar3 = pcVar3 + 1;\n                        iVar2 = iVar2 + -1;\n                        if (iVar2 == 0) break;\n                        bVar5 = *pcVar3 == *pcVar4;\n                    } while (bVar5);\n                    if (bVar5) {\n                        return arg_8h;\n                    }\n                }\n                arg_8h = arg_8h + 1;\n            } while (arg_8h <= pcVar1);\n        }\n        arg_8h = NULL;\n    }\n    return arg_8h;\n}\n",
        "token_count": 372
    },
    "00401eb0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401f18) overlaps instruction at (ram,0x00401f16)\n// \n\nint32_t __cdecl fcn.00401eb0(uint16_t *arg_8h, uint16_t *arg_ch, int32_t arg_10h)\n\n{\n    uint32_t *puVar1;\n    uint16_t *puVar2;\n    char *unaff_EBX;\n    \n    if (arg_10h != 0) {\n        do {\n            arg_8h = arg_8h + *arg_ch;\n            puVar2 = arg_8h >> 0x10;\n            if (arg_8h >> 0x10 == 0) {\ncode_r0x00401f27:\n                arg_ch = arg_ch + 1;\n            }\n            else if ((arg_8h < 0) || (arg_8h >= 0)) {\n                puVar2 = puVar2 + (arg_8h & 0xffff);\n                arg_8h = puVar2;\n                goto code_r0x00401f27;\n            }\n            *(arg_8h + 0xffffe1) = *(arg_8h + 0xffffe1) + arg_ch;\n            *unaff_EBX = *unaff_EBX + arg_ch;\n            puVar1 = unaff_EBX + 0x2c283c8;\n            *puVar1 = *puVar1 >> 0xe | *puVar1 << 0x12;\n            arg_ch = puVar2;\n        } while (*unaff_EBX != '\\0');\n    }\n    return (arg_8h >> 0x10) + arg_8h;\n}\n",
        "token_count": 375
    },
    "00403200": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403228) overlaps instruction at (ram,0x00403226)\n// \n// WARNING: Removing unreachable block (ram,0x0040326a)\n// WARNING: Removing unreachable block (ram,0x00403277)\n// WARNING: Removing unreachable block (ram,0x00403228)\n\nint32_t __cdecl fcn.00403200(uint arg_8h, int32_t arg_ch, uint *arg_10h, int32_t *arg_14h)\n\n{\n    uint32_t uVar1;\n    uint16_t uVar2;\n    uint32_t extraout_ECX;\n    uint32_t uVar3;\n    int32_t unaff_EBX;\n    uchar **unaff_EBP;\n    int32_t unaff_ESI;\n    uint32_t uVar4;\n    int32_t unaff_EDI;\n    bool bVar5;\n    int32_t iVar6;\n    uchar *puStack4;\n    \n    while( true ) {\n        iVar6 = unaff_EBX;\n        puStack4 = unaff_EBP;\n        uVar2 = fcn.00401eb0(0, arg_8h, arg_ch + 1U >> 1);\n        uVar4 = uVar2;\n        unaff_EDI = (*_sym.imp.dbghelp.dll_ImageNtHeader)(arg_8h, unaff_EDI, unaff_ESI, iVar6);\n        uVar1 = *(unaff_EDI + 0x58);\n        if (uVar2 < uVar1) {\n            uVar4 = uVar4 - uVar1 & 0xffff;\n            bVar5 = SBORROW4(uVar4, 1);\n            unaff_ESI = uVar4 - 1;\n            uVar3 = extraout_ECX;\n        }\n        else {\n            uVar3 = uVar1 & 0xffff;\n            bVar5 = SBORROW4(uVar4, uVar3);\n            unaff_ESI = uVar4 - uVar3;\n        }\n        if ((unaff_ESI == 0 || bVar5 != unaff_ESI < 0) || (unaff_ESI != 0 && bVar5 == unaff_ESI < 0)) break;\n        if (uVar3 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *(unaff_EBX + 0x664951f8) = *(unaff_EBX + 0x664951f8);\n        unaff_EBP = &puStack4;\n    }\n    if (unaff_ESI < uVar1 >> 0x10) {\n        unaff_ESI = (unaff_ESI - (uVar1 >> 0x10) & 0xffff) - 1;\n    }\n    else {\n        unaff_ESI = unaff_ESI - (uVar1 >> 0x10);\n    }\n    *arg_14h = unaff_ESI + arg_ch;\n    *arg_10h = *(unaff_EDI + 0x58);\n    return unaff_EDI;\n}\n",
        "token_count": 699
    },
    "00404050": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004040bf) overlaps instruction at (ram,0x004040b6)\n// \n// WARNING: Removing unreachable block (ram,0x004040b0)\n\nuint __cdecl fcn.00404050(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint var_31ch;\n    uint lpBuffer;\n    uint var_114h;\n    uint var_10h;\n    uint pcbBuffer;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)();\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)();\n        if (iVar1 != 0) {\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 229
    },
    "00403800": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00403800(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    fcn.00401f40();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(*0x10 + -0x110, 4);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00401670();\n        arg_ch_01 = fcn.00401670();\n        arg_ch_02 = fcn.00401670();\n        fcn.004033a0(arg_10h, arg_ch_00);\n        fcn.004033a0(arg_8h, arg_ch_01);\n        fcn.004033a0(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x406028, &lpBuffer, arg_10h);\n        iVar2 = fcn.00401000(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x406034, &lpBuffer, arg_8h);\n            iVar2 = fcn.00401000(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x406034, &lpBuffer, arg_ch);\n                iVar2 = fcn.00401000(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.004033a0(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 613
    },
    "00403960": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403a08) overlaps instruction at (ram,0x00403a07)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint * __cdecl fcn.00403960(uint32_t *arg_8h, uint arg_ch)\n\n{\n    uchar uVar1;\n    uint32_t *puVar2;\n    uint *puVar3;\n    char cVar4;\n    uint32_t in_ECX;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint32_t in_EDX;\n    uint32_t unaff_EBX;\n    uint32_t uVar7;\n    uint *puVar8;\n    uint *puVar9;\n    uint32_t *puVar10;\n    uint32_t uVar11;\n    uint8_t *unaff_EDI;\n    bool bVar12;\n    uint8_t in_AF;\n    bool bVar13;\n    bool bVar14;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    float10 in_ST0;\n    uint8_t uStack20;\n    char cStack19;\n    uint16_t uStack16;\n    uint16_t uStack14;\n    \n    puVar3 = &stack0xfffffffc;\n    uStack16 = unaff_EDI;\n    uStack20 = in_ECX;\n    uVar1 = uStack20;\n    cStack19 = in_ECX >> 8;\n    bVar14 = -1 < (in_ECX - 1U & uStack16 | 0x61be);\n    *arg_8h = 0xc4;\n    uStack20 = arg_8h;\n    if ((bVar14) && (!bVar14)) {\n        *(unaff_EDI + 0x1c) = in_ST0;\n        unaff_EDI = unaff_EDI + 5;\n    }\n    *(arg_8h + 1) = 0x3c;\n    uVar5 = in_ECX & 0xffff0000 | CONCAT11(cStack19 - unaff_EBX, uVar1);\n    *(arg_8h + 2) = 0x39;\n    if ((in_EDX <= uVar5) && (in_EDX > uVar5)) {\n        cVar4 = uStack20 - *unaff_EDI;\n        uStack16 = (in_NT & 1) * 0x4000 | SBORROW1(uStack20, *unaff_EDI) * 0x800 | (in_IF & 1) * 0x200 |\n                   (in_TF & 1) * 0x100 | (cVar4 < '\\0') * 0x80 | (cVar4 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                   ((POPCOUNT(cVar4) & 1U) == 0) * 4 | uStack20 < *unaff_EDI;\n        uStack14 = (in_ID & 1) * 0x20 | (in_VIP & 1) * 0x10 | (in_VIF & 1) * 8 | (in_AC & 1) * 4;\n        func_0x10189930();\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    *(arg_8h + 3) = 0x44;\n    puVar9 = &stack0xfffffffc;\n    if ((uVar5 != in_EDX) && (puVar9 = &stack0xfffffffc,  uVar5 == in_EDX)) {\n        puVar8 = &uStack16;\n        puVar9 = &uStack16;\n        cVar4 = '\\x10';\n        do {\n            puVar3 = puVar3 + -1;\n            puVar8 = puVar8 + -1;\n            *puVar8 = *puVar3;\n            cVar4 = cVar4 + -1;\n        } while ('\\0' < cVar4);\n    }\n    *(arg_8h + 1) = 0x8b;\n    *(arg_8h + 5) = 0x31;\n    bVar14 = false;\n    *(arg_8h + 6) = 0xbb;\n    puVar10 = arg_8h;\n    do {\n        uVar7 = unaff_EBX;\n        uVar5 = in_ECX & 0xffff;\n        if (bVar14) {\n            LOCK();\n            puVar10 = 0x138b2633;\n            arg_8h = arg_8h + 0x658f517f;\n        }\n        *(puVar10 + 7) = 0xd9;\n        *(puVar10 + 2) = 0xbd;\n        uStack14 = in_ECX;\n        uStack16 = uVar7 >> 0x10;\n        uVar6 = in_ECX & 0xffff0000;\n        uVar11 = puVar10 | 0x561b;\n        bVar14 = SBORROW4(uVar11, in_EDX);\n        bVar13 = uVar11 - in_EDX == 0;\n        bVar12 = (POPCOUNT(uVar11 - in_EDX & 0xff) & 1U) == 0;\n        do {\n            unaff_EBX = puVar9[2];\n            *(unaff_EBX + 9) = 0xb;\n            if ((bVar13 || uVar11 < in_EDX) || (!bVar13 && in_EDX <= uVar11)) {\n                *(unaff_EBX + 10) = 0x20;\n                if ((bVar12) || (!bVar12)) {\n                    *(unaff_EBX + 0xb) = 0x12;\n                }\n                else {\n                    puVar10 = 0x34a96cf4;\n                    puVar2 = in_EDX + 1;\n                    puVar9 = *0xc617b43a;\n                    unaff_EBX = unaff_EBX + 1;\n                    in_EDX = arg_8h | *arg_8h;\n                    arg_8h = puVar2;\n                }\n                uStack16 = arg_8h;\n                bVar14 = (POPCOUNT((uStack16 + unaff_EBX | 0x11a9) & 0xff) & 1U) != 0;\n                *(unaff_EBX + 0xc) = 0x1b;\n                if ((bVar14) && (!bVar14)) {\n                    puVar3 = &uStack16;\n                    cVar4 = '\\x1e';\n                    do {\n                        puVar9 = puVar9 + -1;\n                        puVar3 = puVar3 + -1;\n                        *puVar3 = *puVar9;\n                        cVar4 = cVar4 + -1;\n                    } while ('\\0' < cVar4);\n                    puVar3 = in(0x78);\n                    return puVar3;\n                }\n                *(unaff_EBX + 0xd) = 0x15;\n                *(unaff_EBX + 0xe) = 0xd7;\n                uStack14 = uStack16;\n                uStack16 = uVar5;\n                cVar4 = uVar5 + -1;\n                bVar14 = (POPCOUNT(cVar4) & 1U) != 0;\n                *(unaff_EBX + 0xf) = 0xb3;\n                if ((cVar4 != '\\0') && (cVar4 == '\\0')) {\n                    out(*puVar10, in_EDX);\n                }\n                *(unaff_EBX + 0x10) = 0x2a;\n                if ((bVar14) && (!bVar14)) {\n                    puVar3 = &uStack16;\n                    cVar4 = '\\x1e';\n                    do {\n                        puVar9 = puVar9 + -1;\n                        puVar3 = puVar3 + -1;\n                        *puVar3 = *puVar9;\n                        cVar4 = cVar4 + -1;\n                    } while ('\\0' < cVar4);\n                    puVar3 = in(0x78);\n                    return puVar3;\n                }\n                puVar3 = puVar9[3];\n                *puVar3 = 0x11;\n                return puVar3;\n            }\n            in_AF = 9 < (arg_8h & 0xf) | in_AF;\n            arg_8h = arg_8h & 0xffff0000 | CONCAT11((arg_8h >> 8) + in_AF, arg_8h + in_AF * '\\x06') & 0xff0f;\n            if ((uVar6 & 0xffff0000 | uVar5) != 0) {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            uVar6 = 0xffffffff;\n            in_ECX = uVar7;\n        } while (!bVar13);\n    } while( true );\n}\n",
        "token_count": 2042
    },
    "00403be0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00403be0(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00401810;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x406010;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 217
    },
    "00404430": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "004012a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004012fd) overlaps instruction at (ram,0x004012f9)\n// \n// WARNING: Removing unreachable block (ram,0x004012ee)\n\nuint __cdecl fcn.004012a0(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    char extraout_CH;\n    int32_t **unaff_EDI;\n    bool in_OF;\n    \n    if ((!in_OF) && (in_OF)) {\n        LOCK();\n    }\n    piVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(arg_8h, arg_ch, 0xf01ff);\n    if (piVar2 != NULL) {\n        iVar3 = *piVar2;\n        *unaff_EDI = piVar2 + 1;\n        *(iVar3 >> 0x1f) = *(iVar3 >> 0x1f) + extraout_CH;\n        iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(0x6ab8ec44, 0);\n        pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n        if (((iVar3 == 0) && (iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar3 != 0x420)) &&\n           (iVar3 = (*pcVar1)(),  iVar3 != 0x422)) {\n            (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(0x6ab8ec44);\n            return 0;\n        }\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(0x6ab8ec44);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 384
    },
    "004016a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004016a0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x406010, 0x41fab0, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 139
    },
    "00401af0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401b2a) overlaps instruction at (ram,0x00401b28)\n// \n\nvoid __cdecl fcn.00401af0(uint arg_8h, uint arg_ch, uint *arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    unkbyte3 Var4;\n    char cVar5;\n    uint32_t in_EAX;\n    uint32_t uVar6;\n    char *in_EDX;\n    uint8_t unaff_BL;\n    uint *puVar7;\n    uint *puVar8;\n    uint *puVar9;\n    bool bVar10;\n    uint8_t in_AF;\n    bool bVar11;\n    uint auStack24 [2];\n    uint32_t uVar3;\n    \n    puVar8 = &stack0xfffffffc;\n    uVar6 = 0;\n    uVar2 = arg_14h;\n    if (arg_14h != 0) {\n        do {\n            bVar11 = uVar2 < 0;\n            bVar10 = (POPCOUNT(uVar2 & 0xff) & 1U) == 0;\n            if ((bVar10) || (!bVar10)) {\n                unaff_BL = *(uVar6 + arg_10h);\n            }\n            else {\n                out(*arg_10h, in_EDX);\n                do {\n                    cVar5 = in_EAX >> 8;\n                    in_AF = 9 < (in_EAX & 0xf) | in_AF;\n                    Var4 = CONCAT21(in_EAX >> 0x10, cVar5 - in_AF);\n                    in_EAX = CONCAT31(Var4, -in_AF);\n                } while (in_AF || cVar5 == *in_EDX);\n                puVar1 = arg_14h + in_EDX * 2;\n                uVar2 = *puVar1;\n                uVar3 = *puVar1;\n                *puVar1 = (uVar3 + 0x7b) - in_AF;\n                *(uVar6 - 0x76) = in_EAX;\n                cVar5 = (-in_AF + -0x31) - (uVar2 < 0xffffff85 || uVar3 + 0x7b < in_AF);\n                in_EAX = CONCAT31(Var4, cVar5);\n                bVar11 = cVar5 < '\\0';\n                arg_10h = arg_10h + 1;\n            }\n            if ((bVar11) || (!bVar11)) {\n                in_EDX = NULL;\n                in_EAX = uVar6;\n            }\n            in_EDX = CONCAT44(in_EDX, in_EAX + 0xd233c18b) % puVar8[3];\n            in_EAX = puVar8[2];\n            unaff_BL = unaff_BL ^ in_EDX[in_EAX];\n            puVar9 = puVar8;\n            if ((unaff_BL != 0) && (unaff_BL == 0)) {\n                puVar7 = auStack24 + 1;\n                puVar9 = auStack24 + 1;\n                cVar5 = '\\x10';\n                do {\n                    puVar8 = puVar8 + -1;\n                    puVar7 = puVar7 + -1;\n                    *puVar7 = *puVar8;\n                    cVar5 = cVar5 + -1;\n                } while ('\\0' < cVar5);\n            }\n            *(uVar6 + arg_10h) = unaff_BL;\n            uVar6 = uVar6 + 1;\n            puVar8 = puVar9;\n            uVar2 = uVar6 - arg_14h;\n        } while (uVar6 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 841
    },
    "00401b60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain pusha popa sequence"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401b60(uint arg_8h, uint arg_ch)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    uint var_4h;\n    \n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)();\n    fcn.004017a0(hSCManager, arg_8h);\n    uVar1 = fcn.00401350(hSCManager, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 141
    },
    "00401bf0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401ce6) overlaps instruction at (ram,0x00401ce4)\n// \n// WARNING (jumptable): Unable to track spacebase fully for stack\n// WARNING (jumptable): Heritage AFTER dead removal. Example location: s0x00000000 : 0x00401dc8\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.00401bf0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBX;\n    uint *puVar4;\n    uint uVar5;\n    uint *puVar6;\n    bool bVar7;\n    uchar lpBuffer;\n    uint var_213h;\n    uchar s;\n    uint var_10fh;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar4 = &stack0xfffffffc;\n    lpBuffer = 0;\n    puVar6 = &var_213h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    s = 0;\n    puVar6 = &var_10fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    var_ch = 1;\n    *(puVar6 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x406034, &lpBuffer);\n    fcn.00403b60(&var_4h);\n    uVar2 = fcn.00404430(arg_8h, arg_ch, arg_10h, arg_14h, var_4h);\n    bVar7 = (POPCOUNT(uVar2 & 0xff) & 1U) == 0;\n    if (uVar2 == 0) {\n        return 0;\n    }\n    if ((-1 < uVar2) && (-1 >= uVar2)) {\n    // WARNING: Could not recover jumptable at 0x00401cea. Too many branches\n    // WARNING: Treating indirect jump as call\n        iVar3 = (**(unaff_EBX + 0x41fab4))();\n        return iVar3;\n    }\n    *0x41fab4 = fcn.00401710();\n    if ((!bVar7) && (bVar7)) {\n        puVar6 = &stack0xfffffdd0;\n        cVar1 = '\\x1e';\n        do {\n            puVar4 = puVar4 + -1;\n            puVar6 = puVar6 + -1;\n            *puVar6 = *puVar4;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        iVar3 = in(0x78);\n        return iVar3;\n    }\n    iVar3 = fcn.00403700(&s, var_4h, var_8h);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    fcn.00403590();\n    iVar3 = fcn.004019f0(0x40606c);\n    if (iVar3 == -1) {\n        iVar3 = fcn.004019f0(0x406060);\n        if (iVar3 == -1) goto code_r0x00401dde;\n        uVar5 = 0xf;\n    }\n    else {\n        uVar5 = 0xe;\n    }\n    iVar3 = fcn.00403410(arg_8h);\n    if (iVar3 != 0) {\n        fcn.00401070();\n        fcn.004015c0(uVar5);\n        return 1;\n    }\n    if (*0x41fab4 == 0) {\n        return 0;\n    }\ncode_r0x00401dde:\n    iVar3 = fcn.00401b60(arg_8h, &s);\n    if (iVar3 == 0) {\n        var_ch = 0;\n    }\n    bVar7 = var_ch == 0;\n    if (!bVar7) {\n        iVar3 = fcn.00402f00(arg_8h);\n        bVar7 = iVar3 == 0;\n        if (bVar7) {\n            var_ch = 0;\n        }\n    }\n    if ((!bVar7) && (bVar7)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    if (var_ch == 0) {\n        var_ch = fcn.00402d80(arg_8h, 0);\n    }\n    if (var_ch != 0) {\n        fcn.004015c0();\n    }\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    (*_sym.imp.KERNEL32.dll_WinExec)(0x406080, 0);\n    return var_ch;\n}\n",
        "token_count": 1211
    },
    "00401f40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00401f40(void)\n\n{\n    uint uVar1;\n    \n    if (*0x41fab8 == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x41fab8 = 1;\n    }\n    return;\n}\n",
        "token_count": 84
    },
    "00402cf0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file",
            "write file on Windows"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402cf0(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    if (iVar1 != 0) {\n        (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, iVar1);\n        (*_sym.imp.MSVCRT.dll_fflush)(iVar1);\n        (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 132
    },
    "00402f00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402f00(uint arg_8h)\n\n{\n    uint arg_8h_00;\n    uint uVar1;\n    \n    arg_8h_00 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    uVar1 = fcn.004012a0(arg_8h_00, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(arg_8h_00);\n    return uVar1;\n}\n",
        "token_count": 119
    },
    "00402f60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402f60(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "00403110": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "set registry value",
            "delete registry key"
        ],
        "decompiled_code": "\nvoid fcn.00403110(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint uStack332;\n    uint uStack328;\n    uint uStack324;\n    uint uStack320;\n    uint uStack316;\n    uint uStack312;\n    uint uStack308;\n    uint uStack304;\n    uchar *puStack300;\n    uchar *puStack296;\n    uchar uStack276;\n    uint uStack275;\n    uint uStack271;\n    uint uStack267;\n    ushort uStack263;\n    uchar uStack261;\n    uchar uStack260;\n    uint uStack259;\n    \n    uStack275 = 0;\n    uStack271 = 0;\n    uStack267 = 0;\n    uStack276 = 0;\n    uStack263 = 0;\n    uStack260 = 0;\n    uStack261 = 0;\n    puVar4 = &stack0xfffffefd;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    fcn.00401f40();\n    puStack296 = 0x40315a;\n    fcn.004033a0(&stack0xfffffeec, 5);\n    pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n    puStack296 = &stack0xfffffefc;\n    puStack300 = 0x403174;\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    puStack296 = 0x403187;\n    (*_sym.imp.SHLWAPI.dll_SHDeleteKeyA)();\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    puStack300 = &stack0xfffffee4;\n    puStack296 = 0x10;\n    uStack304 = 1;\n    uStack308 = 0x41fab0;\n    uStack312 = 0x40636c;\n    uStack316 = 0x80000000;\n    uStack320 = 0x4031a7;\n    (*_sym.imp.SHLWAPI.dll_SHSetValueA)();\n    uStack320 = 0x4b;\n    uStack324 = 0x4063a0;\n    uStack328 = 1;\n    uStack332 = 0x41fab0;\n    (*pcVar2)(0x80000000, &stack0xfffffedc);\n    (*pcVar1)(&stack0xfffffec4, 0x4063ec, &stack0xfffffeb4);\n    (*pcVar2)(0x80000000, &stack0xfffffec4, 0x406428, 1, 0x406430, 0x14);\n    return;\n}\n",
        "token_count": 650
    },
    "00403340": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403340(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    uint arg_8h_00;\n    uint arg_ch_00;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    uchar *puVar5;\n    bool bVar6;\n    \n    arg_ch_00 = arg_ch;\n    arg_8h_00 = arg_8h;\n    puVar3 = &stack0xfffffffc;\n    iVar2 = fcn.00403200(arg_8h, arg_ch, &arg_8h, &arg_ch);\n    bVar6 = iVar2 == 0;\n    if (bVar6) {\n        return 0;\n    }\n    puVar5 = &stack0xfffffffc;\n    if ((!bVar6) && (puVar5 = &stack0xfffffffc,  bVar6)) {\n        puVar4 = &stack0xfffffff0;\n        puVar5 = &stack0xfffffff0;\n        cVar1 = '\\x10';\n        do {\n            puVar3 = puVar3 + -1;\n            puVar4 = puVar4 + -1;\n            *puVar4 = *puVar3;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    *(iVar2 + 0x58) = *(puVar5 + 0xc);\n    if ((!bVar6) && (bVar6)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    fcn.00403200(arg_8h_00, arg_ch_00, puVar5 + 8, puVar5 + 0xc);\n    return 1;\n}\n",
        "token_count": 393
    },
    "004033a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004033e4) overlaps instruction at (ram,0x004033e3)\n// \n\nvoid __cdecl fcn.004033a0(uint8_t *arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_EAX;\n    code *pcVar2;\n    uint32_t uVar3;\n    \n    uVar3 = 0;\n    uVar1 = arg_ch;\n    if (arg_ch != 0) {\n        do {\n            if ((uVar1 < 0) || (uVar1 >= 0)) {\n                pcVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n            }\n            else {\n                *arg_8h = *arg_8h & 0xc3;\n                pcVar2 = sym.imp.MSVCRT.dll_rand + uVar3;\n                uVar3 = in_EAX + 0xe40ce22a;\n            }\n            in_EAX = pcVar2 / 0x1a;\n            arg_8h[uVar3] = pcVar2 % 0x1a + 0x61;\n            uVar3 = uVar3 + 1;\n            uVar1 = uVar3 - arg_ch;\n        } while (uVar3 < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 295
    },
    "00403410": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool __cdecl fcn.00403410(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00402d80(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 68
    },
    "00403440": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403493) overlaps instruction at (ram,0x00403492)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t fcn.00403440(void)\n\n{\n    uint8_t *puVar1;\n    uint *puVar2;\n    uint32_t uVar3;\n    uint *puVar4;\n    uchar uVar5;\n    bool bVar6;\n    uint var_4h;\n    \n    puVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    puVar4 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (puVar2 == NULL) {\n        return 0;\n    }\n    uVar5 = 0;\n    bVar6 = false;\n    *0x41fabc = (*_sym.imp.KERNEL32.dll_GetProcAddress)(puVar2, 0x406118);\n    if ((bVar6) || (!bVar6)) {\n        *0x41fac0 = (*puVar4)(puVar2, 0x406134);\n    }\n    else {\n        uVar3 = *0x41fabc + 1;\n        *puVar2 = *puVar4;\n        puVar1 = puVar2 + 3;\n        uVar5 = 0x97 < *puVar1;\n        *puVar1 = *puVar1 + 0x68;\n        *0x41fac0 = uVar3 & 0xffffff00 | -uVar5;\n        puVar4 = puVar4 + 1;\n        puVar2 = puVar2 + 1;\n    }\n    if (!uVar5) {\n        if (uVar5) {\n            out(0xbd, *0x41fac0);\n            return *0x41fac0;\n        }\n    }\n    *0x41fac4 = (*puVar4)(puVar2, 0x406144);\n    if (((*0x41fabc != 0) && (*0x41fac0 != 0)) && (*0x41fac4 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 473
    },
    "00403590": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "set registry value"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004035f4) overlaps instruction at (ram,0x004035f3)\n// \n\nbool fcn.00403590(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t extraout_ECX;\n    uint32_t uVar3;\n    char *pcVar4;\n    uint8_t *unaff_EBX;\n    char *pcVar5;\n    bool bVar6;\n    ulong uVar7;\n    char *var_4h;\n    \n    var_4h = NULL;\n    uVar7 = fcn.00404050(&var_4h);\n    if (uVar7 == 0) {\n        return false;\n    }\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    bVar6 = (POPCOUNT(*(unaff_EBX + -0x3f7a03bb) - extraout_ECX & 0xff) & 1U) == 0;\n    if (*(unaff_EBX + -0x3f7a03bb) - extraout_ECX == 0) {\n        return false;\n    }\n    if ((bVar6) || (uVar3 = extraout_ECX,  pcVar4 = uVar7 >> 0x20,  !bVar6)) {\n        uVar3 = 0xffffffff;\n        pcVar4 = var_4h;\n    }\n    *(unaff_EBX + -0x367c03ab) = 0xffffffff;\n    pcVar5 = pcVar4;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar5;\n        pcVar5 = pcVar5 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x406208, 0x406248, 1, pcVar4, ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 462
    },
    "00403b60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403b91) overlaps instruction at (ram,0x00403b8f)\n// \n// WARNING: Removing unreachable block (ram,0x00403b8e)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.00403b60(uint *param_1, uint *param_2)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar uStack108;\n    uint uStack107;\n    uint uStack8;\n    \n    uStack8 = 0;\n    uStack108 = 0;\n    puVar2 = &uStack107;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00403960(&uStack108, &uStack8);\n    fcn.00401af0(&uStack108, uStack8, 0x40652c, 0xa560);\n    *param_1 = 0x40652c;\n    *param_2 = 0xa560;\n    return;\n}\n",
        "token_count": 290
    },
    "00403c40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403d1a) overlaps instruction at (ram,0x00403d16)\n// \n\nuint __cdecl fcn.00403c40(uint arg_8h)\n\n{\n    uint8_t uVar1;\n    int16_t iVar2;\n    uint8_t uVar3;\n    ushort extraout_CX;\n    int32_t iVar4;\n    uint extraout_ECX;\n    int32_t extraout_EDX;\n    int32_t *piVar5;\n    int32_t unaff_EBX;\n    uint *puVar6;\n    bool bVar7;\n    char cVar8;\n    char cVar9;\n    unkbyte10 extraout_ST0;\n    ulong uVar10;\n    uchar lpBuffer;\n    uint var_20fh;\n    uchar s;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    lpBuffer = 0;\n    puVar6 = &var_20fh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    s = 0;\n    puVar6 = &var_10bh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    iVar2 = (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x406028, &lpBuffer, arg_8h);\n    uVar1 = (unaff_EBX ^ 0x70c5) - iVar2 >> 8 | extraout_CX >> 8;\n    uVar3 = extraout_CX;\n    bVar7 = uVar1 < uVar3;\n    cVar9 = SBORROW1(uVar1, uVar3);\n    cVar8 = uVar1 - uVar3 < '\\0';\n    fcn.004042f0(&var_4h, &var_8h);\n    if ((!bVar7) && (bVar7)) {\n        piVar5 = unaff_EBX + 0x69 + extraout_EDX * 4;\n        iVar4 = unaff_EBX + *piVar5;\n        cVar9 = SCARRY4(unaff_EBX, *piVar5) != SCARRY4(iVar4, bVar7);\n        cVar8 = iVar4 + bVar7 < 0;\n    }\n    uVar10 = fcn.00403d70(var_4h);\n    piVar5 = uVar10 >> 0x20;\n    if ((cVar9 == cVar8) && (cVar9 != cVar8)) {\n        *(uVar10 + -0x7ce92414) = extraout_ST0;\n        *piVar5 = *piVar5 + 0x4d8bdf84;\n        var_8h = extraout_ECX;\n    }\n    iVar4 = fcn.00402cf0(&s, 0x406048, var_4h, var_8h);\n    if (iVar4 != 0) {\n        fcn.00402b70(&s, 0xffffffff);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 816
    },
    "00403f30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040401c) overlaps instruction at (ram,0x00404019)\n// \n// WARNING: Variable defined which should be unmapped: var_2h\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00403f30(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    int32_t iVar1;\n    uchar *puVar2;\n    bool bVar3;\n    uint var_10h;\n    uchar *var_ch;\n    int32_t var_8h;\n    uint var_2h;\n    \n    var_8h = 0;\n    if (0 < arg_14h) {\n        var_ch = 0x1;\n        iVar1 = arg_14h * 2;\n        do {\n            bVar3 = (iVar1 >> 8 & var_8h) != 6;\n            puVar2 = var_ch;\n            if ((bVar3) && (!bVar3)) {\n                puVar2 = var_ch + 1;\n                out(*var_ch, var_ch % arg_ch & 0xff00 | *(var_ch % arg_ch + arg_8h));\n            }\n            var_10h._0_1_ = arg_14h * 2;\n            var_ch[arg_18h + -1] = var_10h ^ *(var_8h + arg_10h) ^ *((puVar2 + -1) % arg_ch + arg_8h);\n            var_ch[arg_18h] = var_10h ^ 0x72;\n            iVar1 = var_8h + 1;\n            var_ch = var_ch + 2;\n            var_8h = iVar1;\n        } while (iVar1 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 432
    },
    "00404140": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004042ba) overlaps instruction at (ram,0x004042b8)\n// \n// WARNING: Removing unreachable block (ram,0x00404189)\n// WARNING: Removing unreachable block (ram,0x00404292)\n// WARNING: Removing unreachable block (ram,0x004041b0)\n// WARNING: Removing unreachable block (ram,0x004041d7)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nulong __cdecl fcn.00404140(uchar *arg_8h, uint *arg_ch)\n\n{\n    char cVar1;\n    uint16_t uVar2;\n    uint uVar3;\n    uchar *puVar4;\n    uchar *puVar5;\n    uint32_t in_EDX;\n    int16_t unaff_BX;\n    uint *puVar6;\n    uint *puVar7;\n    uchar *unaff_ESI;\n    uchar *unaff_EDI;\n    uint16_t in_ES;\n    ushort in_SS;\n    bool in_PF;\n    bool bVar8;\n    uint uStack24;\n    \n    puVar6 = &stack0xfffffffc;\n    if ((!in_PF) && (in_PF)) {\n        puVar7 = &stack0xffffffec;\n        cVar1 = '\\x1e';\n        do {\n            puVar6 = puVar6 + -1;\n            puVar7 = puVar7 + -1;\n            *puVar7 = *puVar6;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar3 = in(0x78);\n        return CONCAT44(in_EDX, uVar3);\n    }\n    *arg_8h = 200;\n    arg_8h[1] = 0x74;\n    arg_8h[2] = 0x3a;\n    arg_8h[3] = 0xf9;\n    arg_8h[4] = 0x34;\n    uVar2 = arg_8h;\n    bVar8 = -1 < (uVar2 + unaff_BX | 0x11a9);\n    arg_8h[5] = 9;\n    puVar5 = unaff_EDI;\n    if ((bVar8) && (!bVar8)) {\n        in_SS = SUB42(unaff_EDI, 0);\n        puVar5 = unaff_EDI & 0xffff0000 | in_ES;\n        unaff_ESI = unaff_ESI + -1;\n        *(unaff_EDI | &stack0xfffffffc) = arg_8h;\n        in_EDX = in_EDX & 0xffffff00;\n        uVar2 = arg_8h + (arg_8h >> 8) * 'y';\n    }\n    arg_8h[6] = 0x2b;\n    uVar2 = uVar2 + unaff_BX | 0x11a9;\n    bVar8 = (POPCOUNT(uVar2 & 0xff) & 1U) == 0;\n    arg_8h[7] = 0x59;\n    puVar4 = puVar5;\n    if ((uVar2 != 0) && (uVar2 == 0)) {\n        puVar4 = puVar5 & 0xe2f4cc58;\n        bVar8 = (POPCOUNT(puVar5 & 0x58) & 1U) == 0;\n    }\n    arg_8h[8] = 0xc1;\n    if ((!bVar8) && (bVar8)) {\n        puVar6 = segment(in_SS, *0x10 + -0xc);\n        in_EDX = 0xb7bc9ea5;\n        if (bVar8) {\n            return CONCAT44(0xb7bc9ea5, *puVar6);\n        }\n        puVar4 = *puVar6;\n    }\n    arg_8h[9] = 0x9f;\n    arg_8h[10] = 0xf4;\n    uVar2 = puVar4 + unaff_BX | 0x11a9;\n    bVar8 = uVar2 == 0;\n    arg_8h[0xb] = 0x97;\n    if ((uVar2 < 0) || (uVar2 >= 0)) {\n        arg_8h[0xc] = 0x79;\n        puVar5 = puVar4;\n    }\n    else {\n        bVar8 = (unaff_ESI | 0x79) == 0;\n        puVar5 = unaff_ESI | 0x79;\n        unaff_ESI = puVar4;\n    }\n    if ((!bVar8) && (bVar8)) {\n        puVar5 = puVar5 & 0xffffff00 | *0x4bb148d3;\n        out(*unaff_ESI, in_EDX);\n    }\n    *arg_ch = 0xd;\n    return CONCAT44(in_EDX, puVar5);\n}\n",
        "token_count": 1113
    },
    "004042f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00404312)\n\nvoid __cdecl fcn.004042f0(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00404140(&var_68h, &var_4h);\n    fcn.00401af0(&var_68h, var_4h, 0x410a8c, 0xf000);\n    *arg_8h = 0x410a8c;\n    *arg_ch = 0xf000;\n    return;\n}\n",
        "token_count": 256
    },
    "00404380": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "encode data using XOR"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404380(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = 0;\n    if (0 < arg_14h) {\n        do {\n            *(iVar1 + arg_10h) = arg_14h ^ *(iVar1 + arg_10h) ^ *(iVar1 % arg_ch + arg_8h);\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 136
    },
    "00401810": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401810(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    if (arg_ch == 1) {\n        fcn.00401f90();\n        fcn.00402f90();\n        if (*0x41fab4 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.004010a0();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 138
    },
    "004015d0": {
        "rules": [
            "create or open registry key"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401626) overlaps instruction at (ram,0x00401623)\n// \n// WARNING: Removing unreachable block (ram,0x0040161a)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.004015d0(uint param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EDI;\n    bool in_SF;\n    float10 in_ST0;\n    uint uStack8;\n    \n    uVar2 = 1;\n    if ((!in_SF) && (in_SF)) {\n        *(unaff_EDI + 0x1c) = in_ST0;\n        uVar2 = 6;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(param_1, param_2, 0, 0xf003f, &uStack8);\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(uStack8, param_3, 0, param_4);\n        if (iVar1 != 0) {\n            uVar2 = 0;\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(uStack8);\n        return uVar2;\n    }\n    return 0;\n}\n",
        "token_count": 315
    },
    "00401070": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00401070(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x406208, 0x40624c, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 78
    },
    "00401350": {
        "rules": [
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004013b4)\n\nuint __cdecl fcn.00401350(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, arg_10h, 0, 0, 0, 0, 0);\n    if (iVar1 != 0) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 154
    },
    "004017a0": {
        "rules": [
            "get service handle",
            "delete service"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004017f8) overlaps instruction at (ram,0x004017f4)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint * __cdecl fcn.004017a0(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    uint *puVar3;\n    \n    puVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (puVar2 != NULL) {\n        puVar3 = (*_sym.imp.ADVAPI32.dll_DeleteService)(puVar2);\n        *puVar3 = *puVar2;\n        pcVar1 = _sym.imp.ADVAPI32.dll_CloseServiceHandle;\n        puVar3[-1] = 0x4017ff;\n        (*pcVar1)();\n        return puVar3 + 1;\n    }\n    return NULL;\n}\n",
        "token_count": 215
    }
}