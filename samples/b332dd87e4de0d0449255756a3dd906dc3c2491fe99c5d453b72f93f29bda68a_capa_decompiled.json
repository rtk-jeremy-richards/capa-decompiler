{
    "null": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "1400010b": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint64_t fcn.1400010be(ulong arg1, ulong noname_1, ulong noname_2, ulong arg4)\n\n{\n    int32_t iVar1;\n    uint64_t uVar2;\n    uint32_t uVar3;\n    int64_t iVar4;\n    bool bVar5;\n    uint32_t auStack60 [3];\n    uint32_t *puStack48;\n    uchar auStack40 [12];\n    uint32_t uStack28;\n    uint uStack24;\n    \n    iVar4 = 0;\n    uStack24 = 0;\n    _auStack40 = ZEXT816(0);\n    puStack48 = auStack60;\n    auStack60[0] = 0;\n    iVar1 = (*_sym.imp.USER32.dll_EnumWindows)();\n    uVar2 = 0x14000f020;\n    do {\n        *(auStack40 + *(iVar4 + 0x14000f020) * 4) = *(auStack40 + *(iVar4 + 0x14000f020) * 4) ^ 0x1e27;\n        iVar4 = iVar4 + 4;\n    } while (iVar4 != 0x10);\n    uVar3 = 0x2e15;\n    bVar5 = true;\n    do {\n        do {\n            while (0x7793 < uVar3) {\n                if (uVar3 == 0x7794) {\n                    return uVar2 & 0xffffffffffffff01;\n                }\n                if (uVar3 == 0x7e1d) {\n                    uVar2 = 0;\n                    uVar3 = auStack40._8_4_;\ncode_r0x00014000118b:\n                    uVar3 = uVar3 ^ 0x6995;\n                }\n            }\n            if (uVar3 == 0x28d2) {\n                uVar2 = arg4 & 0xffffff00 | arg1 < auStack60[0];\n                uVar3 = uStack28;\n                goto code_r0x00014000118b;\n            }\n        } while (uVar3 != 0x2e15);\n        if (bVar5) {\n            iVar4 = 0;\n            do {\n                auStack40[*(iVar4 + 0x14000f014) * 4] = auStack40[*(iVar4 + 0x14000f014) * 4] ^ 0x26;\n                iVar4 = iVar4 + 4;\n            } while (iVar4 != 0xc);\n        }\n        uVar3 = 0x36f5;\n        if (iVar1 == ((~*0x140059ec0 & *0x140059ec4) + *0x140059ec0) - (*0x140059ec4 | *0x140059ec0)) {\n            uVar3 = 0x603a;\n        }\n        uVar3 = uVar3 ^ auStack40._0_4_;\n        bVar5 = false;\n    } while( true );\n}\n",
        "token_count": 676
    },
    "1400011d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187"
        ],
        "decompiled_code": "\nuint64_t fcn.1400011da(ulong noname_0, ulong noname_1, uint64_t arg3)\n\n{\n    bool bVar1;\n    int64_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    char cVar7;\n    uint32_t uVar8;\n    uint8_t uVar9;\n    int32_t iVar10;\n    uint64_t uVar11;\n    uint64_t uVar12;\n    bool bVar13;\n    int32_t iStack120;\n    int32_t iStack116;\n    int32_t *piStack112;\n    uint32_t auStack104 [4];\n    uint32_t uStack88;\n    uint32_t uStack84;\n    uint uStack80;\n    \n    uStack80 = 0;\n    uStack88 = 0;\n    uStack84 = 0;\n    auStack104[0] = 0;\n    auStack104[1] = 0;\n    auStack104[2] = 0;\n    auStack104[3] = 0;\n    uVar3 = *0x7ffe0324 * *0x7ffe0004 * 0x100;\n    uVar12 = arg3 & 0xffffffffffffff00 | *0x140059ed9;\n    uVar9 = *0x140059ed9 ^ *0x140059ed8;\n    cVar7 = *0x140059ed8 - *0x140059ed9;\n    iVar4 = (uVar3 | 0xd084d4ea) + (uVar3 | 0x2f7b2b15);\n    uVar11 = 0xd084d4ec;\n    uVar3 = iVar4 + 0xd084d4ec;\n    uVar6 = *0x7ffe0320 * *0x7ffe0004 >> 0x18;\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    iVar5 = *0x7ffe0324 * *0x7ffe0004 * 0x100;\n    uVar8 = -(*0x7ffe0320 * *0x7ffe0004 >> 0x18);\n    iVar5 = (*0x7ffe0324 * *0x7ffe0004 * -0x100 ^ uVar8) + (iVar5 - (iVar5 - 1U & uVar8)) * 2;\n    iVar10 = (((~uVar6 - uVar3) - (uVar3 & ~uVar6)) - (0x2f7b2b13U - iVar4 & uVar6)) + (uVar6 ^ uVar3) + iVar5 +\n             -0x2f7b2b14;\n    iVar4 = -iVar10;\n    if (0 < iVar10) {\n        iVar4 = iVar10;\n    }\n    uVar8 = ~*0x140059edc & *0x140059ee0;\n    uVar3 = ~*0x140059ee0 | *0x140059edc;\n    iVar2 = 0;\n    do {\n        auStack104[*(iVar2 + 0x14000f050)] = auStack104[*(iVar2 + 0x14000f050)] ^ 0x1e27;\n        iVar2 = iVar2 + 4;\n    } while (iVar2 != 0x18);\n    uVar6 = 0x7e1d;\n    bVar13 = true;\n    bVar1 = false;\ncode_r0x000140001343:\n    do {\ncode_r0x000140001356:\n        if (0x6dc3 < uVar6) {\n            if (uVar6 == 0x6dc4) {\n                uVar12 = 0;\n                uVar6 = uStack88 ^ 0x13f2;\n                goto code_r0x000140001356;\n            }\n            if (uVar6 == 0x7794) {\n                uVar11 = 0;\n                uVar6 = auStack104[2] ^ 0x1f18;\n                goto code_r0x000140001356;\n            }\n            if (uVar6 == 0x7e1d) break;\n            goto code_r0x000140001356;\n        }\n        if (uVar6 == 0x119) {\n            return uVar11 & 0xffffffffffffff01;\n        }\n        if (uVar6 == 0x476) {\n            uVar11 = uVar12 & 0xffffff01;\n            uVar6 = uStack84 ^ 0x169d;\n            goto code_r0x000140001356;\n        }\n        if (uVar6 != 0x16dd) goto code_r0x000140001356;\n        piStack112 = &iStack120;\n        iStack120 = (*0x140059eec - *0x140059ef0) + ~(*0x140059ef0 ^ *0x140059eec) + (~*0x140059ef0 | *0x140059eec) * -2\n                    + 7;\n        (*_sym.imp.USER32.dll_GetLastInputInfo)();\n        if (!bVar1) {\n            iVar2 = 0;\n            do {\n                auStack104[*(iVar2 + 0x14000f068)] = auStack104[*(iVar2 + 0x14000f068)] ^ 0x985;\n                iVar2 = iVar2 + 4;\n            } while (iVar2 != 8);\n        }\n        uVar6 = 0x1a77;\n        if (9000 < iVar5 - iStack116) {\n            uVar6 = 0x73c5;\n        }\n        uVar6 = uVar6 ^ auStack104[3];\n        bVar1 = true;\n        uVar12 = uVar12 & 0xffffffffffffff00 | cVar7 + ~uVar9;\n    } while( true );\n    if (bVar13) {\n        iVar2 = 0;\n        do {\n            *(auStack104 + *(iVar2 + 0x14000f030)) = *(auStack104 + *(iVar2 + 0x14000f030)) ^ 0x26;\n            iVar2 = iVar2 + 4;\n        } while (iVar2 != 0x14);\n    }\n    uVar6 = 0x8fa;\n    if (iVar4 < uVar3 + uVar8 + 0x1389) {\n        uVar6 = 0x69b3;\n    }\n    uVar6 = uVar6 ^ auStack104[0];\n    bVar13 = false;\n    goto code_r0x000140001343;\n}\n",
        "token_count": 1484
    },
    "140006dc": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_bp_8h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nint32_t fcn.140006dc4(ulong arg1, ulong noname_1, int64_t arg3, ulong *arg4)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    uint uVar4;\n    uint uVar5;\n    uint *puVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint *arg2;\n    uint *puVar9;\n    uint *puVar10;\n    uint *puVar11;\n    int64_t iVar12;\n    int64_t iStackX24;\n    ulong *puStackX32;\n    uchar auStack56 [4];\n    uint uStack52;\n    uint auStack48 [2];\n    uchar var_bp_20h [4];\n    ulong **var_1ch;\n    ulong var_10h;\n    ulong var_bp_8h;\n    \n    iStackX24 = arg3;\n    puStackX32 = arg4;\n    fcn.140006d0c(arg3, *arg4);\n    uVar7 = fcn.140006a18(arg1);\n    if (uVar7 == *(*(iStackX24 + 0x88) + 4)) {\n        return 0;\n    }\n    arg2 = fcn.1400087ec(0x228);\n    if (arg2 != NULL) {\n        iVar12 = 4;\n        puVar10 = *(iStackX24 + 0x88);\n        puVar6 = arg2;\n        do {\n            puVar11 = puVar6;\n            puVar9 = puVar10;\n            uVar3 = puVar9[1];\n            uVar4 = puVar9[2];\n            uVar5 = puVar9[3];\n            *puVar11 = *puVar9;\n            puVar11[1] = uVar3;\n            puVar11[2] = uVar4;\n            puVar11[3] = uVar5;\n            uVar3 = puVar9[5];\n            uVar4 = puVar9[6];\n            uVar5 = puVar9[7];\n            puVar11[4] = puVar9[4];\n            puVar11[5] = uVar3;\n            puVar11[6] = uVar4;\n            puVar11[7] = uVar5;\n            uVar3 = puVar9[9];\n            uVar4 = puVar9[10];\n            uVar5 = puVar9[0xb];\n            puVar11[8] = puVar9[8];\n            puVar11[9] = uVar3;\n            puVar11[10] = uVar4;\n            puVar11[0xb] = uVar5;\n            uVar3 = puVar9[0xd];\n            uVar4 = puVar9[0xe];\n            uVar5 = puVar9[0xf];\n            puVar11[0xc] = puVar9[0xc];\n            puVar11[0xd] = uVar3;\n            puVar11[0xe] = uVar4;\n            puVar11[0xf] = uVar5;\n            uVar3 = puVar9[0x11];\n            uVar4 = puVar9[0x12];\n            uVar5 = puVar9[0x13];\n            puVar11[0x10] = puVar9[0x10];\n            puVar11[0x11] = uVar3;\n            puVar11[0x12] = uVar4;\n            puVar11[0x13] = uVar5;\n            uVar3 = puVar9[0x15];\n            uVar4 = puVar9[0x16];\n            uVar5 = puVar9[0x17];\n            puVar11[0x14] = puVar9[0x14];\n            puVar11[0x15] = uVar3;\n            puVar11[0x16] = uVar4;\n            puVar11[0x17] = uVar5;\n            uVar3 = puVar9[0x19];\n            uVar4 = puVar9[0x1a];\n            uVar5 = puVar9[0x1b];\n            puVar11[0x18] = puVar9[0x18];\n            puVar11[0x19] = uVar3;\n            puVar11[0x1a] = uVar4;\n            puVar11[0x1b] = uVar5;\n            uVar3 = puVar9[0x1d];\n            uVar4 = puVar9[0x1e];\n            uVar5 = puVar9[0x1f];\n            puVar11[0x1c] = puVar9[0x1c];\n            puVar11[0x1d] = uVar3;\n            puVar11[0x1e] = uVar4;\n            puVar11[0x1f] = uVar5;\n            iVar12 = iVar12 + -1;\n            puVar10 = puVar9 + 0x20;\n            puVar6 = puVar11 + 0x20;\n        } while (iVar12 != 0);\n        uVar3 = puVar9[0x21];\n        uVar4 = puVar9[0x22];\n        uVar5 = puVar9[0x23];\n        puVar11[0x20] = puVar9[0x20];\n        puVar11[0x21] = uVar3;\n        puVar11[0x22] = uVar4;\n        puVar11[0x23] = uVar5;\n        uVar3 = puVar9[0x25];\n        uVar4 = puVar9[0x26];\n        uVar5 = puVar9[0x27];\n        puVar11[0x24] = puVar9[0x24];\n        puVar11[0x25] = uVar3;\n        puVar11[0x26] = uVar4;\n        puVar11[0x27] = uVar5;\n        *(puVar11 + 0x28) = *(puVar9 + 0x28);\n        *arg2 = 0;\n        iVar8 = fcn.140006770(uVar7, arg2);\n        if (iVar8 != -1) {\n            if (noname_1 == '\\0') {\n                fcn.140005024();\n            }\n            piVar2 = *(iStackX24 + 0x88);\n            LOCK();\n            iVar1 = *piVar2;\n            *piVar2 = *piVar2 + -1;\n            if ((iVar1 == 1) && (*(iStackX24 + 0x88) != 0x14005a020)) {\n                fcn.1400080ec(*(iStackX24 + 0x88));\n            }\n            *arg2 = 1;\n            puVar10 = NULL;\n            *(iStackX24 + 0x88) = arg2;\n            arg2 = puVar10;\n            if (((*(iStackX24 + 0x3a8) & 2) == 0) && ((*0x14005a8a0 & 1) == 0)) {\n                _var_bp_20h = &iStackX24;\n                unique0x00003100 = &puStackX32;\n                uStack52 = 5;\n                auStack48[0] = 5;\n                fcn.140006f88(auStack56, auStack48, var_bp_20h, &uStack52);\n                if (noname_1 != '\\0') {\n                    *0x14005a6d0 = *puStackX32;\n                    arg2 = NULL;\n                }\n            }\n            goto code_r0x000140006ebc;\n        }\n        puVar10 = fcn.140008584();\n        *puVar10 = 0x16;\n    }\n    iVar8 = -1;\ncode_r0x000140006ebc:\n    fcn.1400080ec(arg2);\n    return iVar8;\n}\n",
        "token_count": 1822
    },
    "14000bc3": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187"
        ],
        "decompiled_code": "\nuint8_t * fcn.14000bc30(uint8_t *arg1, uint8_t *arg2)\n\n{\n    uint *puVar1;\n    uint8_t *puVar2;\n    int64_t aiStack40 [2];\n    int64_t iStack24;\n    char cStack16;\n    \n    if ((arg1 == NULL) || (arg2 == NULL)) {\n        puVar1 = fcn.140008584();\n        *puVar1 = 0x16;\n        fcn.140005d80();\n    }\n    else if (arg1 < arg2) {\n        fcn.140004c90(aiStack40, 0);\n        if (*(iStack24 + 8) == 0) {\n            arg2 = arg2 + -1;\n        }\n        else {\n            puVar2 = arg2 + -1;\n            do {\n                puVar2 = puVar2 + -1;\n                if (puVar2 < arg1) break;\n            } while ((*(*puVar2 + 0x19 + iStack24) & 4) != 0);\n            arg2 = arg2 + (-1 - (arg2 - puVar2 & 1));\n        }\n        if (cStack16 == '\\0') {\n            return arg2;\n        }\n        *(aiStack40[0] + 0x3a8) = *(aiStack40[0] + 0x3a8) & 0xfffffffd;\n        return arg2;\n    }\n    return NULL;\n}\n",
        "token_count": 329
    },
    "14000c15": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: lpMode\n// WARNING: Variable defined which should be unmapped: var_bp_20h\n// WARNING: Variable defined which should be unmapped: lpNumberOfBytesWritten\n\nint32_t fcn.14000c154(int64_t arg1, uint16_t *arg2, ulong arg3)\n\n{\n    char cVar1;\n    uint16_t uVar2;\n    uint16_t uVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    int64_t iVar8;\n    ulong *puVar9;\n    uint *puVar10;\n    uint32_t uVar11;\n    uint64_t arg1_00;\n    uint16_t *puVar12;\n    uint64_t arg4;\n    int64_t iVar13;\n    int64_t iVar14;\n    uint64_t uVar15;\n    ulong uVar16;\n    uint uStack104;\n    int32_t iStack100;\n    int32_t iStack96;\n    uint32_t uStack88;\n    int32_t iStack84;\n    int32_t iStack80;\n    int64_t iStack64;\n    ulong lpNumberOfBytesWritten;\n    ulong var_bp_20h;\n    ulong lpMode;\n    ulong var_8h;\n    \n    arg4 = arg3;\n    uVar15 = arg1;\n    if (arg3 == 0) {\n        return 0;\n    }\n    if (arg2 == NULL) {\ncode_r0x00014000c188:\n        puVar7 = fcn.1400085a4(arg1);\n        *puVar7 = 0;\n        puVar7 = fcn.140008584();\n        *puVar7 = 0x16;\n        fcn.140005d80();\n        return -1;\n    }\n    iVar13 = uVar15 >> 6;\n    iVar14 = (arg1 & 0x3f) * 0x40;\n    arg1 = *(iVar13 * 8 + 0x14005b0e0);\n    cVar1 = *(arg1 + 0x39 + iVar14);\n    iStack64 = iVar13;\n    if ((cVar1 - 1U < 2) && ((~arg3 & 1) == 0)) goto code_r0x00014000c188;\n    puVar12 = arg2;\n    if ((*(arg1 + 0x38 + iVar14) & 0x20) != 0) {\n        puVar12 = NULL;\n        fcn.14000cfbc(uVar15 & 0xffffffff, 0, 2);\n    }\n    uStack88 = 0;\n    arg1_00 = uVar15 & 0xffffffff;\n    iStack84 = 0;\n    iStack80 = 0;\n    iVar5 = fcn.14000b128(arg1_00);\n    if (((iVar5 == 0) || ((*(*(iVar13 * 8 + 0x14005b0e0) + 0x38 + iVar14) & 0x80) == 0)) ||\n       ((iVar8 = fcn.1400078cc(arg1_00, puVar12),  *(*(iVar8 + 0x90) + 0x138) == 0 &&\n        (*(*(iVar13 * 8 + 0x14005b0e0) + 0x39 + iVar14) == '\\0')))) {\ncode_r0x00014000c319:\n        iVar8 = *(iVar13 * 8 + 0x14005b0e0);\n        if ((*(iVar8 + 0x38 + iVar14) & 0x80) == 0) {\n            puVar7 = *(iVar8 + 0x28 + iVar14);\n            uStack104 = 0;\n            iStack100 = 0;\n            iStack96 = 0;\n            iVar6 = (*_sym.imp.KERNEL32.dll_WriteFile)(puVar7, arg2, arg4, &iStack100, 0);\n            iVar5 = iStack96;\n            if (iVar6 == 0) {\n                uStack104 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                iVar5 = iStack96;\n            }\n            goto code_r0x00014000c3b2;\n        }\n        if (cVar1 == '\\0') {\n            puVar7 = &uStack104;\n            puVar9 = fcn.14000c678(puVar7, uVar15 & 0xffffffff, arg2, arg4);\n        }\n        else {\n            uVar11 = cVar1 - 1;\n            puVar7 = uVar11;\n            if (uVar11 == 0) {\n                puVar7 = &uStack104;\n                puVar9 = fcn.14000c898(puVar7, uVar15 & 0xffffffff, arg2, arg4);\n            }\n            else {\n                iVar5 = iStack80;\n                if (uVar11 != 1) goto code_r0x00014000c3bc;\n                puVar7 = &uStack104;\n                puVar9 = fcn.14000c77c(puVar7, uVar15 & 0xffffffff, arg2, arg4);\n            }\n        }\ncode_r0x00014000c30d:\n        uVar16 = *puVar9;\n        iVar5 = *(puVar9 + 1);\n    }\n    else {\n        puVar7 = *(*(iVar13 * 8 + 0x14005b0e0) + 0x28 + iVar14);\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetConsoleMode)();\n        if (iVar5 == 0) goto code_r0x00014000c319;\n        if (cVar1 == '\\0') {\n            puVar7 = &uStack104;\n            puVar9 = fcn.14000c450(puVar7, uVar15 & 0xffffffff, arg2, arg4);\n            goto code_r0x00014000c30d;\n        }\n        iVar5 = iStack80;\n        if (1 < cVar1 - 1U) goto code_r0x00014000c3bc;\n        uStack104 = 0;\n        iStack100 = 0;\n        iStack96 = 0;\n        puVar12 = arg2;\n        iVar13 = iStack64;\n        iVar5 = iStack96;\n        if (arg2 < arg2 + arg4) {\n            do {\n                iVar6 = iStack100;\n                uVar2 = *puVar12;\n                puVar7 = uVar2;\n                uVar3 = fcn.14000d6e4();\n                if (uVar3 != uVar2) {\ncode_r0x00014000c2e6:\n                    uStack104 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    iVar13 = iStack64;\n                    break;\n                }\n                iStack100 = iVar6 + 2;\n                if (uVar2 == 10) {\n                    puVar7 = 0xd;\n                    iVar4 = fcn.14000d6e4();\n                    if (iVar4 != 0xd) goto code_r0x00014000c2e6;\n                    iStack100 = iVar6 + 3;\n                    iVar5 = iVar5 + 1;\n                }\n                puVar12 = puVar12 + 1;\n                iVar13 = iStack64;\n            } while (puVar12 < arg2 + arg4);\n        }\ncode_r0x00014000c3b2:\n        uVar16 = CONCAT44(iStack100, uStack104);\n    }\n    uStack88 = uVar16;\n    iStack84 = uVar16 >> 0x20;\ncode_r0x00014000c3bc:\n    if (iStack84 != 0) {\n        return iStack84 - iVar5;\n    }\n    if (uStack88 != 0) {\n        if (uStack88 == 5) {\n            puVar10 = fcn.140008584();\n            *puVar10 = 9;\n            puVar7 = fcn.1400085a4(puVar7);\n            *puVar7 = 5;\n            return -1;\n        }\n        fcn.1400085c4(uStack88);\n        return -1;\n    }\n    if (((*(*(iVar13 * 8 + 0x14005b0e0) + 0x38 + iVar14) & 0x40) != 0) && (*arg2 == '\\x1a')) {\n        return 0;\n    }\n    puVar10 = fcn.140008584();\n    *puVar10 = 0x1c;\n    puVar7 = fcn.1400085a4(puVar7);\n    *puVar7 = 0;\n    return -1;\n}\n",
        "token_count": 1970
    },
    "14000dab": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nulong fcn.14000dab8(int64_t arg1)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    uint32_t auStackX8 [2];\n    uchar auStackX16 [8];\n    uint32_t auStackX24 [2];\n    uint32_t auStackX32 [2];\n    uint32_t *apuStack24 [3];\n    \n    auStackX8[0] = arg1;\n    if (auStackX8[0] == 0xfffffffe) {\n        puVar1 = fcn.1400085a4(arg1);\n        *puVar1 = 0;\n        puVar1 = fcn.140008584();\n        *puVar1 = 9;\n    }\n    else {\n        if (((-1 < auStackX8[0]) && (auStackX8[0] < *0x14005b4e0)) &&\n           (arg1 = (auStackX8[0] & 0x3f) * 0x40,  (*(*((auStackX8[0] >> 6) * 8 + 0x14005b0e0) + 0x38 + arg1) & 1) != 0))\n        {\n            apuStack24[0] = auStackX8;\n            auStackX24[0] = auStackX8[0];\n            auStackX32[0] = auStackX8[0];\n            uVar2 = fcn.14000dc18(auStackX16, auStackX32, apuStack24, auStackX24);\n            return uVar2;\n        }\n        puVar1 = fcn.1400085a4(arg1);\n        *puVar1 = 0;\n        puVar1 = fcn.140008584();\n        *puVar1 = 9;\n        fcn.140005d80();\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 424
    },
    "1400014a": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t * fcn.1400014a0(int64_t arg1, ulong arg2, ulong arg3)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    bool bVar3;\n    uint32_t uVar4;\n    int64_t iVar5;\n    uint32_t *puVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    int32_t iVar12;\n    uint32_t uVar13;\n    uint32_t unaff_R13D;\n    uint32_t unaff_R15D;\n    uint32_t uStack188;\n    uchar auStack168 [12];\n    uint32_t uStack156;\n    uint32_t uStack152;\n    uint32_t uStack148;\n    uint32_t uStack144;\n    uint32_t uStack140;\n    uint32_t uStack136;\n    uint32_t uStack132;\n    uint uStack128;\n    ulong uStack112;\n    ulong uStack104;\n    ulong uStack96;\n    ulong uStack88;\n    ulong uStack80;\n    int64_t iStack72;\n    \n    uStack112 = arg2;\n    iStack72 = arg1;\n    uStack136 = 0;\n    uStack132 = 0;\n    uStack128 = 0;\n    uStack152 = SUB164(ZEXT816(0), 0);\n    uStack152 = 0;\n    uStack148 = SUB164(ZEXT816(0) >> 0x20, 0);\n    uStack148 = 0;\n    uStack144 = 0;\n    uStack140 = 0;\n    _auStack168 = ZEXT816(0);\n    uVar10 = *0x140059f00 ^ *0x140059efc;\n    uVar13 = ~*0x140059f00 | *0x140059efc;\n    uVar4 = ~*0x140059efc | *0x140059f00;\n    iVar5 = 0;\n    do {\n        *(auStack168 + *(iVar5 + 0x14000f0a0) * 4) = *(auStack168 + *(iVar5 + 0x14000f0a0) * 4) ^ 0x1e27;\n        iVar5 = iVar5 + 4;\n    } while (iVar5 != 0x28);\n    iVar2 = uStack112;\n    uVar7 = iVar2 + 0x5cd38d53;\n    auStack168._0_4_ = 0x6dc4;\n    bVar3 = false;\n    uStack80 = 0;\n    uStack88 = 0;\n    uStack96 = 0;\n    puVar6 = NULL;\n    uStack104 = 0;\n    do {\n        while( true ) {\n            while( true ) {\n                while( true ) {\n                    while( true ) {\n                        if (0x5038 < auStack168._0_4_) break;\n                        if (auStack168._0_4_ < 0x22f1) {\n                            if (auStack168._0_4_ == 0x119) {\n                                if (uStack80 == '\\0') {\n                                    iVar5 = 0;\n                                    do {\n                                        *(auStack168 + *(iVar5 + 0x14000f0d0) * 4) =\n                                             *(auStack168 + *(iVar5 + 0x14000f0d0) * 4) ^ 0x52f6;\n                                        iVar5 = iVar5 + 4;\n                                    } while (iVar5 != 0x20);\n                                }\n                                auStack168._0_4_ = 0x4ff1;\n                                if (unaff_R15D <\n                                    ((((uVar7 * 2 - iVar2) + (uVar7 ^ 0x5cd38d53)) - (0x232c72acU - iVar2 | 0xa32c72ac))\n                                    - (uVar7 | 0x5cd38d53)) + 0x4658e558) {\n                                    auStack168._0_4_ = 0x4e38;\n                                }\n                                auStack168._0_4_ = auStack168._0_4_ ^ auStack168._8_4_;\n                                uStack80 = 0x4e01;\n                            }\n                            else if (auStack168._0_4_ == 0xbb5) {\n                                unaff_R13D = unaff_R13D + 1;\n                                auStack168._0_4_ = uStack140 ^ 0x77c1;\n                            }\n                        }\n                        else if (auStack168._0_4_ == 0x22f1) {\n                            iVar12 = *(iStack72 + unaff_R15D * 4);\n                            uVar1 = *(iStack72 + unaff_R13D * 4);\n                            uVar9 = iVar12 + 0x79c2e7b5;\n                            uVar11 = uVar9 & uVar1;\n                            iVar8 = uVar1 - uVar11;\n                            iVar12 = uVar11 + iVar12 + (~uVar1 | uVar9);\n                            uVar9 = iVar12 + iVar8 * 2 + 0x79c2e7b6;\n                            if (uStack104 == '\\0') {\n                                iVar5 = 0;\n                                do {\n                                    *(auStack168 + *(iVar5 + 0x14000f1cc) * 4) =\n                                         *(auStack168 + *(iVar5 + 0x14000f1cc) * 4) ^ 0x2e15;\n                                    iVar5 = iVar5 + 4;\n                                } while (iVar5 != 8);\n                            }\n                            auStack168._0_4_ = 0x6c50;\n                            if (iVar12 + iVar8 * 2 + (uVar9 & 0x79c2e7b4) + (~uVar9 | 0x863d184b) + 2 == arg3) {\n                                auStack168._0_4_ = 0x148;\n                            }\n                            auStack168._0_4_ = auStack168._0_4_ ^ uStack148;\n                            uStack104 = 0x101;\n                        }\n                        else if (auStack168._0_4_ == 0x3958) {\n                            uVar9 = (unaff_R15D ^ 0x71a7e26d) + unaff_R15D * 2 + (unaff_R15D ^ 0x8e581d92) + uStack188 +\n                                    0x8e581d94;\n                            unaff_R15D = (uVar9 | 1) + (uVar9 | 0xfffffffe) + 0x71a7e270;\n                            auStack168._0_4_ = uStack136 ^ 0x66fc;\n                        }\n                        else if (auStack168._0_4_ == 0x3e31) {\n                            if (uStack96 == '\\0') {\n                                iVar5 = 0;\n                                do {\n                                    *(auStack168 + *(iVar5 + 0x14000f104) * 4) =\n                                         *(auStack168 + *(iVar5 + 0x14000f104) * 4) ^ 0x2297;\n                                    iVar5 = iVar5 + 4;\n                                } while (iVar5 != 0x10);\n                            }\n                            auStack168._0_4_ = 0x7c2a;\n                            if (unaff_R13D < uStack112) {\n                                auStack168._0_4_ = 0x6783;\n                            }\n                            auStack168._0_4_ = auStack168._0_4_ ^ uStack152;\n                            uStack96 = 0x6701;\n                        }\n                    }\n                    if (0x66ac < auStack168._0_4_) break;\n                    if (auStack168._0_4_ == 0x5039) {\n                        uStack188 = ~unaff_R15D;\n                        if (uStack88 == '\\0') {\n                            iVar5 = 0;\n                            do {\n                                *(auStack168 + *(iVar5 + 0x14000f0f0) * 4) =\n                                     *(auStack168 + *(iVar5 + 0x14000f0f0) * 4) ^ 0x985;\n                                iVar5 = iVar5 + 4;\n                            } while (iVar5 != 0x14);\n                        }\n                        unaff_R13D = (uStack188 & 0x1dc72554) + (unaff_R15D & 0x1dc72554) + unaff_R15D + 0xe238daad;\n                        auStack168._0_4_ = uStack156 ^ 0x72c6;\n                        uStack88 = 0x7201;\n                    }\n                    else if (auStack168._0_4_ == 0x51f0) {\n                        auStack168._0_4_ = uStack132 ^ 0x3064;\n                        puVar6 = NULL;\n                    }\n                }\n                if (auStack168._0_4_ != 0x66ad) break;\n                puVar6 = fcn.14000620c(8);\n                *puVar6 = unaff_R15D;\n                puVar6[1] = unaff_R13D;\n                auStack168._0_4_ = uStack144 ^ 0x3563;\n            }\n            if (auStack168._0_4_ != 0x6dc4) break;\n            unaff_R15D = uVar4 + uVar13 + uVar10 + 2;\n            if (!bVar3) {\n                iVar5 = 0;\n                do {\n                    auStack168[*(iVar5 + 0x14000f070) * 4] = auStack168[*(iVar5 + 0x14000f070) * 4] ^ 0x26;\n                    iVar5 = iVar5 + 4;\n                } while (iVar5 != 0x24);\n            }\n            auStack168._0_4_ = auStack168._0_4_ ^ 0x1f3e;\n            bVar3 = true;\n        }\n    } while (auStack168._0_4_ != 0x7c93);\n    return puVar6;\n}\n",
        "token_count": 2317
    },
    "14000368": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint64_t fcn.140003684(void)\n\n{\n    int16_t *piVar1;\n    uint64_t uVar2;\n    int32_t *piVar3;\n    \n    piVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    if ((((piVar1 == NULL) || (*piVar1 != 0x5a4d)) || (piVar3 = *(piVar1 + 0x1e) + piVar1,  *piVar3 != 0x4550)) ||\n       ((piVar1 = 0x20b,  *(piVar3 + 6) != 0x20b || (piVar3[0x21] < 0xf)))) {\n        uVar2 = piVar1 & 0xffffffffffffff00;\n    }\n    else {\n        uVar2 = CONCAT71(2, piVar3[0x3e] != 0);\n    }\n    return uVar2;\n}\n",
        "token_count": 213
    },
    "140004b2": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nulong fcn.140004b28(void)\n\n{\n    char cVar1;\n    ulong uVar2;\n    int64_t *piVar3;\n    bool bVar4;\n    \n    piVar3 = 0x14000f340;\n    do {\n        if ((*piVar3 != 0) && (cVar1 = (**0x14005d008)(),  cVar1 == '\\0')) break;\n        piVar3 = piVar3 + 2;\n    } while (piVar3 != 0x14000f430);\n    if (piVar3 == 0x14000f430) {\n        uVar2 = 1;\n    }\n    else {\n        if (piVar3 != 0x14000f340) {\n            piVar3 = piVar3 + -1;\n            do {\n                if ((piVar3[-1] != 0) && (*piVar3 != 0)) {\n                    (**0x14005d008)(0);\n                }\n                bVar4 = piVar3 != 0x14000f348;\n                piVar3 = piVar3 + -2;\n            } while (bVar4);\n        }\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 271
    },
    "140004b5": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.140004b50(int32_t **arg1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint64_t uVar3;\n    uint64_t uVar4;\n    \n    uVar4 = 0;\n    uVar3 = arg1 + 1 + (7 - arg1) >> 3;\n    if (arg1 + 1 < arg1) {\n        uVar3 = uVar4;\n    }\n    if (uVar3 != 0) {\n        do {\n            piVar2 = *arg1;\n            LOCK();\n            iVar1 = *piVar2;\n            *piVar2 = *piVar2 + -1;\n            if ((iVar1 == 1) && (*arg1 != 0x14005a020)) {\n                fcn.1400080ec(*arg1);\n                *arg1 = 0x14005a020;\n            }\n            arg1 = arg1 + 1;\n            uVar4 = uVar4 + 1;\n        } while (uVar4 != uVar3);\n    }\n    return;\n}\n",
        "token_count": 242
    },
    "140004d3": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x000140004e75)\n// WARNING: Removing unreachable block (ram,0x000140004e82)\n// WARNING: Removing unreachable block (ram,0x000140004e8c)\n// WARNING: Removing unreachable block (ram,0x000140004e9b)\n// WARNING: Removing unreachable block (ram,0x000140004ea6)\n// WARNING: Removing unreachable block (ram,0x000140004eaf)\n// WARNING: Removing unreachable block (ram,0x000140004eb8)\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.140004d38(void)\n\n{\n    code *pcVar1;\n    uint auStackX16 [2];\n    int32_t aiStackX24 [2];\n    ulong var_28h;\n    uchar var_30h [4];\n    ulong var_2ch;\n    uint *var_20h;\n    int32_t *var_bp_18h;\n    ulong *var_bp_10h;\n    \n    aiStackX24[0] = 1;\n    auStackX16[0] = 0;\n    var_20h = auStackX16;\n    var_28h._0_1_ = 0;\n    var_bp_18h = aiStackX24;\n    var_bp_10h = &var_28h;\n    var_2ch._0_4_ = 2;\n    var_2ch._4_4_ = 2;\n    fcn.140004fec(var_30h, &var_2ch + 4, &var_20h, &var_2ch);\n    if (aiStackX24[0] == 0) {\n        fcn.140004e00(0);\n        pcVar1 = swi(3);\n        (*pcVar1)();\n        return;\n    }\n    return;\n}\n",
        "token_count": 408
    },
    "140006d0": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t * fcn.140006d0c(int64_t arg1, int32_t *arg2)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t *piVar3;\n    \n    if (((*(arg1 + 0x3a8) & *0x14005a8a0) == 0) || (*(arg1 + 0x90) == 0)) {\n        fcn.14000780c(5);\n        piVar3 = *(arg1 + 0x88);\n        if (piVar3 != arg2) {\n            if (piVar3 != NULL) {\n                LOCK();\n                iVar1 = *piVar3;\n                *piVar3 = *piVar3 + -1;\n                if ((iVar1 == 1) && (piVar3 != 0x14005a020)) {\n                    fcn.1400080ec(piVar3);\n                }\n            }\n            *(arg1 + 0x88) = arg2;\n            LOCK();\n            *arg2 = *arg2 + 1;\n            piVar3 = arg2;\n        }\n        fcn.140007828(5);\n    }\n    else {\n        piVar3 = *(arg1 + 0x88);\n    }\n    if (piVar3 == NULL) {\n        fcn.14000638c();\n        pcVar2 = swi(3);\n        piVar3 = (*pcVar2)();\n        return piVar3;\n    }\n    return piVar3;\n}\n",
        "token_count": 331
    },
    "140006f8": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.140006f88(ulong noname_0, uint32_t *arg2, int64_t **arg3, uint32_t *arg4)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    uint uVar4;\n    uint uVar5;\n    int64_t iVar6;\n    uint *puVar7;\n    uint *puVar8;\n    uint *puVar9;\n    \n    fcn.14000780c(*arg2);\n    puVar9 = *(**arg3 + 0x88) + 0x18;\n    if (*0x14005acd0 == NULL) {\ncode_r0x000140007036:\n        puVar9 = fcn.140008584();\n        *puVar9 = 0x16;\n        fcn.140005d80();\n    }\n    else {\n        if (puVar9 == NULL) {\n            fcn.140004690(*0x14005acd0, 0, 0x101);\n            goto code_r0x000140007036;\n        }\n        iVar6 = 2;\n        puVar8 = *0x14005acd0;\n        do {\n            uVar3 = puVar9[1];\n            uVar4 = puVar9[2];\n            uVar5 = puVar9[3];\n            *puVar8 = *puVar9;\n            puVar8[1] = uVar3;\n            puVar8[2] = uVar4;\n            puVar8[3] = uVar5;\n            uVar3 = puVar9[5];\n            uVar4 = puVar9[6];\n            uVar5 = puVar9[7];\n            puVar8[4] = puVar9[4];\n            puVar8[5] = uVar3;\n            puVar8[6] = uVar4;\n            puVar8[7] = uVar5;\n            uVar3 = puVar9[9];\n            uVar4 = puVar9[10];\n            uVar5 = puVar9[0xb];\n            puVar8[8] = puVar9[8];\n            puVar8[9] = uVar3;\n            puVar8[10] = uVar4;\n            puVar8[0xb] = uVar5;\n            uVar3 = puVar9[0xd];\n            uVar4 = puVar9[0xe];\n            uVar5 = puVar9[0xf];\n            puVar8[0xc] = puVar9[0xc];\n            puVar8[0xd] = uVar3;\n            puVar8[0xe] = uVar4;\n            puVar8[0xf] = uVar5;\n            uVar3 = puVar9[0x11];\n            uVar4 = puVar9[0x12];\n            uVar5 = puVar9[0x13];\n            puVar8[0x10] = puVar9[0x10];\n            puVar8[0x11] = uVar3;\n            puVar8[0x12] = uVar4;\n            puVar8[0x13] = uVar5;\n            uVar3 = puVar9[0x15];\n            uVar4 = puVar9[0x16];\n            uVar5 = puVar9[0x17];\n            puVar8[0x14] = puVar9[0x14];\n            puVar8[0x15] = uVar3;\n            puVar8[0x16] = uVar4;\n            puVar8[0x17] = uVar5;\n            uVar3 = puVar9[0x19];\n            uVar4 = puVar9[0x1a];\n            uVar5 = puVar9[0x1b];\n            puVar8[0x18] = puVar9[0x18];\n            puVar8[0x19] = uVar3;\n            puVar8[0x1a] = uVar4;\n            puVar8[0x1b] = uVar5;\n            puVar7 = puVar8 + 0x20;\n            uVar3 = puVar9[0x1d];\n            uVar4 = puVar9[0x1e];\n            uVar5 = puVar9[0x1f];\n            puVar8[0x1c] = puVar9[0x1c];\n            puVar8[0x1d] = uVar3;\n            puVar8[0x1e] = uVar4;\n            puVar8[0x1f] = uVar5;\n            puVar9 = puVar9 + 0x20;\n            iVar6 = iVar6 + -1;\n            puVar8 = puVar7;\n        } while (iVar6 != 0);\n        *puVar7 = *puVar9;\n    }\n    iVar6 = 2;\n    puVar9 = *(**arg3 + 0x88) + 0x119;\n    if (*0x14005acd8 != NULL) {\n        puVar8 = *0x14005acd8;\n        if (puVar9 != NULL) {\n            do {\n                uVar3 = puVar9[1];\n                uVar4 = puVar9[2];\n                uVar5 = puVar9[3];\n                *puVar8 = *puVar9;\n                puVar8[1] = uVar3;\n                puVar8[2] = uVar4;\n                puVar8[3] = uVar5;\n                uVar3 = puVar9[5];\n                uVar4 = puVar9[6];\n                uVar5 = puVar9[7];\n                puVar8[4] = puVar9[4];\n                puVar8[5] = uVar3;\n                puVar8[6] = uVar4;\n                puVar8[7] = uVar5;\n                uVar3 = puVar9[9];\n                uVar4 = puVar9[10];\n                uVar5 = puVar9[0xb];\n                puVar8[8] = puVar9[8];\n                puVar8[9] = uVar3;\n                puVar8[10] = uVar4;\n                puVar8[0xb] = uVar5;\n                uVar3 = puVar9[0xd];\n                uVar4 = puVar9[0xe];\n                uVar5 = puVar9[0xf];\n                puVar8[0xc] = puVar9[0xc];\n                puVar8[0xd] = uVar3;\n                puVar8[0xe] = uVar4;\n                puVar8[0xf] = uVar5;\n                uVar3 = puVar9[0x11];\n                uVar4 = puVar9[0x12];\n                uVar5 = puVar9[0x13];\n                puVar8[0x10] = puVar9[0x10];\n                puVar8[0x11] = uVar3;\n                puVar8[0x12] = uVar4;\n                puVar8[0x13] = uVar5;\n                uVar3 = puVar9[0x15];\n                uVar4 = puVar9[0x16];\n                uVar5 = puVar9[0x17];\n                puVar8[0x14] = puVar9[0x14];\n                puVar8[0x15] = uVar3;\n                puVar8[0x16] = uVar4;\n                puVar8[0x17] = uVar5;\n                uVar3 = puVar9[0x19];\n                uVar4 = puVar9[0x1a];\n                uVar5 = puVar9[0x1b];\n                puVar8[0x18] = puVar9[0x18];\n                puVar8[0x19] = uVar3;\n                puVar8[0x1a] = uVar4;\n                puVar8[0x1b] = uVar5;\n                uVar3 = puVar9[0x1d];\n                uVar4 = puVar9[0x1e];\n                uVar5 = puVar9[0x1f];\n                puVar8[0x1c] = puVar9[0x1c];\n                puVar8[0x1d] = uVar3;\n                puVar8[0x1e] = uVar4;\n                puVar8[0x1f] = uVar5;\n                puVar9 = puVar9 + 0x20;\n                iVar6 = iVar6 + -1;\n                puVar8 = puVar8 + 0x20;\n            } while (iVar6 != 0);\n            goto code_r0x0001400070e3;\n        }\n        fcn.140004690(*0x14005acd8, 0, 0x100);\n    }\n    puVar9 = fcn.140008584();\n    *puVar9 = 0x16;\n    fcn.140005d80();\ncode_r0x0001400070e3:\n    piVar2 = **arg3[1];\n    LOCK();\n    iVar1 = *piVar2;\n    *piVar2 = *piVar2 + -1;\n    if ((iVar1 == 1) && (**arg3[1] != 0x14005a020)) {\n        fcn.1400080ec(**arg3[1]);\n    }\n    **arg3[1] = *(**arg3 + 0x88);\n    LOCK();\n    **(**arg3 + 0x88) = **(**arg3 + 0x88) + 1;\n    fcn.140007828(*arg4);\n    return;\n}\n",
        "token_count": 2165
    },
    "1400082a": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nulong fcn.1400082a8(uint64_t arg1)\n\n{\n    uint8_t uVar1;\n    bool bVar2;\n    uint *puVar3;\n    int64_t iVar4;\n    uint64_t uVar5;\n    int8_t iVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint64_t noname_0;\n    uint64_t noname_0_00;\n    uint64_t in_RDX;\n    code *arg2;\n    uint32_t uVar9;\n    uint64_t *puVar10;\n    uint64_t uVar11;\n    uint64_t *puVar12;\n    uint uStackX24;\n    uint64_t uStackX32;\n    uint64_t *puVar13;\n    \n    iVar7 = arg1;\n    noname_0_00 = arg1 & 0xffffffff;\n    puVar13 = NULL;\n    puVar12 = NULL;\n    uStackX24 = 0;\n    bVar2 = true;\n    uVar9 = noname_0_00;\n    if (iVar7 == 2) {\ncode_r0x000140008363:\n        noname_0 = iVar7 - 2U;\n        if (iVar7 - 2U == 0) {\n            puVar10 = 0x14005b4f0;\n        }\n        else {\n            noname_0 = iVar7 - 6U;\n            if (iVar7 - 6U == 0) {\ncode_r0x000140008380:\n                puVar10 = 0x14005b500;\n                puVar12 = puVar13;\n            }\n            else {\n                noname_0 = iVar7 - 0xfU;\n                if (iVar7 - 0xfU == 0) {\n                    puVar10 = 0x14005b508;\n                }\n                else {\n                    uVar8 = iVar7 - 0x15;\n                    noname_0 = uVar8;\n                    if (uVar8 == 0) {\n                        puVar10 = 0x14005b4f8;\n                        puVar12 = puVar13;\n                    }\n                    else {\n                        if (uVar8 == 1) goto code_r0x000140008380;\n                        puVar10 = NULL;\n                        puVar12 = puVar13;\n                    }\n                }\n            }\n        }\n    }\n    else {\n        if (iVar7 != 4) {\n            if (iVar7 != 6) {\n                if ((iVar7 == 8) || (iVar7 == 0xb)) goto code_r0x0001400082fc;\n                if ((iVar7 != 0xf) && (1 < iVar7 - 0x15U)) goto code_r0x000140008340;\n            }\n            goto code_r0x000140008363;\n        }\ncode_r0x0001400082fc:\n        puVar12 = fcn.140007a40(arg1, in_RDX);\n        if (puVar12 == NULL) {\n            return 0xffffffff;\n        }\n        noname_0 = *puVar12;\n        in_RDX = *0x14000f4f0 * 0x10 + noname_0;\n        for (; noname_0 != in_RDX; noname_0 = noname_0 + 0x10) {\n            if (*(noname_0 + 4) == uVar9) goto code_r0x000140008334;\n        }\n        noname_0 = 0;\ncode_r0x000140008334:\n        if (noname_0 == 0) {\ncode_r0x000140008340:\n            puVar3 = fcn.140008584();\n            *puVar3 = 0x16;\n            fcn.140005d80();\n            return 0xffffffff;\n        }\n        puVar10 = noname_0 + 8;\n        bVar2 = false;\n    }\n    uStackX32 = 0;\n    if (bVar2) {\n        fcn.14000780c(3);\n        uVar8 = *0x14005a000 & 0x3f;\n        noname_0 = uVar8;\n        iVar6 = uVar8;\n        in_RDX = (*0x14005a000 ^ *puVar10) >> iVar6 | (*0x14005a000 ^ *puVar10) << 0x40 - iVar6;\n        uVar11 = in_RDX;\n    }\n    else {\n        uVar11 = *puVar10;\n    }\n    if (uVar11 == 1) goto code_r0x0001400084b6;\n    if (uVar11 == 0) {\n        if (bVar2) {\n            fcn.140007828(3);\n        }\n        noname_0 = 3;\n        fcn.140004d2c(3);\n    }\n    if ((uVar9 < 0xc) && ((0x910U >> (uVar9 & 0x1f) & 1) != 0)) {\n        uStackX32 = puVar12[1];\n        puVar12[1] = 0;\n        if (uVar9 == 8) {\n            iVar4 = fcn.1400078cc(noname_0, in_RDX);\n            uStackX24 = *(iVar4 + 0x10);\n            iVar4 = fcn.1400078cc(noname_0, in_RDX);\n            *(iVar4 + 0x10) = 0x8c;\n            goto code_r0x000140008459;\n        }\n    }\n    else {\ncode_r0x000140008459:\n        if (uVar9 == 8) {\n            uVar5 = *0x14000f4f8 * 0x10 + *puVar12;\n            noname_0 = *0x14000f500 * 0x10 + uVar5;\n            for (; uVar5 != noname_0; uVar5 = uVar5 + 0x10) {\n                *(uVar5 + 8) = 0;\n            }\n            goto code_r0x0001400084b6;\n        }\n    }\n    in_RDX = *0x14005a000;\n    uVar8 = 0x40 - (*0x14005a000 & 0x3f);\n    noname_0 = uVar8;\n    uVar1 = uVar8 & 0x3f;\n    *puVar10 = (0 >> uVar1 | 0 << 0x40 - uVar1) ^ *0x14005a000;\ncode_r0x0001400084b6:\n    if (bVar2) {\n        noname_0 = 3;\n        fcn.140007828(3);\n    }\n    if (uVar11 != 1) {\n        if (uVar9 == 8) {\n            iVar4 = fcn.1400078cc(noname_0, in_RDX);\n            arg2 = *(iVar4 + 0x10);\n            (**0x14005d008)();\n        }\n        else {\n            arg2 = *0x14005d008;\n            (**0x14005d008)();\n        }\n        if (((uVar9 < 0xc) && ((0x910U >> (uVar9 & 0x1f) & 1) != 0)) && (puVar12[1] = uStackX32,  uVar9 == 8)) {\n            iVar4 = fcn.1400078cc(noname_0_00, arg2);\n            *(iVar4 + 0x10) = uStackX24;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1692
    },
    "140008bc": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nbool fcn.140008bc0(void)\n\n{\n    int32_t aiStackX8 [8];\n    \n    aiStackX8[0] = 0;\n    fcn.140007564(aiStackX8);\n    return aiStackX8[0] != 1;\n}\n",
        "token_count": 62
    },
    "14000b18": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.14000b188(void)\n\n{\n    char acStackX8 [8];\n    ulong var_18h_2;\n    ulong var_20h;\n    ulong var_28h;\n    ulong var_20h_2;\n    ulong *var_18h;\n    char *var_10h;\n    ulong *var_bp_8h;\n    \n    acStackX8[0] = '\\x01';\n    var_28h._0_4_ = 0;\n    var_18h = &var_28h;\n    var_20h._0_4_ = 0;\n    var_10h = acStackX8;\n    var_bp_8h = &var_20h;\n    var_20h_2._0_4_ = 8;\n    var_20h_2._4_4_ = 8;\n    fcn.14000b354(&var_18h_2, &var_20h_2 + 4, &var_18h, &var_20h_2);\n    if (acStackX8[0] != '\\0') {\n        var_20h._0_4_ = var_28h;\n    }\n    return var_20h;\n}\n",
        "token_count": 280
    },
    "14000b6e": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.14000b6e0(uchar *arg1, uint64_t arg2, uint64_t arg3, int64_t arg4)\n\n{\n    uchar uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar *puVar4;\n    uchar *puVar5;\n    uchar *puVar6;\n    uchar *puVar7;\n    uint64_t uVar8;\n    int64_t iVar9;\n    uchar *arg2_00;\n    uchar auStack1112 [32];\n    ulong auStack1080 [62];\n    ulong auStack584 [62];\n    uint64_t uStack88;\n    \n    uStack88 = *0x14005a000 ^ auStack1112;\n    if ((((arg1 == NULL) && (arg2 != 0)) || (arg3 == 0)) || (arg4 == 0)) {\n        puVar3 = fcn.140008584();\n        *puVar3 = 0x16;\n        fcn.140005d80();\n    }\n    else if (1 < arg2) {\n        iVar9 = 0;\n        arg2_00 = arg1 + (arg2 - 1) * arg3;\ncode_r0x00014000b771:\n        while (uVar8 = (arg2_00 - arg1) / arg3 + 1,  8 < uVar8) {\n            puVar6 = arg1 + (uVar8 >> 1) * arg3;\n            iVar2 = (**0x14005d008)(arg1, puVar6);\n            if ((0 < iVar2) && (arg1 != puVar6)) {\n                puVar5 = puVar6;\n                uVar8 = arg3;\n                do {\n                    uVar1 = puVar5[arg1 - puVar6];\n                    puVar5[arg1 - puVar6] = *puVar5;\n                    *puVar5 = uVar1;\n                    puVar5 = puVar5 + 1;\n                    uVar8 = uVar8 - 1;\n                } while (uVar8 != 0);\n            }\n            iVar2 = (**0x14005d008)(arg1, arg2_00);\n            if ((0 < iVar2) && (arg1 != arg2_00)) {\n                puVar5 = arg2_00;\n                uVar8 = arg3;\n                do {\n                    uVar1 = puVar5[arg1 - arg2_00];\n                    puVar5[arg1 - arg2_00] = *puVar5;\n                    *puVar5 = uVar1;\n                    puVar5 = puVar5 + 1;\n                    uVar8 = uVar8 - 1;\n                } while (uVar8 != 0);\n            }\n            iVar2 = (**0x14005d008)();\n            puVar5 = arg1;\n            puVar7 = arg2_00;\n            if ((0 < iVar2) && (puVar6 != arg2_00)) {\n                puVar4 = arg2_00;\n                uVar8 = arg3;\n                do {\n                    uVar1 = puVar4[puVar6 - arg2_00];\n                    puVar4[puVar6 - arg2_00] = *puVar4;\n                    *puVar4 = uVar1;\n                    puVar4 = puVar4 + 1;\n                    uVar8 = uVar8 - 1;\n                } while (uVar8 != 0);\n            }\ncode_r0x00014000b880:\n            if (puVar5 < puVar6) {\n                do {\n                    puVar5 = puVar5 + arg3;\n                    if (puVar6 <= puVar5) goto code_r0x00014000b8a5;\n                    iVar2 = (**0x14005d008)();\n                } while (iVar2 < 1);\n                if (puVar6 <= puVar5) goto code_r0x00014000b8a5;\n            }\n            else {\ncode_r0x00014000b8a5:\n                do {\n                    puVar5 = puVar5 + arg3;\n                    if (arg2_00 < puVar5) break;\n                    iVar2 = (**0x14005d008)();\n                } while (iVar2 < 1);\n            }\n            do {\n                puVar7 = puVar7 + -arg3;\n                if (puVar7 <= puVar6) break;\n                iVar2 = (**0x14005d008)();\n            } while (0 < iVar2);\n            if (puVar5 <= puVar7) {\n                if (puVar5 != puVar7) {\n                    puVar4 = puVar7;\n                    uVar8 = arg3;\n                    do {\n                        uVar1 = puVar4[puVar5 - puVar7];\n                        puVar4[puVar5 - puVar7] = *puVar4;\n                        *puVar4 = uVar1;\n                        puVar4 = puVar4 + 1;\n                        uVar8 = uVar8 - 1;\n                    } while (uVar8 != 0);\n                }\n                if (puVar6 == puVar7) {\n                    puVar6 = puVar5;\n                }\n                goto code_r0x00014000b880;\n            }\n            puVar7 = puVar7 + arg3;\n            if (puVar6 < puVar7) {\n                do {\n                    puVar7 = puVar7 + -arg3;\n                    if (puVar7 <= puVar6) goto code_r0x00014000b942;\n                    iVar2 = (**0x14005d008)(puVar7);\n                } while (iVar2 == 0);\n                if (puVar7 <= puVar6) goto code_r0x00014000b942;\n            }\n            else {\ncode_r0x00014000b942:\n                do {\n                    puVar7 = puVar7 + -arg3;\n                    if (puVar7 <= arg1) break;\n                    iVar2 = (**0x14005d008)(puVar7);\n                } while (iVar2 == 0);\n            }\n            if (puVar7 - arg1 < arg2_00 - puVar5) goto code_r0x00014000b994;\n            if (arg1 < puVar7) {\n                auStack1080[iVar9] = arg1;\n                auStack584[iVar9] = puVar7;\n                iVar9 = iVar9 + 1;\n            }\n            arg1 = puVar5;\n            if (arg2_00 <= puVar5) goto code_r0x00014000b797;\n        }\n        fcn.14000ba00(arg1, arg2_00, arg3, arg4);\n        goto code_r0x00014000b797;\n    }\ncode_r0x00014000b9e2:\n    fcn.1400065e0(uStack88 ^ auStack1112);\n    return;\ncode_r0x00014000b994:\n    if (puVar5 < arg2_00) {\n        auStack1080[iVar9] = puVar5;\n        auStack584[iVar9] = arg2_00;\n        iVar9 = iVar9 + 1;\n    }\n    arg2_00 = puVar7;\n    if (puVar7 <= arg1) {\ncode_r0x00014000b797:\n        iVar9 = iVar9 + -1;\n        if (-1 < iVar9) {\n            arg1 = auStack1080[iVar9];\n            arg2_00 = auStack584[iVar9];\n            goto code_r0x00014000b771;\n        }\n        goto code_r0x00014000b9e2;\n    }\n    goto code_r0x00014000b771;\n}\n",
        "token_count": 1687
    },
    "140003fe": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuchar (*) [32] fcn.140003fe0(uchar (*arg1) [32], uchar (*arg2) [32], uint64_t arg3)\n\n{\n    uint *puVar1;\n    uchar uVar2;\n    ushort uVar3;\n    uint uVar4;\n    uint uVar5;\n    uint uVar6;\n    uint uVar7;\n    uint uVar8;\n    uint uVar9;\n    uint uVar10;\n    uint uVar11;\n    uint uVar12;\n    uint uVar13;\n    uint uVar14;\n    uchar (*pauVar15) [32];\n    uchar (*pauVar16) [32];\n    uchar (*pauVar17) [32];\n    uint *puVar18;\n    uint *puVar19;\n    uchar (*pauVar20) [32];\n    uint *puVar21;\n    uint64_t uVar22;\n    int64_t iVar23;\n    uint64_t uVar24;\n    uint uVar25;\n    uint uVar27;\n    uint uVar28;\n    uint uVar29;\n    uchar auVar26 [32];\n    uchar auVar30 [32];\n    uchar auVar31 [32];\n    uchar auVar32 [32];\n    uchar auVar33 [32];\n    uchar auVar34 [32];\n    \n    pauVar15 = arg1;\n    if (arg3 < 0x10) {\n    // switch table (16 cases) at 0x140060000\n        switch(*(arg3 * 4 + 0x140060000) + 0x140000000) {\n        case 0x14000400e:\n            return pauVar15;\n        case 0x140004010:\n            uVar4 = *(*arg2 + 8);\n            uVar3 = *(*arg2 + 0xc);\n            uVar2 = (*arg2)[0xe];\n            **arg1 = **arg2;\n            *(*arg1 + 8) = uVar4;\n            *(*arg1 + 0xc) = uVar3;\n            (*arg1)[0xe] = uVar2;\n            return pauVar15;\n        case 0x140004030:\n            uVar3 = *(*arg2 + 8);\n            uVar2 = (*arg2)[10];\n            **arg1 = **arg2;\n            *(*arg1 + 8) = uVar3;\n            (*arg1)[10] = uVar2;\n            return pauVar15;\n        case 0x140004048:\n            **arg1 = **arg2;\n            return pauVar15;\n        case 0x140004050:\n            uVar3 = *(*arg2 + 4);\n            uVar2 = (*arg2)[6];\n            **arg1 = **arg2;\n            *(*arg1 + 4) = uVar3;\n            (*arg1)[6] = uVar2;\n            return pauVar15;\n        case 0x140004068:\n            uVar4 = *(*arg2 + 8);\n            uVar3 = *(*arg2 + 0xc);\n            **arg1 = **arg2;\n            *(*arg1 + 8) = uVar4;\n            *(*arg1 + 0xc) = uVar3;\n            return pauVar15;\n        case 0x14000407f:\n            uVar2 = (*arg2)[2];\n            **arg1 = **arg2;\n            (*arg1)[2] = uVar2;\n            return pauVar15;\n        case 0x140004090:\n            uVar4 = *(*arg2 + 8);\n            uVar2 = (*arg2)[0xc];\n            **arg1 = **arg2;\n            *(*arg1 + 8) = uVar4;\n            (*arg1)[0xc] = uVar2;\n            return pauVar15;\n        case 0x1400040a6:\n            uVar3 = *(*arg2 + 8);\n            **arg1 = **arg2;\n            *(*arg1 + 8) = uVar3;\n            return pauVar15;\n        case 0x1400040b5:\n            uVar2 = (*arg2)[8];\n            **arg1 = **arg2;\n            (*arg1)[8] = uVar2;\n            return pauVar15;\n        case 0x1400040c3:\n            uVar4 = *(*arg2 + 8);\n            **arg1 = **arg2;\n            *(*arg1 + 8) = uVar4;\n            return pauVar15;\n        case 0x1400040d0:\n            uVar3 = *(*arg2 + 4);\n            **arg1 = **arg2;\n            *(*arg1 + 4) = uVar3;\n            return pauVar15;\n        case 0x1400040df:\n            uVar2 = (*arg2)[4];\n            **arg1 = **arg2;\n            (*arg1)[4] = uVar2;\n            return pauVar15;\n        case 0x1400040ed:\n            **arg1 = **arg2;\n            return pauVar15;\n        case 0x1400040f4:\n            (*arg1)[0] = (*arg2)[0];\n            return pauVar15;\n        case 0x1400040fa:\n            **arg1 = **arg2;\n            return pauVar15;\n        }\n    }\n    if (arg3 < 0x21) {\n        uVar4 = *(*arg2 + 4);\n        uVar5 = *(*arg2 + 8);\n        uVar6 = *(*arg2 + 0xc);\n        puVar18 = arg2[-1] + arg3 + 0x10;\n        uVar25 = *puVar18;\n        uVar27 = puVar18[1];\n        uVar28 = puVar18[2];\n        uVar29 = puVar18[3];\n        **arg1 = **arg2;\n        *(*arg1 + 4) = uVar4;\n        *(*arg1 + 8) = uVar5;\n        *(*arg1 + 0xc) = uVar6;\n        puVar18 = arg1[-1] + arg3 + 0x10;\n        *puVar18 = uVar25;\n        puVar18[1] = uVar27;\n        puVar18[2] = uVar28;\n        puVar18[3] = uVar29;\n        return pauVar15;\n    }\n    if ((arg2 < arg1) && (arg1 < *arg2 + arg3)) {\n        iVar23 = arg2 - arg1;\n        puVar18 = arg1 + iVar23 + (arg3 - 0x10);\n        uVar4 = puVar18[1];\n        uVar5 = puVar18[2];\n        uVar6 = puVar18[3];\n        puVar19 = arg1[-1] + arg3 + 0x10;\n        uVar22 = arg3 - 0x10;\n        puVar21 = puVar19;\n        uVar25 = *puVar18;\n        uVar27 = uVar4;\n        uVar28 = uVar5;\n        uVar29 = uVar6;\n        if ((puVar19 & 0xf) != 0) {\n            puVar21 = puVar19 & 0xfffffffffffffff0;\n            puVar1 = puVar21 + iVar23;\n            uVar25 = *puVar1;\n            uVar27 = puVar1[1];\n            uVar28 = puVar1[2];\n            uVar29 = puVar1[3];\n            *puVar19 = *puVar18;\n            *(arg1[-1] + arg3 + 0x14) = uVar4;\n            *(arg1[-1] + arg3 + 0x18) = uVar5;\n            *(arg1[-1] + arg3 + 0x1c) = uVar6;\n            uVar22 = puVar21 - arg1;\n        }\n        uVar24 = uVar22 >> 7;\n        if (uVar24 != 0) {\n            *puVar21 = uVar25;\n            puVar21[1] = uVar27;\n            puVar21[2] = uVar28;\n            puVar21[3] = uVar29;\n            puVar18 = puVar21;\n            while( true ) {\n                puVar19 = puVar18 + iVar23 + -0x10;\n                uVar4 = puVar19[1];\n                uVar5 = puVar19[2];\n                uVar6 = puVar19[3];\n                puVar21 = puVar18 + iVar23 + -0x20;\n                uVar25 = *puVar21;\n                uVar27 = puVar21[1];\n                uVar28 = puVar21[2];\n                uVar29 = puVar21[3];\n                puVar21 = puVar18 + -0x20;\n                puVar18[-4] = *puVar19;\n                puVar18[-3] = uVar4;\n                puVar18[-2] = uVar5;\n                puVar18[-1] = uVar6;\n                puVar18[-8] = uVar25;\n                puVar18[-7] = uVar27;\n                puVar18[-6] = uVar28;\n                puVar18[-5] = uVar29;\n                puVar19 = puVar18 + iVar23 + -0x30;\n                uVar4 = puVar19[1];\n                uVar5 = puVar19[2];\n                uVar6 = puVar19[3];\n                puVar1 = puVar18 + iVar23 + -0x40;\n                uVar25 = *puVar1;\n                uVar27 = puVar1[1];\n                uVar28 = puVar1[2];\n                uVar29 = puVar1[3];\n                uVar24 = uVar24 - 1;\n                puVar18[-0xc] = *puVar19;\n                puVar18[-0xb] = uVar4;\n                puVar18[-10] = uVar5;\n                puVar18[-9] = uVar6;\n                puVar18[-0x10] = uVar25;\n                puVar18[-0xf] = uVar27;\n                puVar18[-0xe] = uVar28;\n                puVar18[-0xd] = uVar29;\n                puVar19 = puVar18 + iVar23 + -0x50;\n                uVar4 = puVar19[1];\n                uVar5 = puVar19[2];\n                uVar6 = puVar19[3];\n                puVar1 = puVar18 + iVar23 + -0x60;\n                uVar25 = *puVar1;\n                uVar27 = puVar1[1];\n                uVar28 = puVar1[2];\n                uVar29 = puVar1[3];\n                puVar18[-0x14] = *puVar19;\n                puVar18[-0x13] = uVar4;\n                puVar18[-0x12] = uVar5;\n                puVar18[-0x11] = uVar6;\n                puVar18[-0x18] = uVar25;\n                puVar18[-0x17] = uVar27;\n                puVar18[-0x16] = uVar28;\n                puVar18[-0x15] = uVar29;\n                puVar1 = puVar18 + iVar23 + -0x70;\n                uVar4 = puVar1[1];\n                uVar5 = puVar1[2];\n                uVar6 = puVar1[3];\n                puVar19 = puVar21 + iVar23;\n                uVar25 = *puVar19;\n                uVar27 = puVar19[1];\n                uVar28 = puVar19[2];\n                uVar29 = puVar19[3];\n                if (uVar24 == 0) break;\n                puVar18[-0x1c] = *puVar1;\n                puVar18[-0x1b] = uVar4;\n                puVar18[-0x1a] = uVar5;\n                puVar18[-0x19] = uVar6;\n                *puVar21 = uVar25;\n                puVar18[-0x1f] = uVar27;\n                puVar18[-0x1e] = uVar28;\n                puVar18[-0x1d] = uVar29;\n                puVar18 = puVar21;\n            }\n            puVar18[-0x1c] = *puVar1;\n            puVar18[-0x1b] = uVar4;\n            puVar18[-0x1a] = uVar5;\n            puVar18[-0x19] = uVar6;\n            uVar22 = uVar22 & 0x7f;\n        }\n        for (uVar24 = uVar22 >> 4; uVar24 != 0; uVar24 = uVar24 - 1) {\n            *puVar21 = uVar25;\n            puVar21[1] = uVar27;\n            puVar21[2] = uVar28;\n            puVar21[3] = uVar29;\n            puVar21 = puVar21 + -4;\n            puVar18 = puVar21 + iVar23;\n            uVar25 = *puVar18;\n            uVar27 = puVar18[1];\n            uVar28 = puVar18[2];\n            uVar29 = puVar18[3];\n        }\n        if ((uVar22 & 0xf) != 0) {\n            uVar4 = *(*arg2 + 4);\n            uVar5 = *(*arg2 + 8);\n            uVar6 = *(*arg2 + 0xc);\n            **arg1 = **arg2;\n            *(*arg1 + 4) = uVar4;\n            *(*arg1 + 8) = uVar5;\n            *(*arg1 + 0xc) = uVar6;\n        }\n        *puVar21 = uVar25;\n        puVar21[1] = uVar27;\n        puVar21[2] = uVar28;\n        puVar21[3] = uVar29;\n        return arg1;\n    }\n    if (*0x140059fe8 < 3) {\n        if ((arg3 < 0x801) || ((*0x14005a9c8 & 2) == 0)) {\n            if (0x80 < arg3) {\n                iVar23 = (arg1 & 0xf) - 0x10;\n                puVar18 = arg1 - iVar23;\n                puVar21 = arg2 - iVar23;\n                arg3 = arg3 + iVar23;\n                if (0x80 < arg3) {\n                    do {\n                        uVar4 = puVar21[1];\n                        uVar5 = puVar21[2];\n                        uVar6 = puVar21[3];\n                        uVar25 = puVar21[4];\n                        uVar27 = puVar21[5];\n                        uVar28 = puVar21[6];\n                        uVar29 = puVar21[7];\n                        uVar7 = puVar21[8];\n                        uVar8 = puVar21[9];\n                        uVar9 = puVar21[10];\n                        uVar10 = puVar21[0xb];\n                        uVar11 = puVar21[0xc];\n                        uVar12 = puVar21[0xd];\n                        uVar13 = puVar21[0xe];\n                        uVar14 = puVar21[0xf];\n                        *puVar18 = *puVar21;\n                        puVar18[1] = uVar4;\n                        puVar18[2] = uVar5;\n                        puVar18[3] = uVar6;\n                        puVar18[4] = uVar25;\n                        puVar18[5] = uVar27;\n                        puVar18[6] = uVar28;\n                        puVar18[7] = uVar29;\n                        puVar18[8] = uVar7;\n                        puVar18[9] = uVar8;\n                        puVar18[10] = uVar9;\n                        puVar18[0xb] = uVar10;\n                        puVar18[0xc] = uVar11;\n                        puVar18[0xd] = uVar12;\n                        puVar18[0xe] = uVar13;\n                        puVar18[0xf] = uVar14;\n                        uVar4 = puVar21[0x11];\n                        uVar5 = puVar21[0x12];\n                        uVar6 = puVar21[0x13];\n                        uVar25 = puVar21[0x14];\n                        uVar27 = puVar21[0x15];\n                        uVar28 = puVar21[0x16];\n                        uVar29 = puVar21[0x17];\n                        uVar7 = puVar21[0x18];\n                        uVar8 = puVar21[0x19];\n                        uVar9 = puVar21[0x1a];\n                        uVar10 = puVar21[0x1b];\n                        uVar11 = puVar21[0x1c];\n                        uVar12 = puVar21[0x1d];\n                        uVar13 = puVar21[0x1e];\n                        uVar14 = puVar21[0x1f];\n                        puVar18[0x10] = puVar21[0x10];\n                        puVar18[0x11] = uVar4;\n                        puVar18[0x12] = uVar5;\n                        puVar18[0x13] = uVar6;\n                        puVar18[0x14] = uVar25;\n                        puVar18[0x15] = uVar27;\n                        puVar18[0x16] = uVar28;\n                        puVar18[0x17] = uVar29;\n                        puVar18[0x18] = uVar7;\n                        puVar18[0x19] = uVar8;\n                        puVar18[0x1a] = uVar9;\n                        puVar18[0x1b] = uVar10;\n                        puVar18[0x1c] = uVar11;\n                        puVar18[0x1d] = uVar12;\n                        puVar18[0x1e] = uVar13;\n                        puVar18[0x1f] = uVar14;\n                        puVar18 = puVar18 + 0x20;\n                        puVar21 = puVar21 + 0x20;\n                        arg3 = arg3 - 0x80;\n                    } while (0x7f < arg3);\n                }\n            }\n    // WARNING: Could not recover jumptable at 0x0001400044f6. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (9 cases) at 0x140060088\n            pauVar15 = (*(*((arg3 + 0xf >> 4) * 4 + 0x140060088) + 0x140000000))();\n            return pauVar15;\n        }\n    }\n    else if (((arg3 < 0x2001) || (0x180000 < arg3)) || ((*0x14005a9c8 & 2) == 0)) {\n        auVar26 = vmovdqu_avx(*arg2);\n        auVar34 = vmovdqu_avx(*(arg2[-1] + arg3));\n        if (0x100 < arg3) {\n            iVar23 = (arg1 & 0x1f) - 0x20;\n            pauVar16 = arg1 - iVar23;\n            arg2 = arg2 - iVar23;\n            arg3 = arg3 + iVar23;\n            if (0x100 < arg3) {\n                if (0x180000 < arg3) {\n                    do {\n                        uVar22 = arg3;\n                        pauVar20 = arg2;\n                        pauVar17 = pauVar16;\n                        auVar30 = vmovdqu_avx(*pauVar20);\n                        auVar31 = vmovdqu_avx(pauVar20[1]);\n                        auVar32 = vmovdqu_avx(pauVar20[2]);\n                        auVar33 = vmovdqu_avx(pauVar20[3]);\n                        auVar30 = vmovntdq_avx(auVar30);\n                        *pauVar17 = auVar30;\n                        auVar30 = vmovntdq_avx(auVar31);\n                        pauVar17[1] = auVar30;\n                        auVar30 = vmovntdq_avx(auVar32);\n                        pauVar17[2] = auVar30;\n                        auVar30 = vmovntdq_avx(auVar33);\n                        pauVar17[3] = auVar30;\n                        auVar30 = vmovdqu_avx(pauVar20[4]);\n                        auVar31 = vmovdqu_avx(pauVar20[5]);\n                        auVar32 = vmovdqu_avx(pauVar20[6]);\n                        auVar33 = vmovdqu_avx(pauVar20[7]);\n                        auVar30 = vmovntdq_avx(auVar30);\n                        pauVar17[4] = auVar30;\n                        auVar30 = vmovntdq_avx(auVar31);\n                        pauVar17[5] = auVar30;\n                        auVar30 = vmovntdq_avx(auVar32);\n                        pauVar17[6] = auVar30;\n                        auVar30 = vmovntdq_avx(auVar33);\n                        pauVar17[7] = auVar30;\n                        pauVar16 = pauVar17[8];\n                        arg2 = pauVar20[8];\n                        arg3 = uVar22 - 0x100;\n                    } while (0xff < uVar22 - 0x100);\n                    uVar24 = uVar22 - 0xe1 & 0xffffffffffffffe0;\n    // switch table (18 cases) at 0x140060064\n                    switch(uVar22) {\n                    case 0x1e1:\n                    case 0x1e2:\n                    case 0x1e3:\n                    case 0x1e4:\n                    case 0x1e5:\n                    case 0x1e6:\n                    case 0x1e7:\n                    case 0x1e8:\n                    case 0x1e9:\n                    case 0x1ea:\n                    case 0x1eb:\n                    case 0x1ec:\n                    case 0x1ed:\n                    case 0x1ee:\n                    case 0x1ef:\n                    case 0x1f0:\n                    case 0x1f1:\n                    case 0x1f2:\n                    case 499:\n                    case 500:\n                    case 0x1f5:\n                    case 0x1f6:\n                    case 0x1f7:\n                    case 0x1f8:\n                    case 0x1f9:\n                    case 0x1fa:\n                    case 0x1fb:\n                    case 0x1fc:\n                    case 0x1fd:\n                    case 0x1fe:\n                    case 0x1ff:\n                        auVar30 = vmovdqu_avx(*(*pauVar20 + uVar24));\n                        auVar30 = vmovntdq_avx(auVar30);\n                        *(*pauVar17 + uVar24) = auVar30;\n                    case 0x1c1:\n                    case 0x1c2:\n                    case 0x1c3:\n                    case 0x1c4:\n                    case 0x1c5:\n                    case 0x1c6:\n                    case 0x1c7:\n                    case 0x1c8:\n                    case 0x1c9:\n                    case 0x1ca:\n                    case 0x1cb:\n                    case 0x1cc:\n                    case 0x1cd:\n                    case 0x1ce:\n                    case 0x1cf:\n                    case 0x1d0:\n                    case 0x1d1:\n                    case 0x1d2:\n                    case 0x1d3:\n                    case 0x1d4:\n                    case 0x1d5:\n                    case 0x1d6:\n                    case 0x1d7:\n                    case 0x1d8:\n                    case 0x1d9:\n                    case 0x1da:\n                    case 0x1db:\n                    case 0x1dc:\n                    case 0x1dd:\n                    case 0x1de:\n                    case 0x1df:\n                    case 0x1e0:\n                        auVar30 = vmovdqu_avx(*(pauVar20[1] + uVar24));\n                        auVar30 = vmovntdq_avx(auVar30);\n                        *(pauVar17[1] + uVar24) = auVar30;\n                    case 0x1a1:\n                    case 0x1a2:\n                    case 0x1a3:\n                    case 0x1a4:\n                    case 0x1a5:\n                    case 0x1a6:\n                    case 0x1a7:\n                    case 0x1a8:\n                    case 0x1a9:\n                    case 0x1aa:\n                    case 0x1ab:\n                    case 0x1ac:\n                    case 0x1ad:\n                    case 0x1ae:\n                    case 0x1af:\n                    case 0x1b0:\n                    case 0x1b1:\n                    case 0x1b2:\n                    case 0x1b3:\n                    case 0x1b4:\n                    case 0x1b5:\n                    case 0x1b6:\n                    case 0x1b7:\n                    case 0x1b8:\n                    case 0x1b9:\n                    case 0x1ba:\n                    case 0x1bb:\n                    case 0x1bc:\n                    case 0x1bd:\n                    case 0x1be:\n                    case 0x1bf:\n                    case 0x1c0:\n                        auVar30 = vmovdqu_avx(*(pauVar20[2] + uVar24));\n                        auVar30 = vmovntdq_avx(auVar30);\n                        *(pauVar17[2] + uVar24) = auVar30;\n                    case 0x181:\n                    case 0x182:\n                    case 0x183:\n                    case 0x184:\n                    case 0x185:\n                    case 0x186:\n                    case 0x187:\n                    case 0x188:\n                    case 0x189:\n                    case 0x18a:\n                    case 0x18b:\n                    case 0x18c:\n                    case 0x18d:\n                    case 0x18e:\n                    case 399:\n                    case 400:\n                    case 0x191:\n                    case 0x192:\n                    case 0x193:\n                    case 0x194:\n                    case 0x195:\n                    case 0x196:\n                    case 0x197:\n                    case 0x198:\n                    case 0x199:\n                    case 0x19a:\n                    case 0x19b:\n                    case 0x19c:\n                    case 0x19d:\n                    case 0x19e:\n                    case 0x19f:\n                    case 0x1a0:\n                        auVar30 = vmovdqu_avx(*(pauVar20[3] + uVar24));\n                        auVar30 = vmovntdq_avx(auVar30);\n                        *(pauVar17[3] + uVar24) = auVar30;\n                    case 0x161:\n                    case 0x162:\n                    case 0x163:\n                    case 0x164:\n                    case 0x165:\n                    case 0x166:\n                    case 0x167:\n                    case 0x168:\n                    case 0x169:\n                    case 0x16a:\n                    case 0x16b:\n                    case 0x16c:\n                    case 0x16d:\n                    case 0x16e:\n                    case 0x16f:\n                    case 0x170:\n                    case 0x171:\n                    case 0x172:\n                    case 0x173:\n                    case 0x174:\n                    case 0x175:\n                    case 0x176:\n                    case 0x177:\n                    case 0x178:\n                    case 0x179:\n                    case 0x17a:\n                    case 0x17b:\n                    case 0x17c:\n                    case 0x17d:\n                    case 0x17e:\n                    case 0x17f:\n                    case 0x180:\n                        auVar30 = vmovdqu_avx(*(pauVar20[4] + uVar24));\n                        auVar30 = vmovntdq_avx(auVar30);\n                        *(pauVar17[4] + uVar24) = auVar30;\n                    case 0x141:\n                    case 0x142:\n                    case 0x143:\n                    case 0x144:\n                    case 0x145:\n                    case 0x146:\n                    case 0x147:\n                    case 0x148:\n                    case 0x149:\n                    case 0x14a:\n                    case 0x14b:\n                    case 0x14c:\n                    case 0x14d:\n                    case 0x14e:\n                    case 0x14f:\n                    case 0x150:\n                    case 0x151:\n                    case 0x152:\n                    case 0x153:\n                    case 0x154:\n                    case 0x155:\n                    case 0x156:\n                    case 0x157:\n                    case 0x158:\n                    case 0x159:\n                    case 0x15a:\n                    case 0x15b:\n                    case 0x15c:\n                    case 0x15d:\n                    case 0x15e:\n                    case 0x15f:\n                    case 0x160:\n                        auVar30 = vmovdqu_avx(*(pauVar20[5] + uVar24));\n                        auVar30 = vmovntdq_avx(auVar30);\n                        *(pauVar17[5] + uVar24) = auVar30;\n                    case 0x121:\n                    case 0x122:\n                    case 0x123:\n                    case 0x124:\n                    case 0x125:\n                    case 0x126:\n                    case 0x127:\n                    case 0x128:\n                    case 0x129:\n                    case 0x12a:\n                    case 299:\n                    case 300:\n                    case 0x12d:\n                    case 0x12e:\n                    case 0x12f:\n                    case 0x130:\n                    case 0x131:\n                    case 0x132:\n                    case 0x133:\n                    case 0x134:\n                    case 0x135:\n                    case 0x136:\n                    case 0x137:\n                    case 0x138:\n                    case 0x139:\n                    case 0x13a:\n                    case 0x13b:\n                    case 0x13c:\n                    case 0x13d:\n                    case 0x13e:\n                    case 0x13f:\n                    case 0x140:\n                        auVar30 = vmovdqu_avx(*(pauVar20[6] + uVar24));\n                        auVar30 = vmovntdq_avx(auVar30);\n                        *(pauVar17[6] + uVar24) = auVar30;\n                    default:\n                        auVar34 = vmovdqu_avx(auVar34);\n                        *(pauVar17[-1] + uVar22) = auVar34;\n                    case 0x100:\n                        auVar26 = vmovdqu_avx(auVar26);\n                        *arg1 = auVar26;\n                        vzeroupper_avx();\n                        return pauVar15;\n                    }\n                }\n                do {\n                    auVar34 = vmovdqu_avx(*arg2);\n                    auVar30 = vmovdqu_avx(arg2[1]);\n                    auVar31 = vmovdqu_avx(arg2[2]);\n                    auVar32 = vmovdqu_avx(arg2[3]);\n                    *pauVar16 = auVar34;\n                    pauVar16[1] = auVar30;\n                    pauVar16[2] = auVar31;\n                    pauVar16[3] = auVar32;\n                    auVar34 = vmovdqu_avx(arg2[4]);\n                    auVar30 = vmovdqu_avx(arg2[5]);\n                    auVar31 = vmovdqu_avx(arg2[6]);\n                    auVar32 = vmovdqu_avx(arg2[7]);\n                    pauVar16[4] = auVar34;\n                    pauVar16[5] = auVar30;\n                    pauVar16[6] = auVar31;\n                    pauVar16[7] = auVar32;\n                    pauVar16 = pauVar16[8];\n                    arg2 = arg2[8];\n                    arg3 = arg3 - 0x100;\n                } while (0xff < arg3);\n            }\n        }\n    // WARNING: Could not recover jumptable at 0x000140004252. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (27 cases) at 0x140060040\n        pauVar15 = (*(*((arg3 + 0x1f >> 5) * 4 + 0x140060040) + 0x140000000))(SUB328(auVar26, 0));\n        return pauVar15;\n    }\n    for (; arg3 != 0; arg3 = arg3 - 1) {\n        (*arg1)[0] = (*arg2)[0];\n        arg2 = *arg2 + 1;\n        arg1 = *arg1 + 1;\n    }\n    return pauVar15;\n}\n",
        "token_count": 7522
    },
    "14000469": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuchar (*) [32] fcn.140004690(uchar (*arg1) [32], ulong noname_1, uint64_t arg3)\n\n{\n    uchar auVar1 [32];\n    uchar (*pauVar2) [32];\n    uchar (*pauVar3) [32];\n    uchar (*pauVar4) [16];\n    uint64_t uVar5;\n    uint64_t uVar6;\n    uchar uVar7;\n    int64_t iVar10;\n    uchar auVar11 [16];\n    uchar in_YMM0 [32];\n    uchar auVar12 [32];\n    ushort uVar8;\n    uint uVar9;\n    \n    uVar5 = noname_1;\n    iVar10 = uVar5 * 0x101010101010101;\n    if (arg3 < 0x10) {\n        uVar7 = iVar10;\n        uVar8 = iVar10;\n        uVar9 = iVar10;\n    // switch table (16 cases) at 0x1400600b0\n        switch(*(arg3 * 4 + 0x1400600b0) + 0x140000000) {\n        case 0x1400046d1:\n            *(arg1[-1] + arg3 + 0x11) = iVar10;\n        case 0x1400046d5:\n            *(arg1[-1] + arg3 + 0x19) = uVar9;\n        case 0x1400046d9:\n            *(arg1[-1] + arg3 + 0x1d) = uVar8;\n        case 0x1400046de:\n            arg1[-1][arg3 + 0x1f] = uVar7;\n            return arg1;\n        case 0x1400046e2:\n            return arg1;\n        case 0x1400046e3:\n            *(arg1[-1] + arg3 + 0x12) = iVar10;\n        case 0x1400046e7:\n            *(arg1[-1] + arg3 + 0x1a) = uVar9;\n        case 0x1400046eb:\n            *(arg1[-1] + arg3 + 0x1e) = uVar8;\n            return arg1;\n        case 0x140004700:\n            *(arg1[-1] + arg3 + 0x13) = iVar10;\n        case 0x140004704:\n            *(arg1[-1] + arg3 + 0x1b) = uVar9;\n            arg1[-1][arg3 + 0x1f] = uVar7;\n            return arg1;\n        case 0x140004710:\n            *(arg1[-1] + arg3 + 0x14) = iVar10;\n        case 0x140004714:\n            *(arg1[-1] + arg3 + 0x1c) = uVar9;\n            return arg1;\n        case 0x140004719:\n            *(arg1[-1] + arg3 + 0x15) = iVar10;\n            *(arg1[-1] + arg3 + 0x1d) = uVar8;\n            arg1[-1][arg3 + 0x1f] = uVar7;\n            return arg1;\n        case 0x140004727:\n            *(arg1[-1] + arg3 + 0x17) = iVar10;\n            arg1[-1][arg3 + 0x1f] = uVar7;\n            return arg1;\n        case 0x140004730:\n            *(arg1[-1] + arg3 + 0x16) = iVar10;\n            *(arg1[-1] + arg3 + 0x1e) = uVar8;\n            return arg1;\n        case 0x14000473a:\n            *(arg1[-1] + arg3 + 0x18) = iVar10;\n            return arg1;\n        }\n    }\n    auVar11 = CONCAT88(iVar10, iVar10);\n    if (arg3 < 0x21) {\n        **arg1 = auVar11;\n        *(arg1[-1] + arg3 + 0x10) = auVar11;\n        return arg1;\n    }\n    pauVar2 = arg1;\n    if (*0x140059fe8 < 3) {\n        if ((arg3 <= *0x140059ff0) || ((*0x14005a9c8 & 2) == 0)) {\n            iVar10 = (arg1 & 0xf) - 0x10;\n            pauVar4 = arg1 - iVar10;\n            arg3 = arg3 + iVar10;\n            if (0x80 < arg3) {\n                do {\n                    *pauVar4 = auVar11;\n                    pauVar4[1] = auVar11;\n                    pauVar4[2] = auVar11;\n                    pauVar4[3] = auVar11;\n                    pauVar4[4] = auVar11;\n                    pauVar4[5] = auVar11;\n                    pauVar4[6] = auVar11;\n                    pauVar4[7] = auVar11;\n                    pauVar4 = pauVar4[8];\n                    arg3 = arg3 - 0x80;\n                } while (0x7f < arg3);\n            }\n    // WARNING: Could not recover jumptable at 0x0001400049d8. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (9 cases) at 0x140060138\n            pauVar2 = (*(*((arg3 + 0xf >> 4) * 4 + 0x140060138) + 0x140000000))(pauVar4, uVar5 - iVar10);\n            return pauVar2;\n        }\n    }\n    else if (((arg3 <= *0x140059ff0) || (*0x140059ff8 < arg3)) || ((*0x14005a9c8 & 2) == 0)) {\n        auVar12 = vinsertf128_avx(CONCAT1616(SUB3216(in_YMM0 >> 0x80, 0), auVar11), auVar11, 1);\n        iVar10 = (arg1 & 0x1f) - 0x20;\n        pauVar2 = arg1 - iVar10;\n        arg3 = arg3 + iVar10;\n        if (0x100 < arg3) {\n            if (*0x140059ff8 < arg3) {\n                do {\n                    uVar5 = arg3;\n                    pauVar3 = pauVar2;\n                    auVar1 = vmovntdq_avx(auVar12);\n                    *pauVar3 = auVar1;\n                    auVar1 = vmovntdq_avx(auVar12);\n                    pauVar3[1] = auVar1;\n                    auVar1 = vmovntdq_avx(auVar12);\n                    pauVar3[2] = auVar1;\n                    auVar1 = vmovntdq_avx(auVar12);\n                    pauVar3[3] = auVar1;\n                    auVar1 = vmovntdq_avx(auVar12);\n                    pauVar3[4] = auVar1;\n                    auVar1 = vmovntdq_avx(auVar12);\n                    pauVar3[5] = auVar1;\n                    auVar1 = vmovntdq_avx(auVar12);\n                    pauVar3[6] = auVar1;\n                    auVar1 = vmovntdq_avx(auVar12);\n                    pauVar3[7] = auVar1;\n                    pauVar2 = pauVar3[8];\n                    arg3 = uVar5 - 0x100;\n                } while (0xff < uVar5 - 0x100);\n                uVar6 = uVar5 - 0xe1 & 0xffffffffffffffe0;\n    // switch table (18 cases) at 0x140060114\n                switch(uVar5) {\n                case 0x1e1:\n                case 0x1e2:\n                case 0x1e3:\n                case 0x1e4:\n                case 0x1e5:\n                case 0x1e6:\n                case 0x1e7:\n                case 0x1e8:\n                case 0x1e9:\n                case 0x1ea:\n                case 0x1eb:\n                case 0x1ec:\n                case 0x1ed:\n                case 0x1ee:\n                case 0x1ef:\n                case 0x1f0:\n                case 0x1f1:\n                case 0x1f2:\n                case 499:\n                case 500:\n                case 0x1f5:\n                case 0x1f6:\n                case 0x1f7:\n                case 0x1f8:\n                case 0x1f9:\n                case 0x1fa:\n                case 0x1fb:\n                case 0x1fc:\n                case 0x1fd:\n                case 0x1fe:\n                case 0x1ff:\n                    auVar1 = vmovntdq_avx(auVar12);\n                    *(*pauVar3 + uVar6) = auVar1;\n                case 0x1c1:\n                case 0x1c2:\n                case 0x1c3:\n                case 0x1c4:\n                case 0x1c5:\n                case 0x1c6:\n                case 0x1c7:\n                case 0x1c8:\n                case 0x1c9:\n                case 0x1ca:\n                case 0x1cb:\n                case 0x1cc:\n                case 0x1cd:\n                case 0x1ce:\n                case 0x1cf:\n                case 0x1d0:\n                case 0x1d1:\n                case 0x1d2:\n                case 0x1d3:\n                case 0x1d4:\n                case 0x1d5:\n                case 0x1d6:\n                case 0x1d7:\n                case 0x1d8:\n                case 0x1d9:\n                case 0x1da:\n                case 0x1db:\n                case 0x1dc:\n                case 0x1dd:\n                case 0x1de:\n                case 0x1df:\n                case 0x1e0:\n                    auVar1 = vmovntdq_avx(auVar12);\n                    *(pauVar3[1] + uVar6) = auVar1;\n                case 0x1a1:\n                case 0x1a2:\n                case 0x1a3:\n                case 0x1a4:\n                case 0x1a5:\n                case 0x1a6:\n                case 0x1a7:\n                case 0x1a8:\n                case 0x1a9:\n                case 0x1aa:\n                case 0x1ab:\n                case 0x1ac:\n                case 0x1ad:\n                case 0x1ae:\n                case 0x1af:\n                case 0x1b0:\n                case 0x1b1:\n                case 0x1b2:\n                case 0x1b3:\n                case 0x1b4:\n                case 0x1b5:\n                case 0x1b6:\n                case 0x1b7:\n                case 0x1b8:\n                case 0x1b9:\n                case 0x1ba:\n                case 0x1bb:\n                case 0x1bc:\n                case 0x1bd:\n                case 0x1be:\n                case 0x1bf:\n                case 0x1c0:\n                    auVar1 = vmovntdq_avx(auVar12);\n                    *(pauVar3[2] + uVar6) = auVar1;\n                case 0x181:\n                case 0x182:\n                case 0x183:\n                case 0x184:\n                case 0x185:\n                case 0x186:\n                case 0x187:\n                case 0x188:\n                case 0x189:\n                case 0x18a:\n                case 0x18b:\n                case 0x18c:\n                case 0x18d:\n                case 0x18e:\n                case 399:\n                case 400:\n                case 0x191:\n                case 0x192:\n                case 0x193:\n                case 0x194:\n                case 0x195:\n                case 0x196:\n                case 0x197:\n                case 0x198:\n                case 0x199:\n                case 0x19a:\n                case 0x19b:\n                case 0x19c:\n                case 0x19d:\n                case 0x19e:\n                case 0x19f:\n                case 0x1a0:\n                    auVar1 = vmovntdq_avx(auVar12);\n                    *(pauVar3[3] + uVar6) = auVar1;\n                case 0x161:\n                case 0x162:\n                case 0x163:\n                case 0x164:\n                case 0x165:\n                case 0x166:\n                case 0x167:\n                case 0x168:\n                case 0x169:\n                case 0x16a:\n                case 0x16b:\n                case 0x16c:\n                case 0x16d:\n                case 0x16e:\n                case 0x16f:\n                case 0x170:\n                case 0x171:\n                case 0x172:\n                case 0x173:\n                case 0x174:\n                case 0x175:\n                case 0x176:\n                case 0x177:\n                case 0x178:\n                case 0x179:\n                case 0x17a:\n                case 0x17b:\n                case 0x17c:\n                case 0x17d:\n                case 0x17e:\n                case 0x17f:\n                case 0x180:\n                    auVar1 = vmovntdq_avx(auVar12);\n                    *(pauVar3[4] + uVar6) = auVar1;\n                case 0x141:\n                case 0x142:\n                case 0x143:\n                case 0x144:\n                case 0x145:\n                case 0x146:\n                case 0x147:\n                case 0x148:\n                case 0x149:\n                case 0x14a:\n                case 0x14b:\n                case 0x14c:\n                case 0x14d:\n                case 0x14e:\n                case 0x14f:\n                case 0x150:\n                case 0x151:\n                case 0x152:\n                case 0x153:\n                case 0x154:\n                case 0x155:\n                case 0x156:\n                case 0x157:\n                case 0x158:\n                case 0x159:\n                case 0x15a:\n                case 0x15b:\n                case 0x15c:\n                case 0x15d:\n                case 0x15e:\n                case 0x15f:\n                case 0x160:\n                    auVar1 = vmovntdq_avx(auVar12);\n                    *(pauVar3[5] + uVar6) = auVar1;\n                case 0x121:\n                case 0x122:\n                case 0x123:\n                case 0x124:\n                case 0x125:\n                case 0x126:\n                case 0x127:\n                case 0x128:\n                case 0x129:\n                case 0x12a:\n                case 299:\n                case 300:\n                case 0x12d:\n                case 0x12e:\n                case 0x12f:\n                case 0x130:\n                case 0x131:\n                case 0x132:\n                case 0x133:\n                case 0x134:\n                case 0x135:\n                case 0x136:\n                case 0x137:\n                case 0x138:\n                case 0x139:\n                case 0x13a:\n                case 0x13b:\n                case 0x13c:\n                case 0x13d:\n                case 0x13e:\n                case 0x13f:\n                case 0x140:\n                    auVar1 = vmovntdq_avx(auVar12);\n                    *(pauVar3[6] + uVar6) = auVar1;\n                default:\n                    auVar1 = vmovdqu_avx(auVar12);\n                    *(pauVar3[-1] + uVar5) = auVar1;\n                case 0x100:\n                    auVar12 = vmovdqu_avx(auVar12);\n                    *arg1 = auVar12;\n                    vzeroupper_avx();\n                    return arg1;\n                }\n            }\n            do {\n                *pauVar2 = auVar12;\n                pauVar2[1] = auVar12;\n                pauVar2[2] = auVar12;\n                pauVar2[3] = auVar12;\n                pauVar2[4] = auVar12;\n                pauVar2[5] = auVar12;\n                pauVar2[6] = auVar12;\n                pauVar2[7] = auVar12;\n                pauVar2 = pauVar2[8];\n                arg3 = arg3 - 0x100;\n            } while (0xff < arg3);\n        }\n    // WARNING: Could not recover jumptable at 0x000140004824. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (27 cases) at 0x1400600f0\n        pauVar2 = (*(*((arg3 + 0x1f >> 5) * 4 + 0x1400600f0) + 0x140000000))\n                            (SUB328(auVar12, 0), pauVar2, uVar5 - iVar10);\n        return pauVar2;\n    }\n    for (; arg3 != 0; arg3 = arg3 - 1) {\n        (*pauVar2)[0] = noname_1;\n        pauVar2 = *pauVar2 + 1;\n    }\n    return arg1;\n}\n",
        "token_count": 4156
    },
    "140002ff": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353"
        ],
        "decompiled_code": "\nvoid fcn.140002ff8(ulong arg1, ulong arg2, uint64_t arg3)\n\n{\n    ulong uVar1;\n    \n    arg3 = arg3 & 0xffffffff;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    uVar1 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1, 0, arg3);\n    fcn.140003a08(arg2, arg3, 4);\n    fcn.140003a88(arg1, arg2, uVar1, arg3);\n    return;\n}\n",
        "token_count": 129
    },
    "140003a0": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_2h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nbool fcn.140003a08(ulong arg1, ulong arg2, ulong arg3)\n\n{\n    int32_t iVar1;\n    ulong arg1_00;\n    code *pcVar2;\n    uchar auStackX16 [8];\n    ulong var_28h;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    ushort uStack28;\n    uchar uStack26;\n    ulong var_10h;\n    ulong var_2h;\n    \n    uStack40 = 0x74726956;\n    uStack26 = 0;\n    uStack36 = 0x506c6175;\n    uStack32 = 0x65746f72;\n    uStack28 = 0x7463;\n    arg1_00 = fcn.140002da0(0x14000f260);\n    pcVar2 = fcn.140002e04(arg1_00, &uStack40);\n    iVar1 = (*pcVar2)(arg1, arg2, arg3, auStackX16);\n    return iVar1 != 0;\n}\n",
        "token_count": 269
    },
    "140009ad": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353"
        ],
        "decompiled_code": "\nulong fcn.140009adc(int64_t arg1, ulong arg2, int64_t arg3, int64_t *arg4)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int64_t iVar3;\n    uint64_t uVar4;\n    ulong uVar5;\n    int64_t iVar6;\n    \n    uVar5 = 0;\n    iVar3 = -1;\n    do {\n        iVar6 = iVar3;\n        iVar3 = iVar6 + 1;\n    } while (*(arg1 + iVar3) != '\\0');\n    uVar4 = iVar6 + 2;\n    if (-arg3 - 1U < uVar4) {\n        return 0xc;\n    }\n    iVar6 = arg3 + 1 + uVar4;\n    iVar3 = fcn.14000918c(iVar6, 1);\n    if ((arg3 != 0) && (iVar2 = fcn.14000babc(iVar3, iVar6, arg2, arg3),  iVar2 != 0)) {\n        fcn.140005da0(0, 0, 0, 0, 0);\n        pcVar1 = swi(3);\n        uVar5 = (*pcVar1)();\n        return uVar5;\n    }\n    iVar2 = fcn.14000babc(iVar3 + arg3, iVar6 - arg3, arg1, uVar4);\n    if (iVar2 != 0) {\n        fcn.140005da0(0, 0, 0, 0, 0);\n        pcVar1 = swi(3);\n        uVar5 = (*pcVar1)();\n        return uVar5;\n    }\n    if (arg4[1] == arg4[2]) {\n        if (*arg4 == 0) {\n            iVar6 = fcn.14000918c(4, 8);\n            *arg4 = iVar6;\n            fcn.1400080ec(0);\n            iVar6 = *arg4;\n            if (iVar6 != 0) {\n                arg4[1] = iVar6;\n                arg4[2] = iVar6 + 0x20;\n                goto code_r0x000140009bcf;\n            }\n        }\n        else {\n            uVar4 = arg4[2] - *arg4 >> 3;\n            if (uVar4 < 0x8000000000000000) {\n                iVar6 = fcn.140009ec0(*arg4, uVar4 * 2, 8);\n                if (iVar6 != 0) {\n                    *arg4 = iVar6;\n                    arg4[1] = iVar6 + uVar4 * 8;\n                    arg4[2] = iVar6 + uVar4 * 0x10;\n                    fcn.1400080ec(0);\n                    goto code_r0x000140009bcf;\n                }\n                fcn.1400080ec(0);\n            }\n        }\n        fcn.1400080ec(iVar3);\n        uVar5 = 0xc;\n    }\n    else {\ncode_r0x000140009bcf:\n        *arg4[1] = iVar3;\n        arg4[1] = arg4[1] + 8;\n    }\n    fcn.1400080ec(0);\n    return uVar5;\n}\n",
        "token_count": 736
    },
    "14000a05": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353"
        ],
        "decompiled_code": "\nuint64_t fcn.14000a05c(uint64_t arg1, ulong arg2)\n\n{\n    uint64_t arg2_00;\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint64_t uVar4;\n    int64_t iVar5;\n    int64_t *piVar6;\n    uint64_t uVar7;\n    int64_t *piVar8;\n    uint32_t uVar9;\n    uint64_t uVar10;\n    int64_t iVar11;\n    bool bVar12;\n    \n    uVar7 = 0;\n    uVar9 = 0;\n    if (arg1 == 0) {\n        puVar3 = fcn.140008584();\n        *puVar3 = 0x16;\n        return 0xffffffffffffffff;\n    }\n    uVar4 = fcn.14000bd98(arg1, 0x3d);\n    uVar10 = arg1;\n    if ((uVar4 == 0) || (uVar4 == arg1)) {\ncode_r0x00014000a337:\n        puVar3 = fcn.140008584();\n        uVar9 = 0xffffffff;\n        *puVar3 = 0x16;\n    }\n    else {\n        bVar12 = *(uVar4 + 1) == '\\0';\n        if (*0x14005ab78 == *0x14005ab90) {\n            *0x14005ab78 = fcn.14000a388(*0x14005ab78);\n        }\n        if (*0x14005ab78 == NULL) {\n            if ((arg2 != 0) && (*0x14005ab80 != 0)) {\n                iVar5 = fcn.1400059b0();\n                if (iVar5 != 0) {\n                    if (*0x14005ab78 == *0x14005ab90) {\n                        *0x14005ab78 = fcn.14000a388(*0x14005ab78);\n                    }\n                    goto code_r0x00014000a1ac;\n                }\n                goto code_r0x00014000a337;\n            }\n            if (!bVar12) {\n                *0x14005ab78 = fcn.14000918c(1, 8);\n                fcn.1400080ec(0);\n                if (*0x14005ab78 != NULL) {\n                    if (*0x14005ab80 == 0) {\n                        *0x14005ab80 = fcn.14000918c(1, 8);\n                        fcn.1400080ec(0);\n                        if (*0x14005ab80 == 0) goto code_r0x00014000a16f;\n                    }\ncode_r0x00014000a1ac:\n                    if (*0x14005ab78 != NULL) goto code_r0x00014000a1b1;\n                }\ncode_r0x00014000a16f:\n                uVar9 = 0xffffffff;\n            }\n        }\n        else {\ncode_r0x00014000a1b1:\n            piVar6 = *0x14005ab78;\n            iVar11 = uVar4 - arg1;\n            iVar5 = **0x14005ab78;\n            piVar8 = *0x14005ab78;\n            while (iVar5 != 0) {\n                iVar2 = fcn.14000be18(arg1, *piVar8, iVar11);\n                if ((iVar2 == 0) && ((*(iVar11 + *piVar8) == '=' || (*(iVar11 + *piVar8) == '\\0')))) {\n                    iVar5 = piVar8 - piVar6 >> 3;\n                    goto code_r0x00014000a1fd;\n                }\n                piVar8 = piVar8 + 1;\n                iVar5 = *piVar8;\n            }\n            iVar5 = -(piVar8 - piVar6 >> 3);\ncode_r0x00014000a1fd:\n            if ((-1 < iVar5) && (*piVar6 != 0)) {\n                fcn.1400080ec(piVar6[iVar5]);\n                if (bVar12) {\n                    for (; piVar6[iVar5] != 0; iVar5 = iVar5 + 1) {\n                        piVar6[iVar5] = piVar6[iVar5 + 1];\n                    }\n                    piVar6 = fcn.140009ec0(piVar6, iVar5, 8);\n                    fcn.1400080ec(0);\n                    if (piVar6 != NULL) {\n                        *0x14005ab78 = piVar6;\n                    }\n                }\n                else {\n                    piVar6[iVar5] = arg1;\n                    uVar10 = uVar7;\n                }\ncode_r0x00014000a2b6:\n                if (arg2 != 0) {\n                    iVar5 = -1;\n                    do {\n                        iVar11 = iVar5;\n                        iVar5 = iVar11 + 1;\n                    } while (*(arg1 + iVar11 + 1) != '\\0');\n                    iVar5 = fcn.14000918c(iVar11 + 3, 1);\n                    if (iVar5 != 0) {\n                        iVar2 = fcn.140006614(iVar5, iVar11 + 3, arg1);\n                        if (iVar2 != 0) {\n                            fcn.140005da0(0, 0, 0, 0, 0);\n                            pcVar1 = swi(3);\n                            uVar7 = (*pcVar1)();\n                            return uVar7;\n                        }\n                        uVar4 = uVar4 + 1 + (iVar5 - arg1);\n                        *(uVar4 - 1) = 0;\n                        if (bVar12) {\n                            uVar4 = uVar7;\n                        }\n                        iVar2 = (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(iVar5, uVar4);\n                        if (iVar2 == 0) {\n                            puVar3 = fcn.140008584();\n                            uVar7 = 0xffffffff;\n                            *puVar3 = 0x2a;\n                        }\n                    }\n                    fcn.1400080ec(iVar5);\n                }\n                goto code_r0x00014000a34e;\n            }\n            if (!bVar12) {\n                arg2_00 = -iVar5 + 2;\n                if ((-iVar5 <= arg2_00) && (arg2_00 < 0x1fffffffffffffff)) {\n                    piVar6 = fcn.140009ec0(piVar6, arg2_00, 8);\n                    fcn.1400080ec(0);\n                    if (piVar6 != NULL) {\n                        piVar6[-iVar5] = arg1;\n                        piVar6[1 - iVar5] = 0;\n                        uVar10 = uVar7;\n                        *0x14005ab78 = piVar6;\n                        goto code_r0x00014000a2b6;\n                    }\n                }\n                uVar9 = 0xffffffff;\n            }\n        }\n    }\n    uVar7 = uVar9;\ncode_r0x00014000a34e:\n    fcn.1400080ec(uVar10);\n    return uVar7;\n}\n",
        "token_count": 1589
    },
    "14000306": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nulong fcn.140003068(ulong arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    int32_t iVar1;\n    ulong uVar2;\n    code *pcVar3;\n    code *pcVar4;\n    code *pcVar5;\n    code *pcVar6;\n    code *pcVar7;\n    uint auStackX16 [2];\n    ulong in_stack_fffffffffffffed8;\n    uint uVar8;\n    uint uStack280;\n    uint uStack276;\n    uint uStack272;\n    uchar uStack268;\n    uint uStack264;\n    uint uStack260;\n    uint uStack256;\n    uchar uStack252;\n    uint uStack248;\n    uint uStack244;\n    uint uStack240;\n    ushort uStack236;\n    uint uStack232;\n    uint uStack228;\n    uint uStack224;\n    ushort uStack220;\n    uchar uStack218;\n    ulong uStack216;\n    ulong uStack208;\n    ulong uStack200;\n    uint uStack192;\n    uint uStack188;\n    uint uStack184;\n    uint uStack180;\n    uint uStack176;\n    uchar uStack172;\n    uint uStack168;\n    uint uStack164;\n    uint uStack160;\n    uint uStack156;\n    uint uStack152;\n    code *pcStack144;\n    code *pcStack136;\n    code *pcStack128;\n    uint uStack120;\n    uint uStack116;\n    uint uStack112;\n    uint uStack108;\n    uchar uStack104;\n    uint uStack96;\n    uint uStack92;\n    uint uStack88;\n    uint uStack84;\n    uint uStack80;\n    uint uStack76;\n    uint uStack72;\n    uint uStack68;\n    \n    uVar8 = in_stack_fffffffffffffed8 >> 0x20;\n    uStack280 = 0x61766461;\n    uStack268 = 0;\n    uStack192 = str.CryptDestroyHashCryptAcquireContCryptReleaseCont._16_4_;\n    uStack188 = str.CryptDestroyHashCryptAcquireContCryptReleaseCont._20_4_;\n    uStack184 = str.CryptDestroyHashCryptAcquireContCryptReleaseCont._24_4_;\n    uStack180 = str.CryptDestroyHashCryptAcquireContCryptReleaseCont._28_4_;\n    uStack172 = 0;\n    uStack276 = 0x32336970;\n    uStack272 = 0x6c6c642e;\n    uStack176 = 0x57747865;\n    auStackX16[0] = arg2;\n    uVar2 = fcn.140002ed0(&uStack280);\n    pcVar3 = fcn.140002e04(uVar2, &uStack192);\n    uStack96 = *0x14000f200;\n    uStack92 = str.tCreateHash._0_4_;\n    uStack88 = str.tCreateHash._4_4_;\n    uStack84 = str.tCreateHash._8_4_;\n    uVar2 = fcn.140002ed0(&uStack280);\n    pcVar4 = fcn.140002e04(uVar2, &uStack96);\n    uStack248 = 0x70797243;\n    uStack244 = 0x73614874;\n    uStack240 = 0x74614468;\n    uStack236 = 0x61;\n    uVar2 = fcn.140002ed0(&uStack280);\n    pcStack144 = fcn.140002e04(uVar2, &uStack248);\n    uStack232 = 0x70797243;\n    uStack228 = 0x72654474;\n    uStack224 = 0x4b657669;\n    uStack220 = 0x7965;\n    uStack218 = 0;\n    uVar2 = fcn.140002ed0(&uStack280);\n    pcStack136 = fcn.140002e04(uVar2, &uStack232);\n    uStack264 = 0x70797243;\n    uStack260 = 0x63654474;\n    uStack256 = 0x74707972;\n    uStack252 = 0;\n    uVar2 = fcn.140002ed0(&uStack280);\n    pcStack128 = fcn.140002e04(uVar2, &uStack264);\n    uStack168 = str.CryptDestroyHashCryptAcquireContCryptReleaseCont._32_4_;\n    uStack164 = str.CryptDestroyHashCryptAcquireContCryptReleaseCont._36_4_;\n    uStack160 = str.CryptDestroyHashCryptAcquireContCryptReleaseCont._40_4_;\n    uStack156 = str.CryptDestroyHashCryptAcquireContCryptReleaseCont._44_4_;\n    uStack152 = 0x747865;\n    uVar2 = fcn.140002ed0(&uStack280);\n    pcVar5 = fcn.140002e04(uVar2, &uStack168);\n    uStack120 = str.CryptDestroyHashCryptAcquireContCryptReleaseCont._0_4_;\n    uStack116 = str.CryptDestroyHashCryptAcquireContCryptReleaseCont._4_4_;\n    uStack112 = str.CryptDestroyHashCryptAcquireContCryptReleaseCont._8_4_;\n    uStack108 = str.CryptDestroyHashCryptAcquireContCryptReleaseCont._12_4_;\n    uStack104 = 0;\n    uVar2 = fcn.140002ed0(&uStack280);\n    pcVar6 = fcn.140002e04(uVar2, &uStack120);\n    uStack80 = str.CryptDestroyKey._0_4_;\n    uStack76 = str.CryptDestroyKey._4_4_;\n    uStack72 = str.CryptDestroyKey._8_4_;\n    uStack68 = str.CryptDestroyKey._12_4_;\n    uVar2 = fcn.140002ed0(&uStack280);\n    pcVar7 = fcn.140002e04(uVar2, &uStack80);\n    iVar1 = (*pcVar3)(&uStack216, 0, 0, 0x18, CONCAT44(uVar8, 0xf0000000));\n    if ((((iVar1 != 0) && (iVar1 = (*pcVar4)(uStack216, 0x800c, 0, 0, &uStack208),  iVar1 != 0)) &&\n        (iVar1 = (*pcStack144)(uStack208, arg3, arg4, 0),  iVar1 != 0)) &&\n       ((iVar1 = (*pcStack136)(uStack216, 0x6610, uStack208, 0, &uStack200),  iVar1 != 0 &&\n        (iVar1 = (*pcStack128)(uStack200, 0, 1, 0, arg1, auStackX16),  iVar1 != 0)))) {\n        (*pcVar5)(uStack216, 0);\n        (*pcVar6)(uStack208);\n        (*pcVar7)(uStack200);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 1571
    },
    "140003b0": {
        "rules": [
            "encrypt data using Curve25519/bbf924b96e5b4ce780ce59f68f21b030"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x000140003bd6)\n// WARNING: Removing unreachable block (ram,0x000140003b46)\n// WARNING: Removing unreachable block (ram,0x000140003b1f)\n\nulong fcn.140003b0c(ulong noname_0, ulong arg2)\n\n{\n    int32_t *piVar1;\n    uint32_t *puVar2;\n    int64_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint8_t in_XCR0;\n    \n    piVar1 = cpuid_basic_info(0);\n    uVar6 = 0;\n    puVar2 = cpuid_Version_info(1);\n    uVar4 = puVar2[3];\n    if ((piVar1[2] ^ 0x49656e69U | piVar1[3] ^ 0x6c65746eU | piVar1[1] ^ 0x756e6547U) == 0) {\n        *0x140059ff8 = 0xffffffffffffffff;\n        uVar5 = *puVar2 & 0xfff3ff0;\n        *0x140059ff0 = 0x8000;\n        if ((((uVar5 == 0x106c0) || (uVar5 == 0x20660)) || (uVar5 == 0x20670)) ||\n           ((uVar5 - 0x30650 < 0x21 && ((0x100010001U >> (uVar5 - 0x30650 & 0x3f) & 1) != 0)))) {\n            *0x14005a9c8 = *0x14005a9c8 | 1;\n        }\n    }\n    if (6 < *piVar1) {\n        iVar3 = cpuid_Extended_Feature_Enumeration_info(7);\n        uVar6 = *(iVar3 + 4);\n        if ((uVar6 >> 9 & 1) != 0) {\n            *0x14005a9c8 = *0x14005a9c8 | 2;\n        }\n    }\n    *0x140059fe8 = 1;\n    *0x140059fec = 2;\n    if ((uVar4 >> 0x14 & 1) != 0) {\n        *0x140059fe8 = 2;\n        *0x140059fec = 6;\n        if ((((uVar4 >> 0x1b & 1) != 0) && ((uVar4 >> 0x1c & 1) != 0)) && ((in_XCR0 & 6) == 6)) {\n            *0x140059fec = 0xe;\n            *0x140059fe8 = 3;\n            if ((uVar6 & 0x20) != 0) {\n                *0x140059fe8 = 5;\n                *0x140059fec = 0x2e;\n                if (((uVar6 & 0xd0030000) == 0xd0030000) && ((in_XCR0 & 0xe0) == 0xe0)) {\n                    *0x140059fec = 0x6e;\n                    *0x140059fe8 = 6;\n                }\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 750
    },
    "1400098c": {
        "rules": [
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0",
            "hash data using aphash/10489b186fc44711a1078750698db7a9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_bp_10h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Could not reconcile some variable overlaps\n\nuint64_t fcn.1400098c8(int64_t *arg1, int64_t *arg2)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint64_t uVar5;\n    int64_t iVar6;\n    int64_t iVar7;\n    int64_t *piVar8;\n    uint64_t uVar9;\n    uint64_t uVar10;\n    uint64_t uVar11;\n    int64_t iVar12;\n    int64_t iVar13;\n    ulong uStackX24;\n    int64_t iStackX32;\n    ulong var_50h;\n    ulong var_58h;\n    uchar auStack88 [16];\n    ulong uStack72;\n    ulong var_30h;\n    ulong var_28h;\n    ulong var_20h;\n    ulong var_18h;\n    ulong var_bp_10h;\n    \n    uVar9 = 0;\n    if (arg2 == NULL) {\n        puVar4 = fcn.140008584();\n        *puVar4 = 0x16;\n        fcn.140005d80();\n        uVar5 = 0x16;\n    }\n    else {\n        *arg2 = 0;\n        iVar6 = *arg1;\n        auStack88 = ZEXT816(0);\n        uStack72 = 0;\n        while (iVar6 != 0) {\n            uStackX24 = CONCAT53(uStackX24._3_5_, 0x3f2a);\n            iVar6 = fcn.14000bb90(*arg1, &uStackX24);\n            if (iVar6 == 0) {\n                uVar2 = fcn.140009adc(*arg1, 0, 0, auStack88);\n            }\n            else {\n                uVar2 = fcn.140009c74(*arg1, iVar6, auStack88);\n            }\n            uVar5 = uVar2;\n            if (uVar2 != 0) {\n                goto code_r0x000140009a70;\n            }\n            arg1 = arg1 + 1;\n            iVar6 = *arg1;\n        }\n        uStackX24 = 0;\n        iVar6 = (auStack88._8_8_ - auStack88._0_8_ >> 3) + 1;\n        uVar5 = (auStack88._8_8_ - auStack88._0_8_) + 7U >> 3;\n        if (auStack88._8_8_ < auStack88._0_8_) {\n            uVar5 = uVar9;\n        }\n        piVar8 = auStack88._0_8_;\n        uVar10 = uVar9;\n        uVar11 = uVar9;\n        if (uVar5 != 0) {\n            do {\n                iVar7 = -1;\n                do {\n                    iVar7 = iVar7 + 1;\n                } while (*(*piVar8 + iVar7) != '\\0');\n                piVar8 = piVar8 + 1;\n                uVar11 = uVar11 + 1 + iVar7;\n                uVar10 = uVar10 + 1;\n                uStackX24 = uVar11;\n            } while (uVar10 != uVar5);\n        }\n        iVar7 = fcn.1400052c4(iVar6, uStackX24);\n        uVar5 = 0xffffffffffffffff;\n        if (iVar7 != 0) {\n            iVar6 = iVar7 + iVar6 * 8;\n            iStackX32 = iVar6;\n            if (auStack88._0_8_ != auStack88._8_8_) {\n                piVar8 = auStack88._0_8_;\n                do {\n                    iVar12 = -1;\n                    do {\n                        iVar13 = iVar12;\n                        iVar12 = iVar13 + 1;\n                    } while (*(*piVar8 + iVar12) != '\\0');\n                    iVar13 = iVar13 + 2;\n                    iVar3 = fcn.14000babc(iStackX32, (iVar6 - iStackX32) + uStackX24, *piVar8, iVar13);\n                    if (iVar3 != 0) {\n                        fcn.140005da0(0, 0, 0, 0, 0);\n                        pcVar1 = swi(3);\n                        uVar9 = (*pcVar1)();\n                        return uVar9;\n                    }\n                    *((iVar7 - auStack88._0_8_) + piVar8) = iStackX32;\n                    iStackX32 = iStackX32 + iVar13;\n                    piVar8 = piVar8 + 1;\n                } while (piVar8 != auStack88._8_8_);\n            }\n            *arg2 = iVar7;\n            uVar5 = uVar9;\n        }\n        fcn.1400080ec(0);\ncode_r0x000140009a70:\n        uVar10 = auStack88._8_8_ + (7 - auStack88._0_8_) >> 3;\n        if (auStack88._8_8_ < auStack88._0_8_) {\n            uVar10 = uVar9;\n        }\n        piVar8 = auStack88._0_8_;\n        if (uVar10 != 0) {\n            do {\n                fcn.1400080ec(*piVar8);\n                uVar9 = uVar9 + 1;\n                piVar8 = piVar8 + 1;\n            } while (uVar9 != uVar10);\n        }\n        fcn.1400080ec(auStack88._0_8_);\n        uVar5 = uVar5 & 0xffffffff;\n    }\n    return uVar5;\n}\n",
        "token_count": 1356
    },
    "14000642": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuchar fcn.14000642c(void)\n\n{\n    if (*0x14005a014 != 0xffffffff) {\n        fcn.14000a7e0(*0x14005a014);\n        *0x14005a014 = 0xffffffff;\n    }\n    return 1;\n}\n",
        "token_count": 66
    },
    "1400078a": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuchar fcn.1400078a8(void)\n\n{\n    if (*0x14005a560 != 0xffffffff) {\n        fcn.1400072f0(*0x14005a560);\n        *0x14005a560 = 0xffffffff;\n    }\n    return 1;\n}\n",
        "token_count": 66
    },
    "1400075b": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nuint64_t fcn.1400075b4(ulong arg1, ulong arg2, uint32_t *arg3, uint32_t *arg4)\n\n{\n    int64_t *piVar1;\n    ulong arg1_00;\n    int64_t iVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    int64_t iVar5;\n    uint64_t uVar6;\n    uint64_t uVar7;\n    \n    uVar7 = arg1;\n    uVar6 = *0x14005a000 ^ *(uVar7 * 8 + 0x14005ad90);\n    uVar3 = *0x14005a000 & 0x3f;\n    uVar6 = uVar6 >> uVar3 | uVar6 << 0x40 - uVar3;\n    if (uVar6 != 0xffffffffffffffff) {\n        if (uVar6 != 0) {\n            return uVar6;\n        }\n        if (arg3 != arg4) {\n            do {\n                uVar6 = *arg3;\n                iVar5 = *(uVar6 * 8 + 0x14005acf0);\n                if (iVar5 == 0) {\n                    arg1_00 = *(uVar6 * 8 + 0x14000fc40);\n                    iVar5 = (*_sym.imp.KERNEL32.dll_LoadLibraryExW)(arg1_00, 0);\n                    if (iVar5 == 0) {\n                        iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        if (((iVar4 == 0x57) && (iVar4 = fcn.140009204(arg1_00, L\"api-ms-\", 7),  iVar4 != 0)) &&\n                           (iVar4 = fcn.140009204(arg1_00, L\"ext-ms-\", 7),  iVar4 != 0)) {\n                            iVar5 = (*_sym.imp.KERNEL32.dll_LoadLibraryExW)(arg1_00, 0, 0);\n                        }\n                        else {\n                            iVar5 = 0;\n                        }\n                    }\n                    if (iVar5 != 0) {\n                        piVar1 = uVar6 * 8 + 0x14005acf0;\n                        iVar2 = *piVar1;\n                        *piVar1 = iVar5;\n                        if (iVar2 != 0) {\n                            (*_sym.imp.KERNEL32.dll_FreeLibrary)(iVar5);\n                        }\n                        goto code_r0x0001400076e6;\n                    }\n                    *(uVar6 * 8 + 0x14005acf0) = 0xffffffffffffffff;\n                }\n                else if (iVar5 != -1) {\ncode_r0x0001400076e6:\n                    if (iVar5 != 0) goto code_r0x000140007701;\n                }\n                arg3 = arg3 + 1;\n            } while (arg3 != arg4);\n        }\n        iVar5 = 0;\ncode_r0x000140007701:\n        if ((iVar5 != 0) && (uVar6 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar5, arg2),  uVar6 != 0)) {\n            uVar3 = 0x40 - (*0x14005a000 & 0x3f) & 0x3f;\n            *(uVar7 * 8 + 0x14005ad90) = (uVar6 >> uVar3 | uVar6 << 0x40 - uVar3) ^ *0x14005a000;\n            return uVar6;\n        }\n        uVar3 = 0x40 - (*0x14005a000 & 0x3f) & 0x3f;\n        *(uVar7 * 8 + 0x14005ad90) = (0xffffffffffffffffU >> uVar3 | -1 << 0x40 - uVar3) ^ *0x14005a000;\n    }\n    return 0;\n}\n",
        "token_count": 868
    },
    "14000853": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nuint64_t fcn.14000853c(ulong noname_0, uint32_t *arg2, ulong noname_2, uint32_t *arg4)\n\n{\n    uint8_t uVar1;\n    uint64_t uVar2;\n    \n    fcn.14000780c(*arg2);\n    uVar1 = *0x14005a000 & 0x3f;\n    uVar2 = *0x14005a000 ^ *0x14005b500;\n    fcn.140007828(*arg4);\n    return uVar2 >> uVar1 | uVar2 << 0x40 - uVar1;\n}\n",
        "token_count": 143
    },
    "14000a74": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nvoid fcn.14000a748(ulong arg1)\n\n{\n    // WARNING: Could not recover jumptable at 0x00014000a764. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)((arg1 & 0x3f) * 0x40 + *((arg1 >> 6) * 8 + 0x14005b0e0));\n    return;\n}\n",
        "token_count": 102
    },
    "14000a76": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nvoid fcn.14000a76c(ulong arg1)\n\n{\n    // WARNING: Could not recover jumptable at 0x00014000a788. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)((arg1 & 0x3f) * 0x40 + *((arg1 >> 6) * 8 + 0x14005b0e0));\n    return;\n}\n",
        "token_count": 104
    },
    "14000cfb": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nint64_t fcn.14000cfbc(ulong arg1, ulong arg2, ulong arg3)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int64_t iVar4;\n    uint *puVar5;\n    int64_t iStackX32;\n    \n    iVar4 = fcn.14000a474(arg1 & 0xffffffff);\n    if (iVar4 == -1) {\n        puVar5 = fcn.140008584();\n        *puVar5 = 9;\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_SetFilePointerEx)(iVar4, arg2, &iStackX32, arg3);\n        if (iVar2 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            fcn.1400085c4(uVar3);\n        }\n        else if (iStackX32 != -1) {\n            puVar1 = *((arg1 >> 6) * 8 + 0x14005b0e0) + 0x38 + (arg1 & 0x3f) * 0x40;\n            *puVar1 = *puVar1 & 0xfd;\n            return iStackX32;\n        }\n    }\n    return -1;\n}\n",
        "token_count": 293
    },
    "140008a2": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140008a2c(int64_t arg1)\n\n{\n    // WARNING: Could not recover jumptable at 0x000140008a30. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(arg1 + 0x30);\n    return;\n}\n",
        "token_count": 76
    },
    "140008a3": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140008a38(int64_t arg1)\n\n{\n    // WARNING: Could not recover jumptable at 0x000140008a3c. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(arg1 + 0x30);\n    return;\n}\n",
        "token_count": 77
    },
    "140002da": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140002da0(int64_t arg1)\n\n{\n    int32_t iVar1;\n    ulong uVar2;\n    ulong *puVar3;\n    ulong *puVar4;\n    int64_t in_GS_OFFSET;\n    \n    if (arg1 == 0) {\n        uVar2 = *(*(in_GS_OFFSET + 0x60) + 0x10);\n    }\n    else {\n        puVar4 = *(*(in_GS_OFFSET + 0x60) + 0x18) + 0x20;\n        for (puVar3 = *puVar4; puVar3 != puVar4; puVar3 = *puVar3) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_lstrcmpiW)(puVar3[10], arg1);\n            if (iVar1 == 0) {\n                return puVar3[4];\n            }\n        }\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 215
    },
    "140002e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop",
            "resolve function by parsing PE exports"
        ],
        "decompiled_code": "\nuint64_t fcn.140002e04(int64_t arg1, char *arg2)\n\n{\n    char cVar1;\n    char cVar2;\n    uint64_t uVar3;\n    uint64_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    char *pcVar7;\n    int64_t iVar8;\n    int64_t iVar9;\n    uint32_t *puVar10;\n    \n    uVar3 = 0;\n    iVar9 = *(*(arg1 + 0x3c) + 0x88 + arg1) + arg1;\n    iVar8 = *(iVar9 + 0x1c) + arg1;\n    puVar10 = *(iVar9 + 0x20) + arg1;\n    uVar4 = uVar3;\n    if (arg2 < 0x10000) {\n        uVar5 = *(iVar9 + 0x10);\n        uVar6 = arg2 & 0xffff;\n        if ((uVar5 <= uVar6) && (uVar6 < *(iVar9 + 0x14) + uVar5)) {\n            uVar5 = *(iVar8 + (uVar6 - uVar5) * 4);\ncode_r0x000140002eb3:\n            uVar4 = uVar5 + arg1;\n        }\n    }\n    else if (*(iVar9 + 0x18) != 0) {\n        do {\n            pcVar7 = arg2;\n            do {\n                cVar1 = *pcVar7;\n                cVar2 = pcVar7[(*puVar10 + arg1) - arg2];\n                if (cVar1 != cVar2) break;\n                pcVar7 = pcVar7 + 1;\n            } while (cVar2 != '\\0');\n            if (cVar1 == cVar2) {\n                uVar5 = *(iVar8 + *(*(iVar9 + 0x24) + arg1 + uVar3 * 2) * 4);\n                goto code_r0x000140002eb3;\n            }\n            uVar5 = uVar3 + 1;\n            uVar3 = uVar5;\n            puVar10 = puVar10 + 1;\n            uVar4 = 0;\n        } while (uVar5 < *(iVar9 + 0x18));\n    }\n    return uVar4;\n}\n",
        "token_count": 523
    },
    "14000389": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140003898(void)\n\n{\n    int64_t *piVar1;\n    \n    for (piVar1 = 0x140017488; piVar1 < 0x140017488; piVar1 = piVar1 + 1) {\n        if (*piVar1 != 0) {\n            (**0x14005d008)();\n        }\n    }\n    return;\n}\n",
        "token_count": 86
    },
    "140003a8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140003a88(ulong arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    ulong arg1_00;\n    code *pcVar1;\n    ulong in_stack_00000028;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uchar uStack20;\n    \n    uStack24 = 0x79726f6d;\n    uStack40 = str.NtWriteVirtualMeK._0_4_;\n    uStack36 = str.NtWriteVirtualMeK._4_4_;\n    uStack32 = str.NtWriteVirtualMeK._8_4_;\n    uStack28 = str.NtWriteVirtualMeK._12_4_;\n    uStack20 = 0;\n    arg1_00 = fcn.140002da0(0x14000f2d0);\n    pcVar1 = fcn.140002e04(arg1_00, &uStack40);\n    (*pcVar1)(arg1, arg2, arg3, arg4, in_stack_00000028);\n    return;\n}\n",
        "token_count": 251
    },
    "140004b3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140004b3c(void)\n\n{\n    int64_t *piVar1;\n    bool bVar2;\n    \n    piVar1 = 0x14000f428;\n    do {\n        if (*piVar1 != 0) {\n            (**0x14005d008)(0);\n        }\n        bVar2 = piVar1 != 0x14000f348;\n        piVar1 = piVar1 + -2;\n    } while (bVar2);\n    return 1;\n}\n",
        "token_count": 112
    },
    "14000552": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.140005524(ulong arg1, ulong arg2)\n\n{\n    ulong uStackX8;\n    ulong uStackX16;\n    ulong var_20h_2;\n    ulong var_28h;\n    ulong var_20h;\n    ulong *var_18h;\n    ulong *var_bp_10h;\n    \n    var_18h = &uStackX8;\n    var_bp_10h = &uStackX16;\n    var_28h._0_4_ = 2;\n    var_20h._0_4_ = 2;\n    uStackX8 = arg1;\n    uStackX16 = arg2;\n    fcn.1400058e0(&var_20h_2, &var_20h, &var_18h, &var_28h);\n    return;\n}\n",
        "token_count": 193
    },
    "140005a2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140005a24(void)\n\n{\n    int64_t iVar1;\n    ulong uVar2;\n    int64_t arg1;\n    int64_t iVar3;\n    \n    uVar2 = 0;\n    if (*0x14005ab78 == 0) {\n        fcn.140006710();\n        arg1 = fcn.140009f58();\n        if (arg1 == 0) {\n            uVar2 = 0xffffffff;\n        }\n        else {\n            iVar3 = fcn.140005b0c(arg1);\n            iVar1 = iVar3;\n            if (iVar3 == 0) {\n                uVar2 = 0xffffffff;\n                iVar3 = *0x14005ab78;\n                iVar1 = *0x14005ab90;\n            }\n            *0x14005ab90 = iVar1;\n            *0x14005ab78 = iVar3;\n            fcn.1400080ec(0);\n        }\n        fcn.1400080ec(arg1);\n    }\n    else {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 243
    },
    "140005a9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140005a90(int64_t *arg1)\n\n{\n    if (*arg1 != *0x14005ab90) {\n        fcn.140005ac8(*arg1);\n    }\n    return;\n}\n",
        "token_count": 50
    },
    "140005aa": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140005aac(int64_t *arg1)\n\n{\n    if (*arg1 != *0x14005ab88) {\n        fcn.140005ac8(*arg1);\n    }\n    return;\n}\n",
        "token_count": 49
    },
    "1400087e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t fcn.1400087ec(uint64_t arg1)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    uint *puVar3;\n    \n    if (arg1 < 0xffffffffffffffe1) {\n        if (arg1 == 0) {\n            arg1 = 1;\n        }\n        do {\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x14005b0d8, 0, arg1);\n            if (iVar2 != 0) {\n                return iVar2;\n            }\n            iVar1 = fcn.1400061d8();\n        } while ((iVar1 != 0) && (iVar1 = fcn.1400081ec(arg1),  iVar1 != 0));\n    }\n    puVar3 = fcn.140008584();\n    *puVar3 = 0xc;\n    return 0;\n}\n",
        "token_count": 199
    },
    "14000624": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool fcn.140006240(int16_t *arg1)\n\n{\n    if ((*arg1 == 0x5a4d) && (*(*(arg1 + 0x1e) + arg1) == 0x4550)) {\n        return *(*(arg1 + 0x1e) + arg1 + 6) == 0x20b;\n    }\n    return false;\n}\n",
        "token_count": 88
    },
    "1400066b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.1400066bc(void)\n\n{\n    uint64_t uVar1;\n    \n    uVar1 = *0x14005acc0;\n    while (uVar1 != 0) {\n        uVar1 = uVar1 - 1;\n        (*_sym.imp.KERNEL32.dll_DeleteCriticalSection)(uVar1 * 0x28 + 0x14005ac98);\n        *0x14005acc0 = *0x14005acc0 - 1;\n    }\n    return 1;\n}\n",
        "token_count": 114
    },
    "1400066f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * fcn.1400066f4(ulong arg1)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int64_t iVar3;\n    int32_t *piVar4;\n    ulong in_RDX;\n    int32_t *lpMem;\n    \n    iVar3 = fcn.1400078cc(arg1, in_RDX);\n    piVar4 = *0x14005acc8;\n    if (((*(iVar3 + 0x3a8) & *0x14005a8a0) == 0) || (*(iVar3 + 0x90) == 0)) {\n        fcn.14000780c(5);\n        lpMem = *(iVar3 + 0x88);\n        if (lpMem != piVar4) {\n            if (lpMem != NULL) {\n                LOCK();\n                iVar1 = *lpMem;\n                *lpMem = *lpMem + -1;\n                if ((iVar1 == 1) && (lpMem != 0x14005a020)) {\n                    fcn.1400080ec(lpMem);\n                }\n            }\n            *(iVar3 + 0x88) = piVar4;\n            LOCK();\n            *piVar4 = *piVar4 + 1;\n            lpMem = piVar4;\n        }\n        fcn.140007828(5);\n    }\n    else {\n        lpMem = *(iVar3 + 0x88);\n    }\n    if (lpMem == NULL) {\n        fcn.14000638c();\n        pcVar2 = swi(3);\n        piVar4 = (*pcVar2)();\n        return piVar4;\n    }\n    return lpMem;\n}\n",
        "token_count": 368
    },
    "1400077d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.1400077d4(void)\n\n{\n    uint64_t uVar1;\n    \n    uVar1 = *0x14005b0d0;\n    while (uVar1 != 0) {\n        uVar1 = uVar1 - 1;\n        (*_sym.imp.KERNEL32.dll_DeleteCriticalSection)(uVar1 * 0x28 + 0x14005aea0);\n        *0x14005b0d0 = *0x14005b0d0 - 1;\n    }\n    return 1;\n}\n",
        "token_count": 121
    },
    "14000884": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.14000884c(uint16_t *arg1, uint8_t *arg2, uint64_t arg3)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint uVar3;\n    int64_t iStack40;\n    int64_t aiStack32 [2];\n    char cStack16;\n    \n    if ((arg2 != NULL) && (arg3 != 0)) {\n        if (*arg2 != 0) {\n            fcn.140004c90(&iStack40, 0);\n            if (*(aiStack32[0] + 0x138) == 0) {\n                if (arg1 != NULL) {\n                    *arg1 = *arg2;\n                }\n                uVar3 = 1;\n            }\n            else {\n                iVar1 = fcn.14000b54c(*arg2, aiStack32);\n                uVar3 = 1;\n                if (iVar1 == 0) {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                      (*(aiStack32[0] + 0xc), 9, arg2, 1, arg1, arg1 != NULL);\n                    if (iVar1 != 0) goto code_r0x000140008982;\n                }\n                else {\n                    iVar1 = *(aiStack32[0] + 8);\n                    if ((((1 < iVar1) && (iVar1 <= arg3)) &&\n                        (iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                           (*(aiStack32[0] + 0xc), 9, arg2, iVar1, arg1, arg1 != NULL),  iVar1 != 0)) ||\n                       ((*(aiStack32[0] + 8) <= arg3 && (arg2[1] != 0)))) {\n                        uVar3 = *(aiStack32[0] + 8);\n                        goto code_r0x000140008982;\n                    }\n                }\n                puVar2 = fcn.140008584();\n                uVar3 = 0xffffffff;\n                *puVar2 = 0x2a;\n            }\ncode_r0x000140008982:\n            if (cStack16 == '\\0') {\n                return uVar3;\n            }\n            *(iStack40 + 0x3a8) = *(iStack40 + 0x3a8) & 0xfffffffd;\n            return uVar3;\n        }\n        if (arg1 != NULL) {\n            *arg1 = 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 561
    },
    "14000899": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.14000899c(int64_t arg1, int64_t *arg2)\n\n{\n    int64_t iVar1;\n    \n    if ((*arg2 != *0x14005b510) && ((*0x14005a8a0 & *(arg1 + 0x3a8)) == 0)) {\n        iVar1 = fcn.140009718(arg1);\n        *arg2 = iVar1;\n    }\n    return;\n}\n",
        "token_count": 99
    },
    "1400089d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.1400089d0(int64_t arg1, int64_t *arg2)\n\n{\n    int64_t iVar1;\n    \n    if ((*arg2 != *0x14005acc8) && ((*0x14005a8a0 & *(arg1 + 0x3a8)) == 0)) {\n        iVar1 = fcn.1400066f4(arg1);\n        *arg2 = iVar1;\n    }\n    return;\n}\n",
        "token_count": 102
    },
    "140008cf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140008cf4(int64_t *arg1)\n\n{\n    if (arg1 != NULL) {\n        if (*arg1 != *0x14005a800) {\n            fcn.1400080ec(*arg1);\n        }\n        if (arg1[1] != *0x14005a808) {\n            fcn.1400080ec(arg1[1]);\n        }\n        if (arg1[2] != *0x14005a810) {\n            fcn.1400080ec(arg1[2]);\n        }\n        if (arg1[0xb] != *0x14005a858) {\n            fcn.1400080ec(arg1[0xb]);\n        }\n        if (arg1[0xc] != *0x14005a860) {\n            fcn.1400080ec(arg1[0xc]);\n        }\n    }\n    return;\n}\n",
        "token_count": 197
    },
    "14000bd0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.14000bd0c(int64_t arg1)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    \n    if (arg1 == 0) {\n        puVar1 = fcn.140008584();\n        *puVar1 = 0x16;\n        fcn.140005d80();\n        return 0xffffffffffffffff;\n    }\n    // WARNING: Could not recover jumptable at 0x00014000bd02. Too many branches\n    // WARNING: Treating indirect jump as call\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapSize)(*0x14005b0d8, 0, arg1);\n    return uVar2;\n}\n",
        "token_count": 156
    },
    "14000dcd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file"
        ],
        "decompiled_code": "\nvoid fcn.14000dcd0(void)\n\n{\n    *0x14005a8c0 = (*_sym.imp.KERNEL32.dll_CreateFileW)(L\"CONOUT$\", 0x40000000, 3, 0, 3, 0, 0);\n    return;\n}\n",
        "token_count": 67
    },
    "140002ed": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_28h_2\n// WARNING: Could not reconcile some variable overlaps\n\nulong fcn.140002ed0(ulong arg1)\n\n{\n    uint uVar1;\n    ulong uVar2;\n    code *pcVar3;\n    code *pcVar4;\n    ulong uStackX16;\n    ulong var_28h_2;\n    uint uStack104;\n    uint uStack100;\n    ushort uStack96;\n    uchar uStack94;\n    ulong var_50h;\n    ulong var_46h;\n    uint uStack68;\n    uint uStack64;\n    uint uStack60;\n    ulong var_30h;\n    uint var_28h;\n    uint var_24h;\n    uint var_bp_20h;\n    uint uStack36;\n    ulong var_bp_18h;\n    ulong var_4h;\n    \n    stack0xffffffffffffffb8 = 0x74004e;\n    uStack94 = 0;\n    var_bp_18h._4_1_ = 0;\n    uStack68 = 0x6c0064;\n    uStack64 = 0x2e006c;\n    uStack60 = 0x6c0064;\n    var_30h._0_4_ = 0x6c;\n    uStack104 = 0x4c72644c;\n    uStack100 = 0x4464616f;\n    uStack96 = 0x6c6c;\n    var_28h = 0x496c7452;\n    var_24h = 0x5574696e;\n    var_bp_20h = 0x6f63696e;\n    uStack36 = 0x74536564;\n    var_bp_18h._0_4_ = 0x676e6972;\n    uVar2 = fcn.140002da0(&var_46h + 6);\n    pcVar3 = fcn.140002e04(uVar2, &uStack104);\n    pcVar4 = fcn.140002e04(uVar2, &var_28h);\n    uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg1);\n    uVar2 = (*_sym.imp.OLEAUT32.dll_SysReAllocStringLen)(0, uVar1);\n    (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, arg1, uVar1, uVar2, uVar1);\n    (*pcVar4)(&var_50h, uVar2);\n    (*_sym.imp.OLEAUT32.dll_SysStringLen)(uVar2);\n    (*pcVar3)(0, 0, &var_50h, &uStackX16);\n    return uStackX16;\n}\n",
        "token_count": 631
    },
    "14000620": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint64_t fcn.14000620c(uint64_t arg1)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    uint *puVar3;\n    \n    if (arg1 < 0xffffffffffffffe1) {\n        if (arg1 == 0) {\n            arg1 = 1;\n        }\n        do {\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x14005b0d8, 0, arg1);\n            if (iVar2 != 0) {\n                return iVar2;\n            }\n            iVar1 = fcn.1400061d8();\n        } while ((iVar1 != 0) && (iVar1 = fcn.1400081ec(arg1),  iVar1 != 0));\n    }\n    puVar3 = fcn.140008584();\n    *puVar3 = 0xc;\n    return 0;\n}\n",
        "token_count": 199
    },
    "140004d2": {
        "rules": [
            "parse PE header"
        ],
        "decompiled_code": "\nvoid fcn.140004d20(ulong arg1)\n\n{\n    code *pcVar1;\n    int16_t *piVar2;\n    int32_t *piVar3;\n    uint auStackX16 [2];\n    int32_t aiStackX24 [2];\n    uchar auStackX32 [8];\n    uchar auStack56 [4];\n    uint uStack52;\n    uint auStack48 [2];\n    uint *puStack40;\n    int32_t *piStack32;\n    uchar *puStack24;\n    \n    aiStackX24[0] = 0;\n    auStackX16[0] = 0;\n    piVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    if ((((piVar2 != NULL) && (*piVar2 == 0x5a4d)) && (piVar3 = *(piVar2 + 0x1e) + piVar2,  *piVar3 == 0x4550)) &&\n       (((*(piVar3 + 6) == 0x20b && (0xe < piVar3[0x21])) && (piVar3[0x3e] != 0)))) {\n        fcn.140004da4(arg1);\n    }\n    puStack40 = auStackX16;\n    auStackX32[0] = 0;\n    piStack32 = aiStackX24;\n    puStack24 = auStackX32;\n    uStack52 = 2;\n    auStack48[0] = 2;\n    fcn.140004fec(auStack56, auStack48, &puStack40, &uStack52);\n    if (aiStackX24[0] == 0) {\n        fcn.140004e00(arg1);\n        pcVar1 = swi(3);\n        (*pcVar1)();\n        return;\n    }\n    return;\n}\n",
        "token_count": 413
    }
}