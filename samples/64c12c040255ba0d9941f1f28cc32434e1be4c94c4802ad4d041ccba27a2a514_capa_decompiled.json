{
    "0040100a": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n\nvoid __cdecl fcn.0040100a(uint noname_0, uint noname_1, uint arg_8h)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    uint var_28h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_4h_2;\n    uint uStack4;\n    \n    uStack4 = 0xc;\n    var_4h_2 = 0x467c60;\n    fcn.0040daac();\n    *(unaff_EBP + -4) = 0;\n    fcn.0040dc10();\n    *(unaff_EBP + -0x18) = &fcn.0040100a::var_4h_2;\n    *(unaff_EBP + -0x1c) = &fcn.0040100a::var_4h_2;\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(unaff_EBP + -0x2c) = 0x401062;\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 256
    },
    "00410f45": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410f45(uint32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    uint32_t *puVar3;\n    int32_t *piVar4;\n    char cVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    code *pcVar8;\n    uint8_t uVar9;\n    uint32_t uVar10;\n    uint32_t *puVar11;\n    uint32_t *puVar12;\n    uint32_t *puVar13;\n    uint32_t uVar14;\n    uint32_t uVar15;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    uVar6 = arg_8h[4];\n    puVar13 = arg_ch + -4;\n    uVar15 = arg_ch - arg_8h[3] >> 0xf;\n    piVar4 = uVar15 * 0x204 + 0x144 + uVar6;\n    var_4h = *puVar13 - 1;\n    if ((var_4h & 1) == 0) {\n        puVar11 = var_4h + puVar13;\n        uVar14 = *puVar11;\n        uVar7 = *(arg_ch + -8);\n        if ((uVar14 & 1) == 0) {\n            uVar10 = (uVar14 >> 4) - 1;\n            if (0x3f < uVar10) {\n                uVar10 = 0x3f;\n            }\n            if (puVar11[1] == puVar11[2]) {\n                if (uVar10 < 0x20) {\n                    pcVar2 = uVar10 + 4 + uVar6;\n                    uVar10 = ~(0x80000000U >> (uVar10 & 0x1f));\n                    puVar12 = uVar6 + 0x44 + uVar15 * 4;\n                    *puVar12 = *puVar12 & uVar10;\n                    *pcVar2 = *pcVar2 + -1;\n                    if (*pcVar2 == '\\0') {\n                        *arg_8h = *arg_8h & uVar10;\n                    }\n                }\n                else {\n                    pcVar2 = uVar10 + 4 + uVar6;\n                    uVar10 = ~(0x80000000U >> (uVar10 - 0x20 & 0x1f));\n                    puVar12 = uVar6 + 0xc4 + uVar15 * 4;\n                    *puVar12 = *puVar12 & uVar10;\n                    *pcVar2 = *pcVar2 + -1;\n                    if (*pcVar2 == '\\0') {\n                        arg_8h[1] = arg_8h[1] & uVar10;\n                    }\n                }\n            }\n            var_4h = var_4h + uVar14;\n            *(puVar11[2] + 4) = puVar11[1];\n            *(puVar11[1] + 8) = puVar11[2];\n        }\n        puVar11 = (var_4h >> 4) + -1;\n        if (0x3f < puVar11) {\n            puVar11 = 0x3f;\n        }\n        puVar12 = arg_8h;\n        if ((uVar7 & 1) == 0) {\n            puVar13 = puVar13 - uVar7;\n            puVar12 = (uVar7 >> 4) + -1;\n            if (0x3f < puVar12) {\n                puVar12 = 0x3f;\n            }\n            var_4h = var_4h + uVar7;\n            puVar11 = (var_4h >> 4) + -1;\n            if (0x3f < puVar11) {\n                puVar11 = 0x3f;\n            }\n            if (puVar12 != puVar11) {\n                if (puVar13[1] == puVar13[2]) {\n                    if (puVar12 < 0x20) {\n                        uVar14 = ~(0x80000000U >> (puVar12 & 0x1f));\n                        puVar3 = uVar6 + 0x44 + uVar15 * 4;\n                        *puVar3 = *puVar3 & uVar14;\n                        pcVar2 = puVar12 + uVar6 + 4;\n                        *pcVar2 = *pcVar2 + -1;\n                        if (*pcVar2 == '\\0') {\n                            *arg_8h = *arg_8h & uVar14;\n                        }\n                    }\n                    else {\n                        uVar14 = ~(0x80000000U >> (puVar12 - 0x20 & 0x1f));\n                        puVar3 = uVar6 + 0xc4 + uVar15 * 4;\n                        *puVar3 = *puVar3 & uVar14;\n                        pcVar2 = puVar12 + uVar6 + 4;\n                        *pcVar2 = *pcVar2 + -1;\n                        if (*pcVar2 == '\\0') {\n                            arg_8h[1] = arg_8h[1] & uVar14;\n                        }\n                    }\n                }\n                *(puVar13[2] + 4) = puVar13[1];\n                *(puVar13[1] + 8) = puVar13[2];\n            }\n        }\n        if (((uVar7 & 1) != 0) || (puVar12 != puVar11)) {\n            piVar1 = piVar4 + puVar11 * 2;\n            uVar14 = piVar1[1];\n            puVar13[2] = piVar1;\n            puVar13[1] = uVar14;\n            piVar1[1] = puVar13;\n            *(puVar13[1] + 8) = puVar13;\n            if (puVar13[1] == puVar13[2]) {\n                cVar5 = *(puVar11 + uVar6 + 4);\n                *(puVar11 + uVar6 + 4) = cVar5 + '\\x01';\n                uVar9 = puVar11;\n                if (puVar11 < 0x20) {\n                    if (cVar5 == '\\0') {\n                        *arg_8h = *arg_8h | 0x80000000U >> (uVar9 & 0x1f);\n                    }\n                    puVar11 = uVar6 + 0x44 + uVar15 * 4;\n                    *puVar11 = *puVar11 | 0x80000000U >> (uVar9 & 0x1f);\n                }\n                else {\n                    if (cVar5 == '\\0') {\n                        arg_8h[1] = arg_8h[1] | 0x80000000U >> (uVar9 - 0x20 & 0x1f);\n                    }\n                    puVar11 = uVar6 + 0xc4 + uVar15 * 4;\n                    *puVar11 = *puVar11 | 0x80000000U >> (uVar9 - 0x20 & 0x1f);\n                }\n            }\n        }\n        *puVar13 = var_4h;\n        *((var_4h - 4) + puVar13) = var_4h;\n        *piVar4 = *piVar4 + -1;\n        pcVar8 = _sym.imp.KERNEL32.dll_VirtualFree;\n        if (*piVar4 == 0) {\n            if (*0x49af44 != NULL) {\n                (*_sym.imp.KERNEL32.dll_VirtualFree)(*0x49af5c * 0x8000 + (*0x49af44)[3], 0x8000, 0x4000);\n                (*0x49af44)[2] = (*0x49af44)[2] | 0x80000000U >> (*0x49af5c & 0x1f);\n                *((*0x49af44)[4] + 0xc4 + *0x49af5c * 4) = 0;\n                *((*0x49af44)[4] + 0x43) = *((*0x49af44)[4] + 0x43) + -1;\n                if (*((*0x49af44)[4] + 0x43) == '\\0') {\n                    (*0x49af44)[1] = (*0x49af44)[1] & 0xfffffffe;\n                }\n                if ((*0x49af44)[2] == 0xffffffff) {\n                    (*pcVar8)((*0x49af44)[3], 0, 0x8000);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(*0x49af60, 0, (*0x49af44)[4]);\n                    fcn.0040ea50(*0x49af44, *0x49af44 + 5, (*0x49af48 * 0x14 - *0x49af44) + -0x14 + *0x49af4c);\n                    *0x49af48 = *0x49af48 + -1;\n                    if (*0x49af44 < arg_8h) {\n                        arg_8h = arg_8h + -5;\n                    }\n                    *0x49af54 = *0x49af4c;\n                }\n            }\n            *0x49af44 = arg_8h;\n            *0x49af5c = uVar15;\n        }\n    }\n    return;\n}\n",
        "token_count": 2166
    },
    "0041308c": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\nvoid fcn.0041308c(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uStack296;\n    uchar *puStack292;\n    uint uStack288;\n    uchar auStack272 [260];\n    uchar uStack12;\n    uint uStack8;\n    \n    uStack8 = *0x496830;\n    uVar1 = 0;\n    do {\n        if (param_1 == *(uVar1 * 8 + 0x496c00)) break;\n        uVar1 = uVar1 + 1;\n    } while (uVar1 < 0x13);\n    if (param_1 == *(uVar1 * 8 + 0x496c00)) {\n        if ((*0x4998e0 == 1) || ((*0x4998e0 == 0 && (*0x496814 == 1)))) {\n            uStack288 = 0;\n            puStack292 = &stack0x00000004;\n            uStack296 = *(uVar1 * 8 + 0x496c04);\n            uStack296 = fcn.0040e9c0();\n            (*_sym.imp.KERNEL32.dll_GetStdHandle)();\n            (*_sym.imp.KERNEL32.dll_WriteFile)();\n        }\n        else if (param_1 != 0xfc) {\n            uStack288 = 0x104;\n            puStack292 = &stack0xfffffef0;\n            uStack296 = 0;\n            uStack12 = 0;\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)();\n            if (iVar2 == 0) {\n                fcn.00415f50();\n            }\n            iVar2 = fcn.0040e9c0();\n            if (0x3c < iVar2 + 1U) {\n                fcn.0040e9c0();\n                fcn.004185b0();\n            }\n            fcn.0040e9c0();\n            fcn.0040e9c0();\n            fcn.0040dc10();\n            fcn.00415f50();\n            fcn.00415f60();\n            fcn.00415f60();\n            fcn.00415f60();\n            fcn.004184af(&stack0xfffffed8, \"Microsoft Visual C++ Runtime Library\", 0x12010);\n        }\n    }\n    uStack288 = 0x4131f8;\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 551
    },
    "00413c2e": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h_2\n\nvoid __cdecl fcn.00413c2e(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    char *pcVar4;\n    uint var_8h;\n    uint var_ch;\n    uint var_128h_2;\n    uint var_124h_2;\n    uint var_128h;\n    uint lpFilename;\n    uint var_18h_2;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint uStack4;\n    \n    uStack4 = 0x118;\n    var_18h = 0x4739e8;\n    fcn.0040daac();\n    *(unaff_EBP + -0x1c) = *0x496830;\n    pcVar1 = *0x499c04;\n    if (*0x499c04 == NULL) {\n        if (*(unaff_EBP + 8) == 1) {\n            pcVar4 = \"Buffer overrun detected!\";\n            *(unaff_EBP + -0x128) =\n                 \"A buffer overrun has been detected which has corrupted the program\\'s\\ninternal state.  The program cannot safely continue execution and must\\nnow be terminated.\\n\"\n            ;\n        }\n        else {\n            pcVar4 = \"Unknown security failure detected!\";\n            *(unaff_EBP + -0x128) =\n                 \"A security error of unknown cause has been detected which has\\ncorrupted the program\\'s internal state.  The program cannot safely\\ncontinue execution and must now be terminated.\\n\"\n            ;\n        }\n        *(unaff_EBP + -0x20) = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, unaff_EBP + -0x124, 0x104);\n        if (iVar2 == 0) {\n            fcn.00415f50(unaff_EBP + -0x124, \"<program name unknown>\");\n        }\n        iVar2 = unaff_EBP + -0x124;\n        iVar3 = fcn.0040e9c0(iVar2);\n        if (0x3c < iVar3 + 0xbU) {\n            iVar2 = fcn.0040e9c0(iVar2);\n            iVar2 = iVar2 + unaff_EBP + -0x155;\n            fcn.004185b0(iVar2, 0x473808, 3);\n        }\n        fcn.0040e9c0(iVar2);\n        fcn.0040dc10();\n        *(unaff_EBP + -0x18) = &var_18h;\n        fcn.00415f50(&var_18h, pcVar4);\n        fcn.00415f60(&var_18h, 0x4737e8);\n        fcn.00415f60(&var_18h, \"Program: \");\n        fcn.00415f60(&var_18h, iVar2);\n        fcn.00415f60(&var_18h, 0x4737e8);\n        fcn.00415f60(&var_18h, *(unaff_EBP + -0x128));\n        fcn.004184af(&var_18h, \"Microsoft Visual C++ Runtime Library\", 0x12010);\n    }\n    else {\n        *(unaff_EBP + -4) = 0;\n        (*pcVar1)(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    fcn.0040f467(3);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 914
    },
    "00416182": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_38h_2\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: lpSrcStr\n// WARNING: Variable defined which should be unmapped: var_44h\n// WARNING: Variable defined which should be unmapped: var_40h_2\n// WARNING: Variable defined which should be unmapped: var_3ch_2\n// WARNING: Variable defined which should be unmapped: var_54h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h_2\n// WARNING: Variable defined which should be unmapped: var_20h\n\nvoid __cdecl\nfcn.00416182(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint CodePage, uint arg_24h, uint arg_8h, \n            uint arg_ch, uint arg_10h, uint cchSrc, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *lpMultiByteStr_00;\n    int32_t unaff_EBP;\n    uchar *arg_8h_00;\n    uint var_2ch;\n    uint var_48h;\n    uint var_24h_2;\n    uint var_40h;\n    uint lpWideCharStr;\n    uint lpDestStr;\n    uint cchDest;\n    uint var_20h_2;\n    uint var_24h_3;\n    uint var_28h;\n    uint var_24h;\n    uint Locale;\n    uint dwMapFlags;\n    uint lpMultiByteStr;\n    uint cbMultiByte;\n    uint var_18h_2;\n    uint var_4h;\n    uint uVar5;\n    uint uVar6;\n    uint var_38h_2;\n    uint var_34h;\n    uint var_30h_2;\n    uint var_20h;\n    uint lpSrcStr;\n    uint var_44h;\n    uint var_40h_2;\n    uint var_3ch_2;\n    uint var_38h;\n    uint var_54h;\n    uint var_30h;\n    \n    fcn.0040daac();\n    if (*0x499c2c == 0) {\n        lpSrcStr = 0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringW)();\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x499c2c = 2;\n            }\n        }\n        else {\n            *0x499c2c = 1;\n        }\n    }\n    if (0 < *(unaff_EBP + 0x14)) {\n        iVar1 = *(unaff_EBP + 0x14);\n        pcVar2 = *(unaff_EBP + 0x10);\n        do {\n            iVar1 = iVar1 + -1;\n            if (*pcVar2 == '\\0') goto code_r0x004161e8;\n            pcVar2 = pcVar2 + 1;\n        } while (iVar1 != 0);\n        iVar1 = -1;\ncode_r0x004161e8:\n        *(unaff_EBP + 0x14) = *(unaff_EBP + 0x14) + (-1 - iVar1);\n    }\n    if ((*0x499c2c != 2) && (*0x499c2c != 0)) {\n        if (*0x499c2c != 1) goto code_r0x00416535;\n        *(unaff_EBP + -0x2c) = 0;\n        *(unaff_EBP + -0x38) = 0;\n        *(unaff_EBP + -0x34) = 0;\n        if (*(unaff_EBP + 0x20) == 0) {\n            *(unaff_EBP + 0x20) = *0x499c24;\n        }\n        lpSrcStr = *(unaff_EBP + 0x20);\n        iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        *(unaff_EBP + -0x30) = iVar1;\n        if (iVar1 == 0) goto code_r0x00416535;\n        *(unaff_EBP + -4) = 1;\n        fcn.0040dc10();\n        *(unaff_EBP + -0x18) = &fcn.00416182::lpSrcStr;\n        *(unaff_EBP + -0x1c) = &fcn.00416182::lpSrcStr;\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*(unaff_EBP + -0x1c) == 0) {\n            iVar3 = fcn.0040d946();\n            *(unaff_EBP + -0x1c) = iVar3;\n            if (iVar3 == 0) goto code_r0x00416535;\n            *(unaff_EBP + -0x38) = 1;\n        }\n        var_30h_2 = 1;\n        var_34h = *(unaff_EBP + 0x20);\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        if (iVar3 != 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, 0, 0);\n            *(unaff_EBP + -0x2c) = iVar3;\n            if (iVar3 != 0) {\n                if ((*(unaff_EBP + 0xd) & 4) == 0) {\n                    *(unaff_EBP + -4) = 2;\n                    fcn.0040dc10();\n                    *(unaff_EBP + -0x18) = &fcn.00416182::var_34h;\n                    *(unaff_EBP + -0x20) = &fcn.00416182::var_34h;\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    if (*(unaff_EBP + -0x20) == 0) {\n                        iVar4 = fcn.0040d946(iVar3 * 2);\n                        *(unaff_EBP + -0x20) = iVar4;\n                        if (iVar4 == 0) goto code_r0x004163b7;\n                        *(unaff_EBP + -0x34) = 1;\n                    }\n                    iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                                      (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, \n                                       *(unaff_EBP + -0x20), iVar3);\n                    if (iVar1 != 0) {\n                        if (*(unaff_EBP + 0x1c) == 0) {\n                            uVar6 = 0;\n                            uVar5 = 0;\n                        }\n                        else {\n                            uVar6 = *(unaff_EBP + 0x1c);\n                            uVar5 = *(unaff_EBP + 0x18);\n                        }\n                        (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                  (*(unaff_EBP + 0x20), 0, *(unaff_EBP + -0x20), iVar3, uVar5, uVar6, 0, 0);\n                    }\n                }\n                else if ((*(unaff_EBP + 0x1c) != 0) && (iVar3 <= *(unaff_EBP + 0x1c))) {\n                    (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, *(unaff_EBP + 0x18), \n                               *(unaff_EBP + 0x1c));\n                }\n            }\n        }\ncode_r0x004163b7:\n        if (*(unaff_EBP + -0x34) != 0) {\n            fcn.0040d958(*(unaff_EBP + -0x20));\n        }\n        if (*(unaff_EBP + -0x38) != 0) {\n            fcn.0040d958(*(unaff_EBP + -0x1c));\n        }\n        goto code_r0x00416535;\n    }\n    *(unaff_EBP + -0x28) = 0;\n    *(unaff_EBP + -0x3c) = 0;\n    if (*(unaff_EBP + 8) == 0) {\n        *(unaff_EBP + 8) = *0x499c14;\n    }\n    if (*(unaff_EBP + 0x20) == 0) {\n        *(unaff_EBP + 0x20) = *0x499c24;\n    }\n    iVar1 = fcn.0041921e(*(unaff_EBP + 8));\n    *(unaff_EBP + -0x40) = iVar1;\n    if (iVar1 == -1) goto code_r0x00416535;\n    if (iVar1 == *(unaff_EBP + 0x20)) {\n        lpSrcStr = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n    }\n    else {\n        lpSrcStr = *(unaff_EBP + 0x20);\n        iVar1 = fcn.00419261(lpSrcStr, iVar1, *(unaff_EBP + 0x10), unaff_EBP + 0x14, 0, 0, 0x473a80, 0x38);\n        *(unaff_EBP + -0x28) = iVar1;\n        if (iVar1 == 0) goto code_r0x00416535;\n        uVar6 = *(unaff_EBP + 0xc);\n        lpSrcStr = *(unaff_EBP + 8);\n        lpMultiByteStr_00 = &fcn.00416182::lpSrcStr;\n        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n        *(unaff_EBP + -0x24) = iVar1;\n        arg_8h_00 = NULL;\n        if (iVar1 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.0040dc10();\n            *(unaff_EBP + -0x18) = &fcn.00416182::lpSrcStr;\n            *(unaff_EBP + -0x44) = &fcn.00416182::lpSrcStr;\n            fcn.0040e620();\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x20) {\n                lpMultiByteStr_00 = fcn.0040d946();\n                arg_8h_00 = lpMultiByteStr_00;\n                if (lpMultiByteStr_00 == NULL) goto code_r0x004164fd;\n                fcn.0040e620();\n                *(unaff_EBP + -0x3c) = 1;\n            }\n            var_30h_2 = *(unaff_EBP + 0xc);\n            var_34h = *(unaff_EBP + 8);\n            iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n            *(unaff_EBP + -0x24) = iVar1;\n            arg_8h_00 = lpMultiByteStr_00;\n            if (iVar1 != 0) {\n                var_30h_2 = *(unaff_EBP + 0x20);\n                var_34h = *(unaff_EBP + -0x40);\n                fcn.00419261(var_34h, var_30h_2, lpMultiByteStr_00, unaff_EBP + -0x24, *(unaff_EBP + 0x18), \n                             *(unaff_EBP + 0x1c), lpSrcStr, uVar6);\n            }\n        }\ncode_r0x004164fd:\n        if (*(unaff_EBP + -0x3c) != 0) {\n            fcn.0040d958(arg_8h_00);\n        }\n    }\n    if (*(unaff_EBP + -0x28) != 0) {\n        fcn.0040d958(*(unaff_EBP + -0x28));\n    }\ncode_r0x00416535:\n    *(unaff_EBP + -0x58) = 0x41653d;\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 3009
    },
    "0041653e": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_28h_2\n// WARNING: Variable defined which should be unmapped: var_24h_2\n// WARNING: Variable defined which should be unmapped: var_20h_2\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: lpCharType\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n\nvoid __cdecl\nfcn.0041653e(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint arg_20h_2, \n            uint noname_7, uint arg_8h, uint lpMultiByteStr, uint cbMultiByte, uint arg_14h, uint CodePage, uint arg_1ch\n            , uint arg_20h)\n\n{\n    int32_t iVar1;\n    uint *arg_8h_00;\n    uint uVar2;\n    int32_t noname_1_00;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    int32_t noname_0_00;\n    uint dwInfoType;\n    uint var_ch;\n    uint var_10h;\n    uint var_14h;\n    uint var_18h_2;\n    uint var_4h;\n    uint var_2ch;\n    uint var_28h_2;\n    uint var_24h_2;\n    uint var_20h_2;\n    int32_t lpCharType;\n    int32_t var_38h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    \n    fcn.0040daac();\n    iVar3 = 0;\n    if (*0x499c30 == 0) {\n        var_38h = 0x416568;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)();\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x499c30 = 2;\n            }\n        }\n        else {\n            *0x499c30 = 1;\n        }\n    }\n    if ((*0x499c30 == 2) || (*0x499c30 == 0)) {\n        iVar1 = *(unaff_EBP + 0x1c);\n        if (*(unaff_EBP + 0x1c) == 0) {\n            iVar1 = *0x499c14;\n        }\n        noname_0_00 = *(unaff_EBP + 0x18);\n        if (*(unaff_EBP + 0x18) == 0) {\n            noname_0_00 = *0x499c24;\n        }\n        noname_1_00 = fcn.0041921e(iVar1);\n        if (noname_1_00 != -1) {\n            if (noname_1_00 != noname_0_00) {\n                lpCharType = noname_0_00;\n                var_38h = noname_1_00;\n                iVar3 = fcn.00419261(noname_0_00, noname_1_00, *(unaff_EBP + 0xc), unaff_EBP + 0x10, 0, 0, 0x473aa8, \n                                     0x1c);\n                if (iVar3 == 0) goto code_r0x004166ef;\n                *(unaff_EBP + 0xc) = iVar3;\n            }\n            lpCharType = 0x4166e0;\n            var_38h = iVar1;\n            (*_sym.imp.KERNEL32.dll_GetStringTypeA)();\n            if (iVar3 != 0) {\n                lpCharType = iVar3;\n                fcn.0040d958(iVar3);\n            }\n        }\n    }\n    else if (*0x499c30 == 1) {\n        *(unaff_EBP + -0x24) = 0;\n        *(unaff_EBP + -0x20) = 0;\n        if (*(unaff_EBP + 0x18) == 0) {\n            *(unaff_EBP + 0x18) = *0x499c24;\n        }\n        var_38h = (*(unaff_EBP + 0x20) != 0) * 8 + 1;\n        lpCharType = *(unaff_EBP + 0x18);\n        arg_8h_00 = &fcn.0041653e::lpCharType;\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        *(unaff_EBP + -0x28) = iVar3;\n        if (iVar3 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.0040dc10();\n            *(unaff_EBP + -0x18) = &fcn.0041653e::lpCharType;\n            *(unaff_EBP + -0x2c) = &fcn.0041653e::lpCharType;\n            fcn.0040e620(&fcn.0041653e::lpCharType, 0, iVar3 * 2);\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x20) {\n                arg_8h_00 = fcn.0040f0e4(2, iVar3);\n                if (arg_8h_00 == NULL) goto code_r0x004166ef;\n                *(unaff_EBP + -0x20) = 1;\n            }\n            iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                              (*(unaff_EBP + 0x18), 1, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), arg_8h_00, iVar3);\n            if (iVar3 != 0) {\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)(*(unaff_EBP + 8), arg_8h_00, iVar3, *(unaff_EBP + 0x14))\n                ;\n                *(unaff_EBP + -0x24) = uVar2;\n            }\n            if (*(unaff_EBP + -0x20) != 0) {\n                fcn.0040d958(arg_8h_00);\n            }\n        }\n    }\ncode_r0x004166ef:\n    *(unaff_EBP + -0x3c) = 0x4166f7;\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 1557
    },
    "00419261": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl\nfcn.00419261(uint noname_0, uint noname_1, uint lpMultiByteStr, uint arg_14h_2, uint arg_8h, uint arg_ch, uint noname_6\n            , uint arg_14h)\n\n{\n    uchar *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uchar *arg_ch_00;\n    uint *arg_8h_00;\n    int32_t unaff_EBP;\n    uint CodePage;\n    uint var_4h;\n    uint var_48h_2;\n    uint var_54h;\n    uint cbMultiByte;\n    uint var_3ch_2;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_1ch;\n    uchar *var_18h;\n    uint var_4h_2;\n    uint uStack4;\n    \n    uStack4 = 0x38;\n    var_4h_2 = 0x474358;\n    var_18h = 0x41926d;\n    fcn.0040daac();\n    *(unaff_EBP + -0x1c) = *0x496830;\n    *(unaff_EBP + -0x34) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    puVar1 = **(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x40) = puVar1;\n    *(unaff_EBP + -0x3c) = 0;\n    pcVar2 = _sym.imp.KERNEL32.dll_GetCPInfo;\n    if (*(unaff_EBP + 8) == *(unaff_EBP + 0xc)) {\n        arg_8h_00 = *(unaff_EBP + -0x48);\n    }\n    else {\n        var_18h = unaff_EBP + -0x30;\n        var_1ch = *(unaff_EBP + 8);\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetCPInfo)();\n        if ((((iVar3 != 0) && (*(unaff_EBP + -0x30) == 1)) &&\n            (iVar3 = (*pcVar2)(*(unaff_EBP + 0xc), unaff_EBP + -0x30),  iVar3 != 0)) && (*(unaff_EBP + -0x30) == 1)) {\n            *(unaff_EBP + -0x3c) = 1;\n        }\n        if (*(unaff_EBP + -0x3c) == 0) {\n            arg_ch_00 = *(unaff_EBP + -0x38);\n        }\n        else {\n            arg_ch_00 = puVar1;\n            if (puVar1 == 0xffffffff) {\n                iVar3 = fcn.0040e9c0(*(unaff_EBP + 0x10));\n                arg_ch_00 = iVar3 + 1;\n            }\n            *(unaff_EBP + -0x38) = arg_ch_00;\n        }\n        if (*(unaff_EBP + -0x3c) == 0) {\n            arg_ch_00 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                  (*(unaff_EBP + 8), 1, *(unaff_EBP + 0x10), puVar1, 0, 0);\n            *(unaff_EBP + -0x38) = arg_ch_00;\n            if (arg_ch_00 == NULL) goto code_r0x00419419;\n        }\n        arg_8h_00 = &fcn.00419261::var_1ch;\n        *(unaff_EBP + -4) = 0;\n        fcn.0040dc10();\n        *(unaff_EBP + -0x18) = &fcn.00419261::var_1ch;\n        *(unaff_EBP + -0x48) = &fcn.00419261::var_1ch;\n        fcn.0040e620(&fcn.00419261::var_1ch, 0, arg_ch_00 * 2);\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*0x10 == 0x10) {\n            arg_8h_00 = fcn.0040f0e4(2, arg_ch_00);\n            if (arg_8h_00 == NULL) goto code_r0x00419419;\n            *(unaff_EBP + -0x44) = 1;\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                          (*(unaff_EBP + 8), 1, *(unaff_EBP + 0x10), *(unaff_EBP + -0x40), arg_8h_00, arg_ch_00);\n        if (iVar3 != 0) {\n            if (*(unaff_EBP + 0x18) == 0) {\n                if (*(unaff_EBP + -0x3c) == 0) {\n                    var_18h = NULL;\n                    var_1ch = 0;\n                    arg_ch_00 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                          (*(unaff_EBP + 0xc), 0, arg_8h_00, arg_ch_00, 0, 0);\n                    if (arg_ch_00 == NULL) goto code_r0x0041940a;\n                }\n                var_1ch = 1;\n                var_18h = arg_ch_00;\n                iVar3 = fcn.0040f0e4(1, arg_ch_00);\n                *(unaff_EBP + -0x34) = iVar3;\n                if (iVar3 != 0) {\n                    var_18h = NULL;\n                    var_1ch = 0;\n                    iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                      (*(unaff_EBP + 0xc), 0, arg_8h_00, arg_ch_00, iVar3, arg_ch_00);\n                    if (iVar3 == 0) {\n                        var_18h = *(unaff_EBP + -0x34);\n                        var_1ch = 0x4193f4;\n                        fcn.0040d958(var_18h);\n                        *(unaff_EBP + -0x34) = 0;\n                    }\n                    else if (*(unaff_EBP + -0x40) != -1) {\n                        **(unaff_EBP + 0x14) = iVar3;\n                    }\n                }\n            }\n            else {\n                var_18h = NULL;\n                var_1ch = 0;\n                iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                  (*(unaff_EBP + 0xc), 0, arg_8h_00, arg_ch_00, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c)\n                                  );\n                if (iVar3 != 0) {\n                    *(unaff_EBP + -0x34) = *(unaff_EBP + 0x18);\n                }\n            }\n        }\n    }\ncode_r0x0041940a:\n    if (*(unaff_EBP + -0x44) != 0) {\n        var_1ch = 0x419415;\n        var_18h = arg_8h_00;\n        fcn.0040d958(arg_8h_00);\n    }\ncode_r0x00419419:\n    *(unaff_EBP + -0x58) = 0x419424;\n    fcn.0040e60a();\n    *(unaff_EBP + -0x58) = 0x419429;\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 1844
    },
    "00419aa6": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_42h\n\nvoid __cdecl\nfcn.00419aa6(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint8_t uVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    uint32_t *puVar4;\n    uint8_t **ppuVar5;\n    uint uVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    uint *arg_8h_00;\n    char *pcVar9;\n    int32_t iVar10;\n    char cVar11;\n    uint8_t *puVar12;\n    uint32_t uVar13;\n    uint32_t uVar14;\n    ushort *puVar15;\n    int32_t unaff_EBP;\n    uint var_19h;\n    uint var_10h;\n    uint var_14h;\n    uint var_18h_2;\n    uint var_4h;\n    uint var_54h_2;\n    uint var_48h_2;\n    uint var_42h_2;\n    uint var_38h;\n    uint var_54h;\n    uint var_30h_2;\n    uint var_2ch_2;\n    uint var_48h;\n    uint var_42h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    \n    var_20h = 0x38;\n    var_24h = 0x4744a0;\n    fcn.0040daac();\n    if (*(unaff_EBP + 0xc) == 0) {\n        uVar6 = *(*(unaff_EBP + 0x1c) + 0xa0);\n    }\n    else if (*(unaff_EBP + 0xc) == 1) {\n        uVar6 = *(*(unaff_EBP + 0x1c) + 0xa4);\n    }\n    else {\n        uVar6 = *(*(unaff_EBP + 0x1c) + 0xa8);\n    }\n    *(unaff_EBP + -0x20) = uVar6;\n    if (*(*(unaff_EBP + 0x1c) + 0xb0) == 1) {\n        puVar15 = *(unaff_EBP + 0x10);\n    }\n    else {\n        pcVar7 = _sym.imp.KERNEL32.dll_GetDateFormatA;\n        if (*(unaff_EBP + 0xc) == 2) {\n            pcVar7 = _sym.imp.KERNEL32.dll_GetTimeFormatA;\n        }\n        *(unaff_EBP + -0x30) = pcVar7;\n        puVar15 = *(unaff_EBP + 0x10);\n        *(unaff_EBP + -0x48) = puVar15[10] + 0x76c;\n        *(unaff_EBP + -0x46) = puVar15[8] + 1;\n        *(unaff_EBP + -0x42) = puVar15[6];\n        *(unaff_EBP + -0x40) = puVar15[4];\n        *(unaff_EBP + -0x3e) = puVar15[2];\n        *(unaff_EBP + -0x3c) = *puVar15;\n        *(unaff_EBP + -0x3a) = 0;\n        arg_8h_00 = &fcn.00419aa6::var_24h;\n        iVar8 = (*pcVar7)(*(*(unaff_EBP + 0x1c) + 0xac), 0, unaff_EBP + -0x48, *(unaff_EBP + -0x20), 0, 0);\n        *(unaff_EBP + -0x2c) = iVar8;\n        if (iVar8 != 0) {\n            *(unaff_EBP + -0x34) = 0;\n            *(unaff_EBP + -4) = 0;\n            fcn.0040dc10();\n            *(unaff_EBP + -0x18) = &fcn.00419aa6::var_24h;\n            *(unaff_EBP + -0x38) = &fcn.00419aa6::var_24h;\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x8) {\n                arg_8h_00 = fcn.0040d946(*(unaff_EBP + -0x2c));\n                if (arg_8h_00 == NULL) goto code_r0x00419c06;\n                *(unaff_EBP + -0x34) = 1;\n            }\n            *(unaff_EBP + -0x24) = arg_8h_00;\n            iVar8 = (**(unaff_EBP + -0x30))\n                              (*(*(unaff_EBP + 0x1c) + 0xac), 0, unaff_EBP + -0x48, *(unaff_EBP + -0x20), arg_8h_00, \n                               *(unaff_EBP + -0x2c));\n            iVar8 = iVar8 + -1;\n            if (0 < iVar8) {\n                piVar2 = *(unaff_EBP + 0x18);\n                piVar3 = *(unaff_EBP + 0x14);\n                do {\n                    if (*piVar2 == 0) break;\n                    **piVar3 = **(unaff_EBP + -0x24);\n                    *piVar3 = *piVar3 + 1;\n                    *(unaff_EBP + -0x24) = *(unaff_EBP + -0x24) + 1;\n                    *piVar2 = *piVar2 + -1;\n                    iVar8 = iVar8 + -1;\n                } while (0 < iVar8);\n            }\n            if (*(unaff_EBP + -0x34) != 0) {\n                fcn.0040d958(arg_8h_00);\n            }\n            goto code_r0x00419bfa;\n        }\n    }\ncode_r0x00419c06:\n    cVar11 = **(unaff_EBP + -0x20);\n    if (cVar11 != '\\0') {\n        puVar4 = *(unaff_EBP + 0x18);\n        ppuVar5 = *(unaff_EBP + 0x14);\n        while (*puVar4 != 0) {\n            *(unaff_EBP + -0x19) = 0;\n            *(unaff_EBP + -0x28) = 0;\n            pcVar9 = *(unaff_EBP + -0x20);\n            uVar14 = 0;\n            do {\n                uVar13 = uVar14;\n                pcVar9 = pcVar9 + 1;\n                uVar14 = uVar13 + 1;\n            } while (*pcVar9 == cVar11);\n            *(unaff_EBP + -0x24) = pcVar9;\n            if (cVar11 < 'e') {\n                if (cVar11 == 'd') {\n                    if (uVar13 == 0) {\n                        *(unaff_EBP + -0x28) = 1;\n                    }\n                    else if (uVar13 != 1) {\n                        if (uVar13 == 2) {\n                            *(unaff_EBP + -0x19) = 0x61;\n                        }\n                        else if (uVar13 == 3) {\n                            *(unaff_EBP + -0x19) = 0x41;\n                        }\n                        goto code_r0x00419ebe;\n                    }\n                    *(unaff_EBP + -0x19) = 100;\n                    goto code_r0x00419ebe;\n                }\n                if (cVar11 != '\\'') {\n                    if (cVar11 != 'A') {\n                        if (cVar11 == 'H') {\n                            if (uVar13 == 0) {\n                                *(unaff_EBP + -0x28) = 1;\n                            }\n                            else if (uVar14 != 2) goto code_r0x00419ebe;\n                            *(unaff_EBP + -0x19) = 0x48;\n                        }\n                        else if (cVar11 == 'M') {\n                            if (uVar13 == 0) {\n                                *(unaff_EBP + -0x28) = 1;\n                            }\n                            else if (uVar13 != 1) {\n                                if (uVar13 == 2) {\n                                    *(unaff_EBP + -0x19) = 0x62;\n                                }\n                                else if (uVar13 == 3) {\n                                    *(unaff_EBP + -0x19) = 0x42;\n                                }\n                                goto code_r0x00419ebe;\n                            }\n                            *(unaff_EBP + -0x19) = 0x6d;\n                        }\n                        else if (cVar11 == 'a') goto code_r0x00419c67;\n                        goto code_r0x00419ebe;\n                    }\ncode_r0x00419c67:\n                    iVar8 = *(unaff_EBP + -0x20);\n                    iVar10 = fcn.0041cf90(iVar8, \"am/pm\");\n                    if (iVar10 == 0) {\n                        iVar8 = iVar8 + 5;\ncode_r0x00419ce5:\n                        *(unaff_EBP + -0x24) = iVar8;\n                    }\n                    else {\n                        iVar10 = fcn.0041cf90(iVar8, 0x474490);\n                        if (iVar10 == 0) {\n                            iVar8 = iVar8 + 3;\n                            goto code_r0x00419ce5;\n                        }\n                    }\n                    *(unaff_EBP + -0x19) = 0x70;\n                    goto code_r0x00419ebe;\n                }\n                *(unaff_EBP + -0x20) = *(unaff_EBP + -0x20) + uVar14;\n                if ((uVar14 & 1) != 0) {\n                    puVar12 = *(unaff_EBP + -0x20);\n                    while( true ) {\n                        uVar1 = *puVar12;\n                        if ((uVar1 == 0) || (*puVar4 == 0)) goto code_r0x00419f1e;\n                        if (uVar1 == 0x27) break;\n                        if (((*(*(*(unaff_EBP + 8) + 0x48) + 1 + uVar1 * 2) & 0x80) == 0) || (*puVar4 < 2)) {\n                            puVar12 = *(unaff_EBP + -0x20);\n                        }\n                        else {\n                            puVar12 = *(unaff_EBP + -0x20) + 1;\n                            if (*puVar12 == 0) goto code_r0x00419bfa;\n                            **ppuVar5 = uVar1;\n                            *ppuVar5 = *ppuVar5 + 1;\n                            *puVar4 = *puVar4 - 1;\n                        }\n                        **ppuVar5 = *puVar12;\n                        *ppuVar5 = *ppuVar5 + 1;\n                        puVar12 = puVar12 + 1;\n                        *(unaff_EBP + -0x20) = puVar12;\n                        *puVar4 = *puVar4 - 1;\n                    }\n                    *(unaff_EBP + -0x20) = *(unaff_EBP + -0x20) + 1;\n                }\n            }\n            else {\n                if (cVar11 == 'h') {\n                    if (uVar13 == 0) {\n                        *(unaff_EBP + -0x28) = 1;\n                    }\n                    else if (uVar14 != 2) goto code_r0x00419ebe;\n                    *(unaff_EBP + -0x19) = 0x49;\ncode_r0x00419ebe:\n                    if (*(unaff_EBP + -0x19) == '\\0') {\n                        puVar12 = *(unaff_EBP + -0x20);\n                        uVar1 = *puVar12;\n                        if (((*(*(*(unaff_EBP + 8) + 0x48) + 1 + uVar1 * 2) & 0x80) != 0) && (1 < *puVar4)) {\n                            puVar12 = puVar12 + 1;\n                            if (*puVar12 == 0) break;\n                            **ppuVar5 = uVar1;\n                            *ppuVar5 = *ppuVar5 + 1;\n                            *puVar4 = *puVar4 - 1;\n                        }\n                        **ppuVar5 = *puVar12;\n                        *ppuVar5 = *ppuVar5 + 1;\n                        *(unaff_EBP + -0x20) = puVar12 + 1;\n                        *puVar4 = *puVar4 - 1;\n                        goto code_r0x00419f1e;\n                    }\n                    iVar8 = fcn.00419840(*(unaff_EBP + 8), *(unaff_EBP + 0x10), *(unaff_EBP + 0x1c), \n                                         *(unaff_EBP + -0x28));\n                    if (iVar8 == 0) break;\n                }\n                else {\n                    if (cVar11 == 'm') {\n                        if (uVar13 == 0) {\n                            *(unaff_EBP + -0x28) = 1;\n                        }\n                        else if (uVar14 != 2) goto code_r0x00419ebe;\n                        *(unaff_EBP + -0x19) = 0x4d;\n                        goto code_r0x00419ebe;\n                    }\n                    if (cVar11 == 's') {\n                        if (uVar13 == 0) {\n                            *(unaff_EBP + -0x28) = 1;\n                        }\n                        else if (uVar14 != 2) goto code_r0x00419ebe;\n                        *(unaff_EBP + -0x19) = 0x53;\n                        goto code_r0x00419ebe;\n                    }\n                    if (cVar11 != 't') {\n                        if (cVar11 == 'y') {\n                            if (uVar13 == 1) {\n                                *(unaff_EBP + -0x19) = 0x79;\n                            }\n                            else if (uVar13 == 3) {\n                                *(unaff_EBP + -0x19) = 0x59;\n                            }\n                        }\n                        goto code_r0x00419ebe;\n                    }\n                    if (*(puVar15 + 4) < 0xc) {\n                        puVar12 = *(*(unaff_EBP + 0x1c) + 0x98);\n                    }\n                    else {\n                        puVar12 = *(*(unaff_EBP + 0x1c) + 0x9c);\n                    }\n                    if ((uVar14 == 1) && (*puVar4 != 0)) {\n                        uVar1 = *puVar12;\n                        if (((*(*(*(unaff_EBP + 8) + 0x48) + 1 + uVar1 * 2) & 0x80) != 0) && (1 < *puVar4)) {\n                            puVar12 = puVar12 + 1;\n                            if (*puVar12 == 0) break;\n                            **ppuVar5 = uVar1;\n                            *ppuVar5 = *ppuVar5 + 1;\n                            *puVar4 = *puVar4 - 1;\n                        }\n                        **ppuVar5 = *puVar12;\n                        *ppuVar5 = *ppuVar5 + 1;\n                        *puVar4 = *puVar4 - 1;\n                    }\n                    else {\n                        while( true ) {\n                            uVar1 = *puVar12;\n                            if ((uVar1 == 0) || (*puVar4 == 0)) break;\n                            if (((*(*(*(unaff_EBP + 8) + 0x48) + 1 + uVar1 * 2) & 0x80) != 0) && (1 < *puVar4)) {\n                                puVar12 = puVar12 + 1;\n                                if (*puVar12 == 0) goto code_r0x00419bfa;\n                                **ppuVar5 = uVar1;\n                                *ppuVar5 = *ppuVar5 + 1;\n                                *puVar4 = *puVar4 - 1;\n                            }\n                            **ppuVar5 = *puVar12;\n                            *ppuVar5 = *ppuVar5 + 1;\n                            puVar12 = puVar12 + 1;\n                            *puVar4 = *puVar4 - 1;\n                        }\n                    }\n                }\n                *(unaff_EBP + -0x20) = *(unaff_EBP + -0x24);\n            }\ncode_r0x00419f1e:\n            cVar11 = **(unaff_EBP + -0x20);\n            if (cVar11 == '\\0') break;\n            puVar15 = *(unaff_EBP + 0x10);\n        }\n    }\ncode_r0x00419bfa:\n    *(unaff_EBP + -0x58) = 0x419c02;\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 4038
    },
    "0041de4c": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_24h_2\n// WARNING: Variable defined which should be unmapped: var_20h_2\n// WARNING: Variable defined which should be unmapped: var_1ch_2\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_28h\n\nvoid __cdecl\nfcn.0041de4c(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint CodePage, uint noname_5, uint arg_8h, \n            uint arg_ch, uint noname_8, uint noname_9, uint arg_18h)\n\n{\n    int32_t iVar1;\n    uchar *arg_8h_00;\n    int32_t unaff_EBP;\n    uint Locale;\n    uint LCType;\n    uint lpLCData;\n    uint cchData;\n    uint var_34h;\n    uint uVar2;\n    uint var_28h;\n    uint var_24h_2;\n    uint var_20h_2;\n    uint var_1ch_2;\n    uint uStack24;\n    uint uStack20;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    \n    var_18h = 0x18;\n    var_1ch = 0x4753d8;\n    var_20h = 0x41de58;\n    fcn.0040daac();\n    if (*0x499dac == 0) {\n        var_20h = 0;\n        var_24h = 0;\n        uStack20 = 1;\n        uStack24 = 0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)();\n        if (iVar1 == 0) {\n            var_20h = 0x41de81;\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x499dac = 2;\n            }\n        }\n        else {\n            *0x499dac = 1;\n        }\n    }\n    if (*0x499dac == 1) {\n        var_20h = *(unaff_EBP + 0x14);\n        var_24h = *(unaff_EBP + 0x10);\n        uStack20 = *(unaff_EBP + 0xc);\n        uStack24 = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)();\n    }\n    else if ((*0x499dac == 2) || (*0x499dac == 0)) {\n        *(unaff_EBP + -0x1c) = 0;\n        *(unaff_EBP + -0x24) = 0;\n        if (*(unaff_EBP + 0x18) == 0) {\n            *(unaff_EBP + 0x18) = *0x499c24;\n        }\n        var_20h = 0;\n        var_24h = 0;\n        uStack20 = *(unaff_EBP + 0xc);\n        uStack24 = *(unaff_EBP + 8);\n        arg_8h_00 = &stack0xffffffe8;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)();\n        *(unaff_EBP + -0x20) = iVar1;\n        if (iVar1 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.0040dc10();\n            *(unaff_EBP + -0x18) = &stack0xffffffe8;\n            *(unaff_EBP + -0x28) = &stack0xffffffe8;\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x18) {\n                arg_8h_00 = fcn.0040d946(*(unaff_EBP + -0x20));\n                if (arg_8h_00 == NULL) goto code_r0x0041df73;\n                *(unaff_EBP + -0x24) = 1;\n            }\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)\n                              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), arg_8h_00, *(unaff_EBP + -0x20));\n            if (iVar1 != 0) {\n                if (*(unaff_EBP + 0x14) == 0) {\n                    var_28h = 0;\n                    uVar2 = 0;\n                }\n                else {\n                    var_28h = *(unaff_EBP + 0x14);\n                    uVar2 = *(unaff_EBP + 0x10);\n                }\n                uVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                  (*(unaff_EBP + 0x18), 1, arg_8h_00, 0xffffffff, uVar2, var_28h);\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            if (*(unaff_EBP + -0x24) != 0) {\n                fcn.0040d958(arg_8h_00);\n            }\n        }\n    }\ncode_r0x0041df73:\n    *(unaff_EBP + -0x38) = 0x41df7b;\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 1247
    },
    "0041df7c": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_24h_2\n// WARNING: Variable defined which should be unmapped: var_20h_2\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_28h\n\nvoid __cdecl\nfcn.0041df7c(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint CodePage, uint noname_5, uint Locale, \n            uint LCType, uint lpLCData, uint cchData, uint arg_18h)\n\n{\n    int32_t iVar1;\n    uchar *arg_8h;\n    int32_t unaff_EBP;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h;\n    uint var_4h;\n    uint uVar2;\n    uint uVar3;\n    uint var_28h;\n    uint var_24h_2;\n    uint var_20h_2;\n    uint var_34h;\n    uint uStack24;\n    uint uStack20;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    \n    var_18h = 0x18;\n    var_1ch = 0x4753e8;\n    var_20h = 0x41df88;\n    fcn.0040daac();\n    if (*0x499db0 == 0) {\n        var_20h = 0;\n        var_24h = 0;\n        uStack20 = 1;\n        uStack24 = 0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)();\n        if (iVar1 == 0) {\n            var_20h = 0x41dfb1;\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x499db0 = 2;\n            }\n        }\n        else {\n            *0x499db0 = 1;\n        }\n    }\n    if ((*0x499db0 == 2) || (*0x499db0 == 0)) {\n        var_20h = *(unaff_EBP + 0x14);\n        var_24h = *(unaff_EBP + 0x10);\n        uStack20 = *(unaff_EBP + 0xc);\n        uStack24 = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)();\n    }\n    else if (*0x499db0 == 1) {\n        *(unaff_EBP + -0x1c) = 0;\n        *(unaff_EBP + -0x20) = 0;\n        if (*(unaff_EBP + 0x18) == 0) {\n            *(unaff_EBP + 0x18) = *0x499c24;\n        }\n        var_20h = 0;\n        var_24h = 0;\n        uStack20 = *(unaff_EBP + 0xc);\n        uStack24 = *(unaff_EBP + 8);\n        arg_8h = &stack0xffffffe8;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)();\n        *(unaff_EBP + -0x24) = iVar1;\n        if (iVar1 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.0040dc10();\n            *(unaff_EBP + -0x18) = &stack0xffffffe8;\n            *(unaff_EBP + -0x28) = &stack0xffffffe8;\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x18) {\n                arg_8h = fcn.0040d946(iVar1 * 2);\n                if (arg_8h == NULL) goto code_r0x0041e0b3;\n                *(unaff_EBP + -0x20) = 1;\n            }\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), arg_8h, iVar1);\n            if (iVar1 != 0) {\n                if (*(unaff_EBP + 0x14) == 0) {\n                    uVar3 = 0;\n                    uVar2 = 0;\n                }\n                else {\n                    uVar3 = *(unaff_EBP + 0x14);\n                    uVar2 = *(unaff_EBP + 0x10);\n                }\n                uVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                  (*(unaff_EBP + 0x18), 0, arg_8h, 0xffffffff, uVar2, uVar3, 0, 0);\n                *(unaff_EBP + -0x1c) = uVar3;\n            }\n            if (*(unaff_EBP + -0x20) != 0) {\n                fcn.0040d958(arg_8h);\n            }\n        }\n    }\ncode_r0x0041e0b3:\n    *(unaff_EBP + -0x38) = 0x41e0bb;\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 1213
    },
    "0041e13d": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_44h_2\n// WARNING: Variable defined which should be unmapped: var_40h_3\n// WARNING: Variable defined which should be unmapped: var_3ch_3\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_40h_2\n// WARNING: Variable defined which should be unmapped: var_3ch_2\n// WARNING: Variable defined which should be unmapped: var_5ch\n\nvoid __cdecl\nfcn.0041e13d(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint arg_8h, uint arg_ch, uint lpMultiByteStr, uint cbMultiByte, \n            uint lpString2, uint cchCount2, uint CodePage)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint8_t *puVar4;\n    uint *arg_8h_00;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    int32_t iVar6;\n    uint Locale;\n    uint dwCmpFlags;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint lpCPInfo;\n    uint var_4h_2;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_18h_2;\n    uint var_1ch_2;\n    uint var_20h;\n    uint var_4h;\n    uint var_50h;\n    uint var_44h_2;\n    uint var_40h_3;\n    uint var_3ch_3;\n    uint lpString1;\n    uint var_30h_2;\n    uchar auStack48 [2];\n    uint var_2ah;\n    int32_t var_4ch;\n    uint var_40h_2;\n    uint var_3ch_2;\n    uint var_5ch;\n    uint uVar7;\n    \n    uVar7 = 0x40;\n    fcn.0040daac();\n    *(unaff_EBP + -0x1c) = *0x496830;\n    iVar6 = 0;\n    if (*0x499db4 == 0) {\n        var_4ch = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_CompareStringW)();\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar2 == 0x78) {\n                *0x499db4 = 2;\n            }\n        }\n        else {\n            *0x499db4 = 1;\n        }\n    }\n    if (0 < *(unaff_EBP + 0x14)) {\n        uVar3 = fcn.0041e121();\n        *(unaff_EBP + 0x14) = uVar3;\n    }\n    iVar2 = *(unaff_EBP + 0x1c);\n    if (0 < iVar2) {\n        iVar2 = fcn.0041e121();\n        *(unaff_EBP + 0x1c) = iVar2;\n    }\n    if ((*0x499db4 == 2) || (*0x499db4 == 0)) {\n        *(unaff_EBP + -0x38) = 0;\n        if (*(unaff_EBP + 8) == 0) {\n            *(unaff_EBP + 8) = *0x499c14;\n        }\n        iVar2 = *(unaff_EBP + 0x20);\n        if (*(unaff_EBP + 0x20) == 0) {\n            iVar2 = *0x499c24;\n        }\n        iVar5 = fcn.0041921e(*(unaff_EBP + 8));\n        if (iVar5 == -1) goto code_r0x0041e4b0;\n        if (iVar5 != iVar2) {\n            var_4ch = iVar2;\n            iVar6 = fcn.00419261(iVar2, iVar5, *(unaff_EBP + 0x10), unaff_EBP + 0x14, 0, 0, 0x4753f8, uVar7);\n            if (iVar6 == 0) goto code_r0x0041e4b0;\n            var_4ch = iVar2;\n            iVar2 = fcn.00419261(iVar2, iVar5, *(unaff_EBP + 0x18), unaff_EBP + 0x1c, 0, 0, 0x4753f8, uVar7);\n            *(unaff_EBP + -0x38) = iVar2;\n            if (iVar2 == 0) {\n                fcn.0040d958(iVar6);\n                goto code_r0x0041e4b0;\n            }\n            *(unaff_EBP + 0x10) = iVar6;\n            *(unaff_EBP + 0x18) = *(unaff_EBP + -0x38);\n        }\n        var_4ch = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_CompareStringA)();\n        if (iVar6 != 0) {\n            fcn.0040d958(iVar6);\n            stack0xffffffd4 = 0x41e4ac;\n            fcn.0040d958(*(unaff_EBP + -0x38));\n        }\n        goto code_r0x0041e4b0;\n    }\n    if (*0x499db4 != 1) goto code_r0x0041e4b0;\n    *(unaff_EBP + -0x3c) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    *(unaff_EBP + -0x40) = 0;\n    if (*(unaff_EBP + 0x20) == 0) {\n        *(unaff_EBP + 0x20) = *0x499c24;\n    }\n    if ((*(unaff_EBP + 0x14) == 0) || (iVar2 == 0)) {\n        if ((*(unaff_EBP + 0x14) == iVar2) ||\n           (((1 < iVar2 || (1 < *(unaff_EBP + 0x14))) || (iVar6 = (*_sym.imp.KERNEL32.dll_GetCPInfo)(),  iVar6 == 0))))\n        goto code_r0x0041e4b0;\n        if (0 < *(unaff_EBP + 0x14)) {\n            if (1 < *(unaff_EBP + -0x30)) {\n                puVar4 = unaff_EBP + -0x2a;\n                uVar1 = *(unaff_EBP + -0x2a);\n                while (((uVar1 != 0 && (puVar4[1] != 0)) &&\n                       ((**(unaff_EBP + 0x10) < *puVar4 || (puVar4[1] < **(unaff_EBP + 0x10)))))) {\n                    puVar4 = puVar4 + 2;\n                    uVar1 = *puVar4;\n                }\n            }\n            goto code_r0x0041e4b0;\n        }\n        if (0 < *(unaff_EBP + 0x1c)) {\n            if (1 < *(unaff_EBP + -0x30)) {\n                puVar4 = unaff_EBP + -0x2a;\n                uVar1 = *(unaff_EBP + -0x2a);\n                while (((uVar1 != 0 && (puVar4[1] != 0)) &&\n                       ((**(unaff_EBP + 0x18) < *puVar4 || (puVar4[1] < **(unaff_EBP + 0x18)))))) {\n                    puVar4 = puVar4 + 2;\n                    uVar1 = *puVar4;\n                }\n            }\n            goto code_r0x0041e4b0;\n        }\n    }\n    var_4ch = *(unaff_EBP + 0x20);\n    iVar6 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n    *(unaff_EBP + -0x48) = iVar6;\n    if (iVar6 == 0) goto code_r0x0041e4b0;\n    *(unaff_EBP + -4) = 0;\n    fcn.0040dc10();\n    *(unaff_EBP + -0x18) = &fcn.0041e13d::var_4ch;\n    *(unaff_EBP + -0x34) = &fcn.0041e13d::var_4ch;\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + -0x34) == 0) {\n        iVar2 = fcn.0040d946();\n        *(unaff_EBP + -0x34) = iVar2;\n        if (iVar2 == 0) goto code_r0x0041e4b0;\n        *(unaff_EBP + -0x3c) = 1;\n    }\n    unique0x00007a00 = *(unaff_EBP + 0x14);\n    _auStack48 = *(unaff_EBP + 0x10);\n    var_30h_2 = 1;\n    lpString1 = *(unaff_EBP + 0x20);\n    iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n    if (iVar2 != 0) {\n        arg_8h_00 = &fcn.0041e13d::lpString1;\n        iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                          (*(unaff_EBP + 0x20), 9, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c), 0, 0);\n        *(unaff_EBP + -0x4c) = iVar2;\n        if (iVar2 != 0) {\n            *(unaff_EBP + -4) = 1;\n            fcn.0040dc10();\n            *(unaff_EBP + -0x18) = &fcn.0041e13d::lpString1;\n            *(unaff_EBP + -0x50) = &fcn.0041e13d::lpString1;\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x38) {\n                arg_8h_00 = fcn.0040d946(iVar2 * 2);\n                if (arg_8h_00 == NULL) goto code_r0x0041e3eb;\n                *(unaff_EBP + -0x44) = 1;\n            }\n            iVar5 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                              (*(unaff_EBP + 0x20), 1, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c), arg_8h_00, iVar2);\n            if (iVar5 != 0) {\n                uVar7 = (*_sym.imp.KERNEL32.dll_CompareStringW)\n                                  (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x34), iVar6, arg_8h_00, iVar2);\n                *(unaff_EBP + -0x40) = uVar7;\n            }\n            if (*(unaff_EBP + -0x44) != 0) {\n                fcn.0040d958(arg_8h_00);\n            }\n        }\n    }\ncode_r0x0041e3eb:\n    if (*(unaff_EBP + -0x3c) != 0) {\n        fcn.0040d958(*(unaff_EBP + -0x34));\n    }\ncode_r0x0041e4b0:\n    *(unaff_EBP + -0x60) = 0x41e4bb;\n    fcn.0040e60a();\n    *(unaff_EBP + -0x60) = 0x41e4c0;\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 2895
    },
    "0041e744": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041e744(int32_t *arg_8h, int32_t *arg_ch)\n\n{\n    int16_t iVar1;\n    uint16_t uVar2;\n    int32_t *piVar3;\n    uint16_t uVar4;\n    int32_t iVar5;\n    uint16_t uVar6;\n    uint32_t uVar7;\n    uint16_t uVar8;\n    int32_t var_28h;\n    uint16_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint *var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar3 = arg_ch;\n    var_4h = *0x496830;\n    var_1ch = 0;\n    var_10h._0_1_ = 0;\n    var_10h._1_1_ = 0;\n    var_10h._2_2_ = 0;\n    var_ch._0_2_ = 0;\n    var_ch._2_2_ = 0;\n    var_8h._0_2_ = 0;\n    var_8h._2_1_ = 0;\n    var_8h._3_1_ = 0;\n    uVar6 = *(arg_ch + 10) & 0x7fff;\n    uVar4 = *(arg_8h + 10) & 0x7fff;\n    uVar8 = (*(arg_ch + 10) ^ *(arg_8h + 10)) & 0x8000;\n    uVar2 = uVar6 + uVar4;\n    if (((uVar4 < 0x7fff) && (uVar6 < 0x7fff)) && (uVar2 < 0xbffe)) {\n        if (uVar2 < 0x3fc0) {\ncode_r0x0041e7f1:\n            arg_8h[2] = 0;\n            arg_8h[1] = 0;\n            *arg_8h = 0;\n            goto code_r0x0041e969;\n        }\n        if (uVar4 == 0) {\n            uVar2 = uVar2 + 1;\n            arg_8h._0_2_ = 0;\n            if ((((arg_8h[2] & 0x7fffffffU) != 0) || (arg_8h[1] != 0)) || (*arg_8h != 0)) goto code_r0x0041e7db;\n        }\n        else {\ncode_r0x0041e7db:\n            if (((uVar6 == 0) && (uVar2 = uVar2 + 1,  (arg_ch[2] & 0x7fffffffU) == 0)) &&\n               ((arg_ch[1] == 0 && (*arg_ch == 0)))) goto code_r0x0041e7f1;\n            var_18h = 0;\n            var_14h = &var_ch;\n            arg_ch = 0x5;\n            do {\n                if (0 < arg_ch) {\n                    var_24h = var_18h * 2 + arg_8h;\n                    var_20h = piVar3 + 2;\n                    var_28h = arg_ch;\n                    do {\n                        iVar5 = fcn.0041d42d(var_14h[-1], *var_20h * *var_24h, var_14h + -1);\n                        if (iVar5 != 0) {\n                            *var_14h = *var_14h + 1;\n                        }\n                        var_24h = var_24h + 1;\n                        var_20h = var_20h + -2;\n                        var_28h = var_28h + -1;\n                    } while (var_28h != 0);\n                }\n                var_14h = var_14h + 2;\n                var_18h = var_18h + 1;\n                arg_ch = arg_ch + -1;\n            } while (0 < arg_ch);\n            arg_8h._0_2_ = uVar2 + 0xc002;\n            if (arg_8h < 1) {\ncode_r0x0041e8a5:\n                arg_8h._0_2_ = arg_8h - 1;\n                if (arg_8h < 0) {\n                    uVar7 = -arg_8h;\n                    arg_8h._0_2_ = 0;\n                    do {\n                        if ((var_10h & 1) != 0) {\n                            var_1ch = var_1ch + 1;\n                        }\n                        fcn.0041d4da(&var_10h);\n                        uVar7 = uVar7 - 1;\n                    } while (uVar7 != 0);\n                    if (var_1ch != 0) {\n                        var_10h._0_1_ = var_10h | 1;\n                    }\n                }\n            }\n            else {\n                do {\n                    if ((var_8h._3_1_ & 0x80) != 0) break;\n                    fcn.0041d4ac(&var_10h);\n                    arg_8h._0_2_ = arg_8h - 1;\n                } while (0 < arg_8h);\n                if (arg_8h < 1) goto code_r0x0041e8a5;\n            }\n            if ((0x8000 < CONCAT11(var_10h._1_1_, var_10h)) ||\n               ((CONCAT22(var_10h._2_2_, CONCAT11(var_10h._1_1_, var_10h)) & 0x1ffff) == 0x18000)) {\n                if (CONCAT22(var_ch, var_10h._2_2_) == -1) {\n                    var_10h._2_2_ = 0;\n                    var_ch._0_2_ = 0;\n                    if (CONCAT22(var_8h, var_ch._2_2_) == -1) {\n                        var_ch._2_2_ = 0;\n                        var_8h._0_2_ = 0;\n                        if (CONCAT11(var_8h._3_1_, var_8h._2_1_) == -1) {\n                            arg_8h._0_2_ = arg_8h + 1;\n                            var_8h._2_1_ = 0;\n                            var_8h._3_1_ = 0x80;\n                        }\n                        else {\n                            iVar1 = CONCAT11(var_8h._3_1_, var_8h._2_1_) + 1;\n                            var_8h._2_1_ = iVar1;\n                            var_8h._3_1_ = iVar1 >> 8;\n                        }\n                    }\n                    else {\n                        iVar5 = CONCAT22(var_8h, var_ch._2_2_) + 1;\n                        var_ch._2_2_ = iVar5;\n                        var_8h._0_2_ = iVar5 >> 0x10;\n                    }\n                }\n                else {\n                    iVar5 = CONCAT22(var_ch, var_10h._2_2_) + 1;\n                    var_10h._2_2_ = iVar5;\n                    var_ch._0_2_ = iVar5 >> 0x10;\n                }\n            }\n            if (0x7ffe < arg_8h) goto code_r0x0041e94e;\n            *arg_8h = var_10h._2_2_;\n            *(arg_8h + 2) = CONCAT22(var_ch._2_2_, var_ch);\n            *(arg_8h + 6) = CONCAT13(var_8h._3_1_, CONCAT12(var_8h._2_1_, var_8h));\n            arg_8h._0_2_ = arg_8h | uVar8;\n        }\n        *(arg_8h + 10) = arg_8h;\n    }\n    else {\ncode_r0x0041e94e:\n        arg_8h[1] = 0;\n        *arg_8h = 0;\n        arg_8h[2] = (-(uVar8 != 0) & 0x80000000) + 0x7fff8000;\n    }\ncode_r0x0041e969:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 1926
    },
    "004241b1": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n\nuint __cdecl fcn.004241b1(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t in_ECX;\n    uint32_t uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint *puStack28;\n    uint var_14h;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    puStack28 = &var_8h;\n    uStack32 = 0;\n    uStack36 = 0x434;\n    uStack40 = *(in_ECX + 0x1c);\n    var_4h = 0;\n    var_8h = 0;\n    (*_sym.imp.USER32.dll_SendMessageA)();\n    fcn.0040dc10();\n    uStack40 = uStack40 & 0xffffff00;\n    (*pcVar1)(*(in_ECX + 0x1c), 0x43e, 0, &uStack40);\n    fcn.004045fc(&uStack40);\n    return arg_8h;\n}\n",
        "token_count": 262
    },
    "0042dd71": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042dd71(int32_t arg_8h)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint16_t *puVar4;\n    uint32_t uVar5;\n    bool bVar6;\n    \n    bVar6 = *(arg_8h + 2) == -1;\n    iVar2 = fcn.0042dd26(arg_8h);\n    iVar3 = fcn.0042dc66(arg_8h);\n    if (iVar3 != 0) {\n        iVar2 = iVar2 + (bVar6 * 2 + 1) * 2;\n        iVar3 = fcn.00410138(iVar2);\n        iVar2 = iVar2 + 2 + iVar3 * 2;\n    }\n    if (bVar6) {\n        uVar1 = *(arg_8h + 0x10);\n    }\n    else {\n        uVar1 = *(arg_8h + 8);\n    }\n    if (uVar1 != 0) {\n        uVar5 = uVar1;\n        do {\n            puVar4 = (iVar2 + 3U & 0xfffffffc) + (-bVar6 & 6) + 0x12;\n            if (*puVar4 == 0xffff) {\n                puVar4 = puVar4 + 2;\n            }\n            else {\n                do {\n                    uVar1 = *puVar4;\n                    puVar4 = puVar4 + 1;\n                } while (uVar1 != 0);\n            }\n            if (*puVar4 == 0xffff) {\n                puVar4 = puVar4 + 2;\n            }\n            else {\n                do {\n                    uVar1 = *puVar4;\n                    puVar4 = puVar4 + 1;\n                } while (uVar1 != 0);\n            }\n            uVar1 = *puVar4;\n            if ((uVar1 != 0) && (!bVar6)) {\n                uVar1 = uVar1 - 2;\n            }\n            uVar5 = uVar5 - 1;\n            iVar2 = puVar4 + uVar1 + 2;\n        } while (uVar5 != 0);\n    }\n    return iVar2 - arg_8h;\n}\n",
        "token_count": 509
    },
    "0042de34": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042de34(uint lpMultiByteStr, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    ushort *puVar5;\n    uint32_t arg_ch_00;\n    uint *in_ECX;\n    int32_t iVar6;\n    int16_t iVar7;\n    uint32_t arg_8h;\n    bool bVar8;\n    uint var_54h;\n    uint hMem;\n    uint var_4ch;\n    uint var_48h;\n    uint lpWideCharStr;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    if (in_ECX[1] != 0) {\n        puVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*in_ECX);\n        bVar8 = *(puVar2 + 2) == -1;\n        iVar3 = fcn.0042dc66(puVar2);\n        iVar1 = bVar8 * 2 + 1;\n        if (bVar8) {\n            puVar2[3] = puVar2[3] | 0x40;\n        }\n        else {\n            *puVar2 = *puVar2 | 0x40;\n        }\n        iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpMultiByteStr);\n        if (iVar4 < 0x20) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, lpMultiByteStr, 0xffffffff, &lpWideCharStr, 0x20)\n            ;\n            iVar4 = iVar1 * 2 + iVar4 * 2;\n            puVar5 = fcn.0042dd26(puVar2);\n            iVar6 = 0;\n            if (iVar3 != 0) {\n                iVar3 = fcn.00410138(puVar5 + iVar1);\n                iVar6 = iVar1 * 2 + 2 + iVar3 * 2;\n            }\n            arg_ch_00 = iVar6 + 3 + puVar5 & 0xfffffffc;\n            arg_8h = puVar5 + iVar4 + 3 & 0xfffffffc;\n            if (bVar8) {\n                iVar7 = *(puVar2 + 4);\n            }\n            else {\n                iVar7 = *(puVar2 + 2);\n            }\n            if ((iVar4 != iVar6) && (iVar7 != 0)) {\n                fcn.0040ea50(arg_8h, arg_ch_00, puVar2 + (in_ECX[1] - arg_ch_00));\n            }\n            *puVar5 = arg_ch;\n            fcn.0040ea50(puVar5 + iVar1, &lpWideCharStr, iVar4 + iVar1 * -2);\n            in_ECX[1] = in_ECX[1] + (arg_8h - arg_ch_00);\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*in_ECX);\n            in_ECX[2] = 0;\n        }\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 704
    },
    "null": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "0044a03d": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0044a03d(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *in_ECX;\n    int32_t iVar3;\n    uint unaff_EBX;\n    int32_t iVar4;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    int32_t iVar5;\n    uint *puVar6;\n    int32_t var_8h_3;\n    int32_t var_ch_2;\n    uint var_30h;\n    uint lpRect;\n    uint dy;\n    uint var_1ch;\n    uint var_14h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    int32_t aiStack92 [2];\n    uchar *puStack84;\n    uchar *puStack80;\n    uint uStack76;\n    uchar *puStack72;\n    int32_t iStack68;\n    int32_t iStack40;\n    int32_t iStack32;\n    int32_t iStack24;\n    int32_t var_ch_3;\n    uchar *var_8h_2;\n    int32_t var_4h_2;\n    \n    if (var_8h_3 != 0) {\n        (*_sym.imp.USER32.dll_GetWindowRect)();\n        iStack68 = -iStack40;\n        puStack72 = &stack0xffffffd8;\n        uStack76 = 0x44a076;\n        (*_sym.imp.USER32.dll_OffsetRect)();\n        uStack76 = 1;\n        puStack80 = &stack0xffffffd8;\n        puStack84 = 0x44a086;\n        (**(*in_ECX + 0x13c))();\n        puStack84 = &stack0xffffffe8;\n        aiStack92[1] = 0;\n        aiStack92[0] = 0x407;\n        var_8h_2 = &stack0xffffffa4;\n        (**(*in_ECX + 0x110))();\n        iVar5 = (iStack32 - iStack40) + var_ch_3;\n        var_8h_3 = 0;\n        iVar4 = in_ECX[0x1c];\n        if (0 < iVar4) {\n            piVar2 = in_ECX[0x1d] + 4;\n            iVar3 = iVar4;\n            do {\n                if ((*(piVar2 + 7) & 8) != 0) {\n                    var_8h_3 = var_8h_3 + 1;\n                }\n                iVar1 = *piVar2;\n                piVar2 = piVar2 + 5;\n                iVar5 = iVar5 + ((-6 - iVar1) - var_ch_3);\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n        fcn.0040dc10();\n        var_4h_2 = 0;\n        if (0 < iVar4) {\n            iVar4 = in_ECX[0x1d] + 8;\n            do {\n                iStack24 = iStack24 + 6 + *(iVar4 + -4);\n                if (((*(iVar4 + 3) & 8) != 0) && (0 < iVar5)) {\n                    iVar3 = iVar5 / var_8h_3;\n                    iStack24 = iStack24 + iVar3;\n                    var_8h_3 = var_8h_3 + -1;\n                    iVar5 = iVar5 - iVar3;\n                }\n                *(&stack0xffffffa4 + var_4h_2 * 4) = iStack24;\n                iStack24 = iStack24 + var_ch_3;\n                iVar4 = iVar4 + 0x14;\n                var_4h_2 = var_4h_2 + 1;\n            } while (var_4h_2 < in_ECX[0x1c]);\n        }\n        (**(*in_ECX + 0x110))(0x404, in_ECX[0x1c], &stack0xffffffa4);\n    }\n    iVar4 = 0;\n    if ((var_ch_2 != 0) && (0 < in_ECX[0x1c])) {\n        puVar6 = in_ECX[0x1d] + 0x10;\n        do {\n            if ((*(puVar6 + -1) & 1) != 0) {\n                iStack68 = 0x44a161;\n                fcn.0043ad35(iVar4, *puVar6, 1, unaff_EDI, unaff_ESI, unaff_EBX);\n            }\n            puVar6 = puVar6 + 5;\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < in_ECX[0x1c]);\n    }\n    return;\n}\n",
        "token_count": 1210
    },
    "0045eaa1": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING (jumptable): Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_44h\n// WARNING: Variable defined which should be unmapped: var_44h_2\n\nint32_t __cdecl\nfcn.0045eaa1(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_8h)\n\n{\n    uint16_t uVar1;\n    uint *puVar2;\n    char cVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint extraout_ECX;\n    int32_t *piVar7;\n    int32_t unaff_EBP;\n    uint unaff_EDI;\n    uint32_t uVar8;\n    uint *in_FS_OFFSET;\n    float10 fVar9;\n    ulong uVar10;\n    uint pvargDest;\n    uint var_8h_2;\n    uint lpString;\n    uint var_ch;\n    uint var_14h_2;\n    uint var_14h;\n    uint var_10h;\n    uint var_44h_2;\n    uint var_44h;\n    int32_t var_34h;\n    uint var_30h;\n    uint var_1ch_2;\n    uint var_20h_2;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_11h;\n    uint var_ch_2;\n    uint var_8h_3;\n    \n    fcn.0040e188();\n    iVar6 = *(unaff_EBP + 8);\n    iVar5 = *(iVar6 + 8);\n    *(unaff_EBP + -0x10) = &stack0xffffffc8;\n    *(unaff_EBP + -0x20) = extraout_ECX;\n    *(unaff_EBP + -0x11) = 0;\n    *(unaff_EBP + 8) = iVar5;\n    if (iVar5 == 0) {\n        *(unaff_EBP + 8) = unaff_EBP + -0x11;\n    }\n    var_30h = *(unaff_EBP + 8);\n    var_34h = 0x45ead7;\n    iVar5 = (*_sym.imp.KERNEL32.dll_lstrlenA)();\n    *(unaff_EBP + -0x18) = *(iVar6 + 0x10);\n    *(unaff_EBP + -0x1c) = *(iVar6 + 0xc);\n    if ((*(unaff_EBP + 0xc) & 0xc) == 0) {\ncode_r0x0045eb45:\n        iVar6 = *(unaff_EBP + 0x14);\n        var_34h = *(iVar6 + 8) << 4;\n        var_44h = 0x45eb54;\n        cVar3 = fcn.0040100a(var_34h, var_30h, unaff_EDI);\n        if (cVar3 != '\\0') {\n            iVar5 = *(iVar6 + 8);\n            var_34h = 0x45eb6c;\n            fcn.0040dc10();\n            *(unaff_EBP + -0x10) = &fcn.0045eaa1::var_30h;\n            *(unaff_EBP + 0xc) = &fcn.0045eaa1::var_30h;\n            var_44h = 0;\n            var_34h = iVar5 << 4;\n            fcn.0040e620(*(unaff_EBP + 0xc));\n            var_34h = *(unaff_EBP + -0x1c);\n            var_44h = *(unaff_EBP + 8);\n            iVar5 = fcn.0045e670();\n            cVar3 = fcn.0040100a(iVar5 + 0x10, var_44h, var_34h);\n            if (cVar3 != '\\0') {\n                fcn.0040dc10();\n                *(unaff_EBP + -0x10) = &fcn.0045eaa1::var_44h;\n                iVar6 = fcn.0045e6b2(&fcn.0045eaa1::var_44h, *(unaff_EBP + 8), unaff_EBP + -0x34, *(unaff_EBP + -0x1c), \n                                     iVar6, *(unaff_EBP + 0x18), *(unaff_EBP + 0xc));\n                piVar7 = NULL;\n                *(unaff_EBP + 0x18) = iVar6;\n                if (iVar6 == 0) {\n                    uVar1 = *(unaff_EBP + -0x1c);\n                    *(unaff_EBP + -4) = 0;\n                    if (uVar1 == 4) {\n                        fVar9 = fcn.0045f730(*(unaff_EBP + -0x18), &fcn.0045eaa1::var_44h, iVar5);\n                        *(unaff_EBP + 8) = fVar9;\n                        *(unaff_EBP + -0x34) = *(unaff_EBP + 8);\n                    }\n                    else {\n                        if (uVar1 == 5) {\n                            fVar9 = fcn.0045f730(*(unaff_EBP + -0x18), &fcn.0045eaa1::var_44h, iVar5);\n                            *(unaff_EBP + -0x24) = fVar9;\n                        }\n                        else {\n                            if (uVar1 != 7) {\n                                if ((uVar1 < 0x14) || (0x15 < uVar1)) {\n                                    piVar7 = fcn.0045f730(*(unaff_EBP + -0x18), &fcn.0045eaa1::var_44h, iVar5);\n                                }\n                                else {\n                                    uVar10 = fcn.0045f730(*(unaff_EBP + -0x18), &fcn.0045eaa1::var_44h, iVar5);\n                                    *(unaff_EBP + -0x34) = uVar10;\n                                    *(unaff_EBP + -0x30) = uVar10 >> 0x20;\n                                }\n                                goto code_r0x0045ec16;\n                            }\n                            fVar9 = fcn.0045f730(*(unaff_EBP + -0x18), &fcn.0045eaa1::var_44h, iVar5);\n                            *(unaff_EBP + -0x24) = fVar9;\n                        }\n                        *(unaff_EBP + -0x34) = fVar9;\n                    }\n                }\ncode_r0x0045ec16:\n                iVar6 = *(unaff_EBP + 0x14);\n                *(unaff_EBP + -4) = 0xffffffff;\n                uVar8 = 0;\n                if (*(iVar6 + 8) != 0) {\n                    *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc);\n                    do {\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(*(unaff_EBP + 0xc));\n                        *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc) + 0x10;\n                        uVar8 = uVar8 + 1;\n                    } while (uVar8 < *(iVar6 + 8));\n                }\n                iVar6 = *(unaff_EBP + 0x18);\n                if (iVar6 != 0) goto code_r0x0045ed53;\n                puVar2 = *(unaff_EBP + 0x10);\n                if (puVar2 == NULL) {\n                    iVar4 = *(unaff_EBP + -0x1c);\n                    if (iVar4 == 8) {\n                        if (piVar7 != NULL) {\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(piVar7);\n                        }\n                    }\n                    else if (iVar4 == 9) {\ncode_r0x0045ed2e:\n                        if (piVar7 != NULL) {\n                            (**(*piVar7 + 8))(piVar7);\n                        }\n                    }\n                    else if (iVar4 == 0xc) {\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(unaff_EBP + -0x34);\n                    }\n                    else if (iVar4 == 0xd) goto code_r0x0045ed2e;\n                }\n                else {\n                    uVar8 = *(unaff_EBP + -0x1c);\n                    *puVar2 = uVar8;\n    // switch table (20 cases) at 0x45ed67\n                    switch(uVar8 & 0xffff) {\n                    case 3:\n                    case 8:\n                    case 9:\n                    case 10:\n                    case 0xd:\n                    case 0x13:\n                        puVar2[2] = piVar7;\n                        break;\n                    case 4:\n                        puVar2[2] = *(unaff_EBP + -0x34);\n                        break;\n                    case 5:\n                    case 7:\n                        *(puVar2 + 2) = *(unaff_EBP + -0x34);\n                        break;\n                    case 6:\n                    case 0x14:\n                    case 0x15:\n                        puVar2[2] = *(unaff_EBP + -0x34);\n                        puVar2[3] = *(unaff_EBP + -0x30);\n                        break;\n                    case 0xb:\n                        piVar7 = -(piVar7 != NULL);\n                    case 2:\n                    case 0x12:\n                        *(puVar2 + 2) = piVar7;\n                        break;\n                    case 0xc:\n                        *puVar2 = *(unaff_EBP + -0x34);\n                        puVar2[1] = *(unaff_EBP + -0x30);\n                        puVar2[2] = *(unaff_EBP + -0x2c);\n                        puVar2[3] = *(unaff_EBP + -0x28);\n                        break;\n                    case 0x10:\n                    case 0x11:\n                        *(puVar2 + 2) = piVar7;\n                    }\n                }\n                iVar6 = 0;\n                goto code_r0x0045ed53;\n            }\n        }\n    }\n    else {\n        var_34h = iVar5 + 3;\n        var_44h = 0x45eaf6;\n        cVar3 = fcn.0040100a(var_34h, var_30h, unaff_EDI);\n        if (cVar3 != '\\0') {\n            var_34h = 0x45eb0c;\n            fcn.0040dc10();\n            *(unaff_EBP + -0x10) = &fcn.0045eaa1::var_30h;\n            var_44h = *(unaff_EBP + 8);\n            var_34h = iVar5;\n            fcn.0040e680(&fcn.0045eaa1::var_30h, var_44h, iVar5);\n            iVar4 = *(iVar6 + 0xc);\n            *(unaff_EBP + 8) = &fcn.0045eaa1::var_30h;\n            if (iVar4 == 8) {\n                iVar4 = 0xe;\n            }\n            *(&fcn.0045eaa1::var_30h + iVar5) = 0xff;\n            *(unaff_EBP + -0x1c) = 0;\n            *(&fcn.0045eaa1::var_30h + iVar5 + 1) = iVar4;\n            *(&fcn.0045eaa1::var_30h + iVar5 + 2) = 0;\n            *(unaff_EBP + -0x18) = *(iVar6 + 0x14);\n            goto code_r0x0045eb45;\n        }\n    }\n    iVar6 = -0x7ff8fff2;\ncode_r0x0045ed53:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar6;\n}\n",
        "token_count": 2807
    },
    "00401069": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/77a25ea9f6f245cfb8807f7953974472",
            "validate payment card number using luhn algorithm with no lookup table/101d11b5106849ad963488c88a9294b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.00401069(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint var_8h;\n    \n    iVar4 = 0;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetThreadLocale)();\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)(uVar1, 0x1004, &var_8h, 7);\n    if ((iVar2 != 0) && (puVar3 = &var_8h,  var_8h != '\\0')) {\n        do {\n            puVar3 = puVar3 + 1;\n            iVar4 = var_8h + -0x30 + iVar4 * 10;\n            var_8h._0_1_ = *puVar3;\n        } while (var_8h != '\\0');\n        if (iVar4 != 0) {\n            return iVar4;\n        }\n    }\n    iVar4 = (*_sym.imp.KERNEL32.dll_GetACP)();\n    return iVar4;\n}\n",
        "token_count": 252
    },
    "00413fc5": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/77a25ea9f6f245cfb8807f7953974472",
            "validate payment card number using luhn algorithm with no lookup table/101d11b5106849ad963488c88a9294b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00413fc5(uint param_1, uint16_t *param_2, int32_t **param_3)\n\n{\n    uint16_t *puVar1;\n    int32_t **ppiVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int32_t extraout_ECX;\n    int32_t *piVar7;\n    uint16_t uVar8;\n    uint32_t unaff_EBX;\n    uint8_t *arg_ch;\n    bool bVar9;\n    int64_t iVar10;\n    int32_t *piStack1116;\n    int32_t *piStack1112;\n    uint8_t *puStack1104;\n    uint32_t uStack1100;\n    uint uStack1096;\n    int32_t iStack1092;\n    int32_t iStack1088;\n    int32_t iStack1084;\n    int32_t iStack1080;\n    int32_t *piStack1076;\n    uchar uStack1072;\n    uchar uStack1071;\n    ushort uStack1068;\n    int16_t iStack1066;\n    int32_t iStack1064;\n    int32_t *piStack1060;\n    int32_t iStack1056;\n    int32_t iStack1052;\n    int32_t *piStack1048;\n    int32_t iStack1044;\n    int32_t *piStack1040;\n    uint32_t uStack1036;\n    int32_t aiStack1032 [127];\n    uint uStack521;\n    uint uStack8;\n    \n    uStack8 = *0x496830;\n    uVar8 = *param_2;\n    arg_ch = unaff_EBX & 0xffff0000 | uVar8;\n    iStack1044 = 0;\n    iStack1052 = 0;\n    piStack1076 = NULL;\n    iVar6 = 0;\n    puVar1 = param_2;\n    ppiVar2 = param_3;\n    while (uVar8 != 0) {\n        param_2 = puVar1 + 1;\n        if (iStack1052 < 0) break;\n        uVar8 = arg_ch;\n        if ((uVar8 < 0x20) || (0x78 < uVar8)) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = *((arg_ch & 0xffff) + 0x4739d8) & 0xf;\n        }\n        iStack1092 = *(iVar6 + 0x4739f8 + uVar4 * 8) >> 4;\n        param_3 = ppiVar2;\n    // switch table (8 cases) at 0x4147d5\n        switch(iStack1092) {\n        case 0:\ncode_r0x0041420c:\n            iStack1064 = 1;\n            fcn.00413f29(arg_ch);\n            break;\n        case 1:\n            piStack1040 = 0xffffffff;\n            uStack1096 = 0;\n            iStack1080 = 0;\n            piStack1060 = NULL;\n            iStack1056 = 0;\n            uStack1036 = 0;\n            iStack1064 = 0;\n            break;\n        case 2:\n            uVar4 = arg_ch & 0xffff;\n            if (uVar4 == 0x20) {\n                uStack1036 = uStack1036 | 2;\n            }\n            else if (uVar4 == 0x23) {\n                uStack1036 = uStack1036 | 0x80;\n            }\n            else if (uVar4 == 0x2b) {\n                uStack1036 = uStack1036 | 1;\n            }\n            else if (uVar4 == 0x2d) {\n                uStack1036 = uStack1036 | 4;\n            }\n            else if (uVar4 == 0x30) {\n                uStack1036 = uStack1036 | 8;\n            }\n            break;\n        case 3:\n            if (uVar8 == 0x2a) {\n                piStack1060 = *ppiVar2;\n                param_3 = ppiVar2 + 1;\n                if (piStack1060 < 0) {\n                    uStack1036 = uStack1036 | 4;\n                    piStack1060 = -piStack1060;\n                }\n            }\n            else {\n                piStack1060 = ((arg_ch & 0xffff) - 0x30) + piStack1060 * 10;\n            }\n            break;\n        case 4:\n            piStack1040 = NULL;\n            break;\n        case 5:\n            if (uVar8 == 0x2a) {\n                piStack1040 = *ppiVar2;\n                param_3 = ppiVar2 + 1;\n                if (piStack1040 < 0) {\n                    piStack1040 = 0xffffffff;\n                }\n            }\n            else {\n                piStack1040 = ((arg_ch & 0xffff) - 0x30) + piStack1040 * 10;\n            }\n            break;\n        case 6:\n            uVar4 = arg_ch & 0xffff;\n            if (uVar4 == 0x49) {\n                uVar8 = *param_2;\n                if ((uVar8 == 0x36) && (puVar1[2] == 0x34)) {\n                    param_2 = puVar1 + 3;\n                    uStack1036 = uStack1036 | 0x8000;\n                }\n                else if ((uVar8 == 0x33) && (puVar1[2] == 0x32)) {\n                    param_2 = puVar1 + 3;\n                    uStack1036 = uStack1036 & 0xffff7fff;\n                }\n                else if (((((uVar8 != 100) && (uVar8 != 0x69)) && (uVar8 != 0x6f)) &&\n                         ((uVar8 != 0x75 && (uVar8 != 0x78)))) && (uVar8 != 0x58)) {\n                    iStack1092 = 0;\n                    goto code_r0x0041420c;\n                }\n            }\n            else if (uVar4 == 0x68) {\n                uStack1036 = uStack1036 | 0x20;\n            }\n            else if (uVar4 == 0x6c) {\n                uStack1036 = uStack1036 | 0x10;\n            }\n            else if (uVar4 == 0x77) {\n                uStack1036 = uStack1036 | 0x800;\n            }\n            break;\n        case 7:\n            uVar4 = arg_ch & 0xffff;\n            if (uVar4 < 0x68) {\n                if (uVar4 < 0x65) {\n                    if (uVar4 < 0x59) {\n                        if (uVar4 != 0x58) {\n                            if (uVar4 == 0x43) {\n                                if ((uStack1036 & 0x830) == 0) {\n                                    uStack1036 = uStack1036 | 0x20;\n                                }\n                                goto code_r0x0041431a;\n                            }\n                            if ((uVar4 != 0x45) && (uVar4 != 0x47)) {\n                                if (uVar4 == 0x53) {\n                                    if ((uStack1036 & 0x830) == 0) {\n                                        uStack1036 = uStack1036 | 0x20;\n                                    }\n                                    goto code_r0x00414278;\n                                }\n                                goto code_r0x00414693;\n                            }\n                            uStack1096 = 1;\n                            arg_ch = arg_ch + 0x20;\n                            goto code_r0x004142ef;\n                        }\ncode_r0x00414539:\n                        iStack1088 = 7;\ncode_r0x0041453c:\n                        iStack1044 = 0x10;\n                        if ((uStack1036 & 0x80) != 0) {\n                            iStack1066 = iStack1088 + 0x51;\n                            uStack1068 = 0x30;\n                            iStack1056 = 2;\n                        }\n                        goto code_r0x0041437c;\n                    }\n                    if (uVar4 == 0x5a) {\n                        param_3 = ppiVar2 + 1;\n                        piVar7 = *ppiVar2;\n                        piVar5 = *0x496d50;\n                        piVar3 = *0x496d50;\n                        if ((piVar7 == NULL) || (piStack1048 = piVar7[1],  piVar3 = *0x496d50,  piStack1048 == NULL))\n                        goto code_r0x004144b9;\n                        iStack1044 = *piVar7;\n                        if ((uStack1036 & 0x800) == 0) {\n                            iStack1064 = 0;\n                        }\n                        else {\n                            iStack1044 = iStack1044 / 2;\n                            iStack1064 = 1;\n                        }\n                    }\n                    else if (uVar4 == 99) {\ncode_r0x0041431a:\n                        uVar8 = *ppiVar2;\n                        uStack1100 = uVar8;\n                        iStack1064 = 1;\n                        if ((uStack1036 & 0x20) == 0) {\n                            aiStack1032[0]._0_2_ = uVar8;\n                        }\n                        else {\n                            uStack1072 = uVar8;\n                            uStack1071 = 0;\n                            iVar6 = fcn.00418f34(aiStack1032, &uStack1072, *0x497310);\n                            if (iVar6 < 0) {\n                                iStack1080 = 1;\n                            }\n                        }\n                        iStack1044 = 1;\n                        param_3 = ppiVar2 + 1;\n                        piStack1048 = aiStack1032;\n                    }\n                    else if (uVar4 == 100) goto code_r0x00414371;\n                }\n                else {\ncode_r0x004142ef:\n                    uStack1036 = uStack1036 | 0x40;\n                    piVar7 = aiStack1032;\n                    piVar5 = aiStack1032;\n                    if (piStack1040 < 0) {\n                        piStack1040 = 0x6;\n                    }\n                    else if (piStack1040 == NULL) {\n                        if (arg_ch == 0x67) {\n                            piStack1040 = 0x1;\n                        }\n                    }\n                    else {\n                        if (0x200 < piStack1040) {\n                            piStack1040 = 0x200;\n                        }\n                        if ((0xa3 < piStack1040) &&\n                           (piStack1048 = aiStack1032,  piStack1076 = fcn.0040d946(piStack1040 + 0x15d), \n                           piVar7 = piStack1076,  piVar5 = piStack1076,  piStack1076 == NULL)) {\n                            piStack1040 = 0xa3;\n                            piVar7 = aiStack1032;\n                            piVar5 = piStack1048;\n                        }\n                    }\n                    piStack1048 = piVar5;\n                    piStack1116 = *ppiVar2;\n                    param_3 = ppiVar2 + 2;\n                    piStack1112 = ppiVar2[1];\n                    (**0x497070)(&piStack1116, piVar7, arg_ch, piStack1040, uStack1096);\n                    uVar4 = uStack1036 & 0x80;\n                    if ((uVar4 != 0) && (piStack1040 == NULL)) {\n                        (**0x49707c)(piVar7);\n                    }\n                    if ((arg_ch == 0x67) && (uVar4 == 0)) {\n                        (**0x497074)(piVar7);\n                    }\n                    piVar5 = piVar7;\n                    piVar3 = piStack1048;\n                    if (*piVar7 == 0x2d) {\n                        uStack1036 = uStack1036 | 0x100;\n                        piVar5 = piVar7 + 1;\n                        piVar3 = piVar7 + 1;\n                    }\ncode_r0x004144b9:\n                    piStack1048 = piVar3;\n                    iStack1044 = fcn.0040e9c0(piVar5);\n                }\ncode_r0x00414693:\n                if (iStack1080 == 0) {\n                    if ((uStack1036 & 0x40) != 0) {\n                        if ((uStack1036 & 0x100) == 0) {\n                            if ((uStack1036 & 1) == 0) {\n                                if ((uStack1036 & 2) == 0) goto code_r0x004146ce;\n                                uStack1068 = 0x20;\n                            }\n                            else {\n                                uStack1068 = 0x2b;\n                            }\n                        }\n                        else {\n                            uStack1068 = 0x2d;\n                        }\n                        iStack1056 = 1;\n                    }\ncode_r0x004146ce:\n                    arg_ch = piStack1060 + (-iStack1044 - iStack1056);\n                    if ((uStack1036 & 0xc) == 0) {\n                        fcn.00413f4e(0x20, arg_ch, param_1);\n                    }\n                    fcn.00413f73(iStack1056);\n                    if (((uStack1036 & 8) != 0) && ((uStack1036 & 4) == 0)) {\n                        fcn.00413f4e(0x30, arg_ch, param_1);\n                    }\n                    if ((iStack1064 == 0) && (0 < iStack1044)) {\n                        iStack1084 = iStack1044;\n                        piVar7 = piStack1048;\n                        do {\n                            iStack1084 = iStack1084 + -1;\n                            puStack1104 = fcn.00418f34(&uStack1100, piVar7, *0x497310);\n                            if (puStack1104 < 1) break;\n                            fcn.00413f29(uStack1100);\n                            piVar7 = piVar7 + puStack1104;\n                        } while (0 < iStack1084);\n                    }\n                    else {\n                        fcn.00413f73(iStack1044);\n                    }\n                    if ((uStack1036 & 4) != 0) {\n                        fcn.00413f4e(0x20, arg_ch, param_1);\n                    }\n                }\n            }\n            else {\n                if (uVar4 == 0x69) {\ncode_r0x00414371:\n                    uStack1036 = uStack1036 | 0x40;\ncode_r0x00414375:\n                    iStack1044 = 10;\ncode_r0x0041437c:\n                    if ((uStack1036 & 0x8000) == 0) {\n                        param_3 = ppiVar2 + 1;\n                        if ((uStack1036 & 0x20) == 0) {\n                            piVar7 = *ppiVar2;\n                            if ((uStack1036 & 0x40) == 0) {\n                                piVar5 = NULL;\n                                goto code_r0x004145dd;\n                            }\n                        }\n                        else if ((uStack1036 & 0x40) == 0) {\n                            piVar7 = *ppiVar2;\n                        }\n                        else {\n                            piVar7 = *ppiVar2;\n                        }\n                        piVar5 = piVar7 >> 0x1f;\n                    }\n                    else {\n                        piVar7 = *ppiVar2;\n                        piVar5 = ppiVar2[1];\n                        param_3 = ppiVar2 + 2;\n                    }\ncode_r0x004145dd:\n                    if ((((uStack1036 & 0x40) != 0) && (piVar5 < 1)) && (piVar5 < 0)) {\n                        bVar9 = piVar7 != NULL;\n                        piVar7 = -piVar7;\n                        piVar5 = -(piVar5 + bVar9);\n                        uStack1036 = uStack1036 | 0x100;\n                    }\n                    if ((uStack1036 & 0x8000) == 0) {\n                        piVar5 = NULL;\n                    }\n                    iVar10 = CONCAT44(piVar5, piVar7);\n                    if (piStack1040 < 0) {\n                        piStack1040 = 0x1;\n                    }\n                    else {\n                        uStack1036 = uStack1036 & 0xfffffff7;\n                        if (0x200 < piStack1040) {\n                            piStack1040 = 0x200;\n                        }\n                    }\n                    if ((piVar7 | piVar5) == 0) {\n                        iStack1056 = 0;\n                    }\n                    piVar7 = &uStack521;\n                    while( true ) {\n                        arg_ch = iVar10;\n                        piVar5 = piStack1040 + -1;\n                        if ((piStack1040 < 1) && (iVar10 == 0)) break;\n                        piStack1040 = piVar5;\n                        iVar10 = fcn.00418f70();\n                        iVar6 = extraout_ECX + 0x30;\n                        if (0x39 < iVar6) {\n                            iVar6 = iVar6 + iStack1088;\n                        }\n                        *piVar7 = iVar6;\n                        piVar7 = piVar7 + -1;\n                        puStack1104 = arg_ch;\n                    }\n                    iStack1044 = &uStack521 + -piVar7;\n                    piStack1048 = piVar7 + 1;\n                    piStack1040 = piVar5;\n                    if (((uStack1036 & 0x200) != 0) && ((*piStack1048 != 0x30 || (iStack1044 == 0)))) {\n                        *piVar7 = 0x30;\n                        iStack1044 = &uStack521 + -piVar7 + 1;\n                        piStack1048 = piVar7;\n                    }\n                    goto code_r0x00414693;\n                }\n                if (uVar4 != 0x6e) {\n                    if (uVar4 == 0x6f) {\n                        iStack1044 = 8;\n                        if ((uStack1036 & 0x80) != 0) {\n                            uStack1036 = uStack1036 | 0x200;\n                        }\n                        goto code_r0x0041437c;\n                    }\n                    if (uVar4 == 0x70) {\n                        piStack1040 = 0x8;\n                        goto code_r0x00414539;\n                    }\n                    if (uVar4 == 0x73) {\ncode_r0x00414278:\n                        piVar7 = piStack1040;\n                        if (piStack1040 == 0xffffffff) {\n                            piVar7 = 0x7fffffff;\n                        }\n                        param_3 = ppiVar2 + 1;\n                        piStack1048 = *ppiVar2;\n                        if ((uStack1036 & 0x20) == 0) {\n                            if (piStack1048 == NULL) {\n                                piStack1048 = *0x496d54;\n                            }\n                            iStack1064 = 1;\n                            for (piVar5 = piStack1048; (piVar7 != NULL && (piVar7 = piVar7 + -1,  *piVar5 != 0));\n                                piVar5 = piVar5 + 2) {\n                            }\n                            iStack1044 = piVar5 - piStack1048 >> 1;\n                        }\n                        else {\n                            if (piStack1048 == NULL) {\n                                piStack1048 = *0x496d50;\n                            }\n                            iStack1044 = 0;\n                            piVar5 = piStack1048;\n                            if (0 < piVar7) {\n                                do {\n                                    if (*piVar5 == 0) break;\n                                    if ((*(*0x49731c + 1 + *piVar5 * 2) & 0x80) != 0) {\n                                        piVar5 = piVar5 + 1;\n                                    }\n                                    piVar5 = piVar5 + 1;\n                                    iStack1044 = iStack1044 + 1;\n                                } while (iStack1044 < piVar7);\n                            }\n                        }\n                        goto code_r0x00414693;\n                    }\n                    if (uVar4 != 0x75) {\n                        if (uVar4 != 0x78) goto code_r0x00414693;\n                        iStack1088 = 0x27;\n                        goto code_r0x0041453c;\n                    }\n                    goto code_r0x00414375;\n                }\n                param_3 = ppiVar2 + 1;\n                if ((uStack1036 & 0x20) == 0) {\n                    **ppiVar2 = iStack1052;\n                }\n                else {\n                    **ppiVar2 = iStack1052;\n                }\n                iStack1080 = 1;\n            }\n            if (piStack1076 != NULL) {\n                fcn.0040d958(piStack1076);\n                piStack1076 = NULL;\n            }\n        }\n        uVar8 = *param_2;\n        arg_ch = arg_ch & 0xffff0000 | uVar8;\n        iVar6 = iStack1092;\n        puVar1 = param_2;\n        ppiVar2 = param_3;\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 4840
    },
    "0041497b": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/77a25ea9f6f245cfb8807f7953974472",
            "validate payment card number using luhn algorithm with no lookup table/101d11b5106849ad963488c88a9294b9"
        ],
        "decompiled_code": "\n// WARNING: Type propagation algorithm not settling\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0041497b(uint param_1, uint8_t *param_2, int32_t **param_3)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    int32_t **ppiVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    int32_t *piVar8;\n    int32_t extraout_ECX;\n    int32_t iVar9;\n    uint8_t uVar10;\n    char *arg_ch;\n    bool bVar11;\n    int64_t iVar12;\n    int32_t *piStack600;\n    int32_t *piStack596;\n    int32_t iStack588;\n    int32_t iStack584;\n    uint uStack580;\n    int32_t iStack576;\n    int32_t iStack572;\n    int32_t *piStack568;\n    int32_t iStack564;\n    int32_t *piStack560;\n    int32_t iStack556;\n    uchar uStack552;\n    char cStack551;\n    int32_t iStack548;\n    int32_t iStack544;\n    int32_t *piStack540;\n    int32_t *piStack536;\n    uint32_t uStack532;\n    int32_t aiStack528 [127];\n    uint uStack17;\n    uint uStack8;\n    \n    uStack8 = *0x496830;\n    iStack544 = 0;\n    iStack548 = 0;\n    piStack568 = NULL;\n    uVar10 = *param_2;\n    iVar7 = 0;\n    puVar2 = param_2;\n    ppiVar3 = param_3;\n    do {\n        if ((uVar10 == 0) || (param_2 = puVar2 + 1,  iStack548 < 0)) {\n            fcn.0040e60a();\n            return;\n        }\n        if ((uVar10 < ' ') || ('x' < uVar10)) {\n            uVar5 = 0;\n        }\n        else {\n            uVar5 = *(uVar10 + 0x4739d8) & 0xf;\n        }\n        iStack584 = *(iVar7 + 0x4739f8 + uVar5 * 8) >> 4;\n        param_3 = ppiVar3;\n    // switch table (8 cases) at 0x415155\n        switch(iStack584) {\n        case 0:\ncode_r0x00414b97:\n            iStack564 = 0;\n            if ((*(*0x49731c + 1 + uVar10 * 2) & 0x80) != 0) {\n                fcn.004148ce();\n                param_2 = puVar2 + 2;\n            }\n            fcn.004148ce();\n            break;\n        case 1:\n            piStack536 = 0xffffffff;\n            uStack580 = 0;\n            iStack572 = 0;\n            piStack560 = NULL;\n            iStack556 = 0;\n            uStack532 = 0;\n            iStack564 = 0;\n            break;\n        case 2:\n            if (uVar10 == 0x20) {\n                uStack532 = uStack532 | 2;\n            }\n            else if (uVar10 == 0x23) {\n                uStack532 = uStack532 | 0x80;\n            }\n            else if (uVar10 == 0x2b) {\n                uStack532 = uStack532 | 1;\n            }\n            else if (uVar10 == 0x2d) {\n                uStack532 = uStack532 | 4;\n            }\n            else if (uVar10 == 0x30) {\n                uStack532 = uStack532 | 8;\n            }\n            break;\n        case 3:\n            if (uVar10 == 0x2a) {\n                piStack560 = *ppiVar3;\n                param_3 = ppiVar3 + 1;\n                if (piStack560 < 0) {\n                    uStack532 = uStack532 | 4;\n                    piStack560 = -piStack560;\n                }\n            }\n            else {\n                piStack560 = uVar10 + -0x30 + piStack560 * 10;\n            }\n            break;\n        case 4:\n            piStack536 = NULL;\n            break;\n        case 5:\n            if (uVar10 == 0x2a) {\n                piStack536 = *ppiVar3;\n                param_3 = ppiVar3 + 1;\n                if (piStack536 < 0) {\n                    piStack536 = 0xffffffff;\n                }\n            }\n            else {\n                piStack536 = uVar10 + -0x30 + piStack536 * 10;\n            }\n            break;\n        case 6:\n            if (uVar10 == 0x49) {\n                uVar1 = *param_2;\n                if ((uVar1 == 0x36) && (puVar2[2] == 0x34)) {\n                    param_2 = puVar2 + 3;\n                    uStack532 = uStack532 | 0x8000;\n                }\n                else if ((uVar1 == 0x33) && (puVar2[2] == 0x32)) {\n                    param_2 = puVar2 + 3;\n                    uStack532 = uStack532 & 0xffff7fff;\n                }\n                else if (((((uVar1 != 100) && (uVar1 != 0x69)) && (uVar1 != 0x6f)) &&\n                         ((uVar1 != 0x75 && (uVar1 != 0x78)))) && (uVar1 != 0x58)) {\n                    iStack584 = 0;\n                    goto code_r0x00414b97;\n                }\n            }\n            else if (uVar10 == 0x68) {\n                uStack532 = uStack532 | 0x20;\n            }\n            else if (uVar10 == 0x6c) {\n                uStack532 = uStack532 | 0x10;\n            }\n            else if (uVar10 == 0x77) {\n                uStack532 = uStack532 | 0x800;\n            }\n            break;\n        case 7:\n            if (uVar10 < 'h') {\n                if (uVar10 < 'e') {\n                    if (uVar10 < 'Y') {\n                        if (uVar10 != 0x58) {\n                            if (uVar10 == 0x43) {\n                                if ((uStack532 & 0x830) == 0) {\n                                    uStack532 = uStack532 | 0x800;\n                                }\n                                goto code_r0x00414ca0;\n                            }\n                            if ((uVar10 != 0x45) && (uVar10 != 0x47)) {\n                                if (uVar10 == 0x53) {\n                                    if ((uStack532 & 0x830) == 0) {\n                                        uStack532 = uStack532 | 0x800;\n                                    }\n                                    goto code_r0x00414c23;\n                                }\n                                goto code_r0x00415018;\n                            }\n                            uStack580 = 1;\n                            uVar10 = uVar10 + 0x20;\n                            goto code_r0x00414c74;\n                        }\ncode_r0x00414ebe:\n                        iStack576 = 7;\ncode_r0x00414ec1:\n                        iStack544 = 0x10;\n                        if ((uStack532 & 0x80) != 0) {\n                            cStack551 = iStack576 + 'Q';\n                            uStack552 = 0x30;\n                            iStack556 = 2;\n                        }\n                        goto code_r0x00414cf1;\n                    }\n                    if (uVar10 == 0x5a) {\n                        param_3 = ppiVar3 + 1;\n                        piVar8 = *ppiVar3;\n                        piVar6 = *0x496d50;\n                        piVar4 = *0x496d50;\n                        if ((piVar8 == NULL) || (piStack540 = piVar8[1],  piVar4 = *0x496d50,  piStack540 == NULL))\n                        goto code_r0x00414e32;\n                        iStack544 = *piVar8;\n                        if ((uStack532 & 0x800) == 0) {\n                            iStack564 = 0;\n                        }\n                        else {\n                            iStack544 = iStack544 / 2;\n                            iStack564 = 1;\n                        }\n                    }\n                    else if (uVar10 == 99) {\ncode_r0x00414ca0:\n                        if ((uStack532 & 0x810) == 0) {\n                            aiStack528[0]._0_1_ = *ppiVar3;\n                            iStack544 = 1;\n                        }\n                        else {\n                            iStack544 = fcn.00419065(aiStack528, *ppiVar3);\n                            if (iStack544 < 0) {\n                                iStack572 = 1;\n                            }\n                        }\n                        param_3 = ppiVar3 + 1;\n                        piStack540 = aiStack528;\n                    }\n                    else if (uVar10 == 100) goto code_r0x00414ce6;\n                }\n                else {\ncode_r0x00414c74:\n                    uStack532 = uStack532 | 0x40;\n                    piVar8 = aiStack528;\n                    piVar6 = aiStack528;\n                    if (piStack536 < 0) {\n                        piStack536 = 0x6;\n                    }\n                    else if (piStack536 == NULL) {\n                        if (uVar10 == 0x67) {\n                            piStack536 = 0x1;\n                        }\n                    }\n                    else {\n                        if (0x200 < piStack536) {\n                            piStack536 = 0x200;\n                        }\n                        if ((0xa3 < piStack536) &&\n                           (piStack540 = aiStack528,  piStack568 = fcn.0040d946(piStack536 + 0x15d), \n                           piVar8 = piStack568,  piVar6 = piStack568,  piStack568 == NULL)) {\n                            piStack536 = 0xa3;\n                            piVar8 = aiStack528;\n                            piVar6 = piStack540;\n                        }\n                    }\n                    piStack540 = piVar6;\n                    piStack600 = *ppiVar3;\n                    param_3 = ppiVar3 + 2;\n                    piStack596 = ppiVar3[1];\n                    (**0x497070)(&piStack600, piVar8, uVar10, piStack536, uStack580);\n                    uVar5 = uStack532 & 0x80;\n                    if ((uVar5 != 0) && (piStack536 == NULL)) {\n                        (**0x49707c)(piVar8);\n                    }\n                    if ((uVar10 == 0x67) && (uVar5 == 0)) {\n                        (**0x497074)(piVar8);\n                    }\n                    piVar6 = piVar8;\n                    piVar4 = piStack540;\n                    if (*piVar8 == '-') {\n                        uStack532 = uStack532 | 0x100;\n                        piVar6 = piVar8 + 1;\n                        piVar4 = piVar8 + 1;\n                    }\ncode_r0x00414e32:\n                    piStack540 = piVar4;\n                    iStack544 = fcn.0040e9c0(piVar6);\n                }\ncode_r0x00415018:\n                uVar5 = uStack532;\n                if (iStack572 == 0) {\n                    if ((uStack532 & 0x40) != 0) {\n                        if ((uStack532 & 0x100) == 0) {\n                            if ((uStack532 & 1) == 0) {\n                                if ((uStack532 & 2) == 0) goto code_r0x00415050;\n                                uStack552 = 0x20;\n                            }\n                            else {\n                                uStack552 = 0x2b;\n                            }\n                        }\n                        else {\n                            uStack552 = 0x2d;\n                        }\n                        iStack556 = 1;\n                    }\ncode_r0x00415050:\n                    arg_ch = piStack560 + (-iStack544 - iStack556);\n                    if ((uStack532 & 0xc) == 0) {\n                        fcn.00414901(0x20, arg_ch, param_1);\n                    }\n                    fcn.00414925(iStack556);\n                    if (((uVar5 & 8) != 0) && ((uVar5 & 4) == 0)) {\n                        fcn.00414901(0x30, arg_ch, param_1);\n                    }\n                    if ((iStack564 == 0) || (iStack544 < 1)) {\n                        fcn.00414925(iStack544);\n                    }\n                    else {\n                        iStack588 = iStack544;\n                        piVar8 = piStack540;\n                        do {\n                            iStack588 = iStack588 + -1;\n                            iVar7 = fcn.00419065(&uStack17 + 1, *piVar8);\n                            piVar8 = piVar8 + 2;\n                            if (iVar7 < 1) break;\n                            fcn.00414925(iVar7);\n                        } while (iStack588 != 0);\n                    }\n                    if ((uStack532 & 4) != 0) {\n                        fcn.00414901(0x20, arg_ch, param_1);\n                    }\n                }\n            }\n            else {\n                if (uVar10 == 0x69) {\ncode_r0x00414ce6:\n                    uStack532 = uStack532 | 0x40;\ncode_r0x00414cea:\n                    iStack544 = 10;\ncode_r0x00414cf1:\n                    if ((uStack532 & 0x8000) == 0) {\n                        param_3 = ppiVar3 + 1;\n                        if ((uStack532 & 0x20) == 0) {\n                            piVar8 = *ppiVar3;\n                            if ((uStack532 & 0x40) == 0) {\n                                piVar6 = NULL;\n                                goto code_r0x00414f62;\n                            }\n                        }\n                        else if ((uStack532 & 0x40) == 0) {\n                            piVar8 = *ppiVar3;\n                        }\n                        else {\n                            piVar8 = *ppiVar3;\n                        }\n                        piVar6 = piVar8 >> 0x1f;\n                    }\n                    else {\n                        piVar8 = *ppiVar3;\n                        piVar6 = ppiVar3[1];\n                        param_3 = ppiVar3 + 2;\n                    }\ncode_r0x00414f62:\n                    if ((((uStack532 & 0x40) != 0) && (piVar6 < 1)) && (piVar6 < 0)) {\n                        bVar11 = piVar8 != NULL;\n                        piVar8 = -piVar8;\n                        piVar6 = -(piVar6 + bVar11);\n                        uStack532 = uStack532 | 0x100;\n                    }\n                    if ((uStack532 & 0x8000) == 0) {\n                        piVar6 = NULL;\n                    }\n                    iVar12 = CONCAT44(piVar6, piVar8);\n                    if (piStack536 < 0) {\n                        piStack536 = 0x1;\n                    }\n                    else {\n                        uStack532 = uStack532 & 0xfffffff7;\n                        if (0x200 < piStack536) {\n                            piStack536 = 0x200;\n                        }\n                    }\n                    if ((piVar8 | piVar6) == 0) {\n                        iStack556 = 0;\n                    }\n                    piVar8 = &uStack17;\n                    while( true ) {\n                        iVar7 = iVar12;\n                        piVar6 = piStack536 + -1;\n                        if ((piStack536 < 1) && (iVar12 == 0)) break;\n                        piStack536 = piVar6;\n                        iVar12 = fcn.00418f70();\n                        iVar9 = extraout_ECX + 0x30;\n                        if (0x39 < iVar9) {\n                            iVar9 = iVar9 + iStack576;\n                        }\n                        *piVar8 = iVar9;\n                        piVar8 = piVar8 + -1;\n                        iStack588 = iVar7;\n                    }\n                    iStack544 = &uStack17 + -piVar8;\n                    piStack540 = piVar8 + 1;\n                    piStack536 = piVar6;\n                    if (((uStack532 & 0x200) != 0) && ((*piStack540 != '0' || (iStack544 == 0)))) {\n                        *piVar8 = '0';\n                        iStack544 = &uStack17 + -piVar8 + 1;\n                        piStack540 = piVar8;\n                    }\n                    goto code_r0x00415018;\n                }\n                if (uVar10 != 0x6e) {\n                    if (uVar10 == 0x6f) {\n                        iStack544 = 8;\n                        if ((uStack532 & 0x80) != 0) {\n                            uStack532 = uStack532 | 0x200;\n                        }\n                        goto code_r0x00414cf1;\n                    }\n                    if (uVar10 == 0x70) {\n                        piStack536 = 0x8;\n                        goto code_r0x00414ebe;\n                    }\n                    if (uVar10 == 0x73) {\ncode_r0x00414c23:\n                        piVar8 = piStack536;\n                        if (piStack536 == 0xffffffff) {\n                            piVar8 = 0x7fffffff;\n                        }\n                        param_3 = ppiVar3 + 1;\n                        piStack540 = *ppiVar3;\n                        if ((uStack532 & 0x810) == 0) {\n                            piVar6 = piStack540;\n                            if (piStack540 == NULL) {\n                                piVar6 = *0x496d50;\n                                piStack540 = *0x496d50;\n                            }\n                            for (; (piVar8 != NULL && (piVar8 = piVar8 + -1,  *piVar6 != '\\0')); piVar6 = piVar6 + 1) {\n                            }\n                            iStack544 = piVar6 - piStack540;\n                        }\n                        else {\n                            if (piStack540 == NULL) {\n                                piStack540 = *0x496d54;\n                            }\n                            iStack564 = 1;\n                            for (piVar6 = piStack540; (piVar8 != NULL && (piVar8 = piVar8 + -1,  *piVar6 != 0));\n                                piVar6 = piVar6 + 2) {\n                            }\n                            iStack544 = piVar6 - piStack540 >> 1;\n                        }\n                        goto code_r0x00415018;\n                    }\n                    if (uVar10 != 0x75) {\n                        if (uVar10 != 0x78) goto code_r0x00415018;\n                        iStack576 = 0x27;\n                        goto code_r0x00414ec1;\n                    }\n                    goto code_r0x00414cea;\n                }\n                param_3 = ppiVar3 + 1;\n                if ((uStack532 & 0x20) == 0) {\n                    **ppiVar3 = iStack548;\n                }\n                else {\n                    **ppiVar3 = iStack548;\n                }\n                iStack572 = 1;\n            }\n            if (piStack568 != NULL) {\n                fcn.0040d958(piStack568);\n                piStack568 = NULL;\n            }\n        }\n        uVar10 = *param_2;\n        iVar7 = iStack584;\n        puVar2 = param_2;\n        ppiVar3 = param_3;\n    } while( true );\n}\n",
        "token_count": 4443
    },
    "004151cd": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/77a25ea9f6f245cfb8807f7953974472",
            "validate payment card number using luhn algorithm with no lookup table/101d11b5106849ad963488c88a9294b9"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl fcn.004151cd(uint arg_8h_2, uint arg_ch_2, uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    uint32_t *puVar2;\n    uint8_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uchar uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint uVar9;\n    uint uVar10;\n    uint32_t uVar11;\n    uint8_t uVar12;\n    uint8_t uVar13;\n    uint32_t uVar14;\n    uint *puVar15;\n    int32_t unaff_EBP;\n    uint8_t *puVar16;\n    uint8_t *puVar17;\n    char *pcVar18;\n    char *pcVar19;\n    uint *puVar20;\n    uint8_t *puVar21;\n    ulong uVar22;\n    uint var_4h;\n    uint var_1e8h;\n    uint var_1dch;\n    uint var_1d8h;\n    uint var_1d4h;\n    uint var_1d0h;\n    uint var_1cch;\n    uint var_1c8h;\n    uint var_1c4h;\n    uint var_1c0h;\n    uint var_1bch;\n    uint var_1b8h;\n    uint var_1b4h;\n    uint var_1b0h;\n    uint var_1ach;\n    uint var_1a8h;\n    uint var_1a0h;\n    uint var_19ch;\n    uint var_194h;\n    uint var_18ch;\n    uint var_184h;\n    uint var_17dh;\n    uint var_1ch;\n    uint var_18h;\n    uint var_4h_2;\n    uint uStack4;\n    \n    uStack4 = 0x1cc;\n    var_4h_2 = 0x473a70;\n    fcn.0040daac();\n    *(unaff_EBP + -0x1c) = *0x496830;\n    *(unaff_EBP + -0x1bc) = 0;\n    *(unaff_EBP + -0x1d8) = 0;\n    *(unaff_EBP + -0x1b0) = 0;\n    *(unaff_EBP + -0x194) = 0;\n    *(unaff_EBP + -0x195) = 0;\n    *(unaff_EBP + -0x184) = 0;\n    *(unaff_EBP + -0x1b8) = 0;\ncode_r0x00415210:\n    if (**(unaff_EBP + 0xc) == '\\0') {\ncode_r0x00415f02:\n        if (*(unaff_EBP + -0x1d8) == 1) {\n            fcn.0040d958(*(unaff_EBP + -0x1bc));\n        }\n        *(unaff_EBP + -0x1ec) = 0x415f43;\n        fcn.0040e60a();\n        *(unaff_EBP + -0x1ec) = 0x415f48;\n        fcn.0040dae7();\n        return;\n    }\n    iVar7 = fcn.004181f8(**(unaff_EBP + 0xc));\n    if (iVar7 != 0) {\n        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n        do {\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            iVar7 = fcn.0041518d();\n            iVar8 = fcn.004181f8(iVar7);\n        } while (iVar8 != 0);\n        if (iVar7 != -1) {\n            fcn.0041916d(iVar7, *(unaff_EBP + 8));\n        }\n        do {\n            *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc) + 1;\n            iVar7 = fcn.004181f8(**(unaff_EBP + 0xc));\n        } while (iVar7 != 0);\n        goto code_r0x00415210;\n    }\n    puVar21 = *(unaff_EBP + 0xc);\n    if (*puVar21 != 0x25) {\n        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n        uVar14 = fcn.0041518d();\n        *(unaff_EBP + -0x194) = uVar14;\n        uVar13 = *puVar21;\n        *(unaff_EBP + 0xc) = puVar21 + 1;\n        if (uVar13 != uVar14) goto code_r0x00415ec9;\n        if ((*(*0x49731c + 1 + (uVar14 & 0xff) * 2) & 0x80) != 0) {\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            uVar11 = fcn.0041518d();\n            uVar13 = puVar21[1];\n            *(unaff_EBP + 0xc) = puVar21 + 2;\n            if (uVar13 != uVar11) {\n                if (uVar11 != 0xffffffff) {\n                    fcn.0041916d(uVar11, *(unaff_EBP + 8));\n                }\n                goto code_r0x00415ec9;\n            }\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n        }\n        goto code_r0x00415ee3;\n    }\n    iVar7 = 0;\n    *(unaff_EBP + -0x1a0) = 0;\n    *(unaff_EBP + -0x198) = 0;\n    *(unaff_EBP + -0x19c) = 0;\n    *(unaff_EBP + -0x1b4) = 0;\n    *(unaff_EBP + -0x18c) = 0;\n    *(unaff_EBP + -0x1a1) = 0;\n    *(unaff_EBP + -0x197) = 0;\n    *(unaff_EBP + -0x18e) = 0;\n    *(unaff_EBP + -0x17d) = 0;\n    *(unaff_EBP + -0x196) = 0;\n    *(unaff_EBP + -0x185) = 0;\n    *(unaff_EBP + -0x18d) = 1;\n    *(unaff_EBP + -0x1c8) = 0;\n    do {\n        puVar16 = puVar21 + 1;\n        uVar14 = *puVar16;\n        iVar8 = fcn.0041817f(uVar14);\n        puVar17 = puVar16;\n        if (iVar8 == 0) {\n            if (uVar14 < 0x4f) {\n                if (uVar14 != 0x4e) {\n                    if (uVar14 == 0x2a) {\n                        *(unaff_EBP + -0x18e) = *(unaff_EBP + -0x18e) + '\\x01';\n                    }\n                    else if (uVar14 != 0x46) {\n                        if (uVar14 == 0x49) {\n                            uVar13 = puVar21[2];\n                            if ((uVar13 == 0x36) && (puVar21[3] == 0x34)) {\n                                *(unaff_EBP + -0x1c8) = *(unaff_EBP + -0x1c8) + 1;\n                                *(unaff_EBP + -0x1ac) = 0;\n                                *(unaff_EBP + -0x1a8) = 0;\n                                puVar17 = puVar21 + 3;\n                            }\n                            else if (((uVar13 != 0x33) || (puVar17 = puVar21 + 3,  *puVar17 != 0x32)) &&\n                                    ((((puVar17 = puVar16,  uVar13 != 100 && (uVar13 != 0x69)) && (uVar13 != 0x6f)) &&\n                                     ((uVar13 != 0x78 && (uVar13 != 0x58)))))) goto code_r0x00415397;\n                        }\n                        else if (uVar14 == 0x4c) {\n                            *(unaff_EBP + -0x18d) = *(unaff_EBP + -0x18d) + '\\x01';\n                        }\n                        else {\ncode_r0x00415397:\n                            *(unaff_EBP + -0x17d) = *(unaff_EBP + -0x17d) + '\\x01';\n                            puVar17 = puVar16;\n                        }\n                    }\n                }\n            }\n            else if (uVar14 == 0x68) {\n                *(unaff_EBP + -0x18d) = *(unaff_EBP + -0x18d) + -1;\n                *(unaff_EBP + -0x185) = *(unaff_EBP + -0x185) + -1;\n            }\n            else {\n                if (uVar14 == 0x6c) {\n                    *(unaff_EBP + -0x18d) = *(unaff_EBP + -0x18d) + '\\x01';\n                }\n                else if (uVar14 != 0x77) goto code_r0x00415397;\n                *(unaff_EBP + -0x185) = *(unaff_EBP + -0x185) + '\\x01';\n            }\n        }\n        else {\n            *(unaff_EBP + -0x1b4) = *(unaff_EBP + -0x1b4) + 1;\n            iVar7 = (uVar14 - 0x30) + iVar7 * 10;\n        }\n        puVar21 = puVar17;\n    } while (*(unaff_EBP + -0x17d) == '\\0');\n    *(unaff_EBP + -0x18c) = iVar7;\n    *(unaff_EBP + 0xc) = puVar17;\n    if (*(unaff_EBP + -0x18e) == '\\0') {\n        puVar15 = *(unaff_EBP + 0x10);\n        *(unaff_EBP + -0x1dc) = puVar15;\n        *(unaff_EBP + 0x10) = puVar15 + 1;\n        puVar15 = *puVar15;\n        *(unaff_EBP + -0x1b0) = puVar15;\n    }\n    else {\n        puVar15 = *(unaff_EBP + -0x1b0);\n    }\n    *(unaff_EBP + -0x17d) = 0;\n    if ((*(unaff_EBP + -0x185) == '\\0') &&\n       ((uVar13 = *puVar17,  uVar13 == 0x53 || (*(unaff_EBP + -0x185) = 0xff,  uVar13 == 0x43)))) {\n        *(unaff_EBP + -0x185) = 1;\n    }\n    uVar14 = *puVar17 | 0x20;\n    *(unaff_EBP + -0x1c0) = uVar14;\n    if (uVar14 == 0x6e) {\ncode_r0x00415464:\n        uVar9 = *(unaff_EBP + 8);\n    }\n    else {\n        if ((uVar14 != 99) && (uVar14 != 0x7b)) {\n            do {\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                uVar9 = fcn.0041518d();\n                iVar7 = fcn.004181f8(uVar9);\n            } while (iVar7 != 0);\n            *(unaff_EBP + -0x194) = uVar9;\n            goto code_r0x00415464;\n        }\n        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n        uVar9 = *(unaff_EBP + 8);\n        uVar10 = fcn.0041518d();\n        *(unaff_EBP + -0x194) = uVar10;\n    }\n    iVar7 = *(unaff_EBP + -0x1b4);\n    if ((iVar7 != 0) && (*(unaff_EBP + -0x18c) == 0)) {\ncode_r0x00415774:\n        uVar14 = *(unaff_EBP + -0x194);\ncode_r0x00415ec9:\n        if (uVar14 != 0xffffffff) {\n            fcn.0041916d(*(unaff_EBP + -0x194), *(unaff_EBP + 8));\n        }\n        goto code_r0x00415f02;\n    }\n    if (0x6f < uVar14) {\n        if (uVar14 == 0x70) {\n            *(unaff_EBP + -0x18d) = 1;\ncode_r0x00415b61:\n            uVar11 = *(unaff_EBP + -0x194);\n            if (uVar11 == 0x2d) {\n                *(unaff_EBP + -0x197) = 1;\n            }\n            else if (uVar11 != 0x2b) goto code_r0x00415ba4;\n            piVar1 = unaff_EBP + -0x18c;\n            *piVar1 = *piVar1 + -1;\n            if ((*piVar1 == 0) && (iVar7 != 0)) {\n                *(unaff_EBP + -0x17d) = 1;\n            }\n            else {\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                uVar11 = fcn.0041518d();\ncode_r0x00415b9e:\n                *(unaff_EBP + -0x194) = uVar11;\n            }\n        }\n        else {\n            if (uVar14 == 0x73) {\ncode_r0x00415727:\n                if ('\\0' < *(unaff_EBP + -0x185)) {\n                    *(unaff_EBP + -0x196) = 1;\n                }\ncode_r0x004158f1:\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n                puVar20 = puVar15;\n                if (*(unaff_EBP + -0x194) != -1) {\n                    fcn.0041916d(*(unaff_EBP + -0x194), *(unaff_EBP + 8));\n                }\n                do {\n                    if ((*(unaff_EBP + -0x1b4) != 0) &&\n                       (iVar7 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar7 == 0)\n                       ) goto code_r0x00415b12;\n                    *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                    uVar11 = fcn.0041518d();\n                    *(unaff_EBP + -0x194) = uVar11;\n                    if (uVar11 == 0xffffffff) goto code_r0x00415afc;\n                    uVar13 = uVar11;\n                    if ((uVar14 != 99) && (((uVar14 != 0x73 || ((8 < uVar11 && (uVar11 < 0xe)))) || (uVar11 == 0x20))))\n                    {\n                        if ((uVar14 != 0x7b) ||\n                           (((*((uVar11 >> 3) + *(unaff_EBP + -0x1bc)) ^ *(unaff_EBP + -0x1a1)) & 1 << (uVar13 & 7)) ==\n                            0)) goto code_r0x00415afc;\n                        uVar14 = *(unaff_EBP + -0x1c0);\n                    }\n                    if (*(unaff_EBP + -0x18e) == '\\0') {\n                        if (*(unaff_EBP + -0x196) == '\\0') {\n                            *puVar15 = uVar13;\n                            puVar15 = puVar15 + 1;\n                        }\n                        else {\n                            *(unaff_EBP + -0x1c4) = uVar13;\n                            if ((*(*0x49731c + 1 + (uVar11 & 0xff) * 2) & 0x80) != 0) {\n                                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                                uVar6 = fcn.0041518d();\n                                *(unaff_EBP + -0x1c3) = uVar6;\n                            }\n                            fcn.00418f34(unaff_EBP + -0x1cc, unaff_EBP + -0x1c4, *0x497310);\n                            *puVar15 = *(unaff_EBP + -0x1cc);\n                            puVar15 = puVar15 + 2;\n                        }\n                        *(unaff_EBP + -0x1b0) = puVar15;\n                    }\n                    else {\n                        puVar20 = puVar20 + 1;\n                    }\n                } while( true );\n            }\n            if (uVar14 == 0x75) goto code_r0x00415b61;\n            if (uVar14 != 0x78) {\n                if (uVar14 == 0x7b) {\n                    if ('\\0' < *(unaff_EBP + -0x185)) {\n                        *(unaff_EBP + -0x196) = 1;\n                    }\n                    iVar7 = *(unaff_EBP + 0xc);\n                    puVar21 = iVar7 + 1;\n                    *(unaff_EBP + 0xc) = puVar21;\n                    *(unaff_EBP + -0x1d0) = puVar21;\n                    if (*puVar21 == 0x5e) {\n                        puVar21 = iVar7 + 2;\n                        *(unaff_EBP + -0x1d0) = puVar21;\n                        *(unaff_EBP + -0x1a1) = 0xff;\n                    }\n                    puVar15 = *(unaff_EBP + -0x1bc);\n                    if (*(unaff_EBP + -0x1bc) == NULL) {\n                        *(unaff_EBP + -4) = 0;\n                        fcn.0040dc10();\n                        *(unaff_EBP + -0x18) = &fcn.004151cd::var_4h_2;\n                        *(unaff_EBP + -0x1bc) = &fcn.004151cd::var_4h_2;\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        puVar15 = &fcn.004151cd::var_4h_2;\n                    }\n                    fcn.0040e620(puVar15, 0, 0x20);\n                    if (*(unaff_EBP + -0x1c0) != 0x7b) goto code_r0x004158c5;\n                    if (*puVar21 != 0x5d) goto code_r0x004158c5;\n                    uVar13 = 0x5d;\n                    puVar21 = puVar21 + 1;\n                    *(puVar15 + 0xb) = 0x20;\n                    while (uVar12 = *puVar21,  uVar12 != 0x5d) {\n                        if (((uVar12 == 0x2d) && (uVar13 != 0)) && (uVar3 = puVar21[1],  uVar3 != 0x5d)) {\n                            puVar21 = puVar21 + 2;\n                            uVar12 = uVar3;\n                            if (uVar13 < uVar3) {\n                                uVar12 = uVar13;\n                                uVar13 = uVar3;\n                            }\n                            if (uVar12 <= uVar13) {\n                                uVar14 = uVar12;\n                                *(unaff_EBP + -0x1d4) = (uVar13 - uVar12) + 1;\n                                do {\n                                    *(puVar15 + (uVar14 >> 3)) = *(puVar15 + (uVar14 >> 3)) | '\\x01' << (uVar14 & 7);\n                                    uVar14 = uVar14 + 1;\n                                    piVar1 = unaff_EBP + -0x1d4;\n                                    *piVar1 = *piVar1 + -1;\n                                } while (*piVar1 != 0);\n                            }\n                            uVar13 = 0;\n                        }\n                        else {\n                            *(unaff_EBP + -0x198) = uVar12;\n                            *(puVar15 + (uVar12 >> 3)) = *(puVar15 + (uVar12 >> 3)) | '\\x01' << (uVar12 & 7);\n                            puVar21 = puVar21 + 1;\ncode_r0x004158c5:\n                            uVar13 = *(unaff_EBP + -0x198);\n                        }\n                    }\n                    puVar15 = *(unaff_EBP + -0x1b0);\n                    if (*(unaff_EBP + -0x1c0) == 0x7b) {\n                        *(unaff_EBP + 0xc) = puVar21;\n                    }\n                    uVar14 = *(unaff_EBP + -0x1c0);\n                    goto code_r0x004158f1;\n                }\n                goto code_r0x00415766;\n            }\ncode_r0x004154ee:\n            uVar11 = *(unaff_EBP + -0x194);\n            if (uVar11 == 0x2d) {\n                *(unaff_EBP + -0x197) = 1;\ncode_r0x00415a14:\n                piVar1 = unaff_EBP + -0x18c;\n                *piVar1 = *piVar1 + -1;\n                if ((*piVar1 == 0) && (iVar7 != 0)) {\n                    *(unaff_EBP + -0x17d) = 1;\n                }\n                else {\n                    *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                    uVar11 = fcn.0041518d();\n                    *(unaff_EBP + -0x194) = uVar11;\n                }\n            }\n            else if (uVar11 == 0x2b) goto code_r0x00415a14;\n            if (uVar11 == 0x30) {\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                uVar11 = fcn.0041518d();\n                *(unaff_EBP + -0x194) = uVar11;\n                if ((uVar11 == 'x') || (uVar11 == 'X')) {\n                    *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                    uVar11 = fcn.0041518d();\n                    *(unaff_EBP + -0x194) = uVar11;\n                    if ((*(unaff_EBP + -0x1b4) != 0) &&\n                       (*(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -2,  *(unaff_EBP + -0x18c) < 1)) {\n                        *(unaff_EBP + -0x17d) = *(unaff_EBP + -0x17d) + '\\x01';\n                    }\n                    uVar14 = 0x78;\n                }\n                else {\n                    *(unaff_EBP + -0x19c) = 1;\n                    if (uVar14 == 0x78) {\n                        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n                        if (uVar11 != 0xffffffff) {\n                            fcn.0041916d(uVar11, uVar9);\n                        }\n                        uVar11 = 0x30;\n                        goto code_r0x00415b9e;\n                    }\n                    if (*(unaff_EBP + -0x1b4) != 0) {\n                        piVar1 = unaff_EBP + -0x18c;\n                        *piVar1 = *piVar1 + -1;\n                        if (*piVar1 == 0) {\n                            *(unaff_EBP + -0x17d) = *(unaff_EBP + -0x17d) + '\\x01';\n                        }\n                    }\n                    uVar14 = 0x6f;\n                }\n            }\n        }\ncode_r0x00415ba4:\n        if (*(unaff_EBP + -0x1c8) == 0) {\n            if (*(unaff_EBP + -0x17d) == '\\0') {\n                do {\n                    if ((uVar14 == 0x78) || (uVar14 == 0x70)) {\n                        iVar7 = fcn.004181b9(uVar11);\n                        if (iVar7 != 0) {\n                            *(unaff_EBP + -0x1a0) = *(unaff_EBP + -0x1a0) << 4;\n                            iVar7 = fcn.0041817f(uVar11);\n                            if (iVar7 == 0) {\n                                uVar11 = (uVar11 & 0xffffffdf) - 7;\n                            }\n                            goto code_r0x00415d81;\n                        }\ncode_r0x00415d7b:\n                        *(unaff_EBP + -0x17d) = *(unaff_EBP + -0x17d) + '\\x01';\n                    }\n                    else {\n                        iVar7 = fcn.0041817f(uVar11);\n                        if (iVar7 == 0) goto code_r0x00415d7b;\n                        if (uVar14 == 0x6f) {\n                            if (0x37 < uVar11) goto code_r0x00415d7b;\n                            *(unaff_EBP + -0x1a0) = *(unaff_EBP + -0x1a0) << 3;\n                        }\n                        else {\n                            *(unaff_EBP + -0x1a0) = *(unaff_EBP + -0x1a0) * 10;\n                        }\n                    }\ncode_r0x00415d81:\n                    if (*(unaff_EBP + -0x17d) == '\\0') {\n                        *(unaff_EBP + -0x19c) = *(unaff_EBP + -0x19c) + 1;\n                        *(unaff_EBP + -0x1a0) = *(unaff_EBP + -0x1a0) + -0x30 + uVar11;\n                        if (*(unaff_EBP + -0x1b4) != 0) {\n                            piVar1 = unaff_EBP + -0x18c;\n                            *piVar1 = *piVar1 + -1;\n                            if (*piVar1 == 0) {\n                                *(unaff_EBP + -0x17d) = 1;\n                                goto code_r0x00415ddf;\n                            }\n                        }\n                        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                        uVar11 = fcn.0041518d();\n                    }\n                    else {\n                        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n                        if (uVar11 != 0xffffffff) {\n                            fcn.0041916d(uVar11, uVar9);\n                        }\n                    }\ncode_r0x00415ddf:\n                } while (*(unaff_EBP + -0x17d) == '\\0');\n                *(unaff_EBP + -0x194) = uVar11;\n            }\n            if (*(unaff_EBP + -0x197) != '\\0') {\n                *(unaff_EBP + -0x1a0) = -*(unaff_EBP + -0x1a0);\n            }\n        }\n        else {\n            if (*(unaff_EBP + -0x17d) == '\\0') {\n                do {\n                    if ((uVar14 == 0x78) || (uVar14 == 0x70)) {\n                        iVar7 = fcn.004181b9(uVar11);\n                        if (iVar7 != 0) {\n                            uVar4 = *(unaff_EBP + -0x1ac);\n                            *(unaff_EBP + -0x1ac) = uVar4 << 4;\n                            *(unaff_EBP + -0x1a8) = *(unaff_EBP + -0x1a8) << 4 | uVar4 >> 0x1c;\n                            iVar7 = fcn.0041817f(uVar11);\n                            if (iVar7 == 0) {\n                                uVar11 = (uVar11 & 0xffffffdf) - 7;\n                            }\n                            goto code_r0x00415c6c;\n                        }\ncode_r0x00415c66:\n                        *(unaff_EBP + -0x17d) = *(unaff_EBP + -0x17d) + '\\x01';\n                    }\n                    else {\n                        iVar7 = fcn.0041817f(uVar11);\n                        if (iVar7 == 0) goto code_r0x00415c66;\n                        if (uVar14 == 0x6f) {\n                            if (0x37 < uVar11) goto code_r0x00415c66;\n                            uVar4 = *(unaff_EBP + -0x1ac);\n                            *(unaff_EBP + -0x1ac) = uVar4 << 3;\n                            *(unaff_EBP + -0x1a8) = *(unaff_EBP + -0x1a8) << 3 | uVar4 >> 0x1d;\n                        }\n                        else {\n                            var_4h_2 = *(unaff_EBP + -0x1ac);\n                            uVar22 = fcn.0040f9b0();\n                            *(unaff_EBP + -0x1ac) = uVar22;\n                            *(unaff_EBP + -0x1a8) = uVar22 >> 0x20;\n                        }\n                    }\ncode_r0x00415c6c:\n                    if (*(unaff_EBP + -0x17d) == '\\0') {\n                        *(unaff_EBP + -0x19c) = *(unaff_EBP + -0x19c) + 1;\n                        uVar4 = uVar11 - 0x30;\n                        puVar2 = unaff_EBP + -0x1ac;\n                        uVar5 = *puVar2;\n                        *puVar2 = *puVar2 + uVar4;\n                        *(unaff_EBP + -0x1a8) = *(unaff_EBP + -0x1a8) + (uVar4 >> 0x1f) + CARRY4(uVar5, uVar4);\n                        if (*(unaff_EBP + -0x1b4) != 0) {\n                            piVar1 = unaff_EBP + -0x18c;\n                            *piVar1 = *piVar1 + -1;\n                            if (*piVar1 == 0) {\n                                *(unaff_EBP + -0x17d) = 1;\n                                goto code_r0x00415cca;\n                            }\n                        }\n                        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                        uVar11 = fcn.0041518d();\n                    }\n                    else {\n                        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n                        if (uVar11 != 0xffffffff) {\n                            fcn.0041916d(uVar11, uVar9);\n                        }\n                    }\ncode_r0x00415cca:\n                } while (*(unaff_EBP + -0x17d) == '\\0');\n                *(unaff_EBP + -0x194) = uVar11;\n            }\n            if (*(unaff_EBP + -0x197) != '\\0') {\n                iVar7 = *(unaff_EBP + -0x1ac);\n                *(unaff_EBP + -0x1ac) = -iVar7;\n                *(unaff_EBP + -0x1a8) = -(*(unaff_EBP + -0x1a8) + (iVar7 != 0));\n            }\n        }\n        if (uVar14 == 0x46) {\n            *(unaff_EBP + -0x19c) = 0;\n        }\n        if (*(unaff_EBP + -0x19c) != 0) {\n            if (*(unaff_EBP + -0x18e) == '\\0') {\n                *(unaff_EBP + -0x1b8) = *(unaff_EBP + -0x1b8) + 1;\n                puVar15 = *(unaff_EBP + -0x1b0);\n                uVar9 = *(unaff_EBP + -0x1a0);\ncode_r0x00415e35:\n                if (*(unaff_EBP + -0x1c8) == 0) {\n                    if (*(unaff_EBP + -0x18d) == '\\0') {\n                        *puVar15 = uVar9;\n                    }\n                    else {\n                        *puVar15 = uVar9;\n                    }\n                }\n                else {\n                    *puVar15 = *(unaff_EBP + -0x1ac);\n                    puVar15[1] = *(unaff_EBP + -0x1a8);\n                }\n            }\n            goto code_r0x00415e61;\n        }\n        goto code_r0x00415f02;\n    }\n    if (uVar14 == 0x6f) goto code_r0x00415b61;\n    if (uVar14 == 99) {\n        if (iVar7 == 0) {\n            *(unaff_EBP + -0x1b4) = 1;\n            *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + 1;\n        }\n        goto code_r0x00415727;\n    }\n    if (uVar14 == 100) goto code_r0x00415b61;\n    if (uVar14 < 0x65) {\ncode_r0x00415766:\n        if (**(unaff_EBP + 0xc) != *(unaff_EBP + -0x194)) goto code_r0x00415774;\n        *(unaff_EBP + -0x195) = *(unaff_EBP + -0x195) + -1;\n        if (*(unaff_EBP + -0x18e) == '\\0') {\n            *(unaff_EBP + 0x10) = *(unaff_EBP + -0x1dc);\n        }\n    }\n    else {\n        if (0x67 < uVar14) {\n            if (uVar14 == 0x69) {\n                uVar14 = 100;\n                goto code_r0x004154ee;\n            }\n            if (uVar14 != 0x6e) goto code_r0x00415766;\n            uVar9 = *(unaff_EBP + -0x184);\n            if (*(unaff_EBP + -0x18e) != '\\0') goto code_r0x00415e61;\n            goto code_r0x00415e35;\n        }\n        pcVar18 = unaff_EBP + -0x17c;\n        iVar7 = *(unaff_EBP + -0x194);\n        if (iVar7 == 0x2d) {\n            *(unaff_EBP + -0x17c) = 0x2d;\n            pcVar18 = unaff_EBP + -0x17b;\ncode_r0x0041552d:\n            *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1;\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            uVar9 = *(unaff_EBP + 8);\n            iVar7 = fcn.0041518d();\n            *(unaff_EBP + -0x194) = iVar7;\n        }\n        else {\n            if (iVar7 == 0x2b) goto code_r0x0041552d;\n            uVar9 = *(unaff_EBP + 8);\n        }\n        if ((*(unaff_EBP + -0x1b4) == 0) || (0x15d < *(unaff_EBP + -0x18c))) {\n            *(unaff_EBP + -0x18c) = 0x15d;\n        }\n        while( true ) {\n            iVar8 = fcn.0041817f(iVar7);\n            if ((iVar8 == 0) ||\n               (iVar8 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar8 == 0)) break;\n            *(unaff_EBP + -0x19c) = *(unaff_EBP + -0x19c) + 1;\n            *pcVar18 = iVar7;\n            pcVar18 = pcVar18 + 1;\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            iVar7 = fcn.0041518d();\n            *(unaff_EBP + -0x194) = iVar7;\n        }\n        if ((*0x497314 == iVar7) &&\n           (iVar8 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar8 != 0)) {\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            iVar7 = fcn.0041518d();\n            *pcVar18 = *0x497314;\n            while( true ) {\n                pcVar18 = pcVar18 + 1;\n                *(unaff_EBP + -0x194) = iVar7;\n                iVar8 = fcn.0041817f(iVar7);\n                if ((iVar8 == 0) ||\n                   (iVar8 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar8 == 0))\n                break;\n                *(unaff_EBP + -0x19c) = *(unaff_EBP + -0x19c) + 1;\n                *pcVar18 = iVar7;\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                iVar7 = fcn.0041518d();\n            }\n        }\n        pcVar19 = pcVar18;\n        if ((*(unaff_EBP + -0x19c) != 0) &&\n           (((iVar7 == 0x65 || (iVar7 == 0x45)) &&\n            (iVar8 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar8 != 0)))) {\n            *pcVar18 = 'e';\n            pcVar19 = pcVar18 + 1;\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            iVar7 = fcn.0041518d();\n            *(unaff_EBP + -0x194) = iVar7;\n            if (iVar7 == 0x2d) {\n                *pcVar19 = '-';\n                pcVar19 = pcVar18 + 2;\ncode_r0x00415667:\n                iVar8 = *(unaff_EBP + -0x18c);\n                *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1;\n                if (iVar8 != 0) goto code_r0x00415698;\n                *(unaff_EBP + -0x18c) = 0;\n            }\n            else if (iVar7 == 0x2b) goto code_r0x00415667;\n            while ((iVar8 = fcn.0041817f(iVar7),  iVar8 != 0 &&\n                   (iVar8 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar8 != 0))) {\n                *(unaff_EBP + -0x19c) = *(unaff_EBP + -0x19c) + 1;\n                *pcVar19 = iVar7;\n                pcVar19 = pcVar19 + 1;\ncode_r0x00415698:\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                iVar7 = fcn.0041518d();\n                *(unaff_EBP + -0x194) = iVar7;\n            }\n        }\n        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n        if (iVar7 != -1) {\n            fcn.0041916d(iVar7, uVar9);\n        }\n        if (*(unaff_EBP + -0x19c) == 0) goto code_r0x00415f02;\n        if (*(unaff_EBP + -0x18e) == '\\0') {\n            *(unaff_EBP + -0x1b8) = *(unaff_EBP + -0x1b8) + 1;\n            *pcVar19 = '\\0';\n            (**0x497078)(*(unaff_EBP + -0x18d) + -1, *(unaff_EBP + -0x1b0), unaff_EBP + -0x17c);\n        }\n    }\ncode_r0x00415e61:\n    *(unaff_EBP + -0x195) = *(unaff_EBP + -0x195) + '\\x01';\n    *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc) + 1;\ncode_r0x00415ee3:\n    if ((*(unaff_EBP + -0x194) == -1) && ((**(unaff_EBP + 0xc) != '%' || ((*(unaff_EBP + 0xc))[1] != 'n'))))\n    goto code_r0x00415f02;\n    goto code_r0x00415210;\ncode_r0x00415afc:\n    *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n    if (uVar11 != 0xffffffff) {\n        fcn.0041916d(uVar11, *(unaff_EBP + 8));\n    }\ncode_r0x00415b12:\n    if (puVar20 == puVar15) goto code_r0x00415f02;\n    if ((*(unaff_EBP + -0x18e) == '\\0') &&\n       (*(unaff_EBP + -0x1b8) = *(unaff_EBP + -0x1b8) + 1,  *(unaff_EBP + -0x1c0) != 99)) {\n        if (*(unaff_EBP + -0x196) == '\\0') {\n            **(unaff_EBP + -0x1b0) = 0;\n        }\n        else {\n            **(unaff_EBP + -0x1b0) = 0;\n        }\n    }\n    goto code_r0x00415e61;\n}\n",
        "token_count": 10080
    },
    "0041d5e5": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/77a25ea9f6f245cfb8807f7953974472",
            "validate payment card number using luhn algorithm with no lookup table/101d11b5106849ad963488c88a9294b9"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0041d8bb)\n// WARNING: Removing unreachable block (ram,0x0041d835)\n// WARNING: Removing unreachable block (ram,0x0041d997)\n// WARNING: Removing unreachable block (ram,0x0041d847)\n// WARNING: Removing unreachable block (ram,0x0041d84f)\n// WARNING: Removing unreachable block (ram,0x0041d855)\n// WARNING: Removing unreachable block (ram,0x0041d858)\n// WARNING: Removing unreachable block (ram,0x0041d85f)\n// WARNING: Removing unreachable block (ram,0x0041d869)\n// WARNING: Removing unreachable block (ram,0x0041d933)\n// WARNING: Removing unreachable block (ram,0x0041d92d)\n// WARNING: Removing unreachable block (ram,0x0041d939)\n// WARNING: Removing unreachable block (ram,0x0041d956)\n// WARNING: Removing unreachable block (ram,0x0041d958)\n// WARNING: Removing unreachable block (ram,0x0041d960)\n// WARNING: Removing unreachable block (ram,0x0041d963)\n// WARNING: Removing unreachable block (ram,0x0041d968)\n// WARNING: Removing unreachable block (ram,0x0041d96b)\n// WARNING: Removing unreachable block (ram,0x0041d9a0)\n// WARNING: Removing unreachable block (ram,0x0041d972)\n// WARNING: Removing unreachable block (ram,0x0041d979)\n// WARNING: Removing unreachable block (ram,0x0041d9b7)\n// WARNING: Removing unreachable block (ram,0x0041d9be)\n// WARNING: Removing unreachable block (ram,0x0041d9c6)\n\nvoid __cdecl\nfcn.0041d5e5(uint arg_8h, uint arg_ch, char *arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    char cVar1;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_19h;\n    uint var_14h;\n    uint var_eh;\n    uint var_ah;\n    uint var_4h;\n    \n    for (; (((cVar1 = *arg_10h,  cVar1 == ' ' || (cVar1 == '\\t')) || (cVar1 == '\\n')) || (cVar1 == '\\r'));\n        arg_10h = arg_10h + 1) {\n    }\n    // WARNING: Could not recover jumptable at 0x0041d648. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (12 cases) at 0x41d9e9\n    (**0x41d9e9)();\n    return;\n}\n",
        "token_count": 706
    },
    "004010bd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid fcn.004010bd(void)\n\n{\n    code *pcVar1;\n    uint var_94h;\n    uint32_t var_90h;\n    int32_t var_84h;\n    \n    var_94h = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&var_94h);\n    if ((var_84h != 2) || (pcVar1 = 0x4010b9,  var_90h < 5)) {\n        pcVar1 = fcn.00401069;\n    }\n    (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x4860f8, pcVar1);\n    (**0x4860f8)();\n    return;\n}\n",
        "token_count": 161
    },
    "004015ab": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004015ab(int32_t **param_1)\n\n{\n    int32_t **arg_8h;\n    \n    while (*param_1 != NULL) {\n        arg_8h = *param_1;\n        *param_1 = *arg_8h;\n        fcn.0040d958(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 82
    },
    "0042afac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042afac(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDialog.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[7] != NULL) {\n        fcn.00427b34();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042823e();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 196
    },
    "00432482": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00432482(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.00432458();\n    uVar1 = (*_sym.imp.GDI32.dll_DeleteObject)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 86
    },
    "0040249b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040249b(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0xec) == 0) {\n        uVar1 = *(param_1 + 0xf0);\n    }\n    else {\n        uVar1 = *(param_1 + 0xf4);\n    }\n    *(param_1 + 0xe8) = uVar1;\n    fcn.00432482();\n    fcn.004023a9(0, *(param_1 + 0xe8), 0);\n    return;\n}\n",
        "token_count": 131
    },
    "00459cb1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00459cb1(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    fcn.0044f0b9();\n    var_4h = (**(*param_1 + 0xb4))();\n    while( true ) {\n        iVar1 = fcn.0044f0a8(&var_4h);\n        if (iVar1 == 0) break;\n        (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(iVar1 + 4);\n    }\n    var_4h = (**(*param_1 + 0xb4))();\n    while( true ) {\n        piVar2 = fcn.0044f0a8();\n        if (piVar2 == NULL) break;\n        if (piVar2[0xb] != 0) {\n            (**(*piVar2 + 4))(1);\n        }\n    }\n    var_4h = (**(*param_1 + 0xb4))();\n    while( true ) {\n        iVar1 = fcn.0044f0a8();\n        if (iVar1 == 0) break;\n        fcn.0044fd01();\n    }\n    return;\n}\n",
        "token_count": 288
    },
    "00402d48": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00402d48(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint lprc;\n    \n    if (*(param_1 + 0x10) == 0) {\n        (*_sym.imp.USER32.dll_SetRectEmpty)();\n    }\n    else {\n        if (*(param_1 + 0x10) < 1) {\n            fcn.0040ed8d(&stack0xffffffdc, 0x47c05c);\n            pcVar2 = swi(3);\n            (*pcVar2)();\n            return;\n        }\n        iVar7 = **(param_1 + 0xc);\n        iVar5 = (*(param_1 + 0xc))[1];\n        piVar1 = param_1 + 0x1c;\n        *piVar1 = iVar7;\n        *(param_1 + 0x20) = iVar5;\n        *(param_1 + 0x24) = iVar7;\n        *(param_1 + 0x28) = iVar5;\n        iVar7 = 1;\n        if (1 < *(param_1 + 0x10)) {\n            do {\n                piVar3 = fcn.00402649();\n                iVar5 = *piVar3;\n                iVar4 = piVar3[1];\n                iVar6 = *piVar1;\n                if (iVar5 <= *piVar1) {\n                    iVar6 = iVar5;\n                }\n                *piVar1 = iVar6;\n                if (iVar5 < *(param_1 + 0x24)) {\n                    iVar5 = *(param_1 + 0x24);\n                }\n                *(param_1 + 0x24) = iVar5;\n                iVar5 = *(param_1 + 0x20);\n                if (*(param_1 + 0x20) <= iVar4) {\n                    iVar5 = iVar4;\n                }\n                *(param_1 + 0x20) = iVar5;\n                if (*(param_1 + 0x28) < iVar4) {\n                    iVar4 = *(param_1 + 0x28);\n                }\n                iVar7 = iVar7 + 1;\n                *(param_1 + 0x28) = iVar4;\n            } while (iVar7 < *(param_1 + 0x10));\n        }\n        (*_sym.imp.USER32.dll_InflateRect)(piVar1, *(param_1 + 4), -*(param_1 + 4));\n    }\n    return;\n}\n",
        "token_count": 613
    },
    "004030c9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004030c9(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *arg_8h_00;\n    int32_t in_ECX;\n    uint var_10h;\n    uint var_8h;\n    \n    arg_8h_00 = arg_8h;\n    iVar1 = *(in_ECX + 0x1c);\n    (**(*arg_8h + 0x34))(8);\n    var_8h = *(iVar1 + 0x11c);\n    iVar2 = *(iVar1 + 0x120);\n    fcn.00431c1d(&var_10h, 0, 0);\n    (**(*arg_8h_00 + 0x48))(&var_10h, var_8h, -iVar2);\n    arg_8h = *(iVar1 + 0x104);\n    while (arg_8h != NULL) {\n        fcn.00402f40(&arg_8h);\n        fcn.00402c86(arg_8h_00);\n    }\n    return 1;\n}\n",
        "token_count": 256
    },
    "00403597": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00403597(int32_t *arg_8h)\n\n{\n    int32_t *arg_8h_00;\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_28h;\n    uint var_18h;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    arg_8h_00 = arg_8h;\n    iVar2 = *(in_ECX + 0x50);\n    (**(*arg_8h + 0x50))(&var_28h);\n    (*_sym.imp.GDI32.dll_LPtoDP)(arg_8h_00[2], &var_28h, 2);\n    (*_sym.imp.USER32.dll_InflateRect)(&var_28h, 1, 1);\n    var_4h = iVar2 + 0x100;\n    arg_8h = *(iVar2 + 0x104);\n    while (arg_8h != NULL) {\n        piVar1 = fcn.00402f40(&arg_8h);\n        var_8h = *piVar1;\n        var_18h = *(var_8h + 0x1c);\n        uStack24 = *(var_8h + 0x20);\n        uStack20 = *(var_8h + 0x24);\n        uStack16 = *(var_8h + 0x28);\n        (*_sym.imp.GDI32.dll_LPtoDP)(arg_8h_00[2], &var_18h, 2);\n        (*_sym.imp.USER32.dll_InflateRect)(&var_18h, 1, 1);\n        iVar2 = (*_sym.imp.USER32.dll_IntersectRect)(&var_18h, &var_18h, &var_28h);\n        if (iVar2 != 0) {\n            fcn.00402c86(arg_8h_00);\n        }\n    }\n    return;\n}\n",
        "token_count": 464
    },
    "00403667": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t ** fcn.00403667(int32_t **param_1)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    uint32_t uVar4;\n    int32_t **ppiVar5;\n    int32_t **ppiVar6;\n    \n    piVar2 = (**(**param_1 + 0x10))();\n    ppiVar3 = param_1 + 3;\n    if ((-1 < *ppiVar3) && (piVar2 == *param_1)) {\n        LOCK();\n        *ppiVar3 = *ppiVar3 + 1;\n        return param_1;\n    }\n    ppiVar3 = (***piVar2)(param_1[1], 1);\n    if (ppiVar3 == NULL) {\n        fcn.00401182(0x8007000e);\n        pcVar1 = swi(3);\n        ppiVar3 = (*pcVar1)();\n        return ppiVar3;\n    }\n    ppiVar3[1] = param_1[1];\n    piVar2 = param_1[1];\n    ppiVar5 = param_1 + 4;\n    ppiVar6 = ppiVar3 + 4;\n    for (uVar4 = piVar2 + 1U >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *ppiVar6 = *ppiVar5;\n        ppiVar5 = ppiVar5 + 1;\n        ppiVar6 = ppiVar6 + 1;\n    }\n    for (uVar4 = piVar2 + 1U & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *ppiVar6 = *ppiVar5;\n        ppiVar5 = ppiVar5 + 1;\n        ppiVar6 = ppiVar6 + 1;\n    }\n    return ppiVar3;\n}\n",
        "token_count": 443
    },
    "00403c06": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00403c06(uint *param_1)\n\n{\n    if (param_1[1] != 0) {\n        *(param_1[1] + 0xec) = *param_1;\n        *(param_1[1] + 0xf0) = param_1[2];\n    }\n    return;\n}\n",
        "token_count": 78
    },
    "004043a5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004043a5(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *param_1;\n    if (param_2 < *(iVar1 + -0xc)) {\n        param_2 = *(iVar1 + -0xc);\n    }\n    if (*(iVar1 + -4) < 2) {\n        iVar1 = *(iVar1 + -8);\n        if (iVar1 < param_2) {\n            if (iVar1 < 0x401) {\n                iVar1 = iVar1 * 2;\n            }\n            else {\n                iVar1 = iVar1 + 0x400;\n            }\n            if (iVar1 < param_2) {\n                iVar1 = param_2;\n            }\n            fcn.004042ce(iVar1);\n        }\n    }\n    else {\n        fcn.0040433e(param_2);\n    }\n    return;\n}\n",
        "token_count": 210
    },
    "0040449c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040449c(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t arg_8h_00;\n    int32_t *in_ECX;\n    uint32_t uVar2;\n    \n    if (arg_ch == 0) {\n        fcn.004042f6();\n    }\n    else {\n        if (arg_8h == 0) {\n            fcn.00401182(0x80070057);\n        }\n        uVar1 = *(*in_ECX + -0xc);\n        uVar2 = arg_8h - *in_ECX;\n        arg_8h_00 = fcn.004043ec(arg_ch);\n        if (uVar1 < uVar2) {\n            fcn.0040e680(arg_8h_00, arg_8h, arg_ch);\n        }\n        else {\n            fcn.0040ea50(arg_8h_00, arg_8h_00 + uVar2, arg_ch);\n        }\n        fcn.004042a8(arg_ch);\n    }\n    return;\n}\n",
        "token_count": 249
    },
    "00404853": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.00404853(int32_t *param_1, int32_t param_2, uint *param_3)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    \n    if ((param_2 == 0) && (param_3 != NULL)) {\n        uStack12 = 0x80070057;\n        fcn.00401182();\n    }\n    iVar1 = (***param_3)(param_3, 1);\n    if (iVar1 == 0) {\n        iVar1 = fcn.004034e5();\n    }\n    *param_1 = iVar1 + 0x10;\n    fcn.004042a8(param_3);\n    fcn.0040e680(*param_1, uStack12, param_3);\n    return param_1;\n}\n",
        "token_count": 186
    },
    "004048c5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.004048c5(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    iVar2 = *param_2;\n    piVar1 = iVar2 + -0x10;\n    piVar3 = *param_1 + -0x10;\n    if (piVar1 != piVar3) {\n        if ((*(*param_1 + -4) < 0) || (*piVar1 != *piVar3)) {\n            fcn.0040449c(iVar2, *(iVar2 + -0xc));\n        }\n        else {\n            iVar2 = fcn.00403667(piVar1);\n            fcn.00403164();\n            *param_1 = iVar2 + 0x10;\n        }\n    }\n    return param_1;\n}\n",
        "token_count": 206
    },
    "0042d1bf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0042d1bf(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.0042d195();\n    uVar1 = (*_sym.imp.USER32.dll_DestroyMenu)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 88
    },
    "00404d3b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid fcn.00404d3b(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint lpVersionInformation;\n    uint var_94h;\n    uint var_88h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    puVar2 = &var_94h;\n    for (iVar1 = 0x24; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 171
    },
    "00404eca": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404eca(int32_t arg_8h, int32_t arg_ch, uint32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    \n    iVar2 = fcn.00404d88();\n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    if (iVar2 == 0) {\n        if (((arg_10h & 3) == 0) &&\n           ((((arg_8h < 0 || (iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0),  iVar2 <= arg_8h)) || (arg_ch < 0)) ||\n            (iVar2 = (*pcVar1)(1),  iVar2 <= arg_ch)))) {\n            uVar3 = 0;\n        }\n        else {\n            uVar3 = 0x12340042;\n        }\n    }\n    else {\n        uVar3 = (**0x49922c)(arg_8h, arg_ch, arg_10h);\n    }\n    return uVar3;\n}\n",
        "token_count": 238
    },
    "00405157": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00405157(int32_t arg_8h, int32_t arg_ch, uint32_t *arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    \n    iVar2 = fcn.00404d88();\n    pcVar1 = _sym.imp.KERNEL32.dll_lstrcpynA;\n    if (iVar2 == 0) {\n        if ((arg_8h == 0) && (arg_ch == 0)) {\n            if ((arg_10h == NULL) || (*arg_10h < 0x1a8)) {\n                uVar3 = 0;\n            }\n            else {\n                (*_sym.imp.KERNEL32.dll_lstrcpynA)(arg_10h + 1, \"DISPLAY\", 0x20);\n                (*pcVar1)(arg_10h + 9, \"DISPLAY\", 0x80);\n                arg_10h[0x29] = 5;\n                uVar3 = 1;\n            }\n        }\n        else {\n            uVar3 = 0;\n        }\n        return uVar3;\n    }\n    // WARNING: Could not recover jumptable at 0x00405164. Too many branches\n    // WARNING: Treating indirect jump as call\n    uVar3 = (**0x499238)();\n    return uVar3;\n}\n",
        "token_count": 304
    },
    "004051c5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_48h\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl\nfcn.004051c5(int32_t *arg_8h, int32_t arg_ch, uint noname_2, uint noname_3, uint32_t arg_18h, uint32_t *arg_1ch, \n            uint *arg_20h, uint noname_7, int32_t *arg_28h)\n\n{\n    uint16_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint16_t *puVar4;\n    code *pcVar5;\n    int32_t *piVar6;\n    uint32_t *puVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t *piVar11;\n    uint var_48h;\n    uint *var_44h;\n    uint *var_40h;\n    uint *var_34h;\n    uint var_30h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    \n    puVar7 = arg_1ch;\n    piVar6 = arg_8h;\n    iVar10 = 0;\n    var_30h._0_2_ = 0;\n    if (arg_8h == NULL) {\n        return -0x7ff8ffa9;\n    }\n    if (arg_1ch == NULL) {\n        return -0x7ffdfff8;\n    }\n    uVar2 = arg_1ch[2];\n    if (5 < uVar2) {\n        return -0x7ffdfff2;\n    }\n    arg_8h = NULL;\n    if (arg_1ch[3] != 0) {\n        arg_1ch = arg_1ch[1];\n        do {\n            uVar3 = *arg_1ch;\n            if (uVar2 <= uVar3) {\n                return -0x7ffdfff2;\n            }\n            arg_1ch = arg_1ch + 1;\n            arg_8h = arg_8h + 1;\n            (&var_44h)[uVar3] = *puVar7 + iVar10;\n            iVar10 = iVar10 + 0x10;\n        } while (arg_8h < puVar7[3]);\n    }\n    if (arg_8h < uVar2) {\n        iVar10 = arg_8h * 0x10 + *puVar7;\n        iVar9 = uVar2 - arg_8h;\n        piVar11 = &var_48h + (uVar2 - arg_8h);\n        do {\n            *piVar11 = iVar10;\n            iVar10 = iVar10 + 0x10;\n            piVar11 = piVar11 + -1;\n            iVar9 = iVar9 + -1;\n        } while (iVar9 != 0);\n    }\n    iVar10 = -0x7ffdfffd;\n    if (arg_28h == NULL) {\n        arg_28h = &arg_18h;\n    }\n    if (arg_20h == NULL) {\n        arg_20h = &var_30h;\n    }\n    (*_sym.imp.OLEAUT32.dll_VariantClear)(&var_10h);\n    pcVar5 = _sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime;\n    if (0x12 < arg_ch + 0x139aU) goto code_r0x0040574d;\n    // switch table (19 cases) at 0x405760\n    switch(*((arg_ch + 0x139aU) * 4 + 0x405760)) {\n    case 0x4052aa:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 100))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3]);\n            goto code_r0x0040574d;\n        }\n        break;\n    case 0x4052d3:\n        if (puVar7[2] == 2) {\n            if (*var_44h != 3) {\n                iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_44h, 0, 3);\n                if (iVar10 < 0) goto code_r0x004052f9;\n                var_44h = &var_10h;\n            }\n            arg_18h = var_44h[2];\n            if (*var_40h != 3) {\n                iVar10 = (*pcVar5)(&var_10h, var_40h, 0, 3);\n                if (iVar10 < 0) {\ncode_r0x00405327:\n                    *arg_28h = 1;\n                    goto code_r0x0040574d;\n                }\n                var_40h = &var_10h;\n            }\n            iVar10 = (**(*piVar6 + 0x60))(piVar6, arg_18h, var_40h[2], arg_20h);\n            goto code_r0x0040574d;\n        }\n        break;\n    case 0x40534a:\n        if (puVar7[2] == 2) {\n            if (*var_44h != 3) {\n                iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_44h, 0, 3);\n                if (iVar10 < 0) goto code_r0x004052f9;\n                var_44h = &var_10h;\n            }\n            iVar10 = (**(*piVar6 + 0x5c))(piVar6, var_44h[2], *var_40h, var_40h[1], var_40h[2], var_40h[3], arg_20h);\n            goto code_r0x0040574d;\n        }\n        break;\n    case 0x405393:\n        if (puVar7[2] == 5) {\n            iVar10 = 0;\n            do {\n                puVar4 = (&var_44h)[iVar10];\n                uVar1 = *puVar4;\n                if (((uVar1 & 0x4000) == 0) || ((uVar1 & 0xf) == 0)) {\n                    *arg_28h = iVar10;\n                    break;\n                }\n                if ((uVar1 & 0xc) == 0) {\n                    iVar9 = *(puVar4 + 4);\n                }\n                else {\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(*(puVar4 + 4));\n                    puVar4 = (&var_44h)[iVar10];\n                    **(puVar4 + 4) = 3;\n                    iVar9 = *(puVar4 + 4) + 8;\n                }\n                (&var_20h)[iVar10] = iVar9;\n                iVar10 = iVar10 + 1;\n            } while (iVar10 < 4);\n            iVar10 = (**(*piVar6 + 0x58))\n                               (piVar6, var_20h, var_1ch, var_18h, var_14h, *var_34h, var_34h[1], var_34h[2], var_34h[3]\n                               );\n            goto code_r0x0040574d;\n        }\n        break;\n    case 0x405409:\n        if (puVar7[2] == 2) {\n            if (*var_44h != 3) {\n                iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_44h, 0, 3);\n                if (iVar10 < 0) goto code_r0x004052f9;\n                var_44h = &var_10h;\n            }\n            iVar10 = (**(*piVar6 + 0x54))(piVar6, var_44h[2], *var_40h, var_40h[1], var_40h[2], var_40h[3]);\n            goto code_r0x0040574d;\n        }\n        break;\n    case 0x405453:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x50))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\ncode_r0x00405476:\n            if (-1 < iVar10) {\n                *arg_20h = 8;\n            }\n            goto code_r0x0040574d;\n        }\n        break;\n    case 0x40548d:\n        iVar10 = (**(*piVar6 + 0x4c))(piVar6, arg_20h);\n        goto code_r0x0040574d;\n    case 0x40549b:\n        iVar10 = (**(*piVar6 + 0x48))(piVar6, arg_20h);\n        goto code_r0x0040574d;\n    case 0x4054a9:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x44))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00405476;\n        }\n        break;\n    case 0x4054ce:\n        if (puVar7[2] == 2) {\n            uVar1 = *var_44h;\n            if (((uVar1 & 0x4000) != 0) && ((uVar1 & 0xc) == 0)) {\n                iVar10 = -0x7ffdfffb;\ncode_r0x004052f9:\n                *arg_28h = 0;\n                goto code_r0x0040574d;\n            }\n            if (uVar1 == 0x400c) {\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(var_44h[2]);\n                *var_44h[2] = 8;\n                puVar8 = var_44h[2] + 8;\n            }\n            else if (uVar1 == 0x4008) {\n                puVar8 = var_44h[2];\n            }\n            else {\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(var_44h);\n                puVar8 = var_44h + 2;\n                *var_44h = 8;\n            }\n            iVar10 = (**(*piVar6 + 0x40))(piVar6, puVar8, *var_40h, var_40h[1], var_40h[2], var_40h[3], arg_20h + 2);\n            goto code_r0x00405544;\n        }\n        break;\n    case 0x40555b:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x3c))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00405476;\n        }\n        break;\n    case 0x405583:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x38))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h);\n            goto code_r0x0040574d;\n        }\n        break;\n    case 0x4055a7:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x34))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h);\n            goto code_r0x0040574d;\n        }\n        break;\n    case 0x4055cb:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x30))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00405476;\n        }\n        break;\n    case 0x4055f3:\n        if ((arg_18h & 2) == 0) {\n            if ((arg_18h & 4) == 0) goto code_r0x00405677;\n            if (puVar7[2] == 2) {\n                var_20h = *var_44h;\n                var_1ch = var_44h[1];\n                var_18h = var_44h[2];\n                var_14h = var_44h[3];\n                if (*var_40h != 8) {\n                    iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_40h, 0, 3);\n                    if (iVar10 < 0) goto code_r0x00405327;\n                    var_40h = &var_10h;\n                }\n                iVar10 = (**(*piVar6 + 0x6c))(piVar6, var_20h, var_1ch, var_18h, var_14h, var_40h[2]);\n                goto code_r0x0040574d;\n            }\n        }\n        else if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x2c))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00405476;\n        }\n        break;\n    case 0x405677:\ncode_r0x00405677:\n        if ((arg_18h & 2) == 0) {\n            if ((arg_18h & 4) == 0) goto code_r0x004056fb;\n            if (puVar7[2] == 2) {\n                var_20h = *var_44h;\n                var_1ch = var_44h[1];\n                var_18h = var_44h[2];\n                var_14h = var_44h[3];\n                if (*var_40h != 8) {\n                    iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_40h, 0, 3);\n                    if (iVar10 < 0) goto code_r0x00405327;\n                    var_40h = &var_10h;\n                }\n                iVar10 = (**(*piVar6 + 0x68))(piVar6, var_20h, var_1ch, var_18h, var_14h, var_40h[2]);\n                goto code_r0x0040574d;\n            }\n        }\n        else if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x28))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00405476;\n        }\n        break;\n    case 0x4056fb:\ncode_r0x004056fb:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x24))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x0040573f;\n        }\n        break;\n    case 0x405720:\n        iVar10 = (**(*piVar6 + 0x20))(piVar6, arg_20h + 2);\ncode_r0x00405544:\n        if (-1 < iVar10) {\n            *arg_20h = 3;\n        }\n        goto code_r0x0040574d;\n    case 0x405732:\n        iVar10 = (**(*piVar6 + 0x1c))(piVar6, arg_20h + 2);\ncode_r0x0040573f:\n        if (-1 < iVar10) {\n            *arg_20h = 9;\n        }\n        goto code_r0x0040574d;\n    }\n    iVar10 = -0x7ffdfff2;\ncode_r0x0040574d:\n    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_10h);\n    return iVar10;\n}\n",
        "token_count": 3845
    },
    "004057ac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nuint __cdecl fcn.004057ac(uint noname_0, int32_t arg_ch, uint32_t arg_10h, uint noname_3, int32_t arg_18h)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint var_1h;\n    \n    uVar3 = 0;\n    if (arg_10h != 0) {\n        do {\n            bVar1 = false;\n            uVar4 = 0;\n            do {\n                iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(*(arg_ch + uVar3 * 4), *(uVar4 + 0x494e30));\n                if (iVar2 == 0) {\n                    bVar1 = true;\n                    *(arg_18h + uVar3 * 4) = *(uVar4 + 0x494de0);\n                }\n                uVar4 = uVar4 + 4;\n            } while (uVar4 < 0x4c);\n            if (!bVar1) {\n                return 0x80020006;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < arg_10h);\n    }\n    return 0;\n}\n",
        "token_count": 302
    },
    "0040598c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040598c(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0xc) == 0) {\n        return 0;\n    }\n    uVar1 = (**(**(param_1 + 0xc) + 0xc))(*(param_1 + 0xc), 0);\n    return uVar1;\n}\n",
        "token_count": 89
    },
    "004059a1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004059a1(int32_t arg_8h, int32_t **arg_ch, int32_t *arg_10h, int32_t **arg_14h)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    \n    if ((arg_8h == 0) || (arg_ch == NULL)) {\n        iVar3 = -0x7ff8ffa9;\n    }\n    else if (arg_14h == NULL) {\n        iVar3 = -0x7fffbffd;\n    }\n    else {\n        *arg_14h = NULL;\n        if ((((*arg_10h == 0) && (arg_10h[1] == 0)) && (arg_10h[2] == 0xc0)) && (arg_10h[3] == 0x46000000)) {\ncode_r0x00405a51:\n            piVar4 = arg_ch[1] + arg_8h;\n            (**(*piVar4 + 4))(piVar4);\n            *arg_14h = piVar4;\n            iVar3 = 0;\n        }\n        else {\n            piVar4 = arg_ch[2];\n            while (piVar4 != NULL) {\n                piVar2 = *arg_ch;\n                if ((piVar2 == NULL) ||\n                   (((*piVar2 == *arg_10h && (piVar2[1] == arg_10h[1])) &&\n                    ((piVar2[2] == arg_10h[2] && (piVar2[3] == arg_10h[3])))))) {\n                    if (piVar4 == 0x1) goto code_r0x00405a51;\n                    iVar3 = (*piVar4)(arg_8h, arg_10h, arg_14h, arg_ch[1]);\n                    if (iVar3 == 0) {\n                        return 0;\n                    }\n                    if ((piVar2 != NULL) && (iVar3 < 0)) {\n                        return iVar3;\n                    }\n                }\n                ppiVar1 = arg_ch + 5;\n                arg_ch = arg_ch + 3;\n                piVar4 = *ppiVar1;\n            }\n            iVar3 = -0x7fffbffe;\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 527
    },
    "00405f38": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00405f38(int32_t *param_1)\n\n{\n    if (1 < *(*param_1 + -4)) {\n        fcn.0040433e(*(*param_1 + -0xc));\n    }\n    return *param_1;\n}\n",
        "token_count": 64
    },
    "00406e34": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00406e34(int32_t arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint uVar1;\n    \n    if (*(arg_8h + 0x20) == 0) {\n        uVar1 = 0x80004001;\n    }\n    else {\n        uVar1 = (**(**(arg_8h + 0x20) + 0xfc))(arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch);\n    }\n    return uVar1;\n}\n",
        "token_count": 145
    },
    "00407db5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00407db5(int32_t param_1)\n\n{\n    if ((*(param_1 + 0x4c) != 3) && (*(param_1 + 0x4c) != 4)) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 67
    },
    "00407ff5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00407ff5(int32_t param_1, uint param_2)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    \n    uVar2 = 0x8000ffff;\n    if ((*(param_1 + 0xf0) != 0) && (*(param_1 + 0xe8) != 0)) {\n        puVar1 = *(param_1 + 0xe8);\n        uVar2 = (***puVar1)(puVar1, 0x47603c, param_2);\n    }\n    return uVar2;\n}\n",
        "token_count": 134
    },
    "00408021": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00408021(int32_t param_1, uint param_2)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    \n    uVar2 = 0x8000ffff;\n    if ((*(param_1 + 0xf4) != 0) && (*(param_1 + 0xec) != 0)) {\n        puVar1 = *(param_1 + 0xec);\n        uVar2 = (***puVar1)(puVar1, 0x47603c, param_2);\n    }\n    return uVar2;\n}\n",
        "token_count": 131
    },
    "0040834d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.0040834d(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004082fb();\n    *param_1 = iVar1;\n    if ((*param_2 != 0) && (iVar1 == 0)) {\n        fcn.00401182(0x8007000e);\n    }\n    return param_1;\n}\n",
        "token_count": 103
    },
    "004096e1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_44h\n// WARNING: Variable defined which should be unmapped: var_48h\n\nint32_t __cdecl fcn.004096e1(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *arg_8h_00;\n    int32_t unaff_EBP;\n    int32_t iVar1;\n    uint *in_FS_OFFSET;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    arg_8h_00 = *(unaff_EBP + 8);\n    iVar1 = -0x7ffbfefe;\n    if (arg_8h_00 == NULL) goto code_r0x00409773;\n    fcn.004096a8(unaff_EBP + -0x14, 1, *(unaff_EBP + 0xc));\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    *(unaff_EBP + -0x10) = 0;\n    *(unaff_EBP + -0x14) = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x48) = *(unaff_EBP + 0x10);\n    if (*(unaff_EBP + 0x14) == 3) {\ncode_r0x00409763:\n        iVar1 = -0x7ffbfeff;\n    }\n    else {\n        iVar1 = fcn.004095c0(arg_8h_00, 1);\n        if (iVar1 == 0) {\n            iVar1 = -0x7ffbff00;\n        }\n        else {\n            if ((*(unaff_EBP + -0x10) & 2) == 0) goto code_r0x00409763;\n            iVar1 = (**(*arg_8h_00 + 0xc))(*(unaff_EBP + -0x48), 0, 0, 0);\n            iVar1 = (-(iVar1 != 0) & 0x7fffbffb) + 0x80004005;\n        }\n    }\n    fcn.00403164();\ncode_r0x00409773:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1;\n}\n",
        "token_count": 588
    },
    "00409c68": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409c68(int16_t *plLbound, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int16_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t cDims;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    piVar2 = plLbound;\n    if ((*plLbound != 0x2011) || (iVar3 = (*_sym.imp.OLEAUT32.dll_SafeArrayGetElemsize)(*(plLbound + 4)),  iVar3 != 1))\n    {\n        (*_sym.imp.OLEAUT32.dll_VariantCopy)(piVar2);\n        var_8h = 0;\n        cDims = arg_ch;\n        *piVar2 = 0x2011;\n        iVar3 = (*_sym.imp.OLEAUT32.dll_SafeArrayDestroy)(0x11, 1, &cDims);\n        *(piVar2 + 4) = iVar3;\n        if (iVar3 != 0) {\n            return;\n        }\n        fcn.004202f9();\n        pcVar1 = swi(3);\n        (*pcVar1)();\n        return;\n    }\n    uVar4 = (*_sym.imp.OLEAUT32.dll_SafeArrayLock)(*(piVar2 + 4), 1, &var_4h);\n    fcn.004099df(uVar4);\n    uVar4 = (*_sym.imp.OLEAUT32.dll_SafeArrayGetLBound)(*(piVar2 + 4), 1, &plLbound);\n    fcn.004099df(uVar4);\n    iVar3 = plLbound - var_4h;\n    if (iVar3 < 0) {\n        iVar3 = 0;\n    }\n    if (iVar3 == arg_ch) {\n        return;\n    }\n    cDims = arg_ch;\n    var_8h = var_4h;\n    uVar4 = (*_sym.imp.OLEAUT32.dll_SafeArrayAllocDescriptorEx)(*(piVar2 + 4), &cDims);\n    fcn.004099df(uVar4);\n    return;\n}\n",
        "token_count": 483
    },
    "0040a369": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0040a369(int32_t param_1)\n\n{\n    if (param_1 != 0) {\n        fcn.0040e620(param_1, 0, 0x18);\n    }\n    return;\n}\n",
        "token_count": 54
    },
    "0040a649": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a649(int32_t arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    uVar1 = (*_sym.imp.OLEAUT32.dll_SafeArrayUnaccessData)(*(in_ECX + 8), &var_ch);\n    fcn.004099df(uVar1);\n    iVar2 = (*_sym.imp.OLEAUT32.dll_SafeArrayGetElemsize)(*(in_ECX + 8));\n    if (iVar2 == 1) {\n        (*_sym.imp.OLEAUT32.dll_SafeArrayLock)(*(in_ECX + 8), 1, &var_8h);\n        (*_sym.imp.OLEAUT32.dll_SafeArrayGetLBound)(*(in_ECX + 8), 1, &var_4h);\n        iVar2 = (*_sym.imp.OLEAUT32.dll_SafeArrayGetUBound)(*(in_ECX + 8));\n        iVar2 = iVar2 * ((var_4h - var_8h) + 1);\n        fcn.00424dfb(iVar2, 0xffffffff);\n        fcn.0040e680(*(arg_8h + 4), var_ch, iVar2);\n    }\n    else {\n        fcn.00424dfb(0, 0xffffffff);\n    }\n    (*_sym.imp.OLEAUT32.dll_SafeArrayGetElement)(*(in_ECX + 8));\n    return;\n}\n",
        "token_count": 353
    },
    "0040abdd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040abdd(int32_t arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    uVar1 = (*_sym.imp.OLEAUT32.dll_SafeArrayUnaccessData)(*(in_ECX + 8), &var_ch);\n    fcn.004099df(uVar1);\n    iVar2 = (*_sym.imp.OLEAUT32.dll_SafeArrayGetElemsize)(*(in_ECX + 8));\n    if (iVar2 == 1) {\n        (*_sym.imp.OLEAUT32.dll_SafeArrayLock)(*(in_ECX + 8), 0, &var_8h);\n        (*_sym.imp.OLEAUT32.dll_SafeArrayGetLBound)(*(in_ECX + 8), 0, &var_4h);\n        iVar2 = (*_sym.imp.OLEAUT32.dll_SafeArrayGetUBound)(*(in_ECX + 8));\n        iVar2 = iVar2 * ((var_4h - var_8h) + 1);\n        fcn.00424dfb(iVar2, 0xffffffff);\n        fcn.0040e680(*(arg_8h + 4), var_ch, iVar2);\n    }\n    else {\n        fcn.00424dfb(0, 0xffffffff);\n    }\n    (*_sym.imp.OLEAUT32.dll_SafeArrayGetElement)(*(in_ECX + 8));\n    return;\n}\n",
        "token_count": 353
    },
    "0040aca0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040aca0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = (*_sym.imp.OLEAUT32.dll_SafeArrayGetElemsize)(*(in_ECX + 8));\n    if (iVar1 != 1) {\n        fcn.0042032d();\n    }\n    var_4h = 0;\n    var_8h = arg_8h;\n    fcn.0040a303(&var_8h);\n    return;\n}\n",
        "token_count": 136
    },
    "0040acd5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040acd5(uint16_t *param_1, uint32_t param_2, int32_t param_3, int32_t param_4)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint16_t uVar4;\n    \n    if ((param_3 != 0) && (param_4 != 0)) {\n        uVar4 = param_2;\n        if (((param_2 & 0x7000) == 0) && ((uVar4 != 0 && (uVar4 != 1)))) {\n            (*_sym.imp.OLEAUT32.dll_VariantCopy)(param_1);\n            iVar2 = (*_sym.imp.OLEAUT32.dll_SafeArrayDestroy)(param_2, param_3, param_3);\n            *(param_1 + 4) = iVar2;\n            if (iVar2 == 0) {\n                iVar2 = fcn.004202f9();\n            }\n            *param_1 = uVar4 | 0x2000;\n            *(param_1 + 10) = param_3;\n            uVar3 = (*_sym.imp.OLEAUT32.dll_SafeArrayGetUBound)(iVar2);\n            *(param_1 + 8) = uVar3;\n            return;\n        }\n    }\n    fcn.0042032d();\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 324
    },
    "0040b024": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040b024(int32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t *in_ECX;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint var_4h;\n    \n    if ((in_ECX[2] == 2) || (arg_ch[2] == 2)) {\n        arg_8h[2] = 2;\n    }\n    else {\n        if ((in_ECX[2] != 1) && (arg_ch[2] != 1)) {\n            uVar2 = arg_ch[1] + in_ECX[1] + CARRY4(*arg_ch, *in_ECX);\n            if ((((arg_ch[1] ^ in_ECX[1]) & 0x80000000) == 0) && (((in_ECX[1] ^ uVar2) & 0x80000000) != 0)) {\n                iVar1 = 1;\n            }\n            else {\n                iVar1 = 0;\n            }\n            *arg_8h = *arg_ch + *in_ECX;\n            arg_8h[1] = uVar2;\n            arg_8h[2] = iVar1;\n            return;\n        }\n        arg_8h[2] = 1;\n    }\n    *arg_8h = 0;\n    arg_8h[1] = 0;\n    return;\n}\n",
        "token_count": 317
    },
    "0040b0a9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040b0a9(int32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t *in_ECX;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint var_4h;\n    \n    if ((in_ECX[2] == 2) || (arg_ch[2] == 2)) {\n        arg_8h[2] = 2;\n    }\n    else {\n        if ((in_ECX[2] != 1) && (arg_ch[2] != 1)) {\n            uVar2 = (in_ECX[1] - arg_ch[1]) - (*in_ECX < *arg_ch);\n            if ((((arg_ch[1] ^ in_ECX[1]) & 0x80000000) == 0) || (((in_ECX[1] ^ uVar2) & 0x80000000) == 0)) {\n                iVar1 = 0;\n            }\n            else {\n                iVar1 = 1;\n            }\n            *arg_8h = *in_ECX - *arg_ch;\n            arg_8h[1] = uVar2;\n            arg_8h[2] = iVar1;\n            return;\n        }\n        arg_8h[2] = 1;\n    }\n    *arg_8h = 0;\n    arg_8h[1] = 0;\n    return;\n}\n",
        "token_count": 317
    },
    "0040b12e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040b12e(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar1 = *param_1;\n    if (param_1[2] == 0) {\n        iVar2 = param_1[1];\n        iVar3 = 0;\n        if ((iVar1 == 0) && (iVar2 == -0x80000000)) {\n            iVar3 = 1;\n        }\n        param_2[2] = iVar3;\n        *param_2 = -iVar1;\n        param_2[1] = -(iVar2 + (iVar1 != 0));\n    }\n    else {\n        *param_2 = iVar1;\n        param_2[1] = param_1[1];\n        param_2[2] = param_1[2];\n    }\n    return;\n}\n",
        "token_count": 211
    },
    "0040b292": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0040b292(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t *in_ECX;\n    ulong uVar1;\n    \n    if (in_ECX[2] == 0) {\n        if (arg_ch == 0) {\n            *arg_8h = 0;\n            arg_8h[1] = -0x80000000;\n        }\n        else {\n            if (((arg_ch != -1) || (*in_ECX != 0)) || (in_ECX[1] != -0x80000000)) {\n                uVar1 = fcn.00410a00(*in_ECX, in_ECX[1], arg_ch, arg_ch >> 0x1f);\n                arg_8h[2] = 0;\n                *arg_8h = uVar1;\n                arg_8h[1] = uVar1 >> 0x20;\n                return arg_8h;\n            }\n            *arg_8h = -1;\n            arg_8h[1] = 0x7fffffff;\n        }\n        arg_8h[2] = 1;\n    }\n    else {\n        *arg_8h = *in_ECX;\n        arg_8h[1] = in_ECX[1];\n        arg_8h[2] = in_ECX[2];\n    }\n    return arg_8h;\n}\n",
        "token_count": 317
    },
    "0040b49f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040b49f(uint arg_8h, int32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t var_8h;\n    uint var_4h;\n    \n    iVar1 = arg_ch;\n    if (arg_ch == 0) {\n        fcn.0042032d();\n    }\n    var_4h = arg_14h;\n    var_8h = iVar1;\n    fcn.0040acd5(arg_8h, 1, &var_8h);\n    if (arg_10h != 0) {\n        fcn.0040a21e(&arg_ch);\n        iVar2 = (*_sym.imp.OLEAUT32.dll_SafeArrayGetUBound)(*(in_ECX + 8));\n        fcn.0040e680(arg_ch, arg_10h, iVar2 * iVar1);\n        fcn.0040a234();\n    }\n    return;\n}\n",
        "token_count": 238
    },
    "0040c123": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: pbstr\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0040c123(uint arg_8h, uint pbstrOut, uint dwFlags)\n\n{\n    ulong uVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    ulong *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint pbstr;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = 0;\n    if (*(extraout_ECX + 1) == 2) {\n        fcn.004045fc(0x469144);\n    }\n    else if (*(extraout_ECX + 1) == 1) {\n        piVar3 = fcn.0042c770();\n        iVar4 = (**(*piVar3 + 0xc))();\n        *(unaff_EBP + 0xc) = iVar4 + 0x10;\n        *(unaff_EBP + -4) = 0;\n        iVar4 = fcn.00404503(0xd800);\n        if (iVar4 == 0) {\n            fcn.004045fc(\"Invalid DateTime\");\n        }\n        else {\n            fcn.004039b4(unaff_EBP + 0xc);\n        }\n        fcn.00403164();\n    }\n    else {\n        *(unaff_EBP + -0x10) = 0;\n        uVar1 = *extraout_ECX;\n        *(unaff_EBP + -4) = 1;\n        iVar4 = (*_sym.imp.OLEAUT32.dll_VarBstrFromDisp)\n                          (uVar1, *(unaff_EBP + 0x10), *(unaff_EBP + 0xc), unaff_EBP + -0x10, extraout_ECX);\n        if (iVar4 < 0) {\n            piVar3 = fcn.0042c770();\n            iVar4 = (**(*piVar3 + 0xc))();\n            *(unaff_EBP + 0xc) = iVar4 + 0x10;\n            *(unaff_EBP + -4) = 2;\n            iVar4 = fcn.00404503(0xd800);\n            if (iVar4 == 0) {\n                fcn.004045fc(\"Invalid DateTime\");\n            }\n            else {\n                fcn.004039b4(unaff_EBP + 0xc);\n            }\n        }\n        else {\n            fcn.0040be18(*(unaff_EBP + -0x10));\n            *(unaff_EBP + -4) = 3;\n            fcn.004039b4(unaff_EBP + 0x10);\n        }\n        fcn.00403164();\n        (*_sym.imp.OLEAUT32.dll_SysStringLen)(*(unaff_EBP + -0x10));\n    }\n    uVar2 = *(unaff_EBP + 8);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 714
    },
    "0040c57d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040c57d(uint32_t *param_1, uint32_t param_2, uint32_t param_3)\n\n{\n    if (param_2 < 4) {\n        param_2 = 4;\n    }\n    if (param_3 < 2) {\n        param_3 = 0x40;\n    }\n    param_1[3] = 0;\n    param_1[2] = 0;\n    *param_1 = param_2;\n    param_1[1] = param_3;\n    return;\n}\n",
        "token_count": 128
    },
    "0040c5d4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040c5d4(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    \n    if (param_1[3] == 0) {\n        iVar1 = fcn.00424db4(param_1 + 2, param_1[1], *param_1);\n        iVar3 = param_1[1];\n        piVar2 = iVar1 + 4 + *param_1 * (iVar3 + -1);\n        if (-1 < iVar3 + -1) {\n            do {\n                *piVar2 = param_1[3];\n                param_1[3] = piVar2;\n                piVar2 = piVar2 - *param_1;\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n    }\n    param_1[3] = *param_1[3];\n    return;\n}\n",
        "token_count": 218
    },
    "0040c8a5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040c8a5(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if (*(param_1 + 0x7c) == 0) {\n        iVar1 = fcn.0044fcc1(*(param_1 + 0x20), 0x47791c);\n        *(param_1 + 0x7c) = iVar1;\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.ole32.dll_OleRun)(*(param_1 + 0x20));\n            if (iVar1 < 0) {\n                *(param_1 + 0x7c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.0044fcc1(*(param_1 + 0x20), 0x47791c);\n                *(param_1 + 0x7c) = uVar2;\n            }\n        }\n    }\n    if ((*(param_1 + 0x7c) != 0) && (*(param_1 + 0x7c) != -1)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 265
    },
    "0040cb0b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0040cb0b(int32_t arg_8h, int32_t *arg_ch, int32_t arg_10h)\n\n{\n    uint32_t *puVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    piVar2 = fcn.0042c6eb(0x46d5b0, *(arg_8h + 0x50));\n    if (piVar2 != NULL) {\n        var_8h = (**(*piVar2 + 0xb4))();\n        if (var_8h != 0) {\n            do {\n                iVar3 = fcn.0044f097(&var_8h);\n                var_ch = fcn.0042c6eb(0x472848, iVar3);\n                if ((var_ch != 0) &&\n                   ((arg_10h != 0 || ((*(iVar3 + 0x54) != 0 && (*(*(iVar3 + 0x54) + 0x1c) == *(arg_8h + 0x1c))))))) {\n                    iVar3 = fcn.0040c8a5();\n                    if (iVar3 == 0) {\n                        var_4h = var_4h + 1;\n                    }\n                    else {\n                        iVar3 = fcn.0040c8f9(0, &var_10h);\n                        if (iVar3 != 0) {\n                            var_4h = var_4h + var_10h;\n                        }\n                        arg_ch[1] = 1;\n                    }\n                    if (arg_10h == 0) break;\n                }\n            } while (var_8h != 0);\n            if (0 < var_4h) {\n                uVar4 = *(*(*arg_ch + 0x70) + 0x1e);\n                if (uVar4 != 0xffff) {\n                    var_4h = var_4h + uVar4;\n                }\n                *(*(*arg_ch + 0x70) + 0x1e) = var_4h;\n                arg_ch[1] = 1;\n            }\n        }\n        if ((arg_ch[1] != 0) && (puVar1 = *(*arg_ch + 0x70) + 0x14,  *puVar1 = *puVar1 | 4,  arg_10h != 0)) {\n            puVar1 = *(*arg_ch + 0x70) + 0x14;\n            *puVar1 = *puVar1 | 8;\n        }\n        piVar2 = 0x1;\n    }\n    return piVar2;\n}\n",
        "token_count": 640
    },
    "0040cc0b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040cc0b(int32_t arg_8h, int32_t *arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t arg_ch_00;\n    uint uVar2;\n    uint var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint *var_4h;\n    \n    var_14h = fcn.0042c6eb(0x46d5b0, *(arg_8h + 0x50));\n    if (var_14h != NULL) {\n        var_10h = (**(*var_14h + 0xb4))();\n        while (var_10h != 0) {\n            iVar1 = fcn.0044f097(&var_10h);\n            var_ch = fcn.0042c6eb(0x472848, iVar1);\n            if ((var_ch != 0) &&\n               ((arg_10h != 0 || ((*(iVar1 + 0x54) != 0 && (*(*(iVar1 + 0x54) + 0x1c) == *(arg_8h + 0x1c))))))) {\n                iVar1 = fcn.0040c8a5();\n                if (iVar1 == 0) {\n                    fcn.0040c808(6, 2, 0);\n                }\n                else {\n                    var_8h = 0;\n                    iVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(*(*arg_ch + 0x70) + 0xc));\n                    if (iVar1 != 0) {\n                        arg_ch_00 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(*(*arg_ch + 0x70) + 8));\n                        if (arg_ch_00 != 0) {\n                            var_8h = fcn.0044ea03(iVar1, arg_ch_00);\n                            if (var_8h != 0) {\n                                var_4h = (*_sym.imp.ole32.dll_CoTaskMemAlloc)(0x18);\n                                if (var_4h != NULL) {\n                                    *var_4h = 0x18;\n                                    var_4h[1] = 1;\n                                    var_4h[2] = 1;\n                                    var_4h[3] = 1;\n                                    var_4h[4] = *(*(*arg_ch + 0x70) + 0x18);\n                                    var_4h[5] = *(*(*arg_ch + 0x70) + 0x1a);\n                                    var_18h = var_4h[4];\n                                    uVar2 = 8;\n                                    if ((*(*(*arg_ch + 0x70) + 0x14) & 0x20) != 0) {\n                                        uVar2 = 0x48;\n                                    }\n                                    (**(**(var_ch + 0x7c) + 0x14))\n                                              (*(var_ch + 0x7c), uVar2, &var_8h, &var_4h, 0, 0, arg_ch[5], &var_1ch, \n                                               &var_18h);\n                                    (*_sym.imp.ole32.dll_CoTaskMemFree)(var_4h);\n                                }\n                                (*_sym.imp.ole32.dll_CoTaskMemFree)(var_8h);\n                            }\n                            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*(*(*arg_ch + 0x70) + 8));\n                        }\n                        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*(*(*arg_ch + 0x70) + 0xc));\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 849
    },
    "0040cdb9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.0040cdb9(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar4 = -0x7fffbffb;\n    piVar1 = fcn.0042c6eb(0x46d5b0, *(arg_8h + 0x50));\n    if (piVar1 != NULL) {\n        var_4h = (**(*piVar1 + 0xb4))();\n        do {\n            if (var_4h == 0) {\n                return -0x7fffbffb;\n            }\n            uVar2 = fcn.0044f097();\n            iVar3 = fcn.0042c6eb(0x472848, uVar2);\n        } while (iVar3 == 0);\n        arg_8h = NULL;\n        if ((*(iVar3 + 0x20) != 0) && (iVar4 = (****(iVar3 + 0x20))(*(iVar3 + 0x20), 0x47790c, &arg_8h),  iVar4 == 0)) {\n            var_ch = (*(arg_ch + 8) != 0) + 6;\n            iVar4 = (**(*arg_8h + 0xc))(arg_8h, 0, 1, &var_ch, 0);\n            if (((iVar4 == 0) && ((var_8h & 3) == 3)) &&\n               ((iVar4 = (**(*arg_8h + 0x10))(arg_8h, 0, var_ch, 1, 0, 0),  iVar4 == -0x7ffbfefd || (iVar4 == 0)))) {\n                iVar4 = 0;\n            }\n            (**(*arg_8h + 8))(arg_8h);\n        }\n    }\n    return iVar4;\n}\n",
        "token_count": 475
    },
    "0040d56b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040d56b(int32_t param_1, uint param_2, int32_t param_3)\n\n{\n    int32_t *unaff_retaddr;\n    \n    if (param_3 != 0) {\n        *(param_1 + 4) = param_2;\n        *(param_1 + 0xc) = *0x475f8c;\n        *(param_1 + 0x10) = *0x475f90;\n        *(param_1 + 0x14) = *0x475f94;\n        *(param_1 + 0x18) = *0x475f98;\n        fcn.0044fce5(param_1 + 0x1c);\n        fcn.0044fce5(param_1 + 8);\n        *(param_1 + 8) = unaff_retaddr;\n        (**(*unaff_retaddr + 4))(unaff_retaddr);\n    }\n    return;\n}\n",
        "token_count": 215
    },
    "0040d5ae": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0040d5ae(int32_t param_1, int32_t param_2, uint param_3, uint *param_4)\n\n{\n    int32_t iVar1;\n    \n    if ((((*(param_1 + 4) != -1) && (*(param_1 + 4) == param_2)) && (*(param_1 + 0x1c) != 0)) &&\n       (iVar1 = fcn.00405ad0(param_1 + 0xc, param_3),  iVar1 != 0)) {\n        *param_4 = *(param_1 + 0x1c);\n        (**(**(param_1 + 0x1c) + 4))(*(param_1 + 0x1c));\n        return 1;\n    }\n    *param_4 = 0;\n    return 0;\n}\n",
        "token_count": 193
    },
    "0040d89f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040d89f(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint32_t arg_8h_00;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040daac(0x4731e8, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if ((*0x49af64 == 3) && (arg_8h_00 <= *0x49af50)) {\n        fcn.00410d9c(4);\n        *(unaff_EBP + -4) = 0;\n        uVar1 = fcn.00411b3e(arg_8h_00);\n        *(unaff_EBP + -0x1c) = uVar1;\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0040d911();\n        if (*(unaff_EBP + -0x1c) != 0) goto code_r0x0040d908;\n    }\n    if (arg_8h_00 == 0) {\n        arg_8h_00 = 1;\n    }\n    if (*0x49af64 != 1) {\n        arg_8h_00 = arg_8h_00 + 0xf & 0xfffffff0;\n    }\n    (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x49af60, 0, arg_8h_00);\ncode_r0x0040d908:\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 378
    },
    "0040d958": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040d958(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    int32_t arg_ch;\n    uint var_4h;\n    \n    fcn.0040daac(0x4731f8, 0xc);\n    arg_ch = *(unaff_EBP + 8);\n    if (arg_ch != 0) {\n        if (*0x49af64 == 3) {\n            fcn.00410d9c(4);\n            *(unaff_EBP + -4) = 0;\n            arg_8h_00 = fcn.00410f1a(arg_ch);\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 != 0) {\n                fcn.00410f45(arg_8h_00, arg_ch);\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0040d9ab();\n            if (*(unaff_EBP + -0x1c) != 0) goto code_r0x0040d9c3;\n            arg_ch = *(unaff_EBP + 8);\n        }\n        (*_sym.imp.KERNEL32.dll_HeapFree)(*0x49af60, 0, arg_ch);\n    }\ncode_r0x0040d9c3:\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 353
    },
    "0040d9c9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_58h\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040d9c9(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint var_58h;\n    uint lpSystemInfo;\n    int32_t var_48h;\n    uint32_t lpBuffer;\n    int32_t var_24h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    uint var_13h;\n    uint lpflOldProtect;\n    int32_t dwSize;\n    uint32_t lpAddress;\n    \n    fcn.0040dc10();\n    iVar1 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(&var_58h, &lpBuffer, 0x1c);\n    if (iVar1 != 0) {\n        (*_sym.imp.KERNEL32.dll_GetSystemInfo)(&lpSystemInfo);\n        uVar4 = (~(var_48h - 1U) & &var_58h) - var_48h;\n        uVar3 = ((-(*0x4998ec != 1) & 0xfffffff1) + 0x11) * var_48h + var_24h;\n        dwSize = var_48h;\n        if (uVar3 <= uVar4) {\n            lpAddress = uVar4;\n            if (*0x4998ec != 1) {\n                lpAddress = var_24h;\n                do {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(lpAddress, &lpBuffer, 0x1c);\n                    if (iVar1 == 0) {\n                        return 0;\n                    }\n                    lpAddress = lpAddress + var_1ch;\n                } while ((var_18h & 0x1000) == 0);\n                lpAddress = lpBuffer;\n                if ((var_13h & 1) != 0) {\n                    return 1;\n                }\n                if (uVar4 < lpBuffer) {\n                    return 0;\n                }\n                if (lpBuffer < uVar3) {\n                    lpAddress = uVar3;\n                }\n                (*_sym.imp.KERNEL32.dll_VirtualAlloc)(lpAddress, dwSize, 0x1000, 4);\n            }\n            uVar2 = (*_sym.imp.KERNEL32.dll_VirtualProtect)\n                              (lpAddress, dwSize, (-(*0x4998ec != 1) & 0x103) + 1, &lpflOldProtect);\n            return uVar2;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 590
    },
    "0040ddb5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.0040ddb5(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint arg_8h, uint arg_ch, uint noname_16, uint noname_17, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    uint *var_8h_3;\n    uint *var_ch_2;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    uint var_34h;\n    uint *var_30h;\n    uint var_2ch;\n    uint *var_28h_2;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint *puStack28;\n    uint uStack24;\n    uint uStack20;\n    uchar *puStack16;\n    uchar *var_8h_2;\n    int32_t var_4h_2;\n    \n    var_8h_2 = &stack0xfffffffc;\n    puStack16 = &stack0xffffffc4;\n    if (var_8h_3 == 0x123) {\n        *var_ch_2 = 0x40de50;\n        var_34h = 1;\n    }\n    else {\n        pcStack40 = fcn.0040de7c;\n        uStack36 = *0x496830;\n        uStack32 = var_20h;\n        puStack28 = var_ch_2;\n        uStack24 = var_1ch;\n        uStack20 = var_18h;\n        var_4h_2 = 0;\n        var_28h_2 = *in_FS_OFFSET;\n        *in_FS_OFFSET = &fcn.0040ddb5::var_28h_2;\n        var_30h = var_8h_3;\n        var_2ch = var_28h;\n        iVar1 = fcn.00412cd5(*var_8h_3, &fcn.0040ddb5::var_30h);\n        (**(iVar1 + 0x74))();\n        var_34h = 0;\n        if (var_4h_2 == 0) {\n            *in_FS_OFFSET = var_28h_2;\n        }\n        else {\n            *var_28h_2 = **in_FS_OFFSET;\n            *in_FS_OFFSET = var_28h_2;\n        }\n    }\n    return var_34h;\n}\n",
        "token_count": 669
    },
    "0040de7c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0040de7c(int32_t param_1, int32_t param_2, uint param_3, uint param_4, uint param_5, uint param_6, uint param_7\n                 , uint param_8)\n\n{\n    uint uVar1;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    int32_t arg_20h;\n    int32_t noname_8;\n    code *extraout_var;\n    code *UNRECOVERED_JUMPTABLE;\n    \n    if (*(param_2 + 8) == *0x496830) {\n        if ((*(param_1 + 4) & 0x66) == 0) {\n            noname_8 = 1;\n            arg_20h = *(param_2 + 0x18);\n            fcn.00412bfa(param_1, *(param_2 + 0x10), param_3, 0, *(param_2 + 0xc), *(param_2 + 0x14), arg_20h, 1);\n            UNRECOVERED_JUMPTABLE = extraout_var;\n            if (*(param_2 + 0x24) == 0) {\n                arg_20h = param_2;\n                noname_8 = param_1;\n                fcn.0040dcd8(param_2, param_1);\n            }\n            fcn.0040ddb5(0x123, &stack0xfffffff8, 0, 0, 0, 0, 0, arg_20h, noname_8, unaff_EBX, UNRECOVERED_JUMPTABLE, \n                         unaff_EBP, unaff_retaddr, param_1, param_2, param_3, param_4, param_5, param_6, param_7, \n                         param_8);\n    // WARNING: Could not recover jumptable at 0x0040df26. Too many branches\n    // WARNING: Treating indirect jump as call\n            uVar1 = (*UNRECOVERED_JUMPTABLE)();\n            return uVar1;\n        }\n        *(param_2 + 0x24) = 1;\n    }\n    else {\n        *(param_1 + 4) = *(param_1 + 4) | 8;\n    }\n    return 1;\n}\n",
        "token_count": 525
    },
    "0040df2e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040df2e(uint32_t arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t *arg_14h, uint32_t *arg_18h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t var_4h;\n    \n    iVar3 = arg_8h;\n    var_4h = *(arg_8h + 0xc);\n    iVar2 = *(arg_8h + 0x10);\n    uVar4 = var_4h;\n    arg_8h = var_4h;\n    if (-1 < arg_ch) {\n        do {\n            if (uVar4 == 0xffffffff) {\n                fcn.00413004();\n            }\n            uVar4 = uVar4 - 1;\n            iVar1 = iVar2 + uVar4 * 0x14;\n            if (((*(iVar1 + 4) < arg_10h) && (arg_10h <= *(iVar1 + 8))) || (uVar4 == 0xffffffff)) {\n                arg_ch = arg_ch + -1;\n                var_4h = arg_8h;\n                arg_8h = uVar4;\n            }\n        } while (-1 < arg_ch);\n    }\n    uVar4 = uVar4 + 1;\n    *arg_14h = uVar4;\n    *arg_18h = var_4h;\n    if ((*(iVar3 + 0xc) <= var_4h && var_4h != *(iVar3 + 0xc)) || (var_4h < uVar4)) {\n        fcn.00413004();\n    }\n    return iVar2 + uVar4 * 0x14;\n}\n",
        "token_count": 404
    },
    "0040dff1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0040dff1(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    \n    iVar2 = fcn.00412cd5();\n    if (param_1 == *(iVar2 + 0x88)) {\n        iVar2 = fcn.00412cd5();\n        *(iVar2 + 0x88) = *(param_1 + 4);\n        return;\n    }\n    iVar2 = fcn.00412cd5();\n    iVar2 = *(iVar2 + 0x88);\n    do {\n        iVar3 = iVar2;\n        if (*(iVar3 + 4) == 0) {\n            fcn.0040daac(0x473410, 8);\n            pcVar1 = *0x496bf4;\n            if (*0x496bf4 != NULL) {\n                *(unaff_EBP + -4) = 0;\n                (*pcVar1)();\n                *(unaff_EBP + -4) = 0xffffffff;\n            }\n            fcn.0040daac(0x473400, 8);\n            iVar2 = fcn.00412cd5();\n            if (*(iVar2 + 0x6c) != 0) {\n                *(unaff_EBP + -4) = 0;\n                iVar2 = fcn.00412cd5();\n                (**(iVar2 + 0x6c))();\n                *(unaff_EBP + -4) = 0xffffffff;\n            }\n            fcn.0041308c(10);\n            fcn.0041c293(0x16);\n            fcn.0040f467(3);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n        iVar2 = *(iVar3 + 4);\n    } while (param_1 != *(iVar3 + 4));\n    *(iVar3 + 4) = *(param_1 + 4);\n    return;\n}\n",
        "token_count": 445
    },
    "00412fb7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00412fb7(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0040daac(0x473400, 8);\n    iVar2 = fcn.00412cd5();\n    if (*(iVar2 + 0x6c) != 0) {\n        *(unaff_EBP + -4) = 0;\n        iVar2 = fcn.00412cd5();\n        (**(iVar2 + 0x6c))();\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    fcn.0041308c(10);\n    fcn.0041c293(0x16);\n    fcn.0040f467(3);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 216
    },
    "0040ef28": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t * __cdecl fcn.0040ef28(uint32_t *arg_8h, uint32_t arg_ch)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    \n    iVar3 = fcn.00412cd5();\n    iVar3 = *(iVar3 + 0x60);\n    if (iVar3 != *0x49af6c) {\n        iVar3 = fcn.0040fc0e();\n    }\n    if (*(iVar3 + 8) == 0) {\n        uVar7 = arg_8h & 3;\n        while (uVar7 != 0) {\n            if (*arg_8h == arg_ch) {\n                return arg_8h;\n            }\n            if (*arg_8h == 0) {\n                return NULL;\n            }\n            uVar7 = arg_8h + 1 & 3;\n            arg_8h = arg_8h + 1;\n        }\n        while( true ) {\n            while( true ) {\n                uVar7 = *arg_8h;\n                uVar6 = uVar7 ^ CONCAT22(CONCAT11(arg_ch, arg_ch), CONCAT11(arg_ch, arg_ch));\n                uVar4 = uVar7 ^ 0xffffffff ^ uVar7 + 0x7efefeff;\n                puVar5 = arg_8h + 1;\n                if (((uVar6 ^ 0xffffffff ^ uVar6 + 0x7efefeff) & 0x81010100) != 0) break;\n                arg_8h = puVar5;\n                if ((uVar4 & 0x81010100) != 0) {\n                    if ((uVar4 & 0x1010100) != 0) {\n                        return NULL;\n                    }\n                    if ((uVar7 + 0x7efefeff & 0x80000000) == 0) {\n                        return NULL;\n                    }\n                }\n            }\n            uVar7 = *arg_8h;\n            if (uVar7 == arg_ch) {\n                return arg_8h;\n            }\n            if (uVar7 == 0) {\n                return NULL;\n            }\n            uVar2 = uVar7 >> 8;\n            if (uVar2 == arg_ch) {\n                return arg_8h + 1;\n            }\n            if (uVar2 == 0) break;\n            uVar2 = uVar7 >> 0x10;\n            if (uVar2 == arg_ch) {\n                return arg_8h + 2;\n            }\n            if (uVar2 == 0) {\n                return NULL;\n            }\n            uVar2 = uVar7 >> 0x18;\n            if (uVar2 == arg_ch) {\n                return arg_8h + 3;\n            }\n            arg_8h = puVar5;\n            if (uVar2 == 0) {\n                return NULL;\n            }\n        }\n        return NULL;\n    }\n    while( true ) {\n        uVar2 = *arg_8h;\n        uVar7 = uVar2;\n        if (uVar2 == 0) break;\n        if ((*(uVar7 + 0x1d + iVar3) & 4) == 0) {\n            puVar5 = arg_8h;\n            if (arg_ch == uVar7) break;\n        }\n        else {\n            uVar1 = *(arg_8h + 1);\n            if (uVar1 == 0) {\n                return NULL;\n            }\n            puVar5 = arg_8h + 1;\n            if (arg_ch == CONCAT11(uVar2, uVar1)) {\n                return arg_8h;\n            }\n        }\n        arg_8h = puVar5 + 1;\n    }\n    return ~-(arg_ch != uVar7) & arg_8h;\n}\n",
        "token_count": 885
    },
    "0040efa3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040efa3(uint *arg_8h, uint8_t *arg_ch)\n\n{\n    uint8_t uVar1;\n    uint uVar2;\n    uint *puVar3;\n    uint8_t uVar4;\n    uint16_t uVar5;\n    int32_t iVar6;\n    uint16_t uVar7;\n    uint8_t *puVar8;\n    bool bVar9;\n    \n    iVar6 = fcn.00412cd5();\n    iVar6 = *(iVar6 + 0x60);\n    if (iVar6 != *0x49af6c) {\n        iVar6 = fcn.0040fc0e();\n    }\n    if (*(iVar6 + 8) != 0) {\n        while( true ) {\n            uVar4 = *arg_8h;\n            uVar5 = uVar4;\n            puVar3 = arg_8h + 1;\n            if ((*(uVar4 + 0x1d + iVar6) & 4) != 0) {\n                if (*puVar3 == 0) {\n                    uVar5 = 0;\n                }\n                else {\n                    uVar5 = CONCAT11(uVar4, *puVar3);\n                    puVar3 = arg_8h + 2;\n                }\n            }\n            arg_8h = puVar3;\n            uVar4 = *arg_ch;\n            uVar7 = uVar4;\n            puVar8 = arg_ch + 1;\n            if ((*(uVar4 + 0x1d + iVar6) & 4) != 0) {\n                uVar1 = *puVar8;\n                if (uVar1 == 0) {\n                    uVar7 = 0;\n                }\n                else {\n                    puVar8 = arg_ch + 2;\n                    uVar7 = CONCAT11(uVar4, uVar1);\n                }\n            }\n            if (uVar7 != uVar5) break;\n            arg_ch = puVar8;\n            if (uVar5 == 0) {\n                return 0;\n            }\n        }\n        return (-(uVar7 < uVar5) & 2) - 1;\n    }\n    if ((arg_8h & 3) != 0) {\n        if ((arg_8h & 1) != 0) {\n            uVar4 = *arg_8h;\n            arg_8h = arg_8h + 1;\n            bVar9 = uVar4 < *arg_ch;\n            if (uVar4 != *arg_ch) goto code_r0x00413b84;\n            arg_ch = arg_ch + 1;\n            if (uVar4 == 0) {\n                return 0;\n            }\n            if ((arg_8h & 2) == 0) goto code_r0x00413b50;\n        }\n        uVar5 = *arg_8h;\n        arg_8h = arg_8h + 2;\n        uVar4 = uVar5;\n        bVar9 = uVar4 < *arg_ch;\n        if (uVar4 != *arg_ch) goto code_r0x00413b84;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        uVar4 = uVar5 >> 8;\n        bVar9 = uVar4 < arg_ch[1];\n        if (uVar4 != arg_ch[1]) goto code_r0x00413b84;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        arg_ch = arg_ch + 2;\n    }\ncode_r0x00413b50:\n    while( true ) {\n        uVar2 = *arg_8h;\n        uVar4 = uVar2;\n        bVar9 = uVar4 < *arg_ch;\n        if (uVar4 != *arg_ch) break;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        uVar4 = uVar2 >> 8;\n        bVar9 = uVar4 < arg_ch[1];\n        if (uVar4 != arg_ch[1]) break;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        uVar4 = uVar2 >> 0x10;\n        bVar9 = uVar4 < arg_ch[2];\n        if (uVar4 != arg_ch[2]) break;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        uVar4 = uVar2 >> 0x18;\n        bVar9 = uVar4 < arg_ch[3];\n        if (uVar4 != arg_ch[3]) break;\n        arg_ch = arg_ch + 4;\n        arg_8h = arg_8h + 1;\n        if (uVar4 == 0) {\n            return 0;\n        }\n    }\ncode_r0x00413b84:\n    return bVar9 * -2 + 1;\n}\n",
        "token_count": 1094
    },
    "0040f0e4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040f0e4(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t arg_8h_00;\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040daac(0x473270, 0x10);\n    uVar2 = *(unaff_EBP + 8) * *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x20) = uVar2;\n    if (uVar2 == 0) {\n        uVar2 = 1;\n    }\n    do {\n        iVar3 = 0;\n        *(unaff_EBP + -0x1c) = 0;\n        if (uVar2 < 0xffffffe1) {\n            if (*0x49af64 == 3) {\n                uVar2 = uVar2 + 0xf & 0xfffffff0;\n                *(unaff_EBP + 0xc) = uVar2;\n                arg_8h_00 = *(unaff_EBP + -0x20);\n                if (*0x49af50 < arg_8h_00) goto code_r0x0040f159;\n                fcn.00410d9c(4);\n                *(unaff_EBP + -4) = 0;\n                uVar1 = fcn.00411b3e(arg_8h_00);\n                *(unaff_EBP + -0x1c) = uVar1;\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.0040f18e();\n                iVar3 = *(unaff_EBP + -0x1c);\n                if (iVar3 != 0) {\n                    fcn.0040e620(iVar3, 0, *(unaff_EBP + -0x20));\n                    goto code_r0x0040f159;\n                }\n            }\n            else {\ncode_r0x0040f159:\n                if (iVar3 != 0) {\ncode_r0x0040f199:\n                    fcn.0040dae7();\n                    return;\n                }\n            }\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x49af60, 8, uVar2);\n        }\n        if (((iVar3 != 0) || (*0x499a94 == 0)) || (iVar3 = fcn.00411e64(uVar2),  iVar3 == 0)) goto code_r0x0040f199;\n    } while( true );\n}\n",
        "token_count": 613
    },
    "0040f79f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040f79f(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) == 0) {\n        fcn.0040f6f9(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n    }\n    return;\n}\n",
        "token_count": 128
    },
    "0040fa82": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_518h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040fa82(void)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uchar uVar4;\n    char cVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint8_t *puVar8;\n    uint unaff_ESI;\n    uint *puVar9;\n    uint noname_8;\n    uint noname_9;\n    uint *noname_2;\n    uint noname_11;\n    uint *noname_4;\n    uint noname_13;\n    uint noname_14;\n    uint noname_15;\n    uint noname_8_00;\n    uint *noname_1;\n    uint noname_10;\n    uint noname_12;\n    uint noname_13_00;\n    uint noname_14_00;\n    uint noname_7;\n    uint *arg_8h;\n    uint var_518h;\n    uint in_stack_fffffae8;\n    uint in_stack_fffffaec;\n    uint in_stack_fffffaf0;\n    uint in_stack_fffffaf4;\n    uint in_stack_fffffaf8;\n    uint in_stack_fffffafc;\n    uint in_stack_fffffb00;\n    uint in_stack_fffffb04;\n    uint var_318h;\n    uint var_218h;\n    uint var_118h;\n    uint lpCPInfo;\n    uint var_12h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    arg_8h = &lpCPInfo;\n    noname_7 = *0x49b084;\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfo)();\n    if (iVar2 == 1) {\n        uVar3 = 0;\n        do {\n            *(&var_118h + uVar3) = uVar3;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n        var_118h._0_1_ = 0x20;\n        if (var_12h != 0) {\n            puVar8 = &var_12h + 1;\n            do {\n                uVar3 = var_12h;\n                if (uVar3 <= *puVar8) {\n                    uVar6 = (*puVar8 - uVar3) + 1;\n                    puVar9 = &var_118h + uVar3;\n                    for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n                        *puVar9 = 0x20202020;\n                        puVar9 = puVar9 + 1;\n                    }\n                    for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {\n                        *puVar9 = 0x20;\n                        puVar9 = puVar9 + 1;\n                    }\n                }\n                var_12h._0_1_ = puVar8[1];\n                puVar8 = puVar8 + 2;\n            } while (var_12h != 0);\n        }\n        noname_14_00 = 0;\n        puVar9 = &var_518h;\n        noname_10 = 0x100;\n        noname_1 = &var_118h;\n        noname_8_00 = 1;\n        noname_12 = *0x49b084;\n        noname_13_00 = *0x49af68;\n        fcn.0041653e(1, noname_1, 0x100, puVar9, *0x49b084, *0x49af68, 0, noname_7, arg_8h, unaff_ESI, var_518h, \n                     in_stack_fffffae8, in_stack_fffffaec, in_stack_fffffaf0, in_stack_fffffaf4);\n        noname_15 = 0;\n        noname_4 = &var_218h;\n        noname_13 = 0x100;\n        noname_11 = 0x100;\n        noname_2 = &var_118h;\n        noname_9 = 0x100;\n        noname_8 = *0x49af68;\n        noname_14 = *0x49b084;\n        fcn.00416182(*0x49af68, 0x100, noname_2, 0x100, noname_4, 0x100, *0x49b084, 0, noname_8_00, noname_1, noname_10\n                     , puVar9, noname_12, noname_13_00, noname_14_00, noname_7, arg_8h, unaff_ESI, var_518h, \n                     in_stack_fffffae8, in_stack_fffffaec, in_stack_fffffaf0, in_stack_fffffaf4, in_stack_fffffaf8, \n                     in_stack_fffffafc, in_stack_fffffb00, in_stack_fffffb04);\n        fcn.00416182(*0x49af68, 0x200, &var_118h, 0x100, &var_318h, 0x100, *0x49b084, 0, noname_8, noname_9, noname_2, \n                     noname_11, noname_4, noname_13, noname_14, noname_15, noname_8_00, noname_1, noname_10, puVar9, \n                     noname_12, noname_13_00, noname_14_00, noname_7, arg_8h, unaff_ESI, var_518h);\n        uVar3 = 0;\n        do {\n            uVar1 = *(&var_518h + uVar3 * 2);\n            if ((uVar1 & 1) == 0) {\n                if ((uVar1 & 2) != 0) {\n                    *(uVar3 + 0x49af81) = *(uVar3 + 0x49af81) | 0x20;\n                    uVar4 = *(&var_318h + uVar3);\n                    goto code_r0x0040fb94;\n                }\n                *(uVar3 + 0x49b0a0) = 0;\n            }\n            else {\n                *(uVar3 + 0x49af81) = *(uVar3 + 0x49af81) | 0x10;\n                uVar4 = *(&var_218h + uVar3);\ncode_r0x0040fb94:\n                *(uVar3 + 0x49b0a0) = uVar4;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n    }\n    else {\n        uVar3 = 0;\n        do {\n            if ((uVar3 < 0x41) || (0x5a < uVar3)) {\n                if ((0x60 < uVar3) && (uVar3 < 0x7b)) {\n                    *(uVar3 + 0x49af81) = *(uVar3 + 0x49af81) | 0x20;\n                    cVar5 = uVar3 + -0x20;\n                    goto code_r0x0040fbd7;\n                }\n                *(uVar3 + 0x49b0a0) = 0;\n            }\n            else {\n                *(uVar3 + 0x49af81) = *(uVar3 + 0x49af81) | 0x10;\n                cVar5 = uVar3 + ' ';\ncode_r0x0040fbd7:\n                *(uVar3 + 0x49b0a0) = cVar5;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 1844
    },
    "0040fc7d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040fc7d(int32_t arg_8h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    uint extraout_ECX_00;\n    int32_t iVar5;\n    uint8_t *puVar6;\n    uint8_t *puVar7;\n    uint *puVar8;\n    uint32_t var_1ch;\n    uint32_t lpCPInfo;\n    uint var_12h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    if (arg_8h != 0) {\n        iVar5 = 0;\n        uVar3 = 0;\ncode_r0x0040fc9f:\n        if (*(uVar3 + 0x496858) != arg_8h) goto code_r0x0040fca7;\n        puVar8 = 0x49af80;\n        for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar8 = 0;\n            puVar8 = puVar8 + 1;\n        }\n        var_1ch = 0;\n        *puVar8 = 0;\n        puVar6 = iVar5 * 0x30 + 0x496868;\n        do {\n            uVar2 = *puVar6;\n            puVar7 = puVar6;\n            while ((uVar2 != 0 && (uVar1 = puVar7[1],  uVar1 != 0))) {\n                uVar3 = uVar2;\n                if (uVar3 <= uVar1) {\n                    uVar2 = *(var_1ch + 0x496850);\n                    do {\n                        *(uVar3 + 0x49af81) = *(uVar3 + 0x49af81) | uVar2;\n                        uVar3 = uVar3 + 1;\n                    } while (uVar3 <= uVar1);\n                }\n                puVar7 = puVar7 + 2;\n                uVar2 = *puVar7;\n            }\n            var_1ch = var_1ch + 1;\n            puVar6 = puVar6 + 8;\n        } while (var_1ch < 4);\n        *0x49b084 = arg_8h;\n        *0x49af70 = 1;\n        *0x49af68 = fcn.0040fa2a();\n        *0x49b090 = *(extraout_ECX + 0x49685c);\n        *0x49b094 = *(extraout_ECX + 0x496860);\n        *0x49b098 = *(extraout_ECX + 0x496864);\n        goto code_r0x0040fdf4;\n    }\ncode_r0x0040fdef:\n    fcn.0040fa59();\ncode_r0x0040fdf4:\n    fcn.0040fa82();\ncode_r0x0040fe00:\n    fcn.0040e60a();\n    return;\ncode_r0x0040fca7:\n    uVar3 = uVar3 + 0x30;\n    iVar5 = iVar5 + 1;\n    if (0xef < uVar3) goto code_r0x0040fcb2;\n    goto code_r0x0040fc9f;\ncode_r0x0040fcb2:\n    iVar5 = (*_sym.imp.KERNEL32.dll_GetCPInfo)(arg_8h, &lpCPInfo);\n    if (iVar5 != 1) {\n        if (*0x499930 == 0) goto code_r0x0040fe00;\n        goto code_r0x0040fdef;\n    }\n    puVar8 = 0x49af80;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *0x49b084 = arg_8h;\n    *0x49af68 = 0;\n    if (lpCPInfo < 2) {\n        *0x49af70 = 0;\n    }\n    else {\n        if (var_12h != '\\0') {\n            puVar6 = &var_12h + 1;\n            do {\n                uVar2 = *puVar6;\n                if (uVar2 == 0) break;\n                for (uVar3 = puVar6[-1]; uVar3 <= uVar2; uVar3 = uVar3 + 1) {\n                    *(uVar3 + 0x49af81) = *(uVar3 + 0x49af81) | 4;\n                }\n                puVar7 = puVar6 + 1;\n                puVar6 = puVar6 + 2;\n            } while (*puVar7 != 0);\n        }\n        uVar3 = 1;\n        do {\n            *(uVar3 + 0x49af81) = *(uVar3 + 0x49af81) | 8;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0xff);\n        *0x49af68 = fcn.0040fa2a();\n        *0x49af70 = extraout_ECX_00;\n    }\n    *0x49b090 = 0;\n    *0x49b094 = 0;\n    *0x49b098 = 0;\n    goto code_r0x0040fdf4;\n}\n",
        "token_count": 1263
    },
    "0040ff8b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid __cdecl fcn.0040ff8b(uint arg_8h, uint arg_ch)\n\n{\n    int32_t arg_ch_00;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint32_t arg_10h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040daac(0x4732f8, 0x14);\n    arg_ch_00 = *(unaff_EBP + 8);\n    if (arg_ch_00 == 0) {\n        fcn.0040d946(*(unaff_EBP + 0xc));\n    }\n    else {\n        arg_10h = *(unaff_EBP + 0xc);\n        if (arg_10h == 0) {\n            fcn.0040d958(arg_ch_00);\n        }\n        else if (*0x49af64 == 3) {\n            do {\n                *(unaff_EBP + -0x1c) = 0;\n                if (arg_10h < 0xffffffe1) {\n                    fcn.00410d9c(4);\n                    *(unaff_EBP + -4) = 0;\n                    iVar1 = fcn.00410f1a(arg_ch_00);\n                    *(unaff_EBP + -0x20) = iVar1;\n                    if (iVar1 != 0) {\n                        if (arg_10h <= *0x49af50) {\n                            iVar1 = fcn.0041141a(iVar1, arg_ch_00, arg_10h);\n                            if (iVar1 == 0) {\n                                iVar1 = fcn.00411b3e(arg_10h);\n                                *(unaff_EBP + -0x1c) = iVar1;\n                                if (iVar1 != 0) {\n                                    uVar2 = *(arg_ch_00 + -4) - 1;\n                                    *(unaff_EBP + -0x24) = uVar2;\n                                    if (arg_10h <= uVar2) {\n                                        uVar2 = arg_10h;\n                                    }\n                                    fcn.0040e680(*(unaff_EBP + -0x1c), arg_ch_00, uVar2);\n                                    uVar3 = fcn.00410f1a(arg_ch_00);\n                                    *(unaff_EBP + -0x20) = uVar3;\n                                    fcn.00410f45(uVar3, arg_ch_00);\n                                }\n                            }\n                            else {\n                                *(unaff_EBP + -0x1c) = arg_ch_00;\n                            }\n                        }\n                        if (*(unaff_EBP + -0x1c) == 0) {\n                            if (arg_10h == 0) {\n                                arg_10h = 1;\n                                *(unaff_EBP + 0xc) = 1;\n                            }\n                            arg_10h = arg_10h + 0xf & 0xfffffff0;\n                            *(unaff_EBP + 0xc) = arg_10h;\n                            iVar1 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x49af60, 0, arg_10h);\n                            *(unaff_EBP + -0x1c) = iVar1;\n                            if (iVar1 != 0) {\n                                uVar2 = *(arg_ch_00 + -4) - 1;\n                                *(unaff_EBP + -0x24) = uVar2;\n                                if (arg_10h <= uVar2) {\n                                    uVar2 = arg_10h;\n                                }\n                                fcn.0040e680(*(unaff_EBP + -0x1c), arg_ch_00, uVar2);\n                                fcn.00410f45(*(unaff_EBP + -0x20), arg_ch_00);\n                            }\n                        }\n                    }\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    fcn.004100f3();\n                    if (*(unaff_EBP + -0x20) == 0) {\n                        if (arg_10h == 0) {\n                            arg_10h = 1;\n                        }\n                        arg_10h = arg_10h + 0xf & 0xfffffff0;\n                        *(unaff_EBP + 0xc) = arg_10h;\n                        uVar3 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x49af60, 0, arg_ch_00, arg_10h);\n                        *(unaff_EBP + -0x1c) = uVar3;\n                    }\n                }\n            } while (((*(unaff_EBP + -0x1c) == 0) && (*0x499a94 != 0)) && (iVar1 = fcn.00411e64(arg_10h),  iVar1 != 0));\n        }\n        else {\n            do {\n                iVar1 = 0;\n                if (arg_10h < 0xffffffe1) {\n                    if (arg_10h == 0) {\n                        arg_10h = 1;\n                    }\n                    iVar1 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x49af60, 0, arg_ch_00, arg_10h);\n                }\n            } while (((iVar1 == 0) && (*0x499a94 != 0)) && (iVar1 = fcn.00411e64(arg_10h),  iVar1 != 0));\n        }\n    }\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 1271
    },
    "0041014e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041014e(uint lpMem, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint32_t arg_10h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040daac(0x473308, 0x10);\n    arg_10h = *(unaff_EBP + 0xc);\n    if (arg_10h < 0xffffffe1) {\n        if (*0x49af64 == 3) {\n            fcn.00410d9c(4);\n            *(unaff_EBP + -4) = 0;\n            uVar2 = *(unaff_EBP + 8);\n            iVar1 = fcn.00410f1a(uVar2);\n            *(unaff_EBP + -0x20) = iVar1;\n            if (((iVar1 != 0) && (*(unaff_EBP + -0x1c) = 0,  arg_10h <= *0x49af50)) &&\n               (iVar1 = fcn.0041141a(iVar1, uVar2, arg_10h),  iVar1 != 0)) {\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.004101cc();\n            if (*(unaff_EBP + -0x20) != 0) goto code_r0x004101f2;\n            if (arg_10h == 0) {\n                arg_10h = 1;\n            }\n            arg_10h = arg_10h + 0xf & 0xfffffff0;\n        }\n        else if (arg_10h == 0) {\n            arg_10h = 1;\n        }\n        uVar2 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x49af60, 0x10, *(unaff_EBP + 8), arg_10h);\n        *(unaff_EBP + -0x1c) = uVar2;\n    }\ncode_r0x004101f2:\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 522
    },
    "004101f8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004101f8(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040daac(0x473318, 0x10);\n    if (*0x49af64 == 3) {\n        fcn.00410d9c(4);\n        *(unaff_EBP + -4) = 0;\n        iVar1 = *(unaff_EBP + 8);\n        iVar2 = fcn.00410f1a(iVar1);\n        *(unaff_EBP + -0x20) = iVar2;\n        if (iVar2 != 0) {\n            *(unaff_EBP + -0x1c) = *(iVar1 + -4) + -9;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00410265();\n        if (*(unaff_EBP + -0x20) != 0) goto code_r0x0041025a;\n    }\n    (*_sym.imp.KERNEL32.dll_HeapSize)(*0x49af60, 0, *(unaff_EBP + 8));\ncode_r0x0041025a:\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 324
    },
    "0041026e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0041026e(uint8_t *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    \n    iVar1 = fcn.00412cd5();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x496dc4) {\n        iVar1 = fcn.00416a84();\n    }\n    while( true ) {\n        if (*(iVar1 + 0x28) < 2) {\n            uVar2 = *(*(iVar1 + 0x48) + *param_1 * 2) & 8;\n        }\n        else {\n            uVar2 = fcn.004166f8(iVar1, *param_1, 8);\n        }\n        if (uVar2 == 0) break;\n        param_1 = param_1 + 1;\n    }\n    uVar2 = *param_1;\n    puVar5 = param_1 + 1;\n    if ((uVar2 == 0x2d) || (uVar3 = uVar2,  uVar2 == 0x2b)) {\n        uVar3 = *puVar5;\n        puVar5 = param_1 + 2;\n    }\n    iVar1 = 0;\n    while( true ) {\n        if ((uVar3 < 0x30) || (0x39 < uVar3)) {\n            iVar4 = -1;\n        }\n        else {\n            iVar4 = uVar3 - 0x30;\n        }\n        if (iVar4 == -1) break;\n        iVar1 = iVar4 + iVar1 * 10;\n        uVar3 = *puVar5;\n        puVar5 = puVar5 + 1;\n    }\n    if (uVar2 == 0x2d) {\n        iVar1 = -iVar1;\n    }\n    return iVar1;\n}\n",
        "token_count": 440
    },
    "004103c9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint8_t * fcn.004103c9(uint8_t *param_1)\n\n{\n    uint8_t *puVar1;\n    \n    puVar1 = param_1 + 1;\n    if (((*(*param_1 + 0x49af81) & 4) != 0) && (*puVar1 != 0)) {\n        puVar1 = param_1 + 2;\n    }\n    return puVar1;\n}\n",
        "token_count": 98
    },
    "0041042f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041042f(uint arg_8h, uint arg_ch, uint noname_2, uint noname_3, uint arg_18h)\n\n{\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x20) == 0) {\n        fcn.0040f6f9(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), *(unaff_EBP + 0x18));\n    }\n    return;\n}\n",
        "token_count": 140
    },
    "004104b2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint8_t * fcn.004104b2(uint8_t *param_1, uint8_t *param_2)\n\n{\n    int32_t iVar1;\n    uint8_t *puVar2;\n    \n    iVar1 = fcn.00412cd5();\n    iVar1 = *(iVar1 + 0x60);\n    if (iVar1 != *0x49af6c) {\n        iVar1 = fcn.0040fc0e();\n    }\n    if (param_2 <= param_1) {\n        return NULL;\n    }\n    if (*(iVar1 + 8) == 0) {\n        return param_2 + -1;\n    }\n    puVar2 = param_2 + -1;\n    do {\n        puVar2 = puVar2 + -1;\n        if (puVar2 < param_1) break;\n    } while ((*(*puVar2 + 0x1d + iVar1) & 4) != 0);\n    return param_2 + (-1 - (param_2 - puVar2 & 1U));\n}\n",
        "token_count": 233
    },
    "00410501": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint64_t __cdecl fcn.00410501(int32_t arg_8h)\n\n{\n    uint64_t uVar1;\n    int32_t *in_EAX;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    bool bVar6;\n    int64_t iVar7;\n    ulong uVar8;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    int32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_ch = in_EAX[5];\n    var_8h = var_ch >> 0x1f;\n    if ((var_8h < 0) ||\n       ((((-1 < var_ch || var_8h < 0 && (var_ch < 0x45)) || (0 < var_8h)) || ((-1 < var_8h && (0x44c < var_ch)))))) {\ncode_r0x00410747:\n        _var_ch = -1;\n    }\n    else {\n        iVar4 = in_EAX[4];\n        if ((iVar4 < 0) || (0xb < iVar4)) {\n            uVar2 = iVar4 / 0xc;\n            iVar4 = iVar4 % 0xc;\n            bVar6 = CARRY4(var_ch, uVar2);\n            var_ch = var_ch + uVar2;\n            in_EAX[4] = iVar4;\n            var_8h = var_8h + (uVar2 >> 0x1f) + bVar6;\n            if (iVar4 < 0) {\n                bVar6 = var_ch != 0;\n                var_ch = var_ch - 1;\n                in_EAX[4] = iVar4 + 0xc;\n                var_8h = var_8h + -1 + bVar6;\n            }\n            if ((((var_8h < 0) || ((var_8h < 1 && (var_ch < 0x45)))) || (0 < var_8h)) ||\n               ((-1 < var_8h && (0x44c < var_ch)))) goto code_r0x00410747;\n        }\n        iVar4 = in_EAX[4];\n        var_14h = *(iVar4 * 4 + 0x497034);\n        var_10h = var_14h >> 0x1f;\n        iVar7 = fcn.00417ba0(var_ch, var_8h, 4, 0);\n        if ((iVar7 == 0) && (uVar2 = var_ch,  iVar7 = fcn.00417ba0(var_ch, var_8h, 100, 0),  iVar7 != 0)) {\ncode_r0x004105f6:\n            if (1 < iVar4) {\n                bVar6 = 0xfffffffe < var_14h;\n                var_14h = var_14h + 1;\n                var_10h = var_10h + bVar6;\n            }\n        }\n        else {\n            uVar2 = var_ch + 0x76c;\n            iVar7 = fcn.00417ba0();\n            if (iVar7 == 0) goto code_r0x004105f6;\n        }\n        iVar5 = var_ch - 1;\n        iVar4 = var_8h - (var_ch == 0);\n        iVar7 = fcn.00410a00(var_ch + 299, var_8h + (0xfffffed4 < var_ch), 400, 0, uVar2);\n        uVar2 = iVar7 + in_EAX[3];\n        var_4h = iVar7 + in_EAX[3] >> 0x20;\n        uVar8 = fcn.00410a00(iVar5, iVar4, 100, 0);\n        var_4h = (var_4h - (uVar8 >> 0x20)) - (uVar2 < uVar8);\n        iVar7 = fcn.00410a00(iVar5, iVar4, 4, 0);\n        uVar1 = iVar7 + CONCAT44(var_4h, uVar2 - uVar8);\n        var_4h = uVar1 >> 0x20;\n        iVar7 = fcn.0040f9b0(var_ch, var_8h, 0x16d, 0);\n        iVar7 = iVar7 + (uVar1 & 0xffffffff | var_4h << 0x20) + CONCAT44(var_10h, var_14h);\n        uVar2 = iVar7;\n        var_4h = uVar2 - 0x63df;\n        iVar7 = fcn.0040f9b0(var_4h, (iVar7 >> 0x20) - (uVar2 < 0x63df), 0x18, 0);\n        iVar7 = fcn.0040f9b0(iVar7 + in_EAX[2], 0x3c, 0);\n        _var_ch = fcn.0040f9b0(iVar7 + in_EAX[1], 0x3c, 0);\n        _var_ch = _var_ch + *in_EAX;\n        if (arg_8h == 0) {\n            piVar3 = fcn.004172cd(&var_ch);\ncode_r0x00410733:\n            if (piVar3 == NULL) goto code_r0x00410747;\n        }\n        else {\n            fcn.00417ad9();\n            _var_ch = _var_ch + *0x496f50;\n            piVar3 = fcn.0041076b(&var_ch);\n            if (piVar3 == NULL) goto code_r0x00410747;\n            if ((0 < in_EAX[8]) || ((in_EAX[8] < 0 && (0 < piVar3[8])))) {\n                _var_ch = _var_ch + *0x496f58;\n                piVar3 = fcn.0041076b(&var_ch);\n                goto code_r0x00410733;\n            }\n        }\n        for (iVar4 = 9; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *in_EAX = *piVar3;\n            piVar3 = piVar3 + 1;\n            in_EAX = in_EAX + 1;\n        }\n    }\n    return _var_ch;\n}\n",
        "token_count": 1456
    },
    "00410bad": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00410bad(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_00000008;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint32_t var_4h;\n    \n    uVar1 = arg_8h;\n    if (arg_8h < 0x100) {\n        uVar3 = fcn.004181f8(arg_8h);\n    }\n    else {\n        var_4h = 0;\n        iVar2 = fcn.00412cd5();\n        iVar2 = *(iVar2 + 0x60);\n        if (iVar2 != *0x49af6c) {\n            iVar2 = fcn.0040fc0e();\n        }\n        arg_8h = CONCAT13(uVar1, CONCAT12(uVar1 >> 8, arg_8h));\n        if ((((*(iVar2 + 8) != 0) &&\n             (iVar2 = fcn.0041653e(1, &arg_8h + 2, 2, &var_4h, *(iVar2 + 4), *(iVar2 + 0xc), 1, unaff_EBX, var_4h, \n                                   unaff_EBP, unaff_retaddr, arg_8h, in_stack_00000008, in_stack_0000000c, \n                                   in_stack_00000010),  iVar2 != 0)) && (var_4h._2_2_ == 0)) && ((var_4h & 8) != 0)) {\n            return 1;\n        }\n        uVar3 = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 429
    },
    "00410dcd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint fcn.00410dcd(void)\n\n{\n    if ((*0x4998ec == 2) && (4 < *0x4998f8)) {\n        return 1;\n    }\n    return 3;\n}\n",
        "token_count": 50
    },
    "00410de7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint fcn.00410de7(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *0x49af60 = (*_sym.imp.KERNEL32.dll_HeapCreate)(param_1 == 0, 0x1000, 0);\n    if (*0x49af60 == 0) {\n        return 0;\n    }\n    *0x49af64 = fcn.00410dcd();\n    if ((*0x49af64 == 3) && (iVar1 = fcn.00410ed2(0x3f8),  iVar1 == 0)) {\n        (*_sym.imp.KERNEL32.dll_HeapDestroy)(*0x49af60);\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 168
    },
    "004117ca": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.004117ca(void)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t **ppiVar4;\n    uint32_t uVar5;\n    int32_t *piVar6;\n    int32_t **ppiVar7;\n    int32_t iVar8;\n    int32_t **ppiVar9;\n    int32_t **ppiVar10;\n    uint32_t *puVar11;\n    uint32_t *puVar12;\n    uint *puVar13;\n    bool bVar14;\n    uint var_138h;\n    uint32_t *var_38h;\n    uint32_t *var_34h;\n    int32_t **var_30h;\n    int32_t **var_2ch;\n    uint32_t var_28h;\n    int32_t **var_24h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    int32_t var_ch;\n    int32_t **var_8h;\n    int32_t *var_4h;\n    \n    iVar3 = (*_sym.imp.KERNEL32.dll_IsBadWritePtr)(*0x49af4c, *0x49af48 * 0x14);\n    if (iVar3 != 0) {\n        return 0xffffffff;\n    }\n    var_1ch = 0;\n    puVar11 = *0x49af4c;\n    if (0 < *0x49af48) {\n        do {\n            uVar5 = puVar11[4];\n            var_34h = puVar11;\n            iVar3 = (*_sym.imp.KERNEL32.dll_IsBadWritePtr)(uVar5, 0x41c4);\n            if (iVar3 != 0) {\n                return 0xfffffffe;\n            }\n            var_8h = puVar11[3];\n            var_24h = uVar5 + 0x144;\n            var_20h = puVar11[2];\n            puVar12 = uVar5 + 0xc4;\n            var_10h = 0;\n            var_14h = 0;\n            var_ch = 0;\n            do {\n                var_28h = 0;\n                var_18h = 0;\n                var_4h = NULL;\n                bVar14 = -1 < var_20h;\n                puVar13 = &var_138h;\n                var_38h = puVar12;\n                for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar13 = 0;\n                    puVar13 = puVar13 + 1;\n                }\n                if (bVar14) {\n                    iVar3 = (*_sym.imp.KERNEL32.dll_IsBadWritePtr)(var_8h, 0x8000);\n                    if (iVar3 != 0) {\n                        return 0xfffffffc;\n                    }\n                    iVar3 = 0;\n                    ppiVar9 = var_8h + 0x3ff;\n                    do {\n                        ppiVar4 = ppiVar9 + -0x3fc;\n                        if ((ppiVar9[-0x3fd] != 0xffffffff) || (*ppiVar9 != 0xffffffff)) {\n                            return 0xfffffffb;\n                        }\n                        do {\n                            piVar2 = *ppiVar4;\n                            if ((piVar2 & 1) == 0) {\n                                iVar8 = (piVar2 >> 4) + -1;\n                                if (0x3f < iVar8) {\n                                    iVar8 = 0x3f;\n                                }\n                                (&var_138h)[iVar8] = (&var_138h)[iVar8] + 1;\n                                piVar6 = piVar2;\n                            }\n                            else {\n                                if (0x400 < piVar2 - 1U) {\n                                    return 0xfffffffa;\n                                }\n                                var_4h = var_4h + 1;\n                                piVar6 = piVar2 - 1U;\n                            }\n                            if (((piVar6 < 0x10) || ((piVar6 & 0xf) != 0)) || (0xff0 < piVar6)) {\n                                return 0xfffffff9;\n                            }\n                            ppiVar4 = piVar6 + ppiVar4;\n                            if (ppiVar4[-1] != piVar2) {\n                                return 0xfffffff8;\n                            }\n                        } while (ppiVar4 < ppiVar9);\n                        if (ppiVar4 != ppiVar9) {\n                            return 0xfffffff8;\n                        }\n                        ppiVar9 = ppiVar9 + 0x400;\n                        iVar3 = iVar3 + 1;\n                    } while (iVar3 < 8);\n                    if (*var_24h != var_4h) {\n                        return 0xfffffff7;\n                    }\n                    iVar3 = 0;\n                    ppiVar9 = var_24h;\n                    do {\n                        var_4h = NULL;\n                        var_30h = ppiVar9 + 2;\n                        ppiVar4 = ppiVar9[1];\n                        var_2ch = ppiVar9;\n                        ppiVar10 = var_30h;\n                        if (ppiVar4 != ppiVar9) {\n                            do {\n                                if (var_4h == (&var_138h)[iVar3]) break;\n                                if ((ppiVar4 < var_8h) || (var_8h + 0x2000 <= ppiVar4)) {\n                                    return 0xfffffff6;\n                                }\n                                ppiVar7 = (ppiVar4 & 0xfffff000) + 0xc;\n                                ppiVar1 = (ppiVar4 & 0xfffff000) + 0xffc;\n                                if (ppiVar7 == ppiVar1) {\n                                    return 0xfffffff5;\n                                }\n                                do {\n                                    if (ppiVar7 == ppiVar4) break;\n                                    ppiVar7 = ppiVar7 + (*ppiVar7 & 0xfffffffe);\n                                    ppiVar10 = var_30h;\n                                } while (ppiVar7 != ppiVar1);\n                                if (ppiVar7 == ppiVar1) {\n                                    return 0xfffffff5;\n                                }\n                                iVar8 = (*ppiVar4 >> 4) + -1;\n                                if (0x3f < iVar8) {\n                                    iVar8 = 0x3f;\n                                }\n                                if (iVar8 != iVar3) {\n                                    return 0xfffffff4;\n                                }\n                                if (ppiVar4[2] != var_2ch) {\n                                    return 0xfffffff3;\n                                }\n                                var_4h = var_4h + 1;\n                                var_2ch = ppiVar4;\n                                ppiVar4 = ppiVar4[1];\n                            } while (ppiVar4 != ppiVar9);\n                            if (var_4h != NULL) {\n                                if (iVar3 < 0x20) {\n                                    uVar5 = 0x80000000 >> (iVar3 & 0x1f);\n                                    var_28h = var_28h | uVar5;\n                                    var_10h = var_10h | uVar5;\n                                }\n                                else {\n                                    uVar5 = 0x80000000 >> (iVar3 - 0x20 & 0x1f);\n                                    var_18h = var_18h | uVar5;\n                                    var_14h = var_14h | uVar5;\n                                }\n                            }\n                        }\n                        if ((var_2ch[1] != ppiVar9) || (var_4h != (&var_138h)[iVar3])) {\n                            return 0xfffffff2;\n                        }\n                        if (*ppiVar10 != var_2ch) {\n                            return 0xfffffff1;\n                        }\n                        iVar3 = iVar3 + 1;\n                        puVar11 = var_34h;\n                        puVar12 = var_38h;\n                        ppiVar9 = ppiVar10;\n                    } while (iVar3 < 0x40);\n                }\n                if ((var_28h != puVar12[-0x20]) || (var_18h != *puVar12)) {\n                    return 0xfffffff0;\n                }\n                var_8h = var_8h + 0x2000;\n                var_24h = var_24h + 0x81;\n                var_20h = var_20h << 1;\n                var_ch = var_ch + 1;\n                puVar12 = puVar12 + 1;\n            } while (var_ch < 0x20);\n            if ((var_10h != *puVar11) || (var_14h != puVar11[1])) {\n                return 0xffffffef;\n            }\n            puVar11 = puVar11 + 5;\n            var_1ch = var_1ch + 1;\n            var_38h = puVar12;\n        } while (var_1ch < *0x49af48);\n    }\n    return 0;\n}\n",
        "token_count": 2020
    },
    "00411b3e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00411b3e(uint32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    int32_t *piVar3;\n    char cVar4;\n    int32_t *piVar5;\n    uint uVar6;\n    uint8_t uVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    uint32_t *puVar10;\n    int32_t iVar11;\n    uint32_t uVar12;\n    int32_t *piVar13;\n    uint32_t *puVar14;\n    uint32_t *puVar15;\n    uint32_t uVar16;\n    int32_t iVar17;\n    bool bVar18;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    uVar8 = arg_8h + 0x17U & 0xfffffff0;\n    iVar9 = (arg_8h + 0x17U >> 4) + -1;\n    puVar10 = *0x49af4c + *0x49af48 * 5;\n    uVar7 = iVar9;\n    if (iVar9 < 0x20) {\n        uVar16 = 0xffffffff >> (uVar7 & 0x1f);\n        var_8h = 0xffffffff;\n    }\n    else {\n        uVar16 = 0;\n        var_8h = 0xffffffff >> (uVar7 - 0x20 & 0x1f);\n    }\n    bVar18 = *0x49af54 < puVar10;\n    arg_8h = *0x49af54;\n    while ((bVar18 && ((arg_8h[1] & var_8h | *arg_8h & uVar16) == 0))) {\n        arg_8h = arg_8h + 5;\n        bVar18 = arg_8h < puVar10;\n    }\n    puVar14 = *0x49af4c;\n    if (arg_8h == puVar10) {\n        for (; (puVar14 < *0x49af54 && ((puVar14[1] & var_8h | *puVar14 & uVar16) == 0)); puVar14 = puVar14 + 5) {\n        }\n        arg_8h = puVar14;\n        if (puVar14 == *0x49af54) {\n            for (; (puVar14 < puVar10 && (puVar14[2] == 0)); puVar14 = puVar14 + 5) {\n            }\n            puVar15 = *0x49af4c;\n            arg_8h = puVar14;\n            if (puVar14 == puVar10) {\n                for (; (puVar15 < *0x49af54 && (puVar15[2] == 0)); puVar15 = puVar15 + 5) {\n                }\n                arg_8h = puVar15;\n                if ((puVar15 == *0x49af54) && (arg_8h = fcn.0041125d(),  arg_8h == NULL)) {\n                    return NULL;\n                }\n            }\n            uVar6 = fcn.00411314(arg_8h);\n            *arg_8h[4] = uVar6;\n            if (*arg_8h[4] == -1) {\n                return NULL;\n            }\n        }\n    }\n    piVar5 = arg_8h[4];\n    var_4h = *piVar5;\n    if ((var_4h == -1) || ((piVar5[var_4h + 0x31] & var_8h | piVar5[var_4h + 0x11] & uVar16) == 0)) {\n        var_4h = 0;\n        puVar10 = piVar5 + 0x11;\n        uVar12 = piVar5[0x31] & var_8h | *puVar10 & uVar16;\n        while (uVar12 == 0) {\n            puVar14 = puVar10 + 0x21;\n            var_4h = var_4h + 1;\n            puVar10 = puVar10 + 1;\n            uVar12 = *puVar14 & var_8h | *puVar10 & uVar16;\n        }\n    }\n    piVar3 = piVar5 + var_4h * 0x81 + 0x51;\n    iVar9 = 0;\n    uVar16 = piVar5[var_4h + 0x11] & uVar16;\n    if (uVar16 == 0) {\n        uVar16 = piVar5[var_4h + 0x31] & var_8h;\n        iVar9 = 0x20;\n    }\n    for (; -1 < uVar16; uVar16 = uVar16 << 1) {\n        iVar9 = iVar9 + 1;\n    }\n    piVar13 = piVar3[iVar9 * 2 + 1];\n    iVar11 = *piVar13 - uVar8;\n    iVar17 = (iVar11 >> 4) + -1;\n    if (0x3f < iVar17) {\n        iVar17 = 0x3f;\n    }\n    *0x49af54 = arg_8h;\n    if (iVar17 != iVar9) {\n        if (piVar13[1] == piVar13[2]) {\n            if (iVar9 < 0x20) {\n                pcVar2 = piVar5 + iVar9 + 4;\n                uVar16 = ~(0x80000000U >> (iVar9 & 0x1f));\n                piVar5[var_4h + 0x11] = uVar16 & piVar5[var_4h + 0x11];\n                *pcVar2 = *pcVar2 + -1;\n                if (*pcVar2 == '\\0') {\n                    *arg_8h = *arg_8h & uVar16;\n                }\n            }\n            else {\n                pcVar2 = piVar5 + iVar9 + 4;\n                uVar16 = ~(0x80000000U >> (iVar9 - 0x20 & 0x1f));\n                piVar5[var_4h + 0x31] = piVar5[var_4h + 0x31] & uVar16;\n                *pcVar2 = *pcVar2 + -1;\n                if (*pcVar2 == '\\0') {\n                    arg_8h[1] = arg_8h[1] & uVar16;\n                }\n            }\n        }\n        *(piVar13[2] + 4) = piVar13[1];\n        *(piVar13[1] + 8) = piVar13[2];\n        if (iVar11 == 0) goto code_r0x00411df7;\n        piVar1 = piVar3 + iVar17 * 2;\n        iVar9 = piVar1[1];\n        piVar13[2] = piVar1;\n        piVar13[1] = iVar9;\n        piVar1[1] = piVar13;\n        *(piVar13[1] + 8) = piVar13;\n        if (piVar13[1] == piVar13[2]) {\n            cVar4 = *(iVar17 + 4 + piVar5);\n            *(iVar17 + 4 + piVar5) = cVar4 + '\\x01';\n            uVar7 = iVar17;\n            if (iVar17 < 0x20) {\n                if (cVar4 == '\\0') {\n                    *arg_8h = *arg_8h | 0x80000000U >> (uVar7 & 0x1f);\n                }\n                piVar5[var_4h + 0x11] = piVar5[var_4h + 0x11] | 0x80000000U >> (uVar7 & 0x1f);\n            }\n            else {\n                if (cVar4 == '\\0') {\n                    arg_8h[1] = arg_8h[1] | 0x80000000U >> (uVar7 - 0x20 & 0x1f);\n                }\n                piVar5[var_4h + 0x31] = piVar5[var_4h + 0x31] | 0x80000000U >> (uVar7 - 0x20 & 0x1f);\n            }\n        }\n    }\n    if (iVar11 != 0) {\n        *piVar13 = iVar11;\n        *(iVar11 + -4 + piVar13) = iVar11;\n    }\ncode_r0x00411df7:\n    piVar13 = piVar13 + iVar11;\n    *piVar13 = uVar8 + 1;\n    *(piVar13 + (uVar8 - 4)) = uVar8 + 1;\n    iVar9 = *piVar3;\n    *piVar3 = iVar9 + 1;\n    if (((iVar9 == 0) && (arg_8h == *0x49af44)) && (var_4h == *0x49af5c)) {\n        *0x49af44 = NULL;\n    }\n    *piVar5 = var_4h;\n    return piVar13 + 1;\n}\n",
        "token_count": 2102
    },
    "00411e7f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00411e7f(uint32_t *arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    uint32_t *puVar4;\n    uint32_t *puVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    uint32_t *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    int32_t in_FS_OFFSET;\n    uint lpBuffer;\n    int16_t *var_1ch;\n    uint var_ch;\n    int32_t var_8h;\n    uint32_t *var_4h;\n    \n    puVar4 = arg_8h;\n    pcVar3 = _sym.imp.KERNEL32.dll_InterlockedExchange;\n    puVar8 = arg_8h[2];\n    if ((puVar8 & 3) != 0) {\n        return 0;\n    }\n    var_4h = *(*(in_FS_OFFSET + 0x18) + 8);\n    if ((var_4h <= puVar8) && (puVar8 < *(*(in_FS_OFFSET + 0x18) + 4))) {\n        return 0;\n    }\n    puVar1 = arg_8h + 3;\n    if (*puVar1 == 0xffffffff) {\n        return 1;\n    }\n    uVar10 = 0;\n    arg_8h = NULL;\n    puVar5 = puVar8;\n    do {\n        if ((*puVar5 != 0xffffffff) && (uVar10 <= *puVar5)) {\n            return 0;\n        }\n        if (puVar5[1] != 0) {\n            arg_8h = arg_8h + 1;\n        }\n        uVar10 = uVar10 + 1;\n        puVar5 = puVar5 + 3;\n    } while (uVar10 <= *puVar1);\n    if ((arg_8h != NULL) && ((puVar1 = puVar4[-2],  puVar1 < var_4h || (puVar4 <= puVar1)))) {\n        return 0;\n    }\n    uVar10 = puVar8 & 0xfffff000;\n    iVar12 = 0;\n    if (0 < *0x499a98) {\n        do {\n            if (*(iVar12 * 4 + 0x499aa0) == uVar10) {\n                if (iVar12 < 1) {\n                    return 1;\n                }\n                iVar7 = (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x499ae0, 1);\n                if (iVar7 != 0) {\n                    return 1;\n                }\n                if (*(iVar12 * 4 + 0x499aa0) == uVar10) goto code_r0x0041207a;\n                iVar12 = *0x499a98 + -1;\n                if (iVar12 < 0) goto code_r0x00412068;\n                goto code_r0x00412058;\n            }\n            iVar12 = iVar12 + 1;\n        } while (iVar12 < *0x499a98);\n    }\n    iVar12 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(puVar8, &lpBuffer, 0x1c);\n    if (iVar12 == 0) {\n        return 0xffffffff;\n    }\n    if (var_8h != 0x1000000) {\n        return 0xffffffff;\n    }\n    if ((var_ch & 0xcc) != 0) {\n        if (((*var_1ch != 0x5a4d) || (piVar6 = *(var_1ch + 0x1e) + var_1ch,  *piVar6 != 0x4550)) ||\n           (*(piVar6 + 6) != 0x10b)) {\n            return 0xffffffff;\n        }\n        uVar9 = *(piVar6 + 5);\n        if (*(piVar6 + 6) == 0) {\n            return 0xffffffff;\n        }\n        uVar2 = *(piVar6 + uVar9 + 0x24);\n        if (((uVar2 <= puVar8 - var_1ch) && (puVar8 - var_1ch < *(piVar6 + uVar9 + 0x20) + uVar2)) &&\n           ((*(piVar6 + uVar9 + 0x3f) & 0x80) != 0)) {\n            return 0;\n        }\n    }\n    iVar7 = (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x499ae0, 1);\n    iVar12 = *0x499a98;\n    if (iVar7 != 0) {\n        return 1;\n    }\n    iVar7 = *0x499a98;\n    if (0 < *0x499a98) {\n        puVar8 = *0x499a98 * 4 + 0x499a9c;\n        do {\n            if (*puVar8 == uVar10) break;\n            iVar7 = iVar7 + -1;\n            puVar8 = puVar8 + -1;\n        } while (0 < iVar7);\n    }\n    if (iVar7 == 0) {\n        iVar7 = 0xf;\n        if (*0x499a98 < 0x10) {\n            iVar7 = *0x499a98;\n        }\n        iVar11 = 0;\n        if (-1 < iVar7) {\n            do {\n                puVar8 = iVar11 * 4 + 0x499aa0;\n                uVar9 = *puVar8;\n                iVar11 = iVar11 + 1;\n                *puVar8 = uVar10;\n                uVar10 = uVar9;\n            } while (iVar11 <= iVar7);\n        }\n        if (iVar12 < 0x10) {\n            *0x499a98 = iVar12 + 1;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x499ae0, 0);\n    return 1;\n    while (iVar12 = iVar12 + -1,  -1 < iVar12) {\ncode_r0x00412058:\n        if (*(iVar12 * 4 + 0x499aa0) == uVar10) break;\n    }\n    if (iVar12 < 0) {\ncode_r0x00412068:\n        if (*0x499a98 < 0x10) {\n            *0x499a98 = *0x499a98 + 1;\n        }\n        iVar12 = *0x499a98 + -1;\n    }\n    else if (iVar12 == 0) goto code_r0x00412092;\ncode_r0x0041207a:\n    iVar7 = 0;\n    if (-1 < iVar12) {\n        do {\n            puVar8 = iVar7 * 4 + 0x499aa0;\n            uVar9 = *puVar8;\n            iVar7 = iVar7 + 1;\n            *puVar8 = uVar10;\n            uVar10 = uVar9;\n        } while (iVar7 <= iVar12);\n    }\ncode_r0x00412092:\n    (*pcVar3)(0x499ae0, 0);\n    return 1;\n}\n",
        "token_count": 1637
    },
    "004120a8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.004120a8(uint32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint8_t *unaff_ESI;\n    uint8_t *unaff_EDI;\n    \n    iVar1 = *(unaff_ESI + 4);\n    if ((iVar1 != 0) && (*(iVar1 + 8) != '\\0')) {\n        if ((iVar1 != *(unaff_EDI + 4)) && (iVar1 = fcn.00413b40(iVar1 + 8, *(unaff_EDI + 4) + 8),  iVar1 != 0)) {\n            return 0;\n        }\n        if (((((*unaff_EDI & 2) != 0) && ((*unaff_ESI & 8) == 0)) || (((*param_1 & 1) != 0 && ((*unaff_ESI & 1) == 0))))\n           || (((*param_1 & 2) != 0 && ((*unaff_ESI & 2) == 0)))) {\n            return 0;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 244
    },
    "00412115": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00412115(uint arg_8h, uint noname_1, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040daac(0x473348, 0x10);\n    iVar1 = *(unaff_EBP + 8);\n    iVar5 = *(iVar1 + 8);\n    *(unaff_EBP + -0x1c) = iVar5;\n    iVar2 = fcn.00412cd5();\n    *(iVar2 + 0x84) = *(iVar2 + 0x84) + 1;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = *(unaff_EBP + 0x10);\n    while (iVar5 != *(unaff_EBP + 0x14)) {\n        if ((iVar5 < 0) || (*(iVar2 + 4) <= iVar5)) {\n            fcn.00413004();\n        }\n        iVar3 = iVar5 * 8;\n        piVar4 = *(iVar2 + 8) + iVar3;\n        iVar5 = *piVar4;\n        *(unaff_EBP + -0x20) = iVar5;\n        *(unaff_EBP + -4) = 1;\n        if (piVar4[1] != 0) {\n            *(iVar1 + 8) = iVar5;\n            fcn.00413040(*(*(iVar2 + 8) + 4 + iVar3), iVar1, 0x103);\n        }\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x1c) = iVar5;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004121c8();\n    if (iVar5 != *(unaff_EBP + 0x14)) {\n        fcn.00413004();\n    }\n    *(iVar1 + 8) = iVar5;\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 527
    },
    "004121c8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.004121c8(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00412cd5();\n    if (0 < *(iVar1 + 0x84)) {\n        iVar1 = fcn.00412cd5();\n        *(iVar1 + 0x84) = *(iVar1 + 0x84) + -1;\n    }\n    return;\n}\n",
        "token_count": 89
    },
    "00412258": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00412258(int32_t *param_1)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    \n    iVar1 = *param_1 + in_EAX;\n    if (-1 < param_1[1]) {\n        iVar1 = iVar1 + *(*(param_1[1] + in_EAX) + param_1[2]) + param_1[1];\n    }\n    return iVar1;\n}\n",
        "token_count": 104
    },
    "004125c1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid fcn.004125c1(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_20h;\n    \n    *(unaff_EDI + -4) = *(unaff_EBP + -0x38);\n    fcn.0040dff1(*(unaff_EBP + -0x3c));\n    iVar1 = fcn.00412cd5();\n    *(iVar1 + 0x7c) = *(unaff_EBP + -0x40);\n    iVar1 = fcn.00412cd5();\n    *(iVar1 + 0x80) = *(unaff_EBP + -0x44);\n    if ((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&\n        ((unaff_ESI[5] == 0x19930520 || (unaff_ESI[5] == 0x19930521)))) &&\n       ((*(unaff_EBP + -0x48) == 0 && (*(unaff_EBP + -0x20) != 0)))) {\n        iVar1 = fcn.0040dfd0(unaff_ESI[6]);\n        if (iVar1 != 0) {\n            fcn.0040e142();\n            fcn.00412213(unaff_ESI);\n        }\n    }\n    return;\n}\n",
        "token_count": 358
    },
    "00412630": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00412630(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint arg_ch_00;\n    uint uVar5;\n    uint8_t *extraout_ECX;\n    int32_t *extraout_EDX;\n    int32_t unaff_EBP;\n    int32_t *arg_8h_00;\n    uint var_4h;\n    \n    fcn.0040daac(0x4733a8, 8);\n    puVar1 = *(unaff_EBP + 0xc);\n    iVar4 = *(unaff_EBP + 8);\n    if (((puVar1[1] == 0) || (*(puVar1[1] + 8) == '\\0')) || ((puVar1[2] == 0 && ((*(puVar1 + 3) & 0x80) == 0))))\n    goto code_r0x0041279a;\n    uVar2 = *puVar1;\n    arg_8h_00 = extraout_EDX;\n    if (-1 < uVar2) {\n        arg_8h_00 = puVar1[2] + 0xc + extraout_EDX;\n    }\n    *(unaff_EBP + -4) = 0;\n    uVar5 = *(iVar4 + 0x18);\n    if ((uVar2 & 8) == 0) {\n        if ((*extraout_ECX & 1) == 0) {\n            if (*(extraout_ECX + 0x18) == 0) {\n                iVar4 = fcn.00418447(uVar5, 1);\n                if ((iVar4 == 0) || (iVar4 = fcn.00418463(arg_8h_00, 1),  iVar4 == 0)) {\ncode_r0x00412791:\n                    fcn.00413004();\n                }\n                else {\n                    uVar5 = *(extraout_ECX + 0x14);\n                    arg_ch_00 = fcn.00412258();\n                    fcn.0040ea50(arg_8h_00, arg_ch_00, uVar5);\n                }\n            }\n            else {\n                iVar4 = fcn.00418447(uVar5, 1);\n                if (((iVar4 == 0) || (iVar4 = fcn.00418463(arg_8h_00, 1),  iVar4 == 0)) ||\n                   (iVar4 = fcn.0041847f(*(extraout_ECX + 0x18)),  iVar4 == 0)) goto code_r0x00412791;\n                if ((*extraout_ECX & 4) == 0) {\n                    uVar5 = fcn.00412258();\n                    fcn.0040dcca(arg_8h_00, *(extraout_ECX + 0x18), uVar5);\n                }\n                else {\n                    uVar5 = fcn.00412258(1);\n                    fcn.0040dcd1(arg_8h_00, *(extraout_ECX + 0x18), uVar5);\n                }\n            }\n        }\n        else {\n            iVar3 = fcn.00418447(uVar5, 1);\n            if ((iVar3 == 0) || (iVar3 = fcn.00418463(arg_8h_00, 1),  iVar3 == 0)) goto code_r0x00412791;\n            fcn.0040ea50(arg_8h_00, *(iVar4 + 0x18), *(extraout_ECX + 0x14));\n            if ((*(extraout_ECX + 0x14) == 4) && (*arg_8h_00 != 0)) goto code_r0x004126a9;\n        }\n    }\n    else {\n        iVar3 = fcn.00418447(uVar5, 1);\n        if ((iVar3 == 0) || (iVar3 = fcn.00418463(arg_8h_00, 1),  iVar3 == 0)) goto code_r0x00412791;\n        *arg_8h_00 = *(iVar4 + 0x18);\ncode_r0x004126a9:\n        iVar4 = fcn.00412258();\n        *arg_8h_00 = iVar4;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\ncode_r0x0041279a:\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 1028
    },
    "004127ac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004127ac(int32_t **arg_8h, int32_t arg_ch, uint32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t *arg_8h_00;\n    uint32_t var_14h;\n    int32_t var_10h;\n    int32_t var_4h;\n    \n    if (arg_8h == NULL) {\n        return 0;\n    }\n    arg_8h_00 = *arg_8h;\n    if ((arg_ch == 0) || (*(arg_ch + 8) == '\\0')) {\n        if ((((*arg_8h_00 != -0x1f928c9d) || (arg_8h_00[4] != 3)) ||\n            (((arg_8h_00[5] != 0x19930520 && (arg_8h_00[5] != 0x19930521)) || (arg_8h_00[7] != 0)))) ||\n           (iVar1 = fcn.00412cd5(),  *(iVar1 + 0x7c) != 0)) {\n            iVar1 = fcn.00412cd5();\n            *(iVar1 + 0x84) = *(iVar1 + 0x84) + 1;\n            return 1;\n        }\n    }\n    else if (((*arg_8h_00 == -0x1f928c9d) && (arg_8h_00[4] == 3)) &&\n            ((arg_8h_00[5] == 0x19930520 || (arg_8h_00[5] == 0x19930521)))) {\n        if (arg_8h_00[7] == 0) {\n            iVar1 = fcn.00412cd5();\n            if (*(iVar1 + 0x7c) == 0) {\n                return 0;\n            }\n            iVar1 = fcn.00412cd5();\n            arg_8h_00 = *(iVar1 + 0x7c);\n        }\n        var_14h = arg_10h | 0x80000000;\n        var_10h = arg_ch;\n        for (var_4h = **(arg_8h_00[7] + 0xc); 0 < var_4h; var_4h = var_4h + -1) {\n            iVar1 = fcn.004120a8(arg_8h_00[7]);\n            if (iVar1 != 0) {\n                iVar1 = fcn.00412cd5();\n                *(iVar1 + 0x84) = *(iVar1 + 0x84) + 1;\n                if (arg_14h == 0) {\n                    return 1;\n                }\n                fcn.00412630(arg_8h_00, &var_14h);\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 663
    },
    "004128d1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004128d1(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, int32_t arg_1ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint unaff_EBX;\n    int32_t unaff_ESI;\n    uint *unaff_EDI;\n    \n    if (in_ECX != 0) {\n        fcn.00412630(arg_8h, unaff_EBX);\n    }\n    if (arg_1ch == 0) {\n        arg_1ch = unaff_ESI;\n    }\n    fcn.0040dcd8(arg_1ch, arg_8h);\n    fcn.00412115(unaff_ESI, arg_10h, arg_14h, *unaff_EDI);\n    *(unaff_ESI + 8) = unaff_EDI[1] + 1;\n    iVar1 = fcn.0041246c(arg_8h, unaff_ESI, arg_ch, arg_14h, arg_18h, 0x100);\n    if (iVar1 != 0) {\n        fcn.0040dc93(iVar1);\n    }\n    return;\n}\n",
        "token_count": 279
    },
    "00412938": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl\nfcn.00412938(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, int32_t arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_retaddr;\n    uint in_stack_00000024;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    if ((*arg_8h != -0x7ffffffd) &&\n       (((iVar1 = fcn.00412cd5(),  *(iVar1 + 0x74) == 0 ||\n         (iVar1 = fcn.0040ddb5(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_20h, arg_24h, unaff_ESI, var_8h, var_4h, \n                               unaff_EBP, unaff_retaddr, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, arg_20h, \n                               arg_24h, in_stack_00000024),  iVar1 == 0)) &&\n        (piVar2 = fcn.0040df2e(arg_18h, arg_20h, arg_1ch, &var_4h, &var_8h),  var_4h < var_8h)))) {\n        do {\n            if (((*piVar2 <= arg_1ch) && (arg_1ch <= piVar2[1])) &&\n               ((iVar1 = *(piVar2[3] * 0x10 + piVar2[4] + -0xc),  iVar1 == 0 || (*(iVar1 + 8) == '\\0')))) {\n                fcn.004128d1(arg_8h, arg_10h, arg_14h, arg_18h, arg_20h, arg_24h);\n            }\n            var_4h = var_4h + 1;\n            piVar2 = piVar2 + 5;\n        } while (var_4h < var_8h);\n    }\n    return;\n}\n",
        "token_count": 549
    },
    "004129f6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.004129f6(int32_t *arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h, int32_t arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint var_24h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t *var_10h;\n    uint32_t var_ch;\n    int32_t *var_8h;\n    uchar auStack8 [3];\n    uint var_1h;\n    \n    var_1ch = *(arg_ch + 8);\n    _auStack8 = auStack8;\n    if ((var_1ch < -1) || (*(arg_18h + 4) <= var_1ch)) {\n        fcn.00413004();\n    }\n    if (*arg_8h == -0x1f928c9d) {\n        if ((arg_8h[4] == 3) && (((arg_8h[5] == 0x19930520 || (arg_8h[5] == 0x19930521)) && (arg_8h[7] == 0)))) {\n            iVar2 = fcn.00412cd5();\n            if (*(iVar2 + 0x7c) == 0) {\n                return;\n            }\n            iVar2 = fcn.00412cd5();\n            arg_8h = *(iVar2 + 0x7c);\n            iVar2 = fcn.00412cd5();\n            arg_10h = *(iVar2 + 0x80);\n            _auStack8 = CONCAT13(1, auStack8);\n            iVar2 = fcn.00418447(arg_8h, 1);\n            if (iVar2 == 0) {\n                fcn.00413004();\n            }\n            if (*arg_8h != -0x1f928c9d) goto code_r0x00412bcf;\n            if (((arg_8h[4] == 3) && ((arg_8h[5] == 0x19930520 || (arg_8h[5] == 0x19930521)))) && (arg_8h[7] == 0)) {\n                fcn.00413004();\n            }\n        }\n        iVar2 = var_1ch;\n        if (((*arg_8h == -0x1f928c9d) && (arg_8h[4] == 3)) && ((arg_8h[5] == 0x19930520 || (arg_8h[5] == 0x19930521))))\n        {\n            piVar3 = fcn.0040df2e(arg_18h, arg_20h, var_1ch, &var_ch, &var_20h);\n            var_8h = piVar3;\n            if (var_ch < var_20h) {\n                do {\n                    if ((*piVar3 == iVar2 || *piVar3 < iVar2) && (iVar2 <= piVar3[1])) {\n                        var_8h = piVar3;\n                        for (var_18h = piVar3[3]; 0 < var_18h; var_18h = var_18h + -1) {\n                            var_10h = *(arg_8h[7] + 0xc);\n                            for (var_14h = *var_10h; var_10h = var_10h + 1,  0 < var_14h; var_14h = var_14h + -1) {\n                                iVar2 = fcn.004120a8(arg_8h[7]);\n                                piVar3 = var_8h;\n                                if (iVar2 != 0) {\n                                    fcn.004128d1(arg_8h, arg_10h, arg_14h, arg_18h, arg_20h, arg_24h);\n                                    goto code_r0x00412ba2;\n                                }\n                            }\n                        }\n                    }\ncode_r0x00412ba2:\n                    var_ch = var_ch + 1;\n                    piVar3 = piVar3 + 5;\n                    iVar2 = var_1ch;\n                    var_8h = piVar3;\n                } while (var_ch < var_20h);\n            }\n            if (arg_1ch == '\\0') {\n                return;\n            }\n            fcn.00412213(arg_8h);\n            return;\n        }\n    }\ncode_r0x00412bcf:\n    if (arg_1ch == '\\0') {\n        fcn.00412938(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, var_1ch, arg_20h, arg_24h);\n        return;\n    }\n    fcn.0040daac(0x473400, 8);\n    iVar2 = fcn.00412cd5();\n    if (*(iVar2 + 0x6c) != 0) {\n        _auStack8 = 0;\n        iVar2 = fcn.00412cd5();\n        (**(iVar2 + 0x6c))();\n        _auStack8 = 0xffffffff;\n    }\n    fcn.0041308c(10);\n    fcn.0041c293(0x16);\n    fcn.0040f467(3);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 1283
    },
    "00412bfa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.00412bfa(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint32_t *arg_18h, int32_t arg_1ch, uint arg_20h\n            , uint32_t arg_24h)\n\n{\n    uint uVar1;\n    \n    if ((*arg_18h & 0x1fffffff) != 0x19930520) {\n        fcn.00413004();\n    }\n    if ((*(arg_8h + 1) & 0x66) == 0) {\n        if (arg_18h[3] != 0) {\n            if (((*arg_8h == -0x1f928c9d) && (0x19930520 < arg_8h[5])) && (*(arg_8h[7] + 8) != NULL)) {\n                uVar1 = (**(arg_8h[7] + 8))(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, arg_20h, arg_24h & 0xff)\n                ;\n                return uVar1;\n            }\n            fcn.004129f6(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_24h, arg_1ch, arg_20h);\n        }\n    }\n    else if ((arg_18h[1] != 0) && (arg_1ch == 0)) {\n        fcn.00412115(arg_ch, arg_14h, arg_18h, 0xffffffff);\n    }\n    return 1;\n}\n",
        "token_count": 377
    },
    "00412ca5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00412ca5(void)\n\n{\n    int32_t arg_8h;\n    code *pcVar1;\n    int32_t *piVar2;\n    \n    if (*0x496bf0 != -1) {\n        (**0x499af0)(*0x496bf0);\n        *0x496bf0 = -1;\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_DeleteCriticalSection;\n    piVar2 = 0x496ac8;\n    do {\n        arg_8h = *piVar2;\n        if ((arg_8h != 0) && (piVar2[1] != 1)) {\n            (*pcVar1)(arg_8h);\n            fcn.0040d958(arg_8h);\n            *piVar2 = 0;\n        }\n        piVar2 = piVar2 + 2;\n    } while (piVar2 < 0x496be8);\n    piVar2 = 0x496ac8;\n    do {\n        if ((*piVar2 != 0) && (piVar2[1] == 1)) {\n            (*pcVar1)(*piVar2);\n        }\n        piVar2 = piVar2 + 2;\n    } while (piVar2 < 0x496be8);\n    return;\n}\n",
        "token_count": 286
    },
    "00412ec8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00412ec8(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint uVar4;\n    \n    iVar2 = fcn.00410c31();\n    if (iVar2 == 0) {\n        fcn.00412ca5();\n        return 0;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"kernel32.dll\");\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar2 != 0) {\n        *0x499ae4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"FlsAlloc\");\n        *0x499ae8 = (*pcVar1)(iVar2, \"FlsGetValue\");\n        *0x499aec = (*pcVar1)(iVar2, \"FlsSetValue\");\n        *0x499af0 = (*pcVar1)(iVar2, \"FlsFree\");\n        if (*0x499ae8 == 0) {\n            *0x499ae8 = _sym.imp.KERNEL32.dll_TlsGetValue;\n            *0x499aec = _sym.imp.KERNEL32.dll_TlsSetValue;\n            *0x499ae4 = 0x412c9c;\n            *0x499af0 = _sym.imp.KERNEL32.dll_TlsFree;\n        }\n    }\n    *0x496bf0 = (**0x499ae4)(fcn.00412d46);\n    if (((*0x496bf0 != -1) && (puVar3 = fcn.0040f0e4(1, 0x8c),  puVar3 != NULL)) &&\n       (iVar2 = (**0x499aec)(*0x496bf0, puVar3),  iVar2 != 0)) {\n        puVar3[0x15] = 0x496c98;\n        puVar3[5] = 1;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        puVar3[1] = 0xffffffff;\n        *puVar3 = uVar4;\n        return 1;\n    }\n    fcn.00412ca5();\n    return 0;\n}\n",
        "token_count": 487
    },
    "00413292": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00413292(int32_t arg_8h, uint ExceptionInfo)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t *piVar7;\n    int32_t iVar8;\n    uint var_4h;\n    \n    iVar4 = fcn.00412cd5();\n    piVar1 = *(iVar4 + 0x54);\n    piVar7 = piVar1;\n    do {\n        if (*piVar7 == arg_8h) break;\n        piVar7 = piVar7 + 3;\n    } while (piVar7 < piVar1 + *0x496d1c * 3);\n    if ((piVar1 + *0x496d1c * 3 <= piVar7) || (*piVar7 != arg_8h)) {\n        piVar7 = NULL;\n    }\n    if ((piVar7 == NULL) || (pcVar2 = piVar7[2],  pcVar2 == NULL)) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_UnhandledExceptionFilter)(ExceptionInfo);\n    }\n    else if (pcVar2 == 0x5) {\n        piVar7[2] = 0;\n        uVar5 = 1;\n    }\n    else {\n        if (pcVar2 != 0x1) {\n            uVar5 = *(iVar4 + 0x58);\n            *(iVar4 + 0x58) = ExceptionInfo;\n            if (piVar7[1] == 8) {\n                if (*0x496d10 < *0x496d14 + *0x496d10) {\n                    iVar6 = *0x496d10 * 0xc;\n                    iVar8 = *0x496d10;\n                    do {\n                        *(iVar6 + 8 + *(iVar4 + 0x54)) = 0;\n                        iVar8 = iVar8 + 1;\n                        iVar6 = iVar6 + 0xc;\n                    } while (iVar8 < *0x496d14 + *0x496d10);\n                }\n                iVar8 = *piVar7;\n                uVar3 = *(iVar4 + 0x5c);\n                if (iVar8 == -0x3fffff72) {\n                    *(iVar4 + 0x5c) = 0x83;\n                }\n                else if (iVar8 == -0x3fffff70) {\n                    *(iVar4 + 0x5c) = 0x81;\n                }\n                else if (iVar8 == -0x3fffff6f) {\n                    *(iVar4 + 0x5c) = 0x84;\n                }\n                else if (iVar8 == -0x3fffff6d) {\n                    *(iVar4 + 0x5c) = 0x85;\n                }\n                else if (iVar8 == -0x3fffff73) {\n                    *(iVar4 + 0x5c) = 0x82;\n                }\n                else if (iVar8 == -0x3fffff71) {\n                    *(iVar4 + 0x5c) = 0x86;\n                }\n                else if (iVar8 == -0x3fffff6e) {\n                    *(iVar4 + 0x5c) = 0x8a;\n                }\n                (*pcVar2)(8, *(iVar4 + 0x5c));\n                *(iVar4 + 0x5c) = uVar3;\n            }\n            else {\n                piVar7[2] = 0;\n                (*pcVar2)(piVar7[1]);\n            }\n            *(iVar4 + 0x58) = uVar5;\n        }\n        uVar5 = 0xffffffff;\n    }\n    return uVar5;\n}\n",
        "token_count": 853
    },
    "00413535": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00413535(uint8_t **arg_8h, int32_t *arg_ch)\n\n{\n    bool bVar1;\n    bool bVar2;\n    uint8_t *in_EAX;\n    uint8_t *puVar3;\n    uint8_t *puVar4;\n    uint8_t uVar5;\n    uint8_t *in_ECX;\n    uint32_t uVar6;\n    int32_t *unaff_ESI;\n    uint var_4h;\n    \n    bVar1 = false;\n    *unaff_ESI = 0;\n    *arg_ch = 1;\n    if (arg_8h != NULL) {\n        *arg_8h = in_ECX;\n        arg_8h = arg_8h + 1;\n    }\n    do {\n        if (*in_EAX == 0x22) {\n            bVar1 = !bVar1;\n            puVar3 = in_EAX + 1;\n            uVar5 = 0x22;\n        }\n        else {\n            *unaff_ESI = *unaff_ESI + 1;\n            if (in_ECX != NULL) {\n                *in_ECX = *in_EAX;\n                in_ECX = in_ECX + 1;\n            }\n            uVar5 = *in_EAX;\n            puVar3 = in_EAX + 1;\n            if ((*(uVar5 + 0x49af81) & 4) != 0) {\n                *unaff_ESI = *unaff_ESI + 1;\n                if (in_ECX != NULL) {\n                    *in_ECX = *puVar3;\n                    in_ECX = in_ECX + 1;\n                }\n                puVar3 = in_EAX + 2;\n            }\n            if (uVar5 == 0) {\n                puVar3 = puVar3 + -1;\n                goto code_r0x004135ae;\n            }\n        }\n        in_EAX = puVar3;\n    } while ((bVar1) || ((uVar5 != 0x20 && (uVar5 != 9))));\n    if (in_ECX != NULL) {\n        in_ECX[-1] = 0;\n    }\ncode_r0x004135ae:\n    bVar1 = false;\n    while (*puVar3 != 0) {\n        for (; (*puVar3 == 0x20 || (*puVar3 == 9)); puVar3 = puVar3 + 1) {\n        }\n        if (*puVar3 == 0) break;\n        if (arg_8h != NULL) {\n            *arg_8h = in_ECX;\n            arg_8h = arg_8h + 1;\n        }\n        *arg_ch = *arg_ch + 1;\n        while( true ) {\n            bVar2 = true;\n            uVar6 = 0;\n            for (; *puVar3 == 0x5c; puVar3 = puVar3 + 1) {\n                uVar6 = uVar6 + 1;\n            }\n            if (*puVar3 == 0x22) {\n                puVar4 = puVar3;\n                if ((uVar6 & 1) == 0) {\n                    if ((!bVar1) || (puVar4 = puVar3 + 1,  *puVar4 != 0x22)) {\n                        bVar2 = false;\n                        puVar4 = puVar3;\n                    }\n                    bVar1 = !bVar1;\n                }\n                uVar6 = uVar6 >> 1;\n                puVar3 = puVar4;\n            }\n            for (; uVar6 != 0; uVar6 = uVar6 - 1) {\n                if (in_ECX != NULL) {\n                    *in_ECX = 0x5c;\n                    in_ECX = in_ECX + 1;\n                }\n                *unaff_ESI = *unaff_ESI + 1;\n            }\n            uVar5 = *puVar3;\n            if ((uVar5 == 0) || ((!bVar1 && ((uVar5 == 0x20 || (uVar5 == 9)))))) break;\n            if (bVar2) {\n                if (in_ECX == NULL) {\n                    if ((*(uVar5 + 0x49af81) & 4) != 0) {\n                        puVar3 = puVar3 + 1;\n                        *unaff_ESI = *unaff_ESI + 1;\n                    }\n                }\n                else {\n                    if ((*(uVar5 + 0x49af81) & 4) != 0) {\n                        *in_ECX = uVar5;\n                        in_ECX = in_ECX + 1;\n                        puVar3 = puVar3 + 1;\n                        *unaff_ESI = *unaff_ESI + 1;\n                    }\n                    *in_ECX = *puVar3;\n                    in_ECX = in_ECX + 1;\n                }\n                *unaff_ESI = *unaff_ESI + 1;\n            }\n            puVar3 = puVar3 + 1;\n        }\n        if (in_ECX != NULL) {\n            *in_ECX = 0;\n            in_ECX = in_ECX + 1;\n        }\n        *unaff_ESI = *unaff_ESI + 1;\n    }\n    if (arg_8h != NULL) {\n        *arg_8h = NULL;\n    }\n    *arg_ch = *arg_ch + 1;\n    return;\n}\n",
        "token_count": 1211
    },
    "00413865": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00413865(void)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    uint *puVar3;\n    uint uVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int32_t *piVar9;\n    uchar auStack68 [46];\n    int16_t iStack22;\n    int32_t *piStack20;\n    \n    puVar3 = fcn.0040d946(0x480);\n    if (puVar3 == NULL) {\n        uVar4 = 0xffffffff;\n    }\n    else {\n        *0x49ae2c = 0x20;\n        *0x49ae40 = puVar3;\n        for (; puVar3 < *0x49ae40 + 0x120; puVar3 = puVar3 + 9) {\n            *puVar3 = 0xffffffff;\n            puVar3[2] = 0;\n            *(puVar3 + 1) = 0;\n            *(puVar3 + 5) = 10;\n        }\n        (*_sym.imp.KERNEL32.dll_GetStartupInfoA)(auStack68);\n        if ((iStack22 != 0) && (piStack20 != NULL)) {\n            iVar8 = *piStack20;\n            piStack20 = piStack20 + 1;\n            piVar9 = iVar8 + piStack20;\n            if (0x7ff < iVar8) {\n                iVar8 = 0x800;\n            }\n            iVar6 = iVar8;\n            if (*0x49ae2c < iVar8) {\n                puVar3 = 0x49ae44;\n                do {\n                    puVar5 = fcn.0040d946(0x480);\n                    iVar6 = *0x49ae2c;\n                    if (puVar5 == NULL) break;\n                    *0x49ae2c = *0x49ae2c + 0x20;\n                    *puVar3 = puVar5;\n                    puVar2 = puVar5;\n                    for (; puVar5 < puVar2 + 0x120; puVar5 = puVar5 + 9) {\n                        *puVar5 = 0xffffffff;\n                        puVar5[2] = 0;\n                        *(puVar5 + 1) = 0;\n                        *(puVar5 + 5) = 10;\n                        puVar2 = *puVar3;\n                    }\n                    puVar3 = puVar3 + 1;\n                    iVar6 = iVar8;\n                } while (*0x49ae2c < iVar8);\n            }\n            uVar7 = 0;\n            if (0 < iVar6) {\n                do {\n                    if (((*piVar9 != -1) && ((*piStack20 & 1) != 0)) &&\n                       (((*piStack20 & 8) != 0 || (iVar8 = (*_sym.imp.KERNEL32.dll_GetFileType)(*piVar9),  iVar8 != 0)))\n                       ) {\n                        piVar1 = *((uVar7 >> 5) * 4 + 0x49ae40) + (uVar7 & 0x1f) * 0x24;\n                        *piVar1 = *piVar9;\n                        *(piVar1 + 1) = *piStack20;\n                        iVar8 = fcn.004183bc(piVar1 + 3, 4000);\n                        if (iVar8 == 0) {\n                            return 0xffffffff;\n                        }\n                        piVar1[2] = piVar1[2] + 1;\n                    }\n                    piVar9 = piVar9 + 1;\n                    uVar7 = uVar7 + 1;\n                    piStack20 = piStack20 + 1;\n                } while (uVar7 < iVar6);\n            }\n        }\n        iVar8 = 0;\n        do {\n            piVar9 = *0x49ae40 + iVar8 * 9;\n            if (*piVar9 == -1) {\n                *(piVar9 + 1) = 0x81;\n                if (iVar8 == 0) {\n                    iVar6 = -10;\n                }\n                else {\n                    iVar6 = -0xb - (iVar8 != 1);\n                }\n                iVar6 = (*_sym.imp.KERNEL32.dll_GetStdHandle)(iVar6);\n                if ((iVar6 == -1) || (uVar7 = (*_sym.imp.KERNEL32.dll_GetFileType)(iVar6),  uVar7 == 0)) {\n                    *(piVar9 + 1) = *(piVar9 + 1) | 0x40;\n                }\n                else {\n                    *piVar9 = iVar6;\n                    if ((uVar7 & 0xff) == 2) {\n                        *(piVar9 + 1) = *(piVar9 + 1) | 0x40;\n                    }\n                    else if ((uVar7 & 0xff) == 3) {\n                        *(piVar9 + 1) = *(piVar9 + 1) | 8;\n                    }\n                    iVar6 = fcn.004183bc(piVar9 + 3, 4000);\n                    if (iVar6 == 0) {\n                        return 0xffffffff;\n                    }\n                    piVar9[2] = piVar9[2] + 1;\n                }\n            }\n            else {\n                *(piVar9 + 1) = *(piVar9 + 1) | 0x80;\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 3);\n        (*_sym.imp.KERNEL32.dll_SetHandleCount)(*0x49ae2c);\n        uVar4 = 0;\n    }\n    return uVar4;\n}\n",
        "token_count": 1267
    },
    "00413f73": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00413f73(ushort *param_1, int32_t param_2)\n\n{\n    int32_t *in_EAX;\n    int32_t unaff_EDI;\n    \n    if (((*(unaff_EDI + 0xc) & 0x40) == 0) || (*(unaff_EDI + 8) != 0)) {\n        do {\n            if (param_2 < 1) {\n                return;\n            }\n            param_2 = param_2 + -1;\n            fcn.00413f29(*param_1);\n            param_1 = param_1 + 1;\n        } while (*in_EAX != -1);\n    }\n    else {\n        *in_EAX = *in_EAX + param_2;\n    }\n    return;\n}\n",
        "token_count": 177
    },
    "00414925": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00414925(int32_t param_1)\n\n{\n    int32_t *in_EAX;\n    int32_t unaff_EDI;\n    \n    if (((*(unaff_EDI + 0xc) & 0x40) == 0) || (*(unaff_EDI + 8) != 0)) {\n        do {\n            if (param_1 < 1) {\n                return;\n            }\n            param_1 = param_1 + -1;\n            fcn.004148ce();\n        } while (*in_EAX != -1);\n    }\n    else {\n        *in_EAX = *in_EAX + param_1;\n    }\n    return;\n}\n",
        "token_count": 149
    },
    "0041695a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041695a(int32_t arg_8h, char *arg_ch)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    char *arg_8h_00;\n    int32_t iVar3;\n    \n    arg_8h_00 = arg_ch;\n    fcn.0040e620(arg_8h, 0, 0x90);\n    if (*arg_ch != '\\0') {\n        if ((*arg_ch != '.') || (arg_ch[1] == '\\0')) {\n            arg_ch = NULL;\n            do {\n                uVar2 = fcn.00416120(arg_8h_00, 0x473c78);\n                if (uVar2 == 0) {\n                    return 0xffffffff;\n                }\n                cVar1 = arg_8h_00[uVar2];\n                if (arg_ch == NULL) {\n                    if (0x3f < uVar2) {\n                        return 0xffffffff;\n                    }\n                    iVar3 = arg_8h;\n                    if (cVar1 == '.') {\n                        return 0xffffffff;\n                    }\n                }\n                else if (arg_ch == 0x1) {\n                    if (0x3f < uVar2) {\n                        return 0xffffffff;\n                    }\n                    if (cVar1 == '_') {\n                        return 0xffffffff;\n                    }\n                    iVar3 = arg_8h + 0x40;\n                }\n                else {\n                    if (arg_ch != 0x2) {\n                        return 0xffffffff;\n                    }\n                    if (0xf < uVar2) {\n                        return 0xffffffff;\n                    }\n                    if ((cVar1 != '\\0') && (cVar1 != ',')) {\n                        return 0xffffffff;\n                    }\n                    iVar3 = arg_8h + 0x80;\n                }\n                fcn.004185b0(iVar3, arg_8h_00, uVar2);\n                if ((cVar1 == ',') || (cVar1 == '\\0')) {\n                    return 0;\n                }\n                arg_ch = arg_ch + 1;\n                arg_8h_00 = arg_8h_00 + uVar2 + 1;\n            } while( true );\n        }\n        fcn.004185b0(arg_8h + 0x80, arg_ch + 1, 0xf);\n        *(arg_8h + 0x8f) = 0;\n    }\n    return 0;\n}\n",
        "token_count": 539
    },
    "00416a36": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00416a36(uint param_1, int32_t param_2)\n\n{\n    fcn.00415f50(param_1, param_2);\n    if (*(param_2 + 0x40) != '\\0') {\n        fcn.00416936(param_1, 2, 0x473c80, param_2 + 0x40);\n    }\n    if (*(param_2 + 0x80) != '\\0') {\n        fcn.00416936(param_1, 2, 0x473c7c, param_2 + 0x80);\n    }\n    return;\n}\n",
        "token_count": 141
    },
    "00416b7e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00416b7e(char *arg_8h, uchar *arg_ch, ushort *arg_10h, uint *arg_14h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint var_94h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    if (arg_8h != NULL) {\n        if ((*arg_8h == 'C') && (arg_8h[1] == '\\0')) {\n            *arg_ch = 0x43;\n            arg_ch[1] = 0;\n            if (arg_10h != NULL) {\n                *arg_10h = 0;\n                arg_10h[1] = 0;\n                arg_10h[2] = 0;\n            }\n            if (arg_14h != NULL) {\n                *arg_14h = 0;\n            }\n        }\n        else {\n            uVar1 = fcn.0040e9c0(arg_8h);\n            if ((0x81 < uVar1) ||\n               ((iVar2 = fcn.00413b40(0x496e78, arg_8h),  iVar2 != 0 &&\n                (iVar2 = fcn.00413b40(0x496df0, arg_8h),  iVar2 != 0)))) {\n                iVar2 = fcn.0041695a(&var_94h, arg_8h);\n                if ((iVar2 != 0) || (iVar2 = fcn.0041b4c5(&var_94h, 0x499c34, &var_94h),  iVar2 == 0))\n                goto code_r0x00416ccf;\n                *0x499c3c = *0x499c38;\n                fcn.00416a36(0x496e78, &var_94h);\n                if ((*arg_8h == '\\0') || (uVar1 = fcn.0040e9c0(arg_8h),  0x81 < uVar1)) {\n                    arg_8h = 0x469144;\n                }\n                *0x496e72 = 0;\n                fcn.004185b0(0x496df0, arg_8h, 0x82);\n            }\n            if (arg_10h != NULL) {\n                fcn.0040e680(arg_10h, 0x499c34, 6);\n            }\n            if (arg_14h != NULL) {\n                fcn.0040e680(arg_14h, 0x499c3c, 4);\n            }\n            fcn.00415f50(arg_ch, 0x496e78);\n        }\n    }\ncode_r0x00416ccf:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 637
    },
    "00416cda": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid fcn.00416cda(uint param_1)\n\n{\n    uint32_t *puVar1;\n    int32_t arg_8h;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint unaff_EBX;\n    int32_t iVar9;\n    int32_t unaff_ESI;\n    uint unaff_EDI;\n    uint in_stack_fffffe3c;\n    uint in_stack_fffffe40;\n    int32_t in_stack_fffffe44;\n    uint in_stack_fffffe48;\n    uint32_t arg_1ch;\n    uint32_t in_stack_fffffe50;\n    int32_t iStack420;\n    int32_t iStack404;\n    int32_t iStack400;\n    uchar uStack396;\n    uint8_t auStack395 [255];\n    uchar auStack140 [132];\n    uint uStack8;\n    \n    uStack8 = *0x496830;\n    iVar4 = fcn.00416b7e(param_1, auStack140, &stack0xfffffe50, &iStack404);\n    if (iVar4 != 0) {\n        iVar9 = unaff_ESI * 0xc;\n        iVar4 = fcn.00413b40(auStack140, *(iVar9 + 0x496f04));\n        if (iVar4 != 0) {\n            iVar4 = fcn.0040e9c0(auStack140);\n            iVar4 = fcn.0040d946(iVar4 + 1);\n            if (iVar4 != 0) {\n                arg_8h = *(iVar9 + 0x496f04);\n                puVar1 = unaff_ESI * 4 + 0x499c0c;\n                arg_1ch = *puVar1;\n                iStack400 = unaff_ESI * 6 + 0x499d6c;\n                fcn.0040e680(&stack0xfffffe3c, iStack400, 6);\n                iVar3 = *0x499c24;\n                uVar5 = fcn.00415f50(iVar4, auStack140);\n                *(iVar9 + 0x496f04) = uVar5;\n                *puVar1 = in_stack_fffffe50 & 0xffff;\n                fcn.0040e680(iStack400, &stack0xfffffe50, 6);\n                uVar8 = *0x496d60;\n                if (unaff_ESI == 2) {\n                    iStack400 = 0;\n                    *0x499c24 = iStack404;\n                    iStack420 = *0x496dec;\n                    piVar6 = 0x496dc8;\n                    iVar7 = *0x496de8;\n                    do {\n                        if (iStack404 == *piVar6) {\n                            if (iStack400 != 0) {\n                                iVar2 = iStack400 * 8;\n                                *0x496dc8 = *(iVar2 + 0x496dc8);\n                                *0x496dcc = *(iVar2 + 0x496dcc);\n                                *(iVar2 + 0x496dc8) = iVar7;\n                                *(iVar2 + 0x496dcc) = iStack420;\n                            }\n                            break;\n                        }\n                        in_stack_fffffe44 = *piVar6;\n                        iStack400 = iStack400 + 1;\n                        *piVar6 = iVar7;\n                        iVar2 = piVar6[1];\n                        piVar6[1] = iStack420;\n                        piVar6 = piVar6 + 2;\n                        iVar7 = in_stack_fffffe44;\n                        iStack420 = iVar2;\n                    } while (piVar6 < 0x496df0);\n                    uVar8 = *0x496dcc;\n                    if (iStack400 == 5) {\n                        iVar7 = fcn.0041653e(1, 0x473bb8, 0x7f, &uStack396, iStack404, *0x499c14, 1, unaff_EDI, \n                                             unaff_EBX, in_stack_fffffe3c, in_stack_fffffe40, in_stack_fffffe44, \n                                             in_stack_fffffe48, arg_1ch, in_stack_fffffe50);\n                        if (iVar7 == 0) {\n                            *0x496dcc = 0;\n                        }\n                        else {\n                            uVar8 = 0;\n                            do {\n                                auStack395[uVar8 * 2] = auStack395[uVar8 * 2] & 1;\n                                uVar8 = uVar8 + 1;\n                            } while (uVar8 < 0x7f);\n                            iVar7 = fcn.0040ee70(&uStack396, \n                                                 L\"        h((((                  H\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x10\\x10\\x10\\x10\\x10\\x10\\x10\u0181\u0181\u0181\u0181\u0181\u0181\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\\x10\\x10\\x10\\x10\\x10\\x10\u0182\u0182\u0182\u0182\u0182\u0182\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\\x10\\x10\\x10\\x10 \"\n                                                 , 0xfe);\n                            *0x496dcc = iVar7 == 0;\n                        }\n                        *0x496dc8 = *0x499c24;\n                        uVar8 = *0x496dcc;\n                    }\n                }\n                *0x496d60 = uVar8;\n                if (unaff_ESI == 1) {\n                    *0x499c28 = iStack404;\n                }\n                iVar7 = (**(iVar9 + 0x496f08))();\n                if (iVar7 == 0) {\n                    if (arg_8h != 0x496d68) {\n                        fcn.0040d958(arg_8h);\n                    }\n                }\n                else {\n                    *(iVar9 + 0x496f04) = arg_8h;\n                    fcn.0040d958(iVar4);\n                    *puVar1 = arg_1ch;\n                    *0x499c24 = iVar3;\n                }\n            }\n        }\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 1481
    },
    "00416f69": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00416f69(char *param_1, int32_t param_2)\n\n{\n    bool bVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t iStack152;\n    int32_t iStack144;\n    uchar auStack140 [132];\n    uint uStack8;\n    \n    uStack8 = *0x496830;\n    if (param_2 != 0) {\n        if (param_1 != NULL) {\n            fcn.00416cda(param_1);\n        }\n        goto code_r0x004170a3;\n    }\n    bVar1 = true;\n    iStack144 = 0;\n    if (param_1 != NULL) {\n        if (((*param_1 == 'L') && (param_1[1] == 'C')) && (param_1[2] == '_')) {\n            do {\n                pcVar2 = fcn.00416090(param_1, 0x473c98);\n                if (((pcVar2 == NULL) || (iVar3 = pcVar2 - param_1,  iVar3 == 0)) || (*pcVar2 == ';'))\n                goto code_r0x004170a3;\n                iStack152 = 1;\n                puVar5 = 0x496f0c;\n                do {\n                    iVar4 = fcn.00416050(*puVar5, param_1, iVar3);\n                    if ((iVar4 == 0) && (iVar4 = fcn.0040e9c0(*puVar5),  iVar3 == iVar4)) break;\n                    iStack152 = iStack152 + 1;\n                    puVar5 = puVar5 + 3;\n                } while (puVar5 < 0x496f3d);\n                pcVar2 = pcVar2 + 1;\n                iVar3 = fcn.00416120(pcVar2, 0x46cfa4);\n                if ((iVar3 == 0) && (*pcVar2 != ';')) goto code_r0x004170a3;\n                if (iStack152 < 6) {\n                    fcn.004185b0(auStack140, pcVar2, iVar3);\n                    auStack140[iVar3] = 0;\n                    iVar4 = fcn.00416cda(auStack140);\n                    if (iVar4 != 0) {\n                        iStack144 = iStack144 + 1;\n                    }\n                }\n            } while ((pcVar2[iVar3] != '\\0') && (param_1 = pcVar2 + iVar3 + 1,  *param_1 != '\\0'));\n        }\n        else {\n            iVar3 = fcn.00416b7e(param_1, auStack140, 0, 0);\n            if (iVar3 == 0) goto code_r0x004170a3;\n            puVar5 = 0x496f04;\n            do {\n                if (puVar5 != 0x496f04) {\n                    iVar3 = fcn.00413b40(auStack140, *puVar5);\n                    if ((iVar3 == 0) || (iVar3 = fcn.00416cda(auStack140),  iVar3 != 0)) {\n                        iStack144 = iStack144 + 1;\n                    }\n                    else {\n                        bVar1 = false;\n                    }\n                }\n                puVar5 = puVar5 + 3;\n            } while (puVar5 < 0x496f41);\n            if (bVar1) {\n                fcn.00416abf();\n                fcn.0040d958(*0x496f04);\n                *0x496f04 = 0;\n                goto code_r0x004170a3;\n            }\n        }\n        if (iStack144 == 0) goto code_r0x004170a3;\n    }\n    fcn.00416abf();\ncode_r0x004170a3:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 891
    },
    "004172cd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.004172cd(int64_t *arg_8h)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    int64_t iVar7;\n    int64_t iVar8;\n    int64_t iVar9;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    bVar1 = false;\n    iVar5 = *(arg_8h + 4);\n    iVar4 = *arg_8h;\n    iVar8 = *arg_8h;\n    iVar2 = fcn.00412cd5();\n    if (((iVar5 < 0) || (0x1000 < iVar5)) || ((0xfff < iVar5 && (iVar4 != 0)))) {\n        return NULL;\n    }\n    if (*(iVar2 + 0x44) == 0) {\n        iVar3 = fcn.0040d946(0x24);\n        *(iVar2 + 0x44) = iVar3;\n        if (iVar3 != 0) goto code_r0x00417333;\n        piVar6 = 0x499c40;\n    }\n    else {\ncode_r0x00417333:\n        piVar6 = *(iVar2 + 0x44);\n    }\n    iVar4 = fcn.00410a00(iVar4, iVar5, 0x1e13380, 0);\n    var_4h = iVar4 + 0x46;\n    iVar5 = iVar4 + 0x45;\n    iVar7 = fcn.0040f9b0(iVar4, iVar4 >> 0x1f, 0xfffffe93, 0xffffffff);\n    iVar7 = fcn.0040f9b0(iVar7 - (((iVar4 + 0x171) / 400 - iVar5 / 100) + -0x11 + iVar5 / 4), 0x15180, 0);\n    iVar7 = iVar7 + iVar8;\n    iVar2 = iVar7;\n    if ((iVar7 < 0x100000000) && (iVar7 < 0)) {\n        iVar7 = iVar7 + 0x1e13380;\n        var_4h = iVar5;\n        if (((iVar5 % 4 != 0) || (iVar5 % 100 == 0)) && ((iVar4 + 0x7b1) % 400 != 0)) goto code_r0x0041742f;\n        iVar7 = CONCAT44((iVar7 >> 0x20) + (0xfffeae7f < iVar7), iVar2 + 0x1e28500);\n    }\n    else if (((var_4h % 4 != 0) || (var_4h % 100 == 0)) && ((iVar4 + 0x7b2) % 400 != 0)) goto code_r0x0041742f;\n    bVar1 = true;\ncode_r0x0041742f:\n    piVar6[5] = var_4h;\n    iVar5 = fcn.00410a00(iVar7, 0x15180, 0);\n    piVar6[7] = iVar5;\n    iVar8 = fcn.0040f9b0(iVar5, iVar5 >> 0x1f, 0xfffeae80, 0xffffffff);\n    iVar5 = 0x497000;\n    if (!bVar1) {\n        iVar5 = 0x497034;\n    }\n    iVar2 = 1;\n    iVar4 = *(iVar5 + 4);\n    while (iVar4 < piVar6[7]) {\n        iVar2 = iVar2 + 1;\n        iVar4 = *(iVar5 + iVar2 * 4);\n    }\n    piVar6[4] = iVar2 + -1;\n    piVar6[3] = piVar6[7] - *(iVar5 + (iVar2 + -1) * 4);\n    iVar5 = fcn.00410a00(*arg_8h, *(arg_8h + 4), 0x15180, 0);\n    piVar6[6] = (iVar5 + 4) % 7;\n    iVar5 = fcn.00410a00(iVar8 + iVar7, 0xe10, 0);\n    piVar6[2] = iVar5;\n    iVar9 = fcn.0040f9b0(iVar5, iVar5 >> 0x1f, 0xfffff1f0, 0xffffffff);\n    iVar9 = iVar8 + iVar7 + iVar9;\n    iVar5 = fcn.00410a00(iVar9, 0x3c, 0);\n    piVar6[1] = iVar5;\n    *piVar6 = iVar9 + iVar5 * -0x3c;\n    piVar6[8] = 0;\n    return piVar6;\n}\n",
        "token_count": 1126
    },
    "004174f2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_28h\n\nvoid fcn.004174f2(void)\n\n{\n    char cVar1;\n    code *pcVar2;\n    uint uVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    char *pcVar6;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0040daac(0x473cf0, 0x18);\n    *(unaff_EBP + -0x20) = 0;\n    fcn.00410d9c(7);\n    *(unaff_EBP + -4) = 0;\n    uVar3 = *0x499c24;\n    *(unaff_EBP + -0x28) = *0x499c24;\n    *0x499d14 = 0;\n    *0x496ff4 = 0xffffffff;\n    *0x496fe8 = 0xffffffff;\n    pcVar4 = fcn.0041b67a(0x473cec);\n    *(unaff_EBP + -0x24) = pcVar4;\n    if ((pcVar4 == NULL) || (*pcVar4 == '\\0')) {\n        if (*0x499d18 != 0) {\n            fcn.0040d958(*0x499d18);\n            *0x499d18 = 0;\n        }\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetTimeZoneInformation)(0x499c68);\n        pcVar2 = _sym.imp.KERNEL32.dll_WideCharToMultiByte;\n        if (iVar5 != -1) {\n            *0x499d14 = 1;\n            *0x496f50 = *0x499c68 * 0x3c;\n            if (*0x499cae != 0) {\n                *0x496f50 = *0x496f50 + *0x499cbc * 0x3c;\n            }\n            if ((*0x499d02 == 0) || (*0x499d10 == 0)) {\n                *0x496f54 = 0;\n                *0x496f58 = 0;\n            }\n            else {\n                *0x496f54 = 1;\n                *0x496f58 = (*0x499d10 - *0x499cbc) * 0x3c;\n            }\n            iVar5 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                              (uVar3, 0, 0x499c6c, 0xffffffff, *0x496fe0, 0x3f, 0, unaff_EBP + -0x1c);\n            if ((iVar5 == 0) || (*(unaff_EBP + -0x1c) != 0)) {\n                **0x496fe0 = 0;\n            }\n            else {\n                (*0x496fe0)[0x3f] = 0;\n            }\n            iVar5 = (*pcVar2)(uVar3, 0, 0x499cc0, 0xffffffff, *0x496fe4, 0x3f, 0, unaff_EBP + -0x1c);\n            if ((iVar5 == 0) || (*(unaff_EBP + -0x1c) != 0)) {\n                **0x496fe4 = 0;\n            }\n            else {\n                (*0x496fe4)[0x3f] = 0;\n            }\n        }\n    }\n    else {\n        if (*0x499d18 != 0) {\n            iVar5 = fcn.00413b40(pcVar4, *0x499d18);\n            if (iVar5 == 0) goto code_r0x004176f6;\n            if (*0x499d18 != 0) {\n                fcn.0040d958(*0x499d18);\n            }\n        }\n        iVar5 = fcn.0040e9c0(pcVar4);\n        *0x499d18 = fcn.0040d946(iVar5 + 1);\n        if (*0x499d18 != 0) {\n            fcn.00415f50(*0x499d18, pcVar4);\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0041770d();\n            fcn.004185b0(*0x496fe0, pcVar4, 3);\n            (*0x496fe0)[3] = 0;\n            pcVar6 = pcVar4 + 3;\n            if (*pcVar6 == '-') {\n                *(unaff_EBP + -0x20) = 1;\n                pcVar6 = pcVar4 + 4;\n            }\n            *0x496f50 = fcn.0041026e(pcVar6);\n            *0x496f50 = *0x496f50 * 0xe10;\n            for (; (cVar1 = *pcVar6,  cVar1 == '+' || (('/' < cVar1 && (cVar1 < ':')))); pcVar6 = pcVar6 + 1) {\n            }\n            if (*pcVar6 == ':') {\n                pcVar6 = pcVar6 + 1;\n                iVar5 = fcn.0041026e(pcVar6);\n                *0x496f50 = *0x496f50 + iVar5 * 0x3c;\n                for (; ('/' < *pcVar6 && (*pcVar6 < ':')); pcVar6 = pcVar6 + 1) {\n                }\n                if (*pcVar6 == ':') {\n                    pcVar6 = pcVar6 + 1;\n                    iVar5 = fcn.0041026e(pcVar6);\n                    *0x496f50 = *0x496f50 + iVar5;\n                    for (; ('/' < *pcVar6 && (*pcVar6 < ':')); pcVar6 = pcVar6 + 1) {\n                    }\n                }\n            }\n            if (*(unaff_EBP + -0x20) != 0) {\n                *0x496f50 = -*0x496f50;\n            }\n            *0x496f54 = *pcVar6;\n            if (*0x496f54 == 0) {\n                **0x496fe4 = 0;\n            }\n            else {\n                fcn.004185b0(*0x496fe4, pcVar6, 3);\n                (*0x496fe4)[3] = 0;\n            }\n            goto code_r0x00417794;\n        }\n    }\ncode_r0x004176f6:\n    fcn.0040e0da(unaff_EBP + -0x10, 0xffffffff);\ncode_r0x00417794:\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 1616
    },
    "0041779a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.0041779a(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch, \n            int32_t arg_20h, int32_t arg_24h, int32_t arg_28h)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = arg_10h % 4;\n    if (arg_ch == 1) {\n        if (((iVar2 == 0) && (arg_10h % 100 != 0)) || ((arg_10h + 0x76c) % 400 == 0)) {\n            iVar4 = *(in_EAX * 4 + 0x496ffc);\n        }\n        else {\n            iVar4 = *(in_EAX * 4 + 0x497030);\n        }\n        iVar5 = iVar4 + 1;\n        iVar3 = (arg_10h * 0x16d + -0x63db + (arg_10h + -1) / 4 + iVar5 + ((arg_10h + 299) / 400 - (arg_10h + -1) / 100)\n                ) % 7;\n        iVar1 = (arg_14h * 7 - iVar3) + arg_18h;\n        if (iVar3 <= arg_18h) {\n            iVar5 = iVar4 + -6;\n        }\n        iVar5 = iVar5 + iVar1;\n        if (arg_14h == 5) {\n            if (((iVar2 == 0) && (arg_10h % 100 != 0)) || ((arg_10h + 0x76c) % 400 == 0)) {\n                iVar1 = *(in_EAX * 4 + 0x497000);\n            }\n            else {\n                iVar1 = *(in_EAX * 4 + 0x497034);\n            }\n            if (iVar1 < iVar5) {\n                iVar5 = iVar5 + -7;\n            }\n        }\n    }\n    else {\n        if (((iVar2 == 0) && (iVar1 = arg_10h / 100,  arg_10h % 100 != 0)) ||\n           (iVar1 = (arg_10h + 0x76c) / 400,  (arg_10h + 0x76c) % 400 == 0)) {\n            iVar5 = *(in_EAX * 4 + 0x496ffc);\n        }\n        else {\n            iVar5 = *(in_EAX * 4 + 0x497030);\n        }\n        iVar5 = iVar5 + arg_1ch;\n    }\n    iVar2 = (in_ECX * 0x3c + arg_20h) * 0x3c;\n    if (arg_8h == 1) {\n        *0x496ff0 = (iVar2 + arg_24h) * 1000 + arg_28h;\n        *0x496fe8 = arg_10h;\n        *0x496fec = iVar5;\n    }\n    else {\n        *0x496ffc = (iVar2 + *0x496f58 + arg_24h) * 1000 + arg_28h;\n        if (*0x496ffc < 0) {\n            *0x496ffc = *0x496ffc + 86400000;\n            *0x496ff8 = iVar5 + -1;\n        }\n        else {\n            iVar1 = 86400000;\n            *0x496ff8 = iVar5;\n            if (86399999 < *0x496ffc) {\n                *0x496ffc = *0x496ffc + -86400000;\n                *0x496ff8 = iVar5 + 1;\n            }\n        }\n        *0x496ff4 = arg_10h;\n    }\n    return iVar1;\n}\n",
        "token_count": 924
    },
    "00417cf3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417cf3(int32_t arg_8h, int32_t *arg_ch, uint arg_10h)\n\n{\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (arg_8h != 0) {\n        fcn.0041bbd8(&var_8h, arg_10h);\n        *arg_ch = var_8h;\n        arg_ch[1] = var_4h;\n        return;\n    }\n    fcn.0041bc53(&arg_8h, arg_10h);\n    *arg_ch = arg_8h;\n    return;\n}\n",
        "token_count": 144
    },
    "00417d4e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417d4e(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t *in_EAX;\n    uchar *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uchar *unaff_EBX;\n    \n    if (arg_10h != '\\0') {\n        fcn.00417d31();\n    }\n    if (*in_EAX == 0x2d) {\n        *unaff_EBX = 0x2d;\n        unaff_EBX = unaff_EBX + 1;\n    }\n    puVar1 = unaff_EBX;\n    if (0 < arg_8h) {\n        puVar1 = unaff_EBX + 1;\n        *unaff_EBX = *puVar1;\n        *puVar1 = *0x497314;\n    }\n    puVar1 = fcn.00415f50(puVar1 + arg_8h + (arg_10h == '\\0'), \"e+000\");\n    if (arg_ch != 0) {\n        *puVar1 = 0x45;\n    }\n    if (*in_EAX[3] != '0') {\n        iVar2 = in_EAX[1] + -1;\n        if (iVar2 < 0) {\n            iVar2 = -iVar2;\n            puVar1[1] = 0x2d;\n        }\n        if (99 < iVar2) {\n            iVar3 = iVar2 / 100;\n            iVar2 = iVar2 % 100;\n            puVar1[2] = puVar1[2] + iVar3;\n        }\n        if (9 < iVar2) {\n            iVar3 = iVar2 / 10;\n            iVar2 = iVar2 % 10;\n            puVar1[3] = puVar1[3] + iVar3;\n        }\n        puVar1[4] = puVar1[4] + iVar2;\n    }\n    return;\n}\n",
        "token_count": 441
    },
    "00417e68": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuchar * __cdecl fcn.00417e68(uchar *arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_EAX;\n    uchar *puVar3;\n    \n    iVar1 = in_EAX[1];\n    if ((arg_10h != '\\0') && (iVar1 + -1 == arg_ch)) {\n        iVar2 = *in_EAX;\n        arg_8h[(iVar2 == 0x2d) + iVar1 + -1] = 0x30;\n        (arg_8h + (iVar2 == 0x2d) + iVar1 + -1)[1] = 0;\n    }\n    puVar3 = arg_8h;\n    if (*in_EAX == 0x2d) {\n        *arg_8h = 0x2d;\n        puVar3 = arg_8h + 1;\n    }\n    if (in_EAX[1] < 1) {\n        fcn.00417d31();\n        *puVar3 = 0x30;\n        puVar3 = puVar3 + 1;\n    }\n    else {\n        puVar3 = puVar3 + in_EAX[1];\n    }\n    if (0 < arg_ch) {\n        fcn.00417d31();\n        *puVar3 = *0x497314;\n        iVar1 = in_EAX[1];\n        if (iVar1 < 0) {\n            if ((arg_10h != '\\0') || (SBORROW4(arg_ch, -iVar1) == arg_ch + iVar1 < 0)) {\n                arg_ch = -iVar1;\n            }\n            fcn.00417d31();\n            fcn.0040e620(puVar3 + 1, 0x30, arg_ch);\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 426
    },
    "0041817f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.0041817f(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.00412cd5();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x496dc4) {\n        iVar1 = fcn.00416a84();\n    }\n    if (1 < *(iVar1 + 0x28)) {\n        uVar2 = fcn.004166f8(iVar1, param_1, 4);\n        return uVar2;\n    }\n    return *(*(iVar1 + 0x48) + param_1 * 2) & 4;\n}\n",
        "token_count": 157
    },
    "004181b9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.004181b9(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.00412cd5();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x496dc4) {\n        iVar1 = fcn.00416a84();\n    }\n    if (1 < *(iVar1 + 0x28)) {\n        uVar2 = fcn.004166f8(iVar1, param_1, 0x80);\n        return uVar2;\n    }\n    return *(*(iVar1 + 0x48) + param_1 * 2) & 0x80;\n}\n",
        "token_count": 161
    },
    "004181f8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.004181f8(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.00412cd5();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x496dc4) {\n        iVar1 = fcn.00416a84();\n    }\n    if (1 < *(iVar1 + 0x28)) {\n        uVar2 = fcn.004166f8(iVar1, param_1, 8);\n        return uVar2;\n    }\n    return *(*(iVar1 + 0x48) + param_1 * 2) & 8;\n}\n",
        "token_count": 157
    },
    "004183bc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004183bc(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_4h;\n    \n    fcn.0040daac(0x473da0, 0x10);\n    if (*0x499d20 == NULL) {\n        if (*0x4998ec != 1) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"kernel32.dll\");\n            if (iVar2 != 0) {\n                *0x499d20 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"InitializeCriticalSectionAndSpinCount\");\n                if (*0x499d20 != NULL) goto code_r0x00418408;\n            }\n        }\n        *0x499d20 = 0x4183ac;\n    }\ncode_r0x00418408:\n    pcVar1 = *0x499d20;\n    *(unaff_EBP + -4) = 0;\n    uVar3 = (*pcVar1)(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n    *(unaff_EBP + -0x20) = uVar3;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 335
    },
    "004184af": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004184af(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint var_10h;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar4 = 0;\n    if (*0x499d24 == NULL) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"user32.dll\");\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if ((iVar2 == 0) || (*0x499d24 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x473e04),  *0x499d24 == NULL))\n        {\n            return 0;\n        }\n        *0x499d28 = (*pcVar1)(iVar2, 0x473df4);\n        *0x499d2c = (*pcVar1)(iVar2, 0x473de0);\n        if ((*0x4998ec == 2) && (*0x499d34 = (*pcVar1)(iVar2, \"GetUserObjectInformationA\"),  *0x499d34 != NULL)) {\n            *0x499d30 = (*pcVar1)(iVar2, \"GetProcessWindowStation\");\n        }\n    }\n    if ((*0x499d30 == NULL) ||\n       (((iVar2 = (**0x499d30)(),  iVar2 != 0 && (iVar2 = (**0x499d34)(iVar2, 1, &var_10h, 0xc, &var_4h),  iVar2 != 0))\n        && ((var_8h & 1) != 0)))) {\n        if (((*0x499d28 != NULL) && (iVar4 = (**0x499d28)(),  iVar4 != 0)) && (*0x499d2c != NULL)) {\n            iVar4 = (**0x499d2c)(iVar4);\n        }\n    }\n    else if (*0x4998f8 < 4) {\n        arg_10h = arg_10h | 0x40000;\n    }\n    else {\n        arg_10h = arg_10h | 0x200000;\n    }\n    uVar3 = (**0x499d24)(iVar4, arg_8h, arg_ch, arg_10h);\n    return uVar3;\n}\n",
        "token_count": 560
    },
    "004186d4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.004186d4(uint8_t param_1, uint32_t param_2, uint8_t param_3)\n\n{\n    if ((*(param_1 + 0x49af81) & param_3) == 0) {\n        if (param_2 == 0) {\n            param_2 = 0;\n        }\n        else {\n            param_2 = *(*0x49731c + param_1 * 2) & param_2;\n        }\n        if (param_2 == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 132
    },
    "00418e74": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00418e74(int32_t arg_8h, uint16_t *lpWideCharStr, uint8_t *arg_10h, uint32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    if ((arg_10h != NULL) && (arg_14h != 0)) {\n        uVar1 = *arg_10h;\n        if (uVar1 != 0) {\n            if (*(arg_8h + 0x14) == 0) {\n                if (lpWideCharStr != NULL) {\n                    *lpWideCharStr = uVar1;\n                }\n                return 1;\n            }\n            if ((*(*(arg_8h + 0x48) + 1 + uVar1 * 2) & 0x80) == 0) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                  (*(arg_8h + 4), 9, arg_10h, 1, lpWideCharStr, lpWideCharStr != NULL);\n                if (iVar2 != 0) {\n                    return 1;\n                }\n            }\n            else {\n                iVar2 = *(arg_8h + 0x28);\n                if ((((1 < iVar2) && (iVar2 <= arg_14h)) &&\n                    (iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                       (*(arg_8h + 4), 9, arg_10h, iVar2, lpWideCharStr, lpWideCharStr != NULL), \n                    iVar2 != 0)) || ((*(arg_8h + 0x28) <= arg_14h && (arg_10h[1] != 0)))) {\n                    return *(arg_8h + 0x28);\n                }\n            }\n            puVar3 = fcn.00410979();\n            *puVar3 = 0x2a;\n            return 0xffffffff;\n        }\n        if (lpWideCharStr != NULL) {\n            *lpWideCharStr = 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 478
    },
    "0041916d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.0041916d(uint32_t param_1, char **param_2)\n\n{\n    char *pcVar1;\n    \n    if (param_1 != 0xffffffff) {\n        pcVar1 = param_2[3];\n        if (((pcVar1 & 1) != 0) || ((pcVar1 < '\\0' && ((pcVar1 & 2) == 0)))) {\n            if (param_2[2] == NULL) {\n                fcn.00418b7c(param_2);\n            }\n            if (*param_2 == param_2[2]) {\n                if (param_2[1] != NULL) {\n                    return 0xffffffff;\n                }\n                *param_2 = *param_2 + 1;\n            }\n            *param_2 = *param_2 + -1;\n            pcVar1 = *param_2;\n            if ((*(param_2 + 3) & 0x40) == 0) {\n                *pcVar1 = param_1;\n            }\n            else if (*pcVar1 != param_1) {\n                *param_2 = pcVar1 + 1;\n                return 0xffffffff;\n            }\n            param_2[1] = param_2[1] + 1;\n            param_2[3] = param_2[3] & 0xffffffef | 1;\n            return param_1 & 0xff;\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 326
    },
    "00419840": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00419840(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h)\n\n{\n    char in_AL;\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t *unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    uint noname_1;\n    \n    if (in_AL < '[') {\n        if (in_AL == 'Z') {\ncode_r0x00419a31:\n            fcn.00417ad9();\ncode_r0x00419a96:\n            fcn.00419771();\n            return 1;\n        }\n        if (in_AL < 'N') {\n            if (in_AL != 'M') {\n                if (in_AL == '%') {\n                    **in_ECX = 0x25;\n                    *in_ECX = *in_ECX + 1;\n                    *unaff_EBX = *unaff_EBX + -1;\n                    return 1;\n                }\n                if ((in_AL == 'A') || (in_AL == 'B')) goto code_r0x00419a96;\n                if ((in_AL != 'H') && (in_AL != 'I')) {\n                    return 1;\n                }\n            }\ncode_r0x00419908:\n            fcn.004197c7(arg_14h);\n            return 1;\n        }\n        if (((in_AL == 'S') || (in_AL == 'U')) || (in_AL == 'W')) goto code_r0x00419908;\n        if (in_AL != 'X') {\n            if (in_AL != 'Y') {\n                return 1;\n            }\n            goto code_r0x00419908;\n        }\n    }\n    else {\n        if ('m' < in_AL) {\n            if (in_AL == 'p') goto code_r0x00419a96;\n            if (in_AL == 'w') goto code_r0x00419908;\n            if (in_AL == 'x') {\n                if (arg_14h == 0) {\n                    noname_1 = 0;\n                }\n                else {\n                    noname_1 = 1;\n                }\n                goto code_r0x0041991d;\n            }\n            if (in_AL == 'y') goto code_r0x00419908;\n            if (in_AL != 'z') {\n                return 1;\n            }\n            goto code_r0x00419a31;\n        }\n        if (in_AL == 'm') goto code_r0x00419908;\n        if ((in_AL == 'a') || (in_AL == 'b')) goto code_r0x00419a96;\n        if (in_AL != 'c') {\n            if ((in_AL != 'd') && (in_AL != 'j')) {\n                return 1;\n            }\n            goto code_r0x00419908;\n        }\n        iVar1 = fcn.00419aa6(arg_8h, arg_14h != 0, arg_ch, in_ECX, unaff_EBX, arg_10h, unaff_EDI, unaff_ESI, unaff_EBP, \n                             unaff_retaddr, arg_8h, arg_ch, arg_10h, arg_14h);\n        if (iVar1 == 0) {\n            return 0;\n        }\n        if (*unaff_EBX == 0) {\n            return 0;\n        }\n        **in_ECX = 0x20;\n        *in_ECX = *in_ECX + 1;\n        *unaff_EBX = *unaff_EBX + -1;\n    }\n    noname_1 = 2;\ncode_r0x0041991d:\n    iVar1 = fcn.00419aa6(arg_8h, noname_1, arg_ch, in_ECX, unaff_EBX, arg_10h, unaff_EDI, unaff_ESI, unaff_EBP, \n                         unaff_retaddr, arg_8h, arg_ch, arg_10h, arg_14h);\n    if (iVar1 != 0) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 926
    },
    "00419f30": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl\nfcn.00419f30(int32_t arg_8h, uint8_t *arg_ch, uint32_t arg_10h, uint8_t *arg_14h, uint arg_18h, uint32_t arg_1ch)\n\n{\n    uint8_t uVar1;\n    int32_t arg_10h_00;\n    int32_t iVar2;\n    uint8_t *puVar3;\n    bool bVar4;\n    uint var_4h;\n    \n    arg_10h_00 = arg_1ch;\n    if (arg_1ch == 0) {\n        arg_10h_00 = *(arg_8h + 0x4c);\n    }\n    if (arg_10h != 0) {\n        arg_1ch = arg_10h;\n        if (arg_10h == 0) {\ncode_r0x00419fdf:\n            bVar4 = arg_1ch == 0;\n        }\n        else {\n            do {\n                uVar1 = *arg_14h;\n                if (uVar1 == 0) break;\n                if (uVar1 == 0x25) {\n                    puVar3 = arg_14h + 1;\n                    uVar1 = *puVar3;\n                    if (uVar1 == 0x23) {\n                        puVar3 = arg_14h + 2;\n                    }\n                    iVar2 = fcn.00419840(arg_8h, arg_18h, arg_10h_00, uVar1 == 0x23);\n                    if (iVar2 == 0) goto code_r0x00419fdf;\n                }\n                else {\n                    if (((*(*(arg_8h + 0x48) + 1 + uVar1 * 2) & 0x80) != 0) && (1 < arg_1ch)) {\n                        arg_14h = arg_14h + 1;\n                        if (*arg_14h == 0) goto code_r0x00419fdf;\n                        *arg_ch = uVar1;\n                        arg_ch = arg_ch + 1;\n                        arg_1ch = arg_1ch - 1;\n                    }\n                    *arg_ch = *arg_14h;\n                    arg_ch = arg_ch + 1;\n                    arg_1ch = arg_1ch - 1;\n                    puVar3 = arg_14h;\n                }\n                arg_14h = puVar3 + 1;\n            } while (arg_1ch != 0);\n            bVar4 = arg_1ch == 0;\n            if (!bVar4) {\n                *arg_ch = 0;\n                return arg_10h - arg_1ch;\n            }\n        }\n        if (bVar4) {\n            arg_ch = arg_ch + -1;\n        }\n        *arg_ch = 0;\n        arg_10h = 0;\n    }\n    return arg_10h;\n}\n",
        "token_count": 645
    },
    "0041a630": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0041a630(void)\n\n{\n    char *pcVar1;\n    char cVar2;\n    int32_t *arg_8h;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    char *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint *arg_14h;\n    uint *puVar8;\n    uint32_t uVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((*0x499c1c == 0) && (*0x499c18 == 0)) {\n        if (((*0x499e14 != NULL) && (**0x499e14 == 0)) && (*0x499e14 != *(*0x496dc4 + 0x2c))) {\n            fcn.0040d958(*0x499e14);\n            fcn.0040d958(*0x499d44);\n        }\n        *0x499e18 = NULL;\n        *0x499e14 = NULL;\n        arg_14h = 0x4973f4;\n        *0x499d44 = NULL;\n        puVar8 = *0x499d44;\n        arg_8h = *0x499e14;\ncode_r0x0041a7dd:\n        *0x499e14 = arg_8h;\n        *0x499d44 = puVar8;\n        *0x497314 = **arg_14h;\n        *0x497318 = 1;\n        uVar6 = 0;\n        *0x497424 = arg_14h;\n    }\n    else {\n        arg_14h = fcn.0040f0e4(1, 0x30);\n        if (arg_14h != NULL) {\n            puVar8 = *0x497424;\n            puVar11 = arg_14h;\n            for (iVar7 = 0xc; iVar7 != 0; iVar7 = iVar7 + -1) {\n                *puVar11 = *puVar8;\n                puVar8 = puVar8 + 1;\n                puVar11 = puVar11 + 1;\n            }\n            arg_8h = fcn.0040d946(4);\n            if (arg_8h != NULL) {\n                *arg_8h = 0;\n                if (*0x499c1c == 0) {\n                    *0x499e18 = NULL;\n                    *arg_14h = *0x4973f4;\n                    arg_14h[1] = *0x4973f8;\n                    arg_14h[2] = *0x4973fc;\n                }\n                else {\n                    *0x499e18 = fcn.0040d946(4);\n                    if (*0x499e18 == NULL) {\n                        uVar6 = 1;\ncode_r0x0041a73b:\n                        fcn.0040d958(arg_14h);\n                        fcn.0040d958(arg_8h);\n                        return uVar6;\n                    }\n                    **0x499e18 = 0;\n                    uVar9 = *0x499d86;\n                    uVar3 = fcn.0041cfde(1, uVar9, 0xe, arg_14h);\n                    uVar4 = fcn.0041cfde(1, uVar9, 0xf, arg_14h + 1);\n                    uVar9 = fcn.0041cfde(1, uVar9, 0x10, arg_14h + 2);\n                    if ((uVar9 | uVar3 | uVar4) != 0) {\n                        fcn.0041a5d1(arg_14h);\n                        uVar6 = 0xffffffff;\n                        goto code_r0x0041a73b;\n                    }\n                    pcVar5 = arg_14h[2];\n                    while (*pcVar5 != '\\0') {\n                        cVar2 = *pcVar5;\n                        if ((cVar2 < '0') || ('9' < cVar2)) {\n                            pcVar10 = pcVar5;\n                            if (cVar2 != ';') goto code_r0x0041a767;\n                            do {\n                                pcVar1 = pcVar10 + 1;\n                                *pcVar10 = *pcVar1;\n                                pcVar10 = pcVar1;\n                            } while (*pcVar1 != '\\0');\n                        }\n                        else {\n                            *pcVar5 = cVar2 + -0x30;\ncode_r0x0041a767:\n                            pcVar5 = pcVar5 + 1;\n                        }\n                    }\n                }\n                puVar8 = arg_14h;\n                if (((*0x499e14 != NULL) && (**0x499e14 == 0)) && (*0x499e14 != *(*0x496dc4 + 0x2c))) {\n                    fcn.0040d958(*0x499e14);\n                    fcn.0040d958(*0x499d44);\n                }\n                goto code_r0x0041a7dd;\n            }\n            fcn.0040d958(arg_14h);\n        }\n        uVar6 = 1;\n    }\n    return uVar6;\n}\n",
        "token_count": 1170
    },
    "0041a909": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0041a909(void)\n\n{\n    char *pcVar1;\n    char cVar2;\n    uint *arg_8h;\n    uint *arg_8h_00;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    uint32_t uVar12;\n    uint32_t uVar13;\n    uint32_t uVar14;\n    uint32_t uVar15;\n    uint32_t uVar16;\n    char *pcVar17;\n    uint uVar18;\n    int32_t iVar19;\n    uint32_t uVar20;\n    char *pcVar21;\n    uint *puVar22;\n    uint *puVar23;\n    uint var_4h;\n    \n    if ((*0x499c18 == 0) && (*0x499c1c == 0)) {\n        *0x499e10 = NULL;\n        *0x499e14 = NULL;\n        *0x497424 = 0x4973f4;\n        *0x499d44 = NULL;\ncode_r0x0041ab41:\n        uVar18 = 0;\n    }\n    else {\n        arg_8h = fcn.0040f0e4(1, 0x30);\n        if (arg_8h != NULL) {\n            arg_8h_00 = fcn.0040d946(4);\n            if (arg_8h_00 == NULL) {\n                fcn.0040d958(arg_8h);\n            }\n            else {\n                *arg_8h_00 = 0;\n                if (*0x499c18 == 0) {\n                    puVar22 = 0x4973f4;\n                    puVar23 = arg_8h;\n                    for (iVar19 = 0xc; iVar19 != 0; iVar19 = iVar19 + -1) {\n                        *puVar23 = *puVar22;\n                        puVar22 = puVar22 + 1;\n                        puVar23 = puVar23 + 1;\n                    }\n                    *0x499e10 = NULL;\ncode_r0x0041ab0e:\n                    *arg_8h = **0x497424;\n                    arg_8h[1] = (*0x497424)[1];\n                    arg_8h[2] = (*0x497424)[2];\n                    *0x497424 = arg_8h;\n                    *0x499d44 = arg_8h;\n                    *0x499e14 = arg_8h_00;\n                    goto code_r0x0041ab41;\n                }\n                *0x499e10 = fcn.0040d946(4);\n                if (*0x499e10 == NULL) {\n                    fcn.0040d958(arg_8h);\n                    fcn.0040d958(arg_8h_00);\n                }\n                else {\n                    **0x499e10 = 0;\n                    uVar20 = *0x499d80;\n                    uVar3 = fcn.0041cfde(1, uVar20, 0x15, arg_8h + 3);\n                    uVar4 = fcn.0041cfde(1, uVar20, 0x14, arg_8h + 4);\n                    uVar5 = fcn.0041cfde(1, uVar20, 0x16, arg_8h + 5);\n                    uVar6 = fcn.0041cfde(1, uVar20, 0x17, arg_8h + 6);\n                    uVar7 = fcn.0041cfde(1, uVar20, 0x18, arg_8h + 7);\n                    uVar8 = fcn.0041cfde(1, uVar20, 0x50, arg_8h + 8);\n                    uVar9 = fcn.0041cfde(1, uVar20, 0x51, arg_8h + 9);\n                    uVar10 = fcn.0041cfde(0, uVar20, 0x1a, arg_8h + 10);\n                    uVar11 = fcn.0041cfde(0, uVar20, 0x19, arg_8h + 0x29);\n                    uVar12 = fcn.0041cfde(0, uVar20, 0x54, arg_8h + 0x2a);\n                    uVar13 = fcn.0041cfde(0, uVar20, 0x55, arg_8h + 0x2b);\n                    uVar14 = fcn.0041cfde(0, uVar20, 0x56, arg_8h + 0xb);\n                    uVar15 = fcn.0041cfde(0, uVar20, 0x57, arg_8h + 0x2d);\n                    uVar16 = fcn.0041cfde(0, uVar20, 0x52, arg_8h + 0x2e);\n                    uVar20 = fcn.0041cfde(0, uVar20, 0x53, arg_8h + 0x2f);\n                    if ((uVar20 | uVar3 | uVar4 | uVar5 | uVar6 | uVar7 | uVar8 | uVar9 | uVar10 | uVar11 | uVar12 |\n                                  uVar13 | uVar14 | uVar15 | uVar16) == 0) {\n                        pcVar17 = arg_8h[7];\n                        while (*pcVar17 != '\\0') {\n                            cVar2 = *pcVar17;\n                            if ((cVar2 < '0') || ('9' < cVar2)) {\n                                pcVar21 = pcVar17;\n                                if (cVar2 != ';') goto code_r0x0041aadc;\n                                do {\n                                    pcVar1 = pcVar21 + 1;\n                                    *pcVar21 = *pcVar1;\n                                    pcVar21 = pcVar1;\n                                } while (*pcVar1 != '\\0');\n                            }\n                            else {\n                                *pcVar17 = cVar2 + -0x30;\ncode_r0x0041aadc:\n                                pcVar17 = pcVar17 + 1;\n                            }\n                        }\n                        goto code_r0x0041ab0e;\n                    }\n                    fcn.0041a830(arg_8h);\n                    fcn.0040d958(arg_8h);\n                    fcn.0040d958(arg_8h_00);\n                }\n            }\n        }\n        uVar18 = 1;\n    }\n    return uVar18;\n}\n",
        "token_count": 1522
    },
    "0041ab48": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_12h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0041ab48(void)\n\n{\n    uint8_t *puVar1;\n    char16_t *noname_3;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint8_t *puVar4;\n    uint32_t uVar5;\n    ushort *puVar6;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    int32_t var_24h;\n    uint *var_20h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    uchar auStack24 [2];\n    uint var_12h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    var_1ch = 0;\n    if (*0x499c14 == 0) {\n        *0x49731c = \n        L\"         (((((                  H\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x81\\x81\\x81\\x81\\x81\\x81\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x10\\x10\\x10\\x10\\x10\\x10\\x82\\x82\\x82\\x82\\x82\\x82\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x10\\x10\\x10\\x10 \"\n        ;\n        *0x499e0c = NULL;\n        *0x499e08 = NULL;\n        goto code_r0x0041ad27;\n    }\n    if ((*0x499c24 == 0) && (iVar3 = fcn.0041cfde(0, *0x499d78, 0x1004, 0x499c24),  iVar3 != 0)) {\ncode_r0x0041acfa:\n        fcn.0040d958(var_20h);\n        fcn.0040d958(var_24h);\n    }\n    else {\n        var_20h = fcn.0040d946(4);\n        var_24h = fcn.0040d946(0x300);\n        var_1ch = fcn.0040d946(0x101);\n        if ((var_20h == NULL) || ((var_24h == 0 || (var_1ch == 0)))) goto code_r0x0041acfa;\n        *var_20h = 0;\n        iVar3 = 0;\n        do {\n            *(iVar3 + var_1ch) = iVar3;\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < 0x100);\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetCPInfo)(*0x499c24, &var_18h);\n        if ((iVar3 == 0) || (5 < var_18h)) goto code_r0x0041acfa;\n        *0x497310 = var_18h & 0xffff;\n        if ((1 < *0x497310) && (var_12h != '\\0')) {\n            puVar4 = &var_12h + 1;\n            do {\n                uVar2 = *puVar4;\n                if (uVar2 == 0) break;\n                for (uVar5 = puVar4[-1]; uVar5 <= uVar2; uVar5 = uVar5 + 1) {\n                    *(uVar5 + var_1ch) = 0;\n                    uVar2 = *puVar4;\n                }\n                puVar1 = puVar4 + 1;\n                puVar4 = puVar4 + 2;\n            } while (*puVar1 != 0);\n        }\n        noname_3 = var_24h + 0x100;\n        iVar3 = fcn.0041653e(1, var_1ch, 0x100, noname_3, 0, 0, 0, unaff_ESI, unaff_EBX, unaff_EDI, noname_3, var_20h, \n                             var_1ch, var_18h, _auStack24);\n        if (iVar3 == 0) goto code_r0x0041acfa;\n        *(var_24h + 0xfe) = 0;\n        if ((1 < *0x497310) && (var_12h != '\\0')) {\n            puVar4 = &var_12h + 1;\n            do {\n                if (*puVar4 == 0) break;\n                uVar5 = puVar4[-1];\n                if (uVar5 <= *puVar4) {\n                    puVar6 = var_24h + 0x100 + uVar5 * 2;\n                    do {\n                        *puVar6 = 0x8000;\n                        uVar5 = uVar5 + 1;\n                        puVar6 = puVar6 + 1;\n                    } while (uVar5 <= *puVar4);\n                }\n                puVar1 = puVar4 + 1;\n                puVar4 = puVar4 + 2;\n            } while (*puVar1 != 0);\n        }\n        fcn.0040e680(var_24h, var_24h + 0x200, 0xfe);\n        *0x49731c = noname_3;\n        *0x499e08 = var_24h + 0xfe;\n        *0x499e0c = var_20h;\n    }\n    fcn.0040d958(var_1ch);\ncode_r0x0041ad27:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 1414
    },
    "0041ae00": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041ae00(uint *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint var_ch;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    if ((param_1 == NULL) || (*param_1 == '\\0')) {\ncode_r0x0041ae46:\n        uVar2 = 0x1004;\ncode_r0x0041ae51:\n        iVar1 = (**0x499d68)(*0x499d50, uVar2, &var_ch, 8);\n        if (iVar1 == 0) goto code_r0x0041ae6b;\n        param_1 = &var_ch;\n    }\n    else {\n        iVar1 = fcn.00413b40(param_1, 0x4752b0);\n        if (iVar1 == 0) goto code_r0x0041ae46;\n        iVar1 = fcn.00413b40(param_1, 0x4752ac);\n        if (iVar1 == 0) {\n            uVar2 = 0xb;\n            goto code_r0x0041ae51;\n        }\n    }\n    fcn.0041026e(param_1);\ncode_r0x0041ae6b:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 300
    },
    "0041ae94": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041ae94(uint32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    \n    iVar5 = 0;\n    iVar6 = 0x1a;\n    do {\n        iVar2 = (iVar6 + iVar5) / 2;\n        uVar1 = *(iVar2 * 0x2c + 0x4744b0);\n        if (arg_8h == uVar1) {\n            if (arg_ch == 1) {\n                pcVar4 = \"040a\" + iVar2 * 0x2c;\n            }\n            else if (arg_ch == 3) {\n                pcVar4 = iVar2 * 0x2c + 0x4744c0;\n            }\n            else if (arg_ch == 7) {\n                pcVar4 = iVar2 * 0x2c + 0x4744c8;\n            }\n            else if (arg_ch == 0xb) {\n                pcVar4 = iVar2 * 0x2c + 0x4744cc;\n            }\n            else if (arg_ch == 0x1001) {\n                pcVar4 = *(iVar2 * 0x2c + 0x4744bc);\n            }\n            else if (arg_ch == 0x1002) {\n                pcVar4 = *(iVar2 * 0x2c + 0x4744c4);\n            }\n            else {\n                if (arg_ch != 0x1004) break;\n                pcVar4 = iVar2 * 0x2c + 0x4744d4;\n            }\n            if ((pcVar4 != NULL) && (0 < arg_14h)) {\n                fcn.004185b0(arg_10h, pcVar4, arg_14h + -1);\n                *(arg_10h + -1 + arg_14h) = 0;\n                return 1;\n            }\n            break;\n        }\n        if (arg_8h < uVar1) {\n            iVar6 = iVar2 + -1;\n        }\n        else {\n            iVar5 = iVar2 + 1;\n        }\n    } while (iVar5 <= iVar6);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return uVar3;\n}\n",
        "token_count": 578
    },
    "0041b05d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041b05d(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint var_7ch;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    iVar1 = (**0x499d68)(arg_8h & 0x3ff | 0x400, 1, &var_7ch, 0x78);\n    if (((iVar1 != 0) && (uVar2 = fcn.0041af77(),  arg_8h != uVar2)) && (arg_ch != 0)) {\n        fcn.0040e9c0(*0x499d64);\n        fcn.0041afac();\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 194
    },
    "0041b2e8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041b2e8(uint arg_8h)\n\n{\n    uint arg_8h_00;\n    int32_t iVar1;\n    uint var_7ch;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    arg_8h_00 = fcn.0041af77();\n    iVar1 = (**0x499d68)(arg_8h_00, (-(*0x499d54 != 0) & 0xfffff002) + 0x1001, &var_7ch, 0x78);\n    if (iVar1 == 0) {\n        *0x499d48 = 0;\n        goto code_r0x0041b3a6;\n    }\n    iVar1 = fcn.0041d105(*0x499d64, &var_7ch);\n    if (iVar1 == 0) {\n        if (*0x499d54 == 0) {\n            iVar1 = 1;\n            goto code_r0x0041b37a;\n        }\n    }\n    else {\n        if (((*0x499d54 != 0) || (*0x499d60 == 0)) ||\n           (iVar1 = fcn.0041d16e(*0x499d64, &var_7ch, *0x499d60),  iVar1 != 0)) goto code_r0x0041b3a6;\ncode_r0x0041b37a:\n        iVar1 = fcn.0041b05d(arg_8h_00, iVar1);\n        if (iVar1 == 0) goto code_r0x0041b3a6;\n    }\n    *0x499d48 = *0x499d48 | 4;\n    *0x499d4c = arg_8h_00;\n    *0x499d50 = arg_8h_00;\ncode_r0x0041b3a6:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 448
    },
    "0041b4c5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint fcn.0041b4c5(char *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t arg_8h;\n    uint uVar2;\n    int16_t *unaff_EBX;\n    int32_t unaff_retaddr;\n    \n    if (*0x499d68 == NULL) {\n        if (*0x4998ec == 2) {\n            *0x499d68 = _sym.imp.KERNEL32.dll_GetLocaleInfoA;\n        }\n        else {\n            *0x499d68 = fcn.0041ae94;\n        }\n    }\n    if (param_1 == NULL) {\ncode_r0x0041b59f:\n        fcn.0041ade6();\ncode_r0x0041b5a4:\n        if (*0x499d48 == 0) {\n            return 0;\n        }\n    }\n    else {\n        *0x499d5c = param_1 + 0x40;\n        *0x499d64 = param_1;\n        if ((*0x499d5c != NULL) && (**0x499d5c != '\\0')) {\n            fcn.0041ad86(0x474ae0, 0x16, 0x499d5c);\n        }\n        *0x499d48 = 0;\n        if ((*0x499d64 == NULL) || (**0x499d64 == '\\0')) {\n            if ((*0x499d5c == NULL) || (**0x499d5c == '\\0')) goto code_r0x0041b59f;\n            fcn.0041b3b3();\n            goto code_r0x0041b5a4;\n        }\n        if ((*0x499d5c == NULL) || (**0x499d5c == '\\0')) {\n            fcn.0041b470();\n        }\n        else {\n            fcn.0041b3ea();\n        }\n        if (*0x499d48 == 0) {\n            iVar1 = fcn.0041ad86(0x474c90, 0x40, 0x499d64);\n            if (iVar1 != 0) {\n                if ((*0x499d5c == NULL) || (**0x499d5c == '\\0')) {\n                    fcn.0041b470();\n                }\n                else {\n                    fcn.0041b3ea();\n                }\n            }\n            goto code_r0x0041b5a4;\n        }\n    }\n    arg_8h = fcn.0041ae00();\n    if (((arg_8h == 0) || (iVar1 = (*_sym.imp.KERNEL32.dll_IsValidCodePage)(arg_8h & 0xffff),  iVar1 == 0)) ||\n       (iVar1 = (*_sym.imp.KERNEL32.dll_IsValidLocale)(*0x499d4c, 1),  uVar2 = *0x499d4c,  iVar1 == 0)) {\ncode_r0x0041b674:\n        uVar2 = 0;\n    }\n    else {\n        if (unaff_EBX != NULL) {\n            *unaff_EBX = *0x499d4c;\n            unaff_EBX[1] = *0x499d50;\n            unaff_EBX[2] = arg_8h;\n        }\n        if (unaff_retaddr != 0) {\n            if (*unaff_EBX == 0x814) {\n                fcn.00415f50(unaff_retaddr, \"Norwegian-Nynorsk\");\n            }\n            else {\n                iVar1 = (**0x499d68)(uVar2, 0x1001, unaff_retaddr, 0x40);\n                if (iVar1 == 0) goto code_r0x0041b674;\n            }\n            iVar1 = (**0x499d68)(*0x499d50, 0x1002, unaff_retaddr + 0x40, 0x40);\n            if (iVar1 == 0) goto code_r0x0041b674;\n            fcn.0041d22b(arg_8h, unaff_retaddr + 0x80, 10);\n        }\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 943
    },
    "0041b742": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.0041b742(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t in_ECX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint noname_3;\n    uint unaff_retaddr;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint in_stack_00000020;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint in_stack_0000002c;\n    uint in_stack_00000030;\n    uint in_stack_00000034;\n    uint32_t var_4h;\n    \n    uVar2 = arg_ch;\n    uVar1 = arg_8h;\n    if ((*(arg_8h + 0x14) == 0) || ((*(arg_8h + 0x24) != 0 && (arg_ch < 0x80)))) {\n        if ((0x40 < arg_ch) && (arg_ch < 0x5b)) {\n            return arg_ch + 0x20;\n        }\n    }\n    else {\n        noname_3 = 1;\n        var_4h = in_ECX;\n        if (arg_ch < 0x100) {\n            if (*(arg_8h + 0x28) < 2) {\n                uVar3 = *(*(arg_8h + 0x48) + arg_ch * 2) & 1;\n            }\n            else {\n                uVar3 = fcn.004166f8(arg_8h, arg_ch, 1);\n            }\n            if (uVar3 == 0) {\n                return uVar2;\n            }\n        }\n        if ((*(*(uVar1 + 0x48) + 1 + (uVar2 >> 8 & 0xffU) * 2) & 0x80) == 0) {\n            arg_8h = arg_8h & 0xffff0000 | uVar2 & 0xff;\n        }\n        else {\n            arg_8h = arg_8h & 0xff000000 | CONCAT11(uVar2, uVar2 >> 8);\n            noname_3 = 2;\n        }\n        iVar4 = fcn.00416182(*(uVar1 + 0x14), 0x100, &arg_8h, noname_3, &var_4h, 3, *(uVar1 + 4), 1, unaff_EDI, \n                             unaff_ESI, unaff_EBX, var_4h, unaff_EBP, unaff_retaddr, arg_8h, arg_ch, in_stack_0000000c, \n                             in_stack_00000010, in_stack_00000014, in_stack_00000018, in_stack_0000001c, \n                             in_stack_00000020, in_stack_00000024, in_stack_00000028, in_stack_0000002c, \n                             in_stack_00000030, in_stack_00000034);\n        if (iVar4 != 0) {\n            if (iVar4 != 1) {\n                return CONCAT11(var_4h, var_4h._1_1_);\n            }\n            return var_4h & 0xff;\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 837
    },
    "0041b82c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0041b82c(int32_t param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    iVar2 = param_2 / 0x20;\n    uVar1 = *(param_1 + iVar2 * 4) & ~(-1 << (0x1fU - param_2 % 0x20 & 0x1f));\n    while( true ) {\n        if (uVar1 != 0) {\n            return 0;\n        }\n        iVar2 = iVar2 + 1;\n        if (2 < iVar2) break;\n        uVar1 = *(param_1 + iVar2 * 4);\n    }\n    return 1;\n}\n",
        "token_count": 165
    },
    "0041b95d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041b95d(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint8_t uVar3;\n    uint *puVar4;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    uVar3 = arg_ch % 0x20;\n    iVar2 = 0;\n    var_4h = 0;\n    do {\n        uVar1 = *(arg_8h + iVar2 * 4);\n        *(arg_8h + iVar2 * 4) = uVar1 >> (uVar3 & 0x1f) | var_4h;\n        var_4h = (uVar1 & ~(-1 << (uVar3 & 0x1f))) << (0x20 - uVar3 & 0x1f);\n        iVar2 = iVar2 + 1;\n    } while (iVar2 < 3);\n    iVar2 = 2;\n    puVar4 = arg_8h + (2 - arg_ch / 0x20) * 4;\n    do {\n        if (iVar2 < arg_ch / 0x20) {\n            *(arg_8h + iVar2 * 4) = 0;\n        }\n        else {\n            *(arg_8h + iVar2 * 4) = *puVar4;\n        }\n        iVar2 = iVar2 + -1;\n        puVar4 = puVar4 + -1;\n    } while (-1 < iVar2);\n    return;\n}\n",
        "token_count": 353
    },
    "0041c293": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041c293(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    code *extraout_ECX;\n    code *arg_8h_00;\n    int32_t unaff_EBP;\n    code **ppcVar4;\n    code *pcVar5;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040daac(0x4752f8, 0x20);\n    *(unaff_EBP + -0x1c) = 0;\n    iVar1 = *(unaff_EBP + 8);\n    if (iVar1 == 2) {\n        ppcVar4 = 0x499d90;\n        pcVar5 = *0x499d90;\ncode_r0x0041c320:\n        *(unaff_EBP + -0x1c) = 1;\n        iVar1 = *(unaff_EBP + -0x24);\n    }\n    else {\n        if (((iVar1 != 4) && (iVar1 != 8)) && (iVar1 != 0xb)) {\n            if (iVar1 == 0xf) {\n                ppcVar4 = 0x499d9c;\n                pcVar5 = *0x499d9c;\n            }\n            else if (iVar1 == 0x15) {\n                ppcVar4 = 0x499d94;\n                pcVar5 = *0x499d94;\n            }\n            else {\n                if (iVar1 != 0x16) goto code_r0x0041c406;\n                ppcVar4 = 0x499d98;\n                pcVar5 = *0x499d98;\n            }\n            goto code_r0x0041c320;\n        }\n        iVar1 = fcn.00412cd5();\n        *(unaff_EBP + -0x24) = iVar1;\n        iVar2 = fcn.0041c0b2();\n        ppcVar4 = iVar2 + 8;\n        pcVar5 = *ppcVar4;\n    }\n    arg_8h_00 = NULL;\n    *(unaff_EBP + -0x20) = pcVar5;\n    if (pcVar5 == 0x1) goto code_r0x0041c406;\n    if (pcVar5 == NULL) {\n        fcn.0040f467(3);\n        arg_8h_00 = extraout_ECX;\n    }\n    if (*(unaff_EBP + -0x1c) != arg_8h_00) {\n        fcn.00410d9c(arg_8h_00);\n        arg_8h_00 = NULL;\n    }\n    *(unaff_EBP + -4) = arg_8h_00;\n    iVar2 = *(unaff_EBP + 8);\n    if (((iVar2 == 8) || (iVar2 == 0xb)) || (iVar2 == 4)) {\n        *(unaff_EBP + -0x2c) = *(iVar1 + 0x58);\n        *(iVar1 + 0x58) = arg_8h_00;\n        if (iVar2 == 8) {\n            *(unaff_EBP + -0x30) = *(iVar1 + 0x5c);\n            *(iVar1 + 0x5c) = 0x8c;\n            goto code_r0x0041c37f;\n        }\ncode_r0x0041c3ab:\n        *ppcVar4 = arg_8h_00;\n    }\n    else {\ncode_r0x0041c37f:\n        iVar3 = *0x496d10;\n        if (iVar2 != 8) goto code_r0x0041c3ab;\n        for (; *(unaff_EBP + -0x28) = iVar3,  iVar3 < *0x496d14 + *0x496d10; iVar3 = iVar3 + 1) {\n            *(*(iVar1 + 0x54) + 8 + iVar3 * 0xc) = arg_8h_00;\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041c3ce();\n    if (*(unaff_EBP + 8) == 8) {\n        (*pcVar5)(8, *(iVar1 + 0x5c));\n    }\n    else {\n        (*pcVar5)(*(unaff_EBP + 8));\n    }\n    iVar2 = *(unaff_EBP + 8);\n    if ((((iVar2 == 8) || (iVar2 == 0xb)) || (iVar2 == 4)) && (*(iVar1 + 0x58) = *(unaff_EBP + -0x2c),  iVar2 == 8)) {\n        *(iVar1 + 0x5c) = *(unaff_EBP + -0x30);\n    }\ncode_r0x0041c406:\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 1165
    },
    "0041c40c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0041c40c(uint32_t param_1, uint param_2)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint uVar4;\n    \n    if (param_1 < *0x49ae2c) {\n        piVar1 = (param_1 >> 5) * 4 + 0x49ae40;\n        iVar3 = (param_1 & 0x1f) * 0x24;\n        if (*(iVar3 + *piVar1) == -1) {\n            if (*0x496814 == 1) {\n                if (param_1 == 0) {\n                    uVar4 = 0xfffffff6;\n                }\n                else if (param_1 == 1) {\n                    uVar4 = 0xfffffff5;\n                }\n                else {\n                    if (param_1 != 2) goto code_r0x0041c465;\n                    uVar4 = 0xfffffff4;\n                }\n                (*_sym.imp.KERNEL32.dll_SetStdHandle)(uVar4, param_2);\n            }\ncode_r0x0041c465:\n            *(iVar3 + *piVar1) = param_2;\n            return 0;\n        }\n    }\n    puVar2 = fcn.00410979();\n    *puVar2 = 9;\n    puVar2 = fcn.00410982();\n    *puVar2 = 0;\n    return 0xffffffff;\n}\n",
        "token_count": 332
    },
    "0041c488": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0041c488(uint32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint uVar5;\n    \n    if (param_1 < *0x49ae2c) {\n        piVar1 = (param_1 >> 5) * 4 + 0x49ae40;\n        iVar4 = (param_1 & 0x1f) * 0x24;\n        piVar2 = *piVar1 + iVar4;\n        if (((*(piVar2 + 1) & 1) != 0) && (*piVar2 != -1)) {\n            if (*0x496814 == 1) {\n                if (param_1 == 0) {\n                    uVar5 = 0xfffffff6;\n                }\n                else if (param_1 == 1) {\n                    uVar5 = 0xfffffff5;\n                }\n                else {\n                    if (param_1 != 2) goto code_r0x0041c4e4;\n                    uVar5 = 0xfffffff4;\n                }\n                (*_sym.imp.KERNEL32.dll_SetStdHandle)(uVar5, 0);\n            }\ncode_r0x0041c4e4:\n            *(iVar4 + *piVar1) = 0xffffffff;\n            return 0;\n        }\n    }\n    puVar3 = fcn.00410979();\n    *puVar3 = 9;\n    puVar3 = fcn.00410982();\n    *puVar3 = 0;\n    return 0xffffffff;\n}\n",
        "token_count": 364
    },
    "0041ca29": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint fcn.0041ca29(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t arg_10h;\n    \n    uVar2 = 0;\n    if (((param_1[3] & 3) == 2) && ((param_1[3] & 0x108U) != 0)) {\n        arg_10h = *param_1 - param_1[2];\n        if (0 < arg_10h) {\n            iVar1 = fcn.00418ad1(param_1[4], param_1[2], arg_10h);\n            if (iVar1 == arg_10h) {\n                if (param_1[3] < '\\0') {\n                    param_1[3] = param_1[3] & 0xfffffffd;\n                }\n            }\n            else {\n                param_1[3] = param_1[3] | 0x20;\n                uVar2 = 0xffffffff;\n            }\n        }\n    }\n    param_1[1] = 0;\n    *param_1 = param_1[2];\n    return uVar2;\n}\n",
        "token_count": 260
    },
    "0041cd0a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpBuffer\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.0041cd0a(uint32_t arg_8h, char *arg_ch, char *nNumberOfBytesToRead)\n\n{\n    int32_t *piVar1;\n    uint8_t *puVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char *pcVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    char *pcVar8;\n    int32_t iVar9;\n    int32_t lpNumberOfBytesRead;\n    char *var_8h;\n    uint lpBuffer;\n    \n    var_8h = NULL;\n    if (nNumberOfBytesToRead != NULL) {\n        piVar1 = (arg_8h >> 5) * 4 + 0x49ae40;\n        iVar9 = (arg_8h & 0x1f) * 0x24;\n        uVar3 = *(*piVar1 + iVar9 + 4);\n        if ((uVar3 & 2) == 0) {\n            pcVar8 = arg_ch;\n            if (((uVar3 & 0x48) != 0) && (*(*piVar1 + iVar9 + 5) != '\\n')) {\n                nNumberOfBytesToRead = nNumberOfBytesToRead + -1;\n                *arg_ch = *(*piVar1 + 5 + iVar9);\n                pcVar8 = arg_ch + 1;\n                var_8h = 0x1;\n                *(*piVar1 + 5 + iVar9) = 10;\n            }\n            iVar6 = (*_sym.imp.KERNEL32.dll_ReadFile)\n                              (*(*piVar1 + iVar9), pcVar8, nNumberOfBytesToRead, &lpNumberOfBytesRead, 0);\n            if (iVar6 == 0) {\n                iVar9 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                if (iVar9 == 5) {\n                    puVar7 = fcn.00410979();\n                    *puVar7 = 9;\n                    puVar7 = fcn.00410982();\n                    *puVar7 = 5;\n                }\n                else {\n                    if (iVar9 == 0x6d) {\n                        return 0;\n                    }\n                    fcn.0041098b(iVar9);\n                }\n                return -1;\n            }\n            if ((*(*piVar1 + 4 + iVar9) & 0x80) == 0) {\n                return var_8h + lpNumberOfBytesRead;\n            }\n            if ((lpNumberOfBytesRead == 0) || (*arg_ch != '\\n')) {\n                puVar2 = *piVar1 + 4 + iVar9;\n                *puVar2 = *puVar2 & 0xfb;\n            }\n            else {\n                puVar2 = *piVar1 + 4 + iVar9;\n                *puVar2 = *puVar2 | 4;\n            }\n            var_8h = arg_ch + var_8h + lpNumberOfBytesRead;\n            nNumberOfBytesToRead = arg_ch;\n            pcVar8 = arg_ch;\n            if (arg_ch < var_8h) {\n                do {\n                    cVar4 = *nNumberOfBytesToRead;\n                    if (cVar4 == '\\x1a') {\n                        if ((*(*piVar1 + 4 + iVar9) & 0x40) == 0) {\n                            puVar2 = *piVar1 + 4 + iVar9;\n                            *puVar2 = *puVar2 | 2;\n                        }\n                        break;\n                    }\n                    if (cVar4 == '\\r') {\n                        if (nNumberOfBytesToRead < var_8h + -1) {\n                            if (nNumberOfBytesToRead[1] == '\\n') {\n                                pcVar5 = nNumberOfBytesToRead + 2;\n                                goto code_r0x0041ce97;\n                            }\ncode_r0x0041ceb1:\n                            nNumberOfBytesToRead = nNumberOfBytesToRead + 1;\n                            *pcVar8 = '\\r';\n                        }\n                        else {\n                            pcVar5 = nNumberOfBytesToRead + 1;\n                            iVar6 = (*_sym.imp.KERNEL32.dll_ReadFile)\n                                              (*(*piVar1 + iVar9), &lpBuffer, 1, &lpNumberOfBytesRead, 0);\n                            if (((iVar6 == 0) && (iVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar6 != 0)) ||\n                               (lpNumberOfBytesRead == 0)) goto code_r0x0041ceb1;\n                            if ((*(*piVar1 + 4 + iVar9) & 0x48) == 0) {\n                                if ((pcVar8 == arg_ch) && (lpBuffer == '\\n')) goto code_r0x0041ce97;\n                                fcn.004187e4(arg_8h, 0xffffffff, 1);\n                                if (lpBuffer == '\\n') goto code_r0x0041ceb5;\n                                goto code_r0x0041ceb1;\n                            }\n                            if (lpBuffer == '\\n') {\ncode_r0x0041ce97:\n                                nNumberOfBytesToRead = pcVar5;\n                                *pcVar8 = '\\n';\n                            }\n                            else {\n                                *pcVar8 = '\\r';\n                                *(*piVar1 + 5 + iVar9) = lpBuffer;\n                                nNumberOfBytesToRead = pcVar5;\n                            }\n                        }\n                        pcVar8 = pcVar8 + 1;\n                        pcVar5 = nNumberOfBytesToRead;\n                    }\n                    else {\n                        *pcVar8 = cVar4;\n                        pcVar8 = pcVar8 + 1;\n                        pcVar5 = nNumberOfBytesToRead + 1;\n                    }\ncode_r0x0041ceb5:\n                    nNumberOfBytesToRead = pcVar5;\n                } while (nNumberOfBytesToRead < var_8h);\n            }\n            return pcVar8 - arg_ch;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1326
    },
    "0041cfde": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_84h\n\nvoid __cdecl fcn.0041cfde(int32_t arg_8h, uint arg_ch, uint arg_10h, int32_t *arg_14h)\n\n{\n    char cVar1;\n    bool bVar2;\n    int32_t iVar3;\n    uint *noname_2;\n    int32_t iVar4;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    char *pcVar5;\n    uint var_84h;\n    uint in_stack_ffffff7c;\n    uint in_stack_ffffff80;\n    uint var_4h;\n    \n    if (arg_8h != 1) {\n        if (arg_8h == 0) {\n            pcVar5 = 0x499da4;\n            iVar3 = fcn.0041de4c(arg_ch, arg_10h, 0x499da4, 4, 0, unaff_EDI, unaff_ESI, unaff_EBX, var_84h, \n                                 in_stack_ffffff7c, in_stack_ffffff80);\n            if (iVar3 != 0) {\n                *arg_14h = '\\0';\n                do {\n                    cVar1 = *pcVar5;\n                    iVar3 = fcn.0041817f(cVar1);\n                    if (iVar3 == 0) break;\n                    pcVar5 = pcVar5 + 2;\n                    *arg_14h = *arg_14h * '\\n' + cVar1 + -0x30;\n                } while (pcVar5 < 0x499dac);\n            }\n        }\n        goto code_r0x0041d090;\n    }\n    noname_2 = &var_84h;\n    bVar2 = false;\n    iVar3 = fcn.0041df7c(arg_ch, arg_10h, noname_2, 0x80, 0, unaff_EDI, unaff_ESI, unaff_EBX, var_84h, in_stack_ffffff7c\n                         , in_stack_ffffff80);\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (((iVar3 != 0x7a) ||\n            (iVar3 = fcn.0041df7c(arg_ch, arg_10h, 0, 0, 0, unaff_EDI, unaff_ESI, unaff_EBX, var_84h, in_stack_ffffff7c\n                                  , in_stack_ffffff80),  iVar3 == 0)) ||\n           (noname_2 = fcn.0040d946(iVar3),  noname_2 == NULL)) goto code_r0x0041d090;\n        bVar2 = true;\n        iVar3 = fcn.0041df7c(arg_ch, arg_10h, noname_2, iVar3, 0, unaff_EDI, unaff_ESI, unaff_EBX, var_84h, \n                             in_stack_ffffff7c, in_stack_ffffff80);\n        if (iVar3 != 0) goto code_r0x0041d071;\n    }\n    else {\ncode_r0x0041d071:\n        iVar4 = fcn.0040d946(iVar3);\n        *arg_14h = iVar4;\n        if (iVar4 != 0) {\n            fcn.004185b0(iVar4, noname_2, iVar3);\n            if (bVar2) {\n                fcn.0040d958(noname_2);\n            }\n            goto code_r0x0041d090;\n        }\n        if (!bVar2) goto code_r0x0041d090;\n    }\n    fcn.0040d958(noname_2);\ncode_r0x0041d090:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 867
    },
    "0041d105": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041d105(uint8_t *arg_8h, uint8_t *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar1 = fcn.00412cd5();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x496dc4) {\n        iVar1 = fcn.00416a84();\n    }\n    if (*(iVar1 + 0x14) == 0) {\n        iVar2 = fcn.0041cf90(arg_8h, arg_ch);\n    }\n    else {\n        do {\n            iVar2 = fcn.0041b742(iVar1, *arg_8h);\n            arg_8h = arg_8h + 1;\n            iVar3 = fcn.0041b742(iVar1, *arg_ch);\n            arg_ch = arg_ch + 1;\n            if (iVar2 == 0) break;\n        } while (iVar2 == iVar3);\n        iVar2 = iVar2 - iVar3;\n    }\n    return iVar2;\n}\n",
        "token_count": 256
    },
    "0041d16e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041d16e(uint8_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar1 = fcn.00412cd5();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x496dc4) {\n        iVar1 = fcn.00416a84();\n    }\n    if (arg_10h == 0) {\n        iVar2 = 0;\n    }\n    else if (*(iVar1 + 0x14) == 0) {\n        iVar2 = fcn.0041e0c0(arg_8h, arg_ch, arg_10h);\n    }\n    else {\n        do {\n            iVar2 = fcn.0041b742(iVar1, *arg_8h);\n            arg_8h = arg_8h + 1;\n            iVar3 = fcn.0041b742(iVar1, *arg_ch);\n            arg_ch = arg_ch + 1;\n            arg_10h = arg_10h + -1;\n            if ((arg_10h == 0) || (iVar2 == 0)) break;\n        } while (iVar2 == iVar3);\n        iVar2 = iVar2 - iVar3;\n    }\n    return iVar2;\n}\n",
        "token_count": 318
    },
    "0041d1ed": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041d1ed(char *param_1, uint32_t param_2, int32_t param_3)\n\n{\n    uint64_t uVar1;\n    char *pcVar2;\n    uint32_t in_EAX;\n    char *pcVar3;\n    char cVar4;\n    \n    pcVar2 = param_1;\n    if (param_3 != 0) {\n        *param_1 = '-';\n        param_1 = param_1 + 1;\n        in_EAX = -in_EAX;\n        pcVar2 = param_1;\n    }\n    do {\n        pcVar3 = pcVar2;\n        uVar1 = in_EAX;\n        in_EAX = in_EAX / param_2;\n        cVar4 = uVar1 % param_2;\n        if (uVar1 % param_2 < 10) {\n            cVar4 = cVar4 + '0';\n        }\n        else {\n            cVar4 = cVar4 + 'W';\n        }\n        *pcVar3 = cVar4;\n        pcVar2 = pcVar3 + 1;\n    } while (in_EAX != 0);\n    pcVar3[1] = '\\0';\n    do {\n        cVar4 = *pcVar3;\n        *pcVar3 = *param_1;\n        pcVar3 = pcVar3 + -1;\n        *param_1 = cVar4;\n        param_1 = param_1 + 1;\n    } while (param_1 < pcVar3);\n    return;\n}\n",
        "token_count": 342
    },
    "0041d34f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041d34f(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint in_stack_00000020;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint in_stack_0000002c;\n    uint in_stack_00000030;\n    uint in_stack_00000034;\n    uint in_stack_00000038;\n    uint in_stack_0000003c;\n    uint in_stack_00000040;\n    uint in_stack_00000044;\n    uint in_stack_00000048;\n    uint in_stack_0000004c;\n    uint in_stack_00000050;\n    \n    iVar1 = fcn.00412cd5();\n    iVar1 = *(iVar1 + 0x60);\n    if (iVar1 != *0x49af6c) {\n        iVar1 = fcn.0040fc0e();\n    }\n    if (arg_10h == 0) {\n        return 0;\n    }\n    iVar1 = fcn.0041e13d(*(iVar1 + 0xc), 1, arg_8h, arg_10h, arg_ch, arg_10h, *(iVar1 + 4), unaff_EBP, unaff_retaddr, \n                         arg_8h, arg_ch, arg_10h, in_stack_00000010, in_stack_00000014, in_stack_00000018, \n                         in_stack_0000001c, in_stack_00000020, in_stack_00000024, in_stack_00000028, in_stack_0000002c, \n                         in_stack_00000030, in_stack_00000034, in_stack_00000038, in_stack_0000003c, in_stack_00000040, \n                         in_stack_00000044, in_stack_00000048, in_stack_0000004c, in_stack_00000050);\n    if (iVar1 == 0) {\n        return 0x7fffffff;\n    }\n    return iVar1 + -2;\n}\n",
        "token_count": 517
    },
    "0041da19": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041da19(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint var_10h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    fcn.0041d5e5(&var_10h, arg_ch, arg_10h, arg_14h, 0, 0, 0);\n    fcn.0041bb5c(&var_10h, arg_8h);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 133
    },
    "0041da65": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.0041da65(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h, int32_t arg_14h, uint32_t arg_18h, int16_t *arg_1ch)\n\n{\n    int16_t *piVar1;\n    char cVar2;\n    uint32_t uVar3;\n    int16_t *piVar4;\n    int16_t *piVar5;\n    int16_t iVar6;\n    int32_t iVar7;\n    char *pcVar8;\n    int16_t *var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint uStack40;\n    uint uStack36;\n    uint var_1ch;\n    uchar var_18h;\n    uchar var_17h;\n    uchar var_16h;\n    uchar var_15h;\n    uchar var_14h;\n    uchar var_13h;\n    uchar var_12h;\n    uchar var_11h;\n    ushort var_10h;\n    uint var_eh;\n    uint32_t var_ah;\n    uchar var_6h;\n    char var_5h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    uVar3 = arg_10h & 0x7fff;\n    var_1ch._0_1_ = 0xcc;\n    var_1ch._1_1_ = 0xcc;\n    var_1ch._2_1_ = 0xcc;\n    var_1ch._3_1_ = 0xcc;\n    var_18h = 0xcc;\n    var_17h = 0xcc;\n    var_16h = 0xcc;\n    var_15h = 0xcc;\n    var_14h = 0xcc;\n    var_13h = 0xcc;\n    var_12h = 0xfb;\n    var_11h = 0x3f;\n    if ((arg_10h & 0x8000) == 0) {\n        *(arg_1ch + 1) = 0x20;\n    }\n    else {\n        *(arg_1ch + 1) = 0x2d;\n    }\n    if (((uVar3 == 0) && (arg_ch == 0)) && (arg_8h == 0)) {\ncode_r0x0041dbdb:\n        *(arg_1ch + 2) = 0x30;\ncode_r0x0041dcde:\n        *arg_1ch = 0;\n        *(arg_1ch + 1) = 0x20;\n        *(arg_1ch + 3) = 1;\n        *(arg_1ch + 5) = 0;\n    }\n    else {\n        if (uVar3 == 0x7fff) {\n            *arg_1ch = 1;\n            if (((arg_ch == 0x80000000) && (arg_8h == 0)) || ((arg_ch & 0x40000000) != 0)) {\n                if (((arg_10h & 0x8000) == 0) || (arg_ch != 0xc0000000)) {\n                    if ((arg_ch != 0x80000000) || (arg_8h != 0)) goto code_r0x0041db51;\n                    pcVar8 = \"1#INF\";\n                }\n                else {\n                    if (arg_8h != 0) {\ncode_r0x0041db51:\n                        pcVar8 = \"1#QNAN\";\n                        goto code_r0x0041db56;\n                    }\n                    pcVar8 = \"1#IND\";\n                }\n                fcn.00415f50(arg_1ch + 2, pcVar8);\n                *(arg_1ch + 3) = 5;\n            }\n            else {\n                pcVar8 = \"1#SNAN\";\ncode_r0x0041db56:\n                fcn.00415f50(arg_1ch + 2, pcVar8);\n                *(arg_1ch + 3) = 6;\n            }\n            goto code_r0x0041dcc0;\n        }\n        var_10h = 0;\n        iVar6 = ((uVar3 >> 8) + (arg_ch >> 0x18) * 2) * 0x4d + -0x134312f4 + uVar3 * 0x4d10 >> 0x10;\n        var_6h = uVar3;\n        var_5h = uVar3 >> 8;\n        var_eh = arg_8h;\n        var_ah = arg_ch;\n        fcn.0041e976(&var_10h, -iVar6, 1);\n        if (0x3ffe < CONCAT11(var_5h, var_6h)) {\n            iVar6 = iVar6 + 1;\n            fcn.0041e744(&var_10h, &var_1ch);\n        }\n        *arg_1ch = iVar6;\n        if (((arg_18h & 1) != 0) && (arg_14h = arg_14h + iVar6,  arg_14h < 1)) goto code_r0x0041dbdb;\n        if (0x15 < arg_14h) {\n            arg_14h = 0x15;\n        }\n        iVar7 = CONCAT11(var_5h, var_6h) - 0x3ffe;\n        var_6h = 0;\n        var_5h = '\\0';\n        arg_10h = 8;\n        do {\n            fcn.0041d4ac(&var_10h);\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n        if (iVar7 < 0) {\n            for (uVar3 = -iVar7 & 0xff; uVar3 != 0; uVar3 = uVar3 - 1) {\n                fcn.0041d4da(&var_10h);\n            }\n        }\n        arg_10h = arg_14h + 1;\n        piVar4 = arg_1ch + 2;\n        var_30h = piVar4;\n        if (0 < arg_10h) {\n            do {\n                var_ah._2_2_ = var_ah >> 0x10;\n                var_eh._2_2_ = var_eh >> 0x10;\n                var_28h = CONCAT22(var_eh, var_10h);\n                uStack40 = CONCAT22(var_ah, var_eh._2_2_);\n                uStack36 = CONCAT13(var_5h, CONCAT12(var_6h, var_ah._2_2_));\n                fcn.0041d4ac(&var_10h);\n                fcn.0041d4ac(&var_10h);\n                fcn.0041d44e(&var_10h, &var_28h);\n                fcn.0041d4ac(&var_10h);\n                piVar4 = var_30h + 1;\n                arg_10h = arg_10h + -1;\n                *var_30h = var_5h + '0';\n                var_5h = '\\0';\n                var_30h = piVar4;\n            } while (arg_10h != 0);\n        }\n        piVar5 = piVar4 + -1;\n        piVar1 = arg_1ch + 2;\n        if (*(piVar4 + -1) < '5') {\n            for (; (piVar1 <= piVar5 && (*piVar5 == '0')); piVar5 = piVar5 + -1) {\n            }\n            if (piVar5 < piVar1) {\n                *piVar1 = 0x30;\n                goto code_r0x0041dcde;\n            }\n        }\n        else {\n            for (; (piVar1 <= piVar5 && (*piVar5 == '9')); piVar5 = piVar5 + -1) {\n                *piVar5 = 0x30;\n            }\n            if (piVar5 < piVar1) {\n                piVar5 = piVar5 + 1;\n                *arg_1ch = *arg_1ch + 1;\n            }\n            *piVar5 = *piVar5 + '\\x01';\n        }\n        cVar2 = (piVar5 - arg_1ch) + -3;\n        *(arg_1ch + 3) = cVar2;\n        *(cVar2 + 4 + arg_1ch) = 0;\n    }\ncode_r0x0041dcc0:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 1944
    },
    "0041dd90": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041dd90(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040daac(0x4753c8, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x49ae2c) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x49ae40;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.0041c548(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\ncode_r0x0041de10:\n                puVar3 = fcn.00410979();\n                *puVar3 = 9;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.0041c507(arg_8h_00);\n                iVar4 = (*_sym.imp.KERNEL32.dll_FlushFileBuffers)(uVar2);\n                if (iVar4 == 0) {\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    *(unaff_EBP + -0x1c) = uVar2;\n                }\n                else {\n                    *(unaff_EBP + -0x1c) = 0;\n                }\n                if (*(unaff_EBP + -0x1c) != 0) {\n                    puVar3 = fcn.00410982();\n                    *puVar3 = *(unaff_EBP + -0x1c);\n                    goto code_r0x0041de10;\n                }\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0041de30();\n            goto code_r0x0041de46;\n        }\n    }\n    puVar3 = fcn.00410979();\n    *puVar3 = 9;\ncode_r0x0041de46:\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 587
    },
    "0041e121": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0041e121(int32_t param_1)\n\n{\n    char *in_EAX;\n    int32_t iVar1;\n    \n    iVar1 = param_1;\n    if (param_1 != 0) {\n        do {\n            iVar1 = iVar1 + -1;\n            if (*in_EAX == '\\0') goto code_r0x0041e135;\n            in_EAX = in_EAX + 1;\n        } while (iVar1 != 0);\n    }\n    iVar1 = iVar1 + -1;\ncode_r0x0041e135:\n    return (param_1 - iVar1) + -1;\n}\n",
        "token_count": 144
    },
    "0041e50e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * fcn.0041e50e(void)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t *unaff_EDI;\n    uint var_4h;\n    \n    iVar3 = 0;\n    if (unaff_EDI != NULL) {\n        iVar1 = *unaff_EDI;\n        piVar2 = unaff_EDI;\n        while (iVar1 != 0) {\n            piVar2 = piVar2 + 1;\n            iVar3 = iVar3 + 1;\n            iVar1 = *piVar2;\n        }\n        piVar2 = fcn.0040d946(iVar3 * 4 + 4);\n        if (piVar2 == NULL) {\n            fcn.0040e299(9);\n        }\n        iVar3 = *unaff_EDI;\n        piVar4 = piVar2;\n        while (iVar3 != 0) {\n            iVar3 = fcn.0040f496(iVar3);\n            *piVar4 = iVar3;\n            piVar4 = piVar4 + 1;\n            unaff_EDI = unaff_EDI + 1;\n            iVar3 = *unaff_EDI;\n        }\n        *piVar4 = 0;\n        return piVar2;\n    }\n    return unaff_EDI;\n}\n",
        "token_count": 308
    },
    "0041fb0e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041fb0e(uint *param_1)\n\n{\n    if (*(param_1 + 1) != '\\0') {\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(*param_1);\n        *(param_1 + 1) = 0;\n    }\n    return;\n}\n",
        "token_count": 70
    },
    "004200d9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004200d9(char *arg_8h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    int32_t arg_8h_00;\n    int32_t *lpArguments;\n    char *pcVar6;\n    bool bVar7;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x8007007e;\n    if (*(*0x40003c + 0x4000e4) != 0) {\n        for (arg_8h_00 = *(*0x40003c + 0x4000e0) + 0x400000; iVar2 = *(arg_8h_00 + 4),  iVar2 != 0;\n            arg_8h_00 = arg_8h_00 + 0x20) {\n            pcVar4 = iVar2 + 0x400000;\n            do {\n                cVar1 = *pcVar4;\n                pcVar4 = pcVar4 + 1;\n            } while (cVar1 != '\\0');\n            iVar5 = pcVar4 - (iVar2 + 0x400001);\n            pcVar4 = arg_8h;\n            do {\n                cVar1 = *pcVar4;\n                pcVar4 = pcVar4 + 1;\n            } while (cVar1 != '\\0');\n            if (iVar5 == pcVar4 - (arg_8h + 1)) {\n                bVar7 = true;\n                pcVar4 = arg_8h;\n                pcVar6 = iVar2 + 0x400000;\n                do {\n                    if (iVar5 == 0) break;\n                    iVar5 = iVar5 + -1;\n                    bVar7 = *pcVar4 == *pcVar6;\n                    pcVar4 = pcVar4 + 1;\n                    pcVar6 = pcVar6 + 1;\n                } while (bVar7);\n                if (bVar7) break;\n            }\n        }\n        if (*(arg_8h_00 + 4) != 0) {\n            lpArguments = *(arg_8h_00 + 0xc) + 0x400000;\n            iVar5 = 0;\n            iVar2 = *lpArguments;\n            piVar3 = lpArguments;\n            while (iVar2 != 0) {\n                piVar3 = piVar3 + 1;\n                iVar5 = iVar5 + 1;\n                iVar2 = *piVar3;\n            }\n            piVar3 = lpArguments + iVar5;\n            for (; lpArguments < piVar3; lpArguments = lpArguments + 1) {\n                fcn.0041fe7a(arg_8h_00, lpArguments);\n            }\n            var_4h = 0;\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 642
    },
    "00420189": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00420189(char *arg_8h)\n\n{\n    char cVar1;\n    uint uVar2;\n    char *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    uint *puVar7;\n    int32_t *piVar8;\n    char *pcVar9;\n    int32_t *piVar10;\n    bool bVar11;\n    uint var_ch;\n    uint var_8h;\n    int32_t *var_4h;\n    \n    var_8h = 0;\n    var_4h = *0x499df8;\n    if (*0x499df8 != NULL) {\n        do {\n            pcVar9 = *(var_4h[1] + 4) + 0x400000;\n            pcVar3 = pcVar9;\n            do {\n                cVar1 = *pcVar3;\n                pcVar3 = pcVar3 + 1;\n            } while (cVar1 != '\\0');\n            iVar4 = pcVar3 - (*(var_4h[1] + 4) + 0x400001);\n            pcVar3 = arg_8h;\n            do {\n                cVar1 = *pcVar3;\n                pcVar3 = pcVar3 + 1;\n            } while (cVar1 != '\\0');\n            if (iVar4 == pcVar3 - (arg_8h + 1)) {\n                bVar11 = true;\n                pcVar3 = arg_8h;\n                do {\n                    if (iVar4 == 0) break;\n                    iVar4 = iVar4 + -1;\n                    bVar11 = *pcVar3 == *pcVar9;\n                    pcVar3 = pcVar3 + 1;\n                    pcVar9 = pcVar9 + 1;\n                } while (bVar11);\n                if (bVar11) break;\n            }\n            var_4h = *var_4h;\n        } while (var_4h != NULL);\n        if ((var_4h != NULL) && (iVar4 = var_4h[1],  *(iVar4 + 0x18) != 0)) {\n            puVar7 = *(iVar4 + 8) + 0x400000;\n            uVar2 = *puVar7;\n            piVar10 = *(iVar4 + 0xc) + 0x400000;\n            piVar8 = *(iVar4 + 0x18) + 0x400000;\n            iVar5 = 0;\n            iVar4 = *piVar10;\n            piVar6 = piVar10;\n            while (iVar4 != 0) {\n                piVar6 = piVar6 + 1;\n                iVar5 = iVar5 + 1;\n                iVar4 = *piVar6;\n            }\n            for (; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *piVar10 = *piVar8;\n                piVar8 = piVar8 + 1;\n                piVar10 = piVar10 + 1;\n            }\n            (*_sym.imp.KERNEL32.dll_FreeLibrary)(uVar2);\n            *puVar7 = 0;\n            fcn.0041fdac();\n            (*_sym.imp.KERNEL32.dll_LocalFree)(var_4h);\n            var_8h = 1;\n        }\n    }\n    return var_8h;\n}\n",
        "token_count": 745
    },
    "004203cd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004203cd(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    \n    if (arg_8h == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.USER32.dll_GetParent)(arg_8h);\n    uVar2 = fcn.00427905(uVar2);\n    piVar3 = fcn.0042c6eb(0x470424, uVar2);\n    if (piVar3 != NULL) {\n        if (arg_ch == 0x400) {\n            uVar2 = (**(*piVar3 + 0x158))(arg_10h, arg_10h >> 0x10, arg_14h);\n            return uVar2;\n        }\n        if ((0x400 < arg_ch) && (arg_ch < 0x407)) {\n            iVar1 = *piVar3;\n            uVar2 = fcn.00432120(arg_10h, arg_ch, arg_14h);\n            uVar2 = (**(iVar1 + 0x15c))(uVar2);\n            return uVar2;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 295
    },
    "004204d7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.004204d7(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint16_t *puVar3;\n    int32_t iVar4;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalLock;\n    if (param_1 == 0) {\n        uVar2 = 0;\n    }\n    else {\n        iVar4 = param_1;\n        puVar3 = (*_sym.imp.KERNEL32.dll_GlobalLock)(param_1);\n        if (param_1 == 0) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*pcVar1)(param_1);\n        }\n        if (puVar3 == NULL) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*_sym.imp.GDI32.dll_CreateDCA)(*puVar3 + puVar3, puVar3[1] + puVar3, puVar3[2] + puVar3, uVar2);\n            pcVar1 = _sym.imp.KERNEL32.dll_GlobalUnlock;\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(iVar4);\n            if (param_1 != 0) {\n                (*pcVar1)(param_1);\n            }\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 292
    },
    "004205cd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\ncode ** __cdecl fcn.004205cd(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0042b093(0, *(unaff_EBP + 0x10));\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.CPrintDialog.0;\n    extraout_ECX[0x1c] = extraout_ECX + 0x1d;\n    fcn.0040e620(extraout_ECX + 0x1d, 0, 0x42);\n    *extraout_ECX[0x1c] = 0x42;\n    *(extraout_ECX[0x1c] + 0x14) = *(unaff_EBP + 0xc) | 0x3000;\n    iVar3 = fcn.0042b3c5();\n    if (iVar3 != 0) {\n        extraout_ECX[0x1c][0x15] = extraout_ECX[0x1c][0x15] | 8;\n    }\n    iVar3 = *(unaff_EBP + 8);\n    *(extraout_ECX[0x1c] + 0x2a) = fcn.004212e9;\n    *(extraout_ECX[0x1c] + 0x2e) = fcn.004212e9;\n    if (iVar3 == 0) {\n        extraout_ECX[0x14] = 0x7008;\n        pcVar2 = extraout_ECX[0x1c] + 0x15;\n        *pcVar2 = *pcVar2 | 1;\n    }\n    else {\n        extraout_ECX[0x14] = 0x7009;\n        puVar1 = extraout_ECX[0x1c] + 0x14;\n        *puVar1 = *puVar1 | 0x40;\n    }\n    extraout_ECX[0x1c][0x15] = extraout_ECX[0x1c][0x15] & 0xfd;\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 634
    },
    "00420882": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00420882(int32_t param_1)\n\n{\n    bool bVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    \n    iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*(*(param_1 + 0x70) + 0x1c));\n    bVar1 = false;\n    fcn.0040e620(*(*(param_1 + 0x70) + 0x1c) + iVar3 + 1, 0, *(*(param_1 + 0x70) + 0x20) - (iVar3 + 1));\n    (*_sym.imp.USER32.dll_GetFocus)();\n    iVar3 = *(param_1 + 0x70);\n    uVar4 = fcn.0042b29e();\n    *(iVar3 + 4) = uVar4;\n    fcn.00427986();\n    pcVar2 = _sym.imp.USER32.dll_EnableWindow;\n    if (*(*(param_1 + 0x70) + 4) != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*(*(param_1 + 0x70) + 4));\n        if (iVar3 != 0) {\n            bVar1 = true;\n            (*pcVar2)(*(*(param_1 + 0x70) + 4), 0);\n        }\n    }\n    iVar3 = fcn.0044bde5();\n    if ((*(*(param_1 + 0x70) + 0x36) & 8) == 0) {\n        fcn.004293a0(param_1);\n    }\n    else {\n        *(iVar3 + 0x18) = param_1;\n    }\n    if (*(param_1 + 0x74) == 0) {\n        (*_sym.imp.comdlg32.dll_GetSaveFileNameA)(*(param_1 + 0x70));\n    }\n    else {\n        (*_sym.imp.comdlg32.dll_GetOpenFileNameA)();\n    }\n    *(iVar3 + 0x18) = 0;\n    if (bVar1) {\n        (*pcVar2)(*(*(param_1 + 0x70) + 4), 1);\n    }\n    iVar3 = (*_sym.imp.USER32.dll_IsWindow)(unaff_EBP);\n    if (iVar3 != 0) {\n        (*_sym.imp.USER32.dll_SetFocus)(unaff_ESI);\n    }\n    fcn.0042b2d8();\n    if (unaff_EBP == 0) {\n        unaff_EBP = 2;\n    }\n    return unaff_EBP;\n}\n",
        "token_count": 606
    },
    "00420bdb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_a8h\n// WARNING: Variable defined which should be unmapped: var_a0h\n// WARNING: Variable defined which should be unmapped: lpVersionInformation\n\nvoid __cdecl\nfcn.00420bdb(uint arg_8h, uint arg_ch, uint lpString2, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    code **ppcVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    uchar *puVar7;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_a8h;\n    uint lpVersionInformation;\n    uint var_a0h;\n    uint var_94h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = *0x496830;\n    *(unaff_EBP + -0xa8) = extraout_ECX;\n    fcn.0042b093(0, *(unaff_EBP + 0x1c));\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.CFileDialog.0;\n    fcn.00403c40();\n    *(unaff_EBP + -4) = 1;\n    if (*(unaff_EBP + 0x20) == 0) {\n        fcn.0040e620(unaff_EBP + -0xa4, 0, 0x94);\n        *(unaff_EBP + -0xa4) = 0x94;\n        (*_sym.imp.KERNEL32.dll_GetVersionExA)(unaff_EBP + -0xa4);\n        if ((*(unaff_EBP + -0x94) != 2) || (*(unaff_EBP + 0x20) = 0x58,  *(unaff_EBP + -0xa0) < 5)) {\n            *(unaff_EBP + 0x20) = 0x4c;\n        }\n    }\n    pcVar5 = fcn.0040d946(*(unaff_EBP + 0x20));\n    extraout_ECX[0x1c] = pcVar5;\n    if (pcVar5 == NULL) {\n        pcVar5 = fcn.004202f9();\n    }\n    fcn.0040e620(pcVar5, 0, *(unaff_EBP + 0x20));\n    pcVar5 = *(unaff_EBP + 8);\n    uVar2 = *(unaff_EBP + 0x20);\n    extraout_ECX[0x1d] = pcVar5;\n    extraout_ECX[0x14] = 0x7005 - (pcVar5 != NULL);\n    extraout_ECX[0x70] = NULL;\n    *(extraout_ECX + 0x1f) = 0;\n    ppcVar1 = extraout_ECX + 0x2f;\n    *ppcVar1 = 0;\n    *extraout_ECX[0x1c] = uVar2;\n    uVar2 = *(unaff_EBP + 0xc);\n    *(extraout_ECX[0x1c] + 0x1c) = ppcVar1;\n    *(extraout_ECX[0x1c] + 0x20) = 0x104;\n    *(extraout_ECX[0x1c] + 0x3c) = uVar2;\n    uVar3 = *(unaff_EBP + 0x14);\n    *(extraout_ECX[0x1c] + 0x24) = extraout_ECX + 0x1f;\n    *(extraout_ECX[0x1c] + 0x28) = 0x40;\n    *(extraout_ECX[0x1c] + 0x34) = *(extraout_ECX[0x1c] + 0x34) | uVar3 | 0x80020;\n    if ((*(unaff_EBP + 0x14) & 0x40) != 0) {\n        extraout_ECX[0x1c][0x36] = extraout_ECX[0x1c][0x36] & 0x7f;\n    }\n    iVar6 = fcn.0044be10();\n    iVar4 = *(unaff_EBP + 0x10);\n    *(extraout_ECX[0x1c] + 8) = *(iVar6 + 0xc);\n    *(extraout_ECX[0x1c] + 0x44) = fcn.004212e9;\n    if (iVar4 != 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(ppcVar1, *(unaff_EBP + 0x10), 0x104);\n    }\n    if (*(unaff_EBP + 0x18) != 0) {\n        fcn.004045a1(*(unaff_EBP + 0x18));\n        puVar7 = fcn.004043ec(0);\n        while( true ) {\n            puVar7 = fcn.0040ef28(puVar7, 0x7c);\n            if (puVar7 == NULL) break;\n            *puVar7 = 0;\n            puVar7 = puVar7 + 1;\n        }\n        *(extraout_ECX[0x1c] + 0xc) = extraout_ECX[0x1e];\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 1304
    },
    "00420d7b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint __cdecl fcn.00420d7b(uint arg_8h)\n\n{\n    uint8_t uVar1;\n    code *pcVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint uVar6;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    uVar1 = *(*(extraout_ECX + 0x70) + 0x36);\n    *(unaff_EBP + -0x14) = 0;\n    if (((uVar1 & 8) != 0) && (*(extraout_ECX + 0x1c) != 0)) {\n        piVar3 = fcn.0042c770();\n        iVar4 = (**(*piVar3 + 0xc))();\n        *(unaff_EBP + -0x10) = iVar4 + 0x10;\n        pcVar2 = _sym.imp.USER32.dll_GetParent;\n        uVar6 = *(extraout_ECX + 0x1c);\n        *(unaff_EBP + -4) = 0;\n        uVar5 = (*pcVar2)(uVar6);\n        uVar5 = fcn.004278de(uVar5);\n        *(unaff_EBP + -0x14) = uVar5;\n        uVar5 = fcn.004043ec(0x104);\n        iVar4 = (*_sym.imp.USER32.dll_SendMessageA)(*(*(unaff_EBP + -0x14) + 0x1c), 0x464, 0x104, uVar5);\n        if (iVar4 < 0) {\n            fcn.004042f6();\n        }\n        else {\n            fcn.00404cad(uVar6, 0xffffffff);\n        }\n        if (*(*(unaff_EBP + -0x10) + -0xc) != 0) {\n            uVar6 = (*pcVar2)(*(extraout_ECX + 0x1c));\n            iVar4 = fcn.004278de(uVar6);\n            uVar6 = fcn.004043ec(0x104);\n            iVar4 = (*_sym.imp.USER32.dll_SendMessageA)(*(iVar4 + 0x1c), 0x465, 0x104, uVar6);\n            if (-1 < iVar4) {\n                fcn.00404cad(0xffffffff);\n                fcn.004039b4(unaff_EBP + -0x10);\n                fcn.00403164();\n                goto code_r0x00420e5e;\n            }\n            fcn.004042f6();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00403164();\n    }\n    fcn.004045fc(*(*(extraout_ECX + 0x70) + 0x1c));\ncode_r0x00420e5e:\n    uVar6 = *(unaff_EBP + 8);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar6;\n}\n",
        "token_count": 768
    },
    "00447082": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.00447082(uint32_t arg_8h, uint32_t wParam, int32_t lParam, int32_t *arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    uint32_t var_ch;\n    int32_t *var_8h;\n    uint32_t var_4h;\n    \n    if (arg_8h == 0x2b) {\n        var_4h = lParam;\n        var_8h = 0x447107;\n        (**(*in_ECX + 0x134))();\n        return 1;\n    }\n    if (arg_8h == 0x2c) {\n        var_4h = lParam;\n        var_8h = 0x4470fa;\n        (**(*in_ECX + 0x138))();\n        return 1;\n    }\n    if (arg_8h == 0x2d) {\n        var_4h = lParam;\n        var_8h = 0x4470ed;\n        (**(*in_ECX + 0x140))();\n        return 1;\n    }\n    if (arg_8h == 0x2e) {\n        var_4h = wParam >> 0x10;\n        var_8h = wParam & 0xffff;\n        var_ch = 0x4470e0;\n        iVar1 = (**(*in_ECX + 0x144))();\n    }\n    else if (arg_8h == 0x2f) {\n        var_4h = wParam >> 0x10;\n        var_8h = wParam & 0xffff;\n        var_ch = 0x4470c5;\n        iVar1 = (**(*in_ECX + 0x148))();\n    }\n    else {\n        if (arg_8h != 0x39) {\n            if (in_ECX[0x13] != 0) {\n                var_8h = lParam;\n                var_ch = wParam;\n                iVar1 = (*_sym.imp.USER32.dll_SendMessageA)(in_ECX[7], arg_8h + 0x2000);\n                if (((arg_8h < 0x132) || (0x138 < arg_8h)) || (iVar1 != 0)) {\n                    if (arg_14h != NULL) {\n                        *arg_14h = iVar1;\n                    }\n                    iVar1 = 1;\n                }\n                return iVar1;\n            }\n            if (arg_8h < 0x112) {\n                if (arg_8h == 0x111) {\n                    iVar1 = fcn.0042ab62(0, wParam >> 0x10 | 0xbd110000, 0, 0);\n                    if (iVar1 == 0) {\n                        return 0;\n                    }\n                    if (arg_14h != NULL) {\n                        *arg_14h = 1;\n                        return 1;\n                    }\n                    return 1;\n                }\n                if (0x2a < arg_8h) {\n                    if ((arg_8h < 0x30) || (arg_8h == 0x39)) goto code_r0x00429bc4;\n                    if (arg_8h == 0x4e) {\n                        var_8h = arg_14h;\n                        var_4h = lParam;\n                        iVar1 = fcn.0042ab62(0, *(lParam + 8) & 0xffff | 0xbc4e0000, &fcn.00447082::var_8h, 0);\n                        return iVar1;\n                    }\n                }\n            }\n            else if ((0x113 < arg_8h) && ((arg_8h < 0x116 || (arg_8h == 0x210)))) {\ncode_r0x00429bc4:\n                iVar1 = fcn.00429525(arg_8h + 0xbc00, wParam, lParam, arg_14h);\n                return iVar1;\n            }\n            if ((0x131 < arg_8h) && (arg_8h < 0x139)) {\n                var_4h = arg_8h - 0x132;\n                var_8h = wParam;\n                iVar1 = fcn.00429525(0xbc19, 0, &fcn.00447082::var_ch, arg_14h);\n                if (*arg_14h != 0) {\n                    return iVar1;\n                }\n            }\n            return 0;\n        }\n        var_4h = lParam;\n        var_8h = 0x4470af;\n        iVar1 = (**(*in_ECX + 0x13c))();\n    }\n    *arg_14h = iVar1;\n    return 1;\n}\n",
        "token_count": 1062
    },
    "00422971": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00422971(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    iVar1 = fcn.0044be36();\n    if ((*(iVar1 + 0x24) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.00425cd0(0x436878);\n        iVar3 = fcn.00425ce2(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0042d853(0x46e6f4, 0x44c98c, 0x44c964, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x24) = uVar4;\n        fcn.00425cd0(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x24);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 364
    },
    "0042d8dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t __cdecl fcn.0042d8dc(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t *piVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_8h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    arg_8h_00 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &stack0xffffffec;\n    if (arg_8h_00 == 0) {\n        iVar1 = 0;\n    }\n    else {\n        iVar1 = fcn.00425996(arg_8h_00);\n        if (iVar1 == 0) {\n            iVar1 = fcn.00425996(arg_8h_00);\n            if (iVar1 == 0) {\n                uVar2 = fcn.00425cd0(0x436878);\n                *(unaff_EBP + -4) = 0;\n                *(unaff_EBP + 8) = uVar2;\n                iVar1 = fcn.0040c5d4();\n                if (iVar1 == 0) {\n                    fcn.004202f9();\n                }\n                (**(extraout_ECX + 0x14))(iVar1);\n                piVar3 = fcn.00425b35(arg_8h_00);\n                uVar2 = *(unaff_EBP + 8);\n                *(unaff_EBP + -4) = 0xffffffff;\n                *piVar3 = iVar1;\n                fcn.00425cd0(uVar2);\n                piVar3 = *(extraout_ECX + 0x58) + iVar1;\n                *piVar3 = arg_8h_00;\n                if (*(extraout_ECX + 0x5c) == 2) {\n                    piVar3[1] = arg_8h_00;\n                }\n            }\n            else {\n                piVar3 = *(extraout_ECX + 0x58) + iVar1;\n                *piVar3 = arg_8h_00;\n                if (*(extraout_ECX + 0x5c) == 2) {\n                    piVar3[1] = arg_8h_00;\n                }\n            }\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1;\n}\n",
        "token_count": 613
    },
    "00422cb8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00422cb8(code **param_1)\n\n{\n    uint uVar1;\n    \n    *param_1 = vtable.CImageList.0;\n    if (param_1[1] == NULL) {\n        return 0;\n    }\n    uVar1 = fcn.004229ed();\n    uVar1 = (*_sym.imp.COMCTL32.dll_ImageList_Destroy)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 99
    },
    "004235c3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004235c3(uint arg_8h, uint arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t in_ECX;\n    uint var_30h;\n    uint var_20h;\n    uint var_ch;\n    \n    fcn.004234ee(&var_30h, arg_8h, arg_14h);\n    if (arg_10h != 0) {\n        fcn.0040e680(&var_20h, arg_10h, 0x10);\n    }\n    var_ch = arg_ch;\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x404, 0, &var_30h);\n    return;\n}\n",
        "token_count": 173
    },
    "00423611": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00423611(uint arg_8h, uint32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_30h;\n    uint var_20h;\n    uint var_10h;\n    uint32_t var_ch;\n    \n    fcn.004234ee(&var_30h, arg_8h, arg_14h);\n    if (arg_10h != 0) {\n        fcn.0040e680(&var_20h, arg_10h, 0x10);\n    }\n    iVar1 = fcn.0044be10();\n    var_10h = *(iVar1 + 0xc);\n    var_ch = arg_ch & 0xffff;\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x404, 0, &var_30h);\n    return;\n}\n",
        "token_count": 220
    },
    "00423b94": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00423b94(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    \n    iVar1 = fcn.0044be36();\n    iVar2 = *(iVar1 + 0x3c);\n    if (arg_8h == 0) {\n        if ((*(in_ECX + 0x38) & arg_ch) != 0) {\n            if (*(iVar1 + 0x40) == in_ECX) {\n                fcn.00426b72(1);\n            }\n            if ((iVar2 != 0) && (*(iVar2 + 0x1c) != 0)) {\n                fcn.0040e620(&var_30h, 0, 0x30);\n                var_28h = *(in_ECX + 0x1c);\n                var_30h = 0x28;\n                var_2ch = 1;\n                var_24h = var_28h;\n                (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x1c), 0x405, 0, &var_30h);\n            }\n            *(in_ECX + 0x38) = *(in_ECX + 0x38) & ~arg_ch;\n        }\n    }\n    else if ((*(in_ECX + 0x38) & arg_ch) == 0) {\n        iVar2 = fcn.0044be10();\n        *(iVar2 + 0x1034) = 0x423b39;\n        *(in_ECX + 0x38) = *(in_ECX + 0x38) | arg_ch;\n    }\n    return 1;\n}\n",
        "token_count": 419
    },
    "00424107": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool fcn.00424107(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.0044c3a2(0x424074);\n    if (*(iVar1 + 0x24) == 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"RICHED20.DLL\");\n        *(iVar1 + 0x24) = uVar2;\n    }\n    return *(iVar1 + 0x24) != 0;\n}\n",
        "token_count": 117
    },
    "00424530": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00424530(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    uint uStack8;\n    \n    if (*(param_1 + 0x10) == 0) {\n        uStack8 = 0xc;\n        iVar1 = fcn.00424db4(param_1 + 0x14, *(param_1 + 0x18));\n        iVar3 = *(param_1 + 0x18);\n        puVar2 = iVar1 + -8 + iVar3 * 0xc;\n        if (-1 < iVar3 + -1) {\n            do {\n                *puVar2 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar2;\n                puVar2 = puVar2 + -3;\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n    }\n    puVar2 = *(param_1 + 0x10);\n    *(param_1 + 0x10) = *puVar2;\n    puVar2[1] = uStack8;\n    *puVar2 = unaff_ESI;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    puVar2[2] = 0;\n    return;\n}\n",
        "token_count": 318
    },
    "004245d9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004245d9(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = arg_8h;\n    if (arg_8h == 0) {\n        fcn.0042032d();\n    }\n    arg_8h = *(iVar1 + 8);\n    while (arg_8h != 0) {\n        fcn.00406c9b(&arg_8h);\n        fcn.00424586();\n    }\n    return;\n}\n",
        "token_count": 114
    },
    "00424616": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424616(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = arg_8h;\n    if (arg_8h == 0) {\n        fcn.0042032d();\n    }\n    arg_8h = *(iVar1 + 4);\n    while (arg_8h != 0) {\n        fcn.00402f40(&arg_8h);\n        fcn.004245b0();\n    }\n    return;\n}\n",
        "token_count": 113
    },
    "0042487a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042487a(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    uint uStack8;\n    \n    if (*(param_1 + 0x10) == 0) {\n        uStack8 = 0xc;\n        iVar1 = fcn.00424db4(param_1 + 0x14, *(param_1 + 0x18));\n        iVar3 = *(param_1 + 0x18);\n        puVar2 = iVar1 + -8 + iVar3 * 0xc;\n        if (-1 < iVar3 + -1) {\n            do {\n                *puVar2 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar2;\n                puVar2 = puVar2 + -3;\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n    }\n    puVar2 = *(param_1 + 0x10);\n    *(param_1 + 0x10) = *puVar2;\n    puVar2[1] = uStack8;\n    *puVar2 = unaff_ESI;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    puVar2[2] = 0;\n    return;\n}\n",
        "token_count": 319
    },
    "00424923": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424923(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = arg_8h;\n    if (arg_8h == 0) {\n        fcn.0042032d();\n    }\n    arg_8h = *(iVar1 + 8);\n    while (arg_8h != 0) {\n        fcn.00405aab(&arg_8h);\n        fcn.004248d0();\n    }\n    return;\n}\n",
        "token_count": 112
    },
    "00424960": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424960(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = arg_8h;\n    if (arg_8h == 0) {\n        fcn.0042032d();\n    }\n    arg_8h = *(iVar1 + 4);\n    while (arg_8h != 0) {\n        fcn.00403b8b(&arg_8h);\n        fcn.004248fa();\n    }\n    return;\n}\n",
        "token_count": 113
    },
    "00424db4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00424db4(uint *param_1, int32_t param_2, int32_t param_3)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    \n    if ((param_2 != 0) && (param_3 != 0)) {\n        puVar2 = fcn.00425ce2(param_2 * param_3 + 4);\n        *puVar2 = *param_1;\n        *param_1 = puVar2;\n        return;\n    }\n    fcn.0042032d();\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 143
    },
    "0042555f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042555f(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    \n    if (param_2 == 0) {\n        param_2 = 0x11;\n    }\n    if (*(param_1 + 4) != 0) {\n        fcn.00425d0d(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    if (param_3 != 0) {\n        uVar1 = fcn.00425ce2(param_2 << 2);\n        *(param_1 + 4) = uVar1;\n        fcn.0040e620(uVar1, 0, param_2 << 2);\n    }\n    *(param_1 + 8) = param_2;\n    return;\n}\n",
        "token_count": 197
    },
    "004255d9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __fastcall fcn.004255d9(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    \n    if (*(param_1 + 0x10) == 0) {\n        iVar2 = fcn.00424db4(param_1 + 0x14, *(param_1 + 0x18), 0x10);\n        iVar4 = *(param_1 + 0x18);\n        puVar3 = iVar2 + -0xc + iVar4 * 0x10;\n        if (-1 < iVar4 + -1) {\n            do {\n                *puVar3 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar3;\n                puVar3 = puVar3 + -4;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n    }\n    puVar3 = *(param_1 + 0x10);\n    uVar1 = *puVar3;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    *(param_1 + 0x10) = uVar1;\n    if (puVar3 != 0xfffffff8) {\n        fcn.00403c40();\n    }\n    puVar3[3] = 0;\n    return puVar3;\n}\n",
        "token_count": 325
    },
    "004258ce": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004258ce(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    \n    if (param_2 == 0) {\n        param_2 = 0x11;\n    }\n    if (*(param_1 + 4) != 0) {\n        fcn.00425d0d(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    if (param_3 != 0) {\n        uVar1 = fcn.00425ce2(param_2 << 2);\n        *(param_1 + 4) = uVar1;\n        fcn.0040e620(uVar1, 0, param_2 << 2);\n    }\n    *(param_1 + 8) = param_2;\n    return;\n}\n",
        "token_count": 196
    },
    "00425aea": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00425aea(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    \n    if (*(param_1 + 0x10) == 0) {\n        iVar2 = fcn.00424db4(param_1 + 0x14, *(param_1 + 0x18), 0xc);\n        iVar4 = *(param_1 + 0x18);\n        puVar3 = iVar2 + -8 + iVar4 * 0xc;\n        if (-1 < iVar4 + -1) {\n            do {\n                *puVar3 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar3;\n                puVar3 = puVar3 + -3;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n    }\n    puVar3 = *(param_1 + 0x10);\n    uVar1 = *puVar3;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    *(param_1 + 0x10) = uVar1;\n    puVar3[1] = 0;\n    puVar3[2] = 0;\n    return;\n}\n",
        "token_count": 303
    },
    "00425ba6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00425ba6(int32_t *param_1)\n\n{\n    if (0 < param_1[1]) {\n        (**(*param_1 + 4))(1);\n    }\n    return;\n}\n",
        "token_count": 50
    },
    "00425f19": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpWndClass\n\nuint __cdecl\nfcn.00425f19(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    uint lpWndClass;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    iVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &lpWndClass;\n    iVar4 = (*_sym.imp.USER32.dll_GetClassInfoA)(*(iVar1 + 0x10), *(iVar1 + 0x24), unaff_EBP + -0x40);\n    if (iVar4 != 0) {\n        uVar5 = 1;\n        goto code_r0x00425ff9;\n    }\n    iVar3 = (*_sym.imp.USER32.dll_RegisterClassA)(iVar1);\n    if (iVar3 == 0) {\ncode_r0x00425f9e:\n        uVar5 = 0;\n    }\n    else {\n        *(unaff_EBP + -0x18) = 1;\n        iVar4 = fcn.0044be10();\n        if (*(iVar4 + 0x14) != '\\0') {\n            fcn.0044ca10(1);\n            *(unaff_EBP + -4) = 0;\n            iVar4 = fcn.0044be10();\n            pcVar2 = _sym.imp.KERNEL32.dll_lstrlenA;\n            *(unaff_EBP + -0x14) = iVar4 + 0x34;\n            iVar4 = (*pcVar2)(iVar4 + 0x34);\n            iVar6 = (*pcVar2)(*(iVar1 + 0x24));\n            if (0xfff < iVar4 + 2 + iVar6) goto code_r0x00425f9e;\n            uVar7 = (*pcVar2)(*(unaff_EBP + -0x14));\n            uVar5 = *(iVar1 + 0x24);\n            *(unaff_EBP + 8) = uVar7;\n            iVar4 = (*pcVar2)(uVar5);\n            pcVar2 = _sym.imp.KERNEL32.dll_lstrcatA;\n            if (*(unaff_EBP + 8) + 2 + iVar4 < 0x1000) {\n                (*_sym.imp.KERNEL32.dll_lstrcatA)(*(unaff_EBP + -0x14), *(iVar1 + 0x24));\n                *(unaff_EBP + 10) = 10;\n                *(unaff_EBP + 0xb) = 0;\n                (*pcVar2)(*(unaff_EBP + -0x14), unaff_EBP + 10);\n            }\n            else {\n                uVar5 = *(iVar1 + 0x10);\n                *(unaff_EBP + -0x18) = 0;\n                (*_sym.imp.USER32.dll_UnregisterClassA)(*(iVar1 + 0x24), uVar5);\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0044ca73(1);\n        }\n        uVar5 = *(unaff_EBP + -0x18);\n    }\ncode_r0x00425ff9:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar5;\n}\n",
        "token_count": 928
    },
    "00426051": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00426051(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    while( true ) {\n        if (arg_8h[4] == 0) {\n            return NULL;\n        }\n        if ((((arg_ch == *arg_8h) && (arg_10h == arg_8h[1])) && (arg_8h[2] <= arg_14h)) &&\n           (arg_14h < arg_8h[3] || arg_14h == arg_8h[3])) break;\n        arg_8h = arg_8h + 6;\n    }\n    return arg_8h;\n}\n",
        "token_count": 167
    },
    "00426122": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00426122(int32_t *param_1, int32_t param_2, uint *param_3, uint param_4)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = param_1[7];\n    if (param_2 != 2) {\n        iVar1 = (**(*param_1 + 0x70))(param_2);\n        if (iVar1 != 0) {\n            iVar2 = *(iVar1 + 0x1c);\n            param_2 = 2;\n        }\n    }\n    *param_3 = 0x1c;\n    (*_sym.imp.USER32.dll_SetScrollInfo)(iVar2, param_2, param_3, param_4);\n    return 1;\n}\n",
        "token_count": 174
    },
    "0042615f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042615f(int32_t *param_1, int32_t param_2, uint *param_3, uint param_4)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = param_1[7];\n    if (param_2 != 2) {\n        iVar1 = (**(*param_1 + 0x70))(param_2);\n        if (iVar1 != 0) {\n            iVar2 = *(iVar1 + 0x1c);\n            param_2 = 2;\n        }\n    }\n    *param_3 = 0x1c;\n    param_3[1] = param_4;\n    (*_sym.imp.USER32.dll_GetScrollInfo)(iVar2, param_2, param_3);\n    return;\n}\n",
        "token_count": 181
    },
    "0042619c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042619c(int32_t *arg_8h, uint hWnd, int32_t *lprc2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint lpRect;\n    uint var_8h;\n    \n    uVar2 = (*_sym.imp.USER32.dll_GetParent)(hWnd);\n    if ((arg_8h == NULL) || (*arg_8h != 0)) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(hWnd, &lpRect);\n        pcVar1 = _sym.imp.USER32.dll_ScreenToClient;\n        (*_sym.imp.USER32.dll_ScreenToClient)(uVar2, &lpRect);\n        (*pcVar1)(uVar2, &var_8h);\n        iVar3 = (*_sym.imp.USER32.dll_EqualRect)(&lpRect, lprc2);\n        if (iVar3 == 0) {\n            if (arg_8h == NULL) {\n                (*_sym.imp.USER32.dll_SetWindowPos)\n                          (hWnd, 0, *lprc2, lprc2[1], lprc2[2] - *lprc2, lprc2[3] - lprc2[1], 0x14);\n            }\n            else {\n                iVar3 = (*_sym.imp.USER32.dll_DeferWindowPos)(*arg_8h);\n                *arg_8h = iVar3;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 335
    },
    "00426228": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00426228(uint param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    \n    uVar1 = fcn.0042a1df();\n    if (param_2 == 0) {\n        uVar1 = uVar1 & 0xfffffdff;\n    }\n    uVar2 = fcn.0042a1c5(0, uVar1);\n    (*_sym.imp.USER32.dll_AdjustWindowRectEx)(param_1, uVar2);\n    return;\n}\n",
        "token_count": 124
    },
    "004268ee": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004268ee(int32_t hdc, uint arg_ch, int32_t arg_10h, int32_t hgdiobj, int32_t arg_18h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint lpvObject;\n    uint crColor;\n    \n    if ((((hdc == 0) || (hgdiobj == 0)) || (arg_10h == 1)) || ((arg_10h == 0 || (arg_10h == 5)))) {\ncode_r0x0042695d:\n        uVar2 = 0;\n    }\n    else {\n        if (arg_10h == 2) {\n            iVar1 = fcn.004366bb(arg_ch, 2);\n            if (iVar1 == 0) goto code_r0x0042695d;\n        }\n        (*_sym.imp.GDI32.dll_GetObjectA)(hgdiobj, 0xc, &lpvObject);\n        (*_sym.imp.GDI32.dll_SetBkColor)(hdc, crColor);\n        if (arg_18h == -1) {\n            arg_18h = (*_sym.imp.USER32.dll_GetSysColor)(8);\n        }\n        (*_sym.imp.GDI32.dll_SetTextColor)(hdc, arg_18h);\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 303
    },
    "00426b72": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00426b72(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    \n    iVar4 = fcn.0044be36();\n    if ((*(iVar4 + 0x3c) != 0) && (iVar1 = *(*(iVar4 + 0x3c) + 0x1c),  iVar1 != 0)) {\n        (*_sym.imp.USER32.dll_SendMessageA)(iVar1, 0x401, 0, 0);\n    }\n    piVar2 = *(iVar4 + 0x7c);\n    if ((param_1 != 0) && (piVar2 != NULL)) {\n        iVar3 = (*_sym.imp.USER32.dll_GetKeyState)(1);\n        if (-1 < iVar3) {\n            (**(*piVar2 + 0x160))(0xffffffff);\n        }\n    }\n    return;\n}\n",
        "token_count": 219
    },
    "00426eb6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00426eb6(int32_t *param_1, int32_t param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    uint unaff_ESI;\n    \n    if (param_2 == 3) {\n        fcn.00426eb6(0, param_3);\n        param_2 = 1;\n    }\n    iVar1 = (**(*param_1 + 0x70))(param_2);\n    if (iVar1 == 0) {\n        (*_sym.imp.USER32.dll_ShowScrollBar)(param_1[7], param_2, unaff_ESI);\n    }\n    else {\n        fcn.0042a326();\n    }\n    return;\n}\n",
        "token_count": 159
    },
    "00426f40": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00426f40(uint XAmount, int32_t YAmount, int32_t arg_10h, int32_t lpClipRect)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint uVar4;\n    uint lpRect;\n    int32_t Y;\n    uint uStack12;\n    uint *puStack8;\n    \n    iVar3 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(in_ECX + 0x1c));\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    if (((iVar3 == 0) && (arg_10h == 0)) && (lpClipRect == 0)) {\n        uVar4 = 5;\n        iVar3 = *(in_ECX + 0x1c);\n        while (iVar3 = (*pcVar1)(iVar3, uVar4),  iVar3 != 0) {\n            (*_sym.imp.USER32.dll_GetWindowRect)(iVar3, &fcn.00426f40::lpRect);\n            puStack8 = &fcn.00426f40::lpRect;\n            uStack12 = 0x426f85;\n            fcn.00431de5();\n            iVar2 = Y;\n            uStack12 = 0x15;\n            Y = 0;\n            lpRect = 0;\n            (*_sym.imp.USER32.dll_SetWindowPos)(iVar3, 0, XAmount, iVar2 + YAmount);\n            uVar4 = 2;\n        }\n    }\n    else {\n        (*_sym.imp.USER32.dll_ScrollWindow)(*(in_ECX + 0x1c), XAmount, YAmount, arg_10h, lpClipRect);\n    }\n    if ((*(in_ECX + 0x48) != 0) && (arg_10h == 0)) {\n        (**(**(in_ECX + 0x48) + 0x5c))(XAmount, YAmount);\n    }\n    return;\n}\n",
        "token_count": 449
    },
    "00427016": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00427016(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar3 = 0;\n    if (*(param_1 + 0x48) != 0) {\n        iVar1 = *(*(param_1 + 0x48) + 0x40);\n        while (iVar1 != 0) {\n            piVar2 = fcn.00403b8b();\n            if ((*(*piVar2 + 4) != 0) && (*(*(*piVar2 + 4) + 0x70) != 0)) {\n                iVar3 = iVar3 + 1;\n            }\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 179
    },
    "0042705c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.0042705c(uint arg_8h, uint noname_1, int32_t arg_10h, uint noname_3, int32_t *arg_18h, int32_t *arg_1ch, \n            int32_t *arg_20h, int32_t *arg_24h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t in_ECX;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.0042681a(arg_18h, arg_1ch, arg_20h, arg_24h, arg_8h);\n    if (iVar1 < 0) {\n        (**(**(in_ECX + 0x24) + 0x20))(*(in_ECX + 0x24), &var_4h);\n        iVar2 = fcn.00427016();\n        if (arg_10h <= iVar2 + var_4h) {\n            var_8h = *(*(in_ECX + 0x48) + 0x40);\n            while (var_8h != 0) {\n                piVar3 = fcn.00403b8b(&var_8h);\n                iVar2 = *(*piVar3 + 4);\n                if (iVar2 != 0) {\n                    if (*(iVar2 + 0x70) != 0) {\n                        var_4h = var_4h + 1;\n                    }\n                    if (var_4h == arg_10h) {\n                        iVar1 = *(*piVar3 + 4);\n                        var_18h = *(iVar1 + 0x2c);\n                        var_14h = *(iVar1 + 0x30);\n                        var_10h = *(iVar1 + 0x34);\n                        var_ch = *(iVar1 + 0x38);\n                        fcn.00431e21(&var_18h);\n                        *arg_18h = var_18h;\n                        *arg_1ch = var_14h;\n                        *arg_20h = var_10h - var_18h;\n                        *arg_24h = var_ch - var_14h;\n                        iVar1 = 0;\n                    }\n                }\n            }\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 557
    },
    "00427862": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00427862(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    iVar1 = fcn.0044be36();\n    if ((*(iVar1 + 0x14) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.00425cd0(0x436878);\n        iVar3 = fcn.00425ce2(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0042d853(0x469eac, 0x4493c2, 0x449348, 0x1c, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x14) = uVar4;\n        fcn.00425cd0(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x14);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 364
    },
    "00427986": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00427986(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar1 = fcn.0044c776(0x448a07);\n    iVar2 = fcn.0044be10();\n    if ((*(iVar2 + 0x14) != '\\0') && (*(iVar1 + 0x28) != 0)) {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar1 + 0x28));\n        *(iVar1 + 0x28) = 0;\n    }\n    if (*(iVar1 + 0x14) != 0) {\n        *(iVar1 + 0x14) = 0;\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 169
    },
    "00427a23": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00427a23(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint var_30h;\n    uint var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    \n    iVar2 = fcn.0042bc3d();\n    if (iVar2 == 0) goto code_r0x00427a6e;\n    if (*(iVar2 + 0x1c) == param_1) {\n        iVar3 = fcn.0044be10();\n        if (*(iVar3 + 0x14) == '\\0') {\n            iVar3 = fcn.0044be10();\n            if (iVar2 == *(iVar3 + 4)) {\n                iVar3 = fcn.00445c71();\n                if (iVar3 == 0) goto code_r0x00427a63;\n            }\n            fcn.0046362c(0);\n        }\ncode_r0x00427a63:\n        *(iVar2 + 0x1c) = 0;\n    }\n    if (*(iVar2 + 0x20) == param_1) {\n        *(iVar2 + 0x20) = 0;\n    }\ncode_r0x00427a6e:\n    if (param_1[0x11] != NULL) {\n        (**(*param_1[0x11] + 0x50))();\n        param_1[0x11] = 0;\n    }\n    if (param_1[0x12] != NULL) {\n        (**(*param_1[0x12] + 4))(1);\n    }\n    param_1[0x12] = 0;\n    if ((*(param_1 + 0xe) & 1) != 0) {\n        iVar2 = fcn.0044be36();\n        iVar2 = *(iVar2 + 0x3c);\n        if ((iVar2 != 0) && (*(iVar2 + 0x1c) != 0)) {\n            fcn.0040e620(&var_30h, 0, 0x30);\n            var_28h = param_1[7];\n            var_30h = 0x28;\n            var_2ch = 1;\n            var_24h = var_28h;\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x1c), 0x405, 0, &var_30h);\n        }\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongA;\n    iVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(param_1[7], 0xfffffffc);\n    fcn.0042783b();\n    iVar3 = (*pcVar1)(param_1[7], 0xfffffffc);\n    if (iVar3 == iVar2) {\n        piVar4 = (**(*param_1 + 0xf0))();\n        if (*piVar4 != 0) {\n            (*_sym.imp.USER32.dll_SetWindowLongA)(param_1[7], 0xfffffffc, *piVar4);\n        }\n    }\n    fcn.00427958();\n    (**(*param_1 + 0x114))();\n    return;\n}\n",
        "token_count": 743
    },
    "00427cd7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.00427cd7(uint32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h, uint32_t arg_14h, int32_t *lprcDst, int32_t *arg_1ch, \n            int32_t arg_20h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    int32_t in_ECX;\n    int32_t hWinPosInfo;\n    int32_t lprcSrc;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    var_8h = arg_20h;\n    var_ch = 0;\n    var_10h = 0;\n    if (arg_1ch == NULL) {\n        (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lprcSrc);\n    }\n    else {\n        lprcSrc = *arg_1ch;\n        var_1ch = arg_1ch[1];\n        var_18h = arg_1ch[2];\n        var_14h = arg_1ch[3];\n    }\n    uVar2 = arg_14h & 0xffff7fff;\n    if (uVar2 == 1) {\n        hWinPosInfo = 0;\n    }\n    else {\n        hWinPosInfo = (*_sym.imp.USER32.dll_BeginDeferWindowPos)(8);\n    }\n    for (iVar3 = (*_sym.imp.USER32.dll_GetTopWindow)(*(in_ECX + 0x1c)); iVar3 != 0;\n        iVar3 = (*_sym.imp.USER32.dll_GetWindow)(iVar3, 2)) {\n        uVar4 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(iVar3);\n        uVar4 = uVar4 & 0xffff;\n        iVar5 = fcn.00427905(iVar3);\n        iVar1 = iVar3;\n        if ((((uVar4 != arg_10h) && (iVar1 = var_4h,  arg_8h <= uVar4)) && (uVar4 <= arg_ch)) && (iVar5 != 0)) {\n            (*_sym.imp.USER32.dll_SendMessageA)(iVar3, 0x361, 0, &hWinPosInfo);\n            iVar1 = var_4h;\n        }\n        var_4h = iVar1;\n    }\n    if (uVar2 == 1) {\n        if (arg_20h == 0) {\n            lprcDst[2] = var_10h;\n            lprcDst[1] = 0;\n            *lprcDst = 0;\n            lprcDst[3] = var_ch;\n        }\n        else {\n            (*_sym.imp.USER32.dll_CopyRect)(lprcDst, &lprcSrc);\n        }\n    }\n    else {\n        if ((arg_10h != 0) && (var_4h != 0)) {\n            piVar6 = fcn.004278de(var_4h);\n            if (uVar2 == 2) {\n                lprcSrc = lprcSrc + *lprcDst;\n                var_1ch = var_1ch + lprcDst[1];\n                var_18h = var_18h - lprcDst[2];\n                var_14h = var_14h - lprcDst[3];\n            }\n            if ((arg_14h & 0x8000) == 0) {\n                (**(*piVar6 + 0x68))(&lprcSrc, 0);\n                fcn.0042619c(&hWinPosInfo, var_4h, &lprcSrc);\n            }\n        }\n        if (hWinPosInfo != 0) {\n            (*_sym.imp.USER32.dll_EndDeferWindowPos)(hWinPosInfo);\n        }\n    }\n    return;\n}\n",
        "token_count": 946
    },
    "00427f1b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00427f1b(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *in_ECX;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    if (*(in_ECX + 8) != '\\0') {\n        var_4h = NULL;\n        iVar1 = (**(*in_ECX + 0xe4))(arg_8h, arg_ch, &var_4h);\n        if (-1 < iVar1) {\n            return var_4h;\n        }\n    }\n    piVar2 = fcn.0042783b();\n    return piVar2;\n}\n",
        "token_count": 164
    },
    "00428100": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_40h\n\nuint fcn.00428100(void)\n\n{\n    int32_t *arg_8h;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint *puVar4;\n    uint *puVar5;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h_2;\n    uint var_14h;\n    uint var_18h;\n    uint var_10h;\n    uint var_40h;\n    uint var_24h;\n    uint var_14h_2;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = &stack0xffffffc0;\n    iVar1 = fcn.0044c776(0x448a07);\n    puVar4 = iVar1 + 0x58;\n    puVar5 = unaff_EBP + -0x40;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n    }\n    iVar3 = *(unaff_EBP + 0x10);\n    arg_8h = *(unaff_EBP + 8);\n    *(iVar1 + 0x58) = *(unaff_EBP + 0xc);\n    *(iVar1 + 0x60) = *(unaff_EBP + 0x14);\n    *(iVar1 + 100) = *(unaff_EBP + 0x18);\n    *(unaff_EBP + -0x14) = iVar1;\n    *(iVar1 + 0x5c) = iVar3;\n    *(unaff_EBP + -4) = 0;\n    if ((iVar3 == 2) && (arg_8h[0x12] != 0)) {\n        (**(*arg_8h[0x12] + 0x60))(0);\n    }\n    *(unaff_EBP + 8) = 0;\n    if (iVar3 == 0x110) {\n        fcn.00426ab8(arg_8h, unaff_EBP + -0x24, unaff_EBP + 8);\n    }\n    uVar2 = (**(*arg_8h + 0x108))(iVar3, *(unaff_EBP + 0x14), *(unaff_EBP + 0x18));\n    *(unaff_EBP + 0x18) = uVar2;\n    if (iVar3 == 0x110) {\n        fcn.00428087(arg_8h, unaff_EBP + -0x24);\n    }\n    uVar2 = *(unaff_EBP + 0x18);\n    puVar4 = unaff_EBP + -0x40;\n    puVar5 = iVar1 + 0x58;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 772
    },
    "0042823e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042823e(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CWnd.0;\n    *(unaff_EBP + -4) = 0;\n    if ((((extraout_ECX[7] != NULL) && (extraout_ECX != 0x499250)) && (extraout_ECX != 0x4992a0)) &&\n       ((extraout_ECX != 0x4992f0 && (extraout_ECX != 0x499340)))) {\n        fcn.00427b34();\n    }\n    if (extraout_ECX[0x12] != NULL) {\n        (**(*extraout_ECX[0x12] + 4))(1);\n    }\n    pcVar1 = extraout_ECX[0x13];\n    if ((pcVar1 != NULL) && (*(pcVar1 + 0x24) == extraout_ECX)) {\n        *(pcVar1 + 0x24) = 0;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042aa3f();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 354
    },
    "004283c7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.004283c7(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    if ((param_1 != NULL) && (param_1[7] != 0)) {\n        iVar2 = (**(*param_1 + 0x120))();\n        piVar3 = param_1;\n        if (iVar2 == 0) {\n            param_1 = fcn.00428388();\n            piVar3 = param_1;\n        }\n        while (piVar1 = piVar3,  piVar1 != NULL) {\n            piVar3 = fcn.00428388();\n            param_1 = piVar1;\n        }\n        return param_1;\n    }\n    return NULL;\n}\n",
        "token_count": 184
    },
    "00428408": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00428408(uint arg_8h, uint Msg, uint wParam, uint lParam, int32_t arg_18h, int32_t arg_1ch)\n\n{\n    code *pcVar1;\n    int32_t arg_8h_00;\n    int32_t iVar2;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    for (arg_8h_00 = (*_sym.imp.USER32.dll_GetTopWindow)(arg_8h); arg_8h_00 != 0;\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetWindow)(arg_8h_00, 2)) {\n        if (arg_1ch == 0) {\n            (*_sym.imp.USER32.dll_SendMessageA)(arg_8h_00, Msg, wParam, lParam);\n        }\n        else {\n            iVar2 = fcn.00427905(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.00428100(iVar2, *(iVar2 + 0x1c), Msg, wParam, lParam);\n            }\n        }\n        if (arg_18h != 0) {\n            iVar2 = (*pcVar1)(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.00428408(arg_8h_00, Msg, wParam, lParam, arg_18h, arg_1ch);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 326
    },
    "00428641": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00428641(int32_t arg_8h, int32_t arg_ch, ushort *arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t in_ECX;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = in_ECX;\n    var_4h = in_ECX;\n    if (*(in_ECX + 0x48) != 0) {\n        var_8h = arg_8h;\n        var_4h = arg_ch;\n        (*_sym.imp.USER32.dll_ScreenToClient)(*(in_ECX + 0x1c), &var_8h);\n        iVar2 = fcn.0042858b();\n        if (*(in_ECX + 0x48) != 0) {\n            iVar1 = *(*(in_ECX + 0x48) + 0x40);\n            while (iVar1 != 0) {\n                piVar3 = fcn.00403b8b();\n                iVar4 = *(*piVar3 + 4);\n                if ((iVar4 != 0) && (*(iVar4 + 0x70) != 0)) {\n                    iVar2 = iVar2 + 1;\n                    iVar4 = (*_sym.imp.USER32.dll_PtInRect)(iVar4 + 0x2c, var_8h, var_4h);\n                    if (iVar4 != 0) {\n                        *arg_10h = 3;\n                        *(arg_10h + 4) = iVar2;\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n    uVar5 = fcn.0042686b(arg_8h, arg_ch, arg_10h);\n    return uVar5;\n}\n",
        "token_count": 418
    },
    "004286e5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_88h\n\nvoid __cdecl fcn.004286e5(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_88h;\n    uint hWnd;\n    uint var_38h;\n    uint var_34h;\n    uint var_24h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0042acf6();\n    fcn.00426a75();\n    uVar1 = *(extraout_ECX + 0x1c);\n    *(unaff_EBP + -4) = 0;\n    iVar2 = (*_sym.imp.USER32.dll_GetTopWindow)(uVar1);\n    do {\n        if (iVar2 == 0) {\n            *(unaff_EBP + -4) = 0xffffffff;\n            *(unaff_EBP + -0x6c) = 0;\n            fcn.0042823e();\n            *in_FS_OFFSET = *(unaff_EBP + -0xc);\n            return;\n        }\n        *(unaff_EBP + -0x6c) = iVar2;\n        uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(iVar2);\n        *(unaff_EBP + -0x34) = uVar3 & 0xffff;\n        *(unaff_EBP + -0x24) = unaff_EBP + -0x88;\n        iVar4 = fcn.00427905(iVar2);\n        if (((iVar4 == 0) || (iVar4 = fcn.0042ab62(0, 0xbd11ffff, unaff_EBP + -0x38, 0),  iVar4 == 0)) &&\n           (iVar4 = fcn.0042ab62(*(unaff_EBP + -0x34), 0xffffffff, unaff_EBP + -0x38, 0),  iVar4 == 0)) {\n            iVar4 = *(unaff_EBP + 0xc);\n            if (iVar4 != 0) {\n                uVar3 = (*_sym.imp.USER32.dll_SendMessageA)(*(unaff_EBP + -0x6c), 0x87, 0, 0);\n                if ((uVar3 & 0x2000) != 0) {\n                    uVar3 = fcn.0042a1c5();\n                    uVar3 = uVar3 & 0xf;\n                    if (((uVar3 != 3) && (uVar3 != 6)) && ((uVar3 != 7 && (uVar3 != 9)))) goto code_r0x004287b4;\n                }\n                iVar4 = 0;\n            }\ncode_r0x004287b4:\n            fcn.0042ad1c(*(unaff_EBP + 8), iVar4);\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2);\n    } while( true );\n}\n",
        "token_count": 732
    },
    "004287f6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.004287f6(int32_t *param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint unaff_retaddr;\n    \n    iVar1 = fcn.0042791f(param_2);\n    if (iVar1 != 0) {\n        (**(*param_1 + 0x50))();\n        piVar2 = (**(*param_1 + 0xf0))();\n        iVar1 = (*_sym.imp.USER32.dll_SetWindowLongA)(unaff_retaddr, 0xfffffffc, fcn.004281ed);\n        if (*piVar2 == 0) {\n            *piVar2 = iVar1;\n        }\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 177
    },
    "004288bf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004288bf(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if (*(param_1 + 0x4c) == 0) {\n        iVar1 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)(*(param_1 + 0x1c));\n        uVar2 = fcn.00405a86(iVar1, iVar1 + 1);\n        (*_sym.imp.USER32.dll_GetWindowTextA)(*(param_1 + 0x1c), uVar2);\n        fcn.00404cad(0xffffffff);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x004288fe. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0x8c))();\n    return;\n}\n",
        "token_count": 201
    },
    "00428bda": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00428bda(uint32_t wParam, int32_t lParam)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    uint32_t uVar7;\n    uint hWnd;\n    \n    iVar4 = fcn.00428b49();\n    uVar7 = wParam & 0xfff0;\n    if ((uVar7 == 0xf040) || (uVar7 == 0xf050)) {\n        if (lParam != 0x75) {\n            return 0;\n        }\n        if (iVar4 == 0) {\n            return 0;\n        }\n        fcn.0042a347();\n    }\n    else {\n        if ((uVar7 != 0xf060) && (uVar7 != 0xf100)) {\n            return 0;\n        }\n        if (((uVar7 == 0xf060) || (lParam != 0)) && (iVar4 != 0)) {\n            uVar1 = *(in_ECX + 0x1c);\n            uVar5 = (*_sym.imp.USER32.dll_GetFocus)();\n            pcVar2 = _sym.imp.USER32.dll_SetActiveWindow;\n            uVar6 = (*_sym.imp.USER32.dll_SetActiveWindow)(*(iVar4 + 0x1c));\n            fcn.004278de(uVar6);\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar4 + 0x1c), 0x112, wParam, lParam);\n            pcVar3 = _sym.imp.USER32.dll_IsWindow;\n            iVar4 = (*_sym.imp.USER32.dll_IsWindow)(uVar1);\n            if (iVar4 != 0) {\n                (*pcVar2)(uVar1);\n            }\n            iVar4 = (*pcVar3)(uVar5);\n            if (iVar4 != 0) {\n                (*_sym.imp.USER32.dll_SetFocus)(uVar5);\n            }\n        }\n    }\n    return 1;\n}\n",
        "token_count": 458
    },
    "00428e71": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00428e71(int16_t *arg_8h)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint *puVar5;\n    uint *puVar6;\n    uint var_2ch;\n    uint var_28h;\n    uint *var_24h;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar2 = _sym.imp.USER32.dll_SendDlgItemMessageA;\n    var_4h = 1;\n    if (arg_8h != NULL) {\n        do {\n            iVar1 = *arg_8h;\n            if (iVar1 == 0) break;\n            iVar3 = arg_8h[1];\n            var_8h = *(arg_8h + 2);\n            puVar5 = arg_8h + 4;\n            if (iVar3 == 0x1234) {\ncode_r0x00428ed8:\n                (**0x4860f8)();\n                var_28h = 0xffffffff;\n                var_2ch = 1;\n                iVar3 = 0x401;\n                puVar6 = &var_2ch;\n                var_24h = puVar5;\ncode_r0x00428f13:\n                iVar4 = (*pcVar2)(*(in_ECX + 0x1c), iVar1, iVar3, 0, puVar6);\n                if (iVar4 == -1) {\n                    var_4h = 0;\n                }\n            }\n            else {\n                puVar6 = puVar5;\n                if (iVar3 == 0x401) {\n                    iVar3 = 0x180;\n                    goto code_r0x00428f13;\n                }\n                if (iVar3 == 0x403) {\n                    iVar3 = 0x143;\n                }\n                if (iVar3 == 0x401) goto code_r0x00428ed8;\n                if ((iVar3 == 0x180) || (iVar3 == 0x143)) goto code_r0x00428f13;\n            }\n            arg_8h = puVar5 + var_8h;\n        } while (var_4h != 0);\n        if (var_4h == 0) {\n            return 0;\n        }\n    }\n    fcn.00428408(*(in_ECX + 0x1c), 0x364, 0, 0, 0, 0);\n    return var_4h;\n}\n",
        "token_count": 572
    },
    "00429181": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00429181(int32_t arg_8h, uint arg_ch, int32_t *arg_10h)\n\n{\n    char cVar1;\n    int32_t *piVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint *puVar7;\n    int32_t iVar8;\n    code **ppcVar9;\n    code *pcVar10;\n    uint var_13ch;\n    uint var_10ch;\n    uchar var_dh;\n    uint32_t var_ch;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    iVar4 = fcn.0044c776(0x448a07);\n    if (arg_8h != 3) {\n        (*_sym.imp.USER32.dll_CallNextHookEx)(*(iVar4 + 0x28), arg_8h, arg_ch, arg_10h);\n        goto code_r0x00429393;\n    }\n    piVar2 = *(iVar4 + 0x14);\n    iVar8 = *arg_10h;\n    iVar5 = fcn.0044be10();\n    cVar1 = *(iVar5 + 0x14);\n    if ((piVar2 != NULL) || (((*(iVar8 + 0x23) & 0x40) == 0 && (cVar1 == '\\0')))) {\n        if (*0x49984c == 0) {\ncode_r0x00429244:\n            if (piVar2 == NULL) {\n                if (*0x499390 == 0) {\n                    fcn.0040e620(&var_13ch, 0, 0x30);\n                    var_13ch = 0x30;\n                    *0x499390 = (*_sym.imp.USER32.dll_GetClassInfoExA)(0, \"#32768\", &var_13ch);\n                    if (*0x499390 != 0) goto code_r0x004292ca;\n                    iVar8 = (*_sym.imp.USER32.dll_GetClassNameA)(arg_ch, &var_10ch, 0x100);\n                    if (iVar8 != 0) {\n                        var_dh = 0;\n                        iVar8 = fcn.0040efa3(&var_10ch, \"#32768\");\n                        if (iVar8 == 0) goto code_r0x00429369;\n                    }\n                }\n                else {\ncode_r0x004292ca:\n                    iVar3 = (*_sym.imp.USER32.dll_GetClassLongA)(arg_ch, 0xffffffe0);\n                    if (iVar3 == *0x499390) goto code_r0x00429369;\n                }\n                var_ch = (*_sym.imp.USER32.dll_GetWindowLongA)(arg_ch, 0xfffffffc);\n                pcVar10 = _sym.imp.USER32.dll_GetPropA;\n                if ((var_ch != 0) && (iVar8 = (*_sym.imp.USER32.dll_GetPropA)(arg_ch, \"AfxOldWndProc423\"),  iVar8 == 0))\n                {\n                    (*_sym.imp.USER32.dll_SetPropA)(arg_ch, \"AfxOldWndProc423\", var_ch);\n                    uVar6 = (*pcVar10)(arg_ch, \"AfxOldWndProc423\");\n                    if (uVar6 == var_ch) {\n                        (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(\"AfxOldWndProc423\");\n                        (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, 0x429029);\n                    }\n                }\n            }\n            else {\n                fcn.0042791f(arg_ch);\n                (**(*piVar2 + 0x50))();\n                ppcVar9 = (**(*piVar2 + 0xf0))();\n                pcVar10 = (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, fcn.004281ed);\n                if (pcVar10 != fcn.004281ed) {\n                    *ppcVar9 = pcVar10;\n                }\n                *(iVar4 + 0x14) = 0;\n            }\n        }\n        else {\n            uVar6 = (*_sym.imp.USER32.dll_GetClassLongA)(arg_ch, 0xffffffe6);\n            if ((uVar6 & 0x10000) == 0) {\n                puVar7 = *(iVar8 + 0x28);\n                if (puVar7 < 0x10000) {\n                    var_ch = var_ch & 0xffffff00;\n                    (*_sym.imp.KERNEL32.dll_GlobalGetAtomNameA)(*(iVar8 + 0x28), &var_ch, 5);\n                    puVar7 = &var_ch;\n                }\n                iVar8 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(puVar7, 0x46a86c);\n                if (iVar8 != 0) goto code_r0x00429244;\n            }\n        }\n    }\ncode_r0x00429369:\n    (*_sym.imp.USER32.dll_CallNextHookEx)(*(iVar4 + 0x28), 3, arg_ch, arg_10h);\n    if (cVar1 != '\\0') {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar4 + 0x28));\n        *(iVar4 + 0x28) = 0;\n    }\ncode_r0x00429393:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 1210
    },
    "004293a0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.004293a0(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    \n    iVar1 = fcn.0044c776(0x448a07);\n    if (*(iVar1 + 0x14) != unaff_retaddr) {\n        if (*(iVar1 + 0x28) == 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n            iVar3 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(5, fcn.00429181, 0, uVar2);\n            *(iVar1 + 0x28) = iVar3;\n            if (iVar3 == 0) {\n                fcn.004202f9();\n            }\n        }\n        *(iVar1 + 0x14) = unaff_retaddr;\n    }\n    return;\n}\n",
        "token_count": 203
    },
    "00429525": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING (jumptable): Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_74h\n\nuint __cdecl fcn.00429525(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint uVar8;\n    int32_t *arg_8h_00;\n    uint *puVar9;\n    uint *puVar10;\n    int32_t unaff_EBP;\n    int16_t iVar11;\n    uint *in_FS_OFFSET;\n    int32_t *in_stack_ffffff70;\n    uint in_stack_ffffff84;\n    uint var_74h;\n    uint var_58h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = 0;\n    uVar7 = *(unaff_EBP + 8);\n    if (uVar7 == 0x111) {\n        iVar4 = (**(*arg_8h_00 + 0xe8))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n        if (iVar4 == 0) goto code_r0x00429710;\ncode_r0x004299c0:\n        *(unaff_EBP + -0x10) = 1;\n        goto code_r0x00429a18;\n    }\n    if (uVar7 == 0x4e) {\n        if (**(unaff_EBP + 0x10) == 0) goto code_r0x00429710;\n        iVar4 = (**(*arg_8h_00 + 0xec))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), unaff_EBP + -0x10);\ncode_r0x004299e4:\n        if (iVar4 == 0) goto code_r0x00429710;\n        goto code_r0x00429a18;\n    }\n    puVar9 = *(unaff_EBP + 0x10);\n    if (uVar7 == 6) {\n        in_stack_ffffff84 = fcn.004278de(puVar9);\n        fcn.00428f52(arg_8h_00, *(unaff_EBP + 0xc), in_stack_ffffff84);\n    }\n    iVar11 = puVar9;\n    if ((uVar7 == 0x20) &&\n       (in_stack_ffffff70 = arg_8h_00,  iVar4 = fcn.00428fb3(arg_8h_00, iVar11, puVar9 >> 0x10),  iVar4 != 0))\n    goto code_r0x004299c0;\n    if (((arg_8h_00[0x12] != 0) && (0 < *(arg_8h_00[0x12] + 0x70))) &&\n       ((((0x1ff < uVar7 && (uVar7 < 0x20a)) || ((0xff < uVar7 && (uVar7 < 0x110)))) ||\n        ((0x280 < uVar7 && (uVar7 < 0x292)))))) {\n        in_stack_ffffff70 = *(unaff_EBP + 0xc);\n        iVar4 = (**(*arg_8h_00[0x12] + 0x94))(uVar7, in_stack_ffffff70, puVar9, unaff_EBP + -0x10);\n        if (iVar4 == 0) goto code_r0x00429617;\n        goto code_r0x00429a18;\n    }\ncode_r0x00429617:\n    uVar5 = (**(*arg_8h_00 + 0x28))();\n    *(unaff_EBP + -0x14) = uVar5;\n    uVar7 = *(unaff_EBP + 8);\n    fcn.0044ca10(7);\n    iVar4 = ((uVar5 ^ uVar7) & 0x1ff) * 0xc;\n    iVar6 = *(unaff_EBP + -0x14);\n    if ((*(unaff_EBP + 8) != *(iVar4 + 0x497a20)) || (iVar6 != *(iVar4 + 0x497a28))) {\n        *(iVar4 + 0x497a20) = *(unaff_EBP + 8);\n        *(iVar4 + 0x497a28) = iVar6;\n        while (iVar6 != 0) {\n            if (*(unaff_EBP + 8) < 0xc000) {\n                iVar6 = fcn.00426051(*(*(unaff_EBP + -0x14) + 4), *(unaff_EBP + 8), in_stack_ffffff70, 0);\n                *(unaff_EBP + 0x10) = iVar6;\n                if (iVar6 != 0) {\n                    *(iVar4 + 0x497a24) = iVar6;\n                    fcn.0044ca73(7);\n                    goto code_r0x004296a8;\n                }\n            }\n            else {\n                iVar6 = *(*(unaff_EBP + -0x14) + 4);\n                while( true ) {\n                    iVar6 = fcn.00426051(iVar6, 0xc000, 0, in_stack_ffffff84);\n                    *(unaff_EBP + 0x10) = iVar6;\n                    if (iVar6 == 0) break;\n                    if (**(*(unaff_EBP + 0x10) + 0x10) == *(unaff_EBP + 8)) {\n                        *(iVar4 + 0x497a24) = *(unaff_EBP + 0x10);\n                        fcn.0044ca73(7);\n                        goto code_r0x00429a07;\n                    }\n                    iVar6 = *(unaff_EBP + 0x10) + 0x18;\n                }\n            }\n            iVar6 = **(unaff_EBP + -0x14);\n            *(unaff_EBP + -0x14) = iVar6;\n        }\n        *(iVar4 + 0x497a24) = 0;\n        fcn.0044ca73(7);\ncode_r0x00429710:\n        uVar8 = 0;\n        goto code_r0x00429712;\n    }\n    iVar4 = *(iVar4 + 0x497a24);\n    *(unaff_EBP + 0x10) = iVar4;\n    fcn.0044ca73(7);\n    if (iVar4 == 0) goto code_r0x00429710;\n    if (0xbfff < *(unaff_EBP + 8)) {\ncode_r0x00429a07:\n        uVar8 = (**(*(unaff_EBP + 0x10) + 0x14))(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x00429a15;\n    }\ncode_r0x004296a8:\n    pcVar1 = *(*(unaff_EBP + 0x10) + 0x14);\n    iVar4 = *(*(unaff_EBP + 0x10) + 0x10);\n    iVar3 = puVar9 >> 0x10;\n    // switch table (65 cases) at 0x429a2c\n    switch(iVar4) {\n    case 1:\n        puVar9 = *(unaff_EBP + 0xc);\n        fcn.00432120(puVar9);\n        goto code_r0x00429831;\n    case 2:\n    case 3:\n    case 4:\n    case 0x18:\n    case 0x19:\n        puVar9 = *(unaff_EBP + 0xc);\n        goto code_r0x00429831;\n    case 5:\n    case 0xc:\n        uVar5 = puVar9 >> 0x10;\n        puVar9 = puVar9 & 0xffff;\n        uVar7 = *(unaff_EBP + 0xc);\n        uVar5 = fcn.004278de(uVar7, puVar9, uVar5);\n        goto code_r0x00429855;\n    case 6:\n        uVar7 = fcn.004278de(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x0042996a;\n    case 7:\n    case 0xd:\ncode_r0x00429831:\n        uVar8 = (*pcVar1)(puVar9);\n        goto code_r0x00429a15;\n    case 8:\n        fcn.00431a50();\n        uVar8 = puVar9[1];\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x20) = uVar8;\n        fcn.00426a75();\n        uVar8 = *puVar9;\n        uVar2 = puVar9[2];\n        *(unaff_EBP + -4) = 1;\n        *(unaff_EBP + -0x58) = uVar8;\n        iVar4 = fcn.00427905(uVar8);\n        if (iVar4 == 0) {\n            if ((arg_8h_00[0x12] != 0) && (iVar4 = fcn.00425996(*(unaff_EBP + -0x58)),  iVar4 != 0)) {\n                *(unaff_EBP + -0x28) = iVar4;\n            }\n            iVar4 = unaff_EBP + -0x74;\n        }\n        uVar8 = (*pcVar1)(unaff_EBP + -0x24, iVar4, uVar2);\n        *(unaff_EBP + -0x20) = 0;\n        *(unaff_EBP + -0x58) = 0;\n        *(unaff_EBP + -0x10) = uVar8;\n        *(unaff_EBP + -4) = 0;\n        fcn.0042823e();\n        goto code_r0x00429800;\n    case 9:\n        fcn.00431a50();\n        uVar8 = puVar9[2];\n        *(unaff_EBP + -0x20) = puVar9[1];\n        *(unaff_EBP + -4) = 2;\n        uVar8 = (*pcVar1)(unaff_EBP + -0x24, uVar8);\n        *(unaff_EBP + -0x20) = 0;\n        *(unaff_EBP + -0x10) = uVar8;\ncode_r0x00429800:\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.004321ac();\n        break;\n    case 10:\n        uVar7 = fcn.004278de(puVar9, *(unaff_EBP + 0xc) >> 0x10);\n        goto code_r0x00429850;\n    case 0xb:\n        puVar9 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0042996a;\n    case 0xe:\n    case 0x2c:\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0042996a;\n    case 0xf:\n        puVar9 = fcn.0042d140(puVar9);\n        uVar7 = *(unaff_EBP + 0xc) >> 0x10;\ncode_r0x00429850:\n        uVar5 = *(unaff_EBP + 0xc);\ncode_r0x00429855:\n        uVar8 = (*pcVar1)(uVar5, uVar7, puVar9);\n        goto code_r0x00429a15;\n    case 0x10:\n        (*pcVar1)();\n        break;\n    case 0x11:\n        puVar9 = *(unaff_EBP + 0xc);\n        goto code_r0x0042998a;\n    case 0x12:\n    case 0x1b:\n    case 0x2a:\n    case 0x2f:\n        goto code_r0x0042997d;\n    case 0x13:\n        puVar9 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x00429980;\n    case 0x14:\n        puVar9 = iVar3;\n        uVar7 = iVar11;\n        goto code_r0x00429980;\n    case 0x15:\n    case 0x16:\n        puVar10 = puVar9 >> 0x10;\n        uVar7 = puVar9 & 0xffff;\n        goto code_r0x004299ae;\n    case 0x17:\n        fcn.004278de(puVar9);\ncode_r0x0042997d:\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x00429980;\n    case 0x1a:\n    case 0x25:\n    case 0x2e:\n        uVar8 = (*pcVar1)();\n        goto code_r0x00429a15;\n    case 0x1c:\n        puVar10 = *(unaff_EBP + 0xc);\n        uVar7 = fcn.004278de(puVar10);\n        fcn.004278de(puVar9, uVar7);\n        uVar5 = arg_8h_00[7] == puVar9;\n        goto code_r0x004299b2;\n    case 0x1d:\n        puVar9 = *(unaff_EBP + 0xc);\n        fcn.00432120(puVar9);\n        goto code_r0x0042998a;\n    case 0x1e:\n        puVar9 = *(unaff_EBP + 0xc);\n        fcn.0042d140(puVar9);\n        goto code_r0x0042998a;\n    case 0x1f:\n        puVar10 = puVar9 >> 0x10;\n        uVar7 = puVar9 & 0xffff;\n        uVar5 = fcn.0042d140(*(unaff_EBP + 0xc), uVar7, puVar10);\n        goto code_r0x004299b2;\n    case 0x20:\n        puVar9 = *(unaff_EBP + 0xc);\n        goto code_r0x004298ed;\n    case 0x21:\ncode_r0x004298ed:\n        fcn.004278de(puVar9);\n        goto code_r0x0042998a;\n    case 0x22:\n        puVar10 = puVar9 >> 0x10;\n        uVar7 = puVar9 & 0xffff;\n        goto code_r0x00429909;\n    case 0x23:\n        uVar7 = iVar11;\n        puVar10 = iVar3;\ncode_r0x00429909:\n        uVar5 = fcn.004278de(*(unaff_EBP + 0xc), uVar7, puVar10);\n        goto code_r0x004299b2;\n    case 0x24:\n        uVar7 = fcn.004278de(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x00429980;\n    case 0x26:\n        puVar10 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = fcn.004278de(puVar9, puVar10);\n        goto code_r0x0042999a;\n    case 0x27:\n    case 0x28:\n        *(unaff_EBP + 8) = *(unaff_EBP + 0xc);\n        *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc) >> 0x10;\n        if (iVar4 == 0x27) {\n            uVar7 = fcn.004278de(puVar9);\n            uVar5 = *(unaff_EBP + 0xc);\n            puVar10 = puVar9;\n            goto code_r0x004299b2;\n        }\n        puVar9 = *(unaff_EBP + 0xc);\n        uVar7 = *(unaff_EBP + 8);\ncode_r0x00429980:\n        (*pcVar1)(uVar7, puVar9);\n        break;\n    case 0x29:\n    case 0x30:\ncode_r0x0042998a:\n        (*pcVar1)(puVar9);\n        break;\n    case 0x2b:\n    case 0x33:\n        (*pcVar1)(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x004299c0;\n    case 0x2d:\n        uVar7 = iVar11;\n        puVar9 = iVar3;\ncode_r0x0042996a:\n        uVar8 = (*pcVar1)(uVar7, puVar9);\ncode_r0x00429a15:\n        *(unaff_EBP + -0x10) = uVar8;\n        break;\n    case 0x31:\n        uVar7 = *(unaff_EBP + 0xc) >> 0x10;\n        puVar10 = puVar9;\ncode_r0x0042999a:\n        uVar5 = *(unaff_EBP + 0xc);\n        goto code_r0x004299b2;\n    case 0x32:\n        uVar7 = iVar11;\n        puVar10 = iVar3;\ncode_r0x004299ae:\n        uVar5 = *(unaff_EBP + 0xc);\ncode_r0x004299b2:\n        (*pcVar1)(uVar5, uVar7, puVar10);\n        break;\n    case 0x34:\n        iVar4 = (*pcVar1)(*(unaff_EBP + 0xc), *(unaff_EBP + 0xc) >> 0x10, puVar9 & 0xffff, puVar9 >> 0x10);\n        *(unaff_EBP + -0x10) = iVar4;\n        goto code_r0x004299e4;\n    case 0x41:\n        iVar4 = (*pcVar1)();\n        *(unaff_EBP + -0x10) = iVar4;\n        if (iVar4 != 0) goto code_r0x00429710;\n    }\ncode_r0x00429a18:\n    if (*(unaff_EBP + 0x14) != NULL) {\n        **(unaff_EBP + 0x14) = *(unaff_EBP + -0x10);\n    }\n    uVar8 = 1;\ncode_r0x00429712:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar8;\n}\n",
        "token_count": 4305
    },
    "00429fe8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00429fe8(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x48) != 0) {\n    // WARNING: Could not recover jumptable at 0x00429ff3. Too many branches\n    // WARNING: Treating indirect jump as call\n        uVar1 = (**(**(param_1 + 0x48) + 0x98))();\n        return uVar1;\n    }\n    return 0;\n}\n",
        "token_count": 115
    },
    "00429ffe": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00429ffe(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x48) != 0) {\n    // WARNING: Could not recover jumptable at 0x0042a009. Too many branches\n    // WARNING: Treating indirect jump as call\n        uVar1 = (**(**(param_1 + 0x48) + 0x54))();\n        return uVar1;\n    }\n    return 0;\n}\n",
        "token_count": 114
    },
    "0042a033": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a033(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x48) == 0) {\n        (*_sym.imp.USER32.dll_CheckRadioButton)(*(in_ECX + 0x1c), arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a058. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x48) + 0x6c))();\n    return;\n}\n",
        "token_count": 153
    },
    "0042a05b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042a05b(int32_t param_1, uint param_2)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x48) == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_GetDlgItem)(*(param_1 + 0x1c), param_2);\n        fcn.004278de(uVar1);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a07c. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x48) + 0x74))();\n    return;\n}\n",
        "token_count": 155
    },
    "0042a07f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042a07f(int32_t param_1, uint param_2)\n\n{\n    uint uVar1;\n    uint *unaff_retaddr;\n    \n    if (*(param_1 + 0x48) == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_GetDlgItem)(*(param_1 + 0x1c), param_2);\n        *unaff_retaddr = uVar1;\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a0a0. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x48) + 0x70))();\n    return;\n}\n",
        "token_count": 164
    },
    "0042a0a3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a0a3(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x48) == 0) {\n        (*_sym.imp.USER32.dll_GetDlgItemInt)(*(in_ECX + 0x1c), arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a0c8. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x48) + 0x78))();\n    return;\n}\n",
        "token_count": 157
    },
    "0042a0cb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a0cb(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x48) == 0) {\n        (*_sym.imp.USER32.dll_GetDlgItemTextA)(*(in_ECX + 0x1c), arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a0f0. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x48) + 0x7c))();\n    return;\n}\n",
        "token_count": 158
    },
    "0042a0f3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a0f3(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x48) == 0) {\n        (*_sym.imp.USER32.dll_SendDlgItemMessageA)(*(in_ECX + 0x1c), arg_8h, arg_ch, arg_10h, arg_14h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a11b. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x48) + 0x80))();\n    return;\n}\n",
        "token_count": 168
    },
    "0042a121": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a121(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x48) == 0) {\n        (*_sym.imp.USER32.dll_SetDlgItemInt)(*(in_ECX + 0x1c), arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a146. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x48) + 0x84))();\n    return;\n}\n",
        "token_count": 153
    },
    "0042a14c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042a14c(int32_t param_1, uint param_2, uint param_3)\n\n{\n    if (*(param_1 + 0x48) == 0) {\n        (*_sym.imp.USER32.dll_SetDlgItemTextA)(*(param_1 + 0x1c), param_2, param_3);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a16b. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x48) + 0x88))();\n    return;\n}\n",
        "token_count": 144
    },
    "0042a1c5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042a1c5(int32_t param_1)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowLongA)(*(param_1 + 0x1c), 0xfffffff0);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a1dc. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0x78))();\n    return;\n}\n",
        "token_count": 134
    },
    "0042a1df": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042a1df(int32_t param_1)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowLongA)(*(param_1 + 0x1c), 0xffffffec);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a1f6. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0x7c))();\n    return;\n}\n",
        "token_count": 134
    },
    "0042a1f9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a1f9(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        fcn.00425dc9(*(in_ECX + 0x1c), arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a21d. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x4c) + 0x80))();\n    return;\n}\n",
        "token_count": 154
    },
    "0042a223": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a223(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        fcn.00425de3(*(in_ECX + 0x1c), arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a247. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x4c) + 0x84))();\n    return;\n}\n",
        "token_count": 151
    },
    "0042a24d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042a24d(int32_t param_1, uint param_2)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_SetWindowTextA)(*(param_1 + 0x1c), param_2);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a268. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0x88))();\n    return;\n}\n",
        "token_count": 135
    },
    "0042a289": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042a289(int32_t param_1, uint param_2)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_SetWindowLongA)(*(param_1 + 0x1c), 0xfffffff4, param_2);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a2a6. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0x94))();\n    return;\n}\n",
        "token_count": 143
    },
    "0042a2ac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a2ac(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_MoveWindow)(*(in_ECX + 0x1c), arg_8h, arg_ch, arg_10h, arg_14h, arg_18h);\n    }\n    else {\n        (**(**(in_ECX + 0x4c) + 0x98))(arg_8h, arg_ch, arg_10h, arg_14h);\n    }\n    return;\n}\n",
        "token_count": 162
    },
    "0042a2ea": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042a2ea(int32_t param_1, uint param_2)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_ShowWindow)(*(param_1 + 0x1c), param_2);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a305. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0xa0))();\n    return;\n}\n",
        "token_count": 134
    },
    "0042a30b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042a30b(int32_t param_1)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_IsWindowEnabled)(*(param_1 + 0x1c));\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a320. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0xa4))();\n    return;\n}\n",
        "token_count": 125
    },
    "0042a326": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042a326(int32_t param_1, uint param_2)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(*(param_1 + 0x1c), param_2);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a341. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0xa8))();\n    return;\n}\n",
        "token_count": 133
    },
    "0042a347": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042a347(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x4c) == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_SetFocus)(*(param_1 + 0x1c));\n        fcn.004278de(uVar1);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a362. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0xb0))();\n    return;\n}\n",
        "token_count": 145
    },
    "0042a368": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0042a368(int32_t arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    if (*(arg_8h + 0x4c) != 0) {\n        (**(**(arg_8h + 0x4c) + 0x60))(arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, &arg_20h);\n    }\n    return;\n}\n",
        "token_count": 129
    },
    "0042a40f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042a40f(int32_t param_1, int32_t param_2, uint param_3)\n\n{\n    if ((*(param_1 + 0x4c) == 0) && (*(param_2 + 0x48) != 0)) {\n        (**(**(param_2 + 0x48) + 0x9c))(param_1, param_3);\n    }\n    return;\n}\n",
        "token_count": 101
    },
    "0042a434": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042a434(uint *param_1)\n\n{\n    if (param_1[1] != 0) {\n    // WARNING: Could not recover jumptable at 0x0042a43f. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(*param_1[1] + 0x78))();\n        return;\n    }\n    (*_sym.imp.USER32.dll_GetWindowLongA)(*param_1, 0xfffffff0);\n    return;\n}\n",
        "token_count": 115
    },
    "0042a492": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.0042a492(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, int32_t arg_18h, uint arg_1ch, uint32_t arg_20h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (arg_18h != 0) {\n        arg_18h = *(arg_18h + 4);\n    }\n    uVar1 = (*_sym.imp.USER32.dll_ScrollWindowEx)\n                      (*(in_ECX + 0x1c), arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, arg_20h);\n    if ((*(in_ECX + 0x48) != 0) && ((arg_20h & 1) != 0)) {\n        (**(**(in_ECX + 0x48) + 0x5c))(arg_8h, arg_ch);\n    }\n    return uVar1;\n}\n",
        "token_count": 231
    },
    "0042a4e3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a4e3(int32_t arg_8h, uint X, uint Y, uint cx, uint cy, uint uFlags)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        if (arg_8h != 0) {\n            arg_8h = *(arg_8h + 0x1c);\n        }\n        (*_sym.imp.USER32.dll_SetWindowPos)(*(in_ECX + 0x1c), arg_8h, X, Y, cx, cy, uFlags);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042a519. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x4c) + 0x9c))();\n    return;\n}\n",
        "token_count": 201
    },
    "0042a51f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042a51f(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    if ((param_1 != 0) && (*(param_1 + 0x4c) == 0)) {\n        uVar1 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x1c));\n        iVar2 = fcn.00425996(uVar1);\n        if ((iVar2 != 0) && (*(iVar2 + 0x48) != 0)) {\n            (**(**(iVar2 + 0x48) + 0x9c))(param_1, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 159
    },
    "0042a560": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0042a560(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t in_ECX;\n    bool bVar6;\n    code *var_8h;\n    code *var_4h;\n    \n    if (*(in_ECX + 0x48) != 0) {\n        if (arg_ch == 0) {\n            var_8h = 0x449343;\n            var_4h = 0x403b87;\n        }\n        else {\n            var_8h = 0x42a48d;\n            var_4h = 0x405aa7;\n        }\n        arg_ch = (*var_4h)();\njoined_r0x0042a5a8:\n        do {\n            if (arg_ch == 0) {\n                return NULL;\n            }\n            ppiVar3 = (*var_8h)(&arg_ch);\n            piVar1 = *ppiVar3;\n            if (arg_8h == NULL) {\n                if ((*piVar1 != 0) && (iVar4 = (*_sym.imp.USER32.dll_GetFocus)(),  *piVar1 == iVar4)) break;\n                if (piVar1[1] == 0) goto joined_r0x0042a5a8;\n                bVar6 = piVar1[1] == *(*(in_ECX + 0x48) + 0x6c);\n            }\n            else {\n                bVar6 = arg_8h == piVar1;\n            }\n        } while (!bVar6);\n        if (piVar1 != NULL) {\n            if (arg_ch == 0) {\n                arg_ch = (*var_4h)();\n            }\n            do {\n                ppiVar3 = (*var_8h)(&arg_ch);\n                piVar2 = *ppiVar3;\n                uVar5 = fcn.0042a434();\n                if (piVar2 == piVar1) {\n                    return piVar2;\n                }\n                if (((uVar5 & 0x10000) != 0) && ((uVar5 & 0x8000000) == 0)) {\n                    return piVar2;\n                }\n            } while (arg_ch != 0);\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 543
    },
    "0042a63c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042a63c(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t in_ECX;\n    uint uVar6;\n    bool bVar7;\n    uint var_10h;\n    uint32_t var_ch;\n    uint var_8h;\n    int32_t *var_4h;\n    \n    if (*(in_ECX + 0x48) != 0) {\n        var_4h = *(*(in_ECX + 0x48) + 0x44);\ncode_r0x0042a69a:\n        do {\n            piVar2 = var_4h;\n            if (var_4h == NULL) {\n                return 0;\n            }\n            ppiVar3 = fcn.00405aab(&var_4h);\n            piVar1 = *ppiVar3;\n            if (arg_8h == NULL) {\n                if ((*piVar1 != 0) && (iVar4 = (*_sym.imp.USER32.dll_GetFocus)(),  *piVar1 == iVar4)) break;\n                if (piVar1[1] == 0) goto code_r0x0042a69a;\n                bVar7 = piVar1[1] == *(*(in_ECX + 0x48) + 0x6c);\n            }\n            else {\n                bVar7 = arg_8h == piVar1;\n            }\n        } while (!bVar7);\n        if ((var_4h != NULL) && (piVar1 != NULL)) {\n            bVar7 = false;\n            do {\n                puVar5 = fcn.00405aab(&var_4h);\n                uVar6 = *puVar5;\n                var_ch = fcn.0042a434();\n                if ((!bVar7) && ((var_ch & 0x20000) != 0)) {\n                    bVar7 = true;\n                    arg_8h = piVar2;\n                    fcn.00403b8b(&arg_8h);\n                    while (arg_8h != NULL) {\n                        puVar5 = fcn.00403b8b();\n                        uVar6 = *puVar5;\n                        var_ch = fcn.0042a434();\n                        if ((var_ch & 0x20000) != 0) {\n                            return uVar6;\n                        }\n                    }\n                }\n                if ((var_ch & 0x8000000) == 0) {\n                    return uVar6;\n                }\n            } while (var_4h != NULL);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 601
    },
    "0042a738": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042a738(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t in_ECX;\n    uint uVar6;\n    bool bVar7;\n    uint var_10h;\n    uint32_t var_ch;\n    uint var_8h;\n    int32_t *var_4h;\n    \n    if (*(in_ECX + 0x48) != 0) {\n        var_4h = *(*(in_ECX + 0x48) + 0x40);\ncode_r0x0042a796:\n        do {\n            piVar2 = var_4h;\n            if (var_4h == NULL) {\n                return 0;\n            }\n            ppiVar3 = fcn.00403b8b(&var_4h);\n            piVar1 = *ppiVar3;\n            if (arg_8h == NULL) {\n                if ((*piVar1 != 0) && (iVar4 = (*_sym.imp.USER32.dll_GetFocus)(),  *piVar1 == iVar4)) break;\n                if (piVar1[1] == 0) goto code_r0x0042a796;\n                bVar7 = piVar1[1] == *(*(in_ECX + 0x48) + 0x6c);\n            }\n            else {\n                bVar7 = arg_8h == piVar1;\n            }\n        } while (!bVar7);\n        if ((var_4h != NULL) && (piVar1 != NULL)) {\n            bVar7 = false;\n            do {\n                puVar5 = fcn.00403b8b(&var_4h);\n                uVar6 = *puVar5;\n                var_ch = fcn.0042a434();\n                if ((!bVar7) && ((var_ch & 0x20000) != 0)) {\n                    bVar7 = true;\n                    arg_8h = piVar2;\n                    fcn.00405aab(&arg_8h);\n                    while (arg_8h != NULL) {\n                        puVar5 = fcn.00405aab();\n                        uVar6 = *puVar5;\n                        var_ch = fcn.0042a434();\n                        if ((var_ch & 0x20000) != 0) {\n                            return uVar6;\n                        }\n                    }\n                }\n                if ((var_ch & 0x8000000) == 0) {\n                    return uVar6;\n                }\n            } while (var_4h != NULL);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 598
    },
    "0042a834": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a834(uint *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    uint32_t uVar5;\n    int32_t in_ECX;\n    uint *puVar6;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if (*(in_ECX + 0x48) == 0) {\n        return;\n    }\n    if (arg_8h == NULL) {\n        return;\n    }\n    if ((arg_8h[2] == 0) ||\n       (iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*arg_8h, 0xf0, 0, 0),  puVar4 = arg_8h,  iVar2 != 1)) {\n        puVar3 = fcn.0042482d(arg_8h, 0);\n        puVar6 = &arg_8h;\n        arg_8h = puVar3;\n        fcn.00403b8b(puVar6);\n        do {\n            if (arg_8h == NULL) {\ncode_r0x0042a8d9:\n                arg_8h = puVar3;\n                fcn.00405aab(&arg_8h, puVar6);\n                while( true ) {\n                    if (arg_8h == NULL) {\n                        return;\n                    }\n                    puVar4 = fcn.00405aab(&arg_8h);\n                    puVar4 = *puVar4;\n                    if ((puVar4[2] != 0) && (iVar2 = (*pcVar1)(*puVar4, 0xf0, 0, 0),  iVar2 == 1)) break;\n                    uVar5 = fcn.0042a434();\n                    if ((uVar5 & 0x20000) != 0) {\n                        return;\n                    }\n                }\n                break;\n            }\n            puVar6 = &arg_8h;\n            puVar4 = fcn.00403b8b();\n            puVar4 = *puVar4;\n            uVar5 = fcn.0042a434();\n            if ((uVar5 & 0x20000) != 0) goto code_r0x0042a8d9;\n        } while ((puVar4[2] == 0) || (iVar2 = (*pcVar1)(*puVar4, 0xf0, 0, 0),  iVar2 != 1));\n    }\n    (*pcVar1)(*puVar4, 0xf1, 0, 0);\n    return;\n}\n",
        "token_count": 599
    },
    "0042a944": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpString2\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042a944(uint lpString1, uint iMaxLength)\n\n{\n    uint uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpString2;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    if (*(extraout_ECX + 0x4c) == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_GetWindowTextA)(*(extraout_ECX + 0x1c), *(unaff_EBP + 8), *(unaff_EBP + 0xc));\n    }\n    else {\n        piVar2 = fcn.0042c770();\n        iVar3 = (**(*piVar2 + 0xc))();\n        *(unaff_EBP + -0x10) = iVar3 + 0x10;\n        iVar3 = **(extraout_ECX + 0x4c);\n        *(unaff_EBP + -4) = 0;\n        (**(iVar3 + 0x8c))(unaff_EBP + -0x10);\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(*(unaff_EBP + 8), *(unaff_EBP + -0x10), *(unaff_EBP + 0xc));\n        uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*(unaff_EBP + 8));\n        fcn.00403164();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar1;\n}\n",
        "token_count": 418
    },
    "0042a9c4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint fcn.0042a9c4(void)\n\n{\n    uint uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    if (*(extraout_ECX + 0x4c) == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)(*(extraout_ECX + 0x1c));\n    }\n    else {\n        piVar2 = fcn.0042c770();\n        iVar3 = (**(*piVar2 + 0xc))();\n        *(unaff_EBP + -0x10) = iVar3 + 0x10;\n        iVar3 = **(extraout_ECX + 0x4c);\n        *(unaff_EBP + -4) = 0;\n        (**(iVar3 + 0x8c))(unaff_EBP + -0x10);\n        uVar1 = *(*(unaff_EBP + -0x10) + -0xc);\n        fcn.00403164();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar1;\n}\n",
        "token_count": 316
    },
    "0042ab62": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042ab62(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    uint32_t arg_ch_00;\n    int32_t *piVar4;\n    \n    if (arg_ch == 0xfffffffe) {\n        iVar1 = fcn.0044be10();\n        iVar1 = (**(**(iVar1 + 0x1038) + 4))();\n        return iVar1;\n    }\n    if (arg_ch == 0xfffffffd) {\n        iVar1 = *(arg_10h + 0x30);\n        arg_ch = 0;\n        puVar2 = (**(*in_ECX + 0x2c))();\n        do {\n            if (puVar2 == NULL) {\n                return arg_ch;\n            }\n            if (arg_ch != 0) {\n                return arg_ch;\n            }\n            piVar4 = puVar2[1];\n            while (((piVar4[1] != 0 && (piVar4[2] != 0)) && (arg_ch == 0))) {\n                if (arg_8h == piVar4[1]) {\n                    if (iVar1 == 0) {\n                        if (*piVar4 == 0) {\ncode_r0x0042abee:\n                            *(arg_10h + 4) = piVar4[2];\n                            arg_ch = 1;\n                        }\n                    }\n                    else if ((*piVar4 != 0) && (iVar3 = fcn.00405ad0(iVar1, *piVar4),  iVar3 != 0))\n                    goto code_r0x0042abee;\n                }\n                piVar4 = piVar4 + 3;\n            }\n            puVar2 = *puVar2;\n        } while( true );\n    }\n    if (arg_ch != 0xffffffff) {\n        arg_ch_00 = arg_ch >> 0x10;\n        arg_ch = arg_ch & 0xffff;\n        if (arg_ch_00 != 0) goto code_r0x0042ac27;\n    }\n    arg_ch_00 = 0x111;\ncode_r0x0042ac27:\n    puVar2 = (**(*in_ECX + 0x28))();\n    while( true ) {\n        if (puVar2 == NULL) {\n            return 0;\n        }\n        iVar1 = fcn.00426051(puVar2[1], arg_ch_00, arg_ch, arg_8h);\n        if (iVar1 != 0) break;\n        puVar2 = *puVar2;\n    }\n    iVar1 = fcn.0042aa4c(in_ECX, arg_8h, arg_ch, *(iVar1 + 0x14), arg_10h, *(iVar1 + 0x10), arg_14h);\n    return iVar1;\n}\n",
        "token_count": 661
    },
    "0042b75e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: hResData\n// WARNING: Variable defined which should be unmapped: hWnd\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nint32_t fcn.0042b75e(uint param_1, uint param_2, uint param_3, uint param_4, uint param_5, uint param_6)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t noname_0;\n    uint noname_1;\n    uint32_t uVar3;\n    int32_t *extraout_ECX;\n    uint unaff_EBX;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint uVar4;\n    uint *in_FS_OFFSET;\n    uint unaff_retaddr;\n    uint var_10h;\n    int32_t *noname_4;\n    uint var_20h;\n    uint var_1ch;\n    uint hResData;\n    uint hWnd;\n    uint in_stack_ffffffec;\n    uint var_ch;\n    uint in_stack_fffffff4;\n    uint var_4h;\n    uint noname_13;\n    \n    noname_13 = 0x42b768;\n    fcn.0040e188();\n    iVar1 = extraout_ECX[0x16];\n    noname_0 = extraout_ECX[0x17];\n    *(unaff_EBP + -0x10) = &fcn.0042b75e::var_20h;\n    *(unaff_EBP + -0x1c) = extraout_ECX;\n    *(unaff_EBP + -0x18) = iVar1;\n    var_20h = unaff_EDI;\n    var_1ch = unaff_ESI;\n    hResData = unaff_EBX;\n    iVar1 = fcn.0044be10();\n    uVar4 = *(iVar1 + 0xc);\n    if (extraout_ECX[0x15] != 0) {\n        iVar1 = fcn.0044be10();\n        uVar4 = *(iVar1 + 0xc);\n        uVar2 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar4, extraout_ECX[0x15], 5);\n        uVar2 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar4, uVar2);\n        *(unaff_EBP + -0x18) = uVar2;\n    }\n    if (*(unaff_EBP + -0x18) != 0) {\n        noname_0 = (*_sym.imp.KERNEL32.dll_LockResource)(*(unaff_EBP + -0x18));\n    }\n    if (noname_0 == 0) {\n        iVar1 = -1;\n    }\n    else {\n        uVar2 = fcn.0042b29e();\n        *(unaff_EBP + -0x14) = uVar2;\n        fcn.00427986();\n        *(unaff_EBP + -0x20) = 0;\n        if (*(unaff_EBP + -0x14) != 0) {\n            iVar1 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n            if (*(unaff_EBP + -0x14) != iVar1) {\n                iVar1 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*(unaff_EBP + -0x14));\n                if (iVar1 != 0) {\n                    (*_sym.imp.USER32.dll_EnableWindow)(*(unaff_EBP + -0x14), 0);\n                    *(unaff_EBP + -0x20) = 1;\n                }\n            }\n        }\n        *(unaff_EBP + -4) = 0;\n        noname_4 = extraout_ECX;\n        fcn.004293a0();\n        uVar2 = *(unaff_EBP + -0x14);\n        noname_1 = fcn.004278de();\n        iVar1 = fcn.0042b551(noname_0, noname_1, uVar4, uVar2, noname_4, var_20h, var_1ch, hResData, hWnd, \n                             in_stack_ffffffec, var_ch, in_stack_fffffff4, var_4h, noname_13, unaff_retaddr, param_1, \n                             param_2, param_3, var_10h, param_5, param_6);\n        if (iVar1 != 0) {\n            if ((*(extraout_ECX + 0xe) & 0x10) != 0) {\n                uVar4 = 4;\n                uVar3 = fcn.0042a1c5();\n                if ((uVar3 & 0x100) != 0) {\n                    uVar4 = 5;\n                }\n                fcn.00427382(uVar4);\n            }\n            if (extraout_ECX[7] != 0) {\n                fcn.0042a4e3(0, 0, 0, 0, 0, 0x97);\n            }\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*(unaff_EBP + -0x20) != 0) {\n            (*_sym.imp.USER32.dll_EnableWindow)(*(unaff_EBP + -0x14), 1);\n        }\n        if (*(unaff_EBP + -0x14) != 0) {\n            iVar1 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n            if (iVar1 == extraout_ECX[7]) {\n                (*_sym.imp.USER32.dll_SetActiveWindow)(*(unaff_EBP + -0x14));\n            }\n        }\n        (**(*extraout_ECX + 0x60))();\n        fcn.0042b2d8();\n        if (extraout_ECX[0x15] != 0) {\n            (*_sym.imp.KERNEL32.dll_FreeResource)(*(unaff_EBP + -0x18));\n        }\n        iVar1 = extraout_ECX[0x10];\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1;\n}\n",
        "token_count": 1428
    },
    "0042bae2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042bae2(uint lpString2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalLock;\n    if (*(in_ECX + 0x70) != 0) {\n        var_4h = in_ECX;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(in_ECX + 0x70));\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(*(iVar2 + 2) + iVar2, lpString2);\n        if ((iVar2 == 0) && (iVar2 = sub.WINSPOOL.DRV_OpenPrinterA(lpString2, &var_4h, 0),  iVar2 != 0)) {\n            if (*(in_ECX + 0x6c) != 0) {\n                fcn.00436848(*(in_ECX + 0x6c));\n            }\n            uVar3 = sub.WINSPOOL.DRV_DocumentPropertiesA(0, var_4h, lpString2, 0, 0, 0);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x42, uVar3);\n            *(in_ECX + 0x6c) = uVar3;\n            uVar3 = (*pcVar1)(uVar3);\n            iVar2 = sub.WINSPOOL.DRV_DocumentPropertiesA(0, var_4h, lpString2, uVar3, 0, 2);\n            if (iVar2 != 1) {\n                fcn.00436848(*(in_ECX + 0x6c));\n                *(in_ECX + 0x6c) = 0;\n            }\n            sub.WINSPOOL.DRV_ClosePrinter(var_4h);\n        }\n    }\n    return;\n}\n",
        "token_count": 431
    },
    "0042bc8a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid fcn.0042bc8a(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    bool bVar2;\n    uint var_10h;\n    uint var_8h;\n    uint var_4h;\n    uint var_ch;\n    uint var_4h_2;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = &stack0xffffffec;\n    fcn.0042d84a();\n    fcn.0042da42(0xffffffff);\n    *(unaff_EBP + -4) = 2;\n    if (*(unaff_EBP + 8) == 0) {\n        iVar1 = fcn.0044be36();\n        if ((iVar1 != 0) && (*(iVar1 + 0x3c) != NULL)) {\n            (**(**(iVar1 + 0x3c) + 0x60))();\n            if (*(iVar1 + 0x3c) != NULL) {\n                (**(**(iVar1 + 0x3c) + 4))(1);\n            }\n            *(iVar1 + 0x3c) = 0;\n        }\n    }\n    bVar2 = *0x499614 != 0;\n    *(unaff_EBP + -4) = 4;\n    if (bVar2) {\n        fcn.0044c71d(*(unaff_EBP + 8), 0);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 377
    },
    "0042becb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0042becb(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    \n    iVar1 = fcn.0044be36();\n    if (((*(iVar1 + 4) != 0) && (*param_1 == 0)) && (iVar1 = fcn.0042bddf(param_1),  iVar1 != 0)) {\n        return 1;\n    }\n    piVar2 = fcn.004049c2();\n    piVar4 = piVar2;\n    if (piVar2 != NULL) {\n        piVar4 = piVar2[7];\n    }\n    iVar1 = fcn.00427e1f(piVar4, param_1);\n    if (iVar1 == 0) {\n        if (piVar2 != NULL) {\n            fcn.004278de(*param_1);\n            piVar4 = fcn.00428b49();\n            if (piVar4 != piVar2) {\n                uVar3 = (**(*piVar2 + 0x100))(param_1);\n                return uVar3;\n            }\n        }\n        uVar3 = 0;\n    }\n    else {\n        uVar3 = 1;\n    }\n    return uVar3;\n}\n",
        "token_count": 298
    },
    "0042bfd9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0042bfd9(uint param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint unaff_retaddr;\n    \n    iVar2 = fcn.0044be36();\n    piVar1 = *(iVar2 + 4);\n    if (piVar1 != NULL) {\n        if (piVar1[0xe] != NULL) {\n            (*piVar1[0xe])(1, 0);\n        }\n        if (param_2 != 0) {\n            (**(*piVar1 + 0x78))();\n        }\n        *(iVar2 + 4) = 0;\n    }\n    fcn.0042bc8a(0);\n    fcn.0040f596(unaff_retaddr);\n    return;\n}\n",
        "token_count": 179
    },
    "0042c230": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0042c230(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.0044be10();\n    if (*(iVar1 + 0x14) == '\\0') {\n        iVar1 = fcn.0044bde5();\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        uVar2 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(0xffffffff, 0x42c0b2, 0, uVar2);\n        *(iVar1 + 0x2c) = uVar2;\n    }\n    return;\n}\n",
        "token_count": 143
    },
    "0042c6b9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0042c6b9(int32_t param_1, int32_t param_2)\n\n{\n    if (param_2 != 0) {\n        for (; param_1 != 0; param_1 = *(param_1 + 0x10)) {\n            if (param_1 == param_2) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 94
    },
    "0042caca": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042caca(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *param_1;\n    if (param_2 < *(iVar1 + -0xc)) {\n        param_2 = *(iVar1 + -0xc);\n    }\n    if (*(iVar1 + -4) < 2) {\n        iVar1 = *(iVar1 + -8);\n        if (iVar1 < param_2) {\n            if (iVar1 < 0x401) {\n                iVar1 = iVar1 * 2;\n            }\n            else {\n                iVar1 = iVar1 + 0x400;\n            }\n            if (iVar1 < param_2) {\n                iVar1 = param_2;\n            }\n            fcn.0042ca70(iVar1);\n        }\n    }\n    else {\n        fcn.0042ca09(param_2);\n    }\n    return;\n}\n",
        "token_count": 211
    },
    "0042cb40": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042cb40(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    uint32_t uVar3;\n    \n    if (arg_ch == 0) {\n        fcn.0042c9c0();\n    }\n    else {\n        if (arg_8h == 0) {\n            fcn.00401182(0x80070057);\n        }\n        uVar1 = *(*in_ECX + -0xc);\n        uVar3 = arg_8h - *in_ECX >> 1;\n        iVar2 = fcn.0042cb11(arg_ch);\n        if (uVar1 < uVar3) {\n            fcn.0042c80b(iVar2, arg_8h, arg_ch);\n        }\n        else {\n            fcn.0042c823(iVar2, iVar2 + uVar3 * 2);\n        }\n        fcn.0042c8e5(arg_ch);\n    }\n    return;\n}\n",
        "token_count": 240
    },
    "0042d03c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042d03c(uint arg_8h, int32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    if (arg_ch == 0) {\n        uVar1 = 0;\n    }\n    else {\n        if (arg_10h != 0) {\n            do {\n                arg_10h = arg_10h + -1;\n                arg_ch = fcn.0040ef28(arg_ch, arg_14h);\n                if (arg_ch == 0) {\n                    fcn.004042f6();\n                    return 0;\n                }\n                arg_ch = arg_ch + 1;\n            } while (arg_10h != 0);\n        }\n        iVar2 = fcn.0040ef28(arg_ch, arg_14h);\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_ch);\n        }\n        else {\n            iVar2 = iVar2 - arg_ch;\n        }\n        uVar1 = fcn.00405a86(iVar2, arg_ch, iVar2);\n        fcn.0040e680(uVar1, iVar2, arg_ch);\n        fcn.00404cad(0xffffffff);\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 307
    },
    "0042d0c4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042d0c4(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    iVar1 = fcn.0044be36();\n    if ((*(iVar1 + 0x18) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.00425cd0(0x436878);\n        iVar3 = fcn.00425ce2(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0042d853(0x46e67c, 0x44c8f5, 0x44c8cd, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x18) = uVar4;\n        fcn.00425cd0(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x18);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 368
    },
    "0042d99e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042d99e(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (param_1 != 0) {\n        var_8h = -(*(param_1 + 0x44) != 0);\n        while (var_8h != 0) {\n            fcn.00425a37(&var_8h, &var_ch, &var_4h);\n            puVar1 = *(param_1 + 0x58) + var_4h;\n            *puVar1 = 0;\n            if (*(param_1 + 0x5c) == 2) {\n                puVar1[1] = 0;\n            }\n            (**(param_1 + 0x18))(var_4h);\n        }\n        fcn.0042591a();\n        fcn.0040c5a7();\n    }\n    return;\n}\n",
        "token_count": 225
    },
    "0042da42": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0042da42(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    \n    iVar1 = fcn.0044be36();\n    if ((*(iVar1 + 0x10) != 0) && (iVar2 = *(iVar1 + 0x10) + -1,  *(iVar1 + 0x10) = iVar2,  iVar2 == 0)) {\n        if (arg_8h != 0) {\n            if (((arg_8h != -1) && (iVar2 = fcn.0042bc3d(),  iVar2 != 0)) && (*(iVar2 + 0x38) != NULL)) {\n                (**(iVar2 + 0x38))(0, 0);\n            }\n            fcn.0042d99e();\n            fcn.0042d99e();\n            fcn.0042d99e();\n            fcn.0042d99e();\n            fcn.0042d99e();\n        }\n        iVar2 = fcn.0044be10();\n        iVar2 = *(iVar2 + 4);\n        iVar3 = fcn.0044c388();\n        if ((((iVar3 != 0) && (iVar2 != 0)) &&\n            ((*(iVar3 + 0xc) == 0 || (uVar4 = fcn.004101f8(*(iVar3 + 0xc)),  uVar4 < *(iVar2 + 0x94))))) &&\n           (*(iVar2 + 0x94) != 0)) {\n            arg_8h = 0;\n            if (*(iVar3 + 0xc) != 0) {\n                arg_8h = fcn.004101f8(*(iVar3 + 0xc));\n                fcn.0040d958(*(iVar3 + 0xc));\n            }\n            iVar2 = fcn.0040d946(*(iVar2 + 0x94));\n            *(iVar3 + 0xc) = iVar2;\n            if ((iVar2 == 0) && (arg_8h != 0)) {\n                uVar5 = fcn.0040d946(arg_8h);\n                *(iVar3 + 0xc) = uVar5;\n            }\n        }\n    }\n    return *(iVar1 + 0x10) != 0;\n}\n",
        "token_count": 539
    },
    "0042df6c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042df6c(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    char *lpMultiByteStr;\n    uint var_44h;\n    int32_t lpvObject;\n    uint var_24h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.GDI32.dll_GetStockObject;\n    uVar4 = 10;\n    var_4h = *0x496830;\n    lpMultiByteStr = \"System\";\n    iVar2 = (*_sym.imp.GDI32.dll_GetStockObject)(0x11);\n    if (iVar2 == 0) {\n        iVar2 = (*pcVar1)(0xd);\n        if (iVar2 == 0) goto code_r0x0042dfe5;\n    }\n    iVar2 = (*_sym.imp.GDI32.dll_GetObjectA)(iVar2, 0x3c, &lpvObject);\n    if (iVar2 != 0) {\n        lpMultiByteStr = &var_24h;\n        uVar3 = (*_sym.imp.USER32.dll_GetDC)(0);\n        if (lpvObject < 0) {\n            lpvObject = -lpvObject;\n        }\n        uVar4 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(uVar3, 0x5a);\n        uVar4 = (*_sym.imp.KERNEL32.dll_MulDiv)(lpvObject, 0x48, uVar4);\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar3);\n    }\ncode_r0x0042dfe5:\n    if (arg_8h == 0) {\n        arg_8h = uVar4;\n    }\n    fcn.0042de34(lpMultiByteStr, arg_8h);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 426
    },
    "0042e25a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042e25a(char *lpString, int32_t arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    char *pcVar4;\n    char *pcVar5;\n    uint var_4h;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n    iVar3 = fcn.0044daef(lpString, 0, 0);\n    iVar3 = iVar3 + -1;\n    pcVar5 = lpString + (iVar2 - iVar3);\n    if (arg_ch < iVar2) {\n        if (arg_ch < iVar3) {\n            if (arg_10h == 0) {\n                pcVar5 = 0x469144;\n            }\n        }\n        else {\n            pcVar4 = lpString + 2;\n            if ((*lpString == '\\\\') && (lpString[1] == '\\\\')) {\n                for (; *pcVar4 != '\\\\'; pcVar4 = fcn.004103c9(pcVar4)) {\n                }\n            }\n            if (3 < iVar2 - iVar3) {\n                do {\n                    pcVar4 = fcn.004103c9(pcVar4);\n                } while (*pcVar4 != '\\\\');\n            }\n            iVar2 = pcVar4 - lpString;\n            if (iVar2 + 5 + iVar3 <= arg_ch) {\n                while (iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(pcVar4),  arg_ch < iVar3 + 4 + iVar2) {\n                    do {\n                        pcVar4 = fcn.004103c9(pcVar4);\n                    } while (*pcVar4 != '\\\\');\n                }\n                lpString[iVar2] = '\\0';\n                pcVar1 = _sym.imp.KERNEL32.dll_lstrcatA;\n                (*_sym.imp.KERNEL32.dll_lstrcatA)(lpString, \"\\\\...\");\n                (*pcVar1)(lpString, pcVar4);\n                return;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(lpString, pcVar5);\n    }\n    return;\n}\n",
        "token_count": 478
    },
    "0042eb2a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042eb2a(char *lpString1, uint lpString2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint var_61ch;\n    uint var_414h;\n    uint var_20ch;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(lpString1, lpString2);\n    if ((iVar2 == 0) &&\n       (iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x2a),  pcVar1 = _sym.imp.KERNEL32.dll_lstrlenA,  iVar2 != 0)) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString1);\n        iVar3 = (*pcVar1)(lpString2);\n        if (iVar2 == iVar3) {\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetThreadLocale)();\n            pcVar1 = _sym.imp.KERNEL32.dll_GetStringTypeExA;\n            (*_sym.imp.KERNEL32.dll_GetStringTypeExA)(uVar4, 1, lpString1, 0xffffffff, &var_20ch);\n            (*pcVar1)(uVar4, 4, lpString1, 0xffffffff, &var_414h);\n            (*pcVar1)(uVar4, 1, lpString2, 0xffffffff, &var_61ch);\n            if (*lpString1 != '\\0') {\n                iVar2 = 0;\n                do {\n                    if (((*(&var_414h + iVar2) & 0x80) != 0) && (*(&var_20ch + iVar2) != *(&var_61ch + iVar2))) break;\n                    iVar2 = iVar2 + 2;\n                    lpString1 = fcn.004103c9(lpString1);\n                } while (*lpString1 != '\\0');\n            }\n        }\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 465
    },
    "0042ef32": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042ef32(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CFile.0;\n    *(unaff_EBP + -4) = 0;\n    if ((extraout_ECX[1] != 0xffffffff) && (extraout_ECX[2] != NULL)) {\n        fcn.0042ee91();\n    }\n    fcn.00403164();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 194
    },
    "004301a1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.004301a1(int32_t param_1, uint param_2)\n\n{\n    uint arg_8h;\n    int32_t arg_10h;\n    \n    if (param_1 != 0) {\n        arg_10h = param_1;\n        arg_8h = fcn.0042fe36(param_1, param_1, param_2);\n        fcn.0043015b(arg_8h, param_1, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 113
    },
    "00430265": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00430265(int32_t *param_1, int32_t param_2, int32_t param_3, int32_t param_4, int32_t param_5)\n\n{\n    param_1[0x16] = param_4;\n    param_1[0x17] = param_5;\n    param_1[0x11] = param_2;\n    param_1[0x10] = param_3;\n    if (*0x495260 == 0) {\n        (**(*param_1 + 0x50))();\n    }\n    return;\n}\n",
        "token_count": 135
    },
    "00430461": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00430461(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e620(&var_14h, 0, 0x14);\n    var_4h = 0;\n    var_10h = arg_ch;\n    if (arg_10h == 0) {\n        var_14h = 0;\n    }\n    else {\n        var_14h = *(in_ECX + 0x5c);\n    }\n    if (*(in_ECX + 0x58) == 0) {\n        piVar1 = NULL;\n    }\n    else {\n        piVar1 = fcn.0042c660();\n        if (piVar1 != NULL) {\n            iVar2 = (**(*piVar1 + 0x134))(*(in_ECX + 0x40), 0x44000000, arg_8h, &var_14h);\n            piVar1 = -(iVar2 != 0) & piVar1;\n        }\n    }\n    return piVar1;\n}\n",
        "token_count": 291
    },
    "00430851": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00430851(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint uVar3;\n    \n    fcn.004305f6();\n    if ((*(param_1 + 0x3c) != 0) && (*(param_1 + 100) == 0)) {\n        iVar1 = fcn.0044be10();\n        uVar3 = *(iVar1 + 0xc);\n        uVar2 = (*_sym.imp.USER32.dll_LoadMenuA)(uVar3, *(param_1 + 0x3c));\n        *(param_1 + 100) = uVar2;\n        uVar3 = (*_sym.imp.USER32.dll_LoadAcceleratorsA)(uVar3, *(param_1 + 0x3c));\n        *(param_1 + 0x68) = uVar3;\n    }\n    return;\n}\n",
        "token_count": 203
    },
    "00430b26": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00430b26(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    if ((arg_ch == 0) || (arg_8h == 0)) {\n        iVar1 = 0;\n    }\n    else {\n        if ((*(in_ECX + 0x18) & 1) == 0) {\n            fcn.00434a73(4, *(in_ECX + 0x14));\n        }\n        uVar3 = *(in_ECX + 0x2c) - *(in_ECX + 0x28);\n        if (arg_ch < uVar3) {\n            uVar3 = arg_ch;\n        }\n        fcn.0040e680(arg_8h, *(in_ECX + 0x28), uVar3);\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + uVar3;\n        arg_8h = arg_8h + uVar3;\n        uVar3 = arg_ch - uVar3;\n        if (uVar3 != 0) {\n            iVar1 = uVar3 - uVar3 % *(in_ECX + 0x20);\n            var_8h = 0;\n            var_4h = iVar1;\n            do {\n                iVar2 = (**(**(in_ECX + 0x24) + 0x34))(arg_8h, var_4h);\n                arg_8h = arg_8h + iVar2;\n                var_8h = var_8h + iVar2;\n                var_4h = var_4h - iVar2;\n                if (iVar2 == 0) break;\n            } while (var_4h != 0);\n            uVar3 = uVar3 - var_8h;\n            if ((uVar3 != 0) && (var_8h == iVar1)) {\n                uVar4 = 0;\n                if (*(in_ECX + 8) == 0) {\n                    if ((*(in_ECX + 0xc) != 0) || (var_4h = *(in_ECX + 0x20),  *(in_ECX + 0x20) < uVar3)) {\n                        var_4h = uVar3;\n                    }\n                    var_8h = *(in_ECX + 0x30);\n                    do {\n                        iVar1 = (**(**(in_ECX + 0x24) + 0x34))(var_8h, var_4h);\n                        var_8h = var_8h + iVar1;\n                        var_4h = var_4h - iVar1;\n                        uVar4 = uVar4 + iVar1;\n                        if ((iVar1 == 0) || (var_4h == 0)) break;\n                    } while (uVar4 < uVar3);\n                    iVar1 = *(in_ECX + 0x30);\n                    *(in_ECX + 0x2c) = iVar1 + uVar4;\n                }\n                else {\n                    (**(**(in_ECX + 0x24) + 0x50))(0, *(in_ECX + 0x20), in_ECX + 0x30, in_ECX + 0x2c);\n                    iVar1 = *(in_ECX + 0x30);\n                }\n                uVar4 = *(in_ECX + 0x2c) - iVar1;\n                *(in_ECX + 0x28) = iVar1;\n                if (uVar3 < uVar4) {\n                    uVar4 = uVar3;\n                }\n                fcn.0040e680(arg_8h, iVar1, uVar4);\n                *(in_ECX + 0x28) = *(in_ECX + 0x28) + uVar4;\n                uVar3 = uVar3 - uVar4;\n            }\n        }\n        iVar1 = arg_ch - uVar3;\n    }\n    return iVar1;\n}\n",
        "token_count": 932
    },
    "00430cca": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00430cca(uint32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    uint32_t arg_8h_00;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint unaff_EBX;\n    int32_t iVar4;\n    uint unaff_ESI;\n    int32_t iVar6;\n    uint var_8h;\n    uint32_t var_4h;\n    uint32_t uVar5;\n    \n    if ((*(in_ECX + 0x18) & 1) != 0) {\n        uVar5 = *(in_ECX + 0x28);\n        piVar1 = in_ECX + 0x2c;\n        var_4h = *piVar1 - uVar5;\n        uVar2 = arg_8h + var_4h;\n        if (*(in_ECX + 8) == 0) {\n            arg_8h_00 = *(in_ECX + 0x30);\n            if (arg_8h_00 < uVar5) {\n                if (0 < var_4h) {\n                    fcn.0040ea50(arg_8h_00, uVar5, var_4h);\n                    arg_8h_00 = *(in_ECX + 0x30);\n                    *(in_ECX + 0x28) = arg_8h_00;\n                    *piVar1 = arg_8h_00 + var_4h;\n                }\n                uVar5 = arg_8h;\n                if (*(in_ECX + 0xc) == 0) {\n                    uVar5 = *(in_ECX + 0x20);\n                }\n                iVar4 = uVar5 - var_4h;\n                iVar6 = var_4h + arg_8h_00;\n                do {\n                    iVar3 = (**(**(in_ECX + 0x24) + 0x34))(iVar6, iVar4);\n                    var_4h = var_4h + iVar3;\n                    iVar6 = iVar6 + iVar3;\n                    iVar4 = iVar4 - iVar3;\n                    if ((iVar3 == 0) || (iVar4 == 0)) break;\n                } while (var_4h < arg_8h);\n                *(in_ECX + 0x28) = *(in_ECX + 0x30);\n                *(in_ECX + 0x2c) = *(in_ECX + 0x30) + var_4h;\n            }\n        }\n        else {\n            if (var_4h != 0) {\n                (**(**(in_ECX + 0x24) + 0x28))(-var_4h, -var_4h >> 0x1f, 1);\n            }\n            (**(**(in_ECX + 0x24) + 0x50))(0, *(in_ECX + 0x20), in_ECX + 0x30, piVar1);\n            *(in_ECX + 0x28) = *(in_ECX + 0x30);\n        }\n        if (uVar2 <= *(in_ECX + 0x2c) - *(in_ECX + 0x28)) {\n            return;\n        }\n        unaff_EBX = 0;\n        unaff_ESI = 3;\n    }\n    fcn.00434a73(unaff_ESI, unaff_EBX);\n    return;\n}\n",
        "token_count": 764
    },
    "00430db5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00430db5(uint arg_8h, uint *arg_ch)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    uint *var_8h;\n    int32_t var_4h;\n    \n    puVar2 = arg_ch;\n    *arg_ch = 1;\n    fcn.004068c3(&arg_ch + 3);\n    if (arg_ch._3_1_ == -1) {\n        fcn.004026a1(&arg_8h + 2);\n        if (arg_8h._2_2_ == -2) {\n            *puVar2 = 2;\n            fcn.004068c3(&arg_ch + 3);\n            if (arg_ch._3_1_ != -1) goto code_r0x00430e03;\n            fcn.004026a1(&arg_8h + 2);\n        }\n        if (arg_8h._2_2_ == 0xffff) {\n            fcn.0040694a(&arg_ch);\n            puVar2 = arg_ch;\n            if (arg_ch == 0xffffffff) {\n                fcn.00406902(&var_8h);\n                if ((var_4h != 0) || (puVar2 = var_8h,  0x7fffffff < var_8h)) {\n                    fcn.00434a73(1, 0);\n                    pcVar1 = swi(3);\n                    puVar2 = (*pcVar1)();\n                    return puVar2;\n                }\n            }\n        }\n        else {\n            puVar2 = arg_8h._2_2_;\n        }\n    }\n    else {\ncode_r0x00430e03:\n        puVar2 = arg_ch >> 0x18;\n    }\n    return puVar2;\n}\n",
        "token_count": 401
    },
    "00431029": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00431029(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    uint32_t arg_10h;\n    int32_t iVar1;\n    \n    if ((arg_ch != 0) && (arg_8h != 0)) {\n        if ((~*(in_ECX + 0x18) & 1) == 0) {\n            fcn.00434a73(2, *(in_ECX + 0x14));\n        }\n        arg_10h = *(in_ECX + 0x2c) - *(in_ECX + 0x28);\n        if (arg_ch < arg_10h) {\n            arg_10h = arg_ch;\n        }\n        fcn.0040e680(*(in_ECX + 0x28), arg_8h, arg_10h);\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + arg_10h;\n        arg_ch = arg_ch - arg_10h;\n        if (arg_ch != 0) {\n            fcn.00430c53();\n            iVar1 = arg_ch - arg_ch % *(in_ECX + 0x20);\n            (**(**(in_ECX + 0x24) + 0x38))(arg_8h + arg_10h, iVar1);\n            if (*(in_ECX + 8) != 0) {\n                (**(**(in_ECX + 0x24) + 0x50))(1, *(in_ECX + 0x20), in_ECX + 0x30, in_ECX + 0x2c);\n                *(in_ECX + 0x28) = *(in_ECX + 0x30);\n            }\n            fcn.0040e680(*(in_ECX + 0x28), arg_8h + arg_10h + iVar1, arg_ch - iVar1);\n            *(in_ECX + 0x28) = *(in_ECX + 0x28) + (arg_ch - iVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 470
    },
    "004312a0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004312a0(void)\n\n{\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *(unaff_EBP + -4) = 0;\n    if ((*(extraout_ECX + 0x24) != 0) && ((*(extraout_ECX + 0x18) & 2) == 0)) {\n        fcn.0043101b();\n    }\n    fcn.00430ae4();\n    fcn.00403164();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 202
    },
    "004320a4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.004320a4(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    iVar1 = fcn.0044be36();\n    if ((*(iVar1 + 0x1c) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.00425cd0(0x436878);\n        iVar3 = fcn.00425ce2(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0042d853(0x46cb54, 0x44b79b, 0x44b744, 4, 2);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x1c) = uVar4;\n        fcn.00425cd0(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x1c);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 366
    },
    "004321ac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004321ac(code **param_1)\n\n{\n    uint uVar1;\n    \n    *param_1 = vtable.CDC.0;\n    if (param_1[1] != NULL) {\n        uVar1 = fcn.00432165();\n        (*_sym.imp.GDI32.dll_DeleteDC)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 84
    },
    "004323a1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.004323a1(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    iVar1 = fcn.0044be36();\n    if ((*(iVar1 + 0x20) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.00425cd0(0x436878);\n        iVar3 = fcn.00425ce2(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0042d853(0x46cab4, 0x44b7b7, 0x44b752, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x20) = uVar4;\n        fcn.00425cd0(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x20);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 364
    },
    "00433679": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nint32_t __cdecl fcn.00433679(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint *puVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int32_t arg_8h_00;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    int32_t in_stack_ffffffd0;\n    int32_t in_stack_ffffffd4;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    if ((*(arg_8h_00 + 0x18) & 1) == 0) goto code_r0x00433841;\n    if ((*(unaff_EBP + 8) != 0) && (*(*(unaff_EBP + 8) + 8) == 0xffff)) {\n        fcn.00420313();\n    }\n    fcn.004334ca(0);\n    fcn.004026a1(unaff_EBP + -0x10);\n    if (*(unaff_EBP + -0x10) == 0x7fff) {\n        fcn.0040694a(unaff_EBP + -0x18);\n        uVar5 = *(unaff_EBP + -0x18);\n    }\n    else {\n        uVar5 = (*(unaff_EBP + -0x10) & 0xffff8000) << 0x10 | *(unaff_EBP + -0x10) & 0xffff7fff;\n        *(unaff_EBP + -0x18) = uVar5;\n    }\n    if (-1 < uVar5) {\n        if (*(unaff_EBP + 0x10) != NULL) {\n            **(unaff_EBP + 0x10) = uVar5;\n            iVar7 = 0;\n            goto code_r0x0043370a;\n        }\ncode_r0x0043383c:\n        in_stack_ffffffd4 = *(arg_8h_00 + 0x14);\n        in_stack_ffffffd0 = 5;\n        goto code_r0x00433841;\n    }\n    if (*(unaff_EBP + -0x10) != -1) {\n        uVar5 = uVar5 & 0x7fffffff;\n        if ((uVar5 == 0) || (*(*(arg_8h_00 + 0x38) + 8) - 1U < uVar5)) goto code_r0x0043383c;\n        iVar7 = fcn.00405ccb(uVar5);\n        iVar2 = *(arg_8h_00 + 0x3c);\n        *(unaff_EBP + -0x14) = 0;\n        if ((iVar2 == 0) || (iVar2 = fcn.004259cd(iVar7, unaff_EBP + -0x1c),  iVar2 == 0)) {\n            uVar6 = *(iVar7 + 8) & 0x7fffffff;\n        }\n        else {\n            uVar6 = *(unaff_EBP + -0x1c);\n        }\n        uVar5 = *(unaff_EBP + -0x18);\n        *(unaff_EBP + -0x14) = uVar6;\ncode_r0x00433803:\n        if (*(unaff_EBP + 8) != 0) {\n            iVar2 = fcn.0042c6b9(*(unaff_EBP + 8));\n            if (iVar2 == 0) goto code_r0x00433735;\n            uVar6 = *(unaff_EBP + -0x14);\n        }\n        if (*(unaff_EBP + 0xc) == NULL) {\n            *(arg_8h_00 + 0x10) = uVar6;\n        }\n        else {\n            **(unaff_EBP + 0xc) = uVar6;\n        }\n        if (*(unaff_EBP + 0x10) != NULL) {\n            **(unaff_EBP + 0x10) = uVar5;\n        }\ncode_r0x0043370a:\n        *in_FS_OFFSET = *(unaff_EBP + -0xc);\n        return iVar7;\n    }\n    in_stack_ffffffd4 = unaff_EBP + -0x14;\n    in_stack_ffffffd0 = arg_8h_00;\n    iVar7 = fcn.00430fac(arg_8h_00, in_stack_ffffffd4);\n    if (iVar7 != 0) {\n        if ((*(iVar7 + 8) & 0x7fffffff) != *(unaff_EBP + -0x14)) {\n            if (-1 < *(iVar7 + 8)) goto code_r0x00433841;\n            if (*(arg_8h_00 + 0x3c) == 0) {\n                iVar2 = fcn.00425ce2(0x1c);\n                *(unaff_EBP + -0x1c) = iVar2;\n                *(unaff_EBP + -4) = 0;\n                if (iVar2 == 0) {\n                    uVar3 = 0;\n                }\n                else {\n                    uVar3 = fcn.00425ab1(10);\n                }\n                *(unaff_EBP + -4) = 0xffffffff;\n                *(arg_8h_00 + 0x3c) = uVar3;\n            }\n            uVar3 = *(unaff_EBP + -0x14);\n            puVar4 = fcn.00425b35(iVar7);\n            *puVar4 = uVar3;\n            uVar5 = *(unaff_EBP + -0x18);\n        }\n        fcn.004334b6();\n        iVar2 = *(arg_8h_00 + 0x34);\n        *(arg_8h_00 + 0x34) = iVar2 + 1;\n        fcn.00424c37(iVar2, iVar7, 1);\n        uVar6 = *(unaff_EBP + -0x14);\n        goto code_r0x00433803;\n    }\ncode_r0x00433735:\n    in_stack_ffffffd4 = *(arg_8h_00 + 0x14);\n    in_stack_ffffffd0 = 6;\ncode_r0x00433841:\n    fcn.00434a73(in_stack_ffffffd0, in_stack_ffffffd4);\n    pcVar1 = swi(3);\n    iVar7 = (*pcVar1)();\n    return iVar7;\n}\n",
        "token_count": 1564
    },
    "004338fe": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.004338fe(int32_t arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint32_t in_ECX;\n    uint in_stack_ffffffd0;\n    uint in_stack_ffffffd4;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    var_8h = in_ECX;\n    if ((*(in_ECX + 0x18) & 1) != 0) {\n        var_4h = in_ECX;\n        iVar2 = fcn.00433679(arg_8h, &var_8h, &var_4h);\n        if (iVar2 != 0) goto code_r0x00433969;\n        if (var_4h <= *(*(in_ECX + 0x38) + 8) - 1U) {\n            piVar3 = fcn.00405ccb(var_4h);\n            if (piVar3 == NULL) {\n                return NULL;\n            }\n            if (arg_8h == 0) {\n                return piVar3;\n            }\n            iVar2 = fcn.0042c6e0(arg_8h);\n            if (iVar2 != 0) {\n                return piVar3;\n            }\n            in_stack_ffffffd4 = *(in_ECX + 0x14);\n            in_stack_ffffffd0 = 6;\n        }\n    }\n    fcn.00434a73(in_stack_ffffffd0, in_stack_ffffffd4);\ncode_r0x00433969:\n    piVar3 = fcn.0042c660();\n    if (piVar3 == NULL) {\n        fcn.004202f9();\n    }\n    fcn.004334b6();\n    iVar2 = *(in_ECX + 0x34);\n    *(in_ECX + 0x34) = iVar2 + 1;\n    fcn.00424c37(iVar2, piVar3, 1);\n    uVar1 = *(in_ECX + 0x10);\n    *(in_ECX + 0x10) = var_8h;\n    (**(*piVar3 + 8))();\n    *(in_ECX + 0x10) = uVar1;\n    return piVar3;\n}\n",
        "token_count": 516
    },
    "004339c1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004339c1(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    var_4h = (**(*param_1 + 0x60))();\n    do {\n        if (var_4h == NULL) {\n            uVar2 = (**(*param_1 + 0x90))();\n            return uVar2;\n        }\n        (**(*param_1 + 100))(&var_4h);\n        iVar1 = fcn.00428388();\n    } while ((iVar1 == 0) || (*(iVar1 + 0x54) < 1));\n    return 1;\n}\n",
        "token_count": 168
    },
    "00433ab6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00433ab6(int32_t *arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t *in_ECX;\n    int32_t var_4h;\n    \n    var_4h = (**(*in_ECX + 0x60))();\n    while (var_4h != 0) {\n        piVar1 = (**(*in_ECX + 100))(&var_4h);\n        if (piVar1 != arg_8h) {\n            (**(*piVar1 + 0x164))(arg_8h, arg_ch, arg_10h);\n        }\n    }\n    return;\n}\n",
        "token_count": 155
    },
    "00433af7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00433af7(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    var_4h = (**(*param_1 + 0x60))();\n    while (var_4h != NULL) {\n        piVar1 = (**(*param_1 + 100))(&var_4h);\n        (**(*piVar1 + 0x158))();\n    }\n    return;\n}\n",
        "token_count": 118
    },
    "00433b6c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00433b6c(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 0x34);\n    while (iVar1 != 0) {\n        iVar1 = fcn.00424787();\n        *(iVar1 + 0x50) = 0;\n        iVar1 = *(param_1 + 0x34);\n    }\n    return;\n}\n",
        "token_count": 97
    },
    "00433ce0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00433ce0(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    iVar1 = param_1[0x12];\n    param_1[0x12] = 0;\n    iVar2 = param_1[0xd];\n    while (iVar2 != 0) {\n        piVar3 = fcn.00428388();\n        (**(*param_1 + 0x94))(piVar3);\n        (**(*piVar3 + 0x60))();\n        iVar2 = param_1[0xd];\n    }\n    param_1[0x12] = iVar1;\n    (**(*param_1 + 0x6c))();\n    if (param_1[0x12] != 0) {\n        (**(*param_1 + 4))(1);\n    }\n    return;\n}\n",
        "token_count": 205
    },
    "00433dcb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00433dcb(void)\n\n{\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *(unaff_EBP + -4) = 3;\n    fcn.00433b6c();\n    if (*(extraout_ECX + 0x24) != 0) {\n        (**(**(extraout_ECX + 0x24) + 0x60))(extraout_ECX);\n    }\n    *(unaff_EBP + -4) = 2;\n    fcn.0042486f();\n    fcn.00403164();\n    fcn.00403164();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042aa3f();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 253
    },
    "00434098": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00434098(uint lpString, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    uint var_208h;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n    if (iVar1 < 0x104) {\n        iVar1 = fcn.0042f0fa(&var_108h, lpString);\n        if (iVar1 != 0) goto code_r0x004340db;\n    }\n    fcn.0043015b(3, 0xffffffff, 0);\ncode_r0x004340db:\n    fcn.004045a1(&var_108h);\n    in_ECX[0x13] = 0;\n    iVar1 = fcn.0042ee2a(&var_108h, &var_208h, 0x100);\n    if (iVar1 == 0) {\n        (**(*in_ECX + 0x50))(&var_208h);\n    }\n    if (arg_ch != 0) {\n        iVar1 = fcn.0044be10();\n        (**(**(iVar1 + 4) + 0x8c))(in_ECX[8]);\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 316
    },
    "00434abc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint fcn.00434abc(void)\n\n{\n    int32_t iVar1;\n    \n    if (*0x497a18 == 0) {\n        *0x497a18 = 1;\n        if (*0x49960c == 0) {\n            *0x499588 = 3;\n            (*_sym.imp.USER32.dll_SystemParametersInfoA)(0x68, 0, 0x499588, 0);\n        }\n        else {\n            if (*0x499590 == 0) {\n                *0x49958c = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(\"MSH_SCROLL_LINES_MSG\");\n                if (*0x49958c == 0) {\n                    *0x499590 = 1;\n                    return *0x499588;\n                }\n                *0x499590 = 2;\n            }\n            if (((*0x499590 == 2) &&\n                (iVar1 = (*_sym.imp.USER32.dll_FindWindowA)(\"MouseZ\", \"Magellan MSWHEEL\"),  iVar1 != 0)) &&\n               (*0x49958c != 0)) {\n                *0x499588 = (*_sym.imp.USER32.dll_SendMessageA)(iVar1, *0x49958c, 0, 0);\n            }\n        }\n    }\n    return *0x499588;\n}\n",
        "token_count": 291
    },
    "00434caa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00434caa(uint32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if ((arg_10h != 0) && (iVar1 = fcn.00427e61(0),  iVar1 != 0)) {\n        return;\n    }\n    iVar1 = (**(*in_ECX + 0x70))(0);\n    if (arg_10h == iVar1) {\n        (**(*in_ECX + 0x134))(arg_8h & 0xff | 0xff00, arg_ch, 1);\n    }\n    return;\n}\n",
        "token_count": 154
    },
    "00434cf1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00434cf1(uint32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if ((arg_10h != 0) && (iVar1 = fcn.00427e61(0),  iVar1 != 0)) {\n        return;\n    }\n    iVar1 = (**(*in_ECX + 0x70))(1);\n    if (arg_10h == iVar1) {\n        (**(*in_ECX + 0x134))((arg_8h & 0xff) << 8 | 0xff, arg_ch, 1);\n    }\n    return;\n}\n",
        "token_count": 159
    },
    "004356f0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004356f0(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    int32_t lParam;\n    int32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    uint lpRect;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (*(param_1 + 0x80) == 0) {\n        *(param_1 + 0x80) = 1;\n        var_4h = 1;\n        uVar1 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x1c));\n        iVar2 = fcn.004278de(uVar1);\n        if ((iVar2 == 0) ||\n           (iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x1c), 0x368, 0, &lParam),  iVar2 == 0)) {\n            iVar3 = fcn.004355ba(&var_18h, &var_10h);\n            iVar2 = var_14h;\n            iVar4 = var_18h;\n            if (iVar3 == 0) {\n                (*_sym.imp.USER32.dll_GetClientRect)(*(param_1 + 0x1c), &lpRect);\n                if ((0 < var_20h) && (0 < var_1ch)) {\n                    fcn.00426eb6(3, 0);\n                }\n                *(param_1 + 0x80) = 0;\n                return;\n            }\n        }\n        else {\n            var_4h = 0;\n            fcn.00434c50();\n            iVar2 = var_2ch - var_34h;\n            iVar4 = var_30h - lParam;\n        }\n        fcn.0043562f(iVar4, iVar2, &var_8h, &var_20h, &var_18h, var_4h);\n        if (var_8h != 0) {\n            iVar2 = iVar2 - var_ch;\n        }\n        if (var_4h != 0) {\n            iVar4 = iVar4 - var_10h;\n        }\n        fcn.00434bfe(var_18h, var_14h);\n        var_4ch = 0;\n        var_50h = 3;\n        fcn.00426eb6(0, var_8h);\n        if (var_8h != 0) {\n            var_48h = *(param_1 + 100) + -1;\n            var_44h = iVar4;\n            iVar4 = fcn.00426122(0, &var_54h, 1);\n            if (iVar4 == 0) {\n                fcn.00426e51(0, 0, var_20h, 1);\n            }\n        }\n        fcn.00426eb6(1, var_4h);\n        if (var_4h != 0) {\n            var_48h = *(param_1 + 0x68) + -1;\n            var_44h = iVar2;\n            iVar2 = fcn.00426122(1, &var_54h, 1);\n            if (iVar2 == 0) {\n                fcn.00426e51(1, 0, var_1ch, 1);\n            }\n        }\n        *(param_1 + 0x80) = 0;\n    }\n    return;\n}\n",
        "token_count": 886
    },
    "00435a7f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00435a7f(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    uint uVar4;\n    int32_t *piVar5;\n    uint32_t uVar6;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetCursorPos)(&var_10h);\n    (*_sym.imp.USER32.dll_GetWindowRect)(param_1[7], &var_28h);\n    iVar1 = param_1[0x1b];\n    uVar6 = 0;\n    if ((iVar1 == 0x7923) || (iVar1 == 0x7922)) {\n        if (var_ch < var_24h) {\n            uVar6 = 30999;\n        }\n        else if (var_1ch < var_ch) {\n            uVar6 = 0x791d;\n        }\n    }\n    if ((iVar1 == 0x7923) || (iVar1 == 0x7921)) {\n        if (var_10h < var_28h) {\n            if (uVar6 == 0) {\n                uVar6 = 0x7919;\n            }\n            else if (iVar1 == 0x7923) {\n                uVar6 = uVar6 - 1;\n            }\n        }\n        else if (var_20h < var_10h) {\n            if (uVar6 == 0) {\n                uVar6 = 0x791b;\n            }\n            else if (iVar1 == 0x7923) {\n                uVar6 = uVar6 + 1;\n            }\n        }\n    }\n    if (param_1[0x1a] == 0) {\n        if (uVar6 == 0) {\n            (*_sym.imp.USER32.dll_SetCursor)(param_1[0x1c]);\n        }\n        else {\n            iVar1 = fcn.0044be10();\n            uVar2 = (*_sym.imp.USER32.dll_LoadCursorA)(*(iVar1 + 0xc), uVar6 & 0xffff);\n            (*_sym.imp.USER32.dll_SetCursor)(uVar2);\n            if ((var_20h < var_10h) || (var_20h = var_28h,  var_10h < var_28h)) {\n                var_8h = var_10h - var_20h;\n            }\n            else {\n                var_8h = 0;\n            }\n            if ((var_1ch < var_ch) || (var_1ch = var_24h,  var_ch < var_24h)) {\n                var_4h = var_ch - var_1ch;\n            }\n            else {\n                var_4h = 0;\n            }\n            piVar3 = fcn.00405a6f();\n            iVar1 = param_1[0x1b];\n            if ((iVar1 == 0x7923) || (iVar1 == 0x7922)) {\n                uVar2 = 1;\n            }\n            else {\n                uVar2 = 0;\n            }\n            if ((iVar1 == 0x7923) || (iVar1 == 0x7921)) {\n                uVar4 = 1;\n            }\n            else {\n                uVar4 = 0;\n            }\n            (**(*piVar3 + 0x180))(&var_18h, var_8h, var_4h, uVar4, uVar2);\n            fcn.0042a2ea(0);\n            uVar2 = (*_sym.imp.USER32.dll_GetParent)(piVar3[7]);\n            uVar2 = fcn.004278de(uVar2);\n            piVar5 = fcn.0042c6eb(0x46e418, uVar2);\n            if (piVar5 == NULL) {\n                (**(*piVar3 + 0x138))();\n            }\n            else {\n                (**(*piVar5 + 0x178))(piVar3, var_18h, var_14h, 1);\n            }\n            (*_sym.imp.USER32.dll_UpdateWindow)(param_1[7]);\n            fcn.0042a4e3(0x499250, param_1[0x18] + -0x10, param_1[0x19] + -0x10, 0, 0, 0x51);\n        }\n    }\n    else {\n        (*_sym.imp.USER32.dll_KillTimer)(param_1[7], 0xe000);\n        (*_sym.imp.USER32.dll_ReleaseCapture)();\n        (*_sym.imp.USER32.dll_SetCursor)(0);\n        iVar1 = fcn.00405a6f();\n        (**(*param_1 + 0x60))();\n        if (*(iVar1 + 0x54) != NULL) {\n            (**(**(iVar1 + 0x54) + 4))(1);\n        }\n        *(iVar1 + 0x54) = 0;\n    }\n    return;\n}\n",
        "token_count": 1191
    },
    "00435c77": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00435c77(int32_t *arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    int32_t lpRect;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    \n    if (*(in_ECX + 0x58) == -1) {\n        (**(*arg_8h + 0x34))(8);\n        (**(*arg_8h + 0x48))(&var_8h, *(in_ECX + 0x5c), *(in_ECX + 0x60));\n        (**(*arg_8h + 0x40))(&var_10h, *(in_ECX + 100), *(in_ECX + 0x68));\n    }\n    else {\n        (**(*arg_8h + 0x34))(*(in_ECX + 0x58));\n    }\n    iVar2 = 0;\n    var_8h = 0;\n    if (arg_8h[3] == 0) {\n        piVar1 = fcn.0043520f(&var_10h);\n        var_8h = -*piVar1;\n        iVar2 = -piVar1[1];\n        if (*(in_ECX + 0x7c) != 0) {\n            (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lpRect);\n            if (*(in_ECX + 100) < var_10h - lpRect) {\n                var_8h = ((var_10h - *(in_ECX + 100)) - lpRect) / 2;\n            }\n            if (*(in_ECX + 0x68) < var_ch - var_14h) {\n                iVar2 = ((var_ch - *(in_ECX + 0x68)) - var_14h) / 2;\n            }\n        }\n    }\n    (**(*arg_8h + 0x38))(&var_10h, var_8h, iVar2);\n    fcn.00436529(arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 497
    },
    "00435de0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid __cdecl fcn.00435de0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    code *pcVar5;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_24h;\n    uint var_1ch;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = *(extraout_ECX + 0x58);\n    *(extraout_ECX + 0x58) = *(unaff_EBP + 8);\n    *(extraout_ECX + 0x5c) = *(unaff_EBP + 0xc);\n    *(extraout_ECX + 0x60) = *(unaff_EBP + 0x10);\n    fcn.00432262(0);\n    uVar2 = *(extraout_ECX + 0x58);\n    *(unaff_EBP + -4) = 0;\n    fcn.00431634(uVar2);\n    pcVar5 = _sym.imp.GDI32.dll_LPtoDP;\n    uVar2 = *(unaff_EBP + -0x1c);\n    *(extraout_ECX + 100) = *(extraout_ECX + 0x5c);\n    *(extraout_ECX + 0x68) = *(extraout_ECX + 0x60);\n    (*pcVar5)(uVar2, extraout_ECX + 100, 1);\n    iVar3 = (*(unaff_EBP + 0x14))[1];\n    piVar1 = extraout_ECX + 0x6c;\n    uVar2 = *(unaff_EBP + -0x1c);\n    *piVar1 = **(unaff_EBP + 0x14);\n    *(extraout_ECX + 0x70) = iVar3;\n    (*pcVar5)(uVar2, piVar1, 1);\n    uVar2 = (*(unaff_EBP + 0x18))[1];\n    uVar4 = *(unaff_EBP + -0x1c);\n    *(extraout_ECX + 0x74) = **(unaff_EBP + 0x18);\n    *(extraout_ECX + 0x78) = uVar2;\n    (*pcVar5)(uVar4, extraout_ECX + 0x74, 1);\n    if (*(extraout_ECX + 0x68) < 0) {\n        *(extraout_ECX + 0x68) = -*(extraout_ECX + 0x68);\n    }\n    if (*(extraout_ECX + 0x70) < 0) {\n        *(extraout_ECX + 0x70) = -*(extraout_ECX + 0x70);\n    }\n    if (*(extraout_ECX + 0x78) < 0) {\n        *(extraout_ECX + 0x78) = -*(extraout_ECX + 0x78);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004322bd();\n    if (*piVar1 == 0) {\n        *piVar1 = *(extraout_ECX + 100) / 10;\n    }\n    if (*(extraout_ECX + 0x70) == 0) {\n        *(extraout_ECX + 0x70) = *(extraout_ECX + 0x68) / 10;\n    }\n    if (*(extraout_ECX + 0x74) == 0) {\n        *(extraout_ECX + 0x74) = *piVar1 / 10;\n    }\n    if (*(extraout_ECX + 0x78) == 0) {\n        *(extraout_ECX + 0x78) = *(extraout_ECX + 0x70) / 10;\n    }\n    if (*(extraout_ECX + 0x1c) != 0) {\n        fcn.004356f0();\n        if (*(unaff_EBP + -0x10) != *(extraout_ECX + 0x58)) {\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(extraout_ECX + 0x1c), 0, 1);\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 1057
    },
    "004363a7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.004363a7(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBX;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetParent;\n    uVar2 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x1c));\n    uVar2 = fcn.004278de(uVar2);\n    iVar3 = fcn.0042c6e0(0x46e418);\n    if (iVar3 != 0) {\n        if (unaff_EBX != 0) {\n            return uVar2;\n        }\n        do {\n            uVar4 = (*pcVar1)(*(param_1 + 0x1c));\n            param_1 = fcn.004278de(uVar4);\n            if (param_1 == 0) {\n                return uVar2;\n            }\n            iVar3 = (*_sym.imp.USER32.dll_IsIconic)(*(param_1 + 0x1c));\n        } while (iVar3 == 0);\n    }\n    return 0;\n}\n",
        "token_count": 260
    },
    "004366bb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004366bb(int32_t hWnd, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    uint lpClassName;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    if ((hWnd != 0) && (uVar1 = (*_sym.imp.USER32.dll_GetWindowLongA)(hWnd, 0xfffffff0),  (uVar1 & 0xf) == arg_ch)) {\n        (*_sym.imp.USER32.dll_GetClassNameA)(hWnd, &lpClassName, 10);\n        (*_sym.imp.KERNEL32.dll_lstrcmpiA)(&lpClassName, \"combobox\");\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 166
    },
    "00436d44": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00436d44(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piStack8;\n    int32_t *piStack4;\n    \n    pcVar1 = _sym.imp.USER32.dll_LoadCursorA;\n    piStack8 = param_1;\n    piStack4 = param_1;\n    if ((*0x4995fc == 0) && (*0x4995fc = (*_sym.imp.USER32.dll_LoadCursorA)(0, 0x7f8b),  *0x4995fc == 0)) {\n        iVar2 = fcn.0044be10();\n        *0x4995fc = (*pcVar1)(*(iVar2 + 0xc), 0x7901);\n        if (*0x4995fc == 0) {\n            return;\n        }\n    }\n    (**(*param_1 + 0xc))(0xe145, 0, 0, &piStack8);\n    return;\n}\n",
        "token_count": 228
    },
    "00436d9e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00436d9e(uint arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t in_ECX;\n    int32_t iVar8;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar8 = 0;\n    if (*(in_ECX + 100) == 0) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.USER32.dll_GetCapture)();\n    iVar2 = fcn.00403cae(arg_8h, arg_ch);\n    if (iVar2 == 0) {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = *(iVar2 + 0x1c);\n    }\n    iVar3 = fcn.00428b49();\n    uVar4 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n    fcn.004278de(uVar4);\n    iVar5 = fcn.00428b49();\n    var_ch = 0;\n    iVar6 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n    if (iVar2 != 0) {\n        iVar8 = (*_sym.imp.USER32.dll_GetWindowThreadProcessId)(iVar2, 0);\n    }\n    if ((iVar5 == 0) || (iVar7 = (*_sym.imp.USER32.dll_GetDesktopWindow)(),  iVar2 == iVar7)) {\n        uVar4 = *0x4995f8;\n        if (iVar1 == *(in_ECX + 0x1c)) {\n            (*_sym.imp.USER32.dll_ReleaseCapture)();\n            uVar4 = *0x4995f8;\n        }\ncode_r0x00436e8b:\n        (*_sym.imp.USER32.dll_SetCursor)(uVar4);\n        goto code_r0x00436e91;\n    }\n    if (iVar2 == 0) {\ncode_r0x00436e60:\n        if (iVar6 != iVar8) goto code_r0x00436e65;\n    }\n    else {\n        if (iVar6 == iVar8) {\n            uVar4 = *(in_ECX + 0x1c);\n            iVar7 = fcn.004418f8();\n            if (iVar7 != 0) {\n                var_ch = 1;\n                if (iVar5 != iVar3) {\n                    iVar2 = 0;\n                    goto code_r0x00436e91;\n                }\n                uVar4 = *0x4995fc;\n                if (iVar1 != *(in_ECX + 0x1c)) {\n                    (*_sym.imp.USER32.dll_SetCapture)(*(in_ECX + 0x1c));\n                    uVar4 = *0x4995fc;\n                }\n                goto code_r0x00436e8b;\n            }\n            goto code_r0x00436e60;\n        }\ncode_r0x00436e65:\n        iVar2 = 0;\n    }\n    if (iVar1 == *(in_ECX + 0x1c)) {\n        (*_sym.imp.USER32.dll_ReleaseCapture)(uVar4);\n    }\ncode_r0x00436e91:\n    if (arg_10h != NULL) {\n        *arg_10h = var_ch;\n    }\n    return iVar2;\n}\n",
        "token_count": 771
    },
    "00436ea6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00436ea6(int32_t arg_8h, uint *arg_ch)\n\n{\n    uint32_t uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    uint var_28h;\n    uint lpPoint;\n    uint var_8h;\n    int32_t *var_4h;\n    \n    iVar3 = arg_8h;\n    uVar1 = *(arg_8h + 4);\n    if ((uVar1 == 0x367) || ((uVar1 == 0x100 && (*(arg_8h + 8) == 0x1b)))) {\n        uVar6 = *(arg_8h + 4);\ncode_r0x00437096:\n        (*_sym.imp.USER32.dll_PeekMessageA)(iVar3, 0, uVar6, uVar6, 1);\n        return 0;\n    }\n    if (((uVar1 < 0x200) || (0x209 < uVar1)) && ((uVar1 < 0xa0 || (0xa9 < uVar1)))) {\n        if ((uVar1 != 0x112) && ((uVar1 < 0x100 || (0x109 < uVar1)))) {\n            iVar4 = (*_sym.imp.USER32.dll_PeekMessageA)(arg_8h, 0, *(arg_8h + 4), *(arg_8h + 4), 1);\n            if (iVar4 == 0) {\n                return 1;\n            }\ncode_r0x00436fe3:\n            (*_sym.imp.USER32.dll_DispatchMessageA)(iVar3);\n            return 1;\n        }\n        iVar4 = (*_sym.imp.USER32.dll_GetCapture)();\n        pcVar2 = _sym.imp.USER32.dll_PeekMessageA;\n        if (iVar4 != 0) {\n            (*_sym.imp.USER32.dll_ReleaseCapture)();\n            do {\n                iVar4 = (*pcVar2)(&var_28h, 0, 0x200, 0x209, 3);\n            } while (iVar4 != 0);\n        }\n        iVar4 = (*pcVar2)(iVar3, 0, *(iVar3 + 4), *(iVar3 + 4), 0);\n        if (iVar4 == 0) goto code_r0x0043706f;\n        (*_sym.imp.USER32.dll_GetMessageA)(iVar3, 0, *(iVar3 + 4), *(iVar3 + 4));\n        iVar4 = (**(*var_4h + 0x100))(iVar3);\n        if (iVar4 != 0) goto code_r0x0043706f;\n        (*_sym.imp.USER32.dll_TranslateMessage)(iVar3);\n        uVar1 = *(iVar3 + 4);\n        if ((uVar1 != 0x112) && ((uVar1 < 0x104 || (0x107 < uVar1)))) goto code_r0x0043706f;\n    }\n    else {\n        iVar4 = fcn.00436d9e(*(arg_8h + 0x14), *(arg_8h + 0x18), &arg_8h);\n        if (iVar4 == 0) {\n            return 1;\n        }\n        if (arg_8h == 0) {\n            (*_sym.imp.USER32.dll_PeekMessageA)(iVar3, 0, *(iVar3 + 4), *(iVar3 + 4), 1);\n            goto code_r0x00436fe3;\n        }\n        if (*(iVar3 + 4) != 0x201) {\n            (*_sym.imp.USER32.dll_PeekMessageA)(iVar3, 0, *(iVar3 + 4), *(iVar3 + 4), 1);\n            return 1;\n        }\n        iVar5 = (*_sym.imp.USER32.dll_SendMessageA)(iVar4, 0x84, 0, CONCAT22(*(iVar3 + 0x18), *(iVar3 + 0x14)));\n        if ((iVar5 != 5) && (iVar5 != 3)) {\n            if (iVar5 == 1) {\n                uVar6 = fcn.00436ba7(iVar4, *(iVar3 + 0x14), iVar4);\n            }\n            else {\n                uVar6 = fcn.00436c15(iVar5);\n            }\n            *arg_ch = uVar6;\n            uVar6 = *(iVar3 + 4);\n            goto code_r0x00437096;\n        }\n        (*_sym.imp.USER32.dll_ReleaseCapture)();\n        (*_sym.imp.USER32.dll_GetMessageA)(iVar3, 0, 0xa1, 0xa1);\n    }\n    (*_sym.imp.USER32.dll_DispatchMessageA)(iVar3);\ncode_r0x0043706f:\n    (*_sym.imp.USER32.dll_GetCursorPos)(&lpPoint);\n    fcn.00436d9e(lpPoint, var_8h, 0);\n    return 1;\n}\n",
        "token_count": 1129
    },
    "004370a6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004370a6(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint lpMsg;\n    uint lpPoint;\n    uint var_14h;\n    int32_t *var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (((*(param_1 + 100) != 1) && (iVar3 = fcn.00436d44(),  iVar3 != 0)) &&\n       (iVar3 = (*_sym.imp.USER32.dll_PeekMessageA)(&lpMsg, *(param_1 + 0x1c), 0x367, 0x367, 3),  iVar3 == 0)) {\n        iVar3 = *(param_1 + 100);\n        *(param_1 + 100) = 1;\n        if (((iVar3 == 2) || (*(param_1 + 0x7c) == NULL)) || (iVar4 = (**(**(param_1 + 0x7c) + 0x60))(1),  iVar4 != 0))\n        {\n            if (iVar3 == 0) {\n                (*_sym.imp.USER32.dll_PostMessageA)(*(param_1 + 0x1c), 0x111, 0xe145);\n                *(param_1 + 100) = 2;\n            }\n            else {\n                var_ch = (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x1c), 0x362, 0xe002, 0);\n                if (var_ch == 0) {\n                    var_ch = 0xe001;\n                }\n                var_8h = 0;\n                (*_sym.imp.USER32.dll_GetCursorPos)(&lpPoint);\n                fcn.00436d9e(lpPoint, var_14h, 0);\n                var_4h = 0;\n                iVar3 = fcn.0044be10();\n                piVar1 = *(iVar3 + 4);\n                var_10h = piVar1;\n                do {\n                    while( true ) {\n                        if (*(param_1 + 100) == 0) goto code_r0x004371ce;\n                        iVar3 = (*_sym.imp.USER32.dll_PeekMessageA)(&lpMsg, 0, 0, 0, 0);\n                        if (iVar3 != 0) break;\n                        iVar3 = (**(*piVar1 + 0x60))(var_4h);\n                        var_4h = var_4h + 1;\n                        if (iVar3 == 0) {\n                            var_4h = 0;\n                            (*_sym.imp.USER32.dll_WaitMessage)();\n                        }\n                    }\n                    iVar3 = fcn.00436ea6(&lpMsg, &var_8h);\n                } while (iVar3 != 0);\ncode_r0x004371ce:\n                pcVar2 = _sym.imp.USER32.dll_ReleaseCapture;\n                *(param_1 + 100) = 0;\n                (*pcVar2)();\n                uVar5 = (*_sym.imp.USER32.dll_SetCapture)(*(param_1 + 0x1c));\n                fcn.004278de(uVar5);\n                (*pcVar2)();\n                pcVar2 = _sym.imp.USER32.dll_SendMessageA;\n                (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x1c), 0x362, var_ch, 0);\n                if (*(param_1 + 0x7c) != NULL) {\n                    (**(**(param_1 + 0x7c) + 0x60))(0);\n                }\n                if (var_8h != 0) {\n                    if (var_8h == -1) {\n                        (*pcVar2)(*(param_1 + 0x1c), 0x111, 0xe147, 0);\n                    }\n                    else {\n                        (**(*var_10h + 0xac))(var_8h, 1);\n                    }\n                }\n                (*_sym.imp.USER32.dll_PostMessageA)(*(param_1 + 0x1c), 0x36a, 0, 0);\n            }\n        }\n        else {\n            (**(**(param_1 + 0x7c) + 0x60))(0);\n            *(param_1 + 100) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 1009
    },
    "0043724d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0043724d(uint hModule, int32_t hResInfo, int32_t arg_10h)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    uchar uVar5;\n    uchar extraout_AH;\n    int32_t *piVar6;\n    int32_t *arg_ch;\n    int32_t *arg_8h;\n    uint32_t uVar7;\n    uint uVar8;\n    int32_t *piVar9;\n    uint uVar10;\n    uint uVar11;\n    uint hResData;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar6 = (*_sym.imp.KERNEL32.dll_LoadResource)(hModule, hResInfo);\n    piVar9 = piVar6;\n    if ((piVar6 != NULL) && (arg_ch = (*_sym.imp.KERNEL32.dll_LockResource)(piVar6),  piVar9 = arg_ch,  arg_ch != NULL))\n    {\n        iVar2 = *arg_ch;\n        arg_8h = fcn.0040d946(iVar2 + 0x40);\n        piVar9 = arg_8h;\n        if (arg_8h != NULL) {\n            fcn.0040e680(arg_8h, arg_ch, iVar2 + 0x40);\n            iVar2 = *arg_8h;\n            hResInfo = 0;\n            do {\n                uVar7 = 0;\n                do {\n                    if (*(arg_8h + hResInfo * 4 + iVar2) == *(uVar7 * 8 + 0x4695f8)) {\n                        if (arg_10h == 0) {\n                            puVar1 = uVar7 * 8 + 0x4695fc;\n                            (*_sym.imp.USER32.dll_GetSysColor)(*puVar1);\n                            uVar5 = (*_sym.imp.USER32.dll_GetSysColor)(*puVar1);\n                            uVar7 = (*_sym.imp.USER32.dll_GetSysColor)(*puVar1);\n                            *(arg_8h + hResInfo * 4 + iVar2) = CONCAT11(uVar5, extraout_AH) << 8 | uVar7 >> 0x10 & 0xff;\n                        }\n                        else if (*(uVar7 * 8 + 0x4695fc) != 0x12) {\n                            *(arg_8h + hResInfo * 4 + iVar2) = 0xffffff;\n                        }\n                        break;\n                    }\n                    uVar7 = uVar7 + 1;\n                } while (uVar7 < 4);\n                hResInfo = hResInfo + 1;\n            } while (hResInfo < 0x10);\n            iVar2 = arg_8h[1];\n            iVar3 = arg_8h[2];\n            uVar8 = (*_sym.imp.USER32.dll_GetDC)(0);\n            piVar9 = (*_sym.imp.GDI32.dll_CreateCompatibleBitmap)(uVar8, iVar2, iVar3);\n            if (piVar9 != NULL) {\n                uVar10 = (*_sym.imp.GDI32.dll_CreateCompatibleDC)(uVar8);\n                pcVar4 = _sym.imp.GDI32.dll_SelectObject;\n                uVar11 = (*_sym.imp.GDI32.dll_SelectObject)(uVar10, piVar9);\n                (*_sym.imp.GDI32.dll_StretchDIBits)\n                          (uVar10, 0, 0, iVar2, iVar3, 0, 0, iVar2, iVar3, arg_ch + (1 << (*(arg_8h + 0xe) & 0x1f)) + 10\n                           , arg_8h, 0, 0xcc0020);\n                (*pcVar4)(uVar10, uVar11);\n                (*_sym.imp.GDI32.dll_DeleteDC)(uVar10);\n            }\n            (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar8);\n            fcn.0040d958(arg_8h);\n            (*_sym.imp.KERNEL32.dll_FreeResource)(piVar6);\n        }\n    }\n    return piVar9;\n}\n",
        "token_count": 934
    },
    "004374aa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004374aa(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint8_t *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar6 = 0;\n    iVar5 = 0;\n    var_4h = 0;\n    if (arg_ch < 1) {\ncode_r0x00437555:\n        return var_4h + 1;\n    }\ncode_r0x004374c8:\n    piVar1 = arg_8h + iVar6 * 0x14;\n    piVar2 = piVar1 + 2;\n    *piVar2 = *piVar2 & 0xdf;\n    if ((*piVar2 & 8) == 0) {\n        if ((*(piVar1 + 9) & 1) == 0) {\n            iVar3 = *(in_ECX + 0xa8);\n        }\n        else {\n            iVar3 = *piVar1;\n        }\n        iVar5 = iVar3 + iVar5;\n        iVar3 = iVar6;\n        if (arg_10h < iVar5) {\n            for (; (-1 < iVar3 && ((*piVar2 & 0x20) == 0)); piVar2 = piVar2 + -5) {\n                if (((*(piVar2 + 1) & 1) != 0) && ((piVar2[-1] == 0 && ((*piVar2 & 8) == 0)))) goto code_r0x0043756b;\n                iVar3 = iVar3 + -1;\n            }\n            iVar3 = iVar6 + -1;\n            if (-1 < iVar3) {\n                puVar4 = arg_8h + 8 + iVar3 * 0x14;\n                do {\n                    if ((*puVar4 & 0x20) != 0) break;\n                    if (((*puVar4 & 8) == 0) && (((puVar4[1] & 1) == 0 || (*(puVar4 + -4) == 0))))\n                    goto code_r0x0043756b;\n                    iVar3 = iVar3 + -1;\n                    puVar4 = puVar4 + -0x14;\n                } while (-1 < iVar3);\n            }\n        }\n    }\n    goto code_r0x0043754a;\ncode_r0x0043756b:\n    puVar4 = arg_8h + 8 + iVar3 * 0x14;\n    *puVar4 = *puVar4 | 0x20;\n    iVar5 = 0;\n    var_4h = var_4h + 1;\n    iVar6 = iVar3;\ncode_r0x0043754a:\n    iVar6 = iVar6 + 1;\n    if (arg_ch <= iVar6) goto code_r0x00437555;\n    goto code_r0x004374c8;\n}\n",
        "token_count": 697
    },
    "004378b8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004378b8(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint8_t *puVar7;\n    int32_t var_18h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar6 = 0;\n    var_18h = 0;\n    var_10h = 0;\n    var_ch = 0;\n    uVar2 = (**(*in_ECX + 0x110))(0x455, 0, 0);\n    if (0 < arg_10h) {\n        puVar7 = arg_ch + 9;\n        var_4h = arg_10h;\n        do {\n            arg_ch = *(puVar7 + -9);\n            uVar3 = fcn.0042a1c5();\n            if (((uVar3 & 0x800) == 0) && (*0x494d18 != 0x40047)) {\n                arg_ch = (arg_ch * 2) / 3;\n            }\n            if ((puVar7[-1] & 8) == 0) {\n                uVar1 = *puVar7;\n                iVar5 = in_ECX[0x2a];\n                if ((uVar1 & 1) == 0) {\n                    if (((uVar1 & 8) != 0) && ((uVar2 & 1) != 0)) {\n                        iVar5 = iVar5 + *0x494d1c;\n                    }\n                    if (var_10h < var_18h + iVar5) {\n                        var_10h = var_18h + iVar5;\n                    }\n                    iVar4 = in_ECX[0x2b] + iVar6;\ncode_r0x00437987:\n                    if (var_ch < iVar4) {\n                        var_ch = iVar4;\n                    }\n                }\n                else {\n                    if ((puVar7[-1] & 0x20) != 0) {\n                        iVar4 = in_ECX[0x2b] + iVar6 + arg_ch;\n                        goto code_r0x00437987;\n                    }\n                    if (var_10h < *(puVar7 + -9) + var_18h) {\n                        var_10h = *(puVar7 + -9) + var_18h;\n                    }\n                }\n                if ((uVar1 & 1) != 0) {\n                    iVar5 = *(puVar7 + -9);\n                }\n                var_18h = var_18h + iVar5;\n                if ((puVar7[-1] & 0x20) != 0) {\n                    var_18h = 0;\n                    iVar6 = iVar6 + in_ECX[0x2b];\n                    if ((uVar1 & 1) != 0) {\n                        iVar6 = iVar6 + arg_ch;\n                    }\n                }\n            }\n            puVar7 = puVar7 + 0x14;\n            var_4h = var_4h + -1;\n        } while (var_4h != 0);\n    }\n    *arg_8h = var_10h;\n    arg_8h[1] = var_ch;\n    return;\n}\n",
        "token_count": 780
    },
    "00437f0c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_40h\n// WARNING: Variable defined which should be unmapped: var_3ch\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_34h\n\nvoid __cdecl fcn.00437f0c(int32_t *arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t *puVar3;\n    int32_t *piVar4;\n    int32_t *in_ECX;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    int32_t *piVar8;\n    uint *arg_8h_00;\n    int32_t lpRect;\n    int32_t *var_40h;\n    int32_t var_3ch;\n    uint32_t var_38h;\n    uint32_t var_34h;\n    uint32_t var_30h;\n    int32_t lprc;\n    int32_t var_28h;\n    int32_t var_24h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    int32_t *var_ch;\n    int32_t *var_8h;\n    uint *var_4h;\n    \n    puVar7 = NULL;\n    arg_8h_00 = 0x418;\n    var_ch = NULL;\n    var_34h = 0;\n    var_30h = 0;\n    iVar2 = (**(*in_ECX + 0x110))(0x418, 0, 0);\n    var_1ch = iVar2;\n    if ((iVar2 == 0) || (var_ch = fcn.00425ce2(iVar2 * 0x14),  piVar4 = var_ch,  iVar2 < 1)) goto code_r0x004381d9;\n    do {\n        var_8h = piVar4;\n        arg_8h_00 = puVar7;\n        fcn.004373d5();\n        piVar8 = var_ch;\n        var_8h = var_8h + 5;\n        puVar7 = puVar7 + 1;\n        piVar4 = var_8h;\n    } while (puVar7 < iVar2);\n    if (iVar2 < 1) goto code_r0x004381d9;\n    uVar1 = in_ECX[0x1f];\n    if ((uVar1 & 2) == 0) {\n        var_20h = uVar1 & 4;\n        if (var_20h == 0) {\ncode_r0x00437ffe:\n            var_38h = -((arg_ch & 2) != 0) & 0x7fff;\n        }\n        else if ((arg_ch & 4) == 0) {\n            if ((arg_ch & 8) == 0) {\n                var_38h = 0;\n                if ((arg_ch & 0x10) == 0) {\n                    if (arg_10h == -1) {\n                        if ((uVar1 & 1) == 0) goto code_r0x00437ffe;\n                        goto code_r0x00437ff8;\n                    }\n                    (*_sym.imp.USER32.dll_SetRectEmpty)(&fcn.00437f0c::lprc);\n                    (**(*in_ECX + 0x13c))(&fcn.00437f0c::lprc, arg_ch & 2);\n                    var_34h = arg_ch & 0x20;\n                    if (var_34h == 0) {\n                        var_28h = var_24h - lprc;\n                    }\n                    else {\n                        var_28h = var_20h - var_28h;\n                    }\n                    var_38h = var_28h + arg_10h;\n                }\n            }\n            else {\n                var_38h = 0x7fff;\n            }\n        }\n        else {\ncode_r0x00437ff8:\n            var_38h = in_ECX[0x1b];\n        }\n        var_40h = piVar8;\n        lpRect = 0x438017;\n        var_3ch = iVar2;\n        fcn.004379da(piVar8, iVar2, var_38h, var_34h);\n    }\n    arg_8h_00 = &fcn.00437f0c::var_24h;\n    lpRect = iVar2;\n    puVar3 = fcn.004378b8(arg_8h_00, piVar8, iVar2);\n    var_34h = *puVar3;\n    var_30h = puVar3[1];\n    if ((arg_ch & 0x40) != 0) {\n        var_20h = in_ECX[0x27];\n        iVar6 = 0;\n        var_4h = NULL;\n        arg_10h = 0;\n        in_ECX[0x27] = 0;\n        if (0 < iVar2) {\n            var_14h = piVar8 + 1;\n            piVar4 = var_14h;\n            iVar5 = iVar2;\n            do {\n                if (((*(piVar4 + 5) & 1) != 0) && (*piVar4 != 0)) {\n                    iVar6 = iVar6 + 1;\n                }\n                piVar4 = piVar4 + 5;\n                iVar5 = iVar5 + -1;\n            } while (iVar5 != 0);\n            arg_10h = iVar6;\n            if (0 < iVar6) {\n                puVar7 = fcn.00425ce2(iVar6 * 0x18);\n                if (puVar7 == NULL) {\n                    var_4h = NULL;\n                }\n                else {\n                    arg_8h_00 = puVar7;\n                    fcn.00437579(puVar7, 0x18, iVar6, 0x437b66);\n                    var_4h = puVar7;\n                }\n                arg_10h = 0;\n                var_8h = NULL;\n                var_10h = var_4h + 2;\n                piVar4 = var_10h;\n                do {\n                    piVar8 = piVar4;\n                    if (((*(var_14h + 5) & 1) != 0) && (*var_14h != 0)) {\n                        piVar4[-2] = var_8h;\n                        piVar4[-1] = *var_14h;\n                        (**(*in_ECX + 0x16c))(var_8h, &fcn.00437f0c::lpRect);\n                        arg_8h_00 = &fcn.00437f0c::lpRect;\n                        fcn.00431e21(arg_8h_00);\n                        arg_10h = arg_10h + 1;\n                        piVar8 = var_10h + 6;\n                        *piVar4 = lpRect;\n                        piVar4[1] = var_40h;\n                        piVar4[2] = var_3ch;\n                        piVar4[3] = var_38h;\n                        iVar2 = var_1ch;\n                        var_10h = piVar8;\n                    }\n                    var_8h = var_8h + 1;\n                    var_14h = var_14h + 5;\n                    piVar4 = piVar8;\n                } while (var_8h < iVar2);\n            }\n        }\n        if (((in_ECX[0x1f] & 1U) != 0) && ((in_ECX[0x1f] & 4U) != 0)) {\n            in_ECX[0x1b] = var_34h;\n        }\n        puVar7 = NULL;\n        if (0 < iVar2) {\n            var_10h = var_ch;\n            do {\n                arg_8h_00 = puVar7;\n                fcn.004376de(puVar7, var_10h);\n                var_10h = var_10h + 5;\n                puVar7 = puVar7 + 1;\n            } while (puVar7 < iVar2);\n        }\n        if (0 < arg_10h) {\n            piVar4 = var_4h + 2;\n            do {\n                arg_8h_00 = piVar4[-1];\n                var_1ch = fcn.0042a05b();\n                if (var_1ch != 0) {\n                    (*_sym.imp.USER32.dll_GetWindowRect)(*(var_1ch + 0x1c), &fcn.00437f0c::lpRect);\n                    iVar2 = lpRect - *piVar4;\n                    var_14h = var_40h - piVar4[1];\n                    (**(*in_ECX + 0x16c))(piVar4[-2], &fcn.00437f0c::lpRect);\n                    arg_8h_00 = NULL;\n                    fcn.0042a4e3(0, lpRect + iVar2, var_14h + var_40h, 0, 0, 0x15);\n                }\n                piVar4 = piVar4 + 6;\n                arg_10h = arg_10h + -1;\n            } while (arg_10h != 0);\n            fcn.00425d0d(var_4h, arg_8h_00);\n        }\n        in_ECX[0x27] = var_20h;\n        piVar8 = var_ch;\n    }\n    fcn.00425d0d(piVar8);\ncode_r0x004381d9:\n    (*_sym.imp.USER32.dll_SetRectEmpty)(&fcn.00437f0c::lpRect, arg_8h_00);\n    (**(*in_ECX + 0x13c))(&fcn.00437f0c::lpRect, arg_ch & 2);\n    var_30h = var_40h + (var_30h - var_38h);\n    var_34h = var_34h + (lpRect - var_3ch);\n    fcn.00438909(&fcn.00437f0c::var_24h, arg_ch & 1, arg_ch & 2);\n    if (var_34h <= var_24h) {\n        var_34h = var_24h;\n    }\n    if (var_30h <= var_20h) {\n        var_30h = var_20h;\n    }\n    *arg_8h = var_34h;\n    arg_8h[1] = var_30h;\n    return;\n}\n",
        "token_count": 2401
    },
    "004384ed": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_24h\n\nvoid __cdecl fcn.004384ed(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    iVar2 = *(extraout_ECX + 0xb0);\n    *(unaff_EBP + -0x10) = *0x496830;\n    if (iVar2 == 0) {\ncode_r0x00438572:\n        fcn.004042f6();\n    }\n    else {\n        fcn.004373d5(*(unaff_EBP + 8), unaff_EBP + -0x24);\n        *(unaff_EBP + -0x28) = -(*(*(extraout_ECX + 0xb0) + 0xc) != 0);\n        piVar1 = fcn.0042c770();\n        iVar2 = (**(*piVar1 + 0xc))();\n        *(unaff_EBP + 8) = iVar2 + 0x10;\n        *(unaff_EBP + -4) = 0;\n        do {\n            if (*(unaff_EBP + -0x28) == 0) {\n                fcn.00403164();\n                goto code_r0x00438572;\n            }\n            fcn.004257e2();\n        } while (*(unaff_EBP + -0x2c) != *(unaff_EBP + -0x14));\n        fcn.004048c5();\n        fcn.00403164();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 466
    },
    "00438697": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00438697(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    \n    if ((*(param_1 + 0x1c) != 0) && (iVar1 = fcn.00441d18(),  iVar1 != 0)) {\n        piVar2 = fcn.00441d04();\n    // WARNING: Could not recover jumptable at 0x004386b5. Too many branches\n    // WARNING: Treating indirect jump as call\n        uVar3 = (**(*piVar2 + 0x60))();\n        return uVar3;\n    }\n    uVar3 = 0;\n    if (*(param_1 + 0x1c) == 0) {\n        if (*(param_1 + 0x4c) == 0) {\n            return 0;\n        }\n    }\n    else {\n        fcn.00427862(0);\n        fcn.00425996(*(param_1 + 0x1c));\n    }\n    if ((*(param_1 + 0x1c) != 0) || (*(param_1 + 0x4c) != 0)) {\n        if (*(param_1 + 0x4c) == 0) {\n            uVar3 = (*_sym.imp.USER32.dll_DestroyWindow)(*(param_1 + 0x1c));\n        }\n        else {\n            uVar3 = (**(**(param_1 + 0x4c) + 0x58))();\n        }\n    }\n    return uVar3;\n}\n",
        "token_count": 358
    },
    "004387e1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004387e1(int32_t param_1, int32_t *param_2, int32_t param_3)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *(param_1 + 0x7c);\n    if ((uVar1 & 0x100) != 0) {\n        *param_2 = *param_2 + *0x4995c8;\n    }\n    if ((uVar1 & 0x200) != 0) {\n        param_2[1] = param_2[1] + *0x4995cc;\n    }\n    if ((uVar1 & 0x400) != 0) {\n        param_2[2] = param_2[2] - *0x4995c8;\n    }\n    if ((uVar1 & 0x800) != 0) {\n        param_2[3] = param_2[3] - *0x4995cc;\n    }\n    if (param_3 == 0) {\n        *param_2 = *param_2 + *(param_1 + 0x60);\n        param_2[1] = param_2[1] + *(param_1 + 0x58);\n        param_2[2] = param_2[2] - *(param_1 + 100);\n        param_2[3] = param_2[3] - *(param_1 + 0x5c);\n        if ((*(param_1 + 0x7c) & 0x400001) == 0x400000) {\n            param_2[1] = param_2[1] + 7;\n        }\n    }\n    else {\n        *param_2 = *param_2 + *(param_1 + 0x58);\n        param_2[1] = param_2[1] + *(param_1 + 0x60);\n        param_2[2] = param_2[2] - *(param_1 + 0x5c);\n        param_2[3] = param_2[3] - *(param_1 + 100);\n        if ((*(param_1 + 0x7c) & 0x400001) == 0x400000) {\n            *param_2 = *param_2 + 7;\n        }\n    }\n    return;\n}\n",
        "token_count": 528
    },
    "00438971": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00438971(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t *piVar7;\n    int32_t *in_ECX;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(1);\n    if (iVar2 < 0) {\n        return;\n    }\n    iVar3 = fcn.0044be36();\n    var_8h = iVar3;\n    (*_sym.imp.USER32.dll_GetCursorPos)(&var_10h);\n    (*_sym.imp.USER32.dll_ScreenToClient)(in_ECX[7], &var_10h);\n    var_4h = (**(*in_ECX + 0x6c))(var_10h, var_ch, 0);\n    if (var_4h < 0) {\n        *(iVar3 + 0x78) = 0xffffffff;\n    }\n    else {\n        iVar4 = fcn.00428b49();\n        iVar5 = fcn.00428b71();\n        if ((iVar5 == 0) || (iVar5 = fcn.0042a30b(),  iVar5 == 0)) {\n            var_4h = -1;\n        }\n        if (*(iVar3 + 0x3c) == 0) {\n            iVar3 = 0;\n        }\n        else {\n            iVar3 = *(*(iVar3 + 0x3c) + 0x1c);\n        }\n        uVar6 = (*_sym.imp.USER32.dll_GetCapture)();\n        piVar7 = fcn.004278de(uVar6);\n        if (piVar7 != in_ECX) {\n            if (piVar7 == NULL) {\n                iVar5 = 0;\n            }\n            else {\n                iVar5 = piVar7[7];\n            }\n            if ((iVar5 != iVar3) && (iVar3 = fcn.00428b49(),  iVar3 == iVar4)) {\n                var_4h = -1;\n            }\n        }\n    }\n    pcVar1 = _sym.imp.USER32.dll_KillTimer;\n    if (-1 < var_4h) {\n        (*_sym.imp.USER32.dll_ClientToScreen)(in_ECX[7], &var_10h);\n        iVar3 = (*_sym.imp.USER32.dll_WindowFromPoint)(var_10h, var_ch);\n        if (iVar3 == 0) {\ncode_r0x00438a78:\n            var_4h = -1;\n            *(var_8h + 0x78) = 0xffffffff;\n        }\n        else if ((iVar3 != in_ECX[7]) && (iVar4 = (*_sym.imp.USER32.dll_IsChild)(in_ECX[7], iVar3),  iVar4 == 0)) {\n            iVar4 = *(var_8h + 0x3c);\n            if (iVar4 != 0) {\n                iVar4 = *(iVar4 + 0x1c);\n            }\n            if (iVar4 != iVar3) goto code_r0x00438a78;\n        }\n        if (-1 < var_4h) goto code_r0x00438aa8;\n    }\n    if (*(var_8h + 0x78) == -1) {\n        (*pcVar1)(in_ECX[7], 0xe001);\n    }\n    (**(*in_ECX + 0x160))(0xffffffff);\ncode_r0x00438aa8:\n    if ((arg_8h == 0xe000) && ((*pcVar1)(in_ECX[7], 0xe000),  -1 < var_4h)) {\n        (**(*in_ECX + 0x160))(var_4h);\n    }\n    return;\n}\n",
        "token_count": 880
    },
    "00438dc2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00438dc2(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if ((in_ECX[0x22] != 0) && (iVar1 = (**(*in_ECX + 0x6c))(arg_ch, arg_10h, 0),  iVar1 == -1)) {\n        (*_sym.imp.USER32.dll_ClientToScreen)(in_ECX[7], &arg_ch);\n        (***in_ECX[0x23])(arg_ch, arg_10h);\n        return;\n    }\n    fcn.0042783b();\n    return;\n}\n",
        "token_count": 155
    },
    "00438e46": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00438e46(uint noname_0, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t *in_ECX;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    bool bVar5;\n    int32_t lprcDst;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    uVar1 = (**(*in_ECX + 0x154))(arg_ch);\n    if (((uVar1 & 0x10000000) != 0) && ((uVar1 & 0xf000) != 0)) {\n        (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, arg_ch + 1);\n        iVar4 = var_14h - lprcDst;\n        iVar3 = var_10h - var_18h;\n        bVar5 = arg_ch[7] != 0;\n        if (((var_4h[0x1f] & 4U) == 0) || ((var_4h[0x1f] & 1U) == 0)) {\n            if ((uVar1 & 0xa000) == 0) {\n                uVar2 = bVar5 | 0x10;\n            }\n            else {\n                uVar2 = bVar5 | 10;\n            }\n        }\n        else {\n            uVar2 = bVar5 | 6;\n        }\n        (**(*var_4h + 0x134))(&var_ch, 0xffffffff, uVar2);\n        if (iVar4 <= var_ch) {\n            var_ch = iVar4;\n        }\n        if (iVar3 <= var_8h) {\n            var_8h = iVar3;\n        }\n        if ((uVar1 & 0xa000) == 0) {\n            if ((uVar1 & 0x5000) != 0) {\n                arg_ch[5] = arg_ch[5] + var_ch;\n                iVar3 = arg_ch[6];\n                if (arg_ch[6] <= var_8h) {\n                    iVar3 = var_8h;\n                }\n                arg_ch[6] = iVar3;\n                if ((uVar1 & 0x1000) == 0) {\n                    if ((uVar1 & 0x4000) != 0) {\n                        lprcDst = var_14h - var_ch;\n                        arg_ch[3] = arg_ch[3] - var_ch;\n                    }\n                }\n                else {\n                    arg_ch[1] = arg_ch[1] + var_ch;\n                }\n            }\n        }\n        else {\n            arg_ch[6] = arg_ch[6] + var_8h;\n            iVar3 = arg_ch[5];\n            if (arg_ch[5] <= var_ch) {\n                iVar3 = var_ch;\n            }\n            arg_ch[5] = iVar3;\n            if ((uVar1 & 0x2000) == 0) {\n                if ((uVar1 & 0x8000) != 0) {\n                    var_18h = var_10h - var_8h;\n                    arg_ch[4] = arg_ch[4] - var_8h;\n                }\n            }\n            else {\n                arg_ch[2] = arg_ch[2] + var_8h;\n            }\n        }\n        var_14h = var_ch + lprcDst;\n        var_10h = var_18h + var_8h;\n        if (*arg_ch != 0) {\n            fcn.0042619c(arg_ch, var_4h[7], &lprcDst);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 867
    },
    "004396d4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004396d4(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(extraout_ECX + 0x80) = *(unaff_EBP + 8);\n    if (*(extraout_ECX + 0x8c) == 0) {\n        iVar1 = fcn.00425ce2(0xb0);\n        *(unaff_EBP + 8) = iVar1;\n        *(unaff_EBP + -4) = 0;\n        if (iVar1 == 0) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = fcn.0043f483(extraout_ECX);\n        }\n        *(extraout_ECX + 0x8c) = uVar2;\n    }\n    if (*(extraout_ECX + 0x34) == 0) {\n        uVar2 = (*_sym.imp.USER32.dll_GetParent)(*(extraout_ECX + 0x1c));\n        *(extraout_ECX + 0x34) = uVar2;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 325
    },
    "00439ac2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00439ac2(uint32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    \n    if (arg_8h == 2) {\n        fcn.00428b9d();\n        if ((*(in_ECX + 0x15c) & 0x40) == 0) {\n            iVar2 = 1;\n            iVar1 = 0;\n            do {\n                if (*(in_ECX + 0x17c) <= iVar2) break;\n                iVar1 = fcn.0043994f();\n                iVar2 = iVar2 + 1;\n            } while (iVar1 == 0);\n            (****(iVar1 + 0x8c))(arg_ch, arg_10h);\n            return;\n        }\n    }\n    else if ((9 < arg_8h) && (arg_8h < 0x12)) {\n        fcn.00428b9d();\n        iVar2 = 1;\n        iVar1 = 0;\n        do {\n            if (*(in_ECX + 0x17c) <= iVar2) break;\n            iVar1 = fcn.0043994f();\n            iVar2 = iVar2 + 1;\n        } while (iVar1 == 0);\n        (**(**(iVar1 + 0x8c) + 4))(arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    fcn.0042783b();\n    return;\n}\n",
        "token_count": 346
    },
    "00439c8f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00439c8f(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    if (0xffff < param_1) {\n        param_1 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(param_1 + 0x1c));\n        param_1 = param_1 & 0xffff;\n    }\n    iVar1 = fcn.00439912(param_1, 0xffffffff);\n    if (0 < iVar1) {\n        fcn.00424cc7(iVar1, 1);\n        piVar2 = fcn.00405ce7(iVar1 + -1);\n        if (*piVar2 == 0) {\n            piVar2 = fcn.00405ce7(iVar1);\n            if (*piVar2 == 0) {\n                fcn.00424cc7(iVar1, 1);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 213
    },
    "00439cf6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00439cf6(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint32_t *puVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t *in_ECX;\n    \n    iVar4 = arg_8h;\n    iVar1 = fcn.00439912(arg_8h, arg_ch);\n    if (arg_10h == 1) {\n        puVar2 = fcn.00405ce7(iVar1);\n        uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_8h + 0x1c));\n        *puVar2 = uVar3 & 0xffff;\n        fcn.00405ce7(iVar1);\n        iVar4 = fcn.00439912(iVar4, iVar1);\n        if (0 < iVar4) {\n            fcn.00424cc7(iVar1, 1);\n            piVar5 = fcn.00405ce7();\n            if ((*piVar5 == 0) && (piVar5 = fcn.00405ce7(),  *piVar5 == 0)) {\n                fcn.00424cc7(iVar1, 1);\n            }\n        }\n    }\n    else {\n        fcn.00424cc7(iVar1, 1);\n        piVar5 = fcn.00405ce7(iVar1 + -1);\n        if ((*piVar5 == 0) && (piVar5 = fcn.00405ce7(iVar1),  *piVar5 == 0)) {\n            fcn.00424cc7(iVar1, 1);\n        }\n        if (arg_10h != -1) {\n            fcn.00439c8f(arg_8h);\n        }\n    }\n    if (*(arg_8h + 0x8c) != 0) {\n        piVar5 = fcn.00441d04();\n        if ((in_ECX[0x24] == 0) || (iVar4 = (**(*in_ECX + 0x168))(),  iVar4 != 0)) {\n            piVar5[0x33] = piVar5[0x33] | 0xc;\n        }\n        else {\n            iVar4 = fcn.00439c27();\n            if (iVar4 == 0) {\n                (**(*piVar5 + 0x60))();\n                return 1;\n            }\n            fcn.0042a2ea(0);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 586
    },
    "0043a5d1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043a5d1(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    ushort uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t *piVar4;\n    uint uFlags;\n    uchar auStack300 [16];\n    int32_t iStack284;\n    int32_t iStack280;\n    int32_t iStack276;\n    int32_t iStack272;\n    uchar auStack268 [260];\n    uint uStack8;\n    \n    uStack8 = *0x496830;\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(param_2 + 0x1c), auStack300);\n    if (*(param_2 + 0x88) == param_1) {\n        if (param_3 == 0) goto code_r0x0043a7da;\n        iVar2 = (*_sym.imp.USER32.dll_EqualRect)(auStack300, param_3);\n        if (iVar2 != 0) goto code_r0x0043a7da;\n    }\n    if ((*(param_1 + 0x90) != 0) && ((*(param_2 + 0x80) & 0x40) != 0)) {\n        *(param_1 + 0x7c) = *(param_1 + 0x7c) | 0x40;\n    }\n    *(param_1 + 0x7c) = *(param_1 + 0x7c) & 0xfffffff9;\n    uVar3 = *(param_1 + 0x7c);\n    *(param_1 + 0x7c) = *(param_2 + 0x7c) & 6 | uVar3;\n    if ((uVar3 & 0x40) == 0) {\n        fcn.0042a944(auStack268, 0x104);\n        fcn.00436750(*(param_1 + 0x1c), auStack268);\n    }\n    uVar3 = (*(param_2 + 0x7c) ^ *(param_1 + 0x7c)) & 0xf000 ^ *(param_2 + 0x7c);\n    if (*(param_1 + 0x90) == 0) {\n        uVar3 = uVar3 & 0xfffffffe | 0xf00;\n    }\n    else {\n        uVar3 = uVar3 | 0xf01;\n    }\n    fcn.00449d00(uVar3);\n    uVar1 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(param_2 + 0x1c), 0xffffffff);\n    iVar2 = fcn.00439912(uVar1);\n    if (0 < iVar2) {\n        piVar4 = fcn.00405ce7(iVar2);\n        *piVar4 = param_2;\n    }\n    if (param_3 == 0) {\n        if (iVar2 < 1) {\n            fcn.00424c05(*(param_1 + 0x9c), param_2);\n            fcn.00424c05(*(param_1 + 0x9c), 0);\n        }\n        uFlags = 0x115;\n        iStack272 = 0;\n        iStack276 = 0;\n        iStack280 = -*0x4995cc;\n        iStack284 = -*0x4995c8;\n    }\n    else {\n        (*_sym.imp.USER32.dll_CopyRect)(&iStack284, param_3);\n        fcn.00431de5();\n        if (iVar2 < 1) {\n            fcn.0043996e(param_2, iStack284, iStack280, iStack276, iStack272, (iStack276 - iStack284) / 2 + iStack284, \n                         (iStack272 - iStack280) / 2 + iStack280);\n        }\n        iStack272 = iStack272 - iStack280;\n        uFlags = 0x114;\n        iStack276 = iStack276 - iStack284;\n    }\n    fcn.0042a4e3(0, iStack284, iStack280, iStack276, iStack272, uFlags);\n    (*_sym.imp.USER32.dll_GetParent)(*(param_2 + 0x1c));\n    iVar2 = fcn.004278de();\n    if (iVar2 != param_1) {\n        fcn.00405d63(param_1);\n    }\n    if (*(param_2 + 0x88) != 0) {\n        fcn.00439cf6(param_2, 0xffffffff, 0);\n    }\n    *(param_2 + 0x88) = param_1;\n    iVar2 = fcn.00441d04();\n    *(iVar2 + 0xcc) = *(iVar2 + 0xcc) | 0xc;\ncode_r0x0043a7da:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 1123
    },
    "0043ad35": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch_2\n\nuint __cdecl fcn.0043ad35(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint uVar4;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h_2;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.0040e188();\n    iVar1 = extraout_ECX[0x1d] + *(unaff_EBP + 8) * 0x14;\n    uVar2 = *(iVar1 + 0xc);\n    *(unaff_EBP + -0x10) = &stack0xffffffec;\n    if ((uVar2 & 1) == 0) {\n        if (*(unaff_EBP + 0xc) == 0) {\n            iVar3 = *(*(iVar1 + 0x10) + -0xc);\n        }\n        else {\n            iVar3 = fcn.0040efa3(*(iVar1 + 0x10), *(unaff_EBP + 0xc));\n        }\n        if (iVar3 == 0) goto code_r0x0043adde;\n    }\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + 0xc) == 0) {\n        fcn.004042f6();\n    }\n    else {\n        fcn.004045a1(*(unaff_EBP + 0xc));\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + 0x10) == 0) {\n        *(iVar1 + 0xc) = *(iVar1 + 0xc) | 1;\n    }\n    else {\n        *(iVar1 + 0xc) = *(iVar1 + 0xc) & 0xfffffffe;\n        if ((*(iVar1 + 0xb) & 4) == 0) {\n            uVar4 = *(iVar1 + 0x10);\n        }\n        else {\n            uVar4 = 0;\n        }\n        (**(*extraout_ECX + 0x110))(0x401, *(iVar1 + 8) | *(unaff_EBP + 8), uVar4);\n    }\ncode_r0x0043adde:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return 1;\n}\n",
        "token_count": 610
    },
    "0043ae80": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043ae80(int32_t arg_8h, uint arg_ch, uint32_t arg_10h, int32_t arg_14h)\n\n{\n    uint *puVar1;\n    int32_t in_ECX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    bool bVar2;\n    uint unaff_retaddr;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint in_stack_00000020;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint in_stack_0000002c;\n    uint in_stack_00000030;\n    uint in_stack_00000034;\n    int32_t in_stack_ffffffe0;\n    uint in_stack_ffffffe4;\n    uint in_stack_ffffffe8;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    puVar1 = *(in_ECX + 0x74) + arg_8h * 0x14;\n    *puVar1 = arg_ch;\n    if (puVar1[2] != arg_10h) {\n        bVar2 = ((puVar1[2] ^ arg_10h) & 0x8000000) == 0;\n        if (bVar2) {\n            puVar1[3] = puVar1[3] | 1;\n            in_stack_ffffffe8 = 1;\n            in_stack_ffffffe4 = puVar1[4];\n            puVar1[2] = arg_10h;\n            in_stack_ffffffe0 = arg_8h;\n            fcn.0043ad35(arg_8h, in_stack_ffffffe4, 1, unaff_EDI, unaff_ESI, unaff_EBX);\n        }\n        var_4h = !bVar2;\n        puVar1[2] = arg_10h;\n    }\n    if (arg_14h != puVar1[1]) {\n        puVar1[1] = arg_14h;\n        var_4h = 1;\n    }\n    if (var_4h != 0) {\n        fcn.0044a03d(1, 0, in_stack_ffffffe0, in_stack_ffffffe4, in_stack_ffffffe8, unaff_EDI, unaff_ESI, unaff_EBX, \n                     var_4h, unaff_EBP, unaff_retaddr, arg_8h, arg_ch, arg_10h, arg_14h, in_stack_00000014, \n                     in_stack_00000018, in_stack_0000001c, in_stack_00000020, in_stack_00000024, in_stack_00000028, \n                     in_stack_0000002c, in_stack_00000030, in_stack_00000034);\n    }\n    return;\n}\n",
        "token_count": 679
    },
    "0043af8c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0043af8c(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    iVar1 = arg_8h;\n    fcn.0042a07f(arg_8h, &arg_8h);\n    if (arg_8h == 0) {\n        iVar2 = fcn.00429ffe(iVar1);\n        if (iVar2 == 0) {\n            fcn.00420313();\n        }\n    }\n    *(in_ECX + 0xc) = 0;\n    *(in_ECX + 8) = iVar1;\n    return arg_8h;\n}\n",
        "token_count": 158
    },
    "0043afcb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043afcb(int32_t *param_1)\n\n{\n    int32_t *hWnd;\n    \n    hWnd = param_1;\n    if ((*param_1 != 0) && (param_1[2] != 0)) {\n        fcn.0042a07f(param_1[2], &hWnd);\n        if (hWnd != NULL) {\n            (*_sym.imp.USER32.dll_SetFocus)(hWnd);\n            if (param_1[3] != 0) {\n                (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0xb1, 0, 0xffffffff);\n            }\n        }\n    }\n    fcn.00431a36();\n    return;\n}\n",
        "token_count": 161
    },
    "0043b01a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b01a(int32_t *arg_8h, uint arg_ch, int32_t *arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = arg_8h;\n    fcn.0043af8c(arg_ch);\n    fcn.0042a07f(arg_ch, &arg_8h);\n    if (*piVar1 == 0) {\n        if ((*arg_10h < 0) || (2 < *arg_10h)) {\n            *arg_10h = 0;\n        }\n        (*_sym.imp.USER32.dll_SendMessageA)(arg_8h, 0xf1, *arg_10h, 0);\n    }\n    else {\n        iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(arg_8h, 0xf0, 0, 0);\n        *arg_10h = iVar2;\n    }\n    return;\n}\n",
        "token_count": 220
    },
    "0043b1d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b1d0(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    \n    piVar1 = arg_8h;\n    fcn.0043af8c(arg_ch);\n    fcn.0042a07f(arg_ch, &arg_8h);\n    if (*piVar1 == 0) {\n        (*_sym.imp.USER32.dll_SetScrollPos)(arg_8h, 2, *arg_10h, 1);\n    }\n    else {\n        uVar2 = (*_sym.imp.USER32.dll_GetScrollPos)(arg_8h, 2);\n        *arg_10h = uVar2;\n    }\n    return;\n}\n",
        "token_count": 176
    },
    "0043b2bf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b2bf(int32_t *arg_8h, uint32_t arg_ch, uint32_t arg_10h, uint32_t arg_14h)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    uVar3 = arg_14h;\n    uVar2 = arg_10h;\n    if ((*arg_8h != 0) || ((arg_10h <= arg_ch && (arg_ch <= arg_14h)))) {\n        fcn.0042a07f(arg_8h[2], &arg_ch);\n        pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n        (*_sym.imp.USER32.dll_SendMessageA)(arg_ch, 0x407, 0, uVar2);\n        (*pcVar1)(arg_ch, 0x407, 1, uVar3);\n    }\n    return;\n}\n",
        "token_count": 208
    },
    "0043b310": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b310(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = arg_10h;\n    if (*(arg_10h + 0x1c) != 0) {\n        return;\n    }\n    iVar1 = fcn.00429fdc();\n    if (iVar1 != 0) {\n        return;\n    }\n    fcn.0043af8c(arg_ch);\n    fcn.0042a07f(arg_ch, &arg_10h);\n    if (arg_10h != 0) {\n        iVar1 = fcn.004287f6(arg_10h);\n        if (iVar1 == 0) {\n            fcn.00420313();\n        }\n        if (arg_10h != 0) {\n            iVar1 = *(arg_8h + 4);\n            iVar2 = (*_sym.imp.USER32.dll_GetParent)(*(iVar2 + 0x1c));\n            if (*(iVar1 + 0x1c) == iVar2) {\n                return;\n            }\n            arg_ch = 0;\n            goto code_r0x0043b38b;\n        }\n    }\n    iVar2 = fcn.00429ffe(arg_ch);\n    if (iVar2 == 0) {\n        return;\n    }\n    iVar1 = *(arg_8h + 4);\ncode_r0x0043b38b:\n    fcn.0042a40f(iVar1, arg_ch);\n    return;\n}\n",
        "token_count": 349
    },
    "0043b3b0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b3b0(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    uint arg_10h_00;\n    uint hWnd;\n    int32_t iVar1;\n    uint lpString;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    hWnd = fcn.0043b399(arg_ch);\n    arg_10h_00 = arg_18h;\n    if (*arg_8h == 0) {\n        fcn.0040f19f(&lpString, arg_10h, &arg_18h);\n        fcn.00436750(hWnd, &lpString);\n    }\n    else {\n        (*_sym.imp.USER32.dll_GetWindowTextA)(hWnd, &lpString, 0x40);\n        iVar1 = fcn.0040f226(&lpString, arg_10h, arg_10h_00);\n        if (iVar1 != 1) {\n            fcn.0043c086(arg_14h, 0, 0xffffffff);\n            fcn.0043afcb();\n        }\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 278
    },
    "0043b439": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b439(int32_t *arg_8h, uint arg_ch, uint8_t *arg_10h)\n\n{\n    uint8_t *puVar1;\n    \n    puVar1 = arg_10h;\n    arg_10h = *arg_10h;\n    if (*arg_8h == 0) {\n        fcn.0043b3b0(arg_8h, arg_ch, 0x46be3c, 0xf116, arg_10h);\n    }\n    else {\n        fcn.0043b3b0(arg_8h, arg_ch, 0x46be3c, 0xf116, &arg_10h);\n        if (0xff < arg_10h) {\n            fcn.0043c086(0xf116, 0, 0xffffffff);\n            fcn.0043afcb();\n        }\n        *puVar1 = arg_10h;\n    }\n    return;\n}\n",
        "token_count": 216
    },
    "0043b4aa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b4aa(int32_t *arg_8h, uint arg_ch, int16_t *arg_10h)\n\n{\n    if (*arg_8h == 0) {\n        arg_10h = *arg_10h;\n    }\n    fcn.0043b3b0(arg_8h, arg_ch, 0x46be40, 0xf110, arg_10h);\n    return;\n}\n",
        "token_count": 100
    },
    "0043b4db": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b4db(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    if (*arg_8h == 0) {\n        arg_10h = *arg_10h;\n    }\n    fcn.0043b3b0(arg_8h, arg_ch, 0x46be44, 0xf110, arg_10h);\n    return;\n}\n",
        "token_count": 98
    },
    "0043b50a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b50a(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    if (*arg_8h == 0) {\n        arg_10h = *arg_10h;\n    }\n    fcn.0043b3b0(arg_8h, arg_ch, 0x46be3c, 0xf117, arg_10h);\n    return;\n}\n",
        "token_count": 99
    },
    "0043b539": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b539(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    if (*arg_8h == 0) {\n        arg_10h = *arg_10h;\n    }\n    fcn.0043b3b0(arg_8h, arg_ch, 0x46be48, 0xf110, arg_10h);\n    return;\n}\n",
        "token_count": 97
    },
    "0043b568": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b568(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    if (*arg_8h == 0) {\n        arg_10h = *arg_10h;\n    }\n    fcn.0043b3b0(arg_8h, arg_ch, 0x46be4c, 0xf117, arg_10h);\n    return;\n}\n",
        "token_count": 98
    },
    "0043b597": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b597(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    if (*arg_8h == 0) {\n        fcn.0043b3b0(arg_8h, arg_ch, \"%I64d\", 0xf110, *arg_10h);\n    }\n    else {\n        fcn.0043b3b0(arg_8h, arg_ch, \"%I64d\", 0xf110, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 122
    },
    "0043b5df": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b5df(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    if (*arg_8h == 0) {\n        fcn.0043b3b0(arg_8h, arg_ch, \"%I64u\", 0xf117, *arg_10h);\n    }\n    else {\n        fcn.0043b3b0(arg_8h, arg_ch, \"%I64u\", 0xf117, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 123
    },
    "0043b627": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b627(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint hWnd;\n    \n    hWnd = fcn.0043b399(arg_ch);\n    if (*arg_8h == 0) {\n        fcn.00436750(hWnd, arg_10h);\n    }\n    else {\n        (*_sym.imp.USER32.dll_GetWindowTextLengthA)(hWnd);\n        (*_sym.imp.USER32.dll_GetWindowTextA)(hWnd, arg_10h, arg_14h);\n    }\n    return;\n}\n",
        "token_count": 133
    },
    "0043b665": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_90h\n\nvoid __cdecl\nfcn.0043b665(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_90h;\n    uint var_50h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    iVar2 = **(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = *0x496830;\n    if (iVar2 != 0) {\n        fcn.0040f037(unaff_EBP + -0x90, *(unaff_EBP + 0x1c), *(unaff_EBP + 0xc));\n        fcn.0040f037(unaff_EBP + -0x50, *(unaff_EBP + 0x1c), *(unaff_EBP + 0x14));\n        piVar1 = fcn.0042c770();\n        iVar2 = (**(*piVar1 + 0xc))();\n        *(unaff_EBP + 8) = iVar2 + 0x10;\n        *(unaff_EBP + -4) = 0;\n        fcn.0044028c(unaff_EBP + 8, *(unaff_EBP + 0x20), unaff_EBP + -0x90, unaff_EBP + -0x50);\n        fcn.0043c064(*(unaff_EBP + 8), 0x30, *(unaff_EBP + 0x20));\n        fcn.004042f6();\n        fcn.0043afcb();\n        fcn.00403164();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 466
    },
    "0043ba9c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043ba9c(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    uint hWnd;\n    int32_t iVar1;\n    uint uVar2;\n    \n    hWnd = fcn.0043b399(arg_ch);\n    if (*arg_8h == 0) {\n        fcn.00436750(hWnd, *arg_10h);\n    }\n    else {\n        iVar1 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)(hWnd);\n        uVar2 = fcn.00405a86(iVar1, iVar1 + 1);\n        (*_sym.imp.USER32.dll_GetWindowTextA)(hWnd, uVar2);\n        fcn.00404cad(0xffffffff);\n    }\n    return;\n}\n",
        "token_count": 173
    },
    "0043baee": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043baee(int32_t *hWnd, uint arg_ch, uint *lParam)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    \n    piVar2 = hWnd;\n    fcn.0043af8c(arg_ch);\n    fcn.0042a07f(arg_ch, &hWnd);\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if (*piVar2 == 0) {\n        (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0x18c, 0xffffffff, *lParam);\n    }\n    else {\n        iVar3 = (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0x188, 0, 0);\n        if (iVar3 == -1) {\n            fcn.004042f6();\n        }\n        else {\n            uVar4 = (*pcVar1)(hWnd, 0x18a, iVar3, 0);\n            uVar4 = fcn.00405a86(uVar4);\n            (*pcVar1)(hWnd, 0x189, iVar3, uVar4);\n        }\n        fcn.00404cad(0xffffffff);\n    }\n    return;\n}\n",
        "token_count": 287
    },
    "0043bb82": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043bb82(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    code *pcVar1;\n    int32_t *hWnd;\n    int32_t iVar2;\n    \n    hWnd = arg_8h;\n    fcn.0043af8c(arg_ch);\n    fcn.0042a07f(arg_ch, &arg_8h);\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if (*hWnd == 0) {\n        iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(arg_8h, 0x1a2, 0xffffffff, *arg_10h);\n        if (-1 < iVar2) {\n            (*pcVar1)(arg_8h, 0x186, iVar2, 0);\n        }\n    }\n    else {\n        fcn.0043baee(hWnd, arg_ch, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 217
    },
    "0043bbe2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043bbe2(int32_t *hWnd, uint arg_ch, uint *lParam)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint uVar4;\n    \n    piVar1 = hWnd;\n    fcn.0043af8c(arg_ch);\n    fcn.0042a07f(arg_ch, &hWnd);\n    puVar2 = lParam;\n    if (*piVar1 == 0) {\n        iVar3 = (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0x14d, 0xffffffff, *lParam);\n        if (iVar3 == -1) {\n            fcn.00436750(hWnd, *puVar2);\n        }\n    }\n    else {\n        iVar3 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)(hWnd);\n        if (iVar3 < 1) {\n            uVar4 = fcn.004043ec(0xff, 0x100);\n        }\n        else {\n            uVar4 = fcn.00405a86(iVar3, iVar3 + 1);\n        }\n        (*_sym.imp.USER32.dll_GetWindowTextA)(hWnd, uVar4);\n        fcn.00404cad(0xffffffff);\n    }\n    return;\n}\n",
        "token_count": 288
    },
    "0043bc74": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043bc74(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    code *pcVar1;\n    int32_t *hWnd;\n    uint *puVar2;\n    int32_t iVar3;\n    \n    hWnd = arg_8h;\n    fcn.0043af8c(arg_ch);\n    fcn.0042a07f(arg_ch, &arg_8h);\n    puVar2 = arg_10h;\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if (*hWnd == 0) {\n        iVar3 = (*_sym.imp.USER32.dll_SendMessageA)(arg_8h, 0x158, 0xffffffff, *arg_10h);\n        if (iVar3 < 0) {\n            fcn.00436750(arg_8h, *puVar2);\n        }\n        else {\n            (*pcVar1)(arg_8h, 0x14e, iVar3, 0);\n        }\n    }\n    else {\n        fcn.0043bbe2(hWnd, arg_ch, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 256
    },
    "0043bce2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043bce2(int32_t param_1)\n\n{\n    if (*(param_1 + 0x54) != 0) {\n    // WARNING: Could not recover jumptable at 0x0043bced. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(**(param_1 + 0x54) + 0x34))();\n        return;\n    }\n    return;\n}\n",
        "token_count": 100
    },
    "0043bd05": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0043bd05(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x54) == 0) {\n        return 0;\n    }\n    // WARNING: Could not recover jumptable at 0x0043bd13. Too many branches\n    // WARNING: Treating indirect jump as call\n    uVar1 = (**(**(param_1 + 0x54) + 0x10))();\n    return uVar1;\n}\n",
        "token_count": 115
    },
    "0043bd1e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043bd1e(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    if (*(extraout_ECX + 0x54) == 0) {\n        iVar1 = fcn.00425ce2(0x20);\n        *(unaff_EBP + -0x10) = iVar1;\n        *(unaff_EBP + -4) = 0;\n        if (iVar1 == 0) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = fcn.0044d087();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(extraout_ECX + 0x54) = uVar2;\n    }\n    (**(**(extraout_ECX + 0x54) + 0xc))(*(unaff_EBP + 8));\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 286
    },
    "0043be66": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0043be66(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = fcn.004049c2();\n    if (piVar1 != NULL) {\n        iVar2 = (**(*piVar1 + 0x120))();\n        if ((iVar2 != 0) && (piVar1[0x1f] != 0)) {\n    // WARNING: Could not recover jumptable at 0x0043be8c. Too many branches\n    // WARNING: Treating indirect jump as call\n            (**(*piVar1[0x1f] + 100))();\n            return;\n        }\n    }\n    return;\n}\n",
        "token_count": 156
    },
    "0043c064": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0043bf97)\n// WARNING: Removing unreachable block (ram,0x0043bfe8)\n\nvoid fcn.0043c064(uint param_1, uint32_t param_2, int32_t param_3)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iStack276;\n    int32_t iStack272;\n    uchar auStack268 [259];\n    uchar uStack9;\n    uint uStack8;\n    \n    uStack8 = 0x43c06c;\n    iVar4 = fcn.0044be10();\n    if (*(iVar4 + 4) != NULL) {\n    // WARNING: Could not recover jumptable at 0x0043c078. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(**(iVar4 + 4) + 0x98))();\n        return;\n    }\n    uStack8 = *0x496830;\n    fcn.0043be66(0);\n    iVar4 = fcn.0043be93(0, &stack0xfffffef0);\n    if (iVar4 != iStack272) {\n        (*_sym.imp.USER32.dll_EnableWindow)(iVar4, 1);\n    }\n    if ((iVar4 == 0) || (piVar1 = (*_sym.imp.USER32.dll_SendMessageA)(iVar4, 0x376, 0, 0),  piVar1 == NULL)) {\n        piVar1 = NULL;\n    }\n    iStack276 = 0;\n    if ((piVar1 != NULL) && (iStack276 = *piVar1,  param_3 != 0)) {\n        *piVar1 = param_3 + 0x30000;\n    }\n    if (((param_2 & 0xf0) == 0) && ((uVar2 = param_2 & 0xf,  uVar2 < 2 || ((2 < uVar2 && (uVar2 < 5)))))) {\n        param_2 = param_2 | 0x30;\n    }\n    auStack268[0] = 0;\n    iVar3 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, &stack0xfffffef4, 0x104);\n    if (iVar3 == 0x104) {\n        uStack9 = 0;\n    }\n    (*_sym.imp.USER32.dll_MessageBoxA)(iVar4, param_1, &stack0xfffffef4, param_2);\n    if (piVar1 != NULL) {\n        *piVar1 = iStack276;\n    }\n    if (iStack272 != 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(iStack272, 1);\n    }\n    fcn.0043be66(1);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 652
    },
    "0043c16c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043c16c(int32_t param_1)\n\n{\n    if (*(param_1 + 0x54) != 0) {\n    // WARNING: Could not recover jumptable at 0x0043c177. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(**(param_1 + 0x54) + 0x24))();\n        return;\n    }\n    return;\n}\n",
        "token_count": 100
    },
    "0043c33e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0043c33e(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    if (*(param_1 + 0x84) != 0) {\n        uVar1 = 0x100000;\n    }\n    if (*(param_1 + 0x88) != 0) {\n        uVar1 = uVar1 | 0x200000;\n    }\n    return uVar1;\n}\n",
        "token_count": 110
    },
    "0043d9c6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0043d9c6(uint arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch, \n            int32_t arg_20h)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint lpRect;\n    int32_t lprc1;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (arg_20h != 0) {\n        uVar1 = 1;\n        if ((1 < arg_18h) && (1 < arg_1ch)) {\n            uVar1 = 0;\n        }\n        fcn.0042a1f9((-uVar1 & 0xff800000) + 0x800000, -uVar1 & 0x800000, 0);\n    }\n    var_ch = arg_14h;\n    var_4h = arg_14h + arg_1ch;\n    lprc1 = arg_10h;\n    var_8h = arg_10h + arg_18h;\n    uVar2 = fcn.0042a1df();\n    if ((uVar2 & 0x200) == 0) {\n        iVar3 = fcn.0042c6e0(0x46e418);\n        if (iVar3 == 0) goto code_r0x0043da56;\n    }\n    (*_sym.imp.USER32.dll_InflateRect)(&lprc1, *0x4995c8, *0x4995cc);\ncode_r0x0043da56:\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(arg_ch + 0x1c), &lpRect);\n    uVar4 = (*_sym.imp.USER32.dll_GetParent)(*(arg_ch + 0x1c), &lpRect);\n    fcn.004278de(uVar4);\n    fcn.00431de5();\n    iVar3 = (*_sym.imp.USER32.dll_EqualRect)(&lprc1, &lpRect);\n    if (iVar3 == 0) {\n        fcn.0042619c(arg_8h, *(arg_ch + 0x1c), &lprc1);\n    }\n    return;\n}\n",
        "token_count": 542
    },
    "0043e3bb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043e3bb(uint noname_0, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t *in_ECX;\n    int32_t iVar5;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    iVar1 = (**(*in_ECX + 0x17c))(arg_ch, arg_10h);\n    (**(*in_ECX + 0x19c))(0);\n    uVar2 = fcn.0042a1c5();\n    if ((uVar2 & 1) != 0) {\n        if (iVar1 == 1) {\n            (**(*in_ECX + 0x150))(*(in_ECX[0x24] + 8) / 2);\n        }\n        else if (iVar1 == 2) {\n            (**(*in_ECX + 0x154))(*(in_ECX[0x23] + 8) / 2);\n        }\n        else if ((iVar1 < 0x65) || (0x73 < iVar1)) {\n            if ((iVar1 < 0xc9) || (0xd7 < iVar1)) {\n                if (iVar1 < 0x12d) {\n                    return;\n                }\n                if (0x20d < iVar1) {\n                    return;\n                }\n                piVar4 = (iVar1 + -0x12d) / 0xf;\n                iVar3 = (iVar1 + -0x12d) % 0xf;\n                iVar1 = (**(*in_ECX + 0x160))(&var_4h, &arg_10h);\n                if (iVar1 != 0) {\n                    if (arg_10h == iVar3) {\n                        iVar3 = iVar3 + 1;\n                    }\n                    if (var_4h == piVar4) {\n                        piVar4 = piVar4 + 1;\n                    }\n                }\n                (**(*in_ECX + 0x158))(piVar4);\n            }\n            else {\n                iVar3 = iVar1 + -0xc9;\n                iVar5 = (**(*in_ECX + 0x160))(0, &arg_10h);\n                if ((iVar5 != 0) && (iVar3 == arg_10h)) {\n                    iVar3 = iVar1 + -200;\n                }\n            }\n            (**(*in_ECX + 0x15c))(iVar3);\n        }\n        else {\n            iVar5 = iVar1 + -0x65;\n            iVar3 = (**(*in_ECX + 0x160))(&arg_10h, 0);\n            if ((iVar3 != 0) && (iVar5 == arg_10h)) {\n                iVar5 = iVar1 + -100;\n            }\n            (**(*in_ECX + 0x158))(iVar5);\n        }\n    }\n    return;\n}\n",
        "token_count": 660
    },
    "0043e4fd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043e4fd(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t *in_ECX;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    var_8h = in_ECX;\n    var_4h = in_ECX;\n    (*_sym.imp.USER32.dll_GetCursorPos)(&var_8h);\n    iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(0x11);\n    iVar3 = 0;\n    iVar5 = ((-1 < iVar2) - 1 & 0xfffffff1) + 0x10;\n    iVar6 = 0;\n    if (arg_8h == 0xd) {\n        uVar7 = 1;\n    }\n    else {\n        if (arg_8h != 0x1b) {\n            if (arg_8h == 0x25) {\n                iVar6 = -1;\n            }\n            else if (arg_8h == 0x26) {\n                iVar3 = -1;\n            }\n            else if (arg_8h == 0x27) {\n                iVar6 = 1;\n            }\n            else {\n                if (arg_8h != 0x28) {\n                    fcn.0042783b();\n                    return;\n                }\n                iVar3 = 1;\n            }\n            iVar1 = in_ECX[0x35];\n            if ((iVar1 == 1) || ((100 < iVar1 && (iVar1 < 0x74)))) {\n                iVar6 = 0;\n            }\n            if ((iVar1 == 2) || ((200 < iVar1 && (iVar1 < 0xd8)))) {\n                iVar3 = 0;\n            }\n            var_4h = var_4h + iVar3 * iVar5;\n            var_8h = var_8h + iVar6 * iVar5;\n            (*_sym.imp.USER32.dll_ScreenToClient)(in_ECX[7], &var_8h);\n            piVar4 = in_ECX[0x2a];\n            if ((var_4h < piVar4) || (piVar4 = in_ECX[0x2c],  piVar4 < var_4h)) {\n                var_4h = piVar4;\n            }\n            piVar4 = in_ECX[0x29];\n            if ((var_8h < piVar4) || (piVar4 = in_ECX[0x2b],  piVar4 < var_8h)) {\n                var_8h = piVar4;\n            }\n            (*_sym.imp.USER32.dll_ClientToScreen)(in_ECX[7], &var_8h);\n            (*_sym.imp.USER32.dll_SetCursorPos)(var_8h, var_4h);\n            return;\n        }\n        uVar7 = 0;\n    }\n    (**(*in_ECX + 0x19c))(uVar7);\n    return;\n}\n",
        "token_count": 701
    },
    "0043e6d3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043e6d3(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    bool bVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    int32_t iVar7;\n    int32_t iVar8;\n    bool bVar9;\n    uint uVar10;\n    uint uVar11;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar7 = 0;\n    bVar1 = false;\n    if (0 < *(in_ECX + 0x7c)) {\n        do {\n            iVar8 = 0;\n            if (0 < *(in_ECX + 0x80)) {\n                do {\n                    iVar5 = iVar7;\n                    uVar2 = fcn.0043c27d();\n                    piVar3 = fcn.0042c6eb(0x46dfc4, uVar2);\n                    if (((piVar3 != NULL) && (iVar4 = (**(*piVar3 + 0x70))(1),  iVar4 != 0)) &&\n                       (iVar5 = fcn.0042a30b(iVar5),  iVar5 != 0)) {\n                        bVar1 = true;\n                        goto code_r0x0043e73c;\n                    }\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < *(in_ECX + 0x80));\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < *(in_ECX + 0x7c));\n    }\ncode_r0x0043e73c:\n    var_8h = 0;\n    if (0 < *(in_ECX + 0x7c)) {\n        do {\n            var_4h = 0;\n            if (0 < *(in_ECX + 0x80)) {\n                do {\n                    uVar2 = fcn.0043c27d(var_8h, var_4h);\n                    piVar3 = fcn.0042c6eb(0x46dfc4, uVar2);\n                    if (((piVar3 != NULL) && (iVar7 = (**(*piVar3 + 0x70))(bVar1),  iVar7 != 0)) &&\n                       (iVar8 = fcn.0042a30b(),  iVar8 != 0)) {\n                        uVar6 = (*_sym.imp.USER32.dll_GetScrollPos)(*(iVar7 + 0x1c), 2);\n                        uVar2 = arg_8h;\n                        uVar10 = arg_ch;\n                        uVar11 = arg_10h;\n                        fcn.004358ee(arg_8h, arg_ch);\n                        if (bVar1) {\n                            iVar8 = *(in_ECX + 0x80) + -1;\n                            bVar9 = SBORROW4(var_4h, iVar8);\n                            iVar8 = var_4h - iVar8;\n                        }\n                        else {\n                            iVar8 = *(in_ECX + 0x7c) + -1;\n                            bVar9 = SBORROW4(var_8h, iVar8);\n                            iVar8 = var_8h - iVar8;\n                        }\n                        if (bVar9 != iVar8 < 0) {\n                            (*_sym.imp.USER32.dll_SetScrollPos)(*(iVar7 + 0x1c), 2, uVar6, 0, uVar2, uVar10, uVar11);\n                        }\n                    }\n                    var_4h = var_4h + 1;\n                } while (var_4h < *(in_ECX + 0x80));\n            }\n            var_8h = var_8h + 1;\n        } while (var_8h < *(in_ECX + 0x7c));\n    }\n    return 1;\n}\n",
        "token_count": 889
    },
    "0043e816": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043e816(uint32_t arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar2 = arg_10h;\n    uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_10h + 0x1c));\n    uVar4 = (*_sym.imp.USER32.dll_GetScrollPos)(*(arg_10h + 0x1c), 2);\n    arg_10h = 0;\n    if (0 < *(in_ECX + 0x7c)) {\n        do {\n            uVar1 = *(iVar2 + 0x1c);\n            iVar5 = fcn.0043c27d(arg_10h, (uVar3 & 0xffff) - 0xea00);\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar5 + 0x1c), 0x114, arg_8h & 0xffff | arg_ch << 0x10, uVar1);\n            if (arg_10h < *(in_ECX + 0x7c) + -1) {\n                (*_sym.imp.USER32.dll_SetScrollPos)(*(iVar2 + 0x1c), 2, uVar4, 0);\n            }\n            arg_10h = arg_10h + 1;\n        } while (arg_10h < *(in_ECX + 0x7c));\n    }\n    return;\n}\n",
        "token_count": 375
    },
    "0043e8ac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043e8ac(uint32_t arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar2 = arg_10h;\n    uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_10h + 0x1c));\n    uVar4 = (*_sym.imp.USER32.dll_GetScrollPos)(*(arg_10h + 0x1c), 2);\n    arg_10h = 0;\n    if (0 < *(in_ECX + 0x80)) {\n        do {\n            uVar1 = *(iVar2 + 0x1c);\n            iVar5 = fcn.0043c27d((uVar3 & 0xffff) - 0xea10, arg_10h);\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar5 + 0x1c), 0x115, arg_8h & 0xffff | arg_ch << 0x10, uVar1);\n            if (arg_10h < *(in_ECX + 0x80) + -1) {\n                (*_sym.imp.USER32.dll_SetScrollPos)(*(iVar2 + 0x1c), 2, uVar4, 0);\n            }\n            arg_10h = arg_10h + 1;\n        } while (arg_10h < *(in_ECX + 0x80));\n    }\n    return;\n}\n",
        "token_count": 373
    },
    "0043f2e3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0043f2e3(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    \n    uVar1 = 0;\n    uVar2 = *(param_1 + 0x78) & 0xa000;\n    if (*(param_1 + 0x7c) != 0) {\n        uVar2 = uVar2 == 0;\n    }\n    if ((uVar2 == 0) || ((*(param_1 + 0x70) & 0xa000) == 0)) {\n        if ((*(param_1 + 0x70) & 0x5000) == 0) goto code_r0x0043f33f;\n        uVar1 = *(param_1 + 0x70) & 0xffff5fff;\n        puVar3 = param_1 + 0x38;\n    }\n    else {\n        uVar1 = *(param_1 + 0x70) & 0xffffafff;\n        puVar3 = param_1 + 0x28;\n    }\n    uVar1 = fcn.00444405(*puVar3, puVar3[1], puVar3[2], puVar3[3], uVar1, 0);\ncode_r0x0043f33f:\n    if ((*(param_1 + 0x7c) == 0) && (uVar1 == 0)) {\n        if ((*(param_1 + 0x70) & 0xa000) != 0) {\n            fcn.00444405(*(param_1 + 0x38), *(param_1 + 0x3c), *(param_1 + 0x40), *(param_1 + 0x44), \n                         *(param_1 + 0x70) & 0xffffafff, 0);\n            uVar2 = *(param_1 + 0x70) & 0xffffafff;\n            uVar1 = fcn.00444405(*(param_1 + 0x28), *(param_1 + 0x2c), *(param_1 + 0x30), *(param_1 + 0x34), uVar2, 0);\n            uVar1 = ~-(uVar1 != uVar2) & uVar1;\n            if (uVar1 != 0) {\n                return uVar1;\n            }\n        }\n        if ((*(param_1 + 0x70) & 0x5000) != 0) {\n            fcn.00444405(*(param_1 + 0x28), *(param_1 + 0x2c), *(param_1 + 0x30), *(param_1 + 0x34), \n                         *(param_1 + 0x70) & 0xffff5fff, 0);\n            uVar2 = *(param_1 + 0x70) & 0xffff5fff;\n            uVar1 = fcn.00444405(*(param_1 + 0x38), *(param_1 + 0x3c), *(param_1 + 0x40), *(param_1 + 0x44), uVar2, 0);\n            uVar1 = ~-(uVar1 != uVar2) & uVar1;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 757
    },
    "0043f689": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043f689(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t arg_24h;\n    int32_t in_ECX;\n    uint *puVar3;\n    uint lprc;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = 1;\n    var_10h = 1;\n    uVar2 = (*_sym.imp.GDI32.dll_GetStockObject)(0);\n    var_8h = fcn.0043241d(uVar2);\n    var_ch = var_8h;\n    var_4h = fcn.00445759();\n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    if ((*(in_ECX + 0x74) & 0xa000) == 0) {\n        if ((*(in_ECX + 0x74) & 0x5000) == 0) {\n            var_14h = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x20);\n            var_14h = var_14h + -1;\n            var_10h = (*pcVar1)(0x21);\n            var_10h = var_10h + -1;\n            if ((((*(in_ECX + 0x78) & 0xa000) == 0) || (*(in_ECX + 0x7c) != 0)) &&\n               (((*(in_ECX + 0x78) & 0x5000) == 0 || (*(in_ECX + 0x7c) == 0)))) {\n                puVar3 = in_ECX + 0x58;\n            }\n            else {\n                puVar3 = in_ECX + 0x48;\n            }\n            var_8h = var_4h;\n        }\n        else {\n            puVar3 = in_ECX + 0x38;\n        }\n    }\n    else {\n        puVar3 = in_ECX + 0x28;\n    }\n    lprc = *puVar3;\n    uStack36 = puVar3[1];\n    uStack32 = puVar3[2];\n    uStack28 = puVar3[3];\n    if (arg_8h != 0) {\n        var_10h = 0;\n        var_14h = 0;\n    }\n    if ((*(in_ECX + 0x75) & 0xf0) != 0) {\n        (*_sym.imp.USER32.dll_InflateRect)(&lprc, 0xffffffff, 0xffffffff);\n    }\n    arg_24h = var_4h;\n    if (*(in_ECX + 0x24) == 0) {\n        arg_24h = var_ch;\n    }\n    fcn.004457f8(&lprc, var_14h, var_10h, in_ECX + 0xc, *(in_ECX + 0x1c), *(in_ECX + 0x20), var_8h, arg_24h);\n    *(in_ECX + 0xc) = lprc;\n    *(in_ECX + 0x1c) = var_14h;\n    *(in_ECX + 0x10) = uStack36;\n    *(in_ECX + 0x20) = var_10h;\n    *(in_ECX + 0x14) = uStack32;\n    *(in_ECX + 0x18) = uStack28;\n    *(in_ECX + 0x24) = var_8h == var_4h;\n    return;\n}\n",
        "token_count": 847
    },
    "0043f790": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043f790(int32_t param_1, int32_t *param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    \n    if (*param_2 != param_3) {\n        *param_2 = param_3;\n        if ((((*(param_1 + 0x70) & 0xa000) == 0) || ((*(param_1 + 0x70) & 0x5000) == 0)) || (*(param_1 + 0x7c) == 0)) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = 1;\n        }\n        *(param_1 + 0x7c) = uVar1;\n        if (*(param_1 + 0x80) == 0) {\n            uVar1 = fcn.0043f2e3();\n        }\n        else {\n            uVar1 = 0;\n        }\n        *(param_1 + 0x74) = uVar1;\n        fcn.0043f689(0);\n    }\n    return;\n}\n",
        "token_count": 247
    },
    "0043f7e2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043f7e2(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_OffsetRect;\n    iVar4 = arg_8h - *(in_ECX + 4);\n    iVar2 = arg_ch - *(in_ECX + 8);\n    (*_sym.imp.USER32.dll_OffsetRect)(in_ECX + 0x28, iVar4, iVar2);\n    (*pcVar1)(in_ECX + 0x48, iVar4, iVar2);\n    (*pcVar1)(in_ECX + 0x38, iVar4, iVar2);\n    (*pcVar1)(in_ECX + 0x58, iVar4, iVar2);\n    *(in_ECX + 4) = arg_8h;\n    *(in_ECX + 8) = arg_ch;\n    if (*(in_ECX + 0x80) == 0) {\n        uVar3 = fcn.0043f2e3();\n    }\n    else {\n        uVar3 = 0;\n    }\n    *(in_ECX + 0x74) = uVar3;\n    fcn.0043f689(0);\n    return;\n}\n",
        "token_count": 312
    },
    "0043fa37": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043fa37(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint arg_10h;\n    uint *puVar2;\n    uint arg_ch;\n    uint var_14h;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    int32_t var_4h;\n    \n    fcn.0043f9f2();\n    if (*(param_1 + 0x74) == 0) {\n        uVar1 = *(param_1 + 0x78);\n        if ((((uVar1 & 4) == 0) && (((uVar1 & 0xa000) == 0 || (*(param_1 + 0x7c) != 0)))) &&\n           (((uVar1 & 0x5000) == 0 || (*(param_1 + 0x7c) == 0)))) {\n            uVar1 = *(param_1 + 0x70) & 0x40 | 0x1000;\n            *(param_1 + 0xa8) = *(param_1 + 0x58);\n            arg_10h = *(param_1 + 0x5c);\n            arg_ch = *(param_1 + 0x58);\n        }\n        else {\n            uVar1 = *(param_1 + 0x70) & 0x40 | 0x2000;\n            *(param_1 + 0xa8) = *(param_1 + 0x48);\n            arg_10h = *(param_1 + 0x4c);\n            arg_ch = *(param_1 + 0x48);\n        }\n        *(param_1 + 0xac) = arg_10h;\n        *(param_1 + 0xa4) = uVar1;\n        fcn.004442fb(*(param_1 + 0x68), arg_ch, arg_10h, uVar1);\n    }\n    else {\n        var_4h = fcn.0043f3fb(*(param_1 + 0x74));\n        puVar2 = param_1 + 0x38;\n        if ((*(param_1 + 0x75) & 0x50) == 0) {\n            puVar2 = param_1 + 0x28;\n        }\n        var_14h = *puVar2;\n        uStack20 = puVar2[1];\n        uStack16 = puVar2[2];\n        uStack12 = puVar2[3];\n        uVar1 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(var_4h + 0x1c));\n        uVar1 = uVar1 & 0xffff;\n        if ((0xe81a < uVar1) && (uVar1 < 0xe81f)) {\n            *(param_1 + 0x90) = uVar1;\n            *(param_1 + 0x94) = var_14h;\n            *(param_1 + 0x98) = uStack20;\n            *(param_1 + 0x9c) = uStack16;\n            *(param_1 + 0xa0) = uStack12;\n            fcn.00431de5(param_1 + 0x94);\n        }\n        fcn.00444164(*(param_1 + 0x68), var_4h, &var_14h);\n        (**(**(param_1 + 0x6c) + 0x144))(1);\n    }\n    return;\n}\n",
        "token_count": 780
    },
    "0044010f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044010f(int32_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    \n    iVar4 = 0;\n    uVar1 = *arg_ch;\n    puVar5 = arg_ch;\n    while (uVar1 != 0) {\n        if (*puVar5 == 0x25) {\n            uVar1 = puVar5[1];\n            if ((uVar1 < '1') || ('9' < uVar1)) {\n                if ((uVar1 < 'A') || ('Z' < uVar1)) goto code_r0x00440168;\n                if (uVar1 < ':') goto code_r0x00440146;\n                iVar3 = uVar1 + -0x38;\n            }\n            else {\ncode_r0x00440146:\n                iVar3 = uVar1 + -0x31;\n            }\n            puVar5 = puVar5 + 2;\n            if (arg_14h <= iVar3) goto code_r0x00440177;\n            iVar3 = *(arg_10h + iVar3 * 4);\n            if (iVar3 != 0) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(iVar3);\n                iVar4 = iVar4 + iVar3;\n            }\n        }\n        else {\ncode_r0x00440168:\n            if ((*(*puVar5 + 0x49af81) & 4) != 0) {\n                iVar4 = iVar4 + 1;\n                puVar5 = puVar5 + 1;\n            }\n            puVar5 = puVar5 + 1;\ncode_r0x00440177:\n            iVar4 = iVar4 + 1;\n        }\n        uVar1 = *puVar5;\n    }\n    puVar5 = fcn.004043ec(iVar4);\n    do {\n        while( true ) {\n            if (*arg_ch == 0) {\n                fcn.00404cad(puVar5 - *arg_8h);\n                return;\n            }\n            uVar1 = *arg_ch;\n            if (uVar1 == 0x25) break;\ncode_r0x004401e2:\n            if ((*(uVar1 + 0x49af81) & 4) != 0) {\n                *puVar5 = uVar1;\n                puVar5 = puVar5 + 1;\n                arg_ch = arg_ch + 1;\n            }\n            *puVar5 = *arg_ch;\n            puVar5 = puVar5 + 1;\n            arg_ch = arg_ch + 1;\n        }\n        uVar2 = arg_ch[1];\n        if ((uVar2 < '1') || ('9' < uVar2)) {\n            if ((uVar2 < 'A') || ('Z' < uVar2)) goto code_r0x004401e2;\n            if (uVar2 < ':') goto code_r0x004401b2;\n            iVar4 = uVar2 + -0x38;\n        }\n        else {\ncode_r0x004401b2:\n            iVar4 = uVar2 + -0x31;\n        }\n        arg_ch = arg_ch + 2;\n        if (iVar4 < arg_14h) {\n            iVar4 = *(arg_10h + iVar4 * 4);\n            if (iVar4 != 0) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyA)(puVar5, iVar4);\n                iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(puVar5);\n                puVar5 = puVar5 + iVar4;\n            }\n        }\n        else {\n            *puVar5 = 0x3f;\n            puVar5 = puVar5 + 1;\n        }\n    } while( true );\n}\n",
        "token_count": 885
    },
    "004402b2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004402b2(uint lpAppName, uint lpValueName, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint lpString;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    if (*(in_ECX + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_wsprintfA)(&lpString, 0x46be44, arg_10h);\n        (*_sym.imp.KERNEL32.dll_WritePrivateProfileStringA)(lpAppName, lpValueName, &lpString, *(in_ECX + 100));\n    }\n    else {\n        iVar1 = fcn.0044cc27(lpAppName);\n        if (iVar1 != 0) {\n            (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(iVar1, lpValueName, 0, 4, &arg_10h, 4);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n        }\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 247
    },
    "00440334": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00440334(uint lpAppName, int32_t lpValueName, int32_t lpString)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_WritePrivateProfileStringA)(lpAppName, lpValueName, lpString, *(in_ECX + 100));\n        return uVar3;\n    }\n    if (lpValueName == 0) {\n        iVar1 = fcn.0044cb96();\n        if (iVar1 != 0) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegDeleteKeyA)(iVar1, lpAppName);\n            goto code_r0x004403a0;\n        }\n    }\n    else {\n        iVar1 = fcn.0044cc27(lpAppName);\n        if (lpString == 0) {\n            if (iVar1 != 0) {\n                iVar2 = (*_sym.imp.ADVAPI32.dll_RegDeleteValueA)(iVar1, lpValueName);\ncode_r0x004403a0:\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n                return iVar2 == 0;\n            }\n        }\n        else if (iVar1 != 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(iVar1, lpValueName, 0, 1, lpString, iVar2 + 1);\n            goto code_r0x004403a0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 386
    },
    "004403ca": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004403ca(uint arg_8h, uint arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        iVar2 = fcn.00425ce2(arg_14h * 2 + 1);\n        uVar1 = 0;\n        if (arg_14h != 0) {\n            do {\n                *(iVar2 + uVar1 * 2) = (*(arg_10h + uVar1) & 0xf) + 0x41;\n                *(iVar2 + 1 + uVar1 * 2) = (*(arg_10h + uVar1) >> 4) + 0x41;\n                uVar1 = uVar1 + 1;\n            } while (uVar1 < arg_14h);\n        }\n        *(iVar2 + uVar1 * 2) = 0;\n        uVar1 = fcn.00440334(arg_8h, arg_ch, iVar2);\n        fcn.00425d0d(iVar2);\n    }\n    else {\n        uVar1 = fcn.0044cc27(arg_8h);\n        if (uVar1 != 0) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(uVar1, arg_ch, 0, 3, arg_10h, arg_14h);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(uVar1);\n            uVar1 = iVar2 == 0;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 387
    },
    "004405fe": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004405fe(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t **ppiVar2;\n    int32_t iVar3;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = *(param_1 + 8);\n    iVar3 = 0;\n    var_4h = param_1;\n    while (var_8h != 0) {\n        ppiVar2 = fcn.00403b8b(&var_8h);\n        piVar1 = *ppiVar2;\n        var_4h = (**(*piVar1 + 0x54))();\n        while (var_4h != 0) {\n            (**(*piVar1 + 0x58))(&var_4h);\n            iVar3 = iVar3 + 1;\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 205
    },
    "00441a96": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00441af2)\n// WARNING: Removing unreachable block (ram,0x00441afe)\n\nvoid fcn.00441a96(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    int32_t unaff_EBX;\n    \n    uVar3 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    pcVar2 = _sym.imp.USER32.dll_GetWindow;\n    iVar4 = (*_sym.imp.USER32.dll_GetWindow)(uVar3);\n    pcVar1 = _sym.imp.USER32.dll_ShowWindow;\n    for (; iVar4 != 0; iVar4 = (*pcVar2)(iVar4, 2)) {\n        iVar5 = fcn.00427905(iVar4);\n        if ((((iVar5 != 0) && (*0x21 != iVar4)) && (iVar6 = fcn.004418f8(*0x21, iVar4),  iVar6 != 0)) &&\n           (((uVar7 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar4, 0xfffffff0),  (uVar7 & 0x18000000) == 0 &&\n             ((*(iVar5 + 0x38) & 2) != 0)) && (*(unaff_EBX + 0xb0) == 0)))) {\n            (*pcVar1)(iVar4, 4);\n            *(iVar5 + 0x38) = *(iVar5 + 0x38) & 0xfffffffd;\n        }\n    }\n    return;\n}\n",
        "token_count": 374
    },
    "00441c25": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00441c25(int32_t param_1, int32_t *param_2, int32_t param_3)\n\n{\n    int32_t *piVar1;\n    \n    piVar1 = *(param_1 + 0xac);\n    if (param_2 != piVar1) {\n        *(param_1 + 0xac) = 0;\n        if (piVar1 != NULL) {\n            (**(*piVar1 + 0x15c))(0, param_2, piVar1);\n        }\n        if (((*(param_1 + 0xac) == 0) && (*(param_1 + 0xac) = param_2,  param_2 != NULL)) && (param_3 != 0)) {\n            (**(*param_2 + 0x15c))(1, param_2, piVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 199
    },
    "00441d18": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00441d18(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (**(*param_1 + 0x158))();\n    if (iVar1 != 0) {\n        return param_1[0x24];\n    }\n    if ((param_1[0x22] != 0) && (*(param_1[0x22] + 0x90) != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 117
    },
    "004420a0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004420a0(uint arg_8h, uint lpIconName)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint var_58h;\n    uint var_38h;\n    int32_t lpClassName;\n    uint lpWndClass;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    \n    iVar1 = fcn.0044be10();\n    iVar1 = (*_sym.imp.USER32.dll_LoadIconA)(*(iVar1 + 0xc), lpIconName);\n    if (iVar1 != 0) {\n        fcn.0040e620(&var_58h, 0, 0x30);\n        var_38h = arg_8h;\n        (**(*in_ECX + 100))(&var_58h);\n        if (lpClassName != 0) {\n            iVar2 = fcn.0044be10();\n            iVar2 = (*_sym.imp.USER32.dll_GetClassInfoA)(*(iVar2 + 8), lpClassName, &lpWndClass);\n            if ((iVar2 != 0) && (var_14h != iVar1)) {\n                uVar3 = fcn.00426cc4(lpWndClass, var_10h, var_ch, iVar1);\n                return uVar3;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 317
    },
    "004421e8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004421e8(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    if (param_1[0x2c] != NULL) {\n        (*param_1[0x2c])(param_1);\n    }\n    piVar1 = (**(*param_1 + 0x138))();\n    if ((piVar1 != NULL) && (iVar2 = (**(*piVar1 + 0x8c))(param_1),  iVar2 == 0)) {\n        return;\n    }\n    iVar2 = fcn.0044be10();\n    piVar3 = *(iVar2 + 4);\n    if ((piVar3 != NULL) && (piVar3[7] == param_1)) {\n        if ((piVar1 == NULL) && (iVar2 = (**(*piVar3 + 0x94))(),  iVar2 == 0)) {\n            return;\n        }\n        fcn.0043c1b1();\n        fcn.0043c16c();\n        iVar2 = fcn.00445c71();\n        if (iVar2 == 0) {\n            fcn.00445c91(0);\n            return;\n        }\n        iVar2 = fcn.0044be10();\n        if ((*(iVar2 + 0x14) == '\\0') && (piVar3[7] == 0)) {\n            fcn.0046362c(0);\n            return;\n        }\n    }\n    if ((piVar1 != NULL) && (piVar1[0x12] != 0)) {\n        var_4h = (**(*piVar1 + 0x60))();\n        do {\n            if (var_4h == NULL) {\n                (**(*piVar1 + 0x7c))();\n                return;\n            }\n            (**(*piVar1 + 100))(&var_4h);\n            piVar3 = fcn.00428388();\n        } while (piVar3 == param_1);\n        (**(*piVar1 + 0x94))(param_1);\n    }\n    (**(*param_1 + 0x60))();\n    return;\n}\n",
        "token_count": 513
    },
    "00442449": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00442449(int32_t arg_8h, int32_t *arg_ch, int32_t arg_10h)\n\n{\n    bool bVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    int32_t *in_ECX;\n    \n    fcn.0042783b();\n    uVar2 = fcn.0042a1c5();\n    piVar3 = in_ECX;\n    if ((uVar2 & 0x40000000) == 0) {\n        piVar3 = fcn.004283c7();\n    }\n    if (arg_8h != 0) {\n        arg_ch = in_ECX;\n    }\n    if ((piVar3 == arg_ch) ||\n       ((piVar4 = fcn.004283c7(),  piVar3 == piVar4 &&\n        (iVar5 = (*_sym.imp.USER32.dll_SendMessageA)(arg_ch[7], 0x36d, 0x40, 0),  iVar5 != 0)))) {\n        bVar1 = true;\n    }\n    else {\n        bVar1 = false;\n    }\n    piVar3[0xe] = piVar3[0xe] & 0xffffffdf;\n    if (bVar1) {\n        piVar3[0xe] = piVar3[0xe] | 0x20;\n    }\n    fcn.00441f12(!bVar1 * '\\x04' + '\\x04');\n    piVar3 = in_ECX[0x2b];\n    if (piVar3 == NULL) {\n        iVar5 = (**(*in_ECX + 0x13c))();\n        piVar3 = *(iVar5 + 0xac);\n        if (piVar3 == NULL) {\n            return;\n        }\n    }\n    if ((arg_8h != 0) && (arg_10h == 0)) {\n        (**(*piVar3 + 0x15c))(1, piVar3, piVar3);\n    }\n    (**(*piVar3 + 0x160))(arg_8h);\n    return;\n}\n",
        "token_count": 485
    },
    "0044251c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0044251c(int32_t param_1, uint32_t param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    iVar2 = fcn.004283c7();\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    param_2 = param_2 & 0xfff0;\n    if (*(iVar2 + 100) == 0) {\ncode_r0x00442558:\n        fcn.0042783b();\n    }\n    else {\n        if (param_2 < 0xf041) {\n            if (((param_2 != 0xf040) && (param_2 != 0xf000)) && (param_2 != 0xf010)) {\n                iVar2 = param_2 - 0xf020;\ncode_r0x00442551:\n                if ((iVar2 != 0) && (iVar2 != 0x10)) goto code_r0x00442558;\n            }\n        }\n        else if ((param_2 != 0xf050) && (param_2 != 0xf060)) {\n            iVar2 = param_2 - 0xf120;\n            goto code_r0x00442551;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x1c), 0x365, 0, (param_2 - 0xf000 >> 4) + 0x1ef00);\n        if (iVar2 == 0) {\n            (*pcVar1)(*(param_1 + 0x1c), 0x111, 0xe147, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 373
    },
    "0044269b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044269b(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    int16_t iVar5;\n    int32_t in_ECX;\n    uint var_10ch;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    uVar4 = fcn.0044be10();\n    pcVar2 = _sym.imp.KERNEL32.dll_GlobalGetAtomNameA;\n    iVar1 = *(uVar4 + 4);\n    if ((((iVar1 != 0) && (arg_ch != 0)) && (iVar5 = arg_ch >> 0x10,  iVar5 != 0)) &&\n       ((arg_ch == *(iVar1 + 0x8c) && (iVar5 == *(iVar1 + 0x8e))))) {\n        (*_sym.imp.KERNEL32.dll_GlobalGetAtomNameA)(uVar4 & 0xffff0000 | *(iVar1 + 0x8c), &var_108h, 0x103);\n        pcVar3 = _sym.imp.KERNEL32.dll_GlobalAddAtomA;\n        (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(&var_108h);\n        (*pcVar2)(*(iVar1 + 0x8e), &var_108h, 0x103);\n        (*pcVar3)(&var_108h);\n        (*_sym.imp.USER32.dll_SendMessageA)(arg_8h, 0x3e4, *(in_ECX + 0x1c), *(iVar1 + 0x8c));\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 396
    },
    "0044283c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044283c(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    \n    piVar1 = fcn.00441d04();\n    if (arg_10h == 0) {\n        fcn.0042a4e3(0, 0, 0, 0, 0, (-(arg_ch != 0) & 0xffffffc0) + 0x80 | 0x17);\n        (**(*arg_8h + 0x14c))(arg_ch);\n        if ((arg_ch != 0) || (iVar2 = fcn.00441d18(),  iVar2 == 0)) {\n            (**(*piVar1 + 0x144))(0);\n        }\n    }\n    else {\n        (**(*arg_8h + 0x14c))(arg_ch);\n        piVar1[0x33] = piVar1[0x33] | 0xc;\n    }\n    iVar2 = fcn.00441d18();\n    if (iVar2 == 0) {\n        return;\n    }\n    if (arg_8h[0x22] == NULL) {\n        uVar3 = arg_ch != 0;\n    }\n    else {\n        uVar3 = (**(*arg_8h[0x22] + 0x168))();\n    }\n    if (uVar3 == 1) {\n        if (arg_ch != 0) {\n            piVar1[0x27] = -1;\n            if (arg_10h == 0) {\n                uVar4 = 8;\n                goto code_r0x004428ff;\n            }\n            piVar1[0x27] = 8;\n            goto code_r0x00442928;\n        }\n    }\n    else if (uVar3 == 0) {\n        piVar1[0x27] = -1;\n        if (arg_10h != 0) {\n            piVar1[0x27] = 0;\n            return;\n        }\n        uVar4 = 0;\ncode_r0x004428ff:\n        fcn.0042a2ea(uVar4);\n        return;\n    }\n    if (arg_10h != 0) {\n        return;\n    }\ncode_r0x00442928:\n    (**(*piVar1 + 0x144))(0);\n    return;\n}\n",
        "token_count": 561
    },
    "00442938": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00442938(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    int32_t in_ECX;\n    int32_t iVar7;\n    uint arg_ch_00;\n    int32_t iVar8;\n    uint var_2ch;\n    uint32_t var_28h;\n    uint32_t var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.004367d1(*(in_ECX + 0x1c));\n    if ((arg_10h == 0) &&\n       ((*(in_ECX + 0x7c) == 0 || (iVar2 = (**(**(in_ECX + 0x7c) + 0x74))(arg_8h, arg_ch, 0),  iVar2 == 0)))) {\n        fcn.0042acf6();\n        iVar2 = fcn.0044bde5();\n        pcVar1 = _sym.imp.USER32.dll_GetMenu;\n        if ((*(iVar2 + 0x78) != *(arg_8h + 4)) &&\n           (((iVar2 = (*_sym.imp.USER32.dll_GetMenu)(*(in_ECX + 0x1c)),  iVar2 != 0 &&\n             (iVar2 = fcn.00428b49(),  iVar2 != 0)) && (iVar2 = (*pcVar1)(*(iVar2 + 0x1c)),  iVar2 != 0)))) {\n            iVar3 = (*_sym.imp.USER32.dll_GetMenuItemCount)(iVar2);\n            iVar7 = 0;\n            if (0 < iVar3) {\n                do {\n                    iVar8 = iVar7;\n                    iVar4 = (*_sym.imp.USER32.dll_GetSubMenu)(iVar2, iVar7);\n                    if (iVar4 == *(arg_8h + 4)) {\n                        fcn.0042d140(iVar8, iVar2);\n                        break;\n                    }\n                    iVar7 = iVar7 + 1;\n                } while (iVar7 < iVar3);\n            }\n        }\n        var_ch = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(arg_8h + 4));\n        pcVar1 = _sym.imp.USER32.dll_GetMenuItemID;\n        var_24h = 0;\n        if (var_ch != 0) {\n            do {\n                uVar6 = var_24h;\n                var_28h = (*pcVar1)(*(arg_8h + 4), var_24h);\n                uVar5 = var_ch;\n                if (var_28h != 0) {\n                    if (var_28h == 0xffffffff) {\n                        iVar2 = fcn.00404a97(uVar6, var_24h);\n                        if (((iVar2 == 0) || (var_28h = (*pcVar1)(*(iVar2 + 4), 0),  var_28h == 0)) ||\n                           (var_28h == 0xffffffff)) goto code_r0x00442a9c;\n                        arg_ch_00 = 0;\n                    }\n                    else if ((*(in_ECX + 0x50) == 0) || (0xefff < var_28h)) {\n                        arg_ch_00 = 0;\n                    }\n                    else {\n                        arg_ch_00 = 1;\n                    }\n                    fcn.0042ad1c(in_ECX, arg_ch_00);\n                    uVar5 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(arg_8h + 4));\n                    if (uVar5 < var_ch) {\n                        var_24h = var_24h + (uVar5 - var_ch);\n                        while ((var_24h < uVar5 && (uVar6 = (*pcVar1)(*(arg_8h + 4), var_24h),  uVar6 == var_28h))) {\n                            var_24h = var_24h + 1;\n                        }\n                    }\n                }\ncode_r0x00442a9c:\n                var_ch = uVar5;\n                var_24h = var_24h + 1;\n            } while (var_24h < var_ch);\n        }\n    }\n    return;\n}\n",
        "token_count": 990
    },
    "00442ab2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00442ab2(uint32_t arg_8h, uint32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    \n    iVar1 = fcn.004283c7();\n    if ((in_ECX[0x1f] != NULL) && (iVar2 = (**(*in_ECX[0x1f] + 0x7c))(arg_8h, arg_ch, arg_10h),  iVar2 != 0)) {\n        return;\n    }\n    if (arg_ch == 0xffff) {\n        in_ECX[0xe] = in_ECX[0xe] & 0xffffffbf;\n        if (*(iVar1 + 100) == 0) {\n            in_ECX[0x29] = 0xe001;\n        }\n        else {\n            in_ECX[0x29] = 0xe002;\n        }\n        (*_sym.imp.USER32.dll_SendMessageA)(in_ECX[7], 0x362, in_ECX[0x29], 0);\n        iVar1 = (**(*in_ECX + 0x150))();\n        if (iVar1 != 0) {\n            (*_sym.imp.USER32.dll_UpdateWindow)(*(iVar1 + 0x1c));\n        }\n        goto code_r0x00442b89;\n    }\n    if ((arg_8h == 0) || ((arg_ch & 0x810) != 0)) {\n        in_ECX[0x29] = 0;\n    }\n    else {\n        if ((arg_8h < 0xf000) || (0xf1ef < arg_8h)) {\n            if (0xfeff < arg_8h) {\n                in_ECX[0x29] = 0xef1f;\n                goto code_r0x00442b85;\n            }\n        }\n        else {\n            arg_8h = (arg_8h - 0xf000 >> 4) + 0xef00;\n        }\n        in_ECX[0x29] = arg_8h;\n    }\ncode_r0x00442b85:\n    *(iVar1 + 0x38) = *(iVar1 + 0x38) | 0x40;\ncode_r0x00442b89:\n    if (in_ECX[0x29] != in_ECX[0x2a]) {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(in_ECX[7]);\n        iVar1 = fcn.004278de(uVar3);\n        if (iVar1 != 0) {\n            (*_sym.imp.USER32.dll_PostMessageA)(in_ECX[7], 0x36a, 0, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 629
    },
    "00442c24": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_48h\n\nvoid fcn.00442c24(void)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t **ppiVar3;\n    int32_t *piVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *puVar5;\n    int32_t *unaff_EDI;\n    uint *in_FS_OFFSET;\n    int32_t iStack80;\n    int32_t *var_48h;\n    uint var_44h;\n    uint uStack68;\n    uint var_2ch;\n    uint var_28h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    uStack68 = 10;\n    var_44h = 0x442c3e;\n    fcn.0042484c();\n    *(unaff_EBP + -4) = 0;\n    var_44h = 10;\n    var_48h = 0x442c4c;\n    fcn.0042484c();\n    iVar1 = *(extraout_ECX + 0x84);\n    *(unaff_EBP + -4) = 1;\n    *(unaff_EBP + -0x10) = iVar1;\n    var_48h = unaff_EDI;\n    while (iVar1 != 0) {\n        iStack80 = unaff_EBP + -0x10;\n        ppiVar3 = fcn.00403b8b();\n        piVar4 = *ppiVar3;\n        (**(*piVar4 + 0x158))();\n        iStack80 = 0x442c8b;\n        var_48h = piVar4;\n        fcn.004248fa();\n        iVar1 = *(unaff_EBP + -0x10);\n    }\n    puVar5 = *(unaff_EBP + -0x44);\n    while (puVar5 != NULL) {\n        if (puVar5 == NULL) goto code_r0x0042032d;\n        ppiVar3 = puVar5 + 2;\n        puVar5 = *puVar5;\n        if ((*ppiVar3)[0x24] == 0) {\n            var_48h = 0x442cbe;\n            (**(**ppiVar3 + 0x60))();\n        }\n        else {\n            var_48h = 0x442cb0;\n            piVar4 = fcn.00428388();\n            var_48h = 0x442cb7;\n            (**(*piVar4 + 0x60))();\n        }\n    }\n    puVar5 = *(unaff_EBP + -0x28);\n    while( true ) {\n        if (puVar5 == NULL) {\n            *(unaff_EBP + -4) = 0;\n            var_48h = 0x442ceb;\n            fcn.0042486f();\n            *(unaff_EBP + -4) = 0xffffffff;\n            var_48h = 0x442cf7;\n            fcn.0042486f();\n            *in_FS_OFFSET = *(unaff_EBP + -0xc);\n            return;\n        }\n        if (puVar5 == NULL) break;\n        ppiVar3 = puVar5 + 2;\n        puVar5 = *puVar5;\n        if (*ppiVar3 != NULL) {\n            var_48h = 0x442cdb;\n            (**(**ppiVar3 + 0x60))();\n        }\n    }\ncode_r0x0042032d:\n    iStack80 = 0x497978;\n    fcn.0040ed8d(&stack0xffffffb0, 0x47c05c);\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 852
    },
    "00442d09": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00442d09(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint32_t uVar3;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    if (arg_8h == 0) {\n        iVar1 = 0;\n    }\n    else {\n        var_4h = *(in_ECX + 0x84);\n        do {\n            if (var_4h == 0) {\n                return 0;\n            }\n            piVar2 = fcn.00403b8b(&var_4h);\n            iVar1 = *piVar2;\n            uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(iVar1 + 0x1c));\n        } while ((uVar3 & 0xffff) != arg_8h);\n    }\n    return iVar1;\n}\n",
        "token_count": 207
    },
    "0044323b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0044323b(int32_t *param_1, int32_t param_2)\n\n{\n    fcn.0042783b();\n    if (param_2 != 1) {\n        (**(*param_1 + 0x144))(1);\n    }\n    return;\n}\n",
        "token_count": 68
    },
    "0044346d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044346d(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    uint uVar4;\n    \n    fcn.00442c24();\n    if (param_1[0x16] != 0) {\n        iVar3 = param_1[0x16];\n        iVar2 = (*_sym.imp.USER32.dll_GetMenu)(param_1[7]);\n        if (iVar2 != iVar3) {\n            (*_sym.imp.USER32.dll_SetMenu)(param_1[7], iVar3);\n        }\n    }\n    iVar3 = fcn.0044be10();\n    iVar3 = *(iVar3 + 4);\n    if (((iVar3 != 0) && (*(iVar3 + 0x1c) == param_1)) && (*(iVar3 + 0x68) == 0)) {\n        (*_sym.imp.USER32.dll_WinHelpA)(param_1[7], 0, 2, 0);\n    }\n    if (param_1[0x12] != NULL) {\n        (**(*param_1[0x12] + 4))(1, unaff_ESI);\n    }\n    piVar1 = param_1[10];\n    param_1[0x12] = 0;\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 0xc))(piVar1, 0, 0);\n    }\n    piVar1 = param_1[9];\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 8))(piVar1);\n    }\n    uVar4 = 0x448a07;\n    iVar3 = fcn.0044c776(0x448a07);\n    (**(*param_1 + 0x110))(*(iVar3 + 0x5c), *(iVar3 + 0x60), *(iVar3 + 100), uVar4, unaff_ESI);\n    return;\n}\n",
        "token_count": 455
    },
    "004442fb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004442fb(int32_t arg_8h, uint arg_ch, uint arg_10h, uint32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    uint var_4h;\n    \n    if ((((*(arg_8h + 0x84) == 0) || (iVar1 = *(arg_8h + 0x88),  iVar1 == 0)) || (*(iVar1 + 0x90) == 0)) ||\n       ((iVar2 = fcn.00439c27(),  iVar2 != 1 || ((*(iVar1 + 0x7c) & arg_14h & 0xf000) == 0)))) {\n        uVar5 = arg_14h;\n        if (((*(arg_8h + 0x7c) & 4) != 0) && (uVar5 = arg_14h | 4,  (arg_14h & 0x5000) != 0)) {\n            uVar5 = arg_14h & 0xffff2fff | 0x2004;\n        }\n        arg_14h = uVar5;\n        piVar4 = fcn.0044412b(arg_14h);\n        fcn.0042a4e3(0, arg_ch, arg_10h, 0, 0, 0x15);\n        if (piVar4[0xd] == 0) {\n            piVar4[0xd] = *(arg_8h + 0x1c);\n        }\n        fcn.0042a05b(0xe81f);\n        fcn.0043a365(arg_8h, 0);\n        (**(*piVar4 + 0x144))(1);\n        uVar5 = (*_sym.imp.USER32.dll_GetWindowLongA)(*(arg_8h + 0x1c), 0xfffffff0);\n        if ((uVar5 & 0x10000000) == 0) {\n            return;\n        }\n        fcn.0042a2ea(8);\n    }\n    else {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(*(iVar1 + 0x1c));\n        piVar4 = fcn.004278de(uVar3);\n        fcn.0042a4e3(0, arg_ch, arg_10h, 0, 0, 0x15);\n        (**(*piVar4 + 0x144))(1);\n    }\n    (*_sym.imp.USER32.dll_UpdateWindow)(piVar4[7]);\n    return;\n}\n",
        "token_count": 601
    },
    "00444405": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl\nfcn.00444405(uint lprcSrc2, uint noname_1, uint noname_2, uint noname_3, uint32_t arg_18h, int32_t **arg_1ch)\n\n{\n    int32_t *piVar1;\n    int32_t **ppiVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    int32_t lprcSrc1;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    ppiVar2 = arg_1ch;\n    arg_18h = arg_18h & 0xf040;\n    if (arg_1ch != NULL) {\n        *arg_1ch = NULL;\n    }\n    arg_1ch = *(in_ECX + 0x84);\n    do {\n        do {\n            if (arg_1ch == NULL) {\n                return 0;\n            }\n            ppiVar3 = fcn.00403b8b(&arg_1ch);\n            piVar1 = *ppiVar3;\n            iVar4 = (**(*piVar1 + 0x158))();\n        } while ((((iVar4 == 0) || (iVar4 = (*_sym.imp.USER32.dll_IsWindowVisible)(piVar1[7]),  iVar4 == 0)) ||\n                 ((piVar1[0x1f] & arg_18h & 0xf000) == 0)) ||\n                ((piVar1[0x24] != 0 && ((piVar1[0x1f] & arg_18h & 0x40) == 0))));\n        (*_sym.imp.USER32.dll_GetWindowRect)(piVar1[7], &lprcSrc1);\n        if (var_8h == lprcSrc1) {\n            var_8h = var_8h + 1;\n        }\n        if (var_4h == var_ch) {\n            var_4h = var_4h + 1;\n        }\n        iVar4 = (*_sym.imp.USER32.dll_IntersectRect)(&lprcSrc1, &lprcSrc1, &lprcSrc2);\n    } while (iVar4 == 0);\n    if (ppiVar2 != NULL) {\n        *ppiVar2 = piVar1;\n    }\n    return piVar1[0x1f] & arg_18h;\n}\n",
        "token_count": 544
    },
    "004445d5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.004445d5(int32_t param_1, uint *param_2)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    \n    if (*(param_1 + 0xd0) == 0) {\n        if (param_2 != NULL) {\n            *param_2 = 0;\n        }\n        iVar1 = 0;\n    }\n    else {\n        uVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0xd0), 0x229, 0, param_2);\n        iVar1 = fcn.00427905(uVar2);\n        if ((((iVar1 != 0) && (*(iVar1 + 0xd4) != 0)) && (uVar3 = fcn.0042a1c5(),  (uVar3 & 0x10000000) == 0)) &&\n           (iVar1 = 0,  param_2 != NULL)) {\n            *param_2 = 0;\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 244
    },
    "004450c3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004450c3(int32_t arg_8h, int32_t arg_ch)\n\n{\n    bool bVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    in_ECX[0x35] = 0;\n    fcn.00444e58(0);\n    piVar2 = fcn.00441c1e();\n    if ((arg_8h == 0) && (piVar2 != NULL)) {\n        (**(*piVar2 + 0x15c))(0, piVar2, piVar2);\n    }\n    bVar1 = false;\n    if (in_ECX[0x1f] != NULL) {\n        iVar3 = (**(*in_ECX[0x1f] + 0x5c))(arg_8h);\n        if (iVar3 != 0) {\n            bVar1 = true;\n            goto code_r0x00445132;\n        }\n    }\n    uVar4 = 0;\n    if ((arg_8h != 0) || (arg_ch != 0)) {\n        uVar4 = 1;\n    }\n    (**(*in_ECX + 0x15c))(uVar4);\ncode_r0x00445132:\n    if ((arg_8h != 0) && (piVar2 != NULL)) {\n        uVar4 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n        iVar3 = fcn.004278de(uVar4);\n        iVar5 = fcn.00444768();\n        if (iVar5 == iVar3) {\n            (**(*piVar2 + 0x15c))(1, piVar2, piVar2);\n        }\n    }\n    if (!bVar1) {\n        (**(*in_ECX + 0x174))(arg_8h, arg_ch, 0);\n        iVar3 = fcn.00444768();\n        (*_sym.imp.USER32.dll_DrawMenuBar)(*(iVar3 + 0x1c));\n    }\n    return;\n}\n",
        "token_count": 472
    },
    "00445607": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00445607(uint *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    uVar4 = *0x4995d4;\n    uVar3 = *0x4995d0;\n    if (in_ECX != NULL) {\n        iVar2 = (*_sym.imp.GDI32.dll_GetMapMode)(in_ECX[2]);\n        pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        if ((iVar2 < 7) && (iVar2 != 1)) {\n            (**(*in_ECX + 0x34))(3);\n            fcn.0043203b(arg_8h);\n            (**(*in_ECX + 0x34))(iVar2);\n            return;\n        }\n        uVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(in_ECX[2], 0x58);\n        uVar4 = (*pcVar1)(in_ECX[2], 0x5a);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_MulDiv;\n    uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(*arg_8h, 0x9ec, uVar3);\n    *arg_8h = uVar3;\n    uVar4 = (*pcVar1)(arg_8h[1], 0x9ec, uVar4);\n    arg_8h[1] = uVar4;\n    return;\n}\n",
        "token_count": 355
    },
    "00445695": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00445695(uint *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    uVar4 = *0x4995d4;\n    uVar3 = *0x4995d0;\n    if (in_ECX != NULL) {\n        iVar2 = (*_sym.imp.GDI32.dll_GetMapMode)(in_ECX[2]);\n        pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        if ((iVar2 < 7) && (iVar2 != 1)) {\n            (**(*in_ECX + 0x34))(3);\n            fcn.00431fd2(arg_8h);\n            (**(*in_ECX + 0x34))(iVar2);\n            return;\n        }\n        uVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(in_ECX[2], 0x58);\n        uVar4 = (*pcVar1)(in_ECX[2], 0x5a);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_MulDiv;\n    uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(*arg_8h, uVar3, 0x9ec);\n    *arg_8h = uVar3;\n    uVar4 = (*pcVar1)(arg_8h[1], uVar4, 0x9ec);\n    arg_8h[1] = uVar4;\n    return;\n}\n",
        "token_count": 355
    },
    "00445759": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00445759(void)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint lpvBits;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    fcn.0044ca10(8);\n    if (*0x499584 == 0) {\n        iVar2 = 0;\n        do {\n            uVar1 = iVar2;\n            iVar2 = iVar2 + 1;\n            *(&stack0xffffffe6 + iVar2 * 2) = 0x5555 << (uVar1 & 1);\n        } while (iVar2 < 8);\n        iVar2 = (*_sym.imp.GDI32.dll_CreateBitmap)(8, 8, 1, 1, &lpvBits);\n        if (iVar2 != 0) {\n            *0x499584 = (*_sym.imp.GDI32.dll_CreatePatternBrush)(iVar2);\n            (*_sym.imp.GDI32.dll_DeleteObject)(iVar2);\n        }\n    }\n    if (*0x499580 == '\\0') {\n        iVar2 = fcn.0040e287(0x4455d2);\n        *0x499580 = '\\x01' - (iVar2 != 0);\n    }\n    fcn.0044ca73(8);\n    fcn.0043241d(*0x499584);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 316
    },
    "00445cf5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00445cf5(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = fcn.0044be10();\n    iVar2 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(iVar2 + 0x2c);\n    if (iVar2 != 0) {\n        return;\n    }\n    iVar2 = fcn.0044be10();\n    if (*(iVar2 + 0x30) == 0) {\n        fcn.00445c91(1);\n        iVar2 = fcn.0044be10();\n        iVar2 = *(iVar2 + 4);\n        if ((iVar2 == 0) || (*(iVar2 + 0x1c) == 0)) {\n            iVar2 = fcn.0044be10();\n            if (*(iVar2 + 0x14) == '\\0') {\n                fcn.0046362c(0);\n            }\n        }\n        else {\n            iVar1 = fcn.0042a30b();\n            if (iVar1 != 0) {\n    // WARNING: Could not recover jumptable at 0x00445cde. Too many branches\n    // WARNING: Treating indirect jump as call\n                (**(**(iVar2 + 0x1c) + 0x60))();\n                return;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 303
    },
    "00446351": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00446351(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    uint *arg_8h_00;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    int32_t *piVar5;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t lprc;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint32_t var_ch;\n    int32_t *var_8h;\n    int32_t var_4h;\n    \n    piVar2 = arg_8h;\n    var_8h = in_ECX;\n    (**(*arg_8h + 0x1c))();\n    (**(*arg_8h + 0x34))(1);\n    (**(*arg_8h + 0x38))(&var_10h, 0, 0);\n    arg_8h_00 = &var_10h;\n    fcn.00431c1d(arg_8h_00, 0, 0);\n    lprc = in_ECX[2];\n    var_1ch = in_ECX[3];\n    var_18h = in_ECX[4];\n    var_14h = in_ECX[5];\n    fcn.004087f5();\n    piVar5 = var_8h;\n    var_4h = 0;\n    arg_8h = NULL;\n    if ((var_8h[1] & 3U) != 0) {\n        if ((var_8h[1] & 2U) == 0) {\n            var_4h = (**(*piVar2 + 0x24))(7);\n        }\n        else {\n            uVar3 = fcn.0043241d(*0x499858);\n            var_4h = fcn.00432539(uVar3);\n        }\n        arg_8h = (**(*piVar2 + 0x24))(5);\n        arg_8h_00 = fcn.004315a9(0xd);\n        (*_sym.imp.USER32.dll_InflateRect)(&lprc, 1, 1);\n        fcn.00408819(lprc, var_1ch, var_18h, var_14h);\n        fcn.004315a9(arg_8h_00);\n    }\n    if ((*(piVar5 + 1) & 0x24) != 0) {\n        (*_sym.imp.GDI32.dll_UnrealizeObject)(*0x49985c);\n    }\n    if ((*(piVar5 + 1) & 0x20) != 0) {\n        iVar4 = (**(*piVar2 + 0x24))(8);\n        if (var_4h == 0) {\n            var_4h = iVar4;\n        }\n        uVar3 = fcn.0043241d(*0x49985c);\n        iVar4 = fcn.0043257f(uVar3);\n        if (arg_8h == NULL) {\n            arg_8h = iVar4;\n        }\n        fcn.0043154d(1);\n        arg_8h_00 = fcn.004315a9(3);\n        fcn.00408819(lprc + 1, var_1ch + 1, var_18h, var_14h);\n        fcn.004315a9(arg_8h_00);\n    }\n    if ((*(piVar5 + 1) & 4) != 0) {\n        uVar3 = fcn.0043241d(*0x49985c);\n        iVar4 = fcn.0043257f(uVar3);\n        if (arg_8h == NULL) {\n            arg_8h = iVar4;\n        }\n        fcn.0043154d(2);\n        fcn.00445ff8(&var_30h);\n        pcVar1 = _sym.imp.GDI32.dll_PatBlt;\n        var_ch = var_28h - var_30h;\n        (*_sym.imp.GDI32.dll_PatBlt)(piVar2[1], var_30h, var_2ch, var_ch, var_1ch - var_2ch, 0xf0001);\n        (*pcVar1)(piVar2[1], var_30h, var_14h, var_ch, var_24h - var_14h, 0xf0001);\n        (*pcVar1)(piVar2[1], var_30h, var_1ch, lprc - var_30h, var_14h - var_1ch, 0xf0001);\n        (*pcVar1)(piVar2[1], var_18h, var_1ch, var_28h - var_18h, var_14h - var_1ch, 0xf0001);\n        piVar5 = var_8h;\n    }\n    if ((*(piVar5 + 1) & 0x18) != 0) {\n        var_ch = (**(*piVar5 + 0xc))();\n        iVar4 = 0;\n        do {\n            if ((var_ch & 1 << (iVar4 & 0x1f)) != 0) {\n                fcn.0044604a(iVar4, &lprc);\n                arg_8h_00 = &lprc;\n                fcn.004455dd();\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 8);\n    }\n    if (var_4h != 0) {\n        fcn.00432539(var_4h, arg_8h_00);\n    }\n    if (arg_8h != NULL) {\n        fcn.0043257f(arg_8h);\n    }\n    (**(*piVar2 + 0x20))(0xffffffff);\n    return;\n}\n",
        "token_count": 1360
    },
    "004465ae": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004465ae(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t lpPoint;\n    int32_t var_4h;\n    \n    if (arg_ch == 1) {\n        lpPoint = in_ECX;\n        var_4h = in_ECX;\n        (*_sym.imp.USER32.dll_GetCursorPos)(&lpPoint);\n        (*_sym.imp.USER32.dll_ScreenToClient)(*(arg_8h + 0x1c), &lpPoint);\n        iVar1 = fcn.00446176(lpPoint, var_4h);\n        if (-1 < iVar1) {\n            iVar1 = fcn.00445ee5(iVar1);\n            if (((iVar1 == 8) && (iVar2 = (*_sym.imp.USER32.dll_PtInRect)(in_ECX + 8, lpPoint, var_4h),  iVar2 == 0)) &&\n               ((*(in_ECX + 4) & 4) != 0)) {\n                iVar1 = 9;\n            }\n            (*_sym.imp.USER32.dll_SetCursor)(*(iVar1 * 4 + 0x499860));\n            return 1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 295
    },
    "00446c2d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00446c2d(uint noname_0, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t in_ECX;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = fcn.0042a1c5();\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x1c), &var_14h);\n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    iVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x21);\n    iVar4 = (*pcVar1)(0x20);\n    uVar5 = fcn.0042783b();\n    if ((var_4h & 0x1000) != 0) {\n        if (uVar5 == 3) {\n            uVar5 = 2;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(2);\n        if (iVar2 < 0) {\n            return 0;\n        }\n    }\n    if (((9 < uVar5) && (uVar5 < 0x12)) || (uVar5 == 4)) {\n        if ((var_4h & 0x800) == 0) {\n            (*_sym.imp.USER32.dll_InflateRect)(&var_14h, -iVar4, -iVar3);\n            if ((var_4h & 0x200) != 0) {\n                if (uVar5 != 4) {\n                    if (uVar5 == 0xd) {\n                        return (arg_ch < var_10h) * 2 + 10;\n                    }\n                    if (uVar5 == 0xe) {\n                        return (arg_ch < var_10h) + 0xb;\n                    }\n                    if (uVar5 == 0x10) {\n                        return ((arg_ch <= var_8h) - 1 & 5) + 10;\n                    }\n                    if (uVar5 != 0x11) {\n                        return uVar5;\n                    }\n                }\n                uVar5 = (var_8h < arg_ch) * 4 + 0xb;\n            }\n        }\n        else {\n            uVar5 = 2;\n        }\n    }\n    return uVar5;\n}\n",
        "token_count": 560
    },
    "00447345": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00447345(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CSharedFile.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[8] != NULL) {\n        fcn.004416cd();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004417cc();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 194
    },
    "0044766c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044766c(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t in_ECX;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(2, arg_ch + 1);\n    if (iVar1 != 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LocalLock)(iVar1);\n        iVar3 = fcn.00430b26(iVar2, arg_ch);\n        if (iVar3 != arg_ch) {\n            (*_sym.imp.KERNEL32.dll_LocalUnlock)(iVar1);\n            (*_sym.imp.KERNEL32.dll_LocalFree)(iVar1);\n            fcn.00434a73(3, 0);\n        }\n        *(iVar2 + arg_ch) = 0;\n        if (*0x49960c == 0) goto code_r0x0044770d;\n        iVar2 = (*_sym.imp.USER32.dll_SetWindowTextA)(*(in_ECX + 0x1c), iVar2);\n        (*_sym.imp.KERNEL32.dll_LocalUnlock)(iVar1);\n        (*_sym.imp.KERNEL32.dll_LocalFree)(iVar1);\n        iVar1 = 0;\n        if ((iVar2 != 0) && (iVar2 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)(*(in_ECX + 0x1c)),  arg_ch <= iVar2)) {\n            fcn.00425d0d(*(in_ECX + 0x60));\n            *(in_ECX + 0x60) = 0;\n            *(in_ECX + 100) = 0;\n            return;\n        }\n    }\n    fcn.004202f9();\ncode_r0x0044770d:\n    (*_sym.imp.KERNEL32.dll_LocalUnlock)(iVar1);\n    uVar4 = fcn.0040d348();\n    (*_sym.imp.KERNEL32.dll_LocalFree)(uVar4);\n    fcn.0040d35b(iVar1);\n    (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), 0, 1);\n    return;\n}\n",
        "token_count": 492
    },
    "0044773e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.0044773e(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, uint8_t *arg_1ch, \n            int32_t arg_20h)\n\n{\n    uint8_t *lpString;\n    uint8_t uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint8_t *puVar4;\n    uint lptm;\n    int32_t var_2ch;\n    uint var_8h;\n    \n    (*_sym.imp.GDI32.dll_GetTextMetricsA)(*(arg_8h + 4), &lptm);\n    lpString = arg_18h + arg_1ch;\n    arg_1ch = arg_18h + arg_20h;\n    iVar3 = 0;\n    puVar4 = lpString;\n    do {\n        if (arg_1ch <= puVar4) break;\n        uVar1 = *puVar4;\n        if (uVar1 == 9) {\n            iVar3 = iVar3 + (arg_14h - iVar3 % arg_14h);\n        }\n        else if ((*0x49984c == 0) || ((*(uVar1 + 0x49af81) & 4) == 0)) {\n            iVar3 = iVar3 + *(arg_ch + uVar1 * 4);\n        }\n        else {\n            puVar4 = puVar4 + 1;\n            iVar3 = iVar3 + var_2ch;\n        }\n        puVar4 = puVar4 + 1;\n    } while (iVar3 <= arg_10h);\n    piVar2 = fcn.0040d295(&var_8h, lpString, puVar4 - lpString, 1, &arg_14h);\n    if (arg_10h < *piVar2) {\n        do {\n            if (*0x49984c == 0) {\n                puVar4 = puVar4 + -1;\n            }\n            else {\n                puVar4 = fcn.004104b2(lpString, puVar4);\n            }\n            piVar2 = fcn.0040d295(&var_8h, lpString, puVar4 - lpString, 1, &arg_14h);\n        } while (*piVar2 != arg_10h && arg_10h <= *piVar2);\n    }\n    else if (*piVar2 < arg_10h) {\n        do {\n            if (arg_1ch <= puVar4) goto code_r0x00447850;\n            puVar4 = fcn.004103c9(puVar4);\n            piVar2 = fcn.0040d295(&var_8h, lpString, puVar4 - lpString, 1, &arg_14h);\n        } while (*piVar2 == arg_10h || *piVar2 < arg_10h);\n        if (*0x49984c == 0) {\n            puVar4 = puVar4 + -1;\n        }\n        else {\n            puVar4 = fcn.004104b2(lpString, puVar4);\n        }\n    }\ncode_r0x00447850:\n    return puVar4 - arg_18h;\n}\n",
        "token_count": 733
    },
    "00447ba2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00447ba2(void)\n\n{\n    uint uVar1;\n    \n    if (*0x49960c == 0) {\n        uVar1 = fcn.0040d348();\n        (*_sym.imp.KERNEL32.dll_LocalUnlock)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 67
    },
    "00447cba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00447cba(int32_t *arg_8h, int32_t *arg_ch, uint32_t arg_10h, uint32_t arg_14h)\n\n{\n    int32_t *arg_8h_00;\n    uint32_t uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t in_ECX;\n    uint lpBuffer;\n    int32_t lptm;\n    int32_t var_80h;\n    uint var_58h;\n    uint var_50h;\n    int32_t var_48h;\n    uint32_t var_44h;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t var_38h;\n    uint32_t var_34h;\n    int32_t var_30h;\n    uint32_t var_2ch;\n    uint32_t var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    arg_8h_00 = arg_8h;\n    uVar1 = fcn.0042a1c5();\n    var_28h = ~(uVar1 >> 7) & 1;\n    uVar1 = fcn.00447bb8();\n    if (arg_10h < uVar1) {\n        var_4h = fcn.00447b28();\n        if (uVar1 < arg_14h) {\n            arg_14h = uVar1;\n        }\n        (*_sym.imp.GDI32.dll_GetTextMetricsA)(arg_8h[2], &lptm);\n        var_ch = var_80h + lptm;\n        piVar2 = fcn.0040d295(&var_20h, 0x47147c, 1, 0, 0);\n        var_10h = ((*(in_ECX + 0x5c) * *piVar2) / 8) / 4;\n        (*_sym.imp.GDI32.dll_GetCharWidthA)(arg_8h[2], 0, 0xff, &lpBuffer);\n        uVar1 = arg_ch[1];\n        var_18h = arg_ch[2] - *arg_ch;\n        (**(*arg_8h + 0x1c))();\n        iVar3 = fcn.00431738(arg_ch);\n        arg_8h = uVar1;\n        do {\n            uVar1 = fcn.00447580(var_4h, arg_14h, arg_10h);\n            if (arg_10h == uVar1) {\n                arg_8h = arg_8h + var_ch;\n            }\n            else if (var_28h == 0) {\n                var_38h = *arg_ch;\n                var_30h = arg_ch[2];\n                var_34h = arg_8h;\n                var_2ch = arg_8h + var_ch;\n                var_1ch = var_2ch;\n                if ((iVar3 != 1) && (iVar4 = (**(*arg_8h_00 + 0x58))(&var_38h),  iVar4 != 0)) {\n                    uVar5 = fcn.0044773e(arg_8h_00, &lpBuffer, var_18h, var_10h, var_4h, arg_10h, uVar1);\n                    if (uVar5 < uVar1) {\n                        if ((*(*(uVar5 + var_4h) + 0x49af81) & 4) != 0) {\n                            uVar5 = uVar5 + 1;\n                        }\n                        uVar5 = uVar5 + 1;\n                    }\n                    (**(*arg_8h_00 + 100))\n                              (&var_50h, var_38h, arg_8h, arg_10h + var_4h, uVar5 - arg_10h, 1, &var_10h, var_38h);\n                }\n                arg_8h = var_1ch;\n            }\n            else {\n                var_14h = arg_8h + var_ch;\n                while( true ) {\n                    var_1ch = fcn.0044773e(arg_8h_00, &lpBuffer, var_18h, var_10h, var_4h, arg_10h, uVar1);\n                    var_8h = var_1ch;\n                    if (var_1ch != uVar1) {\n                        while ((arg_10h < var_8h && (iVar4 = fcn.00410bad(*(var_8h + var_4h)),  iVar4 == 0))) {\n                            var_8h = var_8h - 1;\n                        }\n                        if (var_8h == arg_10h) {\n                            var_8h = var_1ch;\n                        }\n                    }\n                    var_48h = *arg_ch;\n                    var_44h = arg_8h;\n                    var_40h = arg_ch[2];\n                    var_3ch = var_14h;\n                    if ((iVar3 != 1) && (iVar4 = (**(*arg_8h_00 + 0x58))(&var_48h),  iVar4 != 0)) {\n                        (**(*arg_8h_00 + 100))\n                                  (&var_58h, var_48h, arg_8h, arg_10h + var_4h, var_8h - arg_10h, 1, &var_10h, var_48h);\n                    }\n                    arg_8h = arg_8h + var_ch;\n                    var_14h = var_14h + var_ch;\n                    arg_10h = var_8h;\n                    if (uVar1 <= var_8h) break;\n                    do {\n                        iVar4 = fcn.00410bad(*(arg_10h + var_4h));\n                        if (iVar4 == 0) break;\n                        arg_10h = arg_10h + 1;\n                    } while (arg_10h < uVar1);\n                    if ((uVar1 <= arg_10h) || (arg_ch[3] < var_14h)) break;\n                }\n            }\n            uVar1 = fcn.004475a1();\n        } while ((uVar1 < arg_14h) && (arg_10h = uVar1,  arg_8h + var_ch <= arg_ch[3]));\n        (**(*arg_8h_00 + 0x20))(0xffffffff);\n        fcn.00447ba2();\n        arg_ch[3] = arg_8h;\n    }\n    return uVar1;\n}\n",
        "token_count": 1552
    },
    "00448162": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lParam\n// WARNING: Variable defined which should be unmapped: wParam\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n\nbool __cdecl fcn.00448162(uint lpString, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    bool bVar3;\n    uint wParam;\n    uint lParam;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*(unaff_EBP + 8));\n    (*_sym.imp.USER32.dll_SendMessageA)(*(extraout_ECX + 0x1c), 0xb0, unaff_EBP + -0x18, unaff_EBP + -0x14);\n    if (iVar1 == *(unaff_EBP + -0x14) - *(unaff_EBP + -0x18)) {\n        piVar2 = fcn.0042c770();\n        iVar1 = (**(*piVar2 + 0xc))();\n        *(unaff_EBP + -0x10) = iVar1 + 0x10;\n        *(unaff_EBP + -4) = 0;\n        fcn.004480f8(unaff_EBP + -0x10);\n        if (*(unaff_EBP + 0xc) == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(*(unaff_EBP + 8), *(unaff_EBP + -0x10));\n        }\n        else {\n            iVar1 = (*_sym.imp.KERNEL32.dll_lstrcmpA)();\n        }\n        bVar3 = iVar1 == 0;\n        fcn.00403164();\n    }\n    else {\n        bVar3 = false;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return bVar3;\n}\n",
        "token_count": 477
    },
    "00448205": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: wParam\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: lParam\n\nuint __cdecl fcn.00448205(uint lpString, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    uint8_t *puVar3;\n    uint uVar4;\n    uint8_t *puVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint8_t *puVar10;\n    uint *in_FS_OFFSET;\n    bool bVar11;\n    uint lParam;\n    uint var_24h;\n    uint wParam;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    uVar4 = fcn.00447bb8();\n    *(unaff_EBP + -0x1c) = uVar4;\n    (*_sym.imp.USER32.dll_SendMessageA)(*(extraout_ECX + 0x1c), 0xb0, unaff_EBP + -0x20, unaff_EBP + -0x28);\n    uVar7 = *(unaff_EBP + -0x20);\n    iVar6 = (*(unaff_EBP + 0xc) != 0) * 2 + -1;\n    *(unaff_EBP + -0x10) = iVar6;\n    if ((uVar7 != 0) || (-1 < iVar6)) {\n        fcn.0044be10();\n        fcn.0042ad7d();\n        *(unaff_EBP + -4) = 0;\n        puVar5 = fcn.00447b28();\n        *(unaff_EBP + -0x24) = puVar5;\n        if (*(unaff_EBP + -0x10) < 0) {\n            iVar6 = fcn.004104b2(puVar5, puVar5 + uVar7);\n            uVar7 = iVar6 - puVar5;\n        }\n        else if ((*(unaff_EBP + -0x20) != *(unaff_EBP + -0x28)) &&\n                (iVar6 = fcn.00448162(*(unaff_EBP + 8), *(unaff_EBP + 0x10)),  iVar6 != 0)) {\n            if ((*(puVar5[uVar7] + 0x49af81) & 4) != 0) {\n                uVar7 = uVar7 + 1;\n            }\n            uVar7 = uVar7 + *(unaff_EBP + -0x10);\n        }\n        uVar8 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*(unaff_EBP + 8));\n        uVar9 = *(unaff_EBP + -0x1c);\n        if ((uVar8 - 1) + uVar7 < uVar9) {\ncode_r0x0044830c:\n            puVar10 = puVar5 + uVar7;\n            uVar4 = _sym.imp.KERNEL32.dll_lstrcmpA;\n            if (*(unaff_EBP + 0x10) == 0) {\n                uVar4 = _sym.imp.KERNEL32.dll_lstrcmpiA;\n            }\n            bVar11 = *0x49984c == 0;\n            *(unaff_EBP + -0x1c) = uVar4;\n            if (bVar11) {\n                if (*(unaff_EBP + -0x10) < 0) {\n                    puVar5 = puVar10 + (1 - puVar5);\n                    *(unaff_EBP + 0xc) = puVar5;\n                }\n                else {\n                    puVar5 = puVar5 + uVar9 + (-uVar8 - puVar10) + 1;\n                    *(unaff_EBP + 0xc) = puVar5;\n                }\n                while (puVar5 != NULL) {\n                    uVar4 = *(unaff_EBP + 8);\n                    puVar3 = puVar10 + uVar8;\n                    *(unaff_EBP + 0x13) = *puVar3;\n                    *puVar3 = 0;\n                    iVar6 = (**(unaff_EBP + -0x1c))(puVar10, uVar4);\n                    uVar2 = *(unaff_EBP + 0x13);\n                    *puVar3 = uVar2;\n                    if (iVar6 == 0) {\n                        fcn.00447ba2();\n                        iVar6 = puVar10 - *(unaff_EBP + -0x24);\n                        goto code_r0x0044843a;\n                    }\n                    *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc) + -1;\n                    puVar10 = puVar10 + *(unaff_EBP + -0x10);\n                    puVar5 = *(unaff_EBP + 0xc);\n                    *puVar3 = uVar2;\n                }\n                goto code_r0x004483fc;\n            }\n            if (*(unaff_EBP + -0x10) < 1) {\n                *(unaff_EBP + -0x18) = puVar10;\n            }\n            else {\n                *(unaff_EBP + -0x18) = puVar5 + uVar9 + (1 - uVar8);\n                puVar5 = puVar10;\n            }\n            puVar10 = NULL;\n            for (; puVar5 < *(unaff_EBP + -0x18) || puVar5 == *(unaff_EBP + -0x18); puVar5 = fcn.004103c9(puVar5)) {\n                puVar3 = *(unaff_EBP + 8);\n                if ((*(unaff_EBP + 0x10) == 0) ||\n                   ((*puVar5 == *puVar3 && (((*(*puVar5 + 0x49af81) & 4) == 0 || (puVar5[1] == puVar3[1])))))) {\n                    *(unaff_EBP + 0xf) = puVar5[uVar8];\n                    puVar5[uVar8] = 0;\n                    iVar6 = (**(unaff_EBP + -0x1c))(puVar5, puVar3);\n                    puVar5[uVar8] = *(unaff_EBP + 0xf);\n                    if ((iVar6 == 0) && (puVar10 = puVar5,  0 < *(unaff_EBP + -0x10))) break;\n                }\n            }\n            fcn.00447ba2();\n            if (puVar10 != NULL) {\n                iVar6 = puVar10 - *(unaff_EBP + -0x24);\ncode_r0x0044843a:\n                fcn.0040d3a2(iVar6, iVar6 + uVar8, 0);\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.0044be10();\n                fcn.0042ad92();\n                uVar4 = 1;\n                goto code_r0x00448417;\n            }\n        }\n        else {\n            if ((*(unaff_EBP + -0x10) < 0) && (uVar8 <= uVar9)) {\n                if (*0x49984c == 0) {\n                    uVar7 = uVar9 - uVar8;\n                }\n                else {\n                    uVar7 = uVar9;\n                    if (uVar8 != 0) {\n                        *(unaff_EBP + 0xc) = uVar8;\n                        do {\n                            iVar6 = fcn.004104b2(puVar5, puVar5 + uVar7);\n                            uVar7 = iVar6 - puVar5;\n                            piVar1 = unaff_EBP + 0xc;\n                            *piVar1 = *piVar1 + -1;\n                        } while (*piVar1 != 0);\n                        uVar9 = *(unaff_EBP + -0x1c);\n                    }\n                }\n                goto code_r0x0044830c;\n            }\ncode_r0x004483fc:\n            fcn.00447ba2();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0044be10();\n        fcn.0042ad92();\n    }\n    uVar4 = 0;\ncode_r0x00448417:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar4;\n}\n",
        "token_count": 1960
    },
    "00448f45": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00448f45(int32_t *param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    \n    if (param_1[7] != 0) {\n        if (param_2 == 0) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = *(param_2 + 0x1c);\n        }\n        (**(*param_1 + 0x110))(0x425, uVar1, 0);\n    }\n    fcn.0040480a(param_2);\n    return;\n}\n",
        "token_count": 132
    },
    "0044a33c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0044a33c(uint arg_8h)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint32_t var_28h;\n    int32_t lpType;\n    uint lpcbData;\n    uint32_t hKey;\n    uint32_t lParam;\n    uint lpData;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetModuleHandleA;\n    var_4h = *0x496830;\n    lParam = 0;\n    iVar5 = 0;\n    lpcbData = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"kernel32.dll\");\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(lpcbData, \"GetUserDefaultUILanguage\");\n    if (pcVar2 == NULL) {\n        iVar6 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n        if (iVar6 < 0) {\n            hKey = 0;\n            iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)\n                              (0x80000001, \"Control Panel\\\\Desktop\\\\ResourceLocale\", 0, 0x20019, &hKey);\n            if (iVar6 == 0) {\n                lpcbData = 0x10;\n                iVar6 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, 0, 0, &lpType, &lpData, &lpcbData);\n                if (((iVar6 == 0) && (lpType == 1)) &&\n                   (iVar6 = fcn.0040f226(&lpData, 0x46bf38, &var_28h), \n                   pcVar1 = _sym.imp.KERNEL32.dll_ConvertDefaultLocale,  iVar6 == 1)) {\n                    lParam = var_28h;\n                    var_3ch = (*_sym.imp.KERNEL32.dll_ConvertDefaultLocale)(var_28h & 0xffff);\n                    var_38h = (*pcVar1)(var_28h & 0x3ff);\n                    iVar5 = 2;\n                }\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n            }\n        }\n        else {\n            iVar6 = (*pcVar1)(\"ntdll.dll\");\n            if (iVar6 != 0) {\n                lParam = 0;\n                (*_sym.imp.KERNEL32.dll_EnumResourceLanguagesA)(iVar6, 0x10, 1, 0x44a326, &lParam);\n                pcVar1 = _sym.imp.KERNEL32.dll_ConvertDefaultLocale;\n                if (lParam != 0) {\n                    uVar4 = lParam & 0x3ff;\n                    var_3ch = (*_sym.imp.KERNEL32.dll_ConvertDefaultLocale)(lParam & 0xffff);\n                    var_38h = (*pcVar1)(uVar4);\n                    iVar5 = 2;\n                }\n            }\n        }\n    }\n    else {\n        lParam = (*pcVar2)();\n        pcVar1 = _sym.imp.KERNEL32.dll_ConvertDefaultLocale;\n        hKey = lParam & 0x3ff;\n        var_3ch = (*_sym.imp.KERNEL32.dll_ConvertDefaultLocale)(lParam & 0xffff);\n        var_38h = (*pcVar1)(hKey);\n        pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(lpcbData, \"GetSystemDefaultUILanguage\");\n        lParam = (*pcVar2)();\n        uVar4 = lParam & 0x3ff;\n        var_34h = (*pcVar1)(lParam & 0xffff);\n        var_30h = (*pcVar1)(uVar4);\n        iVar5 = 4;\n    }\n    (&var_3ch)[iVar5] = 0x800;\n    iVar6 = 0;\n    if (iVar5 != -1) {\n        do {\n            iVar3 = fcn.0044a2a7(arg_8h, (&var_3ch)[iVar6]);\n            if (iVar3 != 0) break;\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < iVar5 + 1);\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 1000
    },
    "0044a9b6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044a9b6(int32_t param_1)\n\n{\n    if (*(param_1 + 0x84) != NULL) {\n        (**(**(param_1 + 0x84) + 0x14))();\n    }\n    if (*(param_1 + 0x90) != 0) {\n        fcn.004402b2(\"Settings\", \"PreviewPages\", *(param_1 + 0x90));\n    }\n    return;\n}\n",
        "token_count": 107
    },
    "0044ac36": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0044ac36(int32_t param_1, int32_t param_2)\n\n{\n    uint arg_ch;\n    uint unaff_EDI;\n    \n    if ((*(*(param_1 + 0x14) + -0xc) != 0) &&\n       ((*(param_1 + 0x10) != 3 ||\n        (((*(*(param_1 + 0x18) + -0xc) != 0 && (*(*(param_1 + 0x1c) + -0xc) != 0)) && (*(*(param_1 + 0x20) + -0xc) != 0)\n         ))))) {\n        return;\n    }\n    if (param_2 == 0) {\n        arg_ch = 0;\n    }\n    else {\n        arg_ch = fcn.0040e9c0(param_2, unaff_EDI);\n    }\n    fcn.0040449c(param_2, arg_ch);\n    return;\n}\n",
        "token_count": 218
    },
    "0044aee3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint __cdecl fcn.0044aee3(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint uVar3;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    iVar2 = *(unaff_EBP + 8);\n    iVar1 = *(iVar2 + 0x10);\n    *(unaff_EBP + -0x10) = 1;\n    if (iVar1 == 0) {\n        iVar2 = fcn.0044be10();\n        iVar2 = (**(**(iVar2 + 4) + 0xc))(0xe100, 0, 0, 0);\n        if (iVar2 == 0) {\n            fcn.0043bce2();\n        }\n        iVar2 = extraout_ECX[7];\ncode_r0x0044b04a:\n        if (iVar2 != 0) goto code_r0x0044b04f;\n    }\n    else {\n        if (iVar1 == 1) {\n            iVar2 = (**(*extraout_ECX + 0x88))(*(iVar2 + 0x14));\n            goto code_r0x0044b04a;\n        }\n        if (iVar1 < 2) goto code_r0x0044b04f;\n        if (3 < iVar1) {\n            if (iVar1 == 4) {\n                extraout_ECX[0x22] = extraout_ECX[0x12];\n                extraout_ECX[0x12] = 0;\n                goto code_r0x0044b04f;\n            }\n            if (iVar1 == 5) {\n                (**(*extraout_ECX + 0x80))();\n                iVar2 = extraout_ECX[0x22];\n                *(unaff_EBP + -0x10) = 0;\n                if (iVar2 != 0) goto code_r0x0044b04f;\n                iVar2 = fcn.00425ce2(0x24);\n                *(unaff_EBP + 8) = iVar2;\n                *(unaff_EBP + -4) = 0;\n            }\n            else {\n                if (iVar1 != 6) goto code_r0x0044b04f;\n                iVar1 = (**(*extraout_ECX + 0x84))();\n                if (*(iVar2 + 8) == 0) {\n                    if (iVar1 == 0) {\n                        uVar3 = 0xf10c;\n                    }\n                    else {\n                        uVar3 = 0xf10b;\n                    }\n                    fcn.0043c086(uVar3, 0, 0xffffffff);\n                }\n                iVar2 = extraout_ECX[0x22];\n                *(unaff_EBP + -0x10) = 0;\n                if (iVar2 != 0) goto code_r0x0044b04f;\n                iVar2 = fcn.00425ce2(0x24);\n                *(unaff_EBP + 8) = iVar2;\n                *(unaff_EBP + -4) = 1;\n            }\n            if (iVar2 == 0) {\n                iVar2 = 0;\n            }\n            else {\n                iVar2 = fcn.0044ab76();\n            }\n            extraout_ECX[0x22] = iVar2;\n            *(iVar2 + 0x10) = 6;\n            goto code_r0x0044b04f;\n        }\n        extraout_ECX[0x12] = 0;\n        iVar1 = (**(*extraout_ECX + 0x88))(*(iVar2 + 0x14));\n        if (iVar1 != 0) {\n            extraout_ECX[0x22] = iVar2;\n            (*_sym.imp.USER32.dll_SendMessageA)(*(extraout_ECX[7] + 0x1c), 0x111, 0xe108, 0);\n            extraout_ECX[0x22] = 0;\n        }\n    }\n    *(unaff_EBP + -0x10) = 0;\ncode_r0x0044b04f:\n    uVar3 = *(unaff_EBP + -0x10);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 1031
    },
    "0044b42c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0044b42c(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    fcn.00457ae6();\n    fcn.004636c1();\n    fcn.00408b22();\n    if (param_1 == 0) {\n        iVar1 = fcn.0042bc3d();\n        if (iVar1 != 0) {\n            if (*(iVar1 + 0x3c) != NULL) {\n                (**(**(iVar1 + 0x3c) + 4))(1);\n            }\n            *(iVar1 + 0x3c) = 0;\n        }\n        iVar1 = fcn.0044bde5();\n        if (*(iVar1 + 0x100) == 1) {\n            (*_sym.imp.ole32.dll_CoFreeUnusedLibraries)();\n            (*_sym.imp.ole32.dll_OleUninitialize)();\n            *(iVar1 + 0x100) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 222
    },
    "0044b913": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044b913(uint arg_8h, int32_t arg_ch, int32_t *arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t arg_10h_00;\n    uint uVar4;\n    int32_t *in_ECX;\n    int32_t *extraout_ECX;\n    int32_t *piVar5;\n    int32_t extraout_EDX;\n    uint32_t uVar6;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar3 = *arg_10h;\n    piVar5 = in_ECX;\n    if (iVar3 < 0) {\n        fcn.00401182(0x80070057);\n        piVar5 = extraout_ECX;\n        iVar3 = extraout_EDX;\n    }\n    if (arg_ch == 0) {\n        fcn.004039b4(piVar5);\n    }\n    else {\n        iVar2 = *piVar5;\n        uVar1 = iVar2 + iVar3;\n        uVar6 = *(iVar2 + -0xc) + iVar2;\n        if (uVar1 < uVar6) {\n            iVar3 = fcn.0040f8dc(uVar1, arg_ch);\n            if (uVar1 + iVar3 < uVar6) {\n                arg_10h_00 = fcn.0040f97a(uVar1 + iVar3, arg_ch);\n                iVar2 = *arg_10h;\n                *arg_10h = iVar2 + iVar3 + 1 + arg_10h_00;\n                fcn.0044b8ae(arg_8h, iVar2 + iVar3, arg_10h_00);\n                return arg_8h;\n            }\n        }\n        *arg_10h = -1;\n        uVar4 = (**(**(*in_ECX + -0x10) + 0x10))();\n        fcn.00403c29(uVar4);\n    }\n    return arg_8h;\n}\n",
        "token_count": 459
    },
    "0044bbd7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044bbd7(code **param_1)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    \n    *param_1 = vtable.AFX_MODULE_THREAD_STATE.0;\n    if (param_1[0xf] != NULL) {\n        (**(*param_1[0xf] + 0x138))();\n    }\n    if (param_1[5] != NULL) {\n        (***param_1[5])(1);\n    }\n    if (param_1[6] != NULL) {\n        (***param_1[6])(1);\n    }\n    if (param_1[7] != NULL) {\n        (***param_1[7])(1);\n    }\n    if (param_1[8] != NULL) {\n        (***param_1[8])(1);\n    }\n    if (param_1[9] != NULL) {\n        (***param_1[9])(1);\n    }\n    pcVar2 = param_1[0xe];\n    if (pcVar2 != NULL) {\n        while (*(pcVar2 + 0xc) != 0) {\n            uVar1 = fcn.00424787();\n            fcn.00425d0d(uVar1);\n            pcVar2 = param_1[0xe];\n        }\n    }\n    if (param_1[0xc] != NULL) {\n        (**(*param_1[0xc] + 4))(1);\n    }\n    if (param_1[0xd] != NULL) {\n        (**(*param_1[0xd] + 4))(1);\n    }\n    if (param_1[0xe] != NULL) {\n        (**(*param_1[0xe] + 4))(1);\n    }\n    return;\n}\n",
        "token_count": 391
    },
    "0044c1e6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0044c1e6(int32_t param_1)\n\n{\n    if (param_1 != 0) {\n    // WARNING: Could not recover jumptable at 0x0044c1ed. Too many branches\n    // WARNING: Treating indirect jump as call\n        (*_sym.imp.KERNEL32.dll_LocalFree)();\n        return;\n    }\n    return;\n}\n",
        "token_count": 86
    },
    "0044c3fe": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044c3fe(int32_t *param_1)\n\n{\n    uint var_4h;\n    \n    if (*param_1 != 0) {\n        if (*param_1 != NULL) {\n            (****param_1)(1);\n        }\n    }\n    return;\n}\n",
        "token_count": 67
    },
    "0044c688": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c688(uint *arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    bool bVar2;\n    uint *in_ECX;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar3 = 1;\n    bVar2 = true;\n    if (1 < arg_8h[2]) {\n        do {\n            if ((arg_ch == 0) || (*(in_ECX[4] + 4 + iVar3 * 8) == arg_ch)) {\n                puVar1 = *(arg_8h[3] + iVar3 * 4);\n                if (puVar1 != NULL) {\n                    (***puVar1)(1);\n                }\n                *(arg_8h[3] + iVar3 * 4) = 0;\n            }\n            else if (*(arg_8h[3] + iVar3 * 4) != 0) {\n                bVar2 = false;\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < arg_8h[2]);\n        if (!bVar2) {\n            return;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 7);\n    fcn.0044c44f(arg_8h);\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 7);\n    (*_sym.imp.KERNEL32.dll_LocalFree)(arg_8h[3]);\n    (***arg_8h)(1);\n    (*_sym.imp.KERNEL32.dll_TlsSetValue)(*in_ECX, 0);\n    return;\n}\n",
        "token_count": 362
    },
    "0044c71d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0044c71d(uint *param_1, int32_t param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint unaff_retaddr;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(param_1 + 7);\n    if (param_2 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*param_1);\n        if (iVar2 != 0) {\n            fcn.0044c688(iVar2, unaff_retaddr);\n        }\n    }\n    else {\n        iVar2 = param_1[5];\n        while (iVar2 != 0) {\n            iVar1 = *(iVar2 + 4);\n            fcn.0044c688(iVar2, param_3);\n            iVar2 = iVar1;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(param_1 + 7);\n    return;\n}\n",
        "token_count": 220
    },
    "0044c776": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.0044c776(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    if (*extraout_ECX == 0) {\n        if (*0x499614 == 0) {\n            *(unaff_EBP + -0x10) = 0x499618;\n            *(unaff_EBP + -4) = 0;\n            *0x499614 = fcn.0044c4c0();\n            *(unaff_EBP + -4) = 0xffffffff;\n        }\n        iVar1 = fcn.0044c1f6();\n        *extraout_ECX = iVar1;\n    }\n    iVar1 = fcn.0044c302(*extraout_ECX);\n    if (iVar1 == 0) {\n        iVar1 = (**(unaff_EBP + 8))();\n        fcn.0044c565(*extraout_ECX, iVar1);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1;\n}\n",
        "token_count": 328
    },
    "0044c9a7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0044c9a7(void)\n\n{\n    if (*0x499848 == 0) {\n        *0x499848 = 1;\n        (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(0x499694);\n    }\n    return *0x499848;\n}\n",
        "token_count": 67
    },
    "0044ca10": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0044ca10(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    \n    if (*0x499848 == 0) {\n        fcn.0044c9a7();\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_EnterCriticalSection;\n    piVar1 = param_1 * 4 + 0x499650;\n    if (*piVar1 == 0) {\n        (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(0x499694);\n        if (*piVar1 == 0) {\n            (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(param_1 * 0x18 + 0x4996b0);\n            *piVar1 = *piVar1 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(0x499694);\n    }\n    (*pcVar2)(param_1 * 0x18 + 0x4996b0);\n    return;\n}\n",
        "token_count": 224
    },
    "0044cc6d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044cc6d(uint lpAppName, uint lpValueName, int32_t nDefault)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_8h;\n    int32_t var_4h;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        nDefault = (*_sym.imp.KERNEL32.dll_GetPrivateProfileIntA)(lpAppName, lpValueName, nDefault, *(in_ECX + 100));\n    }\n    else {\n        var_4h = in_ECX;\n        iVar1 = fcn.0044cc27(lpAppName);\n        if (iVar1 != 0) {\n            lpAppName = 4;\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(iVar1, lpValueName, 0, &var_8h, &var_4h, &lpAppName);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n            if (iVar2 == 0) {\n                return var_4h;\n            }\n        }\n    }\n    return nDefault;\n}\n",
        "token_count": 259
    },
    "0044cf4d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0044cf4d(uint phkResult, uint lpString, int32_t lpValueName)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    bool bVar4;\n    \n    if (lpValueName == 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueA)(0x80000000, phkResult, 1, lpString, uVar1);\n        bVar4 = iVar2 == 0;\n    }\n    else {\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyA)(0x80000000, phkResult, &phkResult);\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(phkResult, lpValueName, 0, 1, lpString, iVar2 + 1);\n            iVar3 = (*_sym.imp.ADVAPI32.dll_RegCloseKey)(phkResult);\n            if ((iVar3 == 0) && (iVar2 == 0)) {\n                return true;\n            }\n        }\n        bVar4 = false;\n    }\n    return bVar4;\n}\n",
        "token_count": 306
    },
    "0044daef": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0044daef(int32_t param_1, uint param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    uVar1 = (*_sym.imp.SHLWAPI.dll_PathFindFileNameA)(param_1);\n    if (param_1 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(uVar1);\n        iVar2 = iVar2 + 1;\n    }\n    else {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(param_1, uVar1, param_2);\n        iVar2 = 0;\n    }\n    return iVar2;\n}\n",
        "token_count": 149
    },
    "0044db1e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044db1e(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    uint uVar4;\n    uchar *puVar5;\n    char *pcVar6;\n    uchar auStack784 [256];\n    uchar auStack528 [260];\n    uchar auStack268 [260];\n    uint uStack8;\n    \n    uStack8 = *0x496830;\n    iVar1 = fcn.0044be10();\n    *(iVar1 + 8) = *(param_1 + 0x40);\n    *(iVar1 + 0xc) = *(param_1 + 0x40);\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(*(param_1 + 0x40), auStack528, 0x104);\n    if ((iVar2 == 0) || (iVar2 == 0x104)) {\n        fcn.00431a36();\n    }\n    puVar3 = (*_sym.imp.SHLWAPI.dll_PathFindExtensionA)(auStack528);\n    if (puVar3 == NULL) {\n        fcn.00431a36();\n    }\n    *puVar3 = 0;\n    iVar2 = fcn.0044daef(auStack528, auStack268, 0x104);\n    if (iVar2 != 0) {\n        fcn.00431a36();\n    }\n    if (*(param_1 + 0x5c) == 0) {\n        uVar4 = fcn.0040f496(auStack268);\n        *(param_1 + 0x5c) = uVar4;\n    }\n    if (*(param_1 + 0x4c) == 0) {\n        iVar2 = fcn.0042cf90(0xe000, auStack784, 0x100);\n        if (iVar2 == 0) {\n            puVar5 = *(param_1 + 0x5c);\n        }\n        else {\n            puVar5 = auStack784;\n        }\n        uVar4 = fcn.0040f496(puVar5);\n        *(param_1 + 0x4c) = uVar4;\n    }\n    *(iVar1 + 0x10) = *(param_1 + 0x4c);\n    if (*(param_1 + 0x60) == 0) {\n        if (*(param_1 + 0x68) == 1) {\n            pcVar6 = \".CHM\";\n        }\n        else {\n            pcVar6 = \".HLP\";\n        }\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(puVar3, pcVar6);\n        uVar4 = fcn.0040f496(auStack528);\n        *(param_1 + 0x60) = uVar4;\n        *puVar3 = 0;\n    }\n    if (*(param_1 + 100) == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcatA)(auStack268, \".INI\");\n        uVar4 = fcn.0040f496(auStack268);\n        *(param_1 + 100) = uVar4;\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 724
    },
    "0044dc6c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0044dc6c(uint param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_SetErrorMode;\n    uVar2 = (*_sym.imp.KERNEL32.dll_SetErrorMode)(0);\n    (*pcVar1)(uVar2 | 0x8001);\n    iVar3 = fcn.0044be10();\n    *(iVar3 + 8) = unaff_ESI;\n    *(iVar3 + 0xc) = unaff_ESI;\n    iVar3 = fcn.0044be10();\n    iVar3 = *(iVar3 + 4);\n    if (iVar3 != 0) {\n        *(iVar3 + 0x44) = param_1;\n        *(iVar3 + 0x48) = param_2;\n        *(iVar3 + 0x40) = unaff_ESI;\n        fcn.0044db1e();\n    }\n    iVar3 = fcn.0044be10();\n    if (*(iVar3 + 0x14) == '\\0') {\n        fcn.0042c230();\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"user32.dll\");\n    if (iVar3 != 0) {\n        *0x499244 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar3, \"NotifyWinEvent\");\n    }\n    return 1;\n}\n",
        "token_count": 338
    },
    "0044e0cf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044e0cf(int32_t lpString, uint rclsid, uint arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    uint hKey;\n    uint lplpsz;\n    \n    pcVar1 = _sym.imp.ole32.dll_CoTreatAsClass;\n    iVar2 = (*_sym.imp.ole32.dll_CoTreatAsClass)(rclsid, arg_10h);\n    if ((iVar2 != 0) && (lpString != 0)) {\n        (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(0x80000000, \"CLSID\", &hKey);\n        lplpsz = 0;\n        (*_sym.imp.ole32.dll_StringFromCLSID)(rclsid, &lplpsz);\n        uVar3 = fcn.0044c16c(lplpsz);\n        uVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n        (*_sym.imp.ADVAPI32.dll_RegSetValueA)(hKey, uVar3, 1, lpString, uVar4);\n        (*_sym.imp.ole32.dll_CoTaskMemFree)(uVar3);\n        iVar2 = (*pcVar1)(rclsid, arg_10h);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n    }\n    return iVar2;\n}\n",
        "token_count": 325
    },
    "0044e15a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0044e15a(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    piVar1 = arg_8h;\n    if (arg_8h != NULL) {\n        iVar2 = (**(*arg_8h + 0x58))(arg_8h, &var_8h);\n        if ((iVar2 != 0) || (var_8h != 1)) {\n            (**(*piVar1 + 4))(piVar1);\n            return piVar1;\n        }\n        arg_8h = NULL;\n        iVar2 = (**(*piVar1 + 0x30))(piVar1, 1, &arg_8h);\n        if (iVar2 == 0) {\n            var_4h = NULL;\n            (**(*arg_8h + 0xc))(arg_8h, 1, &var_4h, 0);\n            fcn.0044fce5(&arg_8h);\n            return var_4h;\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 264
    },
    "0044e6fb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.0044e6fb(int32_t arg_8h, int32_t noname_1, int32_t noname_2, int32_t noname_3, int32_t arg_18h, int32_t arg_1ch, \n            int32_t arg_20h, int32_t arg_24h, int32_t arg_28h, int32_t arg_2ch, int16_t *arg_30h, int16_t *arg_34h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    uint hMem;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_lstrlenW;\n    if (arg_30h == NULL) {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenW)(arg_30h);\n        iVar2 = iVar2 + 1;\n    }\n    if ((arg_34h == NULL) || (*arg_34h == 0)) {\n        arg_34h = arg_30h;\n        iVar3 = iVar2;\n    }\n    else {\n        iVar3 = (*pcVar1)(arg_34h);\n        iVar3 = iVar3 + 1;\n    }\n    iVar3 = (iVar3 + iVar2) * 2 + 0x34;\n    iVar4 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x2042, iVar3);\n    if (iVar4 != 0) {\n        piVar5 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar4);\n        if (arg_30h == NULL) {\n            piVar5[0xb] = 0;\n        }\n        else {\n            piVar5[0xb] = 0x34;\n            fcn.00404011(piVar5 + 0xd, arg_30h);\n        }\n        if (arg_34h == NULL) {\n            piVar5[0xc] = 0;\n        }\n        else {\n            iVar2 = iVar2 * 2 + 0x34;\n            piVar5[0xc] = iVar2;\n            fcn.00404011(iVar2 + piVar5, arg_34h);\n        }\n        *piVar5 = iVar3;\n        piVar5[5] = arg_18h;\n        piVar5[1] = arg_8h;\n        piVar5[6] = arg_1ch;\n        piVar5[2] = noname_1;\n        piVar5[7] = arg_20h;\n        piVar5[8] = arg_24h;\n        piVar5[3] = noname_2;\n        piVar5[9] = arg_28h;\n        piVar5[4] = noname_3;\n        piVar5[10] = arg_2ch;\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(iVar4);\n    }\n    return iVar4;\n}\n",
        "token_count": 675
    },
    "0044ed6d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_128h\n// WARNING: Variable defined which should be unmapped: hMenu\n// WARNING: Variable defined which should be unmapped: var_124h\n// WARNING: Variable defined which should be unmapped: var_130h\n\nvoid __cdecl fcn.0044ed6d(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_130h;\n    uint hMenu;\n    uint var_128h;\n    uint var_124h;\n    uint lpNewItem;\n    uint uIDItem;\n    uint var_118h;\n    uint uPosition;\n    uint lpString;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = *0x496830;\n    *(unaff_EBP + -0x128) = 0;\n    *(unaff_EBP + -300) = 0;\n    iVar3 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(unaff_EBP + 0xc));\n    *(unaff_EBP + -0x130) = iVar3;\n    *(unaff_EBP + -0x118) = 0;\n    *(unaff_EBP + -0x114) = 0;\n    if (*(unaff_EBP + 0x14) == 1) {\n        *(unaff_EBP + -0x114) = **(unaff_EBP + 0x10);\n    }\n    *(unaff_EBP + -0x11c) = 0;\n    if (0 < iVar3) {\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetSubMenu)(*(unaff_EBP + 0xc), *(unaff_EBP + -0x11c));\n            uVar4 = (*_sym.imp.USER32.dll_GetMenuState)(*(unaff_EBP + 0xc), *(unaff_EBP + -0x11c), 0x400);\n            if ((iVar3 == 0) && ((uVar4 & 0x800) != 0)) {\n                iVar3 = *(unaff_EBP + 0x14);\n                puVar2 = *(unaff_EBP + 0x10) + iVar3 * 4;\n                *puVar2 = *(unaff_EBP + -0x118);\n                *(unaff_EBP + -0x118) = 0;\n                if (iVar3 < 5) {\n                    *(unaff_EBP + -0x114) = *(unaff_EBP + -0x114) + puVar2[1];\n                }\n                *(unaff_EBP + 0x14) = *(unaff_EBP + 0x14) + 2;\n            }\n            else {\n                *(unaff_EBP + -0x124) = 0;\n                if ((*(unaff_EBP + 0x18) != 0) && ((*(unaff_EBP + 0x14) == 5 && (*(*(unaff_EBP + 0x10) + 0x14) == 1))))\n                {\n                    uVar5 = (*_sym.imp.USER32.dll_GetSubMenu)(*(unaff_EBP + 8), *(unaff_EBP + -0x114));\n                    *(unaff_EBP + -0x124) = uVar5;\n                }\n                iVar6 = (*_sym.imp.USER32.dll_GetMenuStringA)\n                                  (*(unaff_EBP + 0xc), *(unaff_EBP + -0x11c), unaff_EBP + -0x110, 0x100, 0x400);\n                if (iVar3 == 0) {\n                    if (0 < iVar6) {\n                        iVar6 = unaff_EBP + -0x110;\n                        iVar3 = (*_sym.imp.USER32.dll_GetMenuItemID)(*(unaff_EBP + 0xc), *(unaff_EBP + -0x11c), iVar6);\n                        uVar4 = uVar4 | 0x400;\ncode_r0x0044ef56:\n                        (*_sym.imp.USER32.dll_InsertMenuA)(*(unaff_EBP + 8), *(unaff_EBP + -0x114), uVar4, iVar3, iVar6)\n                        ;\n                        *(unaff_EBP + -0x114) = *(unaff_EBP + -0x114) + 1;\n                        *(unaff_EBP + -0x118) = *(unaff_EBP + -0x118) + 1;\n                    }\n                }\n                else if (*(unaff_EBP + -0x124) == 0) {\n                    iVar6 = (*_sym.imp.USER32.dll_GetMenuItemCount)(iVar3);\n                    if (iVar6 != 0) {\n                        iVar6 = unaff_EBP + -0x110;\n                        uVar4 = uVar4 & 0xff | 0x410;\n                        goto code_r0x0044ef56;\n                    }\n                }\n                else {\n                    iVar6 = fcn.0044be10();\n                    fcn.004045fc(*(iVar6 + 0x10));\n                    iVar6 = *(*(unaff_EBP + -0x120) + -0xc);\n                    *(unaff_EBP + -4) = 0;\n                    if (iVar6 != 0) {\n                        fcn.00404474(0x20);\n                    }\n                    fcn.004489a6(unaff_EBP + -0x110);\n                    (*_sym.imp.USER32.dll_AppendMenuA)(*(unaff_EBP + -0x124), 0x10, iVar3, *(unaff_EBP + -0x120));\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    puVar2 = *(unaff_EBP + 0x10) + *(unaff_EBP + 0x14) * 4;\n                    piVar1 = puVar2 + -1;\n                    *piVar1 = *piVar1 + 1;\n                    *puVar2 = 0;\n                    *(unaff_EBP + -0x128) = 1;\n                    *(unaff_EBP + -300) = iVar3;\n                    fcn.00403164();\n                }\n            }\n            *(unaff_EBP + -0x11c) = *(unaff_EBP + -0x11c) + 1;\n        } while (*(unaff_EBP + -0x11c) < *(unaff_EBP + -0x130));\n        if (*(unaff_EBP + -0x128) != 0) goto code_r0x0044efa3;\n    }\n    *(*(unaff_EBP + 0x10) + *(unaff_EBP + 0x14) * 4) = *(unaff_EBP + -0x118);\ncode_r0x0044efa3:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 1616
    },
    "0044f05f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0044f05f(int32_t *param_1, int32_t *param_2, uint param_3, uint param_4)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    do {\n        if (*param_2 == 0) {\n            return 0;\n        }\n        uVar1 = (**(*param_1 + 0xb8))(param_2);\n        iVar2 = fcn.0042c6e0(param_4);\n    } while (iVar2 == 0);\n    return uVar1;\n}\n",
        "token_count": 129
    },
    "0044f0b9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044f0b9(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    var_4h = (**(*param_1 + 0xb4))();\n    while( true ) {\n        puVar2 = &var_4h;\n        piVar1 = fcn.0044f097();\n        if (piVar1 == NULL) break;\n        if (piVar1[8] != 0) {\n            (**(*piVar1 + 0x58))(1);\n            (**(*param_1 + 0xc0))(piVar1);\n            fcn.0044fd01(puVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 183
    },
    "0044f104": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044f104(uint arg_8h, int32_t *arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    var_4h = (**(*in_ECX + 0xb4))();\n    piVar2 = fcn.0044f097(&var_4h);\n    while (piVar2 != NULL) {\n        if ((*(piVar2 + 0x43) != '\\0') && (arg_ch != NULL)) {\n            piVar1 = piVar2[0x12];\n            if (piVar1 != NULL) {\n                (**(*piVar1 + 8))(piVar1);\n            }\n            (**(*arg_ch + 4))(arg_ch);\n            piVar2[0x12] = arg_ch;\n        }\n        (**(*piVar2 + 0xdc))(arg_8h);\n        piVar2 = fcn.0044f097(&var_4h);\n    }\n    return;\n}\n",
        "token_count": 237
    },
    "0044f299": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0044f299(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t var_4h;\n    \n    var_4h = param_1;\n    iVar1 = fcn.00433d53();\n    if (iVar1 == 0) {\ncode_r0x0044f2d5:\n        uVar2 = 0;\n    }\n    else {\n        if ((*(param_1 + 0x74) != 0) && (*(param_1 + 0x4c) == 0)) {\n            fcn.0044fce5(param_1 + 0x78);\n            iVar1 = (*_sym.imp.ole32.dll_StgCreateDocfile)(0, 0x4011012, 0, &var_4h);\n            if (iVar1 != 0) goto code_r0x0044f2d5;\n            *(param_1 + 0x78) = var_4h;\n        }\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 242
    },
    "0044f335": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0044f335(int32_t *param_1)\n\n{\n    uint uVar1;\n    uint *puVar2;\n    \n    if (*param_1 == 0) {\n        uVar1 = 0;\n    }\n    else {\n        puVar2 = fcn.00407d9c(param_1);\n        uVar1 = *puVar2;\n    }\n    return uVar1;\n}\n",
        "token_count": 92
    },
    "0044f79b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0044f79b(int32_t param_1, int32_t **param_2)\n\n{\n    if (((~param_2[6] & 1) == 0) && (*(param_1 + 0x1c) == 0)) {\n        (**(**param_2 + 0xbc))(param_1);\n    }\n    return;\n}\n",
        "token_count": 85
    },
    "0044f7bf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid fcn.0044f7bf(void)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    *extraout_ECX = vtable.COleDocument.0;\n    pcVar1 = extraout_ECX[0x15];\n    *(unaff_EBP + -4) = 1;\n    *(unaff_EBP + -0x10) = pcVar1;\n    while (pcVar1 != NULL) {\n        piVar2 = fcn.0044f335();\n        if (piVar2 != NULL) {\n            (**(*piVar2 + 4))(1);\n        }\n        pcVar1 = *(unaff_EBP + -0x10);\n    }\n    fcn.0044fce5(extraout_ECX + 0x1e);\n    (*_sym.imp.ole32.dll_CoTaskMemFree)(extraout_ECX[0x21]);\n    fcn.00445cf5();\n    *(unaff_EBP + -4) = 0;\n    fcn.00424525();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00433dcb();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 380
    },
    "0044fd01": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0044fd01(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    if (param_1[1] == 0) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(param_1 + 1);\n    if (iVar1 == 0) {\n        (**(*param_1 + 0x10))();\n    }\n    return iVar1;\n}\n",
        "token_count": 106
    },
    "0044fd2a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0044fd2a(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    if (param_1[2] != 0) {\n        iVar1 = (**(*param_1[2] + 8))(param_1[2]);\n        return iVar1;\n    }\n    if (param_1[1] == 0) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(param_1 + 1);\n    if (iVar1 == 0) {\n        (**(*param_1 + 0x10))();\n    }\n    return iVar1;\n}\n",
        "token_count": 150
    },
    "0044fd3f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.0044fd3f(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t *piVar1;\n    int32_t **ppiVar2;\n    int32_t **ppiVar3;\n    \n    piVar1 = (**(*param_1 + 0x44))(param_2);\n    if (piVar1 == NULL) {\n        ppiVar2 = (**(*param_1 + 0x38))();\n        if ((((*0x4770fc == *param_2) && (param_2[1] == *0x477100)) && (param_2[2] == *0x477104)) &&\n           (param_2[3] == *0x477108)) {\n            do {\n                for (piVar1 = ppiVar2[1]; *piVar1 != 0; piVar1 = piVar1 + 2) {\n                    if (*(piVar1[1] + param_1) != 0) {\n                        return piVar1[1] + param_1;\n                    }\n                }\n                ppiVar2 = *ppiVar2;\n            } while (ppiVar2 != NULL);\n        }\n        else {\n            do {\n                for (ppiVar3 = ppiVar2[1]; piVar1 = *ppiVar3,  piVar1 != NULL; ppiVar3 = ppiVar3 + 2) {\n                    if (((*piVar1 == *param_2) && (piVar1[1] == param_2[1])) &&\n                       ((piVar1[2] == param_2[2] && ((piVar1[3] == param_2[3] && (*(ppiVar3[1] + param_1) != 0)))))) {\n                        return ppiVar3[1] + param_1;\n                    }\n                }\n                ppiVar2 = *ppiVar2;\n            } while (ppiVar2 != NULL);\n        }\n        piVar1 = NULL;\n    }\n    return piVar1;\n}\n",
        "token_count": 452
    },
    "0044fded": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044fded(uint arg_8h)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    uint var_8h;\n    int32_t var_4h;\n    \n    piVar2 = (**(*in_ECX + 0x38))();\n    do {\n        for (piVar3 = piVar2[1]; *piVar3 != 0; piVar3 = piVar3 + 2) {\n        }\n        for (piVar3 = piVar3 + 1; *piVar3 != -1; piVar3 = piVar3 + 2) {\n            puVar1 = *(in_ECX + *piVar3);\n            if (puVar1 != NULL) {\n                var_4h = 0;\n                iVar4 = (***puVar1)(puVar1, arg_8h, &var_4h);\n                if ((iVar4 == 0) && (var_4h != 0)) {\n                    return var_4h;\n                }\n            }\n        }\n        piVar2 = *piVar2;\n        if (piVar2 == NULL) {\n            return 0;\n        }\n    } while( true );\n}\n",
        "token_count": 293
    },
    "0044fe5c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044fe5c(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    \n    piVar1 = param_1 + 4;\n    if (*piVar1 != 0) {\n        uVar2 = fcn.0044fd3f(0x4770fc);\n        (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(piVar1);\n        (*_sym.imp.ole32.dll_CoDisconnectObject)(uVar2, 0);\n        *piVar1 = 0;\n    }\n    return;\n}\n",
        "token_count": 132
    },
    "0044fea3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044fea3(int32_t param_1)\n\n{\n    if (*(param_1 + 8) != 0) {\n        (**(**(param_1 + 8) + 4))(*(param_1 + 8));\n        return;\n    }\n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(param_1 + 4);\n    return;\n}\n",
        "token_count": 86
    },
    "0044fefe": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0044fefe(int32_t param_1, int32_t *param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    uint unaff_retaddr;\n    \n    if (*(param_1 + 8) != 0) {\n        iVar1 = (****(param_1 + 8))(*(param_1 + 8), param_2, param_3);\n        return iVar1;\n    }\n    iVar1 = fcn.0044fd3f(param_2);\n    *param_2 = iVar1;\n    if (iVar1 == 0) {\n        iVar1 = fcn.0044fded(unaff_retaddr);\n        *param_2 = iVar1;\n        iVar1 = (-(iVar1 != 0) & 0x7fffbffe) + 0x80004002;\n    }\n    else {\n        fcn.0044fea3();\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 220
    },
    "004503eb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004503eb(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t in_ECX;\n    uint var_30h;\n    uint var_2ch;\n    uint var_10h;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    piVar2 = fcn.0044fcc1(*(in_ECX + 0x20), 0x4760dc);\n    if (piVar2 != NULL) {\n        iVar3 = (**(*piVar2 + 0x14))(piVar2, &var_4h);\n        if ((iVar3 == 0) && (var_4h != NULL)) {\n            piVar4 = fcn.0044fcc1(*(in_ECX + 0x20), 0x4776ec);\n            iVar3 = (**(*var_4h + 0xc))(var_4h, 1, &var_30h, 0);\n            pcVar1 = _sym.imp.ole32.dll_CoTaskMemFree;\n            while (iVar3 == 0) {\n                iVar3 = (**(*piVar4 + 0xc))(piVar4, &var_30h, &var_10h);\n                if (iVar3 == 0) {\n                    if (var_8h != 0) {\n                        (*_sym.imp.ole32.dll_ReleaseStgMedium)(&var_10h);\n                        goto code_r0x00450464;\n                    }\n                    fcn.004577fc(0, &var_10h, &var_30h);\n                }\n                else {\ncode_r0x00450464:\n                    (*pcVar1)(var_2ch);\n                }\n                iVar3 = (**(*var_4h + 0xc))(var_4h, 1, &var_30h, 0);\n            }\n            (**(*var_4h + 8))(var_4h);\n            (**(*piVar4 + 8))(piVar4);\n        }\n        (**(*piVar2 + 8))(piVar2);\n    }\n    return;\n}\n",
        "token_count": 488
    },
    "004504c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004504c0(uint *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    uint var_20h;\n    int32_t *var_1ch;\n    int32_t *var_18h;\n    uint var_14h;\n    uint var_4h;\n    \n    var_1ch = NULL;\n    var_4h = *0x496830;\n    piVar1 = fcn.0044fcc1(in_ECX[8], 0x47605c);\n    if (piVar1 == NULL) {\n        piVar1 = (**(*in_ECX + 0xc0))();\n        iVar2 = (**(*piVar1 + 0x10))(piVar1, 4, 3, &var_1ch);\n    }\n    else {\n        iVar2 = (**(*piVar1 + 0x18))(piVar1, &var_1ch);\n        (**(*piVar1 + 8))(piVar1);\n    }\n    if (iVar2 != 0) goto code_r0x004505b7;\n    iVar2 = (*_sym.imp.ole32.dll_CreateStreamOnHGlobal)(0, 1, &var_18h);\n    if (iVar2 != 0) {\n        (**(*var_1ch + 8))(var_1ch);\n        fcn.004202f9();\n    }\n    iVar2 = (*_sym.imp.ole32.dll_OleSaveToStream)(var_1ch, var_18h);\n    (**(*var_1ch + 8))(var_1ch);\n    if (iVar2 == 0) {\n        iVar2 = (**(*in_ECX[8] + 0x3c))(in_ECX[8], &var_14h);\n        if ((iVar2 != 0) || (iVar2 = (*_sym.imp.ole32.dll_WriteClassStm)(var_18h, &var_14h),  iVar2 != 0)) {\n            (**(*var_18h + 8))(var_18h);\n            goto code_r0x0045059c;\n        }\n    }\n    else {\n        (**(*var_18h + 8))(var_18h);\ncode_r0x0045059c:\n        fcn.0044e402(iVar2);\n    }\n    arg_8h[2] = 0;\n    *arg_8h = 4;\n    arg_8h[1] = var_18h;\ncode_r0x004505b7:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 583
    },
    "004508ee": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004508ee(int32_t *param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    if (*(param_1 + 0x11) == '\\0') {\n        *(param_1 + 0x11) = 1;\n        iVar1 = (**(*param_1[8] + 0x18))(param_1[8], param_2);\n        param_1[0xc] = iVar1;\n        if (*(param_1 + 0x42) != '\\0') {\n            (*_sym.imp.ole32.dll_OleLockRunning)(param_1[8], 0, 1);\n            *(param_1 + 0x42) = 0;\n        }\n        if (param_1[0x13] != 1) {\n            if (param_1[0x13] == 4) {\n                (**(*param_1 + 0x80))(0);\n            }\n            if (param_1[0x13] == 3) {\n                (**(*param_1 + 0x98))();\n            }\n            if (param_1[0x13] != 1) {\n                (**(*param_1 + 0x6c))(4, 1);\n                param_1[0x13] = 1;\n            }\n        }\n        *(param_1 + 0x11) = 0;\n    }\n    return;\n}\n",
        "token_count": 316
    },
    "004509b6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004509b6(char *param_1)\n\n{\n    char cVar1;\n    char *in_EAX;\n    uint uVar2;\n    uint *unaff_EBX;\n    \n    for (; (cVar1 = *in_EAX,  cVar1 != ',' && (cVar1 != '\\0')); in_EAX = fcn.004103c9(in_EAX)) {\n        *param_1 = cVar1;\n        param_1 = fcn.004103c9(param_1);\n    }\n    *param_1 = '\\0';\n    if (*in_EAX == '\\0') {\n        *unaff_EBX = 0;\n    }\n    else {\n        uVar2 = fcn.004103c9(in_EAX);\n        uVar2 = fcn.0041026e(uVar2);\n        *unaff_EBX = uVar2;\n    }\n    return;\n}\n",
        "token_count": 202
    },
    "004519ad": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004519ad(uint arg_8h)\n\n{\n    int32_t **ppiVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    int32_t arg_8h_00;\n    int32_t *in_ECX;\n    int32_t *var_8h;\n    int32_t *dwBytes;\n    \n    var_8h = in_ECX;\n    dwBytes = in_ECX;\n    fcn.0040694a(&dwBytes);\n    iVar2 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x2002, dwBytes);\n    if (iVar2 == 0) {\n        fcn.004202f9();\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar2);\n    piVar4 = fcn.00430b26(uVar3, dwBytes);\n    (*_sym.imp.KERNEL32.dll_GlobalUnlock)(iVar2);\n    if (piVar4 != dwBytes) {\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(iVar2);\n        fcn.00434a73(3, 0);\n    }\n    ppiVar1 = in_ECX + 0xe;\n    arg_8h_00 = (*_sym.imp.ole32.dll_CreateILockBytesOnHGlobal)(iVar2, 1, ppiVar1);\n    if (arg_8h_00 == 0) {\n        arg_8h_00 = (*_sym.imp.ole32.dll_StgOpenStorageOnILockBytes)(*ppiVar1, 0, 0x12, 0, 0, in_ECX + 0xd);\n        if (arg_8h_00 == 0) {\n            var_8h = NULL;\n            uVar3 = (**(*in_ECX + 0xc0))(&var_8h);\n            uVar3 = (*_sym.imp.ole32.dll_OleLoad)(in_ECX[0xd], 0x4770fc, uVar3);\n            (**(*in_ECX + 200))(uVar3);\n            iVar2 = fcn.0044fcc1(var_8h, 0x47607c);\n            in_ECX[8] = iVar2;\n            (**(*var_8h + 8))(var_8h);\n            if (in_ECX[8] != 0) {\n                return;\n            }\n            arg_8h_00 = -0x7ff8fff2;\n        }\n        else {\n            (**(**ppiVar1 + 8))(*ppiVar1);\n            *ppiVar1 = NULL;\n        }\n    }\n    else {\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(iVar2);\n    }\n    fcn.0044e402(arg_8h_00);\n    return;\n}\n",
        "token_count": 620
    },
    "00451aaf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00451aaf(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint arg_8h_00;\n    int32_t in_ECX;\n    uint hMem;\n    uint var_4ch;\n    uint var_44h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    piVar1 = fcn.0044fcc1(*(in_ECX + 0x20), 0x47777c);\n    if (*(*(in_ECX + 0x1c) + 0x74) == 0) {\n        iVar2 = (**(*piVar1 + 0x10))(piVar1);\n        if (iVar2 == 0) goto code_r0x00451ae3;\n    }\n    else {\ncode_r0x00451ae3:\n        (*_sym.imp.ole32.dll_OleSave)(piVar1, *(in_ECX + 0x34), *(*(in_ECX + 0x1c) + 0x74) == 0);\n        (**(*piVar1 + 0x20))(piVar1, 0);\n    }\n    (**(*piVar1 + 8))(piVar1);\n    (**(**(in_ECX + 0x34) + 0x24))(*(in_ECX + 0x34), 1);\n    iVar2 = (*_sym.imp.ole32.dll_GetHGlobalFromILockBytes)(*(in_ECX + 0x38), &hMem);\n    if (iVar2 == 0) {\n        iVar2 = (**(**(in_ECX + 0x38) + 0x24))(*(in_ECX + 0x38), &var_4ch, 1);\n        if (iVar2 == 0) goto code_r0x00451b3c;\n    }\n    fcn.0044e402(iVar2);\ncode_r0x00451b3c:\n    fcn.00406888(var_44h);\n    arg_8h_00 = (*_sym.imp.KERNEL32.dll_GlobalLock)(hMem);\n    fcn.00431029(arg_8h_00, var_44h);\n    (*_sym.imp.KERNEL32.dll_GlobalUnlock)(hMem);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 523
    },
    "004523ce": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004523ce(int32_t *param_1)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    int32_t *unaff_EDI;\n    uint64_t uVar4;\n    int32_t *piVar5;\n    \n    piVar5 = param_1 + 4;\n    if (*piVar5 != 0) {\n        (**(*param_1 + 0x48))();\n        fcn.0044fce5(piVar5);\n        unaff_EDI = piVar5;\n    }\n    puVar1 = param_1 + 5;\n    uVar2 = *puVar1;\n    uVar4 = uVar2;\n    piVar5 = *(uVar2 - 0x10);\n    if (*(uVar2 - 0xc) != 0) {\n        if (*(uVar2 - 4) < 0) {\n            if (*(uVar2 - 8) < 0) {\n                uVar4 = fcn.00401182(0x80070057);\n            }\n            *(uVar4 + -0xc) = uVar4 >> 0x20;\n            **puVar1 = uVar4 >> 0x20;\n        }\n        else {\n            fcn.00403164(unaff_EDI, unaff_ESI);\n            iVar3 = (**(*piVar5 + 0xc))();\n            *puVar1 = iVar3 + 0x10;\n        }\n    }\n    return;\n}\n",
        "token_count": 344
    },
    "004523ef": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004523ef(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.COleStreamFile.0;\n    pcVar1 = extraout_ECX[4];\n    *(unaff_EBP + -4) = 1;\n    if ((pcVar1 != NULL) && (extraout_ECX[2] != NULL)) {\n        fcn.004523ce();\n    }\n    fcn.00403164();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042ef32();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 231
    },
    "00452ced": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00452ced(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint uVar3;\n    uint var_20h;\n    int32_t *var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t *pv;\n    int32_t *var_4h;\n    \n    pv = NULL;\n    iVar2 = fcn.004502a7(&var_4h, &pv, &var_ch);\n    if ((iVar2 == 0) && (var_4h = fcn.0044fcc1(*(in_ECX + 0x20), 0x4760dc),  var_4h == NULL)) {\n        return 0;\n    }\n    piVar1 = arg_8h;\n    if (arg_8h == NULL) {\n        if (pv != NULL) {\ncode_r0x00452daf:\n            (**(*var_4h + 0x10))(var_4h, var_ch);\n            (*_sym.imp.ole32.dll_CoTaskMemFree)(pv);\ncode_r0x00452dc1:\n            (**(*var_4h + 8))(var_4h);\n            return 1;\n        }\n    }\n    else if (((pv == NULL) || (*pv != *arg_8h)) || (iVar2 = fcn.0040ee70(pv, arg_8h, *arg_8h),  iVar2 != 0)) {\n        var_14h = 0xffffffff;\n        var_1ch = piVar1;\n        var_10h = 0x20;\n        var_20h._0_2_ = 3;\n        var_18h = 1;\n        iVar2 = (**(*var_4h + 0xc))(var_4h, &var_20h, 0x20, &arg_8h);\n        if (iVar2 != 0) {\n            (**(*var_4h + 8))(var_4h);\n            uVar3 = 0;\n            goto code_r0x00452d99;\n        }\n        if (pv == NULL) goto code_r0x00452dc1;\n        goto code_r0x00452daf;\n    }\n    (**(*var_4h + 8))(var_4h);\n    uVar3 = 1;\ncode_r0x00452d99:\n    (*_sym.imp.ole32.dll_CoTaskMemFree)(pv);\n    return uVar3;\n}\n",
        "token_count": 591
    },
    "004531bf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004531bf(uint arg_8h, uint *arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    uint lprc;\n    uint var_4h;\n    \n    iVar4 = arg_ch;\n    if (in_ECX[0x15] == 0) {\n        in_ECX[0x15] = arg_ch;\n    }\n    iVar1 = fcn.0044c3a2(0x4576ed);\n    arg_ch = NULL;\n    var_4h = *(iVar1 + 4);\n    *(iVar1 + 4) = 0;\n    if (iVar4 != 0) {\n        (*_sym.imp.USER32.dll_SetRectEmpty)(&lprc);\n        (**(*in_ECX + 0x70))(&lprc);\n        iVar2 = (*_sym.imp.USER32.dll_IsRectEmpty)(&lprc);\n        if (iVar2 == 0) {\n            arg_ch = &lprc;\n            *(iVar1 + 4) = iVar4;\n        }\n    }\n    uVar3 = (**(*in_ECX + 0xc0))();\n    if (iVar4 != 0) {\n        iVar4 = *(iVar4 + 0x1c);\n    }\n    iVar4 = (**(*in_ECX[8] + 0x2c))(in_ECX[8], arg_8h, arg_10h, uVar3, 0xffffffff, iVar4, arg_ch);\n    *(iVar1 + 4) = var_4h;\n    iVar1 = fcn.00407db5();\n    if (iVar1 == 0) {\n        in_ECX[0x15] = 0;\n    }\n    *(in_ECX + 0x10) = iVar4 < 0;\n    (**(*in_ECX + 200))(iVar4);\n    return;\n}\n",
        "token_count": 444
    },
    "00453ec5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00453ec5(uint arg_8h, code *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    iVar1 = fcn.0044be10();\n    iVar1 = *(iVar1 + 4);\n    if (*(iVar1 + 0x54) != 0) {\n        var_ch = (**(**(iVar1 + 0x54) + 0x10))();\n        while (var_ch != 0) {\n            piVar2 = (**(**(iVar1 + 0x54) + 0x14))(&var_ch);\n            var_8h = (**(*piVar2 + 0x54))();\n            while (var_8h != 0) {\n                piVar3 = (**(*piVar2 + 0x58))(&var_8h);\n                iVar4 = fcn.0042c6e0(0x46d5b0);\n                if (iVar4 != 0) {\n                    var_4h = (**(*piVar3 + 0xb4))();\n                    while (iVar4 = fcn.0044f097(&var_4h),  iVar4 != 0) {\n                        if ((((*(iVar4 + 0x5c) != 0) && (*(*(iVar4 + 0x5c) + 0x20) != 0)) && (*(iVar4 + 0x54) != 0)) &&\n                           ((iVar4 = fcn.004418f8(),  iVar4 != 0 && (iVar4 = (*arg_ch)(arg_8h),  iVar4 == 0)))) {\n                            return 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return 1;\n}\n",
        "token_count": 437
    },
    "00454b2b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00454b2b(int32_t param_1, int32_t param_2)\n\n{\n    *(param_1 + 0x70) = param_2;\n    if (param_2 != 1) {\n        param_2 = ((param_2 != 2) - 1 & 3) - 1;\n    }\n    return param_2;\n}\n",
        "token_count": 90
    },
    "00454bc4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00454bc4(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t hWnd;\n    \n    iVar2 = *(param_1 + 100);\n    if (iVar2 != 0) {\n        iVar2 = *(iVar2 + 0x1c);\n    }\n    hWnd = param_1;\n    uVar1 = fcn.0043be93(iVar2, &hWnd);\n    *(param_1 + 0x7c) = uVar1;\n    fcn.004293a0(param_1);\n    iVar2 = sub.oledlg.dll_OleUIBusyA(param_1 + 0x74);\n    fcn.00427986();\n    fcn.00427958();\n    if (hWnd != 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(hWnd, 1);\n    }\n    uVar1 = 2;\n    if (iVar2 != 2) {\n        if (iVar2 == 0x75) {\n            *(param_1 + 0xa0) = 1;\n        }\n        else {\n            if (iVar2 != 0x76) {\n                if (iVar2 == 0x77) {\n                    *(param_1 + 0xa0) = 3;\n                    return 1;\n                }\n                uVar1 = fcn.00454b2b(iVar2);\n            }\n            *(param_1 + 0xa0) = uVar1;\n        }\n        return 1;\n    }\n    return 2;\n}\n",
        "token_count": 347
    },
    "00455183": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00455183(int32_t *param_1)\n\n{\n    int32_t *var_4h;\n    \n    if ((param_1[0x33] & 8U) != 0) {\n        var_4h = param_1;\n        (**(*param_1 + 0x144))(param_1[0x33] & 4);\n    }\n    var_4h = param_1[0x21];\n    while (var_4h != NULL) {\n        fcn.00403b8b(&var_4h);\n        fcn.00428100();\n    }\n    return;\n}\n",
        "token_count": 141
    },
    "00455778": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuchar __fastcall fcn.00455778(int32_t *param_1)\n\n{\n    uchar uVar1;\n    \n    if (*(param_1 + 0x11) == '\\0') {\n        uVar1 = (**(*param_1 + 0x60))();\n        *(param_1 + 0x45) = uVar1;\n        *(param_1 + 0x11) = 1;\n    }\n    return *(param_1 + 0x45);\n}\n",
        "token_count": 106
    },
    "00455df0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00455df0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    int32_t arg_24h;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    uint *in_FS_OFFSET;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    arg_24h = 0;\n    iVar2 = *(unaff_EBP + 0x14);\n    *(extraout_ECX + 0x47) = *(unaff_EBP + 8);\n    if (iVar2 != 0) {\n        piVar1 = fcn.0042c770();\n        iVar2 = (**(*piVar1 + 0xc))();\n        *(unaff_EBP + -0x10) = iVar2 + 0x10;\n        *(unaff_EBP + -4) = 0;\n        piVar1 = fcn.0042c770();\n        iVar2 = (**(*piVar1 + 0xc))();\n        *(unaff_EBP + 0x14) = iVar2 + 0x10;\n        *(unaff_EBP + -4) = 1;\n        piVar1 = fcn.0042c770();\n        iVar2 = (**(*piVar1 + 0xc))();\n        *(unaff_EBP + -0x14) = iVar2 + 0x10;\n        *(unaff_EBP + -4) = 2;\n        piVar1 = fcn.0042c770();\n        iVar2 = (**(*piVar1 + 0xc))();\n        *(unaff_EBP + -0x1c) = iVar2 + 0x10;\n        *(unaff_EBP + -4) = 3;\n        piVar1 = fcn.0042c770();\n        iVar2 = (**(*piVar1 + 0xc))();\n        *(unaff_EBP + -0x18) = iVar2 + 0x10;\n        iVar2 = **(extraout_ECX + 0x4c);\n        *(unaff_EBP + -4) = 4;\n        iVar2 = (**(iVar2 + 100))(unaff_EBP + -0x10, 5);\n        if ((iVar2 != 0) && (*(*(unaff_EBP + -0x10) + -0xc) != 0)) {\n            iVar2 = (**(**(extraout_ECX + 0x4c) + 100))(unaff_EBP + 0x14, 6);\n            if (iVar2 == 0) {\n                fcn.004048c5(unaff_EBP + -0x10);\n            }\n            iVar2 = (**(**(extraout_ECX + 0x4c) + 100))(unaff_EBP + -0x14, 2);\n            if (iVar2 == 0) {\n                fcn.004048c5(unaff_EBP + 0x14);\n            }\n            (**(**(extraout_ECX + 0x4c) + 100))(unaff_EBP + -0x1c, 3);\n            (**(**(extraout_ECX + 0x4c) + 100))(unaff_EBP + -0x18, 4);\n            fcn.0044be10();\n            iVar2 = fcn.0043bd05();\n            iVar3 = 1;\n            *(unaff_EBP + -0x20) = iVar2;\n            while (iVar2 != 0) {\n                fcn.0044be10();\n                iVar2 = fcn.0043bd16();\n                if (iVar2 == *(extraout_ECX + 0x4c)) {\n                    *(unaff_EBP + -0x20) = 0;\n                    arg_24h = iVar3;\n                }\n                iVar3 = iVar3 + 1;\n                iVar2 = *(unaff_EBP + -0x20);\n            }\n            iVar2 = fcn.0045d333(extraout_ECX + 0x24, *(unaff_EBP + -0x10), *(unaff_EBP + -0x14), *(unaff_EBP + 0x14), \n                                 *(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), arg_24h, \n                                 *(unaff_EBP + -0x1c), *(unaff_EBP + -0x18));\n            if (iVar2 == 0) {\n                fcn.0043c086(0xf18a, 0, 0xffffffff);\n            }\n        }\n        fcn.00403164();\n        fcn.00403164();\n        fcn.00403164();\n        fcn.00403164();\n        fcn.00403164();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 1260
    },
    "00456065": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00456065(int32_t param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    uint unaff_retaddr;\n    \n    *(param_1 + 0x8c) = *(param_1 + 0x8c) + -1;\n    if (*(param_1 + 0x90) != 0) {\n        if (param_2 == 0) {\n            unaff_retaddr = fcn.0044de6c(*(param_1 + 0x90));\n        }\n        piVar1 = *(param_1 + 0x90) + 4;\n        *piVar1 = *piVar1 + 1;\n        fcn.00425ba6();\n        *(param_1 + 0x90) = 0;\n    }\n    return unaff_retaddr;\n}\n",
        "token_count": 192
    },
    "00456944": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00456944(int32_t *param_1)\n\n{\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    if (param_1[0x25] != 0) {\n        var_4h = NULL;\n        (*_sym.imp.ole32.dll_GetRunningObjectTable)(0, &var_4h);\n        if (var_4h != NULL) {\n            (**(*var_4h + 0x10))(var_4h, param_1[0x25]);\n            (**(*var_4h + 8))(var_4h);\n        }\n        param_1[0x25] = 0;\n    }\n    fcn.0044fce5(param_1 + 0x26);\n    fcn.004045a1(0x469144);\n    return;\n}\n",
        "token_count": 191
    },
    "00456ac9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00456ac9(int32_t *param_1, int32_t param_2, uint param_3)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.0044fd3f(0x4770fc, param_2, param_3);\n    (*_sym.imp.ole32.dll_CoLockObjectExternal)(uVar1);\n    if ((param_2 != 0) && (*(param_1[8] + -0xc) != 0)) {\n        fcn.00456944();\n        (**(*param_1 + 0xe8))(param_1[8], 0);\n    }\n    return;\n}\n",
        "token_count": 150
    },
    "00456d70": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00456d70(int32_t **param_1)\n\n{\n    int32_t *piVar1;\n    \n    fcn.0044fce5(param_1 + 1);\n    piVar1 = *param_1;\n    if (piVar1 != NULL) {\n        if (param_1[3] != NULL) {\n            (**(*piVar1 + 8))(piVar1);\n        }\n        *param_1 = NULL;\n    }\n    param_1[2] = NULL;\n    return;\n}\n",
        "token_count": 118
    },
    "00456dc5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00456dc5(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t **in_ECX;\n    uint var_14h;\n    \n    if (in_ECX[2] == NULL) {\n        uVar2 = fcn.0044df67(arg_ch, arg_8h, &var_14h);\n        iVar3 = (**(**in_ECX + 0x14))(*in_ECX, uVar2);\n        uVar1 = iVar3 == 0;\n    }\n    else {\n        uVar1 = (*_sym.imp.USER32.dll_IsClipboardFormatAvailable)(arg_8h & 0xffff);\n    }\n    return uVar1;\n}\n",
        "token_count": 178
    },
    "00456e23": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00456e23(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *var_4h;\n    \n    if ((param_1[2] != 0) && (*param_1 == 0)) {\n        var_4h = param_1;\n        iVar1 = (*_sym.imp.ole32.dll_OleGetClipboard)(&var_4h);\n        if (iVar1 == 0) {\n            fcn.00456e0a(var_4h, 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 129
    },
    "00456e65": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.00456e65(int32_t **param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    \n    fcn.00456e23();\n    piVar1 = *param_1;\n    if ((param_2 != 0) && (piVar1 != NULL)) {\n        (**(*piVar1 + 4))(piVar1);\n    }\n    return piVar1;\n}\n",
        "token_count": 102
    },
    "00456eaa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00456eaa(uint arg_8h, int32_t arg_ch)\n\n{\n    uint16_t *puVar1;\n    int32_t iVar2;\n    int32_t **in_ECX;\n    uint var_2ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    fcn.00456e23();\n    if (*in_ECX == NULL) {\n        return 0;\n    }\n    puVar1 = fcn.0044df67(arg_ch, arg_8h, &var_2ch);\n    if (arg_ch == 0) {\n        *(puVar1 + 8) = 0x21;\n    }\n    iVar2 = (**(**in_ECX + 0xc))(*in_ECX, puVar1, &var_ch);\n    if (-1 < iVar2) {\n        if ((var_ch == 1) || (var_ch == 0x20)) {\n            if (var_4h == 0) {\n                return var_8h;\n            }\n            var_18h = 0;\n            var_10h = 0;\n            iVar2 = fcn.0044e444(*puVar1, &var_18h, &var_ch);\n            if (iVar2 != 0) {\n                (*_sym.imp.ole32.dll_ReleaseStgMedium)(&var_ch);\n                return var_14h;\n            }\n        }\n        (*_sym.imp.ole32.dll_ReleaseStgMedium)();\n    }\n    return 0;\n}\n",
        "token_count": 362
    },
    "00456f55": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00456f55(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t **in_ECX;\n    bool bVar3;\n    uint var_14h;\n    \n    fcn.00456e23();\n    if (*in_ECX == NULL) {\n        bVar3 = false;\n    }\n    else {\n        uVar1 = fcn.0044df67(arg_10h, arg_8h, &var_14h);\n        iVar2 = (**(**in_ECX + 0xc))(*in_ECX, uVar1, arg_ch);\n        bVar3 = -1 < iVar2;\n    }\n    return bVar3;\n}\n",
        "token_count": 169
    },
    "00457af6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00457af6(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CEnumArray.0;\n    pcVar1 = extraout_ECX[8];\n    *(unaff_EBP + -4) = 0;\n    if (pcVar1 != NULL) {\n        fcn.0044fd01();\n    }\n    if (extraout_ECX[0xc] != NULL) {\n        fcn.00425d0d(extraout_ECX[9]);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042aa3f();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 246
    },
    "0045771e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.0045771e(int32_t param_1, uint param_2, uint param_3)\n\n{\n    uint *puVar1;\n    uint arg_8h;\n    int32_t iVar2;\n    uint *unaff_EBX;\n    uint *puVar3;\n    \n    puVar1 = fcn.004571b6(param_2, param_3);\n    if (puVar1 == NULL) {\n        if ((*(param_1 + 0x1c) == 0) || (*(param_1 + 0x24) == *(param_1 + 0x20))) {\n            arg_8h = fcn.00425ce2((*(param_1 + 0x20) + *(param_1 + 0x28)) * 0x24);\n            *(param_1 + 0x20) = *(param_1 + 0x20) + *(param_1 + 0x28);\n            if (*(param_1 + 0x1c) != 0) {\n                fcn.0040e680(arg_8h, *(param_1 + 0x1c), *(param_1 + 0x24) * 0x24);\n                fcn.00425d0d(*(param_1 + 0x1c));\n            }\n            *(param_1 + 0x1c) = arg_8h;\n        }\n        puVar1 = *(param_1 + 0x1c) + *(param_1 + 0x24) * 0x24;\n        *(param_1 + 0x24) = *(param_1 + 0x24) + 1;\n    }\n    else {\n        (*_sym.imp.ole32.dll_CoTaskMemFree)(puVar1[1]);\n        (*_sym.imp.ole32.dll_ReleaseStgMedium)(puVar1 + 5);\n    }\n    puVar1[8] = param_3;\n    puVar3 = puVar1;\n    for (iVar2 = 5; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = *unaff_EBX;\n        unaff_EBX = unaff_EBX + 1;\n        puVar3 = puVar3 + 1;\n    }\n    return puVar1;\n}\n",
        "token_count": 514
    },
    "00458005": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00458005(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    code *pcVar1;\n    ushort uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    uint var_24h;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint var_14h;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    int32_t var_4h;\n    \n    iVar3 = fcn.00428388();\n    uVar4 = (*_sym.imp.USER32.dll_GetParent)(*(iVar3 + 0x1c));\n    iVar5 = fcn.004278de(uVar4);\n    pcVar1 = _sym.imp.USER32.dll_UpdateWindow;\n    var_4h = iVar5;\n    (*_sym.imp.USER32.dll_UpdateWindow)(*(iVar3 + 0x1c));\n    if (iVar5 != 0) {\n        (*pcVar1)(*(iVar5 + 0x1c));\n        (*_sym.imp.USER32.dll_GetClientRect)(*(iVar5 + 0x1c), &var_24h);\n        fcn.00431e21(&var_24h);\n        (*_sym.imp.USER32.dll_ClipCursor)(&var_24h);\n    }\n    var_24h = *(in_ECX + 0x98);\n    uStack36 = *(in_ECX + 0x9c);\n    uStack32 = *(in_ECX + 0xa0);\n    uStack28 = *(in_ECX + 0xa4);\n    iVar3 = fcn.004469e2(in_ECX, arg_ch, arg_10h, 0, var_4h);\n    var_14h = *(in_ECX + 0x98);\n    uStack20 = *(in_ECX + 0x9c);\n    uStack16 = *(in_ECX + 0xa0);\n    uStack12 = *(in_ECX + 0xa4);\n    *(in_ECX + 0x98) = var_24h;\n    *(in_ECX + 0x9c) = uStack36;\n    *(in_ECX + 0xa0) = uStack32;\n    *(in_ECX + 0xa4) = uStack28;\n    (*_sym.imp.USER32.dll_ClipCursor)(0);\n    if (iVar3 != 0) {\n        iVar3 = fcn.00405a6f();\n        fcn.00431e21(&var_14h);\n        fcn.00431de5(&var_14h);\n        uVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(in_ECX + 0x1c));\n        (*_sym.imp.USER32.dll_SendMessageA)(*(iVar3 + 0x1c), 0x369, uVar2, &var_14h);\n    }\n    return;\n}\n",
        "token_count": 666
    },
    "004582f6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004582f6(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.COleDropTarget.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[7] != NULL) {\n        fcn.00458156();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042aa3f();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 198
    },
    "00458928": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00458928(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = param_1 + 0x2f;\n    if (*piVar1 == 0) {\n        iVar2 = (**(*param_1 + 0xf0))();\n        *piVar1 = iVar2;\n        fcn.0044fea3();\n    }\n    return *piVar1;\n}\n",
        "token_count": 108
    },
    "004589bd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004589bd(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    if (in_ECX[0x22] != 0) {\n        fcn.00456944();\n        fcn.0045680e(in_ECX[0x22], arg_8h);\n        var_4h = (**(*in_ECX + 0xb4))();\n        while( true ) {\n            iVar2 = fcn.0044f0a8(&var_4h);\n            if (iVar2 == 0) break;\n            uVar1 = fcn.0045bb09(1);\n            fcn.0045c0d7(3, uVar1);\n            fcn.0044fce5();\n        }\n    }\n    return;\n}\n",
        "token_count": 195
    },
    "00458af6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00458af6(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    if (*(param_1 + 0xac) != NULL) {\n        iVar2 = (*_sym.imp.USER32.dll_InSendMessage)();\n        if (iVar2 == 0) {\n            piVar1 = *(param_1 + 0xac);\n            iVar2 = (**(*piVar1 + 0xc))(piVar1);\n            if (iVar2 != 0) {\n                fcn.0044e402(iVar2);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 139
    },
    "00458b7a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00458b7a(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    if (*(in_ECX + 0xac) == NULL) {\n        var_4h = fcn.00456532(arg_8h);\n    }\n    else {\n        piVar1 = *(in_ECX + 0xac);\n        var_4h = 0;\n        (**(*piVar1 + 0x10))(piVar1, arg_8h, 3, &var_4h);\n    }\n    return var_4h;\n}\n",
        "token_count": 144
    },
    "00458db9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00458db9(int32_t param_1)\n\n{\n    if (*(param_1 + 0xc0) != NULL) {\n    // WARNING: Could not recover jumptable at 0x00458dca. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(**(param_1 + 0xc0) + 0x178))();\n        return;\n    }\n    return;\n}\n",
        "token_count": 98
    },
    "00459d48": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00459d48(int32_t *arg_8h, int32_t *arg_ch, int32_t *arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    int32_t in_ECX;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar6 = *(in_ECX + 0xc0);\n    if (iVar6 == 0) {\n        if (arg_8h != NULL) {\n            *arg_8h = 1;\n            arg_8h[1] = 1;\n            *arg_ch = 1;\n            arg_ch[1] = arg_8h[1];\n        }\n        uVar3 = 0;\n    }\n    else {\n        if (arg_10h == NULL) {\n            arg_10h = iVar6 + 0x118;\n            iVar6 = *(iVar6 + 0x120) - *arg_10h;\n        }\n        else {\n            iVar6 = arg_10h[2] - *arg_10h;\n        }\n        iVar1 = arg_10h[3];\n        iVar2 = arg_10h[1];\n        var_8h = 0;\n        var_4h = 0;\n        piVar4 = fcn.00458928();\n        (**(*piVar4 + 100))(1, &var_8h);\n        if ((var_8h == 0) || (var_4h == 0)) {\n            (**(*piVar4 + 100))(1, &var_8h);\n        }\n        fcn.00445695(&var_8h);\n        if ((var_4h == 0) || (iVar5 = var_8h,  iVar7 = var_4h,  var_8h == 0)) {\n            iVar5 = iVar6;\n            iVar7 = iVar1 - iVar2;\n        }\n        if (arg_8h != NULL) {\n            *arg_8h = iVar6;\n            arg_8h[1] = iVar1 - iVar2;\n            *arg_ch = iVar5;\n            arg_ch[1] = iVar7;\n        }\n        uVar3 = fcn.004067b1(iVar5, iVar7);\n    }\n    return uVar3;\n}\n",
        "token_count": 558
    },
    "0045a480": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045a480(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t *arg_8h_00;\n    int32_t **ppiVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    arg_8h = *(arg_8h + 0x84);\njoined_r0x0045a496:\n    do {\n        if (arg_8h == 0) {\n            return;\n        }\n        ppiVar1 = fcn.00403b8b(&arg_8h);\n        arg_8h_00 = *ppiVar1;\n        if (arg_ch == 0) goto code_r0x0045a4d6;\n    } while ((*(*(in_ECX + 0xc0) + 0x13c) != 0) || ((arg_8h_00[0x1e] & 4U) == 0));\n    arg_8h_00[0x1e] = arg_8h_00[0x1e] & 0xfffffffb;\n    iVar2 = arg_ch;\n    goto code_r0x0045a4f6;\ncode_r0x0045a4d6:\n    iVar2 = (**(*arg_8h_00 + 0x150))();\n    if ((iVar2 != 0) && (iVar2 = fcn.00441d18(),  iVar2 == 0)) {\n        arg_8h_00[0x1e] = arg_8h_00[0x1e] | 4;\ncode_r0x0045a4f6:\n        fcn.0044283c(arg_8h_00, iVar2, 1);\n    }\n    goto joined_r0x0045a496;\n}\n",
        "token_count": 406
    },
    "0045b1e1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint fcn.0045b1e1(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    if (extraout_ECX[0x2b] == 0) {\n        uVar1 = (**(*extraout_ECX + 0x90))();\n    }\n    else {\n        (**(*extraout_ECX + 0xc4))();\n        iVar2 = (**(*extraout_ECX + 0x58))();\n        if (iVar2 == 0) {\n            uVar1 = 1;\n        }\n        else {\n            piVar3 = fcn.0042c770();\n            iVar2 = (**(*piVar3 + 0xc))();\n            *(unaff_EBP + -0x10) = iVar2 + 0x10;\n            iVar2 = extraout_ECX[7];\n            *(unaff_EBP + -4) = 0;\n            fcn.00440275(unaff_EBP + -0x10, 0xf187, iVar2);\n            iVar2 = fcn.0043c064(*(unaff_EBP + -0x10), 3, 0xf187);\n            if (iVar2 == 2) {\n                uVar1 = 0;\n            }\n            else {\n                if (iVar2 == 6) {\n                    (**(*extraout_ECX + 0xec))();\n                }\n                uVar1 = 1;\n            }\n            fcn.00403164();\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar1;\n}\n",
        "token_count": 454
    },
    "0045b2a7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0045b2a7(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    if (*(extraout_ECX + 0xac) != 0) {\n        piVar2 = fcn.0042c770();\n        iVar3 = (**(*piVar2 + 0xc))();\n        *(unaff_EBP + -0x10) = iVar3 + 0x10;\n        uVar1 = *(extraout_ECX + 0xb0);\n        *(unaff_EBP + -4) = 0;\n        fcn.00440275(unaff_EBP + -0x10, *(unaff_EBP + 8), uVar1);\n        if (*(*(unaff_EBP + -0x10) + -0xc) != 0) {\n            (**(**(unaff_EBP + 0xc) + 0xc))(*(unaff_EBP + -0x10));\n        }\n        fcn.00403164();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 357
    },
    "0045ba69": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045ba69(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint var_24h;\n    uint var_20h;\n    uint var_10h;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    piVar2 = fcn.0044fd3f(0x4776ec);\n    iVar3 = (**(*piVar2 + 0x20))(piVar2, 1, &var_4h);\n    if (iVar3 == 0) {\n        iVar3 = (**(*var_4h + 0xc))(var_4h, 1, &var_24h, 0);\n        pcVar1 = _sym.imp.ole32.dll_CoTaskMemFree;\n        while (iVar3 == 0) {\n            iVar3 = (**(*piVar2 + 0xc))(piVar2, &var_24h, &var_10h);\n            if (iVar3 == 0) {\n                if (var_8h != 0) {\n                    (*_sym.imp.ole32.dll_ReleaseStgMedium)(&var_10h);\n                    goto code_r0x0045baba;\n                }\n                fcn.004577fc(0, &var_10h, &var_24h);\n            }\n            else {\ncode_r0x0045baba:\n                (*pcVar1)(var_20h);\n            }\n            iVar3 = (**(*var_4h + 0xc))(var_4h, 1, &var_24h, 0);\n        }\n        (**(*var_4h + 8))(var_4h);\n    }\n    return;\n}\n",
        "token_count": 390
    },
    "0045cc83": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0045cc83(uint arg_8h, uint hKey, uint32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    char *pcVar4;\n    bool bVar5;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.ADVAPI32.dll_RegSetValueA;\n    uVar1 = arg_10h & 1;\n    if ((uVar1 == 0) ||\n       ((iVar3 = (*_sym.imp.ADVAPI32.dll_RegSetValueA)(arg_8h, \"Insertable\", 1, 0x469144, 0),  iVar3 == 0 &&\n        (iVar3 = (*pcVar2)(hKey, \"Insertable\", 1, 0x469144, 0),  iVar3 == 0)))) {\n        pcVar4 = NULL;\n        if ((arg_10h & 2) != 0) {\n            pcVar4 = \"Apartment\";\n        }\n        if ((arg_10h & 4) != 0) {\n            pcVar4 = \"Free\";\n        }\n        if ((arg_10h & 6) == 6) {\n            pcVar4 = \"Both\";\n        }\n        if (pcVar4 == NULL) {\n            return true;\n        }\n        iVar3 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(hKey, \"InprocServer32\", 0, 0x20006, &arg_10h);\n        bVar5 = iVar3 == 0;\n        if (bVar5) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(pcVar4);\n            iVar3 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(arg_10h, \"ThreadingModel\", 0, 1, pcVar4, iVar3 + 1);\n            bVar5 = iVar3 == 0;\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(arg_10h);\n            if (bVar5) {\n                return true;\n            }\n        }\n    }\n    else {\n        bVar5 = false;\n    }\n    pcVar2 = _sym.imp.ADVAPI32.dll_RegDeleteValueA;\n    if (uVar1 != 0) {\n        (*_sym.imp.ADVAPI32.dll_RegDeleteValueA)(hKey, \"Insertable\");\n        (*pcVar2)(arg_8h, \"Insertable\");\n    }\n    return bVar5;\n}\n",
        "token_count": 560
    },
    "0045cdae": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: hKey\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint __cdecl fcn.0045cdae(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    char *arg_ch_00;\n    int32_t *piVar1;\n    int32_t iVar2;\n    char **ppcVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    uint hKey;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    piVar1 = fcn.0042c770();\n    iVar2 = (**(*piVar1 + 0xc))();\n    *(unaff_EBP + -0x14) = iVar2 + 0x10;\n    *(unaff_EBP + -4) = 0;\n    piVar1 = fcn.0042c770();\n    iVar2 = (**(*piVar1 + 0xc))();\n    *(unaff_EBP + -0x18) = iVar2 + 0x10;\n    *(unaff_EBP + -4) = 1;\n    *(unaff_EBP + -0x10) = 0;\n    if (*(unaff_EBP + 0x14) == -0x80000000) {\n        (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(0x80000000, \"CLSID\", 0, 0x20019, unaff_EBP + -0x10);\n    }\n    ppcVar3 = *(unaff_EBP + 8);\n    while (arg_ch_00 = *ppcVar3,  arg_ch_00 != NULL) {\n        ppcVar3 = ppcVar3 + 1;\n        if ((*(unaff_EBP + 0x14) != -0x80000000) || (*arg_ch_00 != '\\0')) {\n            fcn.0044010f(unaff_EBP + -0x14, arg_ch_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n            if ((*(unaff_EBP + 0x14) != -0x80000000) || (*(*(unaff_EBP + -0x14) + -0xc) != 0)) {\n                fcn.0044cfd2(*(unaff_EBP + -0x14));\n            }\n        }\n    }\n    if (*(unaff_EBP + -0x10) != 0) {\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(*(unaff_EBP + -0x10));\n    }\n    fcn.00403164();\n    fcn.00403164();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return 1;\n}\n",
        "token_count": 677
    },
    "0045ce7f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_124h\n// WARNING: Variable defined which should be unmapped: var_118h\n// WARNING: Variable defined which should be unmapped: lpData\n// WARNING: Variable defined which should be unmapped: var_120h\n// WARNING: Variable defined which should be unmapped: var_11ch\n// WARNING: Variable defined which should be unmapped: lpSubKey\n\nvoid __cdecl fcn.0045ce7f(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint hKey)\n\n{\n    char *arg_ch_00;\n    uint uVar1;\n    code *pcVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_124h;\n    uint var_120h;\n    uint var_11ch;\n    uint var_118h;\n    uint lpSubKey;\n    uint lpData;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = *0x496830;\n    piVar3 = fcn.0042c770();\n    iVar4 = (**(*piVar3 + 0xc))();\n    *(unaff_EBP + -0x118) = iVar4 + 0x10;\n    *(unaff_EBP + -4) = 0;\n    piVar3 = fcn.0042c770();\n    iVar4 = (**(*piVar3 + 0xc))();\n    *(unaff_EBP + -0x11c) = iVar4 + 0x10;\n    *(unaff_EBP + -4) = 1;\n    *(unaff_EBP + -0x120) = 0;\n    if (*(unaff_EBP + 0x18) == -0x80000000) {\n        (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(0x80000000, \"CLSID\", 0, 0x20019, unaff_EBP + -0x120);\n    }\n    arg_ch_00 = **(unaff_EBP + 8);\n    *(unaff_EBP + -0x124) = 1;\n    pcVar2 = _sym.imp.KERNEL32.dll_lstrlenA;\n    do {\n        if (arg_ch_00 == NULL) {\ncode_r0x0045cfe1:\n            if (*(unaff_EBP + -0x120) != 0) {\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(*(unaff_EBP + -0x120));\n            }\n            fcn.00403164();\n            fcn.00403164();\n            *in_FS_OFFSET = *(unaff_EBP + -0xc);\n            fcn.0040e60a();\n            return;\n        }\n        *(unaff_EBP + 8) = *(unaff_EBP + 8) + 4;\n        if ((*(unaff_EBP + 0x18) != -0x80000000) || (*arg_ch_00 != '\\0')) {\n            iVar4 = (*pcVar2)(arg_ch_00);\n            *(unaff_EBP + -0x114) = arg_ch_00 + iVar4 + 1;\n            fcn.0044010f(unaff_EBP + -0x118, arg_ch_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n            fcn.0044010f(unaff_EBP + -0x11c, *(unaff_EBP + -0x114), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n            iVar4 = *(unaff_EBP + -0x118);\n            if ((*(unaff_EBP + 0x18) != -0x80000000) || (*(iVar4 + -0xc) != 0)) {\n                if (*(unaff_EBP + 0x14) == 0) {\n                    *(unaff_EBP + -0x114) = 0x100;\n                    iVar4 = (*_sym.imp.ADVAPI32.dll_RegQueryValueA)\n                                      (*(unaff_EBP + 0x18), iVar4, unaff_EBP + -0x110, unaff_EBP + -0x114);\n                    if (iVar4 == 0) goto code_r0x0045cfc6;\n                    iVar4 = *(unaff_EBP + -0x118);\n                }\n                uVar1 = *(unaff_EBP + -0x11c);\n                *(unaff_EBP + -0x114) = iVar4;\n                uVar5 = (*pcVar2)(uVar1);\n                iVar4 = (*_sym.imp.ADVAPI32.dll_RegSetValueA)\n                                  (*(unaff_EBP + 0x18), *(unaff_EBP + -0x114), 1, uVar1, uVar5);\n                if (iVar4 != 0) {\n                    if (iVar4 != 5) {\n                        *(unaff_EBP + -0x124) = 0;\n                    }\n                    goto code_r0x0045cfe1;\n                }\n            }\n        }\ncode_r0x0045cfc6:\n        arg_ch_00 = **(unaff_EBP + 8);\n    } while( true );\n}\n",
        "token_count": 1208
    },
    "0045d095": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045d095(int32_t arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    uint arg_8h_00;\n    \n    if (arg_8h == 0) {\n        fcn.00401182(0x80070057);\n    }\n    uVar1 = fcn.0040f1f6(arg_8h, arg_ch);\n    arg_8h_00 = fcn.004043ec(uVar1);\n    fcn.0040f19f(arg_8h_00, arg_8h, arg_ch);\n    fcn.004042a8(uVar1);\n    return;\n}\n",
        "token_count": 148
    },
    "0045d333": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t __cdecl\nfcn.0045d333(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h, uint arg_28h, uint arg_2ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    arg_8h_00 = *(unaff_EBP + 0x1c);\n    iVar2 = *(unaff_EBP + 0x18);\n    if (arg_8h_00 == 0) {\n        arg_8h_00 = *(iVar2 * 8 + 0x470b08);\n    }\n    iVar1 = *(unaff_EBP + 0x20);\n    if (iVar1 == 0) {\n        iVar1 = fcn.0044be10();\n        if (*(iVar1 + 0x14) == '\\0') {\n            iVar1 = *(iVar2 * 8 + 0x470b0c);\n        }\n        else {\n            iVar1 = *(iVar2 * 8 + 0x470b34);\n        }\n    }\n    fcn.0045cbe4(10);\n    iVar3 = 0;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = fcn.0045d0f3(unaff_EBP + -0x14, *(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), \n                         *(unaff_EBP + 0x14), *(unaff_EBP + 0x24), *(unaff_EBP + 0x28), *(unaff_EBP + 0x2c));\n    if (((iVar2 != 0) && (iVar3 = fcn.0045ce7f(arg_8h_00, *(unaff_EBP + -0x14), 10, 0, 0x80000000),  iVar3 != 0)) &&\n       (iVar1 != 0)) {\n        iVar3 = fcn.0045ce7f(iVar1, *(unaff_EBP + -0x14), 10, 1, 0x80000000);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0045cc11();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar3;\n}\n",
        "token_count": 644
    },
    "0045d3f0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t __cdecl\nfcn.0045d3f0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    arg_8h_00 = *(unaff_EBP + 0x1c);\n    iVar2 = *(unaff_EBP + 0x18);\n    if (arg_8h_00 == 0) {\n        arg_8h_00 = *(iVar2 * 8 + 0x470b08);\n    }\n    iVar1 = *(unaff_EBP + 0x20);\n    if (iVar1 == 0) {\n        iVar1 = fcn.0044be10();\n        if (*(iVar1 + 0x14) == '\\0') {\n            iVar1 = *(iVar2 * 8 + 0x470b0c);\n        }\n        else {\n            iVar1 = *(iVar2 * 8 + 0x470b34);\n        }\n    }\n    fcn.0045cbe4(10);\n    iVar3 = 0;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = fcn.0045d0f3(unaff_EBP + -0x14, *(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), \n                         *(unaff_EBP + 0x14), 0, 0, 0);\n    if (((iVar2 != 0) && (iVar3 = fcn.0045cdae(arg_8h_00, *(unaff_EBP + -0x14), 10, 0x80000000),  iVar3 != 0)) &&\n       (iVar1 != 0)) {\n        iVar3 = fcn.0045cdae(iVar1, *(unaff_EBP + -0x14), 10, 0x80000000);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0045cc11();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar3;\n}\n",
        "token_count": 593
    },
    "0045da88": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_58h\n\nuint __cdecl fcn.0045da88(uint arg_8h, uint lprcSrc, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint uVar3;\n    uint extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t *piVar4;\n    uint *in_FS_OFFSET;\n    uint var_58h;\n    uint lpPoint;\n    uint yBottom;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    fcn.0045d9dc();\n    piVar4 = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -4) = 0;\n    if (piVar4 == NULL) {\n        piVar4 = unaff_EBP + -0x58;\n    }\n    piVar4[0xc] = 0;\n    if (*(unaff_EBP + 0xc) == 0) {\n        (*_sym.imp.USER32.dll_GetCursorPos)(unaff_EBP + -0x1c);\n        (*_sym.imp.USER32.dll_SetRect)\n                  (piVar4 + 8, *(unaff_EBP + -0x1c), *(unaff_EBP + -0x18), *(unaff_EBP + -0x1c), *(unaff_EBP + -0x18));\n    }\n    else {\n        (*_sym.imp.USER32.dll_CopyRect)(piVar4 + 8, *(unaff_EBP + 0xc));\n    }\n    iVar1 = fcn.00404990();\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.USER32.dll_IsRectEmpty)(piVar4 + 8);\n        if (iVar1 != 0) {\n            (*_sym.imp.USER32.dll_InflateRect)(piVar4 + 8, *0x49988c, *0x49988c);\n        }\n    }\n    else {\n        piVar4[0xc] = 1;\n    }\n    iVar1 = *piVar4;\n    uVar2 = fcn.004049c2();\n    iVar1 = (**(iVar1 + 0x58))(uVar2);\n    if (iVar1 == 0) {\n        uVar2 = 0;\n    }\n    else {\n        uVar2 = fcn.0044fd3f(0x4776ec);\n        uVar3 = fcn.0044fd3f(0x475fbc);\n        *(unaff_EBP + -0x10) = 0;\n        (*_sym.imp.ole32.dll_DoDragDrop)(uVar2, uVar3, *(unaff_EBP + 8), unaff_EBP + -0x10);\n        uVar2 = *(unaff_EBP + -0x10);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042aa3f();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 720
    },
    "0045dbf5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0045dbf5(uint arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    pcVar1 = _sym.imp.ole32.dll_CoCreateInstance;\n    var_4h = NULL;\n    in_ECX[1] = 1;\n    var_8h = (*pcVar1)(arg_8h, 0, 0x17, 0x4770fc, &var_4h);\n    if (var_8h == -0x7ff8ffa9) {\n        var_8h = (*pcVar1)(arg_8h, 0, 7, 0x4770fc, &var_4h);\n    }\n    if ((-1 < var_8h) && (var_8h = (*_sym.imp.ole32.dll_OleRun)(var_4h),  -1 < var_8h)) {\n        iVar2 = fcn.0044fcc1(var_4h, 0x47708c);\n        *in_ECX = iVar2;\n        if (iVar2 != 0) {\n            (**(*var_4h + 8))(var_4h);\n            return 1;\n        }\n    }\n    fcn.0044fce5(&var_4h);\n    if (arg_ch != 0) {\n        *(arg_ch + 8) = var_8h;\n    }\n    return 0;\n}\n",
        "token_count": 354
    },
    "0045dc94": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0045dc94(int32_t **param_1)\n\n{\n    int32_t *piVar1;\n    \n    piVar1 = *param_1;\n    if (piVar1 != NULL) {\n        if (param_1[1] != NULL) {\n            (**(*piVar1 + 8))(piVar1);\n        }\n        *param_1 = NULL;\n    }\n    return;\n}\n",
        "token_count": 93
    },
    "0045e386": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0045e386(int32_t arg_8h, int16_t **arg_ch, uint *arg_10h)\n\n{\n    int16_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    ulong *puVar4;\n    uint *puVar5;\n    ulong *puVar6;\n    uint pvargDest;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    puVar6 = &pvargDest;\n    var_4h = 0;\n    fcn.00409fff(puVar6);\n    puVar5 = *arg_ch;\n    iVar1 = *(arg_8h + 0xc);\n    if ((iVar1 != 0xc) && (*puVar5 != iVar1)) {\n        var_4h = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&pvargDest, puVar5, 0, iVar1);\n        if (var_4h < 0) {\n            *arg_10h = 0;\n            return var_4h;\n        }\n        puVar5 = &pvargDest;\n    }\n    puVar4 = *(arg_8h + 0x18) + var_8h;\n    uVar2 = *(arg_8h + 0xc) - 2;\n    if (0x13 < uVar2) {\ncode_r0x0045e457:\n        var_4h = -0x7ffdfff8;\ncode_r0x0045e45e:\n        *arg_10h = 0;\n        goto code_r0x0045e464;\n    }\n    // switch table (20 cases) at 0x45e48a\n    switch(*(uVar2 * 4 + 0x45e48a)) {\n    case 0x45e3f3:\n        *puVar4 = *(puVar5 + 2);\n        break;\n    case 0x45e3fa:\n        *puVar4 = *(puVar5 + 2);\n        break;\n    case 0x45e403:\n        *puVar4 = *(puVar5 + 2);\n        break;\n    case 0x45e40a:\n        *puVar4 = puVar5[2];\n        *(puVar4 + 4) = puVar5[3];\n        break;\n    case 0x45e417:\n        fcn.0044c189(puVar4, puVar5[2]);\n        break;\n    case 0x45e422:\n        uVar2 = *(puVar5 + 2) != 0;\ncode_r0x0045e453:\n        *puVar4 = uVar2;\n        break;\n    case 0x45e42d:\n        iVar3 = (*_sym.imp.OLEAUT32.dll_VariantCopyInd)(puVar4, puVar5);\n        if (iVar3 == 0) break;\n        goto code_r0x0045e45e;\n    case 0x45e43b:\n        if (puVar5[2] != 0) {\n            (**(*puVar5[2] + 4))(puVar5[2]);\n        }\n        puVar6 = puVar4;\n        fcn.0044fce5();\n    case 0x45e450:\n        uVar2 = puVar5[2];\n        goto code_r0x0045e453;\n    case 0x45e457:\n        goto code_r0x0045e457;\n    }\ncode_r0x0045e464:\n    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&pvargDest, puVar6);\n    if ((-1 < var_4h) && (*(arg_8h + 0x14) != NULL)) {\n        (**(arg_8h + 0x14))();\n    }\n    return var_4h;\n}\n",
        "token_count": 862
    },
    "0045e6b2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.0045e6b2(uint32_t *arg_8h, uint8_t *arg_ch, uint32_t arg_10h, int32_t arg_14h, int32_t *arg_18h, int32_t *arg_1ch, \n            int32_t arg_20h)\n\n{\n    int16_t *piVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    bool bVar4;\n    uint uVar5;\n    uint uVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int16_t iVar9;\n    uint32_t in_ECX;\n    int16_t *piVar10;\n    ulong *puVar11;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    *arg_8h = in_ECX;\n    puVar11 = arg_8h + 1;\n    if ((arg_14h == 6) || (arg_14h == 0xc)) {\n        *puVar11 = arg_10h;\n        puVar11 = arg_8h + 2;\n    }\n    iVar3 = *arg_18h;\n    bVar4 = false;\n    arg_14h = arg_18h[2];\n    var_4h = arg_18h[3];\n    uVar2 = *arg_ch;\n    do {\n        if (uVar2 == 0) {\ncode_r0x0045e889:\n            if (arg_14h < 1) {\n                if (*arg_ch == 0) {\n                    iVar8 = 0;\n                }\n                else {\n                    *arg_1ch = arg_18h[2];\n                    iVar8 = -0x7ffdfff1;\n                }\n            }\n            else {\n                iVar8 = -0x7ffdfff2;\ncode_r0x0045e894:\n                *arg_1ch = arg_14h;\n            }\n            return iVar8;\n        }\n        uVar2 = *arg_ch;\n        arg_8h = in_ECX & 0xffff0000 | uVar2;\n        arg_14h = arg_14h + -1;\n        if ((uVar2 != 0xff) && ((uVar2 & 0x40) != 0)) {\n            arg_8h = uVar2 & 0xffbf | 0x4000;\n        }\n        iVar9 = arg_8h;\n        if (arg_14h < var_4h) {\n            if (iVar9 == 0xff) {\n                arg_14h = arg_18h[3];\n                var_4h = 0;\n                bVar4 = true;\n                goto code_r0x0045e879;\n            }\n            if ((!bVar4) && (iVar9 == 0xc)) {\n                *0x4998c8 = 10;\n                *0x4998d0 = 0x80020004;\n                piVar10 = 0x4998c8;\n                goto code_r0x0045e81c;\n            }\n            goto code_r0x0045e889;\n        }\n        if (iVar9 == 0xff) goto code_r0x0045e889;\n        piVar1 = arg_14h * 0x10 + iVar3;\n        piVar10 = piVar1;\n        if ((iVar9 != 0xc) && (iVar9 != *piVar1)) {\n            piVar10 = arg_20h + arg_14h * 0x10;\n            arg_10h = 8;\n            if (iVar9 != 0xe) {\n                arg_10h = arg_8h;\n            }\n            if ((*piVar1 != arg_10h) &&\n               (iVar8 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(piVar10, piVar1, 0, arg_10h),  iVar8 < 0))\n            goto code_r0x0045e894;\n            if (iVar9 == 0xe) {\n                if (*piVar1 == arg_10h) {\n                    uVar6 = fcn.0044beef();\n                    *(piVar10 + 4) = uVar6;\n                    *piVar10 = 8;\n                }\n                else {\n                    uVar6 = *(piVar10 + 4);\n                    uVar5 = fcn.0044beef(uVar6);\n                    *(piVar10 + 4) = uVar5;\n                    (*_sym.imp.OLEAUT32.dll_SysStringLen)(uVar6);\n                }\n                arg_8h = 0x8;\n            }\n        }\ncode_r0x0045e81c:\n        if ((arg_8h & 0x4000) != 0) {\ncode_r0x0045e871:\n            uVar7 = *(piVar10 + 4);\n            goto code_r0x0045e874;\n        }\n    // switch table (20 cases) at 0x45e8bb\n        switch(arg_8h & 0xffff) {\n        case 2:\n            uVar7 = piVar10[4];\n            break;\n        case 3:\n        case 4:\n        case 8:\n        case 9:\n        case 10:\n        case 0xd:\n        case 0x13:\n            goto code_r0x0045e871;\n        case 5:\n        case 7:\n            *puVar11 = *(piVar10 + 4);\n            goto code_r0x0045e856;\n        case 6:\n        case 0x14:\n        case 0x15:\n            *puVar11 = *(piVar10 + 4);\n            *(puVar11 + 4) = *(piVar10 + 6);\ncode_r0x0045e856:\n            puVar11 = puVar11 + 1;\n            goto code_r0x0045e879;\n        case 0xb:\n            uVar7 = piVar10[4] != 0;\n            break;\n        case 0xc:\n            *puVar11 = piVar10;\n            goto code_r0x0045e876;\n        default:\n            goto code_r0x0045e879;\n        case 0x10:\n            uVar7 = *(piVar10 + 4);\n            break;\n        case 0x11:\n            uVar7 = *(piVar10 + 4);\n            break;\n        case 0x12:\n            uVar7 = piVar10[4];\n        }\ncode_r0x0045e874:\n        *puVar11 = uVar7;\ncode_r0x0045e876:\n        puVar11 = puVar11 + 4;\ncode_r0x0045e879:\n        arg_ch = arg_ch + 1;\n        uVar2 = *arg_ch;\n        in_ECX = arg_8h;\n    } while( true );\n}\n",
        "token_count": 1525
    },
    "0045f5bd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** __cdecl fcn.0045f5bd(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int16_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00425c43();\n    *extraout_ECX = vtable.COleDispatchException.0;\n    fcn.00403c40();\n    *(unaff_EBP + -4) = 0;\n    fcn.00403c40();\n    fcn.00403c40();\n    iVar1 = *(unaff_EBP + 0x10);\n    iVar3 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 2;\n    extraout_ECX[4] = -(*(unaff_EBP + 0xc) != 0) & *(unaff_EBP + 0xc) + 0x60000U;\n    *(extraout_ECX + 2) = iVar1;\n    if (iVar3 != 0) {\n        fcn.004045a1(*(unaff_EBP + 8));\n    }\n    uVar2 = *(unaff_EBP + -0xc);\n    extraout_ECX[7] = (-(iVar1 != 0) & 0x7fff0001) + 0x8000ffff;\n    *in_FS_OFFSET = uVar2;\n    return extraout_ECX;\n}\n",
        "token_count": 428
    },
    "0045fbcf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0045fbcf(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CPreviewView.0;\n    *(unaff_EBP + -4) = 1;\n    fcn.00432165();\n    pcVar1 = extraout_ECX[0x4c];\n    if (pcVar1 != NULL) {\n        fcn.0046149d();\n        fcn.00425d0d(pcVar1);\n    }\n    fcn.00425d0d(extraout_ECX[0x29]);\n    if (extraout_ECX[0x23] != NULL) {\n        (**(*extraout_ECX[0x23] + 4))(1);\n    }\n    if (extraout_ECX[0x47] != NULL) {\n        uVar2 = (*_sym.imp.USER32.dll_LoadCursorA)(0, 0x7f00);\n        (*_sym.imp.USER32.dll_SetCursor)(uVar2);\n        (*_sym.imp.USER32.dll_DestroyCursor)(extraout_ECX[0x47]);\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.004321ac();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00434b78();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 427
    },
    "0045fd41": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0045fd41(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    uVar1 = fcn.00428388();\n    iVar2 = fcn.0042c6eb(0x469824, uVar1);\n    if (iVar2 == 0) {\n        uVar1 = fcn.004049c2();\n    }\n    uVar1 = fcn.0042c6eb(0x469824, uVar1);\n    if ((*(param_1 + 0xa8) != 0) && (*(*(param_1 + 0xa8) + 0x50) != 0)) {\n        iVar2 = fcn.0042c6eb(0x468ccc, uVar1);\n        if ((iVar2 != 0) && (*(param_1 + 0x50) != 0)) {\n            piVar3 = fcn.0042c6eb(0x46c7d4, *(param_1 + 0x50));\n            if (piVar3 != NULL) {\n                (**(**(param_1 + 0xa8) + 0x60))();\n                *(param_1 + 0xa8) = 0;\n                *(iVar2 + 0x13c) = 0;\n                (**(*piVar3 + 0x110))(1);\n            }\n        }\n    }\n    if (*(param_1 + 0xa8) != NULL) {\n        (**(**(param_1 + 0xa8) + 0x60))();\n    }\n    *(param_1 + 0xa8) = 0;\n    *(*(param_1 + 0x130) + 0x14) = *(param_1 + 0x110);\n    (**(**(param_1 + 0x84) + 0x17c))(*(param_1 + 0x8c), *(param_1 + 0x130), 0, 0, param_1);\n    return;\n}\n",
        "token_count": 460
    },
    "0045fe4a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045fe4a(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    fcn.004355ba(&var_8h, &var_10h);\n    if (((*(in_ECX + 0x108) == 0) && (*(*(**(in_ECX + 0x130) + 0x70) + 0x1e) != -1)) &&\n       (iVar1 = *(**(in_ECX + 0x130) + 0x70),  *(iVar1 + 0x1e) != *(iVar1 + 0x1c))) {\n        var_8h = var_8h - var_10h;\n    }\n    *(in_ECX + 0x118) = (var_8h + -8) / 2;\n    if (*(in_ECX + 0x114) == 2) {\n        var_8h = (var_8h + -0x18) / 2;\n    }\n    else {\n        var_8h = var_8h + -0x10;\n    }\n    *arg_8h = var_8h;\n    arg_8h[1] = var_4h + -0x10;\n    return;\n}\n",
        "token_count": 317
    },
    "0045fed1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045fed1(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t in_ECX;\n    int32_t *piVar7;\n    uint xRight;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar6 = arg_8h * 0x28 + *(in_ECX + 0xac);\n    fcn.0045fe4a(&var_8h);\n    iVar5 = *(iVar6 + 0x24);\n    iVar1 = *(in_ECX + 0x108);\n    bVar2 = iVar5 <= *(iVar6 + 0x20);\n    if (iVar1 == 0) {\n        *(iVar6 + 0x18) = *(iVar6 + 0x20);\n        uVar4 = *(iVar6 + 0x24);\ncode_r0x0045ff55:\n        *(iVar6 + 0x1c) = uVar4;\n    }\n    else {\n        if (iVar1 == 1) {\n            *(iVar6 + 0x1c) = iVar5;\n            if (bVar2) {\n                iVar5 = *(iVar6 + 0x20) * 3 - iVar5;\n            }\n            else {\n                iVar5 = *(iVar6 + 0x20) + iVar5;\n            }\n            iVar5 = iVar5 / 2;\n        }\n        else {\n            if (iVar1 != 2) goto code_r0x0045ff58;\n            if (!bVar2) {\n                uVar4 = 1;\n                *(iVar6 + 0x18) = 1;\n                goto code_r0x0045ff55;\n            }\n            *(iVar6 + 0x1c) = *(iVar6 + 0x24);\n            iVar5 = *(iVar6 + 0x20) * 2 - *(iVar6 + 0x24);\n        }\n        *(iVar6 + 0x18) = iVar5;\n    }\ncode_r0x0045ff58:\n    iVar5 = (*_sym.imp.KERNEL32.dll_MulDiv)(*(iVar6 + 0x10), *(iVar6 + 0x18), *(iVar6 + 0x1c));\n    iVar6 = (*_sym.imp.KERNEL32.dll_MulDiv)(*(iVar6 + 0x14), *(iVar6 + 0x18), *(iVar6 + 0x1c));\n    piVar7 = *(in_ECX + 0xac) + arg_8h * 0x28;\n    (*_sym.imp.USER32.dll_SetRect)(piVar7, 8, 8, iVar5 + 0xb, iVar6 + 0xb);\n    pcVar3 = _sym.imp.USER32.dll_OffsetRect;\n    if (*(in_ECX + 0x108) == 0) {\n        (*_sym.imp.USER32.dll_OffsetRect)\n                  (piVar7, (var_8h - (piVar7[2] - *piVar7)) / 2 + -1, (var_4h - (piVar7[3] - piVar7[1])) / 2 + -1);\n        if (arg_8h == 1) {\n            (*pcVar3)(piVar7, *(in_ECX + 0x118), 0);\n        }\n    }\n    else {\n        fcn.00435de0(1, (piVar7[2] - *piVar7) + 0x10, (piVar7[3] - piVar7[1]) + 0x10, &var_8h, 0x46dfec);\n    }\n    return;\n}\n",
        "token_count": 845
    },
    "004600e5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004600e5(int32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_8h;\n    \n    if (*(in_ECX + 0x108) != 0) {\n        piVar1 = fcn.0043520f(&var_8h);\n        iVar2 = piVar1[1];\n        *arg_8h = *arg_8h + *piVar1;\n        arg_8h[1] = arg_8h[1] + iVar2;\n    }\n    *arg_ch = 0;\n    if (*(in_ECX + 0x114) != 0) {\n        do {\n            iVar2 = (*_sym.imp.USER32.dll_PtInRect)(*(in_ECX + 0xac) + *arg_ch * 0x28, *arg_8h, arg_8h[1]);\n            if (iVar2 != 0) {\n                iVar2 = *(*(in_ECX + 0xac) + 4 + *arg_ch * 0x28);\n                *arg_8h = *arg_8h - *(*(in_ECX + 0xac) + *arg_ch * 0x28);\n                arg_8h[1] = arg_8h[1] - iVar2;\n                iVar2 = *(in_ECX + 0xac) + *arg_ch * 0x28;\n                iVar2 = (*_sym.imp.KERNEL32.dll_MulDiv)(*arg_8h, *(iVar2 + 0x1c), *(iVar2 + 0x18));\n                *arg_8h = iVar2;\n                iVar2 = *(in_ECX + 0xac) + *arg_ch * 0x28;\n                iVar2 = (*_sym.imp.KERNEL32.dll_MulDiv)(arg_8h[1], *(iVar2 + 0x1c), *(iVar2 + 0x18));\n                arg_8h[1] = iVar2;\n                return 1;\n            }\n            *arg_ch = *arg_ch + 1;\n        } while (*arg_ch < *(in_ECX + 0x114));\n    }\n    return 0;\n}\n",
        "token_count": 505
    },
    "0046029d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0046029d(uint noname_0, int32_t arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t *piVar3;\n    uint var_8h;\n    \n    if (arg_ch == 1) {\n        (*_sym.imp.USER32.dll_GetCursorPos)(&var_8h);\n        (*_sym.imp.USER32.dll_ScreenToClient)(*(in_ECX + 0x1c), &var_8h);\n        if ((*(in_ECX + 0x108) == 2) || (iVar2 = fcn.004600e5(&var_8h, &arg_ch),  iVar2 == 0)) {\n            iVar2 = (*_sym.imp.USER32.dll_LoadCursorA)(0, 0x7f00);\n        }\n        else {\n            piVar3 = in_ECX + 0x11c;\n            if (*piVar3 == 0) {\n                iVar2 = fcn.0044be10();\n                iVar2 = (*_sym.imp.USER32.dll_LoadCursorA)(*(iVar2 + 0xc), 0x7902);\n                *piVar3 = iVar2;\n            }\n            iVar2 = *piVar3;\n        }\n        (*_sym.imp.USER32.dll_SetCursor)(iVar2);\n        return 0;\n    }\n    uVar1 = fcn.0042783b();\n    return uVar1;\n}\n",
        "token_count": 326
    },
    "00460b70": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00460b70(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t in_stack_0000000c;\n    \n    if (in_ECX[0x42] != 0) {\n        if (((in_stack_0000000c == 0) || (iVar1 = fcn.00427e61(0),  iVar1 == 0)) &&\n           (iVar1 = (**(*in_ECX + 0x70))(1),  in_stack_0000000c == iVar1)) {\n            (**(*in_ECX + 0x134))((arg_8h & 0xff) << 8 | 0xff, arg_ch, 1);\n        }\n        return;\n    }\n    if (arg_8h == 0) {\n        arg_ch = in_ECX[0x44] - 1;\n    }\n    else if (arg_8h == 1) {\n        arg_ch = in_ECX[0x44] + 1;\n    }\n    else if (arg_8h == 2) {\n        arg_ch = in_ECX[0x44] - ((*(*(*in_ECX[0x4c] + 0x70) + 0x1e) - *(*(*in_ECX[0x4c] + 0x70) + 0x1c)) + 9) / 10;\n    }\n    else if (arg_8h == 3) {\n        arg_ch = ((*(*(*in_ECX[0x4c] + 0x70) + 0x1e) - *(*(*in_ECX[0x4c] + 0x70) + 0x1c)) + 9) / 10 + in_ECX[0x44];\n    }\n    else if (arg_8h != 4) {\n        if (arg_8h == 6) {\n            arg_ch = *(*(*in_ECX[0x4c] + 0x70) + 0x1c);\n        }\n        else {\n            if (arg_8h != 7) {\n                return;\n            }\n            arg_ch = *(*(*in_ECX[0x4c] + 0x70) + 0x1e);\n        }\n    }\n    fcn.004601ab(arg_ch, 1);\n    return;\n}\n",
        "token_count": 538
    },
    "004612a2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004612a2(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    var_4h = in_ECX;\n    iVar1 = fcn.004600e5(&arg_ch, &var_4h);\n    if (iVar1 != 0) {\n        if (*(in_ECX + 0x108) == 2) {\n            iVar1 = 0;\n        }\n        else {\n            iVar1 = *(in_ECX + 0x108) + 1;\n        }\n        fcn.00461127(iVar1, var_4h, arg_ch, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 173
    },
    "004620d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004620d0(void)\n\n{\n    uint uVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CMetaFileDC.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[1] != NULL) {\n        uVar1 = fcn.00432165();\n        uVar1 = (*_sym.imp.GDI32.dll_CloseMetaFile)(uVar1);\n        (*_sym.imp.GDI32.dll_DeleteMetaFile)(uVar1);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004321ac();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 258
    },
    "0046211c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0046211c(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    int32_t var_8h;\n    int32_t Y;\n    \n    if (*(in_ECX + 8) != 0) {\n        var_8h = in_ECX;\n        Y = in_ECX;\n        uVar1 = (*_sym.imp.GDI32.dll_GetTextAlign)(*(in_ECX + 8));\n        if ((uVar1 & 6) != 6) {\n            if ((uVar1 & 6) == 2) {\n                arg_8h = -arg_8h;\n            }\n            fcn.00408da7(&var_8h);\n            (*_sym.imp.GDI32.dll_MoveToEx)(*(in_ECX + 8), var_8h + arg_8h, Y, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 211
    },
    "0046296f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0046296f(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint uVar4;\n    \n    pcVar2 = _sym.imp.GDI32.dll_GetStockObject;\n    if (param_1[1] != 0) {\n        uVar4 = (*_sym.imp.GDI32.dll_GetStockObject)(7);\n        pcVar3 = _sym.imp.GDI32.dll_SelectObject;\n        uVar4 = (*_sym.imp.GDI32.dll_SelectObject)(param_1[2], uVar4);\n        (*pcVar3)(param_1[2], uVar4);\n        (*pcVar3)(param_1[1], uVar4);\n        uVar4 = (*pcVar2)(4);\n        uVar4 = (*pcVar3)(param_1[2], uVar4);\n        (*pcVar3)(param_1[2], uVar4);\n        (*pcVar3)(param_1[1], uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetROP2)(param_1[2]);\n        fcn.004315a9(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetBkMode)(param_1[2]);\n        fcn.0043154d(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetTextAlign)(param_1[2]);\n        fcn.0043181b(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetPolyFillMode)(param_1[2]);\n        fcn.0043157b(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetStretchBltMode)(param_1[2]);\n        fcn.004315d7(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetTextColor)(param_1[2]);\n        pcVar2 = _sym.imp.GDI32.dll_GetNearestColor;\n        iVar1 = *param_1;\n        uVar4 = (*_sym.imp.GDI32.dll_GetNearestColor)(param_1[2], uVar4);\n        (**(iVar1 + 0x30))(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetBkColor)(param_1[2]);\n        iVar1 = *param_1;\n        uVar4 = (*pcVar2)(param_1[2], uVar4);\n        (**(iVar1 + 0x2c))(uVar4);\n    }\n    return;\n}\n",
        "token_count": 579
    },
    "00462a49": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00462a49(int32_t *param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t aiStack152 [3];\n    int32_t iStack140;\n    uint uStack132;\n    uint uStack124;\n    uchar uStack104;\n    uchar uStack103;\n    uchar uStack102;\n    uint8_t uStack101;\n    uchar uStack100;\n    int32_t iStack96;\n    int32_t iStack92;\n    int32_t iStack88;\n    uchar auStack84 [4];\n    int32_t iStack80;\n    uchar auStack76 [4];\n    int32_t iStack72;\n    int32_t iStack68;\n    uint uStack64;\n    uint uStack52;\n    uchar uStack48;\n    uchar uStack47;\n    uchar uStack46;\n    uchar uStack45;\n    uint8_t uStack41;\n    uchar auStack40 [32];\n    uint uStack8;\n    \n    uStack8 = *0x496830;\n    if (param_1[2] != 0) {\n        if (param_1[0xb] == 0) {\n            (**(*param_1 + 0x24))(0xe);\n        }\n        else if (param_1[1] != 0) {\n            (*_sym.imp.GDI32.dll_GetObjectA)(param_1[0xb], 0x3c, &iStack68);\n            (*_sym.imp.GDI32.dll_GetTextFaceA)(param_1[2], 0x20, auStack40);\n            pcVar1 = _sym.imp.GDI32.dll_GetTextMetricsA;\n            (*_sym.imp.GDI32.dll_GetTextMetricsA)(param_1[2], aiStack152);\n            pcVar2 = _sym.imp.GDI32.dll_CreateFontIndirectA;\n            if (aiStack152[0] < 0) {\n                iStack68 = aiStack152[0];\n            }\n            else {\n                iStack68 = iStack140 - aiStack152[0];\n            }\n            uStack64 = uStack132;\n            uStack52 = uStack124;\n            uStack48 = uStack104;\n            uStack47 = uStack103;\n            uStack46 = uStack102;\n            uStack45 = uStack100;\n            uStack41 = uStack101;\n            iStack88 = (*_sym.imp.GDI32.dll_CreateFontIndirectA)(&iStack68);\n            (*_sym.imp.GDI32.dll_SelectObject)(param_1[1], iStack88);\n            (*pcVar1)(param_1[1], aiStack152);\n            iVar4 = -iStack68;\n            if (aiStack152[0] < 0) {\n                iStack92 = -aiStack152[0];\n            }\n            else {\n                iStack92 = aiStack152[0] - iStack140;\n            }\n            (*_sym.imp.GDI32.dll_GetWindowExtEx)(param_1[1], auStack76);\n            (*_sym.imp.GDI32.dll_GetViewportExtEx)(param_1[1], auStack84);\n            pcVar1 = _sym.imp.KERNEL32.dll_MulDiv;\n            if (iStack72 < 0) {\n                iStack72 = -iStack72;\n            }\n            if (iStack80 < 0) {\n                iStack80 = -iStack80;\n            }\n            iStack96 = (*_sym.imp.KERNEL32.dll_MulDiv)(iVar4, iStack80, iStack72);\n            iVar3 = (*pcVar1)(iStack92, iStack80, iStack72);\n            iVar4 = iStack88;\n            if (iStack96 < iVar3) {\n                auStack40[0] = 0;\n                uStack41 = ((uStack41 & 0xf0) != 0x50) - 1U & 0x50;\n                iVar4 = (*pcVar2)(&iStack68);\n                (*_sym.imp.GDI32.dll_SelectObject)(param_1[1], iVar4);\n                (*_sym.imp.GDI32.dll_DeleteObject)(iStack88);\n            }\n            fcn.004367b8(param_1 + 10);\n            param_1[10] = iVar4;\n        }\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 971
    },
    "0046321e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0046321e(int32_t param_1)\n\n{\n    uint X;\n    uint var_ch;\n    int32_t lpPoint;\n    int32_t Y;\n    \n    if ((*(param_1 + 8) != 0) && (*(param_1 + 4) != 0)) {\n        (*_sym.imp.GDI32.dll_GetViewportOrgEx)(*(param_1 + 8), &lpPoint);\n        fcn.00463110(&lpPoint);\n        Y = Y + *(param_1 + 0x24);\n        lpPoint = lpPoint + *(param_1 + 0x20);\n        (*_sym.imp.GDI32.dll_SetViewportOrgEx)(*(param_1 + 4), lpPoint, Y, 0);\n        (*_sym.imp.GDI32.dll_GetWindowOrgEx)(*(param_1 + 8), &X);\n        (*_sym.imp.GDI32.dll_SetWindowOrgEx)(*(param_1 + 4), X, var_ch, 0);\n    }\n    return;\n}\n",
        "token_count": 231
    },
    "00463308": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00463308(int32_t param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    \n    if (param_2 != 0) {\n        piVar1 = param_1 + 0x38;\n        (*_sym.imp.GDI32.dll_GetViewportExtEx)(*(param_1 + 8), piVar1);\n        piVar2 = param_1 + 0x30;\n        (*_sym.imp.GDI32.dll_GetWindowExtEx)(*(param_1 + 8), piVar2);\n        while ((((-0x4000 < *piVar2 && (*piVar2 < 0x4000)) && (iVar5 = *piVar1,  -0x4000 < iVar5)) && (iVar5 < 0x4000)))\n        {\n            *piVar2 = *piVar2 * 2;\n            *piVar1 = iVar5 * 2;\n        }\n        while (((pcVar3 = _sym.imp.GDI32.dll_GetDeviceCaps,  -0x4000 < *(param_1 + 0x34) && (*(param_1 + 0x34) < 0x4000)\n                ) && ((iVar5 = *(param_1 + 0x3c),  -0x4000 < iVar5 && (iVar5 < 0x4000))))) {\n            *(param_1 + 0x34) = *(param_1 + 0x34) * 2;\n            *(param_1 + 0x3c) = iVar5 * 2;\n        }\n        uVar4 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(*(param_1 + 8), 0x58);\n        iVar5 = fcn.004625c4(*piVar1, *(param_1 + 0x10), *0x4995d0, *(param_1 + 0x14), uVar4);\n        *piVar1 = iVar5;\n        uVar4 = (*pcVar3)(*(param_1 + 8), 0x5a);\n        uVar4 = fcn.004625c4(*(param_1 + 0x3c), *(param_1 + 0x10), *0x4995d4, *(param_1 + 0x14), uVar4);\n        *(param_1 + 0x3c) = uVar4;\n    }\n    if (*(param_1 + 4) != 0) {\n        (*_sym.imp.GDI32.dll_SetMapMode)(*(param_1 + 4), 8);\n        (*_sym.imp.GDI32.dll_SetWindowExtEx)(*(param_1 + 4), *(param_1 + 0x30), *(param_1 + 0x34), 0);\n        (*_sym.imp.GDI32.dll_SetViewportExtEx)(*(param_1 + 4), *(param_1 + 0x38), *(param_1 + 0x3c), 0);\n        fcn.0046321e();\n    }\n    return;\n}\n",
        "token_count": 712
    },
    "004634f8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004634f8(int32_t param_1, uint param_2, uint param_3)\n\n{\n    *(param_1 + 0x10) = param_2;\n    *(param_1 + 0x14) = param_3;\n    if (*(param_1 + 8) != 0) {\n        fcn.00463308(1);\n        fcn.00462a49();\n    }\n    return;\n}\n",
        "token_count": 102
    },
    "00463648": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00463648(int32_t param_1)\n\n{\n    if (*(param_1 + 0x46) != '\\0') {\n        if (*(param_1 + 0x20) != 0) {\n            (*_sym.imp.ole32.dll_CoRevokeClassObject)(*(param_1 + 0x20));\n            *(param_1 + 0x20) = 0;\n        }\n        *(param_1 + 0x46) = 0;\n    }\n    return;\n}\n",
        "token_count": 116
    },
    "00463744": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid fcn.00463744(void)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    *extraout_ECX = vtable.CDocManager.0;\n    pcVar1 = extraout_ECX[2];\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = pcVar1;\n    while (pcVar1 != NULL) {\n        *(unaff_EBP + -0x14) = pcVar1;\n        ppiVar3 = fcn.00403b8b(unaff_EBP + -0x10);\n        piVar2 = *ppiVar3;\n        if (piVar2[7] != 0) {\n            fcn.004247cf(*(unaff_EBP + -0x14));\n            (**(*piVar2 + 4))(1);\n        }\n        pcVar1 = *(unaff_EBP + -0x10);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042486f();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 410
    },
    "004637bb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004637bb(int32_t param_1)\n\n{\n    if (*(param_1 + 0x1c) != 0) {\n        (*_sym.imp.ole32.dll_CoRegisterMessageFilter)(0, 0);\n        *(param_1 + 0x1c) = 0;\n    }\n    return;\n}\n",
        "token_count": 78
    },
    "0040fe1d": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040fe1d(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *arg_8h_00;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040daac(0x4732e8, 0x14);\n    *(unaff_EBP + -0x20) = 0xffffffff;\n    fcn.00410d9c(0xd);\n    *(unaff_EBP + -4) = 0;\n    *0x499930 = 0;\n    iVar1 = *(unaff_EBP + 8);\n    if (iVar1 == -2) {\n        *0x499930 = 1;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetOEMCP)();\n    }\n    else if (iVar1 == -3) {\n        *0x499930 = 1;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetACP)();\n    }\n    else if (iVar1 == -4) {\n        *0x499930 = 1;\n        iVar1 = *0x499c24;\n    }\n    *(unaff_EBP + 8) = iVar1;\n    arg_8h_00 = *0x49af6c;\n    if (iVar1 == *0x49b084) {\n        *(unaff_EBP + -0x20) = 0;\n    }\n    else {\n        *(unaff_EBP + -0x24) = *0x49af6c;\n        if ((arg_8h_00 == NULL) || (*arg_8h_00 != 0)) {\n            arg_8h_00 = fcn.0040d946(0x220);\n            *(unaff_EBP + -0x24) = arg_8h_00;\n        }\n        if (arg_8h_00 != NULL) {\n            iVar1 = fcn.0040fc7d(*(unaff_EBP + 8));\n            *(unaff_EBP + -0x20) = iVar1;\n            if (iVar1 == 0) {\n                *arg_8h_00 = 0;\n                arg_8h_00[1] = *0x49b084;\n                arg_8h_00[2] = *0x49af70;\n                arg_8h_00[3] = *0x49af68;\n                for (iVar1 = 0; *(unaff_EBP + -0x1c) = iVar1,  iVar1 < 5; iVar1 = iVar1 + 1) {\n                    *(arg_8h_00 + iVar1 * 2 + 0x10) = *(iVar1 * 2 + 0x49b090);\n                }\n                for (iVar1 = 0; *(unaff_EBP + -0x1c) = iVar1,  iVar1 < 0x101; iVar1 = iVar1 + 1) {\n                    *(iVar1 + 0x1c + arg_8h_00) = *(iVar1 + 0x49af80);\n                }\n                for (iVar1 = 0; *(unaff_EBP + -0x1c) = iVar1,  *0x49af6c = arg_8h_00,  iVar1 < 0x100; iVar1 = iVar1 + 1)\n                {\n                    *(iVar1 + 0x11d + arg_8h_00) = *(iVar1 + 0x49b0a0);\n                }\n            }\n        }\n        if ((*(unaff_EBP + -0x20) == -1) && (arg_8h_00 != *0x49af6c)) {\n            fcn.0040d958(arg_8h_00);\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0040ff64();\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 916
    },
    "004011b6": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "get OS version"
        ],
        "decompiled_code": "\nvoid fcn.004011b6(uint param_1, uint param_2, uint param_3)\n\n{\n    uint8_t extraout_var;\n    \n    if ((*0x497748 & 1) == 0) {\n        *0x497748 = *0x497748 | 1;\n        (*_sym.imp.KERNEL32.dll_GetVersion)();\n        *0x497745 = extraout_var >> 7;\n    }\n    if (*0x497745 == 0) {\n        param_2 = param_3;\n    }\n    (*_sym.imp.KERNEL32.dll_InterlockedExchange)(param_1, param_2);\n    return;\n}\n",
        "token_count": 142
    },
    "00402665": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00402665(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    ushort unaff_SI;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        fcn.00434a73(2, *(param_1 + 0x14));\n    }\n    uVar1 = *(param_1 + 0x28) + 2;\n    if (*(param_1 + 0x2c) <= uVar1 && uVar1 != *(param_1 + 0x2c)) {\n        fcn.00430c53();\n    }\n    **(param_1 + 0x28) = unaff_SI;\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 2;\n    return param_1;\n}\n",
        "token_count": 195
    },
    "004026a1": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004026a1(int32_t param_1)\n\n{\n    ushort *unaff_ESI;\n    \n    if ((*(param_1 + 0x18) & 1) == 0) {\n        fcn.00434a73(4, *(param_1 + 0x14));\n    }\n    if (*(param_1 + 0x2c) < *(param_1 + 0x28) + 2U) {\n        fcn.00430cca((*(param_1 + 0x28) - *(param_1 + 0x2c)) + 2);\n    }\n    *unaff_ESI = **(param_1 + 0x28);\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 2;\n    return param_1;\n}\n",
        "token_count": 192
    },
    "00402833": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402833(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    \n    uVar1 = arg_8h;\n    if ((~*(arg_8h + 0x18) & 1) == 0) {\n        fcn.00402363(arg_8h, in_ECX + 0x1c);\n        fcn.004026a1(&arg_8h + 2);\n        *(in_ECX + 4) = arg_8h >> 0x10;\n    }\n    else {\n        fcn.00402337();\n        fcn.00402665(*(in_ECX + 4));\n    }\n    (**(*(in_ECX + 8) + 8))(uVar1);\n    return;\n}\n",
        "token_count": 181
    },
    "00402ae1": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402ae1(int32_t arg_8h, int32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    \n    uVar1 = arg_10h;\n    arg_10h = arg_ch;\n    if ((~*(arg_8h + 0x18) & 1) == 0) {\n        for (; uVar1 != 0; uVar1 = uVar1 - uVar2) {\n            uVar2 = 0xfffffff;\n            if (uVar1 < 0xfffffff) {\n                uVar2 = uVar1;\n            }\n            fcn.00430b26(arg_10h, uVar2 * 8);\n            arg_10h = arg_10h + uVar2 * 8;\n        }\n    }\n    else {\n        for (; uVar1 != 0; uVar1 = uVar1 - uVar2) {\n            uVar2 = 0xfffffff;\n            if (uVar1 < 0xfffffff) {\n                uVar2 = uVar1;\n            }\n            fcn.00431029(arg_10h, uVar2 * 8);\n            arg_10h = arg_10h + uVar2 * 8;\n        }\n    }\n    return;\n}\n",
        "token_count": 298
    },
    "0040680e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040680e(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uchar unaff_SI;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        fcn.00434a73(2, *(param_1 + 0x14));\n    }\n    uVar1 = *(param_1 + 0x28) + 1;\n    if (*(param_1 + 0x2c) <= uVar1 && uVar1 != *(param_1 + 0x2c)) {\n        fcn.00430c53();\n    }\n    **(param_1 + 0x28) = unaff_SI;\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 1;\n    return param_1;\n}\n",
        "token_count": 196
    },
    "00406846": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00406846(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint unaff_ESI;\n    uint unaff_retaddr;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        fcn.00434a73(2, *(param_1 + 0x14));\n    }\n    uVar2 = *(param_1 + 0x28) + 8;\n    if (*(param_1 + 0x2c) <= uVar2 && uVar2 != *(param_1 + 0x2c)) {\n        fcn.00430c53();\n    }\n    puVar1 = *(param_1 + 0x28);\n    *puVar1 = unaff_ESI;\n    puVar1[1] = unaff_retaddr;\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 8;\n    return param_1;\n}\n",
        "token_count": 232
    },
    "00406888": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00406888(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint unaff_ESI;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        fcn.00434a73(2, *(param_1 + 0x14));\n    }\n    uVar1 = *(param_1 + 0x28) + 4;\n    if (*(param_1 + 0x2c) <= uVar1 && uVar1 != *(param_1 + 0x2c)) {\n        fcn.00430c53();\n    }\n    **(param_1 + 0x28) = unaff_ESI;\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 4;\n    return param_1;\n}\n",
        "token_count": 197
    },
    "004068c3": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004068c3(int32_t param_1)\n\n{\n    uchar *unaff_ESI;\n    \n    if ((*(param_1 + 0x18) & 1) == 0) {\n        fcn.00434a73(4, *(param_1 + 0x14));\n    }\n    if (*(param_1 + 0x2c) < *(param_1 + 0x28) + 1U) {\n        fcn.00430cca((*(param_1 + 0x28) - *(param_1 + 0x2c)) + 1);\n    }\n    *unaff_ESI = **(param_1 + 0x28);\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 1;\n    return param_1;\n}\n",
        "token_count": 192
    },
    "00406902": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00406902(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint *unaff_ESI;\n    \n    if ((*(param_1 + 0x18) & 1) == 0) {\n        fcn.00434a73(4, *(param_1 + 0x14));\n    }\n    if (*(param_1 + 0x2c) < *(param_1 + 0x28) + 8U) {\n        fcn.00430cca((*(param_1 + 0x28) - *(param_1 + 0x2c)) + 8);\n    }\n    puVar1 = *(param_1 + 0x28);\n    *unaff_ESI = *puVar1;\n    unaff_ESI[1] = puVar1[1];\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 8;\n    return param_1;\n}\n",
        "token_count": 222
    },
    "0040694a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040694a(int32_t param_1)\n\n{\n    uint *unaff_ESI;\n    \n    if ((*(param_1 + 0x18) & 1) == 0) {\n        fcn.00434a73(4, *(param_1 + 0x14));\n    }\n    if (*(param_1 + 0x2c) < *(param_1 + 0x28) + 4U) {\n        fcn.00430cca((*(param_1 + 0x28) - *(param_1 + 0x2c)) + 4);\n    }\n    *unaff_ESI = **(param_1 + 0x28);\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 4;\n    return param_1;\n}\n",
        "token_count": 192
    },
    "0040ad3f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040ad3f(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint unaff_ESI;\n    uint unaff_retaddr;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        fcn.00434a73(2, *(param_1 + 0x14));\n    }\n    uVar2 = *(param_1 + 0x28) + 8;\n    if (*(param_1 + 0x2c) <= uVar2 && uVar2 != *(param_1 + 0x2c)) {\n        fcn.00430c53();\n    }\n    puVar1 = *(param_1 + 0x28);\n    *puVar1 = unaff_ESI;\n    puVar1[1] = unaff_retaddr;\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 8;\n    return param_1;\n}\n",
        "token_count": 234
    },
    "0040ad81": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040ad81(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint unaff_ESI;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        fcn.00434a73(2, *(param_1 + 0x14));\n    }\n    uVar1 = *(param_1 + 0x28) + 4;\n    if (*(param_1 + 0x2c) <= uVar1 && uVar1 != *(param_1 + 0x2c)) {\n        fcn.00430c53();\n    }\n    **(param_1 + 0x28) = unaff_ESI;\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 4;\n    return param_1;\n}\n",
        "token_count": 198
    },
    "0040adbc": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040adbc(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint unaff_ESI;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        fcn.00434a73(2, *(param_1 + 0x14));\n    }\n    uVar1 = *(param_1 + 0x28) + 4;\n    if (*(param_1 + 0x2c) <= uVar1 && uVar1 != *(param_1 + 0x2c)) {\n        fcn.00430c53();\n    }\n    **(param_1 + 0x28) = unaff_ESI;\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 4;\n    return param_1;\n}\n",
        "token_count": 198
    },
    "0040adf7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __fastcall fcn.0040adf7(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint unaff_ESI;\n    uint unaff_retaddr;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        fcn.00434a73(2, *(param_1 + 0x14));\n    }\n    uVar1 = *(param_1 + 0x28) + 8;\n    if (*(param_1 + 0x2c) <= uVar1 && uVar1 != *(param_1 + 0x2c)) {\n        fcn.00430c53();\n    }\n    **(param_1 + 0x28) = CONCAT44(unaff_retaddr, unaff_ESI);\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 8;\n    return param_1;\n}\n",
        "token_count": 227
    },
    "0040ae32": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040ae32(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint *unaff_ESI;\n    \n    if ((*(param_1 + 0x18) & 1) == 0) {\n        fcn.00434a73(4, *(param_1 + 0x14));\n    }\n    if (*(param_1 + 0x2c) < *(param_1 + 0x28) + 8U) {\n        fcn.00430cca((*(param_1 + 0x28) - *(param_1 + 0x2c)) + 8);\n    }\n    puVar1 = *(param_1 + 0x28);\n    *unaff_ESI = *puVar1;\n    unaff_ESI[1] = puVar1[1];\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 8;\n    return param_1;\n}\n",
        "token_count": 223
    },
    "0040ae7a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040ae7a(int32_t param_1)\n\n{\n    uint *unaff_ESI;\n    \n    if ((*(param_1 + 0x18) & 1) == 0) {\n        fcn.00434a73(4, *(param_1 + 0x14));\n    }\n    if (*(param_1 + 0x2c) < *(param_1 + 0x28) + 4U) {\n        fcn.00430cca((*(param_1 + 0x28) - *(param_1 + 0x2c)) + 4);\n    }\n    *unaff_ESI = **(param_1 + 0x28);\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 4;\n    return param_1;\n}\n",
        "token_count": 193
    },
    "0040aebc": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040aebc(int32_t param_1)\n\n{\n    ulong *unaff_ESI;\n    \n    if ((*(param_1 + 0x18) & 1) == 0) {\n        fcn.00434a73(4, *(param_1 + 0x14));\n    }\n    if (*(param_1 + 0x2c) < *(param_1 + 0x28) + 8U) {\n        fcn.00430cca((*(param_1 + 0x28) - *(param_1 + 0x2c)) + 8);\n    }\n    *unaff_ESI = **(param_1 + 0x28);\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 8;\n    return param_1;\n}\n",
        "token_count": 193
    },
    "0040aefe": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040aefe(int32_t param_1)\n\n{\n    uint *unaff_ESI;\n    \n    if ((*(param_1 + 0x18) & 1) == 0) {\n        fcn.00434a73(4, *(param_1 + 0x14));\n    }\n    if (*(param_1 + 0x2c) < *(param_1 + 0x28) + 4U) {\n        fcn.00430cca((*(param_1 + 0x28) - *(param_1 + 0x2c)) + 4);\n    }\n    *unaff_ESI = **(param_1 + 0x28);\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 4;\n    return param_1;\n}\n",
        "token_count": 192
    },
    "0040b174": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Removing unreachable block (ram,0x0040b237)\n\nvoid __cdecl fcn.0040b174(uint32_t *arg_8h, uint32_t arg_ch)\n\n{\n    uint8_t uVar1;\n    uint64_t uVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    uint32_t *in_ECX;\n    uint32_t uVar5;\n    bool bVar6;\n    ulong uVar7;\n    uint64_t uVar8;\n    int64_t iVar9;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_1h;\n    \n    if (in_ECX[2] != 0) {\n        *arg_8h = *in_ECX;\n        arg_8h[1] = in_ECX[1];\n        arg_8h[2] = in_ECX[2];\n        return;\n    }\n    uVar3 = in_ECX[1];\n    uVar5 = *in_ECX;\n    if (((uVar5 | uVar3) == 0) || (arg_ch == 0)) {\n        *arg_8h = 0;\n        arg_8h[1] = 0;\n        arg_8h[2] = 0;\n        return;\n    }\n    uVar1 = arg_ch >> 0x18 ^ uVar3 >> 0x18;\n    if ((uVar3 < 1) && (uVar3 < 0)) {\n        bVar6 = uVar5 != 0;\n        uVar5 = -uVar5;\n        uVar3 = -(uVar3 + bVar6);\n    }\n    uVar4 = fcn.0040f7b7(arg_ch);\n    uVar7 = fcn.0040f9b0(uVar3, 0, uVar4, 0);\n    if ((uVar7 >> 0x20 == 0) && (uVar7 < 0x80000001)) {\n        uVar8 = fcn.0040f9b0(uVar5, 0, uVar4, 0);\n        iVar9 = fcn.0040f9b0(uVar7, 0, 0, 1);\n        uVar2 = uVar8 + iVar9;\n        if (uVar8 <= uVar2) {\n            if (uVar1 < '\\0') {\n                uVar2 = CONCAT44(-((uVar2 >> 0x20) + (uVar2 != 0)), -uVar2);\n            }\n            if (-1 < (uVar2 >> 0x20 ^ arg_ch ^ in_ECX[1])) {\n                uVar3 = 0;\n                goto code_r0x0040b273;\n            }\n        }\n    }\n    uVar3 = 1;\n    if (uVar1 < '\\0') {\n        uVar2 = 0x8000000000000000;\n    }\n    else {\n        uVar2 = 0x7fffffffffffffff;\n    }\ncode_r0x0040b273:\n    *arg_8h = uVar2;\n    arg_8h[1] = uVar2 >> 0x20;\n    arg_8h[2] = uVar3;\n    return;\n}\n",
        "token_count": 754
    },
    "0040bb0d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid __cdecl\nfcn.0040bb0d(int32_t noname_0, uint noname_1, int32_t noname_2, uint noname_3, uint noname_4, uint noname_5, uint arg_8h\n            , uint arg_ch, uint arg_10h)\n\n{\n    uint unaff_EBP;\n    uint unaff_ESI;\n    int32_t iVar1;\n    uint unaff_retaddr;\n    int32_t var_ch;\n    \n    if ((~*(noname_0 + 0x18) & 1) == 0) {\n        iVar1 = noname_2;\n        if (noname_2 != 0) {\n            do {\n                fcn.0040b88e(noname_0, var_ch, noname_0, unaff_ESI, unaff_EBP, unaff_retaddr, noname_0, var_ch, noname_2\n                             , noname_3, noname_4, noname_5, arg_8h, arg_ch, arg_10h);\n                var_ch = var_ch + 0x10;\n                iVar1 = iVar1 + -1;\n            } while (iVar1 != 0);\n        }\n    }\n    else if (noname_2 != 0) {\n        do {\n            fcn.0040a512(var_ch);\n            fcn.0040b670();\n            var_ch = var_ch + 0x10;\n            noname_2 = noname_2 + -1;\n        } while (noname_2 != 0);\n    }\n    return;\n}\n",
        "token_count": 365
    },
    "0040ee70": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t fcn.0040ee70(uint32_t *param_1, uint32_t *param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint8_t uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint32_t *puVar8;\n    bool bVar9;\n    \n    uVar3 = param_3;\n    if (param_3 != 0) {\n        if (((param_1 | param_2) & 3) == 0) {\n            uVar3 = param_3 & 3;\n            param_3 = param_3 >> 2;\n            bVar9 = param_3 == 0;\n            puVar7 = param_1;\n            puVar8 = param_2;\n            if (!bVar9) {\n                do {\n                    param_1 = puVar7;\n                    param_2 = puVar8;\n                    if (param_3 == 0) break;\n                    param_3 = param_3 - 1;\n                    param_2 = puVar8 + 1;\n                    param_1 = puVar7 + 1;\n                    bVar9 = *puVar7 == *puVar8;\n                    puVar7 = param_1;\n                    puVar8 = param_2;\n                } while (bVar9);\n                if (!bVar9) {\n                    uVar3 = param_1[-1];\n                    uVar1 = param_2[-1];\n                    bVar9 = uVar3 < uVar1;\n                    if (((uVar3 == uVar1) &&\n                        (uVar5 = uVar3 >> 8,  uVar6 = uVar1 >> 8,  bVar9 = uVar5 < uVar6,  uVar5 == uVar6)) &&\n                       (uVar5 = uVar3 >> 0x10,  uVar6 = uVar1 >> 0x10,  bVar9 = uVar5 < uVar6,  uVar5 == uVar6)) {\n                        bVar9 = uVar3 >> 0x18 < uVar1 >> 0x18;\n                    }\n                    goto code_r0x0040eef0;\n                }\n            }\n            if (uVar3 != 0) {\n                uVar1 = *param_1;\n                uVar2 = *param_2;\n                bVar9 = uVar1 < uVar2;\n                if (uVar1 != uVar2) {\ncode_r0x0040eef0:\n                    return (1 - bVar9) - (bVar9 != 0);\n                }\n                uVar4 = uVar3 - 1;\n                if (uVar4 != 0) {\n                    uVar5 = uVar2 >> 8;\n                    uVar6 = uVar1 >> 8;\n                    bVar9 = uVar6 < uVar5;\n                    if (uVar6 != uVar5) goto code_r0x0040eef0;\n                    uVar4 = uVar3 - 2;\n                    if (uVar4 != 0) {\n                        bVar9 = (uVar1 & 0xff0000) < (uVar2 & 0xff0000);\n                        if ((uVar1 & 0xff0000) != (uVar2 & 0xff0000)) goto code_r0x0040eef0;\n                        uVar4 = uVar3 - 3;\n                    }\n                }\n                return uVar4;\n            }\n        }\n        else {\n            if ((param_3 & 1) == 0) goto code_r0x0040eea3;\n            bVar9 = *param_1 < *param_2;\n            if (*param_1 != *param_2) goto code_r0x0040eef0;\n            param_1 = param_1 + 1;\n            param_2 = param_2 + 1;\n            for (param_3 = param_3 - 1; uVar3 = param_3,  param_3 != 0; param_3 = param_3 - 2) {\ncode_r0x0040eea3:\n                bVar9 = *param_1 < *param_2;\n                if ((*param_1 != *param_2) ||\n                   (bVar9 = *(param_1 + 1) < *(param_2 + 1),  *(param_1 + 1) != *(param_2 + 1))) goto code_r0x0040eef0;\n                param_2 = param_2 + 2;\n                param_1 = param_1 + 2;\n            }\n        }\n    }\n    return uVar3;\n}\n",
        "token_count": 1054
    },
    "00413b40": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t fcn.00413b40(uint *param_1, uint8_t *param_2)\n\n{\n    uint16_t uVar1;\n    uint uVar2;\n    uint8_t uVar3;\n    bool bVar4;\n    \n    if ((param_1 & 3) != 0) {\n        if ((param_1 & 1) != 0) {\n            uVar3 = *param_1;\n            param_1 = param_1 + 1;\n            bVar4 = uVar3 < *param_2;\n            if (uVar3 != *param_2) goto code_r0x00413b84;\n            param_2 = param_2 + 1;\n            if (uVar3 == 0) {\n                return 0;\n            }\n            if ((param_1 & 2) == 0) goto code_r0x00413b50;\n        }\n        uVar1 = *param_1;\n        param_1 = param_1 + 2;\n        uVar3 = uVar1;\n        bVar4 = uVar3 < *param_2;\n        if (uVar3 != *param_2) goto code_r0x00413b84;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        uVar3 = uVar1 >> 8;\n        bVar4 = uVar3 < param_2[1];\n        if (uVar3 != param_2[1]) goto code_r0x00413b84;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        param_2 = param_2 + 2;\n    }\ncode_r0x00413b50:\n    while( true ) {\n        uVar2 = *param_1;\n        uVar3 = uVar2;\n        bVar4 = uVar3 < *param_2;\n        if (uVar3 != *param_2) break;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        uVar3 = uVar2 >> 8;\n        bVar4 = uVar3 < param_2[1];\n        if (uVar3 != param_2[1]) break;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        uVar3 = uVar2 >> 0x10;\n        bVar4 = uVar3 < param_2[2];\n        if (uVar3 != param_2[2]) break;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        uVar3 = uVar2 >> 0x18;\n        bVar4 = uVar3 < param_2[3];\n        if (uVar3 != param_2[3]) break;\n        param_2 = param_2 + 4;\n        param_1 = param_1 + 1;\n        if (uVar3 == 0) {\n            return 0;\n        }\n    }\ncode_r0x00413b84:\n    return bVar4 * -2 + 1;\n}\n",
        "token_count": 678
    },
    "00413e10": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00413e10(uint32_t arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t arg_8h_00;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    piVar2 = arg_ch;\n    uVar1 = arg_ch[3];\n    arg_8h_00 = arg_ch[4];\n    if (((uVar1 & 0x82) == 0) || ((uVar1 & 0x40) != 0)) {\ncode_r0x00413f1c:\n        arg_ch[3] = uVar1 | 0x20;\n    }\n    else {\n        if ((uVar1 & 1) != 0) {\n            arg_ch[1] = 0;\n            if ((uVar1 & 0x10) == 0) goto code_r0x00413f1c;\n            *arg_ch = arg_ch[2];\n            arg_ch[3] = uVar1 & 0xfffffffe;\n        }\n        uVar1 = arg_ch[3];\n        arg_ch[1] = 0;\n        arg_ch = NULL;\n        piVar2[3] = uVar1 & 0xffffffef | 2;\n        if (((uVar1 & 0x10c) == 0) &&\n           (((piVar2 != 0x4970b0 && (piVar2 != 0x4970d0)) || (iVar3 = fcn.00418bc0(arg_8h_00),  iVar3 == 0)))) {\n            fcn.00418b7c(piVar2);\n        }\n        if ((*(piVar2 + 3) & 0x108) == 0) {\n            iVar3 = 1;\n            arg_ch = fcn.00418ad1(arg_8h_00, &arg_8h, 1);\n        }\n        else {\n            iVar4 = piVar2[2];\n            iVar3 = *piVar2;\n            *piVar2 = iVar4 + 1;\n            iVar3 = iVar3 - iVar4;\n            piVar2[1] = piVar2[6] + -1;\n            if (iVar3 < 1) {\n                if (arg_8h_00 == 0xffffffff) {\n                    iVar4 = 0x496d20;\n                }\n                else {\n                    iVar4 = *((arg_8h_00 >> 5) * 4 + 0x49ae40) + (arg_8h_00 & 0x1f) * 0x24;\n                }\n                if ((*(iVar4 + 4) & 0x20) != 0) {\n                    fcn.00418858(arg_8h_00, 0, 2);\n                }\n            }\n            else {\n                arg_ch = fcn.00418ad1(arg_8h_00, iVar4, iVar3);\n            }\n            *piVar2[2] = arg_8h;\n        }\n        if (arg_ch == iVar3) {\n            return arg_8h & 0xff;\n        }\n        piVar2[3] = piVar2[3] | 0x20;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 731
    },
    "00418858": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00418858(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040daac(0x473e10, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x49ae2c) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x49ae40;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.0041c548(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                puVar3 = fcn.00410979();\n                *puVar3 = 9;\n                puVar3 = fcn.00410982();\n                *puVar3 = 0;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.004187e4(arg_8h_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.004188df();\n            goto code_r0x004188fd;\n        }\n    }\n    puVar3 = fcn.00410979();\n    *puVar3 = 9;\n    puVar3 = fcn.00410982();\n    *puVar3 = 0;\ncode_r0x004188fd:\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 513
    },
    "00418ad1": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00418ad1(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040daac(0x473e20, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x49ae2c) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x49ae40;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.0041c548(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                puVar3 = fcn.00410979();\n                *puVar3 = 9;\n                puVar3 = fcn.00410982();\n                *puVar3 = 0;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.00418903(arg_8h_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00418b58();\n            goto code_r0x00418b76;\n        }\n    }\n    puVar3 = fcn.00410979();\n    *puVar3 = 9;\n    puVar3 = fcn.00410982();\n    *puVar3 = 0;\ncode_r0x00418b76:\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 516
    },
    "0041afc9": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041afc9(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint var_7ch;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    uVar1 = fcn.0041af77();\n    iVar2 = (**0x499d68)(uVar1, (-(*0x499d58 != 0) & 0xfffff005) + 0x1002, &var_7ch, 0x78);\n    if (iVar2 == 0) {\n        *0x499d48 = 0;\n    }\n    else {\n        iVar2 = fcn.0041d105(*0x499d5c, &var_7ch);\n        if ((iVar2 == 0) && (iVar2 = fcn.0041ae76(uVar1),  iVar2 != 0)) {\n            *0x499d48 = *0x499d48 | 4;\n            *0x499d4c = uVar1;\n            *0x499d50 = uVar1;\n        }\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 267
    },
    "0041b0ce": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041b0ce(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uint arg_ch;\n    uint var_7ch;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    arg_8h_00 = fcn.0041af77();\n    iVar1 = (**0x499d68)(arg_8h_00, (-(*0x499d58 != 0) & 0xfffff005) + 0x1002, &var_7ch, 0x78);\n    if (iVar1 == 0) {\n        *0x499d48 = 0;\n        goto code_r0x0041b2db;\n    }\n    iVar1 = fcn.0041d105(*0x499d5c, &var_7ch);\n    if (iVar1 == 0) {\n        iVar1 = (**0x499d68)(arg_8h_00, (-(*0x499d54 != 0) & 0xfffff002) + 0x1001, &var_7ch, 0x78);\n        if (iVar1 != 0) {\n            iVar1 = fcn.0041d105(*0x499d64, &var_7ch);\n            if (iVar1 == 0) {\n                *0x499d48 = *0x499d48 | 0x304;\n                *0x499d4c = arg_8h_00;\n                *0x499d50 = arg_8h_00;\n            }\n            else if ((*0x499d48 & 2) == 0) {\n                if ((*0x499d60 == 0) || (iVar1 = fcn.0041d16e(*0x499d64, &var_7ch, *0x499d60),  iVar1 != 0)) {\n                    if (((*0x499d48 & 1) == 0) && (iVar1 = fcn.0041ae76(arg_8h_00),  iVar1 != 0)) {\n                        *0x499d48 = *0x499d48 | 1;\n                        *0x499d50 = arg_8h_00;\n                    }\n                }\n                else {\n                    *0x499d48 = *0x499d48 | 2;\n                    *0x499d50 = arg_8h_00;\n                    iVar1 = fcn.0040e9c0(*0x499d64);\n                    if (iVar1 == *0x499d60) {\n                        *0x499d4c = arg_8h_00;\n                    }\n                }\n            }\n            goto code_r0x0041b1f9;\n        }\ncode_r0x0041b22d:\n        *0x499d48 = 0;\n        goto code_r0x0041b2db;\n    }\ncode_r0x0041b1f9:\n    if ((*0x499d48 & 0x300) == 0x300) goto code_r0x0041b2db;\n    iVar1 = (**0x499d68)(arg_8h_00, (-(*0x499d54 != 0) & 0xfffff002) + 0x1001, &var_7ch, 0x78);\n    if (iVar1 == 0) goto code_r0x0041b22d;\n    iVar1 = fcn.0041d105(*0x499d64, &var_7ch);\n    if (iVar1 == 0) {\n        *0x499d48 = *0x499d48 | 0x200;\n        if (((*0x499d54 == 0) && (*0x499d60 != 0)) && (iVar1 = fcn.0040e9c0(*0x499d64),  iVar1 == *0x499d60)) {\n            arg_ch = 1;\n            goto code_r0x0041b2ab;\n        }\n    }\n    else {\n        if (((*0x499d54 != 0) || (*0x499d60 == 0)) ||\n           (iVar1 = fcn.0041d16e(*0x499d64, &var_7ch, *0x499d60),  iVar1 != 0)) goto code_r0x0041b2db;\n        arg_ch = 0;\ncode_r0x0041b2ab:\n        iVar1 = fcn.0041b05d(arg_8h_00, arg_ch);\n        if (iVar1 == 0) goto code_r0x0041b2db;\n    }\n    *0x499d48 = *0x499d48 | 0x100;\n    if (*0x499d4c == 0) {\n        *0x499d4c = arg_8h_00;\n    }\ncode_r0x0041b2db:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 1120
    },
    "0041be61": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t fcn.0041be61(void)\n\n{\n    uint32_t uVar1;\n    uint16_t uVar2;\n    uint16_t unaff_BX;\n    \n    uVar1 = 0;\n    if ((unaff_BX & 1) != 0) {\n        uVar1 = 0x10;\n    }\n    if ((unaff_BX & 4) != 0) {\n        uVar1 = uVar1 | 8;\n    }\n    if ((unaff_BX & 8) != 0) {\n        uVar1 = uVar1 | 4;\n    }\n    if ((unaff_BX & 0x10) != 0) {\n        uVar1 = uVar1 | 2;\n    }\n    if ((unaff_BX & 0x20) != 0) {\n        uVar1 = uVar1 | 1;\n    }\n    if ((unaff_BX & 2) != 0) {\n        uVar1 = uVar1 | 0x80000;\n    }\n    uVar2 = unaff_BX & 0xc00;\n    if ((unaff_BX & 0xc00) != 0) {\n        if (uVar2 == 0x400) {\n            uVar1 = uVar1 | 0x100;\n        }\n        else if (uVar2 == 0x800) {\n            uVar1 = uVar1 | 0x200;\n        }\n        else if (uVar2 == 0xc00) {\n            uVar1 = uVar1 | 0x300;\n        }\n    }\n    if ((unaff_BX & 0x300) == 0) {\n        uVar1 = uVar1 | 0x20000;\n    }\n    else if ((unaff_BX & 0x300) == 0x200) {\n        uVar1 = uVar1 | 0x10000;\n    }\n    if ((unaff_BX & 0x1000) != 0) {\n        uVar1 = uVar1 | 0x40000;\n    }\n    return uVar1;\n}\n",
        "token_count": 473
    },
    "0041c507": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint fcn.0041c507(uint32_t param_1)\n\n{\n    uint *puVar1;\n    \n    if ((param_1 < *0x49ae2c) &&\n       (puVar1 = *((param_1 >> 5) * 4 + 0x49ae40) + (param_1 & 0x1f) * 0x24,  (*(puVar1 + 1) & 1) != 0)) {\n        return *puVar1;\n    }\n    puVar1 = fcn.00410979();\n    *puVar1 = 9;\n    puVar1 = fcn.00410982();\n    *puVar1 = 0;\n    return 0xffffffff;\n}\n",
        "token_count": 160
    },
    "0041c60a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041c60a(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0040daac(0x475318, 0x14);\n    *(unaff_EBP + -0x1c) = 0xffffffff;\n    iVar2 = fcn.00410cfc(0xb);\n    if (iVar2 != 0) {\n        fcn.00410d9c(0xb);\n        *(unaff_EBP + -4) = 0;\n        for (iVar2 = 0; *(unaff_EBP + -0x24) = iVar2,  iVar2 < 0x40; iVar2 = iVar2 + 1) {\n            puVar4 = *(iVar2 * 4 + 0x49ae40);\n            if (puVar4 == NULL) {\n                puVar4 = fcn.0040d946(0x480);\n                *(unaff_EBP + -0x20) = puVar4;\n                if (puVar4 != NULL) {\n                    piVar1 = iVar2 * 4 + 0x49ae40;\n                    *piVar1 = puVar4;\n                    *0x49ae2c = *0x49ae2c + 0x20;\n                    while (puVar4 < *piVar1 + 0x480) {\n                        *(puVar4 + 1) = 0;\n                        *puVar4 = 0xffffffff;\n                        *(puVar4 + 5) = 10;\n                        puVar4[2] = 0;\n                        puVar4 = puVar4 + 9;\n                        *(unaff_EBP + -0x20) = puVar4;\n                    }\n                    *(unaff_EBP + -0x1c) = iVar2 << 5;\n                    iVar2 = fcn.0041c548(iVar2 << 5);\n                    if (iVar2 == 0) {\n                        *(unaff_EBP + -0x1c) = 0xffffffff;\n                    }\n                }\n                break;\n            }\n            for (; *(unaff_EBP + -0x20) = puVar4,  puVar4 < *(iVar2 * 4 + 0x49ae40) + 0x480; puVar4 = puVar4 + 9) {\n                if ((*(puVar4 + 1) & 1) == 0) {\n                    if (puVar4[2] == 0) {\n                        fcn.00410d9c(10);\n                        *(unaff_EBP + -4) = 1;\n                        if (puVar4[2] == 0) {\n                            iVar3 = fcn.004183bc(puVar4 + 3, 4000);\n                            if (iVar3 == 0) {\n                                fcn.0040e0da(unaff_EBP + -0x10, 0xffffffff);\n                                goto code_r0x0041c777;\n                            }\n                            puVar4[2] = puVar4[2] + 1;\n                        }\n                        *(unaff_EBP + -4) = 0;\n                        fcn.0041c6e3();\n                    }\n                    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(puVar4 + 3);\n                    if ((*(puVar4 + 1) & 1) == 0) {\n                        *puVar4 = 0xffffffff;\n                        *(unaff_EBP + -0x1c) = (puVar4 - *(iVar2 * 4 + 0x49ae40)) / 0x24 + iVar2 * 0x20;\n                        break;\n                    }\n                    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar4 + 3);\n                }\n            }\n            if (*(unaff_EBP + -0x1c) != -1) break;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0041c77d();\n    }\ncode_r0x0041c777:\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 971
    },
    "0041cbe2": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint16_t __cdecl fcn.0041cbe2(uint arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t arg_8h_00;\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint var_4h;\n    \n    piVar2 = arg_ch;\n    uVar4 = arg_ch[3];\n    arg_8h_00 = arg_ch[4];\n    if (((uVar4 & 0x82) == 0) || ((uVar4 & 0x40) != 0)) {\ncode_r0x0041ccfb:\n        arg_ch[3] = uVar4 | 0x20;\n    }\n    else {\n        if ((uVar4 & 1) != 0) {\n            arg_ch[1] = 0;\n            if ((uVar4 & 0x10) == 0) goto code_r0x0041ccfb;\n            *arg_ch = arg_ch[2];\n            arg_ch[3] = uVar4 & 0xfffffffe;\n        }\n        uVar4 = arg_ch[3];\n        arg_ch[3] = uVar4 & 0xffffffef | 2;\n        arg_ch[1] = 0;\n        arg_ch = NULL;\n        if (((uVar4 & 0x10c) == 0) &&\n           (((piVar2 != 0x4970b0 && (piVar2 != 0x4970d0)) || (iVar3 = fcn.00418bc0(arg_8h_00),  iVar3 == 0)))) {\n            fcn.00418b7c(piVar2);\n        }\n        if ((*(piVar2 + 3) & 0x108) == 0) {\n            uVar4 = 2;\n            arg_ch = arg_ch & 0xffff0000 | arg_8h;\n            arg_ch = fcn.00418ad1(arg_8h_00, &arg_ch, 2);\n        }\n        else {\n            iVar3 = piVar2[2];\n            iVar1 = *piVar2;\n            *piVar2 = iVar3 + 2;\n            uVar4 = iVar1 - iVar3;\n            piVar2[1] = piVar2[6] + -2;\n            if (uVar4 < 1) {\n                if (arg_8h_00 == 0xffffffff) {\n                    iVar3 = 0x496d20;\n                }\n                else {\n                    iVar3 = *((arg_8h_00 >> 5) * 4 + 0x49ae40) + (arg_8h_00 & 0x1f) * 0x24;\n                }\n                if ((*(iVar3 + 4) & 0x20) != 0) {\n                    fcn.00418858(arg_8h_00, 0, 2);\n                }\n            }\n            else {\n                arg_ch = fcn.00418ad1(arg_8h_00, iVar3, uVar4);\n            }\n            *piVar2[2] = arg_8h;\n        }\n        if (arg_ch == uVar4) {\n            return arg_8h;\n        }\n        piVar2[3] = piVar2[3] | 0x20;\n    }\n    return 0xffff;\n}\n",
        "token_count": 751
    },
    "0041cee5": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041cee5(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040daac(0x475388, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x49ae2c) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x49ae40;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.0041c548(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                puVar3 = fcn.00410979();\n                *puVar3 = 9;\n                puVar3 = fcn.00410982();\n                *puVar3 = 0;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.0041cd0a(arg_8h_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0041cf6c();\n            goto code_r0x0041cf8a;\n        }\n    }\n    puVar3 = fcn.00410979();\n    *puVar3 = 9;\n    puVar3 = fcn.00410982();\n    *puVar3 = 0;\ncode_r0x0041cf8a:\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 520
    },
    "0041ea7f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041ea7f(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040daac(0x475410, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x49ae2c) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x49ae40;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.0041c548(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                puVar3 = fcn.00410979();\n                *puVar3 = 9;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.0041e9fc(arg_8h_00);\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0041eaf6();\n            goto code_r0x0041eb14;\n        }\n    }\n    puVar3 = fcn.00410979();\n    *puVar3 = 9;\n    puVar3 = fcn.00410982();\n    *puVar3 = 0;\ncode_r0x0041eb14:\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 467
    },
    "00427382": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00427382(int32_t *param_1, uint8_t param_2)\n\n{\n    bool bVar1;\n    bool bVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t unaff_EBX;\n    uint8_t unaff_retaddr;\n    \n    bVar1 = true;\n    bVar2 = false;\n    if (((param_2 & 4) == 0) || (uVar4 = fcn.0042a1c5(),  (uVar4 & 0x10000000) != 0)) {\n        bVar1 = false;\n    }\n    iVar5 = (*_sym.imp.USER32.dll_GetParent)(param_1[7]);\n    param_1[0xe] = param_1[0xe] | 0x18;\n    iVar6 = fcn.0042bc46();\n    pcVar3 = _sym.imp.USER32.dll_UpdateWindow;\ncode_r0x00427441:\n    while ((!bVar2 || (iVar7 = (*_sym.imp.USER32.dll_PeekMessageA)(iVar6, 0, 0, 0, 0),  iVar7 != 0))) {\n        do {\n            iVar7 = fcn.0042c09c();\n            if (iVar7 == 0) {\n                fcn.0046362c(0);\n                return -1;\n            }\n            if ((bVar1) && ((*(iVar6 + 4) == 0x118 || (*(iVar6 + 4) == 0x104)))) {\n                fcn.0042a2ea(1);\n                (*pcVar3)(param_1[7]);\n                bVar1 = false;\n            }\n            iVar7 = (**(*param_1 + 0x80))();\n            if (iVar7 == 0) {\n                param_1[0xe] = param_1[0xe] & 0xffffffe7;\n                return param_1[0x10];\n            }\n            iVar7 = fcn.0042bfbe(iVar6);\n            if (iVar7 != 0) {\n                bVar2 = true;\n                unaff_EBX = 0;\n            }\n            iVar7 = (*_sym.imp.USER32.dll_PeekMessageA)(iVar6, 0, 0, 0, 0);\n        } while (iVar7 != 0);\n    }\n    if (bVar1) {\n        fcn.0042a2ea(1);\n        (*pcVar3)(param_1[7]);\n        bVar1 = false;\n    }\n    if ((((unaff_retaddr & 1) == 0) && (iVar5 != 0)) && (unaff_EBX == 0)) {\n        (*_sym.imp.USER32.dll_SendMessageA)(iVar5, 0x121, 0, param_1[7]);\n    }\n    if ((unaff_retaddr & 2) == 0) goto code_r0x00427422;\n    goto code_r0x0042743d;\ncode_r0x00427422:\n    iVar7 = (*_sym.imp.USER32.dll_SendMessageA)(param_1[7], 0x36a, 0, unaff_EBX);\n    unaff_EBX = unaff_EBX + 1;\n    if (iVar7 == 0) {\ncode_r0x0042743d:\n        bVar2 = false;\n    }\n    goto code_r0x00427441;\n}\n",
        "token_count": 788
    },
    "00427537": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nbool __cdecl fcn.00427537(uint32_t arg_8h)\n\n{\n    uint noname_8;\n    uint noname_11;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint32_t uVar3;\n    uint unaff_EDI;\n    bool bVar4;\n    uint *noname_0;\n    uint32_t var_34h;\n    uint var_30h;\n    uint in_stack_ffffffd0;\n    uint in_stack_ffffffd4;\n    uint var_24h;\n    uint in_stack_ffffffdc;\n    uint var_1ch;\n    uint var_18h;\n    uint in_stack_ffffffe8;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_4h = fcn.0044be10();\n    arg_8h = arg_8h & ~*(var_4h + 0x18);\n    if (arg_8h == 0) {\n        bVar4 = true;\n    }\n    else {\n        uVar3 = 0;\n        fcn.0040e620(&var_34h, 0, 0x28);\n        var_30h = _sym.imp.USER32.dll_DefWindowProcA;\n        iVar1 = fcn.0044be10();\n        noname_11 = *0x4995f8;\n        noname_8 = *(iVar1 + 8);\n        noname_0 = 0x8;\n        var_ch = 8;\n        if ((arg_8h & 1) != 0) {\n            noname_0 = &var_34h;\n            var_34h = 0xb;\n            iVar1 = fcn.00425f19(noname_0, unaff_EDI, unaff_ESI, unaff_EBX, 0xb, var_30h, in_stack_ffffffd0, \n                                 in_stack_ffffffd4, noname_8, in_stack_ffffffdc, *0x4995f8, var_18h, in_stack_ffffffe8, \n                                 \"AfxWnd70s\", 8, var_8h, var_4h, unaff_EBP);\n            if (iVar1 != 0) {\n                uVar3 = 1;\n            }\n        }\n        if ((arg_8h & 0x20) != 0) {\n            var_34h = var_34h | 0x8b;\n            iVar1 = fcn.00425f19(&var_34h, noname_0, unaff_EDI, unaff_ESI, unaff_EBX, var_34h, var_30h, \n                                 in_stack_ffffffd0, in_stack_ffffffd4, noname_8, in_stack_ffffffdc, noname_11, var_18h, \n                                 in_stack_ffffffe8, \"AfxOleControl70s\", var_ch, var_8h, var_4h);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 0x20;\n            }\n        }\n        if ((arg_8h & 2) != 0) {\n            var_34h = 0;\n            iVar1 = fcn.00425f19(&var_34h, noname_0, unaff_EDI, unaff_ESI, unaff_EBX, 0, var_30h, in_stack_ffffffd0, \n                                 in_stack_ffffffd4, noname_8, in_stack_ffffffdc, noname_11, 0x10, in_stack_ffffffe8, \n                                 0x46a1d8, var_ch, var_8h, var_4h);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 2;\n            }\n        }\n        if ((arg_8h & 4) != 0) {\n            var_34h = 8;\n            iVar1 = fcn.004274f6(&var_34h, \"AfxMDIFrame70s\", 0x7a01);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 4;\n            }\n        }\n        if ((arg_8h & 8) != 0) {\n            var_34h = 0xb;\n            iVar1 = fcn.004274f6(&var_34h, \"AfxFrameOrView70s\", 0x7a02);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 8;\n            }\n        }\n        if ((arg_8h & 0x10) != 0) {\n            var_8h = 0xff;\n            uVar2 = fcn.004269b9(&var_ch, 0x3fc0);\n            uVar3 = uVar3 | uVar2;\n            arg_8h = arg_8h & 0xffffc03f;\n        }\n        if ((arg_8h & 0x40) != 0) {\n            var_8h = 0x10;\n            uVar2 = fcn.004269b9(&var_ch, 0x40);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x80) != 0) {\n            var_8h = 2;\n            uVar2 = fcn.004269b9(&var_ch, 0x80);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x100) != 0) {\n            var_8h = 8;\n            uVar2 = fcn.004269b9(&var_ch, 0x100);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x200) != 0) {\n            var_8h = 0x20;\n            uVar2 = fcn.004269b9(&var_ch, 0x200);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x400) != 0) {\n            var_8h = 1;\n            uVar2 = fcn.004269b9(&var_ch, 0x400);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x800) != 0) {\n            var_8h = 0x40;\n            uVar2 = fcn.004269b9(&var_ch, 0x800);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x1000) != 0) {\n            var_8h = 4;\n            uVar2 = fcn.004269b9(&var_ch, 0x1000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x2000) != 0) {\n            var_8h = 0x80;\n            uVar2 = fcn.004269b9(&var_ch, 0x2000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x4000) != 0) {\n            var_8h = 0x800;\n            uVar2 = fcn.004269b9(&var_ch, 0x4000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x8000) != 0) {\n            var_8h = 0x400;\n            uVar2 = fcn.004269b9(&var_ch, 0x8000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x10000) != 0) {\n            var_8h = 0x200;\n            uVar2 = fcn.004269b9(&var_ch, 0x10000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x20000) != 0) {\n            var_8h = 0x100;\n            uVar2 = fcn.004269b9(&var_ch, 0x20000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x40000) != 0) {\n            var_8h = 0x8000;\n            uVar2 = fcn.004269b9(&var_ch, 0x40000);\n            uVar3 = uVar3 | uVar2;\n        }\n        *(var_4h + 0x18) = *(var_4h + 0x18) | uVar3;\n        if ((*(var_4h + 0x18) & 0x3fc0) == 0x3fc0) {\n            *(var_4h + 0x18) = *(var_4h + 0x18) | 0x10;\n            uVar3 = uVar3 | 0x10;\n        }\n        bVar4 = (uVar3 & arg_8h) == arg_8h;\n    }\n    return bVar4;\n}\n",
        "token_count": 2263
    },
    "0042a192": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042a192(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    if ((*(param_1 + 0x39) & 1) == 0) {\n        (*_sym.imp.USER32.dll_IsDialogMessageA)(*(param_1 + 0x1c), param_2);\n    }\n    else {\n        iVar1 = fcn.0044be10();\n        (**(**(iVar1 + 0x1038) + 0x24))(param_1, param_2);\n    }\n    return;\n}\n",
        "token_count": 133
    },
    "0042c917": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0042c917(int32_t noname_0, int32_t noname_1, int32_t noname_2, uint noname_3, uint arg_8h, uint arg_ch, uint arg_10h\n            )\n\n{\n    if ((noname_2 != 0) && (noname_1 != 0)) {\n        if ((~*(noname_0 + 0x18) & 1) == 0) {\n            do {\n                fcn.0040afc4(noname_0, noname_1);\n                noname_1 = noname_1 + 4;\n                noname_2 = noname_2 + -1;\n            } while (noname_2 != 0);\n        }\n        else {\n            do {\n                fcn.0040834d();\n                fcn.0040af63(noname_0, noname_1);\n                noname_1 = noname_1 + 4;\n                noname_2 = noname_2 + -1;\n            } while (noname_2 != 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 250
    },
    "0042e329": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.0042e329(uint *param_1, uint8_t param_2)\n\n{\n    uint *puVar1;\n    \n    if ((param_2 & 2) == 0) {\n        fcn.004039aa();\n        puVar1 = param_1;\n        if ((param_2 & 1) != 0) {\n            fcn.00425d0d(param_1);\n        }\n    }\n    else {\n        puVar1 = param_1 + -1;\n        fcn.0040f757(param_1, 4, *puVar1, fcn.004039aa);\n        if ((param_2 & 1) != 0) {\n            fcn.00425d0d(puVar1);\n        }\n    }\n    return puVar1;\n}\n",
        "token_count": 181
    },
    "0042f96c": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042f96c(uint arg_8h, uint32_t *arg_ch)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_24h;\n    uint var_1ch;\n    uint var_14h;\n    uint *var_ch;\n    uint *var_8h;\n    uint32_t var_4h;\n    \n    var_ch = NULL;\n    var_8h = NULL;\n    var_4h = (*_sym.imp.KERNEL32.dll_GetFileAttributesA)(arg_8h);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (var_4h == 0xffffffff) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(arg_8h);\n        fcn.004301a1(uVar2);\n    }\n    if ((*(arg_ch + 8) != var_4h) && ((var_4h & 1) != 0)) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_SetFileAttributesA)(arg_8h, *(arg_ch + 8));\n        if (iVar3 == 0) {\n            uVar2 = (*pcVar1)(arg_8h);\n            fcn.004301a1(uVar2);\n        }\n    }\n    if ((arg_ch[2] | arg_ch[3]) != 0) {\n        fcn.0042f8b3(arg_ch + 2, &var_24h);\n        if ((arg_ch[4] | arg_ch[5]) != 0) {\n            fcn.0042f8b3(arg_ch + 4, &var_14h);\n            var_8h = &var_14h;\n        }\n        if ((*arg_ch | arg_ch[1]) != 0) {\n            fcn.0042f8b3(arg_ch, &var_1ch);\n            var_ch = &var_1ch;\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n        if (iVar3 == -1) {\n            uVar2 = (*pcVar1)(arg_8h);\n            fcn.004301a1(uVar2);\n        }\n        iVar4 = (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar3, var_ch, var_8h, &var_24h);\n        if (iVar4 == 0) {\n            uVar2 = (*pcVar1)(arg_8h);\n            fcn.004301a1(uVar2);\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n        if (iVar3 == 0) {\n            uVar2 = (*pcVar1)(arg_8h);\n            fcn.004301a1(uVar2);\n        }\n    }\n    if ((*(arg_ch + 8) != var_4h) && ((var_4h & 1) == 0)) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_SetFileAttributesA)(arg_8h, *(arg_ch + 8));\n        if (iVar3 == 0) {\n            uVar2 = (*pcVar1)(arg_8h);\n            fcn.004301a1(uVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 763
    },
    "00430c53": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00430c53(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar3 = *(param_1 + 0x28);\n    if ((*(param_1 + 0x18) & 1) == 0) {\n        piVar1 = param_1 + 0x30;\n        iVar2 = *piVar1;\n        if (*(param_1 + 8) == 0) {\n            if (iVar3 != iVar2) {\n                (**(**(param_1 + 0x24) + 0x38))(iVar2, iVar3 - iVar2);\n            }\n        }\n        else {\n            if (iVar3 != iVar2) {\n                (**(**(param_1 + 0x24) + 0x50))(2, iVar3 - iVar2, 0, 0);\n            }\n            (**(**(param_1 + 0x24) + 0x50))(1, *(param_1 + 0x20), piVar1, param_1 + 0x2c);\n        }\n        iVar3 = *piVar1;\n    }\n    else {\n        if (*(param_1 + 0x2c) != iVar3) {\n            iVar3 = iVar3 - *(param_1 + 0x2c);\n            (**(**(param_1 + 0x24) + 0x28))(iVar3, iVar3 >> 0x1f, 1);\n        }\n        iVar3 = *(param_1 + 0x2c);\n    }\n    *(param_1 + 0x28) = iVar3;\n    return;\n}\n",
        "token_count": 376
    },
    "004312e5": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint * __cdecl fcn.004312e5(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00403c40();\n    piVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    if (piVar1 == NULL) {\n        fcn.0042032d();\n    }\n    uVar2 = (**(*piVar1 + 0x18))(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 1;\n    fcn.004048c5(uVar2);\n    *(unaff_EBP + -4) = 0;\n    fcn.00403164();\n    uVar2 = *(unaff_EBP + 0xc);\n    extraout_ECX[4] = 0xffffffff;\n    extraout_ECX[6] = uVar2;\n    extraout_ECX[1] = 1;\n    extraout_ECX[7] = 1;\n    extraout_ECX[9] = piVar1;\n    extraout_ECX[0x10] = (-((~uVar2 & 1) != 0) & 0xffffffd0) + 0x40;\n    uVar2 = *(unaff_EBP + 0x14);\n    extraout_ECX[0xf] = 0;\n    extraout_ECX[0xe] = 0;\n    *extraout_ECX = 0;\n    extraout_ECX[0x11] = 0x89;\n    extraout_ECX[0xc] = uVar2;\n    extraout_ECX[2] = 0;\n    uVar3 = (**(*piVar1 + 0x50))(3, 0, 0, 0);\n    iVar5 = *(unaff_EBP + 0x10);\n    extraout_ECX[3] = uVar3 & 2;\n    if (iVar5 < 0x80) {\n        extraout_ECX[8] = 0x80;\n        extraout_ECX[0xc] = 0;\n    }\n    else {\n        extraout_ECX[8] = iVar5;\n    }\n    iVar5 = extraout_ECX[8];\n    if (extraout_ECX[0xc] == 0) {\n        uVar3 = (**(*extraout_ECX[9] + 0x50))(3, 0, 0, 0);\n        extraout_ECX[2] = uVar3 & 1;\n        if ((uVar3 & 1) == 0) {\n            uVar2 = fcn.00425ce2(extraout_ECX[8]);\n            extraout_ECX[0xc] = uVar2;\n            extraout_ECX[7] = 0;\n        }\n        else {\n            iVar5 = 0;\n        }\n    }\n    iVar5 = extraout_ECX[0xc] + iVar5;\n    extraout_ECX[0xb] = iVar5;\n    iVar4 = extraout_ECX[0xc];\n    if ((*(extraout_ECX + 6) & 1) != 0) {\n        iVar4 = iVar5;\n    }\n    uVar2 = *(unaff_EBP + -0xc);\n    extraout_ECX[10] = iVar4;\n    *in_FS_OFFSET = uVar2;\n    return extraout_ECX;\n}\n",
        "token_count": 911
    },
    "004335ce": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004335ce(int32_t param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    uint *puVar3;\n    uint arg_8h;\n    uint arg_ch;\n    \n    if (param_2 == 0) {\n        arg_ch = *(param_1 + 0x14);\n        arg_8h = 6;\n    }\n    else {\n        if ((~*(param_1 + 0x18) & 1) != 0) goto code_r0x004335f4;\n        arg_ch = *(param_1 + 0x14);\n        arg_8h = 1;\n    }\n    fcn.00434a73(arg_8h, arg_ch);\ncode_r0x004335f4:\n    if (*(param_2 + 8) == 0xffff) {\n        fcn.00420313();\n    }\n    fcn.004334ca(0);\n    puVar2 = fcn.00425b35(param_2);\n    uVar1 = *puVar2;\n    if (uVar1 == 0) {\n        fcn.00402665(0xffff);\n        fcn.00431266(param_1);\n        fcn.004334b6();\n        puVar3 = fcn.00425b35(param_2);\n        *puVar3 = *(param_1 + 0x34);\n        *(param_1 + 0x34) = *(param_1 + 0x34) + 1;\n    }\n    else if (uVar1 < 0x7fff) {\n        fcn.00402665(uVar1 | 0x8000);\n    }\n    else {\n        fcn.00402665(0x7fff);\n        fcn.00406888(uVar1 | 0x80000000);\n    }\n    return;\n}\n",
        "token_count": 422
    },
    "00433865": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00433865(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    uint uVar3;\n    uint *puVar4;\n    int32_t *in_stack_fffffff8;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        in_stack_fffffff8 = *(param_1 + 0x14);\n        fcn.00434a73(2, in_stack_fffffff8);\n    }\n    fcn.004334ca(0);\n    if (in_stack_fffffff8 == NULL) {\n        fcn.00402665(0);\n    }\n    else {\n        puVar2 = fcn.00425b35(in_stack_fffffff8);\n        uVar1 = *puVar2;\n        if (uVar1 == 0) {\n            uVar3 = (***in_stack_fffffff8)();\n            fcn.004335ce(uVar3);\n            fcn.004334b6();\n            puVar4 = fcn.00425b35(in_stack_fffffff8);\n            *puVar4 = *(param_1 + 0x34);\n            *(param_1 + 0x34) = *(param_1 + 0x34) + 1;\n            (**(*in_stack_fffffff8 + 8))(param_1);\n        }\n        else if (uVar1 < 0x7fff) {\n            fcn.00402665(uVar1);\n        }\n        else {\n            fcn.00402665(0x7fff);\n            fcn.00406888(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 369
    },
    "00437433": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00437433(int32_t *param_1)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t *var_8h;\n    int32_t *piStack8;\n    \n    uVar1 = param_1[0x1f];\n    param_1[0x27] = 0;\n    if (((uVar1 & 1) == 0) || ((uVar1 & 4) == 0)) {\n        if ((uVar1 & 0xa000) == 0) {\n            uVar2 = 0x50;\n        }\n        else {\n            uVar2 = 0x4a;\n        }\n    }\n    else {\n        uVar2 = 0x46;\n    }\n    var_8h = param_1;\n    piStack8 = param_1;\n    (**(*param_1 + 0x134))(&var_8h, 0, uVar2);\n    return;\n}\n",
        "token_count": 218
    },
    "004376de": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.004376de(uint arg_8h, int32_t *arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    uint *puVar3;\n    uint var_30h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint8_t var_fh;\n    uint var_eh;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    (**(*in_ECX + 0x110))(0x417, arg_8h, &var_18h);\n    *(arg_ch + 2) = *(arg_ch + 2) ^ 4;\n    var_eh._0_1_ = 0;\n    var_eh._1_1_ = 0;\n    *(arg_ch + 10) = 0;\n    *(arg_ch + 0xb) = 0;\n    iVar2 = fcn.0040ee70(arg_ch, &var_18h, 0x14);\n    if (iVar2 != 0) {\n        var_20h = fcn.0042a1c5();\n        fcn.0042a1f9(0x10000000, 0, 0);\n        (**(*in_ECX + 0x110))(0x416, arg_8h, 0);\n        pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n        var_1ch = (*_sym.imp.USER32.dll_SendMessageA)(in_ECX[7], 0x43d, 0, 0);\n        (*pcVar1)(in_ECX[7], 0xb, 0, 0);\n        (*pcVar1)(in_ECX[7], 0x43c, var_1ch + 1, 0);\n        (*pcVar1)(in_ECX[7], 0x43c, var_1ch, 0);\n        (*pcVar1)(in_ECX[7], 0xb, 1, 0);\n        (**(*in_ECX + 0x110))(0x415, arg_8h, arg_ch);\n        fcn.0042a1f9(0, var_20h & 0x10000000, 0);\n        if ((((*(arg_ch + 9) ^ var_fh) & 1) == 0) && (((*(arg_ch + 9) & 1) == 0 || (*arg_ch == var_18h)))) {\n            iVar2 = (**(*in_ECX + 0x110))(0x41d, arg_8h, &var_30h);\n            if (iVar2 == 0) goto code_r0x00437813;\n            puVar3 = &var_30h;\n        }\n        else {\n            puVar3 = NULL;\n        }\n        (*_sym.imp.USER32.dll_InvalidateRect)(in_ECX[7], puVar3, 1);\n    }\ncode_r0x00437813:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 700
    },
    "00438b1c": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00438b1c(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_DefWindowProcA)(*(in_ECX + 0x1c), 0x46, 0, arg_8h);\n    if ((*(arg_8h + 0x18) & 1) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x1c), &lpRect);\n        var_4h = *(arg_8h + 0x10);\n        var_ch = var_ch - lpRect;\n        var_8h = var_8h - var_10h;\n        iVar1 = *(arg_8h + 0x14);\n        if ((var_4h != var_ch) && ((*(in_ECX + 0x7d) & 4) != 0)) {\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, var_4h - *0x4995c8, 0, var_4h, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), &lpRect, 1);\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, var_ch - *0x4995c8, 0, var_ch, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), &lpRect, 1);\n        }\n        pcVar2 = _sym.imp.USER32.dll_SetRect;\n        if ((iVar1 != var_8h) && ((*(in_ECX + 0x7d) & 8) != 0)) {\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, 0, iVar1 - *0x4995cc, var_4h, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), &lpRect, 1);\n            (*pcVar2)(&lpRect, 0, var_8h - *0x4995cc, var_4h, var_8h);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), &lpRect, 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 585
    },
    "0043c35c": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043c35c(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    ulong uVar6;\n    \n    uVar6 = fcn.0043c33e();\n    uVar5 = uVar6 >> 0x20;\n    if (uVar6 != uVar5) {\n        param_1[0x21] = uVar5 >> 0x14 & 1;\n        param_1[0x22] = uVar5 >> 0x15 & 1;\n        if (0 < param_1[0x20]) {\n            iVar3 = 0xea00;\n            do {\n                iVar2 = iVar3;\n                iVar1 = fcn.0042a05b();\n                if (iVar1 == 0) {\n                    iVar2 = (**(*param_1 + 0x148))(0, iVar3);\n                    if (iVar2 == 0) {\n                        fcn.00431a1c();\n                    }\n                    iVar2 = iVar3;\n                    fcn.0042a05b(iVar3);\n                }\n                fcn.0042a2ea(-(param_1[0x21] != 0) & 5, iVar2);\n                iVar2 = iVar3 + -0xe9ff;\n                iVar3 = iVar3 + 1;\n            } while (iVar2 < param_1[0x20]);\n        }\n        if (0 < param_1[0x1f]) {\n            iVar3 = 0xea10;\n            do {\n                iVar2 = iVar3;\n                iVar1 = fcn.0042a05b();\n                if (iVar1 == 0) {\n                    iVar2 = (**(*param_1 + 0x148))(1, iVar3);\n                    if (iVar2 == 0) {\n                        fcn.00431a1c();\n                    }\n                    iVar2 = iVar3;\n                    fcn.0042a05b(iVar3);\n                }\n                fcn.0042a2ea(-(param_1[0x22] != 0) & 5, iVar2);\n                iVar2 = iVar3 + -0xea0f;\n                iVar3 = iVar3 + 1;\n            } while (iVar2 < param_1[0x1f]);\n        }\n        if ((param_1[0x22] == 0) || (param_1[0x21] == 0)) {\n            piVar4 = fcn.0042a05b(0xea20);\n            if (piVar4 != NULL) {\n                (**(*piVar4 + 0x60))();\n            }\n        }\n        else {\n            iVar3 = fcn.0042a05b(0xea20);\n            if (iVar3 == 0) {\n                iVar3 = (**(*param_1 + 0x148))(0x8000008, 0xea20);\n                if (iVar3 == 0) {\n                    fcn.00431a1c();\n                }\n                fcn.0042a05b(0xea20);\n            }\n            fcn.0042a2ea(5);\n        }\n    }\n    return;\n}\n",
        "token_count": 719
    },
    "0043ed50": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0043ed50(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    int32_t *in_ECX;\n    uint32_t uVar5;\n    uint var_50h;\n    uint var_4ch;\n    uint32_t var_48h;\n    uint var_30h;\n    \n    iVar1 = fcn.0042783b();\n    if (iVar1 != 0) {\n        var_50h = 0x50;\n        var_4ch = 0x11;\n        (**(*in_ECX + 0x110))(0x41d, arg_8h, &var_50h);\n        uVar2 = fcn.00427905(var_30h);\n        piVar3 = fcn.0042c6eb(0x4697d8, uVar2);\n        if (piVar3 == NULL) {\n            uVar4 = (*_sym.imp.USER32.dll_GetWindowLongA)(var_30h, 0xfffffff0);\n            uVar4 = uVar4 >> 0x1c & 1;\n        }\n        else {\n            uVar4 = (**(*piVar3 + 0x150))();\n        }\n        uVar5 = ~(var_48h >> 3) & 1;\n        if (uVar4 != uVar5) {\n            (*_sym.imp.USER32.dll_ShowWindow)(var_30h, -(uVar5 != 0) & 5);\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 359
    },
    "00441f12": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00441f12(int32_t param_1, uint32_t param_2)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    \n    uVar3 = fcn.0042a1c5();\n    iVar4 = param_1;\n    if ((uVar3 & 0x40000000) == 0) {\n        iVar4 = fcn.004283c7();\n    }\n    pcVar2 = _sym.imp.USER32.dll_SendMessageA;\n    if ((param_2 & 0xc) != 0) {\n        iVar5 = fcn.0042a30b();\n        if ((((~(param_2 >> 3) & 1) == 0) || (iVar5 == 0)) || (iVar4 == param_1)) {\n            (*pcVar2)(*(iVar4 + 0x1c), 0x86, 0, 0);\n        }\n        else {\n            *(param_1 + 0x39) = *(param_1 + 0x39) | 2;\n            (*pcVar2)(*(iVar4 + 0x1c), 0x86, 1, 0);\n            *(param_1 + 0x39) = *(param_1 + 0x39) & 0xfd;\n        }\n    }\n    uVar7 = 5;\n    iVar5 = (*_sym.imp.USER32.dll_GetDesktopWindow)(5);\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    while (iVar5 = (*pcVar1)(iVar5, uVar7),  iVar5 != 0) {\n        iVar6 = fcn.004418f8(*(iVar4 + 0x1c), iVar5);\n        if (iVar6 != 0) {\n            (*pcVar2)(iVar5, 0x36d, param_2, 0);\n        }\n        uVar7 = 2;\n    }\n    return;\n}\n",
        "token_count": 468
    },
    "0044360d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpMultiByteStr\n// WARNING: Variable defined which should be unmapped: var_110h\n\nvoid __cdecl fcn.0044360d(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpMultiByteStr;\n    uint var_110h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = *0x496830;\n    piVar2 = fcn.0042c770();\n    iVar3 = (**(*piVar2 + 0xc))();\n    *(unaff_EBP + -0x114) = iVar3 + 0x10;\n    puVar1 = *(unaff_EBP + 0xc);\n    iVar3 = puVar1[2];\n    uVar4 = puVar1[1];\n    *(unaff_EBP + -4) = 0;\n    if (((iVar3 == -0x208) && ((*(puVar1 + 0x19) & 1) != 0)) || ((iVar3 == -0x212 && ((*(puVar1 + 0x2d) & 1) != 0)))) {\n        uVar4 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(uVar4);\n        uVar4 = uVar4 & 0xffff;\n    }\n    if (uVar4 != 0) {\n        iVar3 = fcn.0042cf90(uVar4, unaff_EBP + -0x110, 0x100);\n        if (iVar3 == 0) goto code_r0x004436ff;\n        fcn.0042d03c(unaff_EBP + -0x114, unaff_EBP + -0x110, 1, 10);\n    }\n    if (puVar1[2] == -0x208) {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(puVar1 + 4, *(unaff_EBP + -0x114));\n    }\n    else {\n        uVar5 = (**0x4860f8)(0, *(unaff_EBP + -0x114), 0xffffffff, puVar1 + 4, 0x50);\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(uVar5);\n        if ((0 < iVar3) && (puVar1 + 4 != NULL)) {\n            *(puVar1 + iVar3 * 2 + 0xe) = 0;\n        }\n    }\n    **(unaff_EBP + 0x10) = 0;\n    (*_sym.imp.USER32.dll_SetWindowPos)(*puVar1, 0, 0, 0, 0, 0, 0x213);\ncode_r0x004436ff:\n    fcn.00403164();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 730
    },
    "00444f27": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00444f27(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if ((*(arg_8h + 0x18) & 1) == 0) {\n        iVar1 = fcn.00444e58(&var_10h);\n        if (iVar1 != 0) {\n            uVar2 = fcn.0042a1c5();\n            if ((uVar2 & 0x1000000) != 0) {\n                uVar3 = fcn.0042a1df();\n                uVar3 = fcn.0042a1c5(0, uVar3);\n                (*_sym.imp.USER32.dll_AdjustWindowRectEx)(&var_10h, uVar3);\n                *(arg_8h + 8) = var_10h;\n                *(arg_8h + 0xc) = var_ch;\n                *(arg_8h + 0x10) = var_8h - var_10h;\n                *(arg_8h + 0x14) = var_4h - var_ch;\n            }\n        }\n    }\n    fcn.0042783b();\n    return;\n}\n",
        "token_count": 312
    },
    "00446ab6": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00446ab6(uint32_t arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    \n    uVar3 = fcn.0042a1c5();\n    pcVar1 = _sym.imp.USER32.dll_GetKeyState;\n    if ((uVar3 < 0) &&\n       ((((arg_8h & 0xfff0) != 0xf060 ||\n         (((iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(0x73),  iVar2 < 0 && (iVar2 = (*pcVar1)(0x12),  iVar2 < 0)) &&\n          ((uVar3 & 0x100) != 0)))) && (iVar4 = fcn.00428bda(arg_8h, arg_ch),  iVar4 != 0)))) {\n        return;\n    }\n    fcn.0044251c(arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 229
    },
    "00447c59": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00447c59(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    ulong uVar2;\n    uint var_4h;\n    \n    if ((~*(arg_8h + 0x18) & 1) == 0) {\n        uVar2 = (**(**(arg_8h + 0x24) + 0x30))();\n        uVar1 = fcn.0040d44d();\n        if ((uVar2 >> 0x20 != 0) || (uVar1 < uVar2)) {\n            fcn.0043c086(0xf105, 0, 0xffffffff);\n            fcn.00431a36();\n        }\n        fcn.0044766c(arg_8h, uVar2);\n    }\n    else {\n        fcn.00447bfb(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 203
    },
    "0044c1f6": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0044c1f6(int32_t param_1)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint8_t *puVar6;\n    int32_t iVar7;\n    uint uStack48;\n    uchar *puStack44;\n    int32_t iStack40;\n    uint uStack36;\n    int32_t iStack32;\n    int32_t iStack28;\n    uint hMem;\n    uint lpCriticalSection;\n    \n    iVar4 = param_1 + 0x1c;\n    iStack32 = 0x44c20d;\n    iStack28 = iVar4;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)();\n    iVar2 = *(param_1 + 4);\n    iVar7 = *(param_1 + 8);\n    if ((iVar2 <= iVar7) || ((*(*(param_1 + 0x10) + iVar7 * 8) & 1) != 0)) {\n        iVar7 = 1;\n        if (1 < iVar2) {\n            puVar6 = *(param_1 + 0x10);\n            do {\n                puVar6 = puVar6 + 8;\n                if ((*puVar6 & 1) == 0) break;\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < iVar2);\n            if (iVar7 < iVar2) goto code_r0x0044c2d8;\n        }\n        iVar2 = iVar2 + 0x20;\n        iStack32 = *(param_1 + 0x10);\n        if (iStack32 == 0) {\n            iStack32 = iVar2 * 8;\n            uStack36 = 2;\n            iStack40 = 0x44c25e;\n            iStack40 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)();\n        }\n        else {\n            uStack36 = 0x44c267;\n            uStack48 = (*_sym.imp.KERNEL32.dll_GlobalHandle)();\n            iStack40 = 0x44c271;\n            uStack36 = uStack48;\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)();\n            iStack40 = 0x2002;\n            puStack44 = iVar2 * 8;\n            iStack40 = (*_sym.imp.KERNEL32.dll_GlobalReAlloc)();\n        }\n        if (iStack40 == 0) {\n            iStack40 = *(param_1 + 0x10);\n            if (iStack40 != 0) {\n                puStack44 = 0x44c297;\n                puStack44 = (*_sym.imp.KERNEL32.dll_GlobalHandle)();\n                uStack48 = 0x44c29e;\n                (*_sym.imp.KERNEL32.dll_GlobalLock)();\n            }\n            puStack44 = 0x44c2a7;\n            iStack40 = iVar4;\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)();\n            uStack48 = 0x497848;\n            puStack44 = &stack0xfffffffc;\n            fcn.0040ed8d(&stack0xffffffd0, 0x47bfd4);\n            pcVar3 = swi(3);\n            iVar4 = (*pcVar3)();\n            return iVar4;\n        }\n        puStack44 = 0x44c2b3;\n        iVar5 = (*_sym.imp.KERNEL32.dll_GlobalLock)();\n        iStack32 = (iVar2 - *(param_1 + 4)) * 8;\n        iStack40 = iVar5 + *(param_1 + 4) * 8;\n        uStack36 = 0;\n        puStack44 = 0x44c2cc;\n        fcn.0040e620();\n        *(param_1 + 4) = iVar2;\n        *(param_1 + 0x10) = iVar5;\n    }\ncode_r0x0044c2d8:\n    if (*(param_1 + 0xc) <= iVar7) {\n        *(param_1 + 0xc) = iVar7 + 1;\n    }\n    puVar1 = *(param_1 + 0x10) + iVar7 * 8;\n    *puVar1 = *puVar1 | 1;\n    *(param_1 + 8) = iVar7 + 1;\n    uStack36 = 0x44c2fb;\n    iStack32 = iVar4;\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)();\n    return iVar7;\n}\n",
        "token_count": 1002
    },
    "004520f2": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid fcn.004520f2(uint param_1, uint32_t param_2)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t unaff_retaddr;\n    \n    if ((((param_2 >> 0x1f & 1U) == 0) || ((param_2 & 0x1fff0000) != 0x30000)) ||\n       (uVar2 = param_2 & 0xffff,  0xff < uVar2)) {\n        if ((param_2 == 0x80030100) || (((-0x7ffcff00 < param_2 && (-0x7ffcfefb < param_2)) && (param_2 == 0x80030106)))\n           ) {\n            uVar1 = 0xb;\n        }\n        else {\n            uVar1 = 1;\n        }\n    }\n    else {\n        uVar1 = fcn.0042fe36(uVar2);\n        param_2 = uVar2;\n    }\n    *(unaff_retaddr + 8) = uVar1;\n    *(unaff_retaddr + 0xc) = param_2;\n    return;\n}\n",
        "token_count": 261
    },
    "004582be": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t fcn.004582be(uint32_t param_1, uint32_t param_2)\n\n{\n    if ((param_2 & param_1) != 0) {\n        return param_1;\n    }\n    if (param_1 == 1) {\n        if ((param_2 & 2) != 0) {\n            return 2;\n        }\n    }\n    else {\n        if (param_1 != 2) {\n            return 0;\n        }\n        if ((param_2 & 1) != 0) {\n            return 1;\n        }\n    }\n    if ((param_2 & 4) == 0) {\n        return 0;\n    }\n    return 4;\n}\n",
        "token_count": 157
    },
    "004015ea": {
        "rules": [
            "decompress data using aPLib/db7317f0dd944ab688d24dced6f5a7c2"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004015ea(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint unaff_retaddr;\n    \n    if (param_2 == 0) {\n        *param_1 = 0;\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_2);\n        iVar3 = (iVar1 + 1) * 2;\n        if (0x80 < iVar3) {\n            iVar2 = fcn.0040d946(iVar3);\n            *param_1 = iVar2;\n            if (iVar2 == 0) {\n                fcn.00401182(0x8007000e);\n            }\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                          (param_2, 0, unaff_retaddr, iVar1 + 1, *param_1, iVar3, 0, 0);\n        if (iVar3 == 0) {\n            fcn.0040119b();\n        }\n    }\n    return;\n}\n",
        "token_count": 260
    },
    "004062c4": {
        "rules": [
            "decompress data using aPLib/db7317f0dd944ab688d24dced6f5a7c2"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004062c4(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint unaff_retaddr;\n    \n    if (param_2 == 0) {\n        *param_1 = 0;\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_2);\n        iVar3 = (iVar1 + 1) * 2;\n        if (0x80 < iVar3) {\n            iVar2 = fcn.0040d946(iVar3);\n            *param_1 = iVar2;\n            if (iVar2 == 0) {\n                fcn.00401182(0x8007000e);\n            }\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                          (param_2, 0, unaff_retaddr, iVar1 + 1, *param_1, iVar3, 0, 0);\n        if (iVar3 == 0) {\n            fcn.0040119b();\n        }\n    }\n    return;\n}\n",
        "token_count": 261
    },
    "00402988": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402988(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint var_4h;\n    \n    if (-1 < arg_8h) {\n        if (-1 < arg_ch) {\n            *(in_ECX + 0x10) = arg_ch;\n        }\n        if (arg_8h == 0) {\n            if (*(in_ECX + 4) != 0) {\n                fcn.00425d17(*(in_ECX + 4));\n                *(in_ECX + 4) = 0;\n            }\n            *(in_ECX + 0xc) = 0;\n            *(in_ECX + 8) = 0;\n            return;\n        }\n        if (*(in_ECX + 4) == 0) {\n            iVar5 = *(in_ECX + 0x10);\n            if (*(in_ECX + 0x10) < arg_8h) {\n                iVar5 = arg_8h;\n            }\n            puVar1 = fcn.00425d12(iVar5 << 3);\n            *(in_ECX + 4) = puVar1;\n            for (uVar3 = (iVar5 << 3) >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar1 = 0;\n                puVar1 = puVar1 + 1;\n            }\n            for (iVar4 = 0; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar1 = 0;\n                puVar1 = puVar1 + 1;\n            }\n            *(in_ECX + 8) = arg_8h;\n            *(in_ECX + 0xc) = iVar5;\n            return;\n        }\n        iVar5 = *(in_ECX + 0xc);\n        if (arg_8h <= iVar5) {\n            iVar5 = *(in_ECX + 8);\n            if (iVar5 < arg_8h) {\n                puVar1 = *(in_ECX + 4) + iVar5 * 8;\n                for (uVar3 = (arg_8h - iVar5) * 8 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = 0;\n                    puVar1 = puVar1 + 1;\n                }\n                for (iVar5 = 0; iVar5 != 0; iVar5 = iVar5 + -1) {\n                    *puVar1 = 0;\n                    puVar1 = puVar1 + 1;\n                }\n            }\n            *(in_ECX + 8) = arg_8h;\n            return;\n        }\n        arg_ch = *(in_ECX + 0x10);\n        if (arg_ch == 0) {\n            arg_ch = *(in_ECX + 8) / 8;\n            if (arg_ch < 4) {\n                arg_ch = 4;\n            }\n            else if (0x400 < arg_ch) {\n                arg_ch = 0x400;\n            }\n        }\n        arg_ch = arg_ch + iVar5;\n        if (arg_ch <= arg_8h) {\n            arg_ch = arg_8h;\n        }\n        iVar4 = arg_ch;\n        if (iVar5 <= arg_ch) goto code_r0x00402a7a;\n    }\n    iVar4 = fcn.0042032d();\ncode_r0x00402a7a:\n    puVar2 = fcn.00425d12(iVar4 << 3);\n    puVar1 = *(in_ECX + 4);\n    puVar6 = puVar2;\n    for (uVar3 = (*(in_ECX + 8) << 3) >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar6 = *puVar1;\n        puVar1 = puVar1 + 1;\n        puVar6 = puVar6 + 1;\n    }\n    for (iVar5 = 0; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar6 = *puVar1;\n        puVar1 = puVar1 + 1;\n        puVar6 = puVar6 + 1;\n    }\n    puVar1 = puVar2 + *(in_ECX + 8) * 2;\n    for (uVar3 = (arg_8h - *(in_ECX + 8)) * 8 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar1 = 0;\n        puVar1 = puVar1 + 1;\n    }\n    for (iVar5 = 0; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar1 = 0;\n        puVar1 = puVar1 + 1;\n    }\n    fcn.00425d17(*(in_ECX + 4));\n    *(in_ECX + 4) = puVar2;\n    *(in_ECX + 8) = arg_8h;\n    *(in_ECX + 0xc) = arg_ch;\n    return;\n}\n",
        "token_count": 1201
    },
    "0040e620": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint32_t * fcn.0040e620(uint32_t *param_1, uint8_t param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t *puVar4;\n    \n    if (param_3 == 0) {\n        return param_1;\n    }\n    uVar1 = param_2;\n    puVar4 = param_1;\n    if (3 < param_3) {\n        uVar2 = -param_1 & 3;\n        uVar3 = param_3;\n        if (uVar2 != 0) {\n            uVar3 = param_3 - uVar2;\n            do {\n                *puVar4 = param_2;\n                puVar4 = puVar4 + 1;\n                uVar2 = uVar2 - 1;\n            } while (uVar2 != 0);\n        }\n        uVar1 = uVar1 * 0x1010101;\n        param_3 = uVar3 & 3;\n        uVar3 = uVar3 >> 2;\n        if (uVar3 != 0) {\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar4 = uVar1;\n                puVar4 = puVar4 + 1;\n            }\n            if (param_3 == 0) {\n                return param_1;\n            }\n        }\n    }\n    do {\n        *puVar4 = uVar1;\n        puVar4 = puVar4 + 1;\n        param_3 = param_3 - 1;\n    } while (param_3 != 0);\n    return param_1;\n}\n",
        "token_count": 387
    },
    "0040e680": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0040e680(uint *arg_8h, uint *arg_ch, uint32_t arg_10h)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    if ((arg_ch < arg_8h) && (arg_8h < arg_10h + arg_ch)) {\n        arg_ch = (arg_10h - 4) + arg_ch;\n        puVar1 = (arg_10h - 4) + arg_8h;\n        if ((puVar1 & 3) == 0) {\n            uVar3 = arg_10h >> 2;\n            if (uVar3 < 8) goto code_r0x0040e844;\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + -1;\n                puVar1 = puVar1 + -1;\n            }\n    // switch table (4 cases) at 0x40e968\n            switch(*((arg_10h & 3) * 4 + 0x40e968)) {\n            case 0x40e980:\ncode_r0x0040e980:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                return arg_8h;\n            case 0x40e990:\ncode_r0x0040e990:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                return arg_8h;\n            case 0x40e9a4:\ncode_r0x0040e9a4:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                *(puVar1 + 1) = *(arg_ch + 1);\n                return arg_8h;\n            }\n        }\n        else if (arg_10h < 4) {\n    // switch table (4 cases) at 0x40e968\n            switch(*(arg_10h * 4 + 0x40e968)) {\n            case 0x40e980:\n                goto code_r0x0040e980;\n            case 0x40e990:\n                goto code_r0x0040e990;\n            case 0x40e9a4:\n                goto code_r0x0040e9a4;\n            }\n        }\n        else {\n            arg_10h = arg_10h - (puVar1 & 3);\n            switch(*((puVar1 & 3) * 4 + 0x40e86c)) {\n            case 0x40e87c:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                arg_ch = arg_ch + -1;\n                uVar3 = arg_10h >> 2;\n                puVar1 = puVar1 - 1;\n                if (uVar3 < 8) {\ncode_r0x0040e844:\n    // WARNING: Could not recover jumptable at 0x0040e846. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (1 cases) at 0x40e918\n                    puVar1 = (**(uVar3 * -4 + 0x40e918))();\n                    return puVar1;\n                }\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x40e968)) {\n                case 0x40e980:\n                    goto code_r0x0040e980;\n                case 0x40e990:\n                    goto code_r0x0040e990;\n                case 0x40e9a4:\n                    goto code_r0x0040e9a4;\n                }\n                break;\n            case 0x40e8a0:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 2) = *(arg_ch + 2);\n                arg_ch = arg_ch + -2;\n                puVar1 = puVar1 - 2;\n                if (uVar3 < 8) goto code_r0x0040e844;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x40e968)) {\n                case 0x40e980:\n                    goto code_r0x0040e980;\n                case 0x40e990:\n                    goto code_r0x0040e990;\n                case 0x40e9a4:\n                    goto code_r0x0040e9a4;\n                }\n                break;\n            case 0x40e8c8:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 1) = *(arg_ch + 1);\n                arg_ch = arg_ch + -3;\n                puVar1 = puVar1 - 3;\n                if (uVar3 < 8) goto code_r0x0040e844;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x40e968)) {\n                case 0x40e980:\n                    goto code_r0x0040e980;\n                case 0x40e990:\n                    goto code_r0x0040e990;\n                case 0x40e9a4:\n                    goto code_r0x0040e9a4;\n                }\n            }\n        }\n        return arg_8h;\n    }\n    puVar1 = arg_8h;\n    if ((arg_8h & 3) == 0) {\n        uVar2 = arg_10h >> 2;\n        if (uVar2 < 8) goto code_r0x0040e6dc;\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar1 = *arg_ch;\n            arg_ch = arg_ch + 1;\n            puVar1 = puVar1 + 1;\n        }\n    // switch table (4 cases) at 0x40e7cc\n        switch(*((arg_10h & 3) * 4 + 0x40e7cc)) {\n        case 0x40e7e4:\ncode_r0x0040e7e4:\n            *puVar1 = *arg_ch;\n            return arg_8h;\n        case 0x40e7f0:\ncode_r0x0040e7f0:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            return arg_8h;\n        case 0x40e804:\ncode_r0x0040e804:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            *(puVar1 + 2) = *(arg_ch + 2);\n            return arg_8h;\n        }\n    }\n    else if (arg_10h < 4) {\n        switch(*((arg_10h - 4) * 4 + 0x40e7dc)) {\n        case 0x40e7e4:\n            goto code_r0x0040e7e4;\n        case 0x40e7f0:\n            goto code_r0x0040e7f0;\n        case 0x40e804:\n            goto code_r0x0040e804;\n        }\n    }\n    else {\n        uVar3 = (arg_10h - 4) + (arg_8h & 3);\n        switch(*((arg_8h & 3) * 4 + 0x40e6e0)) {\n        case 0x40e6f0:\n            *arg_8h = *arg_ch;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 2) = *(arg_ch + 2);\n            arg_ch = arg_ch + 3;\n            puVar1 = arg_8h + 3;\n            if (uVar2 < 8) {\ncode_r0x0040e6dc:\n    // WARNING: Could not recover jumptable at 0x0040e6dc. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (8 cases) at 0x40e760\n                puVar1 = (**(uVar2 * 4 + 0x40e760))();\n                return puVar1;\n            }\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x40e7cc)) {\n            case 0x40e7e4:\n                goto code_r0x0040e7e4;\n            case 0x40e7f0:\n                goto code_r0x0040e7f0;\n            case 0x40e804:\n                goto code_r0x0040e804;\n            }\n            break;\n        case 0x40e71c:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            arg_ch = arg_ch + 2;\n            puVar1 = arg_8h + 2;\n            if (uVar2 < 8) goto code_r0x0040e6dc;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x40e7cc)) {\n            case 0x40e7e4:\n                goto code_r0x0040e7e4;\n            case 0x40e7f0:\n                goto code_r0x0040e7f0;\n            case 0x40e804:\n                goto code_r0x0040e804;\n            }\n            break;\n        case 0x40e740:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            arg_ch = arg_ch + 1;\n            puVar1 = arg_8h + 1;\n            if (uVar2 < 8) goto code_r0x0040e6dc;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x40e7cc)) {\n            case 0x40e7e4:\n                goto code_r0x0040e7e4;\n            case 0x40e7f0:\n                goto code_r0x0040e7f0;\n            case 0x40e804:\n                goto code_r0x0040e804;\n            }\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 2771
    },
    "0040ea50": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0040ea50(uint *arg_8h, uint *arg_ch, uint32_t arg_10h)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    if ((arg_ch < arg_8h) && (arg_8h < arg_10h + arg_ch)) {\n        arg_ch = (arg_10h - 4) + arg_ch;\n        puVar1 = (arg_10h - 4) + arg_8h;\n        if ((puVar1 & 3) == 0) {\n            uVar3 = arg_10h >> 2;\n            if (uVar3 < 8) goto code_r0x0040ec14;\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + -1;\n                puVar1 = puVar1 + -1;\n            }\n    // switch table (4 cases) at 0x40ed38\n            switch(*((arg_10h & 3) * 4 + 0x40ed38)) {\n            case 0x40ed50:\ncode_r0x0040ed50:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                return arg_8h;\n            case 0x40ed60:\ncode_r0x0040ed60:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                return arg_8h;\n            case 0x40ed74:\ncode_r0x0040ed74:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                *(puVar1 + 1) = *(arg_ch + 1);\n                return arg_8h;\n            }\n        }\n        else if (arg_10h < 4) {\n    // switch table (4 cases) at 0x40ed38\n            switch(*(arg_10h * 4 + 0x40ed38)) {\n            case 0x40ed50:\n                goto code_r0x0040ed50;\n            case 0x40ed60:\n                goto code_r0x0040ed60;\n            case 0x40ed74:\n                goto code_r0x0040ed74;\n            }\n        }\n        else {\n            arg_10h = arg_10h - (puVar1 & 3);\n            switch(*((puVar1 & 3) * 4 + 0x40ec3c)) {\n            case 0x40ec4c:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                arg_ch = arg_ch + -1;\n                uVar3 = arg_10h >> 2;\n                puVar1 = puVar1 - 1;\n                if (uVar3 < 8) {\ncode_r0x0040ec14:\n    // WARNING: Could not recover jumptable at 0x0040ec16. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (1 cases) at 0x40ece8\n                    puVar1 = (**(uVar3 * -4 + 0x40ece8))();\n                    return puVar1;\n                }\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x40ed38)) {\n                case 0x40ed50:\n                    goto code_r0x0040ed50;\n                case 0x40ed60:\n                    goto code_r0x0040ed60;\n                case 0x40ed74:\n                    goto code_r0x0040ed74;\n                }\n                break;\n            case 0x40ec70:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 2) = *(arg_ch + 2);\n                arg_ch = arg_ch + -2;\n                puVar1 = puVar1 - 2;\n                if (uVar3 < 8) goto code_r0x0040ec14;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x40ed38)) {\n                case 0x40ed50:\n                    goto code_r0x0040ed50;\n                case 0x40ed60:\n                    goto code_r0x0040ed60;\n                case 0x40ed74:\n                    goto code_r0x0040ed74;\n                }\n                break;\n            case 0x40ec98:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 1) = *(arg_ch + 1);\n                arg_ch = arg_ch + -3;\n                puVar1 = puVar1 - 3;\n                if (uVar3 < 8) goto code_r0x0040ec14;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x40ed38)) {\n                case 0x40ed50:\n                    goto code_r0x0040ed50;\n                case 0x40ed60:\n                    goto code_r0x0040ed60;\n                case 0x40ed74:\n                    goto code_r0x0040ed74;\n                }\n            }\n        }\n        return arg_8h;\n    }\n    puVar1 = arg_8h;\n    if ((arg_8h & 3) == 0) {\n        uVar2 = arg_10h >> 2;\n        if (uVar2 < 8) goto code_r0x0040eaac;\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar1 = *arg_ch;\n            arg_ch = arg_ch + 1;\n            puVar1 = puVar1 + 1;\n        }\n    // switch table (4 cases) at 0x40eb9c\n        switch(*((arg_10h & 3) * 4 + 0x40eb9c)) {\n        case 0x40ebb4:\ncode_r0x0040ebb4:\n            *puVar1 = *arg_ch;\n            return arg_8h;\n        case 0x40ebc0:\ncode_r0x0040ebc0:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            return arg_8h;\n        case 0x40ebd4:\ncode_r0x0040ebd4:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            *(puVar1 + 2) = *(arg_ch + 2);\n            return arg_8h;\n        }\n    }\n    else if (arg_10h < 4) {\n        switch(*((arg_10h - 4) * 4 + 0x40ebac)) {\n        case 0x40ebb4:\n            goto code_r0x0040ebb4;\n        case 0x40ebc0:\n            goto code_r0x0040ebc0;\n        case 0x40ebd4:\n            goto code_r0x0040ebd4;\n        }\n    }\n    else {\n        uVar3 = (arg_10h - 4) + (arg_8h & 3);\n        switch(*((arg_8h & 3) * 4 + 0x40eab0)) {\n        case 0x40eac0:\n            *arg_8h = *arg_ch;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 2) = *(arg_ch + 2);\n            arg_ch = arg_ch + 3;\n            puVar1 = arg_8h + 3;\n            if (uVar2 < 8) {\ncode_r0x0040eaac:\n    // WARNING: Could not recover jumptable at 0x0040eaac. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (8 cases) at 0x40eb30\n                puVar1 = (**(uVar2 * 4 + 0x40eb30))();\n                return puVar1;\n            }\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x40eb9c)) {\n            case 0x40ebb4:\n                goto code_r0x0040ebb4;\n            case 0x40ebc0:\n                goto code_r0x0040ebc0;\n            case 0x40ebd4:\n                goto code_r0x0040ebd4;\n            }\n            break;\n        case 0x40eaec:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            arg_ch = arg_ch + 2;\n            puVar1 = arg_8h + 2;\n            if (uVar2 < 8) goto code_r0x0040eaac;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x40eb9c)) {\n            case 0x40ebb4:\n                goto code_r0x0040ebb4;\n            case 0x40ebc0:\n                goto code_r0x0040ebc0;\n            case 0x40ebd4:\n                goto code_r0x0040ebd4;\n            }\n            break;\n        case 0x40eb10:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            arg_ch = arg_ch + 1;\n            puVar1 = arg_8h + 1;\n            if (uVar2 < 8) goto code_r0x0040eaac;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x40eb9c)) {\n            case 0x40ebb4:\n                goto code_r0x0040ebb4;\n            case 0x40ebc0:\n                goto code_r0x0040ebc0;\n            case 0x40ebd4:\n                goto code_r0x0040ebd4;\n            }\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 2718
    },
    "00404cad": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00404cad(int32_t *param_1, int32_t param_2)\n\n{\n    if ((param_2 == -1) && (param_2 = *param_1,  param_2 != 0)) {\n        param_2 = fcn.0040e9c0(param_2);\n    }\n    fcn.004042a8(param_2);\n    return;\n}\n",
        "token_count": 93
    },
    "00408bde": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.00408bde(int32_t arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    uint *in_ECX;\n    int64_t iVar1;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_4h;\n    \n    var_24h = arg_1ch;\n    var_20h = arg_18h;\n    var_1ch = arg_14h;\n    var_18h = arg_10h;\n    var_14h = arg_ch + -1;\n    var_10h = arg_8h + -0x76c;\n    var_4h = arg_20h;\n    iVar1 = fcn.00410751(&var_24h);\n    *in_ECX = iVar1;\n    in_ECX[1] = iVar1 >> 0x20;\n    if (iVar1 == -1) {\n        fcn.00401182(0x80070057);\n    }\n    return;\n}\n",
        "token_count": 279
    },
    "0040db00": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.0040db00(int32_t param_1, int32_t param_2, uint param_3)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iStack12;\n    uint uStack8;\n    \n    puVar4 = &stack0xfffffffc;\n    if ((*(param_1 + 4) & 6) == 0) {\n        iStack12 = param_1;\n        uStack8 = param_3;\n        *(param_2 + -4) = &iStack12;\n        iVar5 = *(param_2 + 0xc);\n        iVar3 = *(param_2 + 8);\n        iVar2 = fcn.00411e7f(param_2);\n        if (iVar2 == 0) {\n            *(param_1 + 4) = *(param_1 + 4) | 8;\n        }\n        else {\n            for (; iVar5 != -1; iVar5 = *(iVar3 + iVar5 * 0xc)) {\n                pcVar1 = *(iVar3 + 4 + iVar5 * 0xc);\n                if (pcVar1 != NULL) {\n                    iVar3 = (*pcVar1)();\n                    param_2 = *(puVar4 + 0xc);\n                    if (iVar3 != 0) {\n                        if (iVar3 < 0) {\n                            return 0;\n                        }\n                        iVar3 = *(param_2 + 8);\n                        fcn.0040e098(param_2);\n                        puVar4 = param_2 + 0x10;\n                        fcn.0040e0da(param_2, iVar5);\n                        fcn.0040e16e(1);\n                        *(param_2 + 0xc) = *(iVar3 + extraout_ECX * 4);\n                        param_2 = 0;\n                        iVar5 = 0;\n                        (**(iVar3 + 8 + extraout_ECX * 4))();\n                    }\n                }\n                iVar3 = *(param_2 + 8);\n            }\n        }\n    }\n    else {\n        fcn.0040e0da(param_2, 0xffffffff, &stack0xfffffffc, &stack0xfffffffc);\n    }\n    return 1;\n}\n",
        "token_count": 517
    },
    "00412e8d": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.00412e8d(int32_t param_1)\n\n{\n    if (*0x496bf0 != -1) {\n        if (param_1 == 0) {\n            param_1 = (**0x499ae8)(*0x496bf0);\n        }\n        fcn.00412d46(param_1);\n        (**0x499aec)(*0x496bf0, 0);\n    }\n    return;\n}\n",
        "token_count": 96
    },
    "00418d51": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00418d51(uint32_t arg_8h, uint8_t **arg_ch)\n\n{\n    uint8_t **ppuVar1;\n    uint8_t *puVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint var_ch;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    if ((*(arg_ch + 3) & 0x40) == 0) {\n        puVar2 = arg_ch[4];\n        if (puVar2 == 0xffffffff) {\n            iVar3 = 0x496d20;\n        }\n        else {\n            iVar3 = *((puVar2 >> 5) * 4 + 0x49ae40) + (puVar2 & 0x1f) * 0x24;\n        }\n        if ((*(iVar3 + 4) & 0x80) != 0) {\n            iVar3 = fcn.00419065(&var_ch, arg_8h);\n            if (iVar3 == -1) {\n                puVar4 = fcn.00410979();\n                *puVar4 = 0x2a;\n            }\n            else {\n                iVar6 = 0;\n                if (0 < iVar3) {\n                    do {\n                        ppuVar1 = arg_ch + 1;\n                        *ppuVar1 = *ppuVar1 + -1;\n                        if (*ppuVar1 < 0) {\n                            uVar5 = fcn.00413e10(*(&var_ch + iVar6), arg_ch);\n                        }\n                        else {\n                            **arg_ch = *(&var_ch + iVar6);\n                            uVar5 = **arg_ch;\n                            *arg_ch = *arg_ch + 1;\n                        }\n                    } while ((uVar5 != 0xffffffff) && (iVar6 = iVar6 + 1,  iVar6 < iVar3));\n                }\n            }\n            goto code_r0x00418e1a;\n        }\n    }\n    ppuVar1 = arg_ch + 1;\n    *ppuVar1 = *ppuVar1 + -2;\n    if (*ppuVar1 < 0) {\n        fcn.0041cbe2(arg_8h & 0xffff, arg_ch);\n    }\n    else {\n        **arg_ch = arg_8h;\n        *arg_ch = *arg_ch + 2;\n    }\ncode_r0x00418e1a:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 568
    },
    "0041908c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t fcn.0041908c(uint8_t **param_1)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    uint8_t *puVar3;\n    int32_t iVar4;\n    \n    puVar3 = param_1[3];\n    if (((puVar3 & 0x83) != 0) && ((puVar3 & 0x40) == 0)) {\n        if ((puVar3 & 2) == 0) {\n            param_1[3] = puVar3 | 1;\n            if ((puVar3 & 0x10c) == 0) {\n                fcn.00418b7c(param_1);\n            }\n            else {\n                *param_1 = param_1[2];\n            }\n            puVar3 = fcn.0041cee5(param_1[4], param_1[2], param_1[6]);\n            param_1[1] = puVar3;\n            if ((puVar3 != NULL) && (puVar3 != 0xffffffff)) {\n                if ((param_1[3] & 0x82) == 0) {\n                    puVar2 = param_1[4];\n                    if (puVar2 == 0xffffffff) {\n                        iVar4 = 0x496d20;\n                    }\n                    else {\n                        iVar4 = *((puVar2 >> 5) * 4 + 0x49ae40) + (puVar2 & 0x1f) * 0x24;\n                    }\n                    if ((*(iVar4 + 4) & 0x82) == 0x82) {\n                        param_1[3] = param_1[3] | 0x2000;\n                    }\n                }\n                if (((param_1[6] == 0x200) && ((param_1[3] & 8) != 0)) && ((param_1[3] & 0x400) == 0)) {\n                    param_1[6] = 0x1000;\n                }\n                param_1[1] = puVar3 + -1;\n                uVar1 = **param_1;\n                *param_1 = *param_1 + 1;\n                return uVar1;\n            }\n            param_1[3] = param_1[3] | (-(puVar3 != NULL) & 0x10) + 0x10;\n            param_1[1] = NULL;\n        }\n        else {\n            param_1[3] = puVar3 | 0x20;\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 580
    },
    "00422526": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: nWidth\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: nHeight\n\nvoid __cdecl fcn.00422526(uint wParam)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint nWidth;\n    uint nHeight;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    if (*(unaff_EBP + 8) != -1) {\n        uVar2 = fcn.00445759();\n        (*_sym.imp.USER32.dll_GetClientRect)(*(extraout_ECX + 0x1c), unaff_EBP + -0x24);\n        *(unaff_EBP + -0x10) = 0;\n        *(unaff_EBP + -0x14) = vtable.CRgn.0;\n        *(unaff_EBP + -4) = 0;\n        uVar3 = (*_sym.imp.GDI32.dll_CreateRectRgnIndirect)(unaff_EBP + -0x24);\n        fcn.0043242b(uVar3);\n        uVar3 = (*_sym.imp.USER32.dll_GetDC)(*(extraout_ECX + 0x1c));\n        iVar4 = fcn.00432120(uVar3);\n        fcn.00431d59(unaff_EBP + -0x14);\n        (*_sym.imp.USER32.dll_SendMessageA)(*(extraout_ECX + 0x1c), 0x198, *(unaff_EBP + 8), unaff_EBP + -0x24);\n        iVar1 = *(unaff_EBP + -0x20);\n        *(unaff_EBP + -0x20) = *(unaff_EBP + -0x20) + -2;\n        *(unaff_EBP + -0x18) = iVar1 + 2;\n        uVar2 = fcn.0043257f(uVar2);\n        (*_sym.imp.GDI32.dll_PatBlt)\n                  (*(iVar4 + 4), *(unaff_EBP + -0x24), *(unaff_EBP + -0x20), *(unaff_EBP + -0x1c) - *(unaff_EBP + -0x24)\n                   , *(unaff_EBP + -0x18) - *(unaff_EBP + -0x20), 0x5a0049);\n        fcn.0043257f(uVar2);\n        (*_sym.imp.USER32.dll_ReleaseDC)(*(extraout_ECX + 0x1c), *(iVar4 + 4));\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(unaff_EBP + -0x14) = vtable.CGdiObject.0;\n        fcn.00432482();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 732
    },
    "00422838": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00422838(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    int32_t in_ECX;\n    uint32_t var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_ch;\n    \n    var_14h = arg_ch;\n    var_1ch = arg_10h;\n    var_20h = 5;\n    if (arg_14h != -1) {\n        var_20h = 7;\n        var_18h = arg_14h;\n    }\n    if (arg_18h != -1) {\n        var_20h = var_20h | 8;\n        var_ch = arg_18h;\n    }\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x101b, arg_8h, &var_20h);\n    return;\n}\n",
        "token_count": 235
    },
    "00423366": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00423366(uint arg_8h, uint *arg_ch)\n\n{\n    uint *puVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_30h;\n    int32_t var_10h;\n    int32_t var_ch;\n    \n    puVar1 = arg_ch;\n    puVar3 = &var_30h;\n    for (iVar2 = 0xc; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = *puVar1;\n        puVar1 = puVar1 + 1;\n        puVar3 = puVar3 + 1;\n    }\n    if (((var_10h == 0) && (var_ch != -1)) && (var_ch != 0)) {\n        iVar2 = fcn.00425687(var_ch, &arg_ch);\n        if (iVar2 == 0) {\n            puVar1 = fcn.0042585d(var_ch);\n            *puVar1 = 0;\n        }\n        fcn.004256ae(var_ch, &var_ch);\n    }\n    (**(*in_ECX + 0x110))(0x404, arg_8h, &var_30h);\n    return;\n}\n",
        "token_count": 286
    },
    "004257e2": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004257e2(int32_t param_1, int32_t **param_2, int32_t *param_3)\n\n{\n    int32_t **ppiVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    \n    piVar3 = *param_2;\n    if (piVar3 != NULL) {\n        if (piVar3 == 0xffffffff) {\n            uVar4 = 0;\n            if (*(param_1 + 8) != 0) {\n                ppiVar1 = *(param_1 + 4);\n                while (piVar3 = *ppiVar1,  piVar3 == NULL) {\n                    uVar4 = uVar4 + 1;\n                    ppiVar1 = ppiVar1 + 1;\n                    if (*(param_1 + 8) <= uVar4) {\n                        *param_2 = NULL;\n                        return;\n                    }\n                }\n            }\n        }\n        piVar5 = *piVar3;\n        if (piVar5 == NULL) {\n            uVar4 = *(param_1 + 8);\n            uVar2 = piVar3[1] % uVar4 + 1;\n            if (uVar2 < uVar4) {\n                ppiVar1 = *(param_1 + 4) + uVar2 * 4;\n                do {\n                    piVar5 = *ppiVar1;\n                    if (piVar5 != NULL) break;\n                    uVar2 = uVar2 + 1;\n                    ppiVar1 = ppiVar1 + 1;\n                } while (uVar2 < uVar4);\n            }\n        }\n        *param_2 = piVar5;\n        fcn.004048c5(piVar3 + 2);\n        *param_3 = piVar3[3];\n    }\n    return;\n}\n",
        "token_count": 425
    },
    "00425a37": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00425a37(int32_t param_1, int32_t **param_2, int32_t *param_3, int32_t *param_4)\n\n{\n    int32_t **ppiVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    \n    piVar3 = *param_2;\n    if (piVar3 != NULL) {\n        if (piVar3 == 0xffffffff) {\n            uVar4 = 0;\n            if (*(param_1 + 8) != 0) {\n                ppiVar1 = *(param_1 + 4);\n                while (piVar3 = *ppiVar1,  piVar3 == NULL) {\n                    uVar4 = uVar4 + 1;\n                    ppiVar1 = ppiVar1 + 1;\n                    if (*(param_1 + 8) <= uVar4) {\n                        *param_2 = NULL;\n                        return;\n                    }\n                }\n            }\n        }\n        piVar5 = *piVar3;\n        if (piVar5 == NULL) {\n            uVar4 = *(param_1 + 8);\n            uVar2 = (piVar3[1] >> 4) % uVar4 + 1;\n            if (uVar2 < uVar4) {\n                ppiVar1 = *(param_1 + 4) + uVar2 * 4;\n                do {\n                    piVar5 = *ppiVar1;\n                    if (piVar5 != NULL) break;\n                    uVar2 = uVar2 + 1;\n                    ppiVar1 = ppiVar1 + 1;\n                } while (uVar2 < uVar4);\n            }\n        }\n        *param_2 = piVar5;\n        *param_3 = piVar3[1];\n        *param_4 = piVar3[2];\n    }\n    return;\n}\n",
        "token_count": 435
    },
    "0042ee91": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042ee91(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    bool bVar3;\n    \n    bVar3 = false;\n    if (*(param_1 + 4) != -1) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_CloseHandle)(*(param_1 + 4));\n        bVar3 = iVar1 == 0;\n    }\n    *(param_1 + 4) = 0xffffffff;\n    *(param_1 + 8) = 0;\n    fcn.004042f6();\n    if (bVar3) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(*(param_1 + 0xc));\n        fcn.004301a1(uVar2);\n    }\n    return;\n}\n",
        "token_count": 184
    },
    "0042eed4": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042eed4(int32_t param_1)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    uint64_t uVar5;\n    \n    if (*(param_1 + 4) != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*(param_1 + 4));\n        *(param_1 + 4) = 0xffffffff;\n    }\n    puVar1 = param_1 + 0xc;\n    uVar2 = *puVar1;\n    uVar5 = uVar2;\n    piVar3 = *(uVar2 - 0x10);\n    if (*(uVar2 - 0xc) != 0) {\n        if (*(uVar2 - 4) < 0) {\n            if (*(uVar2 - 8) < 0) {\n                uVar5 = fcn.00401182(0x80070057);\n            }\n            *(uVar5 + -0xc) = uVar5 >> 0x20;\n            **puVar1 = uVar5 >> 0x20;\n        }\n        else {\n            fcn.00403164();\n            iVar4 = (**(*piVar3 + 0xc))();\n            *puVar1 = iVar4 + 0x10;\n        }\n    }\n    return;\n}\n",
        "token_count": 310
    },
    "0042f0fa": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_15ch\n// WARNING: Variable defined which should be unmapped: lpFindFileData\n// WARNING: Variable defined which should be unmapped: lpFilePart\n// WARNING: Variable defined which should be unmapped: var_158h\n\nvoid __cdecl fcn.0042f0fa(uint lpRootPathName, uint lpFileName)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_15ch;\n    uint var_158h;\n    uint lpFilePart;\n    uint lpFindFileData;\n    uint lpString2;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    uVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = *0x496830;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetFullPathNameA)(*(unaff_EBP + 0xc), 0x104, uVar1, unaff_EBP + -0x154);\n    if (uVar2 == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(uVar1, *(unaff_EBP + 0xc), 0x104);\n    }\n    else if (uVar2 < 0x104) {\n        piVar3 = fcn.0042c770();\n        iVar4 = (**(*piVar3 + 0xc))();\n        *(unaff_EBP + 8) = iVar4 + 0x10;\n        *(unaff_EBP + -4) = 0;\n        fcn.0042f0b8(uVar1, unaff_EBP + 8);\n        iVar4 = (*_sym.imp.SHLWAPI.dll_PathIsUNCA)(*(unaff_EBP + 8));\n        if ((iVar4 == 0) &&\n           (iVar4 = (*_sym.imp.KERNEL32.dll_GetVolumeInformationA)\n                              (*(unaff_EBP + 8), 0, 0, 0, unaff_EBP + -0x15c, unaff_EBP + -0x158, 0, 0),  iVar4 != 0)) {\n            if ((*(unaff_EBP + -0x158) & 2) == 0) {\n                (*_sym.imp.USER32.dll_CharUpperA)(uVar1);\n            }\n            if (((((*(unaff_EBP + -0x158) & 4) == 0) &&\n                 (iVar4 = (*_sym.imp.KERNEL32.dll_FindFirstFileA)(*(unaff_EBP + 0xc), unaff_EBP + -0x150),  iVar4 != -1)\n                 ) && ((*_sym.imp.KERNEL32.dll_FindClose)(iVar4),  *(unaff_EBP + -0x154) != 0)) &&\n               ((uVar1 <= *(unaff_EBP + -0x154) && *(unaff_EBP + -0x154) != uVar1 &&\n                (iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(unaff_EBP + -0x124), \n                (iVar4 - uVar1) + *(unaff_EBP + -0x154) < 0x104)))) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyA)(*(unaff_EBP + -0x154), unaff_EBP + -0x124);\n            }\n        }\n        fcn.00403164();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 841
    },
    "0042f23b": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042f23b(uint lpFileName, uint32_t dwDesiredAccess, int32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t in_ECX;\n    uint32_t uVar5;\n    uint uVar6;\n    uint lpSecurityAttributes;\n    uint var_110h;\n    uint32_t var_10ch;\n    uint var_108h;\n    uint var_4h;\n    \n    uVar1 = dwDesiredAccess;\n    var_4h = *0x496830;\n    *(in_ECX + 8) = 0;\n    *(in_ECX + 4) = 0xffffffff;\n    uVar5 = dwDesiredAccess & 0xffff7fff;\n    fcn.004042f6();\n    iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpFileName);\n    if ((0x103 < iVar3) || (iVar3 = fcn.0042f0fa(&var_108h, lpFileName),  iVar3 == 0)) goto code_r0x0042f3b5;\n    fcn.004045a1(&var_108h);\n    uVar4 = dwDesiredAccess & 3;\n    dwDesiredAccess = 0;\n    if (uVar4 == 0) {\n        dwDesiredAccess = 0x80000000;\n    }\n    else if (uVar4 == 1) {\n        dwDesiredAccess = 0x40000000;\n    }\n    else if (uVar4 == 2) {\n        dwDesiredAccess = 0xc0000000;\n    }\n    uVar4 = uVar1 & 0x70;\n    uVar6 = 1;\n    if ((uVar4 == 0) || (uVar4 == 0x10)) {\ncode_r0x0042f2f2:\n        uVar6 = 0;\n    }\n    else if (uVar4 != 0x20) {\n        if (uVar4 == 0x30) {\n            uVar6 = 2;\n        }\n        else {\n            uVar6 = 3;\n            if (uVar4 != 0x40) goto code_r0x0042f2f2;\n        }\n    }\n    var_10ch = ~(uVar5 >> 7) & 1;\n    lpSecurityAttributes = 0xc;\n    var_110h = 0;\n    if ((uVar1 & 0x1000) == 0) {\n        cVar2 = '\\x03';\n    }\n    else {\n        cVar2 = (-((uVar1 & 0x2000) != 0) & 2U) + 2;\n    }\n    uVar5 = 0x80;\n    if ((uVar1 & 0x10000) != 0) {\n        uVar5 = 0x20000080;\n    }\n    if ((uVar1 & 0x20000) != 0) {\n        uVar5 = uVar5 | 0x80000000;\n    }\n    if ((uVar1 & 0x40000) != 0) {\n        uVar5 = uVar5 | 0x10000000;\n    }\n    if ((uVar1 & 0x80000) != 0) {\n        uVar5 = uVar5 | 0x8000000;\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_CreateFileA)\n                      (lpFileName, dwDesiredAccess, uVar6, &lpSecurityAttributes, cVar2, uVar5, 0);\n    if (iVar3 == -1) {\n        if (arg_10h != 0) {\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            *(arg_10h + 0xc) = uVar6;\n            uVar6 = fcn.0042fe36(uVar6);\n            *(arg_10h + 8) = uVar6;\n            fcn.004045a1(lpFileName);\n        }\n    }\n    else {\n        *(in_ECX + 4) = iVar3;\n        *(in_ECX + 8) = 1;\n    }\ncode_r0x0042f3b5:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 974
    },
    "0042fad5": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042fad5(uint32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    uint32_t *puVar4;\n    int32_t in_ECX;\n    uint var_20h;\n    uint lpLastWriteTime;\n    uint lpLastAccessTime;\n    uint lpCreationTime;\n    \n    fcn.0040e620(arg_8h, 0, 0x128);\n    (*_sym.imp.KERNEL32.dll_lstrcpynA)(arg_8h + 0x22, *(in_ECX + 0xc), 0x104);\n    if (*(in_ECX + 4) == *0x470ec4) {\ncode_r0x0042fbdc:\n        uVar3 = 1;\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetFileTime)\n                          (*(in_ECX + 4), &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n        if (iVar1 != 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetFileSize)(*(in_ECX + 4), 0);\n            arg_8h[6] = uVar2;\n            arg_8h[7] = 0;\n            if (uVar2 != 0xffffffff) {\n                if (*(*(in_ECX + 0xc) + -0xc) == 0) {\n                    *(arg_8h + 8) = 0;\n                }\n                else {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_GetFileAttributesA)(*(in_ECX + 0xc));\n                    *(arg_8h + 8) = (iVar1 == -1) - 1U & iVar1;\n                }\n                puVar4 = fcn.00408c96(&lpCreationTime, 0xffffffff);\n                *arg_8h = *puVar4;\n                arg_8h[1] = puVar4[1];\n                puVar4 = fcn.00408c96(&lpLastAccessTime, 0xffffffff);\n                arg_8h[4] = *puVar4;\n                arg_8h[5] = puVar4[1];\n                puVar4 = fcn.00408c96(&lpLastWriteTime, 0xffffffff);\n                arg_8h[2] = *puVar4;\n                arg_8h[3] = puVar4[1];\n                if ((*arg_8h | arg_8h[1]) == 0) {\n                    *arg_8h = *puVar4;\n                    arg_8h[1] = puVar4[1];\n                }\n                if ((arg_8h[4] | arg_8h[5]) == 0) {\n                    arg_8h[4] = arg_8h[2];\n                    arg_8h[5] = arg_8h[3];\n                }\n                goto code_r0x0042fbdc;\n            }\n        }\n        uVar3 = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 687
    },
    "004358ee": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004358ee(uint noname_0, uint nNumber)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t iVar3;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    var_8h = in_ECX;\n    var_4h = in_ECX;\n    fcn.00434d3c(&var_8h, &var_4h);\n    if ((var_4h == NULL) && (var_8h == NULL)) {\n        iVar1 = 0;\n    }\n    else {\n        iVar1 = fcn.00434abc();\n        iVar2 = (*_sym.imp.KERNEL32.dll_MulDiv)(-nNumber, iVar1, 0x78);\n        if (var_4h == NULL) {\n            if (var_8h == NULL) {\n                return 0;\n            }\n            if (iVar1 == -1) {\n                iVar1 = in_ECX[0x1b];\n                if (0 < nNumber) {\n                    iVar1 = -in_ECX[0x1b];\n                }\n            }\n            else {\n                iVar1 = in_ECX[0x1d] * iVar2;\n                if (in_ECX[0x1b] <= in_ECX[0x1d] * iVar2) {\n                    iVar1 = in_ECX[0x1b];\n                }\n            }\n            iVar3 = 0;\n        }\n        else {\n            if (iVar1 == -1) {\n                iVar3 = in_ECX[0x1c];\n                if (0 < nNumber) {\n                    iVar3 = -in_ECX[0x1c];\n                }\n            }\n            else {\n                iVar3 = in_ECX[0x1e] * iVar2;\n                if (in_ECX[0x1c] <= in_ECX[0x1e] * iVar2) {\n                    iVar3 = in_ECX[0x1c];\n                }\n            }\n            iVar1 = 0;\n        }\n        iVar1 = (**(*in_ECX + 0x138))(iVar1, iVar3, 1);\n        if (iVar1 != 0) {\n            (*_sym.imp.USER32.dll_UpdateWindow)(in_ECX[7]);\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 525
    },
    "00435fe6": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00435fe6(int32_t param_1)\n\n{\n    fcn.0042783b();\n    if (*(param_1 + 0x58) == -1) {\n        fcn.00435d55(*(param_1 + 0x5c), *(param_1 + 0x60));\n    }\n    else {\n        fcn.004356f0();\n    }\n    return;\n}\n",
        "token_count": 94
    },
    "0043628a": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0043628a(uint param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0042783b();\n    if (iVar1 != -1) {\n        if ((*param_2 != 0) && (*(*param_2 + 4) != 0)) {\n            fcn.00433a67(param_1);\n        }\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 112
    },
    "0043c086": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint __cdecl fcn.0043c086(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    piVar1 = fcn.0042c770(extraout_ECX);\n    iVar2 = (**(*piVar1 + 0xc))();\n    *(unaff_EBP + -0x10) = iVar2 + 0x10;\n    *(unaff_EBP + -4) = 0;\n    fcn.00404503(*(unaff_EBP + 8));\n    iVar2 = *(unaff_EBP + 0x10);\n    if (iVar2 == -1) {\n        iVar2 = *(unaff_EBP + 8);\n    }\n    uVar3 = fcn.0043c064(*(unaff_EBP + -0x10), *(unaff_EBP + 0xc), iVar2);\n    fcn.00403164();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 338
    },
    "00442051": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00442051(int32_t *param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0042783b();\n    if ((iVar1 != -1) && (iVar1 = (**(*param_1 + 0x158))(param_2, param_3),  iVar1 != 0)) {\n        (*_sym.imp.USER32.dll_PostMessageA)(param_1[7], 0x362, 0xe001, 0);\n        (**(*param_1 + 0x144))(1);\n        return 0;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 150
    },
    "00445ee5": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00445ee5(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    if ((param_2 != 8) && (param_2 != -1)) {\n        iVar1 = param_2 * 0x20;\n        if (*(param_1 + 0x10) - *(param_1 + 8) < 0) {\n            param_2 = *(iVar1 + 0x46fe20);\n            iVar1 = param_2 << 5;\n        }\n        if (*(param_1 + 0x14) - *(param_1 + 0xc) < 0) {\n            param_2 = *(iVar1 + 0x46fe24);\n        }\n    }\n    return param_2;\n}\n",
        "token_count": 179
    },
    "00448ac6": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.00448ac6(void)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    \n    iVar4 = *0x494d18;\n    if (*0x494d18 == -1) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"COMCTL32.DLL\");\n        pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, \"DllGetVersion\");\n        iVar4 = 0x40000;\n        if (pcVar2 != NULL) {\n            fcn.0040e620(&var_14h, 0, 0x14);\n            var_14h = 0x14;\n            iVar3 = (*pcVar2)(&var_14h);\n            if (-1 < iVar3) {\n                iVar4 = CONCAT22(var_10h, var_ch);\n            }\n        }\n    }\n    *0x494d18 = iVar4;\n    return iVar4;\n}\n",
        "token_count": 258
    },
    "00448b34": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t fcn.00448b34(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    \n    if (*0x494d1c == -1) {\n        uVar2 = (*_sym.imp.USER32.dll_GetDC)(0);\n        uVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x48, 0, 0, 0, 400, 0, 0, 0, 2, 0, 0, 0, 0, \"Marlett\");\n        iVar4 = (*_sym.imp.GDI32.dll_CreateFontA)(uVar3);\n        pcVar1 = _sym.imp.GDI32.dll_SelectObject;\n        if (iVar4 != 0) {\n            (*_sym.imp.GDI32.dll_SelectObject)(uVar2, iVar4);\n        }\n        (*_sym.imp.GDI32.dll_GetCharWidthA)(uVar2, 0x36, 0x36, 0x494d1c);\n        if (iVar4 != 0) {\n            (*pcVar1)(uVar2, uVar3);\n            (*_sym.imp.GDI32.dll_DeleteObject)(iVar4);\n        }\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar2);\n    }\n    return *0x494d1c;\n}\n",
        "token_count": 305
    },
    "0044a2a7": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044a2a7(uint arg_8h, int32_t Locale)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint lpLibFileName;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    if (Locale == 0x800) {\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(&Locale, 0x46bf28);\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)(Locale, 3, &Locale, 4);\n        if (iVar2 == 0) goto code_r0x0044a31c;\n    }\n    uVar1 = fcn.0040f25a(&lpLibFileName, 0x112, arg_8h, &Locale);\n    if ((uVar1 != 0xffffffff) && (uVar1 < 0x112)) {\n        (*_sym.imp.KERNEL32.dll_LoadLibraryA)(&lpLibFileName);\n    }\ncode_r0x0044a31c:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 253
    },
    "0044c4c0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.0044c4c0(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uStack12;\n    \n    param_1[5] = 0;\n    param_1[6] = 0;\n    param_1[6] = 4;\n    param_1[1] = 0;\n    param_1[2] = 1;\n    param_1[3] = 0;\n    param_1[4] = 0;\n    iVar3 = (*_sym.imp.KERNEL32.dll_TlsAlloc)();\n    *param_1 = iVar3;\n    if (iVar3 == -1) {\n        uStack12 = 0x497848;\n        fcn.0040ed8d(&stack0xfffffff4, 0x47bfd4);\n        pcVar1 = swi(3);\n        piVar2 = (*pcVar1)();\n        return piVar2;\n    }\n    uStack12 = 0x44c4fe;\n    (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)();\n    return param_1;\n}\n",
        "token_count": 262
    },
    "0044c820": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044c820(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t arg_8h;\n    uint uVar2;\n    \n    arg_8h = param_1[5];\n    while (arg_8h != 0) {\n        iVar1 = *(arg_8h + 4);\n        fcn.0044c688(arg_8h, 0);\n        arg_8h = iVar1;\n    }\n    if (*param_1 != -1) {\n        (*_sym.imp.KERNEL32.dll_TlsFree)(*param_1);\n    }\n    if (param_1[4] != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(param_1[4]);\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(uVar2);\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(uVar2);\n    }\n    (*_sym.imp.KERNEL32.dll_DeleteCriticalSection)(param_1 + 7);\n    return;\n}\n",
        "token_count": 230
    },
    "00451416": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00451416(int32_t arg_8h, uint *arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = arg_8h;\n    if ((in_ECX[8] != 0) && (in_ECX[9] != 0)) {\n        if (arg_10h == -1) {\n            arg_10h = in_ECX[0xb];\n        }\n        var_30h = *arg_ch;\n        var_2ch = arg_ch[1];\n        var_28h = arg_ch[2];\n        var_24h = arg_ch[3];\n        fcn.00408b9c(&var_8h);\n        fcn.00406a25(&var_10h);\n        piVar1 = arg_8h + 0xc;\n        var_20h = var_8h;\n        var_1ch = var_4h;\n        var_18h = var_10h;\n        var_14h = var_ch;\n        arg_ch = NULL;\n        arg_8h = 0;\n        if ((*piVar1 != 0) && (*(in_ECX[7] + 0x84) != 0)) {\n            arg_8h = *(iVar2 + 8);\n            arg_ch = *(in_ECX[7] + 0x84);\n        }\n        iVar3 = (**(*in_ECX[9] + 0xc))\n                          (in_ECX[9], arg_10h, 0xffffffff, 0, arg_ch, arg_8h, *(iVar2 + 4), &var_30h, &var_20h, 0, 0);\n        if ((arg_ch != NULL) && (iVar3 == -0x7ffbfff9)) {\n            iVar3 = (**(*in_ECX[9] + 0xc))\n                              (in_ECX[9], arg_10h, 0xffffffff, 0, 0, 0, *(iVar2 + 4), &var_30h, &var_20h, 0, 0);\n        }\n        if ((iVar3 == 0) || (iVar3 != -0x7ffbfff9)) {\n            (**(*in_ECX + 200))(iVar3);\n            return 1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 626
    },
    "0045d0f3": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lplpsz\n// WARNING: Variable defined which should be unmapped: pszExeFileName\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint __cdecl\nfcn.0045d0f3(uint arg_8h, uint rclsid, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lplpsz;\n    uint pszExeFileName;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    (*_sym.imp.ole32.dll_StringFromCLSID)(*(unaff_EBP + 0xc), unaff_EBP + -0x14);\n    iVar2 = fcn.0044c16c(*(unaff_EBP + -0x14));\n    if (iVar2 == 0) {\n        uVar3 = 0;\n        goto code_r0x0045d323;\n    }\n    fcn.0045cc38(0, iVar2);\n    fcn.0045cc38(1, *(unaff_EBP + 0x10));\n    (*_sym.imp.ole32.dll_CoTaskMemFree)(iVar2);\n    piVar4 = fcn.0042c770();\n    iVar2 = (**(*piVar4 + 0xc))();\n    *(unaff_EBP + -0x10) = iVar2 + 0x10;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = fcn.0044be10();\n    fcn.0042f3ce(*(iVar2 + 8), unaff_EBP + -0x10);\n    fcn.0045cc38(2, *(unaff_EBP + -0x10));\n    fcn.0045cc38(3, *(unaff_EBP + 0x14));\n    fcn.0045cc38(4, *(unaff_EBP + 0x18));\n    iVar2 = fcn.0044be10();\n    fcn.0045cc38(5, *(iVar2 + 0x10));\n    piVar4 = fcn.0042c770();\n    iVar2 = (**(*piVar4 + 0xc))();\n    *(unaff_EBP + 8) = iVar2 + 0x10;\n    iVar2 = *(unaff_EBP + 0x1c);\n    *(unaff_EBP + -4) = 1;\n    if (iVar2 != 0) {\n        iVar5 = fcn.0044be10();\n        iVar5 = (*_sym.imp.SHELL32.dll_ExtractIconA)(*(iVar5 + 8), *(unaff_EBP + -0x10), iVar2);\n        if (iVar5 == 0) {\n            iVar2 = 0;\n        }\n        else {\n            (*_sym.imp.USER32.dll_DestroyIcon)(iVar5);\n        }\n    }\n    fcn.0045d0e0(unaff_EBP + 8, 0x46be44, iVar2);\n    fcn.0045cc38(6, *(unaff_EBP + 8));\n    fcn.0045cc38(7, *(unaff_EBP + 0x20));\n    piVar4 = fcn.0042c770();\n    iVar2 = (**(*piVar4 + 0xc))();\n    *(unaff_EBP + 0xc) = iVar2 + 0x10;\n    pcVar1 = *(unaff_EBP + 0x24);\n    *(unaff_EBP + -4) = 2;\n    if ((pcVar1 == NULL) || (*pcVar1 == '\\0')) {\n        fcn.004045a1(*(unaff_EBP + 0x20));\n        iVar2 = fcn.0045cd7d(0x28, 0);\n        if (iVar2 != -1) {\n            uVar3 = fcn.0045d072(unaff_EBP + 0x20, iVar2 + 1);\n            *(unaff_EBP + -4) = 3;\n            fcn.004048c5(uVar3);\n            *(unaff_EBP + -4) = 2;\n            fcn.00403164();\n            iVar2 = fcn.0045cd7d(0x2e, 0);\n            if (iVar2 != -1) {\n                uVar3 = fcn.0045d072(unaff_EBP + 0x20, iVar2);\n                *(unaff_EBP + -4) = 4;\n                fcn.004048c5(uVar3);\n                *(unaff_EBP + -4) = 2;\n                fcn.00403164();\n                iVar2 = fcn.0045cd7d(0x29, 0);\n                if (iVar2 != -1) {\n                    uVar3 = fcn.0045d031(unaff_EBP + 0x20, iVar2);\n                    *(unaff_EBP + -4) = 5;\n                    fcn.004048c5(uVar3);\n                    fcn.00403164();\n                    goto code_r0x0045d2f7;\n                }\n            }\n        }\n        fcn.004042f6();\n    }\n    else {\n        fcn.004045a1(pcVar1);\n    }\ncode_r0x0045d2f7:\n    fcn.0045cc38(8, *(unaff_EBP + 0xc));\n    fcn.00403164();\n    fcn.00403164();\n    fcn.00403164();\n    uVar3 = 1;\ncode_r0x0045d323:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 1341
    },
    "0045e4da": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.0045e4da(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if (**(param_1 + 8) == -1) {\n        for (iVar1 = *(param_1 + 4); *(iVar1 + 0x18) != -1; iVar1 = iVar1 + 0x20) {\n        }\n        **(param_1 + 8) = iVar1 - *(param_1 + 4) >> 5;\n    }\n    return **(param_1 + 8);\n}\n",
        "token_count": 123
    },
    "0045e507": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0045e507(uint *arg_8h, uint lpString2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint *puVar4;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    do {\n        if (arg_8h == NULL) {\n            return 0xffffffff;\n        }\n        puVar4 = arg_8h[1];\n        uVar1 = fcn.0045e4da(arg_8h);\n        uVar3 = 0;\n        if (uVar1 != 0) {\n            do {\n                if ((*(puVar4 + 3) != 0xfff) &&\n                   (iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(*puVar4, lpString2),  iVar2 == 0)) {\n                    if (puVar4[1] != 0xffffffff) {\n                        return puVar4[1];\n                    }\n                    return var_4h << 0x10 | uVar3 + 1 & 0xffff;\n                }\n                puVar4 = puVar4 + 8;\n                uVar3 = uVar3 + 1;\n            } while (uVar3 < uVar1);\n        }\n        arg_8h = *arg_8h;\n        var_4h = var_4h + 1;\n    } while( true );\n}\n",
        "token_count": 321
    },
    "0045e573": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0045e573(int32_t *arg_8h, uint32_t arg_ch)\n\n{\n    uint *arg_8h_00;\n    uint *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    bool bVar5;\n    \n    arg_8h_00 = (**(*arg_8h + 0x30))();\n    bVar5 = arg_ch == 0;\n    puVar4 = arg_8h_00;\n    if (bVar5) {\n        for (; puVar4 != NULL; puVar4 = *puVar4) {\n            for (puVar1 = puVar4[1]; puVar1[6] != -1; puVar1 = puVar1 + 8) {\n                if (*(puVar1 + 3) == 0xfff) {\n                    arg_ch = puVar1[1];\n                    if ((arg_ch == 0xffffffff) && (arg_ch = fcn.0045e507(arg_8h_00, *puVar1),  arg_ch == 0xffffffff)) {\n                        return 0;\n                    }\n                    bVar5 = arg_ch == 0;\n                    goto code_r0x0045e5ca;\n                }\n            }\n        }\n    }\n    else {\ncode_r0x0045e5ca:\n        if ((!bVar5 && -1 < arg_ch) && (uVar2 = 0,  arg_8h_00 != NULL)) {\n            puVar4 = arg_8h_00;\n            do {\n                if (arg_ch >> 0x10 <= uVar2) break;\n                puVar4 = *puVar4;\n                uVar2 = uVar2 + 1;\n            } while (puVar4 != NULL);\n            if (puVar4 != NULL) {\n                uVar2 = fcn.0045e4da(puVar4);\n                if ((arg_ch & 0xffff) <= uVar2) {\n                    iVar3 = puVar4[1] + ((arg_ch & 0xffff) * 8 + -8) * 4;\n                    if (*(iVar3 + 4) == 0xffffffff) {\n                        return iVar3;\n                    }\n                    if (*(iVar3 + 4) == arg_ch) {\n                        return iVar3;\n                    }\n                }\n            }\n        }\n    }\n    do {\n        if (arg_8h_00 == NULL) {\n            return 0;\n        }\n        for (iVar3 = arg_8h_00[1]; *(iVar3 + 0x18) != -1; iVar3 = iVar3 + 0x20) {\n            if (*(iVar3 + 4) == arg_ch) {\n                return iVar3;\n            }\n        }\n        arg_8h_00 = *arg_8h_00;\n    } while( true );\n}\n",
        "token_count": 632
    },
    "0040f393": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x0040f425: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x0040f42a)\n// WARNING: Removing unreachable block (ram,0x0040f450)\n// WARNING: Removing unreachable block (ram,0x0040f42f)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040f393(uint uExitCode, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0040daac(0x473298, 8);\n    fcn.00410d9c(8);\n    *(unaff_EBP + -4) = 0;\n    if (*0x49992c == 1) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(*(unaff_EBP + 8));\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1);\n    }\n    *0x499928 = 1;\n    *0x499924 = *(unaff_EBP + 0x10);\n    if (*(unaff_EBP + 0xc) == 0) {\n        if (*0x49b1a8 != NULL) {\n            while( true ) {\n                *0x49b1a4 = *0x49b1a4 + -1;\n                if (*0x49b1a4 < *0x49b1a8) break;\n                if (**0x49b1a4 != NULL) {\n                    (***0x49b1a4)();\n                }\n            }\n        }\n        fcn.0040f2f3(0x4860a8);\n    }\n    fcn.0040f2f3(0x4860b4);\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + 0x10) != 0) {\n        fcn.00410ccf(8);\n    }\n    return;\n}\n",
        "token_count": 466
    },
    "0041b85e": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nvoid fcn.0041b85e(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    puVar3 = param_1 + (param_2 / 0x20) * 4;\n    iVar1 = fcn.0041d42d(*puVar3, 1 << (0x1fU - param_2 % 0x20 & 0x1f), puVar3);\n    iVar2 = param_2 / 0x20 + -1;\n    if (-1 < iVar2) {\n        puVar3 = param_1 + iVar2 * 4;\n        do {\n            if (iVar1 == 0) {\n                return;\n            }\n            iVar1 = fcn.0041d42d(*puVar3, 1, puVar3);\n            iVar2 = iVar2 + -1;\n            puVar3 = puVar3 + -1;\n        } while (-1 < iVar2);\n    }\n    return;\n}\n",
        "token_count": 235
    },
    "00433f79": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n\nuint fcn.00433f79(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint arg_10h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    iVar1 = (**(*extraout_ECX + 0x58))();\n    if (iVar1 == 0) {\n        uVar2 = 1;\n        goto code_r0x0043406e;\n    }\n    piVar3 = fcn.0042c770();\n    iVar1 = (**(*piVar3 + 0xc))();\n    *(unaff_EBP + -0x10) = iVar1 + 0x10;\n    piVar3 = extraout_ECX + 8;\n    iVar1 = *(*piVar3 + -0xc);\n    *(unaff_EBP + -4) = 0;\n    if (iVar1 == 0) {\n        fcn.004048c5(extraout_ECX + 7);\n        if (*(*(unaff_EBP + -0x10) + -0xc) == 0) {\n            fcn.00404503(0xf003);\n        }\n    }\n    else {\n        fcn.004048c5(piVar3);\n        iVar1 = *piVar3;\n        arg_10h = 0x104;\n        uVar2 = fcn.004043ec(0x104, 0x104);\n        fcn.0042ee2a(iVar1, uVar2, arg_10h);\n        fcn.00404cad(0xffffffff);\n    }\n    piVar3 = fcn.0042c770();\n    iVar1 = (**(*piVar3 + 0xc))();\n    *(unaff_EBP + -0x14) = iVar1 + 0x10;\n    *(unaff_EBP + -4) = 1;\n    fcn.00440275(unaff_EBP + -0x14, 0xf103, *(unaff_EBP + -0x10));\n    iVar1 = fcn.0043c064(*(unaff_EBP + -0x14), 3, 0xf103);\n    if (iVar1 == 2) {\ncode_r0x00434055:\n        uVar2 = 0;\n    }\n    else {\n        if (iVar1 == 6) {\n            iVar1 = (**(*extraout_ECX + 0x9c))();\n            if (iVar1 == 0) goto code_r0x00434055;\n        }\n        uVar2 = 1;\n    }\n    fcn.00403164();\n    fcn.00403164();\ncode_r0x0043406e:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 706
    },
    "0044e444": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_60h\n\nvoid __cdecl fcn.0044e444(uint arg_8h, int32_t *arg_ch, int32_t *arg_10h)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint var_60h;\n    int32_t lpNewFileName;\n    uint var_4ch;\n    uint var_44h;\n    uint var_40h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    if (*arg_ch == 0) {\n        iVar3 = *arg_10h;\n        if (iVar3 == 1) {\ncode_r0x0044e493:\n            *arg_ch = iVar3;\n        }\n        else {\n            if (iVar3 == 2) {\n                (**0x4860f8)();\n                *arg_ch = 2;\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenW)(arg_10h[1]);\n                iVar3 = iVar3 * 2 + 2;\n                iVar6 = (*_sym.imp.ole32.dll_CoTaskMemAlloc)(iVar3);\n                arg_ch[1] = iVar6;\n                if (iVar6 != 0) {\n                    fcn.0040e680(iVar6, arg_10h[1], iVar3);\n                }\n                goto code_r0x0044e6e9;\n            }\n            if (iVar3 == 4) {\n                piVar1 = arg_10h[1];\n                arg_ch[1] = piVar1;\n                (**(*piVar1 + 4))(piVar1);\n                *arg_ch = 4;\n                goto code_r0x0044e6e9;\n            }\n            if (iVar3 == 8) {\n                piVar1 = arg_10h[1];\n                arg_ch[1] = piVar1;\n                (**(*piVar1 + 4))(piVar1);\n                *arg_ch = 8;\n                goto code_r0x0044e6e9;\n            }\n            if (iVar3 != 0x10) {\n                if (iVar3 == 0x20) {\n                    lpNewFileName = fcn.0044df96(0, arg_10h[1]);\n                    if (lpNewFileName != 0) {\n                        iVar6 = (*_sym.imp.KERNEL32.dll_GlobalLock)(lpNewFileName);\n                        iVar4 = (*_sym.imp.GDI32.dll_CopyMetaFileA)(*(iVar6 + 0xc), 0);\n                        iVar3 = lpNewFileName;\n                        *(iVar6 + 0xc) = iVar4;\n                        if (iVar4 == 0) {\n                            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(lpNewFileName);\n                            (*_sym.imp.KERNEL32.dll_GlobalFree)(lpNewFileName);\n                        }\n                        else {\n                            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(lpNewFileName);\n                            arg_ch[1] = iVar3;\n                            *arg_ch = 0x20;\n                        }\n                    }\n                    goto code_r0x0044e6e9;\n                }\n                if (iVar3 != 0x40) goto code_r0x0044e6e9;\n                goto code_r0x0044e493;\n            }\n            *arg_ch = 0x10;\n        }\n        arg_ch[1] = 0;\n    }\n    iVar3 = *arg_10h;\n    if (iVar3 == 1) {\n        iVar3 = fcn.0044df96(arg_ch[1], arg_10h[1]);\n        if (iVar3 != 0) {\n            arg_ch[1] = iVar3;\n        }\n    }\n    else if (iVar3 == 2) {\n        uVar5 = (**0x4860f8)();\n        pcVar2 = _sym.imp.KERNEL32.dll_lstrlenW;\n        lpNewFileName = arg_ch[1];\n        if (lpNewFileName == 0) {\n            lpNewFileName = 0;\n        }\n        else {\n            iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenW)(lpNewFileName);\n            fcn.0040dc10();\n            lpNewFileName = fcn.00403fce(&lpNewFileName, lpNewFileName, iVar3 * 2 + 2, uVar5);\n        }\n        iVar3 = arg_10h[1];\n        if (iVar3 == 0) {\n            uVar5 = 0;\n        }\n        else {\n            iVar6 = (*pcVar2)(iVar3);\n            fcn.0040dc10();\n            uVar5 = fcn.00403fce(&lpNewFileName, iVar3, iVar6 * 2 + 2, uVar5);\n        }\n        (*_sym.imp.KERNEL32.dll_CopyFileA)(uVar5, lpNewFileName, 0);\n    }\n    else if (iVar3 == 4) {\n        iVar3 = (**(*arg_10h[1] + 0x30))(arg_10h[1], &var_4ch, 1);\n        if (iVar3 == 0) {\n            lpNewFileName = 0;\n            (**(*arg_ch[1] + 0x14))(arg_ch[1], 0, 0, 0, 0);\n            (**(*arg_10h[1] + 0x14))(arg_10h[1], 0, 0, 0, 0);\n            iVar3 = (**(*arg_10h[1] + 0x1c))(arg_10h[1], arg_ch[1], var_44h, var_40h, 0, 0);\n            if (iVar3 == 0) {\n                (**(*arg_ch[1] + 0x14))(arg_ch[1], 0, 0, 0, 0);\n                (**(*arg_10h[1] + 0x14))(arg_10h[1], 0, 0, 0, 0);\n            }\n        }\n    }\n    else if (iVar3 == 8) {\n        (**(*arg_10h[1] + 0x1c))(arg_10h[1], 0, 0, 0, arg_ch[1]);\n    }\n    else if (((iVar3 == 0x10) || (iVar3 == 0x40)) && (arg_ch[1] == 0)) {\n        iVar3 = (*_sym.imp.ole32.dll_OleDuplicateData)(arg_10h[1], arg_8h, 0);\n        arg_ch[1] = iVar3;\n    }\ncode_r0x0044e6e9:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 1505
    },
    "0040dd2a": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040dd2a(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    uint var_4h;\n    \n    uVar1 = fcn.00412bfa(arg_8h, arg_ch, arg_10h, arg_14h, in_EAX, 0, 0, 0);\n    return uVar1;\n}\n",
        "token_count": 105
    },
    "0040d295": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t * __cdecl\nfcn.0040d295(int32_t *arg_8h, uint lpString, uint chCount, uint nTabPositions, uint lpnTabStopPositions)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    uVar1 = (*_sym.imp.USER32.dll_GetTabbedTextExtentA)\n                      (*(in_ECX + 8), lpString, chCount, nTabPositions, lpnTabStopPositions);\n    arg_8h[1] = uVar1 >> 0x10;\n    *arg_8h = uVar1;\n    return arg_8h;\n}\n",
        "token_count": 140
    },
    "0041d507": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041d507(char *arg_8h, int32_t arg_ch, uint32_t *arg_10h)\n\n{\n    int16_t iVar1;\n    uint32_t *puVar2;\n    uint32_t uVar3;\n    uint var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    puVar2 = arg_10h;\n    var_4h = *0x496830;\n    iVar1 = 0x404e;\n    *arg_10h = 0;\n    arg_10h[1] = 0;\n    arg_10h[2] = 0;\n    if (arg_ch != 0) {\n        arg_10h = arg_ch;\n        do {\n            var_10h = *puVar2;\n            var_ch = puVar2[1];\n            var_8h = puVar2[2];\n            fcn.0041d4ac(puVar2);\n            fcn.0041d4ac(puVar2);\n            fcn.0041d44e(puVar2, &var_10h);\n            fcn.0041d4ac(puVar2);\n            var_10h = *arg_8h;\n            var_ch = 0;\n            var_8h = 0;\n            fcn.0041d44e(puVar2, &var_10h);\n            arg_8h = arg_8h + 1;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != NULL);\n    }\n    if (puVar2[2] == 0) {\n        do {\n            iVar1 = iVar1 + -0x10;\n            uVar3 = puVar2[1] >> 0x10;\n            puVar2[1] = *puVar2 >> 0x10 | puVar2[1] << 0x10;\n            *puVar2 = *puVar2 << 0x10;\n        } while (uVar3 == 0);\n        puVar2[2] = uVar3;\n    }\n    while ((puVar2[2] & 0x8000) == 0) {\n        fcn.0041d4ac(puVar2);\n        iVar1 = iVar1 + -1;\n    }\n    *(puVar2 + 10) = iVar1;\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 561
    },
    "004212e9": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004212e9(int32_t arg_8h, uint32_t arg_ch, uint arg_10h, uint32_t arg_14h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    \n    if (arg_8h == 0) {\n        uVar2 = 0;\n    }\n    else {\n        iVar3 = fcn.0044c776(0x448a07);\n        if ((*(iVar3 + 0x18) != 0) && (iVar4 = fcn.00427905(arg_8h),  iVar4 == 0)) {\n            fcn.004287f6(arg_8h);\n            *(iVar3 + 0x18) = 0;\n        }\n        pcVar1 = _sym.imp.USER32.dll_RegisterWindowMessageA;\n        if (arg_ch == 0x110) {\n            *0x49989c = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(\"commdlg_LBSelChangedNotify\");\n            *0x4998a0 = (*pcVar1)(\"commdlg_ShareViolation\");\n            *0x4998a4 = (*pcVar1)(\"commdlg_FileNameOK\");\n            *0x4998a8 = (*pcVar1)(\"commdlg_ColorOK\");\n            *0x4998ac = (*pcVar1)(\"commdlg_help\");\n            *0x4998b0 = (*pcVar1)(\"commdlg_SetRGBColor\");\n            uVar2 = fcn.0042af4a(arg_8h, 0x110, arg_10h, arg_14h);\n        }\n        else if ((arg_ch == *0x4998ac) || ((arg_ch == 0x111 && (arg_10h == 0x40e)))) {\n            (*_sym.imp.USER32.dll_SendMessageA)(arg_8h, 0x111, 0xe146, 0);\n            uVar2 = 1;\n        }\n        else {\n            if (0xbfff < arg_ch) {\n                piVar5 = fcn.00427905(arg_8h);\n                iVar3 = fcn.0042c6e0(0x471960);\n                if ((iVar3 == 0) || (iVar3 = fcn.0042087e(),  (*(iVar3 + 0x36) & 8) == 0)) {\n                    if (arg_ch == *0x4998a0) {\n                        uVar2 = (**(*piVar5 + 0x158))(arg_14h);\n                        return uVar2;\n                    }\n                    if (arg_ch == *0x4998a4) {\n                        piVar5[0x70] = arg_14h;\n                        uVar2 = (**(*piVar5 + 0x15c))();\n                        piVar5[0x70] = 0;\n                        return uVar2;\n                    }\n                    if (arg_ch == *0x49989c) {\n                        (**(*piVar5 + 0x160))(arg_10h, arg_14h & 0xffff, arg_14h >> 0x10);\n                    }\n                    else if (arg_ch == *0x4998a8) {\n                        uVar2 = (**(*piVar5 + 0x158))();\n                        return uVar2;\n                    }\n                }\n            }\n            uVar2 = 0;\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 778
    },
    "00427806": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t fcn.00427806(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.0044c776(0x448a07);\n    uVar2 = (*_sym.imp.USER32.dll_GetMessageTime)();\n    *(iVar1 + 0x68) = uVar2;\n    uVar2 = (*_sym.imp.USER32.dll_GetMessagePos)();\n    *(iVar1 + 0x70) = uVar2 >> 0x10;\n    *(iVar1 + 0x6c) = uVar2;\n    return iVar1 + 0x58;\n}\n",
        "token_count": 139
    },
    "004289fe": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004289fe(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    uint32_t uVar3;\n    uint var_2ch;\n    uint32_t var_28h;\n    int32_t var_4h;\n    \n    uVar3 = arg_8h & 0xffff;\n    arg_8h = arg_8h >> 0x10;\n    if (arg_ch == 0) {\n        if (uVar3 == 0) {\n            return 0;\n        }\n        fcn.004260ea();\n        var_28h = uVar3;\n        (**(*in_ECX + 0xc))(uVar3, 0xffffffff, &var_2ch, 0);\n        if (var_4h != 0) {\n            arg_8h = 0;\ncode_r0x00428a42:\n            uVar1 = (**(*in_ECX + 0xc))(uVar3, arg_8h, 0, 0);\n            return uVar1;\n        }\n    }\n    else {\n        iVar2 = fcn.0044c776(0x448a07);\n        if ((*(iVar2 + 0xdc) != in_ECX[7]) && (iVar2 = fcn.00428485(arg_ch, 0),  iVar2 == 0)) {\n            if (uVar3 == 0) {\n                return 0;\n            }\n            goto code_r0x00428a42;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 358
    },
    "0042db3b": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0042db3b(uint lpString2, uint nNumber, uint arg_10h, uint arg_14h, uint *arg_18h)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    uint uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    int32_t lptm;\n    int32_t var_78h;\n    int32_t var_50h;\n    uint var_48h;\n    int32_t var_44h;\n    int32_t var_40h;\n    uint var_30h;\n    uint var_29h;\n    uint lpString1;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    uVar3 = (*_sym.imp.USER32.dll_GetDC)(0);\n    fcn.0040e620(&var_40h, 0, 0x3c);\n    uVar4 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(uVar3, 0x5a, 0x48);\n    var_40h = (*_sym.imp.KERNEL32.dll_MulDiv)(nNumber, uVar4);\n    var_40h = -var_40h;\n    var_30h = 400;\n    var_29h._0_1_ = 1;\n    (*_sym.imp.KERNEL32.dll_lstrcpynA)(&lpString1, lpString2, 0x20);\n    var_44h = (*_sym.imp.GDI32.dll_CreateFontIndirectA)(&var_40h);\n    pcVar2 = _sym.imp.USER32.dll_GetDialogBaseUnits;\n    pcVar1 = _sym.imp.GDI32.dll_SelectObject;\n    if (var_44h == 0) {\n        uVar5 = (*_sym.imp.USER32.dll_GetDialogBaseUnits)();\n        uVar5 = uVar5 & 0xffff;\n        uVar6 = (*pcVar2)();\n        uVar6 = uVar6 >> 0x10;\n    }\n    else {\n        var_48h = (*_sym.imp.GDI32.dll_SelectObject)(uVar3, var_44h);\n        (*_sym.imp.GDI32.dll_GetTextMetricsA)(uVar3, &lptm);\n        uVar6 = var_78h + lptm;\n        (*_sym.imp.GDI32.dll_GetTextExtentPoint32A)\n                  (uVar3, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 0x34, &var_50h);\n        uVar5 = (var_50h + 0x1a) / 0x34;\n        (*pcVar1)(uVar3, var_48h);\n        (*_sym.imp.GDI32.dll_DeleteObject)(var_44h);\n    }\n    (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar3);\n    uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(arg_10h, uVar5, 4);\n    *arg_18h = uVar3;\n    uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(arg_14h, uVar6, 8);\n    arg_18h[1] = uVar3;\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 743
    },
    "0043785b": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0043785b(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t in_ECX;\n    uint var_18h;\n    char var_10h;\n    uint var_fh;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    fcn.004373d5(arg_8h, &var_18h);\n    cVar1 = arg_ch >> 0x10;\n    if ((var_fh != arg_ch) || (var_10h != cVar1)) {\n        var_10h = cVar1;\n        var_fh._0_1_ = arg_ch;\n        fcn.004376de(arg_8h, &var_18h);\n        *(in_ECX + 0x9c) = 1;\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 210
    },
    "00437b69": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00437b69(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_2ch;\n    uint var_18h;\n    uint var_14h;\n    uchar var_10h;\n    uint var_fh;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    fcn.004373d5(arg_8h, &var_18h);\n    fcn.0040e680(&var_2ch, &var_18h, 0x14);\n    var_14h = arg_ch;\n    var_18h = arg_14h;\n    var_fh._0_1_ = arg_10h;\n    var_10h = arg_10h >> 0x10;\n    iVar1 = fcn.0040ee70(&var_2ch, &var_18h, 0x14);\n    if (iVar1 != 0) {\n        fcn.004376de(arg_8h, &var_18h);\n        *(in_ECX + 0x9c) = 1;\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 294
    },
    "00437d65": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00437d65(int32_t *arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint uVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar3 = 0;\n    uVar2 = 0;\n    if (0x40046 < *0x494d18) {\n        uVar2 = fcn.0042a1c5();\n        iVar3 = fcn.0042a1f9(0, 0x8800, 0);\n    }\n    iVar1 = fcn.0042783b();\n    if (iVar1 != 0) {\n        *arg_8h = arg_ch;\n        arg_8h[1] = arg_ch >> 0x10;\n    }\n    if (iVar3 != 0) {\n        (*_sym.imp.USER32.dll_SetWindowLongA)(*(in_ECX + 0x1c), 0xfffffff0, uVar2);\n    }\n    return iVar1;\n}\n",
        "token_count": 239
    },
    "00446757": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool __cdecl fcn.00446757(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t *in_ECX;\n    bool bVar6;\n    uint uVar7;\n    uint lpMsg;\n    int32_t var_58h;\n    int32_t var_54h;\n    uint var_50h;\n    int32_t var_40h;\n    int32_t iStack64;\n    int32_t iStack60;\n    int32_t iStack56;\n    int32_t lprc1;\n    int32_t iStack48;\n    int32_t iStack44;\n    int32_t iStack40;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t *var_18h;\n    int32_t *var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t *lprc2;\n    \n    iVar3 = (*_sym.imp.USER32.dll_GetCapture)();\n    if (iVar3 == 0) {\n        fcn.0042d84a();\n        piVar1 = in_ECX + 2;\n        var_1ch = in_ECX[4] - *piVar1;\n        var_20h = in_ECX[5] - in_ECX[3];\n        lprc2 = piVar1;\n        uVar4 = (*_sym.imp.USER32.dll_SetCapture)(*(arg_ch + 0x1c));\n        fcn.004278de(uVar4);\n        pcVar2 = _sym.imp.USER32.dll_UpdateWindow;\n        (*_sym.imp.USER32.dll_UpdateWindow)(*(arg_ch + 0x1c));\n        if (arg_18h != 0) {\n            (*pcVar2)(*(arg_18h + 0x1c));\n        }\n        var_40h = *piVar1;\n        iStack64 = in_ECX[3];\n        iStack60 = in_ECX[4];\n        iStack56 = in_ECX[5];\n        fcn.0044623d(arg_8h, &var_14h, &var_18h, &var_ch, &var_10h);\n        var_ch = arg_10h - var_ch;\n        var_10h = arg_14h - var_10h;\n        if (arg_18h == 0) {\n            uVar4 = (*_sym.imp.USER32.dll_GetDC)(*(arg_ch + 0x1c));\n        }\n        else {\n            uVar4 = (*_sym.imp.USER32.dll_GetDCEx)(*(arg_18h + 0x1c), 0, 2);\n        }\n        iVar3 = fcn.00432120(uVar4);\n        var_8h = 0;\n        do {\n            while( true ) {\n                (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0);\n                uVar4 = (*_sym.imp.USER32.dll_GetCapture)();\n                iVar5 = fcn.004278de(uVar4);\n                if (iVar5 != arg_ch) goto code_r0x00446982;\n                if (var_58h == 0x100) break;\n                if ((var_58h == 0x200) || (var_58h == 0x202)) {\n                    lprc1 = *lprc2;\n                    iStack48 = lprc2[1];\n                    iStack44 = lprc2[2];\n                    iStack40 = lprc2[3];\n                    if (var_14h != NULL) {\n                        *var_14h = var_50h - var_ch;\n                    }\n                    if (var_18h != NULL) {\n                        *var_18h = (var_50h >> 0x10) - var_10h;\n                    }\n                    if (arg_8h == 8) {\n                        in_ECX[4] = *lprc2 + var_1ch;\n                        in_ECX[5] = in_ECX[3] + var_20h;\n                    }\n                    (**(*in_ECX + 4))(arg_8h, lprc2);\n                    in_ECX[0x11] = var_58h == 0x202;\n                    iVar5 = (*_sym.imp.USER32.dll_EqualRect)(&lprc1, lprc2);\n                    if ((iVar5 == 0) || (in_ECX[0x11] != 0)) {\n                        if (var_8h != 0) {\n                            in_ECX[0x10] = 1;\n                            (***in_ECX)(&lprc1, arg_18h, iVar3, arg_ch);\n                        }\n                        (**(*in_ECX + 8))(&lprc1);\n                        if (var_58h != 0x202) {\n                            var_8h = 1;\n                        }\n                        if (in_ECX[0x11] != 0) goto code_r0x00446982;\n                    }\n                    iVar5 = (*_sym.imp.USER32.dll_EqualRect)(&lprc1, lprc2);\n                    if (iVar5 == 0) {\n                        in_ECX[0x10] = 0;\n                        (***in_ECX)(lprc2, arg_18h, iVar3, arg_ch);\n                    }\n                }\n                else {\n                    if (var_58h == 0x204) goto code_r0x00446956;\n                    (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n                }\n            }\n        } while (var_54h != 0x1b);\ncode_r0x00446956:\n        if (var_8h != 0) {\n            in_ECX[0x11] = 1;\n            in_ECX[0x10] = 1;\n            (***in_ECX)(lprc2, arg_18h, iVar3, arg_ch);\n        }\n        *lprc2 = var_40h;\n        lprc2[1] = iStack64;\n        lprc2[2] = iStack60;\n        lprc2[3] = iStack56;\ncode_r0x00446982:\n        if (arg_18h == 0) {\n            uVar4 = *(iVar3 + 4);\n            uVar7 = *(arg_ch + 0x1c);\n        }\n        else {\n            uVar4 = *(iVar3 + 4);\n            uVar7 = *(arg_18h + 0x1c);\n        }\n        (*_sym.imp.USER32.dll_ReleaseDC)(uVar7, uVar4);\n        (*_sym.imp.USER32.dll_ReleaseCapture)();\n        fcn.0042da42(0);\n        if (var_8h == 0) {\n            *lprc2 = var_40h;\n            lprc2[1] = iStack64;\n            lprc2[2] = iStack60;\n            lprc2[3] = iStack56;\n        }\n        in_ECX[0x11] = 0;\n        in_ECX[0x10] = 0;\n        iVar3 = (*_sym.imp.USER32.dll_EqualRect)(&var_40h, lprc2);\n        bVar6 = iVar3 == 0;\n    }\n    else {\n        bVar6 = false;\n    }\n    return bVar6;\n}\n",
        "token_count": 1718
    },
    "00449b19": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid fcn.00449b19(void)\n\n{\n    uint8_t uVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iStack148;\n    int32_t iStack144;\n    uint8_t *puStack140;\n    uchar auStack136 [128];\n    uint uStack8;\n    \n    uStack8 = *0x496830;\n    uVar2 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n    iVar5 = uVar2;\n    iStack148 = uVar2 >> 0x10;\n    if (0x20 < iVar5) {\n        iVar5 = 0x20;\n    }\n    iVar6 = iVar5 + 0xf >> 4;\n    iVar7 = ((iVar5 + -4) / 2 + iVar6 * 0x10) - iVar5;\n    if (0xc < iVar7) {\n        iVar7 = 0xc;\n    }\n    if (0x20 < iStack148) {\n        iStack148 = 0x20;\n    }\n    fcn.0040e620(auStack136, 0xff, 0x80);\n    puVar4 = auStack136 + (iStack148 + -6 >> 1) * iVar6 * 2;\n    puStack140 = 0x46a8b0;\n    iStack144 = 5;\n    do {\n        uVar1 = *puStack140;\n        uVar3 = puStack140 & 0xffff0000;\n        puStack140 = puStack140 + 1;\n        uVar3 = ~((uVar3 | uVar1) << (iVar7 & 0x1f));\n        *puVar4 = uVar3 >> 8;\n        puVar4[1] = uVar3;\n        puVar4 = puVar4 + iVar6 * 2;\n        iStack144 = iStack144 + -1;\n    } while (iStack144 != 0);\n    *0x499608 = (*_sym.imp.GDI32.dll_CreateBitmap)(iVar5, iStack148, 1, 1, auStack136);\n    if (*0x499608 == 0) {\n        *0x499608 = (*_sym.imp.USER32.dll_LoadBitmapA)(0, 0x7fe3);\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 550
    },
    "00409d75": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409d75(int32_t arg_8h, uint arg_ch)\n\n{\n    ushort *in_ECX;\n    \n    if (arg_ch == 10) {\n        *in_ECX = 10;\n    }\n    else {\n        if (arg_ch == 0xb) {\n            *in_ECX = 0xb;\n            in_ECX[4] = -(arg_8h != 0);\n            return;\n        }\n        if (arg_ch == 0x16) {\n            *in_ECX = 0x16;\n        }\n        else if (arg_ch == 0x17) {\n            *in_ECX = 0x17;\n        }\n        else if (arg_ch == 0x19) {\n            *in_ECX = 0x19;\n        }\n        else if (arg_ch == 0x13) {\n            *in_ECX = 0x13;\n        }\n        else {\n            *in_ECX = 3;\n        }\n    }\n    *(in_ECX + 4) = arg_8h;\n    return;\n}\n",
        "token_count": 237
    },
    "00418903": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nvoid fcn.00418903(uint32_t param_1, char *param_2, uint32_t param_3)\n\n{\n    int32_t *piVar1;\n    char cVar2;\n    char *pcVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int32_t iStack1060;\n    int32_t iStack1056;\n    int32_t iStack1052;\n    char *pcStack1048;\n    int32_t iStack1044;\n    int32_t iStack1040;\n    char acStack1036 [1028];\n    uint uStack8;\n    \n    uStack8 = *0x496830;\n    iStack1052 = 0;\n    iStack1056 = 0;\n    if (param_3 == 0) goto code_r0x00418abd;\n    piVar1 = (param_1 >> 5) * 4 + 0x49ae40;\n    iVar8 = (param_1 & 0x1f) * 0x24;\n    if ((*(*piVar1 + 4 + iVar8) & 0x20) != 0) {\n        fcn.0041c84d(param_1, 0, 0, 2);\n    }\n    if ((*(*piVar1 + iVar8 + 1) & 0x80) == 0) {\n        iVar5 = (*_sym.imp.KERNEL32.dll_WriteFile)(*(*piVar1 + iVar8), param_2, param_3, &iStack1060, 0);\n        if (iVar5 == 0) {\n            iStack1040 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        else {\n            iStack1040 = 0;\n            iStack1052 = iStack1060;\n        }\ncode_r0x00418a1f:\n        if (iStack1052 != 0) goto code_r0x00418abd;\n        if (iStack1040 != 0) {\n            if (iStack1040 == 5) {\n                puVar6 = fcn.00410979();\n                *puVar6 = 9;\n                puVar6 = fcn.00410982();\n                *puVar6 = 5;\n            }\n            else {\n                fcn.0041098b(iStack1040);\n            }\n            goto code_r0x00418abd;\n        }\n    }\n    else {\n        pcStack1048 = param_2;\n        iStack1040 = 0;\n        if (param_3 != 0) {\n            do {\n                uVar7 = pcStack1048 - param_2;\n                pcVar4 = acStack1036;\n                iStack1044 = 0;\n                do {\n                    if (param_3 <= uVar7) break;\n                    pcVar3 = pcStack1048 + 1;\n                    cVar2 = *pcStack1048;\n                    uVar7 = uVar7 + 1;\n                    if (cVar2 == '\\n') {\n                        iStack1056 = iStack1056 + 1;\n                        *pcVar4 = '\\r';\n                        pcVar4 = pcVar4 + 1;\n                        iStack1044 = iStack1044 + 1;\n                    }\n                    *pcVar4 = cVar2;\n                    pcVar4 = pcVar4 + 1;\n                    iStack1044 = iStack1044 + 1;\n                    pcStack1048 = pcVar3;\n                } while (iStack1044 < 0x400);\n                iVar5 = (*_sym.imp.KERNEL32.dll_WriteFile)\n                                  (*(*piVar1 + iVar8), acStack1036, pcVar4 - acStack1036, &iStack1060, 0);\n                if (iVar5 == 0) {\n                    iStack1040 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    goto code_r0x00418a1f;\n                }\n                iStack1052 = iStack1052 + iStack1060;\n                if ((iStack1060 < pcVar4 - acStack1036) || (param_3 <= pcStack1048 - param_2)) goto code_r0x00418a1f;\n            } while( true );\n        }\n    }\n    if (((*(*piVar1 + 4 + iVar8) & 0x40) == 0) || (*param_2 != '\\x1a')) {\n        puVar6 = fcn.00410979();\n        *puVar6 = 0x1c;\n        puVar6 = fcn.00410982();\n        *puVar6 = 0;\n    }\ncode_r0x00418abd:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 1055
    },
    "0041d22b": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041d22b(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    \n    if ((arg_10h == 10) && (arg_8h < 0)) {\n        uVar1 = 1;\n        arg_10h = 10;\n    }\n    else {\n        uVar1 = 0;\n    }\n    fcn.0041d1ed(arg_10h, uVar1);\n    return arg_ch;\n}\n",
        "token_count": 118
    },
    "0041d255": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041d255(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    \n    uVar1 = 0;\n    if ((arg_10h == 10) && (arg_8h < 0)) {\n        uVar1 = 1;\n    }\n    fcn.0041d1ed(arg_10h, uVar1);\n    return arg_ch;\n}\n",
        "token_count": 103
    },
    "00431152": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_11h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nint32_t __cdecl\nfcn.00431152(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint extraout_ECX;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_ch_2;\n    uint var_10h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_11h;\n    uint var_ch;\n    uint var_4h;\n    uint uStack4;\n    \n    uStack4 = 0x43115c;\n    fcn.0040e188();\n    iVar3 = *(unaff_EBP + 0xc);\n    iVar4 = 0;\n    *(unaff_EBP + -0x10) = &fcn.00431152::var_1ch;\n    *(unaff_EBP + -0x1c) = extraout_ECX;\n    if (iVar3 < 0) {\n        iVar3 = -iVar3;\n    }\n    iVar2 = *(unaff_EBP + 8);\n    if (iVar2 == 0) {\n        iVar2 = 0;\n    }\n    else {\n        *(unaff_EBP + -4) = 0;\n        for (; *(unaff_EBP + -0x18) = iVar4,  iVar4 < iVar3; iVar4 = iVar4 + 1) {\n            var_1ch = unaff_EBP + -0x11;\n            fcn.004068c3();\n            cVar1 = *(unaff_EBP + -0x11);\n            if (cVar1 == '\\n') {\ncode_r0x004311b0:\n                if (*(unaff_EBP + 0xc) != iVar3) {\n                    *(iVar4 + iVar2) = cVar1;\n                    iVar4 = iVar4 + 1;\n                }\n                break;\n            }\n            if (cVar1 == '\\r') {\n                fcn.004068c3(unaff_EBP + -0x11);\n                cVar1 = *(unaff_EBP + -0x11);\n                goto code_r0x004311b0;\n            }\n            *(iVar4 + iVar2) = cVar1;\n        }\n        *(iVar4 + iVar2) = 0;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 641
    },
    "0043f895": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043f895(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    uint uVar4;\n    uint lprcDst;\n    uint lprcSrc1;\n    int32_t lprcSrc2;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar1 = arg_8h - *(in_ECX + 4);\n    iVar3 = arg_ch - *(in_ECX + 8);\n    iVar2 = *(in_ECX + 0x8c);\n    uVar4 = 2;\n    if (iVar2 == 10) {\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + iVar1;\n    }\n    else {\n        if (iVar2 != 0xb) {\n            uVar4 = 0x22;\n            if (iVar2 == 0xc) {\n                *(in_ECX + 0x2c) = *(in_ECX + 0x2c) + iVar3;\n            }\n            else {\n                *(in_ECX + 0x34) = *(in_ECX + 0x34) + iVar3;\n            }\n            iVar2 = *(in_ECX + 0x34) - *(in_ECX + 0x2c);\n            goto code_r0x0043f8ed;\n        }\n        *(in_ECX + 0x30) = *(in_ECX + 0x30) + iVar1;\n    }\n    iVar2 = *(in_ECX + 0x30) - *(in_ECX + 0x28);\ncode_r0x0043f8ed:\n    if (iVar2 < 0) {\n        iVar2 = 0;\n    }\n    (**(**(in_ECX + 0x68) + 0x134))(&var_8h, iVar2, uVar4);\n    uVar4 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    (*_sym.imp.USER32.dll_GetWindowRect)(uVar4, &lprcSrc1);\n    lprcSrc2 = *(in_ECX + 0x48);\n    var_14h = *(in_ECX + 0x4c);\n    var_10h = *(in_ECX + 0x50);\n    var_ch = *(in_ECX + 0x54);\n    if ((*(in_ECX + 0x8c) == 10) || (*(in_ECX + 0x8c) == 0xc)) {\n        lprcSrc2 = ((var_10h - *(in_ECX + 0x60)) - var_8h) + *(in_ECX + 0x58);\n        var_14h = ((*(in_ECX + 0x5c) - *(in_ECX + 100)) - var_4h) + var_ch;\n        iVar2 = (*_sym.imp.USER32.dll_IntersectRect)(&lprcDst, &lprcSrc1, &lprcSrc2);\n        if (iVar2 != 0) {\n            *(in_ECX + 0x38) = *(in_ECX + 0x40) - var_8h;\n            *(in_ECX + 0x3c) = *(in_ECX + 0x44) - var_4h;\n            *(in_ECX + 0x48) = lprcSrc2;\n            *(in_ECX + 0x4c) = var_14h;\n        }\n    }\n    else {\n        var_10h = (*(in_ECX + 0x60) - *(in_ECX + 0x58)) + lprcSrc2 + var_8h;\n        var_ch = (*(in_ECX + 100) - *(in_ECX + 0x5c)) + var_14h + var_4h;\n        iVar2 = (*_sym.imp.USER32.dll_IntersectRect)(&lprcDst, &lprcSrc1, &lprcSrc2);\n        if (iVar2 != 0) {\n            *(in_ECX + 0x40) = *(in_ECX + 0x38) + var_8h;\n            *(in_ECX + 0x44) = *(in_ECX + 0x3c) + var_4h;\n            *(in_ECX + 0x50) = var_10h;\n            *(in_ECX + 0x54) = var_ch;\n        }\n    }\n    *(in_ECX + 4) = arg_8h;\n    *(in_ECX + 8) = arg_ch;\n    fcn.0043f689(0);\n    return;\n}\n",
        "token_count": 1089
    },
    "004475a1": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nint32_t fcn.004475a1(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    char *pcVar1;\n    char *pcVar2;\n    \n    pcVar1 = param_3 + param_1;\n    pcVar2 = param_2 + param_1;\n    if (pcVar1 < pcVar2) {\n        do {\n            if (*pcVar1 != '\\r') break;\n            pcVar1 = pcVar1 + 1;\n        } while (pcVar1 < pcVar2);\n        if ((pcVar1 < pcVar2) && (*pcVar1 == '\\n')) {\n            pcVar1 = pcVar1 + 1;\n        }\n    }\n    return pcVar1 - param_1;\n}\n",
        "token_count": 173
    },
    "0043262d": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043262d(uint arg_8h, int32_t arg_ch, int32_t arg_10h, uint arg_14h, int32_t *arg_18h)\n\n{\n    uint16_t uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint uVar5;\n    uint var_3ch;\n    uint var_34h;\n    uint var_2ch;\n    uint var_24h;\n    uint var_1ch;\n    uint var_14h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    uVar1 = *(arg_10h + 4);\n    if (uVar1 < 0x20c) {\n        if (uVar1 == 0x20b) {\n            fcn.00431c1d(&var_ch, *(arg_10h + 8), *(arg_10h + 6));\n            return 1;\n        }\n        if (uVar1 == 0x1e) {\n            (**(*arg_18h + 0x1c))();\n            return 1;\n        }\n        if (uVar1 == 0x103) {\n            (**(*arg_18h + 0x34))(*(arg_10h + 6));\n            return 1;\n        }\n        if (uVar1 == 0x127) {\n            (**(*arg_18h + 0x20))(*(arg_10h + 6));\n            return 1;\n        }\n        if (uVar1 == 0x12d) {\n            uVar5 = *(arg_ch + *(arg_10h + 6) * 4);\n            iVar3 = (*_sym.imp.GDI32.dll_GetObjectType)(uVar5);\n            if (iVar3 == 0) {\n                var_4h = (*_sym.imp.GDI32.dll_GetStockObject)(0xd);\n                pcVar2 = _sym.imp.GDI32.dll_SelectObject;\n                uVar4 = (*_sym.imp.GDI32.dll_SelectObject)(arg_18h[1], var_4h);\n                var_8h = (*pcVar2)(arg_18h[1], uVar5);\n                if (var_8h == var_4h) {\n                    iVar3 = *arg_18h;\n                    uVar5 = fcn.0043241d(uVar5);\n                    (**(iVar3 + 0x28))(uVar5);\n                    return 1;\n                }\n                (*pcVar2)(arg_18h[1], uVar4);\n                (*pcVar2)(arg_18h[1], var_8h);\n            }\n            else if (iVar3 == 6) {\n                iVar3 = *arg_18h;\n                uVar5 = fcn.0043241d(uVar5);\n                (**(iVar3 + 0x28))(uVar5);\n                return 1;\n            }\n        }\n        else {\n            if (uVar1 == 0x201) {\n                (**(*arg_18h + 0x2c))(*(arg_10h + 6));\n                return 1;\n            }\n            if (uVar1 == 0x209) {\n                (**(*arg_18h + 0x30))(*(arg_10h + 6));\n                return 1;\n            }\n        }\n    }\n    else {\n        if (uVar1 == 0x20c) {\n            (**(*arg_18h + 0x48))(&var_3ch, *(arg_10h + 8), *(arg_10h + 6));\n            return 1;\n        }\n        if (uVar1 == 0x20d) {\n            (**(*arg_18h + 0x38))(&var_34h, *(arg_10h + 8), *(arg_10h + 6));\n            return 1;\n        }\n        if (uVar1 == 0x20e) {\n            (**(*arg_18h + 0x40))(&var_2ch, *(arg_10h + 8), *(arg_10h + 6));\n            return 1;\n        }\n        if (uVar1 == 0x211) {\n            (**(*arg_18h + 0x3c))(&var_24h, *(arg_10h + 8), *(arg_10h + 6));\n            return 1;\n        }\n        if (uVar1 == 0x410) {\n            (**(*arg_18h + 0x4c))(&var_1ch, *(arg_10h + 0xc), *(arg_10h + 10), *(arg_10h + 8), *(arg_10h + 6));\n            return 1;\n        }\n        if (uVar1 == 0x412) {\n            (**(*arg_18h + 0x44))(&var_14h, *(arg_10h + 0xc), *(arg_10h + 10), *(arg_10h + 8), *(arg_10h + 6));\n            return 1;\n        }\n    }\n    (*_sym.imp.GDI32.dll_PlayMetaFileRecord)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return 1;\n}\n",
        "token_count": 1178
    },
    "00441cd5": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00441cd5(int32_t param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    \n    if ((((param_2 != 0) && (param_2 != 6)) && (param_2 != 7)) && ((param_2 != 8 && (param_2 != 4)))) {\n        uVar1 = (*_sym.imp.USER32.dll_GetLastActivePopup)(*(param_1 + 0x1c));\n        (*_sym.imp.USER32.dll_BringWindowToTop)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 132
    },
    "0041076b": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\nuint32_t * __cdecl fcn.0041076b(uint32_t *arg_8h)\n\n{\n    uint32_t *arg_8h_00;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    bool bVar4;\n    int64_t iVar5;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    uVar3 = arg_8h[1];\n    if (((uVar3 < 0) || (0x1000 < uVar3)) || ((0xfff < uVar3 && (*arg_8h != 0)))) {\n        arg_8h_00 = NULL;\n    }\n    else {\n        fcn.00417ad9();\n        uVar3 = arg_8h[1];\n        uVar2 = *arg_8h;\n        if ((uVar3 < 0) || ((uVar3 < 1 && (uVar2 < 0x3f481)))) {\n            arg_8h_00 = fcn.004172cd(arg_8h);\n            if ((*0x496f54 == 0) || (iVar1 = fcn.00417b5a(arg_8h_00),  iVar1 == 0)) {\n                uVar3 = *arg_8h_00;\n                var_8h = uVar3 - *0x496f50;\n                var_4h = ((uVar3 >> 0x1f) - (*0x496f50 >> 0x1f)) - (uVar3 < *0x496f50);\n            }\n            else {\n                uVar2 = *0x496f50 + *0x496f58;\n                uVar3 = *arg_8h_00;\n                var_8h = uVar3 - uVar2;\n                var_4h = ((uVar3 >> 0x1f) - (uVar2 >> 0x1f)) - (uVar3 < uVar2);\n                arg_8h_00[8] = 1;\n            }\n            uVar3 = fcn.00417ba0(var_8h, var_4h, 0x3c, 0);\n            *arg_8h_00 = uVar3;\n            if (uVar3 < 0) {\n                *arg_8h_00 = uVar3 + 0x3c;\n                bVar4 = 0x3b < var_8h;\n                var_8h = var_8h - 0x3c;\n                var_4h = var_4h + -1 + bVar4;\n            }\n            _var_8h = fcn.00410a00(var_8h, var_4h, 0x3c, 0);\n            _var_8h = _var_8h + arg_8h_00[1];\n            uVar3 = fcn.00417ba0(_var_8h, 0x3c, 0);\n            arg_8h_00[1] = uVar3;\n            if (uVar3 < 0) {\n                arg_8h_00[1] = uVar3 + 0x3c;\n                _var_8h = _var_8h + -0x3c;\n            }\n            iVar5 = fcn.00410a00(_var_8h, 0x3c, 0);\n            _var_8h = iVar5 + arg_8h_00[2];\n            uVar3 = fcn.00417ba0(_var_8h, 0x18, 0);\n            arg_8h_00[2] = uVar3;\n            if (uVar3 < 0) {\n                arg_8h_00[2] = uVar3 + 0x18;\n                _var_8h = _var_8h + -0x18;\n            }\n            iVar5 = fcn.00410a00(_var_8h, 0x18, 0);\n            iVar1 = iVar5;\n            if ((iVar5 < 0x100000000) && (iVar5 < 0)) {\n                arg_8h_00[6] = (arg_8h_00[6] + 7 + iVar1) % 7;\n                arg_8h_00[3] = arg_8h_00[3] + iVar1;\n                if (arg_8h_00[3] < 1) {\n                    arg_8h_00[5] = arg_8h_00[5] - 1;\n                    arg_8h_00[3] = arg_8h_00[3] + 0x1f;\n                    arg_8h_00[7] = 0x16c;\n                    arg_8h_00[4] = 0xb;\n                }\n                else {\n                    arg_8h_00[7] = arg_8h_00[7] + iVar1;\n                }\n            }\n        }\n        else {\n            var_8h = uVar2 - *0x496f50;\n            var_4h = (uVar3 - (*0x496f50 >> 0x1f)) - (uVar2 < *0x496f50);\n            arg_8h_00 = fcn.004172cd(&var_8h);\n            if ((*0x496f54 != 0) && (iVar1 = fcn.00417b5a(arg_8h_00),  iVar1 != 0)) {\n                bVar4 = var_8h < *0x496f58;\n                var_8h = var_8h - *0x496f58;\n                var_4h = (var_4h - (*0x496f58 >> 0x1f)) - bVar4;\n                arg_8h_00 = fcn.004172cd(&var_8h);\n                arg_8h_00[8] = 1;\n            }\n        }\n    }\n    return arg_8h_00;\n}\n",
        "token_count": 1352
    },
    "0041953e": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\nint32_t fcn.0041953e(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    int32_t var_10h;\n    uint *var_ch;\n    uint *var_8h;\n    int32_t *var_4h;\n    \n    iVar1 = *0x497330;\n    iVar9 = 0;\n    var_4h = NULL;\n    do {\n        iVar2 = fcn.0040e9c0(*(var_4h * 4 + 0x1c + iVar1));\n        iVar3 = fcn.0040e9c0(*(var_4h * 4 + iVar1));\n        var_4h = var_4h + 1;\n        iVar9 = iVar3 + iVar9 + 2 + iVar2;\n    } while (var_4h < 7);\n    var_ch = iVar1 + 0x38;\n    var_8h = 0xc;\n    do {\n        iVar2 = fcn.0040e9c0(var_ch[0xc]);\n        iVar3 = fcn.0040e9c0(*var_ch);\n        var_ch = var_ch + 1;\n        var_8h = var_8h + -1;\n        iVar9 = iVar3 + iVar9 + 2 + iVar2;\n    } while (var_8h != NULL);\n    iVar2 = fcn.0040e9c0(*(iVar1 + 0x98));\n    iVar3 = fcn.0040e9c0(*(iVar1 + 0x9c));\n    iVar4 = fcn.0040e9c0(*(iVar1 + 0xa0));\n    iVar5 = fcn.0040e9c0(*(iVar1 + 0xa4));\n    iVar6 = fcn.0040e9c0(*(iVar1 + 0xa8));\n    iVar9 = fcn.0040d946(iVar3 + iVar9 + iVar2 + iVar4 + iVar5 + iVar6 + 0xbd);\n    if (iVar9 != 0) {\n        iVar2 = iVar9 + 0xb8;\n        fcn.0040e680(iVar9, *0x497330, 0xb8);\n        var_4h = NULL;\n        var_8h = iVar1 + 0x1c;\n        do {\n            *(iVar9 + var_4h * 4) = iVar2;\n            uVar7 = fcn.00415f50(iVar2, var_8h[-7]);\n            iVar3 = fcn.0040e9c0(uVar7);\n            iVar3 = iVar2 + 1 + iVar3;\n            *((iVar9 - iVar1) + var_8h) = iVar3;\n            uVar7 = fcn.00415f50(iVar3, *var_8h);\n            iVar2 = fcn.0040e9c0(uVar7);\n            var_8h = var_8h + 1;\n            var_4h = var_4h + 1;\n            iVar2 = iVar3 + 1 + iVar2;\n        } while (var_4h < 7);\n        var_4h = iVar9 + 0x68;\n        puVar8 = iVar1 + 0x38;\n        var_10h = 0xc;\n        do {\n            *(puVar8 + (iVar9 - iVar1)) = iVar2;\n            uVar7 = fcn.00415f50(iVar2, *puVar8);\n            iVar3 = fcn.0040e9c0(uVar7);\n            iVar3 = iVar2 + 1 + iVar3;\n            *var_4h = iVar3;\n            uVar7 = fcn.00415f50(iVar3, puVar8[0xc]);\n            iVar2 = fcn.0040e9c0(uVar7);\n            puVar8 = puVar8 + 1;\n            var_4h = var_4h + 1;\n            var_10h = var_10h + -1;\n            iVar2 = iVar3 + 1 + iVar2;\n        } while (var_10h != 0);\n        *(iVar9 + 0x98) = iVar2;\n        uVar7 = fcn.00415f50(iVar2, *(iVar1 + 0x98));\n        iVar3 = fcn.0040e9c0(uVar7);\n        iVar3 = iVar2 + 1 + iVar3;\n        *(iVar9 + 0x9c) = iVar3;\n        uVar7 = fcn.00415f50(iVar3, *(iVar1 + 0x9c));\n        iVar2 = fcn.0040e9c0(uVar7);\n        iVar2 = iVar3 + 1 + iVar2;\n        *(iVar9 + 0xa0) = iVar2;\n        uVar7 = fcn.00415f50(iVar2, *(iVar1 + 0xa0));\n        iVar3 = fcn.0040e9c0(uVar7);\n        iVar3 = iVar2 + 1 + iVar3;\n        *(iVar9 + 0xa4) = iVar3;\n        uVar7 = fcn.00415f50(iVar3, *(iVar1 + 0xa4));\n        iVar2 = fcn.0040e9c0(uVar7);\n        iVar2 = iVar3 + 1 + iVar2;\n        *(iVar9 + 0xa8) = iVar2;\n        fcn.00415f50(iVar2, *(iVar1 + 0xa8));\n    }\n    return iVar9;\n}\n",
        "token_count": 1288
    },
    "0044916d": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044916d(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t arg_8h_00;\n    int32_t iVar4;\n    uint16_t *puVar5;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = fcn.0044be10();\n    uVar1 = *(iVar2 + 0xc);\n    iVar2 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar1, arg_8h, 0xf1);\n    if (((iVar2 != 0) && (iVar2 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar1, iVar2),  iVar2 != 0)) &&\n       (iVar3 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar2),  iVar3 != 0)) {\n        arg_8h_00 = fcn.00425ce2(*(iVar3 + 6) << 2);\n        iVar4 = 0;\n        if (*(iVar3 + 6) != 0) {\n            puVar5 = iVar3 + 8;\n            do {\n                *(arg_8h_00 + iVar4 * 4) = *puVar5;\n                iVar4 = iVar4 + 1;\n                puVar5 = puVar5 + 1;\n            } while (iVar4 < *(iVar3 + 6));\n        }\n        iVar4 = fcn.00448cb8(arg_8h_00, *(iVar3 + 6));\n        fcn.00425d0d(arg_8h_00);\n        if (iVar4 != 0) {\n            fcn.00448f7d(*(iVar3 + 2) + 7, *(iVar3 + 4) + 7, *(iVar3 + 2), *(iVar3 + 4));\n            iVar4 = fcn.00449067(arg_8h);\n        }\n        (*_sym.imp.KERNEL32.dll_FreeResource)(iVar2);\n        return iVar4;\n    }\n    return 0;\n}\n",
        "token_count": 466
    },
    "00410447": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\nuint8_t * __cdecl fcn.00410447(uint8_t *arg_8h, uint32_t arg_ch)\n\n{\n    uint8_t uVar1;\n    uint16_t uVar2;\n    int32_t iVar3;\n    uint8_t uVar4;\n    uint8_t *puVar5;\n    uint8_t *puVar6;\n    bool bVar7;\n    \n    puVar5 = NULL;\n    iVar3 = fcn.00412cd5();\n    iVar3 = *(iVar3 + 0x60);\n    if (iVar3 != *0x49af6c) {\n        iVar3 = fcn.0040fc0e();\n    }\n    if (*(iVar3 + 8) != 0) {\n        do {\n            uVar4 = *arg_8h;\n            if ((*(uVar4 + 0x1d + iVar3) & 4) == 0) {\n                bVar7 = arg_ch == uVar4;\ncode_r0x004104a2:\n                puVar6 = arg_8h;\n                if (bVar7) {\n                    puVar5 = arg_8h;\n                }\n            }\n            else {\n                puVar6 = arg_8h + 1;\n                uVar1 = *puVar6;\n                if (uVar1 == 0) {\n                    bVar7 = puVar5 == NULL;\n                    arg_8h = puVar6;\n                    uVar4 = uVar1;\n                    goto code_r0x004104a2;\n                }\n                uVar2 = CONCAT11(uVar4, uVar1);\n                uVar4 = uVar1;\n                if (arg_ch == uVar2) {\n                    puVar5 = arg_8h;\n                }\n            }\n            arg_8h = puVar6 + 1;\n            if (uVar4 == 0) {\n                return puVar5;\n            }\n        } while( true );\n    }\n    iVar3 = -1;\n    do {\n        puVar5 = arg_8h;\n        if (iVar3 == 0) break;\n        iVar3 = iVar3 + -1;\n        puVar5 = arg_8h + 1;\n        uVar4 = *arg_8h;\n        arg_8h = puVar5;\n    } while (uVar4 != 0);\n    iVar3 = -(iVar3 + 1);\n    puVar5 = puVar5 + -1;\n    do {\n        puVar6 = puVar5;\n        if (iVar3 == 0) break;\n        iVar3 = iVar3 + -1;\n        puVar6 = puVar5 + -1;\n        uVar4 = *puVar5;\n        puVar5 = puVar6;\n    } while (arg_ch != uVar4);\n    puVar6 = puVar6 + 1;\n    if (*puVar6 != arg_ch) {\n        puVar6 = NULL;\n    }\n    return puVar6;\n}\n",
        "token_count": 646
    },
    "0041b9d8": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041b9d8(uint16_t *arg_8h, uint32_t *arg_ch, int32_t *arg_10h)\n\n{\n    uint16_t uVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint var_18h;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    uVar1 = arg_8h[5];\n    var_ch = *(arg_8h + 3);\n    var_8h = *(arg_8h + 1);\n    var_4h = *arg_8h << 0x10;\n    uVar5 = uVar1 & 0x7fff;\n    iVar6 = uVar5 - 0x3fff;\n    if (iVar6 == -0x3fff) {\n        iVar6 = 0;\n        uVar5 = fcn.0041b944();\n        uVar2 = uVar5;\n        if (uVar5 != 0) {\ncode_r0x0041baf0:\n            uVar3 = 0;\n            goto code_r0x0041baf2;\n        }\n    }\n    else {\n        fcn.0041b91d(&var_18h, &var_ch);\n        iVar4 = fcn.0041b8ab(&var_ch, arg_10h[2]);\n        if (iVar4 != 0) {\n            iVar6 = uVar5 - 0x3ffe;\n        }\n        iVar4 = arg_10h[1];\n        if (iVar6 < iVar4 - arg_10h[2]) {\n            var_ch = 0;\n            var_8h = 0;\n            uVar5 = var_ch;\n            uVar2 = var_8h;\n        }\n        else {\n            if (iVar4 < iVar6) {\n                if (*arg_10h <= iVar6) {\n                    var_8h = 0;\n                    var_4h = 0;\n                    var_ch = 0x80000000;\n                    fcn.0041b95d(&var_ch, arg_10h[3]);\n                    iVar6 = arg_10h[5] + *arg_10h;\n                    uVar3 = 1;\n                    goto code_r0x0041baf2;\n                }\n                var_ch = var_ch & 0x7fffffff;\n                iVar6 = arg_10h[5] + iVar6;\n                fcn.0041b95d(&var_ch, arg_10h[3]);\n                goto code_r0x0041baf0;\n            }\n            fcn.0041b91d(&var_ch, &var_18h);\n            fcn.0041b95d(&var_ch, iVar4 - iVar6);\n            fcn.0041b8ab(&var_ch, arg_10h[2]);\n            fcn.0041b95d(&var_ch, arg_10h[3] + 1);\n            uVar5 = var_ch;\n            uVar2 = var_8h;\n        }\n    }\n    var_8h = uVar2;\n    var_ch = uVar5;\n    iVar6 = 0;\n    uVar3 = 2;\ncode_r0x0041baf2:\n    var_ch = iVar6 << (0x1fU - arg_10h[3] & 0x1f) | -((uVar1 & 0x8000) != 0) & 0x80000000 | var_ch;\n    if (arg_10h[4] == 0x40) {\n        arg_ch[1] = var_ch;\n        *arg_ch = var_8h;\n    }\n    else if (arg_10h[4] == 0x20) {\n        *arg_ch = var_ch;\n    }\n    return uVar3;\n}\n",
        "token_count": 877
    },
    "0041bb5c": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041bb5c(uint16_t *arg_8h, uint *arg_ch)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    uint16_t uVar3;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    uVar1 = arg_8h[5];\n    var_10h = *(arg_8h + 3);\n    var_ch = *(arg_8h + 1);\n    var_8h = *arg_8h << 0x10;\n    uVar3 = uVar1 & 0x7fff;\n    iVar2 = fcn.0041b8ab(&var_10h, 0x40);\n    if (iVar2 != 0) {\n        var_10h = 0x80000000;\n        uVar3 = uVar3 + 1;\n    }\n    if (uVar3 == 0x7fff) {\n        var_4h = 1;\n    }\n    arg_ch[1] = var_10h;\n    *(arg_ch + 2) = uVar1 & 0x8000 | uVar3;\n    *arg_ch = var_ch;\n    return var_4h;\n}\n",
        "token_count": 296
    },
    "00423541": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00423541(int32_t arg_8h, uint *arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    uint var_24h;\n    uint32_t var_20h;\n    uint32_t var_18h;\n    uint var_10h;\n    uint32_t lpPoint;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    puVar3 = arg_ch;\n    puVar4 = &var_24h;\n    for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = *puVar3;\n        puVar3 = puVar3 + 1;\n        puVar4 = puVar4 + 1;\n    }\n    var_24h = (*_sym.imp.USER32.dll_SendMessageA)(*(arg_8h + 0x1c), 0x410, 0, &var_10h);\n    lpPoint = arg_ch[5];\n    var_4h = arg_ch[6];\n    if ((0x1ff < var_20h) && (var_20h < 0x20a)) {\n        (*_sym.imp.USER32.dll_ScreenToClient)(var_24h, &lpPoint);\n    }\n    var_18h = lpPoint & 0xffff | var_4h << 0x10;\n    (*pcVar1)(*(arg_8h + 0x1c), 0x407, 0, &var_24h);\n    return;\n}\n",
        "token_count": 370
    },
    "00436ba7": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00436ba7(int32_t arg_8h, uint32_t lpPoint, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    while( true ) {\n        (*_sym.imp.USER32.dll_ScreenToClient)(arg_8h, &lpPoint);\n        iVar1 = (*_sym.imp.USER32.dll_SendMessageA)(arg_8h, 0x366, 0, lpPoint & 0xffff | arg_10h << 0x10);\n        (*_sym.imp.USER32.dll_ClientToScreen)(arg_8h, &lpPoint);\n        uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(arg_8h, 0xfffffff0);\n        if (((uVar2 & 0x40000000) == 0) || (arg_8h = (*_sym.imp.USER32.dll_GetParent)(arg_8h),  arg_8h == 0)) break;\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n    }\n    if (iVar1 != 0) {\n        return iVar1;\n    }\n    return -1;\n}\n",
        "token_count": 267
    },
    "00437477": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00437477(uint arg_8h)\n\n{\n    uint var_18h;\n    uint var_10h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    fcn.004373d5(arg_8h, &var_18h);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 84
    },
    "0043759b": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0043759b(uint arg_8h, uint *arg_ch, uint32_t *arg_10h, uint *arg_14h)\n\n{\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    fcn.004373d5(arg_8h, &var_18h);\n    *arg_ch = var_14h;\n    *arg_10h = var_10h << 0x10 | var_10h._1_1_;\n    *arg_14h = var_18h;\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 171
    },
    "00443270": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00443270(int32_t arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t in_ECX;\n    uint32_t uVar7;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetKeyState;\n    iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(0x11);\n    if (iVar2 < 0) {\n        uVar7 = 8;\n    }\n    else {\n        uVar7 = 0;\n    }\n    iVar2 = (*pcVar1)(0x10);\n    if (iVar2 < 0) {\n        uVar3 = 4;\n    }\n    else {\n        uVar3 = 0;\n    }\n    iVar4 = (*_sym.imp.USER32.dll_GetFocus)();\n    iVar5 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    if (iVar4 == 0) {\n        iVar6 = (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x20a, arg_8h << 0x10 | uVar7 | uVar3, arg_ch);\n    }\n    else {\n        do {\n            iVar6 = (*_sym.imp.USER32.dll_SendMessageA)(iVar4, 0x20a, arg_8h << 0x10 | uVar7 | uVar3, arg_ch);\n            iVar4 = (*_sym.imp.USER32.dll_GetParent)(iVar4);\n            if (iVar6 != 0) {\n                return iVar6;\n            }\n            if (iVar4 == 0) {\n                return 0;\n            }\n        } while (iVar4 != iVar5);\n    }\n    return iVar6;\n}\n",
        "token_count": 419
    },
    "00448f7d": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00448f7d(uint32_t arg_8h, int32_t arg_ch, uint32_t arg_10h, int32_t arg_14h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    iVar2 = (*_sym.imp.USER32.dll_IsWindow)(*(in_ECX + 0x1c));\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if (iVar2 == 0) {\n        *(in_ECX + 0xa8) = arg_8h;\n        *(in_ECX + 0xac) = arg_ch;\n        *(in_ECX + 0xa0) = arg_10h;\n        *(in_ECX + 0xa4) = arg_14h;\n    }\n    else {\n        (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x420, 0, arg_10h & 0xffff | arg_14h << 0x10);\n        (*pcVar1)(*(in_ECX + 0x1c), 0x41f, 0, arg_8h & 0xffff | arg_ch << 0x10);\n        (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), 0, 1);\n    }\n    return;\n}\n",
        "token_count": 314
    },
    "0040f4c1": {
        "rules": [
            "check for kernel debugger via shared user data structure/3e5f0b53f7994283abe93631eebb775f"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.0040f4c1(uint8_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint8_t *puVar6;\n    uint8_t *puVar7;\n    uint var_4h;\n    \n    iVar4 = fcn.00412cd5();\n    iVar4 = *(iVar4 + 0x60);\n    if (arg_10h == 0) {\n        iVar4 = 0;\n    }\n    else {\n        if (iVar4 != *0x49af6c) {\n            iVar4 = fcn.0040fc0e();\n        }\n        if (*(iVar4 + 8) != 0) {\n            do {\n                uVar2 = *arg_8h;\n                var_4h._0_2_ = uVar2;\n                iVar3 = arg_10h + -1;\n                puVar7 = arg_8h + 1;\n                if ((*(uVar2 + 0x1d + iVar4) & 4) == 0) {\ncode_r0x0040f54b:\n                    uVar5 = *arg_ch;\n                    puVar6 = arg_ch + 1;\n                    if ((*(uVar5 + 0x1d + iVar4) & 4) != 0) {\n                        if (iVar3 != 0) {\n                            uVar2 = *puVar6;\n                            iVar3 = arg_10h + -2;\n                            if (uVar2 != 0) {\n                                puVar6 = arg_ch + 2;\n                                uVar5 = CONCAT11(*arg_ch, uVar2);\n                                goto code_r0x0040f577;\n                            }\n                        }\n                        arg_10h = iVar3;\n                        uVar5 = 0;\n                        iVar3 = arg_10h;\n                    }\n                }\n                else {\n                    if (iVar3 != 0) {\n                        uVar1 = *puVar7;\n                        if (uVar1 == 0) {\n                            var_4h._0_2_ = 0;\n                        }\n                        else {\n                            puVar7 = arg_8h + 2;\n                            var_4h._0_2_ = CONCAT11(uVar2, uVar1);\n                        }\n                        goto code_r0x0040f54b;\n                    }\n                    uVar5 = *arg_ch;\n                    var_4h._0_2_ = 0;\n                    puVar6 = arg_ch;\n                    if ((*(uVar5 + 0x1d + iVar4) & 4) != 0) {\n                        return 0;\n                    }\n                }\ncode_r0x0040f577:\n                arg_10h = iVar3;\n                if (uVar5 != var_4h) {\n                    return (-(uVar5 < var_4h) & 2) - 1;\n                }\n                if (var_4h == 0) {\n                    return 0;\n                }\n                arg_ch = puVar6;\n                arg_8h = puVar7;\n                if (arg_10h == 0) {\n                    return 0;\n                }\n            } while( true );\n        }\n        iVar4 = fcn.00416050(arg_8h, arg_ch, arg_10h);\n    }\n    return iVar4;\n}\n",
        "token_count": 775
    },
    "00446176": {
        "rules": [
            "check for kernel debugger via shared user data structure/3e5f0b53f7994283abe93631eebb775f"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00446176(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    int32_t lprc;\n    int32_t iStack36;\n    int32_t iStack32;\n    int32_t iStack28;\n    uint var_14h;\n    uint32_t var_4h;\n    \n    var_4h = (**(*in_ECX + 0xc))();\n    fcn.00445ff8(&var_14h);\n    pcVar1 = _sym.imp.USER32.dll_PtInRect;\n    iVar2 = (*_sym.imp.USER32.dll_PtInRect)(&var_14h, arg_8h, arg_ch);\n    if (iVar2 == 0) {\n        iVar2 = -1;\n    }\n    else {\n        iVar2 = 0;\n        do {\n            if ((var_4h & 1 << (iVar2 & 0x1f)) != 0) {\n                fcn.0044604a(iVar2, &var_14h);\n                iVar3 = (*pcVar1)(&var_14h, arg_8h, arg_ch);\n                if (iVar3 != 0) {\n                    return iVar2;\n                }\n            }\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < 8);\n        var_4h = in_ECX[1];\n        if ((var_4h & 4) == 0) {\n            lprc = in_ECX[2];\n            iStack36 = in_ECX[3];\n            iStack32 = in_ECX[4];\n            iStack28 = in_ECX[5];\n            fcn.004087f5();\n            if ((var_4h & 2 | 1) != 0) {\n                (*_sym.imp.USER32.dll_InflateRect)(&lprc, 1, 1);\n            }\n            iVar2 = (*pcVar1)(&lprc, arg_8h, arg_ch);\n            if (iVar2 == 0) {\n                return -1;\n            }\n        }\n        iVar2 = 8;\n    }\n    return iVar2;\n}\n",
        "token_count": 498
    },
    "00411314": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00411314(int32_t arg_8h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = *(arg_8h + 0x10);\n    iVar7 = 0;\n    for (iVar3 = *(arg_8h + 8); -1 < iVar3; iVar3 = iVar3 << 1) {\n        iVar7 = iVar7 + 1;\n    }\n    iVar3 = iVar7 * 0x204 + 0x144 + iVar2;\n    iVar6 = 0x3f;\n    iVar4 = iVar3;\n    do {\n        *(iVar4 + 8) = iVar4;\n        *(iVar4 + 4) = iVar4;\n        iVar4 = iVar4 + 8;\n        iVar6 = iVar6 + -1;\n    } while (iVar6 != 0);\n    uVar8 = iVar7 * 0x8000 + *(arg_8h + 0xc);\n    iVar4 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(uVar8, 0x8000, 0x1000, 4);\n    if (iVar4 == 0) {\n        iVar7 = -1;\n    }\n    else {\n        if (uVar8 <= uVar8 + 0x7000) {\n            piVar5 = uVar8 + 0x10;\n            iVar4 = ((uVar8 + 0x7000) - uVar8 >> 0xc) + 1;\n            do {\n                piVar5[-2] = -1;\n                piVar5[0x3fb] = -1;\n                *piVar5 = piVar5 + 0x3ff;\n                piVar5[-1] = 0xff0;\n                piVar5[1] = piVar5 + -0x401;\n                piVar5[0x3fa] = 0xff0;\n                piVar5 = piVar5 + 0x400;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n        *(iVar3 + 0x1fc) = uVar8 + 0xc;\n        *(uVar8 + 0x14) = iVar3 + 0x1f8;\n        *(iVar3 + 0x200) = uVar8 + 0x700c;\n        *(uVar8 + 0x7010) = iVar3 + 0x1f8;\n        *(iVar2 + 0x44 + iVar7 * 4) = 0;\n        *(iVar2 + 0xc4 + iVar7 * 4) = 1;\n        cVar1 = *(iVar2 + 0x43);\n        *(iVar2 + 0x43) = cVar1 + '\\x01';\n        if (cVar1 == '\\0') {\n            *(arg_8h + 4) = *(arg_8h + 4) | 1;\n        }\n        *(arg_8h + 8) = *(arg_8h + 8) & ~(0x80000000U >> (iVar7 & 0x1f));\n    }\n    return iVar7;\n}\n",
        "token_count": 763
    },
    "0041bd07": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041bd07(uint32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint16_t uVar1;\n    uint32_t uVar2;\n    uint16_t uVar3;\n    uint16_t uVar4;\n    uint32_t var_4h;\n    \n    uVar1 = *(arg_ch + 6);\n    var_4h = 0x80000000;\n    uVar3 = uVar1 >> 4;\n    uVar4 = uVar3 & 0x7ff;\n    uVar2 = *arg_ch;\n    if ((uVar3 & 0x7ff) == 0) {\n        if (((arg_ch[1] & 0xfffff) == 0) && (uVar2 == 0)) {\n            arg_8h[1] = 0;\n            *arg_8h = 0;\n            *(arg_8h + 2) = 0;\n            return;\n        }\n        uVar4 = uVar4 + 0x3c01;\n        var_4h = 0;\n    }\n    else if (uVar4 == 0x7ff) {\n        uVar4 = 0x7fff;\n    }\n    else {\n        uVar4 = uVar4 + 0x3c00;\n    }\n    arg_8h[1] = uVar2 >> 0x15 | (arg_ch[1] & 0xfffff) << 0xb | var_4h;\n    *arg_8h = uVar2 << 0xb;\n    while (var_4h == 0) {\n        uVar2 = arg_8h[1];\n        uVar4 = uVar4 - 1;\n        arg_8h[1] = uVar2 << 1 | *arg_8h >> 0x1f;\n        *arg_8h = *arg_8h * 2;\n        var_4h = uVar2 << 1 & 0x80000000;\n    }\n    *(arg_8h + 2) = uVar1 & 0x8000 | uVar4;\n    return;\n}\n",
        "token_count": 480
    },
    "0041d4ac": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b"
        ],
        "decompiled_code": "\nvoid fcn.0041d4ac(uint32_t *param_1)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    \n    uVar1 = *param_1;\n    uVar2 = param_1[1];\n    *param_1 = uVar1 * 2;\n    param_1[1] = uVar2 * 2 | uVar1 >> 0x1f;\n    param_1[2] = param_1[2] << 1 | uVar2 >> 0x1f;\n    return;\n}\n",
        "token_count": 127
    },
    "00445d2d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00445d2d(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uchar *puVar4;\n    uint uVar5;\n    ushort auStack16 [6];\n    uint uStack4;\n    \n    uStack4 = *0x496830;\n    fcn.0044ca10(5);\n    if (*0x499888 == 0) {\n        if (*0x49985c == 0) {\n            iVar2 = 0x1111;\n            iVar3 = 0;\n            do {\n                *(&stack0xffffffe8 + iVar3 * 2) = iVar2;\n                auStack16[iVar3] = iVar2;\n                iVar2 = iVar2 << 1;\n                iVar3 = iVar3 + 1;\n            } while (iVar3 < 4);\n            puVar4 = &stack0xffffffe8;\n            iVar2 = (*_sym.imp.GDI32.dll_CreateBitmap)(8, 8, 1, 1, puVar4);\n            if (iVar2 == 0) {\n                fcn.0044ca73(5);\n                fcn.00431a1c();\n            }\n            *0x49985c = (*_sym.imp.GDI32.dll_CreatePatternBrush)(iVar2);\n            (*_sym.imp.GDI32.dll_DeleteObject)(iVar2);\n            if (*0x49985c == 0) {\n                fcn.0044ca73(puVar4, 5);\n                fcn.00431a1c();\n            }\n        }\n        if (*0x499858 == 0) {\n            uVar5 = 0;\n            *0x499858 = (*_sym.imp.GDI32.dll_CreatePen)(2, 0, 0);\n            if (*0x499858 == 0) {\n                fcn.0044ca73(uVar5, 5);\n                fcn.00431a1c();\n            }\n        }\n        iVar2 = fcn.0044be10();\n        pcVar1 = _sym.imp.USER32.dll_LoadCursorA;\n        uVar5 = *(iVar2 + 0xc);\n        *0x499860 = (*_sym.imp.USER32.dll_LoadCursorA)(uVar5, 0x7907);\n        *0x499864 = (*pcVar1)(uVar5, 0x7908);\n        *0x499868 = *0x499860;\n        *0x49986c = *0x499864;\n        *0x499870 = (*pcVar1)(uVar5, 0x7909);\n        *0x499874 = (*pcVar1)(uVar5, 0x790a);\n        *0x499878 = *0x499870;\n        *0x49987c = *0x499874;\n        *0x499880 = (*pcVar1)(uVar5, 0x790b);\n        *0x499884 = (*pcVar1)(uVar5, 0x790c);\n        *0x499854 = (*_sym.imp.KERNEL32.dll_GetProfileIntA)(0x46ff08, \"oleinplaceborderwidth\", 4);\n        *0x499888 = 1;\n    }\n    if (*0x499850 == '\\0') {\n        iVar2 = fcn.0040e287(0x445d0e);\n        *0x499850 = '\\x01' - (iVar2 != 0);\n    }\n    fcn.0044ca73(5);\n    *(param_1 + 4) = 0;\n    iVar2 = *0x499854;\n    *(param_1 + 0x20) = *0x499854;\n    *(param_1 + 0x18) = iVar2 << 1;\n    *(param_1 + 0x1c) = iVar2 << 1;\n    (*_sym.imp.USER32.dll_SetRectEmpty)(param_1 + 0x28);\n    *(param_1 + 0x3c) = 0;\n    *(param_1 + 0x38) = 0;\n    *(param_1 + 0x40) = 0;\n    *(param_1 + 0x44) = 0;\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 956
    },
    "0042bc46": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\nint32_t fcn.0042bc46(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0044bde5();\n    return iVar1 + 0x30;\n}\n",
        "token_count": 46
    },
    "0042366b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042366b(uint arg_8h, uint arg_ch)\n\n{\n    int32_t in_ECX;\n    uint var_30h;\n    \n    fcn.004234ee(&var_30h, arg_8h, arg_ch);\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x405, 0, &var_30h);\n    return;\n}\n",
        "token_count": 100
    },
    "004236ce": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004236ce(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    uint var_30h;\n    uint var_20h;\n    \n    fcn.004234ee(&var_30h, arg_8h, arg_ch);\n    fcn.0040e680(&var_20h, arg_10h, 0x10);\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x406, 0, &var_30h);\n    return;\n}\n",
        "token_count": 136
    },
    "00423710": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00423710(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    uint var_30h;\n    uint var_ch;\n    \n    fcn.004234ee(&var_30h, arg_ch, arg_10h);\n    var_ch = arg_8h;\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x40c, 0, &var_30h);\n    return;\n}\n",
        "token_count": 120
    },
    "00423b49": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00423b49(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    uint var_30h;\n    uint var_ch;\n    \n    fcn.004234ee(&var_30h, arg_ch, arg_10h);\n    var_ch = fcn.004043ec(0x100);\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x40b, 0, &var_30h);\n    fcn.00404cad(0xffffffff);\n    return;\n}\n",
        "token_count": 138
    },
    "004293ec": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nbool __cdecl\nfcn.004293ec(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h, uint arg_28h, uint arg_2ch, uint arg_30h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    bool bVar3;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint lpWindowName;\n    uint lpClassName;\n    uint dwExStyle;\n    \n    dwExStyle = arg_8h;\n    lpClassName = arg_ch;\n    lpWindowName = arg_10h;\n    var_10h = arg_14h;\n    var_14h = arg_18h;\n    var_18h = arg_1ch;\n    var_1ch = arg_20h;\n    var_20h = arg_24h;\n    var_24h = arg_28h;\n    var_28h = arg_2ch;\n    iVar1 = fcn.0044be10();\n    var_2ch = *(iVar1 + 8);\n    var_30h = arg_30h;\n    iVar1 = (**(*in_ECX + 100))(&var_30h);\n    if (iVar1 == 0) {\n        (**(*in_ECX + 0x114))();\n        bVar3 = false;\n    }\n    else {\n        fcn.004293a0();\n        iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                          (dwExStyle, lpClassName, lpWindowName, var_10h, var_14h, var_18h, var_1ch, var_20h, var_24h, \n                           var_28h, var_2ch, var_30h);\n        iVar2 = fcn.00427986();\n        if (iVar2 == 0) {\n            (**(*in_ECX + 0x114))();\n        }\n        bVar3 = iVar1 != 0;\n    }\n    return bVar3;\n}\n",
        "token_count": 522
    },
    "0041346e": {
        "rules": [
            "parse credit card information/92c3fd9898ba41b4bad3ffb6188f4688",
            "search for credit card data/212a26c2b8d740cd9f6579dba482d653"
        ],
        "decompiled_code": "\nuint fcn.0041346e(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    int32_t iVar4;\n    \n    if (*0x49b1ac == 0) {\n        fcn.0040ff6d();\n    }\n    iVar4 = 0;\n    pcVar3 = *0x4998d8;\n    if (*0x4998d8 != NULL) {\n        for (; *pcVar3 != '\\0'; pcVar3 = pcVar3 + iVar2 + 1) {\n            if (*pcVar3 != '=') {\n                iVar4 = iVar4 + 1;\n            }\n            iVar2 = fcn.0040e9c0(pcVar3);\n        }\n        piVar1 = fcn.0040d946(iVar4 * 4 + 4);\n        pcVar3 = *0x4998d8;\n        *0x49990c = piVar1;\n        if (piVar1 != NULL) {\n            do {\n                if (*pcVar3 == '\\0') {\n                    fcn.0040d958(*0x4998d8);\n                    *0x4998d8 = NULL;\n                    *piVar1 = 0;\n                    *0x49b1a0 = 1;\n                    return 0;\n                }\n                iVar4 = fcn.0040e9c0(pcVar3);\n                if (*pcVar3 != '=') {\n                    iVar2 = fcn.0040d946(iVar4 + 1);\n                    *piVar1 = iVar2;\n                    if (iVar2 == 0) {\n                        fcn.0040d958(*0x49990c);\n                        *0x49990c = NULL;\n                        return 0xffffffff;\n                    }\n                    fcn.00415f50(iVar2, pcVar3);\n                    piVar1 = piVar1 + 1;\n                }\n                pcVar3 = pcVar3 + iVar4 + 1;\n            } while( true );\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 455
    },
    "0045e32f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23",
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045e32f(uint arg_8h, uint arg_ch, uint32_t arg_10h, uint arg_14h)\n\n{\n    uint32_t var_4h;\n    \n    if ((arg_10h & 0x4000) != 0) {\n        arg_10h = arg_10h & 0xbfff | 0x40;\n    }\n    if (arg_10h == 8) {\n        arg_10h = 0xe;\n    }\n    var_4h = arg_10h & 0xff;\n    fcn.0045dd92(arg_ch, (arg_10h == 9) * 4 + 4, 0, 0, &var_4h, &arg_14h);\n    return;\n}\n",
        "token_count": 177
    },
    "00418bc0": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nuint8_t fcn.00418bc0(uint32_t param_1)\n\n{\n    if (*0x49ae2c <= param_1) {\n        return 0;\n    }\n    return *(*((param_1 >> 5) * 4 + 0x49ae40) + 4 + (param_1 & 0x1f) * 0x24) & 0x40;\n}\n",
        "token_count": 91
    },
    "0041c548": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041c548(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0040daac(0x475308, 8);\n    uVar2 = *(unaff_EBP + 8);\n    iVar1 = *((uVar2 >> 5) * 4 + 0x49ae40) + (uVar2 & 0x1f) * 0x24;\n    if (*(iVar1 + 8) == 0) {\n        fcn.00410d9c(10);\n        *(unaff_EBP + -4) = 0;\n        if (*(iVar1 + 8) == 0) {\n            iVar3 = fcn.004183bc(iVar1 + 0xc, 4000);\n            if (iVar3 == 0) {\n                fcn.0040e0da(unaff_EBP + -0x10, 0xffffffff);\n                goto code_r0x0041c5d6;\n            }\n            *(iVar1 + 8) = *(iVar1 + 8) + 1;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0041c5df();\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(*((uVar2 >> 5) * 4 + 0x49ae40) + 0xc + (uVar2 & 0x1f) * 0x24);\ncode_r0x0041c5d6:\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 402
    },
    "0041c5e8": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nvoid fcn.0041c5e8(uint32_t param_1)\n\n{\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(*((param_1 >> 5) * 4 + 0x49ae40) + 0xc + (param_1 & 0x1f) * 0x24);\n    return;\n}\n",
        "token_count": 77
    },
    "0041c84d": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0041c84d(uint32_t arg_8h, uint arg_ch, uint arg_10h, uint dwMoveMethod)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint lDistanceToMove;\n    uint lpDistanceToMoveHigh;\n    \n    lpDistanceToMoveHigh = arg_10h;\n    iVar2 = fcn.0041c507(arg_8h);\n    if (iVar2 == -1) {\n        puVar3 = fcn.00410979();\n        *puVar3 = 9;\ncode_r0x0041c8a7:\n        iVar2 = -1;\n        lpDistanceToMoveHigh = 0xffffffff;\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_SetFilePointer)(iVar2, arg_ch, &lpDistanceToMoveHigh, dwMoveMethod);\n        if (iVar2 == -1) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar4 != 0) {\n                fcn.0041098b(iVar4);\n                goto code_r0x0041c8a7;\n            }\n        }\n        puVar1 = *((arg_8h >> 5) * 4 + 0x49ae40) + 4 + (arg_8h & 0x1f) * 0x24;\n        *puVar1 = *puVar1 & 0xfd;\n    }\n    return CONCAT44(lpDistanceToMoveHigh, iVar2);\n}\n",
        "token_count": 350
    },
    "00436848": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nvoid fcn.00436848(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    if (param_1 != 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GlobalFlags)(param_1);\n        for (uVar1 = uVar1 & 0xff; uVar1 != 0; uVar1 = uVar1 - 1) {\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(param_1);\n        }\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(param_1);\n    }\n    return;\n}\n",
        "token_count": 130
    },
    "0043a365": {
        "rules": [
            "encrypt data using Curve25519/bbf924b96e5b4ce780ce59f68f21b030"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043a365(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint arg_10h;\n    uint uStack292;\n    int32_t iStack284;\n    int32_t iStack280;\n    int32_t iStack276;\n    int32_t iStack272;\n    uchar auStack268 [260];\n    uint uStack8;\n    \n    uStack8 = *0x496830;\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(param_2 + 0x1c), &stack0xfffffecc);\n    if (*(param_2 + 0x88) == param_1) {\n        if (param_3 == 0) goto code_r0x0043a5b9;\n        iVar2 = (*_sym.imp.USER32.dll_EqualRect)(&stack0xfffffecc, param_3);\n        if (iVar2 != 0) goto code_r0x0043a5b9;\n    }\n    if ((*(param_1 + 0x90) != 0) && ((*(param_2 + 0x80) & 0x40) != 0)) {\n        *(param_1 + 0x7c) = *(param_1 + 0x7c) | 0x40;\n    }\n    *(param_1 + 0x7c) = *(param_1 + 0x7c) & 0xfffffff9;\n    uVar3 = *(param_1 + 0x7c);\n    *(param_1 + 0x7c) = *(param_2 + 0x7c) & 6 | uVar3;\n    if ((uVar3 & 0x40) == 0) {\n        fcn.0042a944(auStack268, 0x104);\n        fcn.00436750(*(param_1 + 0x1c), auStack268);\n    }\n    uVar3 = (*(param_2 + 0x7c) ^ *(param_1 + 0x7c)) & 0xf000 ^ *(param_2 + 0x7c);\n    if (*(param_1 + 0x90) == 0) {\n        uVar3 = uVar3 & 0xfffffffe | 0xf00;\n    }\n    else {\n        uVar3 = uVar3 | 0xf01;\n    }\n    fcn.00449d00(uVar3);\n    bVar1 = false;\n    if (*(param_2 + 0x88) != param_1) {\n        iVar2 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(param_2 + 0x1c));\n        if (iVar2 != 0) {\n            fcn.0042a4e3(0, 0, 0, 0, 0, 0x97);\n            bVar1 = true;\n        }\n    }\n    uStack292 = 0xffffffff;\n    if (param_3 == 0) {\n        fcn.00424c05(*(param_1 + 0x9c), param_2);\n        fcn.00424c05(*(param_1 + 0x9c), 0);\n        fcn.0042a4e3(0, -*0x4995c8, -*0x4995cc, 0, 0, 0x115);\n    }\n    else {\n        (*_sym.imp.USER32.dll_CopyRect)(&iStack284, param_3);\n        fcn.00431de5(&iStack284);\n        uStack292 = fcn.0043996e(param_2, iStack284, iStack280, iStack276, iStack272, \n                                 (iStack276 - iStack284) / 2 + iStack284, (iStack272 - iStack280) / 2 + iStack280);\n        fcn.0042a4e3(0, iStack284, iStack280, iStack276 - iStack284, iStack272 - iStack280, 0x114);\n    }\n    (*_sym.imp.USER32.dll_GetParent)(*(param_2 + 0x1c));\n    iVar2 = fcn.004278de();\n    if (iVar2 != param_1) {\n        fcn.00405d63(param_1);\n    }\n    iVar2 = *(param_2 + 0x88);\n    if (iVar2 == param_1) {\n        arg_10h = 0;\ncode_r0x0043a584:\n        fcn.00439cf6(param_2, uStack292, arg_10h);\n    }\n    else if (iVar2 != 0) {\n        if ((*(param_1 + 0x90) == 0) || (*(iVar2 + 0x90) != 0)) {\n            arg_10h = 0;\n        }\n        else {\n            arg_10h = 1;\n        }\n        uStack292 = 0xffffffff;\n        goto code_r0x0043a584;\n    }\n    *(param_2 + 0x88) = param_1;\n    if (bVar1) {\n        fcn.0042a4e3(0, 0, 0, 0, 0, 0x57);\n    }\n    fcn.00439c8f(param_2);\n    iVar2 = fcn.00441d04();\n    *(iVar2 + 0xcc) = *(iVar2 + 0xcc) | 0xc;\ncode_r0x0043a5b9:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 1268
    },
    "00460402": {
        "rules": [
            "encrypt data using Curve25519/bbf924b96e5b4ce780ce59f68f21b030"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_20h\n\nint32_t __cdecl fcn.00460402(uint hDC)\n\n{\n    uint32_t *puVar1;\n    uint8_t *puVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    uint uVar7;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(extraout_ECX + 0x88) = *(unaff_EBP + 8);\n    iVar5 = fcn.00425ce2(0x40);\n    *(unaff_EBP + 8) = iVar5;\n    *(unaff_EBP + -4) = 0;\n    if (iVar5 == 0) {\n        piVar6 = NULL;\n    }\n    else {\n        piVar6 = fcn.00461411();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(extraout_ECX + 0x130) = piVar6;\n    *(*piVar6 + 0x50) = 0x7009;\n    puVar1 = *(**(extraout_ECX + 0x130) + 0x70) + 0x14;\n    *puVar1 = *puVar1 | 0x40;\n    puVar2 = *(**(extraout_ECX + 0x130) + 0x70) + 0x15;\n    *puVar2 = *puVar2 & 0xfe;\n    *(*(extraout_ECX + 0x130) + 8) = 1;\n    iVar5 = fcn.00425ce2(0x40);\n    *(unaff_EBP + 8) = iVar5;\n    *(unaff_EBP + -4) = 1;\n    if (iVar5 == 0) {\n        uVar7 = 0;\n    }\n    else {\n        uVar7 = fcn.00462927();\n    }\n    piVar6 = *(extraout_ECX + 0x88);\n    uVar3 = *(extraout_ECX + 0x130);\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(extraout_ECX + 0x8c) = uVar7;\n    iVar5 = (**(*piVar6 + 0x16c))(uVar3);\n    if (iVar5 != 0) {\n        fcn.0043212e(*(*(**(extraout_ECX + 0x130) + 0x70) + 0x10));\n        (**(**(extraout_ECX + 0x8c) + 0xc))(*(*(**(extraout_ECX + 0x130) + 0x70) + 0x10));\n        *(*(extraout_ECX + 0x8c) + 0xc) = 1;\n        *(extraout_ECX + 0x9c) = 1;\n        (**(*(extraout_ECX + 0x90) + 0x1c))();\n        uVar7 = (*_sym.imp.USER32.dll_GetDC)(*(extraout_ECX + 0x1c));\n        iVar5 = **(extraout_ECX + 0x8c);\n        *(unaff_EBP + 8) = uVar7;\n        (**(iVar5 + 0x10))(uVar7);\n        (**(**(extraout_ECX + 0x88) + 0x170))(*(extraout_ECX + 0x8c), *(extraout_ECX + 0x130));\n        (**(**(extraout_ECX + 0x8c) + 0x18))();\n        (*_sym.imp.USER32.dll_ReleaseDC)(*(extraout_ECX + 0x1c), *(unaff_EBP + 8));\n        (**(*(extraout_ECX + 0x90) + 0x20))(0xffffffff);\n        uVar7 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(*(extraout_ECX + 0x98), 0x58);\n        *(extraout_ECX + 0x120) = uVar7;\n        uVar7 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(*(extraout_ECX + 0x98), 0x5a);\n        *(extraout_ECX + 0x124) = uVar7;\n        uVar4 = *(*(extraout_ECX + 0x130) + 0x18);\n        *(extraout_ECX + 0x114) = uVar4;\n        if (uVar4 == 0) {\n            *(extraout_ECX + 0x114) = 1;\n        }\n        else if (*(extraout_ECX + 0x10c) < uVar4) {\n            *(extraout_ECX + 0x114) = *(extraout_ECX + 0x10c);\n        }\n        *(extraout_ECX + 0x104) = *(extraout_ECX + 0x114);\n        fcn.00435de0(1, 1, 1, 0x46dfec, 0x46dfec);\n        piVar6 = *(extraout_ECX + 0x130);\n        if ((*(*(*piVar6 + 0x70) + 0x1e) < 0x8000) &&\n           (*(*(*piVar6 + 0x70) + 0x1e) - *(*(*piVar6 + 0x70) + 0x1c) < 0x8000)) {\n            *(unaff_EBP + -0x24) = 3;\n            *(unaff_EBP + -0x20) = *(*(*piVar6 + 0x70) + 0x1c);\n            *(unaff_EBP + -0x1c) = *(*(*piVar6 + 0x70) + 0x1e);\n            *(unaff_EBP + -0x18) = 1;\n            iVar5 = fcn.00426122(1, unaff_EBP + -0x28, 0);\n            if (iVar5 == 0) {\n                fcn.00426e51(1, *(unaff_EBP + -0x20), *(unaff_EBP + -0x1c), 0);\n            }\n        }\n        else {\n            (*_sym.imp.USER32.dll_ShowScrollBar)(*(extraout_ECX + 0x1c), 1, 0);\n        }\n        fcn.004601ab(*(*(extraout_ECX + 0x130) + 0x14), 1);\n        iVar5 = 1;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar5;\n}\n",
        "token_count": 1619
    },
    "0042f7a7": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\nvoid fcn.0042f7a7(int32_t param_1, uint32_t *param_2)\n\n{\n    int32_t iVar1;\n    uint32_t *puVar2;\n    uint8_t in_stack_fffffeb8;\n    uchar auStack324 [8];\n    uchar auStack316 [8];\n    uchar auStack308 [12];\n    uint32_t uStack296;\n    uint uStack8;\n    \n    uStack8 = *0x496830;\n    if ((param_1 != 0) && (iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(param_1),  iVar1 < 0x104)) {\n        iVar1 = fcn.0042f0fa(param_2 + 0x22, param_1);\n        if (iVar1 == 0) {\n            *(param_2 + 0x22) = 0;\n        }\n        else {\n            iVar1 = (*_sym.imp.KERNEL32.dll_FindFirstFileA)(param_1, &stack0xfffffeb8);\n            if (iVar1 != -1) {\n                (*_sym.imp.KERNEL32.dll_FindClose)(iVar1);\n                *(param_2 + 8) = in_stack_fffffeb8 & 0x7f;\n                param_2[6] = uStack296;\n                param_2[7] = uStack296 >> 0x1f;\n                puVar2 = fcn.00408c96(auStack324, 0xffffffff);\n                *param_2 = *puVar2;\n                param_2[1] = puVar2[1];\n                puVar2 = fcn.00408c96(auStack316, 0xffffffff);\n                param_2[4] = *puVar2;\n                param_2[5] = puVar2[1];\n                puVar2 = fcn.00408c96(auStack308, 0xffffffff);\n                param_2[2] = *puVar2;\n                param_2[3] = puVar2[1];\n                if ((*param_2 | param_2[1]) == 0) {\n                    *param_2 = *puVar2;\n                    param_2[1] = puVar2[1];\n                }\n                if ((param_2[4] | param_2[5]) == 0) {\n                    param_2[4] = param_2[2];\n                    param_2[5] = param_2[3];\n                }\n            }\n        }\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 564
    },
    "0041a048": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nuint32_t fcn.0041a048(void)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    uint32_t uVar12;\n    uint32_t uVar13;\n    uint32_t uVar14;\n    uint32_t uVar15;\n    uint32_t uVar16;\n    uint32_t uVar17;\n    uint32_t uVar18;\n    uint32_t uVar19;\n    uint32_t uVar20;\n    uint32_t uVar21;\n    uint32_t uVar22;\n    uint32_t uVar23;\n    uint32_t uVar24;\n    uint32_t uVar25;\n    uint32_t uVar26;\n    uint32_t uVar27;\n    uint32_t uVar28;\n    uint32_t uVar29;\n    uint32_t uVar30;\n    uint32_t uVar31;\n    uint32_t uVar32;\n    uint32_t uVar33;\n    uint32_t uVar34;\n    uint32_t uVar35;\n    uint32_t uVar36;\n    uint32_t uVar37;\n    uint32_t uVar38;\n    uint32_t uVar39;\n    uint32_t uVar40;\n    uint32_t uVar41;\n    uint32_t uVar42;\n    uint32_t uVar43;\n    uint32_t uVar44;\n    uint32_t arg_ch;\n    int32_t unaff_ESI;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = *0x499d8a;\n    arg_ch = *0x499d8c;\n    if (unaff_ESI == 0) {\n        return 0xffffffff;\n    }\n    uVar2 = fcn.0041cfde(1, uVar1, 0x31, unaff_ESI + 4);\n    uVar3 = fcn.0041cfde(1, uVar1, 0x32, unaff_ESI + 8);\n    uVar4 = fcn.0041cfde(1, uVar1, 0x33, unaff_ESI + 0xc);\n    uVar5 = fcn.0041cfde(1, uVar1, 0x34, unaff_ESI + 0x10);\n    uVar6 = fcn.0041cfde(1, uVar1, 0x35, unaff_ESI + 0x14);\n    uVar7 = fcn.0041cfde(1, uVar1, 0x36, unaff_ESI + 0x18);\n    uVar8 = fcn.0041cfde(1, uVar1, 0x37, unaff_ESI);\n    uVar9 = fcn.0041cfde(1, uVar1, 0x2a, unaff_ESI + 0x20);\n    uVar10 = fcn.0041cfde(1, uVar1, 0x2b, unaff_ESI + 0x24);\n    uVar11 = fcn.0041cfde(1, uVar1, 0x2c, unaff_ESI + 0x28);\n    uVar12 = fcn.0041cfde(1, uVar1, 0x2d, unaff_ESI + 0x2c);\n    uVar13 = fcn.0041cfde(1, uVar1, 0x2e, unaff_ESI + 0x30);\n    uVar14 = fcn.0041cfde(1, uVar1, 0x2f, unaff_ESI + 0x34);\n    uVar15 = fcn.0041cfde(1, uVar1, 0x30, unaff_ESI + 0x1c);\n    uVar16 = fcn.0041cfde(1, uVar1, 0x44, unaff_ESI + 0x38);\n    uVar17 = fcn.0041cfde(1, uVar1, 0x45, unaff_ESI + 0x3c);\n    uVar18 = fcn.0041cfde(1, uVar1, 0x46, unaff_ESI + 0x40);\n    uVar19 = fcn.0041cfde(1, uVar1, 0x47, unaff_ESI + 0x44);\n    uVar20 = fcn.0041cfde(1, uVar1, 0x48, unaff_ESI + 0x48);\n    uVar21 = fcn.0041cfde(1, uVar1, 0x49, unaff_ESI + 0x4c);\n    uVar22 = fcn.0041cfde(1, uVar1, 0x4a, unaff_ESI + 0x50);\n    uVar23 = fcn.0041cfde(1, uVar1, 0x4b, unaff_ESI + 0x54);\n    uVar24 = fcn.0041cfde(1, uVar1, 0x4c, unaff_ESI + 0x58);\n    uVar25 = fcn.0041cfde(1, uVar1, 0x4d, unaff_ESI + 0x5c);\n    uVar26 = fcn.0041cfde(1, uVar1, 0x4e, unaff_ESI + 0x60);\n    uVar27 = fcn.0041cfde(1, uVar1, 0x4f, unaff_ESI + 100);\n    uVar28 = fcn.0041cfde(1, uVar1, 0x38, unaff_ESI + 0x68);\n    uVar29 = fcn.0041cfde(1, uVar1, 0x39, unaff_ESI + 0x6c);\n    uVar30 = fcn.0041cfde(1, uVar1, 0x3a, unaff_ESI + 0x70);\n    uVar31 = fcn.0041cfde(1, uVar1, 0x3b, unaff_ESI + 0x74);\n    uVar32 = fcn.0041cfde(1, uVar1, 0x3c, unaff_ESI + 0x78);\n    uVar33 = fcn.0041cfde(1, uVar1, 0x3d, unaff_ESI + 0x7c);\n    uVar34 = fcn.0041cfde(1, uVar1, 0x3e, unaff_ESI + 0x80);\n    uVar35 = fcn.0041cfde(1, uVar1, 0x3f, unaff_ESI + 0x84);\n    uVar36 = fcn.0041cfde(1, uVar1, 0x40, unaff_ESI + 0x88);\n    uVar37 = fcn.0041cfde(1, uVar1, 0x41, unaff_ESI + 0x8c);\n    uVar38 = fcn.0041cfde(1, uVar1, 0x42, unaff_ESI + 0x90);\n    uVar39 = fcn.0041cfde(1, uVar1, 0x43, unaff_ESI + 0x94);\n    uVar40 = fcn.0041cfde(1, uVar1, 0x28, unaff_ESI + 0x98);\n    uVar1 = fcn.0041cfde(1, uVar1, 0x29, unaff_ESI + 0x9c);\n    uVar41 = fcn.0041cfde(1, arg_ch, 0x1f, unaff_ESI + 0xa0);\n    uVar42 = fcn.0041cfde(1, arg_ch, 0x20, unaff_ESI + 0xa4);\n    uVar43 = fcn.0041cfde(1, arg_ch, 0x1003, unaff_ESI + 0xa8);\n    uVar44 = fcn.0041cfde(0, arg_ch, 0x1009, unaff_ESI + 0xb0);\n    *(unaff_ESI + 0xac) = arg_ch;\n    return uVar2 | uVar3 | uVar4 | uVar5 | uVar6 | uVar7 | uVar8 | uVar9 | uVar10 | uVar11 | uVar12 | uVar13 | uVar14 |\n           uVar15 | uVar16 | uVar17 | uVar18 | uVar19 | uVar20 | uVar21 | uVar22 | uVar23 | uVar24 | uVar25 | uVar26 |\n           uVar27 | uVar28 | uVar29 | uVar30 | uVar31 | uVar32 | uVar33 | uVar34 | uVar35 | uVar36 | uVar37 | uVar38 |\n           uVar39 | uVar40 | uVar1 | uVar41 | uVar42 | uVar43 | uVar44;\n}\n",
        "token_count": 2149
    },
    "004194a9": {
        "rules": [
            "check for PEB NtGlobalFlag flag/02e6ad6983154968a9ea3bb4adc24b9d/10fcbce0171842839e4e3d1dbc7c6301"
        ],
        "decompiled_code": "\nuchar * fcn.004194a9(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uchar *puVar6;\n    uint *puVar7;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar5 = *0x497330;\n    var_4h = 0;\n    puVar7 = *0x497330 + 0x38;\n    var_8h = 0xc;\n    do {\n        iVar1 = fcn.0040e9c0(puVar7[0xc]);\n        iVar2 = fcn.0040e9c0(*puVar7);\n        var_4h = iVar2 + var_4h + 2 + iVar1;\n        puVar7 = puVar7 + 1;\n        var_8h = var_8h + -1;\n    } while (var_8h != 0);\n    puVar3 = fcn.0040d946(var_4h + 1);\n    if (puVar3 != NULL) {\n        puVar7 = iVar5 + 0x68;\n        iVar5 = 0xc;\n        puVar6 = puVar3;\n        do {\n            *puVar6 = 0x3a;\n            puVar6 = puVar6 + 1;\n            uVar4 = fcn.00415f50(puVar6, puVar7[-0xc]);\n            iVar1 = fcn.0040e9c0(uVar4);\n            puVar6 = puVar6 + iVar1;\n            *puVar6 = 0x3a;\n            uVar4 = fcn.00415f50(puVar6 + 1, *puVar7);\n            iVar1 = fcn.0040e9c0(uVar4);\n            puVar6 = puVar6 + 1 + iVar1;\n            puVar7 = puVar7 + 1;\n            iVar5 = iVar5 + -1;\n        } while (iVar5 != 0);\n        *puVar6 = 0;\n    }\n    return puVar3;\n}\n",
        "token_count": 484
    },
    "0044604a": {
        "rules": [
            "hash data using djb2/86fcf1c18148478ab58e8c52ba43c8d5",
            "hash data using jshash/2d43aa00ef9c47beadbc2522c99f9e7b",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044604a(uint arg_8h, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t iVar3;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t lprc;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    lprc = in_ECX[2];\n    var_ch = in_ECX[3];\n    var_8h = in_ECX[4];\n    var_4h = in_ECX[5];\n    fcn.004087f5();\n    if ((*(in_ECX + 1) & 3) != 0) {\n        (*_sym.imp.USER32.dll_InflateRect)(&lprc, 1, 1);\n    }\n    iVar1 = fcn.00445ee5(arg_8h);\n    iVar2 = (**(*in_ECX + 0x14))(0);\n    if ((*(in_ECX + 1) & 0x10) != 0) {\n        (*_sym.imp.USER32.dll_InflateRect)(&lprc, iVar2 + -1, iVar2 + -1);\n    }\n    iVar1 = iVar1 * 0x20;\n    iVar3 = *(&lprc + *(iVar1 + 0x46fe08)) + *(iVar1 + 0x46fe18) * iVar2 +\n            (((var_8h - iVar2) - lprc) * *(iVar1 + 0x46fe10)) / 2;\n    iVar1 = *(&lprc + *(iVar1 + 0x46fe0c)) + *(iVar1 + 0x46fe1c) * iVar2 +\n            (((var_4h - var_ch) - iVar2) * *(iVar1 + 0x46fe14)) / 2;\n    *arg_ch = iVar3;\n    arg_ch[1] = iVar1;\n    arg_ch[2] = iVar3 + iVar2;\n    arg_ch[3] = iVar1 + iVar2;\n    return;\n}\n",
        "token_count": 499
    },
    "0044623d": {
        "rules": [
            "hash data using djb2/86fcf1c18148478ab58e8c52ba43c8d5",
            "hash data using jshash/2d43aa00ef9c47beadbc2522c99f9e7b"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044623d(int32_t arg_8h, int32_t **arg_ch, int32_t **arg_10h, int32_t *arg_14h, int32_t *arg_18h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    \n    if (arg_8h == 8) {\n        arg_8h = 0;\n    }\n    iVar3 = arg_8h * 0x20;\n    *arg_ch = NULL;\n    *arg_10h = NULL;\n    if (*(iVar3 + 0x46fe20) == arg_8h) {\n        if (arg_14h == NULL) goto code_r0x004462a0;\n        iVar2 = fcn.004103a2(*(in_ECX + 0x10) - *(in_ECX + 8));\n        iVar2 = iVar2 / 2 + *(in_ECX + 8);\n    }\n    else {\n        piVar1 = *(iVar3 + 0x46fe08) + 8 + in_ECX;\n        *arg_ch = piVar1;\n        if (arg_14h == NULL) goto code_r0x004462a0;\n        iVar2 = *piVar1;\n    }\n    *arg_14h = iVar2;\ncode_r0x004462a0:\n    if (*(iVar3 + 0x46fe24) == arg_8h) {\n        if (arg_18h != NULL) {\n            iVar3 = fcn.004103a2(*(in_ECX + 0x14) - *(in_ECX + 0xc));\n            *arg_18h = iVar3 / 2 + *(in_ECX + 0xc);\n        }\n    }\n    else {\n        piVar1 = *(iVar3 + 0x46fe0c) + 8 + in_ECX;\n        *arg_10h = piVar1;\n        if (arg_18h != NULL) {\n            *arg_18h = *piVar1;\n        }\n    }\n    return;\n}\n",
        "token_count": 473
    },
    "0042553e": {
        "rules": [
            "hash data using djb2/6ad21e310d674441ba35d7276afbe57d",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0042553e(uint8_t *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t extraout_ECX;\n    uint32_t uVar2;\n    ulong uVar3;\n    \n    iVar1 = 0;\n    if (param_1 != NULL) goto code_r0x00425556;\n    uVar3 = fcn.0042032d();\n    uVar2 = extraout_ECX;\n    do {\n        iVar1 = uVar3 * 0x21 + uVar2;\n        param_1 = (uVar3 >> 0x20) + 1;\ncode_r0x00425556:\n        uVar3 = CONCAT44(param_1, iVar1);\n        uVar2 = *param_1;\n    } while (*param_1 != 0);\n    return iVar1;\n}\n",
        "token_count": 187
    },
    "004016c6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.004016c6(uint *param_1, int32_t param_2)\n\n{\n    uint *puVar1;\n    \n    puVar1 = fcn.0040d946(param_2 + 8);\n    if (puVar1 != NULL) {\n        *puVar1 = *param_1;\n        *param_1 = puVar1;\n        puVar1 = puVar1 + 2;\n    }\n    return puVar1;\n}\n",
        "token_count": 106
    },
    "0040183c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040183c(void)\n\n{\n    fcn.004011b6(0x4860e0, 0x401738, _sym.imp.KERNEL32.dll_CompareStringW);\n    // WARNING: Could not recover jumptable at 0x00401858. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**0x4860e0)();\n    return;\n}\n",
        "token_count": 92
    },
    "00401a48": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00401a48(void)\n\n{\n    fcn.004011b6(0x4860e4, 0x40199c, _sym.imp.KERNEL32.dll_GetStringTypeExW);\n    // WARNING: Could not recover jumptable at 0x00401a64. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**0x4860e4)();\n    return;\n}\n",
        "token_count": 95
    },
    "00401a98": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401a98(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t in_FS_OFFSET;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    piVar1 = *(*(*(in_FS_OFFSET + 0x30) + 0xc) + 0xc);\n    iVar2 = piVar1[6];\n    do {\n        if (iVar2 == 0) {\n            return 0;\n        }\n        iVar4 = *(*(iVar2 + 0x3c) + 0x78 + iVar2);\n        piVar1 = *piVar1;\n        if (iVar4 != 0) {\n            var_4h = 0;\n            iVar4 = iVar4 + iVar2;\n            piVar5 = *(iVar4 + 0x20) + iVar2;\n            if (*(iVar4 + 0x18) != 0) {\n                do {\n                    iVar3 = *piVar5;\n                    piVar5 = piVar5 + 1;\n                    iVar3 = fcn.00401a79(iVar3 + iVar2, arg_8h);\n                    if (iVar3 == 0) {\n                        return *(*(iVar4 + 0x1c) + *(*(iVar4 + 0x24) + var_4h * 2 + iVar2) * 4 + iVar2) + iVar2;\n                    }\n                    var_4h = var_4h + 1;\n                } while (var_4h < *(iVar4 + 0x18));\n            }\n        }\n        iVar2 = piVar1[6];\n    } while( true );\n}\n",
        "token_count": 396
    },
    "00401bd3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00401bd3(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    code *pcVar3;\n    code *pcVar4;\n    code *pcVar5;\n    code *pcVar6;\n    code *pcVar7;\n    code *pcVar8;\n    int32_t iVar9;\n    uint32_t uVar10;\n    uint var_40h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = fcn.00401b2c(0x173, 0);\n    uVar1 = fcn.00401b4b(uVar1);\n    pcVar2 = fcn.00401a98(uVar1);\n    uVar1 = fcn.00401b2c(0x1e3, 0);\n    uVar1 = fcn.00401b4b(uVar1);\n    pcVar3 = fcn.00401a98(uVar1);\n    uVar1 = fcn.00401b2c(0x22d, 0);\n    uVar1 = fcn.00401b4b(uVar1);\n    pcVar4 = fcn.00401a98(uVar1);\n    uVar1 = fcn.00401b2c(0x27c, 0);\n    uVar1 = fcn.00401b4b(uVar1);\n    pcVar5 = fcn.00401a98(uVar1);\n    uVar1 = fcn.00401b2c(0x24b, 0);\n    uVar1 = fcn.00401b4b(uVar1);\n    pcVar6 = fcn.00401a98(uVar1);\n    uVar1 = fcn.00401b2c(0x264, 0);\n    uVar1 = fcn.00401b4b(uVar1);\n    pcVar7 = fcn.00401a98(uVar1);\n    uVar1 = fcn.00401b2c(0x3b9, 0);\n    uVar1 = fcn.00401b4b(uVar1);\n    pcVar8 = fcn.00401a98(uVar1);\n    iVar9 = (*pcVar4)(&var_4h, 0, 0, 1, 0);\n    if ((((iVar9 != 0) || (iVar9 = (*pcVar4)(&var_4h, 0, 0, 1, 8),  iVar9 != 0)) ||\n        (iVar9 = (*pcVar4)(&var_4h, 0, 0, 1, 0xf0000000),  iVar9 != 0)) &&\n       (((iVar9 = (*pcVar6)(var_4h, 0x8003, 0, 0, &var_8h),  iVar9 != 0 &&\n         (iVar9 = (*pcVar7)(var_8h, arg_10h, 0x10, 1),  iVar9 != 0)) &&\n        (iVar9 = (*pcVar8)(var_4h, 0x6801, var_8h, 1, &var_ch),  iVar9 != 0)))) {\n        uVar10 = (*pcVar3)(0, arg_ch, 0x1000, 0x40);\n        (*pcVar2)(uVar10, arg_8h, arg_ch);\n        iVar9 = (*pcVar5)(var_ch, 0, 1, 0, uVar10, &arg_ch, arg_ch);\n        return -(iVar9 != 0) & uVar10;\n    }\n    return 0;\n}\n",
        "token_count": 874
    },
    "00402c7e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00402c7e(int32_t param_1)\n\n{\n    *(param_1 + 8) = 0x46867c;\n    if (*(param_1 + 0xc) != 0) {\n        fcn.00425d17(*(param_1 + 0xc));\n    }\n    return;\n}\n",
        "token_count": 76
    },
    "00402f40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * fcn.00402f40(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *extraout_ECX;\n    \n    piVar1 = *param_1;\n    if (piVar1 == NULL) {\n        piVar1 = fcn.0042032d();\n        param_1 = extraout_ECX;\n    }\n    *param_1 = *piVar1;\n    return piVar1 + 2;\n}\n",
        "token_count": 107
    },
    "0040394e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040394e(int32_t *arg_8h, int32_t arg_ch, int32_t *arg_10h)\n\n{\n    int32_t arg_10h_00;\n    int32_t lptm;\n    uint var_8h;\n    \n    (**(*arg_8h + 0x5c))(0, 0xffffffe7, *arg_10h, *(*arg_10h + -0xc));\n    (*_sym.imp.GDI32.dll_GetTextMetricsA)(arg_8h[2], &lptm);\n    arg_10h_00 = -lptm + -0x23;\n    fcn.00431d99(&var_8h, 0, arg_10h_00);\n    fcn.004317e6(*(arg_ch + 0x2c), arg_10h_00);\n    *(arg_ch + 0x28) = *(arg_ch + 0x28) + -lptm + -0x3c;\n    return;\n}\n",
        "token_count": 230
    },
    "004039b4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.004039b4(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00403667(*param_2 + -0x10);\n    *param_1 = iVar1 + 0x10;\n    return param_1;\n}\n",
        "token_count": 81
    },
    "00403b8b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * fcn.00403b8b(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *extraout_ECX;\n    \n    piVar1 = *param_1;\n    if (piVar1 == NULL) {\n        piVar1 = fcn.0042032d();\n        param_1 = extraout_ECX;\n    }\n    *param_1 = *piVar1;\n    return piVar1 + 2;\n}\n",
        "token_count": 108
    },
    "00403bd4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00403bd4(uint *param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0044bde5();\n    param_1[1] = iVar1;\n    param_1[2] = *(iVar1 + 0xf0);\n    *param_1 = *(iVar1 + 0xec);\n    *(iVar1 + 0xec) = param_2;\n    *(param_1[1] + 0xf0) = param_1;\n    return param_1;\n}\n",
        "token_count": 128
    },
    "00403c29": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.00403c29(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (**(*param_2 + 0xc))();\n    *param_1 = iVar1 + 0x10;\n    return param_1;\n}\n",
        "token_count": 76
    },
    "00404011": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00404011(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint unaff_retaddr;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_2);\n    fcn.0040e680(unaff_retaddr, param_1, iVar1 * 2 + 2);\n    return;\n}\n",
        "token_count": 84
    },
    "00404031": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00404031(uint hModule, uint hResInfo, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint16_t *puVar2;\n    uint16_t *puVar3;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadResource)(hModule, hResInfo);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    puVar2 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar1);\n    if (puVar2 != NULL) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_SizeofResource)(hModule, hResInfo);\n        puVar3 = iVar1 + puVar2;\n        for (arg_10h = arg_10h & 0xf; arg_10h != 0; arg_10h = arg_10h - 1) {\n            if (puVar3 <= puVar2) {\n                return 0;\n            }\n            puVar2 = puVar2 + *puVar2 + 1;\n        }\n        if (puVar2 < puVar3) {\n            return -(*puVar2 != 0) & puVar2;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 275
    },
    "0040408d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040408d(uint param_1, uint32_t param_2)\n\n{\n    int32_t hResInfo;\n    \n    hResInfo = (*_sym.imp.KERNEL32.dll_FindResourceA)(param_1);\n    if (hResInfo == 0) {\n        return;\n    }\n    fcn.00404031((param_2 >> 4) + 1 & 0xffff, hResInfo, 6);\n    return;\n}\n",
        "token_count": 102
    },
    "004042ce": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004042ce(int32_t *param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (**(**(*param_1 + -0x10) + 8))(*param_1 + -0x10, param_2, 1);\n    if (iVar1 == 0) {\n        iVar1 = fcn.004034e5();\n    }\n    *param_1 = iVar1 + 0x10;\n    return;\n}\n",
        "token_count": 112
    },
    "004042f6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004042f6(uint32_t *param_1)\n\n{\n    uint32_t uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint64_t uVar4;\n    \n    uVar1 = *param_1;\n    uVar4 = uVar1;\n    piVar2 = *(uVar1 - 0x10);\n    if (*(uVar1 - 0xc) != 0) {\n        if (*(uVar1 - 4) < 0) {\n            if (*(uVar1 - 8) < 0) {\n                uVar4 = fcn.00401182(0x80070057);\n            }\n            *(uVar4 + -0xc) = uVar4 >> 0x20;\n            **param_1 = uVar4 >> 0x20;\n        }\n        else {\n            fcn.00403164();\n            iVar3 = (**(*piVar2 + 0xc))();\n            *param_1 = iVar3 + 0x10;\n        }\n    }\n    return;\n}\n",
        "token_count": 238
    },
    "0040433e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040433e(int32_t arg_8h)\n\n{\n    int32_t arg_ch;\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_ch = *in_ECX;\n    iVar1 = *(arg_ch + -0xc);\n    puVar2 = (**(**(arg_ch + -0x10) + 0x10))();\n    iVar3 = (***puVar2)(arg_8h, 1);\n    if (iVar3 == 0) {\n        fcn.004034e5();\n    }\n    if (iVar1 < arg_8h) {\n        arg_8h = iVar1;\n    }\n    fcn.0040e680(iVar3 + 0x10, arg_ch, arg_8h + 1);\n    *(iVar3 + 4) = iVar1;\n    fcn.00403164();\n    *in_ECX = iVar3 + 0x10;\n    return;\n}\n",
        "token_count": 244
    },
    "00404523": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404523(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    uint32_t uVar3;\n    uint var_4h;\n    \n    uVar1 = *(*in_ECX + -0xc);\n    uVar3 = arg_8h - *in_ECX;\n    iVar2 = fcn.004043ec(arg_ch + uVar1);\n    if (uVar3 <= uVar1) {\n        arg_8h = uVar3 + iVar2;\n    }\n    fcn.0040e680(iVar2 + uVar1, arg_8h, arg_ch);\n    fcn.004042a8(arg_ch + uVar1);\n    return;\n}\n",
        "token_count": 181
    },
    "00404fd7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404fd7(int32_t arg_8h, uint32_t *arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    uint32_t pvParam;\n    uint32_t uStack16;\n    uint32_t uStack12;\n    uint32_t uStack8;\n    \n    iVar2 = fcn.00404d88();\n    if (iVar2 == 0) {\n        if ((((arg_8h == 0x12340042) && (arg_ch != NULL)) && (0x27 < *arg_ch)) &&\n           (iVar2 = (*_sym.imp.USER32.dll_SystemParametersInfoA)(0x30, 0, &pvParam, 0),  iVar2 != 0)) {\n            arg_ch[1] = 0;\n            arg_ch[2] = 0;\n            pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n            uVar4 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0);\n            arg_ch[3] = uVar4;\n            uVar4 = (*pcVar1)(1);\n            arg_ch[5] = pvParam;\n            arg_ch[6] = uStack16;\n            arg_ch[7] = uStack12;\n            arg_ch[8] = uStack8;\n            uVar3 = 1;\n            arg_ch[4] = uVar4;\n            arg_ch[9] = 1;\n            if (0x47 < *arg_ch) {\n                (*_sym.imp.KERNEL32.dll_lstrcpynA)(arg_ch + 10, \"DISPLAY\", 0x20);\n            }\n        }\n        else {\n            uVar3 = 0;\n        }\n    }\n    else {\n        uVar3 = (**0x499230)(arg_8h, arg_ch);\n    }\n    return uVar3;\n}\n",
        "token_count": 420
    },
    "00405aab": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00405aab(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    \n    iVar1 = *param_1;\n    if (iVar1 == 0) {\n        iVar1 = fcn.0042032d();\n        param_1 = extraout_ECX;\n    }\n    *param_1 = *(iVar1 + 4);\n    return iVar1 + 8;\n}\n",
        "token_count": 102
    },
    "00405ad0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool fcn.00405ad0(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040ee70(param_1, param_2, 0x10);\n    return iVar1 == 0;\n}\n",
        "token_count": 61
    },
    "00405c7a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00405c7a(int32_t *param_1, int32_t param_2, int32_t param_3, int32_t param_4, int32_t param_5)\n\n{\n    param_1[2] = param_4 + param_2;\n    *param_1 = param_2;\n    param_1[1] = param_3;\n    param_1[3] = param_5 + param_3;\n    return;\n}\n",
        "token_count": 108
    },
    "00405e38": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00405e38(uint arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    fcn.004039b4(in_ECX + 0xc0, 0);\n    return arg_8h;\n}\n",
        "token_count": 78
    },
    "00405fe2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00405fe2(uint param_1)\n\n{\n    fcn.0040e620(param_1, 0, 0x18);\n    return param_1;\n}\n",
        "token_count": 44
    },
    "004064fe": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004064fe(void)\n\n{\n    fcn.004011b6(0x4860e0, 0x4063fa, _sym.imp.KERNEL32.dll_CompareStringW);\n    // WARNING: Could not recover jumptable at 0x0040651a. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**0x4860e0)();\n    return;\n}\n",
        "token_count": 93
    },
    "00406754": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00406754(void)\n\n{\n    fcn.004011b6(0x4860e4, 0x406698, _sym.imp.KERNEL32.dll_GetStringTypeExW);\n    // WARNING: Could not recover jumptable at 0x00406770. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**0x4860e4)();\n    return;\n}\n",
        "token_count": 92
    },
    "00406c9b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00406c9b(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    \n    iVar1 = *param_1;\n    if (iVar1 == 0) {\n        iVar1 = fcn.0042032d();\n        param_1 = extraout_ECX;\n    }\n    *param_1 = *(iVar1 + 4);\n    return iVar1 + 8;\n}\n",
        "token_count": 104
    },
    "00407d9c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * fcn.00407d9c(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *extraout_ECX;\n    \n    piVar1 = *param_1;\n    if (piVar1 == NULL) {\n        piVar1 = fcn.0042032d();\n        param_1 = extraout_ECX;\n    }\n    *param_1 = *piVar1;\n    return piVar1 + 2;\n}\n",
        "token_count": 108
    },
    "004081ee": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.004081ee(uint *param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0044bde5();\n    param_1[1] = iVar1;\n    param_1[2] = *(iVar1 + 0xe8);\n    *param_1 = *(iVar1 + 0xe4);\n    *(iVar1 + 0xe4) = param_2;\n    *(param_1[1] + 0xe8) = param_1;\n    return param_1;\n}\n",
        "token_count": 129
    },
    "00408d33": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00408d33(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0041076b(param_1);\n    if (iVar1 != 0) {\n        return *(iVar1 + 0x14) + 0x76c;\n    }\n    return 0;\n}\n",
        "token_count": 78
    },
    "004097cd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_54h\n// WARNING: Variable defined which should be unmapped: var_40h\n// WARNING: Variable defined which should be unmapped: var_44h\n\nuint __cdecl fcn.004097cd(uint arg_8h, uint arg_ch, uint arg_10h, uint lpString1, uint arg_18h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    uint uVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    int32_t iStack100;\n    uint uStack96;\n    uint var_54h;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    iVar1 = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x10) = 0x80004003;\n    if (iVar1 != 0) {\n        *(unaff_EBP + -0x10) = 0;\n        if (*(unaff_EBP + 8) == 0) {\n            iVar6 = *(unaff_EBP + 0x10);\n            if (iVar6 != 0) {\n                puVar3 = iVar1 + 4;\n                do {\n                    *puVar3 = 0;\n                    puVar3 = puVar3 + 2;\n                    iVar6 = iVar6 + -1;\n                } while (iVar6 != 0);\n            }\n        }\n        else {\n            fcn.004096a8();\n            piVar2 = *(unaff_EBP + 0x18);\n            *(unaff_EBP + -4) = 0;\n            if (piVar2 == NULL) {\n                *(unaff_EBP + -0x20) = 0;\n            }\n            else {\n                *(unaff_EBP + -0x20) = *piVar2;\n            }\n            *(unaff_EBP + -0x40) = 0;\n            if (*(unaff_EBP + 0x10) != 0) {\n                do {\n                    *(unaff_EBP + -0x44) = *(iVar1 + *(unaff_EBP + -0x40) * 8);\n                    uStack96 = 0x409855;\n                    fcn.004095c0(*(unaff_EBP + 8), 1);\n                    *(unaff_EBP + -0x40) = *(unaff_EBP + -0x40) + 1;\n                } while (*(unaff_EBP + -0x40) < *(unaff_EBP + 0x10));\n            }\n            if (((piVar2 != NULL) && (*(unaff_EBP + 0x14) = piVar2 + 3,  piVar2 + 3 != NULL)) && (*piVar2 != 0)) {\n                uVar4 = (**0x4860f8)();\n                *(unaff_EBP + 8) = uVar4;\n                uStack96 = 0x409890;\n                uStack96 = fcn.0044d0f1(unaff_EBP + 0x10, piVar2[2] + -1);\n                *(unaff_EBP + -4) = 1;\n                iStack100 = 0x40989d;\n                fcn.004048c5();\n                iStack100 = 0x4098a8;\n                fcn.00403164();\n                iVar1 = *(unaff_EBP + -0x14);\n                uVar5 = piVar2[2] - 1U;\n                if (*(iVar1 + -0xc) < piVar2[2] - 1U) {\n                    uVar5 = *(iVar1 + -0xc);\n                }\n                piVar2[1] = uVar5;\n                iStack100 = iVar1;\n                iVar6 = (*_sym.imp.KERNEL32.dll_lstrlenA)();\n                fcn.0040dc10();\n                uVar4 = fcn.00403b37(&stack0xffffff9c, iVar1, iVar6 + 1, *(unaff_EBP + 8));\n                (*_sym.imp.KERNEL32.dll_lstrcpynW)(*(unaff_EBP + 0x14), uVar4, piVar2[2]);\n            }\n            fcn.00403164();\n        }\n    }\n    uVar4 = *(unaff_EBP + -0x10);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar4;\n}\n",
        "token_count": 1059
    },
    "00409d13": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409d13(uint psa, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    uint var_4h;\n    \n    uVar1 = (*_sym.imp.OLEAUT32.dll_SafeArrayUnaccessData)(psa, &var_4h);\n    fcn.004099df(uVar1);\n    fcn.0040e680(var_4h, arg_ch, arg_10h);\n    uVar1 = (*_sym.imp.OLEAUT32.dll_SafeArrayGetElement)(psa);\n    fcn.004099df(uVar1);\n    return;\n}\n",
        "token_count": 140
    },
    "00409fff": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00409fff(uint param_1)\n\n{\n    fcn.0040e620(param_1, 0, 0x10);\n    return;\n}\n",
        "token_count": 38
    },
    "0040a012": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a012(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    if (arg_10h != 0) {\n        do {\n            fcn.00409fa2();\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n    }\n    return;\n}\n",
        "token_count": 86
    },
    "0040a40e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0040a40e(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint vtime;\n    uint var_ah;\n    ushort var_6h;\n    ushort var_4h;\n    \n    fcn.0040e620(&vtime, 0, 0x10);\n    vtime._0_2_ = arg_8h;\n    vtime._2_2_ = arg_ch;\n    var_ah._0_2_ = arg_10h;\n    var_ah._2_2_ = arg_14h;\n    var_6h = arg_18h;\n    var_4h = arg_1ch;\n    iVar1 = (*_sym.imp.OLEAUT32.dll_VariantTimeToSystemTime)(&vtime);\n    *(in_ECX + 8) = iVar1 == 0;\n    return;\n}\n",
        "token_count": 240
    },
    "0040af63": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0040af63(uint arg_8h, uint arg_ch)\n\n{\n    int32_t arg_8h_00;\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    arg_8h_00 = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -4) = 0;\n    pcVar1 = _sym.imp.OLEAUT32.dll_VariantInit;\n    if (arg_8h_00 == 0) {\n        uVar2 = 0;\n    }\n    else {\n        uVar2 = (*_sym.imp.OLEAUT32.dll_VariantInit)(arg_8h_00);\n    }\n    fcn.00406888(uVar2);\n    if (arg_8h_00 != 0) {\n        iVar3 = (*pcVar1)(arg_8h_00);\n        if (iVar3 != 0) {\n            iVar3 = (*pcVar1)(arg_8h_00);\n            fcn.00431029(arg_8h_00, iVar3 * 2);\n        }\n    }\n    (*_sym.imp.OLEAUT32.dll_SysStringLen)(arg_8h_00);\n    uVar2 = *(unaff_EBP + 8);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 374
    },
    "0040b88e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING (jumptable): Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_30h\n\nvoid __cdecl\nfcn.0040b88e(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint arg_ch)\n\n{\n    uint *puVar1;\n    uint16_t uVar2;\n    uint *puVar3;\n    code **ppcVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    int32_t unaff_EBP;\n    uint16_t *puVar8;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_14h;\n    uint var_10h;\n    uint var_30h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_14h_2;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    puVar8 = *(unaff_EBP + 0xc);\n    uVar2 = *puVar8;\n    *(unaff_EBP + -0x14) = *0x496830;\n    *(unaff_EBP + -0x10) = &var_30h;\n    if (uVar2 != 0) {\n        (*_sym.imp.OLEAUT32.dll_VariantCopy)(puVar8);\n    }\n    uVar6 = *(unaff_EBP + 8);\n    fcn.004026a1(puVar8);\n    if ((*puVar8 & 0x6000) != 0) goto code_r0x0040b998;\n    // switch table (22 cases) at 0x40bab5\n    switch(*puVar8) {\n    case 2:\n    case 0xb:\n    case 0x12:\n        fcn.004026a1(puVar8 + 4);\n        break;\n    case 3:\n    case 10:\n        puVar8 = puVar8 + 4;\n        goto code_r0x0040b907;\n    case 4:\n        fcn.0040ae7a(puVar8 + 4);\n        break;\n    case 5:\n    case 7:\n        fcn.0040aebc(puVar8 + 4);\n        break;\n    case 6:\n        fcn.0040694a(puVar8 + 4);\n        puVar8 = puVar8 + 6;\ncode_r0x0040b907:\n        fcn.0040aefe(puVar8);\n        break;\n    case 8:\n        fcn.0040694a(unaff_EBP + 8);\n        if (*(unaff_EBP + 8) == 0) {\n            *(puVar8 + 4) = 0;\n        }\n        else {\n            iVar7 = (*_sym.imp.OLEAUT32.dll_DllRegisterServer)(0, *(unaff_EBP + 8));\n            *(puVar8 + 4) = iVar7;\n            if (iVar7 == 0) {\n                iVar7 = fcn.004202f9();\n            }\n            fcn.00430b26(iVar7, *(unaff_EBP + 8));\n        }\n        break;\n    case 9:\n    case 0xd:\n        *(unaff_EBP + -0x28) = 0;\n        fcn.004243e5(uVar6);\n        fcn.0040694a(unaff_EBP + -0x24);\n        fcn.004026a1(unaff_EBP + -0x20);\n        fcn.004026a1(unaff_EBP + -0x1e);\n        fcn.00430b26(unaff_EBP + -0x1c, 8);\n        pcVar5 = _sym.imp.ole32.dll_CoCreateInstance;\n        uVar6 = 0x4770fc;\n        if (*puVar8 != 0xd) {\n            uVar6 = 0x47708c;\n        }\n        puVar1 = puVar8 + 4;\n        iVar7 = (*_sym.imp.ole32.dll_CoCreateInstance)(unaff_EBP + -0x24, 0, 0x17, uVar6, puVar1);\n        if (iVar7 == -0x7ff8ffa9) {\n            uVar6 = 0x4770fc;\n            if (*puVar8 != 0xd) {\n                uVar6 = 0x47708c;\n            }\n            iVar7 = (*pcVar5)(unaff_EBP + -0x24, 0, 7, uVar6, puVar1);\n        }\n        fcn.004099df(iVar7);\n        puVar3 = *puVar1;\n        ppcVar4 = *puVar3;\n        *(unaff_EBP + -4) = 0;\n        iVar7 = (**ppcVar4)(puVar3, 0x47780c, unaff_EBP + -0x28);\n        if (iVar7 < 0) {\n            iVar7 = (****puVar1)(*puVar1, 0x47726c, unaff_EBP + -0x28);\n        }\n        fcn.004099df(iVar7);\n        uVar6 = (**(**(unaff_EBP + -0x28) + 0x14))(*(unaff_EBP + -0x28), unaff_EBP + -0x30);\n        fcn.004099df(uVar6);\n        iVar7 = **(unaff_EBP + -0x28);\n        *(unaff_EBP + -4) = 0xffffffff;\n        (**(iVar7 + 8))(*(unaff_EBP + -0x28));\n        break;\n    case 0x10:\n    case 0x11:\n        fcn.004068c3(puVar8 + 4);\n        break;\n    case 0x13:\n        fcn.0040694a(puVar8 + 4);\n        break;\n    case 0x14:\n        fcn.0040ae32(puVar8 + 4);\n        break;\n    case 0x15:\n        fcn.00406902(puVar8 + 4);\n    }\ncode_r0x0040b998:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 1514
    },
    "0040cffe": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040cffe(uint arg_8h)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    char *pcVar4;\n    int32_t *in_ECX;\n    char *pcVar5;\n    char *pcVar6;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = *(*in_ECX + -0xc);\n    pcVar3 = fcn.004043ec(iVar2);\n    pcVar1 = pcVar3 + iVar2;\n    pcVar4 = pcVar3;\n    while (pcVar6 = pcVar4,  pcVar6 < pcVar1) {\n        pcVar4 = fcn.004103c9(pcVar6);\n        if (*pcVar6 != arg_8h) {\n            pcVar5 = pcVar3 + (pcVar4 - pcVar6);\n            for (; pcVar3 != pcVar5; pcVar3 = pcVar3 + 1) {\n                *pcVar3 = *pcVar6;\n                pcVar6 = pcVar6 + 1;\n            }\n        }\n    }\n    *pcVar3 = '\\0';\n    fcn.004042a8(iVar2 - (pcVar6 - pcVar3));\n    return pcVar6 - pcVar3;\n}\n",
        "token_count": 296
    },
    "0040dc10": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n\nvoid fcn.0040dc10(void)\n\n{\n    uint32_t in_EAX;\n    uchar *puVar1;\n    uint unaff_retaddr;\n    \n    if (in_EAX < 0x1000) {\n        *(&stack0x00000000 + -in_EAX) = unaff_retaddr;\n        return;\n    }\n    puVar1 = &stack0x00000004;\n    do {\n        puVar1 = puVar1 + -0x1000;\n        in_EAX = in_EAX - 0x1000;\n    } while (0xfff < in_EAX);\n    *(puVar1 + (-4 - in_EAX)) = unaff_retaddr;\n    return;\n}\n",
        "token_count": 167
    },
    "0040dc93": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040dc93(code *UNRECOVERED_JUMPTABLE)\n\n{\n    uint *in_FS_OFFSET;\n    \n    *in_FS_OFFSET = **in_FS_OFFSET;\n    // WARNING: Could not recover jumptable at 0x0040dcbc. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*UNRECOVERED_JUMPTABLE)();\n    return;\n}\n",
        "token_count": 89
    },
    "0040e1a7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.0040e1a7(void)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint unaff_EDI;\n    \n    uVar1 = fcn.004101f8(*0x49b1a8);\n    if (uVar1 < *0x49b1a4 + (4 - *0x49b1a8)) {\n        uVar3 = 0x800;\n        if (uVar1 < 0x800) {\n            uVar3 = uVar1;\n        }\n        iVar2 = fcn.0040ff8b(*0x49b1a8, uVar3 + uVar1);\n        if (iVar2 == 0) {\n            iVar2 = fcn.0040ff8b(*0x49b1a8, uVar1 + 0x10);\n            if (iVar2 == 0) {\n                return;\n            }\n        }\n        *0x49b1a4 = iVar2 + (*0x49b1a4 - *0x49b1a8 >> 2) * 4;\n        *0x49b1a8 = iVar2;\n    }\n    **0x49b1a4 = unaff_EDI;\n    *0x49b1a4 = *0x49b1a4 + 1;\n    return;\n}\n",
        "token_count": 309
    },
    "0040edc7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040edc7(uchar *arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    uchar *var_20h;\n    int32_t var_1ch;\n    uchar *var_18h;\n    uint var_14h;\n    \n    var_18h = arg_8h;\n    var_20h = arg_8h;\n    var_14h = 0x42;\n    var_1ch = 0x7fffffff;\n    uVar1 = fcn.00413fc5(&var_20h, arg_ch, &arg_10h);\n    var_1ch = var_1ch + -1;\n    if (var_1ch < 0) {\n        fcn.00413e10(0, &var_20h);\n    }\n    else {\n        *var_20h = 0;\n        var_20h = var_20h + 1;\n    }\n    var_1ch = var_1ch + -1;\n    if (var_1ch < 0) {\n        fcn.00413e10(0, &var_20h);\n    }\n    else {\n        *var_20h = 0;\n    }\n    return uVar1;\n}\n",
        "token_count": 283
    },
    "0040ee36": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040ee36(uint arg_8h, uint arg_ch)\n\n{\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    \n    var_18h = 0;\n    var_20h = 0;\n    var_1ch = 0x7fffffff;\n    var_14h = 0x42;\n    fcn.00413fc5(&var_20h, arg_8h, &arg_ch);\n    return;\n}\n",
        "token_count": 119
    },
    "0040f037": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040f037(uchar *arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    uchar *var_20h;\n    int32_t var_1ch;\n    uchar *var_18h;\n    uint var_14h;\n    \n    var_1ch = 0x7fffffff;\n    var_14h = 0x42;\n    var_18h = arg_8h;\n    var_20h = arg_8h;\n    uVar1 = fcn.0041497b(&var_20h, arg_ch, &arg_10h);\n    if (arg_8h != NULL) {\n        var_1ch = var_1ch + -1;\n        if (var_1ch < 0) {\n            fcn.00413e10(0, &var_20h);\n        }\n        else {\n            *var_20h = 0;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 221
    },
    "0040f08f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040f08f(uint arg_8h, uint arg_ch)\n\n{\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    \n    var_18h = 0;\n    var_20h = 0;\n    var_1ch = 0x7fffffff;\n    var_14h = 0x42;\n    fcn.0041497b(&var_20h, arg_8h, &arg_ch);\n    return;\n}\n",
        "token_count": 120
    },
    "0040f19f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040f19f(uchar *arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    uchar *var_20h;\n    int32_t var_1ch;\n    uchar *var_18h;\n    uint var_14h;\n    \n    var_1ch = 0x7fffffff;\n    var_14h = 0x42;\n    var_18h = arg_8h;\n    var_20h = arg_8h;\n    uVar1 = fcn.0041497b(&var_20h, arg_ch, arg_10h);\n    if (arg_8h != NULL) {\n        var_1ch = var_1ch + -1;\n        if (var_1ch < 0) {\n            fcn.00413e10(0, &var_20h);\n        }\n        else {\n            *var_20h = 0;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 221
    },
    "0040f1f6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040f1f6(uint arg_8h, uint arg_ch)\n\n{\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    \n    var_18h = 0;\n    var_20h = 0;\n    var_1ch = 0x7fffffff;\n    var_14h = 0x42;\n    fcn.0041497b(&var_20h, arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 120
    },
    "0040f226": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040f226(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    \n    var_14h = 0x49;\n    var_18h = arg_8h;\n    var_20h = arg_8h;\n    var_1ch = fcn.0040e9c0();\n    fcn.004151cd(&var_20h, arg_ch, &arg_10h, arg_8h);\n    return;\n}\n",
        "token_count": 137
    },
    "0040f25a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040f25a(uchar *arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    uchar *var_20h;\n    int32_t var_1ch;\n    uchar *var_18h;\n    uint var_14h;\n    \n    var_1ch = arg_ch;\n    var_14h = 0x42;\n    var_18h = arg_8h;\n    var_20h = arg_8h;\n    uVar1 = fcn.0041497b(&var_20h, arg_10h, &arg_14h);\n    if (arg_8h != NULL) {\n        var_1ch = var_1ch + -1;\n        if (var_1ch < 0) {\n            fcn.00413e10(0, &var_20h);\n        }\n        else {\n            *var_20h = 0;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 229
    },
    "0040f329": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040f329(uint param_1)\n\n{\n    int32_t iVar1;\n    code **ppcVar2;\n    \n    if (*0x496ab8 != NULL) {\n        (**0x496ab8)(param_1);\n    }\n    iVar1 = 0;\n    ppcVar2 = 0x486088;\n    do {\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n        if (*ppcVar2 != NULL) {\n            iVar1 = (**ppcVar2)();\n        }\n        ppcVar2 = ppcVar2 + 1;\n    } while (ppcVar2 < 0x48609c);\n    if (iVar1 == 0) {\n        fcn.0040e287(0x413af3);\n        ppcVar2 = 0x486000;\n        do {\n            if (*ppcVar2 != NULL) {\n                (**ppcVar2)();\n            }\n            ppcVar2 = ppcVar2 + 1;\n        } while (ppcVar2 < 0x486084);\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 255
    },
    "0040f757": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040f757(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint unaff_retaddr;\n    uint var_1ch;\n    uint var_4h;\n    uint arg_ch_00;\n    \n    arg_ch_00 = 0xc;\n    fcn.0040daac();\n    *(unaff_EBP + -0x1c) = 0;\n    iVar2 = *(unaff_EBP + 0xc);\n    *(unaff_EBP + 8) = *(unaff_EBP + 8) + iVar2 * *(unaff_EBP + 0x10);\n    *(unaff_EBP + -4) = 0;\n    while( true ) {\n        piVar1 = unaff_EBP + 0x10;\n        *piVar1 = *piVar1 + -1;\n        if (*piVar1 < 0) break;\n        *(unaff_EBP + 8) = *(unaff_EBP + 8) - iVar2;\n        (**(unaff_EBP + 0x14))();\n    }\n    *(unaff_EBP + -0x1c) = 1;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0040f79f(0x4732c8, arg_ch_00, unaff_retaddr, arg_8h);\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 367
    },
    "0040f8dc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040f8dc(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00412cd5();\n    iVar1 = *(iVar1 + 0x60);\n    if (iVar1 != *0x49af6c) {\n        iVar1 = fcn.0040fc0e();\n    }\n    fcn.0040f865(iVar1, param_1, param_2);\n    return;\n}\n",
        "token_count": 108
    },
    "0040f97a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040f97a(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00412cd5();\n    iVar1 = *(iVar1 + 0x60);\n    if (iVar1 != *0x49af6c) {\n        iVar1 = fcn.0040fc0e();\n    }\n    fcn.0040f903(iVar1, param_1, param_2);\n    return;\n}\n",
        "token_count": 108
    },
    "004103e5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004103e5(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    uint unaff_retaddr;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    uint arg_ch_00;\n    \n    arg_ch_00 = 0x10;\n    fcn.0040daac();\n    *(unaff_EBP + -0x20) = 0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x1c) = 0;\n    while (*(unaff_EBP + -0x1c) < *(unaff_EBP + 0x10)) {\n        iVar1 = *(unaff_EBP + 8);\n        (**(unaff_EBP + 0x14))();\n        *(unaff_EBP + 8) = iVar1 + *(unaff_EBP + 0xc);\n        *(unaff_EBP + -0x1c) = *(unaff_EBP + -0x1c) + 1;\n    }\n    *(unaff_EBP + -0x20) = 1;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041042f(0x473328, arg_ch_00, unaff_retaddr, arg_8h, arg_ch);\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 355
    },
    "00410979": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00410979(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00412cd5();\n    return iVar1 + 8;\n}\n",
        "token_count": 42
    },
    "00410982": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00410982(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00412cd5();\n    return iVar1 + 0xc;\n}\n",
        "token_count": 43
    },
    "00410b38": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.00410b38(void)\n\n{\n    uint64_t uVar1;\n    uint32_t uVar2;\n    bool bVar3;\n    float fVar4;\n    float10 in_ST0;\n    uint32_t uStack32;\n    float fStack28;\n    \n    uVar1 = ROUND(in_ST0);\n    uStack32 = uVar1;\n    fStack28 = uVar1 >> 0x20;\n    fVar4 = in_ST0;\n    if ((uStack32 != 0) || (fVar4 = fStack28,  (uVar1 & 0x7fffffff00000000) != 0)) {\n        if (fVar4 < 0) {\n            uVar2 = 0x80000000 < (in_ST0 - uVar1 ^ 0x80000000);\n            bVar3 = CARRY4(uStack32, uVar2);\n            uStack32 = uStack32 + uVar2;\n            fStack28 = fStack28 + bVar3;\n        }\n        else {\n            uVar2 = 0x80000000 < in_ST0 - uVar1;\n            bVar3 = uStack32 < uVar2;\n            uStack32 = uStack32 - uVar2;\n            fStack28 = fStack28 - bVar3;\n        }\n    }\n    return CONCAT44(fStack28, uStack32);\n}\n",
        "token_count": 306
    },
    "00410cfc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.00410cfc(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t arg_8h_00;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0040daac(0x473338, 8);\n    piVar1 = *(unaff_EBP + 8) * 8 + 0x496ac8;\n    if (*piVar1 == 0) {\n        arg_8h_00 = fcn.0040d946(0x18);\n        if (arg_8h_00 == 0) {\n            puVar2 = fcn.00410979();\n            *puVar2 = 0xc;\n        }\n        else {\n            fcn.00410d9c(10);\n            *(unaff_EBP + -4) = 0;\n            if (*piVar1 == 0) {\n                iVar3 = fcn.004183bc(arg_8h_00, 4000);\n                if (iVar3 == 0) {\n                    fcn.0040d958(arg_8h_00);\n                    puVar2 = fcn.00410979();\n                    *puVar2 = 0xc;\n                    fcn.0040e0da(unaff_EBP + -0x10, 0xffffffff);\n                    goto code_r0x00410d8d;\n                }\n                *piVar1 = arg_8h_00;\n            }\n            else {\n                fcn.0040d958(arg_8h_00);\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00410d93();\n        }\n    }\ncode_r0x00410d8d:\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 450
    },
    "00410f1a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t fcn.00410f1a(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *0x49af4c;\n    while( true ) {\n        if (*0x49af4c + *0x49af48 * 0x14 <= uVar1) {\n            return 0;\n        }\n        if (param_1 - *(uVar1 + 0xc) < 0x100000) break;\n        uVar1 = uVar1 + 0x14;\n    }\n    return uVar1;\n}\n",
        "token_count": 130
    },
    "0041125d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * fcn.0041125d(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    \n    if (*0x49af48 == *0x49af58) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x49af60, 0, *0x49af4c, (*0x49af58 * 5 + 0x50) * 4);\n        if (iVar2 == 0) {\n            return NULL;\n        }\n        *0x49af58 = *0x49af58 + 0x10;\n        *0x49af4c = iVar2;\n    }\n    puVar1 = *0x49af4c + *0x49af48 * 0x14;\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x49af60, 8, 0x41c4);\n    puVar1[4] = iVar2;\n    if (iVar2 != 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, 0x100000, 0x2000, 4);\n        puVar1[3] = iVar2;\n        if (iVar2 != 0) {\n            puVar1[2] = 0xffffffff;\n            *puVar1 = 0;\n            puVar1[1] = 0;\n            *0x49af48 = *0x49af48 + 1;\n            *puVar1[4] = 0xffffffff;\n            return puVar1;\n        }\n        (*_sym.imp.KERNEL32.dll_HeapFree)(*0x49af60, 0, puVar1[4]);\n    }\n    return NULL;\n}\n",
        "token_count": 386
    },
    "0041246c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041246c(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t arg_8h_00;\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint arg_10h_00;\n    int32_t unaff_EBP;\n    uint var_50h;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_20h;\n    uint var_4h;\n    \n    fcn.0040daac(0x473390, 0x40);\n    arg_8h_00 = *(unaff_EBP + 0xc);\n    iVar3 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x20) = arg_10h_00;\n    *(unaff_EBP + -0x48) = 0;\n    *(unaff_EBP + -0x38) = *(arg_8h_00 + -4);\n    uVar1 = fcn.0040dfa8(unaff_EBP + -0x50, *(iVar3 + 0x18));\n    *(unaff_EBP + -0x3c) = uVar1;\n    iVar2 = fcn.00412cd5();\n    *(unaff_EBP + -0x40) = *(iVar2 + 0x7c);\n    iVar2 = fcn.00412cd5();\n    *(unaff_EBP + -0x44) = *(iVar2 + 0x80);\n    iVar2 = fcn.00412cd5();\n    *(iVar2 + 0x7c) = iVar3;\n    iVar3 = fcn.00412cd5();\n    *(iVar3 + 0x80) = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 1;\n    uVar1 = fcn.0040e03d(arg_8h_00, *(unaff_EBP + 0x14), arg_10h_00, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c));\n    *(unaff_EBP + -0x20) = uVar1;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004125c1();\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 614
    },
    "00413aaf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00413aaf(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040daac(0x473828, 0xc);\n    *(unaff_EBP + -0x1c) = 0x47b89c;\n    while (*(unaff_EBP + -0x1c) < 0x47b89c) {\n        *(unaff_EBP + -4) = 0;\n        if (**(unaff_EBP + -0x1c) != NULL) {\n            (***(unaff_EBP + -0x1c))();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(unaff_EBP + -0x1c) = *(unaff_EBP + -0x1c) + 4;\n    }\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 226
    },
    "00415f60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * fcn.00415f60(uint32_t *param_1, uint32_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t *puVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    \n    uVar4 = param_1 & 3;\n    puVar3 = param_1;\n    while (uVar4 != 0) {\n        uVar1 = *puVar3;\n        puVar3 = puVar3 + 1;\n        if (uVar1 == 0) goto code_r0x00415fb3;\n        uVar4 = puVar3 & 3;\n    }\n    do {\n        do {\n            puVar5 = puVar3;\n            puVar3 = puVar5 + 1;\n        } while (((*puVar5 ^ 0xffffffff ^ *puVar5 + 0x7efefeff) & 0x81010100) == 0);\n        uVar4 = *puVar5;\n        if (uVar4 == '\\0') goto code_r0x00415fc5;\n        if (uVar4 >> 8 == '\\0') {\n            puVar5 = puVar5 + 1;\n            goto code_r0x00415fc5;\n        }\n        if ((uVar4 & 0xff0000) == 0) {\n            puVar5 = puVar5 + 2;\n            goto code_r0x00415fc5;\n        }\n    } while ((uVar4 & 0xff000000) != 0);\ncode_r0x00415fb3:\n    puVar5 = puVar3 + -1;\ncode_r0x00415fc5:\n    uVar4 = param_2 & 3;\n    while (uVar4 != 0) {\n        uVar1 = *param_2;\n        uVar4 = uVar1;\n        param_2 = param_2 + 1;\n        if (uVar1 == 0) goto code_r0x00416040;\n        *puVar5 = uVar1;\n        puVar5 = puVar5 + 1;\n        uVar4 = param_2 & 3;\n    }\n    do {\n        uVar2 = *param_2;\n        uVar4 = *param_2;\n        param_2 = param_2 + 1;\n        if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {\n            if (uVar4 == '\\0') {\ncode_r0x00416040:\n                *puVar5 = uVar4;\n                return param_1;\n            }\n            if (uVar4 >> 8 == '\\0') {\n                *puVar5 = uVar4;\n                return param_1;\n            }\n            if ((uVar4 & 0xff0000) == 0) {\n                *puVar5 = uVar4;\n                *(puVar5 + 2) = 0;\n                return param_1;\n            }\n            if ((uVar4 & 0xff000000) == 0) {\n                *puVar5 = uVar4;\n                return param_1;\n            }\n        }\n        *puVar5 = uVar4;\n        puVar5 = puVar5 + 1;\n    } while( true );\n}\n",
        "token_count": 750
    },
    "00415f50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * fcn.00415f50(uint32_t *param_1, uint32_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t *puVar4;\n    \n    uVar3 = param_2 & 3;\n    puVar4 = param_1;\n    while (uVar3 != 0) {\n        uVar1 = *param_2;\n        uVar3 = uVar1;\n        param_2 = param_2 + 1;\n        if (uVar1 == 0) goto code_r0x00416040;\n        *puVar4 = uVar1;\n        puVar4 = puVar4 + 1;\n        uVar3 = param_2 & 3;\n    }\n    do {\n        uVar2 = *param_2;\n        uVar3 = *param_2;\n        param_2 = param_2 + 1;\n        if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {\n            if (uVar3 == '\\0') {\ncode_r0x00416040:\n                *puVar4 = uVar3;\n                return param_1;\n            }\n            if (uVar3 >> 8 == '\\0') {\n                *puVar4 = uVar3;\n                return param_1;\n            }\n            if ((uVar3 & 0xff0000) == 0) {\n                *puVar4 = uVar3;\n                *(puVar4 + 2) = 0;\n                return param_1;\n            }\n            if ((uVar3 & 0xff000000) == 0) {\n                *puVar4 = uVar3;\n                return param_1;\n            }\n        }\n        *puVar4 = uVar3;\n        puVar4 = puVar4 + 1;\n    } while( true );\n}\n",
        "token_count": 437
    },
    "00416050": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00416050(char *arg_8h, char *arg_ch, uint32_t arg_10h)\n\n{\n    char cVar1;\n    char cVar2;\n    uint8_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    char *pcVar6;\n    char *pcVar7;\n    bool bVar8;\n    \n    uVar4 = arg_10h;\n    pcVar6 = arg_8h;\n    if (arg_10h != 0) {\n        do {\n            if (uVar4 == 0) break;\n            uVar4 = uVar4 - 1;\n            cVar1 = *pcVar6;\n            pcVar6 = pcVar6 + 1;\n        } while (cVar1 != '\\0');\n        iVar5 = arg_10h - uVar4;\n        do {\n            pcVar6 = arg_ch;\n            pcVar7 = arg_8h;\n            if (iVar5 == 0) break;\n            iVar5 = iVar5 + -1;\n            pcVar7 = arg_8h + 1;\n            pcVar6 = arg_ch + 1;\n            cVar1 = *arg_ch;\n            cVar2 = *arg_8h;\n            arg_ch = pcVar6;\n            arg_8h = pcVar7;\n        } while (cVar1 == cVar2);\n        uVar3 = pcVar6[-1];\n        arg_10h = 0;\n        bVar8 = uVar3 == pcVar7[-1];\n        if (uVar3 < pcVar7[-1] || bVar8) {\n            if (bVar8) {\n                return 0;\n            }\n            arg_10h = 0xfffffffe;\n        }\n        arg_10h = ~arg_10h;\n    }\n    return arg_10h;\n}\n",
        "token_count": 414
    },
    "004166f8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint32_t __cdecl fcn.004166f8(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint noname_2;\n    int32_t iVar1;\n    uint32_t in_ECX;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint32_t var_4h;\n    \n    if (arg_ch + 1 < 0x101) {\n        arg_ch._2_2_ = *(*(arg_8h + 0x48) + arg_ch * 2);\n    }\n    else {\n        if ((*(*(arg_8h + 0x48) + 1 + (arg_ch >> 8 & 0xffU) * 2) & 0x80) == 0) {\n            var_4h = in_ECX & 0xffff0000 | arg_ch & 0xff;\n            noname_2 = 1;\n        }\n        else {\n            var_4h = CONCAT11(arg_ch, arg_ch >> 8);\n            var_4h = in_ECX & 0xff000000 | var_4h;\n            noname_2 = 2;\n        }\n        iVar1 = fcn.0041653e(1, &var_4h, noname_2, &arg_ch + 2, *(arg_8h + 4), *(arg_8h + 0x14), 1, var_4h, unaff_EBP, \n                             unaff_retaddr, arg_8h, arg_ch, arg_10h, in_stack_00000010, in_stack_00000014);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return arg_ch._2_2_ & arg_10h;\n}\n",
        "token_count": 429
    },
    "00416936": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00416936(uint param_1, int32_t param_2)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    \n    if (0 < param_2) {\n        puVar1 = &param_2;\n        iVar2 = param_2;\n        do {\n            puVar1 = puVar1 + 1;\n            fcn.00415f60(param_1, *puVar1);\n            iVar2 = iVar2 + -1;\n        } while (iVar2 != 0);\n    }\n    return;\n}\n",
        "token_count": 122
    },
    "00416abf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuchar * fcn.00416abf(void)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    \n    bVar1 = true;\n    if (*0x496f04 == NULL) {\n        *0x496f04 = fcn.0040d946(0x351);\n        if (*0x496f04 == NULL) {\n            return NULL;\n        }\n    }\n    **0x496f04 = 0;\n    fcn.00416936(*0x496f04, 3, *0x496f0c, 0x473c94, *0x496f10);\n    puVar3 = 0x496f10;\n    do {\n        fcn.00415f60(*0x496f04, 0x46cfa4);\n        puVar4 = puVar3 + 3;\n        iVar2 = fcn.00413b40(*puVar3, *puVar4);\n        if (iVar2 != 0) {\n            bVar1 = false;\n        }\n        fcn.00416936(*0x496f04, 3, puVar3[2], 0x473c94, *puVar4);\n        puVar3 = puVar4;\n    } while (puVar4 < 0x496f40);\n    if (!bVar1) {\n        return *0x496f04;\n    }\n    fcn.0040d958(*0x496f04);\n    *0x496f04 = NULL;\n    return *0x496f1c;\n}\n",
        "token_count": 354
    },
    "00417952": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nbool fcn.00417952(void)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t *unaff_EBX;\n    uint32_t uVar6;\n    \n    if (*0x496f54 == 0) {\n        return false;\n    }\n    iVar1 = unaff_EBX[5];\n    if ((iVar1 != *0x496fe8) || (iVar1 != *0x496ff4)) {\n        if (*0x499d14 == 0) {\n            fcn.0041779a(1, 1, iVar1, 1, 0, 0, 0, 0, 0);\n            fcn.0041779a(0, 1, iVar1, 5, 0, 0, 0, 0, 0);\n        }\n        else {\n            if (*0x499d00 != 0) {\n                uVar6 = *0x499d06;\n                uVar3 = 0;\n                uVar4 = 0;\n            }\n            else {\n                uVar3 = *0x499d04;\n                uVar6 = 0;\n                uVar4 = *0x499d06;\n            }\n            fcn.0041779a(1, *0x499d00 == 0, iVar1, uVar4, uVar3, uVar6, *0x499d0a, *0x499d0c, *0x499d0e);\n            if (*0x499cac != 0) {\n                uVar6 = *0x499cb2;\n                uVar3 = 0;\n                uVar4 = 0;\n            }\n            else {\n                uVar3 = *0x499cb0;\n                uVar6 = 0;\n                uVar4 = *0x499cb2;\n            }\n            fcn.0041779a(0, *0x499cac == 0, iVar1, uVar4, uVar3, uVar6, *0x499cb6, *0x499cb8, *0x499cba);\n        }\n    }\n    iVar1 = unaff_EBX[7];\n    if (*0x496fec < *0x496ff8) {\n        if ((iVar1 < *0x496fec) || (*0x496ff8 < iVar1)) {\n            return false;\n        }\n        if ((*0x496fec < iVar1) && (iVar1 < *0x496ff8)) {\n            return true;\n        }\n    }\n    else {\n        if (iVar1 < *0x496ff8) {\n            return true;\n        }\n        if (*0x496fec < iVar1) {\n            return true;\n        }\n        if ((*0x496ff8 < iVar1) && (iVar1 < *0x496fec)) {\n            return false;\n        }\n    }\n    iVar5 = ((unaff_EBX[2] * 0x3c + unaff_EBX[1]) * 0x3c + *unaff_EBX) * 1000;\n    if (iVar1 == *0x496fec) {\n        bVar2 = *0x496ff0 <= iVar5;\n    }\n    else {\n        bVar2 = iVar5 < *0x496ffc;\n    }\n    return bVar2;\n}\n",
        "token_count": 750
    },
    "00417dfc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417dfc(uint *arg_8h, int32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t var_2ch;\n    uint var_1ch;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    fcn.0041bdc1(*arg_8h, arg_8h[1], &var_2ch, &var_1ch);\n    fcn.0041bc90((0 < arg_10h) + (var_2ch == 0x2d) + arg_ch, arg_10h + 1, &var_2ch);\n    fcn.00417d4e(arg_10h, arg_14h, 0);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 192
    },
    "00417f04": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417f04(uint *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint var_1ch;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    fcn.0041bdc1(*arg_8h, arg_8h[1], &var_2ch, &var_1ch);\n    fcn.0041bc90((var_2ch == 0x2d) + arg_ch, var_28h + arg_10h, &var_2ch);\n    fcn.00417e68(arg_ch, arg_10h, 0);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 185
    },
    "00417f66": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417f66(uint *arg_8h, int32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    char *arg_8h_00;\n    int32_t iVar1;\n    char *pcVar2;\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint var_1ch;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    fcn.0041bdc1(*arg_8h, arg_8h[1], &var_2ch, &var_1ch);\n    iVar1 = var_28h + -1;\n    arg_8h_00 = (var_2ch == 0x2d) + arg_ch;\n    fcn.0041bc90(arg_8h_00, arg_10h, &var_2ch);\n    var_28h = var_28h + -1;\n    if ((var_28h < -4) || (arg_10h <= var_28h)) {\n        fcn.00417d4e(arg_10h, arg_14h, 1);\n    }\n    else {\n        if (iVar1 < var_28h) {\n            do {\n                pcVar2 = arg_8h_00;\n                arg_8h_00 = pcVar2 + 1;\n            } while (*pcVar2 != '\\0');\n            pcVar2[-1] = '\\0';\n        }\n        fcn.00417e68(arg_ch, arg_10h, 1);\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 370
    },
    "00418f34": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00418f34(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00412cd5();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x496dc4) {\n        iVar1 = fcn.00416a84();\n    }\n    fcn.00418e74(iVar1, param_1, param_2, param_3);\n    return;\n}\n",
        "token_count": 112
    },
    "00419065": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00419065(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00412cd5();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x496dc4) {\n        iVar1 = fcn.00416a84();\n    }\n    fcn.00419005(iVar1, param_1, param_2);\n    return;\n}\n",
        "token_count": 101
    },
    "00419ff5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00419ff5(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00412cd5();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x496dc4) {\n        iVar1 = fcn.00416a84();\n    }\n    fcn.00419f30(iVar1, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h);\n    return;\n}\n",
        "token_count": 138
    },
    "0041af77": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0041af77(uint param_1, char *param_2)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    \n    iVar1 = 0;\n    while (cVar2 = *param_2,  cVar2 != '\\0') {\n        param_2 = param_2 + 1;\n        if ((cVar2 < 'a') || ('f' < cVar2)) {\n            if (('@' < cVar2) && (cVar2 < 'G')) {\n                cVar2 = cVar2 + -7;\n            }\n        }\n        else {\n            cVar2 = cVar2 + -0x27;\n        }\n        iVar1 = (iVar1 + 0xffffffd) * 0x10 + cVar2;\n    }\n    return iVar1;\n}\n",
        "token_count": 185
    },
    "0041bb30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041bb30(uint param_1, uint param_2)\n\n{\n    fcn.0041b9d8(param_1, param_2, 0x497428);\n    return;\n}\n",
        "token_count": 48
    },
    "0041bb46": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041bb46(uint param_1, uint param_2)\n\n{\n    fcn.0041b9d8(param_1, param_2, 0x497440);\n    return;\n}\n",
        "token_count": 48
    },
    "0041bbd8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041bbd8(uint arg_8h, uint arg_ch)\n\n{\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    fcn.0041d5e5(&var_10h, &var_14h, arg_ch, 0, 0, 0, 0);\n    fcn.0041bb30(&var_10h, arg_8h);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 127
    },
    "0041bc15": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041bc15(uint arg_8h, uint arg_ch)\n\n{\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    fcn.0041d5e5(&var_10h, &var_14h, arg_ch, 1, 0, 0, 0);\n    fcn.0041bb5c(&var_10h, arg_8h);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 127
    },
    "0041bc53": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041bc53(uint arg_8h, uint arg_ch)\n\n{\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    fcn.0041d5e5(&var_10h, &var_14h, arg_ch, 0, 0, 0, 0);\n    fcn.0041bb46(&var_10h, arg_8h);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 126
    },
    "0041bc90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041bc90(char *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    char *arg_ch_00;\n    char *arg_8h_00;\n    char *pcVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    char cVar4;\n    \n    arg_8h_00 = arg_8h;\n    pcVar3 = *(arg_10h + 0xc);\n    arg_ch_00 = arg_8h + 1;\n    *arg_8h = '0';\n    pcVar1 = arg_ch_00;\n    if (0 < arg_ch) {\n        arg_8h = arg_ch;\n        arg_ch = 0;\n        do {\n            cVar4 = *pcVar3;\n            if (cVar4 == '\\0') {\n                cVar4 = '0';\n            }\n            else {\n                pcVar3 = pcVar3 + 1;\n            }\n            *pcVar1 = cVar4;\n            pcVar1 = pcVar1 + 1;\n            arg_8h = arg_8h + -1;\n        } while (arg_8h != NULL);\n    }\n    *pcVar1 = '\\0';\n    if ((-1 < arg_ch) && ('4' < *pcVar3)) {\n        while (pcVar1 = pcVar1 + -1,  *pcVar1 == '9') {\n            *pcVar1 = '0';\n        }\n        *pcVar1 = *pcVar1 + '\\x01';\n    }\n    if (*arg_8h_00 == '1') {\n        *(arg_10h + 4) = *(arg_10h + 4) + 1;\n    }\n    else {\n        iVar2 = fcn.0040e9c0(arg_ch_00);\n        fcn.0040ea50(arg_8h_00, arg_ch_00, iVar2 + 1);\n    }\n    return;\n}\n",
        "token_count": 440
    },
    "0041bdc1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041bdc1(uint arg_8h, uint noname_1, int32_t *arg_10h, int32_t arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint in_stack_ffffffb8;\n    ushort uVar4;\n    uint var_2ch;\n    uchar var_28h [24];\n    uint var_10h;\n    uint uStack16;\n    ushort uStack12;\n    uint var_4h;\n    \n    uVar4 = in_stack_ffffffb8 >> 0x10;\n    var_4h = *0x496830;\n    fcn.0041bd07(&var_10h, &arg_8h);\n    iVar3 = fcn.0041da65(var_10h, uStack16, CONCAT22(uVar4, uStack12), 0x11, 0, &var_2ch);\n    iVar2 = arg_14h;\n    piVar1 = arg_10h;\n    arg_10h[2] = iVar3;\n    *arg_10h = var_2ch._2_1_;\n    arg_10h[1] = var_2ch;\n    fcn.00415f50(arg_14h, var_28h);\n    piVar1[3] = iVar2;\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 330
    },
    "0041c0b2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0041c0b2(uint param_1, uint32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t unaff_ESI;\n    \n    uVar1 = param_2;\n    do {\n        if (*(uVar1 + 4) == unaff_ESI) break;\n        uVar1 = uVar1 + 0xc;\n    } while (uVar1 < param_2 + *0x496d1c * 0xc);\n    if ((param_2 + *0x496d1c * 0xc <= uVar1) || (*(uVar1 + 4) != unaff_ESI)) {\n        uVar1 = 0;\n    }\n    return uVar1;\n}\n",
        "token_count": 169
    },
    "0041cf90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041cf90(char *arg_8h, char *arg_ch)\n\n{\n    char cVar1;\n    char cVar2;\n    uint8_t uVar3;\n    uint8_t uVar5;\n    uint32_t uVar4;\n    \n    uVar4 = 0xff;\n    do {\n        do {\n            cVar2 = uVar4;\n            if (cVar2 == '\\0') goto code_r0x0041cfd6;\n            cVar2 = *arg_ch;\n            arg_ch = arg_ch + 1;\n            cVar1 = *arg_8h;\n            uVar4 = CONCAT11(cVar1, cVar2);\n            arg_8h = arg_8h + 1;\n        } while (uVar4 >> 8 == cVar2);\n        uVar3 = cVar1 + 0xbf;\n        uVar3 = uVar3 + (-(uVar3 < 0x1a) & 0x20U) + 0x41;\n        uVar4 = CONCAT11(cVar2 + 0xbfU + (-(cVar2 + 0xbfU < 0x1a) & 0x20U) + 'A', uVar3);\n        uVar5 = uVar4 >> 8;\n    } while (uVar3 == uVar5);\n    cVar2 = (uVar3 < uVar5) * -2 + '\\x01';\ncode_r0x0041cfd6:\n    return cVar2;\n}\n",
        "token_count": 340
    },
    "0041d39d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0041d39d(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint var_8h;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_WideCharToMultiByte;\n    var_4h = 0;\n    iVar2 = **0x499914;\n    piVar3 = *0x499914;\n    while( true ) {\n        if (iVar2 == 0) {\n            return 0;\n        }\n        iVar2 = (*pcVar1)(0, 0, iVar2, 0xffffffff, 0, 0, 0, 0);\n        if ((iVar2 == 0) || (var_4h = fcn.0040d946(iVar2),  var_4h == 0)) break;\n        iVar2 = (*pcVar1)(0, 0, *piVar3, 0xffffffff, var_4h, iVar2, 0, 0);\n        if (iVar2 == 0) {\n            fcn.0040d958(var_4h);\n            return 0xffffffff;\n        }\n        iVar2 = fcn.0041e56f(&var_4h, 0);\n        if ((iVar2 < 0) && (var_4h != 0)) {\n            fcn.0040d958(var_4h);\n            var_4h = 0;\n        }\n        piVar3 = piVar3 + 1;\n        iVar2 = *piVar3;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 359
    },
    "0041e0c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041e0c0(uint8_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    bool bVar3;\n    \n    if (arg_10h != 0) {\n        do {\n            uVar2 = *arg_8h;\n            uVar1 = *arg_ch;\n            if ((uVar2 == 0) || (uVar1 == 0)) break;\n            arg_8h = arg_8h + 1;\n            arg_ch = arg_ch + 1;\n            if ((0x40 < uVar2) && (uVar2 < 0x5b)) {\n                uVar2 = uVar2 + 0x20;\n            }\n            if ((0x40 < uVar1) && (uVar1 < 0x5b)) {\n                uVar1 = uVar1 + 0x20;\n            }\n            bVar3 = uVar2 < uVar1;\n            if (uVar2 != uVar1) goto code_r0x0041e111;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n        arg_10h = 0;\n        bVar3 = uVar2 < uVar1;\n        if (uVar2 != uVar1) {\ncode_r0x0041e111:\n            arg_10h = -1;\n            if (!bVar3) {\n                arg_10h = 1;\n            }\n        }\n    }\n    return arg_10h;\n}\n",
        "token_count": 366
    },
    "0041e56f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041e56f(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uchar *puVar4;\n    bool bVar5;\n    uint var_10h;\n    uint var_ch;\n    uint lpValue;\n    uint var_4h;\n    \n    var_10h = 0;\n    if (arg_8h == NULL) {\n        return 0xffffffff;\n    }\n    arg_8h_00 = *arg_8h;\n    if (arg_8h_00 == 0) {\n        return 0xffffffff;\n    }\n    iVar1 = fcn.0040ef28(arg_8h_00, 0x3d);\n    if (iVar1 == 0) {\n        return 0xffffffff;\n    }\n    if (arg_8h_00 == iVar1) {\n        return 0xffffffff;\n    }\n    bVar5 = *(iVar1 + 1) == '\\0';\n    if (*0x49990c == *0x499910) {\n        *0x49990c = fcn.0041e50e();\n    }\n    if (*0x49990c == NULL) {\n        if ((arg_ch != 0) && (*0x499914 != NULL)) {\n            iVar2 = fcn.0041d39d();\n            if (iVar2 != 0) {\n                return 0xffffffff;\n            }\n            goto code_r0x0041e624;\n        }\n        if (!bVar5) {\n            *0x49990c = fcn.0040d946(4);\n            if (*0x49990c == NULL) {\n                return 0xffffffff;\n            }\n            **0x49990c = 0;\n            if (*0x499914 == NULL) {\n                *0x499914 = fcn.0040d946(4);\n                if (*0x499914 == NULL) {\n                    return 0xffffffff;\n                }\n                **0x499914 = 0;\n            }\n            goto code_r0x0041e624;\n        }\ncode_r0x0041e5f2:\n        var_10h = 0;\n    }\n    else {\ncode_r0x0041e624:\n        piVar3 = *0x49990c;\n        iVar2 = fcn.0041e4c1(arg_8h_00);\n        if ((iVar2 < 0) || (*piVar3 == 0)) {\n            if (bVar5) {\n                fcn.0040d958(arg_8h_00);\n                *arg_8h = 0;\n                goto code_r0x0041e5f2;\n            }\n            if (iVar2 < 0) {\n                iVar2 = -iVar2;\n            }\n            piVar3 = fcn.0040ff8b(*0x49990c, iVar2 * 4 + 8);\n            if (piVar3 == NULL) {\n                return 0xffffffff;\n            }\n            piVar3[iVar2] = arg_8h_00;\n            (piVar3 + iVar2)[1] = 0;\n            *arg_8h = 0;\ncode_r0x0041e6c1:\n            *0x49990c = piVar3;\n        }\n        else {\n            piVar3 = piVar3 + iVar2;\n            fcn.0040d958(*piVar3);\n            if (bVar5) {\n                for (; *piVar3 != 0; piVar3 = piVar3 + 1) {\n                    *piVar3 = piVar3[1];\n                    iVar2 = iVar2 + 1;\n                }\n                piVar3 = fcn.0040ff8b(*0x49990c, iVar2 << 2);\n                if (piVar3 != NULL) goto code_r0x0041e6c1;\n            }\n            else {\n                *piVar3 = arg_8h_00;\n                *arg_8h = 0;\n            }\n        }\n        if (arg_ch != 0) {\n            iVar2 = fcn.0040e9c0(arg_8h_00);\n            iVar2 = fcn.0040d946(iVar2 + 2);\n            if (iVar2 != 0) {\n                fcn.00415f50(iVar2, arg_8h_00);\n                puVar4 = (iVar2 - arg_8h_00) + iVar1;\n                *puVar4 = 0;\n                iVar1 = (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(iVar2, ~-bVar5 & puVar4 + 1);\n                if (iVar1 == 0) {\n                    var_10h = 0xffffffff;\n                }\n                fcn.0040d958(iVar2);\n            }\n        }\n        if (bVar5) {\n            fcn.0040d958(arg_8h_00);\n        }\n    }\n    return var_10h;\n}\n",
        "token_count": 1122
    },
    "0041e976": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041e976(ushort *arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint *arg_ch_00;\n    uint var_10h;\n    ushort uStack16;\n    ushort uStack14;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    iVar4 = 0x497400;\n    if (arg_ch != 0) {\n        if (arg_ch < 0) {\n            arg_ch = -arg_ch;\n            iVar4 = 0x497560;\n        }\n        if (arg_10h == 0) {\n            *arg_8h = 0;\n        }\n        while (arg_ch != 0) {\n            uVar1 = arg_ch >> 3;\n            uVar3 = arg_ch & 7;\n            iVar4 = iVar4 + 0x54;\n            arg_ch = uVar1;\n            if (uVar3 != 0) {\n                arg_ch_00 = iVar4 + uVar3 * 0xc;\n                if (0x7fff < *arg_ch_00) {\n                    var_10h._0_2_ = *arg_ch_00;\n                    var_10h._2_2_ = *arg_ch_00 >> 0x10;\n                    uStack16 = arg_ch_00[1];\n                    uStack14 = arg_ch_00[1] >> 0x10;\n                    uStack12 = arg_ch_00[2];\n                    iVar2 = CONCAT22(uStack16, var_10h._2_2_) + -1;\n                    var_10h._2_2_ = iVar2;\n                    uStack16 = iVar2 >> 0x10;\n                    arg_ch_00 = &var_10h;\n                }\n                fcn.0041e744(arg_8h, arg_ch_00);\n            }\n        }\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 479
    },
    "0041f9f7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0041f9f7(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t arg_8h;\n    int32_t iVar1;\n    uint uVar2;\n    \n    if ((param_2 < 0) || (iVar1 = param_1[1],  iVar1 <= param_2)) {\n        uVar2 = 0;\n    }\n    else {\n        if (param_2 != iVar1 + -1) {\n            arg_8h = *param_1 + param_2 * 4;\n            fcn.0040ea50(arg_8h, arg_8h + 4, (iVar1 - param_2) * 4 + -4);\n        }\n        param_1[1] = param_1[1] + -1;\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 201
    },
    "00420759": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00420759(uint arg_8h)\n\n{\n    uint16_t *puVar1;\n    int32_t in_ECX;\n    int32_t arg_8h_00;\n    uint var_4h;\n    \n    arg_8h_00 = *(in_ECX + 0x7c);\n    if (arg_8h_00 != 0) {\n        puVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(arg_8h_00, 0);\n        arg_8h_00 = *puVar1 + puVar1;\n    }\n    fcn.004045fc(arg_8h_00);\n    return arg_8h;\n}\n",
        "token_count": 169
    },
    "00420787": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00420787(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = *(in_ECX + 0x7c);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1, 0);\n        iVar1 = *(iVar1 + 2) + iVar1;\n    }\n    fcn.004045fc(iVar1);\n    return arg_8h;\n}\n",
        "token_count": 138
    },
    "004207b6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.004207b6(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = *(in_ECX + 0x7c);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1, 0);\n        iVar1 = *(iVar1 + 4) + iVar1;\n    }\n    fcn.004045fc(iVar1);\n    return arg_8h;\n}\n",
        "token_count": 139
    },
    "004207e5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.004207e5(uint arg_8h)\n\n{\n    uint16_t *puVar1;\n    int32_t in_ECX;\n    int32_t arg_8h_00;\n    uint var_4h;\n    \n    arg_8h_00 = *(*(in_ECX + 0x70) + 0xc);\n    if (arg_8h_00 != 0) {\n        puVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(arg_8h_00, 0);\n        arg_8h_00 = *puVar1 + puVar1;\n    }\n    fcn.004045fc(arg_8h_00);\n    return arg_8h;\n}\n",
        "token_count": 175
    },
    "00420816": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00420816(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = *(*(in_ECX + 0x70) + 0xc);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1, 0);\n        iVar1 = *(iVar1 + 2) + iVar1;\n    }\n    fcn.004045fc(iVar1);\n    return arg_8h;\n}\n",
        "token_count": 143
    },
    "00420848": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00420848(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = *(*(in_ECX + 0x70) + 0xc);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1, 0);\n        iVar1 = *(iVar1 + 4) + iVar1;\n    }\n    fcn.004045fc(iVar1);\n    return arg_8h;\n}\n",
        "token_count": 143
    },
    "0042149a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.0042149a(code **param_1)\n\n{\n    fcn.0042b093(0, 0);\n    *param_1 = vtable.CFindReplaceDialog.0;\n    fcn.0040e620(param_1 + 0x1c, 0, 0x28);\n    *(param_1 + 0x26) = 0;\n    param_1[0x1c] = 0x28;\n    param_1[0x20] = param_1 + 0x26;\n    *(param_1 + 0x46) = 0;\n    param_1[0x1f] = 0x100;\n    param_1[0x24] = fcn.004212e9;\n    return param_1;\n}\n",
        "token_count": 180
    },
    "00421a4e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421a4e(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t in_ECX;\n    uint var_34h;\n    uint var_2ch;\n    uint var_20h;\n    uint var_1ch;\n    \n    fcn.0040e620(&var_34h, 0, 0x34);\n    var_2ch = arg_ch;\n    var_1ch = arg_14h;\n    var_20h = arg_10h;\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x102d, arg_8h, &var_34h);\n    return;\n}\n",
        "token_count": 169
    },
    "00421a93": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00421a93(uint arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_34h;\n    uint var_30h;\n    uint var_14h;\n    \n    fcn.0040e620(&var_34h, 0, 0x34);\n    var_30h = arg_8h;\n    var_34h = 4;\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x1005, 0, &var_34h);\n    return var_14h;\n}\n",
        "token_count": 136
    },
    "0042347b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0042347b(int32_t arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    \n    fcn.0040e620(&var_3ch, 0, 0x3c);\n    var_30h = 0x28;\n    if (arg_8h == 0) {\n        var_3ch = 0;\n    }\n    else {\n        var_3ch = *(arg_8h + 0x1c);\n    }\n    var_38h = arg_ch;\n    var_34h = arg_10h;\n    iVar1 = (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x40a, 0, &var_3ch);\n    if (iVar1 != 0) {\n        fcn.0040e680(arg_14h, &var_30h, 0x28);\n    }\n    return iVar1 != 0;\n}\n",
        "token_count": 266
    },
    "004234ee": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004234ee(uint *param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    uint uVar2;\n    \n    fcn.0040e620(param_1, 0, 0x28);\n    *param_1 = 0x28;\n    if (param_2 == 0) {\n        uVar2 = 0;\n    }\n    else {\n        uVar2 = *(param_2 + 0x1c);\n    }\n    if (param_3 == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_GetParent)(uVar2);\n        param_1[2] = uVar1;\n        param_1[1] = 1;\n        param_1[3] = uVar2;\n    }\n    else {\n        param_1[1] = 0;\n        param_1[2] = uVar2;\n        param_1[3] = param_3;\n    }\n    return;\n}\n",
        "token_count": 226
    },
    "00424a31": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424a31(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    int32_t iVar5;\n    \n    iVar1 = arg_8h;\n    iVar5 = 0;\n    if (arg_8h < 0) {\ncode_r0x00424af7:\n        iVar4 = fcn.0042032d();\n    }\n    else {\n        if (-1 < arg_ch) {\n            *(in_ECX + 0x10) = arg_ch;\n        }\n        if (arg_8h == 0) {\n            fcn.00425d0d(*(in_ECX + 4));\n            *(in_ECX + 0xc) = 0;\n            *(in_ECX + 8) = 0;\n            goto code_r0x00424b41;\n        }\n        if (*(in_ECX + 4) == 0) {\n            uVar3 = fcn.00425ce2(arg_8h << 2);\n            *(in_ECX + 4) = uVar3;\n            fcn.0040e620(uVar3, 0, arg_8h << 2);\n            *(in_ECX + 0xc) = arg_8h;\ncode_r0x00424a8c:\n            *(in_ECX + 8) = arg_8h;\n            return;\n        }\n        iVar5 = *(in_ECX + 0xc);\n        if (arg_8h <= iVar5) {\n            iVar1 = *(in_ECX + 8);\n            if (iVar1 < arg_8h) {\n                fcn.0040e620(*(in_ECX + 4) + iVar1 * 4, 0, (arg_8h - iVar1) * 4);\n            }\n            goto code_r0x00424a8c;\n        }\n        iVar4 = *(in_ECX + 0x10);\n        if (iVar4 == 0) {\n            iVar4 = *(in_ECX + 8) / 8;\n            if (iVar4 < 4) {\ncode_r0x00424ae1:\n                iVar4 = 4;\n            }\n            else if (iVar4 < 0x401) {\n                if (iVar4 < 4) goto code_r0x00424ae1;\n            }\n            else {\n                iVar4 = 0x400;\n            }\n        }\n        iVar2 = iVar4 + iVar5;\n        if (iVar4 + iVar5 <= arg_8h) {\n            iVar2 = arg_8h;\n        }\n        arg_8h = iVar2;\n        iVar4 = arg_8h;\n        if (arg_8h < iVar5) goto code_r0x00424af7;\n    }\n    iVar5 = fcn.00425ce2(iVar4 << 2);\n    fcn.0040e680(iVar5, *(in_ECX + 4), *(in_ECX + 8) << 2);\n    fcn.0040e620(iVar5 + *(in_ECX + 8) * 4, 0, (iVar1 - *(in_ECX + 8)) * 4);\n    fcn.00425d0d(*(in_ECX + 4));\n    *(in_ECX + 8) = iVar1;\n    *(in_ECX + 0xc) = arg_8h;\ncode_r0x00424b41:\n    *(in_ECX + 4) = iVar5;\n    return;\n}\n",
        "token_count": 800
    },
    "00424c37": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424c37(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t in_ECX;\n    \n    if ((-1 < arg_8h) && (0 < arg_10h)) {\n        if (arg_8h < *(in_ECX + 8)) {\n            iVar1 = *(in_ECX + 8);\n            fcn.00424a31(arg_10h + iVar1, 0xffffffff);\n            fcn.0040ea50(*(in_ECX + 4) + (arg_8h + arg_10h) * 4, *(in_ECX + 4) + arg_8h * 4, (iVar1 - arg_8h) * 4);\n            fcn.0040e620(*(in_ECX + 4) + arg_8h * 4, 0, arg_10h << 2);\n        }\n        else {\n            fcn.00424a31(arg_10h + arg_8h, 0xffffffff);\n        }\n        arg_8h = arg_8h << 2;\n        do {\n            *(arg_8h + *(in_ECX + 4)) = arg_ch;\n            arg_8h = arg_8h + 4;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n        return;\n    }\n    fcn.0042032d();\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 362
    },
    "00424cc7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00424cc7(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    if ((-1 < param_2) && (-1 < param_3)) {\n        if (param_2 + param_3 <= *(param_1 + 8)) {\n            iVar2 = (*(param_1 + 8) - param_2) - param_3;\n            if (iVar2 != 0) {\n                fcn.0040ea50(*(param_1 + 4) + param_2 * 4, *(param_1 + 4) + (param_2 + param_3) * 4, iVar2 * 4);\n            }\n            *(param_1 + 8) = *(param_1 + 8) - param_3;\n            return;\n        }\n    }\n    fcn.0042032d();\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 233
    },
    "00424dfb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424dfb(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    int32_t iVar5;\n    \n    iVar1 = arg_8h;\n    iVar5 = 0;\n    if (arg_8h < 0) {\ncode_r0x00424eb5:\n        fcn.0042032d();\n    }\n    else {\n        if (-1 < arg_ch) {\n            *(in_ECX + 0x10) = arg_ch;\n        }\n        if (arg_8h == 0) {\n            fcn.00425d0d(*(in_ECX + 4));\n            *(in_ECX + 0xc) = 0;\n            *(in_ECX + 8) = 0;\n            goto code_r0x00424ef6;\n        }\n        if (*(in_ECX + 4) == 0) {\n            uVar3 = fcn.00425ce2(arg_8h);\n            *(in_ECX + 4) = uVar3;\n            fcn.0040e620(uVar3, 0, arg_8h);\n            *(in_ECX + 0xc) = arg_8h;\ncode_r0x00424e50:\n            *(in_ECX + 8) = arg_8h;\n            return;\n        }\n        iVar5 = *(in_ECX + 0xc);\n        if (arg_8h <= iVar5) {\n            iVar1 = *(in_ECX + 8);\n            if (iVar1 < arg_8h) {\n                fcn.0040e620(iVar1 + *(in_ECX + 4), 0, arg_8h - iVar1);\n            }\n            goto code_r0x00424e50;\n        }\n        iVar4 = *(in_ECX + 0x10);\n        if (iVar4 == 0) {\n            iVar4 = *(in_ECX + 8) / 8;\n            if (iVar4 < 4) {\ncode_r0x00424ea1:\n                iVar4 = 4;\n            }\n            else if (iVar4 < 0x401) {\n                if (iVar4 < 4) goto code_r0x00424ea1;\n            }\n            else {\n                iVar4 = 0x400;\n            }\n        }\n        iVar2 = iVar4 + iVar5;\n        if (iVar4 + iVar5 <= arg_8h) {\n            iVar2 = arg_8h;\n        }\n        arg_8h = iVar2;\n        if (arg_8h < iVar5) goto code_r0x00424eb5;\n    }\n    iVar5 = fcn.00425ce2(arg_8h);\n    fcn.0040e680(iVar5, *(in_ECX + 4), *(in_ECX + 8));\n    fcn.0040e620(*(in_ECX + 8) + iVar5, 0, iVar1 - *(in_ECX + 8));\n    fcn.00425d0d(*(in_ECX + 4));\n    *(in_ECX + 8) = iVar1;\n    *(in_ECX + 0xc) = arg_8h;\ncode_r0x00424ef6:\n    *(in_ECX + 4) = iVar5;\n    return;\n}\n",
        "token_count": 757
    },
    "00424fdc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424fdc(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t arg_ch_00;\n    int32_t in_ECX;\n    \n    if ((-1 < arg_8h) && (0 < arg_10h)) {\n        if (arg_8h < *(in_ECX + 8)) {\n            iVar1 = *(in_ECX + 8);\n            fcn.00424dfb(arg_10h + iVar1, 0xffffffff);\n            arg_ch_00 = *(in_ECX + 4) + arg_8h;\n            fcn.0040ea50(arg_ch_00 + arg_10h, arg_ch_00, iVar1 - arg_8h);\n            fcn.0040e620(*(in_ECX + 4) + arg_8h, 0, arg_10h);\n        }\n        else {\n            fcn.00424dfb(arg_10h + arg_8h, 0xffffffff);\n        }\n        do {\n            *(arg_8h + *(in_ECX + 4)) = arg_ch;\n            arg_8h = arg_8h + 1;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n        return;\n    }\n    fcn.0042032d();\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 339
    },
    "004251bb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004251bb(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    int32_t iVar5;\n    \n    iVar1 = arg_8h;\n    iVar5 = 0;\n    if (arg_8h < 0) {\ncode_r0x00425281:\n        iVar4 = fcn.0042032d();\n    }\n    else {\n        if (-1 < arg_ch) {\n            *(in_ECX + 0x10) = arg_ch;\n        }\n        if (arg_8h == 0) {\n            fcn.00425d0d(*(in_ECX + 4));\n            *(in_ECX + 0xc) = 0;\n            *(in_ECX + 8) = 0;\n            goto code_r0x004252cb;\n        }\n        if (*(in_ECX + 4) == 0) {\n            uVar3 = fcn.00425ce2(arg_8h << 2);\n            *(in_ECX + 4) = uVar3;\n            fcn.0040e620(uVar3, 0, arg_8h << 2);\n            *(in_ECX + 0xc) = arg_8h;\ncode_r0x00425216:\n            *(in_ECX + 8) = arg_8h;\n            return;\n        }\n        iVar5 = *(in_ECX + 0xc);\n        if (arg_8h <= iVar5) {\n            iVar1 = *(in_ECX + 8);\n            if (iVar1 < arg_8h) {\n                fcn.0040e620(*(in_ECX + 4) + iVar1 * 4, 0, (arg_8h - iVar1) * 4);\n            }\n            goto code_r0x00425216;\n        }\n        iVar4 = *(in_ECX + 0x10);\n        if (iVar4 == 0) {\n            iVar4 = *(in_ECX + 8) / 8;\n            if (iVar4 < 4) {\ncode_r0x0042526b:\n                iVar4 = 4;\n            }\n            else if (iVar4 < 0x401) {\n                if (iVar4 < 4) goto code_r0x0042526b;\n            }\n            else {\n                iVar4 = 0x400;\n            }\n        }\n        iVar2 = iVar4 + iVar5;\n        if (iVar4 + iVar5 <= arg_8h) {\n            iVar2 = arg_8h;\n        }\n        arg_8h = iVar2;\n        iVar4 = arg_8h;\n        if (arg_8h < iVar5) goto code_r0x00425281;\n    }\n    iVar5 = fcn.00425ce2(iVar4 << 2);\n    fcn.0040e680(iVar5, *(in_ECX + 4), *(in_ECX + 8) << 2);\n    fcn.0040e620(iVar5 + *(in_ECX + 8) * 4, 0, (iVar1 - *(in_ECX + 8)) * 4);\n    fcn.00425d0d(*(in_ECX + 4));\n    *(in_ECX + 8) = iVar1;\n    *(in_ECX + 0xc) = arg_8h;\ncode_r0x004252cb:\n    *(in_ECX + 4) = iVar5;\n    return;\n}\n",
        "token_count": 791
    },
    "004253c1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004253c1(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t in_ECX;\n    \n    if ((-1 < arg_8h) && (0 < arg_10h)) {\n        if (arg_8h < *(in_ECX + 8)) {\n            iVar1 = *(in_ECX + 8);\n            fcn.004251bb(arg_10h + iVar1, 0xffffffff);\n            fcn.0040ea50(*(in_ECX + 4) + (arg_8h + arg_10h) * 4, *(in_ECX + 4) + arg_8h * 4, (iVar1 - arg_8h) * 4);\n            fcn.0040e620(*(in_ECX + 4) + arg_8h * 4, 0, arg_10h << 2);\n        }\n        else {\n            fcn.004251bb(arg_10h + arg_8h, 0xffffffff);\n        }\n        arg_8h = arg_8h << 2;\n        do {\n            *(arg_8h + *(in_ECX + 4)) = arg_ch;\n            arg_8h = arg_8h + 4;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n        return;\n    }\n    fcn.0042032d();\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 360
    },
    "00425b35": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00425b35(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = arg_8h;\n    puVar2 = fcn.0042595e(arg_8h, &arg_8h, &var_4h);\n    if (puVar2 == NULL) {\n        if (*(in_ECX + 4) == 0) {\n            fcn.004258ce(*(in_ECX + 8), 1);\n        }\n        puVar2 = fcn.00425aea();\n        puVar2[1] = iVar1;\n        *puVar2 = *(arg_8h * 4 + *(in_ECX + 4));\n        *(arg_8h * 4 + *(in_ECX + 4)) = puVar2;\n    }\n    return puVar2 + 2;\n}\n",
        "token_count": 215
    },
    "00426cc4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpWndClass\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.00426cc4(uint arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint noname_1;\n    uint *noname_3;\n    uint lpWndClass;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.0044bde5();\n    iVar1 = iVar1 + 0x7c;\n    iVar2 = fcn.0044be10();\n    var_18h = *(iVar2 + 8);\n    if (((arg_ch == 0) && (arg_10h == 0)) && (arg_14h == 0)) {\n        fcn.0040f037(iVar1, \"Afx:%p:%x\", var_18h);\n    }\n    else {\n        fcn.0040f037(iVar1, \"Afx:%p:%x:%p:%p:%p\", var_18h);\n    }\n    noname_3 = &lpWndClass;\n    noname_1 = var_18h;\n    iVar2 = iVar1;\n    iVar3 = (*_sym.imp.USER32.dll_GetClassInfoA)();\n    if (iVar3 == 0) {\n        lpWndClass = arg_8h;\n        var_24h = _sym.imp.USER32.dll_DefWindowProcA;\n        var_1ch = 0;\n        var_20h = 0;\n        var_8h = 0;\n        var_14h = arg_14h;\n        var_10h = arg_ch;\n        var_ch = arg_10h;\n        var_4h = iVar1;\n        iVar2 = fcn.00425f19(&lpWndClass, noname_1, iVar2, noname_3, unaff_EDI, unaff_ESI, unaff_EBX, arg_8h, \n                             _sym.imp.USER32.dll_DefWindowProcA, 0, 0, var_18h, arg_14h, arg_ch, arg_10h, 0, iVar1, \n                             unaff_EBP);\n        if (iVar2 == 0) {\n            fcn.00431a1c();\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 759
    },
    "004271cd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004271cd(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_60h;\n    uint lprcSrc;\n    int32_t lpPoints;\n    int32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t lprcDst;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = fcn.0042a1c5();\n    if (arg_8h == 0) {\n        if ((var_4h & 0x40000000) == 0) {\n            iVar5 = (*_sym.imp.USER32.dll_GetWindow)(*(in_ECX + 0x1c), 4);\n        }\n        else {\n            iVar5 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x1c));\n        }\n        if ((iVar5 != 0) && (iVar4 = (*_sym.imp.USER32.dll_SendMessageA)(iVar5, 0x36b, 0, 0),  iVar4 != 0)) {\n            iVar5 = iVar4;\n        }\n    }\n    else {\n        iVar5 = *(arg_8h + 0x1c);\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetWindowRect;\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x1c), &var_28h);\n    if ((var_4h & 0x40000000) == 0) {\n        if ((iVar5 != 0) &&\n           ((uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar5, 0xfffffff0),  (uVar2 & 0x10000000) == 0 ||\n            ((uVar2 & 0x20000000) != 0)))) {\n            iVar5 = 0;\n        }\n        if (iVar5 == 0) {\n            iVar5 = fcn.004049c2();\n            if (iVar5 != 0) {\n                iVar5 = *(iVar5 + 0x1c);\n            }\n            uVar3 = fcn.00404f6c(iVar5, 1);\n            fcn.00404fd7(uVar3, iVar5);\n            pcVar1 = _sym.imp.USER32.dll_CopyRect;\n            (*_sym.imp.USER32.dll_CopyRect)(&lpPoints, &lprcSrc);\n            (*pcVar1)(&lprcDst, &lprcSrc);\n        }\n        else {\n            (*pcVar1)(iVar5, &lpPoints);\n            uVar3 = fcn.00404f6c(iVar5, 2);\n            fcn.00404fd7(uVar3, iVar5);\n            (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, &lprcSrc);\n        }\n    }\n    else {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x1c));\n        pcVar1 = _sym.imp.USER32.dll_GetClientRect;\n        (*_sym.imp.USER32.dll_GetClientRect)(uVar3, &lprcDst);\n        (*pcVar1)(iVar5, &lpPoints);\n        (*_sym.imp.USER32.dll_MapWindowPoints)(iVar5, uVar3, &lpPoints, 2);\n    }\n    iVar5 = (lpPoints + var_30h) / 2 - (var_20h - var_28h) / 2;\n    iVar4 = (var_34h + var_2ch) / 2 - (var_1ch - var_24h) / 2;\n    if ((lprcDst <= iVar5) && (lprcDst = iVar5,  var_10h < (var_20h - var_28h) + iVar5)) {\n        lprcDst = (var_10h - var_20h) + var_28h;\n    }\n    if ((var_14h <= iVar4) && (var_14h = iVar4,  var_ch < (var_1ch - var_24h) + iVar4)) {\n        var_14h = (var_24h - var_1ch) + var_ch;\n    }\n    fcn.0042a4e3(0, lprcDst, var_14h, 0xffffffff, 0xffffffff, 0x15);\n    return;\n}\n",
        "token_count": 1089
    },
    "00427905": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00427905(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint32_t unaff_retaddr;\n    \n    iVar1 = fcn.00427862(0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if (*(iVar1 + 0x20) != 0) {\n        for (puVar2 = *(*(iVar1 + 0x20) + ((unaff_retaddr >> 4) % *(iVar1 + 0x24)) * 4); puVar2 != NULL;\n            puVar2 = *puVar2) {\n            if (puVar2[1] == unaff_retaddr) {\n                return puVar2[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 175
    },
    "0042aa3f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042aa3f(int32_t param_1)\n\n{\n    if (*(param_1 + 0x10) != 0) {\n    // WARNING: Could not recover jumptable at 0x0042aa48. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(*(param_1 + 0x10) + 0x1c))();\n        return;\n    }\n    return;\n}\n",
        "token_count": 100
    },
    "0042aa4c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl\nfcn.0042aa4c(uint arg_8h, uint *arg_ch, uint noname_2, code *arg_14h, uint *arg_18h, int32_t arg_1ch, uint *arg_20h)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 1;\n    if (arg_20h != NULL) {\n        *arg_20h = arg_8h;\n        arg_20h[1] = arg_14h;\n        return 1;\n    }\n    if (0xb < arg_1ch - 0x35U) {\n        return 0;\n    }\n    // switch table (12 cases) at 0x42ab32\n    switch(*((arg_1ch - 0x35U) * 4 + 0x42ab32)) {\n    case 0x42aa83:\n        (*arg_14h)();\n        break;\n    case 0x42aa8e:\n        uVar1 = (*arg_14h)();\n        break;\n    case 0x42aa99:\n        arg_18h = arg_ch;\n        goto code_r0x0042ab13;\n    case 0x42aa9e:\n        arg_18h = arg_ch;\n        goto code_r0x0042ab1e;\n    case 0x42aaa3:\n        (*arg_14h)(arg_18h[1], *arg_18h);\n        break;\n    case 0x42aab3:\n        uVar1 = (*arg_14h)(arg_18h[1], *arg_18h);\n        break;\n    case 0x42aac3:\n        (*arg_14h)(arg_ch, arg_18h[1], *arg_18h);\n        break;\n    case 0x42aad6:\n        uVar1 = (*arg_14h)(arg_ch, arg_18h[1], *arg_18h);\n        break;\n    case 0x42aae9:\n        (*arg_14h)(arg_18h);\n        goto code_r0x0042ab02;\n    case 0x42aaf5:\n        (*arg_14h)(arg_18h, arg_ch);\ncode_r0x0042ab02:\n        uVar1 = arg_18h[7] == 0;\n        arg_18h[7] = 0;\n        break;\n    case 0x42ab10:\ncode_r0x0042ab13:\n        (*arg_14h)(arg_18h);\n        break;\n    case 0x42ab1b:\ncode_r0x0042ab1e:\n        uVar1 = (*arg_14h)(arg_18h);\n    }\n    return uVar1;\n}\n",
        "token_count": 611
    },
    "0042af8a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.0042af8a(code **param_1)\n\n{\n    fcn.00426a75();\n    *param_1 = vtable.CDialog.0;\n    fcn.0040e620(param_1 + 0x14, 0, 0x20);\n    return param_1;\n}\n",
        "token_count": 74
    },
    "0042b093": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.0042b093(code **param_1, code *param_2, code *param_3)\n\n{\n    fcn.00426a75();\n    *param_1 = vtable.CDialog.0;\n    fcn.0040e620(param_1 + 0x14, 0, 0x20);\n    param_1[0x19] = param_3;\n    param_1[0x14] = param_2;\n    param_1[0x15] = param_2 & 0xffff;\n    return param_1;\n}\n",
        "token_count": 132
    },
    "0042b551": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_48h\n\nbool __cdecl\nfcn.0042b551(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    char cVar5;\n    bool bVar6;\n    uint var_8h;\n    uint var_ch_2;\n    uint hInstance;\n    uint var_10h;\n    uint var_48h;\n    uint var_38h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint hMem;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = &stack0xffffffb8;\n    *(unaff_EBP + -0x20) = extraout_ECX;\n    if (*(unaff_EBP + 0x10) == 0) {\n        iVar1 = fcn.0044be10();\n        *(unaff_EBP + 0x10) = *(iVar1 + 0xc);\n    }\n    iVar1 = fcn.0044be10();\n    piVar2 = *(iVar1 + 0x1038);\n    *(unaff_EBP + -0x28) = piVar2;\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -0x24) = 0;\n    *(unaff_EBP + -4) = 0;\n    fcn.00427537(0x10);\n    fcn.00427537(0x7c000);\n    if (piVar2 == NULL) {\n        iVar1 = *(unaff_EBP + 8);\ncode_r0x0042b5d5:\n        if (iVar1 != 0) {\n            piVar2 = fcn.0042c770();\n            iVar3 = (**(*piVar2 + 0xc))();\n            *(unaff_EBP + -0x1c) = iVar3 + 0x10;\n            *(unaff_EBP + -4) = 1;\n            *(unaff_EBP + -0x18) = 0;\n            iVar3 = fcn.0042e11a(iVar1, unaff_EBP + -0x1c, unaff_EBP + -0x18);\n            cVar5 = iVar3 == 0;\n            if (*0x49960c == 0) {\ncode_r0x0042b64a:\n                if (cVar5 != '\\0') {\ncode_r0x0042b64e:\n                    fcn.0042e046(iVar1);\n                    *(unaff_EBP + -4) = 2;\n                    fcn.0042df6c(*(unaff_EBP + -0x18));\n                    uVar4 = fcn.0042dcef();\n                    *(unaff_EBP + -0x14) = uVar4;\n                    *(unaff_EBP + -4) = 1;\n                    fcn.0042dce1();\n                    if (*(unaff_EBP + -0x14) != 0) {\n                        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(unaff_EBP + -0x14));\n                    }\n                }\n            }\n            else {\n                if (cVar5) goto code_r0x0042b64e;\n                iVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x2a);\n                if (iVar3 != 0) {\n                    iVar3 = fcn.0040efa3(*(unaff_EBP + -0x1c), \"MS Shell Dlg\");\n                    cVar5 = '\\x01' - (iVar3 != 0);\n                    if (cVar5 != '\\0') {\n                        if (*(unaff_EBP + -0x18) == 8) {\n                            *(unaff_EBP + -0x18) = 0;\n                        }\n                        goto code_r0x0042b64a;\n                    }\n                }\n            }\n            extraout_ECX[0x10] = -1;\n            extraout_ECX[0xe] = extraout_ECX[0xe] | 0x10;\n            fcn.004293a0(extraout_ECX);\n            if (*(unaff_EBP + 0xc) == 0) {\n                uVar4 = 0;\n            }\n            else {\n                uVar4 = *(*(unaff_EBP + 0xc) + 0x1c);\n            }\n            iVar1 = (*_sym.imp.USER32.dll_CreateDialogIndirectParamA)\n                              (*(unaff_EBP + 0x10), iVar1, uVar4, fcn.0042af4a, 0);\n            fcn.00403164();\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*(unaff_EBP + -0x28) != NULL) {\n                (**(**(unaff_EBP + -0x28) + 0x14))(unaff_EBP + -0x48);\n                if (iVar1 != 0) {\n                    (**(*extraout_ECX + 300))(0);\n                }\n            }\n            iVar3 = fcn.00427986();\n            if (iVar3 == 0) {\n                (**(*extraout_ECX + 0x114))();\n            }\n            if ((iVar1 != 0) && ((*(extraout_ECX + 0xe) & 0x10) == 0)) {\n                (*_sym.imp.USER32.dll_DestroyWindow)(iVar1);\n                iVar1 = 0;\n            }\n            if (*(unaff_EBP + -0x14) != 0) {\n                (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*(unaff_EBP + -0x14));\n                (*_sym.imp.KERNEL32.dll_GlobalFree)(*(unaff_EBP + -0x14));\n            }\n            bVar6 = iVar1 != 0;\n            goto code_r0x0042b74d;\n        }\n    }\n    else {\n        iVar1 = (**(*extraout_ECX + 300))(unaff_EBP + -0x48);\n        if (iVar1 != 0) {\n            iVar1 = (**(*piVar2 + 0x10))(unaff_EBP + -0x48, *(unaff_EBP + 8));\n            goto code_r0x0042b5d5;\n        }\n    }\n    bVar6 = false;\ncode_r0x0042b74d:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return bVar6;\n}\n",
        "token_count": 1629
    },
    "0042bddf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0042bddf(int32_t *param_1, int32_t param_2)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint arg_14h;\n    \n    puVar1 = (**(*param_1 + 0x28))();\n    do {\n        if (puVar1 == NULL) {\n            return 0;\n        }\n        arg_14h = 0;\n        if (*(param_2 + 4) < 0xc000) {\n            iVar2 = fcn.00426051(puVar1[1], *(param_2 + 4), 0, 0);\n            if (iVar2 != 0) {\ncode_r0x0042be14:\n                (**(iVar2 + 0x14))(*(param_2 + 8), *(param_2 + 0xc));\n                return 1;\n            }\n        }\n        else {\n            iVar2 = puVar1[1];\n            while (iVar2 = fcn.00426051(iVar2, 0xc000, 0, arg_14h),  iVar2 != 0) {\n                if (**(iVar2 + 0x10) == *(param_2 + 4)) goto code_r0x0042be14;\n                iVar2 = iVar2 + 0x18;\n            }\n        }\n        puVar1 = *puVar1;\n    } while( true );\n}\n",
        "token_count": 314
    },
    "0042c25e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __thiscall fcn.0042c25e(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBX;\n    int32_t arg_8h;\n    \n    if (param_2 < 1) {\n        iVar3 = *(param_1 + 0x1c);\n        if (((iVar3 != 0) && (*(iVar3 + 0x1c) != 0)) &&\n           (iVar1 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar3 + 0x1c)),  iVar1 != 0)) {\n            fcn.00428100(iVar3, *(iVar3 + 0x1c), 0x363, 1, 0);\n            fcn.00428408(*(iVar3 + 0x1c), 0x363, 1, 0, 1, 1);\n        }\n        fcn.0044be10();\n        arg_8h = 0x44926b;\n        iVar1 = fcn.0044c776(0x44926b);\n        for (iVar1 = *(iVar1 + 8); iVar1 != 0; iVar1 = *(iVar1 + 0x68)) {\n            if ((*(iVar1 + 0x1c) != 0) && (iVar1 != iVar3)) {\n                if (*(iVar1 + 0x9c) == 0) {\n                    fcn.0042a2ea(0, arg_8h);\n                }\n                iVar2 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar1 + 0x1c));\n                if ((iVar2 != 0) || (-1 < *(iVar1 + 0x9c))) {\n                    fcn.00428100(iVar1, *(iVar1 + 0x1c), 0x363, 1, 0);\n                    arg_8h = *(iVar1 + 0x1c);\n                    fcn.00428408(arg_8h, 0x363, 1, 0, 1, 1);\n                }\n                iVar2 = *(iVar1 + 0x9c);\n                if (0 < iVar2) {\n                    fcn.0042a2ea();\n                    arg_8h = iVar2;\n                }\n                *(iVar1 + 0x9c) = 0xffffffff;\n            }\n        }\n    }\n    else {\n        fcn.0044be10();\n        iVar3 = fcn.0044c776(0x44926b);\n        if (*(iVar3 + 0x10) == 0) {\n            fcn.0042d84a();\n            fcn.0042da42(1);\n        }\n    }\n    return unaff_EBX < 0;\n}\n",
        "token_count": 631
    },
    "0042c495": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042c495(uint32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    int32_t hHandle;\n    int32_t hEvent;\n    int32_t var_4h;\n    \n    fcn.0040e620(&var_1ch, 0, 0x1c);\n    var_1ch = fcn.0044bde5();\n    pcVar1 = _sym.imp.KERNEL32.dll_CreateEventA;\n    hHandle = (*_sym.imp.KERNEL32.dll_CreateEventA)(0, 1, 0, 0);\n    hEvent = (*pcVar1)(0, 1, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n    var_14h = arg_8h;\n    if (hHandle != 0) {\n        if (hEvent != 0) {\n            iVar2 = fcn.0040f65c(arg_10h, arg_ch, 0x42c367, &var_1ch, arg_8h | 4, in_ECX + 0x2c);\n            *(in_ECX + 0x28) = iVar2;\n            if (iVar2 == 0) {\n                return 0;\n            }\n            (*_sym.imp.KERNEL32.dll_ResumeThread)(iVar2);\n            (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(hHandle, 0xffffffff);\n            (*pcVar1)(hHandle);\n            if ((arg_8h & 4) != 0) {\n                (*_sym.imp.KERNEL32.dll_SuspendThread)(*(in_ECX + 0x28));\n            }\n            if (var_4h == 0) {\n                (*_sym.imp.KERNEL32.dll_SetEvent)(hEvent);\n                return 1;\n            }\n            (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*(in_ECX + 0x28), 0xffffffff);\n            (*pcVar1)(*(in_ECX + 0x28));\n            *(in_ECX + 0x28) = 0;\n            goto code_r0x0042c56a;\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(hHandle);\n    }\n    if (hEvent == 0) {\n        return 0;\n    }\ncode_r0x0042c56a:\n    (*pcVar1)(hEvent);\n    return 0;\n}\n",
        "token_count": 584
    },
    "0042c80b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0042c80b(uint param_1, uint param_2, int32_t param_3)\n\n{\n    fcn.0040e680(param_1, param_2, param_3 * 2);\n    return;\n}\n",
        "token_count": 55
    },
    "0042c823": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0042c823(uint param_1, uint param_2, int32_t param_3)\n\n{\n    fcn.0040ea50(param_1, param_2, param_3 * 2);\n    return;\n}\n",
        "token_count": 54
    },
    "0042c9c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042c9c0(uint32_t *param_1)\n\n{\n    uint32_t uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint64_t uVar4;\n    \n    uVar1 = *param_1;\n    uVar4 = uVar1;\n    piVar2 = *(uVar1 - 0x10);\n    if (*(uVar1 - 0xc) != 0) {\n        if (*(uVar1 - 4) < 0) {\n            if (*(uVar1 - 8) < 0) {\n                uVar4 = fcn.00401182(0x80070057);\n            }\n            *(uVar4 + -0xc) = uVar4 >> 0x20;\n            **param_1 = uVar4 >> 0x20;\n        }\n        else {\n            fcn.00403164();\n            iVar3 = (**(*piVar2 + 0xc))();\n            *param_1 = iVar3 + 0x10;\n        }\n    }\n    return;\n}\n",
        "token_count": 240
    },
    "0042ca09": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042ca09(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = *in_ECX;\n    iVar2 = *(iVar1 + -0xc);\n    puVar3 = (**(**(iVar1 + -0x10) + 0x10))();\n    iVar4 = (***puVar3)(arg_8h, 2);\n    if (iVar4 == 0) {\n        fcn.0042c90c();\n    }\n    if (iVar2 < arg_8h) {\n        arg_8h = iVar2;\n    }\n    fcn.0042c80b(iVar4 + 0x10, iVar1, arg_8h + 1);\n    *(iVar4 + 4) = iVar2;\n    fcn.00403164();\n    *in_ECX = iVar4 + 0x10;\n    return;\n}\n",
        "token_count": 246
    },
    "0042ca70": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042ca70(int32_t *param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (**(**(*param_1 + -0x10) + 8))(*param_1 + -0x10, param_2, 2);\n    if (iVar1 == 0) {\n        iVar1 = fcn.0042c90c();\n    }\n    *param_1 = iVar1 + 0x10;\n    return;\n}\n",
        "token_count": 114
    },
    "0042cf90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0042cf90(uint param_1, uchar *param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    ushort *puVar2;\n    \n    if (param_2 != NULL) {\n        iVar1 = fcn.0044be10();\n        puVar2 = fcn.0040408d(*(iVar1 + 0xc), param_1);\n        if (puVar2 != NULL) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, puVar2 + 1, *puVar2, param_2, param_3 + -1, 0, 0)\n            ;\n            param_2[iVar1] = 0;\n            return iVar1;\n        }\n        *param_2 = 0;\n    }\n    return 0;\n}\n",
        "token_count": 191
    },
    "0042d14e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0042d14e(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint32_t unaff_retaddr;\n    \n    iVar1 = fcn.0042d0c4(0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if (*(iVar1 + 0x20) != 0) {\n        for (puVar2 = *(*(iVar1 + 0x20) + ((unaff_retaddr >> 4) % *(iVar1 + 0x24)) * 4); puVar2 != NULL;\n            puVar2 = *puVar2) {\n            if (puVar2[1] == unaff_retaddr) {\n                return puVar2[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 180
    },
    "0042dc8d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0042dc8d(int32_t *param_1, uint param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    uint arg_8h;\n    \n    param_1[1] = param_3;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40);\n    *param_1 = iVar1;\n    if (iVar1 != 0) {\n        arg_8h = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1);\n        fcn.0040e680(arg_8h, param_3 + 0x40, param_1[1]);\n        iVar1 = fcn.0042dc66(arg_8h);\n        param_1[2] = iVar1 == 0;\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*param_1);\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 210
    },
    "0042dd26": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0042dd26(int32_t param_1)\n\n{\n    int16_t iVar1;\n    int16_t *piVar2;\n    \n    if (*(param_1 + 2) == -1) {\n        piVar2 = param_1 + 0x1a;\n    }\n    else {\n        piVar2 = param_1 + 0x12;\n    }\n    if (*piVar2 == -1) {\n        piVar2 = piVar2 + 2;\n    }\n    else {\n        do {\n            iVar1 = *piVar2;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 != 0);\n    }\n    if (*piVar2 == -1) {\n        piVar2 = piVar2 + 2;\n    }\n    else {\n        do {\n            iVar1 = *piVar2;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 != 0);\n    }\n    do {\n        iVar1 = *piVar2;\n        piVar2 = piVar2 + 1;\n    } while (iVar1 != 0);\n    return;\n}\n",
        "token_count": 251
    },
    "0042e580": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042e580(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t arg_ch_00;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = 0;\n    piVar1 = *(unaff_EBP + 0xc);\n    piVar3 = (**(**(*piVar1 + -0x10) + 0x10))();\n    iVar4 = (**(*piVar3 + 0xc))();\n    *(unaff_EBP + 0xc) = iVar4 + 0x10;\n    iVar4 = **(unaff_EBP + 0x10);\n    uVar2 = *(iVar4 + -0xc);\n    arg_ch_00 = *piVar1;\n    *(unaff_EBP + -4) = 0;\n    fcn.0043bd8d(unaff_EBP + 0xc, arg_ch_00, *(arg_ch_00 + -0xc), iVar4, uVar2);\n    fcn.004039b4(unaff_EBP + 0xc);\n    fcn.00403164();\n    uVar2 = *(unaff_EBP + 8);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 405
    },
    "0042e6c8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** __cdecl fcn.0042e6c8(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    code *arg_10h_00;\n    uint uVar1;\n    code **ppcVar2;\n    code *pcVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CRecentFileList.0;\n    fcn.00403c40();\n    *(unaff_EBP + -4) = 0;\n    fcn.00403c40();\n    fcn.00403c40();\n    arg_10h_00 = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -4) = 2;\n    ppcVar2 = fcn.00425ce2(arg_10h_00 * 4 + 4);\n    if (ppcVar2 == NULL) {\n        pcVar3 = NULL;\n    }\n    else {\n        *ppcVar2 = arg_10h_00;\n        *(unaff_EBP + 0x14) = ppcVar2 + 1;\n        fcn.004103e5(ppcVar2 + 1, 4, arg_10h_00, fcn.00403c40);\n        pcVar3 = *(unaff_EBP + 0x14);\n    }\n    uVar1 = *(unaff_EBP + 0xc);\n    extraout_ECX[2] = pcVar3;\n    pcVar3 = *(unaff_EBP + 8);\n    extraout_ECX[1] = arg_10h_00;\n    extraout_ECX[5] = pcVar3;\n    fcn.004045a1(uVar1);\n    fcn.004045a1(*(unaff_EBP + 0x10));\n    uVar1 = *(unaff_EBP + -0xc);\n    extraout_ECX[6] = *(unaff_EBP + 0x18);\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 572
    },
    "0042f0b8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0042f0b8(void)\n\n{\n    uint uVar1;\n    uint unaff_retaddr;\n    \n    uVar1 = fcn.004043ec(0x104);\n    fcn.0040e620(uVar1, 0, 0x104);\n    (*_sym.imp.KERNEL32.dll_lstrcpynA)(uVar1, unaff_retaddr, 0x104);\n    (*_sym.imp.SHLWAPI.dll_PathStripToRootA)(uVar1);\n    fcn.00404cad(0xffffffff);\n    return;\n}\n",
        "token_count": 128
    },
    "0042f4b8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_108h\n\nvoid __cdecl fcn.0042f4b8(uint arg_8h, uint *arg_ch)\n\n{\n    uint var_108h;\n    uint var_104h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    (*_sym.imp.USER32.dll_wsprintfA)\n              (&var_104h, \"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\", *arg_ch, *(arg_ch + 1), *(arg_ch + 6), \n               *(arg_ch + 2), *(arg_ch + 9), *(arg_ch + 10), *(arg_ch + 0xb), *(arg_ch + 3), *(arg_ch + 0xd), \n               *(arg_ch + 0xe), *(arg_ch + 0xf), 0);\n    fcn.004045fc(&var_104h);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 241
    },
    "0042f53a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042f53a(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t unaff_EBP;\n    uint uVar5;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    puVar1 = *(unaff_EBP + 0x10);\n    *puVar1 = 0;\n    fcn.0042f4b8(unaff_EBP + -0x10, *(unaff_EBP + 8));\n    *(unaff_EBP + -4) = 0;\n    piVar2 = fcn.0042c770();\n    iVar3 = (**(*piVar2 + 0xc))();\n    *(unaff_EBP + 0x10) = iVar3 + 0x10;\n    *(unaff_EBP + -4) = 1;\n    iVar3 = fcn.0042f008(*(unaff_EBP + -0x10), unaff_EBP + 0x10);\n    if (iVar3 != 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(*(unaff_EBP + 0x10));\n        if (iVar3 != 0) {\n            pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar3, \"DllGetClassObject\");\n            if (pcVar4 == NULL) {\n                uVar5 = 0x800401f9;\n            }\n            else {\n                uVar5 = (*pcVar4)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), puVar1);\n            }\n            goto code_r0x0042f5ba;\n        }\n    }\n    uVar5 = 0x80040154;\ncode_r0x0042f5ba:\n    fcn.00403164();\n    fcn.00403164();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar5;\n}\n",
        "token_count": 531
    },
    "0042fe36": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0042fe36(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if (0x10b < param_1) {\n        if (param_1 == 0x3e3) {\n            return 10;\n        }\n        if (param_1 == 0x3e4) {\n            return 10;\n        }\n        if (param_1 == 0x3e5) {\n            return 10;\n        }\n        if (param_1 == 999) {\n            return 5;\n        }\n        return 1;\n    }\n    if (param_1 == 0x10b) {\n        return 3;\n    }\n    if (param_1 < 0x3f) {\n        if (param_1 == 0x3e) {\n            return 8;\n        }\n        if (param_1 < 0x1a) {\n    // switch table (25 cases) at 0x430014\n            switch(param_1) {\n            case 0:\n                return 0;\n            case 1:\n            case 7:\n            case 8:\n            case 9:\n            case 10:\n            case 0xd:\n            case 0xe:\n                goto code_r0x0042ff31;\n            case 2:\n            case 6:\n            case 0x12:\n                goto code_r0x0042ff31;\n            case 3:\n            case 0xf:\n            case 0x11:\n                goto code_r0x0042ff31;\n            case 4:\n                return 4;\n            case 5:\n            case 0xc:\n            case 0x13:\ncode_r0x0042ff31:\n                return 5;\n            case 0xb:\ncode_r0x0042ff31:\n                return 6;\n            case 0x10:\n                return 7;\n            case 0x14:\n            case 0x15:\n            case 0x16:\n            case 0x17:\ncode_r0x0042ff31:\n                return 10;\n            default:\n                goto code_r0x0042ff31;\n            }\n        }\n        if (0x27 < param_1) {\n    // switch table (9 cases) at 0x430078\n            switch(param_1) {\n            case 0x34:\n            case 0x35:\n            case 0x37:\n                goto code_r0x0042ff31;\n            case 0x36:\n            case 0x3a:\n                goto code_r0x0042ff31;\n            default:\n                return 1;\n            case 0x39:\n            case 0x3b:\n                goto code_r0x0042ff31;\n            case 0x3c:\n                goto code_r0x0042ff31;\n            }\n        }\n        if (param_1 == 0x27) {\n            return 0xd;\n        }\n        if (0x20 < param_1) {\n            if (param_1 == 0x21) {\n                return 0xc;\n            }\n            if (param_1 == 0x22) {\n                return 3;\n            }\n            if (param_1 == 0x24) {\n                return 4;\n            }\n            if (param_1 == 0x26) {\n                return 0xe;\n            }\n            return 1;\n        }\n        if (param_1 == 0x20) {\n            return 0xb;\n        }\n        if (param_1 == 0x1a) {\n            return 6;\n        }\n        if (param_1 == 0x1b) {\n            return 9;\n        }\n        iVar1 = param_1 - 0x1d;\n        if (iVar1 == 0) {\n            return 5;\n        }\ncode_r0x0042ff7d:\n        if (iVar1 == 1) {\ncode_r0x0042ff31:\n            return 9;\n        }\n    }\n    else {\n        if (param_1 < 0x6c) {\n            if (param_1 == 0x6b) {\ncode_r0x0042ff31:\n                return 2;\n            }\n            if (0x47 < param_1) {\n                if (param_1 == 0x50) {\n                    return 5;\n                }\n                if (param_1 == 0x52) {\n                    return 5;\n                }\n                if (param_1 == 0x55) {\n                    return 3;\n                }\n                if (param_1 != 0x56) {\n                    if (param_1 == 0x58) {\n                        return 10;\n                    }\n                    return 1;\n                }\n                return 5;\n            }\n            if (param_1 == 0x47) {\n                return 5;\n            }\n            if (param_1 == 0x40) {\n                return 5;\n            }\n            if (param_1 == 0x41) {\n                return 5;\n            }\n            if (param_1 == 0x42) {\n                return 6;\n            }\n            if (param_1 == 0x43) {\n                return 3;\n            }\n            iVar1 = param_1 - 0x44;\n            if (iVar1 == 0) {\n                return 4;\n            }\n        }\n        else {\n            if (param_1 < 0x91) {\n                if (param_1 == 0x90) {\n                    return 3;\n                }\n                if (param_1 < 0x76) {\n                    if (param_1 == 0x75) {\n                        return 10;\n                    }\n                    if (param_1 == 0x6c) {\n                        return 0xc;\n                    }\n                    if (param_1 == 0x6f) {\n                        return 3;\n                    }\n                    if (param_1 == 0x70) {\n                        return 0xd;\n                    }\n                    if (param_1 == 0x71) {\n                        return 4;\n                    }\n                    if (param_1 != 0x72) {\n                        return 1;\n                    }\n                    return 6;\n                }\n                if (param_1 == 0x7b) {\n                    return 3;\n                }\n                if (param_1 == 0x7c) {\n                    return 3;\n                }\n                if (param_1 == 0x7d) {\n                    return 3;\n                }\n                iVar1 = param_1 - 0x83;\n                if (iVar1 == 0) {\n                    return 9;\n                }\n                goto code_r0x0042ff7d;\n            }\n            if (param_1 < 0xb7) {\n                if (param_1 == 0xb6) {\n                    return 6;\n                }\n                if (param_1 == 0x91) {\n                    return 7;\n                }\n                if (param_1 == 0x9a) {\n                    return 3;\n                }\n                if (param_1 != 0xa1) {\n                    if (param_1 == 0xa7) {\n                        return 0xc;\n                    }\n                    if (param_1 == 0xaa) {\n                        return 5;\n                    }\n                    return 1;\n                }\n                return 3;\n            }\n            if (param_1 == 0xb7) {\n                return 5;\n            }\n            if (param_1 == 0xbf) {\n                return 6;\n            }\n            if (param_1 == 0xc1) {\n                return 6;\n            }\n            iVar1 = param_1 - 0xce;\n            if (iVar1 == 0) {\n                return 3;\n            }\n        }\n        if (iVar1 == 2) {\ncode_r0x0042ff31:\n            return 3;\n        }\n    }\ncode_r0x0042ff31:\n    return 1;\n}\n",
        "token_count": 1732
    },
    "00431a64": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00431a64(uint arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_14h;\n    uint var_10h;\n    \n    fcn.0040e620(&var_14h, 0, 0x14);\n    var_10h = arg_8h;\n    var_14h = 0x14;\n    (*_sym.imp.GDI32.dll_StartDocA)(*(in_ECX + 4), &var_14h);\n    return;\n}\n",
        "token_count": 116
    },
    "00434fb1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: hRgn\n\nint32_t __cdecl fcn.00434fb1(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint hRgn;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    piVar1 = extraout_ECX + 0x18;\n    (*_sym.imp.USER32.dll_ClientToScreen)(*(*(unaff_EBP + 8) + 0x1c), piVar1);\n    pcVar2 = _sym.imp.USER32.dll_GetSystemMetrics;\n    iVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x25);\n    extraout_ECX[0x15] = extraout_ECX[0x19] - iVar3;\n    iVar3 = (*pcVar2)(0x25);\n    extraout_ECX[0x17] = iVar3 + extraout_ECX[0x19];\n    iVar4 = (*pcVar2)(0x24);\n    iVar3 = *piVar1;\n    extraout_ECX[0x14] = *piVar1 - iVar4;\n    iVar4 = (*pcVar2)(0x24);\n    extraout_ECX[0x16] = iVar4 + iVar3;\n    *(unaff_EBP + -0x10) = *extraout_ECX;\n    uVar5 = fcn.00426cc4(0x800, 0, 0, 0);\n    iVar3 = (**(*(unaff_EBP + -0x10) + 0x5c))(0x88, uVar5);\n    fcn.0040480a(*(unaff_EBP + 8));\n    if (iVar3 != 0) {\n        *(unaff_EBP + -0x14) = 0;\n        *(unaff_EBP + -0x18) = vtable.CRgn.0;\n        *(unaff_EBP + -4) = 0;\n        uVar5 = (*_sym.imp.GDI32.dll_CreateEllipticRgn)(0, 0, 0x20, 0x20);\n        fcn.0043242b(uVar5);\n        (*_sym.imp.USER32.dll_SetWindowRgn)(extraout_ECX[7], *(unaff_EBP + -0x14), 1);\n        uVar5 = (*_sym.imp.USER32.dll_SetCapture)(extraout_ECX[7]);\n        fcn.004278de(uVar5);\n        (*_sym.imp.USER32.dll_SetTimer)(extraout_ECX[7], 0xe000, 0x32, 0);\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(unaff_EBP + -0x18) = vtable.CGdiObject.0;\n        fcn.00432482();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar3;\n}\n",
        "token_count": 761
    },
    "00435127": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.00435127(code **param_1)\n\n{\n    fcn.00436046();\n    *param_1 = vtable.CScrollView.0;\n    fcn.0040e620(param_1 + 0x15, 0, 0x30);\n    param_1[0x15] = NULL;\n    param_1[0x16] = NULL;\n    return param_1;\n}\n",
        "token_count": 95
    },
    "004352d7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004352d7(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowRect)(in_ECX[7], &var_10h);\n    var_30h = var_10h;\n    var_2ch = var_ch;\n    var_28h = var_8h;\n    var_24h = var_4h;\n    (**(*in_ECX + 0x68))(&var_30h, 0);\n    pcVar1 = _sym.imp.USER32.dll_OffsetRect;\n    var_8h = var_8h * 2 - var_28h;\n    var_ch = var_ch * 2 - var_2ch;\n    var_10h = var_10h * 2 - var_30h;\n    var_4h = var_4h * 2 - var_24h;\n    (*_sym.imp.USER32.dll_OffsetRect)(&var_10h, -var_10h, -var_ch);\n    var_18h = in_ECX[0x19];\n    var_14h = in_ECX[0x1a];\n    var_20h = 0;\n    var_1ch = 0;\n    if (arg_8h != 0) {\n        if (var_8h <= var_18h) {\n            var_18h = var_8h;\n        }\n        if (var_4h <= var_14h) {\n            var_14h = var_4h;\n        }\n    }\n    (**(*in_ECX + 0x68))(&var_20h, 1);\n    (*pcVar1)(&var_20h, -var_20h, -var_1ch);\n    if (arg_8h != 0) {\n        if (var_8h <= in_ECX[0x19]) {\n            var_18h = var_8h;\n        }\n        if (var_4h <= in_ECX[0x1a]) {\n            var_14h = var_4h;\n        }\n    }\n    iVar2 = fcn.00428388();\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(iVar2 + 0x1c), &var_40h);\n    fcn.0042a4e3(0, 0, 0, (var_38h - var_40h) + (var_18h - var_8h), (var_34h - var_3ch) + (var_14h - var_4h), 0x16);\n    return;\n}\n",
        "token_count": 734
    },
    "004355ba": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004355ba(int32_t *arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    uint lpRect;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lpRect);\n    *arg_8h = var_8h;\n    arg_8h[1] = var_4h;\n    uVar1 = fcn.0042a1c5();\n    fcn.00434c50(arg_ch);\n    if ((*arg_ch != 0) && ((uVar1 & 0x200000) != 0)) {\n        *arg_8h = *arg_8h + *arg_ch;\n    }\n    if ((arg_ch[1] != 0) && ((uVar1 & 0x100000) != 0)) {\n        arg_8h[1] = arg_8h[1] + arg_ch[1];\n    }\n    if ((*arg_ch < *arg_8h) && (arg_ch[1] < arg_8h[1])) {\n        uVar2 = 1;\n    }\n    else {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 307
    },
    "0043562f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0043562f(int32_t arg_8h, int32_t arg_ch, uint32_t *arg_10h, int32_t *arg_14h, int32_t *arg_18h, int32_t arg_1ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t in_ECX;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = in_ECX;\n    var_4h = in_ECX;\n    fcn.00434c50(&var_8h);\n    piVar2 = arg_14h;\n    iVar1 = *(in_ECX + 0x68);\n    *arg_14h = *(in_ECX + 100) - arg_8h;\n    arg_14h[1] = iVar1 - arg_ch;\n    piVar3 = fcn.0043520f(&arg_8h);\n    *arg_18h = *piVar3;\n    arg_18h[1] = piVar3[1];\n    uVar5 = 0 < *piVar2;\n    if (uVar5 == 0) {\n        *arg_18h = 0;\n    }\n    else if (arg_1ch != 0) {\n        piVar2[1] = piVar2[1] + var_4h;\n    }\n    uVar4 = 0 < piVar2[1];\n    if (uVar4 == 0) {\n        arg_18h[1] = 0;\n    }\n    else {\n        if (arg_1ch != 0) {\n            *piVar2 = *piVar2 + var_8h;\n        }\n        if (uVar5 == 0) {\n            if (*piVar2 < 1) goto code_r0x004356cf;\n            uVar5 = 1;\n            piVar2[1] = piVar2[1] + var_4h;\n        }\n    }\n    iVar1 = *piVar2;\n    if ((0 < iVar1) && (iVar1 <= *arg_18h)) {\n        *arg_18h = iVar1;\n    }\ncode_r0x004356cf:\n    iVar1 = piVar2[1];\n    if ((0 < iVar1) && (iVar1 <= arg_18h[1])) {\n        arg_18h[1] = iVar1;\n    }\n    *arg_10h = uVar5;\n    arg_10h[1] = uVar4;\n    return;\n}\n",
        "token_count": 595
    },
    "004368c5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004368c5(uint arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uchar *puVar2;\n    uint uVar3;\n    uint var_104h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    iVar1 = fcn.0042cf90(arg_8h, &var_104h, 0x100);\n    if (iVar1 != 0) {\n        puVar2 = fcn.0040ef28(&var_104h, 10);\n        if (puVar2 != NULL) {\n            uVar3 = fcn.004102f6(puVar2 + 1);\n            *arg_ch = uVar3;\n            uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(uVar3, *0x4995d4, 0x48);\n            *arg_ch = uVar3;\n            *puVar2 = 0;\n        }\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(arg_ch + 7, &var_104h, 0x20);\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 269
    },
    "00436c15": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00436c15(int32_t param_1)\n\n{\n    if ((param_1 < 0) || (0x15 < param_1)) {\n        param_1 = -1;\n    }\n    else {\n        param_1 = param_1 + 0x40000;\n    }\n    return param_1;\n}\n",
        "token_count": 77
    },
    "00437579": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00437579(uint param_1, uint param_2, int32_t param_3, code *param_4)\n\n{\n    if (-1 < param_3 + -1) {\n        do {\n            (*param_4)();\n            param_3 = param_3 + -1;\n        } while (param_3 != 0);\n    }\n    return;\n}\n",
        "token_count": 83
    },
    "004379da": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004379da(uint arg_8h, uint arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    bool bVar5;\n    uint var_20h;\n    uint var_18h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    if (arg_14h == 0) {\n        arg_14h = arg_10h;\n        var_4h = fcn.004374aa(arg_8h, arg_ch, arg_10h);\n        iVar1 = fcn.004374aa(arg_8h, arg_ch, 0);\n        if ((iVar1 != var_4h) && (0 < arg_10h)) {\n            do {\n                iVar1 = (arg_14h + iVar4) / 2;\n                iVar2 = fcn.004374aa(arg_8h, arg_ch, iVar1);\n                if ((iVar2 != var_4h) && (bVar5 = iVar4 == iVar1,  iVar4 = iVar1,  iVar1 = arg_14h,  bVar5)) {\n                    fcn.004374aa(arg_8h, arg_ch, arg_14h);\n                    break;\n                }\n                arg_14h = iVar1;\n            } while (iVar4 < arg_14h);\n        }\n        fcn.004378b8(&var_10h, arg_8h, arg_ch);\n        iVar1 = var_10h;\ncode_r0x00437b52:\n        fcn.004374aa(arg_8h, arg_ch, iVar1);\n    }\n    else {\n        fcn.004374aa(arg_8h, arg_ch, 0);\n        piVar3 = fcn.004378b8(&var_10h, arg_8h, arg_ch);\n        iVar4 = *piVar3;\n        var_4h = piVar3[1];\n        var_8h = iVar4;\n        fcn.004374aa(arg_8h, arg_ch, 0x7fff);\n        piVar3 = fcn.004378b8(&var_18h, arg_8h, arg_ch);\n        iVar1 = *piVar3;\n        var_ch = piVar3[1];\n        var_10h = iVar1;\n        if (iVar4 < iVar1) {\n            do {\n                fcn.004374aa(arg_8h, arg_ch, (iVar4 + iVar1) / 2);\n                piVar3 = fcn.004378b8(&var_18h, arg_8h, arg_ch);\n                iVar4 = piVar3[1];\n                if (arg_10h < iVar4) {\n                    iVar4 = fcn.0040475d(*piVar3, iVar4);\n                    if (iVar4 != 0) goto code_r0x00437b52;\n                    var_8h = *piVar3;\n                    var_4h = piVar3[1];\n                }\n                else {\n                    if (arg_10h <= iVar4) {\n                        return;\n                    }\n                    iVar4 = fcn.0040475d(*piVar3, piVar3[1]);\n                    iVar1 = var_8h;\n                    if (iVar4 != 0) goto code_r0x00437b52;\n                    iVar1 = *piVar3;\n                    var_ch = piVar3[1];\n                    var_10h = iVar1;\n                }\n                iVar4 = var_8h;\n            } while (var_8h < iVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 844
    },
    "00437cc7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00437cc7(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    fcn.004387e1(&var_10h, (*(in_ECX + 0x7c) & 0xa000) != 0);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch;\n    if (*0x494d18 < 0x40047) {\n        arg_ch[1] = arg_ch[1] + -2;\n    }\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 225
    },
    "004398c8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004398c8(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t *in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    (**(*in_ECX + 0x13c))(&var_10h, in_ECX[0x1f] & 0xa000);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch;\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 191
    },
    "0043994f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t fcn.0043994f(uint param_1)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = fcn.00405ccb(param_1);\n    return -(0xffff < uVar1) & uVar1;\n}\n",
        "token_count": 57
    },
    "0043996e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.0043996e(uint arg_8h, int32_t arg_ch, int32_t arg_10h, uint noname_3, uint noname_4, int32_t arg_1ch, \n            int32_t arg_20h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint32_t uVar4;\n    bool bVar5;\n    bool bVar6;\n    int32_t lpRect;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    uVar4 = *(in_ECX + 0x7c) & 0xa000;\n    var_ch = 0;\n    var_8h = 0;\n    var_10h = 0;\n    var_4h = 0;\n    if (0 < *(in_ECX + 0x9c)) {\n        do {\n            iVar3 = var_4h;\n            piVar1 = fcn.0043994f();\n            if ((piVar1 == NULL) || (iVar2 = (**(*piVar1 + 0x150))(),  iVar2 == 0)) {\n                var_10h = var_10h + (var_8h - *0x4995cc);\n                var_8h = 0;\n                iVar3 = arg_20h;\n                if (uVar4 == 0) {\n                    iVar3 = arg_1ch;\n                }\n                if (iVar3 < var_10h) {\n                    if (var_4h == 0) {\n                        fcn.00424c37(var_ch + 1, 0, 1);\n                    }\n                    iVar3 = var_ch + 1;\n                    goto code_r0x00439a6f;\n                }\ncode_r0x00439a3e:\n                var_ch = var_4h;\n            }\n            else {\n                (*_sym.imp.USER32.dll_GetWindowRect)(piVar1[7], &lpRect, iVar3);\n                fcn.00431de5(&lpRect);\n                if (uVar4 == 0) {\n                    iVar3 = (var_18h - lpRect) + -1;\n                }\n                else {\n                    iVar3 = var_14h - var_1ch;\n                }\n                if (var_8h <= iVar3) {\n                    if (uVar4 == 0) {\n                        var_8h = (var_18h - lpRect) + -1;\n                    }\n                    else {\n                        var_8h = var_14h - var_1ch;\n                    }\n                }\n                if (uVar4 == 0) {\n                    bVar6 = SBORROW4(arg_10h, var_1ch);\n                    iVar3 = arg_10h - var_1ch;\n                    bVar5 = arg_10h == var_1ch;\n                }\n                else {\n                    bVar6 = SBORROW4(arg_ch, lpRect);\n                    iVar3 = arg_ch - lpRect;\n                    bVar5 = arg_ch == lpRect;\n                }\n                if (!bVar5 && bVar6 == iVar3 < 0) goto code_r0x00439a3e;\n            }\n            var_4h = var_4h + 1;\n        } while (var_4h < *(in_ECX + 0x9c));\n    }\n    iVar3 = var_ch + 1;\n    fcn.00424c37(iVar3, 0, 1);\ncode_r0x00439a6f:\n    fcn.00424c37(iVar3, arg_8h, 1);\n    return iVar3;\n}\n",
        "token_count": 859
    },
    "00439bb5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00439bb5(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDockBar.0;\n    iVar3 = 0;\n    pcVar1 = extraout_ECX[0x27];\n    *(unaff_EBP + -4) = 1;\n    if (0 < pcVar1) {\n        do {\n            iVar2 = fcn.0043994f();\n            if ((iVar2 != 0) && (*(iVar2 + 0x88) == extraout_ECX)) {\n                *(iVar2 + 0x88) = 0;\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < extraout_ECX[0x27]);\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.00424d29();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00438884();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 331
    },
    "0043abc7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043abc7(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    fcn.004387e1(&var_10h, 1);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch + -2;\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 168
    },
    "0043bd8d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043bd8d(uint arg_8h, uint arg_ch, int32_t arg_10h, uint arg_14h, int32_t arg_18h)\n\n{\n    int32_t arg_8h_00;\n    \n    arg_8h_00 = fcn.004043ec(arg_10h + arg_18h);\n    fcn.0040e680(arg_8h_00, arg_ch, arg_10h);\n    fcn.0040e680(arg_8h_00 + arg_10h, arg_14h, arg_18h);\n    fcn.004042a8(arg_10h + arg_18h);\n    return;\n}\n",
        "token_count": 156
    },
    "0043c27d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0043c27d(int32_t param_1, int32_t param_2)\n\n{\n    fcn.0042a05b((param_1 + 0xe90) * 0x10 + param_2);\n    return;\n}\n",
        "token_count": 58
    },
    "0043c734": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043c734(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    \n    if (arg_10h < 0) {\n        arg_10h = 0;\n    }\n    iVar3 = arg_ch + -1;\n    piVar2 = arg_8h;\n    if (0 < iVar3) {\n        do {\n            if (piVar2[1] < *piVar2) {\n                piVar2[1] = 0;\n            }\n            piVar2[2] = piVar2[1];\n            piVar2 = piVar2 + 3;\n            iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n    }\n    iVar3 = 0;\n    piVar2[2] = 0x7fffffff;\n    if (0 < arg_ch) {\n        arg_8h = arg_8h + 2;\n        do {\n            if (arg_10h == 0) {\n                *arg_8h = 0;\n            }\n            else {\n                if ((arg_10h < arg_8h[-2]) && (iVar3 != 0)) {\n                    *arg_8h = 0;\n                    arg_8h[-3] = arg_8h[-3] + *0x4995c8 + arg_10h;\ncode_r0x0043c79a:\n                    arg_10h = 0;\n                }\n                else {\n                    iVar1 = *arg_8h;\n                    if (iVar1 == 0) {\n                        if (iVar3 != 0) {\n                            *arg_8h = 0;\n                        }\n                    }\n                    else {\n                        if (arg_10h < iVar1) {\n                            *arg_8h = arg_10h;\n                            goto code_r0x0043c79a;\n                        }\n                        arg_10h = arg_10h - iVar1;\n                    }\n                }\n                if (iVar3 != arg_ch + -1) {\n                    if (arg_14h < arg_10h) {\n                        arg_10h = arg_10h - arg_14h;\n                    }\n                    else {\n                        arg_10h = arg_10h + *arg_8h;\n                        *arg_8h = arg_10h;\n                        if (arg_14h - *0x4995c8 < arg_10h) {\n                            *arg_8h = (arg_10h - arg_14h) + *0x4995cc;\n                        }\n                        arg_10h = 0;\n                    }\n                }\n            }\n            iVar3 = iVar3 + 1;\n            arg_8h = arg_8h + 3;\n        } while (iVar3 < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 646
    },
    "0043c921": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.0043c921(code **param_1)\n\n{\n    fcn.00426a75();\n    *param_1 = vtable.CSplitterWnd.0;\n    fcn.0040e620(param_1 + 0x14, 0, 0x88);\n    param_1[0x1a] = NULL;\n    param_1[0x19] = NULL;\n    param_1[0x18] = 0x7;\n    param_1[0x17] = 0x7;\n    param_1[0x1c] = 0x7;\n    param_1[0x1b] = 0x7;\n    param_1[0x1e] = 0x2;\n    param_1[0x1d] = 0x2;\n    return param_1;\n}\n",
        "token_count": 194
    },
    "0043eebe": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043eebe(int32_t arg_8h, uint *arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    int32_t lpRect;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    arg_ch[1] = arg_ch[1] | 0x70;\n    *arg_ch = 0x50;\n    arg_ch[8] = *(arg_8h + 0x1c);\n    piVar1 = fcn.0042c6eb(0x4697d8, arg_8h);\n    if (piVar1 == NULL) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(*(arg_8h + 0x1c), &lpRect);\n        var_8h = var_8h - lpRect;\n        var_4h = var_4h - var_ch;\n    }\n    else {\n        piVar1 = (**(*piVar1 + 0x130))(&var_8h, 0, in_ECX[0x1f] & 0xa000);\n        var_8h = *piVar1;\n        var_4h = piVar1[1];\n    }\n    arg_ch[10] = var_4h;\n    if (*0x494d18 < 0x40048) {\n        iVar2 = 4;\n    }\n    else {\n        iVar2 = 0;\n    }\n    iVar2 = iVar2 + var_8h;\n    arg_ch[0x11] = iVar2;\n    arg_ch[0xb] = iVar2;\n    if ((arg_ch[2] & 0x200) == 0) {\n        arg_ch[9] = iVar2;\n    }\n    else {\n        arg_ch[1] = arg_ch[1] | 0x200;\n        arg_ch[9] = var_4h;\n    }\n    iVar2 = (**(*in_ECX + 0x110))(0x401, 0xffffffff, arg_ch);\n    if (iVar2 == 0) {\n        uVar3 = 0;\n    }\n    else {\n        piVar1 = fcn.00428388();\n        if (piVar1 != NULL) {\n            (**(*piVar1 + 0x144))(1);\n        }\n        (*_sym.imp.USER32.dll_SendMessageA)(in_ECX[7], 0x41f, 0, 0);\n        uVar3 = 1;\n    }\n    return uVar3;\n}\n",
        "token_count": 582
    },
    "0043f246": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043f246(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    fcn.004387e1(&var_10h, (*(in_ECX + 0x7c) & 0xa000) != 0);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch;\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 191
    },
    "0043f5cd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043f5cd(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint uStack48;\n    uchar auStack28 [28];\n    \n    pcVar1 = _sym.imp.USER32.dll_PeekMessageA;\n    while( true ) {\n        uStack48 = 0;\n        iVar2 = (*pcVar1)(&stack0xffffffe4, 0, 0xf, 0xf);\n        if (iVar2 == 0) {\n            *(param_1 + 0x70) = *(*(param_1 + 0x68) + 0x80);\n            *(param_1 + 0x78) = *(*(param_1 + 0x68) + 0x7c) & 0xf000;\n            (*_sym.imp.USER32.dll_SetRectEmpty)(param_1 + 0xc);\n            *(param_1 + 0x20) = 0;\n            *(param_1 + 0x1c) = 0;\n            *(param_1 + 0x24) = 0;\n            *(param_1 + 0x7c) = 0;\n            *(param_1 + 0x80) = 0;\n            uVar3 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n            iVar2 = fcn.004278de(uVar3);\n            iVar4 = (*_sym.imp.USER32.dll_LockWindowUpdate)(*(iVar2 + 0x1c));\n            if (iVar4 == 0) {\n                uVar3 = 3;\n            }\n            else {\n                uVar3 = 0x403;\n            }\n            uVar3 = (*_sym.imp.USER32.dll_GetDCEx)(*(iVar2 + 0x1c), 0, uVar3);\n            uVar3 = fcn.00432120(uVar3);\n            *(param_1 + 0x84) = uVar3;\n            return;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetMessageA)(&stack0xffffffd0, 0, 0xf, 0xf);\n        if (iVar2 == 0) break;\n        uStack48 = 0x43f605;\n        (*_sym.imp.USER32.dll_DispatchMessageA)();\n    }\n    return;\n}\n",
        "token_count": 527
    },
    "0043f9f2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043f9f2(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    fcn.0043f689(1);\n    (*_sym.imp.USER32.dll_ReleaseCapture)();\n    uVar2 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    iVar3 = fcn.004278de(uVar2);\n    (*_sym.imp.USER32.dll_LockWindowUpdate)(0);\n    iVar1 = *(param_1 + 0x84);\n    if (iVar1 != 0) {\n        (*_sym.imp.USER32.dll_ReleaseDC)(*(iVar3 + 0x1c), *(iVar1 + 4));\n        *(param_1 + 0x84) = 0;\n    }\n    return;\n}\n",
        "token_count": 182
    },
    "0044020e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid __cdecl fcn.0044020e(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    piVar1 = fcn.0042c770(extraout_ECX);\n    iVar2 = (**(*piVar1 + 0xc))();\n    *(unaff_EBP + -0x10) = iVar2 + 0x10;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = fcn.00404503(*(unaff_EBP + 0xc));\n    if (iVar2 == 0) {\n        fcn.00403164();\n    }\n    else {\n        fcn.0044010f(*(unaff_EBP + 8), *(unaff_EBP + -0x10), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n        fcn.00403164();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 338
    },
    "004434f6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004434f6(uint param_1)\n\n{\n    fcn.0044be10();\n    fcn.0044c776(0x44926b);\n    fcn.0044c43c(param_1);\n    return;\n}\n",
        "token_count": 58
    },
    "0044351a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044351a(uint param_1)\n\n{\n    fcn.0044be10();\n    fcn.0044c776(0x44926b);\n    fcn.0044c44f(param_1);\n    return;\n}\n",
        "token_count": 58
    },
    "004439e5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_fch\n// WARNING: Variable defined which should be unmapped: var_ech\n// WARNING: Variable defined which should be unmapped: lpmi\n// WARNING: Variable defined which should be unmapped: var_c8h\n// WARNING: Variable defined which should be unmapped: var_c4h\n// WARNING: Variable defined which should be unmapped: var_bch\n// WARNING: Variable defined which should be unmapped: var_ach\n// WARNING: Variable defined which should be unmapped: var_a8h\n// WARNING: Variable defined which should be unmapped: var_9ch_2\n// WARNING: Variable defined which should be unmapped: var_88h\n// WARNING: Variable defined which should be unmapped: var_7ch\n// WARNING: Variable defined which should be unmapped: var_68h_2\n// WARNING: Variable defined which should be unmapped: hmenu\n// WARNING: Variable defined which should be unmapped: lprc\n// WARNING: Variable defined which should be unmapped: dy\n// WARNING: Variable defined which should be unmapped: var_50h\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_48h_2\n// WARNING: Variable defined which should be unmapped: var_44h\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_34h_2\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h_2\n// WARNING: Variable defined which should be unmapped: var_24h_2\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch_2\n// WARNING: Variable defined which should be unmapped: var_18h_2\n// WARNING: Variable defined which should be unmapped: var_14h_2\n// WARNING: Variable defined which should be unmapped: var_4h_2\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: item\n// WARNING: Variable defined which should be unmapped: var_10h_2\n\nuint __cdecl\nfcn.004439e5(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint noname_22, uint noname_23, uint noname_24, uint noname_25, \n            uint noname_26, uint noname_27, uint noname_28, uint noname_29, uint noname_30, uint noname_31, \n            uint noname_32, uint noname_33, uint noname_34, uint noname_35, uint noname_36, uint noname_37, \n            uint noname_38, uint noname_39, uint noname_40, uint noname_41, uint noname_42, uint noname_43, \n            uint noname_44, uint noname_45, uint noname_46, uint noname_47, uint noname_48, uint noname_49, \n            uint noname_50, uint noname_51, uint noname_52, uint noname_53, uint noname_54, uint noname_55, \n            uint noname_56, uint noname_57, uint noname_58, uint noname_59, uint noname_60, uint noname_61, \n            uint noname_62, uint noname_63, uint noname_64, uint noname_65, uint noname_66, uint noname_67, \n            uint noname_68, uint noname_69, uint noname_70, uint noname_71, uint noname_72, uint noname_73, \n            uint noname_74, uint noname_75, uint noname_76, uint noname_77, uint noname_78, uint noname_79, \n            uint noname_80, uint noname_81, uint noname_82, uint noname_83, uint noname_84, uint noname_85, \n            uint noname_86, uint noname_87, uint noname_88, uint noname_89, uint noname_90, uint noname_91, \n            uint noname_92, uint noname_93, uint noname_94, uint noname_95, uint noname_96, uint noname_97, \n            uint noname_98, uint noname_99, uint noname_100, uint noname_101, uint noname_102, uint noname_103, \n            uint noname_104, uint noname_105, uint noname_106, uint noname_107, uint noname_108, uint noname_109, \n            uint noname_110, uint noname_111, uint noname_112, uint noname_113, uint noname_114, uint noname_115, \n            uint noname_116, uint noname_117, uint noname_118, uint noname_119, uint noname_120, uint arg_8h, uint hWnd)\n\n{\n    uint *noname_1_00;\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint noname_7_00;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    code **ppcVar8;\n    uint extraout_ECX;\n    uint unaff_EBX;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    uint32_t uVar9;\n    uint unaff_EDI;\n    uint32_t uVar10;\n    uint *in_FS_OFFSET;\n    uint unaff_retaddr;\n    uint var_8h;\n    uint item;\n    uint var_10h_2;\n    uint var_168h;\n    uint var_15ch;\n    uint var_158h;\n    uint var_13ch;\n    uint lprcDst;\n    uint lprcSrc2;\n    uint var_cch;\n    uint var_9ch;\n    uint lprcSrc1;\n    uint var_70h;\n    uint var_68h;\n    uint var_48h;\n    uint var_34h;\n    uint var_28h;\n    uint var_24h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    uint noname_3_00;\n    uint noname_4_00;\n    uint noname_5_00;\n    char *noname_10_00;\n    uint in_stack_fffffeb0;\n    uint in_stack_fffffeb4;\n    uint in_stack_fffffeb8;\n    uint in_stack_fffffebc;\n    uint in_stack_fffffec0;\n    uint in_stack_fffffec4;\n    uint in_stack_fffffec8;\n    uint in_stack_fffffecc;\n    uint in_stack_fffffed0;\n    uint in_stack_fffffed4;\n    uint in_stack_fffffed8;\n    uint in_stack_fffffedc;\n    uint in_stack_fffffee0;\n    uint in_stack_fffffee4;\n    uint in_stack_fffffee8;\n    uint in_stack_fffffeec;\n    uint in_stack_fffffef0;\n    uint in_stack_fffffef4;\n    uint in_stack_fffffef8;\n    uint in_stack_fffffefc;\n    uint var_fch;\n    uint in_stack_ffffff04;\n    uint in_stack_ffffff08;\n    uint in_stack_ffffff0c;\n    uint var_ech;\n    uint in_stack_ffffff14;\n    uint in_stack_ffffff18;\n    uint in_stack_ffffff1c;\n    uint in_stack_ffffff20;\n    uint in_stack_ffffff24;\n    uint in_stack_ffffff28;\n    uint in_stack_ffffff2c;\n    uint lpmi;\n    uint var_c8h;\n    uint var_c4h;\n    uint in_stack_ffffff3c;\n    uint var_bch;\n    uint in_stack_ffffff44;\n    uint in_stack_ffffff48;\n    uint in_stack_ffffff4c;\n    uint var_ach;\n    uint var_a8h;\n    uint in_stack_ffffff58;\n    uint in_stack_ffffff5c;\n    uint var_9ch_2;\n    uint in_stack_ffffff64;\n    uint in_stack_ffffff68;\n    uint in_stack_ffffff6c;\n    uint in_stack_ffffff70;\n    uint var_88h;\n    uint in_stack_ffffff78;\n    uint in_stack_ffffff7c;\n    uint var_7ch;\n    uint in_stack_ffffff84;\n    uint in_stack_ffffff88;\n    uint in_stack_ffffff8c;\n    uint in_stack_ffffff90;\n    uint var_68h_2;\n    uint hmenu;\n    uint in_stack_ffffff9c;\n    uint in_stack_ffffffa0;\n    uint lprc;\n    uint dy;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h_2;\n    uint var_44h;\n    uint in_stack_ffffffbc;\n    uint in_stack_ffffffc0;\n    uint var_38h;\n    uint var_34h_2;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h_2;\n    uint var_24h_2;\n    uint var_20h;\n    uint var_1ch_2;\n    uint var_18h_2;\n    uint var_14h_2;\n    uint in_stack_ffffffec;\n    uint in_stack_fffffff0;\n    uint in_stack_fffffff4;\n    uint var_4h_2;\n    uint noname_97_00;\n    \n    noname_97_00 = 0x4439ef;\n    fcn.0040e188();\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    piVar2 = fcn.0042c770();\n    iVar3 = (**(*piVar2 + 0xc))();\n    *(unaff_EBP + -0x10) = iVar3 + 0x10;\n    *(unaff_EBP + -4) = 0;\n    noname_10_00 = \"ReBarWindow32\";\n    iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)();\n    iVar4 = iVar4 + 1;\n    iVar3 = iVar4;\n    noname_7_00 = fcn.004043ec();\n    noname_1_00 = *(unaff_EBP + 0xc);\n    uVar7 = *noname_1_00;\n    (*_sym.imp.USER32.dll_GetClassNameA)();\n    noname_5_00 = 0xffffffff;\n    fcn.00404cad();\n    noname_4_00 = *noname_1_00;\n    iVar5 = fcn.00427905();\n    *(unaff_EBP + 0xc) = iVar5;\n    iVar6 = fcn.0040efa3(*(unaff_EBP + -0x10), \"ReBarWindow32\");\n    if ((iVar6 == 0) && (iVar5 != 0)) {\n        noname_3_00 = 0x46fb1c;\n        iVar6 = fcn.0042c6e0();\n        if (iVar6 != 0) {\n            iVar6 = fcn.00428388();\n            if ((iVar6 != 0) && (*(unaff_EBP + -0x14) != iVar6)) {\n                uVar7 = fcn.004439e5(*(unaff_EBP + 8), noname_1_00, *(unaff_EBP + 0x10), noname_3_00, noname_4_00, \n                                     noname_5_00, uVar7, noname_7_00, iVar4, iVar3, noname_10_00, unaff_EDI, unaff_ESI, \n                                     unaff_EBX, in_stack_fffffeb0, in_stack_fffffeb4, in_stack_fffffeb8, \n                                     in_stack_fffffebc, in_stack_fffffec0, in_stack_fffffec4, in_stack_fffffec8, \n                                     in_stack_fffffecc, in_stack_fffffed0, in_stack_fffffed4, in_stack_fffffed8, \n                                     in_stack_fffffedc, in_stack_fffffee0, in_stack_fffffee4, in_stack_fffffee8, \n                                     in_stack_fffffeec, in_stack_fffffef0, in_stack_fffffef4, in_stack_fffffef8, \n                                     in_stack_fffffefc, var_fch, in_stack_ffffff04, in_stack_ffffff08, in_stack_ffffff0c\n                                     , var_ech, in_stack_ffffff14, in_stack_ffffff18, in_stack_ffffff1c, \n                                     in_stack_ffffff20, in_stack_ffffff24, in_stack_ffffff28, in_stack_ffffff2c, lpmi, \n                                     var_c8h, var_c4h, in_stack_ffffff3c, var_bch, in_stack_ffffff44, in_stack_ffffff48\n                                     , in_stack_ffffff4c, var_ach, var_a8h, in_stack_ffffff58, in_stack_ffffff5c, \n                                     var_9ch_2, in_stack_ffffff64, in_stack_ffffff68, in_stack_ffffff6c, \n                                     in_stack_ffffff70, var_88h, in_stack_ffffff78, in_stack_ffffff7c, var_7ch, \n                                     in_stack_ffffff84, in_stack_ffffff88, in_stack_ffffff8c, in_stack_ffffff90, \n                                     var_68h_2, hmenu, in_stack_ffffff9c, in_stack_ffffffa0, lprc, dy, var_50h, var_4ch\n                                     , var_48h_2, var_44h, in_stack_ffffffbc, in_stack_ffffffc0, var_38h, var_34h_2, \n                                     var_30h, var_2ch, var_28h_2, var_24h_2, var_20h, var_1ch_2, var_18h_2, var_14h_2, \n                                     in_stack_ffffffec, in_stack_fffffff0, in_stack_fffffff4, var_4h_2, noname_97_00, \n                                     unaff_retaddr, var_8h, item, var_10h_2, noname_3, noname_4, noname_5, noname_6, \n                                     noname_7, noname_8, noname_9, noname_10, noname_11, noname_12, noname_13, noname_14\n                                     , noname_15, noname_16, noname_17, noname_18, noname_19, noname_20, noname_21, \n                                     noname_22, noname_23);\n                goto code_r0x00443ec5;\n            }\n            fcn.0042d1d5();\n            *(unaff_EBP + -4) = 1;\n            piVar2 = fcn.0042c770();\n            iVar3 = (**(*piVar2 + 0xc))();\n            *(unaff_EBP + 8) = iVar3 + 0x10;\n            *(unaff_EBP + -4) = 2;\n            piVar2 = fcn.0042c770();\n            iVar3 = (**(*piVar2 + 0xc))();\n            *(unaff_EBP + -0x18) = iVar3 + 0x10;\n            *(unaff_EBP + -4) = 3;\n            fcn.00431a50();\n            *(unaff_EBP + -4) = 4;\n            fcn.004321c5(*(unaff_EBP + -0x14));\n            pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n            *(unaff_EBP + -4) = 5;\n            *(unaff_EBP + -0x15c) = 0x50;\n            *(unaff_EBP + -0x158) = 0x10;\n            (*pcVar1)();\n            (*pcVar1)(*(iVar5 + 0x1c), 0x409, noname_1_00[3], unaff_EBP + -0x78);\n            iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(\"ToolbarWindow32\");\n            uVar7 = fcn.004043ec(iVar3 + 1, iVar3 + 1);\n            (*_sym.imp.USER32.dll_GetClassNameA)(*(unaff_EBP + -0x13c), uVar7);\n            fcn.00404cad();\n            uVar7 = fcn.00427905();\n            *(unaff_EBP + -0x28) = uVar7;\n            iVar3 = fcn.0040efa3(*(unaff_EBP + -0x10), \"ToolbarWindow32\");\n            if ((iVar3 == 0) && (iVar3 = *(unaff_EBP + -0x28),  iVar3 != 0)) {\n                iVar4 = fcn.0042c6e0();\n                if (iVar4 != 0) {\n                    *(unaff_EBP + -0x70) = noname_1_00[6];\n                    *(unaff_EBP + -0x34) = noname_1_00 + 6;\n                    fcn.00431e21();\n                    fcn.00431de5();\n                    iVar4 = fcn.00404bb8();\n                    *(unaff_EBP + -0x1c) = iVar4;\n                    do {\n                        iVar4 = iVar4 + -1;\n                        uVar7 = *(iVar3 + 0x1c);\n                        *(unaff_EBP + 0xc) = iVar4;\n                        (*pcVar1)(uVar7, 0x41d, iVar4, unaff_EBP + -0xdc);\n                        iVar5 = (*_sym.imp.USER32.dll_IntersectRect)\n                                          (unaff_EBP + -0x10c, unaff_EBP + -0x78, unaff_EBP + -0xdc);\n                        if (iVar5 != 0) break;\n                    } while (iVar4 != 0);\n                    fcn.0040e620(unaff_EBP + -0xcc, 0, 0x30);\n                    *(unaff_EBP + -0xcc) = 0x30;\n                    iVar4 = fcn.00404c1f();\n                    iVar3 = *(unaff_EBP + -0x1c);\n                    uVar10 = *(unaff_EBP + 0xc);\n                    fcn.0040dc10();\n                    *(unaff_EBP + -0x24) = &stack0xfffffe70;\n                    uVar9 = 0;\n                    fcn.0040e620(*(unaff_EBP + -0x24), 0, (iVar3 - uVar10) * 4);\n                    uVar7 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n                    fcn.0042d168(uVar7);\n                    fcn.00404a1c(unaff_EBP + -0x9c);\n                    pcVar1 = _sym.imp.USER32.dll_CopyRect;\n                    *(unaff_EBP + -0x20) = 0;\n                    if (uVar10 < *(unaff_EBP + -0x1c)) {\n                        do {\n                            fcn.0043759b(*(unaff_EBP + 0xc), unaff_EBP + -0x30, unaff_EBP + -0x38, unaff_EBP + -0x2c);\n                            if ((*(unaff_EBP + -0x38) & 1) == 0) {\n                                *(unaff_EBP + -200) = 0x162;\n                                fcn.00404503(*(unaff_EBP + -0x30));\n                                fcn.0042d03c(unaff_EBP + -0x18, *(unaff_EBP + 8), 1, 10);\n                                ppcVar8 = fcn.00425ce2(8);\n                                if (ppcVar8 == NULL) {\n                                    ppcVar8 = NULL;\n                                }\n                                else {\n                                    ppcVar8[1] = NULL;\n                                    *ppcVar8 = vtable.CBitmap.0;\n                                }\n                                piVar2 = *(unaff_EBP + -0x24) + uVar9 * 4;\n                                *piVar2 = ppcVar8;\n                                (*_sym.imp.COMCTL32.dll_ImageList_GetImageInfo)\n                                          (*(iVar4 + 4), *(unaff_EBP + -0x2c), unaff_EBP + -0xfc);\n                                (*pcVar1)(unaff_EBP + -0x58, unaff_EBP + -0xec);\n                                (*_sym.imp.USER32.dll_OffsetRect)\n                                          (unaff_EBP + -0x58, -*(unaff_EBP + -0x58), -*(unaff_EBP + -0x54));\n                                fcn.004049ed(unaff_EBP + -0x9c, *(unaff_EBP + -0x50), *(unaff_EBP + -0x4c));\n                                iVar3 = *piVar2;\n                                if (iVar3 != 0) {\n                                    iVar3 = *(iVar3 + 4);\n                                }\n                                iVar3 = fcn.004324e6(*(unaff_EBP + -0x44), iVar3);\n                                *piVar2 = iVar3;\n                                (*_sym.imp.USER32.dll_GetSysColor)(4);\n                                fcn.004455dd();\n                                fcn.00404be4(unaff_EBP + -0x48, *(unaff_EBP + -0x2c), 0, 0, 1);\n                                iVar3 = *piVar2;\n                                if (iVar3 != 0) {\n                                    iVar3 = *(iVar3 + 4);\n                                }\n                                iVar3 = fcn.004324e6(*(unaff_EBP + -0x44), iVar3);\n                                *(unaff_EBP + -0x20) = *(unaff_EBP + -0x20) + 1;\n                                *piVar2 = iVar3;\n                                *(unaff_EBP + -0xa8) = *(unaff_EBP + -0x18);\n                                *(unaff_EBP + -0xbc) = *(unaff_EBP + -0x30);\n                                *(unaff_EBP + -0xc4) = 0x100;\n                                uVar9 = *(unaff_EBP + -0x20);\n                                *(unaff_EBP + -0xac) = *piVar2;\ncode_r0x00443dcc:\n                                (*_sym.imp.USER32.dll_InsertMenuItemA)\n                                          (*(unaff_EBP + -100), *(unaff_EBP + 0xc), 1, unaff_EBP + -0xcc);\n                            }\n                            else if (uVar9 != 0) {\n                                *(unaff_EBP + -200) = 0x100;\n                                *(unaff_EBP + -0xc4) = 0x800;\n                                goto code_r0x00443dcc;\n                            }\n                            *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc) + 1;\n                        } while (*(unaff_EBP + 0xc) < *(unaff_EBP + -0x1c));\n                    }\n                    (*pcVar1)(unaff_EBP + -0x88, *(unaff_EBP + -0x34));\n                    fcn.00431e21();\n                    fcn.00426bc3(0, *(unaff_EBP + -0x88), *(unaff_EBP + -0x7c), *(unaff_EBP + -0x14), 0);\n                    uVar10 = 0;\n                    **(unaff_EBP + 0x10) = 0;\n                    if (uVar9 != 0) {\n                        do {\n                            piVar2 = *(*(unaff_EBP + -0x24) + uVar10 * 4);\n                            if (piVar2 != NULL) {\n                                (**(*piVar2 + 4))();\n                            }\n                            uVar10 = uVar10 + 1;\n                        } while (uVar10 < uVar9);\n                    }\n                    *(unaff_EBP + -4) = 4;\n                    fcn.00432220();\n                    *(unaff_EBP + -4) = 3;\n                    fcn.004321ac();\n                    fcn.00403164();\n                    fcn.00403164();\n                    *(unaff_EBP + -4) = 0;\n                    fcn.00443313();\n                    uVar7 = 1;\n                    goto code_r0x00443ec5;\n                }\n            }\n            *(unaff_EBP + -4) = 4;\n            fcn.00432220();\n            *(unaff_EBP + -4) = 3;\n            fcn.004321ac();\n            fcn.00403164();\n            fcn.00403164();\n            *(unaff_EBP + -4) = 0;\n            fcn.00443313();\n        }\n    }\n    uVar7 = 0;\ncode_r0x00443ec5:\n    fcn.00403164();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar7;\n}\n",
        "token_count": 5848
    },
    "00443f93": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: ARG_0\n// WARNING: Variable defined which should be unmapped: var_34h\n\nvoid __cdecl fcn.00443f93(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_34h;\n    uint ARG_0;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = *0x496830;\n    piVar1 = fcn.0042c770();\n    iVar2 = (**(*piVar1 + 0xc))();\n    *(unaff_EBP + -0x34) = iVar2 + 0x10;\n    *(unaff_EBP + -4) = 0;\n    uVar3 = fcn.0042a1c5();\n    if ((uVar3 & 0x4000) == 0) {\n        fcn.00449313(extraout_ECX + 0xc0);\n        if (*(unaff_EBP + 8) != 0) {\n            fcn.004489a6(0x469e94);\n            fcn.004489a6(*(unaff_EBP + 8));\n            if (0 < *(extraout_ECX + 0x54)) {\n                (*_sym.imp.USER32.dll_wsprintfA)(unaff_EBP + -0x30, 0x469e98, *(extraout_ECX + 0x54));\n                fcn.004489a6(unaff_EBP + -0x30);\n            }\n        }\n    }\n    else {\n        if (*(unaff_EBP + 8) != 0) {\n            fcn.004489a6(*(unaff_EBP + 8));\n            if (0 < *(extraout_ECX + 0x54)) {\n                (*_sym.imp.USER32.dll_wsprintfA)(unaff_EBP + -0x30, 0x469e98, *(extraout_ECX + 0x54));\n                fcn.004489a6(unaff_EBP + -0x30);\n            }\n            fcn.004489a6(0x469e94);\n        }\n        fcn.00449313();\n    }\n    fcn.00436750(*(extraout_ECX + 0x1c), *(unaff_EBP + -0x34));\n    fcn.00403164();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 609
    },
    "004441ba": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004441ba(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    ushort uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    if (arg_ch == 0) {\n        puVar3 = 0x46ae90;\n        do {\n            iVar2 = fcn.00442d09(*puVar3);\n            if (iVar2 != 0) {\n                uVar1 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_8h + 0x1c), 0xffffffff);\n                iVar2 = fcn.00439912(uVar1);\n                if (0 < iVar2) break;\n            }\n            if (((puVar3[1] ^ *(arg_8h + 0x7c)) & 0xf000) == 0) {\n                fcn.00442d09(*puVar3);\n            }\n            puVar3 = puVar3 + 2;\n        } while (puVar3 < 0x46aeb0);\n    }\n    fcn.0043a5d1(arg_8h, arg_10h);\n    return;\n}\n",
        "token_count": 264
    },
    "00445a91": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00445a91(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t Y, uint crColor)\n\n{\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.GDI32.dll_SetBkColor)(*(in_ECX + 4), crColor);\n    var_10h = arg_8h;\n    var_8h = arg_8h + arg_10h;\n    var_ch = arg_ch;\n    var_4h = arg_ch + Y;\n    (*_sym.imp.GDI32.dll_ExtTextOutA)(*(in_ECX + 4), 0, 0, 2, &var_10h, 0, 0, 0);\n    return;\n}\n",
        "token_count": 207
    },
    "00445add": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00445add(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint var_4h;\n    \n    fcn.00445a91(arg_8h, arg_ch, arg_10h + -1, 1, arg_18h);\n    fcn.00445a91(arg_8h, arg_ch, 1, arg_14h + -1, arg_18h);\n    fcn.00445a91(arg_8h + arg_10h, arg_ch, 0xffffffff, arg_14h, arg_1ch);\n    fcn.00445a91(arg_8h, arg_ch + arg_14h, arg_10h, 0xffffffff, arg_1ch);\n    return;\n}\n",
        "token_count": 199
    },
    "00445c1c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00445c1c(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint var_40h;\n    uint var_29h;\n    uint var_24h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    fcn.0040e620(&var_40h, 0, 0x3c);\n    var_40h = arg_8h;\n    var_29h._0_1_ = 1;\n    (*_sym.imp.KERNEL32.dll_lstrcpynA)(&var_24h, arg_ch, 0x20);\n    fcn.00445b47(&var_40h, arg_10h);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 190
    },
    "00445c81": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00445c81(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0044be10();\n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(iVar1 + 0x2c);\n    return;\n}\n",
        "token_count": 58
    },
    "00447580": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.00447580(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    char *pcVar1;\n    \n    for (pcVar1 = param_3 + param_1; (pcVar1 < param_2 + param_1 && (*pcVar1 != '\\r')); pcVar1 = pcVar1 + 1) {\n    }\n    return pcVar1 - param_1;\n}\n",
        "token_count": 101
    },
    "004480f8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004480f8(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint arg_8h_00;\n    int32_t in_ECX;\n    int32_t lParam;\n    int32_t wParam;\n    \n    lParam = in_ECX;\n    wParam = in_ECX;\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0xb0, &wParam, &lParam);\n    iVar1 = fcn.00447b28();\n    iVar2 = fcn.00447580(iVar1, lParam, wParam);\n    iVar2 = iVar2 - wParam;\n    arg_8h_00 = fcn.004043ec(iVar2);\n    fcn.0040e680(arg_8h_00, iVar1 + wParam, iVar2);\n    fcn.00404cad(iVar2);\n    fcn.00447ba2();\n    return;\n}\n",
        "token_count": 216
    },
    "00448cb8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00448cb8(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    int32_t *piVar4;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar4 = arg_8h;\n    var_4h = *0x496830;\n    for (iVar1 = (**(*in_ECX + 0x110))(0x418, 0, 0); iVar1 != 0; iVar1 = iVar1 + -1) {\n        (**(*in_ECX + 0x110))(0x416, 0, 0);\n    }\n    fcn.0040e620(&var_18h, 0, 0x14);\n    var_8h = 0xffffffff;\n    if (arg_8h == NULL) {\n        iVar1 = 0;\n        var_10h._0_1_ = 4;\n        if (0 < arg_ch) {\n            do {\n                iVar3 = (**(*in_ECX + 0x110))(0x414, 1, &var_18h);\n                if (iVar3 == 0) goto code_r0x00448daa;\n                iVar1 = iVar1 + 1;\n            } while (iVar1 < arg_ch);\n        }\n    }\n    else {\n        arg_8h = NULL;\n        var_1ch = 0;\n        if (0 < arg_ch) {\n            do {\n                var_14h = *piVar4;\n                piVar4 = piVar4 + 1;\n                var_10h._0_1_ = 4;\n                if (var_14h == 0) {\n                    var_10h._1_1_ = 1;\n                    uVar2 = fcn.0042a1c5();\n                    if (((uVar2 & 0x800) == 0) && (*0x494d18 != 0x40047)) {\n                        var_18h = 8;\n                    }\n                    else {\n                        var_18h = 6;\n                    }\n                }\n                else {\n                    var_10h._1_1_ = 0;\n                    var_18h = arg_8h;\n                    arg_8h = arg_8h + 1;\n                }\n                iVar1 = (**(*in_ECX + 0x110))(0x414, 1, &var_18h);\n                if (iVar1 == 0) goto code_r0x00448daa;\n                var_1ch = var_1ch + 1;\n            } while (var_1ch < arg_ch);\n        }\n    }\n    iVar1 = (**(*in_ECX + 0x110))(0x418, 0, 0);\n    in_ECX[0x1c] = iVar1;\n    in_ECX[0x27] = 1;\ncode_r0x00448daa:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 726
    },
    "00449f87": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00449f87(int32_t param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    if (0 < *(param_1 + 0x70)) {\n        do {\n            fcn.004039aa();\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < *(param_1 + 0x70));\n    }\n    iVar2 = fcn.00449d31(param_2, param_3);\n    if (iVar2 != 0) {\n        iVar2 = 0;\n        if (0 < *(param_1 + 0x70)) {\n            iVar1 = *(param_1 + 0x74) + 0x10;\n            do {\n                if (iVar1 != 0) {\n                    fcn.00403c40();\n                }\n                iVar1 = iVar1 + 0x14;\n                iVar2 = iVar2 + 1;\n            } while (iVar2 < *(param_1 + 0x70));\n        }\n        iVar2 = 1;\n    }\n    return iVar2;\n}\n",
        "token_count": 262
    },
    "0044a88e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0044a88e(void)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CWinApp.0;\n    piVar1 = extraout_ECX[0x15];\n    *(unaff_EBP + -4) = 0;\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 4))(1);\n    }\n    if (extraout_ECX[0x21] != NULL) {\n        (**(*extraout_ECX[0x21] + 0x18))(1);\n    }\n    iVar3 = fcn.0044be10();\n    if (*(iVar3 + 0x14) == '\\0') {\n        if (*0x4993ac != NULL) {\n            (**(**0x4993ac + 4))(1);\n            *0x4993ac = NULL;\n        }\n        if (*0x4993a8 != NULL) {\n            (**(**0x4993a8 + 4))(1);\n            *0x4993a8 = NULL;\n        }\n    }\n    if (extraout_ECX[0x1b] != NULL) {\n        fcn.00436848(extraout_ECX[0x1b]);\n    }\n    if (extraout_ECX[0x1c] != NULL) {\n        fcn.00436848(extraout_ECX[0x1c]);\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_GlobalDeleteAtom;\n    if (*(extraout_ECX + 0x23) != 0) {\n        (*_sym.imp.KERNEL32.dll_GlobalDeleteAtom)(*(extraout_ECX + 0x23));\n    }\n    if (*(extraout_ECX + 0x8e) != 0) {\n        (*pcVar2)(*(extraout_ECX + 0x8e));\n    }\n    if (extraout_ECX[0x22] != NULL) {\n        (**(*extraout_ECX[0x22] + 4))(1);\n    }\n    iVar3 = fcn.0044be10();\n    if (*(iVar3 + 0x10) == extraout_ECX[0x13]) {\n        *(iVar3 + 0x10) = 0;\n    }\n    if (*(iVar3 + 4) == extraout_ECX) {\n        *(iVar3 + 4) = 0;\n    }\n    fcn.0040d958(extraout_ECX[0x13]);\n    fcn.0040d958(extraout_ECX[0x14]);\n    fcn.0040d958(extraout_ECX[0x17]);\n    fcn.0040d958(extraout_ECX[0x18]);\n    fcn.0040d958(extraout_ECX[0x19]);\n    *(unaff_EBP + -4) = 0xffffffff;\n    extraout_ECX[10] = NULL;\n    fcn.004636eb();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 793
    },
    "0044b177": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: pszPath\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid fcn.0044b177(void)\n\n{\n    code *pcVar1;\n    ushort uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint pszPath;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    piVar3 = fcn.0042c770();\n    iVar4 = (**(*piVar3 + 0xc))();\n    *(unaff_EBP + -0x14) = iVar4 + 0x10;\n    *(unaff_EBP + -4) = 0;\n    iVar4 = fcn.0044be10();\n    fcn.0042f3ce(*(iVar4 + 8), unaff_EBP + -0x14);\n    uVar5 = (*_sym.imp.SHLWAPI.dll_PathFindFileNameA)(*(unaff_EBP + -0x14));\n    fcn.004045fc(uVar5);\n    *(unaff_EBP + -4) = 1;\n    uVar5 = fcn.00405f38();\n    (*_sym.imp.SHLWAPI.dll_PathRemoveExtensionA)(uVar5);\n    fcn.00404cad(0xffffffff);\n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalAddAtomA;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(*(unaff_EBP + -0x10));\n    *(extraout_ECX + 0x8c) = uVar2;\n    uVar2 = (*pcVar1)(\"system\");\n    *(extraout_ECX + 0x8e) = uVar2;\n    fcn.00403164();\n    fcn.00403164();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 479
    },
    "0044b613": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044b613(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *(param_1 + 0x1c) = 0;\n    *(param_1 + 0x20) = 0;\n    *(param_1 + 0x28) = 0;\n    *(param_1 + 0x2c) = 0;\n    iVar1 = fcn.0044bde5();\n    *(iVar1 + 0x34) = 0;\n    *(iVar1 + 0x54) = 0;\n    (*_sym.imp.USER32.dll_GetCursorPos)(iVar1 + 0x4c);\n    *(param_1 + 0x3c) = 0;\n    *(param_1 + 0x38) = 0;\n    *(param_1 + 0x24) = 1;\n    return;\n}\n",
        "token_count": 201
    },
    "0044b8ae": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044b8ae(uint arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    if (arg_ch < 0) {\n        arg_ch = 0;\n    }\n    if (arg_10h < 0) {\n        arg_10h = 0;\n    }\n    iVar1 = *in_ECX;\n    iVar2 = *(iVar1 + -0xc);\n    if (iVar2 < arg_ch + arg_10h) {\n        arg_10h = iVar2 - arg_ch;\n    }\n    if (iVar2 < arg_ch) {\n        arg_10h = 0;\n    }\n    if ((arg_ch == 0) && (arg_10h == iVar2)) {\n        fcn.004039b4();\n    }\n    else {\n        uVar3 = (**(**(iVar1 + -0x10) + 0x10))();\n        fcn.0044b894(iVar1 + arg_ch, arg_10h, uVar3);\n    }\n    return arg_8h;\n}\n",
        "token_count": 274
    },
    "0044be36": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0044be36(void)\n\n{\n    fcn.0044be10();\n    fcn.0044c776(0x44926b);\n    return;\n}\n",
        "token_count": 40
    },
    "0044c565": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c565(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *in_ECX;\n    uint lpCriticalSection;\n    \n    puVar1 = in_ECX + 7;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(puVar1);\n    if ((arg_8h < 1) || (in_ECX[3] <= arg_8h)) goto code_r0x0044c65f;\n    iVar2 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*in_ECX);\n    if (iVar2 == 0) {\n        iVar2 = fcn.0044c1ce(0x10);\n        if (iVar2 == 0) {\n            iVar2 = 0;\n        }\n        else {\n            iVar2 = fcn.0044c48d();\n        }\n        *(iVar2 + 8) = 0;\n        *(iVar2 + 0xc) = 0;\n        *(iVar2 + in_ECX[6]) = in_ECX[5];\n        in_ECX[5] = iVar2;\ncode_r0x0044c5e0:\n        if (*(iVar2 + 0xc) == 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0, in_ECX[3] << 2);\n        }\n        else {\n            iVar3 = (*_sym.imp.KERNEL32.dll_LocalReAlloc)(*(iVar2 + 0xc), in_ECX[3] << 2, 2);\n        }\n        if (iVar3 == 0) {\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar1);\n            iVar3 = fcn.004202f9();\n        }\n        *(iVar2 + 0xc) = iVar3;\n        fcn.0040e620(iVar3 + *(iVar2 + 8) * 4, 0, (in_ECX[3] - *(iVar2 + 8)) * 4);\n        *(iVar2 + 8) = in_ECX[3];\n        (*_sym.imp.KERNEL32.dll_TlsSetValue)(*in_ECX, iVar2);\n    }\n    else if ((*(iVar2 + 8) <= arg_8h) && (arg_ch != 0)) goto code_r0x0044c5e0;\n    if ((*(iVar2 + 0xc) != 0) && (arg_8h < *(iVar2 + 8))) {\n        *(*(iVar2 + 0xc) + arg_8h * 4) = arg_ch;\n    }\ncode_r0x0044c65f:\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar1);\n    return;\n}\n",
        "token_count": 618
    },
    "0044cb22": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0044cb22(int32_t param_1, uint param_2)\n\n{\n    uint uVar1;\n    \n    fcn.0040d958(*(param_1 + 0x50));\n    uVar1 = fcn.0040f496(param_2);\n    *(param_1 + 0x50) = uVar1;\n    fcn.0040d958(*(param_1 + 100));\n    uVar1 = fcn.0040f496(*(param_1 + 0x4c));\n    *(param_1 + 100) = uVar1;\n    return;\n}\n",
        "token_count": 139
    },
    "0044cfd2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044cfd2(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uchar *puVar2;\n    uint phkResult;\n    uint lpName;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    arg_8h_00 = fcn.0040f496(arg_8h);\n    if (arg_8h_00 != 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_8h_00);\n        puVar2 = iVar1 + arg_8h_00;\n        while (puVar2 != NULL) {\n            *puVar2 = 0;\n            fcn.004104b2(arg_8h_00, puVar2);\n            iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(0x80000000, arg_8h_00, &phkResult);\n            if (iVar1 != 0) break;\n            iVar1 = (*_sym.imp.ADVAPI32.dll_RegEnumKeyA)(phkResult, 0, &lpName, 0x105);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(phkResult);\n            if (iVar1 == 0) break;\n            (*_sym.imp.ADVAPI32.dll_RegDeleteKeyA)(0x80000000, arg_8h_00);\n            puVar2 = fcn.00410447(arg_8h_00, 0x5c);\n        }\n        fcn.0040d958(arg_8h_00);\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 380
    },
    "0044d0f1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044d0f1(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    if (arg_ch < 0) {\n        arg_ch = 0;\n    }\n    iVar1 = *in_ECX;\n    iVar2 = *(iVar1 + -0xc);\n    if (arg_ch < iVar2) {\n        uVar3 = (**(**(iVar1 + -0x10) + 0x10))();\n        fcn.0044b894((iVar1 - arg_ch) + iVar2, arg_ch, uVar3);\n    }\n    else {\n        fcn.004039b4();\n    }\n    return arg_8h;\n}\n",
        "token_count": 186
    },
    "0044de6c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0044de6c(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0042c6e0(0x46932c);\n    if (iVar1 == 0) {\n        iVar1 = fcn.0042c6e0(0x4693e8);\n        if (iVar1 == 0) {\n            iVar1 = fcn.0042c6e0(0x4693b4);\n            iVar1 = (-(iVar1 != 0) & 0xffff4002) + 0x8000ffff;\n        }\n        else {\n            iVar1 = -0x7ff8fff2;\n        }\n    }\n    else {\n        iVar1 = *(param_1 + 8);\n    }\n    return iVar1;\n}\n",
        "token_count": 182
    },
    "0044df96": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044df96(int32_t arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    uint32_t arg_10h;\n    uint arg_ch_00;\n    uint arg_8h_00;\n    uint32_t uVar2;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalSize;\n    arg_10h = (*_sym.imp.KERNEL32.dll_GlobalSize)(arg_ch);\n    if (arg_8h == 0) {\n        arg_8h = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x2002, arg_10h);\n        if (arg_8h == 0) {\n            return 0;\n        }\n    }\n    else {\n        uVar2 = (*pcVar1)(arg_8h);\n        if (uVar2 < arg_10h) {\n            return 0;\n        }\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalLock;\n    arg_ch_00 = (*_sym.imp.KERNEL32.dll_GlobalLock)(arg_ch);\n    arg_8h_00 = (*pcVar1)(arg_8h);\n    fcn.0040e680(arg_8h_00, arg_ch_00, arg_10h);\n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalUnlock;\n    (*_sym.imp.KERNEL32.dll_GlobalUnlock)(arg_8h);\n    (*pcVar1)(arg_ch);\n    return arg_8h;\n}\n",
        "token_count": 329
    },
    "0044febe": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0044febe(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint unaff_retaddr;\n    \n    iVar1 = fcn.0044fd3f(param_1);\n    *param_1 = iVar1;\n    if (iVar1 == 0) {\n        iVar1 = fcn.0044fded(unaff_retaddr);\n        *param_1 = iVar1;\n        iVar1 = (-(iVar1 != 0) & 0x7fffbffe) + 0x80004002;\n    }\n    else {\n        fcn.0044fea3();\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 153
    },
    "00450029": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00450029(int32_t param_1, uint param_2)\n\n{\n    (*_sym.imp.USER32.dll_wsprintfA)(param_2, \"Embedding %lu\", *(param_1 + 0x28));\n    return;\n}\n",
        "token_count": 60
    },
    "0045184e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0045184e(void)\n\n{\n    int32_t iVar1;\n    uint var_14h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    fcn.004501c9(&var_14h);\n    iVar1 = fcn.0040ee70(&var_14h, 0x475f8c, 0x10);\n    if (iVar1 != 0) {\n        fcn.004509fc(&var_14h);\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 129
    },
    "0045522a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.0045522a(code **param_1)\n\n{\n    code *pcVar1;\n    \n    fcn.00443728();\n    *param_1 = vtable.COleIPFrameWnd.0;\n    fcn.0040e620(param_1 + 0x35, 0, 0x14);\n    param_1[0x35] = 0x14;\n    pcVar1 = _sym.imp.USER32.dll_SetRectEmpty;\n    param_1[0x34] = NULL;\n    param_1[0x3a] = NULL;\n    param_1[0x3b] = NULL;\n    param_1[0x45] = NULL;\n    (*pcVar1)(param_1 + 0x46);\n    (*pcVar1)(param_1 + 0x4a);\n    param_1[0x4e] = NULL;\n    param_1[0x3e] = NULL;\n    param_1[0x3c] = NULL;\n    param_1[0x3d] = NULL;\n    param_1[0x4f] = NULL;\n    param_1[0x50] = NULL;\n    return param_1;\n}\n",
        "token_count": 271
    },
    "0045537d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0045537d(uint noname_0, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    int32_t *in_ECX;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar1 = (**(*in_ECX + 0x138))();\n    if (iVar1 != 0) {\n        (*_sym.imp.USER32.dll_CopyRect)(&var_10h, arg_ch);\n        uVar2 = (*_sym.imp.USER32.dll_GetParent)(in_ECX[7]);\n        fcn.004278de(uVar2);\n        fcn.00431e21(&var_10h);\n        fcn.00431de5(&var_10h);\n        piVar3 = fcn.0042a05b(0xe900);\n        var_20h = in_ECX[0x46];\n        var_1ch = in_ECX[0x47];\n        var_18h = in_ECX[0x48];\n        var_14h = in_ECX[0x49];\n        (**(*piVar3 + 0x68))(&var_20h, 1);\n        var_10h = var_10h + (in_ECX[0x46] - var_20h);\n        var_ch = var_ch + (in_ECX[0x47] - var_1ch);\n        var_8h = var_8h + (in_ECX[0x48] - var_18h);\n        var_4h = var_4h + (in_ECX[0x49] - var_14h);\n        (**(*in_ECX + 0x18c))(&var_10h);\n    }\n    return 0;\n}\n",
        "token_count": 452
    },
    "00455ce0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t fcn.00455ce0(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    iVar1 = fcn.0044accc();\n    if (iVar1 == 0) {\n        iVar2 = 0;\n    }\n    else {\n        piVar3 = fcn.0042c770();\n        iVar2 = (**(*piVar3 + 0xc))();\n        *(unaff_EBP + -0x14) = iVar2 + 0x10;\n        *(unaff_EBP + -4) = 0;\n        piVar3 = fcn.0042c770();\n        iVar2 = (**(*piVar3 + 0xc))();\n        *(unaff_EBP + -0x10) = iVar2 + 0x10;\n        *(unaff_EBP + -4) = 1;\n        piVar3 = fcn.0042c770();\n        iVar2 = (**(*piVar3 + 0xc))();\n        *(unaff_EBP + -0x18) = iVar2 + 0x10;\n        iVar2 = **(extraout_ECX + 0x4c);\n        *(unaff_EBP + -4) = 2;\n        iVar4 = (**(iVar2 + 100))(unaff_EBP + -0x14, 5);\n        iVar2 = 0;\n        if ((iVar4 != 0) && (*(*(unaff_EBP + -0x14) + -0xc) != 0)) {\n            iVar2 = (**(**(extraout_ECX + 0x4c) + 100))(unaff_EBP + -0x10, 6);\n            if (iVar2 == 0) {\n                fcn.004048c5(unaff_EBP + -0x14);\n            }\n            iVar2 = (**(**(extraout_ECX + 0x4c) + 100))(unaff_EBP + -0x18, 2);\n            if (iVar2 == 0) {\n                fcn.004048c5();\n            }\n            iVar4 = fcn.0045d3f0(extraout_ECX + 0x24, *(unaff_EBP + -0x14), *(unaff_EBP + -0x18), *(unaff_EBP + -0x10), \n                                 *(extraout_ECX + 0x47), 0, 0);\n            iVar2 = iVar1;\n            if (iVar4 == 0) {\n                iVar2 = 0;\n            }\n        }\n        fcn.00403164();\n        fcn.00403164();\n        fcn.00403164();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 766
    },
    "00457165": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00457165(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    if (*(param_1 + 0x1c) != 0) {\n        uVar1 = 0;\n        if (*(param_1 + 0x24) != 0) {\n            iVar2 = 0;\n            do {\n                (*_sym.imp.ole32.dll_CoTaskMemFree)(*(iVar2 + 4 + *(param_1 + 0x1c)));\n                (*_sym.imp.ole32.dll_ReleaseStgMedium)(iVar2 + 0x14 + *(param_1 + 0x1c));\n                uVar1 = uVar1 + 1;\n                iVar2 = iVar2 + 0x24;\n            } while (uVar1 < *(param_1 + 0x24));\n        }\n        fcn.00425d0d(*(param_1 + 0x1c));\n        *(param_1 + 0x1c) = 0;\n        *(param_1 + 0x20) = 0;\n        *(param_1 + 0x24) = 0;\n    }\n    return;\n}\n",
        "token_count": 269
    },
    "004571b6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint16_t * __cdecl fcn.004571b6(int16_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    int16_t *piVar2;\n    int32_t *piVar3;\n    int32_t in_ECX;\n    uint32_t uVar4;\n    int16_t *var_8h;\n    int32_t var_4h;\n    \n    uVar4 = 0;\n    var_8h = NULL;\n    if (*(in_ECX + 0x24) != 0) {\n        var_4h = 0;\n        do {\n            piVar2 = *(in_ECX + 0x1c) + var_4h;\n            if ((((*piVar2 == *arg_8h) && ((*(arg_8h + 8) & *(piVar2 + 8)) != 0)) && (*(piVar2 + 4) == *(arg_8h + 4)))\n               && (*(piVar2 + 0x10) == arg_ch)) {\n                piVar3 = *(arg_8h + 2);\n                piVar1 = *(piVar2 + 2);\n                var_8h = piVar2;\n                if (piVar1 != NULL) {\n                    if ((piVar3 == NULL) || (*piVar1 != *piVar3)) goto code_r0x00457220;\n                    piVar3 = fcn.0040ee70(piVar1, piVar3, *piVar1);\n                }\n                if (piVar3 == NULL) {\n                    return piVar2;\n                }\n            }\ncode_r0x00457220:\n            var_4h = var_4h + 0x24;\n            uVar4 = uVar4 + 1;\n        } while (uVar4 < *(in_ECX + 0x24));\n    }\n    return var_8h;\n}\n",
        "token_count": 421
    },
    "004573af": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004573af(code **param_1)\n\n{\n    code **extraout_ECX;\n    code *pcVar1;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    uint *puVar2;\n    uint *in_FS_OFFSET;\n    \n    pcVar1 = NULL;\n    *param_1 = vtable.CEnumFormatEtc.0;\n    if ((param_1[8] == NULL) && (param_1[0xb] != NULL)) {\n        puVar2 = param_1[9] + 4;\n        do {\n            (*_sym.imp.ole32.dll_CoTaskMemFree)(*puVar2);\n            pcVar1 = pcVar1 + 1;\n            puVar2 = puVar2 + 5;\n        } while (pcVar1 < param_1[0xb]);\n    }\n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CEnumArray.0;\n    pcVar1 = extraout_ECX[8];\n    *(unaff_EBP + -4) = 0;\n    if (pcVar1 != NULL) {\n        fcn.0044fd01(unaff_ESI, extraout_ECX);\n    }\n    if (extraout_ECX[0xc] != NULL) {\n        fcn.00425d0d(extraout_ECX[9]);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042aa3f();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 365
    },
    "00457416": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00457416(int32_t param_1, ushort *param_2)\n\n{\n    ushort *puVar1;\n    uint arg_8h;\n    \n    if (*(param_1 + 0x2c) == *(param_1 + 0x38)) {\n        arg_8h = fcn.00425ce2((*(param_1 + 0x2c) * 5 + 0x32) * 4);\n        *(param_1 + 0x38) = *(param_1 + 0x38) + 10;\n        fcn.0040e680(arg_8h, *(param_1 + 0x24), *(param_1 + 0x2c) * 0x14);\n        fcn.00425d0d(*(param_1 + 0x24));\n        *(param_1 + 0x24) = arg_8h;\n    }\n    puVar1 = *(param_1 + 0x24) + *(param_1 + 0x2c) * 0x14;\n    *puVar1 = *param_2;\n    *(puVar1 + 2) = *(param_2 + 2);\n    *(puVar1 + 4) = *(param_2 + 4);\n    *(puVar1 + 6) = *(param_2 + 6);\n    *(puVar1 + 8) = *(param_2 + 8);\n    *(param_1 + 0x2c) = *(param_1 + 0x2c) + 1;\n    return;\n}\n",
        "token_count": 355
    },
    "0045786c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045786c(uint arg_8h, int16_t *arg_ch)\n\n{\n    int32_t iVar1;\n    uint var_14h;\n    \n    if (arg_ch == NULL) {\n        arg_ch = fcn.0044df67(0, arg_8h, &var_14h);\n        *(arg_ch + 8) = 1;\n    }\n    if (arg_8h != 0) {\n        *arg_ch = arg_8h;\n    }\n    iVar1 = fcn.0045771e(arg_ch, 1);\n    fcn.0040e620(iVar1 + 0x14, 0, 0xc);\n    return;\n}\n",
        "token_count": 157
    },
    "00457b44": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __thiscall fcn.00457b44(int32_t param_1, uint param_2)\n\n{\n    uint32_t uVar1;\n    bool bVar2;\n    \n    uVar1 = *(param_1 + 0x28);\n    bVar2 = uVar1 < *(param_1 + 0x2c);\n    if (bVar2) {\n        fcn.0040e680(param_2, *(param_1 + 0x1c) * uVar1 + *(param_1 + 0x24), *(param_1 + 0x1c));\n        *(param_1 + 0x28) = *(param_1 + 0x28) + 1;\n    }\n    return bVar2;\n}\n",
        "token_count": 167
    },
    "0045a50a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045a50a(int32_t arg_8h, int32_t *arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t *in_ECX;\n    uint *puVar4;\n    int32_t var_54h;\n    int32_t iStack84;\n    int32_t iStack80;\n    int32_t iStack76;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    piVar3 = arg_ch;\n    var_4h = in_ECX;\n    if (arg_8h == 0) {\n        iVar1 = (**(*arg_ch + 0x14))(arg_ch, &var_14h);\n        if (iVar1 != 0) {\n            iVar1 = *piVar3;\n            puVar4 = NULL;\n            goto code_r0x0045a675;\n        }\n    }\n    else {\n        (*_sym.imp.USER32.dll_CopyRect)(&var_14h, arg_8h);\n    }\n    if (arg_10h == 0) {\n        iVar1 = *(in_ECX[0x30] + 0xf4);\n    }\n    else {\n        iVar1 = *(in_ECX[0x30] + 0xf0);\n    }\n    iVar2 = fcn.0042bc3d();\n    if (*(iVar2 + 0x20) == in_ECX[0x30]) {\n        (**(*in_ECX + 0x114))(iVar1, 1);\n    }\n    var_34h = var_14h;\n    var_30h = var_10h;\n    var_2ch = var_ch;\n    var_28h = var_8h;\n    fcn.00427cd7(0, 0xffff, 0, 1, &var_34h, &var_14h, 1);\n    var_54h = var_34h - var_14h;\n    iStack84 = var_30h - var_10h;\n    iStack80 = var_ch - var_2ch;\n    iStack76 = var_8h - var_28h;\n    var_24h = var_54h;\n    var_20h = iStack84;\n    var_1ch = iStack80;\n    var_18h = iStack76;\n    iVar2 = fcn.00404990();\n    piVar3 = arg_ch;\n    if (((iVar2 == 0) || (*(iVar1 + 0x8c) != 0)) && (iVar2 = (**(*arg_ch + 0x18))(arg_ch, &var_54h),  iVar2 == 0)) {\n        (**(*piVar3 + 0x1c))(piVar3, &var_24h);\n        fcn.00427cd7(0, 0xffff, 0, 0, 0, &var_14h, 1);\n        arg_ch = *(iVar1 + 0x84);\n        while (arg_ch != NULL) {\n            piVar3 = fcn.00403b8b(&arg_ch);\n            iVar1 = *piVar3;\n            iVar2 = fcn.00441d18();\n            if (iVar2 == 0) {\n                (*_sym.imp.USER32.dll_UpdateWindow)(*(iVar1 + 0x1c));\n            }\n        }\n        return;\n    }\n    (**(*var_4h + 0x114))(iVar1, 0);\n    iVar1 = *piVar3;\n    puVar4 = &var_44h;\n    var_44h = 0;\n    var_40h = 0;\n    var_3ch = 0;\n    var_38h = 0;\ncode_r0x0045a675:\n    (**(iVar1 + 0x1c))(piVar3, puVar4);\n    return;\n}\n",
        "token_count": 1002
    },
    "0045c532": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0045c532(uint *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    var_8h = in_ECX;\n    var_4h = in_ECX;\n    piVar1 = fcn.0044fd3f(0x47607c);\n    iVar2 = (**(*piVar1 + 0x20))(piVar1, 4, 3, &var_8h);\n    if (iVar2 != 0) {\n        return 0;\n    }\n    iVar2 = (*_sym.imp.ole32.dll_CreateStreamOnHGlobal)(0, 1, &var_4h);\n    if (iVar2 != 0) {\n        (**(*var_8h + 8))(var_8h);\n        fcn.004202f9();\n    }\n    iVar2 = (*_sym.imp.ole32.dll_OleSaveToStream)(var_8h, var_4h);\n    (**(*var_8h + 8))(var_8h);\n    if (iVar2 == 0) {\n        iVar2 = (*_sym.imp.ole32.dll_WriteClassStm)(var_4h, *(in_ECX[7] + 0x88) + 0x24);\n        if (iVar2 == 0) goto code_r0x0045c5d1;\n        (**(*var_4h + 8))(var_4h);\n    }\n    else {\n        (**(*var_4h + 8))(var_4h);\n    }\n    fcn.0044e402(iVar2);\ncode_r0x0045c5d1:\n    arg_8h[2] = 0;\n    *arg_8h = 4;\n    arg_8h[1] = var_4h;\n    return 1;\n}\n",
        "token_count": 439
    },
    "0045c5ec": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045c5ec(uint *arg_8h, uint *arg_ch, uint *arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint uVar2;\n    uint uVar3;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = fcn.0044fd3f(0x47607c);\n    uVar2 = 0;\n    uVar3 = 0;\n    if (arg_8h != NULL) {\n        var_14h = *arg_8h;\n        var_10h = arg_8h[1];\n        fcn.00445607(&var_14h);\n        uVar2 = var_14h;\n        uVar3 = var_10h;\n    }\n    if (arg_ch == NULL) {\n        var_ch = 0;\n        var_8h = 0;\n    }\n    else {\n        var_ch = *arg_ch;\n        var_8h = arg_ch[1];\n        fcn.00445607(&var_ch);\n    }\n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(in_ECX + 4);\n    iVar1 = fcn.0044e7dc(var_4h, 0, 1, uVar2, uVar3, &var_ch);\n    (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(in_ECX + 4);\n    if (iVar1 == 0) {\n        fcn.004202f9();\n    }\n    arg_10h[2] = 0;\n    arg_10h[1] = iVar1;\n    *arg_10h = 1;\n    return;\n}\n",
        "token_count": 398
    },
    "0045cbe4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.0045cbe4(uint *param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.00425ce2(param_2 << 2);\n    *param_1 = uVar1;\n    fcn.0040e620(uVar1, 0, param_2 << 2);\n    param_1[1] = param_2;\n    return param_1;\n}\n",
        "token_count": 105
    },
    "0045cd7d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0045cd7d(int32_t *param_1, uint8_t param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    \n    if (((-1 < param_3) && (param_3 < *(*param_1 + -0xc))) &&\n       (iVar1 = fcn.0040ef28(*param_1 + param_3, param_2),  iVar1 != 0)) {\n        return iVar1 - *param_1;\n    }\n    return -1;\n}\n",
        "token_count": 123
    },
    "0045e670": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.0045e670(uint8_t *param_1, uint16_t param_2)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = *(param_2 * 4 + 0x472ec0) + 4;\n    uVar1 = *param_1;\n    while (uVar1 != 0) {\n        if (uVar1 != 0xff) {\n            iVar3 = 0x472f18;\n            if ((uVar1 & 0x40) == 0) {\n                iVar3 = 0x472f70;\n            }\n            iVar2 = iVar2 + *(iVar3 + (uVar1 & 0xffffffbf) * 4);\n        }\n        param_1 = param_1 + 1;\n        uVar1 = *param_1;\n    }\n    return iVar2;\n}\n",
        "token_count": 204
    },
    "0045edfd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0045edfd(int32_t param_1, int32_t param_2, int16_t *param_3, uint *param_4)\n\n{\n    int32_t *piVar1;\n    int16_t iVar2;\n    ulong *puVar3;\n    uint uVar4;\n    int32_t iVar5;\n    \n    puVar3 = *(param_2 + 0x18) + param_1;\n    if (*(param_2 + 0xc) != 0xc) {\n        *param_3 = *(param_2 + 0xc);\n    }\n    // switch table (20 cases) at 0x45ee8f\n    switch(*(param_2 + 0xc)) {\n    case 2:\n    case 0x12:\n        iVar2 = *puVar3;\n        goto code_r0x0045ee61;\n    case 3:\n    case 4:\n    case 10:\n    case 0x13:\n        uVar4 = *puVar3;\n        goto code_r0x0045ee56;\n    case 5:\n    case 7:\n        *(param_3 + 4) = *puVar3;\n        break;\n    case 6:\n    case 0x14:\n    case 0x15:\n        *(param_3 + 4) = *puVar3;\n        *(param_3 + 6) = *(puVar3 + 4);\n        break;\n    case 8:\n        uVar4 = fcn.00449233();\ncode_r0x0045ee56:\n        *(param_3 + 4) = uVar4;\n        break;\n    case 9:\n    case 0xd:\n        piVar1 = *puVar3;\n        *(param_3 + 4) = piVar1;\n        if (piVar1 != NULL) {\n            (**(*piVar1 + 4))(piVar1);\n        }\n        break;\n    case 0xb:\n        iVar2 = -(*puVar3 != 0);\ncode_r0x0045ee61:\n        param_3[4] = iVar2;\n        break;\n    case 0xc:\n        iVar5 = (*_sym.imp.OLEAUT32.dll_VariantCopyInd)(param_3, puVar3);\n        if (iVar5 == 0) {\n            return;\n        }\n    default:\n        *param_4 = 0;\n        break;\n    case 0x10:\n    case 0x11:\n        *(param_3 + 4) = *puVar3;\n    }\n    return;\n}\n",
        "token_count": 565
    },
    "0045f730": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0045f730(code *param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint unaff_retaddr;\n    \n    *(param_2 + param_3) = unaff_retaddr;\n    *((param_2 + param_3) - param_3) = 0x45f740;\n    (*param_1)();\n    return;\n}\n",
        "token_count": 87
    },
    "004601ab": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004601ab(int32_t param_1, uint32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t unaff_ESI;\n    \n    *(param_1 + 0x110) = param_2;\n    uVar1 = *(*(**(param_1 + 0x130) + 0x70) + 0x1e);\n    if (uVar1 < param_2) {\n        *(param_1 + 0x110) = uVar1;\n    }\n    uVar1 = *(*(**(param_1 + 0x130) + 0x70) + 0x1c);\n    if (*(param_1 + 0x110) < uVar1) {\n        *(param_1 + 0x110) = uVar1;\n    }\n    if (*(param_1 + 0x108) == 0) {\n        fcn.00426df9(1, *(param_1 + 0x110), 1);\n    }\n    if (unaff_ESI != 0) {\n        uVar1 = 0;\n        if (*(param_1 + 0x10c) != 0) {\n            iVar2 = 0;\n            do {\n                *(*(param_1 + 0xac) + 0x18 + iVar2) = 0;\n                uVar1 = uVar1 + 1;\n                iVar2 = iVar2 + 0x28;\n            } while (uVar1 < *(param_1 + 0x10c));\n        }\n    }\n    (*_sym.imp.USER32.dll_InvalidateRect)(*(param_1 + 0x1c), 0, 1);\n    return;\n}\n",
        "token_count": 388
    },
    "00460ca1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00460ca1(int32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    uint var_ch;\n    \n    pcVar2 = _sym.imp.USER32.dll_ShowScrollBar;\n    if (*(in_ECX + 0x108) == 0) {\n        *(in_ECX + 0x114) = *(in_ECX + 0x104);\n        (*pcVar2)(*(in_ECX + 0x1c), 0);\n        if ((0x7fff < *(*(**(in_ECX + 0x130) + 0x70) + 0x1e)) ||\n           (iVar3 = *(**(in_ECX + 0x130) + 0x70),  arg_8h = 1,  0x7fff < *(iVar3 + 0x1e) - *(iVar3 + 0x1c))) {\n            arg_8h = 0;\n        }\n        (*pcVar2)(*(in_ECX + 0x1c), 1, arg_8h);\n        if (arg_8h != 0) {\n            var_18h = 3;\n            var_14h = *(*(**(in_ECX + 0x130) + 0x70) + 0x1c);\n            var_10h = *(*(**(in_ECX + 0x130) + 0x70) + 0x1e);\n            var_ch = 1;\n            iVar3 = fcn.00426122(1, &var_1ch, 0);\n            if (iVar3 == 0) {\n                fcn.00426e51(1, var_14h, var_10h, 0);\n            }\n        }\n        fcn.004601ab(*(in_ECX + 0x110), 1);\n    }\n    else {\n        iVar3 = *(in_ECX + 0xac);\n        *(in_ECX + 0x114) = 1;\n        iVar4 = arg_8h * 0x28;\n        *(iVar3 + 0x20) = *(iVar3 + 0x20 + iVar4);\n        *(iVar3 + 0x24) = *(iVar3 + 0x24 + iVar4);\n        iVar3 = *(in_ECX + 0xac);\n        *(iVar3 + 0x10) = *(iVar3 + 0x10 + iVar4);\n        *(iVar3 + 0x14) = *(iVar3 + 0x14 + iVar4);\n        fcn.004601ab(*(in_ECX + 0x110) + arg_8h, 0);\n        fcn.0045fed1(0);\n        pcVar2 = _sym.imp.KERNEL32.dll_MulDiv;\n        puVar1 = iVar4 + 0x18 + *(in_ECX + 0xac);\n        iVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(arg_ch, *puVar1, puVar1[1]);\n        iVar4 = (*pcVar2)(arg_10h, *puVar1, puVar1[1]);\n        fcn.0043551e(iVar3 + **(in_ECX + 0xac), iVar4 + (*(in_ECX + 0xac))[1]);\n    }\n    return;\n}\n",
        "token_count": 801
    },
    "00460e33": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_48h\n// WARNING: Variable defined which should be unmapped: var_3ch\n// WARNING: Variable defined which should be unmapped: var_44h\n\nuint __cdecl fcn.00460e33(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint uVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_48h;\n    uint var_44h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    piVar1 = fcn.00428388();\n    iVar2 = fcn.0042c6eb(0x469824, piVar1);\n    if (iVar2 == 0) {\n        piVar1 = fcn.004049c2();\n    }\n    fcn.0040e620(unaff_EBP + -0x48, 0, 0x14);\n    uVar4 = *(extraout_ECX + 0x50);\n    *(unaff_EBP + -0x38) = piVar1;\n    *(unaff_EBP + -0x44) = uVar4;\n    *(unaff_EBP + -0x3c) = extraout_ECX;\n    piVar3 = fcn.0042c660();\n    if (piVar3 != NULL) {\n        iVar2 = *(unaff_EBP + 0x14);\n        piVar3[0x29] = iVar2;\n        (**(*piVar1 + 0x14c))(1, iVar2);\n        iVar2 = fcn.00425ce2(0xa0);\n        *(unaff_EBP + 0x10) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            iVar2 = 0;\n        }\n        else {\n            iVar2 = fcn.004411cb();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        piVar3[0x2a] = iVar2;\n        uVar4 = (**(*piVar1 + 0x13c))();\n        iVar2 = fcn.0042c6eb(0x468ccc, uVar4);\n        *(unaff_EBP + 0x10) = iVar2;\n        if (iVar2 == 0) {\n            iVar2 = (**(*piVar3[0x2a] + 0x168))(piVar1, *(unaff_EBP + 8), 0x2800, 0xe802);\n            if (iVar2 == 0) goto code_r0x00460f11;\n            *(piVar3[0x2a] + 0x54) = 1;\ncode_r0x0046104c:\n            iVar2 = *piVar3;\n            *(unaff_EBP + -0x24) = 0;\n            *(unaff_EBP + -0x20) = 0;\n            *(unaff_EBP + -0x1c) = 0;\n            *(unaff_EBP + -0x18) = 0;\n            iVar2 = (**(iVar2 + 0x54))(0, 0, 0x50800000, unaff_EBP + -0x24, piVar1, 0xe900, unaff_EBP + -0x48);\n            if (iVar2 != 0) {\n                uVar4 = fcn.00441c1e();\n                *(*(unaff_EBP + 0x14) + 0xc) = uVar4;\n                (**(*piVar1 + 0x13c))();\n                piVar5 = fcn.00441c1e();\n                if (piVar5 != NULL) {\n                    (**(*piVar5 + 0x15c))(0, piVar5, piVar5);\n                }\n                iVar2 = fcn.00460402(*(unaff_EBP + 0xc));\n                if (iVar2 == 0) {\n                    fcn.0045fd41();\n                }\n                else {\n                    fcn.00441c25(piVar3, 1);\n                    (*_sym.imp.USER32.dll_SendMessageA)(*(piVar3[0x2a] + 0x1c), 0x363, 1, 0);\n                    (**(*piVar1 + 0x144))(1);\n                    (*_sym.imp.USER32.dll_UpdateWindow)(piVar1[7]);\n                }\n                uVar4 = 1;\n                goto code_r0x00461116;\n            }\n            (**(*piVar1 + 0x14c))(0, *(unaff_EBP + 0x14));\n        }\n        else {\n            piVar5 = fcn.0042c6eb(0x46c7d4, *(*(unaff_EBP + -0x10) + 0x50));\n            *(unaff_EBP + -0x14) = piVar5;\n            if (piVar5 != NULL) {\n                iVar2 = *(*(unaff_EBP + 0x10) + 0xf4);\n                *(unaff_EBP + -0x10) = iVar2;\n                if (iVar2 == 0) {\n                    *(unaff_EBP + -0x10) = *(*(unaff_EBP + 0x10) + 0xf0);\n                }\n                (**(*piVar5 + 0x110))(0);\n                if (*(unaff_EBP + -0x10) != 0) {\n                    iVar2 = (**(*piVar3[0x2a] + 0x168))(*(unaff_EBP + -0x10), *(unaff_EBP + 8), 0x2800, 0xe802);\n                    if (iVar2 != 0) {\n                        uVar4 = *(unaff_EBP + 0x10);\n                        *(piVar3[0x2a] + 0x54) = 1;\n                        fcn.00449c68(uVar4);\n                        *(unaff_EBP + -0x10) = 0;\n                        *(unaff_EBP + 8) = 0;\n                        iVar2 = unaff_EBP + 8;\n                        *(unaff_EBP + -4) = 1;\n                        iVar6 = fcn.00408021();\n                        if (iVar6 < 0) {\n                            iVar2 = unaff_EBP + 8;\n                            fcn.00407ff5();\n                            *(unaff_EBP + -0x10) = 1;\n                        }\n                        piVar5 = *(unaff_EBP + 8);\n                        if (piVar5 != NULL) {\n                            (**(*piVar5 + 0x14))(piVar5, unaff_EBP + -0x34, iVar2);\n                            (**(**(unaff_EBP + -0x14) + 300))(unaff_EBP + -0x34, *(unaff_EBP + 8), *(unaff_EBP + -0x10))\n                            ;\n                            piVar5 = *(unaff_EBP + 8);\n                        }\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        *(*(unaff_EBP + 0x10) + 0x13c) = 1;\n                        if (piVar5 != NULL) {\n                            (**(*piVar5 + 8))(piVar5);\n                        }\n                        goto code_r0x0046104c;\n                    }\n                }\n            }\ncode_r0x00460f11:\n            (**(*piVar1 + 0x14c))(0, *(unaff_EBP + 0x14));\n            if (piVar3[0x2a] != NULL) {\n                (**(*piVar3[0x2a] + 4))(1);\n            }\n            piVar3[0x2a] = 0;\n        }\n        piVar3[0x29] = 0;\n        (**(*piVar3 + 4))(1);\n    }\n    uVar4 = 0;\ncode_r0x00461116:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar4;\n}\n",
        "token_count": 1947
    },
    "0046156c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool fcn.0046156c(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar1 = fcn.0044c3a2(0x4613e0);\n    while ((*(iVar1 + 4) == 0 &&\n           (iVar2 = (*_sym.imp.USER32.dll_PeekMessageA)(&stack0xffffffe0, 0, 0, 0, 0),  iVar2 != 0))) {\n        iVar2 = fcn.0042c09c();\n        if (iVar2 == 0) {\n            return false;\n        }\n    }\n    return *(iVar1 + 4) == 0;\n}\n",
        "token_count": 152
    },
    "004625c4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004625c4(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int64_t iVar7;\n    int64_t iVar8;\n    int64_t iVar9;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar8 = arg_ch * arg_10h;\n    iVar4 = iVar8 >> 0x20;\n    iVar1 = iVar8;\n    iVar7 = arg_14h * arg_18h;\n    iVar5 = iVar7 >> 0x20;\n    iVar9 = iVar8;\n    if ((iVar4 == 0 || iVar8 < 0) && (iVar8 < 0)) {\n        iVar9 = CONCAT44(-(iVar4 + (iVar1 != 0)), -iVar1);\n    }\n    iVar6 = 0;\n    while (iVar9 != 0) {\n        iVar9 = fcn.00410ab0();\n        iVar6 = iVar6 + 1;\n    }\n    iVar2 = arg_8h;\n    if (arg_8h < 0) {\n        iVar2 = -arg_8h;\n    }\n    arg_ch = 0;\n    iVar9 = iVar2;\n    while (iVar9 != 0) {\n        iVar9 = fcn.00410ab0();\n        arg_ch = arg_ch + 1;\n    }\n    iVar6 = iVar6 + arg_ch;\n    if ((iVar5 == 0 || iVar7 < 0) && (iVar7 < 0)) {\n        iVar7 = CONCAT44(-(iVar5 + (iVar7 != 0)), -iVar7);\n        iVar8 = CONCAT44(-(iVar4 + (iVar1 != 0)), -iVar1);\n    }\n    while (0x1f < iVar6) {\n        iVar8 = fcn.00410ab0();\n        iVar7 = fcn.00410ab0();\n        iVar1 = iVar6 + -2;\n        if (iVar6 + -1 < 0x20) break;\n        iVar8 = fcn.00410ab0();\n        iVar7 = fcn.00410ab0();\n        iVar6 = iVar6 + -3;\n        if (iVar1 < 0x20) break;\n        arg_8h = arg_8h >> 1;\n        iVar7 = fcn.00410ab0();\n    }\n    iVar8 = fcn.0040f9b0(arg_8h, arg_8h >> 0x1f, iVar8);\n    if (iVar7 == 0) {\n        if ((iVar8 < 0x100000000) && (iVar8 < 0)) {\n            uVar3 = 0x80000000;\n        }\n        else {\n            uVar3 = 0x7fffffff;\n        }\n    }\n    else {\n        iVar9 = fcn.00410a00(iVar7, 2, 0);\n        uVar3 = fcn.00410a00(iVar9 + iVar8, iVar7);\n    }\n    return uVar3;\n}\n",
        "token_count": 726
    },
    "00462826": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00462826(int32_t arg_8h, uint32_t arg_ch, int32_t *arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    uint32_t uVar1;\n    \n    arg_8h = arg_8h - arg_14h;\n    uVar1 = 0;\n    if (arg_ch != 0) {\n        do {\n            if (*arg_10h != arg_8h && arg_8h <= *arg_10h) {\n                arg_18h = *arg_10h;\n                goto code_r0x0046284f;\n            }\n            uVar1 = uVar1 + 1;\n            arg_10h = arg_10h + 1;\n        } while (uVar1 < arg_ch);\n    }\n    arg_18h = (arg_8h / arg_18h + 1) * arg_18h;\ncode_r0x0046284f:\n    return arg_18h + arg_14h;\n}\n",
        "token_count": 235
    },
    "00463400": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00463400(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t nRightRect;\n    int32_t nBottomRect;\n    \n    pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n    nRightRect = param_1;\n    nBottomRect = param_1;\n    iVar2 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(*(param_1 + 8), 10);\n    nRightRect = (*pcVar1)(*(param_1 + 8), 8);\n    nBottomRect = iVar2;\n    fcn.00463110(&nRightRect);\n    (*_sym.imp.GDI32.dll_SetMapMode)(*(param_1 + 4), 1);\n    (*_sym.imp.GDI32.dll_SetWindowOrgEx)(*(param_1 + 4), 0, 0, 0);\n    (*_sym.imp.GDI32.dll_SetViewportOrgEx)(*(param_1 + 4), *(param_1 + 0x20), *(param_1 + 0x24), 0);\n    (*_sym.imp.GDI32.dll_IntersectClipRect)(*(param_1 + 4), 0xffffffff, 0xffffffff, nRightRect + 2, nBottomRect + 2);\n    fcn.00463308(0);\n    return;\n}\n",
        "token_count": 309
    },
    "004637ea": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop",
            "set application hook"
        ],
        "decompiled_code": "\nvoid fcn.004637ea(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    char *arg_8h;\n    \n    iVar2 = fcn.0044be10();\n    fcn.0044ca10(1);\n    arg_8h = iVar2 + 0x34;\n    while (*arg_8h != '\\0') {\n        puVar3 = fcn.0040ef28(arg_8h, 10);\n        *puVar3 = 0;\n        iVar4 = fcn.0044be10();\n        (*_sym.imp.USER32.dll_UnregisterClassA)(arg_8h, *(iVar4 + 8));\n        arg_8h = puVar3 + 1;\n    }\n    *(iVar2 + 0x34) = '\\0';\n    fcn.0044ca73(1);\n    iVar2 = fcn.0044be10();\n    if ((*(iVar2 + 4) != 0) && (pcVar1 = *(*(iVar2 + 4) + 0x38),  pcVar1 != NULL)) {\n        (*pcVar1)(1, 0);\n    }\n    iVar2 = fcn.0044be36();\n    if (*(iVar2 + 0x3c) != NULL) {\n        iVar4 = (**(**(iVar2 + 0x3c) + 0x138))();\n        if (iVar4 != 0) {\n            *(iVar2 + 0x3c) = 0;\n        }\n    }\n    iVar2 = fcn.0044bde5();\n    iVar4 = fcn.0044be10();\n    pcVar1 = _sym.imp.USER32.dll_UnhookWindowsHookEx;\n    if (*(iVar4 + 0x14) == '\\0') {\n        if (*(iVar2 + 0x2c) != 0) {\n            (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar2 + 0x2c));\n            *(iVar2 + 0x2c) = 0;\n        }\n        if (*(iVar2 + 0x28) != 0) {\n            (*pcVar1)(*(iVar2 + 0x28));\n            *(iVar2 + 0x28) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 519
    },
    "00401b4b": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401b4b(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_1ch;\n    uint var_4h;\n    \n    pcVar1 = fcn.00401a98(0x467f84);\n    if (arg_8h == 0) {\n        iVar2 = 0;\n    }\n    else {\n        iVar3 = (*pcVar1)(0xfde9, 0, arg_8h, 0xffffffff, 0, 0, 0, 0);\n        if ((iVar3 == 0) || (iVar2 = fcn.0040d946(iVar3 + 1),  iVar2 == 0)) {\n            iVar2 = 0;\n        }\n        else {\n            (*pcVar1)(0xfde9, 0, arg_8h, 0xffffffff, iVar2, iVar3, 0, 0);\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 233
    },
    "0040b30e": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040b30e(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    uint var_24h;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_8h = 0;\n    var_4h = 0;\n    var_14h = 0;\n    var_10h = 0;\n    var_ch = fcn.0040f7b7(arg_8h);\n    puVar1 = fcn.0040b174(&var_24h, 10000);\n    var_ch = *puVar1;\n    var_8h = puVar1[1];\n    var_4h = puVar1[2];\n    if (arg_8h < 0) {\n        puVar1 = fcn.0040b12e(&var_24h);\n        var_ch = *puVar1;\n        var_8h = puVar1[1];\n        var_4h = puVar1[2];\n    }\n    var_18h = fcn.0040f7b7(arg_ch);\n    if (arg_ch < 0) {\n        puVar1 = fcn.0040b12e(&var_24h);\n        var_18h = *puVar1;\n        var_14h = puVar1[1];\n        var_10h = puVar1[2];\n    }\n    uVar2 = fcn.0040b024(&var_24h, &var_18h);\n    fcn.0040a038(uVar2);\n    *(in_ECX + 8) = 0;\n    return;\n}\n",
        "token_count": 408
    },
    "00421da3": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421da3(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    \n    var_24h = arg_8h;\n    var_28h = 0x18;\n    var_1ch = 0xf000;\n    var_20h = ((arg_ch != 0) + 1) * 0x1000;\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x110d, 0, &var_28h);\n    return;\n}\n",
        "token_count": 162
    },
    "00426ef9": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00426ef9(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint var_24h;\n    int32_t var_14h;\n    uint var_8h;\n    int32_t var_4h;\n    \n    fcn.00426e86(arg_8h, &var_8h, &var_4h);\n    iVar1 = fcn.0042615f(arg_8h, &var_24h, 2);\n    if (iVar1 != 0) {\n        var_4h = var_4h - (-(var_14h != 1) & var_14h - 1U);\n    }\n    return var_4h;\n}\n",
        "token_count": 161
    },
    "00428a8a": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00428a8a(uint noname_0, uint *hWnd, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint var_ch;\n    uint *var_8h;\n    uint32_t var_4h;\n    \n    uVar3 = *hWnd;\n    var_4h = (*_sym.imp.USER32.dll_GetDlgCtrlID)(uVar3);\n    var_4h = var_4h & 0xffff;\n    uVar1 = hWnd[2];\n    iVar2 = fcn.0044c776(0x448a07);\n    if ((*(iVar2 + 0xdc) != in_ECX[7]) && (iVar2 = fcn.00428485(uVar3, arg_10h),  iVar2 == 0)) {\n        var_ch = arg_10h;\n        var_8h = hWnd;\n        uVar3 = (**(*in_ECX + 0xc))(var_4h, uVar1 & 0xffff | 0x4e0000, &var_ch, 0);\n        return uVar3;\n    }\n    return 1;\n}\n",
        "token_count": 276
    },
    "0042c660": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_14h\n\nuint fcn.0042c660(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    uVar2 = 0;\n    iVar1 = *(extraout_ECX + 0xc);\n    *(unaff_EBP + -0x10) = &var_14h;\n    if (iVar1 != 0) {\n        *(unaff_EBP + -0x14) = 0;\n        *(unaff_EBP + -4) = 0;\n        uVar2 = (**(extraout_ECX + 0xc))();\n        *(unaff_EBP + -0x14) = uVar2;\n        uVar2 = *(unaff_EBP + -0x14);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 272
    },
    "0042f8b3": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0042f8b3(uint arg_8h, int32_t lpFileTime)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    ushort *puVar3;\n    uint uVar4;\n    uint *puStack44;\n    uint lpSystemTime;\n    uint var_12h;\n    ushort var_eh;\n    ushort var_ch;\n    ushort var_ah;\n    uint lpLocalFileTime;\n    \n    if (lpFileTime == 0) {\n        puStack44 = 0x497978;\n        fcn.0040ed8d(&stack0xffffffd4, 0x47c05c);\n        pcVar1 = swi(3);\n        (*pcVar1)();\n        return;\n    }\n    lpSystemTime._0_2_ = fcn.00408d33();\n    lpSystemTime._2_2_ = fcn.00408d4a();\n    puStack44 = 0x42f8e6;\n    iVar2 = fcn.0041076b(arg_8h);\n    if (iVar2 == 0) {\n        var_12h._0_2_ = 0;\n    }\n    else {\n        var_12h._0_2_ = *(iVar2 + 0xc);\n    }\n    var_12h._2_2_ = fcn.00408d6f();\n    var_eh = fcn.00408d82();\n    puStack44 = 0x42f915;\n    puVar3 = fcn.0041076b(arg_8h);\n    if (puVar3 == NULL) {\n        var_ch = 0xffff;\n    }\n    else {\n        var_ch = *puVar3;\n    }\n    puStack44 = &fcn.0042f8b3::lpSystemTime;\n    var_ah = 0;\n    iVar2 = (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)();\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar2 == 0) {\n        puStack44 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n        fcn.004301a1();\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_LocalFileTimeToFileTime)(&fcn.0042f8b3::lpLocalFileTime, lpFileTime);\n    if (iVar2 == 0) {\n        uVar4 = (*pcVar1)(0);\n        fcn.004301a1(uVar4);\n    }\n    return;\n}\n",
        "token_count": 564
    },
    "00435d55": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00435d55(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    *(in_ECX + 0x58) = 0xffffffff;\n    *(in_ECX + 0x5c) = arg_8h;\n    *(in_ECX + 0x60) = arg_ch;\n    if (*(in_ECX + 0x1c) != 0) {\n        uVar1 = fcn.0042a1c5();\n        if ((uVar1 & 0x300000) != 0) {\n            fcn.00426df9(0, 0, 1);\n            fcn.00426df9(1, 0, 1);\n            fcn.00426eb6(3, 0);\n        }\n    }\n    (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lpRect);\n    *(in_ECX + 100) = var_8h - lpRect;\n    *(in_ECX + 0x68) = var_4h - var_ch;\n    if (*(in_ECX + 0x1c) != 0) {\n        fcn.004356f0();\n        (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), 0, 1);\n    }\n    return;\n}\n",
        "token_count": 349
    },
    "00436750": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get graphical window text"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00436750(uint hWnd, uint lpString2)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint lpString1;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString2);\n    if (uVar1 < 0x101) {\n        uVar2 = (*_sym.imp.USER32.dll_GetWindowTextA)(hWnd, &lpString1, 0x100);\n        if (uVar2 == uVar1) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(&lpString1, lpString2);\n            if (iVar3 == 0) goto code_r0x004367ab;\n        }\n    }\n    (*_sym.imp.USER32.dll_SetWindowTextA)(hWnd, lpString2);\ncode_r0x004367ab:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 231
    },
    "00439862": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00439862(uint arg_8h, int32_t *arg_ch)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    uint uVar3;\n    uint uVar4;\n    uint uVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    uint var_18h;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar6 = *(in_ECX + 0xa8);\n    puVar1 = in_ECX + 0xac;\n    uVar2 = *puVar1;\n    uVar3 = *(in_ECX + 0xb0);\n    uVar4 = *(in_ECX + 0xb4);\n    uVar5 = *(in_ECX + 0xb8);\n    *(in_ECX + 0xa8) = *arg_ch == 0;\n    (*_sym.imp.USER32.dll_CopyRect)(puVar1, arg_ch + 1);\n    fcn.00438e46(arg_8h, arg_ch);\n    *puVar1 = uVar2;\n    *(in_ECX + 0xb0) = uVar3;\n    *(in_ECX + 0xb4) = uVar4;\n    *(in_ECX + 0xb8) = uVar5;\n    *(in_ECX + 0xa8) = uVar6;\n    return;\n}\n",
        "token_count": 308
    },
    "0043c4ea": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t fcn.0043c4ea(int32_t *param_1, int32_t param_2, int32_t param_3)\n\n{\n    if ((param_2 < *param_1) || (param_3 = (param_1[2] - param_2) - param_3,  param_3 < param_1[3])) {\n        param_3 = -1;\n    }\n    return param_3;\n}\n",
        "token_count": 99
    },
    "00441fbf": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00441fbf(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar1 = fcn.0042c660();\n    if (piVar1 != NULL) {\n        var_14h = 0;\n        var_10h = 0;\n        var_ch = 0;\n        var_8h = 0;\n        iVar2 = (**(*piVar1 + 0x54))(0, 0, 0x50800000, &var_14h, var_4h, arg_ch, arg_8h);\n        if (iVar2 != 0) {\n            uVar3 = fcn.0042a1df();\n            if ((uVar3 & 0x200) == 0) {\n                return piVar1;\n            }\n            fcn.0042a223(0x200, 0, 0x20);\n            return piVar1;\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 271
    },
    "004425b1": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004425b1(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    uint32_t uVar6;\n    uint var_10ch;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    uVar3 = (*_sym.imp.USER32.dll_SetActiveWindow)(*(in_ECX + 0x1c));\n    fcn.004278de(uVar3);\n    pcVar2 = _sym.imp.SHELL32.dll_DragQueryFileA;\n    uVar6 = 0;\n    uVar4 = (*_sym.imp.SHELL32.dll_DragQueryFileA)(arg_8h, 0xffffffff, 0, 0);\n    iVar5 = fcn.0044be10();\n    piVar1 = *(iVar5 + 4);\n    if (uVar4 != 0) {\n        do {\n            (*pcVar2)(arg_8h, uVar6, &var_108h, 0x104);\n            (**(*piVar1 + 0x88))(&var_108h);\n            uVar6 = uVar6 + 1;\n        } while (uVar6 < uVar4);\n    }\n    (*_sym.imp.SHELL32.dll_DragFinish)(arg_8h);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 343
    },
    "00442776": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00442776(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint var_214h;\n    uint var_210h;\n    uint var_20ch;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    sub.USER32.dll_UnpackDDElParam(1000, arg_ch, &var_214h, &var_210h);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(var_210h);\n    uVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(uVar1);\n    if (uVar2 < 0x208) {\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(var_210h);\n        uVar1 = sub.USER32.dll_ReuseDDElParam(arg_ch, 1000, 0x3e4, 0x8000, var_210h);\n        (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x3e4, *(in_ECX + 0x1c), uVar1);\n        iVar3 = fcn.0042a30b();\n        if (iVar3 != 0) {\n            iVar3 = fcn.0044be10();\n            (**(**(iVar3 + 4) + 0xa0))(&var_20ch);\n        }\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 347
    },
    "004430e9": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004430e9(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t *in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (in_ECX[0x31] == 0) {\n        uVar1 = in_ECX[0x33];\n        in_ECX[0x31] = 1;\n        if ((uVar1 & 4) != 0) {\n            arg_8h = 1;\n        }\n        in_ECX[0x33] = uVar1 & 0xfffffff3;\n        if ((arg_8h != 0) && (in_ECX[0x1f] != NULL)) {\n            (**(*in_ECX[0x1f] + 0x50))();\n        }\n        uVar1 = fcn.0042a1c5();\n        if ((uVar1 & 0x2000) == 0) {\n            fcn.00427cd7(0, 0xffff, 0xe900, 2, in_ECX + 0x1b, 0, 1);\n        }\n        else {\n            var_8h = 0x7fff;\n            var_4h = 0x7fff;\n            var_10h = 0;\n            var_ch = 0;\n            fcn.00427cd7(0, 0xffff, 0xe900, 1, &var_10h, &var_10h, 0);\n            fcn.00427cd7(0, 0xffff, 0xe900, 2, in_ECX + 0x1b, &var_10h, 1);\n            (**(*in_ECX + 0x68))(&var_10h, 0);\n            fcn.0042a4e3(0, 0, 0, var_8h - var_10h, var_4h - var_ch, 0x16);\n        }\n        in_ECX[0x31] = 0;\n    }\n    return;\n}\n",
        "token_count": 488
    },
    "004457f8": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lprcSrc1\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_3ch\n// WARNING: Variable defined which should be unmapped: var_40h\n\nvoid __cdecl\nfcn.004457f8(uint lprcSrc2, uint dx, uint dy, uint lprcSrc, uint arg_18h, uint arg_1ch, uint arg_20h, uint arg_24h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lprcSrc1;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x30) = 0;\n    *(unaff_EBP + -0x34) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x28) = 0;\n    *(unaff_EBP + -0x2c) = vtable.CRgn.0;\n    *(unaff_EBP + -0x20) = 0;\n    *(unaff_EBP + -0x24) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 2;\n    fcn.00407ea5(*(unaff_EBP + 8));\n    (*_sym.imp.USER32.dll_CopyRect)(unaff_EBP + -0x44, *(unaff_EBP + 8));\n    (*_sym.imp.USER32.dll_InflateRect)(unaff_EBP + -0x44, -*(unaff_EBP + 0xc), -*(unaff_EBP + 0x10));\n    (*_sym.imp.USER32.dll_IntersectRect)(unaff_EBP + -0x44, unaff_EBP + -0x44, *(unaff_EBP + 8));\n    uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgnIndirect)(unaff_EBP + -0x44);\n    fcn.0043242b(uVar2);\n    uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgn)(0, 0, 0, 0);\n    fcn.0043242b(uVar2);\n    fcn.00407ed9(unaff_EBP + -0x2c, unaff_EBP + -0x24, 3);\n    if (*(unaff_EBP + 0x20) == 0) {\n        uVar2 = fcn.00445759();\n        *(unaff_EBP + 0x20) = uVar2;\n    }\n    if (*(unaff_EBP + 0x24) == 0) {\n        *(unaff_EBP + 0x24) = *(unaff_EBP + 0x20);\n    }\n    *(unaff_EBP + -0x18) = 0;\n    *(unaff_EBP + -0x1c) = vtable.CRgn.0;\n    *(unaff_EBP + -0x10) = 0;\n    *(unaff_EBP + -0x14) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 4;\n    pcVar1 = _sym.imp.GDI32.dll_CreateRectRgn;\n    if (*(unaff_EBP + 0x14) != 0) {\n        uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgn)(0, 0, 0, 0);\n        fcn.0043242b(uVar2);\n        fcn.00407ebe(*(unaff_EBP + 0x14));\n        (*_sym.imp.USER32.dll_CopyRect)(unaff_EBP + -0x44, *(unaff_EBP + 0x14));\n        (*_sym.imp.USER32.dll_InflateRect)(unaff_EBP + -0x44, -*(unaff_EBP + 0x18), -*(unaff_EBP + 0x1c));\n        (*_sym.imp.USER32.dll_IntersectRect)(unaff_EBP + -0x44, unaff_EBP + -0x44, *(unaff_EBP + 0x14));\n        fcn.00407ebe(unaff_EBP + -0x44);\n        fcn.00407ed9(unaff_EBP + -0x2c, unaff_EBP + -0x24, 3);\n        if (*(*(unaff_EBP + 0x20) + 4) == *(*(unaff_EBP + 0x24) + 4)) {\n            uVar2 = (*pcVar1)(0, 0, 0, 0);\n            fcn.0043242b(uVar2);\n            fcn.00407ed9(unaff_EBP + -0x1c, unaff_EBP + -0x34, 3);\n        }\n    }\n    pcVar1 = _sym.imp.GDI32.dll_PatBlt;\n    if ((*(*(unaff_EBP + 0x20) + 4) != *(*(unaff_EBP + 0x24) + 4)) && (*(unaff_EBP + 0x14) != 0)) {\n        fcn.00431d59(unaff_EBP + -0x1c);\n        (**(*extraout_ECX + 0x50))(unaff_EBP + -0x44);\n        uVar2 = fcn.0043257f(*(unaff_EBP + 0x24));\n        *(unaff_EBP + 0x14) = uVar2;\n        (*pcVar1)(extraout_ECX[1], *(unaff_EBP + -0x44), *(unaff_EBP + -0x40), \n                  *(unaff_EBP + -0x3c) - *(unaff_EBP + -0x44), *(unaff_EBP + -0x38) - *(unaff_EBP + -0x40), 0x5a0049);\n        fcn.0043257f(*(unaff_EBP + 0x14));\n    }\n    iVar3 = unaff_EBP + -0x14;\n    if (*(unaff_EBP + -0x10) == 0) {\n        iVar3 = unaff_EBP + -0x34;\n    }\n    fcn.00431d59(iVar3);\n    (**(*extraout_ECX + 0x50))(unaff_EBP + -0x44);\n    uVar2 = fcn.0043257f(*(unaff_EBP + 0x20));\n    *(unaff_EBP + 0x14) = uVar2;\n    (*pcVar1)(extraout_ECX[1], *(unaff_EBP + -0x44), *(unaff_EBP + -0x40), *(unaff_EBP + -0x3c) - *(unaff_EBP + -0x44), \n              *(unaff_EBP + -0x38) - *(unaff_EBP + -0x40), 0x5a0049);\n    if (*(unaff_EBP + 0x14) != 0) {\n        fcn.0043257f(*(unaff_EBP + 0x14));\n    }\n    fcn.00431d59(0);\n    *(unaff_EBP + -4) = 3;\n    *(unaff_EBP + -0x14) = vtable.CGdiObject.0;\n    fcn.00432482();\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + -0x1c) = vtable.CGdiObject.0;\n    fcn.00432482();\n    *(unaff_EBP + -4) = 1;\n    *(unaff_EBP + -0x24) = vtable.CGdiObject.0;\n    fcn.00432482();\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x2c) = vtable.CGdiObject.0;\n    fcn.00432482();\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(unaff_EBP + -0x34) = vtable.CGdiObject.0;\n    fcn.00432482();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 1991
    },
    "00445b47": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00445b47(uint *arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint var_54h;\n    uint var_50h;\n    int32_t var_4ch;\n    uint var_48h;\n    int32_t var_44h;\n    int32_t var_40h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    if (arg_ch == 0) {\n        uVar2 = (*_sym.imp.USER32.dll_GetDC)(0);\n    }\n    else {\n        uVar2 = *(arg_ch + 8);\n    }\n    puVar4 = &var_40h;\n    for (iVar3 = 0xf; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = *arg_8h;\n        arg_8h = arg_8h + 1;\n        puVar4 = puVar4 + 1;\n    }\n    iVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(uVar2, 0x5a);\n    pcVar1 = _sym.imp.GDI32.dll_DPtoLP;\n    var_44h = (iVar3 * var_40h) / 0x2d0;\n    var_48h = 0;\n    (*_sym.imp.GDI32.dll_DPtoLP)(uVar2, &var_48h, 1);\n    var_50h = 0;\n    var_4ch = 0;\n    (*pcVar1)(uVar2, &var_50h, 1);\n    var_40h = fcn.0040f7b7(var_44h - var_4ch);\n    var_40h = -var_40h;\n    if (arg_ch == 0) {\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar2);\n    }\n    fcn.004031bd(&var_40h);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 473
    },
    "0044794c": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0044794c(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    uint uVar3;\n    uint uVar4;\n    uint uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint uVar8;\n    uint uVar9;\n    int32_t *in_ECX;\n    uint var_18h;\n    uint var_8h;\n    uint lpPoints;\n    \n    uVar6 = *(arg_ch + 0x14);\n    puVar1 = arg_ch + 0x24;\n    uVar2 = *puVar1;\n    uVar3 = *(arg_ch + 0x28);\n    uVar4 = *(arg_ch + 0x2c);\n    uVar5 = *(arg_ch + 0x30);\n    (**(*arg_8h + 0x1c))();\n    fcn.004316f6(0, 0, 0, 0);\n    uVar7 = in_ECX[0x1c];\n    *(arg_ch + 0x14) = uVar7;\n    while (uVar7 < uVar6) {\n        (**(*in_ECX + 0x154))(arg_8h, arg_ch);\n        uVar8 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(arg_8h[2], 8);\n        uVar9 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(arg_8h[2], 10);\n        (*_sym.imp.USER32.dll_SetRect)(puVar1, 0, 0, uVar8, uVar9);\n        (*_sym.imp.GDI32.dll_DPtoLP)(arg_8h[2], puVar1, 2);\n        (**(*in_ECX + 0x174))(arg_8h, arg_ch);\n        if (*(arg_ch + 0x14) == in_ECX[0x1c]) break;\n        *(arg_ch + 0x14) = *(arg_ch + 0x14) + 1;\n        uVar7 = *(arg_ch + 0x14);\n    }\n    uVar7 = *(arg_ch + 0x14);\n    (**(*arg_8h + 0x20))(0xffffffff);\n    *puVar1 = uVar2;\n    *(arg_ch + 0x28) = uVar3;\n    *(arg_ch + 0x2c) = uVar4;\n    *(arg_ch + 0x30) = uVar5;\n    *(arg_ch + 0x14) = uVar6;\n    return uVar7 == uVar6;\n}\n",
        "token_count": 596
    },
    "00448c18": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00448c18(int32_t hgdiobj)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t *in_ECX;\n    uint lpvObject;\n    int32_t var_30h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.GDI32.dll_GetObjectA)(hgdiobj, 0x18, &lpvObject);\n    piVar1 = in_ECX + 0x26;\n    if (*piVar1 == 0) {\n        var_8h = 0;\n        var_4h = hgdiobj;\n        iVar2 = (**(*in_ECX + 0x110))(0x413, var_30h / in_ECX[0x28], &var_8h);\n        uVar3 = iVar2 == 0;\n    }\n    else {\n        var_ch = var_30h / in_ECX[0x28];\n        var_1ch = 0;\n        var_14h = 0;\n        var_10h = hgdiobj;\n        var_18h = *piVar1;\n        uVar3 = (**(*in_ECX + 0x110))(0x42e, 0, &var_1ch);\n    }\n    if (uVar3 != 0) {\n        fcn.004367b8(piVar1);\n        *piVar1 = hgdiobj;\n    }\n    return uVar3;\n}\n",
        "token_count": 380
    },
    "0044ca91": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.0044ca91(void)\n\n{\n    uint uVar1;\n    uint var_18h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetOEMCP)(&var_18h);\n    (*_sym.imp.KERNEL32.dll_GetCPInfo)(uVar1);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 100
    },
    "0044e002": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044e002(uint arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint var_20h;\n    uint var_1ch;\n    uint *var_18h;\n    uint var_14h;\n    uint var_4h;\n    \n    uVar3 = arg_8h;\n    var_4h = *0x496830;\n    iVar4 = (*_sym.imp.ole32.dll_ReadClassStg)(arg_8h, &var_14h);\n    if (iVar4 != 0) goto code_r0x0044e0c1;\n    var_1ch = 0;\n    (*_sym.imp.ole32.dll_ReadFmtUserTypeStg)(uVar3, &arg_8h, &var_1ch);\n    var_20h = 0;\n    var_18h = NULL;\n    iVar4 = (*_sym.imp.ole32.dll_OleRegGetUserType)(arg_ch, 1, &var_18h);\n    pcVar1 = _sym.imp.ole32.dll_WriteClassStg;\n    if (iVar4 != 0) {\n        var_18h = &var_20h;\n    }\n    arg_ch = (*_sym.imp.ole32.dll_WriteClassStg)(uVar3, arg_ch);\n    pcVar2 = _sym.imp.ole32.dll_WriteFmtUserTypeStg;\n    if (arg_ch == 0) {\n        arg_ch = (*_sym.imp.ole32.dll_WriteFmtUserTypeStg)(uVar3, arg_8h, var_18h);\n        if (arg_ch == 0) {\n            arg_ch = (*_sym.imp.ole32.dll_SetConvertStg)(uVar3, 1);\n            if (arg_ch == 0) goto code_r0x0044e0a5;\n        }\n        (*pcVar1)(uVar3, &var_14h);\n        (*pcVar2)(uVar3, arg_8h, var_1ch);\n    }\ncode_r0x0044e0a5:\n    pcVar1 = _sym.imp.ole32.dll_CoTaskMemFree;\n    if (var_18h != &var_20h) {\n        (*_sym.imp.ole32.dll_CoTaskMemFree)(var_18h);\n    }\n    (*pcVar1)(var_1ch);\ncode_r0x0044e0c1:\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 572
    },
    "00450218": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00450218(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint uVar3;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar1 = fcn.0044fcc1(*(in_ECX + 0x20), 0x4760dc);\n    uVar3 = 0;\n    if (piVar1 == NULL) {\n        return 0;\n    }\n    var_18h = 0xffffffff;\n    var_24h._0_2_ = 3;\n    var_20h = 0;\n    var_1ch = 4;\n    var_14h = 0x20;\n    iVar2 = (**(*piVar1 + 0xc))(piVar1, &var_24h, 7, &var_4h);\n    if (iVar2 < 0) {\n        (**(*piVar1 + 8))(piVar1);\n        return 0;\n    }\n    if (arg_8h != 0) {\n        var_ch = arg_8h;\n        var_10h = 0x20;\n        var_8h = 0;\n        iVar2 = (**(*piVar1 + 0x1c))(piVar1, &var_24h, &var_10h, 0);\n        if (iVar2 < 0) goto code_r0x00450298;\n    }\n    uVar3 = 1;\ncode_r0x00450298:\n    (**(*piVar1 + 8))(piVar1);\n    return uVar3;\n}\n",
        "token_count": 427
    },
    "00452478": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_178h\n// WARNING: Variable defined which should be unmapped: var_160h\n// WARNING: Variable defined which should be unmapped: var_164h\n// WARNING: Variable defined which should be unmapped: var_168h\n\nvoid __cdecl fcn.00452478(uint arg_8h)\n\n{\n    code *pcVar1;\n    char cVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *arg_8h_00;\n    int32_t iVar5;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    int32_t var_178h;\n    int32_t *arg_8h_01;\n    uint var_16ch;\n    uint var_168h;\n    uint var_164h;\n    uint var_160h;\n    uint var_15ch;\n    uint pv;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = *0x496830;\n    *(unaff_EBP + -0x16c) = extraout_ECX;\n    fcn.0042eef3();\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.COleStreamFile.0;\n    *(unaff_EBP + -0x160) = extraout_ECX + 5;\n    fcn.00403c40();\n    *(unaff_EBP + -4) = 1;\n    extraout_ECX[4] = *(unaff_EBP + 8);\n    fcn.004042f6();\n    if (extraout_ECX[4] == NULL) goto code_r0x004525a9;\n    uVar3 = (**0x4860f8)();\n    *(unaff_EBP + -0x168) = uVar3;\n    *(unaff_EBP + 8) = 0;\n    arg_8h_01 = extraout_ECX[4];\n    iVar4 = *arg_8h_01;\n    *(unaff_EBP + -4) = 2;\n    var_178h = 0x4524f6;\n    iVar4 = (**(iVar4 + 0x30))();\n    if ((iVar4 == 0) && (var_178h = *(unaff_EBP + -0x58),  var_178h != 0)) {\n        *(unaff_EBP + -0x164) = var_178h;\n        arg_8h_00 = &fcn.00452478::var_178h;\n        iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenW)();\n        iVar4 = iVar4 * 2 + 2;\n        if (iVar4 < 0x401) {\n            cVar2 = fcn.0040100a(iVar4, var_178h, arg_8h_01);\n            if (cVar2 == '\\0') goto code_r0x0045253e;\n            fcn.0040dc10();\n        }\n        else {\ncode_r0x0045253e:\n            arg_8h_00 = fcn.004016c6(iVar4);\n        }\n        iVar4 = fcn.00403fce(arg_8h_00, *(unaff_EBP + -0x164), iVar4, *(unaff_EBP + -0x168));\n        if (iVar4 == 0) {\n            fcn.004202f9();\n        }\n        iVar5 = (*_sym.imp.KERNEL32.dll_lstrlenA)(iVar4);\n        if (0x103 < iVar5) {\ncode_r0x004525cf:\n            var_178h = 0xffffffff;\n            fcn.0043015b(3, 0xffffffff, 0);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n        var_178h = unaff_EBP + -0x15c;\n        iVar4 = fcn.0042f0fa(var_178h, iVar4);\n        (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x58));\n        if (iVar4 == 0) {\n            fcn.004042f6();\n            goto code_r0x004525cf;\n        }\n        var_178h = 0x4525a1;\n        fcn.004045a1();\n    }\n    var_178h = 0x4525a9;\n    fcn.004015ab();\ncode_r0x004525a9:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    *(unaff_EBP + -0x17c) = 0x4525c3;\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 1095
    },
    "0045278a": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl fcn.0045278a(uint arg_8h)\n\n{\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_20h;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    if (*(unaff_EBP + 8) < 0) {\n        fcn.00406d56(0, 0xffffffff, 0);\n        *(unaff_EBP + -4) = 0;\n        fcn.004520f2(unaff_EBP + -0x20, *(unaff_EBP + 8));\n        fcn.0043015b(*(unaff_EBP + -0x18), *(unaff_EBP + -0x14), 0);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 255
    },
    "00459fa1": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00459fa1(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    int32_t *in_ECX;\n    uint var_10h;\n    int32_t *var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.0044be10();\n    iVar1 = *(iVar1 + 4);\n    if (arg_8h == 0) {\n        piVar2 = in_ECX[0x30];\n        if (piVar2 != NULL) {\n            if (piVar2[0x34] != 0) {\n                (**(*in_ECX + 0x10c))(0);\n            }\n            piVar2 = in_ECX[0x30];\n            if (piVar2 == NULL) {\n                return;\n            }\n            (**(*piVar2 + 0x148))(0);\n            return;\n        }\n        var_4h = (**(*in_ECX + 0x60))();\n        if (var_4h != 0) {\n            piVar2 = fcn.0044f26c();\n            var_ch = NULL;\n            (**(*in_ECX + 100))(&var_4h);\n            do {\n                piVar3 = fcn.00428388();\n                do {\n                    iVar5 = (**(*in_ECX + 100))(&var_4h);\n                    if (iVar5 == 0) break;\n                    piVar6 = fcn.00428388();\n                } while (piVar6 == piVar3);\n                piVar6 = fcn.00428388();\n                if ((piVar6 == NULL) || (piVar6 = (**(*piVar6 + 0x13c))(),  piVar6 != piVar3)) {\n                    (**(*in_ECX + 0x94))(piVar3);\n                    if (piVar2 == piVar3) {\n                        (**(*piVar3 + 0x148))(0);\n                        piVar3 = var_ch;\n                    }\n                    else {\n                        (**(*piVar3 + 0x60))();\n                        piVar3 = var_ch;\n                    }\n                }\n                var_ch = piVar3;\n            } while (iVar5 != 0);\n            if (var_ch != NULL) {\n                (**(*in_ECX + 0x94))(var_ch);\n                if (piVar2 == var_ch) {\n                    (**(*var_ch + 0x148))(0);\n                }\n                else {\n                    (**(*var_ch + 0x60))();\n                }\n            }\n        }\n        piVar2 = *(iVar1 + 0x1c);\n        iVar1 = fcn.00445ca0();\n        if ((((iVar1 == 0) && (piVar2 != NULL)) && (iVar1 = fcn.0042a30b(),  iVar1 != 0)) &&\n           ((iVar1 = (**(*piVar2 + 0x120))(),  iVar1 != 0 && (piVar3 = (**(*piVar2 + 0x13c))(),  piVar3 == piVar2)))) {\n            fcn.0043c1b1();\n        }\n    }\n    else {\n        if (in_ECX[0x30] != 0) {\n            (**(*in_ECX + 0x108))();\n        }\n        piVar2 = fcn.0044f26c();\n        if (piVar2 == NULL) {\n            if (*(iVar1 + 0x1c) != 0) {\n                iVar1 = fcn.004049c2();\n                iVar5 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar1 + 0x1c));\n                if ((iVar5 == 0) && (piVar2 = in_ECX[0x2b],  piVar2 != NULL)) {\n                    (**(*piVar2 + 0x18))(piVar2);\n                }\n                fcn.0042a2ea(5);\n                uVar4 = (*_sym.imp.USER32.dll_SetActiveWindow)(*(iVar1 + 0x1c));\n                fcn.004278de(uVar4);\n                (*_sym.imp.USER32.dll_SetForegroundWindow)(*(iVar1 + 0x1c));\n            }\n        }\n        else {\n            iVar1 = (*_sym.imp.USER32.dll_IsWindowVisible)(piVar2[7]);\n            if ((iVar1 == 0) && (piVar3 = in_ECX[0x2b],  piVar3 != NULL)) {\n                (**(*piVar3 + 0x18))(piVar3);\n            }\n            (**(*piVar2 + 0x148))(0xffffffff);\n            piVar3 = fcn.00428388();\n            if (piVar3 != NULL) {\n                (**(*piVar3 + 0x148))(0xffffffff);\n                piVar2 = piVar3;\n            }\n            uVar4 = (*_sym.imp.USER32.dll_GetLastActivePopup)(piVar2[7]);\n            iVar1 = fcn.004278de(uVar4);\n            (*_sym.imp.USER32.dll_SetForegroundWindow)(*(iVar1 + 0x1c));\n            (**(*piVar2 + 0x160))(0);\n            (**(*piVar2 + 0x15c))(1);\n        }\n        if (in_ECX[0x13] == 0) {\n            fcn.00445c91(1);\n        }\n    }\n    piVar2 = in_ECX[0x2b];\n    if (piVar2 != NULL) {\n        if ((arg_8h == 0) && (in_ECX[0x2d] == 0)) {\n            return;\n        }\n        (**(*piVar2 + 0x1c))(piVar2, arg_8h);\n        in_ECX[0x2d] = arg_8h;\n    }\n    if (arg_8h != 0) {\n        fcn.00456c96(1, 0);\n    }\n    return;\n}\n",
        "token_count": 1359
    },
    "0045c44a": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_20h\n\nvoid fcn.0045c44a(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    uint uStack4;\n    \n    uStack4 = 0x45c454;\n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = &fcn.0045c44a::var_20h;\n    *(unaff_EBP + -0x20) = extraout_ECX;\n    iVar5 = (*_sym.imp.ole32.dll_CreateILockBytesOnHGlobal)(0, 1, unaff_EBP + -0x14);\n    if (iVar5 == 0) {\n        iVar5 = (*_sym.imp.ole32.dll_StgCreateDocfileOnILockBytes)(*(unaff_EBP + -0x14), 0x1012, 0, unaff_EBP + -0x18);\n        *(unaff_EBP + -0x1c) = iVar5;\n        if (iVar5 == 0) goto code_r0x0045c4a5;\n        (**(**(unaff_EBP + -0x14) + 8))(*(unaff_EBP + -0x14));\n        iVar5 = *(unaff_EBP + -0x1c);\n    }\n    fcn.0044e402(iVar5);\ncode_r0x0045c4a5:\n    iVar5 = *(extraout_ECX + 0x1c);\n    piVar1 = *(unaff_EBP + -0x20);\n    *(iVar5 + 0x7c) = 0;\n    *(iVar5 + 0x80) = 0;\n    iVar2 = *piVar1;\n    *(unaff_EBP + -0x1c) = iVar5;\n    *(unaff_EBP + -4) = 0;\n    (**(iVar2 + 0xa0))(*(unaff_EBP + -0x18));\n    fcn.0044f104(0, 0);\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(iVar5 + 0x7c) = 1;\n    *(iVar5 + 0x80) = 1;\n    (**(**(unaff_EBP + -0x14) + 8))(*(unaff_EBP + -0x14));\n    puVar3 = *(unaff_EBP + 8);\n    puVar3[1] = *(unaff_EBP + -0x18);\n    uVar4 = *(unaff_EBP + -0xc);\n    puVar3[2] = 0;\n    *puVar3 = 8;\n    *in_FS_OFFSET = uVar4;\n    return;\n}\n",
        "token_count": 746
    },
    "00401a79": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nint32_t fcn.00401a79(uint8_t *param_1, uint8_t *param_2)\n\n{\n    for (; (*param_1 != 0 && (*param_1 == *param_2)); param_1 = param_1 + 1) {\n        param_2 = param_2 + 1;\n    }\n    return *param_1 - *param_2;\n}\n",
        "token_count": 88
    },
    "00408c3e": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00408c3e(uint16_t *arg_8h, uint arg_ch)\n\n{\n    uint *in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*arg_8h < 0x76c) {\n        *in_ECX = 0;\n        in_ECX[1] = 0;\n    }\n    else {\n        fcn.00408bde(*arg_8h, arg_8h[1], arg_8h[3], arg_8h[4], arg_8h[5], arg_8h[6], arg_ch);\n        *in_ECX = in_ECX;\n        in_ECX[1] = in_ECX;\n    }\n    return;\n}\n",
        "token_count": 168
    },
    "004305f6": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004305f6(int32_t param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint uVar5;\n    \n    if (*(*(param_1 + 0x60) + -0xc) == 0) {\n        fcn.00404503(*(param_1 + 0x3c));\n    }\n    pcVar2 = _sym.imp.USER32.dll_LoadAcceleratorsA;\n    pcVar1 = _sym.imp.USER32.dll_LoadMenuA;\n    if ((*(param_1 + 0x44) != 0) && (*(param_1 + 0x2c) == 0)) {\n        iVar3 = fcn.0044be10();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar1)(uVar5, *(param_1 + 0x44));\n        *(param_1 + 0x2c) = uVar4;\n        uVar5 = (*pcVar2)(uVar5, *(param_1 + 0x44));\n        *(param_1 + 0x30) = uVar5;\n    }\n    if ((*(param_1 + 0x40) != 0) && (*(param_1 + 0x34) == 0)) {\n        iVar3 = fcn.0044be10();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar1)(uVar5, *(param_1 + 0x40));\n        *(param_1 + 0x34) = uVar4;\n        uVar5 = (*pcVar2)(uVar5, *(param_1 + 0x40));\n        *(param_1 + 0x38) = uVar5;\n    }\n    if ((*(param_1 + 0x48) != 0) && (*(param_1 + 0x24) == 0)) {\n        iVar3 = fcn.0044be10();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar1)(uVar5, *(param_1 + 0x48));\n        *(param_1 + 0x24) = uVar4;\n        uVar5 = (*pcVar2)(uVar5, *(param_1 + 0x48));\n        *(param_1 + 0x28) = uVar5;\n    }\n    return;\n}\n",
        "token_count": 553
    },
    "00432a84": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: nWidth\n// WARNING: Variable defined which should be unmapped: lpvObject\n// WARNING: Variable defined which should be unmapped: nHeight\n\nvoid __cdecl fcn.00432a84(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpvObject;\n    uint nWidth;\n    uint nHeight;\n    uint var_52h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint hdc;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_24h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x3c) = vtable.CDC.0;\n    *(unaff_EBP + -0x38) = 0;\n    *(unaff_EBP + -0x34) = 0;\n    *(unaff_EBP + -0x30) = 0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x4c) = vtable.CDC.0;\n    *(unaff_EBP + -0x48) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    *(unaff_EBP + -0x40) = 0;\n    *(unaff_EBP + -0x18) = 0;\n    *(unaff_EBP + -0x1c) = vtable.CBitmap.0;\n    pcVar1 = _sym.imp.USER32.dll_GetSysColor;\n    *(unaff_EBP + -4) = 2;\n    uVar2 = (*pcVar1)(0x14);\n    fcn.004329a0(uVar2);\n    *(unaff_EBP + -4) = 3;\n    uVar2 = (*pcVar1)(0x10);\n    fcn.004329a0(uVar2);\n    pcVar1 = _sym.imp.GDI32.dll_CreateCompatibleDC;\n    *(unaff_EBP + -4) = 4;\n    uVar2 = (*pcVar1)(0);\n    iVar3 = fcn.0043212e(uVar2);\n    if (iVar3 != 0) {\n        uVar2 = (*pcVar1)(0);\n        iVar3 = fcn.0043212e(uVar2);\n        if (iVar3 != 0) {\n            iVar3 = *(unaff_EBP + 8);\n            (*_sym.imp.GDI32.dll_GetObjectA)(*(iVar3 + 4), 0x18, unaff_EBP + -100);\n            fcn.00432482();\n            uVar2 = *(unaff_EBP + -0x60);\n            iVar4 = fcn.00406c53(uVar2, *(unaff_EBP + -0x5c), *(unaff_EBP + -0x54), *(unaff_EBP + -0x52), 0);\n            if (iVar4 != 0) {\n                uVar2 = (*_sym.imp.GDI32.dll_CreateBitmap)(*(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), 1, 1, 0);\n                iVar4 = fcn.0043242b();\n                if (iVar4 != 0) {\n                    uVar2 = fcn.004324e6(*(unaff_EBP + -0x38), *(iVar3 + 4));\n                    *(unaff_EBP + 8) = uVar2;\n                    uVar2 = *(unaff_EBP + -0x48);\n                    iVar3 = fcn.004324e6(uVar2, *(unaff_EBP + -0x18));\n                    *(unaff_EBP + -0x14) = iVar3;\n                    if ((*(unaff_EBP + 8) != 0) && (iVar3 != 0)) {\n                        uVar2 = (*_sym.imp.GDI32.dll_GetPixel)(*(unaff_EBP + -0x38), 0, 0);\n                        uVar2 = fcn.0043151e(uVar2);\n                        pcVar1 = _sym.imp.GDI32.dll_BitBlt;\n                        *(unaff_EBP + -0x10) = uVar2;\n                        (*pcVar1)(*(unaff_EBP + -0x48), 0, 0, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), \n                                  *(unaff_EBP + -0x38), 0, 0, 0xcc0020);\n                        fcn.0043151e(0xffffff);\n                        (*pcVar1)(*(unaff_EBP + -0x48), 0, 0, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), \n                                  *(unaff_EBP + -0x38), 0, 0, 0x1100a6);\n                        if (*(unaff_EBP + 0xc) == 0) {\n                            uVar2 = 0;\n                        }\n                        else {\n                            uVar2 = *(*(unaff_EBP + 0xc) + 4);\n                        }\n                        iVar3 = fcn.004324e6(*(unaff_EBP + -0x38), uVar2);\n                        if (iVar3 != 0) {\n                            fcn.00445a91(0, 0, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), *(unaff_EBP + 0x10));\n                            fcn.0043151e(0xffffff);\n                            uVar2 = fcn.0043257f(unaff_EBP + -0x2c);\n                            *(unaff_EBP + 0xc) = uVar2;\n                            (*pcVar1)(*(unaff_EBP + -0x38), 1, 1, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), \n                                      *(unaff_EBP + -0x48), 0, 0, 0xe20746);\n                            fcn.0043257f(unaff_EBP + -0x24);\n                            (*pcVar1)(*(unaff_EBP + -0x38), 0, 0, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), \n                                      *(unaff_EBP + -0x48), 0, 0, 0xe20746);\n                            fcn.0043257f(*(unaff_EBP + 0xc));\n                            fcn.0043151e(*(unaff_EBP + -0x10));\n                        }\n                        fcn.004324e6(*(unaff_EBP + -0x48), *(*(unaff_EBP + -0x14) + 4));\n                        uVar2 = *(*(unaff_EBP + 8) + 4);\n                        fcn.004324e6(*(unaff_EBP + -0x38), uVar2);\n                    }\n                }\n            }\n        }\n    }\n    *(unaff_EBP + -0x24) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 3;\n    fcn.00432482(uVar2);\n    *(unaff_EBP + -0x2c) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 2;\n    fcn.00432482();\n    *(unaff_EBP + -0x1c) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 1;\n    fcn.00432482();\n    *(unaff_EBP + -4) = 0;\n    fcn.004321ac();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004321ac();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 1883
    },
    "00432f48": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpvObject\n// WARNING: Variable defined which should be unmapped: var_74h\n// WARNING: Variable defined which should be unmapped: var_70h\n// WARNING: Variable defined which should be unmapped: var_5ch\n// WARNING: Variable defined which should be unmapped: var_66h\n// WARNING: Variable defined which should be unmapped: lprc\n\nvoid __cdecl fcn.00432f48(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpvObject;\n    uint var_74h;\n    uint var_70h;\n    uint var_66h;\n    uint lprc;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint hdc;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint hDC;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint hbr;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x40) = vtable.CDC.0;\n    *(unaff_EBP + -0x3c) = 0;\n    *(unaff_EBP + -0x38) = 0;\n    *(unaff_EBP + -0x34) = 0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x50) = vtable.CDC.0;\n    *(unaff_EBP + -0x4c) = 0;\n    *(unaff_EBP + -0x48) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    *(unaff_EBP + -0x30) = vtable.CDC.0;\n    *(unaff_EBP + -0x2c) = 0;\n    *(unaff_EBP + -0x28) = 0;\n    *(unaff_EBP + -0x24) = 0;\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -0x18) = vtable.CBitmap.0;\n    *(unaff_EBP + -0x1c) = 0;\n    *(unaff_EBP + -0x20) = vtable.CBrush.0;\n    pcVar1 = _sym.imp.GDI32.dll_CreateCompatibleDC;\n    *(unaff_EBP + -4) = 4;\n    uVar2 = (*pcVar1)(0);\n    iVar3 = fcn.0043212e(uVar2);\n    if (iVar3 != 0) {\n        uVar2 = (*pcVar1)(0);\n        iVar3 = fcn.0043212e(uVar2);\n        if (iVar3 != 0) {\n            uVar2 = (*pcVar1)(0);\n            iVar3 = fcn.0043212e(uVar2);\n            if (iVar3 != 0) {\n                iVar3 = (*_sym.imp.GDI32.dll_GetObjectA)(*(*(unaff_EBP + 8) + 4), 0x18, unaff_EBP + -0x78);\n                if (iVar3 != 0) {\n                    fcn.00432482();\n                    iVar3 = fcn.00406c53(*(unaff_EBP + -0x74), *(unaff_EBP + -0x70), *(unaff_EBP + -0x68), \n                                         *(unaff_EBP + -0x66), 0);\n                    pcVar1 = _sym.imp.GDI32.dll_CreateBitmap;\n                    if (iVar3 != 0) {\n                        uVar2 = (*_sym.imp.GDI32.dll_CreateBitmap)(8, 8, 1, 1, 0x46ce44);\n                        fcn.0043242b(uVar2);\n                        fcn.00406c32(unaff_EBP + -0x18);\n                        fcn.00432482();\n                        uVar2 = (*pcVar1)(*(unaff_EBP + -0x74), *(unaff_EBP + -0x70), 1, 1, 0);\n                        fcn.0043242b(uVar2);\n                        uVar2 = fcn.004324e6(*(unaff_EBP + -0x3c), *(*(unaff_EBP + 8) + 4));\n                        *(unaff_EBP + 8) = uVar2;\n                        iVar3 = fcn.004324e6(*(unaff_EBP + -0x4c), *(unaff_EBP + -0x14));\n                        *(unaff_EBP + -0x10) = iVar3;\n                        if ((*(unaff_EBP + 8) != 0) && (iVar3 != 0)) {\n                            uVar2 = (*_sym.imp.GDI32.dll_GetPixel)(*(unaff_EBP + -0x3c), 0, 0);\n                            uVar2 = fcn.0043151e(uVar2);\n                            pcVar1 = _sym.imp.GDI32.dll_BitBlt;\n                            (*_sym.imp.GDI32.dll_BitBlt)\n                                      (*(unaff_EBP + -0x4c), 0, 0, *(unaff_EBP + -0x74), *(unaff_EBP + -0x70), \n                                       *(unaff_EBP + -0x3c), 0, 0, 0xcc0020);\n                            fcn.0043151e(0xffffff);\n                            (*pcVar1)(*(unaff_EBP + -0x4c), 0, 0, *(unaff_EBP + -0x74), *(unaff_EBP + -0x70), \n                                      *(unaff_EBP + -0x3c), 0, 0, 0xee0086);\n                            fcn.0043151e(uVar2);\n                            if (*(unaff_EBP + 0xc) == 0) {\n                                uVar2 = 0;\n                            }\n                            else {\n                                uVar2 = *(*(unaff_EBP + 0xc) + 4);\n                            }\n                            iVar3 = fcn.004324e6(*(unaff_EBP + -0x2c), uVar2);\n                            *(unaff_EBP + 0xc) = iVar3;\n                            if (iVar3 == 0) {\n                                uVar2 = 0;\n                            }\n                            else {\n                                uVar2 = fcn.00431605(*(unaff_EBP + 0x10));\n                                uVar4 = fcn.0043151e(*(unaff_EBP + 0x14));\n                                *(unaff_EBP + 0x14) = uVar4;\n                                *(unaff_EBP + -0x58) = *(unaff_EBP + -0x74);\n                                *(unaff_EBP + -0x54) = *(unaff_EBP + -0x70);\n                                *(unaff_EBP + -0x60) = 0;\n                                *(unaff_EBP + -0x5c) = 0;\n                                (*_sym.imp.USER32.dll_FillRect)\n                                          (*(unaff_EBP + -0x2c), unaff_EBP + -0x60, *(unaff_EBP + -0x1c));\n                                fcn.00431605(uVar2);\n                                fcn.0043151e(*(unaff_EBP + 0x14));\n                                (*pcVar1)(*(unaff_EBP + -0x2c), 0, 0, *(unaff_EBP + -0x74), *(unaff_EBP + -0x70), \n                                          *(unaff_EBP + -0x3c), 0, 0, 0x660046);\n                                (*pcVar1)(*(unaff_EBP + -0x2c), 0, 0, *(unaff_EBP + -0x74), *(unaff_EBP + -0x70), \n                                          *(unaff_EBP + -0x4c), 0, 0, 0x8800c6);\n                                (*pcVar1)(*(unaff_EBP + -0x2c), 0, 0, *(unaff_EBP + -0x74), *(unaff_EBP + -0x70), \n                                          *(unaff_EBP + -0x3c), 0, 0, 0x660046);\n                                uVar2 = *(*(unaff_EBP + 0xc) + 4);\n                            }\n                            fcn.004324e6(*(unaff_EBP + -0x2c), uVar2);\n                            fcn.004324e6(*(unaff_EBP + -0x4c), *(*(unaff_EBP + -0x10) + 4));\n                            fcn.004324e6(*(unaff_EBP + -0x3c), *(*(unaff_EBP + 8) + 4));\n                        }\n                    }\n                }\n            }\n        }\n    }\n    *(unaff_EBP + -0x20) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 3;\n    fcn.00432482();\n    *(unaff_EBP + -0x18) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 2;\n    fcn.00432482();\n    *(unaff_EBP + -4) = 1;\n    fcn.004321ac();\n    *(unaff_EBP + -4) = 0;\n    fcn.004321ac();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004321ac();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 2293
    },
    "0043b71b": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b71b(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    if ((arg_ch < arg_10h) || (arg_14h < arg_ch)) {\n        fcn.0043b665(arg_8h, arg_10h, 0, arg_14h, 0, \"%I64u\", 0xf112);\n    }\n    return;\n}\n",
        "token_count": 102
    },
    "004072d0": {
        "rules": [
            "PEB access",
            "PEB access"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid __fastcall fcn.004072d0(code **param_1)\n\n{\n    int32_t *piVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    *param_1 = vtable.CDocObjectServerItem.0;\n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *(unaff_EBP + -4) = 2;\n    *(extraout_ECX + 0x2c) = 0;\n    fcn.0044fce5(extraout_ECX + 0x34);\n    fcn.0044fce5(extraout_ECX + 0x38);\n    fcn.0044fe5c();\n    piVar1 = *(extraout_ECX + 0x1c);\n    if (piVar1 != NULL) {\n        if (*(extraout_ECX + 0x28) != 0) {\n            fcn.00456ac9(0, 1);\n            *(extraout_ECX + 0x28) = 0;\n        }\n        if (piVar1[0x2f] == extraout_ECX) {\n            piVar1[0x2f] = 0;\n        }\n        (**(*piVar1 + 0xc0))(extraout_ECX);\n    }\n    fcn.00445cf5();\n    *(unaff_EBP + -4) = 1;\n    fcn.00457a05();\n    fcn.00403164();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0044f323();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 453
    },
    "0044b650": {
        "rules": [
            "PEB access"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\ncode ** __cdecl fcn.0044b650(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0042aa25();\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[0xd] = *(unaff_EBP + 8);\n    pcVar1 = *(unaff_EBP + 0xc);\n    *extraout_ECX = vtable.CWinThread.0;\n    extraout_ECX[0xc] = pcVar1;\n    fcn.0044b613();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 236
    },
    "0044b6b0": {
        "rules": [
            "PEB access"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\ncode ** fcn.0044b6b0(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0042aa25();\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.CWinThread.0;\n    extraout_ECX[0xc] = NULL;\n    extraout_ECX[0xd] = NULL;\n    fcn.0044b613();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 197
    },
    "004243f7": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004243f7(int32_t param_1)\n\n{\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 8) = 0;\n    *(param_1 + 4) = 0;\n    fcn.00424de5();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 102
    },
    "0042591a": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042591a(int32_t param_1)\n\n{\n    if (*(param_1 + 4) != 0) {\n        fcn.00425d0d(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    fcn.00424de5();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 123
    },
    "00420280": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00420280(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *(param_1 + 0xc) = 1;\n    iVar1 = fcn.0042cf90(*(param_1 + 0x94), param_1 + 0x14, 0x80);\n    *(param_1 + 0x10) = iVar1 != 0;\n    return;\n}\n",
        "token_count": 97
    },
    "00424502": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00424502(code **param_1, code *param_2)\n\n{\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    param_1[5] = NULL;\n    *param_1 = vtable.CObList.0;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 104
    },
    "00424745": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00424745(int32_t param_1)\n\n{\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 8) = 0;\n    *(param_1 + 4) = 0;\n    fcn.00424de5();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 101
    },
    "0042484c": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042484c(code **param_1, code *param_2)\n\n{\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    param_1[5] = NULL;\n    *param_1 = vtable.CPtrList.0;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 105
    },
    "004255ab": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004255ab(code **param_1, code *param_2)\n\n{\n    *param_1 = vtable.CMapStringToPtr.0;\n    if (param_2 < 1) {\n        param_2 = 0xa;\n    }\n    param_1[1] = NULL;\n    param_1[2] = 0x11;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[5] = NULL;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 131
    },
    "00425632": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "contain loop"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00425632(int32_t param_1, uint32_t *param_2, uint32_t *param_3)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uint unaff_retaddr;\n    \n    uVar2 = fcn.0042553e(param_2);\n    *param_3 = uVar2;\n    uVar2 = uVar2 % *(param_1 + 8);\n    *param_2 = uVar2;\n    if (*(param_1 + 4) != 0) {\n        for (puVar3 = *(*(param_1 + 4) + uVar2 * 4); puVar3 != NULL; puVar3 = *puVar3) {\n            if ((puVar3[1] == *param_3) && (cVar1 = fcn.004492bb(puVar3 + 2, unaff_retaddr),  cVar1 != '\\0')) {\n                return puVar3;\n            }\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 239
    },
    "004256da": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004256da(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    \n    if (*(param_1 + 4) != 0) {\n        uVar1 = 0;\n        if (*(param_1 + 8) != 0) {\n            do {\n                for (puVar2 = *(*(param_1 + 4) + uVar1 * 4); puVar2 != NULL; puVar2 = *puVar2) {\n                    fcn.004039aa();\n                }\n                uVar1 = uVar1 + 1;\n            } while (uVar1 < *(param_1 + 8));\n        }\n        fcn.00425d0d(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    fcn.00424de5();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 244
    },
    "00425ab1": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00425ab1(code **param_1, code *param_2)\n\n{\n    *param_1 = vtable.CMapPtrToPtr.0;\n    if (param_2 < 1) {\n        param_2 = 0xa;\n    }\n    param_1[1] = NULL;\n    param_1[2] = 0x11;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[5] = NULL;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 132
    },
    "0042aa25": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042aa25(int32_t param_1)\n\n{\n    *(param_1 + 4) = 1;\n    *(param_1 + 8) = 0;\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 0x14) = 1;\n    *(param_1 + 0x18) = 0;\n    return;\n}\n",
        "token_count": 108
    },
    "0042acf6": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042acf6(code **param_1)\n\n{\n    *param_1 = vtable.CCmdUI.0;\n    param_1[8] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    param_1[9] = NULL;\n    param_1[4] = NULL;\n    param_1[3] = NULL;\n    param_1[5] = NULL;\n    param_1[7] = NULL;\n    param_1[6] = NULL;\n    return;\n}\n",
        "token_count": 126
    },
    "004322ff": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: hWnd\n// WARNING: Variable defined which should be unmapped: var_4h\n\ncode ** __cdecl fcn.004322ff(uint arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint hWnd;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    extraout_ECX[1] = NULL;\n    extraout_ECX[2] = NULL;\n    extraout_ECX[3] = NULL;\n    *(unaff_EBP + -4) = 0;\n    iVar3 = *(unaff_EBP + 8);\n    *extraout_ECX = vtable.CPaintDC.0;\n    pcVar1 = *(iVar3 + 0x1c);\n    extraout_ECX[4] = pcVar1;\n    uVar2 = (*_sym.imp.USER32.dll_BeginPaint)(pcVar1, extraout_ECX + 5);\n    iVar3 = fcn.0043212e(uVar2);\n    if (iVar3 == 0) {\n        fcn.00431a1c();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 340
    },
    "004499a5": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.004499a5(code **param_1)\n\n{\n    param_1[5] = NULL;\n    param_1[2] = NULL;\n    param_1[3] = NULL;\n    *param_1 = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.2.0;\n    param_1[1] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.1.0;\n    param_1[4] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.0;\n    fcn.00445c81();\n    return param_1;\n}\n",
        "token_count": 145
    },
    "0044ab76": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.0044ab76(code **param_1)\n\n{\n    *param_1 = vtable.CCommandLineInfo.0;\n    fcn.00403c40();\n    fcn.00403c40();\n    fcn.00403c40();\n    fcn.00403c40();\n    param_1[2] = NULL;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[1] = 0x1;\n    return param_1;\n}\n",
        "token_count": 119
    },
    "00457d5d": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.00457d5d(code **param_1, code *param_2, code *param_3, code *param_4, code *param_5)\n\n{\n    fcn.0042aa25();\n    *param_1 = vtable.CEnumArray.0;\n    param_1[0xd] = vtable.CEnumArray::XEnumVOID.0;\n    param_1[8] = NULL;\n    param_1[10] = NULL;\n    param_1[7] = param_2;\n    param_1[0xb] = param_4;\n    param_1[9] = param_3;\n    param_1[0xc] = param_5;\n    return param_1;\n}\n",
        "token_count": 166
    },
    "00461411": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n\nint32_t * fcn.00461411(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00403c40();\n    *(unaff_EBP + -4) = 0;\n    iVar2 = fcn.00425ce2(0xb8);\n    *(unaff_EBP + -0x14) = iVar2;\n    *(unaff_EBP + -4) = 1;\n    if (iVar2 == 0) {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = fcn.004205cd(0, 0x40004, 0);\n    }\n    uVar1 = *(unaff_EBP + -0xc);\n    *extraout_ECX = iVar2;\n    *(*(iVar2 + 0x70) + 0x1c) = 1;\n    *(*(*extraout_ECX + 0x70) + 0x1e) = 0xffff;\n    extraout_ECX[0xd] = -1;\n    extraout_ECX[8] = 0;\n    extraout_ECX[2] = 0;\n    extraout_ECX[3] = 0;\n    extraout_ECX[1] = 0;\n    extraout_ECX[0xf] = 0;\n    extraout_ECX[0xe] = 0;\n    extraout_ECX[5] = 1;\n    extraout_ECX[4] = 1;\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 469
    },
    "0042024a": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nuint fcn.0042024a(uint param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    \n    uVar4 = 0xffffffff;\n    piVar2 = fcn.0042bc3d();\n    iVar3 = fcn.0044be10();\n    piVar1 = *(iVar3 + 4);\n    iVar3 = fcn.0044dc6c(param_1, param_2, param_3, param_4);\n    if ((iVar3 != 0) && ((piVar1 == NULL || (iVar3 = (**(*piVar1 + 0x90))(),  iVar3 != 0)))) {\n        iVar3 = (**(*piVar2 + 0x50))();\n        if (iVar3 == 0) {\n            if (piVar2[7] != 0) {\n                (**(*piVar2[7] + 0x60))();\n            }\n            uVar4 = (**(*piVar2 + 0x68))();\n        }\n        else {\n            uVar4 = (**(*piVar2 + 0x54))();\n        }\n    }\n    fcn.004637ea();\n    return uVar4;\n}\n",
        "token_count": 294
    },
    "00433a67": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00433a67(int32_t *param_1, int32_t param_2)\n\n{\n    fcn.004248fa(param_2);\n    *(param_2 + 0x50) = param_1;\n    (**(*param_1 + 0x68))();\n    return;\n}\n",
        "token_count": 72
    },
    "00433a87": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00433a87(int32_t *param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.0042482d(param_2, 0);\n    fcn.004247cf(uVar1);\n    *(param_2 + 0x50) = 0;\n    (**(*param_1 + 0x68))();\n    return;\n}\n",
        "token_count": 97
    },
    "0043fb3a": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043fb3a(int32_t param_1)\n\n{\n    int32_t iStack8;\n    int32_t iStack4;\n    \n    iStack8 = param_1;\n    iStack4 = param_1;\n    fcn.0043f9f2();\n    (**(**(param_1 + 0x68) + 0x134))(&iStack8, *(param_1 + 0x40) - *(param_1 + 0x38), 0x42);\n    fcn.004442fb(*(param_1 + 0x68), *(param_1 + 0x48), *(param_1 + 0x4c), *(param_1 + 0x70) & 0x40 | 0x2004);\n    return;\n}\n",
        "token_count": 180
    },
    "0044add4": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nuint fcn.0044add4(void)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    \n    uVar3 = 1;\n    iVar1 = fcn.0044be10();\n    fcn.0044ca10(0);\n    for (piVar2 = *(iVar1 + 0x24); piVar2 != NULL; piVar2 = piVar2[7]) {\n        iVar1 = (**(*piVar2 + 0x50))();\n        if (iVar1 == 0) {\n            iVar1 = fcn.00405ad0(piVar2 + 9, 0x475f8c);\n            if (iVar1 == 0) {\n                iVar1 = (**(*piVar2 + 0x54))();\n                if (iVar1 == 0) {\n                    uVar3 = 0;\n                }\n            }\n        }\n    }\n    fcn.0044ca73(0);\n    return uVar3;\n}\n",
        "token_count": 221
    },
    "0044cb96": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a",
            "create or open registry key"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0044cb96(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = 0;\n    var_4h = 0;\n    var_8h = 0;\n    iVar2 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(0x80000001, \"software\", 0, 0x2001f, &var_4h);\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegCreateKeyExA;\n    if (iVar2 == 0) {\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyExA)\n                          (var_4h, *(param_1 + 0x50), 0, 0, 0, 0x2001f, 0, &var_8h, &var_10h);\n        if (iVar2 == 0) {\n            (*pcVar1)(var_8h, *(param_1 + 100), 0, 0, 0, 0x2001f, 0, &var_ch, &var_10h);\n        }\n    }\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n    if (var_4h != 0) {\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n    }\n    if (var_8h != 0) {\n        (*pcVar1)(var_8h);\n    }\n    return var_ch;\n}\n",
        "token_count": 379
    },
    "0044f171": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0044f171(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    var_4h = (**(*param_1 + 0xb4))();\n    do {\n        if (var_4h == NULL) {\n            return 0;\n        }\n        piVar1 = (**(*param_1 + 0xb8))(&var_4h);\n        iVar2 = (**(*piVar1 + 0x50))();\n    } while (iVar2 == 0);\n    return 1;\n}\n",
        "token_count": 150
    },
    "0044ff79": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044ff79(uint arg_8h)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    ppiVar1 = in_ECX + 0x24;\n    piVar2 = *ppiVar1;\n    *(in_ECX + 0x30) = 0;\n    var_4h = in_ECX;\n    if (piVar2 != NULL) {\n        var_4h = 0;\n        var_8h = in_ECX;\n        (**(*piVar2 + 0x20))(piVar2, &var_8h, 0, &var_4h);\n        if (var_4h != 0) {\n            fcn.0044fce5(&var_4h);\n        }\n        (**(**ppiVar1 + 0x1c))(*ppiVar1, var_8h, 0, 0);\n        fcn.0044fce5(ppiVar1);\n    }\n    ppiVar1 = in_ECX + 0x20;\n    piVar2 = *ppiVar1;\n    if (piVar2 != NULL) {\n        if (*(in_ECX + 0x3c) != 0) {\n            (**(*piVar2 + 0x50))(piVar2, *(in_ECX + 0x3c));\n            *(in_ECX + 0x3c) = 0;\n        }\n        uVar3 = (**(**ppiVar1 + 0x18))(*ppiVar1, arg_8h);\n        *(in_ECX + 0x30) = uVar3;\n        fcn.0044fce5(ppiVar1);\n    }\n    fcn.0044fce5(in_ECX + 0x34);\n    fcn.0044fce5(in_ECX + 0x38);\n    if (*(in_ECX + 0x5c) != 0) {\n        fcn.0044fd01();\n        *(in_ECX + 0x5c) = 0;\n        if (*(in_ECX + 0x60) != 0) {\n            fcn.0044fd01();\n            *(in_ECX + 0x60) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 530
    },
    "00450041": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00450041(uint32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t var_4h;\n    \n    var_4h = param_1;\n    piVar1 = fcn.0044fcc1(*(param_1 + 0x20), 0x47605c);\n    if (piVar1 == NULL) {\n        iVar2 = (**(**(param_1 + 0x20) + 0x58))(*(param_1 + 0x20), 1, &var_4h);\n        if ((iVar2 == 0) && ((var_4h & 8) == 0)) {\n            *(param_1 + 0x50) = 2;\n        }\n        else {\n            *(param_1 + 0x50) = 3;\n        }\n    }\n    else {\n        (**(*piVar1 + 8))(piVar1);\n        *(param_1 + 0x50) = 1;\n    }\n    return;\n}\n",
        "token_count": 235
    },
    "0040ca0f": {
        "rules": [
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040ca0f(int32_t param_1)\n\n{\n    uint lpRect;\n    \n    (**(**(param_1 + 0x78) + 0x28))(*(param_1 + 0x78), 1);\n    (*_sym.imp.USER32.dll_GetClientRect)(*(*(param_1 + 0x54) + 0x1c), &lpRect);\n    (**(**(param_1 + 0x78) + 0x18))(*(param_1 + 0x78), &lpRect);\n    (**(**(param_1 + 0x78) + 0x24))(*(param_1 + 0x78), 1);\n    return;\n}\n",
        "token_count": 159
    },
    "0045a2e4": {
        "rules": [
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045a2e4(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    iVar2 = fcn.0044be10();\n    iVar2 = *(iVar2 + 4);\n    iVar1 = in_ECX[0x30];\n    if (arg_8h == 0) {\n        if (*(iVar2 + 0x20) == iVar1) {\n            *(iVar2 + 0x20) = 0;\n        }\n        fcn.00441a96(0);\n        if (*(iVar1 + 0xf4) != 0) {\n            (**(*in_ECX + 0x114))(*(iVar1 + 0xf4), 0);\n        }\n        (**(*in_ECX + 0x114))(*(iVar1 + 0xf0), 0);\n        if (*(iVar1 + 0xec) != 0) {\n            (**(*in_ECX + 300))(0, *(iVar1 + 0xec), 0);\n        }\n        (**(*in_ECX + 300))(0, *(iVar1 + 0xe8), 1);\n        piVar4 = fcn.00441c1e();\n        if (piVar4 != NULL) {\n            (**(*piVar4 + 0x15c))(0, piVar4, piVar4);\n        }\n        (*_sym.imp.USER32.dll_SendMessageA)(*(iVar1 + 0x1c), 6, 0, 0);\n        uVar3 = fcn.00427958();\n        *(*(iVar1 + 0xf0) + 0x1c) = uVar3;\n        if (*(iVar1 + 0xf4) != 0) {\n            uVar3 = fcn.00427958();\n            *(*(iVar1 + 0xf4) + 0x1c) = uVar3;\n        }\n    }\n    else {\n        uVar3 = fcn.00427958();\n        fcn.0042791f(uVar3);\n        if (*(iVar1 + 0xf4) != 0) {\n            uVar3 = fcn.00427958();\n            fcn.0042791f(uVar3);\n        }\n        *(iVar2 + 0x20) = iVar1;\n        iVar2 = *(iVar1 + 0xf4);\n        if (iVar2 != 0) {\n            (**(*in_ECX + 0x114))(iVar2, 1);\n        }\n        (**(*in_ECX + 0x114))(*(iVar1 + 0xf0), 1);\n        fcn.00441a96(1);\n        if (*(iVar1 + 0xec) != 0) {\n            (**(*in_ECX + 300))(0, *(iVar1 + 0xec), 0);\n        }\n        (**(*in_ECX + 300))(0, *(iVar1 + 0xe8), 1);\n        piVar4 = *(iVar1 + 0xe8);\n        (**(*piVar4 + 0x28))(piVar4, *(iVar1 + 0xf8), *(iVar1 + 0x114), *(iVar1 + 0x1c));\n        (*_sym.imp.USER32.dll_SendMessageA)(*(iVar1 + 0x1c), 6, 1, 0);\n    }\n    return;\n}\n",
        "token_count": 778
    },
    "0042bf52": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nuint fcn.0042bf52(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    \n    iVar1 = *(param_1 + 4);\n    if ((iVar1 == 0x200) || (iVar1 == 0xa0)) {\n        iVar1 = fcn.0044bde5();\n        iVar2 = fcn.00405f9a(*(param_1 + 0x14), *(param_1 + 0x18));\n        if ((iVar2 == 0) || (*(param_1 + 4) != *(iVar1 + 0x54))) {\n            *(iVar1 + 0x4c) = *(param_1 + 0x14);\n            *(iVar1 + 0x50) = *(param_1 + 0x18);\n            *(iVar1 + 0x54) = *(param_1 + 4);\n            uVar3 = 1;\n        }\n        else {\n            uVar3 = 0;\n        }\n        return uVar3;\n    }\n    if ((iVar1 != 0xf) && (iVar1 != 0x118)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 273
    },
    "0042d853": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** __cdecl fcn.0042d853(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    code *pcVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    pcVar1 = *(unaff_EBP + 8);\n    *extraout_ECX = vtable.CHandleMap.0;\n    uVar2 = *(pcVar1 + 4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0040c57d(uVar2, 0x40);\n    *(unaff_EBP + -4) = 0;\n    fcn.00425ab1(10);\n    *(unaff_EBP + -4) = 1;\n    fcn.00425ab1(4);\n    *(unaff_EBP + -4) = 2;\n    fcn.004258ce(7, 0);\n    uVar2 = *(unaff_EBP + -0xc);\n    extraout_ECX[5] = *(unaff_EBP + 0xc);\n    extraout_ECX[6] = *(unaff_EBP + 0x10);\n    extraout_ECX[0x16] = *(unaff_EBP + 0x14);\n    pcVar3 = *(unaff_EBP + 0x18);\n    extraout_ECX[0x15] = pcVar1;\n    extraout_ECX[0x17] = pcVar3;\n    *in_FS_OFFSET = uVar2;\n    return extraout_ECX;\n}\n",
        "token_count": 455
    },
    "00434bfe": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid fcn.00434bfe(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint unaff_EDI;\n    int32_t unaff_retaddr;\n    int32_t iVar3;\n    \n    iVar1 = fcn.00426e29(0);\n    iVar3 = 0;\n    fcn.00426df9(0, unaff_retaddr, 1);\n    iVar2 = fcn.00426e29(1);\n    fcn.00426df9(1, unaff_EDI, 1);\n    fcn.00426f40(iVar1 - iVar3, iVar2 - unaff_retaddr, 0, 0);\n    return;\n}\n",
        "token_count": 156
    },
    "004413df": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.004413df(code **param_1, code *param_2)\n\n{\n    fcn.0042eef3();\n    param_1[4] = param_2;\n    param_1[5] = NULL;\n    param_1[6] = NULL;\n    param_1[7] = NULL;\n    param_1[8] = NULL;\n    *param_1 = vtable.CMemFile.0;\n    param_1[9] = 0x1;\n    return param_1;\n}\n",
        "token_count": 121
    },
    "004416cd": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004416cd(int32_t *param_1)\n\n{\n    param_1[4] = 0;\n    param_1[5] = 0;\n    param_1[6] = 0;\n    param_1[7] = 0;\n    if ((param_1[8] != 0) && (param_1[9] != 0)) {\n        (**(*param_1 + 0x60))(param_1[8]);\n    }\n    param_1[8] = 0;\n    return;\n}\n",
        "token_count": 124
    },
    "004417cc": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004417cc(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CMemFile.0;\n    pcVar1 = extraout_ECX[8];\n    *(unaff_EBP + -4) = 0;\n    if (pcVar1 != NULL) {\n        fcn.004416cd();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    extraout_ECX[4] = NULL;\n    extraout_ECX[5] = NULL;\n    extraout_ECX[6] = NULL;\n    extraout_ECX[7] = NULL;\n    fcn.0042ef32();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 254
    },
    "0044abb5": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044abb5(code **param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t **ppiVar3;\n    \n    *param_1 = vtable.CCommandLineInfo.0;\n    fcn.00403164();\n    fcn.00403164();\n    fcn.00403164();\n    ppiVar3 = param_1[5] + -0x10;\n    piVar1 = param_1[5] + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        (**(**ppiVar3 + 4))(ppiVar3);\n    }\n    return;\n}\n",
        "token_count": 180
    },
    "0044bcd1": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0044bcd1(code **param_1, uchar param_2)\n\n{\n    *param_1 = vtable.AFX_MODULE_STATE.0;\n    param_1[7] = NULL;\n    param_1[8] = NULL;\n    param_1[9] = NULL;\n    param_1[10] = NULL;\n    param_1[0x40f] = NULL;\n    param_1[0x410] = NULL;\n    param_1[0x413] = 0xffffffff;\n    param_1[0x414] = NULL;\n    param_1[0x419] = NULL;\n    param_1[0x41a] = NULL;\n    param_1[10] = 0x1c;\n    param_1[8] = 0x14;\n    param_1[6] = NULL;\n    *(param_1 + 5) = param_2;\n    param_1[0xc] = 0x1;\n    param_1[0x410] = 0x18;\n    return;\n}\n",
        "token_count": 239
    },
    "0044debb": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0044debb(uint param_1, int32_t param_2, uint param_3)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t unaff_ESI;\n    int32_t iVar6;\n    uint unaff_retaddr;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetMenuItemCount;\n    (*_sym.imp.USER32.dll_GetMenuItemCount)(param_3);\n    iVar2 = (*pcVar1)(unaff_retaddr);\n    pcVar1 = _sym.imp.USER32.dll_GetSubMenu;\njoined_r0x0044ded8:\n    do {\n        do {\n            iVar2 = iVar2 + -1;\n            if (iVar2 < 0) {\n                return;\n            }\n            iVar3 = (*pcVar1)(param_1, iVar2);\n            iVar6 = 0;\n        } while (iVar3 == 0);\n        if (param_2 != 0) {\n            iVar4 = (*_sym.imp.USER32.dll_GetMenuItemCount)(iVar3);\n            if (0 < iVar4) {\n                do {\n                    iVar5 = (*pcVar1)(iVar3, iVar6);\n                    if (iVar5 == param_2) {\n                        (*_sym.imp.USER32.dll_RemoveMenu)(iVar3, iVar6, 0x400);\n                        param_2 = 0;\n                        break;\n                    }\n                    iVar6 = iVar6 + 1;\n                } while (iVar6 < iVar4);\n            }\n            goto joined_r0x0044ded8;\n        }\n        if (0 < unaff_ESI) {\n            do {\n                iVar4 = (*pcVar1)(unaff_retaddr, iVar6);\n                if (iVar4 == iVar3) {\n                    (*_sym.imp.USER32.dll_RemoveMenu)(param_1, iVar2, 0x400);\n                    break;\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < unaff_ESI);\n        }\n    } while( true );\n}\n",
        "token_count": 458
    },
    "004577c1": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004577c1(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint var_14h;\n    \n    iVar1 = fcn.0044df67(arg_10h, arg_8h, &var_14h);\n    *(iVar1 + 0x10) = 1;\n    iVar1 = fcn.0045771e(iVar1, 1);\n    *(iVar1 + 0x1c) = 0;\n    *(iVar1 + 0x14) = 1;\n    *(iVar1 + 0x18) = arg_ch;\n    return;\n}\n",
        "token_count": 149
    },
    "00457833": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00457833(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint var_14h;\n    \n    iVar1 = fcn.0044df67(arg_ch, arg_8h, &var_14h);\n    *(iVar1 + 0x10) = 5;\n    iVar1 = fcn.0045771e(iVar1, 1);\n    *(iVar1 + 0x14) = 0;\n    *(iVar1 + 0x18) = 0;\n    *(iVar1 + 0x1c) = 0;\n    return;\n}\n",
        "token_count": 140
    },
    "004578bb": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004578bb(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint var_14h;\n    \n    uVar1 = fcn.0044df67(arg_ch, arg_8h, &var_14h);\n    iVar2 = fcn.0045771e(uVar1, 2);\n    *(iVar2 + 0x14) = 0;\n    *(iVar2 + 0x18) = 0;\n    *(iVar2 + 0x1c) = 0;\n    return;\n}\n",
        "token_count": 133
    },
    "0045c0d7": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0045c0d7(int32_t param_1, int32_t param_2, uint param_3)\n\n{\n    uint uVar1;\n    \n    if (param_2 == 0) {\n        if (*(param_1 + 0x38) != 0) {\n            uVar1 = fcn.0044fd3f(0x4776ec);\n            (**(**(param_1 + 0x38) + 0x18))(*(param_1 + 0x38), uVar1, 0, 0);\n        }\n    }\n    else if (param_2 == 1) {\n        if (*(param_1 + 0x34) != 0) {\n            (**(**(param_1 + 0x34) + 0x1c))(*(param_1 + 0x34));\n        }\n    }\n    else if (param_2 == 2) {\n        if (*(param_1 + 0x34) != 0) {\n            (**(**(param_1 + 0x34) + 0x20))(*(param_1 + 0x34));\n        }\n    }\n    else if ((param_2 == 3) && (*(param_1 + 0x34) != 0)) {\n        (**(**(param_1 + 0x34) + 0x18))(*(param_1 + 0x34), param_3);\n    }\n    return;\n}\n",
        "token_count": 323
    },
    "0045eee7": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0045eee7(code **param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t **ppiVar3;\n    \n    *param_1 = vtable.COleDispatchException.0;\n    fcn.00403164();\n    fcn.00403164();\n    ppiVar3 = param_1[3] + -0x10;\n    piVar1 = param_1[3] + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        (**(**ppiVar3 + 4))(ppiVar3);\n    }\n    return;\n}\n",
        "token_count": 173
    },
    "0040f65c": {
        "rules": [
            "create thread"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.0040f65c(uint lpThreadAttributes, uint dwStackSize, int32_t arg_10h, uint arg_14h, uint dwCreationFlags, \n            uint *arg_1ch)\n\n{\n    uint *puVar1;\n    int32_t arg_8h;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = arg_10h;\n    iVar3 = 0;\n    if (arg_10h == 0) {\n        puVar1 = fcn.00410979();\n        *puVar1 = 0x16;\n    }\n    else {\n        arg_8h = fcn.0040f0e4(1, 0x8c);\n        if (arg_8h != 0) {\n            fcn.00412cc2(arg_8h);\n            *(arg_8h + 4) = 0xffffffff;\n            *(arg_8h + 0x50) = arg_14h;\n            *(arg_8h + 0x4c) = iVar2;\n            puVar1 = arg_1ch;\n            if (arg_1ch == NULL) {\n                puVar1 = &arg_10h;\n            }\n            iVar2 = (*_sym.imp.KERNEL32.dll_CreateThread)\n                              (lpThreadAttributes, dwStackSize, 0x40f5c7, arg_8h, dwCreationFlags, puVar1);\n            if (iVar2 != 0) {\n                return iVar2;\n            }\n            iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0040d958(arg_8h);\n        if (iVar3 != 0) {\n            fcn.0041098b(iVar3);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 397
    },
    "0042c5fa": {
        "rules": [
            "resume thread"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0042c5fa(uint arg_8h, uint arg_ch, uint arg_10h, uint32_t arg_14h, uint arg_18h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = fcn.0042c660();\n    if (piVar1 == NULL) {\n        fcn.004202f9();\n    }\n    piVar1[0xc] = 0;\n    iVar2 = fcn.0042c495(arg_14h | 4, arg_10h, arg_18h);\n    if (iVar2 == 0) {\n        (**(*piVar1 + 0x78))();\n        piVar1 = NULL;\n    }\n    else {\n        (*_sym.imp.KERNEL32.dll_SetThreadPriority)(piVar1[10], arg_ch);\n        if ((arg_14h & 4) == 0) {\n            (*_sym.imp.KERNEL32.dll_ResumeThread)(piVar1[10]);\n        }\n    }\n    return piVar1;\n}\n",
        "token_count": 241
    },
    "0042f008": {
        "rules": [
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0042f008(uint hKey, uint arg_ch)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    bool bVar4;\n    uint lpType;\n    uint lpData;\n    uint lpcbData;\n    uint var_8h;\n    uint var_4h;\n    \n    bVar4 = false;\n    var_8h = 0;\n    lpData = fcn.004043ec(0x104);\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegOpenKeyA;\n    lpcbData = 0x104;\n    lpType = 0;\n    iVar3 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(0x80000000, \"CLSID\", &var_8h);\n    if (iVar3 == 0) {\n        var_4h = 0;\n        iVar3 = (*pcVar1)(var_8h, hKey, &var_4h);\n        pcVar2 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n        if (iVar3 == 0) {\n            hKey = 0;\n            iVar3 = (*pcVar1)(var_4h, \"InProcServer32\", &hKey);\n            if (iVar3 == 0) {\n                iVar3 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, 0x469144, 0, &lpType, lpData, &lpcbData);\n                bVar4 = iVar3 == 0;\n                (*pcVar2)(hKey);\n            }\n            (*pcVar2)(var_4h);\n        }\n        (*pcVar2)(var_8h);\n    }\n    fcn.00404cad(0xffffffff);\n    return bVar4;\n}\n",
        "token_count": 397
    },
    "0044b063": {
        "rules": [
            "create or open registry key",
            "contain loop",
            "query or enumerate registry key"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: phkResult\n// WARNING: Variable defined which should be unmapped: var_120h\n// WARNING: Variable defined which should be unmapped: var_11ch\n// WARNING: Variable defined which should be unmapped: var_14h_2\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl\nfcn.0044b063(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint noname_22, uint noname_23, uint noname_24, uint noname_25, \n            uint noname_26, uint noname_27, uint noname_28, uint noname_29, uint noname_30, uint noname_31, \n            uint noname_32, uint noname_33, uint noname_34, uint noname_35, uint noname_36, uint noname_37, \n            uint noname_38, uint noname_39, uint noname_40, uint noname_41, uint noname_42, uint noname_43, \n            uint noname_44, uint noname_45, uint noname_46, uint noname_47, uint noname_48, uint noname_49, \n            uint noname_50, uint noname_51, uint noname_52, uint noname_53, uint noname_54, uint noname_55, \n            uint noname_56, uint noname_57, uint noname_58, uint noname_59, uint noname_60, uint noname_61, \n            uint noname_62, uint noname_63, uint noname_64, uint noname_65, uint noname_66, uint noname_67, \n            uint noname_68, uint noname_69, uint noname_70, uint noname_71, uint noname_72, uint noname_73, \n            uint noname_74, uint lpSubKey)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint unaff_EBX;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint *in_FS_OFFSET;\n    uint hKey;\n    uint var_ch_2;\n    uint var_14h;\n    uint var_10h;\n    uint phkResult;\n    uint var_120h;\n    uint var_11ch;\n    uint in_stack_fffffee4;\n    uint in_stack_fffffee8;\n    uint in_stack_fffffeec;\n    uint in_stack_fffffef0;\n    uint in_stack_fffffef4;\n    uint in_stack_fffffef8;\n    uint in_stack_fffffefc;\n    uint in_stack_ffffff00;\n    uint in_stack_ffffff04;\n    uint in_stack_ffffff08;\n    uint in_stack_ffffff0c;\n    uint in_stack_ffffff10;\n    uint in_stack_ffffff14;\n    uint in_stack_ffffff18;\n    uint in_stack_ffffff1c;\n    uint in_stack_ffffff20;\n    uint in_stack_ffffff24;\n    uint in_stack_ffffff28;\n    uint in_stack_ffffff2c;\n    uint in_stack_ffffff30;\n    uint in_stack_ffffff34;\n    uint in_stack_ffffff38;\n    uint in_stack_ffffff3c;\n    uint in_stack_ffffff40;\n    uint in_stack_ffffff44;\n    uint in_stack_ffffff48;\n    uint in_stack_ffffff4c;\n    uint in_stack_ffffff50;\n    uint in_stack_ffffff54;\n    uint in_stack_ffffff58;\n    uint in_stack_ffffff5c;\n    uint in_stack_ffffff60;\n    uint in_stack_ffffff64;\n    uint in_stack_ffffff68;\n    uint in_stack_ffffff6c;\n    uint in_stack_ffffff70;\n    uint in_stack_ffffff74;\n    uint in_stack_ffffff78;\n    uint in_stack_ffffff7c;\n    uint in_stack_ffffff80;\n    uint in_stack_ffffff84;\n    uint in_stack_ffffff88;\n    uint in_stack_ffffff8c;\n    uint in_stack_ffffff90;\n    uint in_stack_ffffff94;\n    uint in_stack_ffffff98;\n    uint in_stack_ffffff9c;\n    uint in_stack_ffffffa0;\n    uint in_stack_ffffffa4;\n    uint in_stack_ffffffa8;\n    uint in_stack_ffffffac;\n    uint in_stack_ffffffb0;\n    uint in_stack_ffffffb4;\n    uint in_stack_ffffffb8;\n    uint in_stack_ffffffbc;\n    uint in_stack_ffffffc0;\n    uint in_stack_ffffffc4;\n    uint in_stack_ffffffc8;\n    uint in_stack_ffffffcc;\n    uint in_stack_ffffffd0;\n    uint in_stack_ffffffd4;\n    uint in_stack_ffffffd8;\n    uint in_stack_ffffffdc;\n    uint in_stack_ffffffe0;\n    uint in_stack_ffffffe4;\n    uint var_14h_2;\n    uint in_stack_ffffffec;\n    uint var_ch;\n    uint in_stack_fffffff4;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x14) = *0x496830;\n    uVar1 = **(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x10) = &phkResult;\n    phkResult = unaff_EDI;\n    var_120h = unaff_ESI;\n    var_11ch = unaff_EBX;\n    iVar2 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(*(unaff_EBP + 8), uVar1, unaff_EBP + -0x124);\n    if (iVar2 == 0) {\n        while( true ) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegEnumKeyA)(*(unaff_EBP + -0x124), 0, unaff_EBP + -0x11c, 0x104);\n            if (iVar2 != 0) break;\n            *(unaff_EBP + -4) = 0;\n            iVar2 = unaff_EBP + -0x11c;\n            fcn.004045fc(iVar2);\n            *(unaff_EBP + -4) = 1;\n            iVar2 = fcn.0044b063(*(unaff_EBP + -0x124), unaff_EBP + -0x120, iVar2, phkResult, var_120h, var_11ch, \n                                 in_stack_fffffee4, in_stack_fffffee8, in_stack_fffffeec, in_stack_fffffef0, \n                                 in_stack_fffffef4, in_stack_fffffef8, in_stack_fffffefc, in_stack_ffffff00, \n                                 in_stack_ffffff04, in_stack_ffffff08, in_stack_ffffff0c, in_stack_ffffff10, \n                                 in_stack_ffffff14, in_stack_ffffff18, in_stack_ffffff1c, in_stack_ffffff20, \n                                 in_stack_ffffff24, in_stack_ffffff28, in_stack_ffffff2c, in_stack_ffffff30, \n                                 in_stack_ffffff34, in_stack_ffffff38, in_stack_ffffff3c, in_stack_ffffff40, \n                                 in_stack_ffffff44, in_stack_ffffff48, in_stack_ffffff4c, in_stack_ffffff50, \n                                 in_stack_ffffff54, in_stack_ffffff58, in_stack_ffffff5c, in_stack_ffffff60, \n                                 in_stack_ffffff64, in_stack_ffffff68, in_stack_ffffff6c, in_stack_ffffff70, \n                                 in_stack_ffffff74, in_stack_ffffff78, in_stack_ffffff7c, in_stack_ffffff80, \n                                 in_stack_ffffff84, in_stack_ffffff88, in_stack_ffffff8c, in_stack_ffffff90, \n                                 in_stack_ffffff94, in_stack_ffffff98, in_stack_ffffff9c, in_stack_ffffffa0, \n                                 in_stack_ffffffa4, in_stack_ffffffa8, in_stack_ffffffac, in_stack_ffffffb0, \n                                 in_stack_ffffffb4, in_stack_ffffffb8, in_stack_ffffffbc, in_stack_ffffffc0, \n                                 in_stack_ffffffc4, in_stack_ffffffc8, in_stack_ffffffcc, in_stack_ffffffd0, \n                                 in_stack_ffffffd4, in_stack_ffffffd8, in_stack_ffffffdc, in_stack_ffffffe0, \n                                 in_stack_ffffffe4, var_14h_2, in_stack_ffffffec, var_ch, in_stack_fffffff4, var_4h);\n            *(unaff_EBP + -4) = 0;\n            fcn.00403164();\n            if (iVar2 != 0) break;\n            *(unaff_EBP + -4) = 0xffffffff;\n        }\n        if ((iVar2 == 0x103) || (iVar2 == 0x3f2)) {\n            (*_sym.imp.ADVAPI32.dll_RegDeleteKeyA)(*(unaff_EBP + 8), **(unaff_EBP + 0xc));\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(*(unaff_EBP + -0x124));\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 2234
    },
    "0044cc27": {
        "rules": [
            "create or open registry key"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044cc27(uint lpSubKey)\n\n{\n    int32_t iVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    iVar1 = fcn.0044cb96();\n    if (iVar1 == 0) {\n        var_4h = 0;\n    }\n    else {\n        (*_sym.imp.ADVAPI32.dll_RegCreateKeyExA)(iVar1, lpSubKey, 0, 0, 0, 0x2001f, 0, &var_4h, &var_8h);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n    }\n    return var_4h;\n}\n",
        "token_count": 165
    },
    "00401d82": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00401d82(void)\n\n{\n    code **ppcVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CFrameWnd.0;\n    *(unaff_EBP + -4) = 2;\n    fcn.0044351a();\n    iVar3 = fcn.0044bde5();\n    ppcVar1 = *(iVar3 + 0xec);\n    while (ppcVar1 == extraout_ECX) {\n        puVar2 = *(iVar3 + 0xf0);\n        *(puVar2[1] + 0xec) = *puVar2;\n        *(puVar2[1] + 0xf0) = puVar2[2];\n        puVar2[1] = 0;\n        ppcVar1 = *(iVar3 + 0xec);\n    }\n    if (extraout_ECX[0x2e] != NULL) {\n        fcn.00425d0d(extraout_ECX[0x2e]);\n    }\n    fcn.00403164();\n    *(unaff_EBP + -4) = 0;\n    fcn.0042486f();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042823e();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 359
    },
    "00402c86": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_18h\n\nuint __cdecl fcn.00402c86(uint arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t extraout_ECX;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_20h;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    uVar5 = 0;\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -0x18) = vtable.CPen.0;\n    uVar2 = *(extraout_ECX + 4);\n    *(unaff_EBP + -4) = 0;\n    uVar2 = (*_sym.imp.GDI32.dll_CreatePen)(0, uVar2, 0);\n    iVar3 = fcn.0043242b(uVar2);\n    if (iVar3 != 0) {\n        uVar2 = fcn.00432539(unaff_EBP + -0x18);\n        iVar3 = *(extraout_ECX + 0x10);\n        *(unaff_EBP + -0x10) = uVar2;\n        if (iVar3 < 1) {\n            fcn.0042032d();\n            pcVar1 = swi(3);\n            uVar2 = (*pcVar1)();\n            return uVar2;\n        }\n        iVar3 = unaff_EBP + -0x20;\n        fcn.00431d99(iVar3, **(extraout_ECX + 0xc), (*(extraout_ECX + 0xc))[1]);\n        iVar6 = 1;\n        if (1 < *(extraout_ECX + 0x10)) {\n            do {\n                piVar4 = fcn.00402649(iVar6);\n                iVar3 = *piVar4;\n                fcn.004317e6();\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < *(extraout_ECX + 0x10));\n        }\n        fcn.00432539(*(unaff_EBP + -0x10), iVar3);\n        uVar5 = 1;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(unaff_EBP + -0x18) = vtable.CGdiObject.0;\n    fcn.00432482();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar5;\n}\n",
        "token_count": 642
    },
    "00402e37": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00402e37(void)\n\n{\n    code **ppcVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CFrameWnd.0;\n    *(unaff_EBP + -4) = 2;\n    fcn.0044351a();\n    iVar3 = fcn.0044bde5();\n    ppcVar1 = *(iVar3 + 0xec);\n    while (ppcVar1 == extraout_ECX) {\n        puVar2 = *(iVar3 + 0xf0);\n        *(puVar2[1] + 0xec) = *puVar2;\n        *(puVar2[1] + 0xf0) = puVar2[2];\n        puVar2[1] = 0;\n        ppcVar1 = *(iVar3 + 0xec);\n    }\n    if (extraout_ECX[0x2e] != NULL) {\n        fcn.00425d0d(extraout_ECX[0x2e]);\n    }\n    fcn.00403164();\n    *(unaff_EBP + -4) = 0;\n    fcn.0042486f();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042823e();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 359
    },
    "00408b22": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00408b22(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    iVar2 = fcn.0044be10();\n    puVar3 = 0xb;\n    fcn.0044ca10(0xb);\n    while (puVar1 = *(iVar2 + 0x103c),  puVar1 != NULL) {\n        puVar3 = puVar1;\n        fcn.0044c44f();\n        if (puVar1 != NULL) {\n            (***puVar1)(1);\n        }\n    }\n    fcn.0044ca73(0xb, puVar3);\n    return;\n}\n",
        "token_count": 154
    },
    "0040dc77": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint16_t * fcn.0040dc77(int16_t *param_1, int16_t *param_2)\n\n{\n    int16_t iVar1;\n    int16_t *piVar2;\n    \n    piVar2 = param_1;\n    do {\n        iVar1 = *param_2;\n        *piVar2 = iVar1;\n        piVar2 = piVar2 + 1;\n        param_2 = param_2 + 1;\n    } while (iVar1 != 0);\n    return param_1;\n}\n",
        "token_count": 117
    },
    "0040dfd0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.0040dfd0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    iVar1 = fcn.00412cd5();\n    piVar2 = *(iVar1 + 0x88);\n    while( true ) {\n        if (piVar2 == NULL) {\n            return 1;\n        }\n        if (*piVar2 == param_1) break;\n        piVar2 = piVar2[1];\n    }\n    return 0;\n}\n",
        "token_count": 115
    },
    "0040f6f9": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040f6f9(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0040daac(0x4732b8, 0x14);\n    *(unaff_EBP + -4) = 0;\n    while( true ) {\n        piVar1 = unaff_EBP + 0x10;\n        *piVar1 = *piVar1 + -1;\n        if (*piVar1 < 0) break;\n        *(unaff_EBP + 8) = *(unaff_EBP + 8) - *(unaff_EBP + 0xc);\n        (**(unaff_EBP + 0x14))();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0040dae7();\n    return;\n}\n",
        "token_count": 235
    },
    "0040f7c2": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040f7c2(int32_t arg_8h, uint8_t *arg_ch, uint8_t *arg_10h)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint8_t *puVar3;\n    uint8_t *puVar4;\n    \n    if (*(arg_8h + 8) == 0) {\n        uVar2 = fcn.00416090(arg_ch, arg_10h);\n    }\n    else {\n        puVar4 = arg_10h;\n        if (*arg_ch != 0) {\ncode_r0x0040f815:\n            do {\n                if (*puVar4 != 0) {\n                    uVar1 = *puVar4;\n                    if ((*(uVar1 + 0x1d + arg_8h) & 4) == 0) {\n                        puVar3 = puVar4;\n                        if (uVar1 != *arg_ch) goto code_r0x0040f814;\n                    }\n                    else if (((uVar1 != *arg_ch) || (puVar4[1] != arg_ch[1])) && (puVar3 = puVar4 + 1,  *puVar3 != 0)) {\ncode_r0x0040f814:\n                        puVar4 = puVar3 + 1;\n                        goto code_r0x0040f815;\n                    }\n                }\n                if (((*puVar4 != 0) || (((*(*arg_ch + 0x1d + arg_8h) & 4) != 0 && (arg_ch = arg_ch + 1,  *arg_ch == 0)))\n                    ) || (arg_ch = arg_ch + 1,  puVar4 = arg_10h,  *arg_ch == 0)) break;\n            } while( true );\n        }\n        uVar2 = -(*arg_ch != 0) & arg_ch;\n    }\n    return uVar2;\n}\n",
        "token_count": 435
    },
    "0040f865": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040f865(int32_t arg_8h, uint8_t *arg_ch, uint8_t *arg_10h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint8_t *puVar3;\n    uint8_t *puVar4;\n    uint8_t *puVar5;\n    \n    if (*(arg_8h + 8) == 0) {\n        iVar2 = fcn.004160d0(arg_ch, arg_10h);\n    }\n    else {\n        puVar3 = arg_ch;\n        puVar5 = arg_10h;\n        if (*arg_ch != 0) {\ncode_r0x0040f8b8:\n            do {\n                if (*puVar5 != 0) {\n                    uVar1 = *puVar5;\n                    if ((*(uVar1 + 0x1d + arg_8h) & 4) == 0) {\n                        puVar4 = puVar5;\n                        if (uVar1 != *puVar3) goto code_r0x0040f8b7;\n                    }\n                    else if (((uVar1 != *puVar3) || (puVar5[1] != puVar3[1])) && (puVar4 = puVar5 + 1,  *puVar4 != 0)) {\ncode_r0x0040f8b7:\n                        puVar5 = puVar4 + 1;\n                        goto code_r0x0040f8b8;\n                    }\n                }\n                if (((*puVar5 == 0) || (((*(*puVar3 + 0x1d + arg_8h) & 4) != 0 && (puVar3 = puVar3 + 1,  *puVar3 == 0)))\n                    ) || (puVar3 = puVar3 + 1,  puVar5 = arg_10h,  *puVar3 == 0)) break;\n            } while( true );\n        }\n        iVar2 = puVar3 - arg_ch;\n    }\n    return iVar2;\n}\n",
        "token_count": 460
    },
    "0040f903": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040f903(int32_t arg_8h, uint8_t *arg_ch, uint8_t *arg_10h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint8_t *puVar3;\n    uint8_t *puVar4;\n    uint8_t *puVar5;\n    \n    if (*(arg_8h + 8) == 0) {\n        iVar2 = fcn.00416120(arg_ch, arg_10h);\n    }\n    else {\n        puVar3 = arg_ch;\n        puVar5 = arg_10h;\n        if (*arg_ch != 0) {\ncode_r0x0040f956:\n            do {\n                if (*puVar5 != 0) {\n                    uVar1 = *puVar5;\n                    if ((*(uVar1 + 0x1d + arg_8h) & 4) == 0) {\n                        puVar4 = puVar5;\n                        if (uVar1 != *puVar3) goto code_r0x0040f955;\n                    }\n                    else if (((uVar1 != *puVar3) || (puVar5[1] != puVar3[1])) && (puVar4 = puVar5 + 1,  *puVar4 != 0)) {\ncode_r0x0040f955:\n                        puVar5 = puVar4 + 1;\n                        goto code_r0x0040f956;\n                    }\n                }\n                if (((*puVar5 != 0) || (((*(*puVar3 + 0x1d + arg_8h) & 4) != 0 && (puVar3 = puVar3 + 1,  *puVar3 == 0)))\n                    ) || (puVar3 = puVar3 + 1,  puVar5 = arg_10h,  *puVar3 == 0)) break;\n            } while( true );\n        }\n        iVar2 = puVar3 - arg_ch;\n    }\n    return iVar2;\n}\n",
        "token_count": 451
    },
    "004102f6": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.004102f6(uint8_t *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    \n    iVar1 = fcn.00412cd5();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x496dc4) {\n        iVar1 = fcn.00416a84();\n    }\n    while( true ) {\n        if (*(iVar1 + 0x28) < 2) {\n            uVar2 = *(*(iVar1 + 0x48) + *param_1 * 2) & 8;\n        }\n        else {\n            uVar2 = fcn.004166f8(iVar1, *param_1, 8);\n        }\n        if (uVar2 == 0) break;\n        param_1 = param_1 + 1;\n    }\n    uVar2 = *param_1;\n    puVar5 = param_1 + 1;\n    if ((uVar2 == 0x2d) || (uVar3 = uVar2,  uVar2 == 0x2b)) {\n        uVar3 = *puVar5;\n        puVar5 = param_1 + 2;\n    }\n    iVar1 = 0;\n    while( true ) {\n        if ((uVar3 < 0x30) || (0x39 < uVar3)) {\n            iVar4 = -1;\n        }\n        else {\n            iVar4 = uVar3 - 0x30;\n        }\n        if (iVar4 == -1) break;\n        iVar1 = iVar4 + iVar1 * 10;\n        uVar3 = *puVar5;\n        puVar5 = puVar5 + 1;\n    }\n    if (uVar2 == 0x2d) {\n        iVar1 = -iVar1;\n    }\n    return iVar1;\n}\n",
        "token_count": 440
    },
    "0041098b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0041098b(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.00412cd5();\n    *(iVar1 + 0xc) = param_1;\n    uVar2 = 0;\n    do {\n        if (param_1 == *(uVar2 * 8 + 0x496948)) {\n            iVar1 = fcn.00412cd5();\n            *(iVar1 + 8) = *(uVar2 * 8 + 0x49694c);\n            return;\n        }\n        uVar2 = uVar2 + 1;\n    } while (uVar2 < 0x2d);\n    if ((0x12 < param_1) && (param_1 < 0x25)) {\n        iVar1 = fcn.00412cd5();\n        *(iVar1 + 8) = 0xd;\n        return;\n    }\n    if ((0xbb < param_1) && (param_1 < 0xcb)) {\n        iVar1 = fcn.00412cd5();\n        *(iVar1 + 8) = 8;\n        return;\n    }\n    iVar1 = fcn.00412cd5();\n    *(iVar1 + 8) = 0x16;\n    return;\n}\n",
        "token_count": 292
    },
    "0041afac": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0041afac(uint param_1, char *param_2)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    while( true ) {\n        cVar1 = *param_2;\n        param_2 = param_2 + 1;\n        if (((cVar1 < 'A') || ('Z' < cVar1)) && ((cVar1 < 'a' || ('z' < cVar1)))) break;\n        iVar2 = iVar2 + 1;\n    }\n    return iVar2;\n}\n",
        "token_count": 131
    },
    "0041fb5d": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0041fb5d(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    uint8_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar5 = in_ECX + 0x18;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(iVar5);\n    iVar4 = 0;\n    if (0 < *(in_ECX + 0x34)) {\n        do {\n            iVar5 = iVar4;\n            piVar1 = fcn.0041fa95();\n            if (*piVar1 == arg_8h) {\n                fcn.0041f9f7();\n                uVar3 = 1;\n                goto code_r0x0041fb99;\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < *(in_ECX + 0x34));\n    }\n    iVar4 = iVar5;\n    uVar3 = 0;\ncode_r0x0041fb99:\n    uVar2 = fcn.0041fb0e(iVar4);\n    return uVar2 & 0xffffff00 | uVar3;\n}\n",
        "token_count": 290
    },
    "004244df": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004244df(int32_t param_1, int32_t param_2, uint *param_3)\n\n{\n    if (param_3 != NULL) goto code_r0x004244f5;\n    for (param_3 = *(param_1 + 4); (param_3 != NULL && (param_3[2] != param_2)); param_3 = *param_3) {\ncode_r0x004244f5:\n    }\n    return;\n}\n",
        "token_count": 110
    },
    "0042482d": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042482d(int32_t param_1, int32_t param_2, uint *param_3)\n\n{\n    if (param_3 != NULL) goto code_r0x00424843;\n    for (param_3 = *(param_1 + 4); (param_3 != NULL && (param_3[2] != param_2)); param_3 = *param_3) {\ncode_r0x00424843:\n    }\n    return;\n}\n",
        "token_count": 109
    },
    "00424d39": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424d39(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint var_4h;\n    \n    iVar2 = 0;\n    if ((arg_ch != 0) && (-1 < arg_8h)) {\n        if (0 < *(arg_ch + 8)) {\n            if (*(arg_ch + 8) < 1) goto code_r0x00424d92;\n            fcn.00424c37(arg_8h, **(arg_ch + 4), *(arg_ch + 8));\n            if (0 < *(arg_ch + 8)) {\n                do {\n                    fcn.00405ccb(iVar2);\n                    fcn.00406ce6();\n                    iVar2 = iVar2 + 1;\n                } while (iVar2 < *(arg_ch + 8));\n            }\n        }\n        return;\n    }\ncode_r0x00424d92:\n    fcn.0042032d();\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 245
    },
    "00424de5": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00424de5(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    \n    if (param_1 != NULL) {\n        do {\n            piVar1 = *param_1;\n            fcn.00425d0d(param_1);\n            param_1 = piVar1;\n        } while (piVar1 != NULL);\n    }\n    return;\n}\n",
        "token_count": 91
    },
    "004250c1": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004250c1(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint var_4h;\n    \n    iVar2 = 0;\n    if ((arg_ch != 0) && (-1 < arg_8h)) {\n        if (0 < *(arg_ch + 8)) {\n            if (*(arg_ch + 8) < 1) goto code_r0x0042511c;\n            fcn.00424fdc(arg_8h, **(arg_ch + 4), *(arg_ch + 8));\n            if (0 < *(arg_ch + 8)) {\n                do {\n                    fcn.0040d216(iVar2);\n                    fcn.0040d232();\n                    iVar2 = iVar2 + 1;\n                } while (iVar2 < *(arg_ch + 8));\n            }\n        }\n        return;\n    }\ncode_r0x0042511c:\n    fcn.0042032d();\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 245
    },
    "004254c3": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004254c3(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint var_4h;\n    \n    iVar2 = 0;\n    if ((arg_ch != 0) && (-1 < arg_8h)) {\n        if (0 < *(arg_ch + 8)) {\n            if (*(arg_ch + 8) < 1) goto code_r0x0042551c;\n            fcn.004253c1(arg_8h, **(arg_ch + 4), *(arg_ch + 8));\n            if (0 < *(arg_ch + 8)) {\n                do {\n                    fcn.0040d4d6(iVar2);\n                    fcn.0040d4f2();\n                    iVar2 = iVar2 + 1;\n                } while (iVar2 < *(arg_ch + 8));\n            }\n        }\n        return;\n    }\ncode_r0x0042551c:\n    fcn.0042032d();\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 250
    },
    "0042572c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042572c(code **param_1)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    \n    *param_1 = vtable.CMapStringToPtr.0;\n    if (param_1[1] != NULL) {\n        pcVar1 = NULL;\n        if (param_1[2] != NULL) {\n            do {\n                for (puVar2 = *(param_1[1] + pcVar1 * 4); puVar2 != NULL; puVar2 = *puVar2) {\n                    fcn.004039aa();\n                }\n                pcVar1 = pcVar1 + 1;\n            } while (pcVar1 < param_1[2]);\n        }\n        fcn.00425d0d(param_1[1]);\n        param_1[1] = NULL;\n    }\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    fcn.00424de5();\n    param_1[5] = NULL;\n    return;\n}\n",
        "token_count": 231
    },
    "0042595e": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.0042595e(int32_t param_1, uint32_t param_2, uint32_t *param_3, uint32_t *param_4)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    \n    *param_4 = param_2 >> 4;\n    uVar2 = (param_2 >> 4) % *(param_1 + 8);\n    *param_3 = uVar2;\n    if (*(param_1 + 4) != 0) {\n        for (puVar1 = *(*(param_1 + 4) + uVar2 * 4); puVar1 != NULL; puVar1 = *puVar1) {\n            if (puVar1[1] == param_2) {\n                return puVar1;\n            }\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 192
    },
    "00425996": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00425996(int32_t param_1, uint32_t param_2)\n\n{\n    uint *puVar1;\n    \n    if (*(param_1 + 4) != 0) {\n        for (puVar1 = *(*(param_1 + 4) + ((param_2 >> 4) % *(param_1 + 8)) * 4); puVar1 != NULL; puVar1 = *puVar1) {\n            if (puVar1[1] == param_2) {\n                return puVar1[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 138
    },
    "004259f4": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.004259f4(int32_t param_1, uint32_t param_2)\n\n{\n    uint *puVar1;\n    uint *puVar2;\n    uint *puVar3;\n    \n    if (*(param_1 + 4) == 0) {\n        puVar2 = NULL;\n    }\n    else {\n        puVar3 = *(param_1 + 4) + ((param_2 >> 4) % *(param_1 + 8)) * 4;\n        puVar1 = *puVar3;\n        while (puVar2 = puVar1,  puVar2 != NULL) {\n            if (puVar2[1] == param_2) {\n                *puVar3 = *puVar2;\n                fcn.00425945(puVar2);\n                return 0x1;\n            }\n            puVar3 = puVar2;\n            puVar1 = *puVar2;\n        }\n    }\n    return puVar2;\n}\n",
        "token_count": 218
    },
    "00425ce2": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.00425ce2(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.0040d946(param_1);\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n        if (*0x494d14 == NULL) break;\n        iVar1 = (**0x494d14)(param_1);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 116
    },
    "00425d12": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.00425d12(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.0040d946(param_1);\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n        if (*0x494d14 == NULL) break;\n        iVar1 = (**0x494d14)(param_1);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 116
    },
    "00426c69": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.00426c69(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint unaff_retaddr;\n    \n    iVar1 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(param_1 + 4));\n    iVar3 = 0;\n    if (0 < iVar1) {\n        do {\n            iVar2 = fcn.00404a97(iVar3);\n            if (iVar2 == 0) {\n                iVar2 = (*_sym.imp.USER32.dll_GetMenuItemID)(*(param_1 + 4), iVar3);\n                if (iVar2 == param_1) {\n                    iVar1 = fcn.0042d14e(*(param_1 + 4));\n                    return iVar1;\n                }\n            }\n            else {\n                iVar2 = fcn.00426c69(iVar2, unaff_retaddr);\n                if (iVar2 != 0) {\n                    return iVar2;\n                }\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < iVar1);\n    }\n    return 0;\n}\n",
        "token_count": 251
    },
    "00427bfe": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00427bfe(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongA;\n    if ((param_1 == 0) || (iVar5 = *(param_1 + 0x1c),  iVar5 == 0)) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar5, 0xfffffff0);\n    while ((uVar2 & 0x40000000) != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_GetParent)(iVar5);\n        if (iVar3 == 0) break;\n        uVar2 = (*pcVar1)(iVar3, 0xfffffff0);\n        iVar5 = iVar3;\n    }\n    uVar4 = fcn.004278de(iVar5);\n    return uVar4;\n}\n",
        "token_count": 235
    },
    "00427c60": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427c60(uint hDlg, uint nIDDlgItem, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.USER32.dll_GetDlgItem)(hDlg, nIDDlgItem);\n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    if (iVar2 != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_GetTopWindow)(iVar2);\n        if ((iVar3 != 0) && (iVar3 = fcn.00427c60(iVar2, nIDDlgItem, arg_10h),  iVar3 != 0)) {\n            return;\n        }\n        if (arg_10h == 0) {\n            fcn.004278de();\n            return;\n        }\n        iVar2 = fcn.00427905(iVar2);\n        if (iVar2 != 0) {\n            return;\n        }\n    }\n    iVar2 = (*pcVar1)(hDlg);\n    while( true ) {\n        if (iVar2 == 0) {\n            return;\n        }\n        iVar3 = fcn.00427c60(iVar2, nIDDlgItem, arg_10h);\n        if (iVar3 != 0) break;\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2);\n    }\n    return;\n}\n",
        "token_count": 316
    },
    "00427e1f": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.00427e1f(uint param_1, int32_t *param_2)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    \n    iVar3 = *param_2;\n    while( true ) {\n        if (iVar3 == 0) {\n            return 0;\n        }\n        piVar1 = fcn.00427905(iVar3);\n        if ((piVar1 != NULL) && (iVar2 = (**(*piVar1 + 0x100))(param_2),  iVar2 != 0)) break;\n        if (iVar3 == unaff_retaddr) {\n            return 0;\n        }\n        iVar3 = (*_sym.imp.USER32.dll_GetParent)(iVar3);\n    }\n    return 1;\n}\n",
        "token_count": 186
    },
    "00427ff9": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00427ff9(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint lpMsg;\n    \n    pcVar1 = _sym.imp.USER32.dll_PeekMessageA;\n    while( true ) {\n        iVar2 = (*pcVar1)(&lpMsg, 0, 0x121, 0x121, 1);\n        if (iVar2 == 0) break;\n        (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n    }\n    fcn.0042783b();\n    return;\n}\n",
        "token_count": 127
    },
    "00428388": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.00428388(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetParent;\n    if ((param_1 != 0) && (iVar2 = *(param_1 + 0x1c),  iVar2 != 0)) {\n        while( true ) {\n            uVar3 = (*pcVar1)(iVar2);\n            piVar4 = fcn.004278de(uVar3);\n            if ((piVar4 == NULL) || (iVar2 = (**(*piVar4 + 0x120))(),  iVar2 != 0)) break;\n            iVar2 = piVar4[7];\n        }\n        return piVar4;\n    }\n    return NULL;\n}\n",
        "token_count": 193
    },
    "0042858b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0042858b(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    iVar4 = 0;\n    uVar2 = (*_sym.imp.USER32.dll_GetWindow)(*(param_1 + 0x1c), 5);\n    iVar3 = fcn.004278de(uVar2);\n    while (iVar3 != 0) {\n        uVar2 = (*pcVar1)(*(iVar3 + 0x1c), 2);\n        iVar3 = fcn.004278de(uVar2);\n        iVar4 = iVar4 + 1;\n    }\n    return iVar4;\n}\n",
        "token_count": 178
    },
    "00428b49": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00428b49(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    if ((param_1 != 0) && (iVar1 = *(param_1 + 0x1c),  *(param_1 + 0x1c) != 0)) {\n        do {\n            iVar3 = iVar1;\n            iVar1 = fcn.00428b04(iVar3);\n        } while (iVar1 != 0);\n        uVar2 = fcn.004278de(iVar3);\n        return uVar2;\n    }\n    return 0;\n}\n",
        "token_count": 147
    },
    "0042c6e0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0042c6e0(uint *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (***param_1)();\n    if (param_2 != 0) {\n        for (; iVar1 != 0; iVar1 = *(iVar1 + 0x10)) {\n            if (iVar1 == param_2) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 107
    },
    "00430edf": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * fcn.00430edf(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint unaff_retaddr;\n    \n    iVar1 = fcn.0044be10();\n    fcn.0044ca10(0);\n    for (puVar2 = *(iVar1 + 0x1c); puVar2 != NULL; puVar2 = puVar2[5]) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(unaff_retaddr, *puVar2);\n        if (iVar1 == 0) break;\n    }\n    fcn.0044ca73(0);\n    return puVar2;\n}\n",
        "token_count": 149
    },
    "00436218": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00436218(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *(unaff_EBP + -4) = 0;\n    iVar3 = fcn.0044bde5();\n    iVar1 = *(iVar3 + 0xe4);\n    while (iVar1 == extraout_ECX) {\n        puVar2 = *(iVar3 + 0xe8);\n        *(puVar2[1] + 0xe4) = *puVar2;\n        *(puVar2[1] + 0xe8) = puVar2[2];\n        puVar2[1] = 0;\n        iVar1 = *(iVar3 + 0xe4);\n    }\n    if (*(extraout_ECX + 0x50) != 0) {\n        fcn.00433a87(extraout_ECX);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042823e();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 330
    },
    "0043665a": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0043665a(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    uint *in_FS_OFFSET;\n    \n    fcn.00403164();\n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *(unaff_EBP + -4) = 0;\n    iVar3 = fcn.0044bde5(unaff_ESI, extraout_ECX);\n    iVar1 = *(iVar3 + 0xe4);\n    while (iVar1 == extraout_ECX) {\n        puVar2 = *(iVar3 + 0xe8);\n        *(puVar2[1] + 0xe4) = *puVar2;\n        *(puVar2[1] + 0xe8) = puVar2[2];\n        puVar2[1] = 0;\n        iVar1 = *(iVar3 + 0xe4);\n    }\n    if (*(extraout_ECX + 0x50) != 0) {\n        fcn.00433a87(extraout_ECX);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042823e();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 320
    },
    "0043694d": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0043694d(int32_t hWnd, uint lpPoint, uint arg_10h)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint lpRect;\n    \n    (*_sym.imp.USER32.dll_ClientToScreen)(hWnd, &lpPoint);\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    uVar5 = 5;\n    do {\n        hWnd = (*pcVar1)(hWnd, uVar5);\n        if (hWnd == 0) {\n            return 0;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(hWnd);\n        if ((iVar2 != 0) &&\n           (uVar3 = (*_sym.imp.USER32.dll_GetWindowLongA)(hWnd, 0xfffffff0),  (uVar3 & 0x10000000) != 0)) {\n            (*_sym.imp.USER32.dll_GetWindowRect)(hWnd, &lpRect);\n            iVar4 = (*_sym.imp.USER32.dll_PtInRect)(&lpRect, lpPoint, arg_10h);\n            if (iVar4 != 0) {\n                return hWnd;\n            }\n        }\n        uVar5 = 2;\n    } while( true );\n}\n",
        "token_count": 300
    },
    "00439912": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00439912(int32_t param_1, uint param_2, int32_t param_3)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t unaff_retaddr;\n    \n    iVar2 = 0;\n    if (0 < *(param_1 + 0x9c)) {\n        do {\n            if ((iVar2 != param_3) && (piVar1 = fcn.00405ce7(iVar2),  *piVar1 == unaff_retaddr)) {\n                return iVar2;\n            }\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < *(param_1 + 0x9c));\n    }\n    return -1;\n}\n",
        "token_count": 168
    },
    "00439c27": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00439c27(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = 0;\n    iVar3 = 0;\n    if (0 < *(param_1 + 0x9c)) {\n        do {\n            iVar1 = fcn.0043994f();\n            if (iVar1 != 0) {\n                iVar2 = iVar2 + 1;\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < *(param_1 + 0x9c));\n    }\n    return iVar2;\n}\n",
        "token_count": 147
    },
    "0043a2b7": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043a2b7(int32_t param_1)\n\n{\n    int32_t arg_8h;\n    int32_t iVar1;\n    uint unaff_retaddr;\n    \n    iVar1 = 0;\n    if (0 < *(param_1 + 0x9c)) {\n        do {\n            arg_8h = fcn.0043994f(iVar1);\n            if (arg_8h != 0) {\n                fcn.00441d04();\n                fcn.0044283c(arg_8h, unaff_retaddr, 1);\n            }\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < *(param_1 + 0x9c));\n    }\n    return;\n}\n",
        "token_count": 167
    },
    "0043b07d": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b07d(int32_t *arg_8h, int32_t arg_ch, int32_t *arg_10h)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    \n    piVar2 = arg_8h;\n    fcn.0043af8c(arg_ch);\n    fcn.0042a07f(arg_ch, &arg_8h);\n    if (*piVar2 != 0) {\n        *arg_10h = -1;\n    }\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    arg_ch = 0;\n    while( true ) {\n        uVar3 = (*pcVar1)(arg_8h, 0x87, 0, 0);\n        if ((uVar3 & 0x40) != 0) {\n            if (*piVar2 == 0) {\n                (*pcVar1)(arg_8h, 0xf1, arg_ch == *arg_10h, 0);\n            }\n            else {\n                iVar4 = (*pcVar1)(arg_8h, 0xf0, 0, 0);\n                if (iVar4 != 0) {\n                    *arg_10h = arg_ch;\n                }\n            }\n            arg_ch = arg_ch + 1;\n        }\n        arg_8h = (*_sym.imp.USER32.dll_GetWindow)(arg_8h, 2);\n        if (arg_8h == NULL) break;\n        uVar3 = (*_sym.imp.USER32.dll_GetWindowLongA)(arg_8h, 0xfffffff0);\n        if ((uVar3 & 0x20000) != 0) {\n            return;\n        }\n    }\n    return;\n}\n",
        "token_count": 401
    },
    "0043be93": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.0043be93(int32_t param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    \n    pcVar2 = _sym.imp.USER32.dll_GetParent;\n    iVar3 = param_1;\n    if (param_1 != 0) goto code_r0x0043bec2;\n    iVar3 = fcn.0043be5a();\n    if ((iVar3 == 0) && (iVar3 = fcn.004049c2(),  iVar3 == 0)) {\n        iVar3 = 0;\n        iVar5 = iVar3;\n        iVar6 = iVar3;\n    }\n    else {\n        for (iVar3 = *(iVar3 + 0x1c); iVar5 = iVar3,  iVar6 = iVar3,  iVar3 != 0; iVar3 = (*pcVar2)(iVar3)) {\ncode_r0x0043bec2:\n            uVar4 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar3, 0xfffffff0);\n            iVar5 = iVar3;\n            iVar6 = iVar3;\n            if ((uVar4 & 0x40000000) == 0) break;\n        }\n    }\n    while (iVar1 = iVar5,  iVar1 != 0) {\n        iVar5 = (*pcVar2)(iVar1);\n        iVar3 = iVar1;\n    }\n    if ((param_1 == 0) && (iVar6 != 0)) {\n        iVar6 = (*_sym.imp.USER32.dll_GetLastActivePopup)(iVar6);\n    }\n    if (param_2 != NULL) {\n        if (((iVar3 == 0) || (iVar5 = (*_sym.imp.USER32.dll_IsWindowEnabled)(iVar3),  iVar5 == 0)) || (iVar3 == iVar6))\n        {\n            *param_2 = 0;\n        }\n        else {\n            *param_2 = iVar3;\n            (*_sym.imp.USER32.dll_EnableWindow)(iVar3, 0);\n        }\n    }\n    return iVar6;\n}\n",
        "token_count": 486
    },
    "0043c982": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_14h\n\nuint __cdecl\nfcn.0043c982(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint arg_18h, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint arg_14h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch_2;\n    uint var_10h_2;\n    uint var_14h_2;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    uVar1 = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x10) = &var_14h;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    fcn.00427537(4);\n    iVar2 = (**(*extraout_ECX + 0x5c))\n                      (0, \"AfxMDIFrame70s\", 0, uVar1 & 0xff4fffff, 0, 0, 0, 0, *(*(unaff_EBP + 8) + 0x1c), \n                       *(unaff_EBP + 0x18), 0);\n    if (iVar2 == 0) {\n        uVar4 = 0;\n    }\n    else {\n        iVar2 = extraout_ECX[0x16];\n        *(unaff_EBP + -4) = 0;\n        iVar2 = fcn.00425ce2(iVar2 * 0xc);\n        uVar4 = *(unaff_EBP + 0xc);\n        extraout_ECX[0x23] = iVar2;\n        for (iVar2 = 0; iVar2 < extraout_ECX[0x16]; iVar2 = iVar2 + 1) {\n            iVar3 = iVar2 * 0xc;\n            *(extraout_ECX[0x23] + 4 + iVar3) = uVar4;\n            *(iVar3 + extraout_ECX[0x23]) = uVar4;\n            *(extraout_ECX[0x23] + 8 + iVar3) = 0xffffffff;\n        }\n        iVar2 = fcn.00425ce2(extraout_ECX[0x15] * 0xc);\n        uVar4 = *(unaff_EBP + 0x10);\n        extraout_ECX[0x24] = iVar2;\n        for (iVar2 = 0; iVar2 < extraout_ECX[0x15]; iVar2 = iVar2 + 1) {\n            iVar3 = iVar2 * 0xc;\n            *(extraout_ECX[0x24] + 4 + iVar3) = uVar4;\n            *(iVar3 + extraout_ECX[0x24]) = uVar4;\n            *(extraout_ECX[0x24] + 8 + iVar3) = 0xffffffff;\n        }\n        fcn.0043c35c(*(unaff_EBP + 0x14));\n        uVar4 = 1;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar4;\n}\n",
        "token_count": 795
    },
    "0043fb7e": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0043fb7e(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    uint lpMsg;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetCapture;\n    iVar2 = (*_sym.imp.USER32.dll_GetCapture)();\n    if (iVar2 == 0) {\n        uVar3 = (*_sym.imp.USER32.dll_SetCapture)(*(*(param_1 + 0x68) + 0x1c));\n        fcn.004278de(uVar3);\n        uVar3 = (*pcVar1)();\n        iVar2 = fcn.004278de(uVar3);\n        if (iVar2 == *(param_1 + 0x68)) {\n            do {\n                uVar4 = 0;\n                uVar3 = 0;\n                iVar2 = (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0);\n                if (iVar2 == 0) {\n                    fcn.0046362c(uVar4, var_14h);\n                    break;\n                }\n                if (var_18h == 0x100) {\n                    if (*(param_1 + 0x88) != 0) {\n                        fcn.0043f861(uVar3, 1, var_14h);\n                    }\n                    if (var_14h == 0x1b) break;\n                }\n                else if (var_18h == 0x101) {\n                    if (*(param_1 + 0x88) != 0) {\n                        fcn.0043f861(uVar3, 0, var_14h);\n                    }\n                }\n                else if (var_18h == 0x200) {\n                    if (*(param_1 + 0x88) == 0) {\n                        fcn.0043f895(var_8h, var_4h);\n                    }\n                    else {\n                        fcn.0043f7e2(var_8h, var_4h);\n                    }\n                }\n                else {\n                    if (var_18h == 0x202) {\n                        if (*(param_1 + 0x88) == 0) {\n                            fcn.0043fb3a();\n                        }\n                        else {\n                            fcn.0043fa37();\n                        }\n                        return 1;\n                    }\n                    if (var_18h == 0x204) break;\n                    (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n                }\n                uVar3 = (*pcVar1)();\n                iVar2 = fcn.004278de(uVar3);\n            } while (iVar2 == *(param_1 + 0x68));\n        }\n        fcn.0043f9f2();\n    }\n    return 0;\n}\n",
        "token_count": 654
    },
    "004418f8": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.004418f8(int32_t param_1, int32_t param_2)\n\n{\n    do {\n        if (param_1 == param_2) {\n            return 1;\n        }\n        param_2 = fcn.00428b04();\n    } while (param_2 != 0);\n    return 0;\n}\n",
        "token_count": 76
    },
    "004437ed": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004437ed(void)\n\n{\n    code **ppcVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CFrameWnd.0;\n    *(unaff_EBP + -4) = 2;\n    fcn.0044351a();\n    iVar3 = fcn.0044bde5();\n    ppcVar1 = *(iVar3 + 0xec);\n    while (ppcVar1 == extraout_ECX) {\n        puVar2 = *(iVar3 + 0xf0);\n        *(puVar2[1] + 0xec) = *puVar2;\n        *(puVar2[1] + 0xf0) = puVar2[2];\n        puVar2[1] = 0;\n        ppcVar1 = *(iVar3 + 0xec);\n    }\n    if (extraout_ECX[0x2e] != NULL) {\n        fcn.00425d0d(extraout_ECX[0x2e]);\n    }\n    fcn.00403164();\n    *(unaff_EBP + -4) = 0;\n    fcn.0042486f();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042823e();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 393
    },
    "00444164": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00444164(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    if (arg_ch == 0) {\n        iVar1 = 0;\n        do {\n            if ((*(iVar1 * 8 + 0x46ae94) & 0xf000) == (*(arg_8h + 0x7c) & 0xf000)) {\n                fcn.00442d09(*(iVar1 * 8 + 0x46ae90));\n                break;\n            }\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < 4);\n    }\n    fcn.0043a365(arg_8h, arg_10h);\n    return;\n}\n",
        "token_count": 180
    },
    "0044a755": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0044a755(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    uint uVar3;\n    \n    iVar1 = 1;\n    if (1 < *0x499900) {\n        do {\n            pcVar2 = *(*0x499904 + iVar1 * 4);\n            iVar1 = iVar1 + 1;\n            uVar3 = 0;\n            if ((*pcVar2 == '-') || (*pcVar2 == '/')) {\n                uVar3 = 1;\n                pcVar2 = pcVar2 + 1;\n            }\n            (**(*param_1 + 0xc))(pcVar2, uVar3, iVar1 == *0x499900);\n        } while (iVar1 < *0x499900);\n    }\n    return;\n}\n",
        "token_count": 182
    },
    "0044c44f": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0044c44f(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    \n    iVar4 = *param_1;\n    uVar3 = 0;\n    if (iVar4 != 0) {\n        if (iVar4 == param_2) {\n            *param_1 = *(param_2 + param_1[1]);\n        }\n        else {\n            iVar1 = param_1[1];\n            do {\n                iVar2 = *(iVar1 + iVar4);\n                if (iVar2 == param_2) break;\n                iVar4 = iVar2;\n            } while (iVar2 != 0);\n            if (iVar4 == 0) {\n                return 0;\n            }\n            *(iVar1 + iVar4) = *(iVar1 + param_2);\n        }\n        uVar3 = 1;\n    }\n    return uVar3;\n}\n",
        "token_count": 223
    },
    "0044c502": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c502(int32_t arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    uint lpCriticalSection;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 0x1c);\n    if ((0 < arg_8h) && (arg_8h < *(in_ECX + 0xc))) {\n        for (iVar3 = *(in_ECX + 0x14); iVar3 != 0; iVar3 = *(iVar3 + 4)) {\n            if (arg_8h < *(iVar3 + 8)) {\n                puVar2 = *(*(iVar3 + 0xc) + arg_8h * 4);\n                if (puVar2 != NULL) {\n                    (***puVar2)(1);\n                }\n                *(*(iVar3 + 0xc) + arg_8h * 4) = 0;\n            }\n        }\n        puVar1 = *(in_ECX + 0x10) + arg_8h * 8;\n        *puVar1 = *puVar1 & 0xfffffffe;\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 0x1c);\n    }\n    return;\n}\n",
        "token_count": 295
    },
    "004502a7": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004502a7(int32_t **arg_8h, int32_t *arg_ch, uint *arg_10h)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint var_20h;\n    int32_t var_1ch;\n    uint var_4h;\n    \n    piVar2 = arg_ch;\n    ppiVar1 = arg_8h;\n    *arg_8h = NULL;\n    *arg_ch = 0;\n    piVar3 = fcn.0044fcc1(*(in_ECX + 0x20), 0x4760dc);\n    if (piVar3 != NULL) {\n        iVar4 = (**(*piVar3 + 0x14))(piVar3, &arg_8h);\n        if ((iVar4 == 0) && (arg_8h != NULL)) {\n            while (iVar4 = (*(*arg_8h)[3])(arg_8h, 1, &var_20h, 0),  iVar4 == 0) {\n                if (var_1ch != 0) {\n                    if (arg_10h != NULL) {\n                        *arg_10h = var_4h;\n                    }\n                    *piVar2 = var_1ch;\n                    (*(*arg_8h)[2])(arg_8h);\n                    *ppiVar1 = piVar3;\n                    return 1;\n                }\n            }\n            (*(*arg_8h)[2])(arg_8h);\n        }\n        (**(*piVar3 + 8))(piVar3);\n    }\n    return 0;\n}\n",
        "token_count": 381
    },
    "00450967": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00450967(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t var_4h;\n    \n    piVar1 = *(param_1 + 0x1c);\n    iVar3 = piVar1[0x1b];\n    var_4h = param_1;\n    while( true ) {\n        var_4h = (**(*piVar1 + 0xb4))();\n        iVar2 = fcn.0044f097(&var_4h);\n        if (iVar2 == 0) break;\n        do {\n            if (*(iVar2 + 0x28) == iVar3) break;\n            iVar2 = fcn.0044f097();\n        } while (iVar2 != 0);\n        if (iVar2 == 0) break;\n        iVar3 = iVar3 + 1;\n    }\n    piVar1[0x1b] = iVar3 + 1;\n    return iVar3;\n}\n",
        "token_count": 232
    },
    "00458a26": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00458a26(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    var_4h = (**(*in_ECX + 0xb4))();\n    while( true ) {\n        iVar1 = fcn.0044f0a8(&var_4h);\n        if (iVar1 == 0) break;\n        fcn.0045c0d7();\n    }\n    return;\n}\n",
        "token_count": 117
    },
    "00458a5b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00458a5b(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    (**(*in_ECX + 0xb4))();\n    while( true ) {\n        piVar1 = fcn.0044f0a8();\n        if (piVar1 == NULL) break;\n        if (piVar1 != arg_8h) {\n            (**(*piVar1 + 0x58))(arg_8h, arg_ch, arg_10h, arg_14h);\n        }\n    }\n    return;\n}\n",
        "token_count": 160
    },
    "00459e1c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00459e1c(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    var_4h = (**(*in_ECX + 0xb4))();\n    do {\n        iVar2 = fcn.0044f0a8(&var_4h);\n        if (iVar2 == 0) {\n            return 0;\n        }\n        iVar1 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(*(iVar2 + 0x30), arg_8h);\n    } while (iVar1 != 0);\n    return iVar2;\n}\n",
        "token_count": 155
    },
    "0045b139": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid fcn.0045b139(void)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    *(unaff_EBP + -4) = 1;\n    fcn.00459cb1();\n    if (*(extraout_ECX + 0xbc) != 0) {\n        fcn.0044fd2a();\n        *(extraout_ECX + 0xbc) = 0;\n    }\n    uVar2 = fcn.0044f331();\n    *(unaff_EBP + -0x10) = uVar2;\n    while( true ) {\n        iVar3 = fcn.0044f0a8(unaff_EBP + -0x10);\n        if (iVar3 == 0) break;\n        fcn.0044f03b();\n    }\n    piVar1 = *(extraout_ECX + 0xd0);\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 4))(1);\n        *(extraout_ECX + 0xd0) = NULL;\n    }\n    fcn.0044fce5(extraout_ECX + 0x78);\n    fcn.0044fce5(extraout_ECX + 0xac);\n    fcn.00403164();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00456c3f();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 451
    },
    "0045cc11": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0045cc11(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = 0;\n    if (0 < param_1[1]) {\n        do {\n            fcn.0040d958(*(*param_1 + iVar1 * 4));\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < param_1[1]);\n    }\n    fcn.00425d0d(*param_1);\n    return;\n}\n",
        "token_count": 113
    },
    "004636c1": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.004636c1(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0044be10();\n    fcn.0044ca10(0);\n    for (iVar1 = *(iVar1 + 0x24); iVar1 != 0; iVar1 = *(iVar1 + 0x1c)) {\n        fcn.00463648();\n    }\n    fcn.0044ca73(0);\n    return;\n}\n",
        "token_count": 103
    },
    "0041921e": {
        "rules": [
            "get geographical location"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041921e(uint Locale)\n\n{\n    int32_t iVar1;\n    uint lpLCData;\n    uchar var_6h;\n    uint var_4h;\n    \n    var_4h = *0x496830;\n    var_6h = 0;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)(Locale, 0x1004, &lpLCData, 6);\n    if (iVar1 != 0) {\n        fcn.0041026e(&lpLCData);\n    }\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 136
    },
    "00429d0c": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\nuint fcn.00429d0c(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t arg_8h;\n    int32_t iVar3;\n    \n    iVar3 = 0;\n    arg_8h = 0;\n    if (param_1 != 0) {\n        iVar1 = fcn.0044be10();\n        uVar2 = *(iVar1 + 0xc);\n        iVar1 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar2, param_1, 0xf0);\n        if (iVar1 != 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar2, iVar1);\n            if (iVar3 == 0) {\n                return 0;\n            }\n            arg_8h = (*_sym.imp.KERNEL32.dll_LockResource)(iVar3);\n        }\n    }\n    uVar2 = fcn.00428e71(arg_8h);\n    if ((arg_8h != 0) && (iVar3 != 0)) {\n        (*_sym.imp.KERNEL32.dll_FreeResource)(iVar3);\n    }\n    return uVar2;\n}\n",
        "token_count": 264
    },
    "0042b906": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042b906(uint lpName, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint noname_4;\n    uint uVar2;\n    uint in_ECX;\n    uint unaff_EBX;\n    uint noname_0;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint noname_3;\n    uint noname_5;\n    uint noname_6;\n    uint noname_7;\n    uint var_4h;\n    \n    noname_0 = 0;\n    iVar1 = fcn.0044be10();\n    uVar2 = *(iVar1 + 0xc);\n    noname_7 = 5;\n    noname_5 = uVar2;\n    noname_6 = lpName;\n    noname_4 = (*_sym.imp.KERNEL32.dll_FindResourceA)();\n    noname_3 = uVar2;\n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadResource)();\n    if (iVar1 != 0) {\n        noname_0 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar1);\n    }\n    uVar2 = fcn.0042b551(noname_0, arg_ch, uVar2, noname_3, noname_4, noname_5, noname_6, noname_7, unaff_EDI, unaff_ESI\n                         , unaff_EBX, in_ECX, unaff_EBP, unaff_retaddr, lpName, arg_ch, in_stack_0000000c, \n                         in_stack_00000010, in_stack_00000014, in_stack_00000018, in_stack_0000001c);\n    (*_sym.imp.KERNEL32.dll_FreeResource)(iVar1);\n    return uVar2;\n}\n",
        "token_count": 472
    },
    "0042b95c": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\nvoid fcn.0042b95c(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_LockResource)(param_1);\n    fcn.0042b8db(uVar1, param_1, 0, param_2);\n    return;\n}\n",
        "token_count": 77
    },
    "00404d88": {
        "rules": [
            "link function at runtime on Windows",
            "link many functions at runtime"
        ],
        "decompiled_code": "\nbool fcn.00404d88(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    if (*0x49923c != 0) {\n        return *0x499230 != 0;\n    }\n    *0x499240 = fcn.00404d3b();\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"USER32\");\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (((((iVar2 != 0) && (*0x499220 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x46a294),  *0x499220 != 0)) &&\n         (*0x499224 = (*pcVar1)(iVar2, \"MonitorFromWindow\"),  *0x499224 != 0)) &&\n        ((*0x499228 = (*pcVar1)(iVar2, \"MonitorFromRect\"),  *0x499228 != 0 &&\n         (*0x49922c = (*pcVar1)(iVar2, \"MonitorFromPoint\"),  *0x49922c != 0)))) &&\n       ((*0x499234 = (*pcVar1)(iVar2, \"EnumDisplayMonitors\"),  *0x499234 != 0 &&\n        ((*0x499230 = (*pcVar1)(iVar2, \"GetMonitorInfoA\"),  *0x499230 != 0 &&\n         (*0x499238 = (*pcVar1)(iVar2, \"EnumDisplayDevicesA\"),  *0x499238 != 0)))))) {\n        *0x49923c = 1;\n        return true;\n    }\n    *0x499220 = 0;\n    *0x499224 = 0;\n    *0x499228 = 0;\n    *0x49922c = 0;\n    *0x499230 = 0;\n    *0x499234 = 0;\n    *0x499238 = 0;\n    *0x49923c = 1;\n    return false;\n}\n",
        "token_count": 446
    },
    "0040f2b1": {
        "rules": [
            "link function at runtime on Windows",
            "terminate process"
        ],
        "decompiled_code": "\nvoid fcn.0040f2b1(void)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    uint unaff_retaddr;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"mscoree.dll\");\n    if (iVar1 != 0) {\n        pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"CorExitProcess\");\n        if (pcVar2 != NULL) {\n            (*pcVar2)(unaff_retaddr);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_ExitProcess)(unaff_retaddr);\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 155
    },
    "004269b9": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint32_t fcn.004269b9(void)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint32_t unaff_ESI;\n    uint32_t uVar5;\n    uint unaff_EDI;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"COMCTL32.DLL\");\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"COMCTL32.DLL\");\n    uVar5 = uVar2;\n    if (uVar2 != 0) {\n        pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2, 0x46a678);\n        uVar5 = 0;\n        if (pcVar3 == NULL) {\n            if ((unaff_ESI & 0x3fc0) == unaff_ESI) {\n                (*_sym.imp.COMCTL32.dll_InitCommonControls)();\n                uVar5 = 0x3fc0;\n            }\n        }\n        else {\n            iVar4 = (*pcVar3)(unaff_EDI);\n            if ((iVar4 != 0) && (uVar5 = unaff_ESI,  iVar1 == 0)) {\n                (*_sym.imp.COMCTL32.dll_InitCommonControls)();\n                uVar5 = unaff_ESI | 0x3fc0;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_FreeLibrary)(uVar2);\n    }\n    return uVar5;\n}\n",
        "token_count": 334
    },
    "004318e6": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004318e6(int32_t param_1)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"GDI32.DLL\");\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, \"GetLayout\");\n    if (pcVar2 == NULL) {\n        uVar1 = 0xffffffff;\n        (*_sym.imp.KERNEL32.dll_SetLastError)(0x78);\n    }\n    else {\n        uVar1 = (*pcVar2)(*(param_1 + 4));\n    }\n    return uVar1;\n}\n",
        "token_count": 148
    },
    "0043191c": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0043191c(int32_t param_1)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t unaff_EDI;\n    uint uVar3;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"GDI32.DLL\");\n    uVar3 = 0;\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, \"SetLayout\");\n    if (pcVar2 == NULL) {\n        if (unaff_EDI != 0) {\n            uVar3 = 0xffffffff;\n            (*_sym.imp.KERNEL32.dll_SetLastError)(0x78);\n        }\n    }\n    else {\n        uVar3 = (*pcVar2)(*(param_1 + 4), unaff_EDI);\n    }\n    return uVar3;\n}\n",
        "token_count": 190
    },
    "0040806b": {
        "rules": [
            "find graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040806b(uint *arg_8h, int32_t *arg_ch, int32_t *arg_10h, uint *arg_14h, uint *arg_18h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint var_4h;\n    \n    uVar2 = (*_sym.imp.USER32.dll_FindWindowA)(\"MouseZ\", \"Magellan MSWHEEL\");\n    pcVar1 = _sym.imp.USER32.dll_RegisterWindowMessageA;\n    uVar3 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(\"MSWHEEL_ROLLMSG\");\n    *arg_8h = uVar3;\n    iVar4 = (*pcVar1)(\"MSH_WHEELSUPPORT_MSG\");\n    *arg_ch = iVar4;\n    iVar4 = (*pcVar1)(\"MSH_SCROLL_LINES_MSG\");\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    *arg_10h = iVar4;\n    if (*arg_ch == 0) {\n        *arg_14h = 0;\n    }\n    else {\n        uVar3 = (*pcVar1)(uVar2, *arg_ch, 0, 0);\n        *arg_14h = uVar3;\n    }\n    if (*arg_10h == 0) {\n        *arg_18h = 3;\n    }\n    else {\n        uVar3 = (*pcVar1)(uVar2, *arg_10h, 0, 0);\n        *arg_18h = uVar3;\n    }\n    return uVar2;\n}\n",
        "token_count": 360
    },
    "0044baf2": {
        "rules": [
            "set application hook"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044baf2(code **param_1)\n\n{\n    code *pcVar1;\n    \n    pcVar1 = _sym.imp.USER32.dll_UnhookWindowsHookEx;\n    *param_1 = vtable._AFX_THREAD_STATE.0;\n    if (param_1[0xb] != NULL) {\n        (*pcVar1)(param_1[0xb]);\n    }\n    if (param_1[10] != NULL) {\n        (*pcVar1)(param_1[10]);\n    }\n    if (param_1[3] != NULL) {\n        fcn.0040d958(param_1[3]);\n    }\n    return;\n}\n",
        "token_count": 148
    },
    "0042eae4": {
        "rules": [
            "move file"
        ],
        "decompiled_code": "\nvoid fcn.0042eae4(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_MoveFileA)(param_1, param_2);\n    if (iVar1 == 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(param_2);\n        fcn.004301a1(uVar2);\n    }\n    return;\n}\n",
        "token_count": 107
    },
    "0042eb09": {
        "rules": [
            "delete file"
        ],
        "decompiled_code": "\nvoid fcn.0042eb09(uint param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint unaff_retaddr;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_DeleteFileA)(param_1);\n    if (iVar1 == 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(unaff_retaddr);\n        fcn.004301a1(uVar2);\n    }\n    return;\n}\n",
        "token_count": 105
    },
    "0044ccd6": {
        "rules": [
            "query or enumerate registry value",
            "read .ini file"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0044ccd6(uint arg_8h, uint lpAppName, uint lpKeyName, uint lpDefault)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint uVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_1020h;\n    uint var_101ch;\n    uint var_1018h;\n    uint hKey;\n    uint lpReturnedString;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_4h;\n    \n    fcn.0040e188();\n    fcn.0040dc10();\n    uVar4 = *0x496830;\n    *(unaff_EBP + -0x101c) = 0;\n    iVar2 = *(extraout_ECX + 0x50);\n    *(unaff_EBP + -0x10) = uVar4;\n    if (iVar2 == 0) {\n        if (*(unaff_EBP + 0x14) == 0) {\n            *(unaff_EBP + 0x14) = 0x469144;\n        }\n        (*_sym.imp.KERNEL32.dll_GetPrivateProfileStringA)\n                  (*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), unaff_EBP + -0x1010, 0x1000, \n                   *(extraout_ECX + 100));\n        var_ch = unaff_EBP + -0x1010;\n    }\n    else {\n        iVar2 = fcn.0044cc27(*(unaff_EBP + 0xc));\n        *(unaff_EBP + -0x1014) = iVar2;\n        if (iVar2 != 0) {\n            piVar3 = fcn.0042c770();\n            iVar2 = (**(*piVar3 + 0xc))();\n            *(unaff_EBP + 0xc) = iVar2 + 0x10;\n            pcVar1 = _sym.imp.ADVAPI32.dll_RegQueryValueExA;\n            *(unaff_EBP + -4) = 0;\n            iVar2 = (*pcVar1)(*(unaff_EBP + -0x1014), *(unaff_EBP + 0x10), 0, unaff_EBP + -0x101c, 0, \n                              unaff_EBP + -0x1020);\n            *(unaff_EBP + -0x1018) = iVar2;\n            if (iVar2 == 0) {\n                uVar4 = fcn.004043ec(*(unaff_EBP + -0x1020), unaff_EBP + -0x1020);\n                uVar4 = (*pcVar1)(*(unaff_EBP + -0x1014), *(unaff_EBP + 0x10), 0, unaff_EBP + -0x101c, uVar4);\n                *(unaff_EBP + -0x1018) = uVar4;\n                fcn.00404cad(0xffffffff);\n            }\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(*(unaff_EBP + -0x1014));\n            if (*(unaff_EBP + -0x1018) == 0) {\n                fcn.004039b4(unaff_EBP + 0xc);\n            }\n            else {\n                fcn.004045fc(*(unaff_EBP + 0x14));\n            }\n            fcn.00403164();\n            goto code_r0x0044ce0a;\n        }\n        var_ch = *(unaff_EBP + 0x14);\n    }\n    fcn.004045fc(var_ch);\ncode_r0x0044ce0a:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0040e60a();\n    return;\n}\n",
        "token_count": 919
    },
    "0044c302": {
        "rules": [
            "get thread local storage value"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0044c302(uint *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_retaddr;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(param_1 + 7);\n    if ((0 < unaff_retaddr) && (unaff_retaddr < param_1[3])) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*param_1);\n        if ((iVar1 != 0) && (unaff_retaddr < *(iVar1 + 8))) {\n            uVar2 = *(*(iVar1 + 0xc) + unaff_retaddr * 4);\n            goto code_r0x0044c339;\n        }\n    }\n    uVar2 = 0;\ncode_r0x0044c339:\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(param_1 + 7);\n    return uVar2;\n}\n",
        "token_count": 210
    }
}