{
    "18000100": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\nint32_t fcn.180001000(uint8_t *arg1, int64_t arg2, int64_t arg3, int64_t arg4)\n\n{\n    int64_t *piVar1;\n    int32_t *piVar2;\n    uint32_t *puVar3;\n    int64_t iVar4;\n    uint8_t uVar5;\n    int32_t iVar6;\n    int64_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint uVar11;\n    uint16_t uVar12;\n    uint16_t uVar13;\n    uint32_t uVar14;\n    int32_t iVar15;\n    int32_t iVar16;\n    int64_t iVar17;\n    uint64_t uVar18;\n    int32_t iVar19;\n    int32_t iVar20;\n    int64_t iVar21;\n    uint32_t uStackX8;\n    int64_t in_stack_00000028;\n    uint32_t in_stack_00000030;\n    uint32_t uStack88;\n    \n    // [00] -r-x section size 49152 named .text\n    uVar14 = in_stack_00000030 & 0xffff;\n    iVar21 = *(arg3 + (in_stack_00000030 + 1) * 3 * 4);\n    uVar5 = arg1[in_stack_00000030 + 0x1d];\n    uStack88 = *0x180075960 + 0xc8c;\n    iVar6 = *(arg3 + *0x180075960 * 4);\n    iVar17 = *(arg3 + *arg1 * 8);\n    iVar7 = *(*0x180075940 + *0x180075948 * 8);\n    *0x180075974 = *(uVar14 * 2 * 4 + 0x1a77) + *(arg4 + *0x180075998 * 8) & *0x180075938;\n    piVar1 = iVar17 + *0x180075930 * 8;\n    *piVar1 = *piVar1 + *0x180075928;\n    piVar2 = arg3 + (in_stack_00000030 + 6) * 4;\n    *piVar2 = *piVar2 + *0x180075930;\n    *0x180075930 = *0x180075930 - 1;\n    iVar19 = in_stack_00000030 - 1;\n    *0x180075998 = *0x180075998 + *(iVar7 + in_stack_00000030 * 8) % *(in_stack_00000028 + *arg1 * 8) + -0x460;\n    arg1[uVar14 + 8] = arg1[uVar14 + 8] ^ *(iVar7 + 0xe110) - *0x18007593c;\n    piVar2 = arg3 + iVar19 * 4;\n    uVar12 = uVar14 + 1;\n    iVar20 = in_stack_00000030 - 2;\n    *piVar2 = *piVar2 + ((*(arg2 + (uVar14 + 3) * 4) + iVar19 | *(arg3 + 0x2530)) - iVar19);\n    uVar13 = uVar12;\n    if (0xb5c < *0x180075930) {\n        iVar19 = iVar20 * 3;\n        iVar15 = *0x180075930 * 3;\n        iVar16 = iVar20 * 2;\n        uVar14 = *0x180075930;\n        do {\n            uVar13 = uVar12 + 1;\n            iVar4 = iVar15 * 8;\n            *(iVar4 + in_stack_00000028) = 0x163f - *(iVar4 + in_stack_00000028);\n            uVar18 = uVar14;\n            arg1[uVar12 + 2] = arg1[uVar12 + 2] + *(uVar18 * 2 + 0x1ad4);\n            uStackX8 = uVar5;\n            *(uVar13 * 4 + 0x1a77) = (uStackX8 & uVar14) - *(uVar13 * 4 + 0x1a77);\n            *0x180075970 = *0x180075970 + uVar14;\n            uVar13 = uVar13 * uVar14;\n            *(arg3 + uVar18 * 4) = uVar14 * 2;\n            *0x180075934 = *0x180075934 * arg1[iVar16];\n            if (*(*0x180075978 + (iVar20 + -1) * 8) == *(iVar4 + iVar17)) {\n                *0x180075970 = *0x180075970 + 0x23c7;\n                break;\n            }\n            uVar12 = uVar13 - 1;\n            if ((uVar18 <= *(iVar21 + uVar12 * 8)) ||\n               (iVar8 = iVar20 + -1,  iVar9 = iVar19 + -3,  iVar10 = iVar16 + -2,  *0x180075960 < uVar18)) {\n                iVar8 = iVar20 + -2;\n                iVar9 = iVar19 + -6;\n                iVar10 = iVar16 + -4;\n                if ((*(arg3 + (iVar19 + -3) * 4) < uVar14) && (*(arg2 + uVar12 * 0xc) == 0x7d)) {\n                    arg1[uVar14] = arg1[uVar14] & *(arg2 + (uVar14 + 0x25) * 4);\n                    puVar3 = arg3 + (uVar13 + uVar13 * 2) * 4;\n                    *puVar3 = *puVar3 | uVar14;\n                    uVar11 = fcn.18000b420(*(iVar7 + uVar14 * 2 * 8) & 0xf12, uVar14 & 0xffff, uVar14 & 0x1157, \n                                           uVar5 + 1);\n                    *(arg2 + (uVar14 + 2) * 4) = uVar11;\n                    arg1[*0x180075960 * 3] =\n                         (uVar14 / 0x1947 | *((uVar14 + 7) * 2 + 0x1ad4)) % *(iVar6 + uVar14 * 8) -\n                         arg1[*0x180075960 * 3];\n                    arg1[uVar13] = arg1[uVar13] | uVar14;\n                    puVar3 = *0x180075980 + (*0x180075998 + 3) * 4;\n                    *puVar3 = *puVar3 & (*(iVar21 + 0xc0 + (uVar13 - 1) * 0x18) ^ uStack88) & *0x1cb0;\n                    uVar13 = *((uVar13 - 1) * 2 + 0x1ad4);\n                    goto code_r0x000180001382;\n                }\n            }\n            iVar16 = iVar10;\n            iVar19 = iVar9;\n            iVar20 = iVar8;\n            uVar14 = uVar14 + 1;\n            iVar15 = iVar15 + 3;\n            uVar13 = uVar12;\n        } while (0xb5c < uVar14);\n    }\n    uVar13 = *(uVar13 * 2 + 0x1ad4);\ncode_r0x000180001382:\n    return 0x14f6 - uVar13;\n}\n",
        "token_count": 1685
    },
    "1800025d": {
        "rules": [
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43",
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a"
        ],
        "decompiled_code": "\nuint fcn.1800025d0(ulong arg1, int64_t arg2, int64_t arg3, uint8_t *arg4)\n\n{\n    int16_t *piVar1;\n    uchar auVar2 [16];\n    int64_t iVar3;\n    int64_t iVar4;\n    uint16_t *puVar5;\n    uint32_t uVar6;\n    uint64_t uVar7;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    uint64_t uVar10;\n    int32_t iVar11;\n    uint16_t uVar12;\n    uint64_t uVar13;\n    uint64_t uVar14;\n    int64_t in_stack_00000028;\n    int16_t in_stack_00000038;\n    int64_t in_stack_00000040;\n    uint16_t in_stack_00000048;\n    uint64_t in_stack_00000058;\n    \n    uVar12 = 0x8d5;\n    uVar14 = arg4[0x1464];\n    iVar3 = *(*0x180075978 + 0xac0);\n    uVar13 = *(in_stack_00000040 + 0x1cf0);\n    uVar7 = *0x180075928;\n    iVar11 = *(in_stack_00000040 + (*(*0x1800759a0 + 0xc6e) - 0xd02) * 8);\n    uVar10 = iVar11;\n    uVar6 = *0x180075928;\n    if (*0x242e <= uVar10) {\n        iVar4 = uVar10 * 8;\n        iVar11 = 0x16d0 - iVar11;\n        puVar5 = uVar7 * 2 + arg3;\n        do {\n            *0x180075960 = iVar11 / *0x180075960;\n            uVar12 = uVar12 + 1;\n            iVar4 = iVar4 + 8;\n            uVar6 = uVar7 + 1;\n            uVar7 = uVar6;\n            iVar11 = iVar11 + -1;\n            *(*0x180075940 + -8 + iVar4) = (*puVar5 | 0x84f) - *(*0x180075940 + -8 + iVar4);\n            uVar8 = uVar10;\n            uVar9 = uVar8 + 1;\n            uVar10 = uVar9;\n            *0x180075974 = *0x180075974 ^ (uVar12 ^ uVar8) / 0x466;\n            puVar5 = puVar5 + 1;\n        } while (*0x242e <= uVar9);\n    }\n    uVar7 = in_stack_00000048;\n    uVar13 = uVar13 / 0x113a & 0xff;\n    *0x180075968 = *0x180075960 / (in_stack_00000058 ^ 0x17b) | uVar13;\n    iVar3 = *0x180075958 + (0x81a - iVar3) * 2;\n    *(iVar3 + 0x50) =\n         SUB162((ZEXT816(0) << 0x40 |\n                ZEXT816(*(arg3 + 4 + uVar7 * 6) & *0x180075974) % ZEXT816(*0x2d6e) & 0xffffffffffffffff) /\n                ZEXT216(*(iVar3 + 0x50)), 0);\n    if (*(in_stack_00000028 + 0x1860) < 0xb25) {\n        if ((*(uVar12 * 8 + 0x440) < 0x177f) && (*(uVar14 + 0x30 + uVar13 * 8) == 0x8e9)) {\n            *(uVar14 + uVar7 * 8) = 0xd81;\n            *0x180075990 = *0x180075990 + 0x1bfc;\n            piVar1 = uVar6 * 2 + 0xf79;\n            *piVar1 = *piVar1 + *(arg2 + uVar6 * 4);\n            *(in_stack_00000040 + (*0x180075960 + 4) * 0x10) = *0x180075900 / 0xb24;\n            return *((in_stack_00000048 + 1) * 0x18 + 0x175f);\n        }\n    }\n    else {\n        *0x180075930 = *0x180075930 + -1;\n        iVar11 = fcn.180009470(0x5b1, arg1, *(arg2 + *arg4 * 4) | *(arg3 + *arg4 * 6), 0x45);\n        *(in_stack_00000040 + *0x180075918 * 8) = iVar11;\n        *(in_stack_00000028 + uVar7 * 2) = *(in_stack_00000028 + uVar7 * 2) * in_stack_00000038;\n        auVar2 = (ZEXT816(0) << 0x40 | ZEXT816(0x126)) % ZEXT816(*(uVar14 + 0xe8d8));\n        iVar3 = SUB168(auVar2, 0);\n        iVar4 = SUB168(ZEXT816(0x4afd6a052bf5a815) * (auVar2 & 0xffffffffffffffff) >> 0x40, 0);\n        *((uVar6 + 0x1f) * 8 + 0x175f) =\n             (iVar3 + ((iVar3 - iVar4 >> 1) + iVar4 >> 7) * -0xc6) - *((uVar6 + 0x1f) * 8 + 0x175f);\n    }\n    return *(uVar7 * 0x18 + 0x175f);\n}\n",
        "token_count": 1308
    },
    "18000717": {
        "rules": [
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43",
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x000180007204)\n// WARNING: Removing unreachable block (ram,0x000180007208)\n// WARNING: Removing unreachable block (ram,0x000180007211)\n// WARNING: Removing unreachable block (ram,0x000180007220)\n// WARNING: Removing unreachable block (ram,0x000180007224)\n\nint32_t fcn.180007170(void)\n\n{\n    int64_t *piVar1;\n    int64_t arg1;\n    int32_t iVar2;\n    int64_t *piVar3;\n    int32_t iStack52;\n    \n    iStack52 = 0;\n    fcn.1800052b4(8);\n    piVar1 = *0x1800761d0 + *0x1800761c8;\n    for (piVar3 = *0x1800761d0; piVar3 != piVar1; piVar3 = piVar3 + 1) {\n        arg1 = *piVar3;\n        if (arg1 != 0) {\n            fcn.180005f58(arg1);\n            if (((*(arg1 + 0x14) >> 0xd & 1) != 0) && (iVar2 = fcn.180007124(arg1),  iVar2 != -1)) {\n                iStack52 = iStack52 + 1;\n            }\n            fcn.180005f64(arg1);\n        }\n    }\n    fcn.1800052d0(8);\n    return iStack52;\n}\n",
        "token_count": 337
    },
    "18000b42": {
        "rules": [
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43",
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a"
        ],
        "decompiled_code": "\nuchar fcn.18000b420(int64_t arg1, ulong arg2, int64_t arg3, ulong arg4)\n\n{\n    uint32_t *puVar1;\n    uint64_t *puVar2;\n    int32_t iVar3;\n    uint64_t uVar4;\n    uint16_t uVar5;\n    uint32_t uVar6;\n    int64_t iVar7;\n    uint64_t uVar8;\n    int64_t in_stack_00000028;\n    \n    uVar8 = *(arg1 + 0x9600) | arg4 + 1;\n    iVar3 = *(arg1 + *0x180075930 * 8);\n    uVar4 = *(in_stack_00000028 + 0x7730);\n    uVar5 = *(*0x180075958 + 0x54a);\n    puVar1 = uVar5 + ((uVar5 - uVar5 / 0x7f >> 1) + uVar5 / 0x7f >> 0xb) * -0xfe0 + uVar8 * 4;\n    *(arg3 + 0x8cf8) = 0xf72 / *(arg3 + 0x8cf8);\n    *puVar1 = *puVar1 & *(arg1 + arg4 * 8) * (0x9a5 % *0x180075948);\n    iVar7 = SUB168(ZEXT816(0x376d69001376d691) * ZEXT816(*(in_stack_00000028 + 0x73d0)) >> 0x40, 0);\n    *(arg3 + uVar8 * 4) = (iVar7 + (*(in_stack_00000028 + 0x73d0) - iVar7 >> 1) >> 0xb) % *(arg3 + uVar8 * 4);\n    *0x180075998 = *0x180075998 + 1;\n    *0x180075960 = *0x180075960 * *0x180075998;\n    puVar1 = arg3 + *0x180075960 * 4;\n    *puVar1 = *puVar1 & arg4 - 1U;\n    *0x180075998 = *0x180075970 % *0x180075998;\n    uVar6 = *0x180075900;\n    *0x180075970 = *0x180075970 + 1;\n    if (0xe95 < uVar6) {\n        puVar2 = uVar4 / 0x10c7 + iVar3 * 8;\n        do {\n            *0x180075974 = 0x118f / *0x180075974;\n            *0x18007593c = *0x18007593c + -1;\n            *puVar2 = *0x18007593c % *puVar2;\n            uVar5 = uVar6;\n            uVar6 = uVar6 + 1;\n            *0x180075938 = (*0x180075938 ^ uVar5) * ((*(*0x180075910 + 0x120b) - uVar5) + -0xdd1);\n        } while (0xe95 < uVar6);\n    }\n    return *((arg4 - 1U) * 2 + *0x180075950);\n}\n",
        "token_count": 734
    },
    "18000c00": {
        "rules": [
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43",
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a"
        ],
        "decompiled_code": "\nint32_t fcn.18000c000(int64_t arg1, int64_t arg2, int64_t arg3, ulong arg4)\n\n{\n    uint64_t *puVar1;\n    uint16_t *puVar2;\n    uint8_t uVar3;\n    uchar uVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int64_t iVar7;\n    uint16_t uVar8;\n    char *pcVar9;\n    uint64_t uVar10;\n    int32_t *piVar11;\n    uint64_t uVar12;\n    int64_t in_stack_00000028;\n    int64_t in_stack_00000030;\n    uint8_t in_stack_00000038;\n    int64_t in_stack_00000040;\n    int64_t in_stack_00000048;\n    int64_t in_stack_00000050;\n    \n    *0x180075970 = *0x180075970 + -1;\n    uVar12 = 0x691;\n    uVar10 = *0x180075970 / 0x1e40;\n    uVar3 = *(*0x180075950 + 0xb66);\n    *(*0x180075998 * 2 + 0xb7d) = *(in_stack_00000030 + 0x691) / *(*0x180075998 * 2 + 0xb7d);\n    *0x180075998 = *0x180075998 - 1;\n    uVar8 = *0x180075938 + 1;\n    *0x180075948 = *0x180075948 + 1;\n    *0x180075938 = SUB162(ZEXT816((uVar8 + (uVar8 / 0xe62) * -0xe62 + -0x1a) * 0x1058 + *0x4cbd) % ZEXT216(uVar8), 0);\n    pcVar9 = *0x180075948 * 4 + *0x180075950;\n    *pcVar9 = SUB161((ZEXT816(0) << 0x40 | ZEXT816(0xadc)) / ZEXT816(uVar10), 0) - *pcVar9;\n    *0x180075918 = *0x180075918 + 0x8467ca;\n    if (((*(in_stack_00000048 + arg4 * 2 * 2) != uVar10) || (*(*0xb7d + in_stack_00000040) < *(arg2 + 0x2458))) ||\n       (*0x180075968 != *0x180075934)) {\n        uVar12 = 0x68f;\n        puVar1 = in_stack_00000028 + *0xb7d * 8;\n        *puVar1 = *puVar1 & uVar10;\n        *0x180075900 = 0x1c9b;\n        iVar7 = SUB168(ZEXT816(0x83c977ab2bedd28f) * ZEXT816(*(in_stack_00000028 + 0xd220)) >> 0x40, 0);\n        *0x180075988 = (iVar7 + (*(in_stack_00000028 + 0xd220) - iVar7 >> 1) >> 7) % *0x180075988;\n        uVar10 = *(arg3 + *0xb7d * 8);\n        *(arg3 + *0xb7d * 8) = 0x4d / uVar10;\n        uVar4 = fcn.18000a050(*(in_stack_00000050 + 0x7470), 0x4dU % uVar10 & 0xffffffffffffff00 | *0x8071, 0x6fdfe, \n                              *(in_stack_00000030 + 0x68f) + *(*0x180075908 + (arg4 + -1) * 4 * 8));\n        *(in_stack_00000030 + 0x68f) = uVar4;\n        *(in_stack_00000028 + *0x180075998 * 0x20) = *(in_stack_00000028 + *0x180075998 * 0x20) * 0x2d;\n        *0x180075998 = *0x180075998 - 1;\n    }\n    if (*(arg1 + 0x24 + *0xb7d * 4) == 0x2e1) {\n        *0x180075968 = *0x180075968 + -1;\n        *(in_stack_00000028 + *0x180075968 * 8) = 0xd25;\n        puVar1 = in_stack_00000028 + (in_stack_00000038 + in_stack_00000038 * 2) * 8;\n        uVar12 = uVar12 + *(*0xb7d * 4 + 0xc01) + *0x875d * *0x3901;\n        *0x3a11 = *0x3a11 * 0xd62;\n        *0xb7d = *0xb7d - 1;\n        uVar5 = fcn.1800025d0(*0x5c35 % *(in_stack_00000050 + uVar12 * 0x18), 0x602, 0xc94, 0x177d);\n        *(uVar3 + 0xb84) = uVar5;\n        *puVar1 = ((SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x1c9b)) / ZEXT816(uVar12), 0) - *((arg4 + -1) * 8 + 0x171d)) +\n                  0x7c8U) / *puVar1;\n    }\n    iVar6 = *(in_stack_00000028 + uVar12 * 8);\n    uVar10 = iVar6;\n    if (iVar6 != 0xad1) {\n        iVar7 = uVar10 * 6;\n        piVar11 = uVar10 * 4 + 0x299;\n        do {\n            iVar7 = iVar7 + 6;\n            iVar6 = uVar10;\n            *piVar11 = (*0x25d9 - *piVar11) + iVar6;\n            uVar10 = iVar6 + 1U;\n            puVar2 = *0x180075958 + -6 + iVar7;\n            *puVar2 = *puVar2 & *(in_stack_00000040 + 0x13e7) / iVar6;\n            *0x180075990 = *0x180075990 ^ 3;\n            piVar11 = piVar11 + 1;\n        } while (iVar6 + 1U != 0xad1);\n    }\n    return *(arg3 + 0x2204) + *0x180075970;\n}\n",
        "token_count": 1525
    },
    "18000947": {
        "rules": [
            "encrypt data using HC-128/f6b71aea27f34766a10ff27131cf0227"
        ],
        "decompiled_code": "\nushort fcn.180009470(int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4)\n\n{\n    uint16_t *puVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    uint64_t uVar4;\n    uint64_t uVar5;\n    uint32_t uVar6;\n    uint64_t uVar7;\n    uint16_t uVar8;\n    int32_t iVar9;\n    uint64_t *puVar10;\n    uint8_t *puVar11;\n    uint32_t uVar12;\n    int16_t *piVar13;\n    uint64_t uVar14;\n    int32_t in_stack_00000028;\n    uint8_t *in_stack_00000030;\n    int64_t in_stack_00000038;\n    \n    uVar12 = 0xc03;\n    uVar8 = *0x18007594c + 1;\n    uVar3 = in_stack_00000038 * -0x73;\n    uVar5 = *(arg4 + *in_stack_00000030 * 8);\n    uVar4 = *in_stack_00000030;\n    uVar2 = in_stack_00000030[uVar4 * 2 + 1];\n    uVar7 = *(in_stack_00000038 + 0x728);\n    uVar14 = *(*0x1800759a0 + uVar4 * 4) | in_stack_00000030[0x1500];\n    uVar4 = *(uVar4 * 0x20 + 8 + arg2) & 0x156e;\n    *0x18007594c = uVar8;\n    if (*(*0x180075968 + arg1) <= *(in_stack_00000038 + 0x728)) {\n        puVar10 = (arg3 + 4) * 0x10 + arg2;\n        piVar13 = *0x180075928 + uVar7 * 6;\n        do {\n            puVar10 = puVar10 + 2;\n            uVar12 = (uVar12 | 0x158e) + 1;\n            uVar8 = uVar8 ^ arg3;\n            *0x180075998 = SUB162(ZEXT816(*puVar10) / ZEXT216(*0x180075998), 0);\n            arg3 = arg3 + 1;\n            *piVar13 = *piVar13 + uVar12;\n            uVar6 = uVar7 + 1;\n            uVar7 = uVar6;\n            piVar13 = piVar13 + 3;\n        } while (*(*0x180075968 + arg1) <= uVar6);\n    }\n    puVar10 = arg2 + 0x20 + arg3 * 8;\n    uVar7 = *(uVar14 + in_stack_00000038 * 2);\n    if (*puVar10 <= uVar7) {\n        puVar11 = uVar7 + arg1;\n        do {\n            arg3 = arg3 + 2;\n            puVar10 = puVar10 + 2;\n            uVar6 = uVar7 + 1;\n            uVar7 = uVar6;\n            *puVar11 = arg3 + in_stack_00000028 | 0xc6;\n            puVar11 = puVar11 + 1;\n        } while (*puVar10 <= uVar6);\n    }\n    puVar1 = uVar5 % 0x1397 + (uVar3 + uVar3 * 2) * 2;\n    *puVar1 = *puVar1 & (in_stack_00000038 - *(arg2 + 0x118 + *0x180075998 * 8)) + arg3 + 1;\n    puVar1 = 0x1892 % in_stack_00000028 + uVar12 * 3 * 2;\n    *puVar1 = SUB162(ZEXT816(*(arg2 + 0x9990)) % ZEXT216(*puVar1), 0);\n    puVar1 = uVar4 + *in_stack_00000030 * 6;\n    *puVar1 = *puVar1 | *(uVar4 + 0x4c + *0x180075998 * 2) + (uVar8 & 0xff);\n    *0x180075968 = *0x180075968 & uVar12 - *(*0x1800759a0 + 0x13fc);\n    iVar9 = *(in_stack_00000038 + (in_stack_00000038 + 0x17) * 8);\n    if (0x708 < iVar9) {\n        uVar5 = *(uVar2 + arg3 * 8);\n        do {\n            uVar5 = *0x180075990 / uVar5;\n            iVar9 = iVar9 + 1;\n            *(uVar2 + arg3 * 8) = uVar5;\n        } while (0x708 < iVar9);\n    }\n    return *(uVar14 + (uVar3 + 1) * 2);\n}\n",
        "token_count": 1123
    },
    "18000c45": {
        "rules": [
            "encrypt data using HC-128/f6b71aea27f34766a10ff27131cf0227"
        ],
        "decompiled_code": "\nulong fcn.18000c450(ulong arg1, int64_t arg2, int64_t arg3, int64_t arg4)\n\n{\n    uint16_t *puVar1;\n    int64_t *piVar2;\n    uint8_t uVar3;\n    char cVar4;\n    uint32_t uVar5;\n    uint64_t uVar6;\n    uint8_t *puVar7;\n    uint32_t in_stack_00000028;\n    char in_stack_00000030;\n    \n    uVar3 = *(*0x180075998 + arg4);\n    *0x180075998 = *0x180075998 - 1;\n    uVar6 = *0x180075998;\n    *0x180075960 = *0x180075960 + -1;\n    piVar2 = *0x180075918 * 8 + 0x16a4;\n    *piVar2 = *piVar2 + 0x11a8;\n    piVar2 = (in_stack_00000028 + 8) * 8 + 0x16a4;\n    *piVar2 = *piVar2 + *(*0x1800759a0 + *0x180075918 * 2);\n    *0x180075918 = *0x180075918 + 1;\n    *(arg2 + *0x180075998 * 3 * 2) = *(arg2 + *0x180075998 * 6) & 0x83c;\n    puVar1 = arg2 + *0x180075998 * 2 * 2;\n    *puVar1 = *puVar1 ^ *0x180075998;\n    fcn.18000c000(*(*0x1800759a0 + 0x358) + 0x1b64, 0x6ae, *(uVar6 + 0x1d68), \n                  *((in_stack_00000030 - 1) + arg4) * *0x180075974);\n    *0x180075960 = uVar3 - *0x180075960;\n    fcn.180001000(0x2b4, 0x93e, 0xce6 / *(*0x180075950 + 0x1c50), *(arg4 + 0x1df));\n    uVar3 = *(*0x180075910 + *0x180075968 * 4);\n    uVar5 = uVar3;\n    if (0x1658 < uVar3) {\n        do {\n            *0x180075934 = 0xcad / *0x180075934;\n            fcn.18000b810(*0x180075918, 0xbc6, *(arg3 + 0x4404));\n            cVar4 = uVar5;\n            uVar5 = uVar5 + 1;\n            *(*0x180075918 + arg4) = *(*0x180075918 + arg4) * cVar4;\n        } while (0x1658 < uVar5);\n    }\n    *0x180075970 = *0x180075970 | in_stack_00000028;\n    puVar7 = arg1 * 4 + *0x180075910;\n    *puVar7 = 0xad8 % *puVar7;\n    return 0x1def;\n}\n",
        "token_count": 735
    },
    "18000354": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\ndouble fcn.18000354c(double param_1)\n\n{\n    double dVar1;\n    int16_t iVar2;\n    bool bVar3;\n    uint uVar4;\n    uint uVar5;\n    uint uVar6;\n    uint uVar7;\n    double adStackX8 [4];\n    \n    adStackX8[0] = param_1;\n    iVar2 = fcn.18000344c(adStackX8);\n    if (iVar2 != 0) {\n        if (iVar2 == 1) {\n            bVar3 = (adStackX8[0] & 0x8000000000000000) == 0;\n        }\n        else {\n            bVar3 = iVar2 == 2;\n        }\n        if (!bVar3) {\n            uVar6 = SUB84(adStackX8[0], 0);\n            uVar7 = adStackX8[0] >> 0x20;\n            if (*0x180035300 <= adStackX8[0]) {\n                if (adStackX8[0] == *0x180035300) {\n                    fcn.1800034ac(4);\n                    adStackX8[0] = CONCAT44(*0x180035308 >> 0x20 ^ *0x1800352f4, *0x180035308 ^ *0x1800352f0);\n                }\n                else {\n                    dVar1 = adStackX8[0] + *0x1800352d8;\n                    uVar4 = SUB84(dVar1, 0);\n                    uVar5 = dVar1 >> 0x20;\n                    adStackX8[0] = fcn.180004370(dVar1);\n                    adStackX8[0] = adStackX8[0] -\n                                   ((CONCAT44(uVar5, uVar4) - *0x1800352d8) - CONCAT44(uVar7, uVar6)) /\n                                   CONCAT44(uVar5, uVar4);\n                }\n            }\n            else {\n                fcn.1800034ac(1);\n                adStackX8[0] = *0x180035310;\n            }\n        }\n    }\n    return adStackX8[0];\n}\n",
        "token_count": 488
    },
    "null": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "1800067d": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0001800066a5)\n// WARNING: Removing unreachable block (ram,0x000180006647)\n// WARNING: Removing unreachable block (ram,0x00018000666c)\n// WARNING: Removing unreachable block (ram,0x000180006686)\n// WARNING: Removing unreachable block (ram,0x000180006694)\n// WARNING: Removing unreachable block (ram,0x00018000669b)\n// WARNING: Removing unreachable block (ram,0x0001800066fd)\n\nvoid fcn.1800067d0(ulong arg1)\n\n{\n    code *pcVar1;\n    int16_t *piVar2;\n    int32_t *piVar3;\n    \n    piVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    if ((((piVar2 != NULL) && (*piVar2 == 0x5a4d)) && (piVar3 = *(piVar2 + 0x1e) + piVar2,  *piVar3 == 0x4550)) &&\n       (((*(piVar3 + 6) == 0x20b && (0xe < piVar3[0x21])) && (piVar3[0x3e] != 0)))) {\n        fcn.180006764(arg1);\n    }\n    fcn.1800052b4(2);\n    if (*0x180076200 == '\\0') {\n        *0x1800761f0 = 1;\n        fcn.1800074ec(0x18000d240, 0x18000d248);\n        *0x180076200 = '\\x01';\n    }\n    fcn.1800052d0(2);\n    fcn.180006718(arg1);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 412
    },
    "180003ec": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nvoid fcn.180003ec8(ulong arg1)\n\n{\n    // WARNING: Could not recover jumptable at 0x000180003ee4. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)((arg1 & 0x3f) * 0x40 + *((arg1 >> 6) * 8 + 0x1800759c0));\n    return;\n}\n",
        "token_count": 101
    },
    "180003ee": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nvoid fcn.180003eec(ulong arg1)\n\n{\n    // WARNING: Could not recover jumptable at 0x000180003f08. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)((arg1 & 0x3f) * 0x40 + *((arg1 >> 6) * 8 + 0x1800759c0));\n    return;\n}\n",
        "token_count": 101
    },
    "1800040e": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nint64_t fcn.1800040e0(ulong arg1, ulong arg2, ulong arg3)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int64_t iVar4;\n    uint *puVar5;\n    int64_t iStackX32;\n    \n    iVar4 = fcn.180003fcc(arg1 & 0xffffffff);\n    if (iVar4 == -1) {\n        puVar5 = fcn.1800039a4();\n        *puVar5 = 9;\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_SetFilePointerEx)(iVar4, arg2, &iStackX32, arg3);\n        if (iVar2 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            fcn.180003934(uVar3);\n        }\n        else if (iStackX32 != -1) {\n            puVar1 = *((arg1 >> 6) * 8 + 0x1800759c0) + 0x38 + (arg1 & 0x3f) * 0x40;\n            *puVar1 = *puVar1 & 0xfd;\n            return iStackX32;\n        }\n    }\n    return -1;\n}\n",
        "token_count": 292
    },
    "180007ec": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nulong fcn.180007ec4(ulong arg1)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    uint32_t auStackX8 [2];\n    uchar auStackX16 [8];\n    uint32_t auStackX24 [2];\n    uint32_t auStackX32 [2];\n    uint32_t *apuStack24 [3];\n    \n    auStackX8[0] = arg1;\n    if (arg1 == 0xfffffffe) {\n        puVar1 = fcn.180003984();\n        *puVar1 = 0;\n        puVar1 = fcn.1800039a4();\n        *puVar1 = 9;\n    }\n    else {\n        if (((-1 < arg1) && (arg1 < *0x180075dc0)) &&\n           ((*(*((arg1 >> 6) * 8 + 0x1800759c0) + 0x38 + (arg1 & 0x3f) * 0x40) & 1) != 0)) {\n            apuStack24[0] = auStackX8;\n            auStackX24[0] = arg1;\n            auStackX32[0] = arg1;\n            uVar2 = fcn.180007e50(auStackX16, auStackX32, apuStack24, auStackX24);\n            return uVar2;\n        }\n        puVar1 = fcn.180003984();\n        *puVar1 = 0;\n        puVar1 = fcn.1800039a4();\n        *puVar1 = 9;\n        fcn.180003824();\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 373
    },
    "180005f5": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.180005f58(int64_t arg1)\n\n{\n    // WARNING: Could not recover jumptable at 0x000180005f5c. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(arg1 + 0x30);\n    return;\n}\n",
        "token_count": 76
    },
    "180005f6": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.180005f64(int64_t arg1)\n\n{\n    // WARNING: Could not recover jumptable at 0x000180005f68. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(arg1 + 0x30);\n    return;\n}\n",
        "token_count": 76
    },
    "180008d8": {
        "rules": [
            "hash data using djb2/86fcf1c18148478ab58e8c52ba43c8d5",
            "hash data using jshash/2d43aa00ef9c47beadbc2522c99f9e7b"
        ],
        "decompiled_code": "\nuint16_t fcn.180008d80(ulong noname_0, ulong noname_1, int64_t arg3, int64_t arg4)\n\n{\n    uint16_t *puVar1;\n    uint64_t *puVar2;\n    ushort uVar3;\n    int64_t in_stack_00000028;\n    \n    *0x180075938 = *0x180075938 + -1;\n    *0x180075934 = *0x180075934 + -1;\n    *0x180075998 = *0x180075998 + 1;\n    *0x180075988 = *0x180075988 + -1;\n    *0x18007593c = *0x18007593c + 1;\n    *0x18007594c = *0x18007594c + 1;\n    if (((*(*0x180075958 + (*0x180075900 + 1) * 6) == 0x1750) || (*(*0x180075940 + 0x1e78) < 0x684)) ||\n       (*(in_stack_00000028 + 0x1378) <= (*(arg4 + (noname_1 - 1U) * 3) & noname_0))) {\n        *0x180075990 = *0x180075990 + -1;\n        *0x180075948 = *0x180075948 + 1;\n        *0x180075974 = *0x180075974 + -1;\n        *(*0x180075948 + 1 + in_stack_00000028) = *(*0x180075948 + *0x180075950) * -0x23;\n        puVar2 = arg3 + *0x180075918 * 8;\n        *puVar2 = *puVar2 & *((noname_1 - 1U) * 0x20 + *0x180075940);\n        uVar3 = fcn.18000c450(*0x180075998 - *0x180075960, 0x1cfc, *(*0x180075948 + *0x180075910), *0x180075900 ^ 0xc5);\n        *(*0x1800759a0 + *0x180075900 * 2) = uVar3;\n    }\n    else {\n        *(*0x180075918 + in_stack_00000028) =\n             *(*0x180075918 + in_stack_00000028) | (*0x180075974 | *0x180075918) - *(*0x180075958 + (noname_1 - 2U) * 8)\n        ;\n        puVar1 = *0x1800759a0 + *0x180075960 * 2;\n        *puVar1 = *puVar1 ^ noname_1 - 2U;\n        *0x180075960 = *0x180075960 + 1;\n    }\n    return *0x180075948;\n}\n",
        "token_count": 659
    },
    "180009bf": {
        "rules": [
            "hash data using djb2/86fcf1c18148478ab58e8c52ba43c8d5",
            "hash data using jshash/2d43aa00ef9c47beadbc2522c99f9e7b"
        ],
        "decompiled_code": "\nuchar fcn.180009bf0(int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4)\n\n{\n    uint8_t *puVar1;\n    uint64_t *puVar2;\n    uint8_t uVar3;\n    uint8_t uVar4;\n    uint8_t uVar5;\n    int64_t iVar6;\n    int64_t iVar7;\n    int64_t iVar8;\n    uchar uVar9;\n    int64_t *piVar10;\n    uint32_t uVar11;\n    int64_t iVar12;\n    int32_t *piVar13;\n    uint64_t uVar14;\n    int64_t in_stack_00000028;\n    \n    iVar8 = *0x180075960;\n    iVar12 = *0x180075968 + 1;\n    iVar6 = *(*0x180075908 + *0x180075948 * 0x10);\n    *0x180075948 = *0x180075948 - 1;\n    uVar3 = *(arg2 + 0x1caf);\n    iVar7 = *(*0x180075940 + *0x180075998 * 8);\n    *0x180075998 = *0x180075998 - 1;\n    uVar14 = *0x180075998;\n    uVar4 = *(*0x180075950 + arg3);\n    uVar5 = *(arg2 + 7 + arg3);\n    *0x180075968 = iVar12;\n    *(arg4 + *0x180075918 * 8) = *(arg1 + 0x4c70);\n    piVar13 = uVar5 & 0x96f;\n    puVar1 = in_stack_00000028 + iVar12 * 4;\n    *puVar1 = *puVar1 ^ *(arg4 + arg3 * 8);\n    uVar11 = *0x180075948;\n    *0x180075930 = (*(uVar3 + 0x1c + arg3 * 4) - uVar11) + -299;\n    iVar12 = *0x180075968 * 4;\n    *0x180075968 = *0x180075968 + -1;\n    if (*(iVar12 + 0x282) < *(arg1 + 0x4ec0)) {\n        iVar12 = arg3 + 1;\n        *0x180075960 = *(arg3 * 4 + 0xa42) + iVar12;\n        *0x18007593c = *0x18007593c & *(iVar8 + iVar12 * 2) % *(arg2 + 8 + iVar12);\n        *((*piVar13 << 2) + uVar14) = *(arg4 + 8 + iVar12 * 8) * *0x18007593c + *(arg4 + (arg3 + 0x10) * 0x10);\n        puVar2 = (arg3 + 2) * 0x20 + arg4;\n        *puVar2 = *puVar2 ^ *0x180075974;\n        *0x180075974 = *0x180075974 + 1;\n        uVar9 = *(iVar6 + iVar12 * 4);\n    }\n    else {\n        *0x180075948 = *0x180075948 - 1;\n        if ((*(*piVar13 * 4 + 0x266) == *(uVar11 + 3 + arg2)) && (0x7a7 < *(uVar4 + arg3 * 4))) {\n            *0x180075900 = *(*0x180075900 + in_stack_00000028) % *0x180075900 - 1;\n            *(arg2 + arg3 * 4) = *(iVar7 + 0x1938) % *(arg2 + arg3 * 4);\n            uVar9 = fcn.180008d80(*(*0x180075998 + *0x180075910) * 0x16ee, \n                                  CONCAT44(*0x180075994, *0x180075990) % *(arg1 + 8 + arg3 * 8), *0x180075960, arg3 + 1)\n            ;\n            *(*0x180075918 + in_stack_00000028) = uVar9;\n            uVar9 = *(iVar6 + arg3 * 4);\n        }\n        else {\n            piVar10 = *0x180075998 * 0x10 + *0x180075940;\n            uVar11 = iVar8 & 0xff;\n            *piVar10 = (uVar11 ^ *0x180075970) * *(*0x180075958 + arg3 * 2) - *piVar10;\n            *0x180075970 = *0x180075970 - 1;\n            piVar13 = uVar3 + *0x180075960 * 4;\n            *piVar13 = (*0x180075990 + uVar11 & *(arg2 + arg3)) - *piVar13;\n            uVar9 = *(iVar6 + -4 + arg3 * 4);\n        }\n    }\n    return uVar9;\n}\n",
        "token_count": 1141
    },
    "18000a05": {
        "rules": [
            "hash data using djb2/86fcf1c18148478ab58e8c52ba43c8d5",
            "hash data using jshash/2d43aa00ef9c47beadbc2522c99f9e7b"
        ],
        "decompiled_code": "\nuchar fcn.18000a050(int64_t arg1, uint64_t noname_1, int64_t arg3, int64_t arg4)\n\n{\n    uint32_t *puVar1;\n    uint16_t *puVar2;\n    uint8_t *puVar3;\n    uint8_t uVar4;\n    int16_t iVar5;\n    bool bVar6;\n    int64_t iVar7;\n    int32_t iVar8;\n    uint64_t uVar9;\n    uint32_t uVar10;\n    int64_t iVar11;\n    uint64_t uVar12;\n    int64_t *piVar13;\n    uint32_t uVar14;\n    char cVar15;\n    uint8_t uVar16;\n    ushort *puVar17;\n    uint64_t uVar18;\n    uint64_t uVar19;\n    int16_t iVar20;\n    uint32_t uVar21;\n    int32_t *piVar23;\n    int16_t iVar24;\n    int16_t iVar25;\n    uint32_t uVar26;\n    uint8_t uVar27;\n    int64_t iVar28;\n    uint32_t uStack132;\n    uint64_t uVar22;\n    \n    uVar9 = *0x180075998;\n    noname_1 = noname_1 & 0xff;\n    iVar28 = 0xb8a;\n    iVar20 = *0x180075960;\n    cVar15 = noname_1;\n    iVar5 = *(arg1 + *0x180075960 * 2);\n    iVar24 = *0x180075988;\n    *0x180075900 = *0x180075900 - 1;\n    iVar11 = *0x180075970;\n    uVar4 = *(arg4 + 0x1cfe);\n    uVar12 = *0x180075960 | *0x180075988;\n    uVar18 = 0x11ef / *0x180075900;\n    uVar16 = cVar15 + 1;\n    uStack132 = uVar18;\n    uVar27 = *(uVar9 + *0x180075950) & *(*0x180075940 + 0x8440);\n    *0x180075930 = *0x180075930 + 1;\n    if (uStack132 < 0x10ac) {\n        uVar14 = *0x18007593c & 0xffff;\n        puVar17 = arg1 + uVar18 * 8;\n        uVar19 = uVar18;\n        uVar22 = uVar18;\n        do {\n            uVar27 = uVar27 + 1;\n            *0x180075974 = *(*0x180075978 + uVar27 * 8);\n            uVar21 = uVar22;\n            if (*(arg3 + uVar9 * 8) < uVar14) {\n                uVar26 = uVar14 + uVar22;\n                piVar23 = arg3 + uVar16 * 4;\n                uVar10 = uVar14;\n                do {\n                    *(arg3 + (uVar16 + 6) * 4) = (*(noname_1 + 0x4e68) + uVar10) / uVar10 | uVar10;\n                    iVar7 = uVar10;\n                    uVar10 = uVar10 + 1;\n                    *puVar17 = (CONCAT44((*0x180075930 | 0x11cc) >> 0x1f, *0x180075930) | 0x11cc) % iVar7;\n                    *0x180075990 = uVar19 - *0x180075990;\n                    puVar1 = arg3 + iVar28 * 4;\n                    *puVar1 = *puVar1 & uVar26;\n                    iVar28 = iVar28 + 1;\n                    uVar26 = uVar26 + 1;\n                    *piVar23 = (*((uVar16 + uVar16) * 2 + uVar4) * *0x180075948) % *piVar23;\n                    uVar9 = *0x180075998;\n                    *0x18007594c = uVar16 % *0x18007594c;\n                    uVar21 = uStack132;\n                } while (*(arg3 + *0x180075998 * 2 * 4) < uVar10);\n            }\n            uStack132 = uVar21 + 1;\n            uVar22 = uStack132;\n            uVar19 = uVar19 + 1;\n            puVar17 = puVar17 + 4;\n        } while (uStack132 < 0x10ac);\n    }\n    iVar25 = uVar18;\n    if ((noname_1 - iVar20 < 0x1da8) && (uVar16 = cVar15 + 2,  cVar15 - 1 <= *(*0x180075980 + uVar16 * 4))) {\n        iVar8 = *0x180075934 + -1;\n        bVar6 = *(arg3 + uVar9 * 0x10) <= *0x180075934;\n        *0x180075934 = iVar8;\n        if (bVar6) {\n            *0x180075998 = (*0x180075918 + 0x1912) * *0x180075960 - uVar9;\n            iVar25 = iVar25 + 1;\n            *(arg4 + *0x180075998 * 2) = *0x180075918 * ',' | uVar18;\n        }\n    }\n    uVar18 = uVar27;\n    *(iVar28 * 0x20 + *0x180075908) = *0x180075960;\n    *(uVar12 + *0x180075998 * 2) = iVar25;\n    piVar13 = iVar11 + *0x180075998 * 0x10;\n    *piVar13 = *piVar13 + *0x180075934;\n    *0x180075920 = *0x180075920 + ((*(arg3 + iVar28 * 0x10) + *0x18007593c) / *0x180075930 ^ uVar18);\n    if ((iVar5 + iVar24 <= *0x180075998) && (*(*0x180075908 + uVar16 * 8) != *(arg3 + uVar18 * 8))) {\n        *(arg4 + *0x180075900 * 2) = (*(uVar18 + arg4) ^ *(*0x180075978 + iVar28 * 0x10)) - 0x2b;\n        puVar2 = *0x180075958 + uVar16 * 2;\n        *puVar2 = *puVar2 ^ *0x18007593c;\n    }\n    uVar12 = *0x180075990;\n    if (0x1dfe < *0x180075990) {\n        iVar11 = uVar12 * 8;\n        piVar23 = uVar12 * 0x10 + arg3;\n        do {\n            puVar3 = uVar16 + uVar16 + arg4;\n            *puVar3 = *puVar3 ^ *0x180075900;\n            *0x180075900 = *0x180075900 + 1;\n            iVar28 = *0x180075960 * 8;\n            *0x180075948 = *0x180075948 - 1;\n            *0x180075960 = *0x180075960 - 1;\n            *0x180075988 = *0x180075988 &\n                           SUB168((ZEXT816(0) << 0x40 | ZEXT816(0xaab)) / ZEXT816(*(*0x180075908 + iVar28)), 0);\n            iVar8 = uVar12;\n            uVar14 = iVar8 + 1;\n            uVar12 = uVar14;\n            *0x180075920 = *(*0x180075958 + 0xe30) + *piVar23;\n            *(iVar11 + *0x1800759a0) = 0;\n            uVar9 = 0x1335 - *0x180075918;\n            *0x180075918 = *0x180075918 + -1;\n            *0x180075934 = SUB164((ZEXT816(0) << 0x40 |\n                                  ZEXT816(uVar9 & *(uVar18 * 8 + 0xc11)) % ZEXT816(iVar8) & 0xffffffffffffffff) /\n                                  ZEXT816(*0x180075934), 0);\n            iVar11 = iVar11 + 8;\n            piVar23 = piVar23 + 4;\n            uVar16 = uVar16 - 1;\n        } while (0x1dfe < uVar14);\n    }\n    return *(arg4 + 0x4a8);\n}\n",
        "token_count": 1953
    },
    "1800033e": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.1800033e0(int64_t *arg1)\n\n{\n    if (arg1 != NULL) {\n        if (*arg1 != *0x180075060) {\n            fcn.1800041bc(*arg1);\n        }\n        if (arg1[1] != *0x180075068) {\n            fcn.1800041bc(arg1[1]);\n        }\n        if (arg1[2] != *0x180075070) {\n            fcn.1800041bc(arg1[2]);\n        }\n        if (arg1[0xb] != *0x1800750b8) {\n            fcn.1800041bc(arg1[0xb]);\n        }\n        if (arg1[0xc] != *0x1800750c0) {\n            fcn.1800041bc(arg1[0xc]);\n        }\n    }\n    return;\n}\n",
        "token_count": 197
    },
    "1800048d": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.1800048dc(int64_t arg1, int64_t *arg2)\n\n{\n    int64_t iVar1;\n    \n    if ((*arg2 != *0x180075dd0) && ((*0x1800758d0 & *(arg1 + 0x3a8)) == 0)) {\n        iVar1 = fcn.1800051dc();\n        *arg2 = iVar1;\n    }\n    return;\n}\n",
        "token_count": 97
    },
    "18000491": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.180004910(int64_t arg1, int64_t *arg2)\n\n{\n    int64_t iVar1;\n    \n    if ((*arg2 != *0x180075498) && ((*0x1800758d0 & *(arg1 + 0x3a8)) == 0)) {\n        iVar1 = fcn.180005a10();\n        *arg2 = iVar1;\n    }\n    return;\n}\n",
        "token_count": 95
    },
    "180008fe": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff",
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.180008fe0(ulong noname_0, ulong noname_1, ulong arg3)\n\n{\n    int64_t *piVar1;\n    int16_t *piVar2;\n    uint64_t uVar3;\n    uint16_t uVar4;\n    uint64_t uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint64_t uVar8;\n    uint16_t uVar9;\n    int64_t iVar10;\n    int64_t in_stack_00000030;\n    int64_t in_stack_00000038;\n    int64_t in_stack_00000040;\n    int64_t in_stack_00000058;\n    int64_t in_stack_00000060;\n    \n    *0x180075920 = *0x180075920 + -1;\n    uVar3 = *(in_stack_00000060 + 0x48 + in_stack_00000058 * 8);\n    uVar5 = *0x18007594c;\n    uVar9 = *(in_stack_00000040 + in_stack_00000058 * 4) - 0xa85;\n    uVar4 = *0x180075920 * 0xcca;\n    piVar1 = *0x180075908 + (*0x180075998 - 1) * 8;\n    *piVar1 = *piVar1 * (*(in_stack_00000030 + uVar4 * 0x10) + 0x9e1);\n    uVar8 = uVar9;\n    *0x180075918 = (*0x180075970 | arg3) / 0x499 - *0x180075918;\n    *0x180075998 = (*(uVar5 % uVar3 + 0x9750) * (noname_0 | 0x2f1) - *(in_stack_00000040 + in_stack_00000058 * 4)) - 1;\n    if (uVar9 <= *(*0x180075998 + *0x180075998 + *0x180075910)) {\n        iVar10 = uVar8 * 8;\n        do {\n            iVar6 = uVar8;\n            uVar7 = iVar6 + 1;\n            uVar8 = uVar7;\n            *(in_stack_00000040 + *0x180075948 * 0x10) = iVar6 % *(in_stack_00000040 + *0x180075948 * 0x10);\n            piVar2 = iVar10 + 10 + *0x180075958;\n            *piVar2 = *piVar2 + uVar4;\n            *0x180075974 = *(in_stack_00000038 + in_stack_00000058) % *0x180075974;\n            *0x180075998 = *0x180075998 - 1;\n            iVar10 = iVar10 + 8;\n        } while (uVar7 <= *(*0x180075910 + *0x180075998 * 2));\n    }\n    return *0x7952;\n}\n",
        "token_count": 674
    },
    "18000b81": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "hash data using fnv/71d430608aea45068f0f63fc2cdc3004",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint8_t fcn.18000b810(int64_t arg1, int64_t *arg2, uint64_t arg3)\n\n{\n    uint64_t *puVar1;\n    int32_t *piVar2;\n    uint32_t *puVar3;\n    int64_t *piVar4;\n    uint8_t *puVar5;\n    uint8_t uVar6;\n    uint8_t uVar7;\n    uint16_t uVar8;\n    int32_t iVar9;\n    int64_t iVar10;\n    uint uVar11;\n    uint64_t uVar12;\n    int64_t *piVar13;\n    uint64_t uVar14;\n    uint64_t uVar15;\n    int64_t iVar16;\n    uint64_t uVar17;\n    int64_t iVar18;\n    uint16_t in_R9W;\n    uint32_t uVar19;\n    uint64_t uVar20;\n    int64_t iVar21;\n    char *pcVar22;\n    int64_t *piVar23;\n    uint32_t uVar24;\n    uint64_t uVar25;\n    uint8_t uStackX24;\n    uint8_t in_stack_00000028;\n    uint16_t in_stack_00000030;\n    unkbyte6 in_stack_00000032;\n    int32_t iStack164;\n    int32_t iStack160;\n    int32_t iStack156;\n    uint16_t uStack152;\n    int64_t iStack136;\n    \n    iVar10 = CONCAT62(in_stack_00000032, in_stack_00000030);\n    uVar17 = *0x180075998;\n    uVar12 = *(*0x180075958 + 0x207e) + 0x1b8;\n    uVar15 = *0x180075934;\n    in_stack_00000030 = *0x180075998 + 1;\n    uStackX24 = 0x87;\n    uVar8 = *(arg2 + (*arg2 + 0x11) * 2);\n    uVar24 = uVar8;\n    uVar6 = *(*0x180075968 + *0x180075950);\n    *0x180075968 = *0x180075968 + 1;\n    iStack136 = *(*0x1800759a0 + 0x12 + *arg2 * 2) - *0x180075928;\n    uVar14 = *(*0x1800759a0 + 0x14d4);\n    iVar9 = *(iVar10 + *arg2 * 0x10);\n    iVar16 = 0x1ba1 % iVar9;\n    puVar1 = *0x180075978 + (in_stack_00000030 + in_stack_00000030) * 8;\n    *puVar1 = *(arg1 + in_stack_00000030 * 4) / *puVar1;\n    piVar2 = iVar10 + *0x180075968 * 8;\n    *piVar2 = *0x18007594c - *piVar2;\n    puVar3 = iVar10 + *arg2 * 8;\n    *puVar3 = *puVar3 ^ SUB164(ZEXT416(in_stack_00000028 & 0xe18) / ZEXT816(*0x180075968), 0);\n    uVar20 = *0x180075948;\n    piVar23 = *(*0x1800759a0 + 0x3a + *arg2 * 2) ^ *(*0x180075930 * 4 + uVar17);\n    *0x180075930 = *0x180075930 + -1;\n    *arg2 = *arg2 + -1;\n    iVar18 = *piVar23;\n    iVar21 = arg2[*arg2];\n    uVar7 = *(iVar18 + 3 + uVar20);\n    *(iVar18 * 2 + 0x23a) = 0x1420 % *(iVar18 * 2 + 0x23a);\n    *0x180075934 = *0x180075934 & *0x180075920;\n    *0x180075938 = *0x180075938 + *(iVar21 + 0x10 + *piVar23 * 8) * *((uVar7 ^ 0xa17) + 0x44a0);\n    *(arg3 + 0x17c8 + *0x180075960 * 0xc) = *(*piVar23 * 2 + 0x23a);\n    *0x180075960 = *0x180075960 + 1;\n    if (uVar8 != *(uVar12 + 4 + *arg2 * 0x10)) {\n        piVar23 = arg2 + 1;\n        iStack156 = uVar8 + uVar8;\n        uStack152 = uVar6;\n        iStack160 = uVar8 * 4;\n        iStack164 = uVar8 + 6;\n        do {\n            *0x180075948 = *0x180075948 + 1;\n            uVar7 = uStackX24 | 0xf76 / in_R9W;\n            *(uVar14 + 0x98 + *0x180075948 * 0x10) = *(uVar14 + 0x98 + *0x180075948 * 0x10) * *(uVar14 + 0x3048);\n            uVar25 = uVar24;\n            uVar11 = fcn.180008fe0(0x1d7b, *(iVar16 + 0x8f38) / 0xfd2, uVar24);\n            *(iVar10 + in_stack_00000030 * 4) = uVar11;\n            uStackX24 = uVar7 + 1;\n            *0x180075968 = uVar7 / in_stack_00000030 + 0xcbe;\n            uVar11 = fcn.1800023f0(0x1760);\n            uVar19 = in_stack_00000030;\n            in_stack_00000030 = in_stack_00000030 + 1;\n            *(arg3 + 0x176c + uVar19 * 4 * 4) = uVar11;\n            piVar2 = iVar10 + *piVar23 * 4;\n            *piVar2 = (uVar24 - *(*piVar23 + uVar17)) / *piVar2;\n            *(iVar10 + iStack160 * 4) = *(arg3 + 0x176c + *piVar23 * 4);\n            uVar20 = *(piVar23 + iStack164);\n            if (*(iVar16 + 0x2f20) <= uVar20 && uVar20 != *(iVar16 + 0x2f20)) {\n                iStack136 = 0x1f18;\n                pcVar22 = in_stack_00000030 * 4 + iVar9 % 0x65c;\n                piVar13 = iVar16 + uVar20 * 8;\n                do {\n                    uVar19 = uVar20 + 1;\n                    uVar20 = uVar19;\n                    *piVar13 = *piVar13 * (((in_R9W | arg3) & uVar25) / 0x12b2);\n                    piVar4 = *0x180075978 + uVar25 * 8;\n                    *piVar4 = *piVar4 + *(*0x180075958 + iStack160 * 2);\n                    *pcVar22 = *pcVar22 * *((uVar15 | 0xa6e) + 0x6760);\n                    piVar13 = piVar13 + 1;\n                } while (*(iVar16 + 0x2f20) <= uVar19 && uVar19 != *(iVar16 + 0x2f20));\n            }\n            uVar24 = uVar24 + 1;\n            iVar18 = iStack156;\n            iVar21 = iStack160;\n            iStack156 = iStack156 + 2;\n            iStack164 = iStack164 + 1;\n            *0x180075900 = *(iVar10 + iVar18 * 4) % *0x180075900;\n            iVar18 = arg1 + *piVar23 * 4;\n            *(iVar18 + 100) = in_stack_00000028 - *(iVar18 + 100);\n            *0x180075900 = *0x180075900 & (uStack152 | 0x1e71);\n            iStack160 = iStack160 + 4;\n            *0x180075960 = arg2[iVar21] / *0x180075960;\n            piVar2 = iVar10 + *0x180075968 * 4;\n            *piVar2 = *piVar2 + (*(arg1 + uVar25 * 4) | *((uVar15 | 0xa6e) + *0x180075960 * 4)) * iStack136;\n            *0x180075960 = *0x180075960 | uVar25;\n        } while (uVar24 != *(uVar12 + 4 + *arg2 * 0x10));\n    }\n    *(iVar10 + arg2[1] * 0x10) = *(arg3 + 0x176c + arg2[1] * 8) ^ uStackX24;\n    iVar18 = *0x180075918 + 3;\n    puVar3 = iVar10 + arg2[2] * 4 + 0x20;\n    *0x180075918 = *0x180075918 + 1;\n    *puVar3 = *puVar3 | *(arg2 + iVar18);\n    puVar5 = (in_stack_00000030 - 1) + *0x180075910;\n    *puVar5 = *puVar5 | arg3 + '\\x01' + *0x180075988;\n    return uVar6;\n}\n",
        "token_count": 2192
    },
    "1800023f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "hash data using fnv/71d430608aea45068f0f63fc2cdc3004"
        ],
        "decompiled_code": "\nint32_t fcn.1800023f0(int64_t arg1)\n\n{\n    uint64_t *puVar1;\n    int64_t iVar2;\n    int64_t *piVar3;\n    int32_t iVar4;\n    int64_t iVar5;\n    uint32_t uVar6;\n    uint64_t in_RDX;\n    uint64_t uVar7;\n    uint32_t uVar8;\n    int64_t iVar9;\n    uint64_t uVar10;\n    uint8_t uVar11;\n    uint64_t uVar12;\n    \n    uVar12 = in_RDX & 0xff;\n    iVar2 = *0x180075960 * 8;\n    uVar8 = *(iVar2 + arg1) ^ 0xe40;\n    iVar5 = *(*0x180075940 + 0xf0 + (*0x180075918 + -1) * 8);\n    *0x180075974 = *0x180075974 + -1;\n    iVar9 = *0x180075974;\n    uVar7 = *0x180075900 % *(*0x180075908 + (*0x180075918 + -1) * 8);\n    *(iVar2 + 0x13a0) = *(iVar2 + 0x13a0) * *(uVar7 + 0x40 + *0x180075998 * 8) * *(arg1 + 0x36f8);\n    *(uVar12 * 8 + 0x13a0) = SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x3bf)) % ZEXT816(*(uVar12 * 8 + 0x13a0)), 0);\n    *0x180075948 = *0x180075948 - 1;\n    puVar1 = arg1 + (*0x180075948 + 8) * 8;\n    uVar11 = uVar12 + 1;\n    uVar10 = uVar11;\n    *puVar1 = ((*(*0x180075950 + uVar12 * 2) | uVar12) ^ *(*0x180075958 + *0x180075948 * 4 * 2)) / *puVar1;\n    uVar6 = *0x180075948;\n    *0x180075948 = *0x180075948 + 1;\n    if (((*(iVar9 + (uVar6 * 3 + 0x17) * 8) < uVar10) || (*0x180075934 != 0x100e)) &&\n       (puVar1 = *0x180075978 + 0xa8 + uVar11 * 8,  *puVar1 < uVar10 || *puVar1 == uVar10)) {\n        *(iVar5 + uVar8 * 2 * 4) = *0x180075990;\n        iVar4 = *(uVar7 + *0x180075960 * 8);\n    }\n    else {\n        piVar3 = *0x180075948 * 0x18 + 0x10 + iVar9;\n        *piVar3 = *piVar3 + uVar10;\n        *0x180075948 = *0x180075948 - 1;\n        puVar1 = *0x180075978 + uVar11 * 0x20;\n        *puVar1 = *puVar1 | uVar8;\n        iVar4 = *(uVar7 + *0x180075960 * 8);\n    }\n    return 0x1813 - iVar4;\n}\n",
        "token_count": 786
    },
    "180003b9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.180003b9c(uint16_t *arg1, uint8_t *arg2, uint64_t arg3)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint uVar3;\n    int64_t iStack40;\n    int64_t aiStack32 [2];\n    char cStack16;\n    \n    if ((arg2 != NULL) && (arg3 != 0)) {\n        if (*arg2 != 0) {\n            fcn.1800039c4(&iStack40, 0);\n            if (*(aiStack32[0] + 0x138) == 0) {\n                if (arg1 != NULL) {\n                    *arg1 = *arg2;\n                }\n                uVar3 = 1;\n            }\n            else {\n                iVar1 = fcn.18000489c(*arg2, aiStack32);\n                uVar3 = 1;\n                if (iVar1 == 0) {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                      (*(aiStack32[0] + 0xc), 9, arg2, 1, arg1, arg1 != NULL);\n                    if (iVar1 != 0) goto code_r0x000180003b82;\n                }\n                else {\n                    iVar1 = *(aiStack32[0] + 8);\n                    if ((((1 < iVar1) && (iVar1 <= arg3)) &&\n                        (iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                           (*(aiStack32[0] + 0xc), 9, arg2, iVar1, arg1, arg1 != NULL),  iVar1 != 0)) ||\n                       ((*(aiStack32[0] + 8) <= arg3 && (arg2[1] != 0)))) {\n                        uVar3 = *(aiStack32[0] + 8);\n                        goto code_r0x000180003b82;\n                    }\n                }\n                puVar2 = fcn.1800039a4();\n                uVar3 = 0xffffffff;\n                *puVar2 = 0x2a;\n            }\ncode_r0x000180003b82:\n            if (cStack16 == '\\0') {\n                return uVar3;\n            }\n            *(iStack40 + 0x3a8) = *(iStack40 + 0x3a8) & 0xfffffffd;\n            return uVar3;\n        }\n        if (arg1 != NULL) {\n            *arg1 = 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 567
    },
    "180005d8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file"
        ],
        "decompiled_code": "\nvoid fcn.180005d80(void)\n\n{\n    *0x1800757b0 = (*_sym.imp.KERNEL32.dll_CreateFileW)(L\"CONOUT$\", 0x40000000, 3, 0, 3, 0, 0);\n    return;\n}\n",
        "token_count": 65
    },
    "1800060c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.1800060c0(ulong param_1, ulong param_2, ulong param_3)\n\n{\n    fcn.1800060e0(param_1, param_2, param_3, 0x1a);\n    return;\n}\n",
        "token_count": 58
    }
}