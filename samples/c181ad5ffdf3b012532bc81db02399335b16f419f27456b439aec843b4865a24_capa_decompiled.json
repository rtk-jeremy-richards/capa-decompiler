{
    "null": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00404b7c": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404b7c(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    \n    iVar1 = fcn.0042cd29();\n    iVar2 = *(iVar1 + 0xcc);\n    if (arg_8h == 0) {\n        if ((*(in_ECX + 0x24) & 1) != 0) {\n            if (*(iVar1 + 0xd0) == in_ECX) {\n                fcn.00418af7(1);\n            }\n            if (iVar2 == 0) {\n                iVar1 = 0;\n            }\n            else {\n                iVar1 = *(iVar2 + 0x1c);\n            }\n            if (iVar1 != 0) {\n                fcn.00406030(&var_2ch, 0, 0x2c);\n                var_24h = *(in_ECX + 0x1c);\n                var_2ch = 0x2c;\n                var_28h = 1;\n                var_20h = var_24h;\n                (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x1c), 0x405, 0, &var_2ch);\n            }\n            *(in_ECX + 0x24) = *(in_ECX + 0x24) & 0xfffffffe;\n        }\n    }\n    else if ((*(in_ECX + 0x24) & 1) == 0) {\n        iVar2 = fcn.0042d07c();\n        *(iVar2 + 0x1034) = 0x404c1e;\n        *(in_ECX + 0x24) = *(in_ECX + 0x24) | 1;\n    }\n    return 1;\n}\n",
        "token_count": 439
    },
    "00404c2e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: wParam\n// WARNING: Variable defined which should be unmapped: var_78h\n\nvoid __cdecl fcn.00404c2e(uint arg_8h)\n\n{\n    uint8_t uVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint *puVar8;\n    int32_t extraout_ECX;\n    int32_t *arg_8h_00;\n    int32_t unaff_EBP;\n    uint32_t uVar9;\n    uint *puVar10;\n    uint *in_FS_OFFSET;\n    uint wParam;\n    uint var_78h;\n    uint var_5ch;\n    uint var_58h;\n    uint lParam;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint lpPoint;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    puVar8 = *(unaff_EBP + 8);\n    iVar4 = puVar8[1];\n    uVar1 = *(extraout_ECX + 0x24);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    pcVar2 = _sym.imp.USER32.dll_GetKeyState;\n    if (((uVar1 & 1) == 0) ||\n       ((((iVar4 != 0x200 && (iVar4 != 0xa0)) && (iVar4 != 0x202)) && ((iVar4 != 0x205 && (iVar4 != 0x208))))))\n    goto code_r0x00404f17;\n    iVar3 = (*_sym.imp.USER32.dll_GetKeyState)(1);\n    if (iVar3 < 0) goto code_r0x00404f17;\n    iVar3 = (*pcVar2)(2);\n    if (iVar3 < 0) goto code_r0x00404f17;\n    iVar3 = (*pcVar2)(4);\n    if (iVar3 < 0) goto code_r0x00404f17;\n    uVar5 = *puVar8;\n    while( true ) {\n        iVar4 = fcn.0041819c(uVar5);\n        if (iVar4 == 0) break;\n        if (iVar4 == extraout_ECX) goto code_r0x00404cd0;\n        if ((*(iVar4 + 0x24) & 1) != 0) break;\n        uVar5 = (*_sym.imp.USER32.dll_GetParent)(*(iVar4 + 0x1c));\n    }\n    if (iVar4 != extraout_ECX) goto code_r0x00404f17;\ncode_r0x00404cd0:\n    iVar4 = fcn.0042d88a(0x404495);\n    *(unaff_EBP + -0x18) = iVar4;\n    arg_8h_00 = *(iVar4 + 0xcc);\n    uVar5 = fcn.004198a9();\n    *(unaff_EBP + -0x14) = uVar5;\n    if (arg_8h_00 == NULL) {\ncode_r0x00404d1e:\n        iVar6 = fcn.00416693(0x58);\n        *(unaff_EBP + -0x1c) = iVar6;\n        *(unaff_EBP + -4) = 0;\n        if (iVar6 == 0) {\n            arg_8h_00 = NULL;\n        }\n        else {\n            arg_8h_00 = fcn.0040497d();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        iVar6 = fcn.004049d2(*(unaff_EBP + -0x14), 1);\n        if (iVar6 == 0) {\n            if (arg_8h_00 != NULL) {\n                (**(*arg_8h_00 + 4))(1);\n            }\n            goto code_r0x00404f17;\n        }\n        (*_sym.imp.USER32.dll_SendMessageA)(arg_8h_00[7], 0x401, 0, 0);\n        *(iVar4 + 0xcc) = arg_8h_00;\n    }\n    else {\n        iVar6 = fcn.0040455a();\n        if (iVar6 != *(unaff_EBP + -0x14)) {\n            iVar6 = *arg_8h_00;\n            (**(iVar6 + 0x60))();\n            (**(iVar6 + 4))(1);\n            arg_8h_00 = NULL;\n            *(iVar4 + 0xcc) = 0;\n        }\n        if (arg_8h_00 == NULL) goto code_r0x00404d1e;\n    }\n    fcn.00406030(unaff_EBP + -0x50, 0, 0x2c);\n    *(unaff_EBP + -0x50) = 0x2c;\n    *(unaff_EBP + -0x4c) = 1;\n    uVar5 = *(*(unaff_EBP + -0x10) + 0x1c);\n    *(unaff_EBP + -0x48) = uVar5;\n    *(unaff_EBP + -0x44) = uVar5;\n    iVar6 = (*_sym.imp.USER32.dll_SendMessageA)(arg_8h_00[7], 0x408, 0, unaff_EBP + -0x50);\n    if (iVar6 == 0) {\n        (*_sym.imp.USER32.dll_SendMessageA)(arg_8h_00[7], 0x404, 0, unaff_EBP + -0x50);\n    }\n    uVar5 = *(*(unaff_EBP + 8) + 0x14);\n    *(unaff_EBP + -0x20) = *(*(unaff_EBP + 8) + 0x18);\n    *(unaff_EBP + -0x24) = uVar5;\n    (*_sym.imp.USER32.dll_ScreenToClient)(*(*(unaff_EBP + -0x10) + 0x1c), unaff_EBP + -0x24);\n    fcn.00406030(unaff_EBP + -0x7c, 0, 0x2c);\n    *(unaff_EBP + -0x7c) = 0x2c;\n    iVar7 = (**(**(unaff_EBP + -0x10) + 0x6c))(*(unaff_EBP + -0x24), *(unaff_EBP + -0x20), unaff_EBP + -0x7c);\n    *(unaff_EBP + -0x1c) = iVar7;\n    uVar9 = -(iVar7 != -1) & *(unaff_EBP + -0x10);\n    iVar6 = *(iVar4 + 0xd4);\n    *(unaff_EBP + -0x14) = uVar9;\n    if ((iVar6 == iVar7) && (*(iVar4 + 0xd0) == uVar9)) {\n        if (iVar7 != -1) {\n            fcn.00404f28(arg_8h_00, *(unaff_EBP + 8));\n        }\n    }\n    else {\n        if (iVar7 != -1) {\n            uVar9 = *(unaff_EBP + -0x78);\n            puVar8 = unaff_EBP + -0x7c;\n            puVar10 = unaff_EBP + -0x50;\n            for (iVar4 = 0xb; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar10 = *puVar8;\n                puVar8 = puVar8 + 1;\n                puVar10 = puVar10 + 1;\n            }\n            *(unaff_EBP + -0x4c) = uVar9 & 0x3fffffff;\n            (*_sym.imp.USER32.dll_SendMessageA)(arg_8h_00[7], 0x404, 0, unaff_EBP + -0x50);\n            if ((*(unaff_EBP + -0x75) & 0x40) == 0) {\n                iVar4 = fcn.004198f0();\n                if (iVar4 != 0) goto code_r0x00404e90;\n            }\n            else {\ncode_r0x00404e90:\n                (*_sym.imp.USER32.dll_SendMessageA)(arg_8h_00[7], 0x401, 1, 0);\n                (*_sym.imp.USER32.dll_SetWindowPos)(arg_8h_00[7], 0, 0, 0, 0, 0, 0x213);\n            }\n            iVar4 = *(unaff_EBP + -0x18);\n            uVar9 = *(unaff_EBP + -0x14);\n        }\n        fcn.00404f28(arg_8h_00, *(unaff_EBP + 8));\n        iVar6 = *(iVar4 + 0xd8);\n        puVar8 = iVar4 + 0xd8;\n        *(unaff_EBP + 8) = puVar8;\n        if (iVar6 == 0x2c) {\n            (*_sym.imp.USER32.dll_SendMessageA)(arg_8h_00[7], 0x405, 0, puVar8);\n            puVar8 = *(unaff_EBP + 8);\n        }\n        uVar5 = *(unaff_EBP + -0x1c);\n        *(iVar4 + 0xd0) = uVar9;\n        *(iVar4 + 0xd4) = uVar5;\n        puVar10 = unaff_EBP + -0x7c;\n        for (iVar4 = 0xb; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar8 = *puVar10;\n            puVar10 = puVar10 + 1;\n            puVar8 = puVar8 + 1;\n        }\n    }\n    if ((*(unaff_EBP + -0x58) != -1) && (*(unaff_EBP + -0x5c) == 0)) {\n        fcn.00405f10(*(unaff_EBP + -0x58));\n    }\ncode_r0x00404f17:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 2372
    },
    "00406bd0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t fcn.00406bd0(uint8_t *param_1, uint8_t **param_2, uint32_t param_3, uint32_t param_4)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint8_t uVar5;\n    uint8_t *puStack8;\n    uint32_t uStack4;\n    \n    uStack4 = 0;\n    uVar5 = *param_1;\n    puStack8 = param_1 + 1;\n    while( true ) {\n        if (*0x43d6bc < 2) {\n            uVar1 = *(*0x43d4b0 + uVar5 * 2) & 8;\n        }\n        else {\n            uVar1 = fcn.0040b2d0(uVar5, 8);\n        }\n        if (uVar1 == 0) break;\n        uVar5 = *puStack8;\n        puStack8 = puStack8 + 1;\n    }\n    if (uVar5 == 0x2d) {\n        param_4 = param_4 | 2;\n    }\n    else if (uVar5 != 0x2b) goto code_r0x00406c5b;\n    uVar5 = *puStack8;\n    puStack8 = puStack8 + 1;\ncode_r0x00406c5b:\n    if (((param_3 < 0) || (param_3 == 1)) || (0x24 < param_3)) {\n        if (param_2 != NULL) {\n            *param_2 = param_1;\n        }\n        return 0;\n    }\n    if (param_3 == 0) {\n        if (uVar5 == 0x30) {\n            if ((*puStack8 == 0x78) || (param_3 = 8,  *puStack8 == 0x58)) {\n                param_3 = 0x10;\n            }\n        }\n        else {\n            param_3 = 10;\n        }\n    }\n    if (((param_3 == 0x10) && (uVar5 == 0x30)) && ((*puStack8 == 0x78 || (*puStack8 == 0x58)))) {\n        uVar5 = puStack8[1];\n        puStack8 = puStack8 + 2;\n    }\n    uVar1 = 0xffffffff / param_3;\n    do {\n        if (*0x43d6bc < 2) {\n            uVar2 = *(*0x43d4b0 + uVar5 * 2) & 4;\n        }\n        else {\n            uVar2 = fcn.0040b2d0(uVar5, 4);\n        }\n        if (uVar2 == 0) {\n            if (*0x43d6bc < 2) {\n                uVar2 = *(*0x43d4b0 + uVar5 * 2) & 0x103;\n            }\n            else {\n                uVar2 = fcn.0040b2d0(uVar5, 0x103);\n            }\n            if (uVar2 == 0) {\ncode_r0x00406d94:\n                puStack8 = puStack8 + -1;\n                if ((param_4 & 8) == 0) {\n                    if (param_2 != NULL) {\n                        puStack8 = param_1;\n                    }\n                    uStack4 = 0;\n                }\n                else if (((param_4 & 4) != 0) ||\n                        (((param_4 & 1) == 0 &&\n                         ((((param_4 & 2) != 0 && (0x80000000 < uStack4)) ||\n                          (((param_4 & 2) == 0 && (0x7fffffff < uStack4)))))))) {\n                    puVar4 = fcn.00407210();\n                    *puVar4 = 0x22;\n                    if ((param_4 & 1) == 0) {\n                        uStack4 = ((param_4 & 2) != 0) + 0x7fffffff;\n                    }\n                    else {\n                        uStack4 = 0xffffffff;\n                    }\n                }\n                if (param_2 != NULL) {\n                    *param_2 = puStack8;\n                }\n                if ((param_4 & 2) != 0) {\n                    uStack4 = -uStack4;\n                }\n                return uStack4;\n            }\n            iVar3 = fcn.0040b670(uVar5);\n            uVar2 = iVar3 - 0x37;\n        }\n        else {\n            uVar2 = uVar5 - 0x30;\n        }\n        if (param_3 <= uVar2) goto code_r0x00406d94;\n        if ((uStack4 < uVar1) || ((uStack4 == uVar1 && (uVar2 <= 0xffffffff % param_3)))) {\n            uStack4 = uStack4 * param_3 + uVar2;\n            param_4 = param_4 | 8;\n        }\n        else {\n            param_4 = param_4 | 0xc;\n        }\n        uVar5 = *puStack8;\n        puStack8 = puStack8 + 1;\n    } while( true );\n}\n",
        "token_count": 1179
    },
    "00407b90": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid fcn.00407b90(int32_t *param_1, int32_t param_2, uint param_3, uint param_4, int32_t param_5, char param_6, \n                 uint param_7, uint param_8)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint8_t *puVar3;\n    uint8_t **ppuVar4;\n    int32_t iVar5;\n    uint8_t *puVar6;\n    uint8_t *puVar7;\n    bool bVar8;\n    uint32_t uStack32;\n    int32_t *piStack28;\n    int32_t iStack24;\n    int32_t iStack20;\n    int32_t iStack16;\n    uint32_t uStack12;\n    uint8_t **ppuStack8;\n    int32_t iStack4;\n    \n    iVar5 = *(param_2 + 8);\n    iStack16 = iVar5;\n    if ((iVar5 < -1) || (*(param_5 + 4) <= iVar5)) {\n        fcn.004086d0();\n    }\n    if (*param_1 == -0x1f928c9d) {\n        if (((param_1[4] == 3) && (param_1[5] == 0x19930520)) && (param_1[7] == 0)) {\n            iVar2 = fcn.004085c0();\n            if (*(iVar2 + 0x6c) == 0) {\n                return;\n            }\n            iVar2 = fcn.004085c0();\n            param_1 = *(iVar2 + 0x6c);\n            iVar2 = fcn.004085c0();\n            param_3 = *(iVar2 + 0x70);\n            iVar2 = fcn.0040c030(param_1, 1);\n            if (iVar2 == 0) {\n                fcn.004086d0();\n            }\n            if (*param_1 != -0x1f928c9d) goto code_r0x00407e06;\n            if (((param_1[4] == 3) && (param_1[5] == 0x19930520)) && (param_1[7] == 0)) {\n                fcn.004086d0();\n            }\n        }\n        if (((*param_1 == -0x1f928c9d) && (param_1[4] == 3)) && (param_1[5] == 0x19930520)) {\n            piStack28 = fcn.00405540(param_5, param_7, iVar5, &uStack32, &uStack12);\n            if (uStack32 < uStack12) {\n                do {\n                    if ((*piStack28 == iVar5 || *piStack28 < iVar5) && (iVar5 <= piStack28[1])) {\n                        iStack20 = piStack28[3];\n                        puVar7 = piStack28[4];\n                        if (0 < iStack20) {\n                            ppuStack8 = *(param_1[7] + 0xc) + 1;\n                            iStack4 = **(param_1[7] + 0xc);\n                            do {\n                                iStack24 = iStack4;\n                                if (0 < iStack4) {\n                                    iVar5 = *(puVar7 + 4);\n                                    ppuVar4 = ppuStack8;\n                                    do {\n                                        if ((iVar5 == 0) || (puVar3 = iVar5 + 8,  *(iVar5 + 8) == '\\0')) {\ncode_r0x00407d5f:\n                                            bVar8 = true;\n                                        }\n                                        else {\n                                            iVar2 = *(*ppuVar4 + 4);\n                                            if (iVar5 == iVar2) {\ncode_r0x00407d3a:\n                                                if (((((**ppuVar4 & 2) == 0) || ((*puVar7 & 8) != 0)) &&\n                                                    (((*param_1[7] & 1) == 0 || ((*puVar7 & 1) != 0)))) &&\n                                                   (((*param_1[7] & 2) == 0 || ((*puVar7 & 2) != 0))))\n                                                goto code_r0x00407d5f;\n                                                bVar8 = false;\n                                            }\n                                            else {\n                                                puVar6 = iVar2 + 8;\n                                                do {\n                                                    uVar1 = *puVar3;\n                                                    bVar8 = uVar1 < *puVar6;\n                                                    if (uVar1 != *puVar6) {\ncode_r0x00407d1d:\n                                                        iVar2 = (1 - bVar8) - (bVar8 != 0);\n                                                        goto code_r0x00407d22;\n                                                    }\n                                                    if (uVar1 == 0) break;\n                                                    uVar1 = puVar3[1];\n                                                    bVar8 = uVar1 < puVar6[1];\n                                                    if (uVar1 != puVar6[1]) goto code_r0x00407d1d;\n                                                    puVar3 = puVar3 + 2;\n                                                    puVar6 = puVar6 + 2;\n                                                } while (uVar1 != 0);\n                                                iVar2 = 0;\ncode_r0x00407d22:\n                                                if (iVar2 == 0) goto code_r0x00407d3a;\n                                                bVar8 = false;\n                                            }\n                                        }\n                                        if (bVar8) {\n                                            fcn.00408010(param_1, param_2, param_3, param_4, param_5, puVar7, *ppuVar4, \n                                                         piStack28, param_7, param_8);\n                                            iVar5 = iStack16;\n                                            goto code_r0x00407dcf;\n                                        }\n                                        ppuVar4 = ppuVar4 + 1;\n                                        iStack24 = iStack24 + -1;\n                                    } while (0 < iStack24);\n                                }\n                                iStack20 = iStack20 + -1;\n                                puVar7 = puVar7 + 0x10;\n                                iVar5 = iStack16;\n                            } while (0 < iStack20);\n                        }\n                    }\ncode_r0x00407dcf:\n                    uStack32 = uStack32 + 1;\n                    piStack28 = piStack28 + 5;\n                } while (uStack32 < uStack12);\n            }\n            if (param_6 == '\\0') {\n                return;\n            }\n            fcn.00408440(param_1, 1);\n            return;\n        }\n    }\ncode_r0x00407e06:\n    if (param_6 != '\\0') {\n        fcn.00408640();\n        return;\n    }\n    fcn.00407e50(param_1, param_2, param_3, param_4, param_5, iVar5, param_7, param_8);\n    return;\n}\n",
        "token_count": 1525
    },
    "00408230": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid fcn.00408230(int32_t param_1, int32_t param_2, uint8_t *param_3, uint8_t *param_4)\n\n{\n    int32_t *arg_8h;\n    int32_t iVar1;\n    uint arg_ch;\n    uint uVar2;\n    uint *in_FS_OFFSET;\n    int32_t var_8h;\n    int32_t var_ch;\n    uint8_t *var_18h;\n    uint8_t *var_14h;\n    uint var_10h;\n    code *pcStack16;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x434be0;\n    pcStack16 = fcn.0040a148;\n    var_10h = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_10h;\n    if (((*(var_18h + 4) != 0) && (*(*(var_18h + 4) + 8) != '\\0')) && (*(var_18h + 8) != 0)) {\n        arg_8h = var_ch + 0xc + *(var_18h + 8);\n        var_4h = 0;\n        if ((*var_18h & 8) == 0) {\n            if ((*var_14h & 1) == 0) {\n                if (*(var_14h + 0x18) == 0) {\n                    iVar1 = fcn.0040c030(*(var_8h + 0x18), 1);\n                    if ((iVar1 != 0) && (iVar1 = fcn.0040c050(arg_8h, 1),  iVar1 != 0)) {\n                        uVar2 = *(var_14h + 0x14);\n                        arg_ch = fcn.004084c0(*(var_8h + 0x18), var_14h + 8);\n                        fcn.00406890(arg_8h, arg_ch, uVar2);\n                        goto code_r0x00408420;\n                    }\n                }\n                else {\n                    iVar1 = fcn.0040c030(*(var_8h + 0x18), 1);\n                    if (((iVar1 != 0) && (iVar1 = fcn.0040c050(arg_8h, 1),  iVar1 != 0)) &&\n                       (iVar1 = fcn.0040c070(*(var_14h + 0x18)),  iVar1 != 0)) {\n                        if ((*var_14h & 4) == 0) {\n                            uVar2 = fcn.004084c0(*(var_8h + 0x18), var_14h + 8);\n                            fcn.004052a0(arg_8h, *(var_14h + 0x18), uVar2);\n                        }\n                        else {\n                            uVar2 = fcn.004084c0(*(var_8h + 0x18), var_14h + 8, 1);\n                            fcn.004052a0(arg_8h, *(var_14h + 0x18), uVar2);\n                        }\n                        goto code_r0x00408420;\n                    }\n                }\n            }\n            else {\n                iVar1 = fcn.0040c030(*(var_8h + 0x18), 1);\n                if ((iVar1 != 0) && (iVar1 = fcn.0040c050(arg_8h, 1),  iVar1 != 0)) {\n                    fcn.00406890(arg_8h, *(var_8h + 0x18), *(var_14h + 0x14));\n                    if ((*(var_14h + 0x14) == 4) && (*arg_8h != 0)) {\n                        iVar1 = fcn.004084c0(*arg_8h, var_14h + 8);\n                        *arg_8h = iVar1;\n                    }\n                    goto code_r0x00408420;\n                }\n            }\n        }\n        else {\n            iVar1 = fcn.0040c030(*(var_8h + 0x18), 1);\n            if ((iVar1 != 0) && (iVar1 = fcn.0040c050(arg_8h, 1),  iVar1 != 0)) {\n                iVar1 = *(var_8h + 0x18);\n                *arg_8h = iVar1;\n                iVar1 = fcn.004084c0(iVar1, var_14h + 8);\n                *arg_8h = iVar1;\n                goto code_r0x00408420;\n            }\n        }\n        fcn.004086d0();\n    }\ncode_r0x00408420:\n    *in_FS_OFFSET = var_10h;\n    return;\n}\n",
        "token_count": 1066
    },
    "00408ba0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.00408ba0(uint param_1, uint8_t *param_2, uint *param_3)\n\n{\n    char cVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int16_t *piVar5;\n    int32_t *piVar6;\n    uint16_t *puVar7;\n    int32_t iVar8;\n    uint8_t uVar9;\n    uchar *puVar10;\n    uchar *puVar11;\n    int32_t iVar12;\n    uint64_t uVar13;\n    uint64_t uVar14;\n    uint32_t uStack588;\n    uint16_t *puStack584;\n    int32_t iStack580;\n    int32_t iStack576;\n    uchar uStack570;\n    char cStack569;\n    int32_t iStack568;\n    int32_t iStack564;\n    uint32_t uStack560;\n    int32_t iStack556;\n    int32_t iStack552;\n    uint uStack548;\n    int32_t iStack544;\n    uint32_t uStack540;\n    uint uStack536;\n    uchar auStack532 [4];\n    uint uStack528;\n    uint uStack524;\n    int32_t iStack516;\n    uchar auStack512 [511];\n    uchar uStack1;\n    \n    iStack544 = 0;\n    puVar11 = NULL;\n    iStack576 = 0;\n    uVar9 = *param_2;\n    param_2 = param_2 + 1;\n    uStack540 = uStack540 & 0xffffff00 | uVar9;\n    do {\n        if ((uVar9 == 0) || (iStack576 < 0)) {\n            return iStack576;\n        }\n        if ((uVar9 < ' ') || ('x' < uVar9)) {\n            uVar3 = 0;\n        }\n        else {\n            uVar3 = *(uVar9 + 0x434c10) & 0xf;\n        }\n        iStack544 = *(iStack544 + 0x434c30 + uVar3 * 8) >> 4;\n    // switch table (8 cases) at 0x40941c\n        switch(iStack544) {\n        case 0:\ncode_r0x00408da0:\n            uStack560 = 0;\n            if ((*(*0x43d4b0 + 1 + (uStack540 & 0xff) * 2) & 0x80) != 0) {\n                fcn.00409530(uVar9, param_1, &iStack576);\n                uVar9 = *param_2;\n                param_2 = param_2 + 1;\n            }\n            fcn.00409530(uVar9, param_1, &iStack576);\n            break;\n        case 1:\n            uStack536 = 0;\n            iStack552 = 0;\n            iStack564 = 0;\n            iStack568 = 0;\n            uStack588 = 0;\n            iStack580 = -1;\n            uStack560 = 0;\n            break;\n        case 2:\n    // switch table (6 cases) at 0x40943c\n            switch(uVar9) {\n            case 0x20:\n                uStack588 = uStack588 | 2;\n                break;\n            case 0x23:\n                uStack588 = uStack588 | 0x80;\n                break;\n            case 0x2b:\n                uStack588 = uStack588 | 1;\n                break;\n            case 0x2d:\n                uStack588 = uStack588 | 4;\n                break;\n            case 0x30:\n                uStack588 = uStack588 | 8;\n            }\n            break;\n        case 3:\n            if (uVar9 == 0x2a) {\n                iStack564 = fcn.00409600(&param_3);\n                if (iStack564 < 0) {\n                    uStack588 = uStack588 | 4;\n                    iStack564 = -iStack564;\n                }\n            }\n            else {\n                iStack564 = uVar9 + -0x30 + iStack564 * 10;\n            }\n            break;\n        case 4:\n            iStack580 = 0;\n            break;\n        case 5:\n            if (uVar9 == 0x2a) {\n                iStack580 = fcn.00409600(&param_3);\n                if (iStack580 < 0) {\n                    iStack580 = -1;\n                }\n            }\n            else {\n                iStack580 = uVar9 + -0x30 + iStack580 * 10;\n            }\n            break;\n        case 6:\n    // switch table (5 cases) at 0x409468\n            switch(uVar9) {\n            case 0x49:\n                if ((*param_2 != 0x36) || (param_2[1] != 0x34)) {\n                    iStack544 = 0;\n                    goto code_r0x00408da0;\n                }\n                param_2 = param_2 + 2;\n                uStack588 = uStack588 | 0x8000;\n                break;\n            case 0x68:\n                uStack588 = uStack588 | 0x20;\n                break;\n            case 0x6c:\n                uStack588 = uStack588 | 0x10;\n                break;\n            case 0x77:\n                uStack588 = uStack588 | 0x800;\n            }\n            break;\n        case 7:\n    // switch table (17 cases) at 0x4094ac\n            switch(uVar9) {\n            case 0x43:\n                if ((uStack588 & 0x830) == 0) {\n                    uStack588 = uStack588 | 0x800;\n                }\n            case 99:\n                if ((uStack588 & 0x810) == 0) {\n                    auStack512[0] = fcn.00409600(&param_3);\n                    puVar11 = 0x1;\n                }\n                else {\n                    uVar4 = fcn.00409640(&param_3);\n                    puVar11 = fcn.0040c2a0(auStack512, uVar4);\n                    if (puVar11 < 0) {\n                        puStack584 = auStack512;\n                        iStack552 = 1;\n                        break;\n                    }\n                }\n                puStack584 = auStack512;\n                break;\n            case 0x45:\n            case 0x47:\n                uStack536 = 1;\n                uVar9 = uVar9 + 0x20;\n            case 0x65:\n            case 0x66:\n            case 0x67:\n                puStack584 = auStack512;\n                if (iStack580 < 0) {\n                    iStack580 = 6;\n                }\n                else if ((iStack580 == 0) && (uVar9 == 0x67)) {\n                    iStack580 = 1;\n                }\n                uStack528 = *param_3;\n                uStack524 = param_3[1];\n                param_3 = param_3 + 2;\n                (**0x43d960)(&uStack528, auStack512, uVar9, iStack580, uStack536);\n                if (((uStack588 & 0x80) != 0) && (iStack580 == 0)) {\n                    (**0x43d96c)(auStack512);\n                }\n                if ((uVar9 == 0x67) && ((uStack588 & 0x80) == 0)) {\n                    (**0x43d964)(auStack512);\n                }\n                uVar3 = uStack588 | 0x40;\n                if (auStack512[0] == '-') {\n                    puStack584 = auStack512 + 1;\n                    uVar3 = uStack588 | 0x140;\n                }\n                uStack588 = uVar3;\n                uVar3 = 0xffffffff;\n                puVar7 = puStack584;\n                do {\n                    if (uVar3 == 0) break;\n                    uVar3 = uVar3 - 1;\n                    cVar1 = *puVar7;\n                    puVar7 = puVar7 + 1;\n                } while (cVar1 != '\\0');\n                puVar11 = ~uVar3 - 1;\n                break;\n            case 0x53:\n                if ((uStack588 & 0x830) == 0) {\n                    uStack588 = uStack588 | 0x800;\n                }\n            case 0x73:\n                iVar12 = 0x7fffffff;\n                if (iStack580 != -1) {\n                    iVar12 = iStack580;\n                }\n                puStack584 = fcn.00409600(&param_3);\n                if ((uStack588 & 0x810) == 0) {\n                    puVar7 = puStack584;\n                    if (puStack584 == NULL) {\n                        puVar7 = *0x43b0b8;\n                        puStack584 = *0x43b0b8;\n                    }\n                    for (; (iVar12 != 0 && (iVar12 = iVar12 + -1,  *puVar7 != '\\0')); puVar7 = puVar7 + 1) {\n                    }\n                    puVar11 = puVar7 - puStack584;\n                }\n                else {\n                    if (puStack584 == NULL) {\n                        puStack584 = *0x43b0bc;\n                    }\n                    uStack560 = 1;\n                    for (puVar7 = puStack584; (iVar12 != 0 && (iVar12 = iVar12 + -1,  *puVar7 != 0));\n                        puVar7 = puVar7 + 1) {\n                    }\n                    puVar11 = puVar7 - puStack584 >> 1;\n                }\n                break;\n            case 0x58:\n                goto code_r0x00409110;\n            case 0x5a:\n                piVar5 = fcn.00409600(&param_3);\n                if ((piVar5 == NULL) || (puStack584 = *(piVar5 + 2),  puStack584 == NULL)) {\n                    uVar3 = 0xffffffff;\n                    puStack584 = *0x43b0b8;\n                    puVar7 = *0x43b0b8;\n                    do {\n                        if (uVar3 == 0) break;\n                        uVar3 = uVar3 - 1;\n                        cVar1 = *puVar7;\n                        puVar7 = puVar7 + 1;\n                    } while (cVar1 != '\\0');\n                    puVar11 = ~uVar3 - 1;\n                }\n                else if ((uStack588 & 0x800) == 0) {\n                    puVar11 = *piVar5;\n                    uStack560 = 0;\n                }\n                else {\n                    uStack560 = 1;\n                    puVar11 = *piVar5 >> 1;\n                }\n                break;\n            case 100:\n            case 0x69:\n                iStack556 = 10;\n                uStack588 = uStack588 | 0x40;\n                goto code_r0x00409167;\n            case 0x6e:\n                piVar6 = fcn.00409600(&param_3);\n                if ((uStack588 & 0x20) == 0) {\n                    iStack552 = 1;\n                    *piVar6 = iStack576;\n                }\n                else {\n                    iStack552 = 1;\n                    *piVar6 = iStack576;\n                }\n                break;\n            case 0x6f:\n                iStack556 = 8;\n                if ((uStack588 & 0x80) != 0) {\n                    uStack588 = uStack588 | 0x200;\n                }\n                goto code_r0x00409167;\n            case 0x70:\n                iStack580 = 8;\ncode_r0x00409110:\n                uStack548 = 7;\ncode_r0x00409122:\n                iStack556 = 0x10;\n                if ((uStack588 & 0x80) != 0) {\n                    uStack570 = 0x30;\n                    cStack569 = uStack548 + 'Q';\n                    iStack568 = 2;\n                }\n                goto code_r0x00409167;\n            case 0x75:\n                iStack556 = 10;\ncode_r0x00409167:\n                if ((uStack588 & 0x8000) == 0) {\n                    if ((uStack588 & 0x20) == 0) {\n                        if ((uStack588 & 0x40) == 0) {\n                            uVar3 = fcn.00409600(&param_3);\n                            uVar13 = uVar3;\n                        }\n                        else {\n                            iVar12 = fcn.00409600(&param_3);\n                            uVar13 = iVar12;\n                        }\n                    }\n                    else if ((uStack588 & 0x40) == 0) {\n                        uVar3 = fcn.00409600(&param_3);\n                        uVar13 = uVar3 & 0xffff;\n                    }\n                    else {\n                        iVar2 = fcn.00409600(&param_3);\n                        uVar13 = iVar2;\n                    }\n                }\n                else {\n                    uVar13 = fcn.00409620(&param_3);\n                }\n                if ((((uStack588 & 0x40) != 0) && (uVar13 < 0x100000000)) && (uVar13 < 0)) {\n                    uVar13 = CONCAT44(-((uVar13 >> 0x20) + (uVar13 != 0)), -uVar13);\n                    uStack588 = uStack588 | 0x100;\n                }\n                uVar3 = uVar13 >> 0x20;\n                if ((uStack588 & 0x8000) == 0) {\n                    uVar3 = 0;\n                }\n                uVar14 = uVar13 & 0xffffffff | uVar3 << 0x20;\n                if (iStack580 < 0) {\n                    iStack580 = 1;\n                }\n                else {\n                    uStack588 = uStack588 & 0xfffffff7;\n                }\n                if ((uVar13 | uVar3) == 0) {\n                    iStack568 = 0;\n                }\n                puVar7 = &uStack1;\n                while( true ) {\n                    puVar11 = uVar14 >> 0x20;\n                    iVar12 = iStack580 + -1;\n                    if ((iStack580 < 1) && (uVar14 == 0)) break;\n                    iStack516 = iStack556 >> 0x1f;\n                    iStack580 = iStack556;\n                    iVar8 = fcn.0040c400(uVar14, iStack556, iStack516);\n                    iVar8 = iVar8 + 0x30;\n                    uVar14 = fcn.0040c390();\n                    if (0x39 < iVar8) {\n                        iVar8 = iVar8 + iVar12;\n                    }\n                    *puVar11 = iVar8;\n                    puVar7 = puVar11 + -1;\n                }\n                puVar11 = &uStack1 + -puVar7;\n                puStack584 = puVar7 + 1;\n                iStack580 = iVar12;\n                if (((uStack588 & 0x200) != 0) && ((*puStack584 != '0' || (puVar11 == NULL)))) {\n                    puVar11 = &stack0x00000000 + -puVar7;\n                    *puVar7 = '0';\n                    puStack584 = puVar7;\n                }\n                break;\n            case 0x78:\n                uStack548 = 0x27;\n                goto code_r0x00409122;\n            }\n            if (iStack552 == 0) {\n                if ((uStack588 & 0x40) != 0) {\n                    if ((uStack588 & 0x100) == 0) {\n                        if ((uStack588 & 1) == 0) {\n                            if ((uStack588 & 2) == 0) goto code_r0x004092ff;\n                            uStack570 = 0x20;\n                        }\n                        else {\n                            uStack570 = 0x2b;\n                        }\n                    }\n                    else {\n                        uStack570 = 0x2d;\n                    }\n                    iStack568 = 1;\n                }\ncode_r0x004092ff:\n                iVar12 = (iStack564 - puVar11) - iStack568;\n                if ((uStack588 & 0xc) == 0) {\n                    fcn.00409580(0x20, iVar12, param_1, &iStack576);\n                }\n                fcn.004095c0(&uStack570, iStack568, param_1, &iStack576);\n                if (((uStack588 & 8) != 0) && ((uStack588 & 4) == 0)) {\n                    fcn.00409580(0x30, iVar12, param_1, &iStack576);\n                }\n                if ((uStack560 == 0) || (uVar3 = uStack560,  puVar7 = puStack584,  puVar10 = puVar11,  puVar11 < 1)) {\n                    fcn.004095c0(puStack584, puVar11, param_1, &iStack576);\n                }\n                else {\n                    do {\n                        puVar10 = puVar10 + -1;\n                        iVar8 = fcn.0040c2a0(auStack532, uVar3 & 0xffff0000 | *puVar7);\n                        if (iVar8 < 1) break;\n                        uVar3 = fcn.004095c0(auStack532, iVar8, param_1, &iStack576);\n                        puVar7 = puVar7 + 1;\n                    } while (puVar10 != NULL);\n                }\n                if ((uStack588 & 4) != 0) {\n                    fcn.00409580(0x20, iVar12, param_1, &iStack576);\n                }\n            }\n        }\n        uVar9 = *param_2;\n        param_2 = param_2 + 1;\n        uStack540 = uStack540 & 0xffffff00 | uVar9;\n    } while( true );\n}\n",
        "token_count": 4077
    },
    "00409b80": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid fcn.00409b80(uint8_t *param_1, uint8_t **param_2, uint8_t *param_3, int32_t *param_4, int32_t *param_5)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    bool bVar3;\n    bool bVar4;\n    bool bVar5;\n    int32_t *piVar6;\n    uint8_t *puVar7;\n    uint32_t uVar8;\n    \n    piVar6 = param_5;\n    *param_5 = 0;\n    *param_4 = 1;\n    if (param_2 != NULL) {\n        *param_2 = param_3;\n        param_2 = param_2 + 1;\n    }\n    if (*param_1 == 0x22) {\n        puVar7 = param_1 + 1;\n        uVar2 = param_1[1];\n        while ((uVar2 != 0x22 && (uVar2 != 0))) {\n            if (((*(uVar2 + 0x440519) & 4) != 0) && (*param_5 = *param_5 + 1,  param_3 != NULL)) {\n                *param_3 = *puVar7;\n                param_3 = param_3 + 1;\n                puVar7 = puVar7 + 1;\n            }\n            *param_5 = *param_5 + 1;\n            if (param_3 != NULL) {\n                *param_3 = *puVar7;\n                param_3 = param_3 + 1;\n            }\n            puVar1 = puVar7 + 1;\n            puVar7 = puVar7 + 1;\n            uVar2 = *puVar1;\n        }\n        *param_5 = *param_5 + 1;\n        if (param_3 != NULL) {\n            *param_3 = 0;\n            param_3 = param_3 + 1;\n        }\n        if (*puVar7 == 0x22) {\n            puVar7 = puVar7 + 1;\n        }\n    }\n    else {\n        do {\n            *piVar6 = *piVar6 + 1;\n            if (param_3 != NULL) {\n                *param_3 = *param_1;\n                param_3 = param_3 + 1;\n            }\n            uVar2 = *param_1;\n            puVar7 = param_1 + 1;\n            param_5 = uVar2;\n            if ((*(param_5 + 0x440519) & 4) != 0) {\n                *piVar6 = *piVar6 + 1;\n                if (param_3 != NULL) {\n                    *param_3 = *puVar7;\n                    param_3 = param_3 + 1;\n                }\n                puVar7 = param_1 + 2;\n            }\n            if (uVar2 == 0x20) break;\n            if (uVar2 == 0) goto code_r0x00409c59;\n            param_1 = puVar7;\n        } while (uVar2 != 9);\n        if (uVar2 == 0) {\ncode_r0x00409c59:\n            puVar7 = puVar7 + -1;\n        }\n        else if (param_3 != NULL) {\n            param_3[-1] = 0;\n        }\n    }\n    bVar4 = false;\n    bVar5 = false;\n    while (*puVar7 != 0) {\n        for (; (*puVar7 == 0x20 || (*puVar7 == 9)); puVar7 = puVar7 + 1) {\n        }\n        if (*puVar7 == 0) break;\n        if (param_2 != NULL) {\n            *param_2 = param_3;\n            param_2 = param_2 + 1;\n        }\n        *param_4 = *param_4 + 1;\n        while( true ) {\n            uVar8 = 0;\n            bVar3 = true;\n            uVar2 = *puVar7;\n            while (uVar2 == 0x5c) {\n                puVar1 = puVar7 + 1;\n                puVar7 = puVar7 + 1;\n                uVar8 = uVar8 + 1;\n                uVar2 = *puVar1;\n            }\n            if (*puVar7 == 0x22) {\n                if ((uVar8 & 1) == 0) {\n                    if ((bVar4) && (puVar7[1] == 0x22)) {\n                        puVar7 = puVar7 + 1;\n                    }\n                    else {\n                        bVar3 = false;\n                    }\n                    bVar4 = !bVar5;\n                    bVar5 = bVar4;\n                }\n                uVar8 = uVar8 >> 1;\n            }\n            for (; uVar8 != 0; uVar8 = uVar8 - 1) {\n                if (param_3 != NULL) {\n                    *param_3 = 0x5c;\n                    param_3 = param_3 + 1;\n                }\n                *piVar6 = *piVar6 + 1;\n            }\n            uVar2 = *puVar7;\n            if ((uVar2 == 0) || ((!bVar4 && ((uVar2 == 0x20 || (uVar2 == 9)))))) break;\n            if (bVar3) {\n                if (param_3 == NULL) {\n                    if ((*(uVar2 + 0x440519) & 4) != 0) {\n                        puVar7 = puVar7 + 1;\n                        *piVar6 = *piVar6 + 1;\n                    }\n                    *piVar6 = *piVar6 + 1;\n                    goto code_r0x00409d55;\n                }\n                if ((*(uVar2 + 0x440519) & 4) != 0) {\n                    *param_3 = uVar2;\n                    param_3 = param_3 + 1;\n                    puVar7 = puVar7 + 1;\n                    *piVar6 = *piVar6 + 1;\n                }\n                *param_3 = *puVar7;\n                param_3 = param_3 + 1;\n                *piVar6 = *piVar6 + 1;\n                puVar7 = puVar7 + 1;\n            }\n            else {\ncode_r0x00409d55:\n                puVar7 = puVar7 + 1;\n            }\n        }\n        if (param_3 != NULL) {\n            *param_3 = 0;\n            param_3 = param_3 + 1;\n        }\n        *piVar6 = *piVar6 + 1;\n    }\n    if (param_2 != NULL) {\n        *param_2 = NULL;\n    }\n    *param_4 = *param_4 + 1;\n    return;\n}\n",
        "token_count": 1538
    },
    "00409ef0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid fcn.00409ef0(void)\n\n{\n    code *pcVar1;\n    uint8_t uVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t *piVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uchar auStack68 [46];\n    int16_t iStack22;\n    int32_t *piStack20;\n    \n    puVar3 = fcn.00405e40(0x480);\n    if (puVar3 == NULL) {\n        fcn.00405dc0(0x1b);\n    }\n    *0x440f20 = 0x20;\n    *0x440e20 = puVar3;\n    if (puVar3 < puVar3 + 0x120) {\n        do {\n            *(puVar3 + 1) = 0;\n            *puVar3 = 0xffffffff;\n            *(puVar3 + 5) = 10;\n            puVar3[2] = 0;\n            puVar3 = puVar3 + 9;\n        } while (puVar3 < *0x440e20 + 0x120);\n    }\n    (*_sym.imp.KERNEL32.dll_GetStartupInfoA)(auStack68);\n    if ((iStack22 != 0) && (piStack20 != NULL)) {\n        iVar8 = *piStack20;\n        piStack20 = piStack20 + 1;\n        piVar5 = piStack20 + iVar8;\n        if (0x7ff < iVar8) {\n            iVar8 = 0x800;\n        }\n        iVar4 = iVar8;\n        if (*0x440f20 < iVar8) {\n            piVar6 = 0x440e24;\n            do {\n                puVar3 = fcn.00405e40(0x480);\n                iVar4 = *0x440f20;\n                if (puVar3 == NULL) break;\n                *piVar6 = puVar3;\n                *0x440f20 = *0x440f20 + 0x20;\n                if (puVar3 < puVar3 + 0x120) {\n                    do {\n                        *(puVar3 + 1) = 0;\n                        *puVar3 = 0xffffffff;\n                        *(puVar3 + 5) = 10;\n                        puVar3[2] = 0;\n                        puVar3 = puVar3 + 9;\n                    } while (puVar3 < *piVar6 + 0x480);\n                }\n                piVar6 = piVar6 + 1;\n                iVar4 = iVar8;\n            } while (*0x440f20 < iVar8);\n        }\n        uVar7 = 0;\n        if (0 < iVar4) {\n            do {\n                if (((*piVar5 != -1) && ((*piStack20 & 1) != 0)) &&\n                   (((*piStack20 & 8) != 0 || (iVar8 = (*_sym.imp.KERNEL32.dll_GetFileType)(*piVar5),  iVar8 != 0)))) {\n                    piVar6 = *((uVar7 >> 5) * 4 + 0x440e20) + (uVar7 & 0x1f) * 0x24;\n                    *piVar6 = *piVar5;\n                    *(piVar6 + 1) = *piStack20;\n                }\n                uVar7 = uVar7 + 1;\n                piStack20 = piStack20 + 1;\n                piVar5 = piVar5 + 1;\n            } while (uVar7 < iVar4);\n        }\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_GetStdHandle;\n    iVar8 = 0;\n    do {\n        piVar5 = *0x440e20 + iVar8 * 9;\n        if ((*0x440e20)[iVar8 * 9] == -1) {\n            *(piVar5 + 1) = 0x81;\n            if (iVar8 == 0) {\n                iVar4 = -10;\n            }\n            else {\n                iVar4 = -0xb - (iVar8 != 1);\n            }\n            iVar4 = (*pcVar1)(iVar4);\n            if ((iVar4 == -1) || (uVar7 = (*_sym.imp.KERNEL32.dll_GetFileType)(iVar4),  uVar7 == 0)) {\n                uVar2 = *(piVar5 + 1) | 0x40;\n                goto code_r0x0040a0de;\n            }\n            *piVar5 = iVar4;\n            if ((uVar7 & 0xff) == 2) {\n                uVar2 = *(piVar5 + 1) | 0x40;\n                goto code_r0x0040a0de;\n            }\n            if ((uVar7 & 0xff) == 3) {\n                uVar2 = *(piVar5 + 1) | 8;\n                goto code_r0x0040a0de;\n            }\n        }\n        else {\n            uVar2 = *(piVar5 + 1) | 0x80;\ncode_r0x0040a0de:\n            *(piVar5 + 1) = uVar2;\n        }\n        iVar8 = iVar8 + 1;\n        if (2 < iVar8) {\n            (*_sym.imp.KERNEL32.dll_SetHandleCount)(*0x440f20);\n            return;\n        }\n    } while( true );\n}\n",
        "token_count": 1212
    },
    "0040b1a0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t fcn.0040b1a0(uint32_t param_1, int32_t *param_2)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    \n    piVar3 = param_2;\n    uVar1 = param_2[3];\n    uVar2 = param_2[4];\n    if (((uVar1 & 0x82) == 0) || ((uVar1 & 0x40) != 0)) {\ncode_r0x0040b2c3:\n        param_2[3] = uVar1 | 0x20;\n        return 0xffffffff;\n    }\n    iVar6 = 0;\n    if ((uVar1 & 1) != 0) {\n        param_2[1] = 0;\n        if ((uVar1 & 0x10) == 0) goto code_r0x0040b2c3;\n        *param_2 = param_2[2];\n        param_2[3] = uVar1 & 0xfffffffe;\n    }\n    uVar1 = param_2[3];\n    param_2[1] = 0;\n    param_2[3] = uVar1 & 0xffffffef | 2;\n    if ((uVar1 & 0x10c) == 0) {\n        if ((param_2 == 0x43b0e0) || (param_2 == 0x43b100)) {\n            iVar4 = fcn.0040c0b0(uVar2);\n            if (iVar4 != 0) goto code_r0x0040b213;\n        }\n        fcn.0040ca40(piVar3);\n    }\ncode_r0x0040b213:\n    if ((piVar3[3] & 0x108U) == 0) {\n        iVar4 = 1;\n        iVar6 = fcn.0040c7b0(uVar2, &param_1, 1);\n    }\n    else {\n        iVar5 = piVar3[2];\n        iVar4 = *piVar3 - iVar5;\n        *piVar3 = iVar5 + 1;\n        piVar3[1] = piVar3[6] + -1;\n        if (iVar4 < 1) {\n            if (uVar2 == 0xffffffff) {\n                iVar5 = 0x43b3c8;\n            }\n            else {\n                iVar5 = *((uVar2 >> 5) * 4 + 0x440e20) + (uVar2 & 0x1f) * 0x24;\n            }\n            if ((*(iVar5 + 4) & 0x20) != 0) {\n                fcn.0040c6b0(uVar2, 0, 2);\n            }\n            *piVar3[2] = param_1;\n        }\n        else {\n            iVar6 = fcn.0040c7b0(uVar2, iVar5, iVar4);\n            *piVar3[2] = param_1;\n        }\n    }\n    if (iVar6 != iVar4) {\n        piVar3[3] = piVar3[3] | 0x20;\n        return 0xffffffff;\n    }\n    return param_1 & 0xff;\n}\n",
        "token_count": 761
    },
    "0040c6b0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint fcn.0040c6b0(uint32_t param_1, uint param_2, uint param_3)\n\n{\n    uint uVar1;\n    uint *puVar2;\n    \n    if ((param_1 < *0x440f20) && ((*(*((param_1 >> 5) * 4 + 0x440e20) + 4 + (param_1 & 0x1f) * 0x24) & 1) != 0)) {\n        fcn.0040e2f0(param_1);\n        uVar1 = fcn.0040c730(param_1, param_2, param_3);\n        fcn.0040e360(param_1);\n        return uVar1;\n    }\n    puVar2 = fcn.00407210();\n    *puVar2 = 9;\n    puVar2 = fcn.00407220();\n    *puVar2 = 0;\n    return 0xffffffff;\n}\n",
        "token_count": 216
    },
    "0040c7b0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint fcn.0040c7b0(uint32_t param_1, uint param_2, uint param_3)\n\n{\n    uint uVar1;\n    uint *puVar2;\n    \n    if ((param_1 < *0x440f20) && ((*(*((param_1 >> 5) * 4 + 0x440e20) + 4 + (param_1 & 0x1f) * 0x24) & 1) != 0)) {\n        fcn.0040e2f0(param_1);\n        uVar1 = fcn.0040c830(param_1, param_2, param_3);\n        fcn.0040e360(param_1);\n        return uVar1;\n    }\n    puVar2 = fcn.00407210();\n    *puVar2 = 9;\n    puVar2 = fcn.00407220();\n    *puVar2 = 0;\n    return 0xffffffff;\n}\n",
        "token_count": 216
    },
    "0040dd50": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint32_t fcn.0040dd50(uint32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t auStack8 [2];\n    \n    uVar1 = param_1;\n    if (*0x440828 == 0) {\n        if ((0x40 < param_1) && (param_1 < 0x5b)) {\n            return param_1 + 0x20;\n        }\n    }\n    else {\n        if (param_1 < 0x100) {\n            if (*0x43d6bc < 2) {\n                uVar2 = *(*0x43d4b0 + param_1 * 2) & 1;\n            }\n            else {\n                uVar2 = fcn.0040b2d0(param_1, 1);\n            }\n            if (uVar2 == 0) {\n                return uVar1;\n            }\n        }\n        if ((*(*0x43d4b0 + 1 + (uVar1 >> 8 & 0xffU) * 2) & 0x80) == 0) {\n            param_1 = param_1 & 0xffff0000 | uVar1 & 0xff;\n            uVar3 = 1;\n        }\n        else {\n            param_1 = param_1 & 0xff000000 | CONCAT11(uVar1, uVar1 >> 8);\n            uVar3 = 2;\n        }\n        iVar4 = fcn.0040adf0(*0x440828, 0x100, &param_1, uVar3, auStack8, 3, 0);\n        if (iVar4 == 0) {\n            return uVar1;\n        }\n        if (iVar4 == 1) {\n            return auStack8[0] & 0xff;\n        }\n        param_1 = (auStack8[0] >> 8 & 0xff) << 8 | auStack8[0] & 0xff;\n    }\n    return param_1;\n}\n",
        "token_count": 468
    },
    "0040e2a0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint fcn.0040e2a0(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    \n    if ((param_1 < *0x440f20) &&\n       (iVar1 = *((param_1 >> 5) * 4 + 0x440e20),  (*(iVar1 + 4 + (param_1 & 0x1f) * 0x24) & 1) != 0)) {\n        return *(iVar1 + (param_1 & 0x1f) * 0x24);\n    }\n    puVar2 = fcn.00407210();\n    *puVar2 = 9;\n    puVar2 = fcn.00407220();\n    *puVar2 = 0;\n    return 0xffffffff;\n}\n",
        "token_count": 181
    },
    "0040e870": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint fcn.0040e870(uint32_t param_1)\n\n{\n    uint uVar1;\n    uint *puVar2;\n    \n    if ((param_1 < *0x440f20) && ((*(*((param_1 >> 5) * 4 + 0x440e20) + 4 + (param_1 & 0x1f) * 0x24) & 1) != 0)) {\n        fcn.0040e2f0(param_1);\n        uVar1 = fcn.0040e8e0(param_1);\n        fcn.0040e360(param_1);\n        return uVar1;\n    }\n    puVar2 = fcn.00407210();\n    *puVar2 = 9;\n    puVar2 = fcn.00407220();\n    *puVar2 = 0;\n    return 0xffffffff;\n}\n",
        "token_count": 198
    },
    "00413d10": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t fcn.00413d10(uint32_t param_1, char **param_2)\n\n{\n    char *pcVar1;\n    char *pcVar2;\n    \n    if ((param_1 != 0xffffffff) &&\n       ((pcVar1 = param_2[3],  (pcVar1 & 1) != 0 || (((pcVar1 & 0x80) != 0 && ((pcVar1 & 2) == 0)))))) {\n        if (param_2[2] == NULL) {\n            fcn.0040ca40(param_2);\n        }\n        if (*param_2 == param_2[2]) {\n            if (param_2[1] != NULL) {\n                return 0xffffffff;\n            }\n            *param_2 = *param_2 + 1;\n        }\n        if ((*(param_2 + 3) & 0x40) == 0) {\n            pcVar1 = *param_2;\n            *param_2 = pcVar1 + -1;\n            pcVar1[-1] = param_1;\n        }\n        else {\n            pcVar1 = *param_2;\n            pcVar2 = pcVar1 + -1;\n            *param_2 = pcVar2;\n            if (*pcVar2 != param_1) {\n                *param_2 = pcVar1;\n                return 0xffffffff;\n            }\n        }\n        param_2[1] = param_2[1] + 1;\n        param_2[3] = param_2[3] & 0xffffffef | 1;\n        return param_1 & 0xff;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 369
    },
    "00413e10": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t fcn.00413e10(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    if (((*(param_1 + 0xc) & 0x83) != 0) && (((param_3 == 0 || (param_3 == 1)) || (param_3 == 2)))) {\n        *(param_1 + 0xc) = *(param_1 + 0xc) & 0xffffffef;\n        if (param_3 == 1) {\n            iVar2 = fcn.00414820(param_1);\n            param_2 = param_2 + iVar2;\n            param_3 = 0;\n        }\n        fcn.0040c160(param_1);\n        uVar1 = *(param_1 + 0xc);\n        if ((uVar1 & 0x80) == 0) {\n            if ((((uVar1 & 1) != 0) && ((uVar1 & 8) != 0)) && ((uVar1 & 0x400) == 0)) {\n                *(param_1 + 0x18) = 0x200;\n            }\n        }\n        else {\n            *(param_1 + 0xc) = uVar1 & 0xfffffffc;\n        }\n        iVar2 = fcn.0040c6b0(*(param_1 + 0x10), param_2, param_3);\n        return (iVar2 != -1) - 1;\n    }\n    puVar3 = fcn.00407210();\n    *puVar3 = 0x16;\n    return -1;\n}\n",
        "token_count": 385
    },
    "00414630": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00414675)\n\nuint64_t fcn.00414630(char **param_1)\n\n{\n    char *pcVar1;\n    char *pcVar2;\n    char *pcVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    char *pcVar6;\n    int32_t iVar7;\n    int64_t iVar8;\n    int64_t iVar9;\n    uint var_4h;\n    char **var_8h;\n    uint var_10h;\n    char *pcStack12;\n    \n    pcVar1 = var_8h[4];\n    if (var_8h[1] < 0) {\n        var_8h[1] = NULL;\n    }\n    iVar8 = fcn.00415140(pcVar1, 0, 0, 1);\n    if ((iVar8 < 0x100000000) && (iVar8 < 0)) {\n        return 0xffffffffffffffff;\n    }\n    pcVar6 = var_8h[3];\n    if ((pcVar6 & 0x108) == 0) {\n        return iVar8 - var_8h[1];\n    }\n    pcVar3 = *var_8h;\n    pcVar2 = var_8h[2];\n    pcStack12 = pcVar3 + -pcVar2;\n    iVar5 = pcVar1 >> 5;\n    if ((pcVar6 & 3) == 0) {\n        if ((pcVar6 & 0x80) == 0) {\n            puVar4 = fcn.00407210();\n            *puVar4 = 0x16;\n            return 0xffffffffffffffff;\n        }\n    }\n    else {\n        pcVar6 = pcVar2;\n        if ((*(*(iVar5 * 4 + 0x440e20) + 4 + (pcVar1 & 0x1f) * 0x24) & 0x80) != 0) {\n            for (; pcVar6 < pcVar3; pcVar6 = pcVar6 + 1) {\n                if (*pcVar6 == '\\n') {\n                    pcStack12 = pcStack12 + 1;\n                }\n            }\n        }\n    }\n    if (iVar8 == 0) {\n        return ZEXT48(pcStack12);\n    }\n    if (((*(var_8h + 3) & 1) == 0) || (var_8h[1] == NULL)) goto code_r0x004147e2;\n    pcVar6 = pcVar3 + var_8h[1] + -pcVar2;\n    iVar7 = (pcVar1 & 0x1f) * 0x24;\n    if ((*(iVar7 + 4 + *(iVar5 * 4 + 0x440e20)) & 0x80) != 0) {\n        iVar9 = fcn.00415140(pcVar1, 0, 0, 2);\n        if (iVar9 == iVar8) {\n            pcVar3 = var_8h[2];\n            pcVar1 = pcVar6 + pcVar3;\n            for (; pcVar3 < pcVar1; pcVar3 = pcVar3 + 1) {\n                if (*pcVar3 == '\\n') {\n                    pcVar6 = pcVar6 + 1;\n                }\n            }\n            if ((var_8h[3] & 0x2000) != 0) {\ncode_r0x004147c8:\n                pcVar6 = pcVar6 + 1;\n            }\n        }\n        else {\n            fcn.00415140(pcVar1, iVar8, 0);\n            if (((pcVar6 < 0x201) && ((var_8h[3] & 8) != 0)) && ((var_8h[3] & 0x400) == 0)) {\n                pcVar6 = 0x200;\n            }\n            else {\n                pcVar6 = var_8h[6];\n            }\n            if ((*(iVar7 + 4 + *(iVar5 * 4 + 0x440e20)) & 4) != 0) goto code_r0x004147c8;\n        }\n    }\n    iVar8 = CONCAT44((iVar8 >> 0x20) - (iVar8 < pcVar6), iVar8 + -pcVar6);\ncode_r0x004147e2:\n    return iVar8 + 0x18;\n}\n",
        "token_count": 983
    },
    "00414820": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t fcn.00414820(char **param_1)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    char *pcVar3;\n    int32_t iVar4;\n    char *pcVar5;\n    uint *puVar6;\n    char *pcVar7;\n    int32_t iVar8;\n    int32_t iStack8;\n    int32_t iStack4;\n    \n    pcVar2 = param_1[4];\n    if (param_1[1] < 0) {\n        param_1[1] = NULL;\n    }\n    iStack4 = fcn.0040c6b0(pcVar2, 0, 1);\n    if (iStack4 < 0) {\n        return -1;\n    }\n    pcVar7 = param_1[3];\n    if ((pcVar7 & 0x108) == 0) {\n        return iStack4 - param_1[1];\n    }\n    pcVar5 = *param_1;\n    pcVar3 = param_1[2];\n    iStack8 = pcVar5 - pcVar3;\n    if ((pcVar7 & 3) == 0) {\n        if ((pcVar7 & 0x80) == 0) {\n            puVar6 = fcn.00407210();\n            *puVar6 = 0x16;\n            return -1;\n        }\n    }\n    else {\n        pcVar7 = pcVar3;\n        if ((*(*((pcVar2 >> 5) * 4 + 0x440e20) + 4 + (pcVar2 & 0x1f) * 0x24) & 0x80) != 0) {\n            for (; pcVar7 < pcVar5; pcVar7 = pcVar7 + 1) {\n                if (*pcVar7 == '\\n') {\n                    iStack8 = iStack8 + 1;\n                }\n            }\n        }\n    }\n    if (iStack4 == 0) {\n        return iStack8;\n    }\n    if ((*(param_1 + 3) & 1) == 0) goto code_r0x00414997;\n    if (param_1[1] == NULL) {\n        return iStack4;\n    }\n    pcVar7 = pcVar5 + param_1[1] + -pcVar3;\n    piVar1 = (pcVar2 >> 5) * 4 + 0x440e20;\n    iVar8 = (pcVar2 & 0x1f) * 0x24;\n    if ((*(iVar8 + 4 + *piVar1) & 0x80) != 0) {\n        iVar4 = fcn.0040c6b0(pcVar2, 0, 2);\n        if (iVar4 == iStack4) {\n            pcVar5 = param_1[2];\n            pcVar2 = pcVar7 + pcVar5;\n            for (; pcVar5 < pcVar2; pcVar5 = pcVar5 + 1) {\n                if (*pcVar5 == '\\n') {\n                    pcVar7 = pcVar7 + 1;\n                }\n            }\n            if ((param_1[3] & 0x2000) != 0) {\ncode_r0x0041498e:\n                pcVar7 = pcVar7 + 1;\n            }\n        }\n        else {\n            fcn.0040c6b0(pcVar2, iStack4, 0);\n            if (((pcVar7 < 0x201) && ((param_1[3] & 8) != 0)) && ((param_1[3] & 0x400) == 0)) {\n                pcVar7 = 0x200;\n            }\n            else {\n                pcVar7 = param_1[6];\n            }\n            if ((*(iVar8 + 4 + *piVar1) & 4) != 0) goto code_r0x0041498e;\n        }\n    }\n    iStack4 = iStack4 - pcVar7;\ncode_r0x00414997:\n    return iStack4 + iStack8;\n}\n",
        "token_count": 914
    },
    "00414e90": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint fcn.00414e90(uint32_t param_1, uint param_2, uint param_3)\n\n{\n    uint uVar1;\n    uint *puVar2;\n    \n    if ((param_1 < *0x440f20) && ((*(*((param_1 >> 5) * 4 + 0x440e20) + 4 + (param_1 & 0x1f) * 0x24) & 1) != 0)) {\n        fcn.0040e2f0(param_1);\n        uVar1 = fcn.00414f10(param_1, param_2, param_3);\n        fcn.0040e360(param_1);\n        return uVar1;\n    }\n    puVar2 = fcn.00407210();\n    *puVar2 = 9;\n    puVar2 = fcn.00407220();\n    *puVar2 = 0;\n    return 0xffffffff;\n}\n",
        "token_count": 214
    },
    "00415140": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nulong fcn.00415140(uint32_t param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    \n    if ((param_1 < *0x440f20) && ((*(*((param_1 >> 5) * 4 + 0x440e20) + 4 + (param_1 & 0x1f) * 0x24) & 1) != 0)) {\n        fcn.0040e2f0(param_1);\n        uVar2 = fcn.004151d0(param_1, param_2, param_3, param_4);\n        fcn.0040e360(param_1);\n        return uVar2;\n    }\n    puVar1 = fcn.00407210();\n    *puVar1 = 9;\n    puVar1 = fcn.00407220();\n    *puVar1 = 0;\n    return 0xffffffffffffffff;\n}\n",
        "token_count": 223
    },
    "0041710e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t fcn.0041710e(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t *extraout_ECX;\n    uint unaff_EBX;\n    uint uVar6;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint *in_FS_OFFSET;\n    uint unaff_retaddr;\n    uint var_10h;\n    int32_t *noname_4;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint in_stack_ffffffec;\n    uint var_ch;\n    uint in_stack_fffffff4;\n    uint var_4h;\n    int32_t *noname_14;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = &var_20h;\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    iVar2 = extraout_ECX[0x11];\n    *(unaff_EBP + -0x14) = extraout_ECX[0x12];\n    var_20h = unaff_EDI;\n    var_1ch = unaff_ESI;\n    var_18h = unaff_EBX;\n    noname_14 = extraout_ECX;\n    iVar1 = fcn.0042d07c();\n    uVar6 = *(iVar1 + 0xc);\n    if (extraout_ECX[0x10] != 0) {\n        iVar2 = fcn.0042d07c();\n        uVar6 = *(iVar2 + 0xc);\n        uVar3 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar6, extraout_ECX[0x10], 5);\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar6, uVar3);\n    }\n    if (iVar2 != 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar2);\n        *(unaff_EBP + -0x14) = uVar3;\n    }\n    if (*(unaff_EBP + -0x14) == 0) {\n        iVar2 = -1;\n    }\n    else {\n        iVar1 = fcn.00417099();\n        *(unaff_EBP + -0x20) = iVar1;\n        fcn.004186f9();\n        iVar2 = iVar1;\n        fcn.0041819c();\n        *(unaff_EBP + -0x1c) = 0;\n        if (iVar1 != 0) {\n            iVar4 = (*_sym.imp.USER32.dll_IsWindowEnabled)(iVar1);\n            if (iVar4 != 0) {\n                (*_sym.imp.USER32.dll_EnableWindow)(iVar1, 0);\n                *(unaff_EBP + -0x1c) = 1;\n            }\n        }\n        *(unaff_EBP + -4) = 0;\n        noname_4 = extraout_ECX;\n        fcn.004186ad();\n        iVar4 = iVar1;\n        uVar3 = fcn.0041819c();\n        iVar2 = fcn.00416e30(*(unaff_EBP + -0x14), uVar3, uVar6, iVar4, noname_4, iVar2, var_20h, var_1ch, var_18h, \n                             var_14h, in_stack_ffffffec, var_ch, in_stack_fffffff4, var_4h, noname_14, unaff_retaddr, \n                             param_1, param_2, param_3);\n        if (iVar2 != 0) {\n            if ((*(extraout_ECX + 9) & 0x10) != 0) {\n                uVar6 = 4;\n                uVar5 = fcn.0041ae7b();\n                if ((uVar5 & 0x100) != 0) {\n                    uVar6 = 5;\n                }\n                fcn.0041aa6b(uVar6);\n            }\n            if (extraout_ECX[7] != 0) {\n                fcn.0041af6d(0, 0, 0, 0, 0, 0x97);\n            }\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*(unaff_EBP + -0x1c) != 0) {\n            (*_sym.imp.USER32.dll_EnableWindow)(iVar1, 1);\n        }\n        if (iVar1 != 0) {\n            iVar2 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n            if (iVar2 == extraout_ECX[7]) {\n                (*_sym.imp.USER32.dll_SetActiveWindow)(iVar1);\n            }\n        }\n        (**(*extraout_ECX + 0x60))();\n        fcn.004170d0();\n        iVar2 = extraout_ECX[0xb];\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 1251
    },
    "00418917": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00418917(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    \n    iVar2 = fcn.004176e6();\n    if (iVar2 == 0) goto code_r0x00418962;\n    if (*(iVar2 + 0x1c) == param_1) {\n        iVar3 = fcn.0042d07c();\n        if (*(iVar3 + 0x14) == '\\0') {\n            iVar3 = fcn.0042d07c();\n            if (iVar2 == *(iVar3 + 4)) {\n                iVar3 = fcn.0042a1c4();\n                if (iVar3 == 0) goto code_r0x00418957;\n            }\n            fcn.0042e28c(0);\n        }\ncode_r0x00418957:\n        *(iVar2 + 0x1c) = 0;\n    }\n    if (*(iVar2 + 0x20) == param_1) {\n        *(iVar2 + 0x20) = 0;\n    }\ncode_r0x00418962:\n    if (param_1[0xc] != NULL) {\n        (**(*param_1[0xc] + 0x58))();\n        param_1[0xc] = 0;\n    }\n    if (param_1[0xd] != NULL) {\n        (**(*param_1[0xd] + 4))(1);\n    }\n    param_1[0xd] = 0;\n    if ((*(param_1 + 9) & 1) != 0) {\n        iVar2 = fcn.0042cd29();\n        iVar2 = *(iVar2 + 0xcc);\n        if (iVar2 == 0) {\n            iVar3 = 0;\n        }\n        else {\n            iVar3 = *(iVar2 + 0x1c);\n        }\n        if (iVar3 != 0) {\n            fcn.00406030(&var_2ch, 0, 0x2c);\n            var_24h = param_1[7];\n            var_2ch = 0x2c;\n            var_28h = 1;\n            var_20h = var_24h;\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x1c), 0x405, 0, &var_2ch);\n        }\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongA;\n    iVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(param_1[7], 0xfffffffc);\n    fcn.004180f1();\n    iVar3 = (*pcVar1)(param_1[7], 0xfffffffc);\n    if (iVar3 == iVar2) {\n        piVar4 = (**(*param_1 + 0x88))();\n        if (*piVar4 != 0) {\n            (*_sym.imp.USER32.dll_SetWindowLongA)(param_1[7], 0xfffffffc, *piVar4);\n        }\n    }\n    fcn.00418219();\n    (**(*param_1 + 0xac))();\n    return;\n}\n",
        "token_count": 754
    },
    "0041aa6b": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0041aac3)\n// WARNING: Removing unreachable block (ram,0x0041aad2)\n// WARNING: Removing unreachable block (ram,0x0041aad8)\n// WARNING: Removing unreachable block (ram,0x0041aaee)\n// WARNING: Removing unreachable block (ram,0x0041aaf5)\n// WARNING: Removing unreachable block (ram,0x0041aafb)\n// WARNING: Removing unreachable block (ram,0x0041ab01)\n// WARNING: Removing unreachable block (ram,0x0041ab10)\n// WARNING: Removing unreachable block (ram,0x0041ab17)\n// WARNING: Removing unreachable block (ram,0x0041ab2f)\n\nint32_t __thiscall fcn.0041aa6b(int32_t *param_1, uint8_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t unaff_EBX;\n    \n    if ((param_2 & 4) != 0) {\n        fcn.0041ae7b();\n    }\n    (*_sym.imp.USER32.dll_GetParent)(param_1[7]);\n    param_1[9] = param_1[9] | 0x18;\n    iVar1 = fcn.004176e6();\n    while( true ) {\n        piVar2 = fcn.004176e6();\n        iVar3 = (**(*piVar2 + 100))();\n        if (iVar3 == 0) {\n            fcn.0042e28c(0);\n            return -1;\n        }\n        if ((unaff_EBX != 0) && ((*(iVar1 + 0x34) == 0x118 || (*(iVar1 + 0x34) == 0x104)))) {\n            fcn.0041afbc(1);\n            (*_sym.imp.USER32.dll_UpdateWindow)(param_1[7]);\n            unaff_EBX = 0;\n        }\n        iVar3 = (**(*param_1 + 0x78))();\n        if (iVar3 == 0) break;\n        piVar2 = fcn.004176e6();\n        iVar3 = (**(*piVar2 + 0x6c))(iVar1 + 0x30);\n        if (iVar3 != 0) {\n            unaff_EBX = 0;\n        }\n        (*_sym.imp.USER32.dll_PeekMessageA)(iVar1 + 0x30, 0, 0, 0, 0);\n    }\n    param_1[9] = param_1[9] & 0xffffffe7;\n    return param_1[0xb];\n}\n",
        "token_count": 599
    },
    "0041abf5": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.0041abf5(uint32_t arg_8h)\n\n{\n    uint noname_7;\n    uint noname_9;\n    int32_t iVar1;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    int32_t iVar2;\n    uint unaff_retaddr;\n    uint32_t var_28h;\n    uint var_24h;\n    uint in_stack_ffffffdc;\n    uint in_stack_ffffffe0;\n    uint var_18h;\n    uint in_stack_ffffffe8;\n    uint var_10h;\n    uint var_ch;\n    uint in_stack_fffffff4;\n    uint var_4h;\n    \n    iVar2 = 0;\n    fcn.00406030(&var_28h, 0, 0x28);\n    var_24h = _sym.imp.USER32.dll_DefWindowProcA;\n    iVar1 = fcn.0042d07c();\n    noname_9 = *0x4400d0;\n    noname_7 = *(iVar1 + 8);\n    iVar1 = fcn.0042d07c();\n    if ((arg_8h & 1) == 0) {\n        if ((arg_8h & 0x20) == 0) {\n            if ((arg_8h & 2) == 0) {\n                if ((arg_8h & 4) == 0) {\n                    if ((arg_8h & 8) == 0) {\n                        if ((arg_8h & 0x10) != 0) {\n                            (*_sym.imp.COMCTL32.dll_InitCommonControls)();\n                            *(iVar1 + 0x18) = *(iVar1 + 0x18) | 0x10;\n                            iVar2 = 1;\n                        }\n                    }\n                    else {\n                        var_28h = 0xb;\n                        iVar2 = fcn.0041ad2f(&var_28h, \"AfxFrameOrView42s\", 0x7a02);\n                        if (iVar2 != 0) {\n                            *(iVar1 + 0x18) = *(iVar1 + 0x18) | 8;\n                        }\n                    }\n                }\n                else {\n                    var_28h = 8;\n                    iVar2 = fcn.0041ad2f(&var_28h, \"AfxMDIFrame42s\", 0x7a01);\n                    if (iVar2 != 0) {\n                        *(iVar1 + 0x18) = *(iVar1 + 0x18) | 4;\n                    }\n                }\n            }\n            else {\n                var_28h = 0;\n                iVar2 = fcn.00418e48(&var_28h, unaff_EDI, unaff_ESI, 0, var_24h, in_stack_ffffffdc, in_stack_ffffffe0, \n                                     noname_7, in_stack_ffffffe8, noname_9, 0x10, in_stack_fffffff4, \"AfxControlBar42s\"\n                                     , unaff_EBP, unaff_retaddr, arg_8h);\n                if (iVar2 != 0) {\n                    *(iVar1 + 0x18) = *(iVar1 + 0x18) | 2;\n                }\n            }\n        }\n        else {\n            var_28h = var_28h | 0x8b;\n            iVar2 = fcn.00418e48(&var_28h, unaff_EDI, unaff_ESI, var_28h, var_24h, in_stack_ffffffdc, in_stack_ffffffe0\n                                 , noname_7, in_stack_ffffffe8, noname_9, var_ch, in_stack_fffffff4, \"AfxOleControl42s\"\n                                 , unaff_EBP, unaff_retaddr, arg_8h);\n            if (iVar2 != 0) {\n                *(iVar1 + 0x18) = *(iVar1 + 0x18) | 0x20;\n            }\n        }\n    }\n    else {\n        var_28h = 0xb;\n        iVar2 = fcn.00418e48(&var_28h, unaff_EDI, unaff_ESI, 0xb, var_24h, in_stack_ffffffdc, in_stack_ffffffe0, \n                             noname_7, in_stack_ffffffe8, noname_9, var_ch, in_stack_fffffff4, \"AfxWnd42s\", unaff_EBP, \n                             unaff_retaddr, arg_8h);\n        if (iVar2 != 0) {\n            *(iVar1 + 0x18) = *(iVar1 + 0x18) | 1;\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 1150
    },
    "0041ae48": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041ae48(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    if ((*(param_1 + 0x25) & 1) == 0) {\n        (*_sym.imp.USER32.dll_IsDialogMessageA)(*(param_1 + 0x1c), param_2);\n    }\n    else {\n        iVar1 = fcn.0042d07c();\n        (**(**(iVar1 + 0x1038) + 0x24))(param_1, param_2);\n    }\n    return;\n}\n",
        "token_count": 134
    },
    "0041bf21": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_16ah\n\nuint __cdecl fcn.0041bf21(uint arg_8h, uint pszPath, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_180h;\n    uint psfi;\n    uint var_16ah;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = 0;\n    iVar3 = *(unaff_EBP + 0xc);\n    **(unaff_EBP + 0x10) = 0;\n    *(unaff_EBP + -4) = 0;\n    iVar1 = (*_sym.imp.SHELL32.dll_SHGetFileInfoA)();\n    if ((iVar1 != 0) && ((*(unaff_EBP + -0x16a) & 1) != 0)) {\n        iVar1 = fcn.0041bcf8(0x4333b0, 0, 0x4333c0, unaff_EBP + 0xc);\n        if (-1 < iVar1) {\n            iVar1 = (****(unaff_EBP + 0xc))(*(unaff_EBP + 0xc), 0x4333a0, unaff_EBP + -0x14);\n            if (-1 < iVar1) {\n                if (iVar3 == 0) {\n                    uVar2 = 0;\n                }\n                else {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(iVar3);\n                    fcn.00405820();\n                    uVar2 = fcn.0041b5e1(&stack0xfffffe68, iVar3, iVar1 + 1);\n                }\n                iVar3 = (**(**(unaff_EBP + -0x14) + 0x14))(*(unaff_EBP + -0x14), uVar2, 0);\n                if (-1 < iVar3) {\n                    if (*(unaff_EBP + 8) == 0) {\n                        uVar2 = 0;\n                    }\n                    else {\n                        uVar2 = *(*(unaff_EBP + 8) + 0x1c);\n                    }\n                    iVar3 = (**(**(unaff_EBP + 0xc) + 0x4c))(*(unaff_EBP + 0xc), uVar2, 2);\n                    if (-1 < iVar3) {\n                        (**(**(unaff_EBP + 0xc) + 0xc))\n                                  (*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), 0, 0);\n                        (**(**(unaff_EBP + -0x14) + 8))(*(unaff_EBP + -0x14));\n                        (**(**(unaff_EBP + 0xc) + 8))(*(unaff_EBP + 0xc));\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        fcn.0041bcea();\n                        uVar2 = 1;\n                        goto code_r0x0041c054;\n                    }\n                }\n                (**(**(unaff_EBP + -0x14) + 8))(*(unaff_EBP + -0x14));\n            }\n            (**(**(unaff_EBP + 0xc) + 8))(*(unaff_EBP + 0xc));\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041bcea();\n    uVar2 = 0;\ncode_r0x0041c054:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 873
    },
    "0041ccfa": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0041ccfa(int32_t *param_1, uint param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    uint32_t *arg_8h;\n    uint32_t uVar2;\n    \n    param_1[1] = param_3;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40);\n    *param_1 = iVar1;\n    if (iVar1 != 0) {\n        arg_8h = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1);\n        fcn.00405850(arg_8h, param_3 + 0x40, param_1[1]);\n        if (*(arg_8h + 2) == -1) {\n            uVar2 = arg_8h[3];\n        }\n        else {\n            uVar2 = *arg_8h;\n        }\n        param_1[2] = ~uVar2 >> 6 & 1;\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*param_1);\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 254
    },
    "0041d16a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\ncode * __thiscall fcn.0041d16a(code *param_1, uint8_t param_2)\n\n{\n    code *pcVar1;\n    \n    if ((param_2 & 2) == 0) {\n        fcn.0041b20c();\n        pcVar1 = param_1;\n        if ((param_2 & 1) == 0) {\n            return param_1;\n        }\n    }\n    else {\n        pcVar1 = fcn.0041b20c;\n        fcn.004073f0(param_1, 4, *(param_1 + -4), fcn.0041b20c);\n    }\n    fcn.004166cf(pcVar1);\n    return param_1;\n}\n",
        "token_count": 164
    },
    "0041fdf0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint * __cdecl fcn.0041fdf0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint *extraout_ECX;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    iVar2 = **(unaff_EBP + 8);\n    (**(iVar2 + 0x20))(extraout_ECX + 4);\n    uVar3 = *(unaff_EBP + 0xc);\n    uVar1 = *(unaff_EBP + 8);\n    extraout_ECX[3] = 0xffffffff;\n    extraout_ECX[5] = uVar3;\n    extraout_ECX[8] = uVar1;\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[0xe] = 0;\n    extraout_ECX[0xd] = 0;\n    *extraout_ECX = 0;\n    extraout_ECX[1] = 1;\n    if ((~uVar3 & 1) == 0) {\n        extraout_ECX[0xf] = 0x40;\n    }\n    else {\n        extraout_ECX[0xf] = 0x10;\n    }\n    uVar3 = *(unaff_EBP + 0x14);\n    extraout_ECX[6] = 1;\n    extraout_ECX[0xb] = uVar3;\n    iVar4 = *(unaff_EBP + 0x10);\n    extraout_ECX[0x10] = 0x89;\n    extraout_ECX[2] = 0;\n    if (iVar4 < 0x80) {\n        extraout_ECX[7] = 0x80;\n        extraout_ECX[0xb] = 0;\n    }\n    else {\n        extraout_ECX[7] = iVar4;\n    }\n    iVar4 = extraout_ECX[0xb];\n    *(unaff_EBP + 0x10) = extraout_ECX[7];\n    if (iVar4 == 0) {\n        iVar2 = (**(iVar2 + 0x58))(3, 0, 0, 0);\n        extraout_ECX[2] = iVar2;\n        if (iVar2 == 0) {\n            uVar3 = fcn.00416693(extraout_ECX[7]);\n            extraout_ECX[0xb] = uVar3;\n            extraout_ECX[6] = 0;\n        }\n        else {\n            *(unaff_EBP + 0x10) = 0;\n        }\n    }\n    iVar4 = *(unaff_EBP + 0x10) + extraout_ECX[0xb];\n    extraout_ECX[10] = iVar4;\n    iVar2 = extraout_ECX[0xb];\n    if ((*(extraout_ECX + 5) & 1) != 0) {\n        iVar2 = iVar4;\n    }\n    uVar3 = *(unaff_EBP + -0xc);\n    extraout_ECX[9] = iVar2;\n    *in_FS_OFFSET = uVar3;\n    return extraout_ECX;\n}\n",
        "token_count": 818
    },
    "00420100": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00420100(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if ((*(param_1 + 0x14) & 1) == 0) {\n        iVar1 = *(param_1 + 0x2c);\n        if ((iVar1 != 0) && (*(param_1 + 0x24) == iVar1)) {\n            return;\n        }\n        if (*(param_1 + 8) == 0) {\n            (**(**(param_1 + 0x20) + 0x40))(iVar1, *(param_1 + 0x24) - iVar1);\n        }\n        else {\n            (**(**(param_1 + 0x20) + 0x58))(2, *(param_1 + 0x24) - iVar1, 0, 0);\n            (**(**(param_1 + 0x20) + 0x58))(1, *(param_1 + 0x1c), param_1 + 0x2c, param_1 + 0x28);\n        }\n        uVar2 = *(param_1 + 0x2c);\n    }\n    else {\n        if (*(param_1 + 0x28) != *(param_1 + 0x24)) {\n            (**(**(param_1 + 0x20) + 0x30))(*(param_1 + 0x24) - *(param_1 + 0x28), 1);\n        }\n        uVar2 = *(param_1 + 0x28);\n    }\n    *(param_1 + 0x24) = uVar2;\n    return;\n}\n",
        "token_count": 376
    },
    "00421831": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00421831(uint arg_8h, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t *in_ECX;\n    uint *puVar3;\n    int32_t var_28h;\n    uint8_t var_1fh;\n    uint var_1eh;\n    uint var_14h;\n    code *var_4h;\n    \n    var_4h = *(*in_ECX + 0xa8);\n    (*var_4h)(0x417, arg_8h, &var_28h);\n    var_1eh._0_1_ = 0;\n    var_1eh._1_1_ = 0;\n    *(arg_ch + 2) = *(arg_ch + 2) ^ 4;\n    *(arg_ch + 10) = 0;\n    *(arg_ch + 0xb) = 0;\n    iVar1 = fcn.00405f80(arg_ch, &var_28h, 0x14);\n    if (iVar1 != 0) {\n        uVar2 = fcn.0041ae7b();\n        fcn.0041aeaf(0x10000000, 0, 0);\n        (*var_4h)(0x416, arg_8h, 0);\n        (*var_4h)(0x415, arg_8h, arg_ch);\n        fcn.0041aeaf(0, uVar2 & 0x10000000, 0);\n        if ((((var_1fh ^ *(arg_ch + 9)) & 1) == 0) && (((*(arg_ch + 9) & 1) == 0 || (*arg_ch == var_28h)))) {\n            iVar1 = (*var_4h)(0x41d, arg_8h, &var_14h);\n            if (iVar1 == 0) {\n                return;\n            }\n            puVar3 = &var_14h;\n        }\n        else {\n            puVar3 = NULL;\n        }\n        (*_sym.imp.USER32.dll_InvalidateRect)(in_ECX[7], puVar3, 0);\n    }\n    return;\n}\n",
        "token_count": 497
    },
    "00421a0a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421a0a(int32_t *arg_8h, int32_t *arg_ch, int32_t arg_10h)\n\n{\n    int32_t in_ECX;\n    int32_t iVar1;\n    uint8_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t var_10h;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    piVar3 = arg_ch;\n    iVar4 = 0;\n    var_10h = 0;\n    var_8h = 0;\n    var_4h = 0;\n    if (0 < arg_10h) {\n        arg_ch = arg_10h;\n        do {\n            if ((*(piVar3 + 2) & 8) == 0) {\n                uVar2 = *(piVar3 + 9) & 1;\n                if (uVar2 == 0) {\n                    iVar1 = *(in_ECX + 0x90) + var_10h;\n                    if (var_8h < iVar1) {\n                        var_8h = iVar1;\n                    }\n                    iVar1 = *(in_ECX + 0x94);\ncode_r0x00421a8b:\n                    if (var_4h < iVar1 + iVar4) {\n                        var_4h = iVar1 + iVar4;\n                    }\n                }\n                else {\n                    if ((*(piVar3 + 2) & 0x20) != 0) {\n                        iVar1 = *(in_ECX + 0x94) + (*piVar3 << 1) / 3;\n                        goto code_r0x00421a8b;\n                    }\n                    iVar1 = *piVar3 + var_10h;\n                    if (var_8h < iVar1) {\n                        var_8h = iVar1;\n                    }\n                }\n                if (uVar2 == 0) {\n                    iVar1 = *(in_ECX + 0x90);\n                }\n                else {\n                    iVar1 = *piVar3;\n                }\n                var_10h = var_10h + iVar1;\n                if ((*(piVar3 + 2) & 0x20) != 0) {\n                    iVar4 = iVar4 + *(in_ECX + 0x94);\n                    var_10h = 0;\n                    if (uVar2 != 0) {\n                        iVar4 = iVar4 + (*piVar3 << 1) / 3;\n                    }\n                }\n            }\n            piVar3 = piVar3 + 5;\n            arg_ch = arg_ch + -1;\n        } while (arg_ch != NULL);\n    }\n    *arg_8h = var_8h;\n    arg_8h[1] = var_4h;\n    return;\n}\n",
        "token_count": 622
    },
    "00421ae8": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00421ae8(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    bool bVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    int32_t *piVar5;\n    uint8_t *puVar6;\n    int32_t iVar7;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    var_4h = 0;\n    iVar7 = 0;\n    if (0 < arg_ch) {\n        do {\n            piVar1 = arg_8h + iVar7 * 0x14;\n            *(piVar1 + 2) = *(piVar1 + 2) & 0xdf;\n            piVar5 = piVar1 + 2;\n            iVar4 = var_4h;\n            if ((*piVar5 & 8) == 0) {\n                if ((*(piVar1 + 9) & 1) == 0) {\n                    iVar3 = *(in_ECX + 0x90);\n                }\n                else {\n                    iVar3 = *piVar1;\n                }\n                iVar4 = iVar3 + var_4h;\n                if (arg_10h < iVar3 + var_4h) {\n                    bVar2 = false;\n                    iVar4 = iVar7;\n                    while( true ) {\n                        if ((iVar4 < 0) || ((*piVar5 & 0x20) != 0)) goto code_r0x00421b86;\n                        if (((*(piVar5 + 1) & 1) != 0) && ((piVar5[-1] == 0 && ((*piVar5 & 8) == 0)))) break;\n                        iVar4 = iVar4 + -1;\n                        piVar5 = piVar5 + -5;\n                    }\n                    var_4h = 0;\n                    bVar2 = true;\n                    puVar6 = arg_8h + 8 + iVar4 * 0x14;\n                    *puVar6 = *puVar6 | 0x20;\n                    var_8h = var_8h + 1;\n                    iVar7 = iVar4;\ncode_r0x00421b86:\n                    iVar4 = var_4h;\n                    if (!bVar2) {\n                        iVar4 = iVar7 + -1;\n                        if (-1 < iVar4) {\n                            puVar6 = arg_8h + 8 + iVar4 * 0x14;\n                            do {\n                                if ((*puVar6 & 0x20) != 0) break;\n                                if (((*puVar6 & 8) == 0) && (((puVar6[1] & 1) == 0 || (*(puVar6 + -4) == 0)))) {\n                                    var_4h = 0;\n                                    bVar2 = true;\n                                    puVar6 = arg_8h + 8 + iVar4 * 0x14;\n                                    *puVar6 = *puVar6 | 0x20;\n                                    var_8h = var_8h + 1;\n                                    iVar7 = iVar4;\n                                    break;\n                                }\n                                iVar4 = iVar4 + -1;\n                                puVar6 = puVar6 + -0x14;\n                            } while (-1 < iVar4);\n                        }\n                        iVar4 = var_4h;\n                        if (!bVar2) {\n                            iVar4 = var_4h + iVar3;\n                        }\n                    }\n                }\n            }\n            var_4h = iVar4;\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < arg_ch);\n    }\n    return var_8h + 1;\n}\n",
        "token_count": 836
    },
    "00421d51": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpRect\n\nvoid __cdecl fcn.00421d51(int32_t *arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    code *pcVar2;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    uint32_t *puVar5;\n    uint32_t uVar6;\n    int32_t *piVar7;\n    int32_t *in_ECX;\n    int32_t iVar8;\n    int32_t iVar9;\n    uint32_t *puVar10;\n    uint32_t lpRect;\n    uint *var_3ch;\n    uint32_t var_38h;\n    uint32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t lprc;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint32_t *var_14h;\n    int32_t var_10h;\n    uint32_t *var_ch;\n    uint32_t *var_8h;\n    uint32_t *var_4h;\n    \n    puVar10 = 0x418;\n    var_30h = 0;\n    var_2ch = 0;\n    iVar4 = (**(*in_ECX + 0xa8))(0x418, 0, 0);\n    puVar5 = var_4h;\n    var_18h = iVar4;\n    if (iVar4 != 0) {\n        puVar5 = fcn.00416693(iVar4 * 0x14);\n        var_8h = NULL;\n        puVar3 = puVar5;\n        var_4h = puVar5;\n        if (iVar4 < 1) goto code_r0x00422033;\n        do {\n            var_ch = puVar3;\n            puVar10 = var_8h;\n            fcn.00421812();\n            var_8h = var_8h + 1;\n            var_ch = var_ch + 5;\n            puVar3 = var_ch;\n        } while (var_8h < iVar4);\n    }\n    if (iVar4 < 1) goto code_r0x00422033;\n    uVar1 = in_ECX[0x19];\n    if ((uVar1 & 2) == 0) {\n        uVar6 = uVar1 & 4;\n        if ((uVar6 == 0) || ((arg_ch & 4) == 0)) {\n            if (uVar6 != 0) {\n                if ((arg_ch & 8) != 0) {\n                    arg_10h = 0x7fff;\n                    goto code_r0x00421e64;\n                }\n                if (uVar6 != 0) {\n                    if ((arg_ch & 0x10) != 0) {\n                        arg_10h = 0;\n                        goto code_r0x00421e64;\n                    }\n                    if (uVar6 != 0) {\n                        if (arg_10h != -1) {\n                            (*_sym.imp.USER32.dll_SetRectEmpty)(&fcn.00421d51::lprc, puVar10);\n                            var_38h = arg_ch & 2;\n                            var_3ch = &fcn.00421d51::lprc;\n                            lpRect = 0x421e25;\n                            fcn.0042331a();\n                            lpRect = arg_ch & 0x20;\n                            if (lpRect == 0) {\n                                var_24h = var_20h - lprc;\n                            }\n                            else {\n                                var_24h = var_1ch - var_24h;\n                            }\n                            arg_10h = arg_10h + var_24h;\n                            goto code_r0x00421e64;\n                        }\n                        if ((uVar6 != 0) && ((uVar1 & 1) != 0)) goto code_r0x00421e4c;\n                    }\n                }\n            }\n            lpRect = 0;\n            arg_10h = -((arg_ch & 2) != 0) & 0x7fff;\n        }\n        else {\ncode_r0x00421e4c:\n            arg_10h = in_ECX[0x15];\n        }\ncode_r0x00421e64:\n        fcn.00421bf6(puVar5, iVar4, arg_10h, lpRect);\n    }\n    piVar7 = fcn.00421a0a(&fcn.00421d51::var_20h, puVar5, iVar4);\n    var_30h = *piVar7;\n    var_2ch = piVar7[1];\n    if ((arg_ch & 0x40) != 0) {\n        var_1ch = in_ECX[0x21];\n        puVar5 = NULL;\n        in_ECX[0x21] = 0;\n        var_10h = 0;\n        if (0 < iVar4) {\n            puVar10 = var_4h + 1;\n            iVar8 = iVar4;\n            do {\n                if (((*(puVar10 + 5) & 1) != 0) && (*puVar10 != 0)) {\n                    puVar5 = puVar5 + 1;\n                }\n                puVar10 = puVar10 + 5;\n                iVar8 = iVar8 + -1;\n            } while (iVar8 != 0);\n        }\n        if (0 < puVar5) {\n            var_10h = fcn.00416693(puVar5 * 0x18);\n            if (var_10h == 0) {\n                var_10h = 0;\n            }\n            var_8h = NULL;\n            arg_10h = 0;\n            puVar5 = var_8h;\n            if (0 < iVar4) {\n                var_ch = var_10h + 8;\n                var_14h = var_4h + 1;\n                puVar10 = var_ch;\n                do {\n                    puVar5 = puVar10;\n                    if (((*(var_14h + 5) & 1) != 0) && (*var_14h != 0)) {\n                        puVar10[-2] = arg_10h;\n                        puVar10[-1] = *var_14h;\n                        (**(*in_ECX + 0xe8))(arg_10h, &fcn.00421d51::lpRect);\n                        pcVar2 = _sym.imp.USER32.dll_ClientToScreen;\n                        (*_sym.imp.USER32.dll_ClientToScreen)(in_ECX[7], &fcn.00421d51::lpRect);\n                        (*pcVar2)(in_ECX[7], &fcn.00421d51::var_38h);\n                        var_8h = var_8h + 1;\n                        *puVar10 = lpRect;\n                        puVar10[1] = var_3ch;\n                        puVar5 = var_ch + 6;\n                        puVar10[2] = var_38h;\n                        puVar10[3] = var_34h;\n                        iVar4 = var_18h;\n                        var_ch = puVar5;\n                    }\n                    arg_10h = arg_10h + 1;\n                    var_14h = var_14h + 5;\n                    puVar10 = puVar5;\n                    puVar5 = var_8h;\n                } while (arg_10h < iVar4);\n            }\n        }\n        if (((in_ECX[0x19] & 1U) != 0) && ((in_ECX[0x19] & 4U) != 0)) {\n            in_ECX[0x15] = var_30h;\n        }\n        arg_10h = 0;\n        if (0 < iVar4) {\n            var_ch = var_4h;\n            do {\n                fcn.00421831(arg_10h, var_ch);\n                arg_10h = arg_10h + 1;\n                var_ch = var_ch + 5;\n            } while (arg_10h < iVar4);\n        }\n        if (0 < puVar5) {\n            piVar7 = var_10h + 8;\n            var_14h = puVar5;\n            do {\n                iVar4 = piVar7[-1];\n                var_18h = fcn.0041adf0();\n                if (var_18h != 0) {\n                    (*_sym.imp.USER32.dll_GetWindowRect)(*(var_18h + 0x1c), &fcn.00421d51::lpRect);\n                    iVar8 = lpRect - *piVar7;\n                    iVar9 = var_3ch - piVar7[1];\n                    (**(*in_ECX + 0xe8))(piVar7[-2], &fcn.00421d51::lpRect);\n                    iVar4 = 0;\n                    fcn.0041af6d(0, iVar8 + lpRect, iVar9 + var_3ch, 0, 0, 0x15);\n                }\n                piVar7 = piVar7 + 6;\n                var_14h = var_14h + -1;\n            } while (var_14h != NULL);\n            fcn.004166cf(var_10h, iVar4);\n        }\n        in_ECX[0x21] = var_1ch;\n        puVar5 = var_4h;\n    }\n    fcn.004166cf(puVar5);\ncode_r0x00422033:\n    (*_sym.imp.USER32.dll_SetRectEmpty)(&fcn.00421d51::lpRect);\n    fcn.0042331a(&fcn.00421d51::lpRect, arg_ch & 2);\n    var_2ch = var_3ch + (var_2ch - var_34h);\n    var_30h = var_30h + (lpRect - var_38h);\n    fcn.0042258f(&fcn.00421d51::var_20h, arg_ch & 1, arg_ch & 2);\n    if (var_30h <= var_20h) {\n        var_30h = var_20h;\n    }\n    if (var_2ch <= var_1ch) {\n        var_2ch = var_1ch;\n    }\n    *arg_8h = var_30h;\n    arg_8h[1] = var_2ch;\n    return;\n}\n",
        "token_count": 2339
    },
    "004220c8": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004220c8(uint arg_8h, int32_t arg_ch, uint32_t arg_10h)\n\n{\n    int32_t *in_ECX;\n    \n    if (((arg_ch == -1) && ((arg_10h & 0x44) == 0)) && (((arg_10h & 8) != 0 || ((arg_10h & 0x10) != 0)))) {\n        (**(*in_ECX + 0xc0))(arg_8h, arg_10h & 1, arg_10h & 8);\n    }\n    else {\n        fcn.00421d51(arg_8h, arg_10h, arg_ch);\n    }\n    return arg_8h;\n}\n",
        "token_count": 166
    },
    "004222f4": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004222f4(int32_t *param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *var_8h;\n    int32_t *piStack8;\n    \n    var_8h = param_1;\n    piStack8 = param_1;\n    if (param_1[0x21] != 0) {\n        uVar1 = param_1[0x19];\n        param_1[0x21] = 0;\n        if (((uVar1 & 1) == 0) || ((uVar1 & 4) == 0)) {\n            iVar2 = *param_1;\n            if ((uVar1 & 0xa000) == 0) {\n                uVar3 = 0x50;\n            }\n            else {\n                uVar3 = 0x4a;\n            }\n        }\n        else {\n            iVar2 = *param_1;\n            uVar3 = 0x46;\n        }\n        (**(iVar2 + 0xc4))(&var_8h, 0, uVar3);\n    }\n    fcn.004180f1();\n    return;\n}\n",
        "token_count": 269
    },
    "00422ac5": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00422ac5(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    fcn.004180f1();\n    if ((*(arg_8h + 0x18) & 1) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x1c), &lpRect);\n        var_ch = var_ch - lpRect;\n        var_4h = *(arg_8h + 0x10);\n        var_8h = var_8h - var_10h;\n        iVar1 = *(arg_8h + 0x14);\n        if ((var_4h != var_ch) && ((*(in_ECX + 0x65) & 4) != 0)) {\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, var_4h - *0x4400a0, 0, var_4h, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), &lpRect, 1);\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, var_ch - *0x4400a0, 0, var_ch, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), &lpRect, 1);\n        }\n        pcVar2 = _sym.imp.USER32.dll_SetRect;\n        if ((iVar1 != var_8h) && ((*(in_ECX + 0x65) & 8) != 0)) {\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, 0, iVar1 - *0x4400a4, var_4h, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), &lpRect, 1);\n            (*pcVar2)(&lpRect, 0, var_8h - *0x4400a4, var_4h, var_8h);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), &lpRect, 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 556
    },
    "00422fa9": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00422fa9(uint noname_0, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t *in_ECX;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    bool bVar5;\n    int32_t lprcDst;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    var_8h = *in_ECX;\n    var_4h = in_ECX;\n    uVar1 = (**(var_8h + 0xd4))(arg_ch);\n    if (((uVar1 & 0x10000000) != 0) && ((uVar1 & 0xf000) != 0)) {\n        (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, arg_ch + 1);\n        iVar4 = var_18h - lprcDst;\n        iVar3 = var_14h - var_1ch;\n        bVar5 = arg_ch[7] != 0;\n        if (((var_4h[0x19] & 4U) == 0) || ((var_4h[0x19] & 1U) == 0)) {\n            if ((uVar1 & 0xa000) == 0) {\n                uVar2 = bVar5 | 0x10;\n            }\n            else {\n                uVar2 = bVar5 | 10;\n            }\n        }\n        else {\n            uVar2 = bVar5 | 6;\n        }\n        (**(var_8h + 0xc4))(&var_10h, 0xffffffff, uVar2);\n        if (iVar4 <= var_10h) {\n            var_10h = iVar4;\n        }\n        if (iVar3 <= var_ch) {\n            var_ch = iVar3;\n        }\n        if ((uVar1 & 0xa000) == 0) {\n            if ((uVar1 & 0x5000) != 0) {\n                arg_ch[5] = arg_ch[5] + var_10h;\n                iVar3 = arg_ch[6];\n                if (arg_ch[6] <= var_ch) {\n                    iVar3 = var_ch;\n                }\n                arg_ch[6] = iVar3;\n                if ((uVar1 & 0x1000) == 0) {\n                    if ((uVar1 & 0x4000) != 0) {\n                        lprcDst = var_18h - var_10h;\n                        arg_ch[3] = arg_ch[3] - var_10h;\n                    }\n                }\n                else {\n                    arg_ch[1] = arg_ch[1] + var_10h;\n                }\n            }\n        }\n        else {\n            arg_ch[6] = arg_ch[6] + var_ch;\n            iVar3 = arg_ch[5];\n            if (arg_ch[5] <= var_10h) {\n                iVar3 = var_10h;\n            }\n            arg_ch[5] = iVar3;\n            if ((uVar1 & 0x2000) == 0) {\n                if ((uVar1 & 0x8000) != 0) {\n                    var_1ch = var_14h - var_ch;\n                    arg_ch[4] = arg_ch[4] - var_ch;\n                }\n            }\n            else {\n                arg_ch[2] = arg_ch[2] + var_ch;\n            }\n        }\n        var_18h = var_10h + lprcDst;\n        var_14h = var_ch + var_1ch;\n        if (*arg_ch != 0) {\n            fcn.00419e52(arg_ch, var_4h[7], &lprcDst);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 888
    },
    "0042331a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042331a(int32_t param_1, int32_t *param_2, int32_t param_3)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    uVar1 = *(param_1 + 100);\n    if ((uVar1 & 0x100) != 0) {\n        *param_2 = *param_2 + *0x4400a0;\n    }\n    if ((uVar1 & 0x200) != 0) {\n        param_2[1] = param_2[1] + *0x4400a4;\n    }\n    if ((uVar1 & 0x400) != 0) {\n        param_2[2] = param_2[2] - *0x4400a0;\n    }\n    if ((uVar1 & 0x800) != 0) {\n        param_2[3] = param_2[3] - *0x4400a4;\n    }\n    if (param_3 == 0) {\n        *param_2 = *param_2 + *(param_1 + 0x48);\n        param_2[1] = param_2[1] + *(param_1 + 0x40);\n        param_2[2] = param_2[2] - *(param_1 + 0x4c);\n        iVar2 = *(param_1 + 0x44);\n    }\n    else {\n        *param_2 = *param_2 + *(param_1 + 0x40);\n        param_2[1] = param_2[1] + *(param_1 + 0x48);\n        param_2[2] = param_2[2] - *(param_1 + 0x44);\n        iVar2 = *(param_1 + 0x4c);\n    }\n    param_2[3] = param_2[3] - iVar2;\n    return;\n}\n",
        "token_count": 440
    },
    "00423415": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch_2\n// WARNING: Variable defined which should be unmapped: var_14h_2\n\nuint __cdecl\nfcn.00423415(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_10h_2;\n    uint var_14h_2;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.004056b0();\n    uVar2 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    iVar3 = *(extraout_ECX + 0x5c);\n    *(unaff_EBP + -0x10) = &var_14h_2;\n    iVar1 = iVar3 + uVar2 * 0x14;\n    if ((*(iVar3 + 0xc + uVar2 * 0x14) & 1) == 0) {\n        if (*(unaff_EBP + 0xc) == 0) {\n            if (*(*(iVar1 + 0x10) + -8) == 0) goto code_r0x004234cc;\n            if (*(unaff_EBP + 0xc) == 0) goto code_r0x00423467;\n        }\n        iVar3 = fcn.00406090(*(iVar1 + 0x10), *(unaff_EBP + 0xc));\n        if (iVar3 == 0) goto code_r0x004234cc;\n    }\ncode_r0x00423467:\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + 0xc) == 0) {\n        fcn.0041b197();\n    }\n    else {\n        fcn.0041b354(*(unaff_EBP + 0xc));\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + 0x10) == 0) {\n        *(iVar1 + 0xc) = *(iVar1 + 0xc) | 1;\n    }\n    else {\n        *(iVar1 + 0xc) = *(iVar1 + 0xc) & 0xfffffffe;\n        if ((*(iVar1 + 0xb) & 4) == 0) {\n            uVar4 = *(iVar1 + 0x10);\n        }\n        else {\n            uVar4 = 0;\n        }\n        (**(**(unaff_EBP + -0x14) + 0xa8))(0x401, uVar2 | *(iVar1 + 8), uVar4);\n    }\ncode_r0x004234cc:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return 1;\n}\n",
        "token_count": 714
    },
    "004238d0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004238d0(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    uint *in_ECX;\n    uint var_8h;\n    uint *var_4h;\n    \n    if ((~*(arg_8h + 0x14) & 1) == 0) {\n        var_4h = in_ECX;\n        fcn.00404641(&var_4h);\n        *in_ECX = var_4h;\n        fcn.00404641(&var_4h);\n        in_ECX[1] = var_4h;\n        fcn.00404641(&var_4h);\n        in_ECX[2] = var_4h;\n        fcn.00404641(&var_4h);\n        in_ECX[3] = var_4h;\n        fcn.0041ff62(in_ECX + 5, 8);\n        uVar1 = fcn.00424375();\n        if (1 < uVar1) {\n            fcn.00424379(in_ECX + 5);\n            fcn.00404641(&var_4h);\n            in_ECX[7] = var_4h;\n            fcn.00404641(&var_4h);\n            in_ECX[8] = var_4h;\n            if (var_4h != NULL) {\n                fcn.00404641(&var_4h);\n                in_ECX[9] = var_4h;\n                fcn.0041ff62(in_ECX + 10, 0x10);\n                fcn.004243cc(in_ECX + 10);\n                fcn.00404641(in_ECX + 0xe);\n                fcn.0041ff62(in_ECX + 0xf, 8);\n                fcn.00424379(in_ECX + 0xf);\n            }\n        }\n        fcn.0040460e(&arg_8h);\n        fcn.00415f0a(arg_8h & 0xffff, 0xffffffff);\n        if (arg_8h != 0) {\n            fcn.0041ff62(in_ECX[0x12], in_ECX[0x13] << 2);\n        }\n    }\n    else {\n        fcn.004045e8(*in_ECX);\n        fcn.004045e8(in_ECX[1]);\n        fcn.004045e8(in_ECX[2]);\n        fcn.004045e8(in_ECX[3]);\n        var_8h = in_ECX[5];\n        var_4h = in_ECX[6];\n        fcn.00420070(&var_8h, 8);\n        uVar1 = fcn.00424375();\n        if (1 < uVar1) {\n            fcn.004045e8(in_ECX[7]);\n            fcn.004045e8(in_ECX[8]);\n            if (in_ECX[8] != 0) {\n                fcn.004045e8(in_ECX[9]);\n                fcn.00420070(in_ECX + 10, 0x10);\n                fcn.004045e8(in_ECX[0xe]);\n                var_8h = in_ECX[0xf];\n                var_4h = in_ECX[0x10];\n                fcn.00420070(&var_8h, 8);\n            }\n        }\n        fcn.004045c1(in_ECX[0x13]);\n        if (in_ECX[0x13] != 0) {\n            fcn.00420070(in_ECX[0x12], in_ECX[0x13] << 2);\n        }\n    }\n    return;\n}\n",
        "token_count": 825
    },
    "0042a20e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid fcn.0042a20e(void)\n\n{\n    uint8_t uVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint lpvBits;\n    \n    fcn.0042d3e7(8);\n    if (*0x440490 == 0) {\n        iVar3 = 0;\n        puVar2 = &lpvBits;\n        do {\n            uVar1 = iVar3;\n            iVar3 = iVar3 + 1;\n            *puVar2 = 0x5555 << (uVar1 & 1);\n            puVar2 = puVar2 + 2;\n        } while (iVar3 < 8);\n        iVar3 = (*_sym.imp.GDI32.dll_CreateBitmap)(8, 8, 1, 1, &lpvBits);\n        if (iVar3 != 0) {\n            *0x440490 = (*_sym.imp.GDI32.dll_CreatePatternBrush)(iVar3);\n            (*_sym.imp.GDI32.dll_DeleteObject)(iVar3);\n        }\n    }\n    fcn.0042d457(8);\n    fcn.0041fd52(*0x440490);\n    return;\n}\n",
        "token_count": 258
    },
    "0042b55c": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042b55c(uint32_t arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    \n    uVar3 = fcn.0041ae7b();\n    pcVar1 = _sym.imp.USER32.dll_GetKeyState;\n    if (((uVar3 & 0x80000000) != 0) &&\n       ((((arg_8h & 0xfff0) != 0xf060 ||\n         (((iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(0x73),  iVar2 < 0 && (iVar2 = (*pcVar1)(0x12),  iVar2 < 0)) &&\n          ((uVar3 & 0x100) != 0)))) && (iVar4 = fcn.00419f17(arg_8h, arg_ch),  iVar4 != 0)))) {\n        return;\n    }\n    fcn.00428bb4(arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 237
    },
    "0042c7e8": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042c7e8(int32_t arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *in_ECX;\n    int32_t var_ch;\n    \n    fcn.0042331a(arg_8h, arg_ch);\n    uVar2 = fcn.0041ae7b();\n    if ((uVar2 & 0x100) != 0) {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(in_ECX[7]);\n        iVar4 = (*_sym.imp.USER32.dll_IsZoomed)(uVar3);\n        if (iVar4 == 0) {\n            (**(*in_ECX + 0xa8))(0x407, 0, &var_ch);\n            pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n            iVar4 = (*_sym.imp.USER32.dll_GetSystemMetrics)(5);\n            iVar5 = (*pcVar1)(2);\n            *(arg_8h + 8) = *(arg_8h + 8) + ((iVar4 * -2 - var_ch) - iVar5);\n        }\n    }\n    return;\n}\n",
        "token_count": 284
    },
    "0042c857": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: lpRect\n\nvoid __cdecl fcn.0042c857(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *in_ECX;\n    int32_t iVar3;\n    uint unaff_EBX;\n    int32_t iVar4;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    int32_t iVar5;\n    uint *puVar6;\n    int32_t aiStack100 [2];\n    uint *puStack92;\n    uint var_38h;\n    int32_t lpRect;\n    uint dy;\n    int32_t var_24h;\n    int32_t var_1ch;\n    int32_t var_14h;\n    code *var_10h;\n    uchar *var_ch;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    var_38h = unaff_EDI;\n    if (arg_8h != 0) {\n        (*_sym.imp.USER32.dll_GetWindowRect)();\n        (*_sym.imp.USER32.dll_OffsetRect)();\n        puStack92 = 0x42c89d;\n        fcn.0042c7e8(&fcn.0042c857::lpRect, 1);\n        puStack92 = &fcn.0042c857::var_1ch;\n        aiStack100[1] = 0;\n        var_10h = *(*in_ECX + 0xa8);\n        aiStack100[0] = 0x407;\n        var_ch = &stack0xffffff9c;\n        (*var_10h)();\n        arg_8h = 0;\n        iVar4 = in_ECX[0x16];\n        iVar5 = (var_24h - lpRect) + var_14h;\n        if (0 < iVar4) {\n            piVar2 = in_ECX[0x17] + 4;\n            iVar3 = iVar4;\n            do {\n                if ((*(piVar2 + 7) & 8) != 0) {\n                    arg_8h = arg_8h + 1;\n                }\n                iVar1 = *piVar2;\n                piVar2 = piVar2 + 5;\n                iVar5 = iVar5 + ((-6 - var_14h) - iVar1);\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n        fcn.00405820();\n        var_8h = 0;\n        if (0 < iVar4) {\n            iVar4 = in_ECX[0x17] + 8;\n            var_ch = &stack0xffffff9c;\n            var_4h = &stack0xffffff9c;\n            do {\n                var_1ch = var_1ch + 6 + *(iVar4 + -4);\n                if (((*(iVar4 + 3) & 8) != 0) && (0 < iVar5)) {\n                    iVar3 = iVar5 / arg_8h;\n                    var_1ch = var_1ch + iVar3;\n                    arg_8h = arg_8h + -1;\n                    iVar5 = iVar5 - iVar3;\n                }\n                iVar4 = iVar4 + 0x14;\n                piVar2 = var_4h + 1;\n                *var_4h = var_1ch;\n                var_4h = piVar2;\n                var_1ch = var_1ch + var_14h;\n                var_8h = var_8h + 1;\n            } while (var_8h < in_ECX[0x16]);\n        }\n        (*var_10h)(0x404, in_ECX[0x16], var_ch);\n    }\n    iVar4 = 0;\n    if ((arg_ch != 0) && (0 < in_ECX[0x16])) {\n        puVar6 = in_ECX[0x17] + 0x10;\n        do {\n            if ((*(puVar6 + -1) & 1) != 0) {\n                fcn.00423415(iVar4, *puVar6, 1, var_38h, unaff_ESI, unaff_EBX, lpRect);\n            }\n            puVar6 = puVar6 + 5;\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < in_ECX[0x16]);\n    }\n    return;\n}\n",
        "token_count": 1001
    },
    "0042d54a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0042d54a(int32_t param_1)\n\n{\n    uint32_t *puVar1;\n    code *pcVar2;\n    uint8_t *puVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint unaff_EDI;\n    int32_t iVar7;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(param_1 + 0x1c);\n    iVar6 = *(param_1 + 4);\n    iVar7 = *(param_1 + 8);\n    if ((iVar6 <= iVar7) || ((*(*(param_1 + 0x10) + iVar7 * 8) & 1) != 0)) {\n        iVar7 = 1;\n        if (1 < iVar6) {\n            puVar3 = *(param_1 + 0x10);\n            do {\n                puVar3 = puVar3 + 8;\n                if ((*puVar3 & 1) == 0) break;\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < iVar6);\n            if (iVar7 < iVar6) goto code_r0x0042d62e;\n        }\n        iVar6 = iVar6 + 0x20;\n        if (*(param_1 + 0x10) == 0) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x2002, iVar6 * 8);\n        }\n        else {\n            uVar5 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(*(param_1 + 0x10));\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(uVar5);\n            iVar4 = (*_sym.imp.KERNEL32.dll_GlobalReAlloc)(uVar5, iVar6 * 8, 0x2002);\n        }\n        pcVar2 = _sym.imp.KERNEL32.dll_GlobalLock;\n        if (iVar4 == 0) {\n            uVar5 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(*(param_1 + 0x10));\n            (*pcVar2)(uVar5);\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(unaff_EDI);\n            fcn.00415699();\n        }\n        iVar4 = (*pcVar2)(iVar4);\n        fcn.00406030(iVar4 + *(param_1 + 4) * 8, 0, (*(param_1 + 4) * 0x1fffffff + iVar6) * 8);\n        *(param_1 + 4) = iVar6;\n        *(param_1 + 0x10) = iVar4;\n    }\ncode_r0x0042d62e:\n    if (*(param_1 + 0xc) <= iVar7) {\n        *(param_1 + 0xc) = iVar7 + 1;\n    }\n    puVar1 = *(param_1 + 0x10) + iVar7 * 8;\n    *puVar1 = *puVar1 | 1;\n    *(param_1 + 8) = iVar7 + 1;\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(param_1);\n    return iVar7;\n}\n",
        "token_count": 704
    },
    "0040115d": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/3c11c79f25554a4cae0a51d287295f58"
        ],
        "decompiled_code": "\nuint32_t fcn.0040115d(char *param_1)\n\n{\n    char *pcVar1;\n    char cVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    \n    uVar3 = 0;\n    cVar2 = *param_1;\n    while (cVar2 != '\\0') {\n        iVar4 = cVar2;\n        if ('`' < cVar2) {\n            iVar4 = iVar4 + -0x20;\n        }\n        uVar3 = (uVar3 << 0x13 | uVar3 >> 0xd) + iVar4;\n        pcVar1 = param_1 + 1;\n        param_1 = param_1 + 1;\n        cVar2 = *pcVar1;\n    }\n    return uVar3;\n}\n",
        "token_count": 179
    },
    "00402bbc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00402bbc(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_8h;\n    int32_t *var_4h;\n    \n    iVar3 = arg_8h;\n    arg_8h = 0;\n    iVar1 = *(*(iVar3 + 0x3c) + 0x78 + iVar3);\n    iVar5 = iVar1 + iVar3;\n    var_4h = *(iVar1 + 0x20 + iVar3) + iVar3;\n    iVar1 = *(iVar5 + 0x1c);\n    iVar2 = *(iVar5 + 0x24);\n    if (*(iVar5 + 0x18) != 0) {\n        do {\n            iVar4 = fcn.0040115d(iVar3 + *var_4h);\n            if (iVar4 == arg_ch) {\n                return *(iVar1 + iVar3 + *(iVar2 + iVar3 + arg_8h * 2) * 4) + iVar3;\n            }\n            arg_8h = arg_8h + 1;\n            var_4h = var_4h + 1;\n        } while (arg_8h < *(iVar5 + 0x18));\n    }\n    return 0;\n}\n",
        "token_count": 319
    },
    "00403319": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00403319(int32_t param_1)\n\n{\n    *(param_1 + 0xdc) = 1;\n    fcn.0042210a(5, 0xe124, 0, 4);\n    if (*(param_1 + 0xbc) != 0) {\n        fcn.0041afbc(0);\n    }\n    return 1;\n}\n",
        "token_count": 89
    },
    "00403373": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00403373(int32_t *arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    uint32_t uVar2;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if ((arg_10h & 0x40) == 0) {\n        uVar1 = *(in_ECX + 0xdc);\n        uVar2 = uVar1;\n        if ((arg_10h & 2) == 0) {\n            uVar2 = uVar1 == 0;\n        }\n        var_8h = in_ECX;\n        var_4h = in_ECX;\n        if (uVar2 != 0) {\n            if (uVar1 == 0) {\n                fcn.00403319();\n            }\n            else {\n                fcn.004032a3();\n            }\n        }\n        fcn.004220c8(&var_8h, arg_ch, arg_10h);\n        if (uVar2 != 0) {\n            if (uVar1 == 0) {\n                fcn.00403319();\n            }\n            else {\n                fcn.004032a3();\n            }\n        }\n        *arg_8h = var_8h;\n        arg_8h[1] = var_4h;\n    }\n    else {\n        if ((arg_10h & 0x10) == 0) {\n            if (*(in_ECX + 0xdc) != 0) {\n                fcn.004032a3();\n            }\n        }\n        else if (*(in_ECX + 0xdc) == 0) {\n            fcn.00403319();\n        }\n        fcn.004220c8(arg_8h, arg_ch, arg_10h);\n    }\n    return arg_8h;\n}\n",
        "token_count": 423
    },
    "00416df2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00416df2(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDialog.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[7] != NULL) {\n        fcn.00418a40();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041887d();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 196
    },
    "004051a2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.004051a2(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    iVar1 = fcn.0042d0a2();\n    if ((*(iVar1 + 0x24) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.0041667f(0x4204bc);\n        iVar3 = fcn.00416693(0x44);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0041d8eb(0x434648, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x24) = uVar4;\n        fcn.0041667f(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x24);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 350
    },
    "00405212": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00405212(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.00405178();\n    uVar1 = (*_sym.imp.COMCTL32.dll_ImageList_Destroy)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 87
    },
    "0041da22": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041da22(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    var_8h = -(*(param_1 + 0x28) != 0);\n    while (var_8h != 0) {\n        fcn.00416397(&var_8h, &var_ch, &var_4h);\n        puVar1 = var_4h + *(param_1 + 0x3c);\n        *puVar1 = 0;\n        if (*(param_1 + 0x40) == 2) {\n            puVar1[1] = 0;\n        }\n        if (var_4h != NULL) {\n            (**(*var_4h + 4))(1);\n        }\n    }\n    fcn.004161df();\n    return;\n}\n",
        "token_count": 207
    },
    "00405602": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00405602(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *in_FS_OFFSET;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    int32_t iStack16;\n    \n    iStack16 = param_1;\n    uStack24 = 0x4055e0;\n    uStack28 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack28;\n    while( true ) {\n        iVar1 = *(param_1 + 8);\n        iVar2 = *(param_1 + 0xc);\n        if ((iVar2 == -1) || (iVar2 == param_2)) break;\n        uStack20 = *(iVar1 + iVar2 * 0xc);\n        *(param_1 + 0xc) = uStack20;\n        if (*(iVar1 + 4 + iVar2 * 0xc) == 0) {\n            fcn.00405696(0x101);\n            (**(iVar1 + 8 + iVar2 * 0xc))();\n        }\n    }\n    *in_FS_OFFSET = uStack28;\n    return;\n}\n",
        "token_count": 264
    },
    "00405dc0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00405dc0(uint param_1)\n\n{\n    if (*0x4404d0 == 1) {\n        fcn.0040a220();\n    }\n    fcn.0040a260(param_1);\n    (**0x43aca0)(0xff);\n    return;\n}\n",
        "token_count": 67
    },
    "00406250": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00406250(uint param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    code **ppcVar2;\n    code **ppcVar3;\n    \n    fcn.00406310();\n    if (*0x440514 == 1) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(param_1);\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1);\n    }\n    *0x440510 = 1;\n    *0x44050c = param_3;\n    if (param_2 == 0) {\n        if ((*0x441f48 != NULL) && (ppcVar3 = *0x441f44 + -4,  ppcVar2 = *0x441f48,  *0x441f48 <= ppcVar3)) {\n            do {\n                if (*ppcVar3 != NULL) {\n                    (**ppcVar3)();\n                    ppcVar2 = *0x441f48;\n                }\n                ppcVar3 = ppcVar3 + -1;\n            } while (ppcVar2 <= ppcVar3);\n        }\n        fcn.00406330(0x43a0ec, 0x43a0f4);\n    }\n    fcn.00406330(0x43a0f8, 0x43a100);\n    if (param_3 != 0) {\n        fcn.00406320();\n        return;\n    }\n    *0x440514 = 1;\n    (*_sym.imp.KERNEL32.dll_ExitProcess)(param_1);\n    return;\n}\n",
        "token_count": 370
    },
    "00406530": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.00406530(int16_t *param_1)\n\n{\n    int16_t iVar1;\n    int16_t *piVar2;\n    \n    iVar1 = *param_1;\n    piVar2 = param_1 + 1;\n    while (iVar1 != 0) {\n        iVar1 = *piVar2;\n        piVar2 = piVar2 + 1;\n    }\n    return (piVar2 - param_1 >> 1) + -1;\n}\n",
        "token_count": 109
    },
    "00406550": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.00406550(uint8_t *param_1, uint8_t *param_2)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    uint8_t *puVar4;\n    \n    if (*0x44061c == 0) {\n        uVar3 = fcn.0040adb0(param_1, param_2);\n        return uVar3;\n    }\n    fcn.00408940(0x19);\n    if (*param_1 == 0) {\ncode_r0x004065e9:\n        fcn.004089c0(0x19);\n        return -(*param_1 != 0) & param_1;\n    }\n    puVar4 = param_2;\n    uVar2 = *param_2;\njoined_r0x0040658f:\n    do {\n        if (uVar2 != 0) {\n            uVar2 = *puVar4;\n            if ((*(uVar2 + 0x440519) & 4) == 0) {\n                if (uVar2 != *param_1) goto code_r0x004065bd;\n            }\n            else if (((uVar2 != *param_1) || (puVar4[1] != param_1[1])) && (puVar4[1] != 0)) {\n                puVar4 = puVar4 + 1;\ncode_r0x004065bd:\n                puVar1 = puVar4 + 1;\n                puVar4 = puVar4 + 1;\n                uVar2 = *puVar1;\n                goto joined_r0x0040658f;\n            }\n        }\n        if (((*puVar4 != 0) ||\n            (((*(*param_1 + 0x440519) & 4) != 0 && (puVar4 = param_1 + 1,  param_1 = param_1 + 1,  *puVar4 == 0)))) ||\n           (puVar1 = param_1 + 1,  param_1 = param_1 + 1,  puVar4 = param_2,  uVar2 = *param_2,  *puVar1 == 0))\n        goto code_r0x004065e9;\n    } while( true );\n}\n",
        "token_count": 513
    },
    "00406720": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.00406720(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uStack4;\n    \n    if (param_1 < 0x100) {\n        if (1 < *0x43d6bc) {\n            uVar2 = fcn.0040b2d0(param_1, 4);\n            return uVar2;\n        }\n        return *(*0x43d4b0 + param_1 * 2) & 4;\n    }\n    uStack4 = 0;\n    param_1 = CONCAT31(CONCAT21(param_1._2_2_, param_1), param_1 >> 8);\n    if (*0x44061c == 0) {\n        return 0;\n    }\n    iVar1 = fcn.0040b500(1, &param_1, 2, &uStack4, *0x44061c, *0x440620);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if ((uStack4._2_2_ == 0) && ((uStack4 & 4) != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 276
    },
    "004067c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.004067c0(uint8_t *param_1)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint8_t *puVar6;\n    \n    while( true ) {\n        if (*0x43d6bc < 2) {\n            uVar2 = *(*0x43d4b0 + *param_1 * 2) & 8;\n        }\n        else {\n            uVar2 = fcn.0040b2d0(*param_1, 8);\n        }\n        if (uVar2 == 0) break;\n        param_1 = param_1 + 1;\n    }\n    uVar2 = *param_1;\n    puVar6 = param_1 + 1;\n    if ((uVar2 == 0x2d) || (uVar4 = uVar2,  uVar2 == 0x2b)) {\n        uVar4 = *puVar6;\n        puVar6 = param_1 + 2;\n    }\n    iVar5 = 0;\n    while( true ) {\n        if (*0x43d6bc < 2) {\n            uVar3 = *(*0x43d4b0 + uVar4 * 2) & 4;\n        }\n        else {\n            uVar3 = fcn.0040b2d0(uVar4, 4);\n        }\n        if (uVar3 == 0) break;\n        uVar1 = *puVar6;\n        puVar6 = puVar6 + 1;\n        iVar5 = (uVar4 - 0x30) + iVar5 * 10;\n        uVar4 = uVar1;\n    }\n    if (uVar2 == 0x2d) {\n        iVar5 = -iVar5;\n    }\n    return iVar5;\n}\n",
        "token_count": 427
    },
    "00406e80": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00406e80(uint param_1)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint8_t *puVar9;\n    uint8_t *puVar10;\n    uint *puVar11;\n    uint32_t uStack20;\n    uint8_t auStack14 [14];\n    \n    fcn.00408940(0x19);\n    iVar3 = fcn.004070a0(param_1);\n    if (iVar3 == *0x44061c) {\n        fcn.004089c0(0x19);\n        return 0;\n    }\n    if (iVar3 != 0) {\n        iVar8 = 0;\n        piVar4 = 0x43acd8;\n        do {\n            if (*piVar4 == iVar3) {\n                puVar11 = 0x440518;\n                for (iVar7 = 0x40; iVar7 != 0; iVar7 = iVar7 + -1) {\n                    *puVar11 = 0;\n                    puVar11 = puVar11 + 1;\n                }\n                *puVar11 = 0;\n                uVar5 = 0;\n                iVar8 = iVar8 * 0x30;\n                puVar9 = iVar8 + 0x43ace8;\n                do {\n                    uVar1 = *puVar9;\n                    for (puVar10 = puVar9; (uVar1 != 0 && (uVar1 = puVar10[1],  uVar1 != 0)); puVar10 = puVar10 + 2) {\n                        uVar6 = *puVar10;\n                        if (uVar6 <= uVar1) {\n                            uVar2 = *(uVar5 + 0x43acd0);\n                            do {\n                                *(uVar6 + 0x440519) = *(uVar6 + 0x440519) | uVar2;\n                                uVar6 = uVar6 + 1;\n                            } while (uVar6 <= uVar1);\n                        }\n                        uVar1 = puVar10[2];\n                    }\n                    uVar5 = uVar5 + 1;\n                    puVar9 = puVar9 + 8;\n                } while (uVar5 < 4);\n                *0x44061c = iVar3;\n                *0x440620 = fcn.004070f0(iVar3);\n                *0x440628 = *(iVar8 + 0x43acdc);\n                *0x44062c = *(iVar8 + 0x43ace0);\n                *0x440630 = *(iVar8 + 0x43ace4);\n                fcn.004089c0(0x19);\n                return 0;\n            }\n            piVar4 = piVar4 + 0xc;\n            iVar8 = iVar8 + 1;\n        } while (piVar4 < 0x43adc8);\n        iVar8 = (*_sym.imp.KERNEL32.dll_GetCPInfo)(iVar3, &uStack20);\n        if (iVar8 == 1) {\n            puVar11 = 0x440518;\n            for (iVar8 = 0x40; iVar8 != 0; iVar8 = iVar8 + -1) {\n                *puVar11 = 0;\n                puVar11 = puVar11 + 1;\n            }\n            *puVar11 = 0;\n            if (uStack20 < 2) {\n                *0x44061c = 0;\n                *0x440620 = 0;\n            }\n            else {\n                if (auStack14[0] != 0) {\n                    puVar9 = auStack14 + 1;\n                    do {\n                        uVar1 = *puVar9;\n                        if (uVar1 == 0) break;\n                        for (uVar5 = puVar9[-1]; uVar5 <= uVar1; uVar5 = uVar5 + 1) {\n                            *(uVar5 + 0x440519) = *(uVar5 + 0x440519) | 4;\n                        }\n                        puVar10 = puVar9 + 1;\n                        puVar9 = puVar9 + 2;\n                    } while (*puVar10 != 0);\n                }\n                uVar5 = 1;\n                do {\n                    *(uVar5 + 0x440519) = *(uVar5 + 0x440519) | 8;\n                    uVar5 = uVar5 + 1;\n                } while (uVar5 < 0xff);\n                *0x44061c = iVar3;\n                *0x440620 = fcn.004070f0(iVar3);\n            }\n            *0x440628 = 0;\n            *0x44062c = 0;\n            *0x440630 = 0;\n            fcn.004089c0(0x19);\n            return 0;\n        }\n        if (*0x440634 == 0) {\n            fcn.004089c0(0x19);\n            return 0xffffffff;\n        }\n    }\n    fcn.00407150();\n    fcn.004089c0(0x19);\n    return 0;\n}\n",
        "token_count": 1179
    },
    "00407520": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.00407520(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    bool bVar7;\n    \n    piVar6 = param_1;\n    uVar3 = param_1[5];\n    if (uVar3 < 0x45) {\n        return -1;\n    }\n    if (0x8b < uVar3) {\n        return -1;\n    }\n    iVar4 = param_1[4];\n    if ((iVar4 < 0) || (0xb < iVar4)) {\n        uVar3 = uVar3 + iVar4 / 0xc;\n        iVar4 = iVar4 % 0xc;\n        param_1[4] = iVar4;\n        if (iVar4 < 0) {\n            uVar3 = uVar3 - 1;\n            param_1[4] = iVar4 + 0xc;\n        }\n        if (uVar3 < 0x45) {\n            return -1;\n        }\n        if (0x8b < uVar3) {\n            return -1;\n        }\n    }\n    iVar4 = *(param_1[4] * 4 + 0x43d7c0);\n    if (((uVar3 & 3) == 0) && (1 < param_1[4])) {\n        iVar4 = iVar4 + 1;\n    }\n    iVar1 = param_1[3];\n    iVar5 = uVar3 * 0x16d + -0x63df + iVar4 + (uVar3 - 1 >> 2);\n    iVar4 = iVar5 + iVar1;\n    if (iVar5 < 0) {\ncode_r0x004075d0:\n        if ((iVar1 < 0) && (-1 < iVar4)) {\n            return -1;\n        }\n    }\n    else {\n        if ((-1 < iVar1) && (iVar4 < 0)) {\n            return -1;\n        }\n        if (iVar5 < 0) goto code_r0x004075d0;\n    }\n    iVar5 = iVar4 * 0x18;\n    if (iVar4 == 0) {\n        bVar7 = false;\n    }\n    else {\n        bVar7 = iVar5 / iVar4 != 0x18;\n    }\n    if (bVar7) {\n        return -1;\n    }\n    iVar1 = param_1[2];\n    iVar4 = iVar1 + iVar5;\n    if (iVar5 < 0) {\ncode_r0x0040761b:\n        if ((iVar1 < 0) && (-1 < iVar4)) {\n            return -1;\n        }\n    }\n    else {\n        if ((-1 < iVar1) && (iVar4 < 0)) {\n            return -1;\n        }\n        if (iVar5 < 0) goto code_r0x0040761b;\n    }\n    iVar5 = iVar4 * 0x3c;\n    if (iVar4 == 0) {\n        bVar7 = false;\n    }\n    else {\n        bVar7 = iVar5 / iVar4 != 0x3c;\n    }\n    if (bVar7) {\n        return -1;\n    }\n    iVar1 = param_1[1];\n    iVar4 = iVar1 + iVar5;\n    if (iVar5 < 0) {\ncode_r0x0040766a:\n        if ((iVar1 < 0) && (-1 < iVar4)) {\n            return -1;\n        }\n    }\n    else {\n        if ((-1 < iVar1) && (iVar4 < 0)) {\n            return -1;\n        }\n        if (iVar5 < 0) goto code_r0x0040766a;\n    }\n    iVar5 = iVar4 * 0x3c;\n    if (iVar4 == 0) {\n        bVar7 = false;\n    }\n    else {\n        bVar7 = iVar5 / iVar4 != 0x3c;\n    }\n    if (bVar7) {\n        return -1;\n    }\n    iVar4 = *param_1;\n    param_1 = iVar4 + iVar5;\n    if (-1 < iVar5) {\n        if ((-1 < iVar4) && (param_1 < 0)) {\n            return -1;\n        }\n        if (-1 < iVar5) goto code_r0x004076c8;\n    }\n    if ((iVar4 < 0) && (-1 < param_1)) {\n        return -1;\n    }\ncode_r0x004076c8:\n    if (param_2 == 0) {\n        piVar2 = fcn.00407760(&param_1);\n        if (piVar2 == NULL) {\n            return -1;\n        }\n    }\n    else {\n        fcn.0040b800();\n        param_1 = param_1 + *0x43d6d0;\n        piVar2 = fcn.004078d0(&param_1);\n        if (piVar2 == NULL) {\n            return -1;\n        }\n        if ((0 < piVar6[8]) || ((piVar6[8] < 0 && (0 < piVar2[8])))) {\n            param_1 = param_1 + *0x43d6d8;\n            piVar2 = fcn.004078d0(&param_1);\n            for (iVar4 = 9; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *piVar6 = *piVar2;\n                piVar2 = piVar2 + 1;\n                piVar6 = piVar6 + 1;\n            }\n            return param_1;\n        }\n    }\n    for (iVar4 = 9; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *piVar6 = *piVar2;\n        piVar2 = piVar2 + 1;\n        piVar6 = piVar6 + 1;\n    }\n    return param_1;\n}\n",
        "token_count": 1358
    },
    "004078d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * fcn.004078d0(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    piVar1 = param_1;\n    if (*param_1 < 0) {\n        return NULL;\n    }\n    fcn.0040b800();\n    iVar2 = *piVar1;\n    if ((iVar2 < 0x3f481) || (0x7ffc0b7e < iVar2)) {\n        piVar1 = fcn.00407760(piVar1);\n        iVar3 = fcn.0040bb20(piVar1);\n        iVar2 = *piVar1;\n        if (iVar3 != 0) {\n            iVar2 = iVar2 - *0x43d6d8;\n        }\n        param_1 = iVar2 - *0x43d6d0;\n        iVar2 = param_1 % 0x3c;\n        *piVar1 = iVar2;\n        if (iVar2 < 0) {\n            *piVar1 = iVar2 + 0x3c;\n            param_1 = param_1 + -0x3c;\n        }\n        param_1 = param_1 / 0x3c + piVar1[1];\n        iVar2 = param_1 % 0x3c;\n        piVar1[1] = iVar2;\n        if (iVar2 < 0) {\n            piVar1[1] = iVar2 + 0x3c;\n            param_1 = param_1 + -0x3c;\n        }\n        param_1 = param_1 / 0x3c + piVar1[2];\n        iVar2 = param_1 % 0x18;\n        piVar1[2] = iVar2;\n        if (iVar2 < 0) {\n            piVar1[2] = iVar2 + 0x18;\n            param_1 = param_1 + -0x18;\n        }\n        iVar2 = param_1 / 0x18;\n        if (0 < iVar2) {\n            piVar1[6] = (iVar2 + piVar1[6]) % 7;\n            piVar1[3] = piVar1[3] + iVar2;\n            piVar1[7] = piVar1[7] + iVar2;\n            return piVar1;\n        }\n        if (iVar2 < 0) {\n            piVar1[6] = (iVar2 + 7 + piVar1[6]) % 7;\n            iVar3 = piVar1[3] + iVar2;\n            piVar1[3] = iVar3;\n            if (iVar3 < 1) {\n                piVar1[7] = 0x16c;\n                piVar1[3] = iVar3 + 0x1f;\n                piVar1[4] = 0xb;\n                piVar1[5] = piVar1[5] + -1;\n                return piVar1;\n            }\n            piVar1[7] = piVar1[7] + iVar2;\n        }\n    }\n    else {\n        param_1 = iVar2 - *0x43d6d0;\n        piVar1 = fcn.00407760(&param_1);\n        if (*0x43d6d4 != 0) {\n            iVar2 = fcn.0040bb20(piVar1);\n            if (iVar2 != 0) {\n                param_1 = param_1 - *0x43d6d8;\n                piVar1 = fcn.00407760(&param_1);\n                piVar1[8] = 1;\n                return piVar1;\n            }\n        }\n    }\n    return piVar1;\n}\n",
        "token_count": 832
    },
    "00408198": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid fcn.00408198(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBX;\n    int32_t unaff_EBP;\n    int32_t unaff_ESI;\n    int32_t *unaff_EDI;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    *(unaff_ESI + -4) = *(unaff_EBP + -0x28);\n    iVar1 = fcn.004085c0();\n    *(iVar1 + 0x6c) = *(unaff_EBP + -0x1c);\n    iVar1 = fcn.004085c0();\n    *(iVar1 + 0x70) = *(unaff_EBP + -0x20);\n    if ((((*unaff_EDI == -0x1f928c9d) && (unaff_EDI[4] == 3)) && (unaff_EDI[5] == 0x19930520)) &&\n       ((*(unaff_EBP + -0x24) == 0 && (unaff_EBX != 0)))) {\n        fcn.0040566a();\n        fcn.00408440();\n    }\n    return;\n}\n",
        "token_count": 276
    },
    "00409ae0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00409ae0(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EDI;\n    char *pcVar2;\n    int32_t iStack20;\n    \n    iStack20 = 0x104;\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, 0x4406f0);\n    *0x440504 = 0x4406f0;\n    pcVar2 = *0x441f50;\n    if (**0x441f50 == '\\0') {\n        pcVar2 = 0x4406f0;\n    }\n    fcn.00409b80(pcVar2, 0, 0, &iStack20, &stack0xfffffff0);\n    iVar1 = fcn.00405e40(unaff_EDI + iStack20 * 4);\n    if (iVar1 == 0) {\n        fcn.00405dc0(8);\n    }\n    fcn.00409b80(pcVar2, iVar1, iVar1 + iStack20 * 4, &iStack20, &stack0xfffffff0);\n    *0x4404e8 = iStack20 + -1;\n    *0x4404ec = iVar1;\n    return;\n}\n",
        "token_count": 277
    },
    "00409d90": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * fcn.00409d90(void)\n\n{\n    char cVar1;\n    int16_t iVar2;\n    code *pcVar3;\n    code *pcVar4;\n    int16_t *piVar5;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uchar *puVar10;\n    uint32_t uVar11;\n    uint *puVar12;\n    int16_t *piVar13;\n    uint *puVar14;\n    uint *puVar15;\n    int16_t *piVar6;\n    \n    pcVar4 = _sym.imp.KERNEL32.dll_GetEnvironmentStringsW;\n    pcVar3 = _sym.imp.KERNEL32.dll_GetEnvironmentStrings;\n    piVar13 = NULL;\n    puVar12 = NULL;\n    if (*0x4407f8 == 0) {\n        piVar13 = (*_sym.imp.KERNEL32.dll_GetEnvironmentStringsW)();\n        if (piVar13 == NULL) {\n            puVar12 = (*pcVar3)();\n            if (puVar12 == NULL) {\n                return NULL;\n            }\n            *0x4407f8 = 2;\n        }\n        else {\n            *0x4407f8 = 1;\n        }\n    }\n    if (*0x4407f8 == 1) {\n        if ((piVar13 != NULL) || (piVar13 = (*pcVar4)(),  piVar13 != NULL)) {\n            iVar2 = *piVar13;\n            piVar5 = piVar13;\n            while (iVar2 != 0) {\n                do {\n                    piVar6 = piVar5;\n                    piVar5 = piVar6 + 1;\n                } while (*piVar5 != 0);\n                piVar5 = piVar6 + 2;\n                iVar2 = *piVar5;\n            }\n            iVar7 = (piVar5 - piVar13 >> 1) + 1;\n            iVar8 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, piVar13, iVar7, 0, 0, 0, 0);\n            if ((iVar8 != 0) && (puVar12 = fcn.00405e40(iVar8),  puVar12 != NULL)) {\n                iVar7 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, piVar13, iVar7, puVar12, iVar8, 0, 0);\n                if (iVar7 == 0) {\n                    fcn.00405f10(puVar12);\n                    puVar12 = NULL;\n                }\n                (*_sym.imp.KERNEL32.dll_FreeEnvironmentStringsW)(piVar13);\n                return puVar12;\n            }\n            (*_sym.imp.KERNEL32.dll_FreeEnvironmentStringsW)(piVar13);\n            return NULL;\n        }\n    }\n    else if ((*0x4407f8 == 2) && ((puVar12 != NULL || (puVar12 = (*pcVar3)(),  puVar12 != NULL)))) {\n        cVar1 = *puVar12;\n        puVar9 = puVar12;\n        while (cVar1 != '\\0') {\n            do {\n                puVar14 = puVar9;\n                puVar9 = puVar14 + 1;\n            } while (*(puVar14 + 1) != '\\0');\n            puVar9 = puVar14 + 2;\n            cVar1 = *(puVar14 + 2);\n        }\n        puVar10 = puVar9 + (1 - puVar12);\n        puVar9 = fcn.00405e40(puVar10);\n        if (puVar9 != NULL) {\n            puVar14 = puVar12;\n            puVar15 = puVar9;\n            for (uVar11 = puVar10 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {\n                *puVar15 = *puVar14;\n                puVar14 = puVar14 + 1;\n                puVar15 = puVar15 + 1;\n            }\n            for (uVar11 = puVar10 & 3; uVar11 != 0; uVar11 = uVar11 - 1) {\n                *puVar15 = *puVar14;\n                puVar14 = puVar14 + 1;\n                puVar15 = puVar15 + 1;\n            }\n            (*_sym.imp.KERNEL32.dll_FreeEnvironmentStringsA)(puVar12);\n            return puVar9;\n        }\n        (*_sym.imp.KERNEL32.dll_FreeEnvironmentStringsA)(puVar12);\n        return NULL;\n    }\n    return NULL;\n}\n",
        "token_count": 1020
    },
    "0040a220": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0040a220(void)\n\n{\n    if ((*0x4404d0 == 1) || ((*0x4404d0 == 0 && (*0x43aca4 == 1)))) {\n        fcn.0040a260(0xfc);\n        if (*0x4407fc != NULL) {\n            (**0x4407fc)();\n        }\n        fcn.0040a260(0xff);\n    }\n    return;\n}\n",
        "token_count": 100
    },
    "0040a260": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0040a260(int32_t param_1)\n\n{\n    char cVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    int32_t iVar7;\n    uint *puVar8;\n    uint *puVar9;\n    char *pcVar10;\n    char *pcVar11;\n    char *pcVar12;\n    uchar auStack424 [92];\n    uint auStack332 [15];\n    uint uStack272;\n    uchar auStack260 [260];\n    \n    piVar2 = 0x43b3f0;\n    iVar7 = 0;\n    do {\n        if (param_1 == *piVar2) break;\n        piVar2 = piVar2 + 2;\n        iVar7 = iVar7 + 1;\n    } while (piVar2 < 0x43b480);\n    if (param_1 == *(iVar7 * 8 + 0x43b3f0)) {\n        if ((*0x4404d0 == 1) || ((*0x4404d0 == 0 && (*0x43aca4 == 1)))) {\n            if ((*0x440e20 == 0) || (iVar3 = *(*0x440e20 + 0x48),  iVar3 == -1)) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_GetStdHandle)(0xfffffff4);\n            }\n            pcVar11 = *(iVar7 * 8 + 0x43b3f4);\n            uVar4 = 0xffffffff;\n            pcVar10 = pcVar11;\n            do {\n                if (uVar4 == 0) break;\n                uVar4 = uVar4 - 1;\n                cVar1 = *pcVar10;\n                pcVar10 = pcVar10 + 1;\n            } while (cVar1 != '\\0');\n            (*_sym.imp.KERNEL32.dll_WriteFile)(iVar3, pcVar11, ~uVar4 - 1, auStack424, 0);\n        }\n        else if (param_1 != 0xfc) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack260, 0x104);\n            if (iVar3 == 0) {\n                puVar6 = \"<program name unknown>\";\n                puVar8 = &uStack272;\n                for (iVar3 = 5; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar8 = *puVar6;\n                    puVar6 = puVar6 + 1;\n                    puVar8 = puVar8 + 1;\n                }\n                *puVar8 = *puVar6;\n                *(puVar8 + 2) = *(puVar6 + 2);\n            }\n            uVar4 = 0xffffffff;\n            puVar6 = &uStack272;\n            puVar8 = &uStack272;\n            do {\n                if (uVar4 == 0) break;\n                uVar4 = uVar4 - 1;\n                cVar1 = *puVar8;\n                puVar8 = puVar8 + 1;\n            } while (cVar1 != '\\0');\n            if (0x3c < ~uVar4) {\n                uVar4 = 0xffffffff;\n                puVar6 = &uStack272;\n                do {\n                    if (uVar4 == 0) break;\n                    uVar4 = uVar4 - 1;\n                    cVar1 = *puVar6;\n                    puVar6 = puVar6 + 1;\n                } while (cVar1 != '\\0');\n                puVar6 = auStack332 + ~uVar4;\n                fcn.0040c5b0(puVar6, 0x434f78, 3);\n            }\n            puVar8 = \"Runtime Error!\\n\\nProgram: \";\n            puVar9 = &stack0xfffffe50;\n            for (iVar3 = 6; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar9 = *puVar8;\n                puVar8 = puVar8 + 1;\n                puVar9 = puVar9 + 1;\n            }\n            *puVar9 = *puVar8;\n            uVar4 = 0xffffffff;\n            do {\n                puVar8 = puVar6;\n                if (uVar4 == 0) break;\n                uVar4 = uVar4 - 1;\n                puVar8 = puVar6 + 1;\n                cVar1 = *puVar6;\n                puVar6 = puVar8;\n            } while (cVar1 != '\\0');\n            uVar4 = ~uVar4;\n            iVar3 = -1;\n            pcVar11 = &stack0xfffffe50;\n            do {\n                pcVar10 = pcVar11;\n                if (iVar3 == 0) break;\n                iVar3 = iVar3 + -1;\n                pcVar10 = pcVar11 + 1;\n                cVar1 = *pcVar11;\n                pcVar11 = pcVar10;\n            } while (cVar1 != '\\0');\n            puVar6 = puVar8 - uVar4;\n            puVar8 = pcVar10 + -1;\n            for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n                *puVar8 = *puVar6;\n                puVar6 = puVar6 + 1;\n                puVar8 = puVar8 + 1;\n            }\n            for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n                *puVar8 = *puVar6;\n                puVar6 = puVar6 + 1;\n                puVar8 = puVar8 + 1;\n            }\n            uVar4 = 0xffffffff;\n            pcVar11 = 0x434f58;\n            do {\n                pcVar10 = pcVar11;\n                if (uVar4 == 0) break;\n                uVar4 = uVar4 - 1;\n                pcVar10 = pcVar11 + 1;\n                cVar1 = *pcVar11;\n                pcVar11 = pcVar10;\n            } while (cVar1 != '\\0');\n            uVar4 = ~uVar4;\n            iVar3 = -1;\n            pcVar11 = &stack0xfffffe50;\n            do {\n                pcVar12 = pcVar11;\n                if (iVar3 == 0) break;\n                iVar3 = iVar3 + -1;\n                pcVar12 = pcVar11 + 1;\n                cVar1 = *pcVar11;\n                pcVar11 = pcVar12;\n            } while (cVar1 != '\\0');\n            puVar6 = pcVar10 + -uVar4;\n            puVar8 = pcVar12 + -1;\n            for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n                *puVar8 = *puVar6;\n                puVar6 = puVar6 + 1;\n                puVar8 = puVar8 + 1;\n            }\n            for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n                *puVar8 = *puVar6;\n                puVar6 = puVar6 + 1;\n                puVar8 = puVar8 + 1;\n            }\n            uVar4 = 0xffffffff;\n            pcVar11 = *(iVar7 * 8 + 0x43b3f4);\n            do {\n                pcVar10 = pcVar11;\n                if (uVar4 == 0) break;\n                uVar4 = uVar4 - 1;\n                pcVar10 = pcVar11 + 1;\n                cVar1 = *pcVar11;\n                pcVar11 = pcVar10;\n            } while (cVar1 != '\\0');\n            uVar4 = ~uVar4;\n            iVar7 = -1;\n            pcVar11 = &stack0xfffffe50;\n            do {\n                pcVar12 = pcVar11;\n                if (iVar7 == 0) break;\n                iVar7 = iVar7 + -1;\n                pcVar12 = pcVar11 + 1;\n                cVar1 = *pcVar11;\n                pcVar11 = pcVar12;\n            } while (cVar1 != '\\0');\n            puVar6 = pcVar10 + -uVar4;\n            puVar8 = pcVar12 + -1;\n            for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n                *puVar8 = *puVar6;\n                puVar6 = puVar6 + 1;\n                puVar8 = puVar8 + 1;\n            }\n            for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n                *puVar8 = *puVar6;\n                puVar6 = puVar6 + 1;\n                puVar8 = puVar8 + 1;\n            }\n            fcn.0040c520(&stack0xfffffe50, \"Microsoft Visual C++ Runtime Library\");\n            return;\n        }\n    }\n    return;\n}\n",
        "token_count": 2088
    },
    "0040aa00": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0040aa00(int32_t **param_1, int32_t *param_2, int32_t *param_3)\n\n{\n    char cVar1;\n    int32_t **ppiVar2;\n    int32_t **ppiVar3;\n    int32_t **ppiVar4;\n    int32_t *piVar5;\n    int32_t **ppiVar6;\n    \n    ppiVar2 = *param_1;\n    if (param_3 <= param_1[1]) {\n        *ppiVar2 = param_3;\n        if (ppiVar2 + param_3 < param_1 + 0x3e) {\n            *param_1 = *param_1 + param_3;\n            param_1[1] = param_1[1] - param_3;\n        }\n        else {\n            param_1[1] = NULL;\n            *param_1 = param_1 + 2;\n        }\n        return (ppiVar2 + 2) * 0x10 + param_1 * -0xf;\n    }\n    ppiVar3 = param_1[1] + ppiVar2;\n    ppiVar6 = ppiVar2;\n    if (*ppiVar3 != '\\0') {\n        ppiVar6 = ppiVar3;\n    }\n    if (ppiVar6 + param_3 < param_1 + 0x3e) {\n        do {\n            if (*ppiVar6 == 0) {\n                ppiVar3 = ppiVar6 + 1;\n                piVar5 = 0x1;\n                cVar1 = *(ppiVar6 + 1);\n                while (cVar1 == '\\0') {\n                    ppiVar3 = ppiVar3 + 1;\n                    piVar5 = piVar5 + 1;\n                    cVar1 = *ppiVar3;\n                }\n                if (param_3 <= piVar5) {\n                    if (param_1 + 0x3e <= ppiVar6 + param_3) {\n                        *param_1 = param_1 + 2;\n                        goto code_r0x0040ab4f;\n                    }\n                    *param_1 = ppiVar6 + param_3;\n                    param_1[1] = piVar5 - param_3;\n                    goto code_r0x0040ab56;\n                }\n                if (ppiVar6 == ppiVar2) {\n                    param_1[1] = piVar5;\n                }\n                else {\n                    param_2 = param_2 - piVar5;\n                    if (param_2 < param_3) {\n                        return 0;\n                    }\n                }\n            }\n            else {\n                ppiVar3 = ppiVar6 + *ppiVar6;\n            }\n            ppiVar6 = ppiVar3;\n        } while (ppiVar3 + param_3 < param_1 + 0x3e);\n    }\n    ppiVar3 = param_1 + 2;\n    ppiVar6 = ppiVar3;\n    if (ppiVar3 < ppiVar2) {\n        while (ppiVar6 + param_3 < param_1 + 0x3e) {\n            if (*ppiVar6 == 0) {\n                ppiVar4 = ppiVar6 + 1;\n                piVar5 = 0x1;\n                cVar1 = *(ppiVar6 + 1);\n                while (cVar1 == '\\0') {\n                    ppiVar4 = ppiVar4 + 1;\n                    piVar5 = piVar5 + 1;\n                    cVar1 = *ppiVar4;\n                }\n                if (param_3 <= piVar5) {\n                    if (ppiVar6 + param_3 < param_1 + 0x3e) {\n                        *param_1 = ppiVar6 + param_3;\n                        param_1[1] = piVar5 - param_3;\n                    }\n                    else {\n                        *param_1 = ppiVar3;\ncode_r0x0040ab4f:\n                        param_1[1] = NULL;\n                    }\ncode_r0x0040ab56:\n                    *ppiVar6 = param_3;\n                    return (ppiVar6 + 2) * 0x10 + param_1 * -0xf;\n                }\n                param_2 = param_2 - piVar5;\n                if (param_2 < param_3) {\n                    return 0;\n                }\n            }\n            else {\n                ppiVar4 = ppiVar6 + *ppiVar6;\n            }\n            ppiVar6 = ppiVar4;\n            if (ppiVar2 <= ppiVar4) {\n                return 0;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1038
    },
    "0040ab80": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.0040ab80(int32_t arg_8h, int32_t **noname_1, int32_t **noname_2, uint32_t noname_3, uint noname_4, uint noname_5, \n            uint noname_6, uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, \n            uint noname_13, uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, \n            uint noname_19, uint noname_20, uint noname_21, uint noname_22, uint noname_23, uint noname_24, \n            uint noname_25, uint noname_26, uint noname_27, uint noname_28, uint noname_29, uint noname_30, \n            uint noname_31, uint noname_32, uint noname_33, uint noname_34, uint noname_35, uint noname_36, \n            uint noname_37, uint noname_38, uint noname_39, uint noname_40, uint noname_41, uint noname_42, \n            uint noname_43, uint noname_44, uint noname_45, uint noname_46, uint noname_47, uint noname_48, \n            uint noname_49, uint noname_50, uint noname_51, uint noname_52, uint noname_53, uint noname_54, \n            uint noname_55, uint noname_56, uint noname_57, uint noname_58, uint noname_59, uint arg_f8h)\n\n{\n    int32_t **ppiVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    char cVar4;\n    uint uVar5;\n    int32_t *piVar6;\n    uint32_t uVar7;\n    int32_t **ppiVar8;\n    uint var_4h;\n    \n    uVar5 = 0;\n    piVar3 = arg_8h + 0x18 + (noname_1 - *(arg_8h + 0x10) >> 0xc) * 8;\n    uVar7 = *noname_2;\n    if (uVar7 <= noname_3) {\n        if ((uVar7 < noname_3) && (ppiVar1 = noname_3 + noname_2,  ppiVar1 <= noname_1 + 0x3e)) {\n            for (ppiVar8 = uVar7 + noname_2; (ppiVar8 < ppiVar1 && (*ppiVar8 == '\\0')); ppiVar8 = ppiVar8 + 1) {\n            }\n            if (ppiVar8 == ppiVar1) {\n                *noname_2 = noname_3;\n                if ((noname_2 <= *noname_1) && (*noname_1 < ppiVar1)) {\n                    if (ppiVar1 < noname_1 + 0x3e) {\n                        *noname_1 = ppiVar1;\n                        piVar6 = NULL;\n                        cVar4 = *ppiVar1;\n                        while (cVar4 == '\\0') {\n                            iVar2 = piVar6 + 1;\n                            piVar6 = piVar6 + 1;\n                            cVar4 = *(iVar2 + ppiVar1);\n                        }\n                        noname_1[1] = piVar6;\n                    }\n                    else {\n                        noname_1[1] = NULL;\n                        *noname_1 = noname_1 + 2;\n                    }\n                }\n                *piVar3 = *piVar3 + (uVar7 - noname_3);\n                uVar5 = 1;\n            }\n        }\n        return uVar5;\n    }\n    *noname_2 = noname_3;\n    piVar3[1] = 0xf1;\n    *piVar3 = *piVar3 + (uVar7 - noname_3);\n    return 1;\n}\n",
        "token_count": 937
    },
    "0040adf0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nint32_t fcn.0040adf0(uint param_1, uint param_2, int32_t param_3, int32_t param_4, uint param_5, uint param_6, \n                    uint32_t param_7)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint unaff_ESI;\n    int32_t iVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint uVar9;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_LCMapStringA;\n    if (*0x440814 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LCMapStringA)(0, 0x100, 0x434f94, 1, 0, 0);\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_LCMapStringW)(0, 0x100, 0x434f98, 1, 0, 0);\n            if (iVar2 == 0) {\n                return 0;\n            }\n            *0x440814 = 1;\n        }\n        else {\n            *0x440814 = 2;\n        }\n    }\n    if (0 < param_4) {\n        param_4 = fcn.0040b010(param_3, param_4);\n    }\n    if (*0x440814 == 2) {\n        iVar2 = (*pcVar1)(param_1, param_2, param_3, param_4, param_5, param_6);\n        return iVar2;\n    }\n    if (*0x440814 != 1) {\n        return *0x440814;\n    }\n    if (param_7 == 0) {\n        param_7 = *0x440838;\n    }\n    uVar9 = 0;\n    iVar8 = 0;\n    uVar7 = param_7;\n    iVar2 = param_4;\n    iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(param_7, 9, param_3, param_4, 0, 0);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    iVar4 = fcn.00405e40(iVar3 * 2);\n    if (iVar4 == 0) {\n        return 0;\n    }\n    iVar6 = iVar3;\n    iVar5 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(param_7, 1, unaff_ESI, param_4, iVar4, iVar3);\n    if ((iVar5 != 0) && (iVar5 = (*_sym.imp.KERNEL32.dll_LCMapStringW)(iVar6, uVar7, iVar4, iVar3, 0, 0),  iVar5 != 0))\n    {\n        if ((uVar7 & 0x400) == 0) {\n            param_3 = fcn.00405e40(iVar5 * 2);\n            if ((param_3 == 0) ||\n               (iVar3 = (*_sym.imp.KERNEL32.dll_LCMapStringW)(iVar6, uVar7, iVar4, iVar3, param_3, iVar5),  iVar3 == 0))\n            goto code_r0x0040afef;\n            if (iVar8 == 0) {\n                iVar5 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(uVar9, 0x220, param_3, iVar5, 0, 0);\n                iVar2 = iVar5;\n            }\n            else {\n                iVar5 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(uVar9, 0x220, param_3, iVar5, iVar2, iVar8, 0, 0);\n                iVar2 = iVar5;\n            }\n        }\n        else {\n            if (iVar8 == 0) goto code_r0x0040af54;\n            if (iVar8 < iVar5) goto code_r0x0040afef;\n            iVar2 = (*_sym.imp.KERNEL32.dll_LCMapStringW)(iVar6, uVar7, iVar4, iVar3, iVar2, iVar8);\n        }\n        if (iVar2 != 0) {\ncode_r0x0040af54:\n            fcn.00405f10(iVar4);\n            fcn.00405f10(param_3);\n            return iVar5;\n        }\n    }\ncode_r0x0040afef:\n    fcn.00405f10(iVar4);\n    fcn.00405f10(param_3);\n    return 0;\n}\n",
        "token_count": 1048
    },
    "0040b010": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0040b010(char *param_1, int32_t param_2)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    \n    pcVar1 = param_1;\n    iVar2 = param_2;\n    if (param_2 != 0) {\n        do {\n            iVar2 = iVar2 + -1;\n            if (*pcVar1 == '\\0') break;\n            pcVar1 = pcVar1 + 1;\n        } while (iVar2 != 0);\n    }\n    if (*pcVar1 == '\\0') {\n        return pcVar1 - param_1;\n    }\n    return param_2;\n}\n",
        "token_count": 147
    },
    "0040b370": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0040b370(uint param_1, uint param_2, int32_t param_3, uint param_4, int32_t param_5)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint unaff_EBP;\n    uint uVar8;\n    uint arg_8h;\n    uint uVar9;\n    uint uStack4;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetStringTypeW;\n    iVar7 = 0;\n    if (*0x440818 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)(1, 0x434f98, 1, &uStack4);\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetStringTypeA)(0, 1, 0x434f94, 1, &uStack4);\n            if (iVar2 == 0) {\n                return 0;\n            }\n            *0x440818 = 2;\n        }\n        else {\n            *0x440818 = 1;\n        }\n    }\n    if (*0x440818 != 1) {\n        iVar2 = *0x440818;\n        if (*0x440818 == 2) {\n            uStack4 = 0;\n            if (param_5 == 0) {\n                param_5 = *0x440838;\n            }\n            uVar9 = 0;\n            arg_8h = 0x220;\n            iVar6 = param_3;\n            iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(param_5, 0x220, param_2, param_3, 0, 0, 0, 0);\n            if (iVar3 == 0) {\n                return 0;\n            }\n            iVar4 = fcn.00406480(1, iVar3);\n            if (iVar4 == 0) {\n                return 0;\n            }\n            uVar8 = 0;\n            iVar2 = iVar4;\n            iVar5 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(unaff_EBP, 0x220, uVar9, param_3, iVar4, iVar3, 0, 0);\n            if ((iVar5 != 0) && (iVar7 = fcn.00405e40(iVar3 * 2 + 2),  iVar7 != 0)) {\n                if (iVar6 == 0) {\n                    iVar6 = *0x440828;\n                }\n                param_3 = param_3 * 2;\n                *(iVar7 + param_3) = 0xffff;\n                *(iVar7 + -2 + param_3) = 0xffff;\n                iVar2 = (*_sym.imp.KERNEL32.dll_GetStringTypeA)(iVar6, uVar8, iVar4, iVar3, iVar7);\n                if ((*(iVar7 + -2 + param_3) == -1) || (*(iVar7 + param_3) != -1)) {\n                    iVar2 = 0;\n                }\n                else {\n                    fcn.00406890(arg_8h, iVar7, param_3);\n                }\n            }\n            fcn.00405f10(iVar4);\n            fcn.00405f10(iVar7);\n        }\n        return iVar2;\n    }\n    iVar7 = (*pcVar1)(param_1, param_2, param_3, param_4);\n    return iVar7;\n}\n",
        "token_count": 809
    },
    "0040b500": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nint32_t fcn.0040b500(uint param_1, uint param_2, uint param_3, uint param_4, int32_t param_5, int32_t param_6)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    int32_t iVar4;\n    int32_t unaff_retaddr;\n    uchar auStack2 [2];\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetStringTypeA;\n    iVar4 = 0;\n    if (*0x44081c == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetStringTypeA)(0, 1, 0x434f94, 1, auStack2);\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)(1, 0x434f98, 1, auStack2);\n            if (iVar2 == 0) {\n                return 0;\n            }\n            *0x44081c = 1;\n        }\n        else {\n            *0x44081c = 2;\n        }\n    }\n    if (*0x44081c == 2) {\n        if (param_6 == 0) {\n            param_6 = *0x440828;\n        }\n        iVar4 = (*pcVar1)(param_6, param_1, param_2, param_3, param_4);\n        return iVar4;\n    }\n    iVar2 = *0x44081c;\n    if (*0x44081c == 1) {\n        if (param_5 == 0) {\n            param_5 = *0x440838;\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(param_5, 9, param_2, param_3, 0, 0);\n        iVar2 = unaff_retaddr;\n        if (iVar3 != 0) {\n            iVar4 = fcn.00406480(2, iVar3);\n            iVar2 = unaff_retaddr;\n            if (iVar4 != 0) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(param_5, 1, unaff_ESI, param_3, iVar4, iVar3);\n                iVar2 = unaff_retaddr;\n                if (iVar3 != 0) {\n                    iVar2 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)(unaff_EDI, iVar4, iVar3, unaff_EBX);\n                    fcn.00405f10(iVar4);\n                    return iVar2;\n                }\n            }\n        }\n        fcn.00405f10(iVar4);\n    }\n    return iVar2;\n}\n",
        "token_count": 628
    },
    "0040b700": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.0040b700(uint32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t auStack8 [2];\n    \n    uVar1 = param_1;\n    if (*0x440828 == 0) {\n        if ((0x60 < param_1) && (param_1 < 0x7b)) {\n            return param_1 - 0x20;\n        }\n    }\n    else {\n        if (param_1 < 0x100) {\n            if (*0x43d6bc < 2) {\n                uVar2 = *(*0x43d4b0 + param_1 * 2) & 2;\n            }\n            else {\n                uVar2 = fcn.0040b2d0(param_1, 2);\n            }\n            if (uVar2 == 0) {\n                return uVar1;\n            }\n        }\n        if ((*(*0x43d4b0 + 1 + (uVar1 >> 8 & 0xffU) * 2) & 0x80) == 0) {\n            param_1 = param_1 & 0xffff0000 | uVar1 & 0xff;\n            uVar3 = 1;\n        }\n        else {\n            param_1 = param_1 & 0xff000000 | CONCAT11(uVar1, uVar1 >> 8);\n            uVar3 = 2;\n        }\n        iVar4 = fcn.0040adf0(*0x440828, 0x200, &param_1, uVar3, auStack8, 3, 0);\n        if (iVar4 == 0) {\n            return uVar1;\n        }\n        if (iVar4 == 1) {\n            return auStack8[0] & 0xff;\n        }\n        param_1 = (auStack8[0] >> 8 & 0xff) << 8 | auStack8[0] & 0xff;\n    }\n    return param_1;\n}\n",
        "token_count": 468
    },
    "0040b840": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0040b840(void)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    uint8_t *puVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint8_t *puVar7;\n    uint *puVar8;\n    uint8_t *puVar9;\n    uint *puVar10;\n    bool bVar11;\n    \n    fcn.00408940(0xc);\n    *0x440840 = 0;\n    *0x43d778 = 0xffffffff;\n    *0x43d768 = 0xffffffff;\n    puVar3 = fcn.0040cd50(0x434fe0);\n    if (puVar3 == NULL) {\n        fcn.004089c0(0xc);\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetTimeZoneInformation)(0x440848);\n        if (iVar4 == -1) {\n            return;\n        }\n        *0x440840 = 1;\n        *0x43d6d0 = *0x440848 * 0x3c;\n        if (*0x44088e != 0) {\n            *0x43d6d0 = *0x43d6d0 + *0x44089c * 0x3c;\n        }\n        if ((*0x4408e2 == 0) || (*0x4408f0 == 0)) {\n            *0x43d6d4 = 0;\n            *0x43d6d8 = 0;\n        }\n        else {\n            *0x43d6d4 = 1;\n            *0x43d6d8 = (*0x4408f0 - *0x44089c) * 0x3c;\n        }\n        fcn.0040caa0(*0x43d760, 0x44084c, 0x40);\n        fcn.0040caa0(*0x43d764, 0x4408a0, 0x40);\n        (*0x43d764)[0x3f] = 0;\n        *(*0x43d760 + 0x3f) = 0;\n        return;\n    }\n    if (*puVar3 != 0) {\n        puVar7 = puVar3;\n        puVar8 = *0x4408f4;\n        if (*0x4408f4 != NULL) {\n            do {\n                uVar1 = *puVar7;\n                bVar11 = uVar1 < *puVar8;\n                if (uVar1 != *puVar8) {\ncode_r0x0040b997:\n                    iVar4 = (1 - bVar11) - (bVar11 != 0);\n                    goto code_r0x0040b99c;\n                }\n                if (uVar1 == 0) break;\n                uVar1 = puVar7[1];\n                bVar11 = uVar1 < *(puVar8 + 1);\n                if (uVar1 != *(puVar8 + 1)) goto code_r0x0040b997;\n                puVar7 = puVar7 + 2;\n                puVar8 = puVar8 + 2;\n            } while (uVar1 != 0);\n            iVar4 = 0;\ncode_r0x0040b99c:\n            if (iVar4 == 0) goto code_r0x0040bb09;\n        }\n        fcn.00405f10(*0x4408f4);\n        uVar5 = 0xffffffff;\n        puVar7 = puVar3;\n        do {\n            if (uVar5 == 0) break;\n            uVar5 = uVar5 - 1;\n            uVar1 = *puVar7;\n            puVar7 = puVar7 + 1;\n        } while (uVar1 != 0);\n        *0x4408f4 = fcn.00405e40(~uVar5);\n        if (*0x4408f4 != NULL) {\n            uVar5 = 0xffffffff;\n            puVar7 = puVar3;\n            do {\n                puVar9 = puVar7;\n                if (uVar5 == 0) break;\n                uVar5 = uVar5 - 1;\n                puVar9 = puVar7 + 1;\n                uVar1 = *puVar7;\n                puVar7 = puVar9;\n            } while (uVar1 != 0);\n            uVar5 = ~uVar5;\n            puVar8 = puVar9 + -uVar5;\n            puVar10 = *0x4408f4;\n            for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {\n                *puVar10 = *puVar8;\n                puVar8 = puVar8 + 1;\n                puVar10 = puVar10 + 1;\n            }\n            for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {\n                *puVar10 = *puVar8;\n                puVar8 = puVar8 + 1;\n                puVar10 = puVar10 + 1;\n            }\n            fcn.004089c0(0xc);\n            fcn.0040c5b0(*0x43d760, puVar3, 3);\n            puVar7 = puVar3 + 3;\n            *(*0x43d760 + 3) = 0;\n            uVar1 = *puVar7;\n            if (uVar1 == 0x2d) {\n                puVar7 = puVar3 + 4;\n            }\n            *0x43d6d0 = fcn.004067c0(puVar7);\n            *0x43d6d0 = *0x43d6d0 * 0xe10;\n            for (; (uVar2 = *puVar7,  uVar2 == 0x2b || (('/' < uVar2 && (uVar2 < ':')))); puVar7 = puVar7 + 1) {\n            }\n            if (*puVar7 == 0x3a) {\n                puVar7 = puVar7 + 1;\n                iVar4 = fcn.004067c0(puVar7);\n                *0x43d6d0 = *0x43d6d0 + iVar4 * 0x3c;\n                uVar2 = *puVar7;\n                while (('/' < uVar2 && (uVar2 < ':'))) {\n                    puVar3 = puVar7 + 1;\n                    puVar7 = puVar7 + 1;\n                    uVar2 = *puVar3;\n                }\n                if (*puVar7 == 0x3a) {\n                    puVar7 = puVar7 + 1;\n                    iVar4 = fcn.004067c0(puVar7);\n                    *0x43d6d0 = *0x43d6d0 + iVar4;\n                    uVar2 = *puVar7;\n                    while (('/' < uVar2 && (uVar2 < ':'))) {\n                        puVar3 = puVar7 + 1;\n                        puVar7 = puVar7 + 1;\n                        uVar2 = *puVar3;\n                    }\n                }\n            }\n            if (uVar1 == 0x2d) {\n                *0x43d6d0 = -*0x43d6d0;\n            }\n            *0x43d6d4 = *puVar7;\n            if (*0x43d6d4 == 0) {\n                **0x43d764 = 0;\n                return;\n            }\n            fcn.0040c5b0(*0x43d764, puVar7, 3);\n            (*0x43d764)[3] = 0;\n            return;\n        }\n    }\ncode_r0x0040bb09:\n    fcn.004089c0(0xc);\n    return;\n}\n",
        "token_count": 1785
    },
    "0040bb50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool fcn.0040bb50(int32_t *param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    int32_t iVar6;\n    ushort uVar7;\n    ushort uVar8;\n    \n    if (*0x43d6d4 == 0) {\n        return false;\n    }\n    iVar6 = param_1[5];\n    if ((iVar6 == *0x43d768) && (iVar6 == *0x43d778)) goto code_r0x0040bd24;\n    if (*0x440840 == 0) {\n        fcn.0040bdc0(1, 1, iVar6, 4, 1, 0, 0, 2, 0, 0, 0);\n        iVar6 = param_1[5];\n        *0x44089a = 0;\n        uVar3 = 0;\n        *0x440896 = 0;\n        uVar4 = 2;\n        uVar1 = 0;\n        *0x440892 = 5;\n        uVar7 = 10;\ncode_r0x0040bd18:\n        uVar5 = 1;\n        uVar8 = *0x440892;\n        *0x440892 = 0;\n    }\n    else {\n        if (*0x4408e0 != 0) {\n            uVar3 = 0;\n            uVar7 = 0;\n        }\n        else {\n            uVar3 = *0x4408e4 & 0xffff;\n            uVar7 = *0x4408e6;\n            *0x4408e6 = 0;\n        }\n        fcn.0040bdc0(1, *0x4408e0 == 0, iVar6, *0x4408e2, uVar7, uVar3, *0x4408e6, *0x4408e8 & 0xffff, *0x4408e8 >> 0x10\n                     , *0x4408ec & 0xffff, *0x4408ec >> 0x10);\n        uVar7 = *0x44088e;\n        if (*0x44088c == 0) {\n            uVar3 = *0x440898 & 0xffff;\n            uVar4 = *0x440894 & 0xffff;\n            uVar1 = *0x440890 & 0xffff;\n            iVar6 = param_1[5];\n            goto code_r0x0040bd18;\n        }\n        uVar3 = *0x440898 & 0xffff;\n        uVar4 = *0x440894 & 0xffff;\n        iVar6 = param_1[5];\n        uVar1 = 0;\n        uVar8 = 0;\n        uVar5 = 0;\n    }\n    fcn.0040bdc0(0, uVar5, iVar6, uVar7, uVar8, uVar1, *0x440892, uVar4, *0x440896, uVar3, *0x44089a);\ncode_r0x0040bd24:\n    iVar6 = param_1[7];\n    if (*0x43d76c < *0x43d77c) {\n        if ((iVar6 < *0x43d76c) || (*0x43d77c < iVar6)) {\n            return false;\n        }\n        if ((*0x43d76c < iVar6) && (iVar6 < *0x43d77c)) {\n            return true;\n        }\n    }\n    else {\n        if ((iVar6 < *0x43d77c) || (*0x43d76c < iVar6)) {\n            return true;\n        }\n        if ((*0x43d77c < iVar6) && (iVar6 < *0x43d76c)) {\n            return false;\n        }\n    }\n    iVar2 = (*param_1 + (param_1[1] + param_1[2] * 0x3c) * 0x3c) * 1000;\n    if (iVar6 != *0x43d76c) {\n        return iVar2 < *0x43d780;\n    }\n    return *0x43d770 <= iVar2;\n}\n",
        "token_count": 968
    },
    "0040bdc0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0040bdc0(int32_t param_1, int32_t param_2, uint32_t param_3, int32_t param_4, int32_t param_5, int32_t param_6\n                 , int32_t param_7, int32_t param_8, int32_t param_9, int32_t param_10, int32_t param_11)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    if (param_2 == 1) {\n        if ((param_3 & 3) == 0) {\n            iVar1 = *(param_4 * 4 + 0x43d784);\n        }\n        else {\n            iVar1 = *(param_4 * 4 + 0x43d7bc);\n        }\n        iVar2 = ((param_3 - 1 >> 2) + -0x63db + param_3 * 0x16d + iVar1 + 1) % 7;\n        if (iVar2 < param_6) {\n            iVar1 = iVar1 + -6 + (param_5 * 7 - iVar2) + param_6;\n        }\n        else {\n            iVar1 = iVar1 + 1 + (param_5 * 7 - iVar2) + param_6;\n        }\n        if (param_5 == 5) {\n            if ((param_3 & 3) == 0) {\n                iVar2 = *(param_4 * 4 + 0x43d788);\n            }\n            else {\n                iVar2 = *(param_4 * 4 + 0x43d7c0);\n            }\n            if (iVar2 < iVar1) {\n                iVar1 = iVar1 + -7;\n            }\n        }\n    }\n    else {\n        if ((param_3 & 3) == 0) {\n            iVar1 = *(param_4 * 4 + 0x43d784);\n        }\n        else {\n            iVar1 = *(param_4 * 4 + 0x43d7bc);\n        }\n        iVar1 = iVar1 + param_7;\n    }\n    if (param_1 == 1) {\n        *0x43d768 = param_3;\n        *0x43d76c = iVar1;\n        *0x43d770 = param_11 + (param_10 + (param_9 + param_8 * 0x3c) * 0x3c) * 1000;\n        return;\n    }\n    *0x43d780 = param_11 + (param_10 + (param_9 + param_8 * 0x3c) * 0x3c + *0x43d6d8) * 1000;\n    if (*0x43d780 < 0) {\n        *0x43d778 = param_3;\n        *0x43d77c = iVar1;\n        *0x43d780 = *0x43d780 + 86399999;\n        return;\n    }\n    if (86399999 < *0x43d780) {\n        *0x43d780 = *0x43d780 + -86399999;\n    }\n    *0x43d778 = param_3;\n    *0x43d77c = iVar1;\n    return;\n}\n",
        "token_count": 729
    },
    "0040bf60": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040bf60(uint8_t *arg_8h, uint8_t *arg_ch)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    char cVar3;\n    uint8_t uVar4;\n    uint8_t uVar7;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint32_t uVar8;\n    \n    iVar2 = *0x440e10;\n    if (*0x440828 == 0) {\n        uVar5 = 0xff;\n        do {\n            do {\n                cVar3 = uVar5;\n                if (cVar3 == '\\0') goto code_r0x0040bfae;\n                uVar7 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                uVar4 = *arg_8h;\n                uVar5 = CONCAT11(uVar4, uVar7);\n                arg_8h = arg_8h + 1;\n            } while (uVar5 >> 8 == uVar7);\n            uVar4 = uVar4 + 0xbf;\n            uVar4 = uVar4 + (-(uVar4 < 0x1a) & 0x20U) + 0x41;\n            uVar5 = CONCAT11(uVar7 + 0xbf + (-(uVar7 + 0xbf < 0x1a) & 0x20U) + 'A', uVar4);\n            uVar7 = uVar5 >> 8;\n        } while (uVar4 == uVar7);\n        cVar3 = (uVar4 < uVar7) * -2 + '\\x01';\ncode_r0x0040bfae:\n        uVar6 = cVar3;\n    }\n    else {\n        LOCK();\n        *0x440e10 = *0x440e10 + 1;\n        bVar1 = 0 < *0x440e0c;\n        if (bVar1) {\n            LOCK();\n            *0x440e10 = iVar2;\n            fcn.00408940(0x13);\n        }\n        uVar8 = bVar1;\n        uVar6 = 0xff;\n        uVar5 = 0;\n        do {\n            do {\n                if (uVar6 == '\\0') goto code_r0x0040c00f;\n                uVar7 = *arg_ch;\n                uVar6 = uVar6 & 0xffffff00 | uVar7;\n                arg_ch = arg_ch + 1;\n                uVar4 = *arg_8h;\n                uVar5 = uVar5 & 0xffffff00 | uVar4;\n                arg_8h = arg_8h + 1;\n            } while (uVar7 == uVar4);\n            uVar5 = fcn.0040dd50(uVar5, uVar6);\n            uVar6 = fcn.0040dd50();\n        } while (uVar5 == uVar6);\n        uVar5 = uVar5 < uVar6;\n        uVar6 = (1 - uVar5) - (uVar5 != 0);\ncode_r0x0040c00f:\n        if (uVar8 == 0) {\n            LOCK();\n            *0x440e10 = *0x440e10 + -1;\n        }\n        else {\n            fcn.004089c0(0x13);\n        }\n    }\n    return uVar6;\n}\n",
        "token_count": 763
    },
    "0040c160": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint fcn.0040c160(int32_t *param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    \n    uVar3 = 0;\n    if (((param_1[3] & 3) == 2) && ((param_1[3] & 0x108U) != 0)) {\n        iVar4 = *param_1 - param_1[2];\n        if (0 < iVar4) {\n            iVar2 = fcn.0040c7b0(param_1[4], param_1[2], iVar4);\n            uVar1 = param_1[3];\n            if (iVar2 == iVar4) {\n                if ((uVar1 & 0x80) != 0) {\n                    param_1[1] = 0;\n                    param_1[3] = uVar1 & 0xfffffffd;\n                    *param_1 = param_1[2];\n                    return 0;\n                }\n            }\n            else {\n                uVar3 = 0xffffffff;\n                param_1[3] = uVar1 | 0x20;\n            }\n        }\n    }\n    param_1[1] = 0;\n    *param_1 = param_1[2];\n    return uVar3;\n}\n",
        "token_count": 296
    },
    "0040cb20": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.0040cb20(int32_t param_1, uint16_t *param_2, uint32_t param_3)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint16_t *puVar6;\n    int32_t iVar7;\n    int32_t iStack4;\n    \n    uVar3 = param_3;\n    puVar6 = param_2;\n    uVar2 = 0;\n    iStack4 = 0;\n    if ((param_1 != 0) && (param_3 == 0)) {\n        return uVar2;\n    }\n    if (param_1 == 0) {\n        if (*0x440828 == 0) {\n            uVar3 = fcn.00406530(param_2);\n            return uVar3;\n        }\n        iVar4 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(*0x440838, 0x220, param_2, 0xffffffff, 0, 0, 0, &iStack4);\n        if ((iVar4 != 0) && (iStack4 == 0)) {\n            return iVar4 - 1;\n        }\n    }\n    else if (*0x440828 == 0) {\n        if (param_3 == 0) {\n            return 0;\n        }\n        while (*puVar6 < 0x100) {\n            *(uVar2 + param_1) = *puVar6;\n            if (*puVar6 == 0) {\n                return uVar2;\n            }\n            uVar2 = uVar2 + 1;\n            puVar6 = puVar6 + 1;\n            if (param_3 <= uVar2) {\n                return uVar2;\n            }\n        }\n    }\n    else if (*0x43d6bc == 1) {\n        if (param_3 != 0) {\n            uVar3 = fcn.0040cd10(param_2, param_3);\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                          (*0x440838, 0x220, puVar6, uVar3, param_1, uVar3, 0, &iStack4);\n        if ((uVar3 != 0) && (iStack4 == 0)) {\n            if (*((uVar3 - 1) + param_1) != '\\0') {\n                return uVar3;\n            }\n            return uVar3 - 1;\n        }\n    }\n    else {\n        uVar2 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                          (*0x440838, 0x220, param_2, 0xffffffff, param_1, param_3, 0, &iStack4);\n        if (uVar2 == 0) {\n            if ((iStack4 == 0) && (iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar4 == 0x7a)) {\n                if (uVar3 != 0) {\n                    do {\n                        iVar4 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                          (*0x440838, 0, puVar6, 1, &param_2, *0x43d6bc, 0, &iStack4);\n                        if ((iVar4 == 0) || (iStack4 != 0)) goto code_r0x0040ccf6;\n                        if (uVar3 < iVar4 + uVar2) {\n                            return uVar2;\n                        }\n                        iVar7 = 0;\n                        if (0 < iVar4) {\n                            do {\n                                cVar1 = *(&param_2 + iVar7);\n                                *(uVar2 + param_1) = cVar1;\n                                if (cVar1 == '\\0') {\n                                    return uVar2;\n                                }\n                                iVar7 = iVar7 + 1;\n                                uVar2 = uVar2 + 1;\n                            } while (iVar7 < iVar4);\n                        }\n                        puVar6 = puVar6 + 1;\n                    } while (uVar2 < uVar3);\n                }\n                return uVar2;\n            }\n        }\n        else if (iStack4 == 0) {\n            return uVar2 - 1;\n        }\n    }\ncode_r0x0040ccf6:\n    puVar5 = fcn.00407210();\n    *puVar5 = 0x2a;\n    return 0xffffffff;\n}\n",
        "token_count": 1011
    },
    "0040cd10": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0040cd10(int16_t *param_1, int32_t param_2)\n\n{\n    int16_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = param_1;\n    iVar2 = param_2;\n    if (param_2 != 0) {\n        do {\n            if (*piVar1 == 0) break;\n            piVar1 = piVar1 + 1;\n            iVar2 = iVar2 + -1;\n        } while (iVar2 != 0);\n        if ((iVar2 != 0) && (*piVar1 == 0)) {\n            return (piVar1 - param_1 >> 1) + 1;\n        }\n    }\n    return param_2;\n}\n",
        "token_count": 167
    },
    "0040de50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0040de50(int32_t param_1)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    code **ppcVar7;\n    bool bVar8;\n    uint var_2h;\n    \n    iVar2 = param_1;\n    bVar1 = false;\n    iVar3 = param_1;\n    // switch table (8 cases) at 0x40e028\n    switch(param_1) {\n    case 2:\n        ppcVar7 = 0x440954;\n        bVar1 = true;\n        pcVar6 = *0x440954;\n        break;\n    default:\n        return 0xffffffff;\n    case 4:\n    case 8:\n    case 0xb:\n        iVar3 = fcn.004085c0();\n        iVar4 = fcn.0040e060(param_1, *(iVar3 + 0x50));\n        ppcVar7 = iVar4 + 8;\n        pcVar6 = *ppcVar7;\n        break;\n    case 0xf:\n        ppcVar7 = 0x440960;\n        bVar1 = true;\n        pcVar6 = *0x440960;\n        break;\n    case 0x15:\n        ppcVar7 = 0x440958;\n        bVar1 = true;\n        pcVar6 = *0x440958;\n        break;\n    case 0x16:\n        ppcVar7 = 0x44095c;\n        bVar1 = true;\n        pcVar6 = *0x44095c;\n    }\n    if (bVar1) {\n        fcn.00408940(1);\n    }\n    if (pcVar6 == 0x1) {\n        if (!bVar1) {\n            return 0;\n        }\n        fcn.004089c0(1);\n        return 0;\n    }\n    if (pcVar6 == NULL) {\n        if (bVar1) {\n            fcn.004089c0(1);\n        }\n        fcn.00406230(3);\n    }\n    if (((param_1 == 8) || (param_1 == 0xb)) || (param_1 == 4)) {\n        iVar4 = *(iVar3 + 0x54);\n        bVar8 = param_1 == 8;\n        *(iVar3 + 0x54) = 0;\n        param_1 = iVar4;\n        if (bVar8) {\n            unique0x00007a00 = *(iVar3 + 0x58);\n            *(iVar3 + 0x58) = 0x8c;\n            goto code_r0x0040df83;\n        }\n    }\n    else {\ncode_r0x0040df83:\n        if (iVar2 == 8) {\n            if (*0x43b3b8 < *0x43b3bc + *0x43b3b8) {\n                iVar5 = *0x43b3b8 * 0xc;\n                iVar4 = *0x43b3b8;\n                do {\n                    iVar4 = iVar4 + 1;\n                    *(*(iVar3 + 0x50) + 8 + iVar5) = 0;\n                    iVar5 = iVar5 + 0xc;\n                } while (iVar4 < *0x43b3bc + *0x43b3b8);\n            }\n            goto code_r0x0040dfc8;\n        }\n    }\n    *ppcVar7 = NULL;\ncode_r0x0040dfc8:\n    if (bVar1) {\n        fcn.004089c0(1);\n    }\n    if (iVar2 == 8) {\n        (*pcVar6)(8, *(iVar3 + 0x58));\n    }\n    else {\n        (*pcVar6)(iVar2);\n        if ((iVar2 != 0xb) && (iVar2 != 4)) {\n            return 0;\n        }\n    }\n    *(iVar3 + 0x54) = param_1;\n    if (iVar2 == 8) {\n        *(iVar3 + 0x58) = stack0xfffffffc;\n    }\n    return 0;\n}\n",
        "token_count": 942
    },
    "0040e730": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nint32_t fcn.0040e730(uint param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    int32_t unaff_EDI;\n    uint uVar4;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetLocaleInfoA;\n    if (*0x440978 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)(0, 1, 0, 0);\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)(0, 1, 0, 0);\n            if (iVar2 == 0) {\n                return 0;\n            }\n            *0x440978 = 1;\n        }\n        else {\n            *0x440978 = 2;\n        }\n    }\n    if (*0x440978 == 2) {\n        iVar2 = (*pcVar1)(param_1, param_2, param_3, param_4);\n        return iVar2;\n    }\n    if (*0x440978 != 1) {\n        return *0x440978;\n    }\n    uVar4 = 0;\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)(param_1, param_2, 0, 0);\n    if (iVar2 != 0) {\n        iVar3 = fcn.00405e40(iVar2 * 2);\n        if (iVar3 == 0) {\n            return 0;\n        }\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)(param_1, param_2, iVar3, iVar2);\n        if (iVar2 != 0) {\n            if (unaff_EDI == 0) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(unaff_ESI, 0x220, iVar3, 0xffffffff, 0, 0);\n                if (iVar2 != 0) {\n                    fcn.00405f10(iVar3);\n                    return iVar2;\n                }\n            }\n            else {\n                iVar2 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                  (unaff_ESI, 0x220, iVar3, 0xffffffff, uVar4, unaff_EDI, 0, 0);\n                if (iVar2 != 0) {\n                    fcn.00405f10(iVar3);\n                    return iVar2;\n                }\n            }\n        }\n        fcn.00405f10(iVar3);\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 607
    },
    "0040e8e0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0040e8e0(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    \n    iVar1 = fcn.0040e2a0(param_1);\n    if (iVar1 != -1) {\n        if ((param_1 == 1) || (param_1 == 2)) {\n            iVar1 = fcn.0040e2a0(1);\n            iVar2 = fcn.0040e2a0(2);\n            if (iVar1 == iVar2) goto code_r0x0040e936;\n        }\n        uVar3 = fcn.0040e2a0(param_1);\n        iVar1 = (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            goto code_r0x0040e938;\n        }\n    }\ncode_r0x0040e936:\n    iVar1 = 0;\ncode_r0x0040e938:\n    fcn.0040e200(param_1);\n    *(*((param_1 >> 5) * 4 + 0x440e20) + 4 + (param_1 & 0x1f) * 0x24) = 0;\n    if (iVar1 != 0) {\n        fcn.00407190(iVar1);\n        return 0xffffffff;\n    }\n    return 0;\n}\n",
        "token_count": 335
    },
    "0040e9b0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nint32_t fcn.0040e9b0(uint param_1, uint param_2, uint8_t *param_3, int32_t param_4, uint8_t *param_5, int32_t param_6, \n                    int32_t param_7)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint8_t *puVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint unaff_EBX;\n    int32_t unaff_EBP;\n    uint unaff_EDI;\n    uint uVar7;\n    uint32_t uStack20;\n    uint8_t auStack14 [2];\n    uint uStack12;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_CompareStringA;\n    if (*0x440980 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_CompareStringA)(0, 0, 0x434f94, 1, 0x434f94, 1);\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_CompareStringW)(0, 0, 0x434f98, 1, 0x434f98, 1);\n            if (iVar2 == 0) {\n                return 0;\n            }\n            *0x440980 = 1;\n        }\n        else {\n            *0x440980 = 2;\n        }\n    }\n    if (0 < param_4) {\n        param_4 = fcn.0040b010(param_3, param_4);\n    }\n    if (0 < param_6) {\n        param_6 = fcn.0040b010(param_5, param_6);\n    }\n    if (*0x440980 == 2) {\n        iVar2 = (*pcVar1)(param_1, param_2, param_3, param_4, param_5, param_6);\n        return iVar2;\n    }\n    iVar2 = *0x440980;\n    if (*0x440980 == 1) {\n        if (param_7 == 0) {\n            param_7 = *0x440838;\n        }\n        if ((param_4 == 0) || (param_6 == 0)) {\n            if (param_4 == param_6) {\n                return 2;\n            }\n            if (1 < param_6) {\n                return 1;\n            }\n            if (1 < param_4) {\n                return 3;\n            }\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfo)(param_7, &uStack20);\n            if (iVar2 == 0) {\n                return 0;\n            }\n            if (0 < param_4) {\n                if (uStack20 < 2) {\n                    return 3;\n                }\n                puVar3 = auStack14;\n                while( true ) {\n                    if ((auStack14[0] == 0) || (puVar3[1] == 0)) {\n                        return 3;\n                    }\n                    if ((*puVar3 <= *param_3) && (*param_3 <= puVar3[1])) break;\n                    auStack14[0] = puVar3[2];\n                    puVar3 = puVar3 + 2;\n                }\n                return 2;\n            }\n            if (0 < param_6) {\n                if (uStack20 < 2) {\n                    return 1;\n                }\n                puVar3 = auStack14;\n                while( true ) {\n                    if ((auStack14[0] == 0) || (puVar3[1] == 0)) {\n                        return 1;\n                    }\n                    if ((*puVar3 <= *param_5) && (*param_5 <= puVar3[1])) break;\n                    auStack14[0] = puVar3[2];\n                    puVar3 = puVar3 + 2;\n                }\n                return 2;\n            }\n        }\n        pcVar1 = _sym.imp.KERNEL32.dll_MultiByteToWideChar;\n        uVar7 = 0;\n        iVar4 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(param_7, 9, param_3, param_4, 0, 0);\n        if (iVar4 == 0) {\n            return 0;\n        }\n        iVar2 = fcn.00405e40(iVar4 * 2);\n        if (iVar2 == 0) {\n            return 0;\n        }\n        iVar5 = (*pcVar1)(param_7, 1, uStack12, param_4, iVar2, iVar4);\n        if ((((iVar5 != 0) && (iVar5 = (*pcVar1)(param_7, 9, unaff_EBX, 0, 0, 0),  iVar5 != 0)) &&\n            (unaff_EBP = fcn.00405e40(iVar5 * 2),  unaff_EBP != 0)) &&\n           (iVar6 = (*pcVar1)(param_7, 1, unaff_EBX, 0, unaff_EBP, iVar5),  iVar6 != 0)) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_CompareStringW)(uVar7, unaff_EDI, uStack20, iVar4, unaff_EBP, iVar5);\n        }\n        fcn.00405f10(uStack20);\n        fcn.00405f10(unaff_EBP);\n    }\n    return iVar2;\n}\n",
        "token_count": 1228
    },
    "0040ec80": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0040ec80(char *param_1, int32_t param_2)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t *piVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint *puVar11;\n    uint *puVar12;\n    bool bVar13;\n    \n    if (param_1 == NULL) {\n        return 0xffffffff;\n    }\n    pcVar4 = fcn.004063b0(param_1, 0x3d);\n    if (pcVar4 == NULL) {\n        return 0xffffffff;\n    }\n    if (param_1 == pcVar4) {\n        return 0xffffffff;\n    }\n    bVar13 = pcVar4[1] == '\\0';\n    if (*0x4404f4 == *0x4404f8) {\n        *0x4404f4 = fcn.0040ef10(*0x4404f4);\n    }\n    if (*0x4404f4 == NULL) {\n        if ((param_2 == 0) || (*0x4404fc == NULL)) {\n            if (bVar13) {\n                return 0;\n            }\n            *0x4404f4 = fcn.00405e40(4);\n            if (*0x4404f4 == NULL) {\n                return 0xffffffff;\n            }\n            **0x4404f4 = 0;\n            if (*0x4404fc == NULL) {\n                *0x4404fc = fcn.00405e40(4);\n                if (*0x4404fc == NULL) {\n                    return 0xffffffff;\n                }\n                **0x4404fc = 0;\n            }\n        }\n        else {\n            iVar5 = fcn.0040e3d0();\n            if (iVar5 != 0) {\n                return 0xffffffff;\n            }\n        }\n    }\n    piVar7 = *0x4404f4;\n    iVar6 = pcVar4 - param_1;\n    iVar5 = fcn.0040ee90(param_1, iVar6);\n    if ((iVar5 < 0) || (*piVar7 == 0)) {\n        if (bVar13) {\n            return 0;\n        }\n        if (iVar5 < 0) {\n            iVar5 = -iVar5;\n        }\n        piVar7 = fcn.00408760(piVar7, iVar5 * 4 + 8);\n        if (piVar7 == NULL) {\n            return 0xffffffff;\n        }\n        piVar7[iVar5] = param_1;\n        piVar7[iVar5 + 1] = 0;\n        *0x4404f4 = piVar7;\n    }\n    else if (bVar13) {\n        fcn.00405f10(piVar7[iVar5]);\n        iVar2 = piVar7[iVar5];\n        piVar3 = piVar7 + iVar5;\n        while (iVar2 != 0) {\n            *piVar3 = piVar3[1];\n            iVar5 = iVar5 + 1;\n            iVar2 = piVar3[1];\n            piVar3 = piVar3 + 1;\n        }\n        piVar7 = fcn.00408760(piVar7, iVar5 * 4);\n        if (piVar7 != NULL) {\n            *0x4404f4 = piVar7;\n        }\n    }\n    else {\n        piVar7[iVar5] = param_1;\n    }\n    if (param_2 != 0) {\n        uVar9 = 0xffffffff;\n        pcVar4 = param_1;\n        do {\n            if (uVar9 == 0) break;\n            uVar9 = uVar9 - 1;\n            cVar1 = *pcVar4;\n            pcVar4 = pcVar4 + 1;\n        } while (cVar1 != '\\0');\n        puVar8 = fcn.00405e40(~uVar9 + 1);\n        if (puVar8 != NULL) {\n            uVar9 = 0xffffffff;\n            do {\n                pcVar4 = param_1;\n                if (uVar9 == 0) break;\n                uVar9 = uVar9 - 1;\n                pcVar4 = param_1 + 1;\n                cVar1 = *param_1;\n                param_1 = pcVar4;\n            } while (cVar1 != '\\0');\n            uVar9 = ~uVar9;\n            puVar11 = pcVar4 + -uVar9;\n            puVar12 = puVar8;\n            for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 = uVar10 - 1) {\n                *puVar12 = *puVar11;\n                puVar11 = puVar11 + 1;\n                puVar12 = puVar12 + 1;\n            }\n            for (uVar9 = uVar9 & 3; uVar9 != 0; uVar9 = uVar9 - 1) {\n                *puVar12 = *puVar11;\n                puVar11 = puVar11 + 1;\n                puVar12 = puVar12 + 1;\n            }\n            *(puVar8 + iVar6) = 0;\n            (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(puVar8, ~-bVar13 & puVar8 + iVar6 + 1);\n            fcn.00405f10(puVar8);\n            return 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1262
    },
    "004106c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004106c0(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint *puVar1;\n    \n    *(param_1 + 0x48) = param_3 == 1;\n    if (param_3 == 0) {\n        if (*(param_1 + 0x4c) != 0) {\n            puVar1 = fcn.0040fc70();\n            if (puVar1 != NULL) {\n                (***puVar1)(1);\n            }\n        }\n        if (param_1 != -0x4c) {\n            fcn.004104d0();\n        }\n        *(param_1 + 0x44) = 0;\n    }\n    *(param_1 + 0xc) = param_1 + 4;\n    *(param_1 + 0x1c) = param_1 + 0x14;\n    *(param_1 + 0x20) = param_1 + 0x18;\n    *(param_1 + 0x10) = param_1 + 8;\n    *(param_1 + 0x2c) = param_1 + 0x24;\n    *(param_1 + 0x30) = param_1 + 0x28;\n    *(param_1 + 8) = 0;\n    **(param_1 + 0x20) = 0;\n    **(param_1 + 0x30) = 0;\n    **(param_1 + 0xc) = 0;\n    **(param_1 + 0x1c) = 0;\n    **(param_1 + 0x2c) = 0;\n    if ((param_2 != 0) && (*(param_1 + 0x48) == '\\0')) {\n        *(param_1 + 0x1c) = param_2;\n        *(param_1 + 0xc) = param_2 + 8;\n        *(param_1 + 0x10) = param_2 + 8;\n        *(param_1 + 0x20) = param_2;\n        *(param_1 + 0x2c) = param_2 + 4;\n        *(param_1 + 0x30) = param_2 + 4;\n    }\n    *(param_1 + 0x50) = param_2;\n    *(param_1 + 0x40) = *0x441f60;\n    *(param_1 + 0x3c) = *0x441f60;\n    *(param_1 + 0x38) = 0;\n    return;\n}\n",
        "token_count": 596
    },
    "00411da0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00411da0(int32_t param_1, uint param_2, int32_t param_3)\n\n{\n    uint *puVar1;\n    \n    *(param_1 + 0x48) = param_3 == 1;\n    if (param_3 == 0) {\n        if (*(param_1 + 0x4c) != 0) {\n            puVar1 = fcn.0040fc70();\n            if (puVar1 != NULL) {\n                (***puVar1)(1);\n            }\n        }\n        if (param_1 != -0x4c) {\n            fcn.004104d0();\n        }\n        *(param_1 + 0x44) = 0;\n    }\n    *(param_1 + 0xc) = param_1 + 4;\n    *(param_1 + 0x1c) = param_1 + 0x14;\n    *(param_1 + 0x20) = param_1 + 0x18;\n    *(param_1 + 0x10) = param_1 + 8;\n    *(param_1 + 0x2c) = param_1 + 0x24;\n    *(param_1 + 0x30) = param_1 + 0x28;\n    *(param_1 + 8) = 0;\n    **(param_1 + 0x20) = 0;\n    **(param_1 + 0x30) = 0;\n    **(param_1 + 0xc) = 0;\n    **(param_1 + 0x1c) = 0;\n    **(param_1 + 0x2c) = 0;\n    *(param_1 + 0x50) = param_2;\n    *(param_1 + 0x40) = *0x441f58;\n    *(param_1 + 0x3c) = *0x441f58;\n    *(param_1 + 0x38) = 0;\n    return;\n}\n",
        "token_count": 457
    },
    "00412ab0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00412ab0(uint param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    \n    if (*0x440d88 != 2) {\n        pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n        if (*0x440d88 == 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x440d88, 1);\n            if (iVar3 == 0) {\n                (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(0x440d70);\n                fcn.00405760(0x412b40);\n                *0x440d88 = 2;\n                pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n            }\n            else {\n                pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n                if (iVar3 == 2) {\n                    *0x440d88 = iVar3;\n                }\n            }\n        }\n        while (pcVar2 = _sym.imp.KERNEL32.dll_Sleep,  _sym.imp.KERNEL32.dll_Sleep = pcVar1,  *0x440d88 == 1) {\n            (*pcVar2)(1);\n            pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n            _sym.imp.KERNEL32.dll_Sleep = pcVar2;\n        }\n        if (*0x440d88 != 2) {\n            return param_1;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(0x440d70);\n    return param_1;\n}\n",
        "token_count": 353
    },
    "00413840": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.00413840(uint16_t *param_1, uint8_t *param_2, uint32_t param_3, int32_t *param_4, int32_t *param_5)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    uint var_1h;\n    \n    if ((param_2 != NULL) && (param_3 != 0)) {\n        uVar1 = *param_2;\n        if (uVar1 != 0) {\n            iVar3 = *0x440838;\n            iVar5 = *0x440828;\n            if (param_5 != NULL) {\n                iVar3 = param_5[1];\n                iVar5 = *param_5;\n            }\n            if (iVar5 == 0) {\n                if (param_1 == NULL) {\n                    return 1;\n                }\n                *param_1 = uVar1;\n                return 1;\n            }\n            if (*param_4 == 0) {\n                if ((*(*0x43d4b0 + 1 + uVar1 * 2) & 0x80) == 0) {\n                    iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(iVar3, 9, param_2, 1, param_1, param_1 != NULL)\n                    ;\n                    if (iVar3 != 0) {\n                        return 1;\n                    }\n                    puVar4 = fcn.00407210();\n                    *puVar4 = 0x2a;\n                    return 0xffffffff;\n                }\n                if (param_3 < *0x43d6bc) {\n                    *param_4 = uVar1;\n                    return 0xfffffffe;\n                }\n                if (((1 < *0x43d6bc) &&\n                    (iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                       (iVar3, 9, param_2, *0x43d6bc, param_1, param_1 != NULL),  iVar3 != 0)) ||\n                   (param_2[1] != 0)) {\n                    return *0x43d6bc;\n                }\n            }\n            else {\n                *(param_4 + 1) = uVar1;\n                if ((1 < *0x43d6bc) &&\n                   (uVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(iVar3, 9, param_4, 2, param_1, param_1 != NULL)\n                   ,  uVar2 != 0)) {\n                    *param_4 = 0;\n                    return uVar2;\n                }\n            }\n            *param_4 = 0;\n            puVar4 = fcn.00407210();\n            *puVar4 = 0x2a;\n            return 0xffffffff;\n        }\n        if (param_1 != NULL) {\n            *param_1 = 0;\n            return 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 681
    },
    "00413ed0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint fcn.00413ed0(int32_t *param_1, int32_t *param_2, uint32_t param_3, uint32_t param_4)\n\n{\n    uint32_t uVar1;\n    \n    if ((param_3 != 4) && (((param_4 < 2 || (0x7fffffff < param_4)) || ((param_3 != 0 && (param_3 != 0x40)))))) {\n        return 0xffffffff;\n    }\n    param_4 = param_4 & 0xfffffffe;\n    fcn.004089e0(param_1);\n    fcn.0040c160(param_1);\n    fcn.0040e970(param_1);\n    uVar1 = param_1[3] & 0xffffc2f3;\n    param_1[3] = uVar1;\n    if ((param_3 & 4) == 0) {\n        if (param_2 == NULL) {\n            param_2 = fcn.00405e40(param_4);\n            if (param_2 == NULL) {\n                *0x4406e8 = *0x4406e8 + 1;\n                fcn.00408a50(param_1);\n                return 0xffffffff;\n            }\n            uVar1 = param_1[3] | 0x408;\n        }\n        else {\n            uVar1 = uVar1 | 0x500;\n        }\n        param_1[3] = uVar1;\n    }\n    else {\n        param_2 = param_1 + 5;\n        param_1[3] = uVar1 | 4;\n        param_4 = 2;\n    }\n    param_1[6] = param_4;\n    param_1[2] = param_2;\n    *param_1 = param_2;\n    param_1[1] = 0;\n    fcn.00408a50(param_1);\n    return 0;\n}\n",
        "token_count": 435
    },
    "00414c10": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nushort fcn.00414c10(uint *param_1)\n\n{\n    ushort uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    uVar2 = param_1[3];\n    if (((uVar2 & 0x83) != 0) && ((uVar2 & 0x40) == 0)) {\n        if ((uVar2 & 2) != 0) {\n            param_1[3] = uVar2 | 0x20;\n            return 0xffff;\n        }\n        param_1[3] = uVar2 | 1;\n        if ((uVar2 & 0x10c) == 0) {\n            fcn.0040ca40(param_1);\n        }\n        else {\n            *param_1 = param_1[2];\n        }\n        iVar3 = fcn.00414e90(param_1[4], param_1[2], param_1[6]);\n        param_1[1] = iVar3;\n        if (((iVar3 != 0) && (iVar3 != 1)) && (iVar3 != -1)) {\n            if ((param_1[3] & 0x82) == 0) {\n                uVar2 = param_1[4];\n                if (uVar2 == 0xffffffff) {\n                    iVar4 = 0x43b3c8;\n                }\n                else {\n                    iVar4 = *((uVar2 >> 5) * 4 + 0x440e20) + (uVar2 & 0x1f) * 0x24;\n                }\n                if ((*(iVar4 + 4) & 0x82) == 0x82) {\n                    param_1[3] = param_1[3] | 0x2000;\n                }\n            }\n            if (((param_1[6] == 0x200) && ((param_1[3] & 8) != 0)) && ((param_1[3] & 0x400) == 0)) {\n                param_1[6] = 0x1000;\n            }\n            param_1[1] = iVar3 + -2;\n            uVar1 = **param_1;\n            *param_1 = *param_1 + 1;\n            return uVar1;\n        }\n        param_1[1] = 0;\n        param_1[3] = param_1[3] | (-(iVar3 != 0) & 0x10) + 0x10;\n    }\n    return 0xffff;\n}\n",
        "token_count": 577
    },
    "00414d90": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.00414d90(uint16_t *param_1, uint8_t *param_2, uint32_t param_3)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    if ((param_2 != NULL) && (param_3 != 0)) {\n        uVar1 = *param_2;\n        if (uVar1 != 0) {\n            if (*0x440828 == 0) {\n                if (param_1 == NULL) {\n                    return 1;\n                }\n                *param_1 = uVar1;\n                return 1;\n            }\n            if ((*(*0x43d4b0 + 1 + uVar1 * 2) & 0x80) == 0) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(*0x440838, 9, param_2, 1, param_1, param_1 != NULL)\n                ;\n                if (iVar2 != 0) {\n                    return 1;\n                }\n            }\n            else {\n                if (((1 < *0x43d6bc) && (*0x43d6bc <= param_3)) &&\n                   (iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                      (*0x440838, 9, param_2, *0x43d6bc, param_1, param_1 != NULL),  iVar2 != 0)) {\n                    return *0x43d6bc;\n                }\n                if (*0x43d6bc <= param_3) {\n                    if (param_2[1] != 0) {\n                        return *0x43d6bc;\n                    }\n                    puVar3 = fcn.00407210();\n                    *puVar3 = 0x2a;\n                    return 0xffffffff;\n                }\n            }\n            puVar3 = fcn.00407210();\n            *puVar3 = 0x2a;\n            return 0xffffffff;\n        }\n        if (param_1 != NULL) {\n            *param_1 = 0;\n            return 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 485
    },
    "00415374": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00415374(uint *param_1, char *param_2, int32_t *param_3)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t *piVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    bool bVar7;\n    uint unaff_retaddr;\n    int32_t iStack16;\n    int32_t iStack12;\n    \n    iStack16 = 0;\n    cVar1 = *param_2;\n    piVar5 = param_3;\n    do {\n        if (cVar1 == '\\0') {\n            fcn.0041b4d5(iStack16);\n            fcn.00406690(*param_1, unaff_retaddr, param_1);\n            fcn.0041b524(0xffffffff);\n            return;\n        }\n        if (*param_2 == '%') {\n            param_2 = fcn.00406870(param_2);\n            cVar1 = *param_2;\n            if (cVar1 == '%') goto code_r0x0041559b;\n            iVar6 = 0;\n            param_3 = NULL;\n            piVar4 = piVar5;\n            while (cVar1 != '\\0') {\n                if (cVar1 == '#') {\n                    iStack16 = iStack16 + 2;\n                }\n                else if (cVar1 == '*') {\n                    param_3 = *piVar4;\n                    piVar4 = piVar4 + 1;\n                }\n                else if ((((cVar1 != '-') && (cVar1 != '+')) && (cVar1 != '0')) && (cVar1 != ' ')) break;\n                param_2 = fcn.00406870(param_2);\n                cVar1 = *param_2;\n            }\n            if (param_3 == NULL) {\n                param_3 = fcn.00406860(param_2);\n                while ((*param_2 != '\\0' && (iVar2 = fcn.00406720(*param_2),  iVar2 != 0))) {\n                    param_2 = fcn.00406870(param_2);\n                }\n            }\n            iStack12 = 0;\n            if (*param_2 == '.') {\n                param_2 = fcn.00406870(param_2);\n                if (*param_2 == '*') {\n                    iStack12 = *piVar4;\n                    piVar4 = piVar4 + 1;\n                    param_2 = fcn.00406870(param_2);\n                }\n                else {\n                    iStack12 = fcn.00406860(param_2);\n                    while ((*param_2 != '\\0' && (iVar2 = fcn.00406720(*param_2),  iVar2 != 0))) {\n                        param_2 = fcn.00406870(param_2);\n                    }\n                }\n            }\n            cVar1 = *param_2;\n            uVar3 = 0;\n            if (((cVar1 == 'F') || (cVar1 == 'L')) || (cVar1 == 'N')) {\ncode_r0x00415480:\n                param_2 = fcn.00406870(param_2);\n            }\n            else {\n                if (cVar1 == 'h') {\n                    uVar3 = 0x10000;\n                    goto code_r0x00415480;\n                }\n                if (cVar1 == 'l') {\n                    uVar3 = 0x20000;\n                    goto code_r0x00415480;\n                }\n            }\n            uVar3 = uVar3 | *param_2;\n            piVar5 = piVar4;\n            if (uVar3 < 0x54) {\n                if (uVar3 == 0x53) goto code_r0x004154df;\n                bVar7 = uVar3 == 0x43;\ncode_r0x004154ba:\n                if (bVar7) {\ncode_r0x00415513:\n                    iVar6 = 2;\n                    piVar5 = piVar4 + 1;\n                }\n            }\n            else {\n                if (0x73 < uVar3) {\n                    if (uVar3 < 0x10054) {\n                        if (uVar3 == 0x10053) goto code_r0x004154f2;\n                        bVar7 = uVar3 == 0x10043;\n                        goto code_r0x004154ba;\n                    }\n                    if (uVar3 != 0x10063) {\n                        if (uVar3 == 0x10073) goto code_r0x004154f2;\n                        if (uVar3 != 0x20043) {\n                            if (uVar3 != 0x20053) {\n                                if (uVar3 == 0x20063) goto code_r0x00415513;\n                                if (uVar3 != 0x20073) goto code_r0x00415519;\n                            }\ncode_r0x004154df:\n                            if (*piVar4 == 0) goto code_r0x004154fc;\n                            iVar6 = fcn.00406530(*piVar4);\n                            goto code_r0x00415507;\n                        }\n                    }\n                    goto code_r0x00415513;\n                }\n                if (uVar3 == 0x73) {\ncode_r0x004154f2:\n                    if (*piVar4 == 0) {\ncode_r0x004154fc:\n                        iVar6 = 6;\n                    }\n                    else {\n                        iVar6 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*piVar4);\ncode_r0x00415507:\n                        piVar5 = piVar4 + 1;\n                        if (0 < iVar6) goto code_r0x00415519;\n                        iVar6 = 1;\n                    }\n                    piVar5 = piVar4 + 1;\n                }\n                else if (uVar3 == 99) goto code_r0x00415513;\n            }\ncode_r0x00415519:\n            if (iVar6 == 0) {\n                cVar1 = *param_2;\n                if (cVar1 < 'Y') {\n                    if (cVar1 == 'X') {\ncode_r0x00415576:\n                        piVar5 = piVar5 + 1;\n                        iVar6 = 0x20;\n                    }\n                    else {\n                        if (cVar1 != 'G') goto code_r0x00415591;\ncode_r0x00415557:\n                        piVar5 = piVar5 + 2;\n                        iVar6 = 0x80;\n                    }\n                    iStack12 = iStack12 + param_3;\n                    bVar7 = SBORROW4(iStack12, iVar6);\n                    iVar2 = iStack12 - iVar6;\n                    goto code_r0x00415588;\n                }\n                if (cVar1 < 'j') {\n                    if ((cVar1 == 'i') || (cVar1 == 'd')) goto code_r0x00415576;\n                    if (('d' < cVar1) && (cVar1 < 'h')) goto code_r0x00415557;\n                }\n                else if (cVar1 == 'n') {\n                    piVar5 = piVar5 + 1;\n                }\n                else if (((cVar1 == 'o') || (cVar1 == 'p')) || ((cVar1 == 'u' || (cVar1 == 'x'))))\n                goto code_r0x00415576;\n            }\n            else {\n                if (iVar6 <= param_3) {\n                    iVar6 = param_3;\n                }\n                if (iStack12 == 0) goto code_r0x00415591;\n                bVar7 = SBORROW4(iVar6, iStack12);\n                iVar2 = iVar6 - iStack12;\ncode_r0x00415588:\n                if (bVar7 == iVar2 < 0) {\n                    iVar6 = iStack12;\n                }\n            }\ncode_r0x00415591:\n            iStack16 = iStack16 + iVar6;\n        }\n        else {\ncode_r0x0041559b:\n            iVar6 = fcn.00406700(param_2);\n            iStack16 = iStack16 + iVar6;\n        }\n        param_2 = fcn.00406870(param_2);\n        cVar1 = *param_2;\n    } while( true );\n}\n",
        "token_count": 1851
    },
    "00415ba0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00415ba0(int32_t arg_8h, uint32_t arg_ch, uint arg_10h, uint32_t arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    \n    if (arg_8h != 0) {\n        iVar1 = fcn.0042d88a(0x404495);\n        if (*(iVar1 + 0x18) != 0) {\n            fcn.0041ad96(arg_8h);\n            *(iVar1 + 0x18) = 0;\n        }\n        if (arg_ch == 0x110) {\n            uVar2 = fcn.00416c78(arg_8h, 0x110, arg_10h, arg_14h);\n            return uVar2;\n        }\n        if ((arg_ch == *0x4404c0) || ((arg_ch == 0x111 && (arg_10h == 0x40e)))) {\n            (*_sym.imp.USER32.dll_SendMessageA)(arg_8h, 0x111, 0xe146, 0);\n            return 1;\n        }\n        if (0xbfff < arg_ch) {\n            piVar3 = fcn.004181c4(arg_8h);\n            iVar1 = fcn.0041b739(0x434758);\n            if ((iVar1 == 0) || ((*(piVar3 + 0x92) & 8) == 0)) {\n                if (arg_ch == *0x4404b0) {\n                    uVar2 = (**(*piVar3 + 0xd8))(arg_14h);\n                    return uVar2;\n                }\n                if (arg_ch == *0x4404bc) {\n                    if (*0x4400ec != 0) {\n                        piVar3[0x7d] = arg_14h;\n                    }\n                    uVar2 = (**(*piVar3 + 0xdc))();\n                    piVar3[0x7d] = 0;\n                    return uVar2;\n                }\n                if (arg_ch == *0x4404b8) {\n                    (**(*piVar3 + 0xe0))(arg_10h, arg_14h & 0xffff, arg_14h >> 0x10);\n                }\n                else if (arg_ch == *0x4404b4) {\n                    uVar2 = (**(*piVar3 + 0xd8))();\n                    return uVar2;\n                }\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 572
    },
    "00415d8b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00415d8b(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    uint uStack8;\n    \n    if (*(param_1 + 0x10) == 0) {\n        uStack8 = 0xc;\n        iVar1 = fcn.00416120(param_1 + 0x14, *(param_1 + 0x18));\n        iVar3 = *(param_1 + 0x18);\n        puVar2 = iVar1 + -8 + iVar3 * 0xc;\n        if (-1 < iVar3 + -1) {\n            do {\n                *puVar2 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar2;\n                puVar2 = puVar2 + -3;\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n    }\n    puVar2 = *(param_1 + 0x10);\n    *(param_1 + 0x10) = *puVar2;\n    puVar2[1] = uStack8;\n    *puVar2 = unaff_ESI;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    puVar2[2] = 0;\n    return;\n}\n",
        "token_count": 319
    },
    "00416199": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00416199(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) != 0) {\n        fcn.004166cf(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    if (param_3 != 0) {\n        uVar1 = fcn.00416693(param_2 << 2);\n        *(param_1 + 4) = uVar1;\n        fcn.00406030(uVar1, 0, param_2 << 2);\n    }\n    *(param_1 + 8) = param_2;\n    return;\n}\n",
        "token_count": 169
    },
    "0041623d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041623d(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    \n    if (*(param_1 + 0x10) == 0) {\n        iVar2 = fcn.00416120(param_1 + 0x14, *(param_1 + 0x18), 0xc);\n        iVar4 = *(param_1 + 0x18);\n        puVar3 = iVar2 + -8 + iVar4 * 0xc;\n        if (-1 < iVar4 + -1) {\n            do {\n                *puVar3 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar3;\n                puVar3 = puVar3 + -3;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n    }\n    puVar3 = *(param_1 + 0x10);\n    uVar1 = *puVar3;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    *(param_1 + 0x10) = uVar1;\n    puVar3[1] = 0;\n    puVar3[2] = 0;\n    return;\n}\n",
        "token_count": 303
    },
    "0041644c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041644c(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) != 0) {\n        fcn.004166cf(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    if (param_3 != 0) {\n        uVar1 = fcn.00416693(param_2 << 2);\n        *(param_1 + 4) = uVar1;\n        fcn.00406030(uVar1, 0, param_2 << 2);\n    }\n    *(param_1 + 8) = param_2;\n    return;\n}\n",
        "token_count": 170
    },
    "00416517": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __fastcall fcn.00416517(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint arg_10h;\n    \n    if (*(param_1 + 0x10) == 0) {\n        iVar1 = fcn.00416120(param_1 + 0x14, *(param_1 + 0x18), 0x10);\n        iVar4 = *(param_1 + 0x18);\n        puVar2 = iVar4 * 0x10 + -0xc + iVar1;\n        if (-1 < iVar4 + -1) {\n            do {\n                *puVar2 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar2;\n                puVar2 = puVar2 + -4;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n    }\n    puVar2 = *(param_1 + 0x10);\n    arg_10h = 4;\n    uVar3 = *puVar2;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    *(param_1 + 0x10) = uVar3;\n    uVar3 = fcn.0041b0bb();\n    fcn.00405850(puVar2 + 2, uVar3, arg_10h);\n    puVar2[3] = 0;\n    return puVar2;\n}\n",
        "token_count": 352
    },
    "00416716": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00416716(void)\n\n{\n    uint uVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CCmdTarget.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[4] != NULL) {\n        (**(extraout_ECX[4] + 0x1c))();\n    }\n    uVar1 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.CObject.0;\n    *in_FS_OFFSET = uVar1;\n    return;\n}\n",
        "token_count": 210
    },
    "00416752": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00416752(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    uint32_t arg_ch_00;\n    int32_t *piVar4;\n    \n    if (arg_ch == 0xfffffffe) {\n        iVar1 = fcn.0042d07c();\n        arg_ch = (**(**(iVar1 + 0x1038) + 4))();\n    }\n    else {\n        arg_ch_00 = 0;\n        if (arg_ch == 0xfffffffd) {\n            arg_ch = 0;\n            iVar1 = *(arg_10h + 0x30);\n            puVar2 = (**(*in_ECX + 0x34))();\n            while ((puVar2 != NULL && (arg_ch == 0))) {\n                piVar4 = puVar2[1];\n                while (((piVar4[1] != 0 && (piVar4[2] != 0)) && (arg_ch == 0))) {\n                    if (arg_8h == piVar4[1]) {\n                        if (iVar1 == 0) {\n                            iVar3 = *piVar4;\n                        }\n                        else {\n                            if (*piVar4 == 0) goto code_r0x004167f7;\n                            iVar3 = fcn.00405f80(iVar1, *piVar4, 0x10);\n                        }\n                        if (iVar3 == 0) {\n                            arg_ch = 1;\n                            *(arg_10h + 4) = piVar4[2];\n                        }\n                    }\ncode_r0x004167f7:\n                    piVar4 = piVar4 + 3;\n                }\n                puVar2 = *puVar2;\n            }\n        }\n        else {\n            if (arg_ch != 0xffffffff) {\n                arg_ch_00 = arg_ch >> 0x10;\n                arg_ch = arg_ch & 0xffff;\n            }\n            if (arg_ch_00 == 0) {\n                arg_ch_00 = 0x111;\n            }\n            for (puVar2 = (**(*in_ECX + 0x30))(); puVar2 != NULL; puVar2 = *puVar2) {\n                iVar1 = fcn.004190c7(puVar2[1], arg_ch_00, arg_ch, arg_8h);\n                if (iVar1 != 0) {\n                    iVar1 = fcn.0041686a(in_ECX, arg_8h, arg_ch, *(iVar1 + 0x14), arg_10h, *(iVar1 + 0x10), arg_14h);\n                    return iVar1;\n                }\n            }\n            arg_ch = 0;\n        }\n    }\n    return arg_ch;\n}\n",
        "token_count": 642
    },
    "00417639": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417639(uint lpString2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalLock;\n    if (*(in_ECX + 0x98) != 0) {\n        var_4h = in_ECX;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(in_ECX + 0x98));\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(*(iVar2 + 2) + iVar2, lpString2);\n        if (iVar2 == 0) {\n            iVar2 = sub.WINSPOOL.DRV_OpenPrinterA(lpString2, &var_4h, 0);\n            if (iVar2 != 0) {\n                if (*(in_ECX + 0x94) != 0) {\n                    fcn.00420486(*(in_ECX + 0x94));\n                }\n                uVar3 = sub.WINSPOOL.DRV_DocumentPropertiesA(0, var_4h, lpString2, 0, 0, 0);\n                uVar3 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x42, uVar3);\n                *(in_ECX + 0x94) = uVar3;\n                uVar3 = (*pcVar1)(uVar3);\n                iVar2 = sub.WINSPOOL.DRV_DocumentPropertiesA(0, var_4h, lpString2, uVar3, 0, 2);\n                if (iVar2 != 1) {\n                    fcn.00420486(*(in_ECX + 0x94));\n                    *(in_ECX + 0x94) = 0;\n                }\n                sub.WINSPOOL.DRV_ClosePrinter(var_4h);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 428
    },
    "004176fb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.004176fb(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.0042d07c();\n    if (*(iVar1 + 0x14) == '\\0') {\n        iVar1 = fcn.0042cd29();\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        uVar2 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(0xffffffff, 0x417ae0, 0, uVar2);\n        *(iVar1 + 0x30) = uVar2;\n        iVar1 = fcn.0042d91f(0x4044c9);\n        if (*(iVar1 + 0x14) != 0) {\n            iVar3 = fcn.0042d07c();\n            (**(iVar1 + 0x14))(*(iVar3 + 8));\n        }\n        fcn.0042d88a(0x4044f9);\n    }\n    return;\n}\n",
        "token_count": 232
    },
    "0041776f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041776f(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    \n    bVar2 = true;\n    iVar1 = *param_1;\n    iVar5 = 0;\n    do {\n        if (bVar2) {\n            iVar4 = iVar5;\n            do {\n                iVar3 = (*_sym.imp.USER32.dll_PeekMessageA)(param_1 + 0xc, 0, 0, 0, 0);\n                iVar5 = iVar4;\n                if (iVar3 != 0) break;\n                iVar5 = iVar4 + 1;\n                iVar4 = (**(iVar1 + 0x68))(iVar4);\n                if (iVar4 == 0) {\n                    bVar2 = false;\n                }\n                iVar4 = iVar5;\n            } while (bVar2);\n        }\n        do {\n            iVar4 = (**(iVar1 + 100))();\n            if (iVar4 == 0) {\n                (**(iVar1 + 0x70))();\n                return;\n            }\n            iVar4 = (**(iVar1 + 0x6c))(param_1 + 0xc);\n            if (iVar4 != 0) {\n                iVar5 = 0;\n            }\n            iVar4 = (*_sym.imp.USER32.dll_PeekMessageA)(param_1 + 0xc, 0, 0, 0, 0);\n        } while (iVar4 != 0);\n    } while( true );\n}\n",
        "token_count": 356
    },
    "00417f30": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_40h\n\nuint fcn.00417f30(void)\n\n{\n    int32_t *arg_8h;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint *puVar4;\n    uint *puVar5;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h_2;\n    uint var_14h_2;\n    uint var_18h;\n    uint var_10h;\n    uint var_40h;\n    uint var_24h;\n    uint var_14h;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = &stack0xffffffc0;\n    iVar1 = fcn.0042d88a(0x404495);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x14) = iVar1;\n    puVar4 = iVar1 + 0x34;\n    puVar5 = unaff_EBP + -0x40;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n    }\n    iVar3 = *(unaff_EBP + 0x10);\n    arg_8h = *(unaff_EBP + 8);\n    *(iVar1 + 0x34) = *(unaff_EBP + 0xc);\n    *(iVar1 + 0x3c) = *(unaff_EBP + 0x14);\n    uVar2 = *(unaff_EBP + 0x18);\n    *(iVar1 + 0x38) = iVar3;\n    *(iVar1 + 0x40) = uVar2;\n    if ((iVar3 == 2) && (arg_8h[0xd] != NULL)) {\n        (**(*arg_8h[0xd] + 100))(0);\n    }\n    if (iVar3 == 0x110) {\n        fcn.00418020(arg_8h, unaff_EBP + -0x24, unaff_EBP + 0xc);\n    }\n    uVar2 = (**(*arg_8h + 0xa0))(iVar3, *(unaff_EBP + 0x14), *(unaff_EBP + 0x18));\n    *(unaff_EBP + 8) = uVar2;\n    if (iVar3 == 0x110) {\n        fcn.00418043(arg_8h, unaff_EBP + -0x24);\n    }\n    uVar2 = *(unaff_EBP + 8);\n    puVar4 = unaff_EBP + -0x40;\n    puVar5 = iVar1 + 0x34;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 761
    },
    "0041812c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0041812c(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    iVar1 = fcn.0042d0a2();\n    if ((*(iVar1 + 0x14) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.0041667f(0x4204bc);\n        iVar3 = fcn.00416693(0x44);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0041d8eb(0x431b48, 0x1c, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x14) = uVar4;\n        fcn.0041667f(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x14);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 354
    },
    "0041851f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041851f(int32_t arg_8h, uint arg_ch, int32_t *arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    code *pcVar9;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = fcn.0042d88a(0x404495);\n    if (arg_8h != 3) {\n        uVar3 = (*_sym.imp.USER32.dll_CallNextHookEx)(*(iVar2 + 0x2c), arg_8h, arg_ch, arg_10h);\n        return uVar3;\n    }\n    piVar1 = *(iVar2 + 0x14);\n    if ((piVar1 == NULL) && (((*(*arg_10h + 0x23) & 0x40) != 0 || (iVar4 = fcn.0042d07c(),  *(iVar4 + 0x14) != '\\0'))))\n    goto code_r0x0041867b;\n    if (piVar1 == NULL) {\n        iVar4 = (*_sym.imp.USER32.dll_GetWindowLongA)(arg_ch, 0xfffffffc);\n        if (iVar4 != 0) {\n            (*_sym.imp.USER32.dll_SetPropA)(arg_ch, \"AfxOldWndProc\", iVar4);\n            iVar6 = (*_sym.imp.USER32.dll_GetPropA)(arg_ch, \"AfxOldWndProc\");\n            if (iVar6 == iVar4) {\n                pcVar9 = fcn.004184a3;\n                if (*(iVar2 + 0x28) == 0) {\n                    pcVar9 = fcn.0041827d;\n                }\n                (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, pcVar9);\n            }\n        }\n        goto code_r0x0041867b;\n    }\n    fcn.004181e0(arg_ch);\n    iVar4 = *piVar1;\n    (**(iVar4 + 0x58))();\n    piVar5 = (**(iVar4 + 0x88))();\n    if ((((*0x4400ec == 0) && (iVar6 = fcn.0042d07c(),  iVar4 = *0x440478,  *(iVar6 + 0x14) == '\\0')) &&\n        (*0x440478 != 0)) &&\n       ((*(*0x440478 + 0x20) != 0 && (iVar6 = fcn.00417f30(piVar1, arg_ch, 0x36f, 0, 0),  iVar6 != 0)))) {\n        iVar7 = fcn.00418277();\n        iVar8 = (*_sym.imp.USER32.dll_GetWindowLongA)(arg_ch, 0xfffffffc);\n        (**(iVar4 + 0x20))(arg_ch, iVar6);\n        if (iVar8 != iVar7) {\n            iVar6 = (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, iVar7);\ncode_r0x00418626:\n            *piVar5 = iVar6;\n        }\n    }\n    else {\n        iVar4 = fcn.00418277();\n        iVar6 = (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, iVar4);\n        if (iVar6 != iVar4) goto code_r0x00418626;\n    }\n    *(iVar2 + 0x14) = 0;\ncode_r0x0041867b:\n    uVar3 = (*_sym.imp.USER32.dll_CallNextHookEx)(*(iVar2 + 0x2c), 3, arg_ch, arg_10h);\n    iVar4 = fcn.0042d07c();\n    if (*(iVar4 + 0x14) != '\\0') {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar2 + 0x2c));\n        *(iVar2 + 0x2c) = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 943
    },
    "004186ad": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.004186ad(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    \n    iVar1 = fcn.0042d88a(0x404495);\n    if (*(iVar1 + 0x14) != unaff_retaddr) {\n        if (*(iVar1 + 0x2c) == 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n            iVar3 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(5, fcn.0041851f, 0, uVar2);\n            *(iVar1 + 0x2c) = iVar3;\n            if (iVar3 == 0) {\n                fcn.00415699();\n            }\n        }\n        *(iVar1 + 0x14) = unaff_retaddr;\n    }\n    return;\n}\n",
        "token_count": 204
    },
    "004186f9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.004186f9(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar1 = fcn.0042d88a(0x404495);\n    iVar2 = fcn.0042d07c();\n    if ((*(iVar2 + 0x14) != '\\0') && (*(iVar1 + 0x2c) != 0)) {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar1 + 0x2c));\n        *(iVar1 + 0x2c) = 0;\n    }\n    if (*(iVar1 + 0x14) != 0) {\n        *(iVar1 + 0x14) = 0;\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 174
    },
    "0041887d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041887d(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CWnd.0;\n    *(unaff_EBP + -4) = 0;\n    if ((((extraout_ECX[7] != NULL) && (extraout_ECX != 0x43fe38)) && (extraout_ECX != 0x43fef8)) &&\n       ((extraout_ECX != 0x43fe78 && (extraout_ECX != 0x43feb8)))) {\n        fcn.00418a40();\n    }\n    if (extraout_ECX[0xd] != NULL) {\n        (**(*extraout_ECX[0xd] + 4))(1);\n    }\n    pcVar1 = extraout_ECX[0xe];\n    if ((pcVar1 != NULL) && (*(pcVar1 + 0x24) == extraout_ECX)) {\n        *(pcVar1 + 0x24) = 0;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00416716();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 349
    },
    "00418a40": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00418a40(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if (*(param_1 + 0x1c) == 0) {\n        return 0;\n    }\n    fcn.0041812c(0);\n    iVar1 = fcn.004162d2(*(param_1 + 0x1c));\n    if (*(param_1 + 0x38) == NULL) {\n        uVar2 = (*_sym.imp.USER32.dll_DestroyWindow)(*(param_1 + 0x1c));\n    }\n    else {\n        uVar2 = (**(**(param_1 + 0x38) + 0x58))();\n    }\n    if (iVar1 == 0) {\n        fcn.00418219();\n    }\n    return uVar2;\n}\n",
        "token_count": 191
    },
    "00418af7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00418af7(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    \n    iVar4 = fcn.0042cd29();\n    iVar1 = *(iVar4 + 0xcc);\n    if (iVar1 == 0) {\n        iVar5 = 0;\n    }\n    else {\n        iVar5 = *(iVar1 + 0x1c);\n    }\n    if (iVar5 != 0) {\n        (*_sym.imp.USER32.dll_SendMessageA)(*(iVar1 + 0x1c), 0x401, 0, 0);\n    }\n    piVar2 = *(iVar4 + 0x108);\n    if ((param_1 != 0) && (piVar2 != NULL)) {\n        iVar3 = (*_sym.imp.USER32.dll_GetKeyState)(1);\n        if (-1 < iVar3) {\n            (**(*piVar2 + 0xe4))(0xffffffff);\n        }\n    }\n    return;\n}\n",
        "token_count": 244
    },
    "00418e48": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.00418e48(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpWndClass;\n    uint var_9h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    iVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &stack0xffffffc4;\n    iVar4 = (*_sym.imp.USER32.dll_GetClassInfoA)(*(iVar1 + 0x10), *(iVar1 + 0x24), unaff_EBP + -0x38);\n    if (iVar4 == 0) {\n        iVar3 = (*_sym.imp.USER32.dll_RegisterClassA)(iVar1);\n        if (iVar3 == 0) {\n            uVar5 = 0;\n            goto code_r0x00418eca;\n        }\n        iVar4 = fcn.0042d07c();\n        if (*(iVar4 + 0x14) != '\\0') {\n            fcn.0042d3e7(1);\n            *(unaff_EBP + -4) = 0;\n            iVar4 = fcn.0042d07c();\n            pcVar2 = _sym.imp.KERNEL32.dll_lstrcatA;\n            (*_sym.imp.KERNEL32.dll_lstrcatA)(iVar4 + 0x34, *(iVar1 + 0x24));\n            *(unaff_EBP + 9) = 0;\n            *(unaff_EBP + 8) = 10;\n            (*pcVar2)(iVar4 + 0x34, unaff_EBP + 8);\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0042d457(1);\n        }\n    }\n    uVar5 = 1;\ncode_r0x00418eca:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar5;\n}\n",
        "token_count": 575
    },
    "004190c7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.004190c7(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    while( true ) {\n        if (arg_8h[4] == 0) {\n            return NULL;\n        }\n        if ((((arg_ch == *arg_8h) && (arg_10h == arg_8h[1])) && (arg_8h[2] <= arg_14h)) &&\n           (arg_14h < arg_8h[3] || arg_14h == arg_8h[3])) break;\n        arg_8h = arg_8h + 6;\n    }\n    return arg_8h;\n}\n",
        "token_count": 168
    },
    "00419149": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING (jumptable): Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_60h\n\nuint __cdecl fcn.00419149(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint8_t uVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int32_t *arg_8h_00;\n    uint *puVar9;\n    uint *puVar10;\n    int32_t unaff_EBP;\n    int16_t iVar11;\n    uint *in_FS_OFFSET;\n    uint uVar12;\n    uint var_60h;\n    uint var_44h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = 0;\n    uVar6 = *(unaff_EBP + 8);\n    if (uVar6 == 0x111) {\n        iVar5 = (**(*arg_8h_00 + 0x80))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n        if (iVar5 != 0) {\ncode_r0x0041959d:\n            *(unaff_EBP + -0x10) = 1;\n            goto code_r0x004195e3;\n        }\ncode_r0x004192cb:\n        uVar12 = 0;\n        goto code_r0x004192cd;\n    }\n    if (uVar6 == 0x4e) {\n        if (**(unaff_EBP + 0x10) != 0) {\n            iVar5 = (**(*arg_8h_00 + 0x84))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), unaff_EBP + -0x10);\ncode_r0x004195c1:\n            if (iVar5 != 0) goto code_r0x004195e3;\n        }\n        goto code_r0x004192cb;\n    }\n    puVar9 = *(unaff_EBP + 0x10);\n    if (uVar6 == 6) {\n        uVar12 = fcn.0041819c(puVar9);\n        fcn.004183ca(arg_8h_00, *(unaff_EBP + 0xc), uVar12);\n    }\n    iVar11 = puVar9;\n    if ((uVar6 == 0x20) && (iVar5 = fcn.0041842b(arg_8h_00, iVar11, puVar9 >> 0x10),  iVar5 != 0))\n    goto code_r0x0041959d;\n    uVar12 = (**(*arg_8h_00 + 0x30))();\n    *(unaff_EBP + -0x14) = uVar12;\n    fcn.0042d3e7(7);\n    uVar8 = *(unaff_EBP + 8);\n    uVar6 = uVar6 & 0x1ff ^ *(unaff_EBP + -0x14) & 0x1ff;\n    iVar5 = uVar6 * 0xc;\n    iVar7 = *(unaff_EBP + -0x14);\n    if ((uVar8 != *(uVar6 * 0xc + 0x43e638)) || (iVar7 != *(iVar5 + 0x43e640))) {\n        *(iVar5 + 0x43e638) = uVar8;\n        *(iVar5 + 0x43e640) = iVar7;\n        if (iVar7 != 0) {\n            while( true ) {\n                if (uVar8 < 0xc000) {\n                    iVar7 = fcn.004190c7(*(iVar7 + 4), uVar8, 0, 0);\n                    *(unaff_EBP + 0x10) = iVar7;\n                    if (iVar7 != 0) {\n                        uVar12 = 7;\n                        *(iVar5 + 0x43e63c) = iVar7;\n                        fcn.0042d457(7);\n                        iVar5 = *(unaff_EBP + 0x10);\n                        goto code_r0x004192eb;\n                    }\n                }\n                else {\n                    iVar7 = fcn.004190c7(*(iVar7 + 4), 0xc000, 0, 0);\n                    *(unaff_EBP + 0x10) = iVar7;\n                    if (iVar7 != 0) {\n                        while( true ) {\n                            if (**(iVar7 + 0x10) == *(unaff_EBP + 8)) {\n                                *(iVar5 + 0x43e63c) = iVar7;\n                                fcn.0042d457(7);\n                                iVar5 = *(unaff_EBP + 0x10);\n                                goto code_r0x004195d7;\n                            }\n                            iVar7 = fcn.004190c7(iVar7 + 0x18, 0xc000, 0, 0);\n                            *(unaff_EBP + 0x10) = iVar7;\n                            if (iVar7 == 0) break;\n                            iVar7 = *(unaff_EBP + 0x10);\n                        }\n                    }\n                }\n                iVar7 = **(unaff_EBP + -0x14);\n                *(unaff_EBP + -0x14) = iVar7;\n                if (iVar7 == 0) break;\n                uVar8 = *(unaff_EBP + 8);\n                iVar7 = *(unaff_EBP + -0x14);\n            }\n        }\n        *(iVar5 + 0x43e63c) = 0;\n        fcn.0042d457(7);\n        goto code_r0x004192cb;\n    }\n    iVar5 = *(iVar5 + 0x43e63c);\n    uVar12 = 7;\n    *(unaff_EBP + 0x10) = iVar5;\n    fcn.0042d457();\n    if (iVar5 == 0) goto code_r0x004192cb;\n    if (0xbfff < *(unaff_EBP + 8)) {\ncode_r0x004195d7:\n        uVar12 = (**(iVar5 + 0x14))(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x004195e0;\n    }\ncode_r0x004192eb:\n    iVar7 = *(unaff_EBP + 0x10);\n    pcVar1 = *(iVar5 + 0x14);\n    iVar5 = *(iVar7 + 0x10);\n    if (*(iVar7 + 8) == 0x1a) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetVersion)(uVar12);\n        iVar7 = *(unaff_EBP + 0x10);\n        iVar5 = (-(uVar3 < 4) & 0xfffffff0) + 0x2f;\n    }\n    iVar4 = puVar9 >> 0x10;\n    // switch table (49 cases) at 0x4195f7\n    switch(iVar5) {\n    case 1:\n        puVar9 = *(unaff_EBP + 0xc);\n        fcn.0041f487(puVar9);\n        goto code_r0x00419421;\n    case 2:\n        puVar9 = *(unaff_EBP + 0xc);\n        goto code_r0x00419421;\n    case 3:\n    case 8:\n        uVar8 = puVar9 >> 0x10;\n        puVar9 = iVar11;\n        uVar6 = *(unaff_EBP + 0xc);\n        uVar8 = fcn.0041819c(uVar6, puVar9, uVar8);\n        goto code_r0x0041943c;\n    case 4:\n        fcn.0041f3d3();\n        uVar12 = puVar9[1];\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x20) = uVar12;\n        fcn.00417e33();\n        uVar12 = *puVar9;\n        uVar2 = puVar9[2];\n        *(unaff_EBP + -4) = 1;\n        *(unaff_EBP + -0x44) = uVar12;\n        iVar5 = fcn.004181c4(uVar12);\n        if (iVar5 == 0) {\n            if ((arg_8h_00[0xd] != 0) && (iVar5 = fcn.004162d2(*(unaff_EBP + -0x44)),  iVar5 != 0)) {\n                *(unaff_EBP + -0x28) = iVar5;\n            }\n            iVar5 = unaff_EBP + -0x60;\n        }\n        uVar12 = (*pcVar1)(unaff_EBP + -0x24, iVar5, uVar2);\n        *(unaff_EBP + -0x20) = 0;\n        *(unaff_EBP + -0x44) = 0;\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x10) = uVar12;\n        fcn.0041887d();\n        *(unaff_EBP + -4) = 0xffffffff;\n        goto code_r0x004193e3;\n    case 5:\n        fcn.0041f3d3();\n        uVar12 = puVar9[2];\n        *(unaff_EBP + -0x20) = puVar9[1];\n        *(unaff_EBP + -4) = 2;\n        uVar12 = (*pcVar1)(unaff_EBP + -0x24, uVar12);\n        *(unaff_EBP + -0x20) = 0;\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(unaff_EBP + -0x10) = uVar12;\ncode_r0x004193e3:\n        fcn.0041f505();\n        goto code_r0x004195e3;\n    case 6:\n        uVar6 = fcn.0041819c(puVar9, *(unaff_EBP + 0xc) >> 0x10);\n        goto code_r0x00419437;\n    case 7:\n        puVar9 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar6 = *(unaff_EBP + 0xc);\n        goto code_r0x00419552;\n    case 9:\n    case 0x2a:\ncode_r0x00419421:\n        uVar12 = (*pcVar1)(puVar9);\n        goto code_r0x004195e0;\n    case 10:\n    case 0x21:\n        uVar6 = *(unaff_EBP + 0xc);\n        goto code_r0x00419552;\n    case 0xb:\n        puVar9 = fcn.0041b68e(puVar9);\n        uVar6 = *(unaff_EBP + 0xc) >> 0x10;\ncode_r0x00419437:\n        uVar8 = *(unaff_EBP + 0xc);\ncode_r0x0041943c:\n        uVar12 = (*pcVar1)(uVar8, uVar6, puVar9);\n        goto code_r0x004195e0;\n    case 0xc:\n        (*pcVar1)();\n        goto code_r0x004195e3;\n    case 0xd:\n        puVar9 = *(unaff_EBP + 0xc);\n        break;\n    case 0xe:\n    case 0x12:\n    case 0x25:\n    case 0x2f:\n        goto code_r0x00419562;\n    case 0xf:\n        puVar10 = iVar4;\n        iVar5 = iVar11;\n        goto code_r0x00419565;\n    case 0x10:\n    case 0x11:\n        puVar10 = puVar9 >> 0x10;\n        uVar6 = puVar9 & 0xffff;\n        goto code_r0x0041958b;\n    case 0x13:\n        puVar10 = *(unaff_EBP + 0xc);\n        uVar6 = fcn.0041819c(puVar10);\n        fcn.0041819c(puVar9, uVar6);\n        uVar8 = arg_8h_00[7] == puVar9;\n        goto code_r0x0041958f;\n    case 0x14:\n        puVar9 = *(unaff_EBP + 0xc);\n        fcn.0041f487(puVar9);\n        break;\n    case 0x15:\n        puVar9 = *(unaff_EBP + 0xc);\n        fcn.0041b68e(puVar9);\n        break;\n    case 0x16:\n        puVar10 = puVar9 >> 0x10;\n        uVar6 = puVar9 & 0xffff;\n        uVar8 = fcn.0041b68e(*(unaff_EBP + 0xc), uVar6, puVar10);\n        goto code_r0x0041958f;\n    case 0x17:\n        puVar9 = *(unaff_EBP + 0xc);\n        goto code_r0x004194c4;\n    case 0x18:\n        puVar10 = puVar9 >> 0x10;\n        uVar6 = puVar9 & 0xffff;\n        goto code_r0x004194e4;\n    case 0x19:\n        uVar6 = iVar11;\n        puVar10 = iVar4;\ncode_r0x004194e4:\n        uVar8 = fcn.0041819c(*(unaff_EBP + 0xc), uVar6, puVar10);\n        goto code_r0x0041958f;\n    case 0x1a:\n        iVar5 = fcn.0041819c(*(unaff_EBP + 0xc), puVar9);\n        puVar10 = puVar9;\n        goto code_r0x00419565;\n    case 0x1b:\n        fcn.0041819c(puVar9);\ncode_r0x00419562:\n        iVar5 = *(unaff_EBP + 0xc);\n        puVar10 = puVar9;\n        goto code_r0x00419565;\n    case 0x1c:\n        puVar10 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar6 = fcn.0041819c(puVar9, puVar10);\n        goto code_r0x00419579;\n    case 0x1d:\n    case 0x1e:\n        iVar5 = *(unaff_EBP + 0xc);\n        iVar7 = *(iVar7 + 0x10);\n        *(unaff_EBP + 8) = iVar5;\n        puVar10 = *(unaff_EBP + 0xc) >> 0x10;\n        *(unaff_EBP + 0xc) = puVar10;\n        if (iVar7 == 0x1d) {\n            uVar6 = fcn.0041819c(puVar9);\n            uVar8 = *(unaff_EBP + 0xc);\n            puVar10 = puVar9;\n            goto code_r0x0041958f;\n        }\ncode_r0x00419565:\n        (*pcVar1)(iVar5, puVar10);\n        goto code_r0x004195e3;\n    case 0x1f:\n    case 0x24:\n        break;\n    case 0x20:\n    case 0x2b:\n        (*pcVar1)(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x0041959d;\n    case 0x22:\n        uVar6 = iVar11;\n        puVar9 = iVar4;\n        goto code_r0x00419552;\n    case 0x23:\n        uVar12 = (*pcVar1)();\n        goto code_r0x004195e0;\n    default:\n        goto code_r0x004195e3;\n    case 0x2c:\ncode_r0x004194c4:\n        fcn.0041819c(puVar9);\n        break;\n    case 0x2d:\n        uVar6 = fcn.0041819c(puVar9, puVar9);\ncode_r0x00419552:\n        uVar12 = (*pcVar1)(uVar6, puVar9);\ncode_r0x004195e0:\n        *(unaff_EBP + -0x10) = uVar12;\n        goto code_r0x004195e3;\n    case 0x2e:\n        iVar5 = (*pcVar1)(*(unaff_EBP + 0xc), *(unaff_EBP + 0xc) >> 0x10, puVar9 & 0xffff, puVar9 >> 0x10);\n        *(unaff_EBP + -0x10) = iVar5;\n        goto code_r0x004195c1;\n    case 0x30:\n        uVar6 = *(unaff_EBP + 0xc) >> 0x10;\n        puVar10 = puVar9;\ncode_r0x00419579:\n        uVar8 = *(unaff_EBP + 0xc);\n        goto code_r0x0041958f;\n    case 0x31:\n        uVar6 = iVar11;\n        puVar10 = iVar4;\ncode_r0x0041958b:\n        uVar8 = *(unaff_EBP + 0xc);\ncode_r0x0041958f:\n        (*pcVar1)(uVar8, uVar6, puVar10);\n        goto code_r0x004195e3;\n    }\n    (*pcVar1)(puVar9);\ncode_r0x004195e3:\n    if (*(unaff_EBP + 0x14) != NULL) {\n        **(unaff_EBP + 0x14) = *(unaff_EBP + -0x10);\n    }\n    uVar12 = 1;\ncode_r0x004192cd:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar12;\n}\n",
        "token_count": 4155
    },
    "00419abe": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00419abe(uint arg_8h, uint Msg, uint wParam, uint lParam, int32_t arg_18h, int32_t arg_1ch)\n\n{\n    code *pcVar1;\n    int32_t arg_8h_00;\n    int32_t iVar2;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    for (arg_8h_00 = (*_sym.imp.USER32.dll_GetTopWindow)(arg_8h); arg_8h_00 != 0;\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetWindow)(arg_8h_00, 2)) {\n        if (arg_1ch == 0) {\n            (*_sym.imp.USER32.dll_SendMessageA)(arg_8h_00, Msg, wParam, lParam);\n        }\n        else {\n            iVar2 = fcn.004181c4(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.00417f30(iVar2, *(iVar2 + 0x1c), Msg, wParam, lParam);\n            }\n        }\n        if (arg_18h != 0) {\n            iVar2 = (*pcVar1)(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.00419abe(arg_8h_00, Msg, wParam, lParam, arg_18h, arg_1ch);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 328
    },
    "00419bcb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00419bcb(int32_t *param_1, int32_t param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    uint unaff_ESI;\n    \n    if (param_2 == 3) {\n        fcn.00419bcb(0, param_3);\n        param_2 = 1;\n    }\n    iVar1 = (**(*param_1 + 0x70))(param_2);\n    if (iVar1 == 0) {\n        (*_sym.imp.USER32.dll_ShowScrollBar)(param_1[7], param_2, unaff_ESI);\n    }\n    else {\n        fcn.0041affe();\n    }\n    return;\n}\n",
        "token_count": 158
    },
    "00419c0e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00419c0e(int32_t *param_1, int32_t param_2, uint *param_3, uint param_4)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    if (*0x4400e4 < 0x333) {\n        uVar1 = 0;\n    }\n    else {\n        iVar3 = param_1[7];\n        if (param_2 != 2) {\n            iVar2 = (**(*param_1 + 0x70))(param_2);\n            if (iVar2 != 0) {\n                iVar3 = *(iVar2 + 0x1c);\n                param_2 = 2;\n            }\n        }\n        *param_3 = 0x1c;\n        (*_sym.imp.USER32.dll_SetScrollInfo)(iVar3, param_2, param_3, param_4);\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 222
    },
    "00419c5b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00419c5b(int32_t XAmount, int32_t YAmount, int32_t arg_10h, int32_t lpClipRect)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t Y;\n    uint hWndInsertAfter;\n    \n    iVar2 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(in_ECX + 0x1c));\n    if (((iVar2 == 0) && (arg_10h == 0)) && (lpClipRect == 0)) {\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(*(in_ECX + 0x1c), 5);\n        pcVar1 = _sym.imp.USER32.dll_ScreenToClient;\n        for (; iVar2 != 0; iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2)) {\n            (*_sym.imp.USER32.dll_GetWindowRect)(iVar2, &lpRect);\n            (*pcVar1)(*(in_ECX + 0x1c), &lpRect);\n            (*pcVar1)(*(in_ECX + 0x1c), &hWndInsertAfter);\n            (*_sym.imp.USER32.dll_SetWindowPos)(iVar2, 0, lpRect + XAmount, Y + YAmount, 0, 0, 0x15);\n        }\n    }\n    else {\n        (*_sym.imp.USER32.dll_ScrollWindow)(*(in_ECX + 0x1c), XAmount, YAmount, arg_10h, lpClipRect);\n    }\n    if ((*(in_ECX + 0x34) != NULL) && (arg_10h == 0)) {\n        (**(**(in_ECX + 0x34) + 0x60))(XAmount, YAmount);\n    }\n    return;\n}\n",
        "token_count": 418
    },
    "00419d18": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.00419d18(uint32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h, int32_t arg_14h, int32_t *lprcDst, int32_t *arg_1ch, \n            int32_t arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t in_ECX;\n    int32_t hWinPosInfo;\n    int32_t lprcSrc;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    var_8h = arg_20h;\n    var_ch = 0;\n    var_10h = 0;\n    if (arg_1ch == NULL) {\n        (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lprcSrc);\n    }\n    else {\n        lprcSrc = *arg_1ch;\n        var_1ch = arg_1ch[1];\n        var_18h = arg_1ch[2];\n        var_14h = arg_1ch[3];\n    }\n    if (arg_14h == 1) {\n        hWinPosInfo = 0;\n    }\n    else {\n        hWinPosInfo = (*_sym.imp.USER32.dll_BeginDeferWindowPos)(8);\n    }\n    for (iVar2 = (*_sym.imp.USER32.dll_GetTopWindow)(*(in_ECX + 0x1c)); iVar2 != 0;\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2)) {\n        uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(iVar2);\n        uVar3 = uVar3 & 0xffff;\n        iVar4 = fcn.004181c4(iVar2);\n        iVar1 = iVar2;\n        if ((((uVar3 != arg_10h) && (iVar1 = var_4h,  arg_8h <= uVar3)) && (uVar3 <= arg_ch)) && (iVar4 != 0)) {\n            (*_sym.imp.USER32.dll_SendMessageA)(iVar2, 0x361, 0, &hWinPosInfo);\n            iVar1 = var_4h;\n        }\n        var_4h = iVar1;\n    }\n    if (arg_14h == 1) {\n        if (arg_20h == 0) {\n            lprcDst[2] = var_10h;\n            lprcDst[1] = 0;\n            *lprcDst = 0;\n            lprcDst[3] = var_ch;\n        }\n        else {\n            (*_sym.imp.USER32.dll_CopyRect)(lprcDst, &lprcSrc);\n        }\n    }\n    else {\n        if ((arg_10h != 0) && (var_4h != 0)) {\n            piVar5 = fcn.0041819c(var_4h);\n            if (arg_14h == 2) {\n                lprcSrc = lprcSrc + *lprcDst;\n                var_1ch = var_1ch + lprcDst[1];\n                var_18h = var_18h - lprcDst[2];\n                var_14h = var_14h - lprcDst[3];\n            }\n            (**(*piVar5 + 0x68))(&lprcSrc, 0);\n            fcn.00419e52(&hWinPosInfo, var_4h, &lprcSrc);\n        }\n        if (hWinPosInfo != 0) {\n            (*_sym.imp.USER32.dll_EndDeferWindowPos)(hWinPosInfo);\n        }\n    }\n    return;\n}\n",
        "token_count": 906
    },
    "00419e52": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00419e52(int32_t *arg_8h, uint hWnd, int32_t *lprc2)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint lpRect;\n    uint var_8h;\n    \n    uVar3 = (*_sym.imp.USER32.dll_GetParent)(hWnd);\n    if ((arg_8h == NULL) || (*arg_8h != 0)) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(hWnd, &lpRect);\n        pcVar2 = _sym.imp.USER32.dll_ScreenToClient;\n        (*_sym.imp.USER32.dll_ScreenToClient)(uVar3, &lpRect);\n        (*pcVar2)(uVar3, &var_8h);\n        iVar4 = (*_sym.imp.USER32.dll_EqualRect)(&lpRect, lprc2);\n        if (iVar4 == 0) {\n            iVar4 = lprc2[1];\n            iVar1 = *lprc2;\n            if (arg_8h == NULL) {\n                (*_sym.imp.USER32.dll_SetWindowPos)(hWnd, 0, iVar1, iVar4, lprc2[2] - iVar1, lprc2[3] - iVar4, 0x14);\n            }\n            else {\n                iVar4 = (*_sym.imp.USER32.dll_DeferWindowPos)\n                                  (*arg_8h, hWnd, 0, iVar1, iVar4, lprc2[2] - iVar1, lprc2[3] - iVar4);\n                *arg_8h = iVar4;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 382
    },
    "00419eec": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00419eec(uint param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    \n    uVar1 = fcn.0041ae95();\n    if (param_2 == 0) {\n        uVar1 = uVar1 & 0xfffffdff;\n    }\n    uVar2 = fcn.0041ae7b(0, uVar1);\n    (*_sym.imp.USER32.dll_AdjustWindowRectEx)(param_1, uVar2);\n    return;\n}\n",
        "token_count": 122
    },
    "00419f17": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00419f17(uint32_t wParam, int32_t lParam)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    uint32_t uVar7;\n    uint hWnd;\n    \n    iVar4 = fcn.0041987d();\n    uVar7 = wParam & 0xfff0;\n    if ((uVar7 == 0xf040) || (uVar7 == 0xf050)) {\n        if (lParam != 0x75) {\n            return 0;\n        }\n        if (iVar4 == 0) {\n            return 0;\n        }\n        fcn.0041b025();\n    }\n    else {\n        if ((uVar7 != 0xf060) && (uVar7 != 0xf100)) {\n            return 0;\n        }\n        if (((uVar7 == 0xf060) || (lParam != 0)) && (iVar4 != 0)) {\n            uVar1 = *(in_ECX + 0x1c);\n            uVar5 = (*_sym.imp.USER32.dll_GetFocus)();\n            pcVar2 = _sym.imp.USER32.dll_SetActiveWindow;\n            uVar6 = (*_sym.imp.USER32.dll_SetActiveWindow)(*(iVar4 + 0x1c));\n            fcn.0041819c(uVar6);\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar4 + 0x1c), 0x112, wParam, lParam);\n            pcVar3 = _sym.imp.USER32.dll_IsWindow;\n            iVar4 = (*_sym.imp.USER32.dll_IsWindow)(uVar1);\n            if (iVar4 != 0) {\n                (*pcVar2)(uVar1);\n            }\n            iVar4 = (*pcVar3)(uVar5);\n            if (iVar4 != 0) {\n                (*_sym.imp.USER32.dll_SetFocus)(uVar5);\n            }\n        }\n    }\n    return 1;\n}\n",
        "token_count": 459
    },
    "0041a0e4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041a0e4(uint32_t arg_8h, uint wParam, uint lParam, int32_t *arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x38) == 0) {\n        iVar1 = fcn.0041a13f(arg_8h, wParam, lParam, arg_14h);\n    }\n    else {\n        iVar1 = (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), arg_8h + 0x2000, wParam, lParam);\n        if (((arg_8h < 0x132) || (0x138 < arg_8h)) || (iVar1 != 0)) {\n            if (arg_14h != NULL) {\n                *arg_14h = iVar1;\n            }\n            iVar1 = 1;\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 217
    },
    "0041a5a8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041a5a8(int32_t hdc, uint arg_ch, int32_t arg_10h, int32_t hgdiobj, int32_t arg_18h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint lpvObject;\n    uint crColor;\n    \n    if ((((hdc == 0) || (hgdiobj == 0)) || (arg_10h == 1)) || ((arg_10h == 0 || (arg_10h == 5)))) {\ncode_r0x0041a617:\n        uVar2 = 0;\n    }\n    else {\n        if (arg_10h == 2) {\n            iVar1 = fcn.004202b4(arg_ch, 2);\n            if (iVar1 == 0) goto code_r0x0041a617;\n        }\n        (*_sym.imp.GDI32.dll_GetObjectA)(hgdiobj, 0xc, &lpvObject);\n        (*_sym.imp.GDI32.dll_SetBkColor)(hdc, crColor);\n        if (arg_18h == -1) {\n            arg_18h = (*_sym.imp.USER32.dll_GetSysColor)(8);\n        }\n        (*_sym.imp.GDI32.dll_SetTextColor)(hdc, arg_18h);\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 307
    },
    "0041a936": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_74h\n\nvoid __cdecl fcn.0041a936(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_74h;\n    uint hWnd;\n    uint var_38h;\n    uint var_34h;\n    uint var_24h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00416a51();\n    fcn.00417e33();\n    uVar1 = *(extraout_ECX + 0x1c);\n    *(unaff_EBP + -4) = 0;\n    iVar2 = (*_sym.imp.USER32.dll_GetTopWindow)(uVar1);\n    do {\n        if (iVar2 == 0) {\n            *(unaff_EBP + -4) = 0xffffffff;\n            *(unaff_EBP + -0x58) = 0;\n            fcn.0041887d();\n            *in_FS_OFFSET = *(unaff_EBP + -0xc);\n            return;\n        }\n        *(unaff_EBP + -0x58) = iVar2;\n        uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(iVar2);\n        *(unaff_EBP + -0x34) = uVar3 & 0xffff;\n        *(unaff_EBP + -0x24) = unaff_EBP + -0x74;\n        iVar4 = fcn.004181c4(iVar2);\n        if (((iVar4 == 0) || (iVar4 = fcn.00416752(0, 0xbd11ffff, unaff_EBP + -0x38, 0),  iVar4 == 0)) &&\n           (iVar4 = fcn.00416752(*(unaff_EBP + -0x34), 0xffffffff, unaff_EBP + -0x38, 0),  iVar4 == 0)) {\n            iVar4 = *(unaff_EBP + 0xc);\n            if (iVar4 != 0) {\n                uVar3 = (*_sym.imp.USER32.dll_SendMessageA)(*(unaff_EBP + -0x58), 0x87, 0, 0);\n                if ((uVar3 & 0x2000) != 0) {\n                    uVar3 = fcn.0041ae7b();\n                    uVar3 = uVar3 & 0xf;\n                    if (((uVar3 != 3) && (uVar3 != 6)) && ((uVar3 != 7 && (uVar3 != 9)))) goto code_r0x0041a9fc;\n                }\n                iVar4 = 0;\n            }\ncode_r0x0041a9fc:\n            fcn.00416c11(*(unaff_EBP + 8), iVar4);\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2);\n    } while( true );\n}\n",
        "token_count": 728
    },
    "0041ad96": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0041ad96(int32_t *param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    uint unaff_retaddr;\n    \n    iVar1 = fcn.004181e0(param_2);\n    if (iVar1 != 0) {\n        iVar1 = *param_1;\n        (**(iVar1 + 0x58))();\n        piVar2 = (**(iVar1 + 0x88))();\n        uVar3 = fcn.00418277();\n        iVar1 = (*_sym.imp.USER32.dll_SetWindowLongA)(unaff_retaddr, 0xfffffffc, uVar3);\n        if (*piVar2 == 0) {\n            *piVar2 = iVar1;\n        }\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 199
    },
    "0041b046": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041b046(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    if ((param_1 != 0) && (*(param_1 + 0x38) == 0)) {\n        uVar1 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x1c));\n        iVar2 = fcn.004162d2(uVar1);\n        if (iVar2 != 0) {\n            fcn.0041b076(iVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 130
    },
    "0041b076": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041b076(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    if ((((param_1 != 0) && (*(param_1 + 0x38) == 0)) && (param_2 != 0)) && (*(param_2 + 0x34) != 0)) {\n        iVar2 = fcn.004162d2(*(param_1 + 0x1c));\n        if (iVar2 != 0) {\n            iVar1 = *(iVar2 + 0x24);\n            if ((iVar1 != 0) && (*(iVar1 + 0x38) == iVar2)) {\n                *(iVar1 + 0x38) = 0;\n            }\n            *(param_1 + 0x38) = iVar2;\n            *(iVar2 + 0x24) = param_1;\n        }\n    }\n    return;\n}\n",
        "token_count": 215
    },
    "0041b0d1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.0041b0d1(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    iVar1 = *param_2;\n    if (*(iVar1 + -0xc) < 0) {\n        piVar2 = fcn.0041b0bb();\n        *param_1 = *piVar2;\n        fcn.0041b354(*param_2);\n    }\n    else {\n        *param_1 = iVar1;\n        (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(iVar1 + -0xc);\n    }\n    return param_1;\n}\n",
        "token_count": 156
    },
    "0041b197": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041b197(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    if (*(*param_1 + -8) != 0) {\n        if (-1 < *(*param_1 + -0xc)) {\n            if (*param_1 + -0xc != *0x43a860) {\n                iVar1 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(*param_1 + -0xc);\n                if (iVar1 < 1) {\n                    fcn.004166cf(*param_1 + -0xc);\n                }\n                piVar2 = fcn.0041b0bb();\n                *param_1 = *piVar2;\n            }\n            return;\n        }\n        fcn.0041b354(0x43ff58);\n    }\n    return;\n}\n",
        "token_count": 193
    },
    "0041b1b5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041b1b5(int32_t *param_1)\n\n{\n    int32_t arg_ch;\n    \n    arg_ch = *param_1;\n    if (1 < *(arg_ch + -0xc)) {\n        fcn.0041b142();\n        fcn.0041b108(*(arg_ch + -8));\n        fcn.00405850(*param_1, arg_ch, *(arg_ch + -8) + 1);\n    }\n    return;\n}\n",
        "token_count": 109
    },
    "0041b1e3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041b1e3(int32_t *param_1, int32_t param_2)\n\n{\n    if ((1 < *(*param_1 + -0xc)) || (*(*param_1 + -4) < param_2)) {\n        fcn.0041b142();\n        fcn.0041b108(param_2);\n    }\n    return;\n}\n",
        "token_count": 87
    },
    "0041b305": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.0041b305(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    iVar1 = *param_2;\n    if (*param_1 != iVar1) {\n        piVar2 = *param_1 + -0xc;\n        if (((*piVar2 < 0) && (piVar2 != *0x43a860)) || (*(iVar1 + -0xc) < 0)) {\n            fcn.0041b2d8(*(iVar1 + -8), iVar1);\n        }\n        else {\n            fcn.0041b142();\n            iVar1 = *param_2;\n            *param_1 = iVar1;\n            (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(iVar1 + -0xc);\n        }\n    }\n    return param_1;\n}\n",
        "token_count": 204
    },
    "0041b422": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041b422(int32_t *param_1, int32_t param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    if (param_2 != 0) {\n        iVar1 = *param_1;\n        if ((*(iVar1 + -0xc) < 2) && (param_2 + *(iVar1 + -8) <= *(iVar1 + -4))) {\n            fcn.00405850(*(iVar1 + -8) + iVar1, param_3, param_2);\n            *(*param_1 + -8) = *(*param_1 + -8) + param_2;\n            *(*(*param_1 + -8) + *param_1) = 0;\n        }\n        else {\n            fcn.0041b37b(*(iVar1 + -8), iVar1, param_2, param_3);\n            fcn.0041b174(iVar1 + -0xc);\n        }\n    }\n    return;\n}\n",
        "token_count": 223
    },
    "0041b4d5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0041b4d5(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t arg_ch;\n    int32_t iVar1;\n    \n    arg_ch = *param_1;\n    if ((1 < *(arg_ch + -0xc)) || (*(arg_ch + -4) < param_2)) {\n        iVar1 = *(arg_ch + -8);\n        if (param_2 < iVar1) {\n            param_2 = iVar1;\n        }\n        fcn.0041b108(param_2);\n        fcn.00405850(*param_1, arg_ch, iVar1 + 1);\n        *(*param_1 + -8) = iVar1;\n        fcn.0041b174(arg_ch + -0xc);\n    }\n    return *param_1;\n}\n",
        "token_count": 186
    },
    "0041b5ac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0041b5ac(int32_t param_1, uint param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    \n    if ((param_3 == 0) && (param_1 != 0)) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, param_2, 0xffffffff, param_1, param_3);\n    if (0 < iVar1) {\n        *(param_1 + -2 + iVar1 * 2) = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 143
    },
    "0041b61e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0041b61e(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    iVar1 = fcn.0042d0a2();\n    if ((*(iVar1 + 0x18) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.0041667f(0x4204bc);\n        iVar3 = fcn.00416693(0x44);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0041d8eb(0x4332f0, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x18) = uVar4;\n        fcn.0041667f(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x18);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 353
    },
    "0041b717": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0041b717(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.0041b6ed();\n    uVar1 = (*_sym.imp.USER32.dll_DestroyMenu)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 88
    },
    "0041b74b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0041b74b(uint param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    if (param_2 != 0) {\n        iVar1 = fcn.0041b739(param_1);\n        if (iVar1 != 0) {\n            return param_1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 83
    },
    "0041b896": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041b896(void)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CFile.0;\n    pcVar2 = extraout_ECX[1];\n    *(unaff_EBP + -4) = 1;\n    if ((pcVar2 != 0xffffffff) && (extraout_ECX[2] != NULL)) {\n        fcn.0041bb9b();\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.0041b20c();\n    uVar1 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.CObject.0;\n    *in_FS_OFFSET = uVar1;\n    return;\n}\n",
        "token_count": 255
    },
    "0041c20a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041c20a(char *lpString1, uint lpString2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint var_618h;\n    uint var_410h;\n    uint var_208h;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(lpString1, lpString2);\n    if (iVar2 == 0) {\n        iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x2a);\n        pcVar1 = _sym.imp.KERNEL32.dll_lstrlenA;\n        if (iVar2 != 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString1);\n            iVar3 = (*pcVar1)(lpString2);\n            if (iVar2 != iVar3) goto code_r0x0041c2c9;\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetThreadLocale)();\n            pcVar1 = _sym.imp.KERNEL32.dll_GetStringTypeExA;\n            (*_sym.imp.KERNEL32.dll_GetStringTypeExA)(uVar4, 1, lpString1, 0xffffffff, &var_208h);\n            (*pcVar1)(uVar4, 4, lpString1, 0xffffffff, &var_410h);\n            (*pcVar1)(uVar4, 1, lpString2, 0xffffffff, &var_618h);\n            if (*lpString1 != '\\0') {\n                iVar2 = 0;\n                do {\n                    if (((*(&var_410h + iVar2) & 0x80) != 0) && (*(&var_208h + iVar2) != *(&var_618h + iVar2)))\n                    goto code_r0x0041c2c9;\n                    iVar2 = iVar2 + 2;\n                    lpString1 = fcn.00406870(lpString1);\n                } while (*lpString1 != '\\0');\n            }\n        }\n        uVar4 = 1;\n    }\n    else {\ncode_r0x0041c2c9:\n        uVar4 = 0;\n    }\n    return uVar4;\n}\n",
        "token_count": 493
    },
    "0041c46b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041c46b(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    uVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0xb);\n    *(param_1 + 8) = uVar2;\n    uVar2 = (*pcVar1)(0xc);\n    *(param_1 + 0xc) = uVar2;\n    if (*(param_1 + 0x68) == 0) {\n        fcn.0042d1ea();\n    }\n    else {\n        fcn.0042d1ba();\n    }\n    uVar2 = (*_sym.imp.USER32.dll_GetDC)(0);\n    pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n    uVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(uVar2, 0x58);\n    *(param_1 + 0x18) = uVar3;\n    uVar3 = (*pcVar1)(uVar2, 0x5a);\n    *(param_1 + 0x1c) = uVar3;\n    (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar2);\n    return;\n}\n",
        "token_count": 293
    },
    "0041c4c3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0041c4c3(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_104h;\n    uint var_4h;\n    \n    iVar1 = fcn.0041c547(arg_8h, &var_104h, 0x100);\n    if (0x100U - iVar1 < 3) {\n        iVar2 = 0x100;\n        do {\n            iVar3 = iVar2 + 0x100;\n            fcn.0041b4d5(iVar2 + 0xff, iVar3);\n            iVar1 = fcn.0041c547();\n            iVar2 = iVar3;\n        } while (iVar3 - iVar1 < 3);\n        fcn.0041b524(0xffffffff);\n    }\n    else {\n        fcn.0041b354(&var_104h);\n    }\n    return 0 < iVar1;\n}\n",
        "token_count": 217
    },
    "0041c5e6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0041c5e6(int32_t param_1, uint param_2)\n\n{\n    uint arg_8h;\n    int32_t arg_10h;\n    \n    if (param_1 != 0) {\n        arg_10h = param_1;\n        arg_8h = fcn.0041c728(param_1, param_1, param_2);\n        fcn.0041c6a7(arg_8h, param_1, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 117
    },
    "0041ca90": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041ca90(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    int32_t in_ECX;\n    uint lpLastWriteTime;\n    uint lpLastAccessTime;\n    uint lpCreationTime;\n    \n    fcn.00406030(arg_8h, 0, 0x118);\n    (*_sym.imp.KERNEL32.dll_lstrcpynA)(arg_8h + 0x12, *(in_ECX + 0xc), 0x104);\n    if (*(in_ECX + 4) == -1) {\ncode_r0x0041cb60:\n        uVar2 = 1;\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetFileTime)\n                          (*(in_ECX + 4), &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n        if (iVar1 != 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetFileSize)(*(in_ECX + 4), 0);\n            arg_8h[3] = iVar1;\n            if (iVar1 != -1) {\n                if (*(*(in_ECX + 0xc) + -8) == 0) {\ncode_r0x0041cb0f:\n                    *(arg_8h + 4) = 0;\n                }\n                else {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_GetFileAttributesA)(*(in_ECX + 0xc));\n                    if (iVar1 == -1) goto code_r0x0041cb0f;\n                    *(arg_8h + 4) = iVar1;\n                }\n                piVar3 = fcn.00415767(&lpCreationTime, 0xffffffff);\n                *arg_8h = *piVar3;\n                piVar3 = fcn.00415767(&lpLastAccessTime, 0xffffffff);\n                arg_8h[2] = *piVar3;\n                piVar3 = fcn.00415767(&lpLastWriteTime, 0xffffffff);\n                iVar1 = *piVar3;\n                arg_8h[1] = iVar1;\n                if (*arg_8h == 0) {\n                    *arg_8h = iVar1;\n                }\n                if (arg_8h[2] == 0) {\n                    arg_8h[2] = arg_8h[1];\n                }\n                goto code_r0x0041cb60;\n            }\n        }\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 578
    },
    "0041cb6a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0041cb6a(uint lpFileName, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint lpFindFileData;\n    uint var_13ch;\n    uint var_134h;\n    uint var_12ch;\n    int32_t var_120h;\n    \n    iVar1 = fcn.0041c06b(arg_ch + 0x12, lpFileName);\n    if (iVar1 == 0) {\n        *(arg_ch + 0x12) = 0;\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_FindFirstFileA)(lpFileName, &lpFindFileData);\n        if (iVar1 != -1) {\n            (*_sym.imp.KERNEL32.dll_FindClose)(iVar1);\n            *(arg_ch + 4) = lpFindFileData & 0x7f;\n            arg_ch[3] = var_120h;\n            piVar2 = fcn.00415767(&var_13ch, 0xffffffff);\n            *arg_ch = *piVar2;\n            piVar2 = fcn.00415767(&var_134h, 0xffffffff);\n            arg_ch[2] = *piVar2;\n            piVar2 = fcn.00415767(&var_12ch, 0xffffffff);\n            iVar1 = *piVar2;\n            arg_ch[1] = iVar1;\n            if (*arg_ch == 0) {\n                *arg_ch = iVar1;\n            }\n            if (arg_ch[2] == 0) {\n                arg_ch[2] = arg_ch[1];\n            }\n            return 1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 389
    },
    "0041ceea": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041ceea(uint lpMultiByteStr, uint arg_ch)\n\n{\n    uint uVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    ushort *puVar4;\n    uint *in_ECX;\n    int32_t iVar5;\n    char cVar6;\n    int32_t iVar7;\n    uint32_t arg_8h;\n    uint lpWideCharStr;\n    ushort *var_10h;\n    uint32_t var_ch;\n    uint *hMem;\n    uint32_t var_4h;\n    \n    if (in_ECX[1] == 0) {\n        uVar1 = 0;\n    }\n    else {\n        hMem = in_ECX;\n        puVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*in_ECX);\n        var_4h = *(puVar2 + 2) == -1;\n        if (*(puVar2 + 2) == -1) {\n            var_ch = puVar2[3];\n        }\n        else {\n            var_ch = *puVar2;\n        }\n        var_ch = var_ch & 0x40;\n        iVar7 = (-(var_4h != 0) & 2) + 1;\n        if (var_4h == 0) {\n            *puVar2 = *puVar2 | 0x40;\n        }\n        else {\n            puVar2[3] = puVar2[3] | 0x40;\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, lpMultiByteStr, 0xffffffff, &lpWideCharStr, 0x20);\n        iVar3 = iVar7 * 2 + iVar3 * 2;\n        puVar4 = fcn.0041cd6e(puVar2);\n        iVar5 = 0;\n        var_10h = puVar4;\n        if (var_ch != 0) {\n            iVar5 = fcn.00406530(puVar4 + iVar7);\n            iVar5 = iVar7 * 2 + 2 + iVar5 * 2;\n        }\n        var_ch = iVar5 + 3 + puVar4 & 0xfffffffc;\n        arg_8h = puVar4 + iVar3 + 3 & 0xfffffffc;\n        if (var_4h == 0) {\n            cVar6 = *(puVar2 + 2);\n        }\n        else {\n            cVar6 = *(puVar2 + 4);\n        }\n        if ((iVar3 != iVar5) && (cVar6 != '\\0')) {\n            fcn.00406890(arg_8h, var_ch, puVar2 + (hMem[1] - var_ch));\n        }\n        *var_10h = arg_ch;\n        fcn.00406890(var_10h + iVar7, &lpWideCharStr, iVar3 + iVar7 * -2);\n        hMem[1] = hMem[1] + (arg_8h - var_ch);\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*hMem);\n        hMem[2] = 0;\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 711
    },
    "0041d001": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041d001(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    char *lpMultiByteStr;\n    int32_t lpvObject;\n    uint var_24h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.GDI32.dll_GetStockObject;\n    uVar4 = 10;\n    lpMultiByteStr = \"System\";\n    iVar2 = (*_sym.imp.GDI32.dll_GetStockObject)(0x11);\n    if (iVar2 == 0) {\n        iVar2 = (*pcVar1)(0xd);\n        if (iVar2 == 0) goto code_r0x0041d075;\n    }\n    iVar2 = (*_sym.imp.GDI32.dll_GetObjectA)(iVar2, 0x3c, &lpvObject);\n    if (iVar2 != 0) {\n        lpMultiByteStr = &var_24h;\n        uVar3 = (*_sym.imp.USER32.dll_GetDC)(0);\n        if (lpvObject < 0) {\n            lpvObject = -lpvObject;\n        }\n        uVar4 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(uVar3, 0x5a);\n        uVar4 = (*_sym.imp.KERNEL32.dll_MulDiv)(lpvObject, 0x48, uVar4);\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar3);\n    }\ncode_r0x0041d075:\n    if (arg_8h == 0) {\n        arg_8h = uVar4;\n    }\n    fcn.0041ceea(lpMultiByteStr, arg_8h);\n    return;\n}\n",
        "token_count": 394
    },
    "0041d2aa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041d2aa(uint arg_8h, int32_t arg_ch, uint lpString1, int32_t arg_14h, uint arg_18h)\n\n{\n    uchar uVar1;\n    uint uVar2;\n    int32_t lpString;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    bool bVar5;\n    uint lpString2;\n    int32_t var_4h;\n    \n    if (*(*(*(in_ECX + 8) + arg_ch * 4) + -8) == 0) {\n        uVar2 = 0;\n    }\n    else {\n        var_4h = in_ECX;\n        lpString = fcn.0041b4d5(0x104);\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(lpString, *(*(var_4h + 8) + arg_ch * 4));\n        iVar3 = fcn.0042e1c1(lpString, 0, 0);\n        iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n        iVar4 = (1 - iVar3) + iVar4;\n        bVar5 = false;\n        if (iVar4 == arg_14h) {\n            uVar1 = *(lpString + iVar4);\n            *(lpString + arg_14h) = 0;\n            iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(lpString1, lpString);\n            bVar5 = iVar3 == 0;\n            *(lpString + iVar4) = uVar1;\n        }\n        if (bVar5) {\n            fcn.0041c2cd(lpString + arg_14h, &lpString2, 0x104);\n            (*_sym.imp.KERNEL32.dll_lstrcpynA)(lpString, &lpString2, 0x104);\n        }\n        else if (*(var_4h + 0x18) != -1) {\n            fcn.0041c2cd(lpString + iVar4, &lpString2, 0x104);\n            (*_sym.imp.KERNEL32.dll_lstrcpynA)(lpString + iVar4, &lpString2, 0x104 - iVar4);\n            fcn.0041d717(lpString, *(var_4h + 0x18), arg_18h);\n        }\n        fcn.0041b524(0xffffffff);\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 560
    },
    "0041d717": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041d717(char *lpString, int32_t arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    char *pcVar4;\n    char *pcVar5;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n    iVar3 = fcn.0042e1c1(lpString, 0, 0);\n    iVar3 = iVar3 + -1;\n    pcVar4 = lpString + (iVar2 - iVar3);\n    if (arg_ch < iVar2) {\n        if (arg_ch < iVar3) {\n            if (arg_10h == 0) {\n                pcVar4 = 0x43ff58;\n            }\n        }\n        else {\n            pcVar5 = lpString + 2;\n            if ((*lpString == '\\\\') && (lpString[1] == '\\\\')) {\n                for (; *pcVar5 != '\\\\'; pcVar5 = fcn.00406870(pcVar5)) {\n                }\n            }\n            if (3 < iVar2 - iVar3) {\n                do {\n                    pcVar5 = fcn.00406870(pcVar5);\n                } while (*pcVar5 != '\\\\');\n            }\n            pcVar1 = _sym.imp.KERNEL32.dll_lstrlenA;\n            iVar2 = pcVar5 - lpString;\n            if (iVar2 + 5 + iVar3 <= arg_ch) {\n                while (iVar3 = (*pcVar1)(pcVar5),  arg_ch < iVar3 + 4 + iVar2) {\n                    do {\n                        pcVar5 = fcn.00406870(pcVar5);\n                    } while (*pcVar5 != '\\\\');\n                }\n                lpString[iVar2] = '\\0';\n                pcVar1 = _sym.imp.KERNEL32.dll_lstrcatA;\n                (*_sym.imp.KERNEL32.dll_lstrcatA)(lpString, \"\\\\...\");\n                (*pcVar1)(lpString, pcVar5);\n                return;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(lpString, pcVar4);\n    }\n    return;\n}\n",
        "token_count": 493
    },
    "0041d7fd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0041d7fd(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint var_4h;\n    \n    iVar1 = fcn.0042d0a2();\n    if ((*(iVar1 + 0x10) != 0) && (iVar2 = *(iVar1 + 0x10) + -1,  *(iVar1 + 0x10) = iVar2,  iVar2 == 0)) {\n        iVar3 = fcn.004176e6();\n        iVar2 = fcn.0042d07c();\n        iVar2 = *(iVar2 + 4);\n        if (arg_8h != 0) {\n            if (((arg_8h != -1) && (iVar3 != 0)) && (*(iVar3 + 0x54) != NULL)) {\n                (**(iVar3 + 0x54))(0, 0);\n            }\n            fcn.0041fcce();\n            fcn.0041f403();\n            fcn.0041b60a();\n            fcn.00418118();\n            fcn.00405228();\n        }\n        iVar3 = fcn.0042d88a(0x404495);\n        if (((iVar2 != 0) && ((*(iVar3 + 0xc) == 0 || (uVar4 = fcn.004072e0(*(iVar3 + 0xc)),  uVar4 < *(iVar2 + 0xb8))))\n            ) && (*(iVar2 + 0xb8) != 0)) {\n            iVar6 = 0;\n            if (*(iVar3 + 0xc) != 0) {\n                iVar6 = fcn.004072e0(*(iVar3 + 0xc));\n                fcn.00405f10(*(iVar3 + 0xc));\n            }\n            iVar2 = fcn.00405e40(*(iVar2 + 0xb8));\n            *(iVar3 + 0xc) = iVar2;\n            if ((iVar2 == 0) && (iVar6 != 0)) {\n                uVar5 = fcn.00405e40(iVar6);\n                *(iVar3 + 0xc) = uVar5;\n            }\n        }\n    }\n    return *(iVar1 + 0x10) != 0;\n}\n",
        "token_count": 540
    },
    "0041d947": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nint32_t __cdecl\nfcn.0041d947(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint *puVar4;\n    int32_t *piVar5;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    uint uStack4;\n    \n    uStack4 = 0x41d951;\n    fcn.004056b0();\n    arg_8h_00 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &fcn.0041d947::var_1ch;\n    *(unaff_EBP + -0x1c) = extraout_ECX;\n    if (arg_8h_00 == 0) {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = fcn.004162d2(arg_8h_00);\n        if (iVar2 == 0) {\n            iVar2 = fcn.004162d2(arg_8h_00);\n            if (iVar2 == 0) {\n                uVar3 = fcn.0041667f(0x4204bc);\n                *(unaff_EBP + -4) = 0;\n                *(unaff_EBP + -0x18) = uVar3;\n                iVar2 = fcn.0041b76b();\n                *(unaff_EBP + -0x14) = iVar2;\n                if (iVar2 == 0) {\n                    fcn.00415699();\n                }\n                puVar4 = fcn.00416305(arg_8h_00);\n                *puVar4 = *(unaff_EBP + -0x14);\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.0041667f(*(unaff_EBP + -0x18));\n                piVar5 = *(extraout_ECX + 0x3c) + *(unaff_EBP + -0x14);\n                *piVar5 = arg_8h_00;\n                if (*(extraout_ECX + 0x40) == 2) {\n                    piVar5[1] = arg_8h_00;\n                }\n                iVar2 = *(unaff_EBP + -0x14);\n            }\n            else {\n                iVar1 = *(extraout_ECX + 0x3c);\n                *(iVar1 + iVar2) = arg_8h_00;\n                if (*(extraout_ECX + 0x40) == 2) {\n                    *(iVar1 + iVar2 + 4) = arg_8h_00;\n                }\n            }\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 766
    },
    "0041dbe2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041dbe2(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 0x34);\n    while (iVar1 != 0) {\n        iVar1 = fcn.00415e22();\n        *(iVar1 + 0x3c) = 0;\n        iVar1 = *(param_1 + 0x34);\n    }\n    return;\n}\n",
        "token_count": 98
    },
    "0041f039": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0041f039(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBX;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetParent;\n    uVar2 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x1c));\n    uVar2 = fcn.0041819c(uVar2);\n    iVar3 = fcn.0041b739(0x431de0);\n    if (iVar3 != 0) {\n        if (unaff_EBX != 0) {\n            return uVar2;\n        }\n        do {\n            uVar4 = (*pcVar1)(*(param_1 + 0x1c));\n            param_1 = fcn.0041819c(uVar4);\n            if (param_1 == 0) {\n                return uVar2;\n            }\n            iVar3 = (*_sym.imp.USER32.dll_IsIconic)(*(param_1 + 0x1c));\n        } while (iVar3 == 0);\n    }\n    return 0;\n}\n",
        "token_count": 260
    },
    "0041f417": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0041f417(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    iVar1 = fcn.0042d0a2();\n    if ((*(iVar1 + 0x1c) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.0041667f(0x4204bc);\n        iVar3 = fcn.00416693(0x44);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0041d8eb(0x433640, 4, 2);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x1c) = uVar4;\n        fcn.0041667f(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x1c);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 353
    },
    "0041f505": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041f505(void)\n\n{\n    uint uVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDC.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[1] != NULL) {\n        uVar1 = fcn.0041f4d4();\n        (*_sym.imp.GDI32.dll_DeleteDC)(uVar1);\n    }\n    uVar1 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.CObject.0;\n    *in_FS_OFFSET = uVar1;\n    return;\n}\n",
        "token_count": 223
    },
    "0041fce2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0041fce2(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    iVar1 = fcn.0042d0a2();\n    if ((*(iVar1 + 0x20) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.0041667f(0x4204bc);\n        iVar3 = fcn.00416693(0x44);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0041d8eb(0x4336a0, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x20) = uVar4;\n        fcn.0041667f(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x20);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 352
    },
    "0041fdbf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0041fdbf(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.0041fd95();\n    uVar1 = (*_sym.imp.GDI32.dll_DeleteObject)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 88
    },
    "0041fecc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041fecc(void)\n\n{\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *(unaff_EBP + -4) = 0;\n    if ((*(extraout_ECX + 0x20) != 0) && ((*(extraout_ECX + 0x14) & 2) == 0)) {\n        fcn.0041ff54();\n    }\n    fcn.0041ff12();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041b20c();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 219
    },
    "0041ff62": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041ff62(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    if (arg_ch == 0) {\n        iVar1 = 0;\n    }\n    else {\n        uVar3 = *(in_ECX + 0x28) - *(in_ECX + 0x24);\n        if (arg_ch < uVar3) {\n            uVar3 = arg_ch;\n        }\n        fcn.00405850(arg_8h, *(in_ECX + 0x24), uVar3);\n        *(in_ECX + 0x24) = *(in_ECX + 0x24) + uVar3;\n        arg_8h = arg_8h + uVar3;\n        uVar3 = arg_ch - uVar3;\n        if (uVar3 != 0) {\n            iVar1 = uVar3 - uVar3 % *(in_ECX + 0x1c);\n            var_8h = 0;\n            var_4h = iVar1;\n            do {\n                iVar2 = (**(**(in_ECX + 0x20) + 0x3c))(arg_8h, var_4h);\n                arg_8h = arg_8h + iVar2;\n                var_8h = var_8h + iVar2;\n                var_4h = var_4h - iVar2;\n                if (iVar2 == 0) break;\n            } while (var_4h != 0);\n            uVar3 = uVar3 - var_8h;\n            if (var_8h == iVar1) {\n                uVar4 = 0;\n                if (*(in_ECX + 8) == 0) {\n                    var_4h = uVar3;\n                    if (uVar3 <= *(in_ECX + 0x1c)) {\n                        var_4h = *(in_ECX + 0x1c);\n                    }\n                    var_8h = *(in_ECX + 0x2c);\n                    do {\n                        iVar1 = (**(**(in_ECX + 0x20) + 0x3c))(var_8h, var_4h);\n                        var_8h = var_8h + iVar1;\n                        var_4h = var_4h - iVar1;\n                        uVar4 = uVar4 + iVar1;\n                        if ((iVar1 == 0) || (var_4h == 0)) break;\n                    } while (uVar4 < uVar3);\n                    iVar1 = *(in_ECX + 0x2c);\n                    *(in_ECX + 0x24) = iVar1;\n                    *(in_ECX + 0x28) = uVar4 + iVar1;\n                }\n                else {\n                    (**(**(in_ECX + 0x20) + 0x58))(0, *(in_ECX + 0x1c), in_ECX + 0x2c, in_ECX + 0x28);\n                    iVar1 = *(in_ECX + 0x2c);\n                    *(in_ECX + 0x24) = iVar1;\n                }\n                uVar4 = *(in_ECX + 0x28) - iVar1;\n                if (uVar3 < uVar4) {\n                    uVar4 = uVar3;\n                }\n                fcn.00405850(arg_8h, iVar1, uVar4);\n                *(in_ECX + 0x24) = *(in_ECX + 0x24) + uVar4;\n                uVar3 = uVar3 - uVar4;\n            }\n        }\n        iVar1 = arg_ch - uVar3;\n    }\n    return iVar1;\n}\n",
        "token_count": 871
    },
    "00420070": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00420070(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    uint32_t arg_10h;\n    int32_t iVar1;\n    \n    if (arg_ch != 0) {\n        arg_10h = *(in_ECX + 0x28) - *(in_ECX + 0x24);\n        if (arg_ch < arg_10h) {\n            arg_10h = arg_ch;\n        }\n        fcn.00405850(*(in_ECX + 0x24), arg_8h, arg_10h);\n        *(in_ECX + 0x24) = *(in_ECX + 0x24) + arg_10h;\n        arg_ch = arg_ch - arg_10h;\n        if (arg_ch != 0) {\n            fcn.00420100();\n            iVar1 = arg_ch - arg_ch % *(in_ECX + 0x1c);\n            (**(**(in_ECX + 0x20) + 0x40))(arg_8h + arg_10h, iVar1);\n            if (*(in_ECX + 8) != 0) {\n                (**(**(in_ECX + 0x20) + 0x58))(1, *(in_ECX + 0x1c), in_ECX + 0x2c, in_ECX + 0x28);\n                *(in_ECX + 0x24) = *(in_ECX + 0x2c);\n            }\n            fcn.00405850(*(in_ECX + 0x24), arg_8h + arg_10h + iVar1, arg_ch - iVar1);\n            *(in_ECX + 0x24) = *(in_ECX + 0x24) + (arg_ch - iVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 413
    },
    "0042017a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042017a(uint32_t arg_8h)\n\n{\n    uint32_t arg_ch;\n    uint32_t uVar1;\n    uint32_t arg_8h_00;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    arg_ch = *(in_ECX + 0x24);\n    var_4h = *(in_ECX + 0x28) - arg_ch;\n    uVar1 = arg_8h + var_4h;\n    if (*(in_ECX + 8) == 0) {\n        arg_8h_00 = *(in_ECX + 0x2c);\n        if (arg_8h_00 < arg_ch) {\n            if (0 < var_4h) {\n                fcn.00406890(arg_8h_00, arg_ch, var_4h);\n                arg_8h_00 = *(in_ECX + 0x2c);\n                *(in_ECX + 0x24) = arg_8h_00;\n                *(in_ECX + 0x28) = var_4h + arg_8h_00;\n            }\n            iVar3 = *(in_ECX + 0x1c) - var_4h;\n            iVar4 = var_4h + arg_8h_00;\n            do {\n                iVar2 = (**(**(in_ECX + 0x20) + 0x3c))(iVar4, iVar3);\n                var_4h = var_4h + iVar2;\n                iVar4 = iVar4 + iVar2;\n                iVar3 = iVar3 - iVar2;\n                if ((iVar2 == 0) || (iVar3 == 0)) break;\n            } while (var_4h < arg_8h);\n            *(in_ECX + 0x24) = *(in_ECX + 0x2c);\n            *(in_ECX + 0x28) = var_4h + *(in_ECX + 0x2c);\n        }\n    }\n    else {\n        if (var_4h != 0) {\n            (**(**(in_ECX + 0x20) + 0x30))(-var_4h, 1);\n        }\n        (**(**(in_ECX + 0x20) + 0x58))(0, *(in_ECX + 0x1c), in_ECX + 0x2c, in_ECX + 0x28);\n        *(in_ECX + 0x24) = *(in_ECX + 0x2c);\n    }\n    if (*(in_ECX + 0x28) - *(in_ECX + 0x24) < uVar1) {\n        fcn.0041f358(3, 0);\n    }\n    return;\n}\n",
        "token_count": 647
    },
    "004202b4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004202b4(int32_t hWnd, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint lpClassName;\n    \n    if ((hWnd != 0) && (uVar1 = (*_sym.imp.USER32.dll_GetWindowLongA)(hWnd, 0xfffffff0),  (uVar1 & 0xf) == arg_ch)) {\n        (*_sym.imp.USER32.dll_GetClassNameA)(hWnd, &lpClassName, 10);\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(&lpClassName, \"combobox\");\n        return iVar2 == 0;\n    }\n    return false;\n}\n",
        "token_count": 157
    },
    "00420b46": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00420b46(int32_t hKey)\n\n{\n    int32_t iVar1;\n    uint var_11ch;\n    uint lpVersionInformation;\n    uint32_t var_98h;\n    int32_t var_8ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((hKey != 0) || (*0x440480 == 0)) {\n        *0x440480 = 1;\n        if (*0x44048c == 0) {\n            *0x440488 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(\"MSH_SCROLL_LINES_MSG\");\n            *0x44048c = (*0x440488 != 0) + 1;\n        }\n        if (((*0x44048c == 2) && (iVar1 = (*_sym.imp.USER32.dll_FindWindowA)(\"MouseZ\", \"Magellan MSWHEEL\"),  iVar1 != 0)\n            ) && (*0x440488 != 0)) {\n            *0x440484 = (*_sym.imp.USER32.dll_SendMessageA)(iVar1, *0x440488, 0, 0);\n        }\n        else {\n            fcn.00406030(&lpVersionInformation, 0, 0x94);\n            lpVersionInformation = 0x94;\n            *0x440484 = 3;\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n            if ((iVar1 != 0) && ((var_8ch == 1 || (var_8ch == 2)))) {\n                if (var_98h < 4) {\n                    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(0x80000001, \"Control Panel\\\\Desktop\", 0, 1, &hKey);\n                    if (iVar1 == 0) {\n                        var_4h = 0x80;\n                        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)\n                                          (hKey, \"WheelScrollLines\", 0, &var_8h, &var_11ch, &var_4h);\n                        if (iVar1 == 0) {\n                            *0x440484 = fcn.00406e60(&var_11ch, 0, 10);\n                        }\n                        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n                    }\n                }\n                else if ((var_8ch == 2) && (3 < var_98h)) {\n                    (*_sym.imp.USER32.dll_SystemParametersInfoA)(0x68, 0, 0x440484, 0);\n                }\n            }\n        }\n    }\n    return *0x440484;\n}\n",
        "token_count": 601
    },
    "00420d48": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00420d48(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.00419b70(1);\n    iVar2 = fcn.00419b70(0);\n    if (*(in_ECX + 100) != 0) {\n        (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lpRect);\n        if (*(in_ECX + 0x4c) < var_8h - lpRect) {\n            iVar2 = ((var_8h - lpRect) - *(in_ECX + 0x4c)) / -2;\n        }\n        if (*(in_ECX + 0x50) < var_4h - var_ch) {\n            iVar1 = ((var_4h - var_ch) - *(in_ECX + 0x50)) / -2;\n        }\n    }\n    *arg_8h = iVar2;\n    arg_8h[1] = iVar1;\n    return;\n}\n",
        "token_count": 279
    },
    "0042113c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042113c(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    \n    if ((arg_10h != 0) && (iVar1 = fcn.0041a013(0),  iVar1 != 0)) {\n        return;\n    }\n    iVar1 = *in_ECX;\n    iVar2 = (**(iVar1 + 0x70))(0);\n    if (arg_10h == iVar2) {\n        (**(iVar1 + 0xc4))(CONCAT11(0xff, arg_8h), arg_ch, 1);\n    }\n    return;\n}\n",
        "token_count": 165
    },
    "00421180": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421180(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    \n    if ((arg_10h != 0) && (iVar1 = fcn.0041a013(0),  iVar1 != 0)) {\n        return;\n    }\n    iVar1 = *in_ECX;\n    iVar2 = (**(iVar1 + 0x70))(1);\n    if (arg_10h == iVar2) {\n        (**(iVar1 + 0xc4))(CONCAT31(arg_8h, 0xff), arg_ch, 1);\n    }\n    return;\n}\n",
        "token_count": 164
    },
    "004211fb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004211fb(uint noname_0, uint nNumber)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    bool bVar3;\n    bool bVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t *in_ECX;\n    int32_t iVar8;\n    uint var_ch;\n    uint var_8h;\n    \n    uVar5 = fcn.0041ae7b();\n    iVar1 = *in_ECX;\n    pcVar2 = *(iVar1 + 0x70);\n    iVar6 = (*pcVar2)(1);\n    if (((iVar6 == 0) || (iVar6 = fcn.0041afe3(),  iVar6 == 0)) && ((uVar5 & 0x200000) == 0)) {\n        bVar3 = false;\n    }\n    else {\n        bVar3 = true;\n    }\n    iVar6 = (*pcVar2)(0);\n    iVar8 = 0;\n    if (((iVar6 != 0) && (iVar6 = fcn.0041afe3(),  iVar6 != 0)) || (bVar4 = false,  (uVar5 & 0x100000) != 0)) {\n        bVar4 = true;\n    }\n    if ((!bVar3) && (!bVar4)) {\n        return 0;\n    }\n    iVar6 = fcn.00420b46(0);\n    if (bVar3) {\n        iVar7 = (*_sym.imp.KERNEL32.dll_MulDiv)(-nNumber, iVar6, 0x78);\n        if ((iVar7 == -1) || (iVar6 == -1)) {\n            iVar8 = in_ECX[0x16];\n            if (0 < nNumber) {\n                iVar8 = -iVar8;\n            }\n        }\n        else {\n            iVar8 = in_ECX[0x18] * iVar7;\n            if (in_ECX[0x16] <= in_ECX[0x18] * iVar7) {\n                iVar8 = in_ECX[0x16];\n            }\n        }\n        iVar6 = 0;\n    }\n    else {\n        if (!bVar4) goto code_r0x00421309;\n        iVar8 = (*_sym.imp.KERNEL32.dll_MulDiv)(-nNumber, iVar6, 0x78);\n        if ((iVar8 == -1) || (iVar6 == -1)) {\n            iVar6 = in_ECX[0x15];\n        }\n        else {\n            iVar6 = in_ECX[0x17] * iVar8;\n            if (in_ECX[0x15] <= in_ECX[0x17] * iVar8) {\n                iVar6 = in_ECX[0x15];\n            }\n        }\n        iVar8 = 0;\n    }\n    iVar8 = (**(iVar1 + 200))(iVar6, iVar8, 1);\ncode_r0x00421309:\n    if (iVar8 != 0) {\n        (*_sym.imp.USER32.dll_UpdateWindow)(in_ECX[7]);\n    }\n    return iVar8;\n}\n",
        "token_count": 699
    },
    "00421646": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00421646(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    if (*(extraout_ECX + 0x80) == 0) {\n        iVar1 = fcn.00416693(0x20);\n        *(unaff_EBP + -0x10) = iVar1;\n        *(unaff_EBP + -4) = 0;\n        if (iVar1 == 0) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = fcn.0042da9c();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(extraout_ECX + 0x80) = uVar2;\n    }\n    (**(**(extraout_ECX + 0x80) + 0x14))(*(unaff_EBP + 8));\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 285
    },
    "004216a2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004216a2(uint hModule, int32_t hResInfo, int32_t arg_10h)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    uchar uVar4;\n    uchar extraout_AH;\n    int32_t iVar5;\n    int32_t *arg_ch;\n    int32_t *arg_8h;\n    uint32_t uVar6;\n    uint uVar7;\n    int32_t iVar8;\n    uint uVar9;\n    uint uVar10;\n    uint32_t *puVar11;\n    uint32_t *puVar12;\n    uint var_ch;\n    uint var_8h;\n    uint nIndex;\n    \n    iVar5 = (*_sym.imp.KERNEL32.dll_LoadResource)(hModule, hResInfo);\n    if ((iVar5 != 0) && (arg_ch = (*_sym.imp.KERNEL32.dll_LockResource)(iVar5),  arg_ch != NULL)) {\n        iVar5 = *arg_ch;\n        arg_8h = fcn.00405e40(iVar5 + 0x40);\n        if (arg_8h != NULL) {\n            fcn.00405850(arg_8h, arg_ch, iVar5 + 0x40);\n            puVar12 = arg_8h + *arg_8h;\n            hResInfo = 0x10;\n            do {\n                iVar5 = 0;\n                puVar11 = 0x4324d8;\n                do {\n                    if (*puVar12 == *puVar11) {\n                        if (arg_10h == 0) {\n                            puVar1 = iVar5 * 8 + 0x4324dc;\n                            (*_sym.imp.USER32.dll_GetSysColor)(*(iVar5 * 8 + 0x4324dc));\n                            uVar4 = (*_sym.imp.USER32.dll_GetSysColor)(*puVar1);\n                            uVar6 = (*_sym.imp.USER32.dll_GetSysColor)(*puVar1);\n                            *puVar12 = CONCAT11(uVar4, extraout_AH) << 8 | uVar6 >> 0x10 & 0xff;\n                        }\n                        else if (*(iVar5 * 8 + 0x4324dc) != 0x12) {\n                            *puVar12 = 0xffffff;\n                        }\n                        break;\n                    }\n                    puVar11 = puVar11 + 2;\n                    iVar5 = iVar5 + 1;\n                } while (puVar11 < 0x4324f8);\n                puVar12 = puVar12 + 1;\n                hResInfo = hResInfo + -1;\n                if (hResInfo == 0) {\n                    iVar5 = arg_8h[1];\n                    iVar2 = arg_8h[2];\n                    uVar7 = (*_sym.imp.USER32.dll_GetDC)(0);\n                    iVar8 = (*_sym.imp.GDI32.dll_CreateCompatibleBitmap)(uVar7, iVar5, iVar2);\n                    if (iVar8 != 0) {\n                        uVar9 = (*_sym.imp.GDI32.dll_CreateCompatibleDC)(uVar7);\n                        pcVar3 = _sym.imp.GDI32.dll_SelectObject;\n                        uVar10 = (*_sym.imp.GDI32.dll_SelectObject)(uVar9, iVar8);\n                        (*_sym.imp.GDI32.dll_StretchDIBits)\n                                  (uVar9, 0, 0, iVar5, iVar2, 0, 0, iVar5, iVar2, \n                                   arg_ch + (1 << (*(arg_8h + 0xe) & 0x1f)) + 10, arg_8h, 0, 0xcc0020);\n                        (*pcVar3)(uVar9, uVar10);\n                        (*_sym.imp.GDI32.dll_DeleteDC)(uVar9);\n                    }\n                    (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar7);\n                    fcn.00405f10(arg_8h);\n                    return iVar8;\n                }\n            } while( true );\n        }\n    }\n    return 0;\n}\n",
        "token_count": 900
    },
    "0042261d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042261d(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t *piVar6;\n    int32_t *in_ECX;\n    int32_t iVar7;\n    bool bVar8;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(1);\n    if (iVar2 < 0) {\n        return;\n    }\n    iVar3 = fcn.0042cd29();\n    (*_sym.imp.USER32.dll_GetCursorPos)(&var_14h);\n    (*_sym.imp.USER32.dll_ScreenToClient)(in_ECX[7], &var_14h);\n    var_ch = *in_ECX;\n    iVar7 = 0;\n    var_4h = (**(var_ch + 0x6c))(var_14h, var_10h, 0);\n    if (var_4h < 0) {\n        *(iVar3 + 0x104) = 0xffffffff;\n    }\n    else {\n        var_8h = fcn.0041987d();\n        iVar4 = fcn.004198f0();\n        if ((iVar4 == 0) || (iVar4 = fcn.0041afe3(),  iVar4 == 0)) {\n            var_4h = -1;\n        }\n        if (*(iVar3 + 0xcc) != 0) {\n            iVar7 = *(*(iVar3 + 0xcc) + 0x1c);\n        }\n        uVar5 = (*_sym.imp.USER32.dll_GetCapture)();\n        piVar6 = fcn.0041819c(uVar5);\n        if (piVar6 != in_ECX) {\n            if (piVar6 == NULL) {\n                iVar4 = 0;\n            }\n            else {\n                iVar4 = piVar6[7];\n            }\n            if ((iVar4 != iVar7) && (iVar7 = fcn.0041987d(),  iVar7 == var_8h)) {\n                var_4h = -1;\n            }\n        }\n    }\n    bVar8 = var_4h < 0;\n    if (bVar8) goto code_r0x00422733;\n    (*_sym.imp.USER32.dll_ClientToScreen)(in_ECX[7], &var_14h);\n    iVar7 = (*_sym.imp.USER32.dll_WindowFromPoint)(var_14h, var_10h);\n    if (iVar7 == 0) {\ncode_r0x00422724:\n        var_4h = -1;\n        *(iVar3 + 0x104) = 0xffffffff;\n    }\n    else if ((iVar7 != in_ECX[7]) && (iVar4 = (*_sym.imp.USER32.dll_IsChild)(in_ECX[7], iVar7),  iVar4 == 0)) {\n        iVar4 = *(iVar3 + 0xcc);\n        if (iVar4 != 0) {\n            iVar4 = *(iVar4 + 0x1c);\n        }\n        if (iVar4 != iVar7) goto code_r0x00422724;\n    }\n    bVar8 = var_4h < 0;\ncode_r0x00422733:\n    pcVar1 = _sym.imp.USER32.dll_KillTimer;\n    if (bVar8) {\n        if (*(iVar3 + 0x104) == -1) {\n            (*_sym.imp.USER32.dll_KillTimer)(in_ECX[7], 0xe001);\n        }\n        (**(var_ch + 0xe4))(0xffffffff);\n    }\n    if ((arg_8h == 0xe000) && ((*pcVar1)(in_ECX[7], 0xe000),  -1 < var_4h)) {\n        (**(var_ch + 0xe4))(var_4h);\n    }\n    return;\n}\n",
        "token_count": 906
    },
    "00422c46": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00422c46(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    if (*(param_1 + 0x1c) != 0) {\n        iVar1 = fcn.00429d4d();\n        if (iVar1 != 0) {\n            piVar2 = fcn.00429d3c();\n            (**(*piVar2 + 0x60))();\n            return;\n        }\n    }\n    fcn.00418a40();\n    return;\n}\n",
        "token_count": 124
    },
    "00422e07": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00422e07(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if ((in_ECX[0x1c] != 0) && (iVar1 = (**(*in_ECX + 0x6c))(arg_ch, arg_10h, 0),  iVar1 == -1)) {\n        (*_sym.imp.USER32.dll_ClientToScreen)(in_ECX[7], &arg_ch);\n        (***in_ECX[0x1d])(arg_ch, arg_10h);\n        return;\n    }\n    fcn.004180f1();\n    return;\n}\n",
        "token_count": 157
    },
    "0042316c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042316c(uint arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    uint32_t uVar6;\n    int32_t in_ECX;\n    int32_t iVar7;\n    uint var_34h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint var_24h;\n    int32_t var_20h;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = *(in_ECX + 100);\n    if ((uVar1 & 0xf00) != 0) {\n        var_2ch = arg_ch[2];\n        var_28h = arg_ch[3];\n        var_20h = arg_ch[1];\n        iVar7 = arg_ch[3];\n        uVar5 = *0x4400bc;\n        if (*0x4400ec == 0) {\n            uVar5 = *0x4400c8;\n        }\n        if ((uVar1 & 0x80) != 0) {\n            var_2ch = var_2ch + -1;\n            var_28h = var_28h + -1;\n        }\n        uVar2 = uVar1 & 0x200;\n        if (uVar2 != 0) {\n            var_20h = var_20h + *0x4400a4;\n        }\n        uVar3 = uVar1 & 0x800;\n        if (uVar3 != 0) {\n            iVar7 = iVar7 - *0x4400a4;\n        }\n        uVar4 = uVar1 & 0x100;\n        if (uVar4 != 0) {\n            fcn.0042a596(0, var_20h, 1, iVar7 - var_20h, uVar5);\n        }\n        if (uVar2 != 0) {\n            fcn.0042a596(0, 0, arg_ch[2], 1, uVar5);\n        }\n        uVar6 = uVar1 & 0x400;\n        if (uVar6 != 0) {\n            fcn.0042a596(var_2ch, var_20h, 0xffffffff, iVar7 - var_20h, uVar5);\n        }\n        if (uVar3 != 0) {\n            fcn.0042a596(0, var_28h, arg_ch[2], 0xffffffff, uVar5);\n        }\n        uVar5 = *0x4400c0;\n        if ((uVar1 & 0x80) != 0) {\n            if (uVar4 != 0) {\n                fcn.0042a596(1, var_20h, 1, iVar7 - var_20h, *0x4400c0);\n            }\n            if (uVar2 != 0) {\n                fcn.0042a596(0, 1, arg_ch[2], 1, uVar5);\n            }\n            if (uVar6 != 0) {\n                fcn.0042a596(arg_ch[2], var_20h, 0xffffffff, iVar7 - var_20h, uVar5);\n            }\n            if (uVar3 != 0) {\n                fcn.0042a596(0, arg_ch[3], arg_ch[2], 0xffffffff, uVar5);\n            }\n        }\n        if (uVar4 != 0) {\n            *arg_ch = *arg_ch + *0x4400a0;\n        }\n        if (uVar2 != 0) {\n            arg_ch[1] = arg_ch[1] + *0x4400a4;\n        }\n        if (uVar6 != 0) {\n            arg_ch[2] = arg_ch[2] - *0x4400a0;\n        }\n        if (uVar3 != 0) {\n            arg_ch[3] = arg_ch[3] - *0x4400a4;\n        }\n    }\n    return;\n}\n",
        "token_count": 961
    },
    "00423d2d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00423d2d(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    uint *in_ECX;\n    int32_t iVar2;\n    uint var_110h;\n    uint var_10h;\n    \n    fcn.0042d07c();\n    (*_sym.imp.USER32.dll_wsprintfA)(&var_110h, \"%s-Bar%d\", arg_8h, arg_ch);\n    iVar2 = 0;\n    fcn.00425e4b(&var_110h, 0, 0);\n    if ((((in_ECX[4] == 0) || (in_ECX[1] == 0)) || (in_ECX[2] != 0)) ||\n       (((in_ECX[5] != -1 || (in_ECX[6] != -1)) || (1 < in_ECX[0x13])))) {\n        fcn.00425dd6(&var_110h, \"BarID\", *in_ECX);\n        if (in_ECX[1] == 0) {\n            fcn.00425dd6(&var_110h, \"Visible\", 0);\n        }\n        if (in_ECX[2] != 0) {\n            fcn.00425dd6(&var_110h, \"Horz\", in_ECX[3]);\n            fcn.00425dd6(&var_110h, \"Floating\", in_ECX[2]);\n        }\n        if (in_ECX[5] != -1) {\n            fcn.00425dd6(&var_110h, \"XPos\", in_ECX[5]);\n        }\n        if (in_ECX[6] != -1) {\n            fcn.00425dd6(&var_110h, \"YPos\", in_ECX[6]);\n        }\n        if (in_ECX[7] != 0x7fff) {\n            fcn.00425dd6(&var_110h, \"MRUWidth\", in_ECX[7]);\n        }\n        if (in_ECX[8] != 0) {\n            fcn.00425dd6(&var_110h, \"Docking\", in_ECX[8]);\n            fcn.00425dd6(&var_110h, \"MRUDockID\", in_ECX[9]);\n            fcn.00425dd6(&var_110h, \"MRUDockLeftPos\", in_ECX[10]);\n            fcn.00425dd6(&var_110h, \"MRUDockTopPos\", in_ECX[0xb]);\n            fcn.00425dd6(&var_110h, \"MRUDockRightPos\", in_ECX[0xc]);\n            fcn.00425dd6(&var_110h, \"MRUDockBottomPos\", in_ECX[0xd]);\n            fcn.00425dd6(&var_110h, \"MRUFloatStyle\", in_ECX[0xe]);\n            fcn.00425dd6(&var_110h, \"MRUFloatXPos\", in_ECX[0xf]);\n            fcn.00425dd6(&var_110h, \"MRUFloatYPos\", in_ECX[0x10]);\n        }\n        if (1 < in_ECX[0x13]) {\n            fcn.00425dd6(&var_110h, \"Bars\", in_ECX[0x13]);\n            if (0 < in_ECX[0x13]) {\n                do {\n                    (*_sym.imp.USER32.dll_wsprintfA)(&var_10h, \"Bar#%d\", iVar2);\n                    fcn.00425dd6(&var_110h, &var_10h, *(in_ECX[0x12] + iVar2 * 4));\n                    iVar2 = iVar2 + 1;\n                } while (iVar2 < in_ECX[0x13]);\n            }\n        }\n        uVar1 = 1;\n    }\n    else {\n        uVar1 = 0;\n    }\n    return uVar1;\n}\n",
        "token_count": 887
    },
    "00424379": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00424379(int32_t param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    pcVar2 = _sym.imp.KERNEL32.dll_MulDiv;\n    if (*(param_1 + 0x18) != 0) {\n        iVar4 = *(param_1 + 0x28);\n        iVar1 = *(param_1 + 0x20);\n        iVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(*param_2, *(param_1 + 0x24) - *(param_1 + 0x1c), *(param_1 + 0x3c));\n        *param_2 = iVar3;\n        iVar4 = (*pcVar2)(param_2[1], iVar4 - iVar1, *(param_1 + 0x40));\n        param_2[1] = iVar4;\n    }\n    iVar4 = *(param_1 + 0x34);\n    if (*param_2 != iVar4 && iVar4 <= *param_2) {\n        *param_2 = iVar4;\n    }\n    iVar4 = *(param_1 + 0x38);\n    if (param_2[1] != iVar4 && iVar4 <= param_2[1]) {\n        param_2[1] = iVar4;\n    }\n    return;\n}\n",
        "token_count": 321
    },
    "004243cc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004243cc(int32_t param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint unaff_EBP;\n    \n    if (*(param_1 + 0x18) != 0) {\n        iVar3 = *(param_1 + 0x28);\n        iVar4 = *(param_1 + 0x20);\n        iVar2 = (*_sym.imp.KERNEL32.dll_MulDiv)(*param_2, *(param_1 + 0x24) - *(param_1 + 0x1c), *(param_1 + 0x3c));\n        iVar1 = *param_2;\n        iVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(unaff_EBP, iVar3 - iVar4, *(param_1 + 0x40));\n        (*_sym.imp.USER32.dll_OffsetRect)(param_2, iVar2 - iVar1, iVar3 - param_2[1]);\n    }\n    iVar4 = 0;\n    iVar3 = 0;\n    if (*(param_1 + 0x34) < *param_2) {\n        iVar3 = *(param_1 + 0x34) - *param_2;\n    }\n    if (*(param_1 + 0x38) < param_2[1]) {\n        iVar4 = *(param_1 + 0x38) - param_2[1];\n    }\n    if ((iVar3 != 0) || (iVar4 != 0)) {\n        (*_sym.imp.USER32.dll_OffsetRect)(param_2, iVar3, iVar4);\n    }\n    return;\n}\n",
        "token_count": 382
    },
    "0042453c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid __cdecl fcn.0042453c(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    var_8h = in_ECX;\n    if (0 < *(arg_8h + 0xc)) {\n        do {\n            iVar3 = *(*(arg_8h + 8) + var_4h * 4);\n            if (*(iVar3 + 8) == 0) {\n                iVar2 = fcn.00429484();\n            }\n            else {\n                piVar1 = fcn.00429e45((-(*(iVar3 + 0xc) != 0) & 0x1000) + 0x1000);\n                var_14h = *(iVar3 + 0x18);\n                var_18h = *(iVar3 + 0x14);\n                var_ch = var_14h + 10;\n                var_10h = var_18h + 10;\n                (**(*piVar1 + 0x68))(&var_18h, 0);\n                var_ch = 0x15;\n                var_10h = 0;\n                var_14h = 0;\n                var_18h = 0;\n                fcn.0041af6d(0, 0, 0, 0, 0, 0x15);\n                iVar2 = fcn.0041adf0(0xe81f);\n            }\n            var_4h = var_4h + 1;\n            *(iVar3 + 0x58) = iVar2;\n            *(iVar2 + 0x54) = *(iVar3 + 0x1c);\n        } while (var_4h < *(arg_8h + 0xc));\n    }\n    iVar3 = 0;\n    if (0 < *(arg_8h + 0xc)) {\n        do {\n            iVar2 = *(*(arg_8h + 8) + iVar3 * 4);\n            if (*(iVar2 + 0x58) != 0) {\n                fcn.004247c8(iVar2, var_8h);\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < *(arg_8h + 0xc));\n    }\n    iVar3 = 0;\n    if (0 < *(arg_8h + 0xc)) {\n        do {\n            iVar2 = *(*(arg_8h + 8) + iVar3 * 4);\n            if (*(iVar2 + 8) != 0) {\n                piVar1 = fcn.004197f4();\n                iVar2 = (**(**(iVar2 + 0x58) + 0xe8))();\n                if (0 < iVar2) {\n                    (**(*piVar1 + 0xd0))(1);\n                    fcn.0041afbc(8);\n                }\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < *(arg_8h + 0xc));\n    }\n    *(var_8h + 0xb8) = *(var_8h + 0xb8) | 0xc;\n    return;\n}\n",
        "token_count": 834
    },
    "004246e8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004246e8(uint32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    uint32_t lpPoint;\n    uint32_t var_10h;\n    uint var_ch;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    uVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(in_ECX[7]);\n    iVar3 = *in_ECX;\n    *arg_8h = uVar2 & 0xffff;\n    arg_8h[0x16] = in_ECX;\n    uVar2 = (**(iVar3 + 0xd0))();\n    arg_8h[1] = uVar2;\n    arg_8h[7] = in_ECX[0x15];\n    if (in_ECX[0x1c] != 0) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(in_ECX[7], &lpPoint);\n        iVar1 = in_ECX[0x1c];\n        (*_sym.imp.USER32.dll_ScreenToClient)(*(iVar1 + 0x1c), &lpPoint);\n        (*_sym.imp.USER32.dll_ScreenToClient)(*(iVar1 + 0x1c), &var_ch);\n        arg_8h[8] = 1;\n        arg_8h[5] = lpPoint;\n        arg_8h[6] = var_10h;\n        arg_8h[9] = *(in_ECX[0x1d] + 0x90);\n        iVar1 = in_ECX[0x1d];\n        arg_8h[10] = *(iVar1 + 0x94);\n        arg_8h[0xb] = *(iVar1 + 0x98);\n        arg_8h[0xc] = *(iVar1 + 0x9c);\n        arg_8h[0xd] = *(iVar1 + 0xa0);\n        arg_8h[0xe] = *(var_4h[0x1d] + 0xa4);\n        iVar1 = var_4h[0x1d];\n        arg_8h[0xf] = *(iVar1 + 0xa8);\n        arg_8h[0x10] = *(iVar1 + 0xac);\n    }\n    iVar3 = (**(iVar3 + 0xd8))();\n    if (iVar3 != 0) {\n        fcn.00424896(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 584
    },
    "00424896": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424896(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    uint lpRect;\n    uint var_ch;\n    \n    iVar2 = 0;\n    *(arg_8h + 0x10) = 1;\n    *(arg_8h + 8) = *(in_ECX + 0x78);\n    if (*(in_ECX + 0x78) != 0) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x1c), &lpRect);\n        *(arg_8h + 0x14) = lpRect;\n        *(arg_8h + 0x18) = var_ch;\n    }\n    *(arg_8h + 0xc) = (*(in_ECX + 100) & 0xa000) != 0;\n    if (0 < *(in_ECX + 0x84)) {\n        do {\n            iVar1 = *(*(in_ECX + 0x80) + iVar2 * 4);\n            if (((iVar1 != 0) && (iVar1 >> 0x10 != 0)) && (iVar1 != 0)) {\n                (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(iVar1 + 0x1c));\n            }\n            fcn.0041602d();\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < *(in_ECX + 0x84));\n    }\n    return;\n}\n",
        "token_count": 343
    },
    "0042493f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl fcn.0042493f(uint arg_8h, uint arg_ch)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t arg_8h_00;\n    int32_t iVar5;\n    int32_t extraout_ECX;\n    int32_t arg_8h_01;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint32_t var_4h;\n    \n    fcn.004056b0();\n    iVar5 = *(unaff_EBP + 8);\n    arg_8h_01 = *(iVar5 + 0x4c);\n    if (arg_8h_01 != 0) {\n        iVar4 = *(iVar5 + 0x48) + arg_8h_01 * 4;\n        do {\n            if ((*(iVar4 + -4) != 0) && (*(iVar4 + -4) != 0x10000)) break;\n            arg_8h_01 = arg_8h_01 + -1;\n            iVar4 = iVar4 + -4;\n        } while (arg_8h_01 != 0);\n    }\n    *(unaff_EBP + -0x10) = 1;\n    if (1 < arg_8h_01) {\n        while( true ) {\n            puVar1 = *(iVar5 + 0x48) + *(unaff_EBP + -0x10) * 4;\n            if (*puVar1 >> 0x10 == 0) {\n                arg_8h_00 = fcn.00429484();\n                if (arg_8h_00 != 0) {\n                    (*_sym.imp.USER32.dll_GetParent)(*(arg_8h_00 + 0x1c));\n                    iVar5 = fcn.0041819c();\n                    if (iVar5 != extraout_ECX) {\n                        (*_sym.imp.USER32.dll_SetParent)();\n                        fcn.0041819c();\n                    }\n                    if (*(arg_8h_00 + 0x70) != 0) {\n                        fcn.00425159(arg_8h_00, 0xffffffff, 0);\n                    }\n                    fcn.00425102();\n                    *(arg_8h_00 + 0x70) = extraout_ECX;\n                    uVar2 = *(arg_8h_00 + 100);\n                    uVar3 = CONCAT11((*(extraout_ECX + 100) >> 8 ^ *(arg_8h_00 + 100) >> 8) & 0xf0 ^ uVar2 >> 8, uVar2);\n                    if (*(extraout_ECX + 0x78) == 0) {\n                        var_4h = uVar2 & 0xffff0000 | uVar3 & 0xfffffffe | 0xf00;\n                    }\n                    else {\n                        var_4h = uVar2 & 0xffff0000 | uVar3 | 0xf01;\n                    }\n                    fcn.0042c4af();\n                    if (*(extraout_ECX + 0x78) != 0) {\n                        if ((*(arg_8h_00 + 0x68) & 0x40) != 0) {\n                            *(extraout_ECX + 100) = *(extraout_ECX + 100) | 0x40;\n                        }\n                        iVar5 = fcn.004197f4();\n                        if (*(iVar5 + 0x20) == 0) {\n                            *(iVar5 + 0x20) = *(arg_8h_00 + 0x1c);\n                        }\n                        if ((*(arg_8h_00 + 100) & 4) != 0) {\n                            var_4h = 0x800;\n                            fcn.0041aeaf(0x800, 0, 0);\n                        }\n                    }\n                    if ((*(unaff_EBP + -0x10) == 1) && ((*(extraout_ECX + 100) & 0x40) == 0)) {\n                        fcn.0041b0c1(var_4h);\n                        *(unaff_EBP + -4) = 0;\n                        fcn.00418bc5(unaff_EBP + -0x14);\n                        fcn.0042039e(*(extraout_ECX + 0x1c), *(unaff_EBP + -0x14));\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        fcn.0041b20c();\n                    }\n                }\n            }\n            else {\n                arg_8h_00 = *puVar1;\n            }\n            fcn.00416054(*(unaff_EBP + -0x10), arg_8h_00, 1);\n            *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + 1;\n            if (arg_8h_01 <= *(unaff_EBP + -0x10)) break;\n            iVar5 = *(unaff_EBP + 8);\n        }\n    }\n    iVar5 = *(extraout_ECX + 0x84);\n    if ((arg_8h_01 < iVar5) && (*(*(extraout_ECX + 0x80) + arg_8h_01 * 4) != 0)) {\n        fcn.00416054(arg_8h_01, 0, 1);\n        iVar5 = iVar5 + 1;\n    }\n    if (*(*(extraout_ECX + 0x80) + -4 + iVar5 * 4) != 0) {\n        fcn.00416054(iVar5, 0, 1);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 1369
    },
    "00424f12": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424f12(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    code *pcVar2;\n    ushort uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t in_ECX;\n    uint uVar6;\n    uint var_124h;\n    uint lpRect;\n    int32_t lprcDst;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowRect)(*(arg_8h + 0x1c), &lpRect);\n    if (*(arg_8h + 0x70) == in_ECX) {\n        if (arg_ch == 0) {\n            return;\n        }\n        iVar4 = (*_sym.imp.USER32.dll_EqualRect)(&lpRect, arg_ch);\n        if (iVar4 != 0) {\n            return;\n        }\n    }\n    if ((*(in_ECX + 0x78) != 0) && ((*(arg_8h + 0x68) & 0x40) != 0)) {\n        *(in_ECX + 100) = *(in_ECX + 100) | 0x40;\n    }\n    *(in_ECX + 100) = *(in_ECX + 100) & 0xfffffff9;\n    uVar5 = *(in_ECX + 100);\n    *(in_ECX + 100) = *(arg_8h + 100) & 6 | uVar5;\n    if ((uVar5 & 0x40) == 0) {\n        fcn.0041af3e(&var_124h, 0x104);\n        fcn.0042039e(*(in_ECX + 0x1c), &var_124h);\n    }\n    uVar5 = *(arg_8h + 100);\n    uVar1 = CONCAT11((*(arg_8h + 100) >> 8 ^ *(in_ECX + 100) >> 8) & 0xf0 ^ uVar5 >> 8, uVar5);\n    if (*(in_ECX + 0x78) == 0) {\n        uVar5 = uVar5 & 0xffff0000 | uVar1 & 0xfffffffe | 0xf00;\n    }\n    else {\n        uVar5 = uVar5 & 0xffff0000 | uVar1 | 0xf01;\n    }\n    fcn.0042c4af(uVar5);\n    uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_8h + 0x1c), 0xffffffff);\n    iVar4 = fcn.00425845(uVar3);\n    if (0 < iVar4) {\n        *(*(in_ECX + 0x80) + iVar4 * 4) = arg_8h;\n    }\n    if (arg_ch == 0) {\n        if (iVar4 < 1) {\n            fcn.0041602d(*(in_ECX + 0x84), arg_8h);\n            fcn.0041602d(*(in_ECX + 0x84), 0);\n        }\n        uVar6 = 0x115;\n        var_4h = 0;\n        var_ch = -*0x4400a4;\n        var_8h = 0;\n        lprcDst = -*0x4400a0;\n    }\n    else {\n        (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, arg_ch);\n        pcVar2 = _sym.imp.USER32.dll_ScreenToClient;\n        (*_sym.imp.USER32.dll_ScreenToClient)(*(in_ECX + 0x1c), &lprcDst);\n        (*pcVar2)(*(in_ECX + 0x1c), &var_8h);\n        if (iVar4 < 1) {\n            fcn.004258d0(arg_8h, lprcDst, var_ch, var_8h, var_4h, (var_8h - lprcDst) / 2 + lprcDst, \n                         (var_4h - var_ch) / 2 + var_ch);\n        }\n        uVar6 = 0x114;\n        var_4h = var_4h - var_ch;\n        var_8h = var_8h - lprcDst;\n    }\n    fcn.0041af6d(0, lprcDst, var_ch, var_8h, var_4h, uVar6);\n    uVar6 = (*_sym.imp.USER32.dll_GetParent)(*(arg_8h + 0x1c));\n    iVar4 = fcn.0041819c(uVar6);\n    if (iVar4 != in_ECX) {\n        if (in_ECX == 0) {\n            uVar6 = 0;\n        }\n        else {\n            uVar6 = *(in_ECX + 0x1c);\n        }\n        uVar6 = (*_sym.imp.USER32.dll_SetParent)(*(arg_8h + 0x1c), uVar6);\n        fcn.0041819c(uVar6);\n    }\n    if (*(arg_8h + 0x70) != 0) {\n        fcn.00425159(arg_8h, 0xffffffff, 0);\n    }\n    *(arg_8h + 0x70) = in_ECX;\n    iVar4 = fcn.00429d3c();\n    *(iVar4 + 0xb8) = *(iVar4 + 0xb8) | 0xc;\n    return;\n}\n",
        "token_count": 1266
    },
    "00425102": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00425102(int32_t param_1, int32_t param_2)\n\n{\n    ushort uVar1;\n    int32_t iVar2;\n    \n    uVar1 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(param_2 + 0x1c), 0xffffffff);\n    iVar2 = fcn.00425845(uVar1);\n    if (0 < iVar2) {\n        fcn.004160e9(iVar2, 1);\n        if ((*(*(param_1 + 0x80) + -4 + iVar2 * 4) == 0) && (*(*(param_1 + 0x80) + iVar2 * 4) == 0)) {\n            fcn.004160e9(iVar2, 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 184
    },
    "00425159": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00425159(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t *in_ECX;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    \n    iVar1 = fcn.00425845(arg_8h, arg_ch);\n    if (arg_10h == 0) {\n        fcn.004160e9(iVar1, 1);\n        if ((*(in_ECX[0x20] + -4 + iVar1 * 4) == 0) && (*(in_ECX[0x20] + iVar1 * 4) == 0)) {\n            fcn.004160e9(iVar1, 1);\n        }\n        iVar6 = arg_8h;\n        fcn.00425102(arg_8h);\n    }\n    else {\n        iVar6 = in_ECX[0x20];\n        uVar7 = *(arg_8h + 0x1c);\n        iVar5 = iVar1 * 4;\n        uVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(uVar7);\n        *(iVar6 + iVar5) = uVar2 & 0xffff;\n        iVar6 = *(in_ECX[0x20] + iVar5);\n        iVar3 = fcn.00425845(uVar7, iVar1);\n        if (0 < iVar3) {\n            iVar6 = iVar1;\n            fcn.004160e9();\n            if (((iVar5 + in_ECX[0x20])[-1] == 0) && (*(iVar5 + in_ECX[0x20]) == 0)) {\n                fcn.004160e9(iVar1, 1);\n                iVar6 = iVar1;\n            }\n        }\n    }\n    if (*(arg_8h + 0x74) != 0) {\n        piVar4 = fcn.00429d3c(iVar6);\n        if ((in_ECX[0x1e] == 0) || (iVar1 = (**(*in_ECX + 0xe8))(),  iVar1 != 0)) {\n            piVar4[0x2e] = piVar4[0x2e] | 0xc;\n        }\n        else {\n            iVar1 = fcn.00424c6f();\n            if (iVar1 == 0) {\n                (**(*piVar4 + 0x60))();\n                return 1;\n            }\n            fcn.0041afbc(0);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 601
    },
    "00425a26": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00425a26(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(extraout_ECX + 0x68) = *(unaff_EBP + 8);\n    if (*(extraout_ECX + 0x74) == 0) {\n        iVar1 = fcn.00416693(0xb0);\n        *(unaff_EBP + 8) = iVar1;\n        *(unaff_EBP + -4) = 0;\n        if (iVar1 == 0) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = fcn.00426d47(extraout_ECX);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(extraout_ECX + 0x74) = uVar2;\n    }\n    if (*(extraout_ECX + 0x20) == 0) {\n        uVar2 = (*_sym.imp.USER32.dll_GetParent)(*(extraout_ECX + 0x1c));\n        *(extraout_ECX + 0x20) = uVar2;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 337
    },
    "00425cdf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00425cdf(uint32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    uint uVar3;\n    \n    if (arg_8h == 2) {\n        fcn.00419924();\n        if ((*(in_ECX + 0x130) & 0x40) == 0) {\n            uVar3 = 1;\n            iVar1 = 0;\n            iVar2 = 1;\n            do {\n                if (*(in_ECX + 0x150) <= iVar2) break;\n                iVar1 = fcn.004258b4(uVar3, iVar2);\n                iVar2 = iVar2 + 1;\n            } while (iVar1 == 0);\n            (****(iVar1 + 0x74))(arg_ch, arg_10h);\n            return;\n        }\n    }\n    else if ((9 < arg_8h) && (arg_8h < 0x12)) {\n        fcn.00419924();\n        uVar3 = 1;\n        iVar1 = 0;\n        iVar2 = 1;\n        do {\n            if (*(in_ECX + 0x150) <= iVar2) break;\n            iVar1 = fcn.004258b4(uVar3, iVar2);\n            iVar2 = iVar2 + 1;\n        } while (iVar1 == 0);\n        (**(**(iVar1 + 0x74) + 4))(arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    fcn.0042ad66(arg_8h, arg_ch, arg_10h);\n    return;\n}\n",
        "token_count": 382
    },
    "00425dd6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00425dd6(uint lpAppName, uint lpValueName, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint lpString;\n    \n    if (*(in_ECX + 0x7c) == 0) {\n        (*_sym.imp.USER32.dll_wsprintfA)(&lpString, 0x4332cc, arg_10h);\n        uVar1 = (*_sym.imp.KERNEL32.dll_WritePrivateProfileStringA)(lpAppName, lpValueName, &lpString, *(in_ECX + 0x90))\n        ;\n    }\n    else {\n        uVar1 = fcn.0042cab9(lpAppName);\n        if (uVar1 != 0) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(uVar1, lpValueName, 0, 4, &arg_10h, 4);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(uVar1);\n            uVar1 = iVar2 == 0;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 258
    },
    "00425e4b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00425e4b(uint lpAppName, int32_t lpValueName, int32_t lpString)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x7c) == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_WritePrivateProfileStringA)(lpAppName, lpValueName, lpString, *(in_ECX + 0x90));\n        return uVar3;\n    }\n    if (lpValueName == 0) {\n        iVar1 = fcn.0042ca25();\n        if (iVar1 == 0) {\n            return 0;\n        }\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegDeleteKeyA)(iVar1, lpAppName);\n    }\n    else if (lpString == 0) {\n        iVar1 = fcn.0042cab9(lpAppName);\n        if (iVar1 == 0) {\n            return 0;\n        }\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegDeleteValueA)(iVar1, lpValueName);\n    }\n    else {\n        iVar1 = fcn.0042cab9(lpAppName);\n        if (iVar1 == 0) {\n            return 0;\n        }\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(iVar1, lpValueName, 0, 1, lpString, iVar2 + 1);\n    }\n    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n    return iVar2 == 0;\n}\n",
        "token_count": 384
    },
    "00425eeb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00425eeb(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    fcn.0041ae1a(arg_8h, &arg_8h);\n    if (arg_8h == 0) {\n        fcn.004156b4();\n    }\n    *(in_ECX + 0xc) = 0;\n    *(in_ECX + 8) = arg_8h;\n    return;\n}\n",
        "token_count": 105
    },
    "00425f1a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.00425f1a(int32_t *param_1, int32_t *param_2)\n\n{\n    uint uVar1;\n    uint *unaff_EDI;\n    \n    uVar1 = fcn.00425eeb(param_2);\n    if (*param_1 == 0) {\n        if ((*param_2 < 0) || (2 < *param_2)) {\n            *param_2 = 0;\n        }\n        (*_sym.imp.USER32.dll_SendMessageA)(uVar1, 0xf1, *param_2, 0);\n    }\n    else {\n        uVar1 = (*_sym.imp.USER32.dll_SendMessageA)(uVar1, 0xf0, 0, 0);\n        *unaff_EDI = uVar1;\n    }\n    return;\n}\n",
        "token_count": 182
    },
    "00426037": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00426037(int32_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    \n    iVar4 = 0;\n    uVar1 = *arg_ch;\n    puVar5 = arg_ch;\n    while (uVar1 != 0) {\n        if (*puVar5 == 0x25) {\n            uVar1 = puVar5[1];\n            if ((uVar1 < '0') || ('9' < uVar1)) {\n                if ((uVar1 < 'A') || ('Z' < uVar1)) goto code_r0x00426090;\n                if (uVar1 < ':') goto code_r0x0042606e;\n                iVar3 = uVar1 + -0x38;\n            }\n            else {\ncode_r0x0042606e:\n                iVar3 = uVar1 + -0x31;\n            }\n            puVar5 = puVar5 + 2;\n            if (arg_14h <= iVar3) goto code_r0x0042609f;\n            iVar3 = *(arg_10h + iVar3 * 4);\n            if (iVar3 != 0) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(iVar3);\n                iVar4 = iVar4 + iVar3;\n            }\n        }\n        else {\ncode_r0x00426090:\n            if ((*(*puVar5 + 0x440519) & 4) != 0) {\n                iVar4 = iVar4 + 1;\n                puVar5 = puVar5 + 1;\n            }\n            puVar5 = puVar5 + 1;\ncode_r0x0042609f:\n            iVar4 = iVar4 + 1;\n        }\n        uVar1 = *puVar5;\n    }\n    puVar5 = fcn.0041b4d5(iVar4);\n    do {\n        while( true ) {\n            if (*arg_ch == 0) {\n                fcn.0041b524(puVar5 - *arg_8h);\n                return;\n            }\n            uVar1 = *arg_ch;\n            if (uVar1 == 0x25) break;\ncode_r0x0042610d:\n            if ((*(uVar1 + 0x440519) & 4) != 0) {\n                *puVar5 = uVar1;\n                puVar5 = puVar5 + 1;\n                arg_ch = arg_ch + 1;\n            }\n            *puVar5 = *arg_ch;\n            puVar5 = puVar5 + 1;\n            arg_ch = arg_ch + 1;\n        }\n        uVar2 = arg_ch[1];\n        if ((uVar2 < '0') || ('9' < uVar2)) {\n            if ((uVar2 < 'A') || ('Z' < uVar2)) goto code_r0x0042610d;\n            if (uVar2 < ':') goto code_r0x004260dd;\n            iVar4 = uVar2 + -0x38;\n        }\n        else {\ncode_r0x004260dd:\n            iVar4 = uVar2 + -0x31;\n        }\n        arg_ch = arg_ch + 2;\n        if (iVar4 < arg_14h) {\n            iVar4 = *(arg_10h + iVar4 * 4);\n            if (iVar4 != 0) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyA)(puVar5, iVar4);\n                iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(puVar5);\n                puVar5 = puVar5 + iVar4;\n            }\n        }\n        else {\n            *puVar5 = 0x3f;\n            puVar5 = puVar5 + 1;\n        }\n    } while( true );\n}\n",
        "token_count": 888
    },
    "00427140": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427140(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_OffsetRect;\n    iVar4 = arg_8h - *(in_ECX + 4);\n    iVar2 = arg_ch - *(in_ECX + 8);\n    (*_sym.imp.USER32.dll_OffsetRect)(in_ECX + 0x28, iVar4, iVar2);\n    (*pcVar1)(in_ECX + 0x48, iVar4, iVar2);\n    (*pcVar1)(in_ECX + 0x38, iVar4, iVar2);\n    (*pcVar1)(in_ECX + 0x58, iVar4, iVar2);\n    *(in_ECX + 4) = arg_8h;\n    *(in_ECX + 8) = arg_ch;\n    if (*(in_ECX + 0x80) == 0) {\n        uVar3 = fcn.004278cf();\n    }\n    else {\n        uVar3 = 0;\n    }\n    *(in_ECX + 0x74) = uVar3;\n    fcn.00427767(0);\n    return;\n}\n",
        "token_count": 305
    },
    "004271f0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004271f0(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t arg_ch;\n    uint32_t uVar2;\n    uint *puVar3;\n    uint arg_ch_00;\n    uint arg_10h;\n    uint var_14h;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    int32_t var_4h;\n    \n    fcn.0042771e();\n    if (*(param_1 + 0x74) == 0) {\n        uVar2 = *(param_1 + 0x78);\n        if ((((uVar2 & 4) == 0) && (((uVar2 & 0xa000) == 0 || (*(param_1 + 0x7c) != 0)))) &&\n           (((uVar2 & 0x5000) == 0 || (*(param_1 + 0x7c) == 0)))) {\n            *(param_1 + 0xa8) = *(param_1 + 0x58);\n            arg_10h = *(param_1 + 0x5c);\n            uVar2 = CONCAT11(0x10, *(param_1 + 0x70) & 0x40);\n            arg_ch_00 = *(param_1 + 0x58);\n            *(param_1 + 0xa4) = uVar2;\n            *(param_1 + 0xac) = arg_10h;\n        }\n        else {\n            *(param_1 + 0xa8) = *(param_1 + 0x48);\n            arg_10h = *(param_1 + 0x4c);\n            uVar2 = CONCAT11(0x20, *(param_1 + 0x70) & 0x40);\n            arg_ch_00 = *(param_1 + 0x48);\n            *(param_1 + 0xa4) = uVar2;\n            *(param_1 + 0xac) = arg_10h;\n        }\n        fcn.0042a01f(*(param_1 + 0x68), arg_ch_00, arg_10h, uVar2);\n    }\n    else {\n        var_4h = fcn.004279e7(*(param_1 + 0x74));\n        puVar3 = param_1 + 0x38;\n        if ((*(param_1 + 0x75) & 0x50) == 0) {\n            puVar3 = param_1 + 0x28;\n        }\n        var_14h = *puVar3;\n        uStack20 = puVar3[1];\n        uStack16 = puVar3[2];\n        uStack12 = puVar3[3];\n        uVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(var_4h + 0x1c));\n        arg_ch = var_4h;\n        uVar2 = uVar2 & 0xffff;\n        if ((0xe81a < uVar2) && (uVar2 < 0xe81f)) {\n            *(param_1 + 0x90) = uVar2;\n            *(param_1 + 0x94) = var_14h;\n            *(param_1 + 0x98) = uStack20;\n            *(param_1 + 0x9c) = uStack16;\n            *(param_1 + 0xa0) = uStack12;\n            pcVar1 = _sym.imp.USER32.dll_ScreenToClient;\n            (*_sym.imp.USER32.dll_ScreenToClient)(*(var_4h + 0x1c), param_1 + 0x94);\n            (*pcVar1)(*(arg_ch + 0x1c), param_1 + 0x9c);\n        }\n        fcn.00429f3b(*(param_1 + 0x68), arg_ch, &var_14h);\n        (**(**(param_1 + 0x6c) + 0xd0))(1);\n    }\n    return;\n}\n",
        "token_count": 903
    },
    "00427767": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427767(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t arg_24h;\n    int32_t in_ECX;\n    uint *puVar3;\n    uint lprc;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = 1;\n    var_10h = 1;\n    uVar2 = (*_sym.imp.GDI32.dll_GetStockObject)(0);\n    var_8h = fcn.0041fd52(uVar2);\n    var_ch = var_8h;\n    var_4h = fcn.0042a20e();\n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    if ((*(in_ECX + 0x74) & 0xa000) == 0) {\n        if ((*(in_ECX + 0x74) & 0x5000) == 0) {\n            var_14h = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x20);\n            var_14h = var_14h + -1;\n            var_10h = (*pcVar1)(0x21);\n            var_10h = var_10h + -1;\n            if ((((*(in_ECX + 0x78) & 0xa000) == 0) || (*(in_ECX + 0x7c) != 0)) &&\n               (((*(in_ECX + 0x78) & 0x5000) == 0 || (*(in_ECX + 0x7c) == 0)))) {\n                puVar3 = in_ECX + 0x58;\n            }\n            else {\n                puVar3 = in_ECX + 0x48;\n            }\n            lprc = *puVar3;\n            uStack36 = puVar3[1];\n            uStack32 = puVar3[2];\n            uStack28 = puVar3[3];\n            var_8h = var_4h;\n            goto code_r0x004277fe;\n        }\n        puVar3 = in_ECX + 0x38;\n    }\n    else {\n        puVar3 = in_ECX + 0x28;\n    }\n    lprc = *puVar3;\n    uStack36 = puVar3[1];\n    uStack32 = puVar3[2];\n    uStack28 = puVar3[3];\ncode_r0x004277fe:\n    if (arg_8h != 0) {\n        var_10h = 0;\n        var_14h = 0;\n    }\n    if ((*0x4400ec != 0) && ((*(in_ECX + 0x75) & 0xf0) != 0)) {\n        (*_sym.imp.USER32.dll_InflateRect)(&lprc, 0xffffffff, 0xffffffff);\n    }\n    arg_24h = var_4h;\n    if (*(in_ECX + 0x24) == 0) {\n        arg_24h = var_ch;\n    }\n    fcn.0042a281(&lprc, var_14h, var_10h, in_ECX + 0xc, *(in_ECX + 0x1c), *(in_ECX + 0x20), var_8h, arg_24h);\n    *(in_ECX + 0xc) = lprc;\n    *(in_ECX + 0x1c) = var_14h;\n    *(in_ECX + 0x10) = uStack36;\n    *(in_ECX + 0x14) = uStack32;\n    *(in_ECX + 0x20) = var_10h;\n    *(in_ECX + 0x18) = uStack28;\n    *(in_ECX + 0x24) = var_8h == var_4h;\n    return;\n}\n",
        "token_count": 915
    },
    "0042787d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042787d(int32_t param_1, int32_t *param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    \n    if (*param_2 != param_3) {\n        *param_2 = param_3;\n        if ((((*(param_1 + 0x70) & 0xa000) == 0) || ((*(param_1 + 0x70) & 0x5000) == 0)) || (*(param_1 + 0x7c) == 0)) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = 1;\n        }\n        *(param_1 + 0x7c) = uVar1;\n        if (*(param_1 + 0x80) == 0) {\n            uVar1 = fcn.004278cf();\n        }\n        else {\n            uVar1 = 0;\n        }\n        *(param_1 + 0x74) = uVar1;\n        fcn.00427767(0);\n    }\n    return;\n}\n",
        "token_count": 243
    },
    "004278cf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.004278cf(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    \n    uVar1 = 0;\n    uVar2 = *(param_1 + 0x78) & 0xa000;\n    if (*(param_1 + 0x7c) != 0) {\n        uVar2 = uVar2 == 0;\n    }\n    if ((uVar2 == 0) || ((*(param_1 + 0x70) & 0xa000) == 0)) {\n        if ((*(param_1 + 0x70) & 0x5000) == 0) goto code_r0x0042792a;\n        uVar1 = *(param_1 + 0x70) & 0xffff5fff;\n        puVar3 = param_1 + 0x38;\n    }\n    else {\n        uVar1 = *(param_1 + 0x70) & 0xffffafff;\n        puVar3 = param_1 + 0x28;\n    }\n    uVar1 = fcn.0042a11c(*puVar3, puVar3[1], puVar3[2], puVar3[3], uVar1, 0);\ncode_r0x0042792a:\n    if ((*(param_1 + 0x7c) == 0) && (uVar1 == 0)) {\n        if ((*(param_1 + 0x70) & 0xa000) != 0) {\n            fcn.0042a11c(*(param_1 + 0x38), *(param_1 + 0x3c), *(param_1 + 0x40), *(param_1 + 0x44), \n                         *(param_1 + 0x70) & 0xffffafff, 0);\n            uVar2 = *(param_1 + 0x70) & 0xffffafff;\n            uVar1 = fcn.0042a11c(*(param_1 + 0x28), *(param_1 + 0x2c), *(param_1 + 0x30), *(param_1 + 0x34), uVar2, 0);\n            uVar1 = ~-(uVar1 != uVar2) & uVar1;\n        }\n        if ((uVar1 == 0) && ((*(param_1 + 0x70) & 0x5000) != 0)) {\n            fcn.0042a11c(*(param_1 + 0x28), *(param_1 + 0x2c), *(param_1 + 0x30), *(param_1 + 0x34), \n                         *(param_1 + 0x70) & 0xffff5fff, 0);\n            uVar2 = *(param_1 + 0x70) & 0xffff5fff;\n            uVar1 = fcn.0042a11c(*(param_1 + 0x38), *(param_1 + 0x3c), *(param_1 + 0x40), *(param_1 + 0x44), uVar2, 0);\n            uVar1 = ~-(uVar1 != uVar2) & uVar1;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 752
    },
    "0042858c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042858c(uint arg_8h, uint lpIconName)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint var_58h;\n    uint var_38h;\n    int32_t lpClassName;\n    uint lpWndClass;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    \n    iVar1 = fcn.0042d07c();\n    iVar1 = (*_sym.imp.USER32.dll_LoadIconA)(*(iVar1 + 0xc), lpIconName);\n    if (iVar1 != 0) {\n        fcn.00406030(&var_58h, 0, 0x30);\n        var_38h = arg_8h;\n        (**(*in_ECX + 100))(&var_58h);\n        if (lpClassName != 0) {\n            iVar2 = fcn.0042d07c();\n            iVar2 = (*_sym.imp.USER32.dll_GetClassInfoA)(*(iVar2 + 8), lpClassName, &lpWndClass);\n            if ((iVar2 != 0) && (var_14h != iVar1)) {\n                uVar3 = fcn.00418ef1(lpWndClass, var_10h, var_ch, iVar1);\n                return uVar3;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 318
    },
    "004287f6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004287f6(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    bool bVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    if ((param_1[0x27] == NULL) || (iVar3 = (*param_1[0x27])(param_1),  iVar3 != 0)) {\n        iVar3 = *param_1;\n        piVar4 = (**(iVar3 + 0xc4))();\n        if ((piVar4 == NULL) || (iVar5 = (**(*piVar4 + 0x94))(param_1),  iVar5 != 0)) {\n            iVar5 = fcn.0042d07c();\n            piVar1 = *(iVar5 + 4);\n            if (piVar1[7] == param_1) {\n                if ((piVar4 == NULL) && (iVar5 = (**(*piVar1 + 0x90))(),  iVar5 == 0)) {\n                    return;\n                }\n                fcn.0042135b();\n                fcn.004215bb();\n                iVar5 = fcn.0042a1c4();\n                if (iVar5 == 0) {\n                    fcn.0042a1d4(0);\n                    return;\n                }\n                iVar5 = fcn.0042d07c();\n                if ((*(iVar5 + 0x14) == '\\0') && (piVar1[7] == 0)) {\n                    fcn.0042e28c(0);\n                    return;\n                }\n            }\n            if ((piVar4 != NULL) && (piVar4[0x12] != 0)) {\n                iVar5 = *piVar4;\n                bVar2 = false;\n                var_4h = (**(iVar5 + 0x68))();\n                do {\n                    if (var_4h == 0) goto code_r0x004288d9;\n                    (**(iVar5 + 0x6c))(&var_4h);\n                    piVar4 = fcn.004197f4();\n                } while (piVar4 == param_1);\n                bVar2 = true;\ncode_r0x004288d9:\n                if (!bVar2) {\n                    (**(iVar5 + 0x84))();\n                    return;\n                }\n                (**(iVar5 + 0x9c))(param_1);\n            }\n            (**(iVar3 + 0x60))();\n        }\n    }\n    return;\n}\n",
        "token_count": 584
    },
    "00428aa9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00428aa9(int32_t arg_8h, int32_t *arg_ch, int32_t arg_10h)\n\n{\n    bool bVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t *in_ECX;\n    \n    fcn.004180f1();\n    uVar2 = fcn.0041ae7b();\n    piVar5 = in_ECX;\n    if ((uVar2 & 0x40000000) == 0) {\n        piVar5 = fcn.00419961();\n    }\n    if (arg_8h != 0) {\n        arg_ch = in_ECX;\n    }\n    if ((piVar5 == arg_ch) ||\n       ((piVar3 = fcn.00419961(),  piVar5 == piVar3 &&\n        (iVar4 = (*_sym.imp.USER32.dll_SendMessageA)(arg_ch[7], 0x36d, 0x40, 0),  iVar4 != 0)))) {\n        bVar1 = true;\n    }\n    else {\n        bVar1 = false;\n    }\n    piVar5[9] = piVar5[9] & 0xffffffdf;\n    if (bVar1) {\n        piVar5[9] = piVar5[9] | 0x20;\n    }\n    fcn.004282fa((-bVar1 & 0xfffffffc) + 8);\n    piVar5 = fcn.00428e8c();\n    if (piVar5 == NULL) {\n        (**(*in_ECX + 200))();\n        piVar5 = fcn.00428e8c();\n        if (piVar5 == NULL) {\n            return;\n        }\n    }\n    if ((arg_8h != 0) && (arg_10h == 0)) {\n        (**(*piVar5 + 0xec))(1, piVar5, piVar5);\n    }\n    (**(*piVar5 + 0xf0))(arg_8h);\n    return;\n}\n",
        "token_count": 471
    },
    "00428bb4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00428bb4(int32_t param_1, uint32_t param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    iVar2 = fcn.00419961();\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    param_2 = param_2 & 0xfff0;\n    if (*(iVar2 + 0x50) == 0) {\ncode_r0x00428be0:\n        fcn.004180f1();\n    }\n    else {\n        if (param_2 < 0xf011) {\n            if ((param_2 != 0xf010) && (param_2 != 0xf000)) goto code_r0x00428be0;\n        }\n        else if (param_2 != 0xf020) {\n            if (((((param_2 != 0xf030) && (param_2 != 0xf040)) && (param_2 != 0xf050)) &&\n                ((param_2 != 0xf060 && (param_2 != 0xf120)))) && (param_2 != 0xf130)) goto code_r0x00428be0;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x1c), 0x365, 0, (param_2 - 0xf000 >> 4) + 0x1ef00);\n        if (iVar2 == 0) {\n            (*pcVar1)(*(param_1 + 0x1c), 0x111, 0xe147, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 366
    },
    "00428d1b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00428d1b(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    int16_t iVar5;\n    uint var_108h;\n    int32_t var_4h;\n    \n    uVar4 = fcn.0042d07c();\n    pcVar2 = _sym.imp.KERNEL32.dll_GlobalGetAtomNameA;\n    iVar1 = *(uVar4 + 4);\n    if ((((arg_ch != 0) && (iVar5 = arg_ch >> 0x10,  iVar5 != 0)) && (arg_ch == *(iVar1 + 0xb0))) &&\n       (iVar5 == *(iVar1 + 0xb2))) {\n        (*_sym.imp.KERNEL32.dll_GlobalGetAtomNameA)(uVar4 & 0xffff0000 | *(iVar1 + 0xb0), &var_108h, 0x103);\n        pcVar3 = _sym.imp.KERNEL32.dll_GlobalAddAtomA;\n        (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(&var_108h);\n        (*pcVar2)(&var_108h & 0xffff0000 | *(iVar1 + 0xb2), &var_108h, 0x103);\n        (*pcVar3)(&var_108h);\n        (*_sym.imp.USER32.dll_SendMessageA)(arg_8h, 0x3e4, *(var_4h + 0x1c), *(iVar1 + 0xb0));\n    }\n    return 0;\n}\n",
        "token_count": 364
    },
    "00428e93": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00428e93(int32_t param_1, int32_t *param_2, int32_t param_3)\n\n{\n    int32_t *piVar1;\n    \n    piVar1 = *(param_1 + 0x98);\n    if (param_2 != piVar1) {\n        *(param_1 + 0x98) = 0;\n        if (piVar1 != NULL) {\n            (**(*piVar1 + 0xec))(0, param_2, piVar1);\n        }\n        if (((*(param_1 + 0x98) == 0) && (*(param_1 + 0x98) = param_2,  param_2 != NULL)) && (param_3 != 0)) {\n            (**(*param_2 + 0xec))(1, param_2, piVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 199
    },
    "00428f18": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00428f18(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    \n    piVar1 = fcn.00429d3c();\n    if (arg_10h == 0) {\n        fcn.0041af6d(0, 0, 0, 0, 0, (-(arg_ch != 0) & 0xffffffc0) + 0x80 | 0x17);\n        (**(*arg_8h + 0xcc))(arg_ch);\n        if ((arg_ch != 0) || (iVar2 = fcn.00429d4d(),  iVar2 == 0)) {\n            (**(*piVar1 + 0xd0))(0);\n        }\n    }\n    else {\n        (**(*arg_8h + 0xcc))(arg_ch);\n        piVar1[0x2e] = piVar1[0x2e] | 0xc;\n    }\n    iVar2 = fcn.00429d4d();\n    if (iVar2 == 0) {\n        return;\n    }\n    if (arg_8h[0x1c] == NULL) {\n        uVar3 = arg_ch != 0;\n    }\n    else {\n        uVar3 = (**(*arg_8h[0x1c] + 0xe8))();\n    }\n    if ((uVar3 == 1) && (arg_ch != 0)) {\n        piVar1[0x22] = -1;\n        if (arg_10h == 0) {\n            uVar4 = 8;\ncode_r0x00428ff3:\n            fcn.0041afbc(uVar4);\n            return;\n        }\n        piVar1[0x22] = 8;\n    }\n    else {\n        if (uVar3 == 0) {\n            piVar1[0x22] = -1;\n            if (arg_10h != 0) {\n                piVar1[0x22] = 0;\n                return;\n            }\n            uVar4 = 0;\n            goto code_r0x00428ff3;\n        }\n        if (arg_10h != 0) {\n            return;\n        }\n    }\n    (**(*piVar1 + 0xd0))(0);\n    return;\n}\n",
        "token_count": 546
    },
    "00429013": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00429013(int32_t arg_8h, uint noname_1, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    int32_t in_ECX;\n    int32_t iVar8;\n    int32_t iVar9;\n    uint var_2ch;\n    uint32_t var_28h;\n    uint32_t var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.0042040f(*(in_ECX + 0x1c));\n    if (arg_10h == 0) {\n        fcn.00416a51();\n        iVar2 = fcn.0042cd29();\n        pcVar1 = _sym.imp.USER32.dll_GetMenu;\n        if ((((*(iVar2 + 0x54) != *(arg_8h + 4)) &&\n             (iVar2 = (*_sym.imp.USER32.dll_GetMenu)(*(in_ECX + 0x1c)),  iVar2 != 0)) &&\n            (iVar2 = fcn.0041987d(),  iVar2 != 0)) && (iVar2 = (*pcVar1)(*(iVar2 + 0x1c)),  iVar2 != 0)) {\n            iVar3 = (*_sym.imp.USER32.dll_GetMenuItemCount)(iVar2);\n            iVar8 = 0;\n            if (0 < iVar3) {\n                do {\n                    iVar9 = iVar8;\n                    iVar4 = (*_sym.imp.USER32.dll_GetSubMenu)(iVar2, iVar8);\n                    if (iVar4 == *(arg_8h + 4)) {\n                        fcn.0041b68e(iVar9, iVar2);\n                        break;\n                    }\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < iVar3);\n            }\n        }\n        var_ch = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(arg_8h + 4));\n        pcVar1 = _sym.imp.USER32.dll_GetMenuItemID;\n        var_24h = 0;\n        if (var_ch != 0) {\n            do {\n                var_28h = (*pcVar1)(*(arg_8h + 4), var_24h);\n                uVar6 = var_ch;\n                if (var_28h != 0) {\n                    if (var_28h == 0xffffffff) {\n                        uVar5 = (*_sym.imp.USER32.dll_GetSubMenu)(*(arg_8h + 4), var_24h);\n                        iVar2 = fcn.0041b68e(uVar5);\n                        if (((iVar2 == 0) || (var_28h = (*pcVar1)(*(iVar2 + 4), 0),  var_28h == 0)) ||\n                           (var_28h == 0xffffffff)) goto code_r0x00429162;\n                        uVar5 = 0;\n                    }\n                    else if ((*(in_ECX + 0x3c) == 0) || (0xefff < var_28h)) {\n                        uVar5 = 0;\n                    }\n                    else {\n                        uVar5 = 1;\n                    }\n                    fcn.00416c11(in_ECX, uVar5);\n                    uVar6 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(arg_8h + 4));\n                    if (uVar6 < var_ch) {\n                        var_24h = var_24h + (uVar6 - var_ch);\n                        while ((var_24h < uVar6 && (uVar7 = (*pcVar1)(*(arg_8h + 4), var_24h),  uVar7 == var_28h))) {\n                            var_24h = var_24h + 1;\n                        }\n                    }\n                }\ncode_r0x00429162:\n                var_ch = uVar6;\n                var_24h = var_24h + 1;\n            } while (var_24h < var_ch);\n        }\n    }\n    return;\n}\n",
        "token_count": 940
    },
    "004293fb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_24h\n\nvoid fcn.004293fb(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *puVar4;\n    uint *in_FS_OFFSET;\n    uint var_28h;\n    uint var_24h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    fcn.00415cf9(10);\n    *(unaff_EBP + -4) = 0;\n    puVar4 = *(extraout_ECX + 0x70);\n    while (puVar4 != NULL) {\n        puVar1 = *puVar4;\n        iVar2 = (**(*puVar4[2] + 0xd8))();\n        puVar4 = puVar1;\n        if (iVar2 != 0) {\n            fcn.00415df9();\n        }\n    }\n    puVar4 = *(unaff_EBP + -0x24);\n    while (puVar4 != NULL) {\n        puVar1 = *puVar4;\n        if (puVar4[2][0x1e] == 0) {\n            (**(*puVar4[2] + 0x60))();\n            puVar4 = puVar1;\n        }\n        else {\n            piVar3 = fcn.004197f4();\n            (**(*piVar3 + 0x60))();\n            puVar4 = puVar1;\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00415d58();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 398
    },
    "00429484": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00429484(int32_t param_1, uint32_t param_2)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    \n    if (param_2 == 0) {\ncode_r0x004294b1:\n        iVar3 = 0;\n    }\n    else {\n        puVar4 = *(param_1 + 0x70);\n        do {\n            if (puVar4 == NULL) goto code_r0x004294b1;\n            puVar1 = *puVar4;\n            iVar3 = puVar4[2];\n            uVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(iVar3 + 0x1c));\n            puVar4 = puVar1;\n        } while ((uVar2 & 0xffff) != param_2);\n    }\n    return iVar3;\n}\n",
        "token_count": 208
    },
    "004296db": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004296db(int32_t lpString2)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint lpString1;\n    \n    uVar2 = fcn.0041ae7b();\n    pcVar1 = _sym.imp.KERNEL32.dll_lstrcatA;\n    if ((uVar2 & 0x4000) == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(&lpString1, *(in_ECX + 0xac));\n        pcVar1 = _sym.imp.KERNEL32.dll_lstrcatA;\n        if (lpString2 != 0) {\n            (*_sym.imp.KERNEL32.dll_lstrcatA)(&lpString1, 0x4324d0);\n            (*pcVar1)(&lpString1, lpString2);\n            if (0 < *(in_ECX + 0x40)) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(&lpString1, 0x4324d4, *(in_ECX + 0x40));\n                (*_sym.imp.USER32.dll_wsprintfA)(&lpString1 + iVar3);\n            }\n        }\n    }\n    else {\n        lpString1._0_1_ = 0;\n        if (lpString2 != 0) {\n            (*_sym.imp.KERNEL32.dll_lstrcpyA)(&lpString1, lpString2);\n            if (0 < *(in_ECX + 0x40)) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(&lpString1, 0x4324d4, *(in_ECX + 0x40));\n                (*_sym.imp.USER32.dll_wsprintfA)(&lpString1 + iVar3);\n            }\n            (*pcVar1)(&lpString1, 0x4324d0);\n        }\n        (*pcVar1)(&lpString1, *(in_ECX + 0xac));\n    }\n    fcn.0042039e(*(in_ECX + 0x1c), &lpString1);\n    return;\n}\n",
        "token_count": 479
    },
    "00429c15": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00429c15(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    uint32_t uVar6;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetKeyState;\n    iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(0x11);\n    if (iVar2 < 0) {\n        uVar6 = 8;\n    }\n    else {\n        uVar6 = 0;\n    }\n    iVar2 = (*pcVar1)(0x10);\n    if (iVar2 < 0) {\n        uVar3 = 4;\n    }\n    else {\n        uVar3 = 0;\n    }\n    iVar4 = (*_sym.imp.USER32.dll_GetFocus)();\n    iVar5 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    if (iVar4 == 0) {\n        arg_ch = (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x20a, arg_8h << 0x10 | uVar6 | uVar3, arg_ch);\n    }\n    else {\n        do {\n            arg_ch = (*_sym.imp.USER32.dll_SendMessageA)(iVar4, 0x20a, arg_8h << 0x10 | uVar6 | uVar3, arg_ch);\n            iVar4 = (*_sym.imp.USER32.dll_GetParent)(iVar4);\n            if (arg_ch != 0) {\n                return arg_ch;\n            }\n            if (iVar4 == 0) {\n                return 0;\n            }\n        } while (iVar4 != iVar5);\n    }\n    return arg_ch;\n}\n",
        "token_count": 415
    },
    "00429d4d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00429d4d(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (**(*param_1 + 0xd8))();\n    if (iVar1 != 0) {\n        return param_1[0x1e];\n    }\n    if ((param_1[0x1c] != 0) && (*(param_1[0x1c] + 0x78) != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 121
    },
    "00429f90": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00429f90(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t *puVar3;\n    uint var_4h;\n    \n    if (arg_ch == 0) {\n        puVar3 = 0x432f40;\n        do {\n            uVar2 = *puVar3;\n            iVar1 = fcn.00429484();\n            if (iVar1 != 0) {\n                uVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_8h + 0x1c), 0xffffffff);\n                uVar2 = uVar2 & 0xffff;\n                iVar1 = fcn.00425845(uVar2);\n                if (0 < iVar1) break;\n            }\n            if (((*(arg_8h + 100) ^ puVar3[1]) & 0xf000) == 0) {\n                fcn.00429484(*puVar3, uVar2);\n            }\n            puVar3 = puVar3 + 2;\n        } while (puVar3 < 0x432f60);\n    }\n    fcn.00424f12(arg_8h, arg_10h);\n    return;\n}\n",
        "token_count": 291
    },
    "0042a01f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a01f(int32_t arg_8h, uint arg_ch, uint arg_10h, uint32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    uint var_4h;\n    \n    if ((((*(arg_8h + 0x6c) == 0) || (iVar1 = *(arg_8h + 0x70),  iVar1 == 0)) || (*(iVar1 + 0x78) == 0)) ||\n       ((iVar2 = fcn.00424c6f(),  iVar2 != 1 || ((*(iVar1 + 100) & arg_14h & 0xf000) == 0)))) {\n        uVar5 = arg_14h;\n        if (((*(arg_8h + 100) & 4) != 0) && (uVar5 = arg_14h | 4,  (arg_14h & 0x5000) != 0)) {\n            uVar5 = arg_14h & 0xffff2fff | 0x2004;\n        }\n        arg_14h = uVar5;\n        piVar4 = fcn.00429e45(arg_14h);\n        fcn.0041af6d(0, arg_ch, arg_10h, 0, 0, 0x15);\n        if (piVar4[8] == 0) {\n            piVar4[8] = *(arg_8h + 0x1c);\n        }\n        fcn.0041adf0(0xe81f);\n        fcn.00424cd7(arg_8h, 0);\n        (**(*piVar4 + 0xd0))(1);\n        uVar5 = (*_sym.imp.USER32.dll_GetWindowLongA)(*(arg_8h + 0x1c), 0xfffffff0);\n        if ((uVar5 & 0x10000000) == 0) {\n            return;\n        }\n        fcn.0041afbc(8);\n    }\n    else {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(*(iVar1 + 0x1c));\n        piVar4 = fcn.0041819c(uVar3);\n        fcn.0041af6d(0, arg_ch, arg_10h, 0, 0, 0x15);\n        (**(*piVar4 + 0xd0))(1);\n    }\n    (*_sym.imp.USER32.dll_UpdateWindow)(piVar4[7]);\n    return;\n}\n",
        "token_count": 594
    },
    "0042a11c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl\nfcn.0042a11c(uint lprcSrc2, uint noname_1, uint noname_2, uint noname_3, uint32_t arg_18h, int32_t **arg_1ch)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint *puVar5;\n    int32_t lprcSrc1;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    ppiVar3 = arg_1ch;\n    arg_18h = arg_18h & 0xf040;\n    if (arg_1ch != NULL) {\n        *arg_1ch = NULL;\n    }\n    puVar5 = *(in_ECX + 0x70);\n    do {\n        do {\n            if (puVar5 == NULL) {\n                return 0;\n            }\n            puVar1 = *puVar5;\n            piVar2 = puVar5[2];\n            iVar4 = (**(*piVar2 + 0xd8))();\n            puVar5 = puVar1;\n        } while ((((iVar4 == 0) || (iVar4 = (*_sym.imp.USER32.dll_IsWindowVisible)(piVar2[7]),  iVar4 == 0)) ||\n                 ((piVar2[0x19] & arg_18h & 0xf000) == 0)) ||\n                ((piVar2[0x1e] != 0 && ((piVar2[0x19] & arg_18h & 0x40) == 0))));\n        (*_sym.imp.USER32.dll_GetWindowRect)(piVar2[7], &lprcSrc1);\n        if (var_8h == lprcSrc1) {\n            var_8h = var_8h + 1;\n        }\n        if (var_4h == var_ch) {\n            var_4h = var_4h + 1;\n        }\n        iVar4 = (*_sym.imp.USER32.dll_IntersectRect)(&lprcSrc1, &lprcSrc1, &lprcSrc2);\n    } while (iVar4 == 0);\n    if (ppiVar3 != NULL) {\n        *ppiVar3 = piVar2;\n    }\n    return piVar2[0x19] & arg_18h;\n}\n",
        "token_count": 547
    },
    "0042a9f3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0042a9f3(void)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    uint uVar4;\n    \n    if (*0x4400f4 == 0) {\n        uVar2 = fcn.0041ae7b();\n        pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n        if ((uVar2 & 0x40600) == 0) {\n            iVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(6);\n            uVar4 = 5;\n        }\n        else {\n            iVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x21);\n            uVar4 = 0x20;\n        }\n        iVar3 = (*pcVar1)(uVar4, -iVar3);\n        (*_sym.imp.USER32.dll_InflateRect)(unaff_retaddr, -iVar3);\n        if ((uVar2 & 0xc00000) != 0) {\n            *(unaff_retaddr + 4) = *(unaff_retaddr + 4) + *0x4404ac;\n        }\n    }\n    else {\n        fcn.004180f1();\n    }\n    return;\n}\n",
        "token_count": 280
    },
    "0042aa59": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0042aa59(int32_t pt, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    int32_t lprcSrc;\n    int32_t var_68h;\n    int32_t var_64h;\n    int32_t var_60h;\n    uint lprcDst;\n    int32_t lpRect;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t dy;\n    int32_t dx;\n    uint32_t var_4h;\n    \n    var_4h = fcn.0041ae7b();\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x1c), &lpRect);\n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    iVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x21);\n    dy = iVar3;\n    dx = (*pcVar1)(0x20);\n    if (*0x4400f4 != 0) {\n        uVar4 = fcn.004180f1();\n        if ((*0x4400ec != 0) && ((var_4h & 0x1000) != 0)) {\n            if (uVar4 == 3) {\n                uVar4 = 2;\n            }\n            iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(2);\n            if (iVar2 < 0) {\n                return 0;\n            }\n        }\n        if (((uVar4 < 10) || (0x11 < uVar4)) && (uVar4 != 4)) {\n            return uVar4;\n        }\n        if ((var_4h & 0x800) != 0) {\n            return 2;\n        }\n        (*_sym.imp.USER32.dll_InflateRect)(&lpRect, -dx, -iVar3);\n        if ((var_4h & 0x200) == 0) {\n            return uVar4;\n        }\n        if (uVar4 != 4) {\n            if (uVar4 == 0xd) {\n                uVar4 = (var_24h <= arg_ch) - 1 & 2;\ncode_r0x0042ab4c:\n                return uVar4 + 10;\n            }\n            if (uVar4 == 0xe) {\n                uVar4 = arg_ch < var_24h;\n                goto code_r0x0042ab63;\n            }\n            if (uVar4 == 0x10) {\n                uVar4 = (arg_ch <= var_1ch) - 1 & 5;\n                goto code_r0x0042ab4c;\n            }\n            if (uVar4 != 0x11) {\n                return uVar4;\n            }\n        }\n        uVar4 = (arg_ch <= var_1ch) - 1 & 4;\ncode_r0x0042ab63:\n        return uVar4 + 0xb;\n    }\n    iVar3 = (*_sym.imp.USER32.dll_PtInRect)(&lpRect, pt, arg_ch);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    var_10h = (*pcVar1)(6);\n    iVar3 = (*pcVar1)(5);\n    var_68h = var_24h;\n    lprcSrc = lpRect;\n    var_60h = var_1ch;\n    var_64h = var_20h;\n    fcn.0042a9f3(0, &lprcSrc);\n    (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, &lprcSrc);\n    iVar5 = (*_sym.imp.USER32.dll_PtInRect)(&lprcDst, pt, arg_ch);\n    if (iVar5 != 0) {\n        return 1;\n    }\n    if ((var_4h & 0x40600) == 0) goto code_r0x0042ad1e;\n    var_18h = 0;\n    iVar3 = dx + iVar3 * -3 + *0x4404a8;\n    iVar5 = dy + var_10h * -2 + *0x4404ac;\n    if (arg_ch < dy + var_24h) {\n        if ((var_4h & 0x200) == 0) {\n            if (lpRect + iVar3 < pt) {\n                uVar4 = ((pt < var_20h - iVar3) - 1 & 2) + 0xc;\n            }\n            else {\ncode_r0x0042acaf:\n                uVar4 = 0xd;\n            }\n        }\n        else {\n            uVar4 = 0xc;\n        }\n    }\n    else {\n        var_14h = var_1ch - dy;\n        if (arg_ch < var_14h) {\n            if (pt < lpRect + dx) {\n                if ((var_4h & 0x200) == 0) {\n                    if (arg_ch <= iVar5 + var_24h) goto code_r0x0042acaf;\n                    uVar4 = ((arg_ch < var_1ch - iVar5) - 1 & 6) + 10;\n                }\n                else {\n                    uVar4 = 10;\n                }\n            }\n            else if (pt < var_20h - dx) {\n                uVar4 = 0;\n            }\n            else if ((var_4h & 0x200) == 0) {\n                if (iVar5 + var_24h < arg_ch) {\n                    uVar4 = ((arg_ch < var_1ch - iVar5) - 1 & 6) + 0xb;\n                }\n                else {\n                    uVar4 = 0xe;\n                }\n            }\n            else {\n                uVar4 = 0xb;\n            }\n        }\n        else if ((var_4h & 0x200) == 0) {\n            if (lpRect + iVar3 < pt) {\n                uVar4 = ((pt < var_20h - iVar3) - 1 & 2) + 0xf;\n            }\n            else {\n                uVar4 = 0x10;\n            }\n        }\n        else {\n            uVar4 = 0xf;\n        }\n    }\n    if (uVar4 != 0) {\n        if ((var_4h & 0x800) != 0) {\n            return 2;\n        }\n        return uVar4;\n    }\n    (*_sym.imp.USER32.dll_InflateRect)(&lpRect, -dx, -dy);\ncode_r0x0042ad1e:\n    var_1ch = var_10h + var_24h + *0x4404ac;\n    iVar3 = (*_sym.imp.USER32.dll_PtInRect)(&lpRect, pt, arg_ch);\n    if (iVar3 == 0) {\n        return 0xfffffffe;\n    }\n    if ((pt < lpRect + -2 + *0x4404a8) && ((var_4h & 0x80000) != 0)) {\n        return 3;\n    }\n    return 2;\n}\n",
        "token_count": 1651
    },
    "0042ad66": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042ad66(int32_t param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    \n    if ((*0x4400f4 == 0) && (param_2 == 3)) {\n        *(param_1 + 0xbc) = 1;\n        *(param_1 + 0xc0) = 1;\n        uVar1 = (*_sym.imp.USER32.dll_SetCapture)(*(param_1 + 0x1c));\n        fcn.0041819c(uVar1);\n        fcn.0042ae92();\n    }\n    else {\n        fcn.004180f1();\n    }\n    return;\n}\n",
        "token_count": 153
    },
    "0042b62c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042b62c(int32_t lpRect, uint32_t dwStyle)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    if (*0x4400f4 == 0) {\n        if ((dwStyle & 0x40600) == 0) {\n            uVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(6);\n            uVar3 = 5;\n        }\n        else {\n            uVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x21);\n            uVar3 = 0x20;\n        }\n        uVar2 = (*pcVar1)(uVar3, uVar2);\n        (*_sym.imp.USER32.dll_InflateRect)(lpRect, uVar2);\n        if ((dwStyle & 0xc00000) != 0) {\n            fcn.0042a67a();\n            *(lpRect + 4) = *(lpRect + 4) - *0x4404ac;\n        }\n    }\n    else {\n        (*_sym.imp.USER32.dll_AdjustWindowRectEx)(lpRect, dwStyle, 0, 0x188);\n    }\n    return;\n}\n",
        "token_count": 282
    },
    "0042bea5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042bea5(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if (*(param_1 + 0xa8) != NULL) {\n        (**(**(param_1 + 0xa8) + 0x10))();\n    }\n    if (*(param_1 + 0xb4) != 0) {\n        iVar1 = fcn.0042d07c();\n        fcn.00425dd6(0x4314e0, \"PreviewPages\", *(*(iVar1 + 4) + 0xb4));\n    }\n    return;\n}\n",
        "token_count": 136
    },
    "0042caff": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042caff(uint lpAppName, uint lpValueName, int32_t nDefault)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_8h;\n    int32_t var_4h;\n    \n    if (*(in_ECX + 0x7c) == 0) {\n        nDefault = (*_sym.imp.KERNEL32.dll_GetPrivateProfileIntA)(lpAppName, lpValueName, nDefault, *(in_ECX + 0x90));\n    }\n    else {\n        var_4h = in_ECX;\n        iVar1 = fcn.0042cab9(lpAppName);\n        if (iVar1 != 0) {\n            lpAppName = 4;\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(iVar1, lpValueName, 0, &var_8h, &var_4h, &lpAppName);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n            if (iVar2 == 0) {\n                nDefault = var_4h;\n            }\n        }\n    }\n    return nDefault;\n}\n",
        "token_count": 262
    },
    "0042cdde": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid fcn.0042cdde(void)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    *extraout_ECX = vtable.AFX_MODULE_STATE.0;\n    puVar1 = extraout_ECX[0x411];\n    *(unaff_EBP + -4) = 1;\n    if (puVar1 != NULL) {\n        (***puVar1)(1);\n    }\n    if (extraout_ECX[0x41b] != NULL) {\n        iVar3 = -(*(extraout_ECX[0x41b] + 0xc) != 0);\n        *(unaff_EBP + -0x14) = iVar3;\n        if (iVar3 != 0) {\n            do {\n                fcn.00416397();\n                if (*(unaff_EBP + -0x10) != extraout_ECX + 0x412) {\n                    fcn.004166cf(*(unaff_EBP + -0x10));\n                }\n            } while (*(unaff_EBP + -0x14) != 0);\n        }\n        if (extraout_ECX[0x41b] != NULL) {\n            (**(*extraout_ECX[0x41b] + 4))(1);\n        }\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.0042d901();\n    uVar2 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.CNoTrackObject.0;\n    *in_FS_OFFSET = uVar2;\n    return;\n}\n",
        "token_count": 489
    },
    "0042cf17": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042cf17(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.AFX_MODULE_THREAD_STATE.0;\n    pcVar1 = extraout_ECX[5];\n    *(unaff_EBP + -4) = 3;\n    if (pcVar1 != NULL) {\n        fcn.00404673();\n        fcn.004166cf(pcVar1);\n    }\n    pcVar1 = extraout_ECX[6];\n    if (pcVar1 != NULL) {\n        fcn.00404673();\n        fcn.004166cf(pcVar1);\n    }\n    pcVar1 = extraout_ECX[7];\n    if (pcVar1 != NULL) {\n        fcn.00404673();\n        fcn.004166cf(pcVar1);\n    }\n    pcVar1 = extraout_ECX[8];\n    if (pcVar1 != NULL) {\n        fcn.00404673();\n        fcn.004166cf(pcVar1);\n    }\n    pcVar1 = extraout_ECX[9];\n    if (pcVar1 != NULL) {\n        fcn.00404673();\n        fcn.004166cf(pcVar1);\n    }\n    pcVar1 = extraout_ECX[0x1d];\n    while (pcVar1 != NULL) {\n        uVar2 = fcn.00415e22();\n        fcn.004166cf(uVar2);\n        pcVar1 = extraout_ECX[0x1d];\n    }\n    *(unaff_EBP + -4) = 2;\n    fcn.00415d58();\n    *(unaff_EBP + -4) = 1;\n    fcn.0041620a();\n    *(unaff_EBP + -4) = 0;\n    fcn.0041620a();\n    uVar2 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.CNoTrackObject.0;\n    *in_FS_OFFSET = uVar2;\n    return;\n}\n",
        "token_count": 552
    },
    "0042d1ba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0042d1ba(void)\n\n{\n    code *pcVar1;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    if (*0x4400ec != 0) {\n        *0x440090 = (*_sym.imp.USER32.dll_GetSystemMetrics)(2);\n        *0x440090 = *0x440090 + 1;\n        *0x440094 = (*pcVar1)(3);\n        *0x440094 = *0x440094 + 1;\n        *0x4400f8 = 1;\n    }\n    return;\n}\n",
        "token_count": 133
    },
    "0042d399": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "get OS version"
        ],
        "decompiled_code": "\nint32_t fcn.0042d399(void)\n\n{\n    uint32_t uVar1;\n    \n    if (*0x440230 == 0) {\n        *0x440230 = 1;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n        if ((uVar1 < 4) && ((uVar1 & 0x80000000) != 0)) {\n            *0x4403d0 = 1;\n        }\n        else {\n            *0x4403d0 = 0;\n        }\n        if (*0x4403d0 == 0) {\n            (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(0x4403d8);\n        }\n    }\n    return *0x440230;\n}\n",
        "token_count": 167
    },
    "0042d3e7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0042d3e7(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    \n    if (*0x440230 == 0) {\n        fcn.0042d399();\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_EnterCriticalSection;\n    if (*0x4403d0 == 0) {\n        piVar1 = param_1 * 4 + 0x4403f0;\n        if (*(param_1 * 4 + 0x4403f0) == 0) {\n            (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(0x4403d8);\n            if (*piVar1 == 0) {\n                (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(param_1 * 0x18 + 0x440238);\n                *piVar1 = *piVar1 + 1;\n            }\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(0x4403d8);\n        }\n        (*pcVar2)(param_1 * 0x18 + 0x440238);\n    }\n    return;\n}\n",
        "token_count": 254
    },
    "0042d457": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0042d457(int32_t param_1)\n\n{\n    if (*0x4403d0 == 0) {\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(param_1 * 0x18 + 0x440238);\n    }\n    return;\n}\n",
        "token_count": 65
    },
    "0042d4f4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0042d4f4(int32_t param_1)\n\n{\n    if (param_1 != 0) {\n        (*_sym.imp.KERNEL32.dll_LocalFree)(param_1);\n    }\n    return;\n}\n",
        "token_count": 52
    },
    "0042d7a9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042d7a9(uint *arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    bool bVar2;\n    uint *in_ECX;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar3 = 1;\n    bVar2 = true;\n    if (1 < arg_8h[2]) {\n        do {\n            if ((arg_ch == 0) || (*(in_ECX[4] + 4 + iVar3 * 8) == arg_ch)) {\n                puVar1 = *(arg_8h[3] + iVar3 * 4);\n                if (puVar1 != NULL) {\n                    (***puVar1)(1);\n                }\n                *(arg_8h[3] + iVar3 * 4) = 0;\n            }\n            else if (*(arg_8h[3] + iVar3 * 4) != 0) {\n                bVar2 = false;\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < arg_8h[2]);\n    }\n    if (bVar2) {\n        fcn.0042d48b(arg_8h);\n        (*_sym.imp.KERNEL32.dll_LocalFree)(arg_8h[3]);\n        if (arg_8h != NULL) {\n            (***arg_8h)(1);\n        }\n        (*_sym.imp.KERNEL32.dll_TlsSetValue)(*in_ECX, 0);\n    }\n    return;\n}\n",
        "token_count": 335
    },
    "0042d831": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042d831(uint *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint unaff_retaddr;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(param_1 + 7);\n    if (param_2 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*param_1);\n        if (iVar2 != 0) {\n            fcn.0042d7a9(iVar2, unaff_retaddr);\n        }\n    }\n    else {\n        iVar2 = param_1[5];\n        while (iVar2 != 0) {\n            iVar1 = *(iVar2 + 4);\n            fcn.0042d7a9(iVar2, unaff_retaddr);\n            iVar2 = iVar1;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(param_1 + 7);\n    return;\n}\n",
        "token_count": 219
    },
    "0042d88a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0042d8b1)\n\nint32_t __fastcall fcn.0042d88a(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    code *unaff_retaddr;\n    \n    if (*param_1 == 0) {\n        if (*0x440438 == NULL) {\n            *0x440438 = fcn.0042d508();\n        }\n        iVar1 = fcn.0042d54a();\n        *param_1 = iVar1;\n    }\n    iVar1 = *param_1;\n    iVar2 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(**0x440438);\n    if ((iVar2 == 0) || (*(iVar2 + 8) <= iVar1)) {\n        iVar1 = 0;\n    }\n    else {\n        iVar1 = *(*(iVar2 + 0xc) + iVar1 * 4);\n    }\n    if (iVar1 == 0) {\n        iVar1 = (*unaff_retaddr)();\n        fcn.0042d6b9(*param_1, iVar1);\n    }\n    return iVar1;\n}\n",
        "token_count": 260
    },
    "0042d91f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_14h\n\nint32_t fcn.0042d91f(void)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = &var_14h;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    if (*extraout_ECX == 0) {\n        fcn.0042d3e7(0x10);\n        *(unaff_EBP + -4) = 0;\n        if (*extraout_ECX == 0) {\n            iVar1 = (**(unaff_EBP + 8))();\n            *extraout_ECX = iVar1;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0042d457(0x10);\n    }\n    iVar1 = *extraout_ECX;\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1;\n}\n",
        "token_count": 293
    },
    "0042d98a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042d98a(int32_t *param_1)\n\n{\n    uint var_4h;\n    \n    if (*param_1 != 0) {\n        if (*param_1 != NULL) {\n            (****param_1)(1);\n        }\n    }\n    return;\n}\n",
        "token_count": 67
    },
    "0042df61": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0042df61(uint phkResult, uint lpString, int32_t lpValueName)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    bool bVar4;\n    \n    if (lpValueName == 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueA)(0x80000000, phkResult, 1, lpString, uVar1);\n        bVar4 = iVar2 == 0;\n    }\n    else {\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyA)(0x80000000, phkResult, &phkResult);\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(phkResult, lpValueName, 0, 1, lpString, iVar2 + 1);\n            iVar3 = (*_sym.imp.ADVAPI32.dll_RegCloseKey)(phkResult);\n            if ((iVar3 == 0) && (iVar2 == 0)) {\n                return true;\n            }\n        }\n        bVar4 = false;\n    }\n    return bVar4;\n}\n",
        "token_count": 305
    },
    "0042e041": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0042e041(uint param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    uint unaff_retaddr;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_SetErrorMode;\n    uVar2 = (*_sym.imp.KERNEL32.dll_SetErrorMode)(0);\n    (*pcVar1)(uVar2 | 0x8001);\n    iVar3 = fcn.0042d07c();\n    *(iVar3 + 8) = unaff_ESI;\n    *(iVar3 + 0xc) = unaff_ESI;\n    iVar3 = fcn.0042d07c();\n    iVar3 = *(iVar3 + 4);\n    if (iVar3 != 0) {\n        *(iVar3 + 0x68) = unaff_ESI;\n        *(iVar3 + 0x6c) = unaff_retaddr;\n        *(iVar3 + 0x70) = param_1;\n        *(iVar3 + 0x74) = param_2;\n        fcn.0042e0a4();\n    }\n    iVar3 = fcn.0042d07c();\n    if (*(iVar3 + 0x14) == '\\0') {\n        fcn.004176fb();\n    }\n    return 1;\n}\n",
        "token_count": 305
    },
    "0042e0a4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042e0a4(int32_t param_1)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint var_30ch;\n    uint lpFilename;\n    uint var_108h;\n    uchar *var_4h;\n    \n    iVar2 = fcn.0042d07c();\n    *(iVar2 + 8) = *(param_1 + 0x68);\n    *(iVar2 + 0xc) = *(param_1 + 0x68);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(*(param_1 + 0x68), &lpFilename, 0x104);\n    var_4h = fcn.00406600(&lpFilename, 0x2e);\n    *var_4h = 0;\n    fcn.0042e1c1(&lpFilename, &var_108h, 0x104);\n    if (*(param_1 + 0x88) == 0) {\n        uVar3 = fcn.00406190(&var_108h);\n        *(param_1 + 0x88) = uVar3;\n    }\n    if (*(param_1 + 0x78) == 0) {\n        iVar4 = fcn.0041c547(0xe000, &var_30ch, 0x100);\n        if (iVar4 == 0) {\n            puVar5 = *(param_1 + 0x88);\n        }\n        else {\n            puVar5 = &var_30ch;\n        }\n        uVar3 = fcn.00406190(puVar5);\n        *(param_1 + 0x78) = uVar3;\n    }\n    puVar1 = var_4h;\n    *(iVar2 + 0x10) = *(param_1 + 0x78);\n    if (*(param_1 + 0x8c) == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(var_4h, \".HLP\");\n        uVar3 = fcn.00406190(&lpFilename);\n        *(param_1 + 0x8c) = uVar3;\n        *puVar1 = 0;\n    }\n    if (*(param_1 + 0x90) == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcatA)(&var_108h, \".INI\");\n        uVar3 = fcn.00406190(&var_108h);\n        *(param_1 + 0x90) = uVar3;\n    }\n    return;\n}\n",
        "token_count": 591
    },
    "0042e1c1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0042e1c1(char *param_1, int32_t param_2, uint param_3)\n\n{\n    char cVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    \n    pcVar2 = param_1;\n    for (; *param_1 != '\\0'; param_1 = fcn.00406870(param_1)) {\n        cVar1 = *param_1;\n        if (((cVar1 == '\\\\') || (cVar1 == '/')) || (cVar1 == ':')) {\n            pcVar2 = fcn.00406870(param_1);\n        }\n    }\n    if (param_2 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(pcVar2);\n        iVar3 = iVar3 + 1;\n    }\n    else {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(param_2, pcVar2, param_3);\n        iVar3 = 0;\n    }\n    return iVar3;\n}\n",
        "token_count": 231
    },
    "0042e308": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042e308(void)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    uint *puVar4;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDocManager.0;\n    puVar1 = extraout_ECX[2];\n    *(unaff_EBP + -4) = 1;\n    while (puVar4 = puVar1,  puVar4 != NULL) {\n        puVar1 = *puVar4;\n        piVar2 = puVar4[2];\n        if ((piVar2[7] != 0) && (fcn.00415e46(puVar4),  piVar2 != NULL)) {\n            (**(*piVar2 + 4))(1);\n        }\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.00415d58();\n    uVar3 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.CObject.0;\n    *in_FS_OFFSET = uVar3;\n    return;\n}\n",
        "token_count": 355
    },
    "004031dd": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004031dd(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    *(in_ECX + 0x9c) = arg_ch;\n    *(in_ECX + 0xdc) = 0;\n    arg_ch_00 = 0x50002804;\n    if (arg_10h != 0) {\n        arg_ch_00 = 0x50002834;\n    }\n    iVar2 = fcn.0042c12a(arg_8h, arg_ch_00, 0xe806);\n    if (((iVar2 != 0) && (iVar2 = fcn.00403351(*(in_ECX + 0x9c)),  iVar2 != 0)) &&\n       (iVar2 = fcn.0042c2c1(0x43a1f0, 0x11),  iVar2 != 0)) {\n        var_10h = 0xffffff6a;\n        var_ch = 0xffffff6a;\n        var_8h = 0;\n        var_4h = 0;\n        iVar2 = fcn.00429d77(0x40200242, &var_10h);\n        pcVar1 = _sym.imp.GDI32.dll_GetStockObject;\n        if (iVar2 != 0) {\n            iVar2 = (*_sym.imp.GDI32.dll_GetStockObject)(0x11);\n            if (iVar2 == 0) {\n                iVar2 = (*pcVar1)(0xc);\n            }\n            (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0xbc), 0x30, iVar2, 0);\n            iVar2 = fcn.004032a3();\n            return iVar2 != 0;\n        }\n    }\n    return false;\n}\n",
        "token_count": 452
    },
    "004035b9": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004035b9(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t in_ECX;\n    uint var_2ch;\n    \n    iVar1 = fcn.0042852e(arg_8h);\n    if (iVar1 != -1) {\n        iVar1 = fcn.004039f3(&var_2ch);\n        if (iVar1 != 0) {\n            fcn.00418c24(&var_2ch);\n        }\n        fcn.0042d07c();\n        iVar1 = fcn.0042caff(\"General\", 0x43a3a0, 1);\n        *(in_ECX + 0xbc) = iVar1 != 0;\n        fcn.0042d07c();\n        iVar1 = fcn.0042caff(\"General\", 0x43a394, 1);\n        *(in_ECX + 0xc0) = iVar1 != 0;\n        iVar1 = fcn.0042c12a(in_ECX, -((iVar1 != 0) != 0) & 0x30 | 0x50002804, 0xe800);\n        if (((((((iVar1 != 0) && (iVar1 = fcn.0042c1d5((-(*(in_ECX + 0xbc) != 0) & 0xfffa) + 0x8f),  iVar1 != 0)) &&\n               (iVar1 = fcn.0042c2c1(0x43a238, 7),  iVar1 != 0)) &&\n              ((iVar1 = fcn.0042c12a(in_ECX, -(*(in_ECX + 0xc0) != 0) & 0x30 | 0x50002804, 0xe804),  iVar1 != 0 &&\n               (iVar1 = fcn.0042c1d5((-(*(in_ECX + 0xbc) != 0) & 0xfff3) + 0x90),  iVar1 != 0)))) &&\n             ((iVar1 = fcn.0042c2c1(0x43a258, 7),  iVar1 != 0 &&\n              ((iVar1 = fcn.0042c12a(in_ECX, -(*(in_ECX + 0xc0) != 0) & 0x30 | 0x50002804, 0xe805),  iVar1 != 0 &&\n               (iVar1 = fcn.0042c1d5((-(*(in_ECX + 0xbc) != 0) & 0xfffa) + 0x8c),  iVar1 != 0)))))) &&\n            (iVar1 = fcn.0042c2c1(0x43a278, 0xd),  iVar1 != 0)) &&\n           (((((iVar1 = fcn.004031dd(in_ECX, *(in_ECX + 0xbc), *(in_ECX + 0xc0)),  iVar1 != 0 &&\n               (iVar1 = fcn.0042c12a(in_ECX, -(*(in_ECX + 0xc0) != 0) & 0x30 | 0x50002804, 0xe807),  iVar1 != 0)) &&\n              (iVar1 = fcn.0042c1d5((-(*(in_ECX + 0xbc) != 0) & 0xfff2) + 0x93),  iVar1 != 0)) &&\n             (((iVar1 = fcn.0042c2c1(0x43a2b0, 5),  iVar1 != 0 &&\n               (iVar1 = fcn.0042c12a(in_ECX, -(*(in_ECX + 0xc0) != 0) & 0x30 | 0x50002802, 0xe808),  iVar1 != 0)) &&\n              ((iVar1 = fcn.0042c1d5(0x95 - (*(in_ECX + 0xbc) != 0)),  iVar1 != 0 &&\n               ((iVar1 = fcn.0042c2c1(0x43a2c8, 0xc),  iVar1 != 0 &&\n                (iVar1 = fcn.0042c5b3(in_ECX, 0x50008200, 0xe801),  iVar1 != 0)))))))) &&\n            (iVar1 = fcn.0042c64c(0x43a2f8, 4),  iVar1 != 0)))) {\n            fcn.0041af17(\"Standard\");\n            fcn.00425a26(0xf000);\n            fcn.0041af17(0x43a37c);\n            fcn.00425a26(0xf000);\n            fcn.0041af17(0x43a374);\n            fcn.00425a26(0xf000);\n            fcn.0041af17(0x43a36c);\n            fcn.00425a26(0xf000);\n            fcn.0041af17(0x43a364);\n            fcn.00425a26(0xf000);\n            fcn.0041af17(0x43a35c);\n            fcn.00425a26(0xf000);\n            fcn.00429e7e(0xf000);\n            fcn.00429f13(in_ECX + 0x140, 0xe81b, 0);\n            fcn.00403a3c(in_ECX + 0x314, in_ECX + 0x140);\n            fcn.00403a3c(in_ECX + 0x3f4, in_ECX + 0x314);\n            fcn.00429f13(in_ECX + 0x1dc, 0xe81e, 0);\n            fcn.00403a3c(in_ECX + 0x278, in_ECX + 0x1dc);\n            fcn.00429f13(in_ECX + 0x490, 0xe81d, 0);\n            fcn.0042d07c();\n            arg_8h_00 = fcn.0042caff(\"General\", \"Columns\", 3);\n            fcn.0040413c(arg_8h_00);\n            fcn.004244a2(\"General\");\n            return 0;\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 1438
    },
    "00404a7e": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404a7e(uint arg_8h, uint *arg_ch)\n\n{\n    uint *puVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_2ch;\n    int32_t var_ch;\n    int32_t var_8h;\n    \n    puVar1 = arg_ch;\n    puVar3 = &var_2ch;\n    for (iVar2 = 0xb; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = *puVar1;\n        puVar1 = puVar1 + 1;\n        puVar3 = puVar3 + 1;\n    }\n    if (((var_ch == 0) && (var_8h != -1)) && (var_8h != 0)) {\n        iVar2 = fcn.004165d1(var_8h, &arg_ch);\n        if (iVar2 == 0) {\n            puVar1 = fcn.00416615(var_8h);\n            *puVar1 = 0;\n        }\n        fcn.004165f3(var_8h, &var_8h);\n    }\n    (**(*in_ECX + 0xa8))(0x404, arg_8h, &var_2ch);\n    return;\n}\n",
        "token_count": 299
    },
    "00405540": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t fcn.00405540(int32_t param_1, int32_t param_2, int32_t param_3, uint32_t *param_4, uint32_t *param_5)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    \n    iVar2 = *(param_1 + 0x10);\n    uVar3 = *(param_1 + 0xc);\n    uVar4 = uVar3;\n    uVar5 = uVar3;\n    if (-1 < param_2) {\n        do {\n            if (uVar4 == 0xffffffff) {\n                fcn.004086d0();\n            }\n            uVar4 = uVar4 - 1;\n            iVar1 = iVar2 + uVar4 * 0x14;\n            if (((*(iVar1 + 4) < param_3) && (param_3 <= *(iVar1 + 8))) || (uVar4 == 0xffffffff)) {\n                param_2 = param_2 + -1;\n                uVar3 = uVar5;\n                uVar5 = uVar4;\n            }\n        } while (-1 < param_2);\n    }\n    uVar4 = uVar4 + 1;\n    *param_4 = uVar4;\n    *param_5 = uVar3;\n    if ((*(param_1 + 0xc) <= uVar3 && uVar3 != *(param_1 + 0xc)) || (uVar3 < uVar4)) {\n        fcn.004086d0();\n    }\n    return iVar2 + uVar4 * 0x14;\n}\n",
        "token_count": 379
    },
    "00407f30": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.00407f30(int32_t param_1, uint param_2, int32_t param_3, int32_t param_4)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *in_FS_OFFSET;\n    int32_t var_8h;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_1ch;\n    uint var_10h;\n    code *pcStack16;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x434bb8;\n    pcStack16 = fcn.0040a148;\n    var_10h = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_10h;\n    for (iVar2 = *(var_8h + 8); var_4h = 0xffffffff,  iVar2 != var_14h; iVar2 = *(*(var_18h + 8) + iVar2 * 8)) {\n        if ((iVar2 < 0) || (*(var_18h + 4) <= iVar2)) {\n            fcn.004086d0();\n        }\n        var_4h = 0;\n        iVar1 = *(*(var_18h + 8) + 4 + iVar2 * 8);\n        if (iVar1 != 0) {\n            fcn.004084f0(iVar1, var_8h, 0x103);\n        }\n    }\n    *(var_8h + 8) = iVar2;\n    *in_FS_OFFSET = var_10h;\n    return;\n}\n",
        "token_count": 354
    },
    "00408540": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.00408540(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    \n    fcn.00408910();\n    *0x43aff0 = (*_sym.imp.KERNEL32.dll_TlsAlloc)();\n    if (*0x43aff0 != -1) {\n        puVar1 = fcn.00406480(1, 0x74);\n        if (puVar1 != NULL) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_TlsSetValue)(*0x43aff0, puVar1);\n            if (iVar2 != 0) {\n                fcn.004085a0(puVar1);\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n                *puVar1 = uVar3;\n                puVar1[1] = 0xffffffff;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 207
    },
    "00409530": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.00409530(uint32_t param_1, int32_t *param_2, int32_t *param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = param_2[1];\n    param_2[1] = iVar1 + -1;\n    if (iVar1 + -1 < 0) {\n        param_1 = fcn.0040b1a0(param_1, param_2);\n    }\n    else {\n        **param_2 = param_1;\n        param_1 = param_1 & 0xff;\n        *param_2 = *param_2 + 1;\n    }\n    if (param_1 == 0xffffffff) {\n        *param_3 = -1;\n        return;\n    }\n    *param_3 = *param_3 + 1;\n    return;\n}\n",
        "token_count": 187
    },
    "00409580": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.00409580(uint param_1, int32_t param_2, uint param_3, int32_t *param_4)\n\n{\n    if (0 < param_2) {\n        do {\n            param_2 = param_2 + -1;\n            fcn.00409530(param_1, param_3, param_4);\n            if (*param_4 == -1) {\n                return;\n            }\n        } while (0 < param_2);\n    }\n    return;\n}\n",
        "token_count": 110
    },
    "004095c0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.004095c0(char *param_1, int32_t param_2, uint param_3, int32_t *param_4)\n\n{\n    char cVar1;\n    \n    if (0 < param_2) {\n        do {\n            param_2 = param_2 + -1;\n            cVar1 = *param_1;\n            param_1 = param_1 + 1;\n            fcn.00409530(cVar1, param_3, param_4);\n            if (*param_4 == -1) {\n                return;\n            }\n        } while (0 < param_2);\n    }\n    return;\n}\n",
        "token_count": 141
    },
    "0040a460": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint * fcn.0040a460(void)\n\n{\n    bool bVar1;\n    code *pcVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    uint *puVar6;\n    uint *puVar7;\n    \n    if (*0x43b490 == -1) {\n        puVar6 = 0x43b480;\n    }\n    else {\n        puVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x440e14, 0, 0x2020);\n        if (puVar6 == NULL) {\n            return NULL;\n        }\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_VirtualAlloc;\n    puVar3 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, 0x400000, 0x2000, 4);\n    if (puVar3 != NULL) {\n        iVar4 = (*pcVar2)(puVar3, 0x10000, 0x1000, 4);\n        if (iVar4 != 0) {\n            if (puVar6 == 0x43b480) {\n                if (*0x43b480 == 0) {\n                    *0x43b480 = 0x43b480;\n                }\n                if (*0x43b484 == NULL) {\n                    *0x43b484 = 0x43b480;\n                }\n            }\n            else {\n                *puVar6 = 0x43b480;\n                puVar6[1] = *0x43b484;\n                *0x43b484 = puVar6;\n                *puVar6[1] = puVar6;\n            }\n            puVar6[5] = puVar3 + 0x100000;\n            puVar6[4] = puVar3;\n            puVar6[2] = puVar6 + 6;\n            puVar6[3] = puVar6 + 0x26;\n            iVar4 = 0;\n            piVar5 = puVar6 + 6;\n            do {\n                bVar1 = 0xf < iVar4;\n                iVar4 = iVar4 + 1;\n                *piVar5 = (bVar1 - 1 & 0xf1) - 1;\n                piVar5[1] = 0xf1;\n                piVar5 = piVar5 + 2;\n            } while (iVar4 < 0x400);\n            puVar7 = puVar3;\n            for (iVar4 = 0x4000; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            if (puVar3 < puVar6[4] + 0x10000) {\n                do {\n                    puVar3[1] = 0xf0;\n                    *puVar3 = puVar3 + 2;\n                    *(puVar3 + 0x3e) = 0xff;\n                    puVar3 = puVar3 + 0x400;\n                } while (puVar3 < puVar6[4] + 0x10000);\n            }\n            return puVar6;\n        }\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar3, 0, 0x8000);\n    }\n    if (puVar6 != 0x43b480) {\n        (*_sym.imp.KERNEL32.dll_HeapFree)(*0x440e14, 0, puVar6);\n    }\n    return NULL;\n}\n",
        "token_count": 790
    },
    "0040a630": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.0040a630(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    \n    iVar5 = *0x43b484;\n    do {\n        iVar3 = iVar5;\n        if (*(iVar5 + 0x10) != -1) {\n            iVar4 = 0;\n            piVar2 = iVar5 + 0x2010;\n            iVar3 = 0x3ff000;\n            do {\n                if (*piVar2 == 0xf0) {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_VirtualFree)(*(iVar5 + 0x10) + iVar3, 0x1000, 0x4000);\n                    if (iVar1 != 0) {\n                        *piVar2 = -1;\n                        *0x440808 = *0x440808 + -1;\n                        if ((*(iVar5 + 0xc) == NULL) || (piVar2 < *(iVar5 + 0xc))) {\n                            *(iVar5 + 0xc) = piVar2;\n                        }\n                        iVar4 = iVar4 + 1;\n                        param_1 = param_1 + -1;\n                        if (param_1 == 0) break;\n                    }\n                }\n                iVar3 = iVar3 + -0x1000;\n                piVar2 = piVar2 + -2;\n            } while (-1 < iVar3);\n            iVar3 = *(iVar5 + 4);\n            if ((iVar4 != 0) && (*(iVar5 + 0x18) == -1)) {\n                iVar4 = 1;\n                piVar2 = iVar5 + 0x20;\n                do {\n                    if (*piVar2 != -1) break;\n                    iVar4 = iVar4 + 1;\n                    piVar2 = piVar2 + 2;\n                } while (iVar4 < 0x400);\n                if (iVar4 == 0x400) {\n                    fcn.0040a5d0(iVar5);\n                }\n            }\n        }\n        if ((iVar3 == *0x43b484) || (iVar5 = iVar3,  param_1 < 1)) {\n            return;\n        }\n    } while( true );\n}\n",
        "token_count": 511
    },
    "0040a7c0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t * fcn.0040a7c0(uint32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t *unaff_EBP;\n    int32_t *piVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    bool bVar7;\n    int32_t *piStack4;\n    \n    piStack4 = *0x43d4a0;\n    do {\n        if (piStack4[4] != -1) {\n            piVar4 = piStack4[2];\n            iVar5 = (piVar4 + (-0x18 - piStack4) >> 3) * 0x1000 + piStack4[4];\n            for (; piVar4 < piStack4 + 0x806; piVar4 = piVar4 + 2) {\n                if ((param_1 <= *piVar4) && (param_1 <= piVar4[1] && piVar4[1] != param_1)) {\n                    piVar1 = fcn.0040aa00(iVar5, *piVar4, param_1);\n                    if (piVar1 != NULL) {\n                        *0x43d4a0 = piStack4;\n                        *piVar4 = *piVar4 - param_1;\n                        piStack4[2] = piVar4;\n                        return piVar1;\n                    }\n                    piVar4[1] = param_1;\n                }\n                iVar5 = iVar5 + 0x1000;\n            }\n            piVar1 = piStack4[2];\n            iVar5 = piStack4[4];\n            for (piVar4 = piStack4 + 6; piVar4 < piVar1; piVar4 = piVar4 + 2) {\n                if ((param_1 <= *piVar4) && (param_1 <= piVar4[1] && piVar4[1] != param_1)) {\n                    piVar2 = fcn.0040aa00(iVar5, *piVar4, param_1);\n                    if (piVar2 != NULL) {\n                        *0x43d4a0 = piStack4;\n                        *piVar4 = *piVar4 - param_1;\n                        piStack4[2] = piVar4;\n                        return piVar2;\n                    }\n                    piVar4[1] = param_1;\n                }\n                iVar5 = iVar5 + 0x1000;\n            }\n        }\n        piStack4 = *piStack4;\n    } while (piStack4 != *0x43d4a0);\n    piVar4 = 0x43b480;\n    while ((piVar4[4] == -1 || (piVar4[3] == 0))) {\n        piVar4 = *piVar4;\n        if (piVar4 == 0x43b480) {\n            iVar5 = fcn.0040a460();\n            if (iVar5 == 0) {\n                return NULL;\n            }\n            piVar4 = *(iVar5 + 0x10);\n            *(piVar4 + 2) = param_1;\n            *0x43d4a0 = iVar5;\n            *piVar4 = piVar4 + param_1 + 8;\n            piVar4[1] = 0xf0 - param_1;\n            *(iVar5 + 0x18) = *(iVar5 + 0x18) - (param_1 & 0xff);\n            return piVar4 + 0x40;\n        }\n    }\n    piVar1 = piVar4[3];\n    iVar5 = *piVar1;\n    piVar2 = (piVar1 + (-0x18 - piVar4) >> 3) * 0x1000 + piVar4[4];\n    for (iVar6 = 0; (iVar5 == -1 && (iVar6 < 0x10)); iVar6 = iVar6 + 1) {\n        iVar5 = piVar1[2];\n        piVar1 = piVar1 + 2;\n    }\n    piVar1 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(piVar2, iVar6 << 0xc, 0x1000, 4);\n    if (piVar1 != piVar2) {\n        return NULL;\n    }\n    piVar1 = unaff_EBP;\n    if (0 < iVar6) {\n        piVar3 = piVar2 + 1;\n        do {\n            *piVar3 = 0xf0;\n            piVar3[-1] = piVar3 + 1;\n            *(piVar3 + 0x3d) = 0xff;\n            *piVar1 = 0xf0;\n            piVar1[1] = 0xf1;\n            piVar3 = piVar3 + 0x400;\n            piVar1 = piVar1 + 2;\n            iVar6 = iVar6 + -1;\n        } while (iVar6 != 0);\n    }\n    piVar3 = piVar4 + 0x806;\n    bVar7 = piVar1 < piVar3;\n    if (bVar7) {\n        do {\n            if (*piVar1 == -1) break;\n            piVar1 = piVar1 + 2;\n        } while (piVar1 < piVar3);\n        bVar7 = piVar1 < piVar3;\n    }\n    *0x43d4a0 = piVar4;\n    piVar4[3] = -bVar7 & piVar1;\n    *(piVar2 + 2) = param_1;\n    piVar4[2] = unaff_EBP;\n    *unaff_EBP = *unaff_EBP - param_1;\n    piVar2[1] = piVar2[1] - param_1;\n    *piVar2 = piVar2 + param_1 + 8;\n    return piVar2 + 0x40;\n}\n",
        "token_count": 1328
    },
    "0040c730": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t fcn.0040c730(uint32_t param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.0040e2a0(param_1);\n    if (iVar1 == -1) {\n        puVar2 = fcn.00407210();\n        *puVar2 = 9;\n        return -1;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_SetFilePointer)(iVar1, param_2, 0, param_3);\n    if (iVar1 == -1) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    }\n    else {\n        iVar3 = 0;\n    }\n    if (iVar3 != 0) {\n        fcn.00407190(iVar3);\n        return -1;\n    }\n    iVar3 = *((param_1 >> 5) * 4 + 0x440e20);\n    *(iVar3 + 4 + (param_1 & 0x1f) * 0x24) = *(iVar3 + 4 + (param_1 & 0x1f) * 0x24) & 0xfd;\n    return iVar1;\n}\n",
        "token_count": 287
    },
    "0040e200": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.0040e200(uint32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint uVar5;\n    \n    if (param_1 < *0x440f20) {\n        piVar1 = (param_1 >> 5) * 4 + 0x440e20;\n        iVar2 = *piVar1;\n        iVar4 = (param_1 & 0x1f) * 0x24;\n        if (((*(iVar2 + 4 + iVar4) & 1) != 0) && (*(iVar2 + iVar4) != -1)) {\n            if (*0x43aca4 == 1) {\n                if (param_1 == 0) {\n                    uVar5 = 0xfffffff6;\n                }\n                else if (param_1 == 1) {\n                    uVar5 = 0xfffffff5;\n                }\n                else {\n                    if (param_1 != 2) goto code_r0x0040e267;\n                    uVar5 = 0xfffffff4;\n                }\n                (*_sym.imp.KERNEL32.dll_SetStdHandle)(uVar5, 0);\n            }\ncode_r0x0040e267:\n            *(*piVar1 + iVar4) = 0xffffffff;\n            return 0;\n        }\n    }\n    puVar3 = fcn.00407210();\n    *puVar3 = 9;\n    puVar3 = fcn.00407220();\n    *puVar3 = 0;\n    return 0xffffffff;\n}\n",
        "token_count": 358
    },
    "0040fb00": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040fb00(code **param_1)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint32_t uStack4;\n    \n    uStack8 = 0x42f763;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    *param_1 = vtable.std::basic_filebuf_char__struct_std::char_traits_char__.0;\n    uStack4 = 1;\n    if ((*(param_1 + 0x12) != '\\0') && (param_1[0x14] != NULL)) {\n        iVar3 = fcn.0040e150(param_1[0x14]);\n        if (iVar3 == 0) {\n            *(param_1 + 0x12) = 0;\n            fcn.0040fd00();\n            param_1[0x14] = NULL;\n            param_1[0x10] = *0x441f60;\n            param_1[0xf] = *0x441f60;\n            param_1[0xe] = NULL;\n        }\n    }\n    pcVar2 = param_1[0x11];\n    if (pcVar2 != NULL) {\n        iVar3 = *(pcVar2 + 4);\n        if (iVar3 != 0) {\n            cVar1 = *(iVar3 + -1);\n            if ((cVar1 == '\\0') || (cVar1 == -1)) {\n                fcn.004166cf(iVar3 + -1);\n            }\n            else {\n                *(iVar3 + -1) = cVar1 + -1;\n            }\n        }\n        *(pcVar2 + 4) = 0;\n        *(pcVar2 + 8) = 0;\n        *(pcVar2 + 0xc) = 0;\n        fcn.004166cf(pcVar2);\n    }\n    pcVar2 = param_1[0x13];\n    uStack4 = uStack4 & 0xffffff00;\n    if (pcVar2 != NULL) {\n        fcn.00412ab0();\n        iVar3 = *(pcVar2 + 4);\n        if ((iVar3 != 0) && (iVar3 != -1)) {\n            *(pcVar2 + 4) = iVar3 + -1;\n        }\n        puVar4 = ~-(*(pcVar2 + 4) != 0) & pcVar2;\n        fcn.00412b70();\n        if (puVar4 != NULL) {\n            (***puVar4)(1);\n        }\n    }\n    *param_1 = vtable.std::basic_streambuf_char__struct_std::char_traits_char__.0;\n    pcVar2 = param_1[0xd];\n    uStack4 = 0xffffffff;\n    if (pcVar2 != NULL) {\n        fcn.00412ab0();\n        iVar3 = *(pcVar2 + 4);\n        if ((iVar3 != 0) && (iVar3 != -1)) {\n            *(pcVar2 + 4) = iVar3 + -1;\n        }\n        puVar4 = ~-(*(pcVar2 + 4) != 0) & pcVar2;\n        fcn.00412b70();\n        if (puVar4 != NULL) {\n            (***puVar4)(1);\n        }\n    }\n    *in_FS_OFFSET = uStack12;\n    return;\n}\n",
        "token_count": 783
    },
    "0040fc70": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0040fc70(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    fcn.00412ab0();\n    iVar1 = *(param_1 + 4);\n    if ((iVar1 != 0) && (iVar1 != -1)) {\n        *(param_1 + 4) = iVar1 + -1;\n    }\n    iVar1 = *(param_1 + 4);\n    fcn.00412b70();\n    return ~-(iVar1 != 0) & param_1;\n}\n",
        "token_count": 123
    },
    "0040fcb0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040fcb0(code **param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    *param_1 = vtable.std::basic_streambuf_char__struct_std::char_traits_char__.0;\n    pcVar1 = param_1[0xd];\n    if (pcVar1 != NULL) {\n        fcn.00412ab0();\n        iVar2 = *(pcVar1 + 4);\n        if ((iVar2 != 0) && (iVar2 != -1)) {\n            *(pcVar1 + 4) = iVar2 + -1;\n        }\n        puVar3 = ~-(*(pcVar1 + 4) != 0) & pcVar1;\n        fcn.00412b70();\n        if (puVar3 != NULL) {\n            (***puVar3)(1);\n        }\n    }\n    return;\n}\n",
        "token_count": 204
    },
    "004130a0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004130a0(code **param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x42fadb;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    *param_1 = vtable.std::ios_base.0;\n    pcVar1 = param_1[9];\n    uStack4 = 0;\n    if ((pcVar1 == NULL) || (pcVar1[0x440dc0] = pcVar1[0x440dc0] + -1,  param_1[9][0x440dc0] < '\\x01')) {\n        fcn.00413210();\n    }\n    pcVar1 = param_1[8];\n    uStack4 = 0xffffffff;\n    if (pcVar1 != NULL) {\n        fcn.00412ab0();\n        iVar2 = *(pcVar1 + 4);\n        if ((iVar2 != 0) && (iVar2 != -1)) {\n            *(pcVar1 + 4) = iVar2 + -1;\n        }\n        puVar3 = ~-(*(pcVar1 + 4) != 0) & pcVar1;\n        fcn.00412b70();\n        if (puVar3 != NULL) {\n            (***puVar3)(1);\n        }\n    }\n    *in_FS_OFFSET = uStack12;\n    return;\n}\n",
        "token_count": 354
    },
    "004104d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint * __fastcall fcn.004104d0(uint *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x42f868;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    uVar3 = fcn.004132b0();\n    *param_1 = uVar3;\n    fcn.00412ab0();\n    iVar2 = *0x440dd4;\n    uStack4 = 0;\n    fcn.00412ab0();\n    iVar1 = *(iVar2 + 4);\n    if (iVar1 != -1) {\n        *(iVar2 + 4) = iVar1 + 1;\n    }\n    fcn.00412b70();\n    uStack4 = 0xffffffff;\n    fcn.00412b70();\n    *in_FS_OFFSET = uStack12;\n    return param_1;\n}\n",
        "token_count": 249
    },
    "00411350": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00411350(code **param_1)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint32_t uStack4;\n    \n    uStack8 = 0x42f8b3;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    *param_1 = vtable.std::basic_filebuf_unsigned_short_int__struct_std::char_traits_unsigned_short_int__.0;\n    uStack4 = 1;\n    if ((*(param_1 + 0x12) != '\\0') && (param_1[0x14] != NULL)) {\n        iVar3 = fcn.0040e150(param_1[0x14]);\n        if (iVar3 == 0) {\n            *(param_1 + 0x12) = 0;\n            fcn.0040fd00();\n            param_1[0x14] = NULL;\n            param_1[0x10] = *0x441f58;\n            param_1[0xf] = *0x441f58;\n            param_1[0xe] = NULL;\n        }\n    }\n    pcVar2 = param_1[0x11];\n    if (pcVar2 != NULL) {\n        iVar3 = *(pcVar2 + 4);\n        if (iVar3 != 0) {\n            cVar1 = *(iVar3 + -1);\n            if ((cVar1 == '\\0') || (cVar1 == -1)) {\n                fcn.004166cf(iVar3 + -1);\n            }\n            else {\n                *(iVar3 + -1) = cVar1 + -1;\n            }\n        }\n        *(pcVar2 + 4) = 0;\n        *(pcVar2 + 8) = 0;\n        *(pcVar2 + 0xc) = 0;\n        fcn.004166cf(pcVar2);\n    }\n    pcVar2 = param_1[0x13];\n    uStack4 = uStack4 & 0xffffff00;\n    if (pcVar2 != NULL) {\n        fcn.00412ab0();\n        iVar3 = *(pcVar2 + 4);\n        if ((iVar3 != 0) && (iVar3 != -1)) {\n            *(pcVar2 + 4) = iVar3 + -1;\n        }\n        puVar4 = ~-(*(pcVar2 + 4) != 0) & pcVar2;\n        fcn.00412b70();\n        if (puVar4 != NULL) {\n            (***puVar4)(1);\n        }\n    }\n    *param_1 = vtable.std::basic_streambuf_unsigned_short_int__struct_std::char_traits_unsigned_short_int__.0;\n    pcVar2 = param_1[0xd];\n    uStack4 = 0xffffffff;\n    if (pcVar2 != NULL) {\n        fcn.00412ab0();\n        iVar3 = *(pcVar2 + 4);\n        if ((iVar3 != 0) && (iVar3 != -1)) {\n            *(pcVar2 + 4) = iVar3 + -1;\n        }\n        puVar4 = ~-(*(pcVar2 + 4) != 0) & pcVar2;\n        fcn.00412b70();\n        if (puVar4 != NULL) {\n            (***puVar4)(1);\n        }\n    }\n    *in_FS_OFFSET = uStack12;\n    return;\n}\n",
        "token_count": 792
    },
    "004114a0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004114a0(code **param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    *param_1 = vtable.std::basic_streambuf_unsigned_short_int__struct_std::char_traits_unsigned_short_int__.0;\n    pcVar1 = param_1[0xd];\n    if (pcVar1 != NULL) {\n        fcn.00412ab0();\n        iVar2 = *(pcVar1 + 4);\n        if ((iVar2 != 0) && (iVar2 != -1)) {\n            *(pcVar1 + 4) = iVar2 + -1;\n        }\n        puVar3 = ~-(*(pcVar1 + 4) != 0) & pcVar1;\n        fcn.00412b70();\n        if (puVar3 != NULL) {\n            (***puVar3)(1);\n        }\n    }\n    return;\n}\n",
        "token_count": 207
    },
    "004132b0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.004132b0(void)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint unaff_EBX;\n    uint *puVar6;\n    char *pcVar7;\n    uint *puVar8;\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint32_t uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x42fb03;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    fcn.00412ab0();\n    uStack4 = 0;\n    if (*0x440dd4 == 0) {\n        iVar3 = fcn.00416693(0x28);\n        uStack4 = CONCAT31(uStack4._1_3_, 1);\n        if (iVar3 == 0) {\n            *0x440dd4 = 0;\n        }\n        else {\n            *0x440dd4 = fcn.00413480(0);\n        }\n        uStack8 = uStack8 & 0xffffff00;\n        fcn.00405760(0x4133f0);\n        *(*0x440dd4 + 0x10) = 0x3f;\n        iVar3 = *0x440dd4;\n        uVar4 = 0xffffffff;\n        pcVar7 = 0x4357f8;\n        do {\n            if (uVar4 == 0) break;\n            uVar4 = uVar4 - 1;\n            cVar2 = *pcVar7;\n            pcVar7 = pcVar7 + 1;\n        } while (cVar2 != '\\0');\n        uVar4 = ~uVar4 - 1;\n        cVar2 = fcn.00402dc1(uVar4, 1);\n        if (cVar2 != '\\0') {\n            puVar6 = 0x4357f8;\n            puVar8 = *(iVar3 + 0x1c);\n            for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n                *puVar8 = *puVar6;\n                puVar6 = puVar6 + 1;\n                puVar8 = puVar8 + 1;\n            }\n            for (uVar5 = uVar4 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {\n                *puVar8 = *puVar6;\n                puVar6 = puVar6 + 1;\n                puVar8 = puVar8 + 1;\n            }\n            *(iVar3 + 0x20) = uVar4;\n            *(uVar4 + *(iVar3 + 0x1c)) = 0;\n        }\n        iVar1 = *0x440dd4;\n        *0x440dd0 = *0x440dd4;\n        fcn.00412ab0();\n        iVar3 = *(iVar1 + 4);\n        if (iVar3 != -1) {\n            *(iVar1 + 4) = iVar3 + 1;\n        }\n        fcn.00412b70();\n        *0x440dcc = *0x440dd0;\n    }\n    iVar3 = *0x440dd4;\n    fcn.00412b70();\n    *in_FS_OFFSET = unaff_EBX;\n    return iVar3;\n}\n",
        "token_count": 791
    },
    "004135e0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.004135e0(code **param_1)\n\n{\n    code cVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    uint *puVar5;\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x42fb6b;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    *param_1 = vtable.std::locale::_Locimp.0;\n    uStack4 = 1;\n    fcn.00412ab0();\n    pcVar4 = param_1[3];\n    uStack4._0_1_ = 2;\n    while (pcVar4 != NULL) {\n        pcVar4 = pcVar4 + -1;\n        uVar2 = *(param_1[2] + pcVar4 * 4);\n        if (uVar2 != 0) {\n            fcn.00412ab0();\n            iVar3 = *(uVar2 + 4);\n            if ((iVar3 != 0) && (iVar3 != -1)) {\n                *(uVar2 + 4) = iVar3 + -1;\n            }\n            puVar5 = ~-(*(uVar2 + 4) != 0) & uVar2;\n            fcn.00412b70();\n            if (puVar5 != NULL) {\n                (***puVar5)(1);\n            }\n        }\n    }\n    fcn.00405f10(param_1[2]);\n    uStack4 = CONCAT31(uStack4._1_3_, 1);\n    fcn.00412b70();\n    pcVar4 = param_1[7];\n    if (pcVar4 != NULL) {\n        cVar1 = pcVar4[-1];\n        if ((cVar1 == 0x0) || (cVar1 == 0xff)) {\n            fcn.004166cf(pcVar4 + -1);\n        }\n        else {\n            pcVar4[-1] = cVar1 + -1;\n        }\n    }\n    param_1[7] = NULL;\n    param_1[8] = NULL;\n    param_1[9] = NULL;\n    *param_1 = vtable.std::locale::facet.0;\n    *in_FS_OFFSET = uStack12;\n    return;\n}\n",
        "token_count": 543
    },
    "004139c0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t fcn.004139c0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uStack8;\n    uint32_t uStack4;\n    \n    if (param_1 == -1) {\n        return 0xffffffff;\n    }\n    uStack8 = 0;\n    iVar1 = fcn.004137c0(&uStack4, &param_1, 1, &uStack8, 0);\n    if (iVar1 < 0) {\n        return 0xffff;\n    }\n    return uStack4 & 0xffff;\n}\n",
        "token_count": 129
    },
    "00413da0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.00413da0(uint param_1, uint32_t *param_2)\n\n{\n    ulong uVar1;\n    \n    uVar1 = fcn.00414600(param_1);\n    *param_2 = uVar1;\n    param_2[1] = uVar1 >> 0x20;\n    if ((*param_2 & param_2[1]) != 0xffffffff) {\n        return 0;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 105
    },
    "004142d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.004142d0(uint16_t **param_1)\n\n{\n    uint16_t uVar1;\n    uint16_t *puVar2;\n    uint16_t **ppuVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint uVar7;\n    uint32_t uStack4;\n    \n    ppuVar3 = param_1;\n    if ((*(param_1 + 3) & 0x40) == 0) {\n        puVar2 = param_1[4];\n        if (puVar2 == 0xffffffff) {\n            iVar5 = 0x43b3c8;\n        }\n        else {\n            iVar5 = *((puVar2 >> 5) * 4 + 0x440e20) + (puVar2 & 0x1f) * 0x24;\n        }\n        if ((*(iVar5 + 4) & 0x80) != 0) {\n            puVar2 = param_1[1];\n            uVar7 = 1;\n            param_1[1] = puVar2 + -1;\n            if (puVar2 + -1 < 0) {\n                uVar4 = fcn.00414510(param_1);\n            }\n            else {\n                uVar4 = **param_1;\n                *param_1 = *param_1 + 1;\n            }\n            if (uVar4 == 0xffffffff) {\n                return 0xffffffff;\n            }\n            uStack4 = uVar4 & 0xff;\n            if ((*(*0x43d4b0 + 1 + (uVar4 & 0xff) * 2) & 0x80) != 0) {\n                puVar2 = ppuVar3[1];\n                ppuVar3[1] = puVar2 + -1;\n                if (puVar2 + -1 < 0) {\n                    uVar4 = fcn.00414510(ppuVar3);\n                }\n                else {\n                    uVar4 = **ppuVar3;\n                    *ppuVar3 = *ppuVar3 + 1;\n                }\n                if (uVar4 == 0xffffffff) {\n                    fcn.00413ce0(uStack4, ppuVar3);\n                    return 0xffff;\n                }\n                uStack4._0_2_ = CONCAT11(uVar4, uStack4);\n                uStack4 = uStack4 & 0xffff0000 | uStack4;\n                uVar7 = 2;\n            }\n            iVar5 = fcn.00414d10(&param_1, &uStack4, uVar7);\n            if (iVar5 == -1) {\n                puVar6 = fcn.00407210();\n                *puVar6 = 0x2a;\n                return 0xffff;\n            }\n            return param_1 & 0xffff;\n        }\n    }\n    puVar2 = param_1[1];\n    param_1[1] = puVar2 + -1;\n    if (-1 < puVar2 + -1) {\n        uVar1 = **param_1;\n        *param_1 = *param_1 + 1;\n        return uVar1;\n    }\n    uVar4 = fcn.00414c10(param_1);\n    return uVar4;\n}\n",
        "token_count": 750
    },
    "00414510": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t fcn.00414510(uint8_t **param_1)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    uint8_t *puVar3;\n    int32_t iVar4;\n    \n    puVar3 = param_1[3];\n    if (((puVar3 & 0x83) != 0) && ((puVar3 & 0x40) == 0)) {\n        if ((puVar3 & 2) != 0) {\n            param_1[3] = puVar3 | 0x20;\n            return 0xffffffff;\n        }\n        param_1[3] = puVar3 | 1;\n        if ((puVar3 & 0x10c) == 0) {\n            fcn.0040ca40(param_1);\n        }\n        else {\n            *param_1 = param_1[2];\n        }\n        puVar3 = fcn.00414e90(param_1[4], param_1[2], param_1[6]);\n        param_1[1] = puVar3;\n        if ((puVar3 != NULL) && (puVar3 != 0xffffffff)) {\n            if ((param_1[3] & 0x82) == 0) {\n                puVar2 = param_1[4];\n                if (puVar2 == 0xffffffff) {\n                    iVar4 = 0x43b3c8;\n                }\n                else {\n                    iVar4 = *((puVar2 >> 5) * 4 + 0x440e20) + (puVar2 & 0x1f) * 0x24;\n                }\n                if ((*(iVar4 + 4) & 0x82) == 0x82) {\n                    param_1[3] = param_1[3] | 0x2000;\n                }\n            }\n            if (((param_1[6] == 0x200) && ((param_1[3] & 8) != 0)) && ((param_1[3] & 0x400) == 0)) {\n                param_1[6] = 0x1000;\n            }\n            param_1[1] = puVar3 + -1;\n            uVar1 = **param_1;\n            *param_1 = *param_1 + 1;\n            return uVar1;\n        }\n        param_1[1] = NULL;\n        param_1[3] = param_1[3] | (-(puVar3 != NULL) & 0x10) + 0x10;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 581
    },
    "004151d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nulong fcn.004151d0(uint32_t param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint uStack4;\n    \n    uStack4 = param_3;\n    iVar1 = fcn.0040e2a0(param_1);\n    if (iVar1 == -1) {\n        puVar2 = fcn.00407210();\n        *puVar2 = 9;\n        return 0xffffffffffffffff;\n    }\n    puVar2 = &uStack4;\n    iVar1 = (*_sym.imp.KERNEL32.dll_SetFilePointer)(iVar1, param_2, puVar2, param_4);\n    if (iVar1 == -1) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0) {\n            fcn.00407190(iVar3);\n            return 0xffffffffffffffff;\n        }\n    }\n    iVar3 = *((param_1 >> 5) * 4 + 0x440e20);\n    *(iVar3 + 4 + (param_1 & 0x1f) * 0x24) = *(iVar3 + 4 + (param_1 & 0x1f) * 0x24) & 0xfd;\n    return CONCAT44(puVar2, iVar1);\n}\n",
        "token_count": 315
    },
    "00415f0a": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00415f0a(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    if (arg_ch != -1) {\n        *(in_ECX + 0x10) = arg_ch;\n    }\n    if (arg_8h == 0) {\n        fcn.004166cf(*(in_ECX + 4));\n        *(in_ECX + 4) = 0;\n        *(in_ECX + 0xc) = 0;\n        *(in_ECX + 8) = 0;\n    }\n    else {\n        if (*(in_ECX + 4) == 0) {\n            uVar1 = fcn.00416693(arg_8h << 2);\n            *(in_ECX + 4) = uVar1;\n            fcn.00406030(uVar1, 0, arg_8h << 2);\n            *(in_ECX + 0xc) = arg_8h;\n        }\n        else {\n            if (*(in_ECX + 0xc) < arg_8h) {\n                arg_ch = *(in_ECX + 0x10);\n                if (*(in_ECX + 0x10) == 0) {\n                    arg_ch = *(in_ECX + 8) / 8;\n                    iVar2 = 4;\n                    if (3 < arg_ch) {\n                        iVar2 = arg_ch;\n                    }\n                    if (iVar2 < 0x401) {\n                        if (arg_ch < 4) {\n                            arg_ch = 4;\n                        }\n                    }\n                    else {\n                        arg_ch = 0x400;\n                    }\n                }\n                arg_ch = arg_ch + *(in_ECX + 0xc);\n                if (arg_ch <= arg_8h) {\n                    arg_ch = arg_8h;\n                }\n                iVar2 = fcn.00416693(arg_ch << 2);\n                fcn.00405850(iVar2, *(in_ECX + 4), *(in_ECX + 8) << 2);\n                fcn.00406030(iVar2 + *(in_ECX + 8) * 4, 0, (*(in_ECX + 8) * 0x3fffffff + arg_8h) * 4);\n                fcn.004166cf(*(in_ECX + 4));\n                *(in_ECX + 4) = iVar2;\n                *(in_ECX + 8) = arg_8h;\n                *(in_ECX + 0xc) = arg_ch;\n                return;\n            }\n            iVar2 = *(in_ECX + 8);\n            if (iVar2 < arg_8h) {\n                fcn.00406030(*(in_ECX + 4) + iVar2 * 4, 0, (iVar2 * 0x3fffffff + arg_8h) * 4);\n            }\n        }\n        *(in_ECX + 8) = arg_8h;\n    }\n    return;\n}\n",
        "token_count": 669
    },
    "00416397": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00416397(int32_t param_1, int32_t **param_2, int32_t *param_3, int32_t *param_4)\n\n{\n    int32_t **ppiVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    \n    piVar3 = *param_2;\n    if (piVar3 == 0xffffffff) {\n        uVar4 = 0;\n        if (*(param_1 + 8) != 0) {\n            ppiVar1 = *(param_1 + 4);\n            do {\n                piVar3 = *ppiVar1;\n                if (piVar3 != NULL) break;\n                uVar4 = uVar4 + 1;\n                ppiVar1 = ppiVar1 + 1;\n            } while (uVar4 < *(param_1 + 8));\n        }\n    }\n    piVar5 = *piVar3;\n    if (piVar5 == NULL) {\n        uVar4 = *(param_1 + 8);\n        uVar2 = (piVar3[1] >> 4) % uVar4 + 1;\n        if (uVar2 < uVar4) {\n            ppiVar1 = *(param_1 + 4) + uVar2 * 4;\n            do {\n                piVar5 = *ppiVar1;\n                if (piVar5 != NULL) break;\n                uVar2 = uVar2 + 1;\n                ppiVar1 = ppiVar1 + 1;\n            } while (uVar2 < uVar4);\n        }\n    }\n    *param_2 = piVar5;\n    *param_3 = piVar3[1];\n    *param_4 = piVar3[2];\n    return;\n}\n",
        "token_count": 411
    },
    "0041a8ac": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0041a8ac(int32_t param_1, int16_t *param_2)\n\n{\n    int32_t iVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    iVar4 = 1;\n    if (param_2 != NULL) {\n        do {\n            if (*param_2 == 0) break;\n            iVar2 = param_2[1];\n            iVar1 = *(param_2 + 2);\n            if (iVar2 == 0x401) {\n                iVar2 = 0x180;\n            }\n            else if (iVar2 == 0x403) {\n                iVar2 = 0x143;\n            }\n            if ((iVar2 == 0x180) || (iVar2 == 0x143)) {\n                iVar3 = (*_sym.imp.USER32.dll_SendDlgItemMessageA)(*(param_1 + 0x1c), *param_2, iVar2, 0, param_2 + 4);\n                if (iVar3 == -1) {\n                    iVar4 = 0;\n                }\n            }\n            param_2 = param_2 + 4 + iVar1;\n        } while (iVar4 != 0);\n    }\n    if (iVar4 != 0) {\n        fcn.00419abe(*(param_1 + 0x1c), 0x364, 0, 0, 0, 0);\n    }\n    return iVar4;\n}\n",
        "token_count": 329
    },
    "0041b524": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041b524(int32_t *param_1, int32_t param_2)\n\n{\n    fcn.0041b1b5();\n    if (param_2 == -1) {\n        param_2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*param_1);\n    }\n    *(*param_1 + -8) = param_2;\n    *(*param_1 + param_2) = 0;\n    return;\n}\n",
        "token_count": 105
    },
    "0041b975": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041b975(uint lpFileName, uint32_t dwDesiredAccess, int32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint uVar4;\n    char cVar5;\n    uint32_t uVar6;\n    uint uVar7;\n    uint var_110h;\n    uint lpSecurityAttributes;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    uVar1 = dwDesiredAccess;\n    *(in_ECX + 8) = 0;\n    *(in_ECX + 4) = 0xffffffff;\n    uVar6 = dwDesiredAccess & 0xffff7fff;\n    fcn.0041b197();\n    fcn.0041c06b(&var_110h, lpFileName);\n    fcn.0041b354(&var_110h);\n    uVar2 = dwDesiredAccess & 3;\n    if (uVar2 == 0) {\n        dwDesiredAccess = 0x80000000;\n    }\n    else if (uVar2 == 1) {\n        dwDesiredAccess = 0x40000000;\n    }\n    else if (uVar2 == 2) {\n        dwDesiredAccess = 0xc0000000;\n    }\n    uVar2 = uVar1 & 0x70;\n    uVar4 = 1;\n    if ((uVar2 == 0) || (uVar2 == 0x10)) {\n        uVar7 = 0;\n    }\n    else {\n        uVar7 = uVar4;\n        if (uVar2 != 0x20) {\n            if (uVar2 == 0x30) {\n                uVar7 = 2;\n            }\n            else {\n                uVar7 = lpFileName;\n                if (uVar2 == 0x40) {\n                    uVar7 = 3;\n                }\n            }\n        }\n    }\n    lpSecurityAttributes = 0xc;\n    var_4h = ~uVar6 >> 7 & 1;\n    var_8h = 0;\n    if ((uVar1 & 0x1000) == 0) {\n        cVar5 = '\\x03';\n    }\n    else {\n        cVar5 = (-((uVar1 & 0x2000) != 0) & 2U) + 2;\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_CreateFileA)\n                      (lpFileName, dwDesiredAccess, uVar7, &lpSecurityAttributes, cVar5, 0x80, 0);\n    if (iVar3 == -1) {\n        if (arg_10h != 0) {\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            *(arg_10h + 0xc) = uVar4;\n            uVar4 = fcn.0041c728(uVar4);\n            *(arg_10h + 8) = uVar4;\n            fcn.0041b354(lpFileName);\n        }\n        uVar4 = 0;\n    }\n    else {\n        *(in_ECX + 4) = iVar3;\n        *(in_ECX + 8) = 1;\n    }\n    return uVar4;\n}\n",
        "token_count": 740
    },
    "0041bb9b": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041bb9b(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    bool bVar3;\n    \n    bVar3 = false;\n    if (*(param_1 + 4) != -1) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_CloseHandle)(*(param_1 + 4));\n        bVar3 = iVar1 == 0;\n    }\n    *(param_1 + 4) = 0xffffffff;\n    *(param_1 + 8) = 0;\n    fcn.0041b197();\n    if (bVar3) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n        fcn.0041c5e6(uVar2);\n    }\n    return;\n}\n",
        "token_count": 180
    },
    "0041bbdc": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041bbdc(int32_t param_1)\n\n{\n    if (*(param_1 + 4) != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*(param_1 + 4));\n        *(param_1 + 4) = 0xffffffff;\n    }\n    fcn.0041b197();\n    return;\n}\n",
        "token_count": 83
    },
    "0041c06b": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpFindFileData\n\nuint __cdecl fcn.0041c06b(uint lpRootPathName, uint lpFileName)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpFindFileData;\n    uint lpString2;\n    uint var_18h;\n    uint lpFilePart;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    uVar2 = *(unaff_EBP + 8);\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetFullPathNameA)(*(unaff_EBP + 0xc), 0x104, uVar2, unaff_EBP + -0x14);\n    if (iVar1 == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(uVar2, *(unaff_EBP + 0xc), 0x104);\n    }\n    else {\n        fcn.0041b0c1();\n        *(unaff_EBP + -4) = 0;\n        fcn.0041c144(uVar2, unaff_EBP + 8);\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetVolumeInformationA)\n                          (*(unaff_EBP + 8), 0, 0, 0, unaff_EBP + -0x18, unaff_EBP + -0x10, 0, 0);\n        if (iVar1 != 0) {\n            if ((*(unaff_EBP + -0x10) & 2) == 0) {\n                (*_sym.imp.USER32.dll_CharUpperA)(uVar2);\n            }\n            if ((*(unaff_EBP + -0x10) & 4) == 0) {\n                iVar1 = (*_sym.imp.KERNEL32.dll_FindFirstFileA)(*(unaff_EBP + 0xc), unaff_EBP + -0x158);\n                if (iVar1 != -1) {\n                    (*_sym.imp.KERNEL32.dll_FindClose)(iVar1);\n                    (*_sym.imp.KERNEL32.dll_lstrcpyA)(*(unaff_EBP + -0x14), unaff_EBP + -300);\n                }\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0041b20c();\n            uVar2 = 1;\n            goto code_r0x0041c134;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0041b20c();\n    }\n    uVar2 = 0;\ncode_r0x0041c134:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 624
    },
    "004214f5": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.004214f5(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    fcn.0041b0c1();\n    *(unaff_EBP + -4) = 0;\n    fcn.0041c4c3(*(unaff_EBP + 8));\n    iVar3 = *(unaff_EBP + 0x10);\n    if (iVar3 == -1) {\n        iVar3 = *(unaff_EBP + 8);\n    }\n    iVar1 = fcn.0042d07c();\n    uVar2 = (**(**(iVar1 + 4) + 0x94))(*(unaff_EBP + -0x10), *(unaff_EBP + 0xc), iVar3);\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041b20c();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 328
    },
    "0042853d": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0042853d(int32_t *param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar1 = fcn.004180f1();\n    if (iVar1 != -1) {\n        iVar1 = *param_1;\n        iVar2 = (**(iVar1 + 0xe4))(param_2, param_3);\n        if (iVar2 != 0) {\n            (*_sym.imp.USER32.dll_PostMessageA)(param_1[7], 0x362, 0xe001, 0);\n            (**(iVar1 + 0xd0))(1);\n            return 0;\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 169
    },
    "0042d508": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.0042d508(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    param_1[5] = 0;\n    param_1[6] = 0;\n    param_1[6] = 4;\n    param_1[1] = 0;\n    param_1[2] = 1;\n    param_1[3] = 0;\n    param_1[4] = 0;\n    iVar1 = (*_sym.imp.KERNEL32.dll_TlsAlloc)();\n    *param_1 = iVar1;\n    if (iVar1 == -1) {\n        fcn.00415699();\n    }\n    (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(param_1 + 7);\n    return param_1;\n}\n",
        "token_count": 180
    },
    "00417c7f": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint fcn.00417c7f(int32_t param_1)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetKeyState;\n    if ((((*(param_1 + 4) == 0x100) && (*(param_1 + 8) == 0x70)) && ((*(param_1 + 0xc) >> 0x10 & 0x4000) == 0)) &&\n       (((iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(0x10),  -1 < iVar2 && (iVar2 = (*pcVar1)(0x11),  -1 < iVar2)) &&\n        (iVar2 = (*pcVar1)(0x12),  -1 < iVar2)))) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 191
    },
    "004180bc": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t fcn.004180bc(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.0042d88a(0x404495);\n    uVar2 = (*_sym.imp.USER32.dll_GetMessageTime)();\n    *(iVar1 + 0x44) = uVar2;\n    uVar2 = (*_sym.imp.USER32.dll_GetMessagePos)();\n    *(iVar1 + 0x48) = uVar2;\n    *(iVar1 + 0x4c) = uVar2 >> 0x10;\n    return iVar1 + 0x34;\n}\n",
        "token_count": 139
    },
    "0041827d": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_30h\n\nuint __cdecl\nfcn.0041827d(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint hWnd)\n\n{\n    uint uVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    bool bVar5;\n    uint Msg;\n    uint wParam;\n    uint lParam;\n    uint var_10h;\n    uint var_30h;\n    uint var_1ch;\n    uint lpPrevWndFunc;\n    uint var_14h;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.004056b0();\n    uVar4 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &stack0xffffffc4;\n    uVar1 = (*_sym.imp.USER32.dll_GetPropA)(uVar4, \"AfxOldWndProc\");\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x18) = uVar1;\n    iVar3 = *(unaff_EBP + 0xc);\n    bVar5 = true;\n    if (iVar3 == 6) {\n        uVar1 = fcn.0041819c(*(unaff_EBP + 0x14));\n        uVar2 = fcn.0041819c(uVar4);\n        fcn.004183ca(uVar2, *(unaff_EBP + 0x10), uVar1);\n    }\n    else if (iVar3 == 0x20) {\n        uVar1 = fcn.0041819c(uVar4);\n        iVar3 = fcn.0041842b(uVar1, *(unaff_EBP + 0x14), *(unaff_EBP + 0x14) >> 0x10);\n        bVar5 = iVar3 == 0;\n    }\n    else if (iVar3 == 0x82) {\n        (*_sym.imp.USER32.dll_SetWindowLongA)(uVar4, 0xfffffffc, *(unaff_EBP + -0x18));\n        (*_sym.imp.USER32.dll_RemovePropA)(uVar4, \"AfxOldWndProc\");\n    }\n    else if (iVar3 == 0x110) {\n        uVar1 = fcn.0041819c(uVar4);\n        fcn.00418020(uVar1, unaff_EBP + -0x30, unaff_EBP + -0x1c);\n        bVar5 = false;\n        uVar2 = (*_sym.imp.USER32.dll_CallWindowProcA)\n                          (*(unaff_EBP + -0x18), uVar4, 0x110, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n        *(unaff_EBP + -0x14) = uVar2;\n        fcn.00418043(uVar1, unaff_EBP + -0x30);\n    }\n    if (bVar5) {\n        uVar4 = (*_sym.imp.USER32.dll_CallWindowProcA)\n                          (*(unaff_EBP + -0x18), uVar4, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n        *(unaff_EBP + -0x14) = uVar4;\n    }\n    uVar4 = *(unaff_EBP + -0x14);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar4;\n}\n",
        "token_count": 904
    },
    "004196ee": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004196ee(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    uint32_t uVar3;\n    uint var_2ch;\n    uint32_t var_28h;\n    int32_t var_4h;\n    \n    uVar3 = arg_8h & 0xffff;\n    arg_8h = arg_8h >> 0x10;\n    if (arg_ch == 0) {\n        if (uVar3 == 0) {\n            return 0;\n        }\n        fcn.004196bb();\n        var_28h = uVar3;\n        (**(*in_ECX + 0x14))(uVar3, 0xffffffff, &var_2ch, 0);\n        if (var_4h != 0) {\n            arg_8h = 0;\ncode_r0x00419732:\n            uVar1 = (**(*in_ECX + 0x14))(uVar3, arg_8h, 0, 0);\n            return uVar1;\n        }\n    }\n    else {\n        iVar2 = fcn.0042d88a(0x404495);\n        if ((*(iVar2 + 0xb8) != in_ECX[7]) && (iVar2 = fcn.0041a040(arg_ch, 0),  iVar2 == 0)) {\n            if (uVar3 == 0) {\n                return 0;\n            }\n            goto code_r0x00419732;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 360
    },
    "0041a13f": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041a13f(uint32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, int32_t *arg_14h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint var_ch;\n    int32_t *var_8h;\n    int32_t var_4h;\n    \n    if (arg_8h < 0x3a) {\n        if ((arg_8h == 0x39) || ((0x2a < arg_8h && (arg_8h < 0x30)))) {\ncode_r0x0041a21f:\n            uVar1 = fcn.00419149(arg_8h + 0xbc00, arg_ch, arg_10h, arg_14h);\n            return uVar1;\n        }\n    }\n    else {\n        if (arg_8h == 0x4e) {\n            var_8h = arg_14h;\n            var_4h = arg_10h;\n            uVar1 = fcn.00416752(0, *(arg_10h + 8) & 0xffff | 0xbc4e0000, &var_8h, 0);\n            return uVar1;\n        }\n        if (arg_8h == 0x111) {\n            iVar2 = fcn.00416752(0, arg_ch >> 0x10 | 0xbd110000, 0, 0);\n            if (iVar2 == 0) {\n                return 0;\n            }\n            if (arg_14h != NULL) {\n                *arg_14h = 1;\n                return 1;\n            }\n            return 1;\n        }\n        if ((0x113 < arg_8h) && ((arg_8h < 0x116 || (arg_8h == 0x210)))) goto code_r0x0041a21f;\n    }\n    if ((0x131 < arg_8h) && (arg_8h < 0x139)) {\n        var_4h = arg_8h - 0x132;\n        var_8h = arg_ch;\n        uVar1 = fcn.00419149(0xbc19, 0, &var_ch, arg_14h);\n        if (*arg_14h != 0) {\n            return uVar1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 534
    },
    "0041b27a": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.0041b27a(uint *param_1, uint32_t param_2)\n\n{\n    uint *puVar1;\n    int32_t arg_10h;\n    \n    puVar1 = fcn.0041b0bb();\n    *param_1 = *puVar1;\n    if (param_2 != 0) {\n        if (param_2 >> 0x10 == 0) {\n            fcn.0041c4c3(param_2 & 0xffff);\n            return param_1;\n        }\n        if (param_2 != 0) {\n            arg_10h = (*_sym.imp.KERNEL32.dll_lstrlenA)(param_2);\n            goto code_r0x0041b2b8;\n        }\n    }\n    arg_10h = 0;\ncode_r0x0041b2b8:\n    if (arg_10h != 0) {\n        fcn.0041b108(arg_10h);\n        fcn.00405850(*param_1, param_2, arg_10h);\n    }\n    return param_1;\n}\n",
        "token_count": 248
    },
    "004219cc": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.004219cc(uint arg_8h, uint arg_ch)\n\n{\n    int32_t in_ECX;\n    uint var_14h;\n    uchar var_ch;\n    uint var_bh;\n    \n    fcn.00421812(arg_8h, &var_14h);\n    var_bh._0_1_ = arg_ch;\n    var_ch = arg_ch >> 0x10;\n    fcn.00421831(arg_8h, &var_14h);\n    *(in_ECX + 0x84) = 1;\n    return;\n}\n",
        "token_count": 136
    },
    "0042210a": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0042210a(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t in_ECX;\n    uint var_14h;\n    uint var_10h;\n    uchar var_ch;\n    uint var_bh;\n    \n    fcn.00421812(arg_8h, &var_14h);\n    var_10h = arg_ch;\n    var_14h = arg_14h;\n    var_bh._0_1_ = arg_10h;\n    var_ch = arg_10h >> 0x10;\n    fcn.00421831(arg_8h, &var_14h);\n    *(in_ECX + 0x84) = 1;\n    return;\n}\n",
        "token_count": 180
    },
    "004258b4": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint32_t __thiscall fcn.004258b4(int32_t param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *(*(param_1 + 0x80) + param_2 * 4);\n    return uVar1 & -(uVar1 >> 0x10 != 0);\n}\n",
        "token_count": 82
    },
    "0042b84c": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid fcn.0042b84c(void)\n\n{\n    uint8_t uVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint lpvBits;\n    int32_t nHeight;\n    int32_t var_8h;\n    uint8_t *var_4h;\n    \n    uVar2 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n    iVar5 = uVar2;\n    nHeight = uVar2 >> 0x10;\n    if (0x20 < iVar5) {\n        iVar5 = 0x20;\n    }\n    iVar6 = iVar5 + 0xf >> 4;\n    iVar7 = ((iVar5 + -4) / 2 + iVar6 * 0x10) - iVar5;\n    if (0xc < iVar7) {\n        iVar7 = 0xc;\n    }\n    if (0x20 < nHeight) {\n        nHeight = 0x20;\n    }\n    fcn.00406030(&lpvBits, 0xff, 0x80);\n    var_4h = 0x431220;\n    var_8h = 5;\n    puVar4 = &lpvBits + (nHeight + -6 >> 1) * iVar6 * 2;\n    do {\n        uVar1 = *var_4h;\n        uVar3 = var_4h & 0xffff0000;\n        var_4h = var_4h + 1;\n        uVar3 = ~((uVar3 | uVar1) << (iVar7 & 0x1f));\n        puVar4[1] = uVar3;\n        *puVar4 = uVar3 >> 8;\n        puVar4 = puVar4 + iVar6 * 2;\n        var_8h = var_8h + -1;\n    } while (var_8h != 0);\n    *0x4400e0 = (*_sym.imp.GDI32.dll_CreateBitmap)(iVar5, nHeight, 1, 1, &lpvBits);\n    if (*0x4400e0 == 0) {\n        *0x4400e0 = (*_sym.imp.USER32.dll_LoadBitmapA)(0, 0x7fe3);\n    }\n    return;\n}\n",
        "token_count": 531
    },
    "00404f28": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404f28(int32_t arg_8h, uint *arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    uint var_24h;\n    uint32_t var_20h;\n    uint32_t var_18h;\n    uint var_10h;\n    uint32_t lpPoint;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    puVar3 = arg_ch;\n    puVar4 = &var_24h;\n    for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = *puVar3;\n        puVar3 = puVar3 + 1;\n        puVar4 = puVar4 + 1;\n    }\n    var_24h = (*_sym.imp.USER32.dll_SendMessageA)(*(arg_8h + 0x1c), 0x410, 0, &var_10h);\n    lpPoint = arg_ch[5];\n    var_4h = arg_ch[6];\n    if ((0x1ff < var_20h) && (var_20h < 0x20a)) {\n        (*_sym.imp.USER32.dll_ScreenToClient)(var_24h, &lpPoint);\n    }\n    var_18h = lpPoint & 0xffff | var_4h << 0x10;\n    (*pcVar1)(*(arg_8h + 0x1c), 0x407, 0, &var_24h);\n    return;\n}\n",
        "token_count": 371
    },
    "004219a9": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.004219a9(uint arg_8h)\n\n{\n    uint var_14h;\n    uint var_ch;\n    \n    fcn.00421812(arg_8h, &var_14h);\n    return var_ch << 0x10 | var_ch._1_1_;\n}\n",
        "token_count": 79
    },
    "00406090": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nint32_t fcn.00406090(uint8_t *param_1, uint8_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint16_t uVar2;\n    uint16_t uVar3;\n    uint8_t *puVar4;\n    uint8_t *puVar5;\n    uint8_t *puVar6;\n    bool bVar7;\n    \n    if (*0x44061c != 0) {\n        fcn.00408940(0x19);\n        puVar4 = param_2;\n        while( true ) {\n            param_2 = *param_1;\n            puVar6 = param_1 + 1;\n            if ((*(param_2 + 0x440519) & 4) != 0) {\n                uVar1 = *puVar6;\n                if (uVar1 == 0) {\n                    param_2 = NULL;\n                }\n                else {\n                    puVar6 = param_1 + 2;\n                    param_2 = CONCAT11(*param_1, uVar1);\n                }\n            }\n            uVar3 = *puVar4;\n            puVar5 = puVar4 + 1;\n            if ((*(uVar3 + 0x440519) & 4) != 0) {\n                uVar1 = *puVar5;\n                if (uVar1 == 0) {\n                    uVar3 = 0;\n                }\n                else {\n                    puVar5 = puVar4 + 2;\n                    uVar3 = CONCAT11(*puVar4, uVar1);\n                }\n            }\n            uVar2 = param_2;\n            if (uVar2 != uVar3) break;\n            puVar4 = puVar5;\n            param_1 = puVar6;\n            if (uVar2 == 0) {\n                fcn.004089c0(0x19);\n                return 0;\n            }\n        }\n        fcn.004089c0(0x19);\n        return (-(uVar3 < uVar2) & 2) - 1;\n    }\n    while( true ) {\n        uVar1 = *param_1;\n        bVar7 = uVar1 < *param_2;\n        if (uVar1 != *param_2) break;\n        if (uVar1 == 0) {\n            return 0;\n        }\n        uVar1 = param_1[1];\n        bVar7 = uVar1 < param_2[1];\n        if (uVar1 != param_2[1]) break;\n        param_1 = param_1 + 2;\n        param_2 = param_2 + 2;\n        if (uVar1 == 0) {\n            return 0;\n        }\n    }\n    return (1 - bVar7) - (bVar7 != 0);\n}\n",
        "token_count": 620
    },
    "004063b0": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nuint8_t * fcn.004063b0(uint8_t *param_1, uint32_t param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint8_t *puVar3;\n    \n    if (*0x44061c == 0) {\n        puVar3 = fcn.0040acf0(param_1, param_2);\n        return puVar3;\n    }\n    fcn.00408940(0x19);\n    uVar1 = *param_1;\n    while (uVar2 = uVar1,  uVar1 != 0) {\n        if ((*(uVar2 + 0x440519) & 4) == 0) {\n            puVar3 = param_1;\n            if (param_2 == uVar2) break;\n        }\n        else {\n            puVar3 = param_1 + 1;\n            if (param_1[1] == 0) {\n                fcn.004089c0(0x19);\n                return NULL;\n            }\n            if (param_2 == CONCAT11(uVar1, param_1[1])) {\n                fcn.004089c0(0x19);\n                return param_1;\n            }\n        }\n        param_1 = puVar3 + 1;\n        uVar1 = puVar3[1];\n    }\n    fcn.004089c0(0x19);\n    return (param_2 != uVar2) - 1 & param_1;\n}\n",
        "token_count": 333
    },
    "00406600": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nuint8_t * fcn.00406600(uint8_t *param_1, uint32_t param_2)\n\n{\n    uint16_t uVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    uint8_t *puVar4;\n    uint8_t *puVar5;\n    \n    puVar5 = NULL;\n    if (*0x44061c == 0) {\n        puVar5 = fcn.0040b0f0(param_1, param_2);\n        return puVar5;\n    }\n    fcn.00408940(0x19);\n    do {\n        uVar3 = *param_1;\n        if ((*(uVar3 + 0x440519) & 4) == 0) {\n            puVar4 = param_1;\n            uVar2 = uVar3;\n            if (param_2 == uVar3) {\ncode_r0x00406678:\n                puVar5 = puVar4;\n                uVar3 = uVar2;\n            }\n        }\n        else {\n            uVar2 = param_1[1];\n            puVar4 = param_1 + 1;\n            if (uVar2 == 0) {\n                uVar3 = uVar2;\n                if (puVar5 == NULL) goto code_r0x00406678;\n            }\n            else {\n                uVar1 = CONCAT11(uVar3, uVar2);\n                uVar3 = uVar2;\n                if (param_2 == uVar1) {\n                    puVar5 = param_1;\n                }\n            }\n        }\n        param_1 = puVar4 + 1;\n        if (uVar3 == 0) {\n            fcn.004089c0(0x19);\n            return puVar5;\n        }\n    } while( true );\n}\n",
        "token_count": 399
    },
    "004099b0": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nuint fcn.004099b0(uint32_t param_1, uint32_t param_2, uint8_t param_3)\n\n{\n    if ((*((param_1 & 0xff) + 0x440519) & param_3) == 0) {\n        if (param_2 == 0) {\n            param_2 = 0;\n        }\n        else {\n            param_2 = L\"         (((((                  H\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x81\\x81\\x81\\x81\\x81\\x81\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x10\\x10\\x10\\x10\\x10\\x10\\x82\\x82\\x82\\x82\\x82\\x82\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x10\\x10\\x10\\x10 \"\n                      [param_1 & 0xff] & param_2;\n        }\n        if (param_2 == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 328
    },
    "0040b2d0": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nuint32_t fcn.0040b2d0(uint32_t param_1, uint32_t param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uStack4;\n    \n    if (param_1 + 1 < 0x101) {\n        return *(*0x43d4b0 + param_1 * 2) & param_2;\n    }\n    if ((*(*0x43d4b0 + 1 + (param_1 >> 8 & 0xffU) * 2) & 0x80) == 0) {\n        param_1 = param_1 & 0xffff00ff;\n        uVar1 = 1;\n    }\n    else {\n        param_1 = param_1 & 0xff000000 | CONCAT11(param_1, param_1 >> 8);\n        uVar1 = 2;\n    }\n    iVar2 = fcn.0040b500(1, &param_1, uVar1, &uStack4, 0, 0);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    return uStack4 & 0xffff & param_2;\n}\n",
        "token_count": 266
    },
    "00420486": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nvoid fcn.00420486(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    if (param_1 != 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GlobalFlags)(param_1);\n        for (uVar1 = uVar1 & 0xff; uVar1 != 0; uVar1 = uVar1 - 1) {\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(param_1);\n        }\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(param_1);\n    }\n    return;\n}\n",
        "token_count": 130
    },
    "0041cdc4": {
        "rules": [
            "check for kernel debugger via shared user data structure/3e5f0b53f7994283abe93631eebb775f"
        ],
        "decompiled_code": "\nint32_t fcn.0041cdc4(uint32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint16_t *puVar3;\n    uint8_t uVar4;\n    uint16_t uVar5;\n    uint32_t uVar6;\n    bool bVar7;\n    \n    bVar7 = *(param_1 + 2) == -1;\n    iVar1 = fcn.0041cd6e(param_1);\n    if (*(param_1 + 2) == -1) {\n        uVar6 = param_1[3];\n    }\n    else {\n        uVar6 = *param_1;\n    }\n    if ((uVar6 & 0x40) != 0) {\n        iVar1 = iVar1 + ((-bVar7 & 2) + 1) * 2;\n        iVar2 = fcn.00406530(iVar1);\n        iVar1 = iVar1 + 2 + iVar2 * 2;\n    }\n    if (bVar7) {\n        uVar4 = *(param_1 + 4);\n    }\n    else {\n        uVar4 = *(param_1 + 2);\n    }\n    if (uVar4 != 0) {\n        uVar6 = uVar4;\n        do {\n            puVar3 = (iVar1 + 3U & 0xfffffffc) + (-bVar7 & 6) + 0x12;\n            uVar5 = *puVar3;\n            if (uVar5 == 0xffff) {\n                puVar3 = puVar3 + 2;\n            }\n            else {\n                while (puVar3 = puVar3 + 1,  uVar5 != 0) {\n                    uVar5 = *puVar3;\n                }\n            }\n            uVar5 = *puVar3;\n            if (uVar5 == 0xffff) {\n                puVar3 = puVar3 + 2;\n            }\n            else {\n                while (puVar3 = puVar3 + 1,  uVar5 != 0) {\n                    uVar5 = *puVar3;\n                }\n            }\n            uVar6 = uVar6 - 1;\n            iVar1 = puVar3 + *puVar3 + 2;\n        } while (uVar6 != 0);\n    }\n    return iVar1 - param_1;\n}\n",
        "token_count": 523
    },
    "0041ce7b": {
        "rules": [
            "check for kernel debugger via shared user data structure/3e5f0b53f7994283abe93631eebb775f"
        ],
        "decompiled_code": "\nuint fcn.0041ce7b(uint32_t *param_1, uint param_2, ushort *param_3)\n\n{\n    int16_t iVar1;\n    uint32_t uVar2;\n    ushort *puVar3;\n    uint uVar4;\n    \n    if (*(param_1 + 2) == -1) {\n        uVar2 = param_1[3];\n    }\n    else {\n        uVar2 = *param_1;\n    }\n    if ((uVar2 & 0x40) == 0) {\n        return 0;\n    }\n    puVar3 = fcn.0041cd6e(param_1);\n    *param_3 = *puVar3;\n    iVar1 = *(param_1 + 2);\n    uVar4 = fcn.0041b54c(0x20, 0x20, 0, 0);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, puVar3 + ((iVar1 != -1) - 1 & 2) + 1, 0xffffffff, uVar4);\n    fcn.0041b524(0xffffffff);\n    return 1;\n}\n",
        "token_count": 264
    },
    "00406190": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint * fcn.00406190(char *param_1)\n\n{\n    char cVar1;\n    uint *puVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    uint *puVar7;\n    \n    if (param_1 != NULL) {\n        uVar3 = 0xffffffff;\n        pcVar6 = param_1;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar6;\n            pcVar6 = pcVar6 + 1;\n        } while (cVar1 != '\\0');\n        puVar2 = fcn.00405e40(~uVar3);\n        if (puVar2 != NULL) {\n            uVar3 = 0xffffffff;\n            do {\n                pcVar6 = param_1;\n                if (uVar3 == 0) break;\n                uVar3 = uVar3 - 1;\n                pcVar6 = param_1 + 1;\n                cVar1 = *param_1;\n                param_1 = pcVar6;\n            } while (cVar1 != '\\0');\n            uVar3 = ~uVar3;\n            puVar5 = pcVar6 + -uVar3;\n            puVar7 = puVar2;\n            for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n                *puVar7 = *puVar5;\n                puVar5 = puVar5 + 1;\n                puVar7 = puVar7 + 1;\n            }\n            for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar7 = *puVar5;\n                puVar5 = puVar5 + 1;\n                puVar7 = puVar7 + 1;\n            }\n            return puVar2;\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 457
    },
    "00406480": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint * fcn.00406480(int32_t param_1, int32_t param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    uint *puVar6;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    uVar4 = param_2 * param_1;\n    if (uVar4 < 0xffffffe1) {\n        if (uVar4 == 0) {\n            uVar4 = 0x10;\n        }\n        else {\n            uVar4 = uVar4 + 0xf & 0xfffffff0;\n        }\n    }\n    do {\n        puVar5 = NULL;\n        if (uVar4 < 0xffffffe1) {\n            if (*0x43d4a4 < uVar4) {\ncode_r0x004064f4:\n                if (puVar5 != NULL) {\n                    return puVar5;\n                }\n            }\n            else {\n                fcn.00408940(9);\n                puVar5 = fcn.0040a7c0(uVar4 >> 4);\n                fcn.004089c0(9);\n                if (puVar5 != NULL) {\n                    puVar6 = puVar5;\n                    for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n                        *puVar6 = 0;\n                        puVar6 = puVar6 + 1;\n                    }\n                    for (uVar3 = uVar4 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n                        *puVar6 = 0;\n                        puVar6 = puVar6 + 1;\n                    }\n                    goto code_r0x004064f4;\n                }\n            }\n            puVar5 = (*pcVar1)(*0x440e14, 8, uVar4);\n        }\n        if ((puVar5 != NULL) || (*0x440800 == 0)) {\n            return puVar5;\n        }\n        iVar2 = fcn.0040a440(uVar4);\n        if (iVar2 == 0) {\n            return NULL;\n        }\n    } while( true );\n}\n",
        "token_count": 512
    },
    "00408760": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint * fcn.00408760(uint *param_1, uint32_t param_2, uint param_3, uint param_4, uint param_5, uint param_6, \n                   uint param_7, uint param_8, uint param_9, uint param_10, uint param_11, uint param_12, uint param_13\n                   , uint param_14, uint param_15, uint param_16, uint param_17, uint param_18, uint param_19, \n                   uint param_20, uint param_21, uint param_22, uint param_23, uint param_24, uint param_25, \n                   uint param_26, uint param_27, uint param_28, uint param_29, uint param_30, uint param_31, \n                   uint param_32, uint param_33, uint param_34, uint param_35, uint param_36, uint param_37, \n                   uint param_38, uint param_39, uint param_40, uint param_41, uint param_42, uint param_43, \n                   uint param_44, uint param_45, uint param_46, uint param_47, uint param_48, uint param_49, \n                   uint param_50)\n\n{\n    uint *puVar1;\n    uint8_t *noname_2;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint *puVar5;\n    uint unaff_EDI;\n    uint *puVar6;\n    uint unaff_retaddr;\n    uint in_stack_fffffff8;\n    uint in_stack_fffffffc;\n    \n    if (param_1 == NULL) {\n        puVar1 = fcn.00405e40(param_2);\n        return puVar1;\n    }\n    if (param_2 == 0) {\n        fcn.00405f10(param_1);\n        return NULL;\n    }\n    uVar3 = param_2;\n    if (param_2 < 0xffffffe1) {\n        if (param_2 == 0) {\n            param_2 = 0x10;\n            uVar3 = param_2;\n        }\n        else {\n            param_2 = param_2 + 0xf & 0xfffffff0;\n            uVar3 = param_2;\n        }\n    }\n    do {\n        puVar1 = NULL;\n        if (uVar3 < 0xffffffe1) {\n            fcn.00408940(9);\n            noname_2 = fcn.0040a700(param_1, &stack0xfffffffc, &stack0xfffffff8);\n            if (noname_2 == NULL) {\n                fcn.004089c0(9);\n                puVar1 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x440e14, 0, param_1, uVar3);\n            }\n            else {\n                if (uVar3 < *0x43d4a4) {\n                    iVar2 = fcn.0040ab80(in_stack_fffffffc, in_stack_fffffff8, noname_2, uVar3 >> 4, unaff_EDI, \n                                         unaff_ESI, unaff_EBP, unaff_EBX, in_stack_fffffff8, in_stack_fffffffc, \n                                         unaff_retaddr, param_1, param_2, param_3, param_4, param_5, param_6, param_7, \n                                         param_8, param_9, param_10, param_11, param_12, param_13, param_14, param_15, \n                                         param_16, param_17, param_18, param_19, param_20, param_21, param_22, param_23\n                                         , param_24, param_25, param_26, param_27, param_28, param_29, param_30, \n                                         param_31, param_32, param_33, param_34, param_35, param_36, param_37, param_38\n                                         , param_39, param_40, param_41, param_42, param_43, param_44, param_45, \n                                         param_46, param_47, param_48, param_49, param_50);\n                    puVar1 = param_1;\n                    if (iVar2 != 0) goto code_r0x00408865;\n                    puVar1 = fcn.0040a7c0(uVar3 >> 4);\n                    if (puVar1 != NULL) {\n                        uVar4 = *noname_2 << 4;\n                        if (uVar3 <= *noname_2 << 4) {\n                            uVar4 = uVar3;\n                        }\n                        puVar5 = param_1;\n                        puVar6 = puVar1;\n                        for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n                            *puVar6 = *puVar5;\n                            puVar5 = puVar5 + 1;\n                            puVar6 = puVar6 + 1;\n                        }\n                        for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n                            *puVar6 = *puVar5;\n                            puVar5 = puVar5 + 1;\n                            puVar6 = puVar6 + 1;\n                        }\n                        fcn.0040a760(in_stack_fffffffc, in_stack_fffffff8, noname_2);\n                        uVar3 = param_2;\n                        goto code_r0x00408865;\n                    }\ncode_r0x00408869:\n                    puVar1 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x440e14, 0, uVar3);\n                    if (puVar1 != NULL) {\n                        uVar4 = *noname_2 << 4;\n                        if (uVar3 <= *noname_2 << 4) {\n                            uVar4 = uVar3;\n                        }\n                        puVar5 = param_1;\n                        puVar6 = puVar1;\n                        for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n                            *puVar6 = *puVar5;\n                            puVar5 = puVar5 + 1;\n                            puVar6 = puVar6 + 1;\n                        }\n                        for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n                            *puVar6 = *puVar5;\n                            puVar5 = puVar5 + 1;\n                            puVar6 = puVar6 + 1;\n                        }\n                        fcn.0040a760(in_stack_fffffffc, in_stack_fffffff8, noname_2);\n                        uVar3 = param_2;\n                    }\n                }\n                else {\ncode_r0x00408865:\n                    if (puVar1 == NULL) goto code_r0x00408869;\n                }\n                fcn.004089c0(9);\n            }\n        }\n        if ((puVar1 != NULL) || (*0x440800 == 0)) {\n            return puVar1;\n        }\n        iVar2 = fcn.0040a440(uVar3);\n        if (iVar2 == 0) {\n            return NULL;\n        }\n    } while( true );\n}\n",
        "token_count": 1671
    },
    "004099f0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid fcn.004099f0(void)\n\n{\n    char cVar1;\n    char cVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    char *pcVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    char *pcVar10;\n    char *pcVar11;\n    uint *puVar12;\n    int32_t *piStack4;\n    \n    iVar8 = 0;\n    cVar2 = **0x4404c8;\n    pcVar7 = *0x4404c8;\n    while (cVar2 != '\\0') {\n        if (cVar2 != '=') {\n            iVar8 = iVar8 + 1;\n        }\n        uVar4 = 0xffffffff;\n        pcVar10 = pcVar7;\n        do {\n            if (uVar4 == 0) break;\n            uVar4 = uVar4 - 1;\n            cVar2 = *pcVar10;\n            pcVar10 = pcVar10 + 1;\n        } while (cVar2 != '\\0');\n        pcVar10 = pcVar7 + ~uVar4;\n        pcVar7 = pcVar7 + ~uVar4;\n        cVar2 = *pcVar10;\n    }\n    piVar3 = fcn.00405e40(iVar8 * 4 + 4);\n    *0x4404f4 = piVar3;\n    if (piVar3 == NULL) {\n        fcn.00405dc0(9);\n    }\n    cVar2 = **0x4404c8;\n    piStack4 = piVar3;\n    pcVar7 = *0x4404c8;\n    do {\n        if (cVar2 == '\\0') {\n            fcn.00405f10(*0x4404c8);\n            *0x4404c8 = NULL;\n            *piVar3 = 0;\n            return;\n        }\n        uVar4 = 0xffffffff;\n        pcVar10 = pcVar7;\n        do {\n            if (uVar4 == 0) break;\n            uVar4 = uVar4 - 1;\n            cVar1 = *pcVar10;\n            pcVar10 = pcVar10 + 1;\n        } while (cVar1 != '\\0');\n        uVar4 = ~uVar4;\n        if (cVar2 != '=') {\n            iVar8 = fcn.00405e40(uVar4);\n            *piVar3 = iVar8;\n            if (iVar8 == 0) {\n                fcn.00405dc0(9);\n            }\n            uVar5 = 0xffffffff;\n            pcVar10 = pcVar7;\n            do {\n                pcVar11 = pcVar10;\n                if (uVar5 == 0) break;\n                uVar5 = uVar5 - 1;\n                pcVar11 = pcVar10 + 1;\n                cVar2 = *pcVar10;\n                pcVar10 = pcVar11;\n            } while (cVar2 != '\\0');\n            uVar5 = ~uVar5;\n            puVar9 = pcVar11 + -uVar5;\n            puVar12 = *piStack4;\n            for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {\n                *puVar12 = *puVar9;\n                puVar9 = puVar9 + 1;\n                puVar12 = puVar12 + 1;\n            }\n            piVar3 = piStack4 + 1;\n            for (uVar5 = uVar5 & 3; piStack4 = piVar3,  uVar5 != 0; uVar5 = uVar5 - 1) {\n                *puVar12 = *puVar9;\n                puVar9 = puVar9 + 1;\n                puVar12 = puVar12 + 1;\n            }\n        }\n        cVar2 = pcVar7[uVar4];\n        pcVar7 = pcVar7 + uVar4;\n    } while( true );\n}\n",
        "token_count": 911
    },
    "0040f400": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040f400(int32_t param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint *puVar5;\n    uint unaff_EDI;\n    uint *puVar6;\n    uint unaff_retaddr;\n    uint in_stack_ffffffec;\n    \n    puVar5 = *(param_1 + 4);\n    if (puVar5 == NULL) {\n        return;\n    }\n    cVar1 = *(puVar5 + -1);\n    if (cVar1 == '\\0') {\n        return;\n    }\n    if (cVar1 == -1) {\n        return;\n    }\n    *(puVar5 + -1) = cVar1 + -1;\n    uVar3 = 0xffffffff;\n    *(param_1 + 4) = 0;\n    *(param_1 + 8) = 0;\n    *(param_1 + 0xc) = 0;\n    puVar6 = puVar5;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *puVar6;\n        puVar6 = puVar6 + 1;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3 - 1;\n    if (0xfffffffd < uVar3) {\n        in_stack_ffffffec = 0x40f44e;\n        fcn.00412050();\n    }\n    iVar2 = *(param_1 + 4);\n    if (((iVar2 == 0) || (cVar1 = *(iVar2 + -1),  cVar1 == '\\0')) || (cVar1 == -1)) {\n        if (uVar3 == 0) {\n            fcn.00402f00(1);\n            return;\n        }\n        if ((*(param_1 + 0xc) < 0x20) && (uVar3 <= *(param_1 + 0xc))) goto code_r0x0040f4a7;\n        in_stack_ffffffec = 1;\n        fcn.00402f00();\n    }\n    else if (uVar3 == 0) {\n        *(iVar2 + -1) = cVar1 + -1;\n        fcn.00402f00(0);\n        return;\n    }\n    fcn.00402e4c(uVar3, in_stack_ffffffec, unaff_EDI, unaff_ESI, unaff_EBP, unaff_EBX, unaff_retaddr);\ncode_r0x0040f4a7:\n    puVar6 = *(param_1 + 4);\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar6 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar6 = puVar6 + 1;\n    }\n    for (uVar4 = uVar3 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar6 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar6 = puVar6 + 1;\n    }\n    *(param_1 + 8) = uVar3;\n    *(uVar3 + *(param_1 + 4)) = 0;\n    return;\n}\n",
        "token_count": 797
    },
    "00412050": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid fcn.00412050(void)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    uint *puVar7;\n    uint *in_FS_OFFSET;\n    uint *puStack60;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x42f9e0;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    uVar2 = 0xffffffff;\n    pcVar6 = \"string too long\";\n    do {\n        if (uVar2 == 0) break;\n        uVar2 = uVar2 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar2 - 1;\n    uVar2 = uVar3;\n    cVar1 = fcn.00402dc1(uVar3, 1);\n    if (cVar1 != '\\0') {\n        puVar5 = \"string too long\";\n        puVar7 = puStack60;\n        for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar7 = *puVar5;\n            puVar5 = puVar5 + 1;\n            puVar7 = puVar7 + 1;\n        }\n        for (uVar4 = uVar3 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar7 = *puVar5;\n            puVar5 = puVar5 + 1;\n            puVar7 = puVar7 + 1;\n        }\n        *(uVar3 + puStack60) = 0;\n    }\n    uStack12 = 0;\n    fcn.00414410(&stack0xffffffbc);\n    fcn.00402f00(0);\n    fcn.00412190(&stack0xffffffb8, 0, *0x435630);\n    fcn.00406350(&stack0xffffffbc, 0x439ab8);\n    if (uVar2 != 0) {\n        cVar1 = *(uVar2 - 1);\n        if ((cVar1 != '\\0') && (cVar1 != -1)) {\n            *(uVar2 - 1) = cVar1 + -1;\n            *in_FS_OFFSET = 0;\n            return;\n        }\n        fcn.004166cf(uVar2 - 1);\n    }\n    *in_FS_OFFSET = 0;\n    return;\n}\n",
        "token_count": 624
    },
    "00412190": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00412190(int32_t param_1, int32_t param_2, uint32_t param_3, uint32_t param_4)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint unaff_EBX;\n    uint32_t uVar4;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    int32_t iVar5;\n    uint *puVar6;\n    uint unaff_EDI;\n    uint *puVar7;\n    uint32_t unaff_retaddr;\n    uint noname_1;\n    \n    if (*(param_2 + 8) < param_3) {\n        fcn.00412740();\n    }\n    uVar3 = *0x435630;\n    uVar4 = *(param_2 + 8) - param_3;\n    if (param_4 < uVar4) {\n        uVar4 = param_4;\n    }\n    if (param_1 == param_2) {\n        uVar4 = uVar4 + param_3;\n        if (*(param_1 + 8) < uVar4) {\n            fcn.00412740();\n        }\n        fcn.0040f400();\n        uVar2 = *(param_1 + 8) - uVar4;\n        if (uVar2 < uVar3) {\n            uVar3 = uVar2;\n        }\n        if (uVar3 != 0) {\n            fcn.00406890(uVar4 + *(param_1 + 4), uVar3 + uVar4 + *(param_1 + 4), uVar2 - uVar3);\n            iVar5 = *(param_1 + 8) - uVar3;\n            param_3 = unaff_retaddr;\n            cVar1 = fcn.00402dc1(iVar5, 0);\n            if (cVar1 != '\\0') {\n                *(param_1 + 8) = iVar5;\n                *(iVar5 + *(param_1 + 4)) = 0;\n            }\n        }\n        fcn.0040f400();\n        uVar3 = *(param_1 + 8);\n        if (uVar3 < param_3) {\n            param_3 = uVar3;\n        }\n        if (param_3 == 0) {\n            return param_1;\n        }\n        fcn.00406890(*(param_1 + 4), param_3 + *(param_1 + 4), uVar3 - param_3);\n        iVar5 = *(param_1 + 8) - param_3;\n        cVar1 = fcn.00402dc1(iVar5, 0);\n        if (cVar1 == '\\0') {\n            return param_1;\n        }\n        fcn.0040f3e0(iVar5);\n        return param_1;\n    }\n    if ((uVar4 != 0) && (uVar4 == *(param_2 + 8))) {\n        iVar5 = *(param_2 + 4);\n        if (iVar5 == 0) {\n            iVar5 = 0x43021c;\n        }\n        if (*(iVar5 + -1) < 0xfe) {\n            iVar5 = *(param_1 + 4);\n            if (iVar5 != 0) {\n                cVar1 = *(iVar5 + -1);\n                if ((cVar1 == '\\0') || (cVar1 == -1)) {\n                    fcn.004166cf(iVar5 + -1);\n                }\n                else {\n                    *(iVar5 + -1) = cVar1 + -1;\n                }\n            }\n            *(param_1 + 4) = 0;\n            *(param_1 + 8) = 0;\n            *(param_1 + 0xc) = 0;\n            iVar5 = *(param_2 + 4);\n            if (iVar5 == 0) {\n                iVar5 = 0x43021c;\n            }\n            *(param_1 + 4) = iVar5;\n            *(param_1 + 8) = *(param_2 + 8);\n            *(param_1 + 0xc) = *(param_2 + 0xc);\n            *(iVar5 + -1) = *(iVar5 + -1) + '\\x01';\n            return param_1;\n        }\n    }\n    noname_1 = 0x4122f6;\n    uVar3 = fcn.004123a0();\n    if (uVar3 < uVar4) {\n        noname_1 = 0x4122ff;\n        fcn.00412050();\n    }\n    iVar5 = *(param_1 + 4);\n    if (((iVar5 == 0) || (cVar1 = *(iVar5 + -1),  cVar1 == '\\0')) || (cVar1 == -1)) {\n        if (uVar4 == 0) {\n            fcn.00402f00(1);\n            return param_1;\n        }\n        if ((*(param_1 + 0xc) < 0x20) && (uVar4 <= *(param_1 + 0xc))) goto code_r0x0041235e;\n        noname_1 = 1;\n        fcn.00402f00();\n    }\n    else if (uVar4 == 0) {\n        *(iVar5 + -1) = cVar1 + -1;\n        fcn.00402f00(0);\n        return param_1;\n    }\n    fcn.00402e4c(uVar4, noname_1, unaff_EDI, unaff_ESI, unaff_EBP, unaff_EBX, unaff_retaddr);\ncode_r0x0041235e:\n    iVar5 = *(param_2 + 4);\n    if (iVar5 == 0) {\n        iVar5 = 0x43021c;\n    }\n    puVar6 = param_3 + iVar5;\n    puVar7 = *(param_1 + 4);\n    for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar7 = *puVar6;\n        puVar6 = puVar6 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    for (uVar3 = uVar4 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar7 = *puVar6;\n        puVar6 = puVar6 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    *(param_1 + 8) = uVar4;\n    *(uVar4 + *(param_1 + 4)) = 0;\n    return param_1;\n}\n",
        "token_count": 1508
    },
    "00412740": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nvoid fcn.00412740(void)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    uint *puVar7;\n    uint *in_FS_OFFSET;\n    uint *puStack60;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x42fa40;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    uVar2 = 0xffffffff;\n    pcVar6 = \"invalid string position\";\n    do {\n        if (uVar2 == 0) break;\n        uVar2 = uVar2 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar2 - 1;\n    uVar2 = uVar3;\n    cVar1 = fcn.00402dc1(uVar3, 1);\n    if (cVar1 != '\\0') {\n        puVar5 = \"invalid string position\";\n        puVar7 = puStack60;\n        for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar7 = *puVar5;\n            puVar5 = puVar5 + 1;\n            puVar7 = puVar7 + 1;\n        }\n        for (uVar4 = uVar3 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar7 = *puVar5;\n            puVar5 = puVar5 + 1;\n            puVar7 = puVar7 + 1;\n        }\n        *(uVar3 + puStack60) = 0;\n    }\n    uStack12 = 0;\n    fcn.00414410(&stack0xffffffbc);\n    fcn.00402f00(0);\n    fcn.00412190(&stack0xffffffb8, 0, *0x435630);\n    fcn.00406350(&stack0xffffffbc, 0x439b98);\n    if (uVar2 != 0) {\n        cVar1 = *(uVar2 - 1);\n        if ((cVar1 != '\\0') && (cVar1 != -1)) {\n            *(uVar2 - 1) = cVar1 + -1;\n            *in_FS_OFFSET = 0;\n            return;\n        }\n        fcn.004166cf(uVar2 - 1);\n    }\n    *in_FS_OFFSET = 0;\n    return;\n}\n",
        "token_count": 622
    },
    "00412b90": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00412cbd)\n// WARNING: Removing unreachable block (ram,0x00412cc7)\n// WARNING: Removing unreachable block (ram,0x00412ccb)\n// WARNING: Removing unreachable block (ram,0x00412ce4)\n\nvoid __thiscall fcn.00412b90(int32_t param_1, uint32_t param_2, char param_3)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint *unaff_EBX;\n    char *pcVar4;\n    uint *puVar5;\n    uint *in_FS_OFFSET;\n    uint uStack48;\n    uint uStack20;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack12 = *in_FS_OFFSET;\n    uStack4 = 0xffffffff;\n    uStack8 = 0x42fa80;\n    *in_FS_OFFSET = &uStack12;\n    *(param_1 + 4) = param_2 & 7;\n    uVar2 = *(param_1 + 8) & param_2 & 7;\n    if (uVar2 != 0) {\n        if (param_3 != '\\0') {\n            fcn.00406350(0, 0);\n            *in_FS_OFFSET = uStack20;\n            return;\n        }\n        if ((uVar2 & 4) == 0) {\n            pcVar4 = \"ios::failbit set\";\n            if ((uVar2 & 2) == 0) {\n                pcVar4 = \"ios::eofbit set\";\n            }\n        }\n        else {\n            pcVar4 = \"ios::badbit set\";\n        }\n        uVar2 = 0xffffffff;\n        puVar5 = pcVar4;\n        do {\n            if (uVar2 == 0) break;\n            uVar2 = uVar2 - 1;\n            cVar1 = *puVar5;\n            puVar5 = puVar5 + 1;\n        } while (cVar1 != '\\0');\n        uVar2 = ~uVar2 - 1;\n        uStack48 = 0;\n        cVar1 = fcn.00402dc1(uVar2, 1);\n        if (cVar1 != '\\0') {\n            puVar5 = unaff_EBX;\n            for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar5 = *pcVar4;\n                pcVar4 = pcVar4 + 4;\n                puVar5 = puVar5 + 1;\n            }\n            for (uVar3 = uVar2 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar5 = *pcVar4;\n                pcVar4 = pcVar4 + 1;\n                puVar5 = puVar5 + 1;\n            }\n            *(uVar2 + unaff_EBX) = 0;\n        }\n        uStack12 = 0;\n        fcn.00414410(*0x10);\n        fcn.00402f00();\n        fcn.00412190(&stack0xffffffb8, 0, *0x435630);\n        fcn.00406350(&stack0xffffffbc, 0x439c50);\n    }\n    *in_FS_OFFSET = uStack48;\n    return;\n}\n",
        "token_count": 765
    },
    "00413480": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.00413480(code **param_1, uchar param_2)\n\n{\n    char cVar1;\n    code cVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    code *noname_0;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint *puVar5;\n    uint unaff_EDI;\n    char *pcVar6;\n    uint *puVar7;\n    uint *in_FS_OFFSET;\n    uint in_stack_ffffffdc;\n    code **arg_8h;\n    uint uStack12;\n    uint uStack8;\n    code *pcStack4;\n    \n    uStack8 = 0x42fb38;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    param_1[1] = 0x1;\n    *param_1 = vtable.std::locale::facet.0;\n    param_1[2] = NULL;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    *(param_1 + 5) = param_2;\n    *(param_1 + 6) = param_2;\n    uVar4 = 0xffffffff;\n    param_1[7] = NULL;\n    param_1[8] = NULL;\n    param_1[9] = NULL;\n    pcStack4 = NULL;\n    pcVar6 = 0x4357f4;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    noname_0 = ~uVar4 - 1;\n    arg_8h = param_1;\n    if (0xfffffffd < noname_0) {\n        in_stack_ffffffdc = 0x4134f5;\n        fcn.00412050();\n    }\n    pcVar3 = param_1[7];\n    if (((pcVar3 == NULL) || (cVar2 = pcVar3[-1],  cVar2 == 0x0)) || (cVar2 == 0xff)) {\n        if (noname_0 == NULL) {\n            fcn.00402f00(1);\n            goto code_r0x0041356c;\n        }\n        if ((0x1f < param_1[9]) || (param_1[9] < noname_0)) {\n            in_stack_ffffffdc = 1;\n            fcn.00402f00();\n            goto code_r0x0041353e;\n        }\n    }\n    else {\n        if (noname_0 == NULL) {\n            pcVar3[-1] = cVar2 + -1;\n            fcn.00402f00(0);\n            goto code_r0x0041356c;\n        }\ncode_r0x0041353e:\n        fcn.00402e4c(noname_0, in_stack_ffffffdc, unaff_EDI, unaff_ESI, unaff_EBP, unaff_EBX, arg_8h);\n    }\n    puVar5 = 0x4357f4;\n    puVar7 = param_1[7];\n    for (uVar4 = noname_0 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar7 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    for (uVar4 = noname_0 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar7 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    param_1[8] = pcStack4;\n    pcStack4[param_1[7]] = 0x0;\ncode_r0x0041356c:\n    *param_1 = vtable.std::locale::_Locimp.0;\n    *in_FS_OFFSET = unaff_EBX;\n    return param_1;\n}\n",
        "token_count": 952
    },
    "00414410": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.00414410(code **param_1, char **param_2)\n\n{\n    char cVar1;\n    uint *puVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    \n    uVar3 = 0xffffffff;\n    *param_1 = vtable.exception.0;\n    pcVar6 = *param_2;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    puVar2 = fcn.00416693(~uVar3);\n    param_1[1] = puVar2;\n    if (puVar2 != NULL) {\n        uVar3 = 0xffffffff;\n        pcVar6 = *param_2;\n        do {\n            pcVar7 = pcVar6;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar7 = pcVar6 + 1;\n            cVar1 = *pcVar6;\n            pcVar6 = pcVar7;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        puVar5 = pcVar7 + -uVar3;\n        for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar2 = *puVar5;\n            puVar5 = puVar5 + 1;\n            puVar2 = puVar2 + 1;\n        }\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar2 = *puVar5;\n            puVar5 = puVar5 + 1;\n            puVar2 = puVar2 + 1;\n        }\n    }\n    param_1[2] = 0x1;\n    return param_1;\n}\n",
        "token_count": 488
    },
    "00405310": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00405310(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    uint var_4h;\n    \n    uVar1 = fcn.00407ac0(arg_8h, arg_ch, arg_10h, arg_14h);\n    return uVar1;\n}\n",
        "token_count": 84
    },
    "00416e30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_40h\n// WARNING: Variable defined which should be unmapped: var_34h\n\nbool __cdecl\nfcn.00416e30(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    bool bVar4;\n    uint lpTemplate;\n    uint var_ch;\n    uint hInstance;\n    uint var_10h;\n    uint var_40h;\n    uint var_34h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint hMem;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = &stack0xffffffc0;\n    *(unaff_EBP + -0x24) = extraout_ECX;\n    if (*(unaff_EBP + 0x10) == 0) {\n        iVar2 = fcn.0042d07c();\n        *(unaff_EBP + 0x10) = *(iVar2 + 8);\n    }\n    iVar2 = fcn.0042d07c();\n    piVar1 = *(iVar2 + 0x1038);\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -0x28) = piVar1;\n    *(unaff_EBP + -0x20) = 0;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = fcn.0042d07c();\n    if ((*(iVar2 + 0x18) & 0x10) == 0) {\n        fcn.0041abf5(0x10);\n    }\n    if (piVar1 == NULL) {\ncode_r0x00416eab:\n        if (*(unaff_EBP + 8) != 0) {\n            fcn.0041b0c1();\n            *(unaff_EBP + -4) = 1;\n            *(unaff_EBP + -0x18) = 0;\n            iVar2 = fcn.0041ce7b(*(unaff_EBP + 8), unaff_EBP + -0x1c, unaff_EBP + -0x18);\n            bVar4 = iVar2 == 0;\n            if (bVar4) {\ncode_r0x00416f37:\n                fcn.0041cccb(*(unaff_EBP + 8));\n                *(unaff_EBP + -4) = 2;\n                fcn.0041d001(*(unaff_EBP + -0x18));\n                uVar3 = fcn.0041cd68();\n                *(unaff_EBP + -0x14) = uVar3;\n                *(unaff_EBP + -4) = 1;\n                fcn.0041cd5a();\n            }\n            else {\n                iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x2a);\n                if (iVar2 != 0) {\n                    iVar2 = fcn.00406090(*(unaff_EBP + -0x1c), 0x4314ac);\n                    if (iVar2 != 0) {\n                        iVar2 = fcn.00406090(*(unaff_EBP + -0x1c), \"Helv\");\n                        if (iVar2 != 0) {\n                            bVar4 = false;\n                            goto code_r0x00416f33;\n                        }\n                    }\n                    bVar4 = true;\n                    if (*(unaff_EBP + -0x18) == 8) {\n                        *(unaff_EBP + -0x18) = 0;\n                    }\n                }\ncode_r0x00416f33:\n                if (bVar4) goto code_r0x00416f37;\n            }\n            if (*(unaff_EBP + -0x14) != 0) {\n                uVar3 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(unaff_EBP + -0x14));\n                *(unaff_EBP + 8) = uVar3;\n            }\n            extraout_ECX[0xb] = -1;\n            extraout_ECX[9] = extraout_ECX[9] | 0x10;\n            fcn.004186ad(extraout_ECX);\n            if (*(unaff_EBP + 0xc) == 0) {\n                uVar3 = 0;\n            }\n            else {\n                uVar3 = *(*(unaff_EBP + 0xc) + 0x1c);\n            }\n            uVar3 = (*_sym.imp.USER32.dll_CreateDialogIndirectParamA)\n                              (*(unaff_EBP + 0x10), *(unaff_EBP + 8), uVar3, fcn.00416c78, 0);\n            *(unaff_EBP + -0x20) = uVar3;\n            *(unaff_EBP + -4) = 0;\n            fcn.0041b20c();\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*(unaff_EBP + -0x28) != NULL) {\n                (**(**(unaff_EBP + -0x28) + 0x14))(unaff_EBP + -0x34);\n                if (*(unaff_EBP + -0x20) != 0) {\n                    (**(*extraout_ECX + 0xbc))(0);\n                }\n            }\n            iVar2 = fcn.004186f9();\n            if (iVar2 == 0) {\n                (**(*extraout_ECX + 0xac))();\n            }\n            iVar2 = *(unaff_EBP + -0x20);\n            if ((iVar2 != 0) && ((*(extraout_ECX + 9) & 0x10) == 0)) {\n                (*_sym.imp.USER32.dll_DestroyWindow)(iVar2);\n                iVar2 = 0;\n            }\n            if (*(unaff_EBP + -0x14) != 0) {\n                (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*(unaff_EBP + -0x14));\n                (*_sym.imp.KERNEL32.dll_GlobalFree)(*(unaff_EBP + -0x14));\n            }\n            bVar4 = iVar2 != 0;\n            goto code_r0x0041703d;\n        }\n    }\n    else {\n        iVar2 = (**(*extraout_ECX + 0xbc))(unaff_EBP + -0x34);\n        if (iVar2 != 0) {\n            uVar3 = (**(*piVar1 + 0x10))(unaff_EBP + -0x34, *(unaff_EBP + 8));\n            *(unaff_EBP + 8) = uVar3;\n            goto code_r0x00416eab;\n        }\n    }\n    bVar4 = false;\ncode_r0x0041703d:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return bVar4;\n}\n",
        "token_count": 1703
    },
    "0041873b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nbool __cdecl\nfcn.0041873b(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h, uint arg_28h, uint arg_2ch, uint arg_30h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    bool bVar4;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint lpWindowName;\n    uint lpClassName;\n    uint dwExStyle;\n    \n    dwExStyle = arg_8h;\n    lpClassName = arg_ch;\n    lpWindowName = arg_10h;\n    var_10h = arg_14h;\n    var_14h = arg_18h;\n    var_18h = arg_1ch;\n    var_1ch = arg_20h;\n    var_20h = arg_24h;\n    var_24h = arg_28h;\n    var_28h = arg_2ch;\n    iVar1 = fcn.0042d07c();\n    var_2ch = *(iVar1 + 8);\n    iVar1 = *in_ECX;\n    var_30h = arg_30h;\n    iVar2 = (**(iVar1 + 100))(&var_30h);\n    if (iVar2 == 0) {\n        (**(iVar1 + 0xac))();\n        bVar4 = false;\n    }\n    else {\n        fcn.004186ad();\n        iVar2 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                          (dwExStyle, lpClassName, lpWindowName, var_10h, var_14h, var_18h, var_1ch, var_20h, var_24h, \n                           var_28h, var_2ch, var_30h);\n        iVar3 = fcn.004186f9();\n        if (iVar3 == 0) {\n            (**(iVar1 + 0xac))();\n        }\n        bVar4 = iVar2 != 0;\n    }\n    return bVar4;\n}\n",
        "token_count": 535
    },
    "00407760": {
        "rules": [
            "hash data using aphash/0253f481fbfe42f6972c4d360912dc99"
        ],
        "decompiled_code": "\nint32_t * fcn.00407760(int32_t *param_1)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    \n    bVar1 = false;\n    iVar6 = *param_1;\n    iVar2 = fcn.004085c0();\n    if (iVar6 < 0) {\n        return NULL;\n    }\n    if (*(iVar2 + 0x40) == 0) {\n        iVar3 = fcn.00405e40(0x24);\n        *(iVar2 + 0x40) = iVar3;\n        piVar4 = 0x440650;\n        if (iVar3 == 0) goto code_r0x0040779f;\n    }\n    piVar4 = *(iVar2 + 0x40);\ncode_r0x0040779f:\n    iVar7 = iVar6 % 0x7861f80;\n    iVar6 = (iVar6 / 0x7861f80) * 4;\n    iVar2 = iVar6 + 0x46;\n    iVar3 = iVar7;\n    if (0x1e1337f < iVar7) {\n        iVar3 = iVar7 + -0x1e13380;\n        iVar2 = iVar6 + 0x47;\n        if (0x1e1337f < iVar3) {\n            iVar3 = iVar7 + -0x3c26700;\n            iVar2 = iVar6 + 0x48;\n            if (iVar3 < 0x1e28500) {\n                bVar1 = true;\n            }\n            else {\n                iVar2 = iVar6 + 0x49;\n                iVar3 = iVar7 + -0x5a4ec00;\n            }\n        }\n    }\n    piVar4[5] = iVar2;\n    piVar4[7] = iVar3 / 0x15180;\n    iVar6 = 0x43d788;\n    if (!bVar1) {\n        iVar6 = 0x43d7c0;\n    }\n    piVar5 = iVar6 + 4;\n    iVar7 = 1;\n    iVar2 = *piVar5;\n    while (iVar2 < piVar4[7]) {\n        piVar5 = piVar5 + 1;\n        iVar7 = iVar7 + 1;\n        iVar2 = *piVar5;\n    }\n    piVar4[4] = iVar7 + -1;\n    piVar4[3] = piVar4[7] - *(iVar6 + (iVar7 + -1) * 4);\n    iVar6 = *param_1;\n    piVar4[8] = 0;\n    piVar4[6] = (iVar6 / 0x15180 + 4) % 7;\n    piVar4[2] = (iVar3 % 0x15180) / 0xe10;\n    iVar6 = (iVar3 % 0x15180) % 0xe10;\n    piVar4[1] = iVar6 / 0x3c;\n    *piVar4 = iVar6 % 0x3c;\n    return piVar4;\n}\n",
        "token_count": 724
    },
    "00429d0d": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00429d0d(int32_t param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    \n    if ((((param_2 != 0) && (param_2 != 6)) && (param_2 != 7)) && ((param_2 != 8 && (param_2 != 4)))) {\n        uVar1 = (*_sym.imp.USER32.dll_GetLastActivePopup)(*(param_1 + 0x1c));\n        (*_sym.imp.USER32.dll_BringWindowToTop)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 133
    },
    "00424cd7": {
        "rules": [
            "encrypt data using Curve25519/bbf924b96e5b4ce780ce59f68f21b030"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424cd7(int32_t arg_8h, int32_t lprcSrc)\n\n{\n    uint32_t uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    int32_t in_ECX;\n    uint arg_ch;\n    uint var_12ch;\n    uint lpRect;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t lprcDst;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowRect)(*(arg_8h + 0x1c), &lpRect);\n    if (*(arg_8h + 0x70) == in_ECX) {\n        if (lprcSrc == 0) {\n            return;\n        }\n        iVar3 = (*_sym.imp.USER32.dll_EqualRect)(&lpRect, lprcSrc);\n        if (iVar3 != 0) {\n            return;\n        }\n    }\n    if ((*(in_ECX + 0x78) != 0) && ((*(arg_8h + 0x68) & 0x40) != 0)) {\n        *(in_ECX + 100) = *(in_ECX + 100) | 0x40;\n    }\n    *(in_ECX + 100) = *(in_ECX + 100) & 0xfffffff9;\n    uVar4 = *(in_ECX + 100);\n    *(in_ECX + 100) = *(arg_8h + 100) & 6 | uVar4;\n    if ((uVar4 & 0x40) == 0) {\n        fcn.0041af3e(&var_12ch, 0x104);\n        fcn.0042039e(*(in_ECX + 0x1c), &var_12ch);\n    }\n    uVar4 = *(arg_8h + 100);\n    uVar1 = CONCAT11((*(arg_8h + 100) >> 8 ^ *(in_ECX + 100) >> 8) & 0xf0 ^ uVar4 >> 8, uVar4);\n    if (*(in_ECX + 0x78) == 0) {\n        uVar4 = uVar4 & 0xffff0000 | uVar1 & 0xfffffffe | 0xf00;\n    }\n    else {\n        uVar4 = uVar4 & 0xffff0000 | uVar1 | 0xf01;\n    }\n    fcn.0042c4af(uVar4);\n    var_18h = 0;\n    if ((*(arg_8h + 0x70) != in_ECX) && (iVar3 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(arg_8h + 0x1c)),  iVar3 != 0))\n    {\n        fcn.0041af6d(0, 0, 0, 0, 0, 0x97);\n        var_18h = 1;\n    }\n    var_14h = 0xffffffff;\n    if (lprcSrc == 0) {\n        fcn.0041602d(*(in_ECX + 0x84), arg_8h);\n        fcn.0041602d(*(in_ECX + 0x84), 0);\n        fcn.0041af6d(0, -*0x4400a0, -*0x4400a4, 0, 0, 0x115);\n    }\n    else {\n        (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, lprcSrc);\n        pcVar2 = _sym.imp.USER32.dll_ScreenToClient;\n        (*_sym.imp.USER32.dll_ScreenToClient)(*(in_ECX + 0x1c), &lprcDst);\n        (*pcVar2)(*(in_ECX + 0x1c), &var_8h);\n        var_14h = fcn.004258d0(arg_8h, lprcDst, var_ch, var_8h, var_4h, (var_8h - lprcDst) / 2 + lprcDst, \n                               (var_4h - var_ch) / 2 + var_ch);\n        fcn.0041af6d(0, lprcDst, var_ch, var_8h - lprcDst, var_4h - var_ch, 0x114);\n    }\n    uVar5 = (*_sym.imp.USER32.dll_GetParent)(*(arg_8h + 0x1c));\n    iVar3 = fcn.0041819c(uVar5);\n    if (iVar3 != in_ECX) {\n        if (in_ECX == 0) {\n            uVar5 = 0;\n        }\n        else {\n            uVar5 = *(in_ECX + 0x1c);\n        }\n        uVar5 = (*_sym.imp.USER32.dll_SetParent)(*(arg_8h + 0x1c), uVar5);\n        fcn.0041819c(uVar5);\n    }\n    iVar3 = *(arg_8h + 0x70);\n    if (iVar3 == in_ECX) {\n        uVar5 = 0;\n        arg_ch = var_14h;\n    }\n    else {\n        if (iVar3 == 0) goto code_r0x00424edf;\n        if ((*(in_ECX + 0x78) == 0) || (*(iVar3 + 0x78) != 0)) {\n            uVar5 = 0;\n        }\n        else {\n            uVar5 = 1;\n        }\n        arg_ch = 0xffffffff;\n    }\n    fcn.00425159(arg_8h, arg_ch, uVar5);\ncode_r0x00424edf:\n    *(arg_8h + 0x70) = in_ECX;\n    if (var_18h != 0) {\n        fcn.0041af6d(0, 0, 0, 0, 0, 0x57);\n    }\n    fcn.00425102(arg_8h);\n    iVar3 = fcn.00429d3c();\n    *(iVar3 + 0xb8) = *(iVar3 + 0xb8) | 0xc;\n    return;\n}\n",
        "token_count": 1434
    },
    "0040cd50": {
        "rules": [
            "parse credit card information/92c3fd9898ba41b4bad3ffb6188f4688",
            "search for credit card data/212a26c2b8d740cd9f6579dba482d653"
        ],
        "decompiled_code": "\nchar * fcn.0040cd50(char *param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    char *pcVar6;\n    char **ppcVar7;\n    char *pcVar8;\n    \n    if (((*0x4404f4 != NULL) || (((*0x4404fc == 0 || (iVar2 = fcn.0040e3d0(),  iVar2 == 0)) && (*0x4404f4 != NULL)))) &&\n       (param_1 != NULL)) {\n        uVar3 = 0xffffffff;\n        pcVar6 = **0x4404f4;\n        pcVar8 = param_1;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar8;\n            pcVar8 = pcVar8 + 1;\n        } while (cVar1 != '\\0');\n        uVar4 = ~uVar3 - 1;\n        ppcVar7 = *0x4404f4;\n        if (pcVar6 != NULL) {\n            do {\n                uVar5 = 0xffffffff;\n                pcVar8 = pcVar6;\n                do {\n                    if (uVar5 == 0) break;\n                    uVar5 = uVar5 - 1;\n                    cVar1 = *pcVar8;\n                    pcVar8 = pcVar8 + 1;\n                } while (cVar1 != '\\0');\n                if (((uVar4 < ~uVar5 - 1) && (pcVar6[uVar4] == '=')) &&\n                   (iVar2 = fcn.0040e390(pcVar6, param_1, uVar4),  iVar2 == 0)) {\n                    return *ppcVar7 + ~uVar3;\n                }\n                pcVar6 = ppcVar7[1];\n                ppcVar7 = ppcVar7 + 1;\n                if (pcVar6 == NULL) {\n                    return NULL;\n                }\n            } while( true );\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 485
    },
    "0040ee90": {
        "rules": [
            "parse credit card information/92c3fd9898ba41b4bad3ffb6188f4688",
            "search for credit card data/212a26c2b8d740cd9f6579dba482d653"
        ],
        "decompiled_code": "\nint32_t fcn.0040ee90(uint param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    iVar1 = **0x4404f4;\n    piVar2 = *0x4404f4;\n    if (iVar1 == 0) {\n        return 0;\n    }\n    while ((iVar1 = fcn.0040e390(param_1, iVar1, param_2),  iVar1 != 0 ||\n           ((*(*piVar2 + param_2) != '=' && (*(*piVar2 + param_2) != '\\0'))))) {\n        iVar1 = piVar2[1];\n        piVar2 = piVar2 + 1;\n        if (iVar1 == 0) {\n            return -(piVar2 - *0x4404f4 >> 2);\n        }\n    }\n    return piVar2 - *0x4404f4 >> 2;\n}\n",
        "token_count": 216
    },
    "0041686a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23",
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12"
        ],
        "decompiled_code": "\nuint32_t __cdecl\nfcn.0041686a(uint arg_8h, uint *arg_ch, uint noname_2, code *arg_14h, uint *arg_18h, uint32_t arg_1ch, uint *arg_20h)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 1;\n    if (arg_20h != NULL) {\n        *arg_20h = arg_8h;\n        arg_20h[1] = arg_14h;\n        return 1;\n    }\n    if (arg_1ch < 0xd) {\n        if (arg_1ch == 0xc) {\n            (*arg_14h)();\n            return 1;\n        }\n        arg_18h = arg_ch;\n        if (arg_1ch != 2) {\n            return 0;\n        }\ncode_r0x0041695f:\n        uVar1 = (*arg_14h)(arg_18h);\n        return uVar1;\n    }\n    if (arg_1ch < 0x24) {\n        if (arg_1ch == 0x23) {\n            uVar1 = (*arg_14h)();\n            return uVar1;\n        }\n        arg_18h = arg_ch;\n        if (arg_1ch != 0xd) {\n            return 0;\n        }\ncode_r0x00416954:\n        (*arg_14h)(arg_18h);\n        return 1;\n    }\n    if (9 < arg_1ch - 0x26) {\ncode_r0x0041696d:\n        return 0;\n    }\n    // switch table (10 cases) at 0x416971\n    switch(*((arg_1ch - 0x26) * 4 + 0x416971)) {\n    case 0x4168e4:\n        (*arg_14h)(arg_18h[1], *arg_18h);\n        break;\n    case 0x4168f4:\n        uVar1 = (*arg_14h)(arg_18h[1], *arg_18h);\n        break;\n    case 0x416904:\n        (*arg_14h)(arg_ch, arg_18h[1], *arg_18h);\n        break;\n    case 0x416917:\n        uVar1 = (*arg_14h)(arg_ch, arg_18h[1], *arg_18h);\n        break;\n    case 0x41692a:\n        (*arg_14h)(arg_18h);\n        goto code_r0x00416943;\n    case 0x416936:\n        (*arg_14h)(arg_18h, arg_ch);\ncode_r0x00416943:\n        uVar1 = arg_18h[7] == 0;\n        arg_18h[7] = 0;\n        break;\n    case 0x416951:\n        goto code_r0x00416954;\n    case 0x41695c:\n        goto code_r0x0041695f;\n    case 0x41696b:\n        goto code_r0x0041696d;\n    }\n    return uVar1;\n}\n",
        "token_count": 699
    },
    "0040c0b0": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nuint8_t fcn.0040c0b0(uint32_t param_1)\n\n{\n    if (*0x440f20 <= param_1) {\n        return 0;\n    }\n    return *(*((param_1 >> 5) * 4 + 0x440e20) + 4 + (param_1 & 0x1f) * 0x24) & 0x40;\n}\n",
        "token_count": 92
    },
    "0040c830": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nint32_t fcn.0040c830(uint32_t param_1, char *param_2, uint32_t param_3)\n\n{\n    int32_t *piVar1;\n    char cVar2;\n    char *pcVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    char *pcVar7;\n    int32_t iStack1052;\n    int32_t iStack1044;\n    int32_t iStack1040;\n    int32_t iStack1036;\n    int32_t *piStack1032;\n    char acStack1028 [1028];\n    \n    iStack1052 = 0;\n    iStack1036 = 0;\n    if (param_3 == 0) {\n        return 0;\n    }\n    piVar1 = (param_1 >> 5) * 4 + 0x440e20;\n    iVar6 = (param_1 & 0x1f) * 0x24;\n    piStack1032 = piVar1;\n    if ((*(iVar6 + 4 + *piVar1) & 0x20) != 0) {\n        fcn.0040c730(param_1, 0, 2);\n    }\n    if ((*(*piVar1 + iVar6 + 1) & 0x80) == 0) {\n        iVar4 = (*_sym.imp.KERNEL32.dll_WriteFile)(*(*piVar1 + iVar6), param_2, param_3, &iStack1040, 0);\n        if (iVar4 == 0) {\n            iStack1044 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        else {\n            iStack1052 = iStack1040;\n            iStack1044 = 0;\n        }\n    }\n    else {\n        iStack1044 = 0;\n        pcVar7 = param_2;\n        if (param_3 != 0) {\n            do {\n                pcVar3 = acStack1028;\n                do {\n                    if (param_3 <= pcVar7 - param_2) break;\n                    cVar2 = *pcVar7;\n                    pcVar7 = pcVar7 + 1;\n                    if (cVar2 == '\\n') {\n                        *pcVar3 = '\\r';\n                        iStack1036 = iStack1036 + 1;\n                        pcVar3 = pcVar3 + 1;\n                    }\n                    *pcVar3 = cVar2;\n                    pcVar3 = pcVar3 + 1;\n                } while (pcVar3 - acStack1028 < 0x400);\n                iVar4 = (*_sym.imp.KERNEL32.dll_WriteFile)\n                                  (*(iVar6 + *piStack1032), acStack1028, pcVar3 - acStack1028, &iStack1040, 0);\n                if (iVar4 == 0) {\n                    iStack1044 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    break;\n                }\n                iStack1052 = iStack1052 + iStack1040;\n                if ((iStack1040 < pcVar3 - acStack1028) || (param_3 <= pcVar7 - param_2)) break;\n            } while( true );\n        }\n    }\n    if (iStack1052 != 0) {\n        return iStack1052 - iStack1036;\n    }\n    if (iStack1044 == 0) {\n        if (((*(iVar6 + 4 + *piStack1032) & 0x40) != 0) && (*param_2 == '\\x1a')) {\n            return 0;\n        }\n        puVar5 = fcn.00407210();\n        *puVar5 = 0x1c;\n        puVar5 = fcn.00407220();\n        *puVar5 = 0;\n        return -1;\n    }\n    if (iStack1044 != 5) {\n        fcn.00407190(iStack1044);\n        return -1;\n    }\n    puVar5 = fcn.00407210();\n    *puVar5 = 9;\n    puVar5 = fcn.00407220();\n    *puVar5 = 5;\n    return -1;\n}\n",
        "token_count": 926
    },
    "0040e2f0": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nvoid fcn.0040e2f0(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = (param_1 & 0x1f) * 0x24;\n    iVar1 = *((param_1 >> 5) * 4 + 0x440e20) + iVar2;\n    if (*(iVar1 + 8) == 0) {\n        fcn.00408940(0x11);\n        if (*(iVar1 + 8) == 0) {\n            (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(iVar1 + 0xc);\n            *(iVar1 + 8) = *(iVar1 + 8) + 1;\n        }\n        fcn.004089c0(0x11);\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(*((param_1 >> 5) * 4 + 0x440e20) + 0xc + iVar2);\n    return;\n}\n",
        "token_count": 222
    },
    "0040e360": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nvoid fcn.0040e360(uint32_t param_1)\n\n{\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(*((param_1 >> 5) * 4 + 0x440e20) + 0xc + (param_1 & 0x1f) * 0x24);\n    return;\n}\n",
        "token_count": 75
    },
    "00414f10": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.00414f10(uint32_t param_1, char *param_2, int32_t param_3)\n\n{\n    int32_t *piVar1;\n    char cVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint unaff_EBX;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    char *pcVar8;\n    uint uStack32;\n    char *pcStack12;\n    char *pcStack8;\n    int32_t *piStack4;\n    \n    iVar7 = 0;\n    if (param_3 != 0) {\n        iVar4 = *((param_1 >> 5) * 4 + 0x440e20);\n        piVar1 = (param_1 >> 5) * 4 + 0x440e20;\n        iVar6 = (param_1 & 0x1f) * 0x24;\n        uVar3 = *(iVar6 + 4 + iVar4);\n        if ((uVar3 & 2) == 0) {\n            pcVar8 = param_2;\n            if (((uVar3 & 0x48) != 0) && (cVar2 = *(iVar6 + iVar4 + 5),  cVar2 != '\\n')) {\n                *param_2 = cVar2;\n                param_3 = param_3 + -1;\n                pcVar8 = param_2 + 1;\n                iVar7 = 1;\n                *(iVar6 + 5 + *piVar1) = 10;\n            }\n            uStack32 = 0;\n            piStack4 = piVar1;\n            iVar4 = (*_sym.imp.KERNEL32.dll_ReadFile)(*(iVar6 + *piVar1), pcVar8, param_3, &pcStack8);\n            if (iVar4 != 0) {\n                iVar7 = iVar7 + unaff_EDI;\n                uVar3 = *(iVar6 + 4 + *piVar1);\n                if ((uVar3 & 0x80) != 0) {\n                    if ((unaff_EDI == 0) || (*param_2 != '\\n')) {\n                        uVar3 = uVar3 & 0xfb;\n                    }\n                    else {\n                        uVar3 = uVar3 | 4;\n                    }\n                    *(iVar6 + 4 + *piVar1) = uVar3;\n                    pcStack8 = pcStack12 + iVar7;\n                    pcVar8 = param_2;\n                    if (pcStack12 < pcStack8) {\n                        while (cVar2 = *pcVar8,  cVar2 != '\\x1a') {\n                            if (cVar2 == '\\r') {\n                                if (pcVar8 < pcStack8 + -1) {\n                                    if (pcVar8[1] == '\\n') {\n                                        pcVar8 = pcVar8 + 2;\n                                        *param_2 = '\\n';\n                                        goto code_r0x004150e8;\n                                    }\n                                    *param_2 = '\\r';\n                                    param_2 = param_2 + 1;\n                                    pcVar8 = pcVar8 + 1;\n                                }\n                                else {\n                                    iVar4 = 0;\n                                    pcVar8 = pcVar8 + 1;\n                                    iVar7 = (*_sym.imp.KERNEL32.dll_ReadFile)\n                                                      (*(iVar6 + *unaff_ESI), &uStack32 + 3, 1, &stack0xffffffe4, 0);\n                                    if (iVar7 == 0) {\n                                        iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                    }\n                                    if ((iVar4 == 0) && (unaff_EDI != 0)) {\n                                        if ((*(iVar6 + 4 + *unaff_ESI) & 0x48) == 0) {\n                                            if ((param_2 == pcStack12) && (uStack32._3_1_ == '\\n')) {\n                                                *param_2 = '\\n';\n                                                goto code_r0x004150e8;\n                                            }\n                                            fcn.0040c730(unaff_EBX, 0xffffffff, 1);\n                                            if (uStack32._3_1_ != '\\n') goto code_r0x004150e5;\n                                        }\n                                        else {\n                                            if (uStack32._3_1_ == '\\n') {\n                                                *param_2 = '\\n';\n                                                goto code_r0x004150e8;\n                                            }\n                                            *param_2 = '\\r';\n                                            param_2 = param_2 + 1;\n                                            *(iVar6 + 5 + *unaff_ESI) = uStack32._3_1_;\n                                        }\n                                    }\n                                    else {\ncode_r0x004150e5:\n                                        *param_2 = '\\r';\ncode_r0x004150e8:\n                                        param_2 = param_2 + 1;\n                                    }\n                                }\n                            }\n                            else {\n                                *param_2 = cVar2;\n                                param_2 = param_2 + 1;\n                                pcVar8 = pcVar8 + 1;\n                            }\n                            if (pcStack8 <= pcVar8) {\n                                return param_2 - pcStack12;\n                            }\n                        }\n                        uVar3 = *(iVar6 + 4 + *unaff_ESI);\n                        if ((uVar3 & 0x40) == 0) {\n                            *(iVar6 + 4 + *unaff_ESI) = uVar3 | 2;\n                        }\n                    }\n                    iVar7 = param_2 - pcStack12;\n                }\n                return iVar7;\n            }\n            iVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar7 == 5) {\n                puVar5 = fcn.00407210();\n                *puVar5 = 9;\n                puVar5 = fcn.00407220();\n                *puVar5 = 5;\n                return -1;\n            }\n            if (iVar7 != 0x6d) {\n                fcn.00407190(iVar7);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1365
    },
    "00427438": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427438(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar1 = arg_8h - *(in_ECX + 4);\n    iVar3 = arg_ch - *(in_ECX + 8);\n    iVar2 = *(in_ECX + 0x8c);\n    uVar4 = 2;\n    if (iVar2 == 10) {\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + iVar1;\n    }\n    else {\n        if (iVar2 != 0xb) {\n            uVar4 = 0x22;\n            if (iVar2 == 0xc) {\n                *(in_ECX + 0x2c) = *(in_ECX + 0x2c) + iVar3;\n            }\n            else {\n                *(in_ECX + 0x34) = *(in_ECX + 0x34) + iVar3;\n            }\n            iVar2 = *(in_ECX + 0x34) - *(in_ECX + 0x2c);\n            goto code_r0x00427492;\n        }\n        *(in_ECX + 0x30) = *(in_ECX + 0x30) + iVar1;\n    }\n    iVar2 = *(in_ECX + 0x30) - *(in_ECX + 0x28);\ncode_r0x00427492:\n    if (iVar2 < 0) {\n        iVar2 = 0;\n    }\n    var_8h = in_ECX;\n    var_4h = in_ECX;\n    (**(**(in_ECX + 0x68) + 0xc4))(&var_8h, iVar2, uVar4);\n    if ((*(in_ECX + 0x8c) == 10) || (*(in_ECX + 0x8c) == 0xc)) {\n        *(in_ECX + 0x38) = *(in_ECX + 0x40) - var_8h;\n        *(in_ECX + 0x3c) = *(in_ECX + 0x44) - var_4h;\n        *(in_ECX + 0x48) = ((*(in_ECX + 0x50) - *(in_ECX + 0x60)) + *(in_ECX + 0x58)) - var_8h;\n        *(in_ECX + 0x4c) = ((*(in_ECX + 0x5c) - *(in_ECX + 100)) + *(in_ECX + 0x54)) - var_4h;\n    }\n    else {\n        *(in_ECX + 0x40) = *(in_ECX + 0x38) + var_8h;\n        *(in_ECX + 0x44) = *(in_ECX + 0x3c) + var_4h;\n        *(in_ECX + 0x50) = ((*(in_ECX + 0x60) + *(in_ECX + 0x48)) - *(in_ECX + 0x58)) + var_8h;\n        *(in_ECX + 0x54) = (*(in_ECX + 100) - *(in_ECX + 0x5c)) + *(in_ECX + 0x4c) + var_4h;\n    }\n    *(in_ECX + 4) = arg_8h;\n    *(in_ECX + 8) = arg_ch;\n    fcn.00427767(0);\n    return;\n}\n",
        "token_count": 840
    },
    "00416577": {
        "rules": [
            "hash data using djb2/6ad21e310d674441ba35d7276afbe57d",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00416577(int32_t param_1, char *param_2, uint32_t *param_3)\n\n{\n    char *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    char cVar4;\n    char *pcVar5;\n    uint *puVar6;\n    \n    uVar2 = 0;\n    cVar4 = *param_2;\n    pcVar5 = param_2;\n    while (cVar4 != '\\0') {\n        uVar2 = uVar2 * 0x21 + cVar4;\n        pcVar1 = pcVar5 + 1;\n        pcVar5 = pcVar5 + 1;\n        cVar4 = *pcVar1;\n    }\n    uVar2 = uVar2 % *(param_1 + 8);\n    *param_3 = uVar2;\n    if (*(param_1 + 4) != 0) {\n        for (puVar6 = *(*(param_1 + 4) + uVar2 * 4); puVar6 != NULL; puVar6 = *puVar6) {\n            iVar3 = fcn.00406090(puVar6[2], param_2);\n            if (iVar3 == 0) {\n                return puVar6;\n            }\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 299
    },
    "0041c728": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\nuint fcn.0041c728(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    \n    if (0x10b < param_1) {\n        if (param_1 == 0x3e3) {\n            return 10;\n        }\n        if (param_1 == 0x3e4) {\n            return 10;\n        }\n        if (param_1 == 0x3e5) {\n            return 10;\n        }\n        if (param_1 == 999) {\n            return 5;\n        }\n        return 1;\n    }\n    if (param_1 == 0x10b) {\n        return 3;\n    }\n    if (param_1 < 0x3f) {\n    // switch table (61 cases) at 0x41c888\n        switch(param_1) {\n        case 0:\n            return 0;\n        case 1:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xd:\n        case 0xe:\n        case 0x1c:\n        case 0x1f:\n        case 0x23:\n        case 0x25:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x2f:\n        case 0x30:\n        case 0x31:\n        case 0x32:\n        case 0x33:\n        case 0x38:\n            goto code_r0x0041c812;\n        case 2:\n        case 6:\n        case 0x12:\n            return 2;\n        case 3:\n        case 0xf:\n        case 0x11:\n        case 0x22:\n        case 0x34:\n        case 0x35:\n        case 0x37:\n            goto code_r0x0041c812;\n        case 4:\n        case 0x24:\n            return 4;\n        case 5:\n        case 0xc:\n        case 0x13:\n        case 0x1d:\n        case 0x36:\n        case 0x3a:\n            return 5;\n        case 0xb:\n        case 0x1a:\n        case 0x3c:\n            return 6;\n        case 0x10:\n            return 7;\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x39:\n        case 0x3b:\n            goto code_r0x0041c812;\n        case 0x18:\n        case 0x19:\n        case 0x1b:\n        case 0x1e:\n            return 9;\n        case 0x20:\n            return 0xb;\n        case 0x21:\n            return 0xc;\n        case 0x26:\n            return 0xe;\n        case 0x27:\n            return 0xd;\n        default:\n            return 8;\n        }\n    }\n    if (param_1 < 0x6c) {\n        if (param_1 == 0x6b) {\n            return 2;\n        }\n        if (param_1 < 0x48) {\n            if (param_1 == 0x47) {\n                return 5;\n            }\n            if (param_1 == 0x40) {\n                return 5;\n            }\n            if (param_1 == 0x41) {\n                return 5;\n            }\n            if (param_1 == 0x42) {\n                return 6;\n            }\n            if (param_1 == 0x43) {\n                return 3;\n            }\n            iVar1 = param_1 - 0x44;\n            if (iVar1 == 0) {\n                return 4;\n            }\ncode_r0x0041c7e8:\n            bVar2 = iVar1 == 2;\n            goto code_r0x0041c7ea;\n        }\n        if (param_1 == 0x50) {\n            return 5;\n        }\n        if (param_1 == 0x52) {\n            return 5;\n        }\n        if (param_1 == 0x55) {\n            return 3;\n        }\n        if (param_1 == 0x56) {\n            return 5;\n        }\n        bVar2 = param_1 == 0x58;\n    }\n    else {\n        if (param_1 < 0x70) {\n            if (param_1 == 0x6f) {\n                return 3;\n            }\n            if (param_1 == 0x6c) {\n                return 0xc;\n            }\n            return 1;\n        }\n        if (0x90 < param_1) {\n            if (param_1 < 0x9b) {\n                if (param_1 == 0x9a) {\n                    return 3;\n                }\n                if (param_1 == 0x91) {\n                    return 7;\n                }\n                return 1;\n            }\n            if (0xa7 < param_1) {\n                if (param_1 == 0xaa) {\n                    return 5;\n                }\n                if (param_1 == 0xb6) {\n                    return 6;\n                }\n                if (param_1 == 0xb7) {\n                    return 5;\n                }\n                if (param_1 == 0xbf) {\n                    return 6;\n                }\n                if (param_1 == 0xc1) {\n                    return 6;\n                }\n                iVar1 = param_1 - 0xce;\n                if (iVar1 == 0) {\n                    return 3;\n                }\n                goto code_r0x0041c7e8;\n            }\n            if (param_1 == 0xa7) {\n                return 0xc;\n            }\n            bVar2 = param_1 == 0xa1;\ncode_r0x0041c7ea:\n            if (!bVar2) {\n                return 1;\n            }\ncode_r0x0041c812:\n            return 3;\n        }\n        if (param_1 == 0x90) {\n            return 3;\n        }\n        if (0x7b < param_1) {\n            if (param_1 == 0x7c) {\n                return 3;\n            }\n            if (param_1 == 0x7d) {\n                return 3;\n            }\n            if (param_1 == 0x83) {\n                return 9;\n            }\n            if (param_1 == 0x84) {\n                return 9;\n            }\n            return 1;\n        }\n        if (param_1 == 0x7b) {\n            return 3;\n        }\n        if (param_1 == 0x70) {\n            return 0xd;\n        }\n        if (param_1 == 0x71) {\n            return 4;\n        }\n        if (param_1 == 0x72) {\n            return 6;\n        }\n        bVar2 = param_1 == 0x75;\n    }\n    if (bVar2) {\ncode_r0x0041c812:\n        return 10;\n    }\ncode_r0x0041c812:\n    return 1;\n}\n",
        "token_count": 1651
    },
    "0042c5b3": {
        "rules": [
            "check for trap flag exception/d5d4160e77a5474aa5157e4631e4f1b3"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042c5b3(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint32_t arg_10h_00;\n    uint lprc;\n    \n    *(in_ECX + 100) = arg_ch;\n    arg_10h_00 = CONCAT31(arg_ch >> 8 & 0xffff00, 0x4e);\n    uVar1 = fcn.0041ae7b();\n    if ((uVar1 & 0x40000) != 0) {\n        arg_10h_00 = arg_10h_00 | 0x100;\n    }\n    iVar2 = fcn.0042d07c();\n    if ((*(iVar2 + 0x18) & 0x10) == 0) {\n        fcn.0041abf5(0x10);\n    }\n    (*_sym.imp.USER32.dll_SetRectEmpty)(&lprc);\n    fcn.00418831(\"msctls_statusbar32\", 0, arg_10h_00, &lprc, arg_8h, arg_10h, 0);\n    return;\n}\n",
        "token_count": 281
    },
    "0041db6e": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a",
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041db6e(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDocument.0;\n    *(unaff_EBP + -4) = 3;\n    fcn.0041dbe2();\n    if (extraout_ECX[9] != NULL) {\n        (**(*extraout_ECX[9] + 0x68))(extraout_ECX);\n    }\n    *(unaff_EBP + -4) = 2;\n    fcn.00415d58();\n    *(unaff_EBP + -4) = 1;\n    fcn.0041b20c();\n    *(unaff_EBP + -4) = 0;\n    fcn.0041b20c();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00416716();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 288
    },
    "00427534": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00427534(int32_t param_1)\n\n{\n    int32_t iStack8;\n    int32_t iStack4;\n    \n    iStack8 = param_1;\n    iStack4 = param_1;\n    fcn.0042771e();\n    (**(**(param_1 + 0x68) + 0xc4))(&iStack8, *(param_1 + 0x40) - *(param_1 + 0x38), 0x42);\n    fcn.0042a01f(*(param_1 + 0x68), *(param_1 + 0x48), *(param_1 + 0x4c), *(param_1 + 0x70) & 0x40 | 0x2004);\n    return;\n}\n",
        "token_count": 178
    },
    "00429a79": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00429a79(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t *in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (in_ECX[0x2c] == 0) {\n        in_ECX[0x2c] = 1;\n        if ((in_ECX[0x2e] & 4U) != 0) {\n            arg_8h = 1;\n        }\n        in_ECX[0x2e] = in_ECX[0x2e] & 0xfffffff3;\n        if ((arg_8h != 0) && (in_ECX[0x1a] != NULL)) {\n            (**(*in_ECX[0x1a] + 0x58))();\n        }\n        uVar1 = fcn.0041ae7b();\n        if ((uVar1 & 0x2000) == 0) {\n            fcn.00419d18(0, 0xffff, 0xe900, 2, in_ECX + 0x16, 0, 1);\n        }\n        else {\n            var_8h = 0x7fff;\n            var_4h = 0x7fff;\n            var_10h = 0;\n            var_ch = 0;\n            fcn.00419d18(0, 0xffff, 0xe900, 1, &var_10h, &var_10h, 0);\n            fcn.00419d18(0, 0xffff, 0xe900, 2, in_ECX + 0x16, &var_10h, 1);\n            (**(*in_ECX + 0x68))(&var_10h, 0);\n            fcn.0041af6d(0, 0, 0, var_8h - var_10h, var_4h - var_ch, 0x16);\n        }\n        in_ECX[0x2c] = 0;\n    }\n    return;\n}\n",
        "token_count": 488
    },
    "0040118b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nuint8_t * fcn.0040118b(void)\n\n{\n    uchar *puVar1;\n    uint32_t uVar2;\n    uint8_t *puVar3;\n    uint32_t uVar4;\n    uint8_t uVar5;\n    uint32_t uStack00000008;\n    int32_t iStack0000000c;\n    uint8_t *puStack00000010;\n    int32_t in_stack_0000190c;\n    uint32_t in_stack_00001910;\n    uint8_t *in_stack_00001914;\n    int32_t in_stack_00001918;\n    \n    puStack00000010 = in_stack_00001914;\n    iStack0000000c = in_stack_00001918;\n    fcn.00405820();\n    uVar4 = 0;\n    if (iStack0000000c == 0) {\n        puVar3 = NULL;\n    }\n    else {\n        uVar2 = 0;\n        do {\n            (&stack0x00000014)[uVar2] = uVar2;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < 0x18f1);\n        uVar2 = 0;\n        do {\n            uVar5 = (&stack0x00000014)[uVar4];\n            puVar1 = &stack0x00000014 + uVar4;\n            uVar2 = (*(uVar4 % in_stack_00001910 + in_stack_0000190c) + uVar2 + uVar5) % 0x18f1;\n            uVar4 = uVar4 + 1;\n            *puVar1 = (&stack0x00000014)[uVar2];\n            (&stack0x00000014)[uVar2] = uVar5;\n        } while (uVar4 < 0x18f1);\n        uVar4 = 0;\n        uStack00000008 = 0;\n        puVar3 = puStack00000010;\n        do {\n            uVar4 = (uVar4 + 1) % 0x18f1;\n            uVar5 = (&stack0x00000014)[uVar4];\n            uStack00000008 = (uStack00000008 + uVar5) % 0x18f1;\n            (&stack0x00000014)[uVar4] = (&stack0x00000014)[uStack00000008];\n            (&stack0x00000014)[uStack00000008] = uVar5;\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            fcn.004057c0(\"Characters: %c %c \\n\", 0x61, 0x41);\n            fcn.004057c0(\"Decimals: %d %ld\\n\", 0x7b9, 650000);\n            fcn.004057c0(\"Preceding with blanks: %10d \\n\", 0x7b9);\n            fcn.004057c0(\"Preceding with zeros: %010d \\n\", 0x7b9);\n            *puStack00000010 = *puStack00000010 ^ (&stack0x00000014)[(uVar5 + (&stack0x00000014)[uVar4]) % 0x18f1];\n            puStack00000010 = puStack00000010 + 1;\n            iStack0000000c = iStack0000000c + -1;\n        } while (iStack0000000c != 0);\n    }\n    return puVar3;\n}\n",
        "token_count": 15124
    },
    "00402e4c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl\nfcn.00402e4c(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint arg_8h)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t extraout_ECX;\n    uint32_t uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    uVar4 = *(unaff_EBP + 8) | 0x1f;\n    *(unaff_EBP + -0x10) = &var_14h;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    if (0xfffffffd < uVar4) {\n        uVar4 = *(unaff_EBP + 8);\n    }\n    *(unaff_EBP + -4) = 0;\n    iVar2 = uVar4 + 2;\n    if (iVar2 < 0) {\n        iVar2 = 0;\n    }\n    uVar3 = fcn.00416693(iVar2);\n    *(unaff_EBP + 8) = uVar3;\n    iVar2 = *(extraout_ECX + 8);\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (iVar2 != 0) {\n        fcn.00405850(*(unaff_EBP + 8) + 1, *(extraout_ECX + 4), iVar2);\n    }\n    iVar2 = *(extraout_ECX + 8);\n    fcn.00402f00(1);\n    puVar1 = *(unaff_EBP + 8);\n    uVar3 = *(unaff_EBP + -0xc);\n    *(extraout_ECX + 4) = puVar1 + 1;\n    *puVar1 = 0;\n    *(extraout_ECX + 8) = iVar2;\n    *(extraout_ECX + 0xc) = uVar4;\n    *(iVar2 + *(extraout_ECX + 4)) = 0;\n    *in_FS_OFFSET = uVar3;\n    return;\n}\n",
        "token_count": 548
    },
    "004032a3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004032a3(int32_t *param_1)\n\n{\n    uint var_10h;\n    uint var_ch;\n    \n    param_1[0x37] = 0;\n    fcn.0042c4af(param_1[0x19] & 0xffff2fffU | 0x2000);\n    fcn.0042210a(5, 0x65, 1, 0x96);\n    if (param_1[0x2f] != 0) {\n        (**(*param_1 + 0xe8))(5, &var_10h);\n        fcn.0041af6d(0, var_10h, var_ch, 0, 0, 0x115);\n        fcn.0041afbc(5);\n    }\n    return 1;\n}\n",
        "token_count": 188
    },
    "00403ef3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00403ef3(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    fcn.0041b0c1(extraout_ECX);\n    iVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    fcn.0041561a(unaff_EBP + -0x10, \"%u,%u,%d,%d,%d,%d,%d,%d,%d,%d\", *(iVar1 + 4), *(iVar1 + 8), *(iVar1 + 0xc), \n                 *(iVar1 + 0x10), *(iVar1 + 0x14), *(iVar1 + 0x18), *(iVar1 + 0x1c), *(iVar1 + 0x20), *(iVar1 + 0x24), \n                 *(iVar1 + 0x28));\n    fcn.0042d07c();\n    fcn.00425e4b(\"Settings\", \"WindowPos\", *(unaff_EBP + -0x10));\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041b20c();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 376
    },
    "004045c1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.004045c1(int32_t param_1, ushort param_2)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *(param_1 + 0x24) + 2;\n    if (*(param_1 + 0x28) <= uVar1 && uVar1 != *(param_1 + 0x28)) {\n        fcn.00420100();\n    }\n    **(param_1 + 0x24) = param_2;\n    *(param_1 + 0x24) = *(param_1 + 0x24) + 2;\n    return param_1;\n}\n",
        "token_count": 147
    },
    "004045e8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.004045e8(int32_t param_1, uint param_2)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *(param_1 + 0x24) + 4;\n    if (*(param_1 + 0x28) <= uVar1 && uVar1 != *(param_1 + 0x28)) {\n        fcn.00420100();\n    }\n    **(param_1 + 0x24) = param_2;\n    *(param_1 + 0x24) = *(param_1 + 0x24) + 4;\n    return param_1;\n}\n",
        "token_count": 147
    },
    "0040460e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040460e(int32_t param_1)\n\n{\n    ushort *unaff_retaddr;\n    \n    if (*(param_1 + 0x28) < *(param_1 + 0x24) + 2U) {\n        fcn.0042017a((*(param_1 + 0x24) - *(param_1 + 0x28)) + 2);\n    }\n    *unaff_retaddr = **(param_1 + 0x24);\n    *(param_1 + 0x24) = *(param_1 + 0x24) + 2;\n    return param_1;\n}\n",
        "token_count": 146
    },
    "00404641": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00404641(int32_t param_1)\n\n{\n    uint *unaff_retaddr;\n    \n    if (*(param_1 + 0x28) < *(param_1 + 0x24) + 4U) {\n        fcn.0042017a((*(param_1 + 0x24) - *(param_1 + 0x28)) + 4);\n    }\n    *unaff_retaddr = **(param_1 + 0x24);\n    *(param_1 + 0x24) = *(param_1 + 0x24) + 4;\n    return param_1;\n}\n",
        "token_count": 145
    },
    "004053b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004053b0(uint arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    fcn.00407ac0(arg_8h, *(arg_ch + 0xc), arg_10h, 0, *(arg_ch + 8), *(arg_ch + 0x10), arg_ch, 0);\n    return;\n}\n",
        "token_count": 85
    },
    "004056d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint fcn.004056d0(uint param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    fcn.00406310();\n    uVar1 = fcn.004072e0(*0x441f48);\n    if (uVar1 < *0x441f44 + (4 - *0x441f48)) {\n        iVar2 = fcn.004072e0(*0x441f48);\n        iVar2 = fcn.00408760(*0x441f48, iVar2 + 0x10);\n        if (iVar2 == 0) {\n            fcn.00406320();\n            return 0;\n        }\n        *0x441f44 = iVar2 + (*0x441f44 - *0x441f48 >> 2) * 4;\n        *0x441f48 = iVar2;\n    }\n    **0x441f44 = param_1;\n    *0x441f44 = *0x441f44 + 1;\n    fcn.00406320();\n    return param_1;\n}\n",
        "token_count": 241
    },
    "00405760": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00405760(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004056d0(param_1);\n    return (iVar1 != 0) - 1;\n}\n",
        "token_count": 53
    },
    "004057c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.004057c0(uint param_1)\n\n{\n    uint uVar1;\n    uint uVar2;\n    \n    fcn.00408a20(1, 0x43b0e0);\n    uVar1 = fcn.00408ac0(0x43b0e0);\n    uVar2 = fcn.00408ba0(0x43b0e0, param_1, &stack0x00000008);\n    fcn.00408b60(uVar1, 0x43b0e0);\n    fcn.00408a90(1, 0x43b0e0);\n    return uVar2;\n}\n",
        "token_count": 150
    },
    "00405df0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00405df0(code **param_1)\n\n{\n    *param_1 = vtable.type_info.0;\n    fcn.00408940(0x1b);\n    if (param_1[1] != NULL) {\n        fcn.00405f10(param_1[1]);\n    }\n    fcn.004089c0(0x1b);\n    return;\n}\n",
        "token_count": 91
    },
    "00405e40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00405e40(uint param_1)\n\n{\n    fcn.00405e60(param_1, *0x440800);\n    return;\n}\n",
        "token_count": 37
    },
    "00405e60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00405e60(uint32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    if (param_1 < 0xffffffe1) {\n        if (param_1 == 0) {\n            param_1 = 1;\n        }\n        do {\n            if (param_1 < 0xffffffe1) {\n                iVar1 = fcn.00405eb0(param_1);\n            }\n            else {\n                iVar1 = 0;\n            }\n            if (iVar1 != 0) {\n                return iVar1;\n            }\n            if (param_2 == 0) {\n                return 0;\n            }\n            iVar1 = fcn.0040a440(param_1);\n        } while (iVar1 != 0);\n    }\n    return 0;\n}\n",
        "token_count": 183
    },
    "00405eb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00405eb0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    uVar2 = param_1 + 0xfU & 0xfffffff0;\n    if (uVar2 <= *0x43d4a4) {\n        fcn.00408940(9);\n        iVar1 = fcn.0040a7c0(param_1 + 0xfU >> 4);\n        fcn.004089c0(9);\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x440e14, 0, uVar2);\n    return iVar1;\n}\n",
        "token_count": 172
    },
    "00405f10": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00405f10(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uStack4;\n    \n    iVar1 = param_1;\n    if (param_1 != 0) {\n        fcn.00408940(9);\n        iVar2 = fcn.0040a700(iVar1, &uStack4, &param_1);\n        if (iVar2 != 0) {\n            fcn.0040a760(uStack4, param_1, iVar2);\n            fcn.004089c0(9);\n            return;\n        }\n        fcn.004089c0(9);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(*0x440e14, 0, iVar1);\n    }\n    return;\n}\n",
        "token_count": 179
    },
    "004061e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004061e0(void)\n\n{\n    if (*0x441f4c != NULL) {\n        (**0x441f4c)();\n    }\n    fcn.00406330(0x43a0d8, 0x43a0e8);\n    fcn.00406330(0x43a000, 0x43a0d4);\n    return;\n}\n",
        "token_count": 88
    },
    "00406210": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00406210(uint param_1)\n\n{\n    fcn.00406250(param_1, 0, 0);\n    return;\n}\n",
        "token_count": 35
    },
    "00406230": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00406230(uint param_1)\n\n{\n    fcn.00406250(param_1, 1, 0);\n    return;\n}\n",
        "token_count": 35
    },
    "00406310": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00406310(void)\n\n{\n    fcn.00408940(0xd);\n    return;\n}\n",
        "token_count": 26
    },
    "00406320": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00406320(void)\n\n{\n    fcn.004089c0(0xd);\n    return;\n}\n",
        "token_count": 27
    },
    "00406330": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00406330(code **param_1, code **param_2)\n\n{\n    if (param_1 < param_2) {\n        do {\n            if (*param_1 != NULL) {\n                (**param_1)();\n            }\n            param_1 = param_1 + 1;\n        } while (param_1 < param_2);\n    }\n    return;\n}\n",
        "token_count": 84
    },
    "00406350": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00406350(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint *puVar3;\n    uint auStack32 [4];\n    uint uStack16;\n    uchar auStack12 [4];\n    uint uStack8;\n    uint uStack4;\n    \n    puVar2 = 0x434a48;\n    puVar3 = auStack32;\n    for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = *puVar2;\n        puVar2 = puVar2 + 1;\n        puVar3 = puVar3 + 1;\n    }\n    uStack8 = param_1;\n    uStack4 = param_2;\n    (*_sym.imp.KERNEL32.dll_RaiseException)(auStack32[0], auStack32[1], uStack16, auStack12);\n    return;\n}\n",
        "token_count": 213
    },
    "00406690": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00406690(uchar *param_1, uint param_2, uint param_3)\n\n{\n    uint uVar1;\n    uchar *puStack32;\n    int32_t iStack28;\n    uchar *puStack24;\n    uint uStack20;\n    \n    puStack24 = param_1;\n    puStack32 = param_1;\n    uStack20 = 0x42;\n    iStack28 = 0x7fffffff;\n    uVar1 = fcn.00408ba0(&puStack32, param_2, param_3);\n    iStack28 = iStack28 + -1;\n    if (-1 < iStack28) {\n        *puStack32 = 0;\n        return uVar1;\n    }\n    fcn.0040b1a0(0, &puStack32);\n    return uVar1;\n}\n",
        "token_count": 189
    },
    "00406860": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00406860(uint param_1)\n\n{\n    fcn.004067c0(param_1);\n    return;\n}\n",
        "token_count": 30
    },
    "00406e60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00406e60(uint param_1, uint param_2, uint param_3)\n\n{\n    fcn.00406bd0(param_1, param_2, param_3, 1);\n    return;\n}\n",
        "token_count": 52
    },
    "004070f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.004070f0(uint param_1)\n\n{\n    // switch table (5 cases) at 0x407128\n    switch(param_1) {\n    case 0x3a4:\n        return 0x411;\n    default:\n        return 0;\n    case 0x3a8:\n        return 0x804;\n    case 0x3b5:\n        return 0x412;\n    case 0x3b6:\n        return 0x404;\n    }\n}\n",
        "token_count": 112
    },
    "00407180": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00407180(void)\n\n{\n    fcn.00406e80(0xfffffffd);\n    return;\n}\n",
        "token_count": 28
    },
    "00407190": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00407190(uint32_t param_1)\n\n{\n    uint32_t *puVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    \n    puVar1 = fcn.00407220();\n    iVar3 = 0;\n    *puVar1 = param_1;\n    puVar1 = 0x43adc8;\n    do {\n        if (param_1 == *puVar1) {\n            puVar2 = fcn.00407210();\n            *puVar2 = *(iVar3 * 8 + 0x43adcc);\n            return;\n        }\n        puVar1 = puVar1 + 2;\n        iVar3 = iVar3 + 1;\n    } while (puVar1 < 0x43af30);\n    if ((0x12 < param_1) && (param_1 < 0x25)) {\n        puVar2 = fcn.00407210();\n        *puVar2 = 0xd;\n        return;\n    }\n    if ((0xbb < param_1) && (param_1 < 0xcb)) {\n        puVar2 = fcn.00407210();\n        *puVar2 = 8;\n        return;\n    }\n    puVar2 = fcn.00407210();\n    *puVar2 = 0x16;\n    return;\n}\n",
        "token_count": 295
    },
    "00407210": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00407210(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004085c0();\n    return iVar1 + 8;\n}\n",
        "token_count": 42
    },
    "00407220": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00407220(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004085c0();\n    return iVar1 + 0xc;\n}\n",
        "token_count": 43
    },
    "004072e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004072e0(uint param_1)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    int32_t iVar3;\n    uchar auStack8 [4];\n    uchar auStack4 [4];\n    \n    fcn.00408940(9);\n    puVar2 = fcn.0040a700(param_1, auStack4, auStack8);\n    if (puVar2 != NULL) {\n        uVar1 = *puVar2;\n        fcn.004089c0(9);\n        return uVar1 << 4;\n    }\n    fcn.004089c0(9);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapSize)(*0x440e14, 0, param_1);\n    return iVar3;\n}\n",
        "token_count": 180
    },
    "00407350": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid __cdecl fcn.00407350(uint arg_8h, uint arg_ch, int32_t arg_10h, code *arg_14h)\n\n{\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint *in_FS_OFFSET;\n    uint var_20h;\n    int32_t var_1ch;\n    uint var_10h;\n    code *pcStack16;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x434a68;\n    pcStack16 = fcn.0040a148;\n    var_10h = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_10h;\n    var_4h = 0;\n    for (var_1ch = 0; var_1ch < arg_10h; var_1ch = var_1ch + 1) {\n        (*arg_14h)();\n    }\n    var_4h = 0xffffffff;\n    fcn.004073c8(unaff_EDI, unaff_ESI, unaff_EBX, 1, var_1ch);\n    *in_FS_OFFSET = var_10h;\n    return;\n}\n",
        "token_count": 297
    },
    "004073f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid __cdecl fcn.004073f0(uint arg_8h, uint arg_ch, int32_t arg_10h, code *arg_14h)\n\n{\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint *in_FS_OFFSET;\n    uint var_1ch;\n    uint var_10h;\n    code *pcStack16;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x434a78;\n    pcStack16 = fcn.0040a148;\n    var_10h = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_10h;\n    var_4h = 0;\n    while( true ) {\n        arg_10h = arg_10h + -1;\n        if (arg_10h < 0) break;\n        (*arg_14h)();\n    }\n    var_4h = 0xffffffff;\n    fcn.00407469(unaff_EDI, unaff_ESI, unaff_EBX, 1);\n    *in_FS_OFFSET = var_10h;\n    return;\n}\n",
        "token_count": 265
    },
    "00407510": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00407510(uint param_1)\n\n{\n    fcn.00407520(param_1, 1);\n    return;\n}\n",
        "token_count": 32
    },
    "00407ac0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00407ac0(int32_t *param_1, uint param_2, uint param_3, uint param_4, int32_t *param_5, int32_t param_6, \n                 uint param_7, uint param_8)\n\n{\n    uint uVar1;\n    \n    if (*param_5 != 0x19930520) {\n        fcn.004086d0();\n    }\n    if ((*(param_1 + 1) & 0x66) == 0) {\n        if (param_5[3] != 0) {\n            if (((*param_1 == -0x1f928c9d) && (0x19930520 < param_1[5])) && (*(param_1[7] + 8) != NULL)) {\n                uVar1 = (**(param_1[7] + 8))(param_1, param_2, param_3, param_4, param_5, param_6, param_7, param_8);\n                return uVar1;\n            }\n            fcn.00407b90(param_1, param_2, param_3, param_4, param_5, param_8, param_6, param_7);\n        }\n    }\n    else if ((param_5[1] != 0) && (param_6 == 0)) {\n        fcn.00407f30(param_2, param_4, param_5, 0xffffffff);\n        return 1;\n    }\n    return 1;\n}\n",
        "token_count": 339
    },
    "00407e50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00407e50(uint param_1, uint param_2, uint param_3, uint param_4, uint param_5, int32_t param_6, uint param_7, \n                 uint param_8, uint param_9)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    uint32_t in_stack_fffffff8;\n    uint32_t in_stack_fffffffc;\n    \n    iVar1 = fcn.004085c0();\n    if ((*(iVar1 + 0x68) != 0) &&\n       (iVar1 = fcn.004053e0(param_1, param_2, param_3, param_4, param_5, param_7, param_8, unaff_EDI, unaff_ESI, \n                             unaff_EBP, unaff_EBX, in_stack_fffffff8, in_stack_fffffffc, unaff_retaddr, param_1, param_2\n                             , param_3, param_4, param_5, param_6, param_7, param_8, param_9),  iVar1 != 0)) {\n        return;\n    }\n    piVar2 = fcn.00405540(param_5, param_7, param_6, &stack0xfffffff8, &stack0xfffffffc);\n    if (in_stack_fffffff8 < in_stack_fffffffc) {\n        do {\n            if ((*piVar2 <= param_6) && (param_6 <= piVar2[1])) {\n                iVar3 = piVar2[4] + piVar2[3] * 0x10;\n                iVar1 = *(iVar3 + -0xc);\n                if ((iVar1 == 0) || (*(iVar1 + 8) == '\\0')) {\n                    fcn.00408010(param_1, param_2, param_3, param_4, param_5, iVar3 + -0x10, 0, piVar2, param_7, param_8\n                                );\n                }\n            }\n            in_stack_fffffff8 = in_stack_fffffff8 + 1;\n            piVar2 = piVar2 + 5;\n        } while (in_stack_fffffff8 < in_stack_fffffffc);\n    }\n    return;\n}\n",
        "token_count": 539
    },
    "00408010": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00408010(uint param_1, int32_t param_2, uint param_3, int32_t param_4, uint param_5, uint *param_6, \n                 int32_t param_7, uint param_8, uint param_9, int32_t param_10)\n\n{\n    int32_t iVar1;\n    \n    if (param_7 != 0) {\n        fcn.00408230(param_1, param_2, param_6, param_7);\n    }\n    if (param_10 == 0) {\n        param_10 = param_2;\n    }\n    fcn.004052b0(param_10, param_1);\n    fcn.00407f30(param_2, param_2, param_3, *param_6);\n    *(param_2 + 8) = param_6[1] + 1;\n    iVar1 = fcn.004080a0(param_1, param_2, param_1, param_3, *(param_4 + 0xc), param_7, 0x100);\n    if (iVar1 != 0) {\n        fcn.00405260(iVar1, param_2);\n    }\n    return;\n}\n",
        "token_count": 273
    },
    "004080a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.004080a0(uint param_1, uint param_2, uint param_3, uint param_4, uint param_5, uint param_6, uint param_7)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h;\n    uint var_14h;\n    uint var_18h_2;\n    uint var_1ch_2;\n    uint var_18h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_10h_2;\n    code *pcStack16;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x434bc8;\n    pcStack16 = fcn.0040a148;\n    var_10h_2 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_10h_2;\n    fcn.004085c0();\n    fcn.004085c0();\n    iVar1 = fcn.004085c0();\n    *(iVar1 + 0x6c) = var_8h;\n    iVar1 = fcn.004085c0();\n    *(iVar1 + 0x70) = var_10h;\n    var_4h = 1;\n    uVar2 = fcn.00405350(var_ch, var_14h, var_18h_2, var_1ch_2, var_18h);\n    var_4h = 0xffffffff;\n    fcn.00408198();\n    *in_FS_OFFSET = var_10h_2;\n    return uVar2;\n}\n",
        "token_count": 403
    },
    "004084c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004084c0(int32_t param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = param_1 + *param_2;\n    iVar1 = param_2[1];\n    if (-1 < iVar1) {\n        iVar2 = iVar2 + *(*(param_1 + iVar1) + param_2[2]) + iVar1;\n    }\n    return iVar2;\n}\n",
        "token_count": 109
    },
    "004085c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * fcn.004085c0(void)\n\n{\n    uint uVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint uVar4;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    puVar2 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*0x43aff0);\n    if (puVar2 == NULL) {\n        puVar2 = fcn.00406480(1, 0x74);\n        if (puVar2 != NULL) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_TlsSetValue)(*0x43aff0, puVar2);\n            if (iVar3 != 0) {\n                fcn.004085a0(puVar2);\n                uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n                *puVar2 = uVar4;\n                puVar2[1] = 0xffffffff;\n                (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n                return puVar2;\n            }\n        }\n        fcn.00405dc0(0x10);\n    }\n    (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n    return puVar2;\n}\n",
        "token_count": 270
    },
    "00408940": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00408940(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    \n    if (*(arg_8h * 4 + 0x43aff8) == 0) {\n        iVar1 = fcn.00405e40(0x18);\n        if (iVar1 == 0) {\n            fcn.00405dc0(0x11);\n        }\n        fcn.00408940(0x11);\n        if (*(arg_8h * 4 + 0x43aff8) == 0) {\n            (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)();\n            *(arg_8h * 4 + 0x43aff8) = iVar1;\n        }\n        else {\n            fcn.00405f10(iVar1);\n        }\n        fcn.004089c0(0x11);\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(*(arg_8h * 4 + 0x43aff8));\n    return;\n}\n",
        "token_count": 226
    },
    "004089e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004089e0(uint32_t arg_8h)\n\n{\n    if ((0x43b0bf < arg_8h) && (arg_8h < 0x43b321)) {\n        fcn.00408940((arg_8h - 0x43b0c0 >> 5) + 0x1c);\n        return;\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(arg_8h + 0x20);\n    return;\n}\n",
        "token_count": 113
    },
    "00408a20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00408a20(int32_t arg_8h, int32_t lpCriticalSection)\n\n{\n    if (arg_8h < 0x14) {\n        fcn.00408940(arg_8h + 0x1c);\n        return;\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(lpCriticalSection + 0x20);\n    return;\n}\n",
        "token_count": 87
    },
    "00408a50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00408a50(uint32_t arg_8h)\n\n{\n    if ((0x43b0bf < arg_8h) && (arg_8h < 0x43b321)) {\n        fcn.004089c0((arg_8h - 0x43b0c0 >> 5) + 0x1c);\n        return;\n    }\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(arg_8h + 0x20);\n    return;\n}\n",
        "token_count": 115
    },
    "00408a90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00408a90(int32_t arg_8h, int32_t lpCriticalSection)\n\n{\n    if (arg_8h < 0x14) {\n        fcn.004089c0(arg_8h + 0x1c);\n        return;\n    }\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(lpCriticalSection + 0x20);\n    return;\n}\n",
        "token_count": 89
    },
    "00408ac0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00408ac0(uint *param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = fcn.0040c0b0(param_1[4]);\n    if (iVar2 != 0) {\n        if (param_1 == 0x43b0e0) {\n            iVar2 = 0;\n        }\n        else {\n            if (param_1 != 0x43b100) {\n                return 0;\n            }\n            iVar2 = 1;\n        }\n        *0x4406e8 = *0x4406e8 + 1;\n        if ((param_1[3] & 0x10c) == 0) {\n            if (*(iVar2 * 4 + 0x4406e0) == 0) {\n                iVar3 = fcn.00405e40(0x1000);\n                *(iVar2 * 4 + 0x4406e0) = iVar3;\n                if (iVar3 == 0) {\n                    return 0;\n                }\n            }\n            uVar1 = *(iVar2 * 4 + 0x4406e0);\n            param_1[6] = 0x1000;\n            param_1[2] = uVar1;\n            *param_1 = uVar1;\n            param_1[1] = 0x1000;\n            param_1[3] = param_1[3] | 0x1102;\n            return 1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 351
    },
    "00408b60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00408b60(int32_t param_1, uint *param_2)\n\n{\n    if ((param_1 != 0) && ((param_2[3] & 0x1000) != 0)) {\n        fcn.0040c160(param_2);\n        param_2[6] = 0;\n        param_2[3] = param_2[3] & 0xffffeeff;\n        *param_2 = 0;\n        param_2[2] = 0;\n    }\n    return;\n}\n",
        "token_count": 123
    },
    "00409600": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00409600(int32_t *param_1)\n\n{\n    uint *puVar1;\n    \n    puVar1 = *param_1;\n    *param_1 = puVar1 + 1;\n    return *puVar1;\n}\n",
        "token_count": 56
    },
    "00409620": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.00409620(int32_t *param_1)\n\n{\n    ulong *puVar1;\n    \n    puVar1 = *param_1;\n    *param_1 = puVar1 + 1;\n    return *puVar1;\n}\n",
        "token_count": 56
    },
    "00409640": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t fcn.00409640(uint16_t **param_1)\n\n{\n    uint16_t *puVar1;\n    uint16_t *puVar2;\n    \n    puVar1 = *param_1;\n    puVar2 = puVar1 + 2;\n    *param_1 = puVar2;\n    return puVar2 & 0xffff0000 | *puVar1;\n}\n",
        "token_count": 88
    },
    "00409990": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00409990(uint param_1)\n\n{\n    fcn.004099b0(param_1, 0, 4);\n    return;\n}\n",
        "token_count": 36
    },
    "0040a440": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0040a440(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    if (*0x440804 != NULL) {\n        iVar1 = (**0x440804)(param_1);\n        if (iVar1 != 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 73
    },
    "0040a760": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.0040a760(int32_t param_1, int32_t param_2, uint8_t *param_3)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    iVar2 = param_2 - *(param_1 + 0x10) >> 0xc;\n    piVar1 = param_1 + 0x18 + iVar2 * 8;\n    *piVar1 = *(param_1 + 0x18 + iVar2 * 8) + *param_3;\n    *param_3 = 0;\n    piVar1[1] = 0xf1;\n    if ((*piVar1 == 0xf0) && (*0x440808 = *0x440808 + 1,  *0x440808 == 0x20)) {\n        fcn.0040a630(0x10);\n    }\n    return;\n}\n",
        "token_count": 202
    },
    "0040adb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint8_t * __cdecl fcn.0040adb0(uint8_t *arg_8h, uint8_t *arg_ch)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    uint8_t *puVar3;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    \n    uStack12 = 0;\n    uStack16 = 0;\n    uStack20 = 0;\n    uStack24 = 0;\n    uStack28 = 0;\n    uStack32 = 0;\n    uStack36 = 0;\n    uStack40 = 0;\n    for (; uVar1 = *arg_ch,  uVar1 != 0; arg_ch = arg_ch + 1) {\n        puVar2 = &uStack40 + (uVar1 >> 3);\n        *puVar2 = *puVar2 | '\\x01' << (uVar1 & 7);\n    }\n    do {\n        puVar3 = arg_8h;\n        puVar2 = *puVar3;\n        if (*puVar3 == 0) {\n            return puVar2;\n        }\n        arg_8h = puVar3 + 1;\n    } while ((*(&uStack40 + (puVar2 >> 3)) >> (puVar2 & 7) & 1) == 0);\n    return puVar3;\n}\n",
        "token_count": 339
    },
    "0040b070": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040b070(uint8_t *arg_8h, uint8_t *arg_ch)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    int32_t iVar3;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    \n    uStack12 = 0;\n    uStack16 = 0;\n    uStack20 = 0;\n    uStack24 = 0;\n    uStack28 = 0;\n    uStack32 = 0;\n    uStack36 = 0;\n    uStack40 = 0;\n    for (; uVar1 = *arg_ch,  uVar1 != 0; arg_ch = arg_ch + 1) {\n        puVar2 = &uStack40 + (uVar1 >> 3);\n        *puVar2 = *puVar2 | '\\x01' << (uVar1 & 7);\n    }\n    iVar3 = -1;\n    do {\n        iVar3 = iVar3 + 1;\n        uVar1 = *arg_8h;\n        if (uVar1 == 0) {\n            return iVar3;\n        }\n        arg_8h = arg_8h + 1;\n    } while ((*(&uStack40 + (uVar1 >> 3)) >> (uVar1 & 7) & 1) != 0);\n    return iVar3;\n}\n",
        "token_count": 343
    },
    "0040b0b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040b0b0(uint8_t *arg_8h, uint8_t *arg_ch)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    int32_t iVar3;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    \n    uStack12 = 0;\n    uStack16 = 0;\n    uStack20 = 0;\n    uStack24 = 0;\n    uStack28 = 0;\n    uStack32 = 0;\n    uStack36 = 0;\n    uStack40 = 0;\n    for (; uVar1 = *arg_ch,  uVar1 != 0; arg_ch = arg_ch + 1) {\n        puVar2 = &uStack40 + (uVar1 >> 3);\n        *puVar2 = *puVar2 | '\\x01' << (uVar1 & 7);\n    }\n    iVar3 = -1;\n    do {\n        iVar3 = iVar3 + 1;\n        uVar1 = *arg_8h;\n        if (uVar1 == 0) {\n            return iVar3;\n        }\n        arg_8h = arg_8h + 1;\n    } while ((*(&uStack40 + (uVar1 >> 3)) >> (uVar1 & 7) & 1) == 0);\n    return iVar3;\n}\n",
        "token_count": 345
    },
    "0040b670": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040b670(int32_t param_1)\n\n{\n    code *pcVar1;\n    bool bVar2;\n    uint unaff_retaddr;\n    \n    if (*0x440828 == 0) {\n        if ((0x60 < param_1) && (param_1 < 0x7b)) {\n            return param_1 + -0x20;\n        }\n    }\n    else {\n        (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(0x440e10);\n        pcVar1 = _sym.imp.KERNEL32.dll_InterlockedDecrement;\n        bVar2 = *0x440e0c != 0;\n        if (bVar2) {\n            (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(0x440e10);\n            fcn.00408940(0x13);\n        }\n        param_1 = fcn.0040b700(unaff_retaddr);\n        if (bVar2) {\n            fcn.004089c0(0x13);\n            return param_1;\n        }\n        (*pcVar1)(0x440e10);\n    }\n    return param_1;\n}\n",
        "token_count": 255
    },
    "0040b800": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040b800(void)\n\n{\n    if (*0x4408f8 == 0) {\n        fcn.00408940(0xb);\n        if (*0x4408f8 == 0) {\n            fcn.0040b840();\n            *0x4408f8 = *0x4408f8 + 1;\n        }\n        fcn.004089c0(0xb);\n    }\n    return;\n}\n",
        "token_count": 100
    },
    "0040bb20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0040bb20(uint param_1)\n\n{\n    uint uVar1;\n    \n    fcn.00408940(0xb);\n    uVar1 = fcn.0040bb50(param_1);\n    fcn.004089c0(0xb);\n    return uVar1;\n}\n",
        "token_count": 68
    },
    "0040c090": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040c090(void)\n\n{\n    fcn.0040a260(10);\n    fcn.0040de50(0x16);\n    fcn.00406230(3);\n    return;\n}\n",
        "token_count": 50
    },
    "0040c2a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0040c2a0(uint param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    bool bVar3;\n    uint unaff_retaddr;\n    \n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(0x440e10);\n    pcVar1 = _sym.imp.KERNEL32.dll_InterlockedDecrement;\n    bVar3 = *0x440e0c != 0;\n    if (bVar3) {\n        (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(0x440e10);\n        fcn.00408940(0x13);\n    }\n    uVar2 = fcn.0040c310(unaff_retaddr, param_1);\n    if (!bVar3) {\n        (*pcVar1)(0x440e10);\n        return uVar2;\n    }\n    fcn.004089c0(0x13);\n    return uVar2;\n}\n",
        "token_count": 207
    },
    "0040ca40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040ca40(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    *0x4406e8 = *0x4406e8 + 1;\n    iVar1 = fcn.00405e40(0x1000);\n    param_1[2] = iVar1;\n    if (iVar1 != 0) {\n        param_1[3] = param_1[3] | 8;\n        param_1[6] = 0x1000;\n        *param_1 = param_1[2];\n        param_1[1] = 0;\n        return;\n    }\n    param_1[6] = 2;\n    param_1[3] = param_1[3] | 4;\n    param_1[2] = param_1 + 5;\n    *param_1 = param_1 + 5;\n    param_1[1] = 0;\n    return;\n}\n",
        "token_count": 216
    },
    "0040caa0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0040caa0(uint param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    bool bVar3;\n    uint unaff_retaddr;\n    \n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(0x440e10);\n    pcVar1 = _sym.imp.KERNEL32.dll_InterlockedDecrement;\n    bVar3 = *0x440e0c != 0;\n    if (bVar3) {\n        (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(0x440e10);\n        fcn.00408940(0x13);\n    }\n    uVar2 = fcn.0040cb20(unaff_retaddr, param_1, param_2);\n    if (!bVar3) {\n        (*pcVar1)(0x440e10);\n        return uVar2;\n    }\n    fcn.004089c0(0x13);\n    return uVar2;\n}\n",
        "token_count": 214
    },
    "0040e060": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t fcn.0040e060(int32_t param_1, uint32_t param_2)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    uVar2 = param_2;\n    if (*(param_2 + 4) != param_1) {\n        uVar3 = param_2;\n        do {\n            uVar2 = uVar3 + 0xc;\n            if (param_2 + *0x43b3c4 * 0xc <= uVar2) break;\n            piVar1 = uVar3 + 0x10;\n            uVar3 = uVar2;\n        } while (*piVar1 != param_1);\n    }\n    if ((param_2 + *0x43b3c4 * 0xc <= uVar2) || (*(uVar2 + 4) != param_1)) {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 221
    },
    "0040e150": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0040e150(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if ((*(param_1 + 0xc) & 0x40) != 0) {\n        *(param_1 + 0xc) = 0;\n        return 0xffffffff;\n    }\n    fcn.004089e0(param_1);\n    uVar1 = fcn.0040e190(param_1);\n    fcn.00408a50(param_1);\n    return uVar1;\n}\n",
        "token_count": 116
    },
    "0040e190": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0040e190(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    uVar2 = 0xffffffff;\n    if ((*(param_1 + 0xc) & 0x83) != 0) {\n        uVar2 = fcn.0040c160(param_1);\n        fcn.0040e970(param_1);\n        iVar1 = fcn.0040e870(*(param_1 + 0x10));\n        if (iVar1 < 0) {\n            *(param_1 + 0xc) = 0;\n            return 0xffffffff;\n        }\n        if (*(param_1 + 0x1c) != 0) {\n            fcn.00405f10(*(param_1 + 0x1c));\n            *(param_1 + 0x1c) = 0;\n        }\n    }\n    *(param_1 + 0xc) = 0;\n    return uVar2;\n}\n",
        "token_count": 222
    },
    "0040e390": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040e390(uint param_1, uint param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    \n    if (param_3 == 0) {\n        return param_3;\n    }\n    iVar1 = fcn.0040e9b0(*0x440620, 1, param_1, param_3, param_2, param_3, *0x44061c);\n    if (iVar1 == 0) {\n        return 0x7fffffff;\n    }\n    return iVar1 + -2;\n}\n",
        "token_count": 130
    },
    "0040e3d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040e3d0(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_WideCharToMultiByte;\n    iVar2 = **0x4404fc;\n    piVar4 = *0x4404fc;\n    if (iVar2 == 0) {\n        return 0;\n    }\n    while (((iVar2 = (*pcVar1)(1, 0, iVar2, 0xffffffff, 0, 0, 0, 0),  iVar2 != 0 &&\n            (iVar3 = fcn.00405e40(iVar2),  iVar3 != 0)) &&\n           (iVar2 = (*pcVar1)(1, 0, *piVar4, 0xffffffff, iVar3, iVar2, 0, 0),  iVar2 != 0))) {\n        fcn.0040ec80(iVar3, 0);\n        iVar2 = piVar4[1];\n        piVar4 = piVar4 + 1;\n        if (iVar2 == 0) {\n            return iVar2;\n        }\n    }\n    return -1;\n}\n",
        "token_count": 278
    },
    "0040e970": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040e970(uint *param_1)\n\n{\n    if (((param_1[3] & 0x83) != 0) && ((param_1[3] & 8) != 0)) {\n        fcn.00405f10(param_1[2]);\n        param_1[3] = param_1[3] & 0xfffffbf7;\n        *param_1 = 0;\n        param_1[2] = 0;\n        param_1[1] = 0;\n    }\n    return;\n}\n",
        "token_count": 125
    },
    "0040ef10": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * fcn.0040ef10(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    \n    iVar5 = 0;\n    if (param_1 != NULL) {\n        iVar1 = *param_1;\n        piVar2 = param_1;\n        while (iVar1 != 0) {\n            piVar2 = piVar2 + 1;\n            iVar5 = iVar5 + 1;\n            iVar1 = *piVar2;\n        }\n        puVar3 = fcn.00405e40(iVar5 * 4 + 4);\n        if (puVar3 == NULL) {\n            fcn.00405dc0(9);\n        }\n        iVar5 = *param_1;\n        puVar6 = puVar3;\n        while (iVar5 != 0) {\n            param_1 = param_1 + 1;\n            uVar4 = fcn.00406190(iVar5);\n            *puVar6 = uVar4;\n            puVar6 = puVar6 + 1;\n            iVar5 = *param_1;\n        }\n        *puVar6 = 0;\n        return puVar3;\n    }\n    return NULL;\n}\n",
        "token_count": 296
    },
    "0040fe90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.0040fe90(int32_t *param_1, uint param_2, int32_t param_3)\n\n{\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x42f786;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    if (param_3 != 0) {\n        *param_1 = 0x435680;\n        param_1[0xb] = 0;\n        param_1[2] = vtable.std::basic_ios_char__struct_std::char_traits_char__.0;\n        uStack4 = 0;\n    }\n    *(*(*param_1 + 4) + param_1) = vtable.std::basic_istream_char__struct_std::char_traits_char__.0;\n    fcn.00413180();\n    *in_FS_OFFSET = uStack12;\n    return param_1;\n}\n",
        "token_count": 233
    },
    "0040ffc0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.0040ffc0(int32_t *param_1, uint param_2, int32_t param_3)\n\n{\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x42f7a6;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    if (param_3 != 0) {\n        *param_1 = 0x435690;\n        param_1[10] = 0;\n        param_1[1] = vtable.std::basic_ios_char__struct_std::char_traits_char__.0;\n        uStack4 = 0;\n    }\n    *(*(*param_1 + 4) + param_1) = vtable.std::basic_ostream_char__struct_std::char_traits_char__.0;\n    fcn.00413180();\n    *in_FS_OFFSET = uStack12;\n    return param_1;\n}\n",
        "token_count": 234
    },
    "00411660": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.00411660(int32_t *param_1, uint param_2, int32_t param_3)\n\n{\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x42f8d6;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    if (param_3 != 0) {\n        *param_1 = 0x435720;\n        param_1[0xb] = 0;\n        param_1[2] = vtable.std::basic_ios_unsigned_short_int__struct_std::char_traits_unsigned_short_int__.0;\n        uStack4 = 0;\n    }\n    *(*(*param_1 + 4) + param_1) =\n         vtable.std::basic_istream_unsigned_short_int__struct_std::char_traits_unsigned_short_int__.0;\n    fcn.00413180();\n    *in_FS_OFFSET = uStack12;\n    return param_1;\n}\n",
        "token_count": 243
    },
    "00411790": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.00411790(int32_t *param_1, uint param_2, int32_t param_3)\n\n{\n    uint *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x42f8f6;\n    uStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack12;\n    if (param_3 != 0) {\n        *param_1 = 0x435730;\n        param_1[10] = 0;\n        param_1[1] = vtable.std::basic_ios_unsigned_short_int__struct_std::char_traits_unsigned_short_int__.0;\n        uStack4 = 0;\n    }\n    *(*(*param_1 + 4) + param_1) =\n         vtable.std::basic_ostream_unsigned_short_int__struct_std::char_traits_unsigned_short_int__.0;\n    fcn.00413180();\n    *in_FS_OFFSET = uStack12;\n    return param_1;\n}\n",
        "token_count": 242
    },
    "00411c50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00411c50(int32_t param_1, uint param_2)\n\n{\n    ushort uVar1;\n    char unaff_retaddr;\n    \n    *(param_1 + 0x28) = param_2;\n    *(param_1 + 0x2c) = 0;\n    uVar1 = fcn.004139c0(0x20);\n    *(param_1 + 0x30) = uVar1;\n    fcn.004131d0();\n    if (*(param_1 + 0x28) == 0) {\n        fcn.00412b90(*(param_1 + 4) & 0xffffff00 | *(param_1 + 4) & 0xff | 4 | 4, 0);\n    }\n    if (unaff_retaddr != '\\0') {\n        fcn.00413180();\n    }\n    return;\n}\n",
        "token_count": 202
    },
    "00412550": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00412550(code **param_1)\n\n{\n    code cVar1;\n    code *pcVar2;\n    \n    *param_1 = vtable.std::logic_error.0;\n    pcVar2 = param_1[4];\n    if (pcVar2 != NULL) {\n        cVar1 = pcVar2[-1];\n        if ((cVar1 == 0x0) || (cVar1 == 0xff)) {\n            fcn.004166cf(pcVar2 + -1);\n        }\n        else {\n            pcVar2[-1] = cVar1 + -1;\n        }\n    }\n    param_1[4] = NULL;\n    param_1[5] = NULL;\n    param_1[6] = NULL;\n    fcn.004144e0();\n    return;\n}\n",
        "token_count": 182
    },
    "00412eb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00412eb0(code **param_1)\n\n{\n    code cVar1;\n    code *pcVar2;\n    \n    *param_1 = vtable.std::runtime_error.0;\n    pcVar2 = param_1[4];\n    if (pcVar2 != NULL) {\n        cVar1 = pcVar2[-1];\n        if ((cVar1 == 0x0) || (cVar1 == 0xff)) {\n            fcn.004166cf(pcVar2 + -1);\n        }\n        else {\n            pcVar2[-1] = cVar1 + -1;\n        }\n    }\n    param_1[4] = NULL;\n    param_1[5] = NULL;\n    param_1[6] = NULL;\n    fcn.004144e0();\n    return;\n}\n",
        "token_count": 183
    },
    "00413150": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00413150(int32_t param_1, uint param_2)\n\n{\n    uint *puVar1;\n    \n    for (puVar1 = *(param_1 + 0x1c); puVar1 != NULL; puVar1 = *puVar1) {\n        (*puVar1[2])(param_2, param_1, puVar1[1]);\n    }\n    return;\n}\n",
        "token_count": 94
    },
    "00413210": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00413210(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint *puVar2;\n    \n    fcn.00413150(0);\n    puVar2 = *(param_1 + 0x18);\n    while (puVar2 != NULL) {\n        puVar1 = *puVar2;\n        fcn.004166cf(puVar2);\n        puVar2 = puVar1;\n    }\n    *(param_1 + 0x18) = 0;\n    puVar2 = *(param_1 + 0x1c);\n    while (puVar2 != NULL) {\n        puVar1 = *puVar2;\n        fcn.004166cf(puVar2);\n        puVar2 = puVar1;\n    }\n    *(param_1 + 0x1c) = 0;\n    return;\n}\n",
        "token_count": 195
    },
    "004137c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.004137c0(uint param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    bool bVar3;\n    uint unaff_retaddr;\n    \n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(0x440e10);\n    pcVar1 = _sym.imp.KERNEL32.dll_InterlockedDecrement;\n    bVar3 = *0x440e0c != 0;\n    if (bVar3) {\n        (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(0x440e10);\n        fcn.00408940(0x13);\n    }\n    uVar2 = fcn.00413840(unaff_retaddr, param_1, param_2, param_3, param_4);\n    if (!bVar3) {\n        (*pcVar1)(0x440e10);\n        return uVar2;\n    }\n    fcn.004089c0(0x13);\n    return uVar2;\n}\n",
        "token_count": 231
    },
    "00413c90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t fcn.00413c90(uint8_t **param_1)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    uint32_t uVar3;\n    \n    fcn.004089e0(param_1);\n    puVar2 = param_1[1];\n    param_1[1] = puVar2 + -1;\n    if (-1 < puVar2 + -1) {\n        uVar1 = **param_1;\n        *param_1 = *param_1 + 1;\n        fcn.00408a50(param_1);\n        return uVar1;\n    }\n    uVar3 = fcn.00414510(param_1);\n    fcn.00408a50(param_1);\n    return uVar3;\n}\n",
        "token_count": 175
    },
    "00413ce0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00413ce0(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    \n    fcn.004089e0(param_2);\n    uVar1 = fcn.00413d10(param_1, param_2);\n    fcn.00408a50(param_2);\n    return uVar1;\n}\n",
        "token_count": 78
    },
    "00413dd0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nuint fcn.00413dd0(uint param_1, uint param_2, uint param_3)\n\n{\n    uint uVar1;\n    \n    fcn.004089e0(param_1);\n    uVar1 = fcn.00413e10(param_1, param_2, param_3);\n    fcn.00408a50(param_1);\n    return uVar1;\n}\n",
        "token_count": 87
    },
    "004142a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t fcn.004142a0(uint param_1)\n\n{\n    uint32_t uVar1;\n    uint16_t extraout_var;\n    \n    fcn.004089e0(param_1);\n    uVar1 = fcn.004142d0(param_1);\n    fcn.00408a50(param_1);\n    return uVar1 & 0xffff | extraout_var << 0x10;\n}\n",
        "token_count": 94
    },
    "004144e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004144e0(code **param_1)\n\n{\n    *param_1 = vtable.exception.0;\n    if (param_1[2] != NULL) {\n        fcn.004166cf(param_1[1]);\n    }\n    return;\n}\n",
        "token_count": 62
    },
    "00414600": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.00414600(uint param_1)\n\n{\n    ulong uVar1;\n    \n    fcn.004089e0(param_1);\n    uVar1 = fcn.00414630(param_1);\n    fcn.00408a50(param_1);\n    return uVar1;\n}\n",
        "token_count": 67
    },
    "00414d10": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00414d10(uint param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    bool bVar3;\n    uint unaff_retaddr;\n    \n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(0x440e10);\n    pcVar1 = _sym.imp.KERNEL32.dll_InterlockedDecrement;\n    bVar3 = *0x440e0c != 0;\n    if (bVar3) {\n        (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(0x440e10);\n        fcn.00408940(0x13);\n    }\n    uVar2 = fcn.00414d90(unaff_retaddr, param_1, param_2);\n    if (!bVar3) {\n        (*pcVar1)(0x440e10);\n        return uVar2;\n    }\n    fcn.004089c0(0x13);\n    return uVar2;\n}\n",
        "token_count": 214
    },
    "004156cf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.004156cf(int32_t arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    uint uVar1;\n    uint *in_ECX;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_4h;\n    \n    var_24h = arg_1ch;\n    var_20h = arg_18h;\n    var_1ch = arg_14h;\n    var_18h = arg_10h;\n    var_14h = arg_ch + -1;\n    var_10h = arg_8h + -0x76c;\n    var_4h = arg_20h;\n    uVar1 = fcn.00407510(&var_24h);\n    *in_ECX = uVar1;\n    return;\n}\n",
        "token_count": 237
    },
    "00416054": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00416054(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = *(in_ECX + 8);\n    if (arg_8h < iVar1) {\n        fcn.00415f0a(iVar1 + arg_10h, 0xffffffff);\n        fcn.00406890(*(in_ECX + 4) + (arg_10h + arg_8h) * 4, *(in_ECX + 4) + arg_8h * 4, \n                     (arg_8h * 0x3fffffff + iVar1) * 4);\n        fcn.00406030(*(in_ECX + 4) + arg_8h * 4, 0, arg_10h << 2);\n    }\n    else {\n        fcn.00415f0a(arg_10h + arg_8h, 0xffffffff);\n    }\n    if (arg_10h != 0) {\n        arg_8h = arg_8h << 2;\n        do {\n            *(*(in_ECX + 4) + arg_8h) = arg_ch;\n            arg_8h = arg_8h + 4;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n    }\n    return;\n}\n",
        "token_count": 329
    },
    "004160e9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004160e9(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*(param_1 + 8) - param_2) - param_3;\n    if (iVar1 != 0) {\n        fcn.00405850(*(param_1 + 4) + param_2 * 4, *(param_1 + 4) + (param_3 + param_2) * 4, iVar1 * 4);\n    }\n    *(param_1 + 8) = *(param_1 + 8) - param_3;\n    return;\n}\n",
        "token_count": 154
    },
    "00416120": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00416120(uint *param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint *puVar1;\n    \n    puVar1 = fcn.00416693(param_2 * param_3 + 4);\n    *puVar1 = *param_1;\n    *param_1 = puVar1;\n    return;\n}\n",
        "token_count": 84
    },
    "00416305": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00416305(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    \n    iVar1 = arg_8h;\n    puVar2 = fcn.004162a0(arg_8h, &arg_8h);\n    if (puVar2 == NULL) {\n        if (*(in_ECX + 4) == 0) {\n            fcn.00416199(*(in_ECX + 8), 1);\n        }\n        puVar2 = fcn.0041623d();\n        puVar2[1] = iVar1;\n        *puVar2 = *(*(in_ECX + 4) + arg_8h * 4);\n        *(*(in_ECX + 4) + arg_8h * 4) = puVar2;\n    }\n    return puVar2 + 2;\n}\n",
        "token_count": 204
    },
    "00417060": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.00417060(code **param_1, code *param_2, code *param_3)\n\n{\n    fcn.00417e33();\n    *param_1 = vtable.CDialog.0;\n    fcn.00406030(param_1 + 0xf, 0, 0x20);\n    param_1[0x14] = param_3;\n    param_1[0xf] = param_2;\n    param_1[0x10] = param_2 & 0xffff;\n    return param_1;\n}\n",
        "token_count": 128
    },
    "00417852": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __thiscall fcn.00417852(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBX;\n    int32_t arg_8h;\n    \n    if (param_2 < 1) {\n        iVar3 = *(param_1 + 0x1c);\n        if ((iVar3 != 0) && (*(iVar3 + 0x1c) != 0)) {\n            iVar1 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar3 + 0x1c));\n            if (iVar1 != 0) {\n                fcn.00417f30(iVar3, *(iVar3 + 0x1c), 0x363, 1, 0);\n                fcn.00419abe(*(iVar3 + 0x1c), 0x363, 1, 0, 1, 1);\n            }\n        }\n        fcn.0042d07c();\n        arg_8h = 0x404461;\n        iVar1 = fcn.0042d88a(0x404461);\n        for (iVar1 = *(iVar1 + 8); iVar1 != 0; iVar1 = *(iVar1 + 0x54)) {\n            if ((*(iVar1 + 0x1c) != 0) && (iVar1 != iVar3)) {\n                if (*(iVar1 + 0x88) == 0) {\n                    fcn.0041afbc(0, arg_8h);\n                }\n                iVar2 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar1 + 0x1c));\n                if ((iVar2 != 0) || (-1 < *(iVar1 + 0x88))) {\n                    fcn.00417f30(iVar1, *(iVar1 + 0x1c), 0x363, 1, 0);\n                    arg_8h = *(iVar1 + 0x1c);\n                    fcn.00419abe(arg_8h, 0x363, 1, 0, 1, 1);\n                }\n                iVar2 = *(iVar1 + 0x88);\n                if (0 < iVar2) {\n                    fcn.0041afbc();\n                    arg_8h = iVar2;\n                }\n                *(iVar1 + 0x88) = 0xffffffff;\n            }\n        }\n    }\n    else {\n        fcn.0042d07c();\n        iVar3 = fcn.0042d88a(0x404461);\n        if (*(iVar3 + 0x10) == 0) {\n            fcn.0041d7f4();\n            fcn.0041d7fd(1);\n        }\n    }\n    return unaff_EBX < 0;\n}\n",
        "token_count": 631
    },
    "00417e33": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.00417e33(code **param_1)\n\n{\n    fcn.004166da();\n    *param_1 = vtable.CWnd.0;\n    fcn.00406030(param_1 + 7, 0, 0x20);\n    param_1[0xe] = NULL;\n    param_1[0xd] = NULL;\n    return param_1;\n}\n",
        "token_count": 91
    },
    "00417e79": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.00417e79(code **param_1, code *param_2)\n\n{\n    fcn.004166da();\n    *param_1 = vtable.CWnd.0;\n    fcn.00406030(param_1 + 7, 0, 0x20);\n    param_1[0xe] = NULL;\n    param_1[0xd] = NULL;\n    param_1[7] = param_2;\n    return param_1;\n}\n",
        "token_count": 110
    },
    "00418ef1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpWndClass\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_8h\n\nint32_t __cdecl fcn.00418ef1(uint arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint noname_1;\n    uint *noname_3;\n    uint lpWndClass;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.0042cd29();\n    iVar1 = iVar1 + 0x58;\n    iVar2 = fcn.0042d07c();\n    var_18h = *(iVar2 + 8);\n    if (((arg_ch == 0) && (arg_10h == 0)) && (arg_14h == 0)) {\n        (*_sym.imp.USER32.dll_wsprintfA)(iVar1, \"Afx:%x:%x\", var_18h, arg_8h);\n    }\n    else {\n        (*_sym.imp.USER32.dll_wsprintfA)(iVar1, \"Afx:%x:%x:%x:%x:%x\", var_18h, arg_8h, arg_ch, arg_10h, arg_14h);\n    }\n    noname_3 = &lpWndClass;\n    noname_1 = var_18h;\n    iVar2 = iVar1;\n    iVar3 = (*_sym.imp.USER32.dll_GetClassInfoA)();\n    if (iVar3 == 0) {\n        lpWndClass = arg_8h;\n        var_24h = _sym.imp.USER32.dll_DefWindowProcA;\n        var_1ch = 0;\n        var_20h = 0;\n        var_8h = 0;\n        var_14h = arg_14h;\n        var_10h = arg_ch;\n        var_ch = arg_10h;\n        var_4h = iVar1;\n        iVar2 = fcn.00418e48(&lpWndClass, noname_1, iVar2, noname_3, unaff_EDI, unaff_ESI, unaff_EBX, arg_8h, \n                             _sym.imp.USER32.dll_DefWindowProcA, 0, 0, var_18h, arg_14h, arg_ch, arg_10h, 0);\n        if (iVar2 == 0) {\n            fcn.0041fdd5();\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 754
    },
    "0041a6de": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041a6de(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t lpPoints;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = fcn.0041ae7b();\n    pcVar1 = _sym.imp.USER32.dll_GetParent;\n    if (arg_8h == 0) {\n        if ((var_4h & 0x40000000) == 0) {\n            iVar2 = (*_sym.imp.USER32.dll_GetWindow)(*(in_ECX + 0x1c), 4);\n        }\n        else {\n            iVar2 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x1c));\n        }\n        if ((iVar2 != 0) && (iVar3 = (*_sym.imp.USER32.dll_SendMessageA)(iVar2, 0x36b, 0, 0),  iVar3 != 0)) {\n            iVar2 = iVar3;\n        }\n    }\n    else {\n        iVar2 = *(arg_8h + 0x1c);\n    }\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x1c), &lpRect);\n    if ((var_4h & 0x40000000) == 0) {\n        if ((iVar2 != 0) &&\n           ((uVar4 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar2, 0xfffffff0),  (uVar4 & 0x10000000) == 0 ||\n            ((uVar4 & 0x20000000) != 0)))) {\n            iVar2 = 0;\n        }\n        (*_sym.imp.USER32.dll_SystemParametersInfoA)(0x30, 0, &var_18h, 0);\n        if (iVar2 == 0) {\n            lpPoints = var_18h;\n            var_24h = var_14h;\n            var_20h = var_10h;\n            var_1ch = var_ch;\n        }\n        else {\n            (*_sym.imp.USER32.dll_GetWindowRect)(iVar2, &lpPoints);\n        }\n    }\n    else {\n        uVar5 = (*pcVar1)(*(in_ECX + 0x1c));\n        pcVar1 = _sym.imp.USER32.dll_GetClientRect;\n        (*_sym.imp.USER32.dll_GetClientRect)(uVar5, &var_18h);\n        (*pcVar1)(iVar2, &lpPoints);\n        (*_sym.imp.USER32.dll_MapWindowPoints)(iVar2, uVar5, &lpPoints, 2);\n    }\n    iVar2 = (lpPoints + var_20h) / 2 - (var_30h - lpRect) / 2;\n    iVar3 = (var_24h + var_1ch) / 2 - (var_2ch - var_34h) / 2;\n    if ((var_18h <= iVar2) && (var_18h = iVar2,  var_10h < iVar2 + (var_30h - lpRect))) {\n        var_18h = (lpRect - var_30h) + var_10h;\n    }\n    if ((var_14h <= iVar3) && (var_14h = iVar3,  var_ch < (var_2ch - var_34h) + iVar3)) {\n        var_14h = (var_34h - var_2ch) + var_ch;\n    }\n    fcn.0041af6d(0, var_18h, var_14h, 0xffffffff, 0xffffffff, 0x15);\n    return;\n}\n",
        "token_count": 949
    },
    "0041b108": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041b108(uint *param_1, int32_t param_2)\n\n{\n    uint *puVar1;\n    \n    if (param_2 == 0) {\n        puVar1 = fcn.0041b0bb();\n        puVar1 = *puVar1;\n    }\n    else {\n        puVar1 = fcn.00416693(param_2 + 0xd);\n        *puVar1 = 1;\n        *(puVar1 + param_2 + 0xc) = 0;\n        puVar1[1] = param_2;\n        puVar1[2] = param_2;\n        puVar1 = puVar1 + 3;\n    }\n    *param_1 = puVar1;\n    return;\n}\n",
        "token_count": 172
    },
    "0041b142": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041b142(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    if (*param_1 + -0xc != *0x43a860) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(*param_1 + -0xc);\n        if (iVar1 < 1) {\n            fcn.004166cf(*param_1 + -0xc);\n        }\n        piVar2 = fcn.0041b0bb();\n        *param_1 = *piVar2;\n    }\n    return;\n}\n",
        "token_count": 140
    },
    "0041b20c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041b20c(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    if (*param_1 + -0xc != *0x43a860) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(*param_1 + -0xc);\n        if (iVar1 < 1) {\n            fcn.004166cf(*param_1 + -0xc);\n        }\n    }\n    return;\n}\n",
        "token_count": 107
    },
    "0041b235": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041b235(uint *arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint *puVar1;\n    int32_t *in_ECX;\n    \n    if (arg_14h + arg_ch == 0) {\n        puVar1 = fcn.0041b0bb();\n        *arg_8h = *puVar1;\n    }\n    else {\n        fcn.0041b108(arg_14h + arg_ch);\n        fcn.00405850(*arg_8h, *in_ECX + arg_10h, arg_ch);\n    }\n    return;\n}\n",
        "token_count": 152
    },
    "0041b2d8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041b2d8(int32_t *param_1, int32_t param_2)\n\n{\n    fcn.0041b1e3(param_2);\n    fcn.00405850(*param_1, param_2, param_2);\n    *(*param_1 + -8) = param_2;\n    *(*param_1 + param_2) = 0;\n    return;\n}\n",
        "token_count": 96
    },
    "0041b37b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041b37b(int32_t *param_1, int32_t param_2, uint param_3, int32_t param_4)\n\n{\n    if (param_4 + param_2 != 0) {\n        fcn.0041b108(param_4 + param_2);\n        fcn.00405850(*param_1, param_2, param_2);\n        fcn.00405850(*param_1 + param_2, param_4, param_4);\n    }\n    return;\n}\n",
        "token_count": 122
    },
    "0041be06": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041be06(uint arg_8h, uint *arg_ch)\n\n{\n    uint var_104h;\n    uint var_4h;\n    \n    var_4h = 0;\n    (*_sym.imp.USER32.dll_wsprintfA)\n              (&var_104h, \"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\", *arg_ch, *(arg_ch + 1), *(arg_ch + 6), \n               *(arg_ch + 2), *(arg_ch + 9), *(arg_ch + 10), *(arg_ch + 0xb), *(arg_ch + 3), *(arg_ch + 0xd), \n               *(arg_ch + 0xe), *(arg_ch + 0xf));\n    fcn.0041b27a(&var_104h);\n    return arg_8h;\n}\n",
        "token_count": 206
    },
    "0041c144": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0041c144(void)\n\n{\n    char *pcVar1;\n    char *pcVar2;\n    char cVar3;\n    uint unaff_retaddr;\n    \n    pcVar1 = fcn.0041b4d5(0x104);\n    fcn.00406030(pcVar1, 0, 0x104);\n    (*_sym.imp.KERNEL32.dll_lstrcpynA)(pcVar1, unaff_retaddr, 0x104);\n    cVar3 = *pcVar1;\n    pcVar2 = pcVar1;\n    while ((cVar3 != '\\0' && (((cVar3 != '\\\\' && (cVar3 != '/')) || ((pcVar2[1] != '\\\\' && (pcVar2[1] != '/'))))))) {\n        pcVar2 = fcn.00406870(pcVar2);\n        cVar3 = *pcVar2;\n    }\n    if (*pcVar2 == '\\0') {\n        cVar3 = *pcVar1;\n        while (((cVar3 != '\\0' && (cVar3 != '\\\\')) && (cVar3 != '/'))) {\n            pcVar1 = fcn.00406870(pcVar1);\n            cVar3 = *pcVar1;\n        }\n    }\n    else {\n        for (pcVar1 = pcVar2 + 2; ((cVar3 = *pcVar1,  cVar3 != '\\0' && (cVar3 != '\\\\')) && (cVar3 != '/'));\n            pcVar1 = fcn.00406870(pcVar1)) {\n        }\n        if (*pcVar1 == '\\0') goto code_r0x0041c1c5;\n        do {\n            pcVar1 = fcn.00406870(pcVar1);\ncode_r0x0041c1c5:\n            cVar3 = *pcVar1;\n        } while (((cVar3 != '\\0') && (cVar3 != '\\\\')) && (cVar3 != '/'));\n    }\n    if (*pcVar1 != '\\0') {\n        pcVar1[1] = '\\0';\n    }\n    fcn.0041b524(0xffffffff);\n    return;\n}\n",
        "token_count": 478
    },
    "0041c56e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041c56e(uint arg_8h, int32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if (arg_ch == 0) {\ncode_r0x0041c5e2:\n        uVar2 = 0;\n    }\n    else {\n        if (arg_10h != 0) {\n            do {\n                arg_10h = arg_10h + -1;\n                arg_ch = fcn.004063b0(arg_ch, arg_14h);\n                if (arg_ch == 0) {\n                    fcn.0041b197();\n                    goto code_r0x0041c5e2;\n                }\n                arg_ch = arg_ch + 1;\n            } while (arg_10h != 0);\n        }\n        iVar1 = fcn.004063b0(arg_ch, arg_14h);\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_ch);\n        }\n        else {\n            iVar1 = iVar1 - arg_ch;\n        }\n        uVar2 = fcn.0041b54c(iVar1, arg_ch, iVar1);\n        fcn.00405850(uVar2, iVar1, arg_ch);\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 315
    },
    "0041cc1c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041cc1c(uint arg_8h, uint lpFileTime)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint uVar4;\n    uint lpSystemTime;\n    uint var_12h;\n    ushort var_eh;\n    ushort var_ch;\n    uint var_ah;\n    \n    iVar2 = fcn.004157b3(0);\n    lpSystemTime._0_2_ = *(iVar2 + 0x14) + 0x76c;\n    iVar2 = fcn.004157b3(0);\n    lpSystemTime._2_2_ = *(iVar2 + 0x10) + 1;\n    iVar2 = fcn.004157b3(0);\n    var_12h._0_2_ = *(iVar2 + 0xc);\n    iVar2 = fcn.004157b3(0);\n    var_12h._2_2_ = *(iVar2 + 8);\n    iVar2 = fcn.004157b3(0);\n    var_eh = *(iVar2 + 4);\n    puVar3 = fcn.004157b3(0);\n    var_ah._0_2_ = 0;\n    var_ch = *puVar3;\n    iVar2 = (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, &var_ah + 2);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar2 == 0) {\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n        fcn.0041c5e6(uVar4);\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_LocalFileTimeToFileTime)(&var_ah + 2, lpFileTime);\n    if (iVar2 == 0) {\n        uVar4 = (*pcVar1)(0);\n        fcn.0041c5e6(uVar4);\n    }\n    return;\n}\n",
        "token_count": 458
    },
    "0041cd6e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041cd6e(int32_t param_1)\n\n{\n    int16_t *piVar1;\n    int16_t iVar2;\n    \n    if (*(param_1 + 2) == -1) {\n        piVar1 = param_1 + 0x1a;\n    }\n    else {\n        piVar1 = param_1 + 0x12;\n    }\n    iVar2 = *piVar1;\n    if (iVar2 == -1) {\n        piVar1 = piVar1 + 2;\n    }\n    else {\n        while (piVar1 = piVar1 + 1,  iVar2 != 0) {\n            iVar2 = *piVar1;\n        }\n    }\n    iVar2 = *piVar1;\n    if (iVar2 == -1) {\n        piVar1 = piVar1 + 2;\n    }\n    else {\n        while (piVar1 = piVar1 + 1,  iVar2 != 0) {\n            iVar2 = *piVar1;\n        }\n    }\n    do {\n        iVar2 = *piVar1;\n        piVar1 = piVar1 + 1;\n    } while (iVar2 != 0);\n    return;\n}\n",
        "token_count": 266
    },
    "0041d092": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n\ncode ** __cdecl fcn.0041d092(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    code *arg_10h_00;\n    uint uVar1;\n    code **ppcVar2;\n    code *pcVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0041b0c1();\n    *(unaff_EBP + -4) = 0;\n    fcn.0041b0c1();\n    *(unaff_EBP + -4) = 1;\n    fcn.0041b0c1();\n    arg_10h_00 = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -4) = 2;\n    *extraout_ECX = vtable.CRecentFileList.0;\n    ppcVar2 = fcn.00416693(arg_10h_00 * 4 + 4);\n    *(unaff_EBP + -0x14) = ppcVar2;\n    *(unaff_EBP + -4) = 3;\n    if (ppcVar2 == NULL) {\n        pcVar3 = NULL;\n    }\n    else {\n        *ppcVar2 = arg_10h_00;\n        *(unaff_EBP + 0x14) = ppcVar2 + 1;\n        fcn.00407350(ppcVar2 + 1, 4, arg_10h_00, fcn.0041b0c1);\n        pcVar3 = *(unaff_EBP + 0x14);\n    }\n    uVar1 = *(unaff_EBP + 0xc);\n    extraout_ECX[2] = pcVar3;\n    pcVar3 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 2;\n    extraout_ECX[1] = arg_10h_00;\n    extraout_ECX[5] = pcVar3;\n    fcn.0041b354(uVar1);\n    fcn.0041b354(*(unaff_EBP + 0x10));\n    uVar1 = *(unaff_EBP + -0xc);\n    extraout_ECX[6] = *(unaff_EBP + 0x18);\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 643
    },
    "0042023c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042023c(uint arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uchar *puVar2;\n    uint uVar3;\n    uint lpString2;\n    \n    iVar1 = fcn.0041c547(arg_8h, &lpString2, 0x100);\n    if (iVar1 != 0) {\n        puVar2 = fcn.004063b0(&lpString2, 10);\n        if (puVar2 != NULL) {\n            uVar3 = fcn.00406860(puVar2 + 1);\n            *arg_ch = uVar3;\n            uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(uVar3, *0x4400ac, 0x48);\n            *arg_ch = uVar3;\n            *puVar2 = 0;\n        }\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(arg_ch + 7, &lpString2, 0x20);\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 245
    },
    "00420e95": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00420e95(int32_t *arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    uint lpRect;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lpRect);\n    *arg_8h = var_8h;\n    arg_8h[1] = var_4h;\n    uVar1 = fcn.0041ae7b();\n    fcn.00420e3b(arg_ch);\n    if ((*arg_ch != 0) && ((uVar1 & 0x200000) != 0)) {\n        *arg_8h = *arg_8h + *arg_ch;\n    }\n    if ((arg_ch[1] != 0) && ((uVar1 & 0x100000) != 0)) {\n        arg_8h[1] = arg_8h[1] + arg_ch[1];\n    }\n    if ((*arg_ch < *arg_8h) && (arg_ch[1] < arg_8h[1])) {\n        uVar2 = 1;\n    }\n    else {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 308
    },
    "00420f0a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.00420f0a(int32_t arg_8h, int32_t arg_ch, uint32_t *arg_10h, int32_t *arg_14h, int32_t *arg_18h, int32_t arg_1ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t in_ECX;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = in_ECX;\n    var_4h = in_ECX;\n    fcn.00420e3b(&var_8h);\n    piVar2 = arg_14h;\n    iVar1 = *(in_ECX + 0x50);\n    *arg_14h = *(in_ECX + 0x4c) - arg_8h;\n    arg_14h[1] = iVar1 - arg_ch;\n    piVar3 = fcn.00420d48(&arg_8h);\n    *arg_18h = *piVar3;\n    arg_18h[1] = piVar3[1];\n    uVar5 = 0 < *piVar2;\n    if (uVar5 == 0) {\n        *arg_18h = 0;\n    }\n    else if (arg_1ch != 0) {\n        piVar2[1] = piVar2[1] + var_4h;\n    }\n    uVar4 = 0 < piVar2[1];\n    if (uVar4 == 0) {\n        arg_18h[1] = 0;\n    }\n    else if (arg_1ch != 0) {\n        *piVar2 = *piVar2 + var_8h;\n    }\n    if (((uVar4 != 0) && (uVar5 == 0)) && (0 < *piVar2)) {\n        piVar2[1] = piVar2[1] + var_4h;\n        uVar5 = 1;\n    }\n    iVar1 = *piVar2;\n    if ((0 < iVar1) && (iVar1 <= *arg_18h)) {\n        *arg_18h = iVar1;\n    }\n    iVar1 = piVar2[1];\n    if ((0 < iVar1) && (iVar1 <= arg_18h[1])) {\n        arg_18h[1] = iVar1;\n    }\n    *arg_10h = uVar5;\n    arg_10h[1] = uVar4;\n    return;\n}\n",
        "token_count": 587
    },
    "00421bf6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421bf6(uint arg_8h, uint arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    bool bVar5;\n    uint var_18h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    if (arg_14h == 0) {\n        arg_14h = arg_10h;\n        var_4h = fcn.00421ae8(arg_8h, arg_ch, arg_10h);\n        iVar1 = fcn.00421ae8(arg_8h, arg_ch, 0);\n        if ((iVar1 != var_4h) && (0 < arg_10h)) {\n            do {\n                iVar1 = (arg_14h + iVar4) / 2;\n                iVar2 = fcn.00421ae8(arg_8h, arg_ch, iVar1);\n                if ((iVar2 != var_4h) && (bVar5 = iVar4 == iVar1,  iVar4 = iVar1,  iVar1 = arg_14h,  bVar5)) {\n                    fcn.00421ae8(arg_8h, arg_ch, arg_14h);\n                    break;\n                }\n                arg_14h = iVar1;\n            } while (iVar4 < arg_14h);\n        }\n        fcn.00421a0a(&var_10h, arg_8h, arg_ch);\n        iVar4 = var_10h;\ncode_r0x00421d43:\n        fcn.00421ae8(arg_8h, arg_ch, iVar4);\n    }\n    else {\n        fcn.00421ae8(arg_8h, arg_ch, 0);\n        piVar3 = fcn.00421a0a(&var_10h, arg_8h, arg_ch);\n        iVar1 = *piVar3;\n        var_4h = piVar3[1];\n        fcn.00421ae8(arg_8h, arg_ch, 0x7fff);\n        piVar3 = fcn.00421a0a(&var_10h, arg_8h, arg_ch);\n        iVar4 = *piVar3;\n        while( true ) {\n            var_ch = piVar3[1];\n            while( true ) {\n                if (iVar4 <= iVar1) {\n                    return;\n                }\n                fcn.00421ae8(arg_8h, arg_ch, (iVar4 + iVar1) / 2);\n                piVar3 = fcn.00421a0a(&var_18h, arg_8h, arg_ch);\n                var_10h = *piVar3;\n                if (piVar3[1] <= arg_10h) break;\n                if ((iVar1 == *piVar3) && (var_4h == piVar3[1])) goto code_r0x00421d43;\n                iVar1 = *piVar3;\n                var_4h = piVar3[1];\n            }\n            if (arg_10h <= piVar3[1]) break;\n            iVar4 = *piVar3;\n        }\n    }\n    return;\n}\n",
        "token_count": 741
    },
    "00422232": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00422232(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    fcn.0042331a(&var_10h, (*(in_ECX + 100) & 0xa000) != 0);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch + -2;\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 190
    },
    "00423391": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00423391(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    iVar1 = *(param_1 + 0x58);\n    if (0 < iVar1) {\n        piVar3 = *(param_1 + 0x5c);\n        iVar2 = 0;\n        if (0 < iVar1) {\n            do {\n                if (*piVar3 == param_2) {\n                    return iVar2;\n                }\n                iVar2 = iVar2 + 1;\n                piVar3 = piVar3 + 5;\n            } while (iVar2 < iVar1);\n        }\n    }\n    return -1;\n}\n",
        "token_count": 171
    },
    "004235d5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004235d5(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    fcn.0042331a(&var_10h, 1);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch + -2;\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 168
    },
    "00423ac0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00423ac0(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint var_118h;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    iVar1 = fcn.0042d07c();\n    var_4h = *(iVar1 + 4);\n    (*_sym.imp.USER32.dll_wsprintfA)(&var_118h, \"%s-Bar%d\", arg_8h, arg_ch);\n    iVar1 = fcn.0042caff(&var_118h, \"BarID\", 0);\n    *in_ECX = iVar1;\n    iVar1 = fcn.0042caff(&var_118h, \"Visible\", 1);\n    in_ECX[1] = iVar1;\n    iVar1 = fcn.0042caff(&var_118h, \"Horz\", 1);\n    in_ECX[3] = iVar1;\n    iVar1 = fcn.0042caff(&var_118h, \"Floating\", 0);\n    in_ECX[2] = iVar1;\n    iVar1 = fcn.0042caff(&var_118h, \"YPos\", 0xffffffff);\n    iVar2 = fcn.0042caff(&var_118h, \"XPos\", 0xffffffff);\n    in_ECX[5] = iVar2;\n    in_ECX[6] = iVar1;\n    fcn.00424379(in_ECX + 5);\n    iVar1 = fcn.0042caff(&var_118h, \"MRUWidth\", 0x7fff);\n    in_ECX[7] = iVar1;\n    iVar1 = fcn.0042caff(&var_118h, \"Docking\", 0);\n    in_ECX[8] = iVar1;\n    if (iVar1 != 0) {\n        iVar1 = fcn.0042caff(&var_118h, \"MRUDockID\", 0);\n        in_ECX[9] = iVar1;\n        var_8h = fcn.0042caff(&var_118h, \"MRUDockBottomPos\", 0);\n        var_10h = fcn.0042caff(&var_118h, \"MRUDockRightPos\", 0);\n        var_14h = fcn.0042caff(&var_118h, \"MRUDockTopPos\", 0);\n        var_18h = fcn.0042caff(&var_118h, \"MRUDockLeftPos\", 0);\n        var_ch = var_8h;\n        in_ECX[10] = var_18h;\n        in_ECX[0xb] = var_14h;\n        in_ECX[0xc] = var_10h;\n        in_ECX[0xd] = var_8h;\n        fcn.004243cc(in_ECX + 10);\n        iVar1 = fcn.0042caff(&var_118h, \"MRUFloatStyle\", 0);\n        in_ECX[0xe] = iVar1;\n        iVar1 = fcn.0042caff(&var_118h, \"MRUFloatYPos\", 0);\n        iVar2 = fcn.0042caff(&var_118h, \"MRUFloatXPos\", 0);\n        in_ECX[0xf] = iVar2;\n        in_ECX[0x10] = iVar1;\n        fcn.00424379(in_ECX + 0xf);\n    }\n    iVar1 = fcn.0042caff(&var_118h, \"Bars\", 0);\n    arg_10h = 0;\n    if (0 < iVar1) {\n        do {\n            (*_sym.imp.USER32.dll_wsprintfA)(&var_18h, \"Bar#%d\", arg_10h);\n            uVar3 = fcn.0042caff(&var_118h, &var_18h, 0);\n            fcn.0041602d(in_ECX[0x13], uVar3);\n            arg_10h = arg_10h + 1;\n        } while (arg_10h < iVar1);\n    }\n    return *in_ECX != 0;\n}\n",
        "token_count": 986
    },
    "004241a2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_11ch\n\nvoid __cdecl fcn.004241a2(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t arg_10h;\n    int32_t arg_ch;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_11ch;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    fcn.0042d07c();\n    (*_sym.imp.USER32.dll_wsprintfA)(unaff_EBP + -0x11c, \"%s-Summary\", *(unaff_EBP + 8));\n    arg_ch = 0;\n    uVar1 = fcn.0042caff(unaff_EBP + -0x11c, \"Bars\", 0);\n    *(unaff_EBP + -0x14) = uVar1;\n    uVar1 = fcn.0042caff(unaff_EBP + -0x11c, \"ScreenCX\", 0);\n    *(unaff_EBP + -0x1c) = uVar1;\n    uVar1 = fcn.0042caff(unaff_EBP + -0x11c, \"ScreenCY\", 0);\n    *(unaff_EBP + -0x18) = uVar1;\n    fcn.0042446f(unaff_EBP + -0x1c);\n    if (0 < *(unaff_EBP + -0x14)) {\n        do {\n            iVar2 = fcn.00416693(0x5c);\n            *(unaff_EBP + -0x10) = iVar2;\n            *(unaff_EBP + -4) = 0;\n            if (iVar2 == 0) {\n                *(unaff_EBP + -0x10) = 0;\n            }\n            else {\n                uVar1 = fcn.00423866();\n                *(unaff_EBP + -0x10) = uVar1;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0041602d(*(arg_10h + 0xc), *(unaff_EBP + -0x10));\n            fcn.00423ac0(*(unaff_EBP + 8), arg_ch, arg_10h);\n            arg_ch = arg_ch + 1;\n        } while (arg_ch < *(unaff_EBP + -0x14));\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 595
    },
    "00424289": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424289(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    uint var_10ch;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    fcn.0042d07c();\n    iVar2 = 0;\n    var_4h = 0;\n    if (0 < *(in_ECX + 0xc)) {\n        do {\n            iVar1 = fcn.00423d2d(arg_8h, var_4h);\n            if (iVar1 != 0) {\n                var_4h = var_4h + 1;\n            }\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < *(in_ECX + 0xc));\n    }\n    (*_sym.imp.USER32.dll_wsprintfA)(&var_10ch, \"%s-Summary\", arg_8h);\n    fcn.00425dd6(&var_10ch, \"Bars\", var_4h);\n    fcn.00424455(&var_ch);\n    fcn.00425dd6(&var_10ch, \"ScreenCX\", var_ch);\n    fcn.00425dd6(&var_10ch, \"ScreenCY\", var_8h);\n    return;\n}\n",
        "token_count": 298
    },
    "0042436d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0042436d(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CPtrArray.0;\n    pcVar1 = extraout_ECX[1];\n    *(unaff_EBP + -4) = 0;\n    fcn.004166cf(pcVar1);\n    *extraout_ECX = vtable.CObject.0;\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 157
    },
    "0042466b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0042466b(uint arg_8h)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    fcn.00424333();\n    puVar1 = *(extraout_ECX + 0x70);\n    while (puVar1 != NULL) {\n        puVar1 = *puVar1;\n        iVar2 = fcn.00416693(0x5c);\n        *(unaff_EBP + 8) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            *(unaff_EBP + 8) = 0;\n        }\n        else {\n            uVar3 = fcn.00423866();\n            *(unaff_EBP + 8) = uVar3;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.004246e8(*(unaff_EBP + 8));\n        fcn.0041602d();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 324
    },
    "004247c8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004247c8(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    uint var_ch;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    iVar1 = (**(*in_ECX + 0xd8))();\n    if (iVar1 == 0) {\n        arg_ch = 0x15;\n        if (in_ECX[0x1c] == 0) {\n            arg_ch = 0x17;\n        }\n        in_ECX[0x15] = *(arg_8h + 0x1c);\n        (**(*in_ECX + 0xc4))(&var_ch, 0, 0x46);\n        if (*(arg_8h + 0x20) != 0) {\n            *(in_ECX[0x1d] + 0x90) = *(arg_8h + 0x24);\n            iVar1 = in_ECX[0x1d];\n            *(iVar1 + 0x94) = *(arg_8h + 0x28);\n            *(iVar1 + 0x98) = *(arg_8h + 0x2c);\n            *(iVar1 + 0x9c) = *(arg_8h + 0x30);\n            *(iVar1 + 0xa0) = *(arg_8h + 0x34);\n            *(var_4h[0x1d] + 0xa4) = *(arg_8h + 0x38);\n            iVar1 = var_4h[0x1d];\n            *(iVar1 + 0xa8) = *(arg_8h + 0x3c);\n            *(iVar1 + 0xac) = *(arg_8h + 0x40);\n        }\n        fcn.0041af6d(0, *(arg_8h + 0x14), *(arg_8h + 0x18), 0, 0, (-(*(arg_8h + 4) != 0) & 0xffffffc0) + 0x80 | arg_ch);\n    }\n    else {\n        fcn.0042493f(arg_8h, arg_ch);\n    }\n    return;\n}\n",
        "token_count": 514
    },
    "00425779": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00425779(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    fcn.0042331a(&var_10h, *(in_ECX + 100) & 0xa000);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch;\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 183
    },
    "004258d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.004258d0(uint arg_8h, int32_t arg_ch, int32_t arg_10h, uint noname_3, uint noname_4, int32_t arg_1ch, \n            int32_t arg_20h)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    bool bVar5;\n    bool bVar6;\n    bool bVar7;\n    int32_t lpRect;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = 0;\n    var_8h = 0;\n    bVar5 = (*(in_ECX + 100) & 0xa000) == 0;\n    var_10h = 0;\n    var_4h = 0;\n    if (0 < *(in_ECX + 0x84)) {\n        do {\n            iVar4 = var_4h;\n            piVar2 = fcn.004258b4();\n            if ((piVar2 == NULL) || (iVar3 = (**(*piVar2 + 0xd0))(),  iVar3 == 0)) {\n                iVar4 = var_8h - *0x4400a4;\n                var_8h = 0;\n                var_10h = var_10h + iVar4;\n                iVar4 = arg_20h;\n                if (bVar5) {\n                    iVar4 = arg_1ch;\n                }\n                if (iVar4 < var_10h) {\n                    if (var_4h == 0) {\n                        fcn.00416054(var_ch + 1, 0, 1);\n                    }\n                    iVar4 = var_ch + 1;\n                    goto code_r0x004259ef;\n                }\ncode_r0x004259b9:\n                var_ch = var_4h;\n            }\n            else {\n                (*_sym.imp.USER32.dll_GetWindowRect)(piVar2[7], &lpRect, iVar4);\n                pcVar1 = _sym.imp.USER32.dll_ScreenToClient;\n                (*_sym.imp.USER32.dll_ScreenToClient)(*(in_ECX + 0x1c), &lpRect);\n                (*pcVar1)(*(in_ECX + 0x1c), &var_18h);\n                if (bVar5) {\n                    iVar4 = (var_18h - lpRect) + -1;\n                }\n                else {\n                    iVar4 = var_14h - var_1ch;\n                }\n                if (var_8h <= iVar4) {\n                    if (bVar5) {\n                        var_8h = (var_18h - lpRect) + -1;\n                    }\n                    else {\n                        var_8h = var_14h - var_1ch;\n                    }\n                }\n                if (bVar5) {\n                    bVar7 = SBORROW4(arg_10h, var_1ch);\n                    iVar4 = arg_10h - var_1ch;\n                    bVar6 = arg_10h == var_1ch;\n                }\n                else {\n                    bVar7 = SBORROW4(arg_ch, lpRect);\n                    iVar4 = arg_ch - lpRect;\n                    bVar6 = arg_ch == lpRect;\n                }\n                if (!bVar6 && bVar7 == iVar4 < 0) goto code_r0x004259b9;\n            }\n            var_4h = var_4h + 1;\n        } while (var_4h < *(in_ECX + 0x84));\n    }\n    iVar4 = var_ch + 1;\n    fcn.00416054(iVar4, 0, 1);\ncode_r0x004259ef:\n    fcn.00416054(iVar4, arg_8h, 1);\n    return iVar4;\n}\n",
        "token_count": 904
    },
    "0042765d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042765d(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uchar *puStack64;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint uStack48;\n    uchar auStack28 [28];\n    \n    pcVar1 = _sym.imp.USER32.dll_PeekMessageA;\n    while( true ) {\n        puStack64 = auStack28;\n        uStack52 = 0xf;\n        uStack56 = 0xf;\n        uStack48 = 0;\n        uStack60 = 0;\n        iVar2 = (*pcVar1)();\n        if (iVar2 == 0) {\n            *(param_1 + 0x70) = *(*(param_1 + 0x68) + 0x68);\n            *(param_1 + 0x78) = *(*(param_1 + 0x68) + 100) & 0xf000;\n            (*_sym.imp.USER32.dll_SetRectEmpty)(param_1 + 0xc);\n            *(param_1 + 0x20) = 0;\n            *(param_1 + 0x1c) = 0;\n            *(param_1 + 0x24) = 0;\n            *(param_1 + 0x7c) = 0;\n            *(param_1 + 0x80) = 0;\n            uVar3 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n            iVar2 = fcn.0041819c(uVar3);\n            iVar4 = (*_sym.imp.USER32.dll_LockWindowUpdate)(*(iVar2 + 0x1c));\n            if (iVar4 == 0) {\n                uVar3 = 3;\n            }\n            else {\n                uVar3 = 0x403;\n            }\n            uVar3 = (*_sym.imp.USER32.dll_GetDCEx)(*(iVar2 + 0x1c), 0, uVar3);\n            uVar3 = fcn.0041f487(uVar3);\n            *(param_1 + 0x84) = uVar3;\n            return;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetMessageA)(&uStack48, 0, 0xf, 0xf);\n        if (iVar2 == 0) break;\n        (*_sym.imp.USER32.dll_DispatchMessageA)(&puStack64);\n    }\n    return;\n}\n",
        "token_count": 558
    },
    "0042771e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042771e(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    fcn.00427767(1);\n    (*_sym.imp.USER32.dll_ReleaseCapture)();\n    uVar1 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    iVar2 = fcn.0041819c(uVar1);\n    (*_sym.imp.USER32.dll_LockWindowUpdate)(0);\n    if (*(param_1 + 0x84) != 0) {\n        (*_sym.imp.USER32.dll_ReleaseDC)(*(iVar2 + 0x1c), *(*(param_1 + 0x84) + 4));\n        *(param_1 + 0x84) = 0;\n    }\n    return;\n}\n",
        "token_count": 174
    },
    "00427d16": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00427d16(uint param_1)\n\n{\n    fcn.0042d07c();\n    fcn.0042d88a(0x404461);\n    fcn.0042d478(param_1);\n    return;\n}\n",
        "token_count": 58
    },
    "00427d3a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00427d3a(uint param_1)\n\n{\n    fcn.0042d07c();\n    fcn.0042d88a(0x404461);\n    fcn.0042d48b(param_1);\n    return;\n}\n",
        "token_count": 60
    },
    "00429e7e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00429e7e(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t arg_10h;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    int32_t unaff_EBP;\n    uint32_t *puVar3;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    puVar3 = 0x432f44;\n    *(arg_8h_00 + 0xb4) = 0x433090;\n    do {\n        if (((*(unaff_EBP + 8) & *puVar3 & 0xf000) != 0) && (iVar2 = fcn.00429484(puVar3[-1]),  iVar2 == 0)) {\n            iVar2 = fcn.00416693(0xa4);\n            *(unaff_EBP + -0x10) = iVar2;\n            *(unaff_EBP + -4) = 0;\n            if (iVar2 != 0) {\n                fcn.00424b0c(0);\n            }\n            uVar1 = *puVar3;\n            arg_10h = puVar3[-1];\n            *(unaff_EBP + -4) = 0xffffffff;\n            iVar2 = fcn.00424c0f(arg_8h_00, uVar1 | 0x56000000, arg_10h);\n            if (iVar2 == 0) {\n                fcn.0041fdd5();\n            }\n        }\n        puVar3 = puVar3 + 2;\n    } while (puVar3 < 0x432f64);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 455
    },
    "00429f3b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00429f3b(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    uint var_4h;\n    \n    if (arg_ch == 0) {\n        iVar2 = 0;\n        puVar1 = 0x432f44;\n        do {\n            if (((*puVar1 ^ *(arg_8h + 100)) & 0xf000) == 0) {\n                fcn.00429484(*(iVar2 * 8 + 0x432f40));\n                break;\n            }\n            puVar1 = puVar1 + 2;\n            iVar2 = iVar2 + 1;\n        } while (puVar1 < 0x432f64);\n    }\n    fcn.00424cd7(arg_8h, arg_10h);\n    return;\n}\n",
        "token_count": 204
    },
    "0042a596": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a596(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t Y, uint crColor)\n\n{\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.GDI32.dll_SetBkColor)(*(in_ECX + 4), crColor);\n    var_10h = arg_8h;\n    var_8h = arg_10h + arg_8h;\n    var_4h = Y + arg_ch;\n    var_ch = arg_ch;\n    (*_sym.imp.GDI32.dll_ExtTextOutA)(*(in_ECX + 4), 0, 0, 2, &var_10h, 0, 0, 0);\n    return;\n}\n",
        "token_count": 207
    },
    "0042a67a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_60h\n// WARNING: Variable defined which should be unmapped: lptm\n\nvoid fcn.0042a67a(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    uint *in_FS_OFFSET;\n    bool bVar4;\n    char *pcVar5;\n    int32_t iVar6;\n    uint var_60h;\n    uint lptm;\n    uint var_50h;\n    uint var_49h;\n    uint lpString1;\n    uint lpvObject;\n    uint var_20h;\n    uint var_1ch;\n    uint hdc;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    iVar3 = 0;\n    if (*0x4400f4 != 0) goto code_r0x0042a7c8;\n    fcn.0042d3e7(10);\n    if (*0x44049c == 0) {\n        iVar2 = fcn.0042d07c();\n        *0x44049c = (*_sym.imp.USER32.dll_LoadBitmapA)(*(iVar2 + 0xc), 0x7912);\n        iVar2 = (*_sym.imp.GDI32.dll_GetObjectA)(*0x44049c, 0x18, unaff_EBP + -0x24);\n        if (iVar2 != 0) {\n            *0x4404a8 = *(unaff_EBP + -0x20);\n            *0x4404ac = *(unaff_EBP + -0x1c);\n        }\n    }\n    if (*0x440498 == 0) {\n        fcn.00406030(unaff_EBP + -0x60, 0, 0x3c);\n        *(unaff_EBP + -0x49) = 1;\n        *(unaff_EBP + -0x50) = 400;\n        *(unaff_EBP + -0x60) = 1 - *0x4404ac;\n        iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x2a);\n        if (iVar2 == 0) {\n            pcVar5 = \"Small Fonts\";\n        }\n        else {\n            pcVar5 = \"Terminal\";\n        }\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(unaff_EBP + -0x44, pcVar5);\n        iVar2 = fcn.0042023c(0xf233, unaff_EBP + -0x60);\n        if (iVar2 == 0) {\n            *(unaff_EBP + -0x45) = 0x20;\n        }\n        *0x440498 = (*_sym.imp.GDI32.dll_CreateFontIndirectA)(unaff_EBP + -0x60);\n        if (*0x440498 != 0) goto code_r0x0042a75b;\n    }\n    else {\ncode_r0x0042a75b:\n        iVar6 = 0;\n        fcn.0041faad(0);\n        pcVar1 = _sym.imp.GDI32.dll_SelectObject;\n        iVar2 = *0x440498;\n        bVar4 = *0x440498 != 0;\n        *(unaff_EBP + -4) = 0;\n        if (bVar4) {\n            iVar3 = (*pcVar1)(*(unaff_EBP + -0x1c), iVar2);\n        }\n        iVar2 = (*_sym.imp.GDI32.dll_GetTextMetricsA)(*(unaff_EBP + -0x18), unaff_EBP + -0x5c);\n        if (iVar3 != 0) {\n            (*pcVar1)(*(unaff_EBP + -0x1c), iVar3);\n            iVar6 = iVar3;\n        }\n        if ((iVar2 == 0) || (*0x4404ac < *(unaff_EBP + -0x5c) - *(unaff_EBP + -0x50))) {\n            fcn.004203f6(iVar6, 0x440498);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0041fb1f();\n    }\n    fcn.0042d457(10);\ncode_r0x0042a7c8:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 988
    },
    "0042b4a1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042b4a1(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar2 = _sym.imp.USER32.dll_CopyRect;\n    (*_sym.imp.USER32.dll_CopyRect)(&var_10h, arg_ch);\n    pcVar1 = _sym.imp.USER32.dll_FillRect;\n    var_8h = var_10h + arg_10h;\n    iVar3 = arg_18h;\n    if (arg_18h != 0) {\n        iVar3 = *(arg_18h + 4);\n    }\n    (*_sym.imp.USER32.dll_FillRect)(*(arg_8h + 4), &var_10h, iVar3);\n    var_8h = *(arg_ch + 8);\n    var_10h = var_8h - arg_10h;\n    iVar3 = arg_18h;\n    if (arg_18h != 0) {\n        iVar3 = *(arg_18h + 4);\n    }\n    (*pcVar1)(*(arg_8h + 4), &var_10h, iVar3);\n    (*pcVar2)(&var_10h, arg_ch);\n    var_4h = var_ch + arg_14h;\n    var_10h = var_10h + arg_10h;\n    var_8h = var_8h - arg_10h;\n    iVar3 = arg_18h;\n    if (arg_18h != 0) {\n        iVar3 = *(arg_18h + 4);\n    }\n    (*pcVar1)(*(arg_8h + 4), &var_10h, iVar3);\n    var_4h = *(arg_ch + 0xc);\n    var_ch = var_4h - arg_14h;\n    if (arg_18h != 0) {\n        arg_18h = *(arg_18h + 4);\n    }\n    (*pcVar1)(*(arg_8h + 4), &var_10h, arg_18h);\n    return;\n}\n",
        "token_count": 536
    },
    "0042c2c1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0042c2c1(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar1 = *(*in_ECX + 0xa8);\n    iVar2 = (*pcVar1)(0x418, 0, 0);\n    iVar3 = var_8h;\n    while (var_8h = iVar2,  var_8h != 0) {\n        (*pcVar1)(0x416, 0, 0);\n        iVar3 = var_8h + -1;\n        iVar2 = iVar3;\n    }\n    var_8h = iVar3;\n    if (arg_8h == NULL) {\n        fcn.00406030(&var_1ch, 0, 0x14);\n        var_14h._0_1_ = 4;\n        arg_8h = NULL;\n        if (0 < arg_ch) {\n            do {\n                iVar3 = (*pcVar1)(0x414, 1, &var_1ch);\n                if (iVar3 == 0) {\n                    return 0;\n                }\n                arg_8h = arg_8h + 1;\n            } while (arg_8h < arg_ch);\n        }\n    }\n    else {\n        fcn.00406030(&var_1ch, 0, 0x14);\n        var_4h = 0;\n        var_8h = 0;\n        if (0 < arg_ch) {\n            do {\n                var_14h._0_1_ = 4;\n                var_18h = *arg_8h;\n                if (var_18h != 0) {\n                    var_1ch = var_4h;\n                    var_4h = var_4h + 1;\n                }\n                else {\n                    var_1ch = 8;\n                }\n                var_14h._1_1_ = var_18h == 0;\n                iVar3 = (*pcVar1)(0x414, 1, &var_1ch);\n                if (iVar3 == 0) {\n                    return 0;\n                }\n                var_8h = var_8h + 1;\n                arg_8h = arg_8h + 1;\n            } while (var_8h < arg_ch);\n        }\n    }\n    iVar3 = (*pcVar1)(0x418, 0, 0);\n    in_ECX[0x16] = iVar3;\n    in_ECX[0x21] = 1;\n    return 1;\n}\n",
        "token_count": 644
    },
    "0042c64c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: hdc\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: lpSize\n\nint32_t __cdecl fcn.0042c64c(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t *piVar5;\n    uint unaff_EDI;\n    int32_t *piVar6;\n    uint *in_FS_OFFSET;\n    uint var_38h;\n    uint hdc;\n    uint var_30h;\n    uint in_stack_ffffffd4;\n    uint lpSize;\n    uint var_1ch;\n    uint var_18h;\n    uint hgdiobj;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x1c) = extraout_ECX;\n    iVar2 = fcn.0042c783(*(unaff_EBP + 0xc));\n    if (iVar2 != 0) {\n        *(unaff_EBP + -0x18) = 1;\n        if (*(unaff_EBP + 8) != 0) {\n            iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*(extraout_ECX + 0x1c), 0x31, 0, 0);\n            fcn.0041faad(0);\n            *(unaff_EBP + -4) = 0;\n            *(unaff_EBP + -0x14) = 0;\n            if (iVar2 != 0) {\n                uVar3 = (*_sym.imp.GDI32.dll_SelectObject)(*(unaff_EBP + -0x34), iVar2);\n                *(unaff_EBP + -0x14) = uVar3;\n            }\n            piVar6 = *(extraout_ECX + 0x5c);\n            *(unaff_EBP + -0x10) = 0;\n            if (0 < *(unaff_EBP + 0xc)) {\n                piVar5 = piVar6 + 4;\n                do {\n                    piVar1 = *(unaff_EBP + 8);\n                    *(unaff_EBP + 8) = *(unaff_EBP + 8) + 4;\n                    iVar2 = *piVar1;\n                    piVar5[-1] = piVar5[-1] | 1;\n                    *piVar6 = iVar2;\n                    if (iVar2 != 0) {\n                        iVar2 = fcn.0041c4c3(iVar2);\n                        if (iVar2 != 0) {\n                            (*_sym.imp.GDI32.dll_GetTextExtentPointA)\n                                      (*(unaff_EBP + -0x30), *piVar5, *(*piVar5 + -8), unaff_EBP + -0x24);\n                            piVar5[-3] = *(unaff_EBP + -0x24);\n                            iVar2 = fcn.00423415(*(unaff_EBP + -0x10), *piVar5, 0, 0x14, unaff_EDI, in_stack_ffffffd4, \n                                                 lpSize);\n                            if (iVar2 != 0) goto code_r0x0042c72e;\n                        }\n                        *(unaff_EBP + -0x18) = 0;\n                        break;\n                    }\n                    iVar4 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0);\n                    iVar2 = *(unaff_EBP + -0x10);\n                    piVar5[-3] = iVar4 / 4;\n                    if (iVar2 == 0) {\n                        piVar5[-2] = piVar5[-2] | 0x8000100;\n                    }\ncode_r0x0042c72e:\n                    piVar6 = piVar6 + 5;\n                    piVar5 = piVar5 + 5;\n                    *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + 1;\n                } while (*(unaff_EBP + -0x10) < *(unaff_EBP + 0xc));\n            }\n            if (*(unaff_EBP + -0x14) != 0) {\n                (*_sym.imp.GDI32.dll_SelectObject)(*(unaff_EBP + -0x34), *(unaff_EBP + -0x14));\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0041fb1f();\n        }\n        fcn.0042c857(1, 1);\n        iVar2 = *(unaff_EBP + -0x18);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 1105
    },
    "0042c783": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0042c783(int32_t param_1, uint param_2, uint param_3)\n\n{\n    uint arg_ch;\n    int32_t arg_8h;\n    int32_t iVar1;\n    uint arg_10h;\n    \n    iVar1 = 0;\n    if (0 < *(param_1 + 0x58)) {\n        do {\n            fcn.0041b20c();\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < *(param_1 + 0x58));\n    }\n    iVar1 = fcn.0042c4e0(param_2, param_3);\n    if (iVar1 != 0) {\n        iVar1 = 0;\n        if (0 < *(param_1 + 0x58)) {\n            arg_8h = *(param_1 + 0x5c) + 0x10;\n            do {\n                arg_10h = 4;\n                arg_ch = fcn.0041b0bb();\n                fcn.00405850(arg_8h, arg_ch, arg_10h);\n                arg_8h = arg_8h + 0x14;\n                iVar1 = iVar1 + 1;\n            } while (iVar1 < *(param_1 + 0x58));\n        }\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 308
    },
    "0042d0a2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0042d0a2(void)\n\n{\n    fcn.0042d07c();\n    fcn.0042d88a(0x404461);\n    return;\n}\n",
        "token_count": 43
    },
    "0042d6b9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042d6b9(uint *param_1, int32_t param_2)\n\n{\n    code **ppcVar1;\n    code *pcVar2;\n    int32_t unaff_retaddr;\n    \n    ppcVar1 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*param_1);\n    if (ppcVar1 == NULL) {\ncode_r0x0042d6e9:\n        ppcVar1 = fcn.0042d4d6(0x10);\n        if (ppcVar1 == NULL) {\n            ppcVar1 = NULL;\n        }\n        else {\n            *ppcVar1 = vtable.CThreadData.0;\n        }\n        ppcVar1[2] = NULL;\n        ppcVar1[3] = NULL;\n        fcn.0042d478(ppcVar1);\n    }\n    else {\n        if ((unaff_retaddr < ppcVar1[2]) || (param_2 == 0)) goto code_r0x0042d773;\n        if (ppcVar1 == NULL) goto code_r0x0042d6e9;\n    }\n    if (ppcVar1[3] == NULL) {\n        pcVar2 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0, param_1[3] << 2);\n    }\n    else {\n        pcVar2 = (*_sym.imp.KERNEL32.dll_LocalReAlloc)(ppcVar1[3], param_1[3] << 2, 2);\n    }\n    ppcVar1[3] = pcVar2;\n    if (pcVar2 == NULL) {\n        fcn.00415699();\n    }\n    fcn.00406030(ppcVar1[3] + ppcVar1[2] * 4, 0, (ppcVar1[2] * 0x3fffffff + param_1[3]) * 4);\n    ppcVar1[2] = param_1[3];\n    (*_sym.imp.KERNEL32.dll_TlsSetValue)(*param_1, ppcVar1);\ncode_r0x0042d773:\n    *(ppcVar1[3] + unaff_retaddr * 4) = param_2;\n    return;\n}\n",
        "token_count": 502
    },
    "0042e379": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop",
            "set application hook"
        ],
        "decompiled_code": "\nvoid fcn.0042e379(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    char *pcVar5;\n    \n    iVar2 = fcn.0042d07c();\n    fcn.0042d3e7(1);\n    pcVar5 = iVar2 + 0x34;\n    while (*pcVar5 != '\\0') {\n        puVar3 = fcn.004063b0(pcVar5, 10);\n        *puVar3 = 0;\n        iVar4 = fcn.0042d07c();\n        (*_sym.imp.USER32.dll_UnregisterClassA)(pcVar5, *(iVar4 + 8));\n        pcVar5 = puVar3 + 1;\n    }\n    *(iVar2 + 0x34) = '\\0';\n    fcn.0042d457(1);\n    iVar2 = fcn.0042d07c();\n    if ((*(iVar2 + 4) != 0) && (pcVar1 = *(*(iVar2 + 4) + 0x54),  pcVar1 != NULL)) {\n        (*pcVar1)(1, 0);\n    }\n    iVar2 = fcn.0042cd29();\n    if (*(iVar2 + 0xcc) != 0) {\n        iVar4 = fcn.00404a64();\n        if (iVar4 != 0) {\n            *(iVar2 + 0xcc) = 0;\n        }\n    }\n    iVar4 = fcn.0042d07c();\n    pcVar1 = _sym.imp.USER32.dll_UnhookWindowsHookEx;\n    if (*(iVar4 + 0x14) == '\\0') {\n        if (*(iVar2 + 0x30) != 0) {\n            (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar2 + 0x30));\n            *(iVar2 + 0x30) = 0;\n        }\n        if (*(iVar2 + 0x2c) != 0) {\n            (*pcVar1)(*(iVar2 + 0x2c));\n            *(iVar2 + 0x2c) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 493
    },
    "0041571b": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041571b(uint16_t *arg_8h, uint arg_ch)\n\n{\n    uint16_t **in_ECX;\n    \n    if (*arg_8h < 0x76c) {\n        *in_ECX = NULL;\n    }\n    else {\n        fcn.004156cf(*arg_8h, arg_8h[1], arg_8h[3], arg_8h[4], arg_8h[5], arg_8h[6], arg_ch);\n        *in_ECX = arg_8h;\n    }\n    return;\n}\n",
        "token_count": 131
    },
    "004207ba": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004207ba(int32_t param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint uVar5;\n    \n    if (*(*(param_1 + 0x60) + -8) == 0) {\n        fcn.0041c4c3(*(param_1 + 0x3c));\n    }\n    pcVar2 = _sym.imp.USER32.dll_LoadMenuA;\n    pcVar1 = _sym.imp.USER32.dll_LoadAcceleratorsA;\n    if ((*(param_1 + 0x44) != 0) && (*(param_1 + 0x2c) == 0)) {\n        iVar3 = fcn.0042d07c();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar2)(uVar5, *(param_1 + 0x44));\n        *(param_1 + 0x2c) = uVar4;\n        uVar5 = (*pcVar1)(uVar5, *(param_1 + 0x44));\n        *(param_1 + 0x30) = uVar5;\n    }\n    if ((*(param_1 + 0x40) != 0) && (*(param_1 + 0x34) == 0)) {\n        iVar3 = fcn.0042d07c();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar2)(uVar5, *(param_1 + 0x40));\n        *(param_1 + 0x34) = uVar4;\n        uVar5 = (*pcVar1)(uVar5, *(param_1 + 0x40));\n        *(param_1 + 0x38) = uVar5;\n    }\n    if ((*(param_1 + 0x48) != 0) && (*(param_1 + 0x24) == 0)) {\n        iVar3 = fcn.0042d07c();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar2)(uVar5, *(param_1 + 0x48));\n        *(param_1 + 0x24) = uVar4;\n        uVar5 = (*pcVar1)(uVar5, *(param_1 + 0x48));\n        *(param_1 + 0x28) = uVar5;\n    }\n    return;\n}\n",
        "token_count": 557
    },
    "00403e3e": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00403e3e(int32_t param_1)\n\n{\n    uint arg_10h;\n    int32_t iVar1;\n    uint var_2ch;\n    uint32_t var_28h;\n    \n    fcn.004244ef(\"General\");\n    arg_10h = *(param_1 + 0x52c);\n    fcn.0042d07c();\n    fcn.00425dd6(\"General\", \"Columns\", arg_10h);\n    fcn.0042d07c();\n    fcn.00425dd6(\"General\", 0x43a3a0, *(param_1 + 0xbc) != 0);\n    fcn.0042d07c();\n    fcn.00425dd6(\"General\", 0x43a394, *(param_1 + 0xc0) != 0);\n    var_2ch = 0x2c;\n    iVar1 = fcn.00418c0d(&var_2ch);\n    if (iVar1 != 0) {\n        var_28h = 0;\n        iVar1 = (*_sym.imp.USER32.dll_IsZoomed)(*(param_1 + 0x1c));\n        if (iVar1 != 0) {\n            var_28h = var_28h | 2;\n        }\n        fcn.00403ef3(&var_2ch);\n    }\n    fcn.004287f6();\n    return;\n}\n",
        "token_count": 322
    },
    "00416c11": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00416c11(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    uint uVar3;\n    uint uVar4;\n    uint *in_ECX;\n    uint var_ch;\n    uint var_4h;\n    \n    if ((in_ECX[1] == 0) || (*(in_ECX + 1) == -1)) {\n        uVar3 = 1;\n    }\n    else {\n        iVar1 = *arg_8h;\n        in_ECX[6] = 0;\n        pcVar2 = *(iVar1 + 0x14);\n        uVar3 = (*pcVar2)(in_ECX[1], 0xffffffff);\n        if ((arg_ch != 0) && (in_ECX[6] == 0)) {\n            uVar4 = (*pcVar2)(in_ECX[1], 0);\n            (***in_ECX)(uVar4);\n        }\n    }\n    return uVar3;\n}\n",
        "token_count": 231
    },
    "0041977a": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041977a(uint noname_0, uint *hWnd, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint var_ch;\n    uint *var_8h;\n    uint32_t var_4h;\n    \n    uVar3 = *hWnd;\n    var_4h = (*_sym.imp.USER32.dll_GetDlgCtrlID)(uVar3);\n    var_4h = var_4h & 0xffff;\n    uVar1 = hWnd[2];\n    iVar2 = fcn.0042d88a(0x404495);\n    if ((*(iVar2 + 0xb8) != in_ECX[7]) && (iVar2 = fcn.0041a040(uVar3, arg_10h),  iVar2 == 0)) {\n        var_ch = arg_10h;\n        var_8h = hWnd;\n        uVar3 = (**(*in_ECX + 0x14))(var_4h, uVar1 & 0xffff | 0x4e0000, &var_ch, 0);\n        return uVar3;\n    }\n    return 1;\n}\n",
        "token_count": 278
    },
    "0042039e": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get graphical window text"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042039e(uint hWnd, uint lpString2)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint lpString1;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString2);\n    if (((uVar1 < 0x101) && (uVar2 = (*_sym.imp.USER32.dll_GetWindowTextA)(hWnd, &lpString1, 0x100),  uVar2 == uVar1))\n       && (iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(&lpString1, lpString2),  iVar3 == 0)) {\n        return;\n    }\n    (*_sym.imp.USER32.dll_SetWindowTextA)(hWnd, lpString2);\n    return;\n}\n",
        "token_count": 185
    },
    "00420cbd": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00420cbd(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    *(in_ECX + 0x40) = 0xffffffff;\n    *(in_ECX + 0x44) = arg_8h;\n    *(in_ECX + 0x48) = arg_ch;\n    if (*(in_ECX + 0x1c) != 0) {\n        uVar1 = fcn.0041ae7b();\n        if ((uVar1 & 0x300000) != 0) {\n            fcn.00419b40(0, 0, 1);\n            fcn.00419b40(1, 0, 1);\n            fcn.00419bcb(3, 0);\n        }\n    }\n    (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lpRect);\n    *(in_ECX + 0x4c) = var_8h - lpRect;\n    *(in_ECX + 0x50) = var_4h - var_ch;\n    if (*(in_ECX + 0x1c) != 0) {\n        fcn.00420fc6();\n        (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), 0, 1);\n    }\n    return;\n}\n",
        "token_count": 349
    },
    "00420fc6": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00420fc6(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    uint lpRect;\n    int32_t var_44h;\n    int32_t var_40h;\n    int32_t lParam;\n    int32_t var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (*(param_1 + 0x68) != 0) {\n        return;\n    }\n    *(param_1 + 0x68) = 1;\n    var_4h = 1;\n    uVar1 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x1c));\n    iVar2 = fcn.0041819c(uVar1);\n    if ((iVar2 != 0) && (iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x1c), 0x368, 0, &lParam),  iVar2 != 0))\n    {\n        var_4h = 0;\n    }\n    if (var_4h == 0) {\n        fcn.00420e3b(&var_1ch);\n        var_ch = var_34h - lParam;\n        var_8h = var_30h - var_38h;\n    }\n    else {\n        iVar2 = fcn.00420e95(&var_ch, &var_1ch);\n        if (iVar2 == 0) {\n            (*_sym.imp.USER32.dll_GetClientRect)(*(param_1 + 0x1c), &lpRect);\n            if ((0 < var_44h) && (0 < var_40h)) {\n                fcn.00419bcb(3, 0);\n            }\n            goto code_r0x00421134;\n        }\n    }\n    fcn.00420f0a(var_ch, var_8h, &var_14h, &var_2ch, &var_24h, var_4h);\n    if (var_14h != 0) {\n        var_8h = var_8h - var_18h;\n    }\n    if (var_10h != 0) {\n        var_ch = var_ch - var_1ch;\n    }\n    fcn.00420dc1(var_24h, var_20h);\n    var_64h = 3;\n    var_60h = 0;\n    fcn.00419bcb(0, var_14h);\n    if (var_14h != 0) {\n        var_58h = var_ch;\n        var_5ch = *(param_1 + 0x4c) + -1;\n        iVar2 = fcn.00419c0e(0, &var_68h, 1);\n        if (iVar2 == 0) {\n            fcn.00419b98(0, 0, var_2ch, 1);\n        }\n    }\n    fcn.00419bcb(1, var_10h);\n    if (var_10h != 0) {\n        var_58h = var_8h;\n        var_5ch = *(param_1 + 0x50) + -1;\n        iVar2 = fcn.00419c0e(1, &var_68h, 1);\n        if (iVar2 == 0) {\n            fcn.00419b98(1, 0, var_28h, 1);\n        }\n    }\ncode_r0x00421134:\n    *(param_1 + 0x68) = 0;\n    return;\n}\n",
        "token_count": 933
    },
    "0042446f": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042446f(int32_t param_1, int32_t *param_2)\n\n{\n    uint uVar1;\n    \n    *(param_1 + 0x3c) = *param_2;\n    *(param_1 + 0x40) = param_2[1];\n    if ((*param_2 == *(param_1 + 0x24) - *(param_1 + 0x1c)) && (param_2[1] == *(param_1 + 0x28) - *(param_1 + 0x20))) {\n        uVar1 = 0;\n    }\n    else {\n        uVar1 = 1;\n    }\n    *(param_1 + 0x18) = uVar1;\n    return;\n}\n",
        "token_count": 174
    },
    "00425713": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00425713(uint arg_8h, int32_t *arg_ch)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    uint uVar3;\n    uint uVar4;\n    uint uVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    uint var_18h;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar6 = *(in_ECX + 0x90);\n    puVar1 = in_ECX + 0x94;\n    uVar2 = *puVar1;\n    uVar3 = *(in_ECX + 0x98);\n    uVar4 = *(in_ECX + 0x9c);\n    uVar5 = *(in_ECX + 0xa0);\n    *(in_ECX + 0x90) = *arg_ch == 0;\n    (*_sym.imp.USER32.dll_CopyRect)(puVar1, arg_ch + 1);\n    fcn.00422fa9(arg_8h, arg_ch);\n    *puVar1 = uVar2;\n    *(in_ECX + 0x98) = uVar3;\n    *(in_ECX + 0x9c) = uVar4;\n    *(in_ECX + 0xa0) = uVar5;\n    *(in_ECX + 0x90) = uVar6;\n    return;\n}\n",
        "token_count": 311
    },
    "00428494": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00428494(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar1 = fcn.0041b76b();\n    if (piVar1 != NULL) {\n        var_14h = 0;\n        var_10h = 0;\n        var_ch = 0;\n        var_8h = 0;\n        iVar2 = (**(*piVar1 + 0x5c))(0, 0, 0x50800000, &var_14h, var_4h, arg_ch, arg_8h);\n        if (iVar2 != 0) {\n            if (*0x4400ec == 0) {\n                return piVar1;\n            }\n            uVar3 = fcn.0041ae95();\n            if ((uVar3 & 0x200) == 0) {\n                return piVar1;\n            }\n            fcn.0041aee3(0x200, 0, 0x20);\n            return piVar1;\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 293
    },
    "00428c4b": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00428c4b(uint arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint32_t uVar4;\n    uint var_10ch;\n    code *var_8h;\n    uint32_t var_4h;\n    \n    uVar2 = (*_sym.imp.USER32.dll_SetActiveWindow)(*(in_ECX + 0x1c));\n    fcn.0041819c(uVar2);\n    pcVar1 = _sym.imp.SHELL32.dll_DragQueryFileA;\n    uVar4 = 0;\n    var_4h = (*_sym.imp.SHELL32.dll_DragQueryFileA)(arg_8h, 0xffffffff, 0, 0);\n    iVar3 = fcn.0042d07c();\n    if (var_4h != 0) {\n        var_8h = *(**(iVar3 + 4) + 0x84);\n        do {\n            (*pcVar1)(arg_8h, uVar4, &var_10ch, 0x104);\n            (*var_8h)(&var_10ch);\n            uVar4 = uVar4 + 1;\n        } while (uVar4 < var_4h);\n    }\n    (*_sym.imp.SHELL32.dll_DragFinish)(arg_8h);\n    return;\n}\n",
        "token_count": 316
    },
    "0042a281": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: nLeftRect\n// WARNING: Variable defined which should be unmapped: nBottomRect\n// WARNING: Variable defined which should be unmapped: nRightRect\n// WARNING: Variable defined which should be unmapped: nTopRect\n\nvoid __cdecl\nfcn.0042a281(uint lprcSrc2, uint dx, uint dy, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, uint arg_24h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint nLeftRect;\n    uint nTopRect;\n    uint nRightRect;\n    uint nBottomRect;\n    uint var_34h;\n    uint hrgnDest;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint hrgnSrc1;\n    uint var_14h;\n    uint hrgnSrc2;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    fcn.00404faa();\n    *(unaff_EBP + -0x34) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 0;\n    fcn.00404faa();\n    *(unaff_EBP + -0x1c) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 1;\n    fcn.00404faa();\n    *(unaff_EBP + -0x14) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 2;\n    uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgnIndirect)(*(unaff_EBP + 8));\n    fcn.0041fd68(uVar2);\n    (*_sym.imp.USER32.dll_CopyRect)(unaff_EBP + -0x44, *(unaff_EBP + 8));\n    (*_sym.imp.USER32.dll_InflateRect)(unaff_EBP + -0x44, -*(unaff_EBP + 0xc), -*(unaff_EBP + 0x10));\n    (*_sym.imp.USER32.dll_IntersectRect)(unaff_EBP + -0x44, unaff_EBP + -0x44, *(unaff_EBP + 8));\n    uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgnIndirect)(unaff_EBP + -0x44);\n    fcn.0041fd68(uVar2);\n    uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgn)(0, 0, 0, 0);\n    fcn.0041fd68(uVar2);\n    (*_sym.imp.GDI32.dll_CombineRgn)\n              (*(unaff_EBP + -0x30), -(unaff_EBP != 0x1c) & *(unaff_EBP + -0x18), \n               -(unaff_EBP != 0x14) & *(unaff_EBP + -0x10), 3);\n    if (*(unaff_EBP + 0x20) == 0) {\n        uVar2 = fcn.0042a20e();\n        *(unaff_EBP + 0x20) = uVar2;\n    }\n    if (*(unaff_EBP + 0x24) == 0) {\n        *(unaff_EBP + 0x24) = *(unaff_EBP + 0x20);\n    }\n    fcn.00404faa();\n    *(unaff_EBP + -0x24) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 3;\n    fcn.00404faa();\n    *(unaff_EBP + -0x2c) = vtable.CRgn.0;\n    puVar1 = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -4) = 4;\n    if (puVar1 != NULL) {\n        uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgn)(0, 0, 0, 0);\n        fcn.0041fd68(uVar2);\n        (*_sym.imp.GDI32.dll_SetRectRgn)(*(unaff_EBP + -0x18), *puVar1, puVar1[1], puVar1[2], puVar1[3]);\n        (*_sym.imp.USER32.dll_CopyRect)(unaff_EBP + -0x44, puVar1);\n        (*_sym.imp.USER32.dll_InflateRect)(unaff_EBP + -0x44, -*(unaff_EBP + 0x18), -*(unaff_EBP + 0x1c));\n        (*_sym.imp.USER32.dll_IntersectRect)(unaff_EBP + -0x44, unaff_EBP + -0x44, puVar1);\n        (*_sym.imp.GDI32.dll_SetRectRgn)\n                  (*(unaff_EBP + -0x10), *(unaff_EBP + -0x44), *(unaff_EBP + -0x40), *(unaff_EBP + -0x3c), \n                   *(unaff_EBP + -0x38));\n        (*_sym.imp.GDI32.dll_CombineRgn)\n                  (*(unaff_EBP + -0x20), -(unaff_EBP != 0x1c) & *(unaff_EBP + -0x18), \n                   -(unaff_EBP != 0x14) & *(unaff_EBP + -0x10), 3);\n        if (*(*(unaff_EBP + 0x20) + 4) == *(*(unaff_EBP + 0x24) + 4)) {\n            uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgn)(0, 0, 0, 0);\n            fcn.0041fd68(uVar2);\n            (*_sym.imp.GDI32.dll_CombineRgn)\n                      (*(unaff_EBP + -0x28), -(unaff_EBP != 0x24) & *(unaff_EBP + -0x20), \n                       -(unaff_EBP != 0x34) & *(unaff_EBP + -0x30), 3);\n        }\n    }\n    if ((*(*(unaff_EBP + 0x20) + 4) != *(*(unaff_EBP + 0x24) + 4)) && (puVar1 != NULL)) {\n        fcn.0041f993(unaff_EBP + -0x24);\n        (**(*extraout_ECX + 0x58))(unaff_EBP + -0x44);\n        uVar2 = fcn.0041f61d(*(unaff_EBP + 0x24));\n        (*_sym.imp.GDI32.dll_PatBlt)\n                  (extraout_ECX[1], *(unaff_EBP + -0x44), *(unaff_EBP + -0x40), \n                   *(unaff_EBP + -0x3c) - *(unaff_EBP + -0x44), *(unaff_EBP + -0x38) - *(unaff_EBP + -0x40), 0x5a0049);\n        fcn.0041f61d(uVar2);\n    }\n    iVar3 = unaff_EBP + -0x2c;\n    if (*(unaff_EBP + -0x28) == 0) {\n        iVar3 = unaff_EBP + -0x34;\n    }\n    fcn.0041f993(iVar3);\n    (**(*extraout_ECX + 0x58))(unaff_EBP + -0x44);\n    iVar3 = fcn.0041f61d(*(unaff_EBP + 0x20));\n    (*_sym.imp.GDI32.dll_PatBlt)\n              (extraout_ECX[1], *(unaff_EBP + -0x44), *(unaff_EBP + -0x40), *(unaff_EBP + -0x3c) - *(unaff_EBP + -0x44)\n               , *(unaff_EBP + -0x38) - *(unaff_EBP + -0x40), 0x5a0049);\n    if (iVar3 != 0) {\n        fcn.0041f61d(iVar3);\n    }\n    fcn.0041f993(0);\n    *(unaff_EBP + -0x2c) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 5;\n    fcn.0041fdbf();\n    *(unaff_EBP + -0x24) = vtable.CGdiObject.0;\n    *(unaff_EBP + -0x2c) = vtable.CObject.0;\n    *(unaff_EBP + -4) = 6;\n    fcn.0041fdbf();\n    *(unaff_EBP + -0x24) = vtable.CObject.0;\n    *(unaff_EBP + -0x14) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 7;\n    fcn.0041fdbf();\n    *(unaff_EBP + -0x14) = vtable.CObject.0;\n    *(unaff_EBP + -0x1c) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 8;\n    fcn.0041fdbf();\n    *(unaff_EBP + -0x1c) = vtable.CObject.0;\n    *(unaff_EBP + -0x34) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 9;\n    fcn.0041fdbf();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 2236
    },
    "0042c12a": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0042c12a(uint arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint lprc;\n    \n    *(in_ECX + 100) = arg_ch;\n    if (arg_10h == 0xe800) {\n        *(in_ECX + 100) = arg_ch | 8;\n    }\n    iVar1 = fcn.0042d07c();\n    if ((*(iVar1 + 0x18) & 0x10) == 0) {\n        fcn.0041abf5(0x10);\n    }\n    (*_sym.imp.USER32.dll_SetRectEmpty)(&lprc);\n    iVar1 = fcn.00418831(\"ToolbarWindow32\", 0, CONCAT31(arg_ch >> 8 & 0xffff00, 0x4e), &lprc, arg_8h, arg_10h, 0);\n    return iVar1 != 0;\n}\n",
        "token_count": 233
    },
    "0042c21d": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0042c21d(int32_t hgdiobj)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t *in_ECX;\n    uint lpvObject;\n    int32_t var_30h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.GDI32.dll_GetObjectA)(hgdiobj, 0x18, &lpvObject);\n    if (in_ECX[0x20] == 0) {\n        var_8h = 0;\n        var_4h = hgdiobj;\n        iVar1 = (**(*in_ECX + 0xa8))(0x413, var_30h / in_ECX[0x22], &var_8h);\n        uVar2 = iVar1 == 0;\n    }\n    else {\n        var_ch = var_30h / in_ECX[0x22];\n        var_1ch = 0;\n        var_14h = 0;\n        var_10h = hgdiobj;\n        var_18h = in_ECX[0x20];\n        uVar2 = (**(*in_ECX + 0xa8))(0x42e, 0, &var_1ch);\n    }\n    if (uVar2 != 0) {\n        fcn.004203f6(in_ECX + 0x20);\n        in_ECX[0x20] = hgdiobj;\n    }\n    return uVar2;\n}\n",
        "token_count": 375
    },
    "0040fd00": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040fd00(int32_t param_1)\n\n{\n    *(param_1 + 0x1c) = param_1 + 0x14;\n    *(param_1 + 0x20) = param_1 + 0x18;\n    *(param_1 + 0xc) = param_1 + 4;\n    *(param_1 + 0x2c) = param_1 + 0x24;\n    *(param_1 + 0x10) = param_1 + 8;\n    *(param_1 + 0x30) = param_1 + 0x28;\n    *(param_1 + 8) = 0;\n    **(param_1 + 0x20) = 0;\n    **(param_1 + 0x30) = 0;\n    **(param_1 + 0xc) = 0;\n    **(param_1 + 0x1c) = 0;\n    **(param_1 + 0x2c) = 0;\n    return;\n}\n",
        "token_count": 240
    },
    "0041562d": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041562d(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *(param_1 + 0xc) = 1;\n    iVar1 = fcn.0041c547(*(param_1 + 0x94), param_1 + 0x14, 0x80);\n    *(param_1 + 0x10) = iVar1 != 0;\n    return;\n}\n",
        "token_count": 98
    },
    "00415cf9": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00415cf9(code **param_1, code *param_2)\n\n{\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    param_1[5] = NULL;\n    *param_1 = vtable.CPtrList.0;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 105
    },
    "00415d38": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00415d38(int32_t param_1)\n\n{\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 8) = 0;\n    *(param_1 + 4) = 0;\n    fcn.00416140();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 101
    },
    "00416156": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00416156(code **param_1, code *param_2)\n\n{\n    param_1[1] = NULL;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[5] = NULL;\n    *param_1 = vtable.CMapPtrToPtr.0;\n    param_1[2] = 0x11;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 109
    },
    "004161df": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004161df(int32_t param_1)\n\n{\n    if (*(param_1 + 4) != 0) {\n        fcn.004166cf(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    fcn.00416140();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 119
    },
    "00416409": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00416409(code **param_1, code *param_2)\n\n{\n    param_1[1] = NULL;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[5] = NULL;\n    *param_1 = vtable.CMapStringToPtr.0;\n    param_1[2] = 0x11;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 109
    },
    "00416492": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00416492(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    \n    if (*(param_1 + 4) != 0) {\n        uVar1 = 0;\n        if (*(param_1 + 8) != 0) {\n            do {\n                for (puVar2 = *(*(param_1 + 4) + uVar1 * 4); puVar2 != NULL; puVar2 = *puVar2) {\n                    fcn.0041b20c();\n                }\n                uVar1 = uVar1 + 1;\n            } while (uVar1 < *(param_1 + 8));\n        }\n        fcn.004166cf(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    fcn.00416140();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 243
    },
    "004166da": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004166da(code **param_1)\n\n{\n    *param_1 = vtable.CCmdTarget.0;\n    param_1[1] = 0x1;\n    param_1[2] = NULL;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[5] = 0x1;\n    param_1[6] = NULL;\n    return;\n}\n",
        "token_count": 101
    },
    "00416a51": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00416a51(code **param_1)\n\n{\n    *param_1 = vtable.CCmdUI.0;\n    param_1[8] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    param_1[9] = NULL;\n    param_1[4] = NULL;\n    param_1[3] = NULL;\n    param_1[5] = NULL;\n    param_1[7] = NULL;\n    param_1[6] = NULL;\n    return;\n}\n",
        "token_count": 126
    },
    "00423866": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "parse PE header/27dc37a2d08e4034aa7bcaa8b888b251"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint * fcn.00423866(void)\n\n{\n    uint uVar1;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00415ea0();\n    extraout_ECX[6] = 0xffffffff;\n    extraout_ECX[5] = 0xffffffff;\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = 0;\n    extraout_ECX[8] = 0;\n    extraout_ECX[3] = 0;\n    extraout_ECX[2] = 0;\n    extraout_ECX[1] = 0;\n    extraout_ECX[4] = 0;\n    extraout_ECX[0x16] = 0;\n    extraout_ECX[7] = 0x7fff;\n    extraout_ECX[9] = 0;\n    (*_sym.imp.USER32.dll_SetRectEmpty)(extraout_ECX + 10);\n    uVar1 = *(unaff_EBP + -0xc);\n    extraout_ECX[0xf] = 0;\n    extraout_ECX[0xe] = 0;\n    extraout_ECX[0x10] = 0;\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 372
    },
    "0042bb22": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\ncode ** fcn.0042bb22(void)\n\n{\n    uint uVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CObject.0;\n    *(unaff_EBP + -4) = 0;\n    fcn.0041b0c1();\n    *(unaff_EBP + -4) = 1;\n    fcn.0041b0c1();\n    *(unaff_EBP + -4) = 2;\n    fcn.0041b0c1();\n    *(unaff_EBP + -4) = 3;\n    fcn.0041b0c1();\n    extraout_ECX[2] = NULL;\n    extraout_ECX[3] = NULL;\n    uVar1 = *(unaff_EBP + -0xc);\n    extraout_ECX[4] = NULL;\n    *extraout_ECX = vtable.CCommandLineInfo.0;\n    extraout_ECX[1] = 0x1;\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 315
    },
    "0040c520": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nuint fcn.0040c520(uint param_1, uint param_2, uint param_3)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    \n    iVar4 = 0;\n    if (*0x440908 != NULL) {\ncode_r0x0040c570:\n        if (*0x44090c != NULL) {\n            iVar4 = (**0x44090c)();\n        }\n        if ((iVar4 != 0) && (*0x440910 != NULL)) {\n            iVar4 = (**0x440910)(iVar4);\n        }\n        uVar3 = (**0x440908)(iVar4, param_1, param_2, param_3);\n        return uVar3;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"user32.dll\");\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar2 != 0) {\n        *0x440908 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"MessageBoxA\");\n        if (*0x440908 != NULL) {\n            *0x44090c = (*pcVar1)(iVar2, \"GetActiveWindow\");\n            *0x440910 = (*pcVar1)(iVar2, \"GetLastActivePopup\");\n            goto code_r0x0040c570;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 317
    },
    "00420dc1": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid fcn.00420dc1(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint unaff_EDI;\n    int32_t unaff_retaddr;\n    int32_t iVar3;\n    \n    iVar1 = fcn.00419b70(0);\n    iVar3 = 0;\n    fcn.00419b40(0, unaff_retaddr, 1);\n    iVar2 = fcn.00419b70(1);\n    fcn.00419b40(1, unaff_EDI, 1);\n    fcn.00419c5b(iVar1 - iVar3, iVar2 - unaff_retaddr, 0, 0);\n    return;\n}\n",
        "token_count": 157
    },
    "00425f6c": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00425f6c(int32_t *param_1, uint *param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *unaff_EBP;\n    int32_t *unaff_EDI;\n    \n    iVar2 = fcn.00425eeb(param_2);\n    if (*param_1 != 0) {\n        *param_2 = 0xffffffff;\n    }\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    iVar5 = 0;\n    while( true ) {\n        uVar3 = (*pcVar1)(iVar2, 0x87, 0, 0);\n        if ((uVar3 & 0x40) != 0) {\n            if (*unaff_EDI == 0) {\n                (*pcVar1)(iVar2, 0xf1, iVar5 == *unaff_EBP, 0);\n            }\n            else {\n                iVar4 = (*pcVar1)(iVar2, 0xf0, 0, 0);\n                if (iVar4 != 0) {\n                    *unaff_EBP = iVar5;\n                }\n            }\n            iVar5 = iVar5 + 1;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2);\n        if (iVar2 == 0) break;\n        uVar3 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar2, 0xfffffff0);\n        if ((uVar3 & 0x20000) != 0) {\n            return;\n        }\n    }\n    return;\n}\n",
        "token_count": 377
    },
    "0042bbad": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042bbad(void)\n\n{\n    uint uVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CCommandLineInfo.0;\n    *(unaff_EBP + -4) = 3;\n    fcn.0041b20c();\n    *(unaff_EBP + -4) = 2;\n    fcn.0041b20c();\n    *(unaff_EBP + -4) = 1;\n    fcn.0041b20c();\n    *(unaff_EBP + -4) = 0;\n    fcn.0041b20c();\n    uVar1 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.CObject.0;\n    *in_FS_OFFSET = uVar1;\n    return;\n}\n",
        "token_count": 259
    },
    "0042cd5f": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042cd5f(code **param_1, uchar param_2)\n\n{\n    param_1[7] = NULL;\n    param_1[8] = NULL;\n    param_1[9] = NULL;\n    param_1[10] = NULL;\n    param_1[0x40f] = NULL;\n    param_1[0x410] = NULL;\n    param_1[0x413] = 0xffffffff;\n    param_1[0x414] = NULL;\n    param_1[0x419] = NULL;\n    param_1[0x41a] = NULL;\n    *param_1 = vtable.AFX_MODULE_STATE.0;\n    param_1[10] = 0x1c;\n    param_1[8] = 0x14;\n    *(param_1 + 6) = 0;\n    *(param_1 + 5) = param_2;\n    param_1[0xc] = 0x1;\n    param_1[0x410] = 0x18;\n    return;\n}\n",
        "token_count": 243
    },
    "0040a700": {
        "rules": [
            "inject pe/d5f0df8b10fc4abbbb9974951b6b6eb4"
        ],
        "decompiled_code": "\nint32_t fcn.0040a700(uint32_t param_1, int32_t **param_2, uint32_t *param_3)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    \n    piVar1 = 0x43b480;\n    while ((param_1 < piVar1[4] || param_1 == piVar1[4] || (piVar1[5] <= param_1))) {\n        piVar1 = *piVar1;\n        if (piVar1 == 0x43b480) {\n            return 0;\n        }\n    }\n    if ((param_1 & 0xf) != 0) {\n        return 0;\n    }\n    if ((param_1 & 0xfff) < 0x100) {\n        return 0;\n    }\n    *param_2 = piVar1;\n    uVar2 = param_1 & 0xfffff000;\n    *param_3 = uVar2;\n    return ((param_1 - uVar2) + -0x100 >> 4) + 8 + uVar2;\n}\n",
        "token_count": 249
    },
    "0041be75": {
        "rules": [
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0041be75(uint hKey, uint arg_ch)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    bool bVar5;\n    uint lpType;\n    uint lpcbData;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.ADVAPI32.dll_RegOpenKeyA;\n    bVar5 = false;\n    var_8h = 0;\n    iVar3 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(0x80000000, \"CLSID\", &var_8h);\n    if (iVar3 == 0) {\n        var_4h = 0;\n        iVar3 = (*pcVar1)(var_8h, hKey, &var_4h);\n        pcVar2 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n        if (iVar3 == 0) {\n            hKey = 0;\n            iVar3 = (*pcVar1)(var_4h, \"InProcServer32\", &hKey);\n            if (iVar3 == 0) {\n                uVar4 = fcn.0041b4d5(0x104);\n                lpcbData = 0x104;\n                iVar3 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, 0x433498, 0, &lpType, uVar4, &lpcbData);\n                fcn.0041b524(0xffffffff);\n                bVar5 = iVar3 == 0;\n                (*pcVar2)(hKey);\n            }\n            (*pcVar2)(var_4h);\n        }\n        (*pcVar2)(var_8h);\n    }\n    return bVar5;\n}\n",
        "token_count": 397
    },
    "0042ca25": {
        "rules": [
            "create or open registry key"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0042ca25(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = 0;\n    var_4h = 0;\n    var_8h = 0;\n    iVar2 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(0x80000001, \"Software\", 0, 0x2001f, &var_4h);\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegCreateKeyExA;\n    if (iVar2 == 0) {\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyExA)\n                          (var_4h, *(param_1 + 0x7c), 0, 0, 0, 0x2001f, 0, &var_8h, &var_10h);\n        if (iVar2 == 0) {\n            (*pcVar1)(var_8h, *(param_1 + 0x90), 0, 0, 0, 0x2001f, 0, &var_ch, &var_10h);\n        }\n    }\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n    if (var_4h != 0) {\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n    }\n    if (var_8h != 0) {\n        (*pcVar1)(var_8h);\n    }\n    return var_ch;\n}\n",
        "token_count": 382
    },
    "0042cab9": {
        "rules": [
            "create or open registry key"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042cab9(uint lpSubKey)\n\n{\n    int32_t iVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    iVar1 = fcn.0042ca25();\n    if (iVar1 == 0) {\n        var_4h = 0;\n    }\n    else {\n        (*_sym.imp.ADVAPI32.dll_RegCreateKeyExA)(iVar1, lpSubKey, 0, 0, 0, 0x2001f, 0, &var_4h, &var_8h);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n    }\n    return var_4h;\n}\n",
        "token_count": 165
    },
    "00423f78": {
        "rules": [
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** fcn.00423f78(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CObject.0;\n    *(unaff_EBP + -4) = 0;\n    fcn.00415ea0();\n    extraout_ECX[6] = NULL;\n    extraout_ECX[8] = NULL;\n    extraout_ECX[7] = NULL;\n    pcVar2 = _sym.imp.USER32.dll_GetSystemMetrics;\n    *(unaff_EBP + -4) = 1;\n    *extraout_ECX = vtable.CDockState.0;\n    extraout_ECX[0x11] = 0x2;\n    pcVar1 = (*pcVar2)(0);\n    extraout_ECX[9] = pcVar1;\n    pcVar2 = (*pcVar2)(1);\n    extraout_ECX[10] = pcVar2;\n    extraout_ECX[0xb] = extraout_ECX[7];\n    extraout_ECX[0xc] = extraout_ECX[8];\n    extraout_ECX[0xd] = extraout_ECX[9];\n    extraout_ECX[0xe] = extraout_ECX[10];\n    pcVar2 = _sym.imp.USER32.dll_GetSystemMetrics;\n    iVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0xb);\n    extraout_ECX[0xd] = extraout_ECX[0xd] + -iVar3;\n    iVar3 = (*pcVar2)(0xc);\n    extraout_ECX[0xe] = extraout_ECX[0xe] + -iVar3;\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 514
    },
    "0042ce91": {
        "rules": [
            "PEB access",
            "access PEB ldr_data",
            "check for PEB NtGlobalFlag flag/02e6ad6983154968a9ea3bb4adc24b9d"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\ncode ** fcn.0042ce91(void)\n\n{\n    uint uVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CNoTrackObject.0;\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[2] = NULL;\n    extraout_ECX[3] = NULL;\n    fcn.00416156(10);\n    *(unaff_EBP + -4) = 1;\n    fcn.00416156(10);\n    *(unaff_EBP + -4) = 2;\n    fcn.00415cf9(10);\n    uVar1 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.AFX_MODULE_THREAD_STATE.0;\n    extraout_ECX[3] = 0x54;\n    extraout_ECX[10] = 0x416677;\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 326
    },
    "0040413c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040413c(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t *piVar4;\n    int32_t in_ECX;\n    uint32_t arg_8h_00;\n    uint var_4h;\n    \n    arg_8h_00 = 0;\n    *(in_ECX + 0x9c) = arg_8h;\n    iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x418, 0, 0);\n    if (0 < iVar2) {\n        do {\n            uVar3 = fcn.004219a9(arg_8h_00);\n            uVar1 = arg_8h_00 + 1;\n            if (uVar1 % arg_8h == 0) {\n                uVar3 = uVar3 | 0x200000;\n            }\n            else {\n                uVar3 = uVar3 & 0xffdfffff;\n            }\n            fcn.004219cc(arg_8h_00, uVar3);\n            arg_8h_00 = uVar1;\n        } while (uVar1 < iVar2);\n    }\n    (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), 0, 1);\n    piVar4 = fcn.004197f4();\n    (**(*piVar4 + 0xd0))(1);\n    return;\n}\n",
        "token_count": 348
    },
    "00405228": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00405228(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar auStack16 [4];\n    int32_t iStack12;\n    int32_t *piStack8;\n    \n    piStack8 = 0x40522f;\n    iVar1 = fcn.004051a2(0);\n    if (iVar1 == 0) {\n        return;\n    }\n    iStack12 = -(*(iVar1 + 0x28) != 0);\n    while (iStack12 != 0) {\n        fcn.00416397(&stack0xfffffff4, &stack0xfffffff0, &stack0xfffffff8);\n        puVar2 = piStack8 + *(iVar1 + 0x3c);\n        *puVar2 = 0;\n        if (*(iVar1 + 0x40) == 2) {\n            puVar2[1] = 0;\n        }\n        if (piStack8 != NULL) {\n            (**(*piStack8 + 4))(1);\n        }\n    }\n    fcn.004161df();\n    return;\n}\n",
        "token_count": 245
    },
    "004074a0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.004074a0(uint param_1, uint param_2, int32_t param_3, code *param_4)\n\n{\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_18h;\n    int32_t var_10h;\n    code *var_14h;\n    uint var_10h_2;\n    code *pcStack16;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x434a88;\n    pcStack16 = fcn.0040a148;\n    var_10h_2 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_10h_2;\n    var_4h = 0;\n    while( true ) {\n        var_10h = var_10h + -1;\n        if (var_10h < 0) break;\n        (*var_14h)();\n    }\n    *in_FS_OFFSET = var_10h_2;\n    return;\n}\n",
        "token_count": 221
    },
    "00413180": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00413180(int32_t param_1)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    \n    fcn.00412ab0();\n    uVar3 = *(param_1 + 0x24);\n    while (uVar3 < 8) {\n        iVar2 = *(*(param_1 + 0x24) * 4 + 0x440d98);\n        if ((iVar2 == 0) || (iVar2 == param_1)) break;\n        uVar3 = *(param_1 + 0x24) + 1;\n        *(param_1 + 0x24) = uVar3;\n    }\n    *(*(param_1 + 0x24) * 4 + 0x440d98) = param_1;\n    pcVar1 = *(param_1 + 0x24) + 0x440dc0;\n    *pcVar1 = *pcVar1 + '\\x01';\n    fcn.00412b70();\n    return;\n}\n",
        "token_count": 238
    },
    "00415e7d": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00415e7d(int32_t param_1, int32_t param_2, uint *param_3)\n\n{\n    if (param_3 != NULL) goto code_r0x00415e8a;\n    param_3 = *(param_1 + 4);\n    while( true ) {\n        if (param_3 == NULL) {\n            return NULL;\n        }\n        if (param_3[2] == param_2) break;\ncode_r0x00415e8a:\n        param_3 = *param_3;\n    }\n    return param_3;\n}\n",
        "token_count": 135
    },
    "00416140": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00416140(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    \n    if (param_1 != NULL) {\n        do {\n            piVar1 = *param_1;\n            fcn.004166cf(param_1);\n            param_1 = piVar1;\n        } while (piVar1 != NULL);\n    }\n    return;\n}\n",
        "token_count": 88
    },
    "004162a0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.004162a0(int32_t param_1, uint32_t param_2, uint32_t *param_3)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    \n    uVar2 = (param_2 >> 4) % *(param_1 + 8);\n    *param_3 = uVar2;\n    if (*(param_1 + 4) != 0) {\n        for (puVar1 = *(*(param_1 + 4) + uVar2 * 4); puVar1 != NULL; puVar1 = *puVar1) {\n            if (puVar1[1] == param_2) {\n                return puVar1;\n            }\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 171
    },
    "004162d2": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.004162d2(int32_t param_1, uint32_t param_2)\n\n{\n    uint *puVar1;\n    \n    if (*(param_1 + 4) != 0) {\n        for (puVar1 = *(*(param_1 + 4) + ((param_2 >> 4) % *(param_1 + 8)) * 4); puVar1 != NULL; puVar1 = *puVar1) {\n            if (puVar1[1] == param_2) {\n                return puVar1[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 139
    },
    "00416355": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00416355(int32_t param_1, uint32_t param_2)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint *puVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    \n    iVar1 = *(param_1 + 4);\n    if (iVar1 != 0) {\n        uVar4 = (param_2 >> 4) % *(param_1 + 8);\n        puVar2 = *(iVar1 + uVar4 * 4);\n        puVar5 = iVar1 + uVar4 * 4;\n        while (puVar3 = puVar2,  puVar3 != NULL) {\n            if (puVar3[1] == param_2) {\n                *puVar5 = *puVar3;\n                fcn.00416287(puVar3);\n                return 1;\n            }\n            puVar5 = puVar3;\n            puVar2 = *puVar3;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 231
    },
    "00416693": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.00416693(uint param_1)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    \n    pcVar2 = *0x431140;\n    while( true ) {\n        iVar1 = fcn.00405e40(param_1);\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n        if (pcVar2 == *0x431140) {\n            iVar1 = fcn.0042d0a2();\n            pcVar2 = *(iVar1 + 0x28);\n        }\n        if (pcVar2 == NULL) break;\n        iVar1 = (*pcVar2)(param_1);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 173
    },
    "00418118": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00418118(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar auStack16 [4];\n    int32_t iStack12;\n    int32_t *piStack8;\n    \n    piStack8 = 0x41811f;\n    iVar1 = fcn.0041812c(0);\n    if (iVar1 == 0) {\n        return;\n    }\n    iStack12 = -(*(iVar1 + 0x28) != 0);\n    while (iStack12 != 0) {\n        fcn.00416397(&stack0xfffffff4, &stack0xfffffff0, &stack0xfffffff8);\n        puVar2 = piStack8 + *(iVar1 + 0x3c);\n        *puVar2 = 0;\n        if (*(iVar1 + 0x40) == 2) {\n            puVar2[1] = 0;\n        }\n        if (piStack8 != NULL) {\n            (**(*piStack8 + 4))(1);\n        }\n    }\n    fcn.004161df();\n    return;\n}\n",
        "token_count": 245
    },
    "00418de5": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.00418de5(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    iVar1 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(param_1 + 4));\n    iVar4 = 0;\n    if (0 < iVar1) {\n        do {\n            uVar2 = (*_sym.imp.USER32.dll_GetSubMenu)(*(param_1 + 4), iVar4);\n            iVar3 = fcn.0041b68e(uVar2);\n            if (iVar3 == 0) {\n                iVar3 = (*_sym.imp.USER32.dll_GetMenuItemID)(*(param_1 + 4), iVar4);\n                if (iVar3 == param_1) {\n                    iVar1 = fcn.0041b6a4(*(param_1 + 4));\n                    return iVar1;\n                }\n            }\n            else {\n                iVar3 = fcn.00418de5(iVar3, param_1);\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < iVar1);\n    }\n    return 0;\n}\n",
        "token_count": 277
    },
    "004197f4": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.004197f4(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetParent;\n    if (param_1 == 0) {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = *(param_1 + 0x1c);\n    }\n    if (iVar2 != 0) {\n        iVar2 = *(param_1 + 0x1c);\n        while( true ) {\n            uVar3 = (*pcVar1)(iVar2);\n            piVar4 = fcn.0041819c(uVar3);\n            if (piVar4 == NULL) break;\n            iVar2 = (**(*piVar4 + 0xb8))();\n            if (iVar2 != 0) {\n                return piVar4;\n            }\n            iVar2 = piVar4[7];\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 230
    },
    "0041987d": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041987d(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    if (param_1 == 0) {\n        iVar1 = 0;\n    }\n    else {\n        iVar1 = *(param_1 + 0x1c);\n    }\n    if (iVar1 != 0) {\n        iVar1 = *(param_1 + 0x1c);\n        do {\n            iVar2 = iVar1;\n            iVar1 = fcn.00419838(iVar2);\n        } while (iVar1 != 0);\n        fcn.0041819c(iVar2);\n        return;\n    }\n    return;\n}\n",
        "token_count": 154
    },
    "004198a9": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004198a9(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongA;\n    if (param_1 == 0) {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = *(param_1 + 0x1c);\n    }\n    if (iVar2 != 0) {\n        iVar2 = *(param_1 + 0x1c);\n        uVar3 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar2, 0xfffffff0);\n        while ((uVar3 & 0x40000000) != 0) {\n            iVar4 = (*_sym.imp.USER32.dll_GetParent)(iVar2);\n            if (iVar4 == 0) break;\n            uVar3 = (*pcVar1)(iVar4, 0xfffffff0);\n            iVar2 = iVar4;\n        }\n        fcn.0041819c(iVar2);\n    }\n    return;\n}\n",
        "token_count": 249
    },
    "00419961": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.00419961(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    if (param_1 == NULL) {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = param_1[7];\n    }\n    if (iVar2 != 0) {\n        iVar2 = (**(*param_1 + 0xb8))();\n        piVar3 = param_1;\n        if (iVar2 == 0) {\n            param_1 = fcn.004197f4();\n            piVar3 = param_1;\n        }\n        while (piVar1 = piVar3,  piVar1 != NULL) {\n            piVar3 = fcn.004197f4();\n            param_1 = piVar1;\n        }\n        return param_1;\n    }\n    return NULL;\n}\n",
        "token_count": 207
    },
    "004199a5": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.004199a5(int32_t noname_0, int32_t *noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    bool bVar7;\n    \n    if (noname_0 == 0) {\n        iVar6 = 0;\n    }\n    else {\n        iVar6 = *(noname_0 + 0x1c);\n    }\n    bVar7 = iVar6 == 0;\n    if (bVar7) {\n        iVar3 = fcn.00404425();\n        if (iVar3 != 0) {\n            iVar6 = *(iVar3 + 0x1c);\n        }\n        bVar7 = iVar6 == 0;\n    }\n    pcVar2 = _sym.imp.USER32.dll_GetParent;\n    iVar3 = iVar6;\n    iVar5 = iVar6;\n    if (!bVar7) {\n        do {\n            uVar4 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar6, 0xfffffff0);\n            iVar3 = iVar6;\n            iVar5 = iVar6;\n            if ((uVar4 & 0x40000000) == 0) break;\n            iVar6 = (*pcVar2)(iVar6);\n            iVar3 = iVar6;\n            iVar5 = iVar6;\n        } while (iVar6 != 0);\n    }\n    while (iVar1 = iVar3,  iVar1 != 0) {\n        iVar3 = (*pcVar2)(iVar1);\n        iVar6 = iVar1;\n    }\n    if ((noname_0 == 0) && (iVar5 != 0)) {\n        iVar5 = (*_sym.imp.USER32.dll_GetLastActivePopup)(iVar5);\n    }\n    if (noname_1 != NULL) {\n        if (((iVar6 == 0) || (iVar3 = (*_sym.imp.USER32.dll_IsWindowEnabled)(iVar6),  iVar3 == 0)) || (iVar6 == iVar5))\n        {\n            *noname_1 = 0;\n        }\n        else {\n            *noname_1 = iVar6;\n            (*_sym.imp.USER32.dll_EnableWindow)(iVar6, 0);\n        }\n    }\n    fcn.0041819c(iVar5);\n    return;\n}\n",
        "token_count": 548
    },
    "00419a45": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00419a45(uint hDlg, uint nIDDlgItem, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.USER32.dll_GetDlgItem)(hDlg, nIDDlgItem);\n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    if (iVar2 != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_GetTopWindow)(iVar2);\n        if ((iVar3 != 0) && (iVar3 = fcn.00419a45(iVar2, nIDDlgItem, arg_10h),  iVar3 != 0)) {\n            return iVar3;\n        }\n        if (arg_10h == 0) {\n            iVar2 = fcn.0041819c();\n            return iVar2;\n        }\n        iVar2 = fcn.004181c4(iVar2);\n        if (iVar2 != 0) {\n            return iVar2;\n        }\n    }\n    iVar2 = (*pcVar1)(hDlg);\n    while( true ) {\n        if (iVar2 == 0) {\n            return 0;\n        }\n        iVar3 = fcn.00419a45(iVar2, nIDDlgItem, arg_10h);\n        if (iVar3 != 0) break;\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2);\n    }\n    return iVar3;\n}\n",
        "token_count": 333
    },
    "0041a4d4": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0041a4d4(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint lpMsg;\n    \n    pcVar1 = _sym.imp.USER32.dll_PeekMessageA;\n    while( true ) {\n        iVar2 = (*pcVar1)(&lpMsg, 0, 0x121, 0x121, 1);\n        if (iVar2 == 0) break;\n        (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n    }\n    fcn.004180f1();\n    return;\n}\n",
        "token_count": 129
    },
    "0041b60a": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0041b60a(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar auStack16 [4];\n    int32_t iStack12;\n    int32_t *piStack8;\n    \n    piStack8 = 0x41b611;\n    iVar1 = fcn.0041b61e(0);\n    if (iVar1 == 0) {\n        return;\n    }\n    iStack12 = -(*(iVar1 + 0x28) != 0);\n    while (iStack12 != 0) {\n        fcn.00416397(&stack0xfffffff4, &stack0xfffffff0, &stack0xfffffff8);\n        puVar2 = piStack8 + *(iVar1 + 0x3c);\n        *puVar2 = 0;\n        if (*(iVar1 + 0x40) == 2) {\n            puVar2[1] = 0;\n        }\n        if (piStack8 != NULL) {\n            (**(*piStack8 + 4))(1);\n        }\n    }\n    fcn.004161df();\n    return;\n}\n",
        "token_count": 248
    },
    "0041b7dd": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0041b7dd(int32_t param_1, int32_t param_2)\n\n{\n    while( true ) {\n        if (param_1 == 0) {\n            return 0;\n        }\n        if (param_1 == param_2) break;\n        param_1 = *(param_1 + 0x10);\n    }\n    return 1;\n}\n",
        "token_count": 88
    },
    "0041f403": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0041f403(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uchar auStack16 [4];\n    int32_t iStack12;\n    int32_t *piStack8;\n    \n    piStack8 = 0x41f40a;\n    iVar2 = fcn.0041f417(0);\n    if (iVar2 == 0) {\n        return;\n    }\n    iStack12 = -(*(iVar2 + 0x28) != 0);\n    while (iStack12 != 0) {\n        fcn.00416397(&stack0xfffffff4, &stack0xfffffff0, &stack0xfffffff8);\n        puVar1 = piStack8 + *(iVar2 + 0x3c);\n        *puVar1 = 0;\n        if (*(iVar2 + 0x40) == 2) {\n            puVar1[1] = 0;\n        }\n        if (piStack8 != NULL) {\n            (**(*piStack8 + 4))(1);\n        }\n    }\n    fcn.004161df();\n    return;\n}\n",
        "token_count": 247
    },
    "0041fcce": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0041fcce(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uchar auStack16 [4];\n    int32_t iStack12;\n    int32_t *piStack8;\n    \n    piStack8 = 0x41fcd5;\n    iVar2 = fcn.0041fce2(0);\n    if (iVar2 == 0) {\n        return;\n    }\n    iStack12 = -(*(iVar2 + 0x28) != 0);\n    while (iStack12 != 0) {\n        fcn.00416397(&stack0xfffffff4, &stack0xfffffff0, &stack0xfffffff8);\n        puVar1 = piStack8 + *(iVar2 + 0x3c);\n        *puVar1 = 0;\n        if (*(iVar2 + 0x40) == 2) {\n            puVar1[1] = 0;\n        }\n        if (piStack8 != NULL) {\n            (**(*piStack8 + 4))(1);\n        }\n    }\n    fcn.004161df();\n    return;\n}\n",
        "token_count": 247
    },
    "00420329": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00420329(int32_t hWnd, uint lpPoint, uint arg_10h)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint lpRect;\n    \n    (*_sym.imp.USER32.dll_ClientToScreen)(hWnd, &lpPoint);\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    uVar5 = 5;\n    do {\n        hWnd = (*pcVar1)(hWnd, uVar5);\n        if (hWnd == 0) {\n            return 0;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(hWnd);\n        if ((iVar2 != -1) &&\n           (uVar3 = (*_sym.imp.USER32.dll_GetWindowLongA)(hWnd, 0xfffffff0),  (uVar3 & 0x10000000) != 0)) {\n            (*_sym.imp.USER32.dll_GetWindowRect)(hWnd, &lpRect);\n            iVar4 = (*_sym.imp.USER32.dll_PtInRect)(&lpRect, lpPoint, arg_10h);\n            if (iVar4 != 0) {\n                return hWnd;\n            }\n        }\n        uVar5 = 2;\n    } while( true );\n}\n",
        "token_count": 299
    },
    "00424015": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00424015(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDockState.0;\n    iVar3 = 0;\n    *(unaff_EBP + -4) = 1;\n    if (0 < extraout_ECX[3]) {\n        do {\n            iVar1 = *(extraout_ECX[2] + iVar3 * 4);\n            if (iVar1 != 0) {\n                fcn.00415ed3();\n                fcn.004166cf(iVar1);\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < extraout_ECX[3]);\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.00415ed3();\n    uVar2 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.CObject.0;\n    *in_FS_OFFSET = uVar2;\n    return;\n}\n",
        "token_count": 343
    },
    "00424333": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00424333(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    if (0 < *(param_1 + 0xc)) {\n        do {\n            iVar1 = *(*(param_1 + 8) + iVar2 * 4);\n            if (iVar1 != 0) {\n                fcn.0042436d();\n                fcn.004166cf(iVar1);\n            }\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < *(param_1 + 0xc));\n    }\n    fcn.00415f0a(0, 0xffffffff);\n    return;\n}\n",
        "token_count": 158
    },
    "00424ba3": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00424ba3(void)\n\n{\n    int32_t iVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t iVar2;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDockBar.0;\n    iVar2 = 0;\n    *(unaff_EBP + -4) = 1;\n    if (0 < extraout_ECX[0x21]) {\n        do {\n            iVar1 = fcn.004258b4();\n            if ((iVar1 != 0) && (*(iVar1 + 0x70) == extraout_ECX)) {\n                *(iVar1 + 0x70) = 0;\n            }\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < extraout_ECX[0x21]);\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.00415ed3();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004224f2();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 316
    },
    "00424c6f": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00424c6f(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = 0;\n    iVar3 = 0;\n    if (0 < *(param_1 + 0x84)) {\n        do {\n            iVar1 = fcn.004258b4();\n            if (iVar1 != 0) {\n                iVar2 = iVar2 + 1;\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < *(param_1 + 0x84));\n    }\n    return iVar2;\n}\n",
        "token_count": 146
    },
    "00425845": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00425845(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = 0;\n    if (0 < *(param_1 + 0x84)) {\n        do {\n            if ((iVar1 != param_3) && (*(*(param_1 + 0x80) + iVar1 * 4) == param_2)) {\n                return iVar1;\n            }\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < *(param_1 + 0x84));\n    }\n    return -1;\n}\n",
        "token_count": 146
    },
    "00425873": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00425873(int32_t param_1)\n\n{\n    int32_t arg_8h;\n    int32_t iVar1;\n    uint unaff_retaddr;\n    \n    iVar1 = 0;\n    if (0 < *(param_1 + 0x84)) {\n        do {\n            arg_8h = fcn.004258b4(iVar1);\n            if (arg_8h != 0) {\n                fcn.00429d3c();\n                fcn.00428f18(arg_8h, unaff_retaddr, 1);\n            }\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < *(param_1 + 0x84));\n    }\n    return;\n}\n",
        "token_count": 163
    },
    "00427a2f": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00427a2f(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    uint lpMsg;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetCapture;\n    iVar2 = (*_sym.imp.USER32.dll_GetCapture)();\n    if (iVar2 == 0) {\n        uVar3 = (*_sym.imp.USER32.dll_SetCapture)(*(*(param_1 + 0x68) + 0x1c));\n        fcn.0041819c(uVar3);\n        uVar3 = (*pcVar1)();\n        iVar2 = fcn.0041819c(uVar3);\n        if (iVar2 == *(param_1 + 0x68)) {\n            do {\n                uVar4 = 0;\n                uVar3 = 0;\n                iVar2 = (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0);\n                if (iVar2 == 0) {\n                    fcn.0042e28c(uVar4, var_14h);\n                    break;\n                }\n                if (var_18h == 0x100) {\n                    if (*(param_1 + 0x88) != 0) {\n                        fcn.004271bc(uVar3, 1, var_14h);\n                    }\n                    if (var_14h == 0x1b) break;\n                }\n                else if (var_18h == 0x101) {\n                    if (*(param_1 + 0x88) != 0) {\n                        fcn.004271bc(uVar3, 0, var_14h);\n                    }\n                }\n                else if (var_18h == 0x200) {\n                    if (*(param_1 + 0x88) == 0) {\n                        fcn.00427438(var_8h, var_4h);\n                    }\n                    else {\n                        fcn.00427140(var_8h, var_4h);\n                    }\n                }\n                else {\n                    if (var_18h == 0x202) {\n                        if (*(param_1 + 0x88) == 0) {\n                            fcn.00427534();\n                        }\n                        else {\n                            fcn.004271f0();\n                        }\n                        return 1;\n                    }\n                    if (var_18h == 0x204) break;\n                    (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n                }\n                uVar3 = (*pcVar1)();\n                iVar2 = fcn.0041819c(uVar3);\n            } while (iVar2 == *(param_1 + 0x68));\n        }\n        fcn.0042771e();\n    }\n    return 0;\n}\n",
        "token_count": 648
    },
    "00427fde": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.00427fde(int32_t param_1, int32_t param_2)\n\n{\n    do {\n        if (param_1 == param_2) {\n            return 1;\n        }\n        param_2 = fcn.00419838();\n    } while (param_2 != 0);\n    return 0;\n}\n",
        "token_count": 75
    },
    "0042819a": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004281f3)\n// WARNING: Removing unreachable block (ram,0x0042820d)\n// WARNING: Removing unreachable block (ram,0x00428203)\n\nvoid fcn.0042819a(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    \n    uVar3 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    iVar4 = (*_sym.imp.USER32.dll_GetWindow)(uVar3);\n    pcVar2 = _sym.imp.USER32.dll_ShowWindow;\n    for (; iVar4 != 0; iVar4 = (*pcVar1)(iVar4, 2)) {\n        iVar5 = fcn.004181c4(iVar4);\n        if ((((iVar5 != 0) && (*0x21 != iVar4)) && (iVar6 = fcn.00427fde(*0x21, iVar4),  iVar6 != 0)) &&\n           ((uVar7 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar4, 0xfffffff0),  (uVar7 & 0x18000000) == 0 &&\n            ((*(iVar5 + 0x24) & 2) != 0)))) {\n            (*pcVar2)(iVar4, 4);\n            *(iVar5 + 0x24) = *(iVar5 + 0x24) & 0xfffffffd;\n        }\n    }\n    return;\n}\n",
        "token_count": 366
    },
    "004282fa": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004282fa(int32_t param_1, uint32_t param_2)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    \n    uVar3 = fcn.0041ae7b();\n    iVar4 = param_1;\n    if ((uVar3 & 0x40000000) == 0) {\n        iVar4 = fcn.00419961();\n    }\n    pcVar2 = _sym.imp.USER32.dll_SendMessageA;\n    if ((param_2 & 0xc) != 0) {\n        iVar5 = fcn.0041afe3();\n        if ((((~param_2 & 8) == 0) || (iVar5 == 0)) || (iVar4 == param_1)) {\n            (*pcVar2)(*(iVar4 + 0x1c), 0x86, 0, 0);\n        }\n        else {\n            *(param_1 + 0x25) = *(param_1 + 0x25) | 2;\n            (*pcVar2)(*(iVar4 + 0x1c), 0x86, 1, 0);\n            *(param_1 + 0x25) = *(param_1 + 0x25) & 0xfd;\n        }\n    }\n    uVar7 = 5;\n    iVar5 = (*_sym.imp.USER32.dll_GetDesktopWindow)(5);\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    while (iVar5 = (*pcVar1)(iVar5, uVar7),  iVar5 != 0) {\n        iVar6 = fcn.00427fde(*(iVar4 + 0x1c), iVar5);\n        if (iVar6 != 0) {\n            (*pcVar2)(iVar5, 0x36d, param_2, 0);\n        }\n        uVar7 = 2;\n    }\n    return;\n}\n",
        "token_count": 459
    },
    "0042d077": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0042d077(void)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    *extraout_ECX = vtable.AFX_MODULE_STATE.0;\n    puVar1 = extraout_ECX[0x411];\n    *(unaff_EBP + -4) = 1;\n    if (puVar1 != NULL) {\n        (***puVar1)(1);\n    }\n    if (extraout_ECX[0x41b] != NULL) {\n        iVar3 = -(*(extraout_ECX[0x41b] + 0xc) != 0);\n        *(unaff_EBP + -0x14) = iVar3;\n        if (iVar3 != 0) {\n            do {\n                fcn.00416397();\n                if (*(unaff_EBP + -0x10) != extraout_ECX + 0x412) {\n                    fcn.004166cf(*(unaff_EBP + -0x10));\n                }\n            } while (*(unaff_EBP + -0x14) != 0);\n        }\n        if (extraout_ECX[0x41b] != NULL) {\n            (**(*extraout_ECX[0x41b] + 4))(1);\n        }\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.0042d901();\n    uVar2 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.CNoTrackObject.0;\n    *in_FS_OFFSET = uVar2;\n    return;\n}\n",
        "token_count": 401
    },
    "0042d48b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0042d48b(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = *param_1;\n    if (iVar2 == 0) {\n        return 0;\n    }\n    if (iVar2 == param_2) {\n        *param_1 = *(param_1[1] + param_2);\n    }\n    else {\n        if (iVar2 == 0) {\n            return 0;\n        }\n        do {\n            iVar1 = *(iVar2 + param_1[1]);\n            if (iVar1 == param_2) break;\n            iVar2 = iVar1;\n        } while (iVar1 != 0);\n        if (iVar2 == 0) {\n            return 0;\n        }\n        *(iVar2 + param_1[1]) = *(param_2 + param_1[1]);\n    }\n    return 1;\n}\n",
        "token_count": 215
    },
    "0042d65c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042d65c(int32_t arg_8h)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t in_ECX;\n    uint lpCriticalSection;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 0x1c);\n    for (iVar2 = *(in_ECX + 0x14); iVar2 != 0; iVar2 = *(iVar2 + 4)) {\n        if (arg_8h < *(iVar2 + 8)) {\n            puVar3 = *(*(iVar2 + 0xc) + arg_8h * 4);\n            if (puVar3 != NULL) {\n                (***puVar3)(1);\n            }\n            *(*(iVar2 + 0xc) + arg_8h * 4) = 0;\n        }\n    }\n    puVar1 = *(in_ECX + 0x10) + arg_8h * 8;\n    *puVar1 = *puVar1 & 0xfffffffe;\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 0x1c);\n    return;\n}\n",
        "token_count": 267
    },
    "0041bd3a": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0041bd3a(uint arg_8h, uint arg_ch, uint lpLibFileName)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    code *pcVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    uVar3 = *(unaff_EBP + 8);\n    puVar1 = *(unaff_EBP + 0x10);\n    *puVar1 = 0;\n    fcn.0041be06(unaff_EBP + -0x10, uVar3);\n    *(unaff_EBP + -4) = 0;\n    fcn.0041b0c1();\n    *(unaff_EBP + -4) = 1;\n    iVar2 = fcn.0041be75(*(unaff_EBP + -0x10), unaff_EBP + 0x10);\n    if (iVar2 != 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(*(unaff_EBP + 0x10));\n        if (iVar2 != 0) {\n            pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"DllGetClassObject\");\n            if (pcVar4 == NULL) {\n                *(unaff_EBP + -4) = 0;\n                fcn.0041b20c();\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.0041b20c();\n                uVar3 = 0x800401f9;\n            }\n            else {\n                uVar3 = (*pcVar4)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), puVar1);\n                *(unaff_EBP + -4) = 0;\n                fcn.0041b20c();\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.0041b20c();\n            }\n            goto code_r0x0041bdf6;\n        }\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.0041b20c();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041b20c();\n    uVar3 = 0x80040154;\ncode_r0x0041bdf6:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 621
    },
    "0041a85c": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\nuint fcn.0041a85c(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    \n    uVar3 = 0;\n    if (param_1 != 0) {\n        iVar2 = fcn.0042d07c();\n        uVar1 = *(iVar2 + 0xc);\n        iVar2 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar1, param_1, 0xf0);\n        if (iVar2 != 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar1, iVar2);\n            if (iVar2 == 0) {\n                return 0;\n            }\n            uVar3 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar2);\n        }\n    }\n    uVar3 = fcn.0041a8ac(uVar3);\n    return uVar3;\n}\n",
        "token_count": 209
    },
    "0042ccaf": {
        "rules": [
            "set application hook"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042ccaf(void)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    code *pcVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable._AFX_THREAD_STATE.0;\n    piVar1 = extraout_ECX[0x33];\n    *(unaff_EBP + -4) = 0;\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 0x60))();\n        if (extraout_ECX[0x33] != NULL) {\n            (**(*extraout_ECX[0x33] + 4))(1);\n        }\n    }\n    pcVar3 = _sym.imp.USER32.dll_UnhookWindowsHookEx;\n    if (extraout_ECX[0xc] != NULL) {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(extraout_ECX[0xc]);\n    }\n    if (extraout_ECX[0xb] != NULL) {\n        (*pcVar3)(extraout_ECX[0xb]);\n    }\n    if (extraout_ECX[3] != NULL) {\n        fcn.00405f10(extraout_ECX[3]);\n    }\n    uVar2 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.CNoTrackObject.0;\n    *in_FS_OFFSET = uVar2;\n    return;\n}\n",
        "token_count": 403
    },
    "00418bc5": {
        "rules": [
            "get graphical window text"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00418bc5(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if (*(param_1 + 0x38) == NULL) {\n        iVar1 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)(*(param_1 + 0x1c));\n        uVar2 = fcn.0041b54c(iVar1, iVar1 + 1);\n        (*_sym.imp.USER32.dll_GetWindowTextA)(*(param_1 + 0x1c), uVar2);\n        fcn.0041b524(0xffffffff);\n    }\n    else {\n        (**(**(param_1 + 0x38) + 0x90))(param_2);\n    }\n    return;\n}\n",
        "token_count": 178
    },
    "0041af3e": {
        "rules": [
            "get graphical window text"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041af3e(int32_t param_1, uint param_2, uint param_3)\n\n{\n    if (*(param_1 + 0x38) == NULL) {\n        (*_sym.imp.USER32.dll_GetWindowTextA)(*(param_1 + 0x1c), param_2, param_3);\n    }\n    else {\n        (**(**(param_1 + 0x38) + 0x8c))(param_2, param_3);\n    }\n    return;\n}\n",
        "token_count": 117
    },
    "0041bcaa": {
        "rules": [
            "move file"
        ],
        "decompiled_code": "\nvoid fcn.0041bcaa(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_MoveFileA)(param_1, param_2);\n    if (iVar1 == 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n        fcn.0041c5e6(uVar2);\n    }\n    return;\n}\n",
        "token_count": 106
    },
    "0041bccc": {
        "rules": [
            "delete file"
        ],
        "decompiled_code": "\nvoid fcn.0041bccc(uint param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_DeleteFileA)(param_1);\n    if (iVar1 == 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n        fcn.0041c5e6(uVar2);\n    }\n    return;\n}\n",
        "token_count": 97
    },
    "0042cb6b": {
        "rules": [
            "query or enumerate registry value",
            "read .ini file"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: hKey\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042cb6b(uint arg_8h, uint lpAppName, uint lpKeyName, uint lpDefault)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpReturnedString;\n    uint var_18h;\n    uint var_14h;\n    int32_t hKey;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004056b0();\n    fcn.00405820();\n    iVar2 = *(extraout_ECX + 0x7c);\n    *(unaff_EBP + -0x18) = 0;\n    if (iVar2 == 0) {\n        if (*(unaff_EBP + 0x14) == 0) {\n            *(unaff_EBP + 0x14) = 0x43ff58;\n        }\n        (*_sym.imp.KERNEL32.dll_GetPrivateProfileStringA)\n                  (*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), unaff_EBP + -0x1018, 0x1000, \n                   *(extraout_ECX + 0x90));\n        hKey = unaff_EBP + -0x1018;\n    }\n    else {\n        iVar2 = fcn.0042cab9(*(unaff_EBP + 0xc));\n        *(unaff_EBP + -0x10) = iVar2;\n        if (iVar2 != 0) {\n            fcn.0041b0c1();\n            pcVar1 = _sym.imp.ADVAPI32.dll_RegQueryValueExA;\n            *(unaff_EBP + -4) = 0;\n            iVar2 = (*pcVar1)(*(unaff_EBP + -0x10), *(unaff_EBP + 0x10), 0, unaff_EBP + -0x18, 0, unaff_EBP + -0x14);\n            if (iVar2 == 0) {\n                uVar3 = fcn.0041b4d5(*(unaff_EBP + -0x14), unaff_EBP + -0x14);\n                iVar2 = (*pcVar1)(*(unaff_EBP + -0x10), *(unaff_EBP + 0x10), 0, unaff_EBP + -0x18, uVar3);\n                fcn.0041b524(0xffffffff);\n            }\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(*(unaff_EBP + -0x10));\n            if (iVar2 == 0) {\n                fcn.0041b0d1(unaff_EBP + 0xc);\n            }\n            else {\n                fcn.0041b27a(*(unaff_EBP + 0x14));\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0041b20c();\n            goto code_r0x0042cc69;\n        }\n        hKey = *(unaff_EBP + 0x14);\n    }\n    fcn.0041b27a(hKey);\ncode_r0x0042cc69:\n    uVar3 = *(unaff_EBP + 8);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 838
    }
}