{
    "00401000": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401000(uint arg_8h, int32_t arg_ch, uint arg_10h, int32_t arg_14h)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint var_5ch;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t var_10h;\n    uint var_ch;\n    uint32_t var_8h;\n    \n    // [00] -r-x section size 28672 named .text\n    iVar3 = *0x424734;\n    if (arg_ch == 0xf) {\n        uVar4 = (*_sym.imp.USER32.dll_BeginPaint)(arg_8h, &var_5ch);\n        var_ch = 0;\n        (*_sym.imp.USER32.dll_GetClientRect)(arg_8h, &var_1ch);\n        iVar5 = var_10h;\n        pcVar2 = _sym.imp.GDI32.dll_DeleteObject;\n        var_10h = 0;\n        for (; var_18h < iVar5; var_18h = var_18h + 4) {\n            iVar7 = iVar5 - var_18h;\n            var_8h = CONCAT11((*(iVar3 + 0x52) * iVar7 + *(iVar3 + 0x56) * var_18h) / iVar5, \n                              (*(iVar3 + 0x51) * iVar7 + *(iVar3 + 0x55) * var_18h) / iVar5) << 8 |\n                     (*(iVar3 + 0x50) * iVar7 + *(iVar3 + 0x54) * var_18h) / iVar5 & 0xffU;\n            uVar6 = (*_sym.imp.GDI32.dll_CreateBrushIndirect)(&var_ch);\n            var_10h = var_10h + 4;\n            (*_sym.imp.USER32.dll_FillRect)(uVar4, &var_1ch, uVar6);\n            (*pcVar2)(uVar6);\n        }\n        if (*(iVar3 + 0x58) != -1) {\n            iVar5 = (*_sym.imp.GDI32.dll_CreateFontIndirectA)(*(iVar3 + 0x34));\n            if (iVar5 != 0) {\n                var_1ch = 0x10;\n                var_18h = 8;\n                (*_sym.imp.GDI32.dll_SetBkMode)(uVar4, 1);\n                (*_sym.imp.GDI32.dll_SetTextColor)(uVar4, *(iVar3 + 0x58));\n                pcVar1 = _sym.imp.GDI32.dll_SelectObject;\n                uVar6 = (*_sym.imp.GDI32.dll_SelectObject)(uVar4, iVar5);\n                (*_sym.imp.USER32.dll_DrawTextA)(uVar4, 0x423f20, 0xffffffff, &var_1ch, 0x820);\n                (*pcVar1)(uVar4, uVar6);\n                (*pcVar2)(iVar5);\n            }\n        }\n        (*_sym.imp.USER32.dll_EndPaint)(arg_8h, &var_5ch);\n        uVar4 = 0;\n    }\n    else {\n        if (arg_ch == 0x46) {\n            *(arg_14h + 0x18) = *(arg_14h + 0x18) | 0x10;\n            *(arg_14h + 4) = *0x424728;\n        }\n        uVar4 = (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    }\n    return uVar4;\n}\n",
        "token_count": 847
    },
    "0040386c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.0040386c(void)\n\n{\n    code *pcVar1;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n    if (*0x40a018 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*0x40a018);\n        *0x40a018 = -1;\n    }\n    if (*0x40a01c != -1) {\n        (*pcVar1)(*0x40a01c);\n        *0x40a01c = -1;\n    }\n    fcn.004038c9();\n    fcn.00405909(0x42b800, 7);\n    return;\n}\n",
        "token_count": 150
    },
    "00405b72": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nvoid fcn.00405b72(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    char cVar4;\n    uint var_4h;\n    uint var_67ch;\n    uint var_674h;\n    uint var_66ch;\n    uint var_3c8h;\n    uint var_378h;\n    uint var_33ch;\n    uint var_6ah;\n    \n    *(unaff_EBP + -0x3337b) = 0xff;\n    uVar2 = (**(unaff_EBP + -0x3c8))();\n    *(unaff_EBP + -0x66c) = uVar2;\n    if (*(unaff_EBP + -0x66c) != -1) {\n        uVar2 = (**(unaff_EBP + -0x33c))(*(unaff_EBP + -0x66c), 0);\n        *(unaff_EBP + -0x378) = uVar2;\n        uVar2 = (**(unaff_EBP + -0x67c))(*(unaff_EBP + -0x674), 8, *(unaff_EBP + -0x378));\n        *(unaff_EBP + -4) = uVar2;\n        fcn.004048b2();\n        *(unaff_EBP + -0x6dc) = 0;\n        *(unaff_EBP + -0x6db) = 0;\n        *(unaff_EBP + -0x6da) = 0x2c;\n        cVar4 = '\\0';\n        *(unaff_EBP + -0x6d9) = 0;\n        *(unaff_EBP + -0x6d8) = 0x81;\n        *(unaff_EBP + -0x6d7) = 0xb6;\n        *(unaff_EBP + -0x6d6) = 0xb2;\n        *(unaff_EBP + -0x6d5) = 0xb7;\n        *(unaff_EBP + -0x6d4) = 0x95;\n        *(unaff_EBP + -0x6d3) = 0xba;\n        *(unaff_EBP + -0x6d2) = 0xbf;\n        *(unaff_EBP + -0x6d1) = 0xb6;\n        *(unaff_EBP + -0x6d0) = 0xd3;\n        iVar3 = fcn.004048b2();\n        pcVar1 = swi(4);\n        if (cVar4 == '\\x01') {\n            iVar3 = (*pcVar1)();\n        }\n        *(unaff_EBP + -0x6db7b) = *(unaff_EBP + -0x6db7b) + -1;\n        (**(iVar3 + -0x18))();\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    return;\n}\n",
        "token_count": 683
    },
    "004011ef": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004011ef(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar2 = *0x424768;\n    iVar5 = arg_8h * 0x418 + *0x424768;\n    var_4h = 0;\n    var_8h = 0;\n    if (((*(iVar5 + 8) & 2) != 0) && (arg_ch != 0)) {\n        arg_8h = arg_8h + 1;\n        *(iVar5 + 8) = *(iVar5 + 8) & 0xffffffbe;\n    }\n    if (arg_8h < *0x42476c) {\n        do {\n            puVar1 = arg_8h * 0x418 + 8 + iVar2;\n            uVar3 = arg_8h + 1;\n            uVar4 = *puVar1;\n            if ((uVar4 & 2) != 0) {\n                uVar3 = fcn.004011ef(arg_8h, 1);\n                uVar4 = *puVar1;\n            }\n            if ((uVar4 & 4) != 0) {\n                if (var_4h == 0) {\n                    return uVar3;\n                }\n                if (var_8h != 0) {\n                    *(iVar5 + 8) = *(iVar5 + 8) | 0x40;\n                    return uVar3;\n                }\n                *(iVar5 + 8) = *(iVar5 + 8) & 0xffffff7f | 1;\n                return uVar3;\n            }\n            if ((uVar4 & 0x40) != 0) {\n                var_4h = var_4h + 1;\n            }\n            if ((uVar4 & 1) == 0) {\n                var_8h = var_8h + 1;\n            }\n            else {\n                var_4h = var_4h + 1;\n            }\n            arg_8h = uVar3;\n        } while (uVar3 < *0x42476c);\n    }\n    return 0;\n}\n",
        "token_count": 534
    },
    "004012e2": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004012e2(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    bool bVar3;\n    int32_t *var_8h;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    var_8h = *0x424734 + 0x94;\n    do {\n        uVar1 = 0;\n        if (*var_8h != 0) {\n            bVar3 = *0x42476c == 0;\n            if (*0x42476c != 0) {\n                puVar2 = *0x424768 + 8;\n                do {\n                    if (((*puVar2 & 6) == 0) &&\n                       (((arg_8h == 0 || (*(arg_8h + uVar1 * 4) != 0)) &&\n                        ((puVar2[-1] & 1 << (var_4h & 0x1f)) != (*puVar2 & 1) << (var_4h & 0x1f))))) break;\n                    uVar1 = uVar1 + 1;\n                    puVar2 = puVar2 + 0x106;\n                } while (uVar1 < *0x42476c);\n                bVar3 = uVar1 == *0x42476c;\n            }\n            if (bVar3) {\n                return var_4h;\n            }\n        }\n        var_4h = var_4h + 1;\n        var_8h = var_8h + 1;\n        if (0x1f < var_4h) {\n            return var_4h;\n        }\n    } while( true );\n}\n",
        "token_count": 388
    },
    "00401434": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.00401434(int32_t **hWndChildAfter)\n\n{\n    uint32_t *puVar1;\n    uint8_t uVar2;\n    uint8_t *noname_0;\n    uint8_t *puVar3;\n    int32_t **ppiVar4;\n    char *pcVar5;\n    char *pcVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    uint uVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    int32_t *lpBuffer;\n    int32_t iVar12;\n    int32_t *extraout_EDX;\n    uint unaff_EBX;\n    uint uVar13;\n    uint unaff_ESI;\n    uint *noname_0_00;\n    int32_t **ppiVar14;\n    uint unaff_EDI;\n    int32_t **ppiVar15;\n    uint *puVar16;\n    uint32_t uVar17;\n    uint uVar18;\n    bool bVar19;\n    uint64_t uVar20;\n    uint64_t uVar21;\n    ulong uVar22;\n    ulong uVar23;\n    uint in_stack_fffffe0c;\n    uint in_stack_fffffe10;\n    uint in_stack_fffffe14;\n    uint arg_18h;\n    uint uVar24;\n    uint lpFindFileData;\n    uint var_19ch;\n    uint32_t var_88h;\n    uint var_84h;\n    uint32_t var_80h;\n    uint32_t var_7ch;\n    uint32_t var_78h;\n    uint var_74h;\n    uint32_t var_70h;\n    uint var_6ch;\n    uint32_t lpFileOp;\n    uint var_64h;\n    int32_t var_60h;\n    int32_t var_5ch;\n    uint lpRect;\n    uint var_50h;\n    uint lpValueName;\n    int32_t var_48h;\n    uint var_44h;\n    code *var_40h;\n    code *var_3ch;\n    int32_t *var_38h;\n    uint32_t var_34h;\n    uint32_t dwFileAttributes;\n    uint32_t fuLoad;\n    uint32_t lpLastWriteTime;\n    uint32_t var_24h;\n    uint32_t var_20h;\n    int32_t *hFile;\n    uint8_t var_15h;\n    uint32_t var_14h;\n    int32_t *lpMultiByteStr;\n    uint32_t lpWideCharStr;\n    uint32_t hWndParent;\n    uint32_t var_4h;\n    \n    ppiVar14 = *0x40b840;\n    pcVar7 = _sym.imp.USER32.dll_ShowWindow;\n    hWndParent = *0x424728;\n    uVar13 = 0;\n    ppiVar4 = hWndChildAfter;\n    ppiVar15 = &var_38h;\n    for (iVar12 = 7; iVar12 != 0; iVar12 = iVar12 + -1) {\n        *ppiVar15 = *ppiVar4;\n        ppiVar4 = ppiVar4 + 1;\n        ppiVar15 = ppiVar15 + 1;\n    }\n    iVar12 = var_34h * 0x400;\n    var_4h = 0;\n    noname_0_00 = iVar12 + 0x425000;\n    puVar16 = dwFileAttributes * 0x400 + 0x425000;\n    *0x40b83c = &var_34h;\n    if (0x41 < var_38h - 2U) goto code_r0x004029b8;\n    // switch table (66 cases) at 0x4029ca\n    switch(*((var_38h - 2U) * 4 + 0x4029ca)) {\n    case 0x401490:\ncode_r0x00401492:\n        fcn.00405268();\n        return 0x7fffffff;\n    case 0x40149c:\n        *0x423eec = *0x423eec + 1;\n        if (hWndParent == 0) {\n            return 0x7fffffff;\n        }\n        (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n        return 0x7fffffff;\n    case 0x4014b7:\n        iVar12 = fcn.0040136d(var_34h);\n        uVar10 = fcn.00401389(iVar12 + -1, 0);\n        return uVar10;\n    case 0x4014ca:\n        fcn.00405268(var_34h, 0);\n        break;\n    case 0x4014d6:\n        uVar23 = fcn.00402b0a(0);\n        lpMultiByteStr = uVar23 >> 0x20;\n        iVar12 = uVar23;\n        if (iVar12 < 2) {\n            iVar12 = 1;\n        }\n        (*_sym.imp.KERNEL32.dll_Sleep)(iVar12);\n        break;\n    case 0x4014f4:\n        (*_sym.imp.USER32.dll_SetForegroundWindow)(hWndParent);\n        break;\n    case 0x401502:\n        iVar12 = var_34h * 4;\n        if (fuLoad == 0) {\n            *(iVar12 + 0x424800) = *(iVar12 + 0x4247c0);\n            uVar13 = fcn.00402b0a(1);\n            *(var_34h * 4 + 0x4247c0) = uVar13;\n        }\n        else {\n            *(iVar12 + 0x4247c0) = *(iVar12 + 0x424800);\n        }\n        break;\n    case 0x401541:\n        puVar1 = fuLoad * 4 + 0x4247c0;\n        uVar10 = *puVar1;\n        uVar17 = (&var_34h)[uVar10 == 0];\n        *puVar1 = uVar10 & lpLastWriteTime;\n        return uVar17;\n    case 0x401562:\n        _var_14h = CONCAT44(lpMultiByteStr, var_14h);\n        goto code_r0x00402960;\n    case 0x40156f:\n        if (*0x423ef0 != 0) {\n            (*_sym.imp.USER32.dll_ShowWindow)(*0x423ef0, dwFileAttributes);\n        }\n        if (*0x423f04 != 0) {\n            (*pcVar7)(*0x423f04, var_34h);\n        }\n        break;\n    case 0x40159d:\n        uVar13 = fcn.00402b2c(0xfffffff0);\n        iVar12 = (*_sym.imp.KERNEL32.dll_SetFileAttributesA)(uVar13, dwFileAttributes);\n        goto code_r0x004015ae;\n    case 0x4015bb:\n        uVar13 = fcn.00402b2c(0xfffffff0);\n        noname_0 = fcn.00405b72(uVar13);\n        if (noname_0 != NULL) {\n            do {\n                uVar24 = 0x5c;\n                puVar3 = fcn.00405b04();\n                uVar2 = *puVar3;\n                *puVar3 = 0;\n                hWndChildAfter = hWndChildAfter & 0xffffff | uVar2 << 0x18;\n                if (((uVar2 == 0) && (fuLoad != 0)) &&\n                   (iVar12 = fcn.004057c8(noname_0, uVar24, in_stack_fffffe0c, in_stack_fffffe10, in_stack_fffffe14), \n                   iVar12 != 0)) {\n                    iVar12 = fcn.0040572e(uVar13);\n                }\n                else {\n                    iVar12 = fcn.004057ab(uVar13, noname_0, uVar24, in_stack_fffffe0c, in_stack_fffffe10);\n                }\n                if ((iVar12 != 0) &&\n                   ((iVar12 != 0xb7 ||\n                    (uVar10 = (*_sym.imp.KERNEL32.dll_GetFileAttributesA)(uVar13),  (uVar10 & 0x10) == 0)))) {\n                    var_4h = var_4h + 1;\n                }\n                *puVar3 = hWndChildAfter._3_1_;\n                noname_0 = puVar3 + 1;\n            } while (hWndChildAfter._3_1_ != 0);\n        }\n        if (dwFileAttributes == 0) goto code_r0x004022a4;\n        uVar24 = 0xffffffe6;\n        fcn.00401423();\n        fcn.00406141(0x42a800, uVar13, uVar24, in_stack_fffffe0c, in_stack_fffffe10);\n        iVar12 = (*_sym.imp.KERNEL32.dll_SetCurrentDirectoryA)(uVar13);\n        if (iVar12 == 0) {\n            var_4h = var_4h + 1;\n        }\n        break;\n    case 0x401659:\n        uVar13 = fcn.00402b2c(0);\n        iVar12 = fcn.00406444(uVar13);\n        lpLastWriteTime = dwFileAttributes;\n        goto joined_r0x00401a0c;\n    case 0x40166a:\n        uVar13 = fcn.00402b2c(0xffffffd0);\n        uVar24 = fcn.00402b2c(0xffffffdf);\n        fcn.00402b2c(0x13);\n        iVar12 = (*_sym.imp.KERNEL32.dll_MoveFileA)(uVar13, uVar24);\n        if (iVar12 == 0) {\n            if ((fuLoad == 0) || (iVar12 = fcn.00406444(uVar13),  iVar12 == 0)) goto code_r0x00402783;\n            fcn.00405f20(uVar13, uVar24);\n        }\n        goto code_r0x004022a4;\n    case 0x4016bb:\n        ppiVar4 = fcn.00402b2c(0);\n        uVar13 = 0x400;\n        ppiVar14 = ppiVar4;\n        iVar12 = (*_sym.imp.KERNEL32.dll_GetFullPathNameA)(ppiVar4, 0x400, puVar16, &hWndChildAfter);\n        if (iVar12 == 0) {\ncode_r0x004016fb:\n            var_4h = 1;\n            *puVar16 = '\\0';\n        }\n        else if ((ppiVar4 < hWndChildAfter) && (*hWndChildAfter != '\\0')) {\n            iVar12 = fcn.00406444();\n            if (iVar12 == 0) goto code_r0x004016fb;\n            fcn.00406141(hWndChildAfter, iVar12 + 0x2c, ppiVar4, ppiVar14, uVar13);\n        }\n        if (fuLoad == 0) {\n            (*_sym.imp.KERNEL32.dll_GetShortPathNameA)(puVar16, puVar16, 0x400);\n        }\n        break;\n    case 0x40171f:\n        uVar13 = fcn.00402b2c(0xffffffff);\n        iVar12 = (*_sym.imp.KERNEL32.dll_SearchPathA)(0, uVar13, 0, 0x400, noname_0_00, &hWndChildAfter);\n        bVar19 = iVar12 == 0;\n        goto code_r0x0040173b;\n    case 0x401746:\n        uVar13 = fcn.00402b2c(0xffffffef);\n        iVar12 = fcn.00405d09(noname_0_00, uVar13);\n        goto code_r0x004015ae;\n    case 0x401759:\n        uVar13 = 0x31;\n        uVar17 = fcn.00402b2c();\n        hWndChildAfter = var_34h & 7;\n        uVar10 = uVar17;\n        hWndParent = uVar17;\n        iVar12 = fcn.00405b46(uVar17, uVar13, unaff_EDI, unaff_ESI, unaff_EBX);\n        if (iVar12 == 0) {\n            uVar13 = fcn.00406141(0x40a400, 0x42a800, uVar17, uVar10, uVar13);\n            uVar13 = fcn.00405ad9(uVar13);\n            fcn.0040615d(uVar13);\n        }\n        else {\n            fcn.00406141(0x40a400, uVar17, uVar10, uVar13, unaff_EDI);\n        }\n        fcn.004063ab(0x40a400);\n        do {\n            if (2 < hWndChildAfter) {\n                iVar12 = fcn.00406444(0x40a400);\n                uVar10 = 0;\n                if (iVar12 != 0) {\n                    uVar10 = (*_sym.imp.KERNEL32.dll_CompareFileTime)(iVar12 + 0x14, &lpLastWriteTime);\n                }\n                hWndChildAfter = ((hWndChildAfter - 3U | 0x80000000) & uVar10) == 0;\n            }\n            if (hWndChildAfter == NULL) {\n                fcn.00405cb5(0x40a400);\n            }\n            iVar12 = (hWndChildAfter != 0x1) + 1;\n            uVar24 = 0x40000000;\n            uVar13 = 0x40a400;\n            lpWideCharStr = fcn.00405cda();\n            if (lpWideCharStr != -1) {\n                fcn.00405268(0xffffffea, hWndParent);\n                *0x4247f4 = *0x4247f4 + 1;\n                iVar12 = fcn.004030b5(fuLoad, lpWideCharStr, 0, 0);\n                *0x4247f4 = *0x4247f4 + -1;\n                if ((lpLastWriteTime != 0xffffffff) || (var_24h != 0xffffffff)) {\n                    (*_sym.imp.KERNEL32.dll_SetFileTime)(lpWideCharStr, &lpLastWriteTime, 0, &lpLastWriteTime);\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(lpWideCharStr);\n                if (-1 < iVar12) goto code_r0x004029b8;\n                if (iVar12 == -2) {\n                    func_0x00406163(0x40a400, 0xffffffe9);\n                    fcn.0040615d(0x40a400, hWndParent);\n                }\n                else {\n                    func_0x00406163(0x40a400, 0xffffffee);\n                }\n                uVar13 = 0x40a400;\n                goto code_r0x00402349;\n            }\n            if (hWndChildAfter != NULL) {\n                fcn.00405268(0xffffffe2, hWndParent);\n                bVar19 = hWndChildAfter == 0x2;\n                goto code_r0x004015b0;\n            }\n            uVar9 = 0x425000;\n            uVar18 = 0x40ac00;\n            fcn.00406141(0x40ac00, 0x425000, uVar13, uVar24, iVar12);\n            uVar24 = 0x425000;\n            fcn.00406141(0x425000, 0x40a400, uVar18, uVar9, uVar13);\n            uVar13 = 0x40a800;\n            uVar10 = var_20h;\n            func_0x00406163();\n            fcn.00406141(0x425000, 0x40ac00, uVar13, uVar10, uVar24);\n            iVar12 = func_0x0040585d(0x40a800, var_34h >> 3);\n        } while (iVar12 == 4);\n        if (iVar12 != 5) goto code_r0x00401492;\n        *0x4247c8 = *0x4247c8 + 1;\n        goto code_r0x004029c1;\n    case 0x4018fd:\n        uVar13 = 0;\n        goto code_r0x00401934;\n    case 0x401900:\n        uVar13 = fcn.00402b2c(0x31);\n        uVar10 = func_0x0040585d(uVar13, var_34h);\n        if (uVar10 == 0) goto code_r0x00402783;\n        if (uVar10 == fuLoad) {\n            return lpLastWriteTime;\n        }\n        if (uVar10 == var_24h) {\n            return var_20h;\n        }\n        break;\n    case 0x401932:\n        uVar13 = 0xfffffff0;\ncode_r0x00401934:\n        uVar13 = fcn.00402b2c(uVar13);\n        fcn.00405909(uVar13, dwFileAttributes);\n        break;\n    case 0x401947:\n        uVar13 = fcn.00402b2c(1);\n        fcn.00406157(uVar13);\n        goto code_r0x00402960;\n    case 0x401959:\n        _var_14h = fcn.00402b0a(2);\n        uVar23 = fcn.00402b0a(3);\n        iVar12 = uVar23;\n        uVar13 = 1;\n        var_50h._0_2_ = uVar23;\n        var_50h._2_2_ = uVar23 >> 0x10;\n        lpValueName._0_2_ = uVar23 >> 0x20;\n        lpValueName._2_2_ = uVar23 >> 0x30;\n        hWndChildAfter = var_14h;\n        iVar11 = fcn.00402b2c();\n        hFile = iVar11;\n        iVar8 = fcn.00406157();\n        *noname_0_00 = '\\0';\n        if (lpMultiByteStr == NULL) {\n            hWndChildAfter = iVar8;\n        }\n        if ((hWndChildAfter != NULL) &&\n           ((-1 < var_50h._2_2_ || (iVar12 = iVar8 + CONCAT22(var_50h._2_2_, var_50h),  -1 < iVar12)))) {\n            if (iVar8 < iVar12) {\n                iVar12 = iVar8;\n            }\n            fcn.00406141(noname_0_00, hFile + iVar12, iVar11, uVar13, unaff_EDI);\n            if (hWndChildAfter < 0) {\n                iVar12 = fcn.00406157(noname_0_00);\n                hWndChildAfter = hWndChildAfter + iVar12;\n                if (hWndChildAfter < 0) {\n                    hWndChildAfter = NULL;\n                }\n            }\n            if (hWndChildAfter < 0x400) {\n                *(hWndChildAfter + noname_0_00) = '\\0';\n            }\n        }\n        break;\n    case 0x4019ed:\n        uVar13 = fcn.00402b2c(0x20);\n        uVar24 = fcn.00402b2c(0x31);\n        if (var_24h == 0) {\n            iVar12 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)();\n        }\n        else {\n            iVar12 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(uVar13, uVar24);\n        }\n        goto joined_r0x00401a0c;\n    case 0x401a1e:\n        hWndChildAfter = fcn.00402b2c(1);\n        iVar11 = (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsA)(hWndChildAfter, noname_0_00, 0x400);\n        if ((iVar11 == 0) ||\n           ((fuLoad != 0 && (iVar11 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(hWndChildAfter, noname_0_00),  iVar11 == 0)))) {\n            var_4h = 1;\n            *noname_0_00 = '\\0';\n        }\n        *(iVar12 + 0x4253ff) = 0;\n        break;\n    case 0x401a5e:\n        uVar23 = fcn.00402b0a(0);\n        lpMultiByteStr = uVar23 >> 0x20;\n        uVar10 = uVar23;\n        uVar17 = fcn.00402b0a(1);\n        if (var_20h != 0) {\n            if (uVar10 < uVar17) {\n                return lpLastWriteTime;\n            }\n            if (uVar10 <= uVar17) {\n                return fuLoad;\n            }\n            return var_24h;\n        }\n        if (uVar10 < uVar17) {\n            return lpLastWriteTime;\n        }\n        if (uVar10 <= uVar17) {\n            return fuLoad;\n        }\n        return var_24h;\n    case 0x401a9e:\n        uVar23 = fcn.00402b0a(1);\n        iVar12 = uVar23;\n        uVar20 = fcn.00402b0a(2);\n        lpMultiByteStr = uVar23 >> 0x20;\n        hWndChildAfter = uVar23;\n        uVar21 = uVar20 & 0xffffffff00000000 | var_14h;\n        _var_14h = uVar20 & 0xffffffff00000000 | var_14h;\n        if (0xd < lpLastWriteTime) goto code_r0x00402960;\n    // switch table (14 cases) at 0x402ad2\n        switch(*(lpLastWriteTime * 4 + 0x402ad2)) {\n        case 0x401aca:\n            _var_14h = uVar20 & 0xffffffff00000000 | var_14h;\n            break;\n        case 0x401ace:\n            _var_14h = uVar20 & 0xffffffff00000000 | var_14h;\n            break;\n        case 0x401ad2:\n            _var_14h = uVar20 & 0xffffffff00000000 | var_14h;\n            break;\n        case 0x401ad7:\n            goto joined_r0x00401b14;\n        case 0x401ae4:\n            _var_14h = uVar20 & 0xffffffff00000000 | var_14h;\n            break;\n        case 0x401ae8:\n            _var_14h = uVar20 & 0xffffffff00000000 | var_14h;\n            break;\n        case 0x401aec:\n            _var_14h = uVar20 & 0xffffffff00000000 | var_14h;\n            break;\n        case 0x401af2:\n            _var_14h = uVar20 & 0xffffffff00000000 | var_14h;\n            break;\n        case 0x401afb:\n            _var_14h = uVar20 & 0xffffffff00000000 | var_14h;\n            if (iVar12 == 0) {\ncode_r0x00401b09:\n                _var_14h = uVar20 & 0xffffffff00000000 | var_14h;\n            }\n            break;\n        case 0x401b05:\n            _var_14h = uVar20 & 0xffffffff00000000 | var_14h;\n            if (iVar12 != 0) goto code_r0x00401b09;\n            break;\n        case 0x401b12:\n            uVar21 = uVar20 & 0xffffffff00000000 | var_14h;\njoined_r0x00401b14:\n            _var_14h = uVar21;\n            if (uVar20 == 0) {\n                var_4h = 1;\n                _var_14h = uVar20 & 0xffffffff00000000 | var_14h;\n            }\n            break;\n        case 0x401b2a:\n            _var_14h = uVar20 & 0xffffffff00000000 | var_14h;\n            break;\n        case 0x401b2e:\n            _var_14h = uVar20 & 0xffffffff00000000 | var_14h;\n            break;\n        case 0x401b32:\n            _var_14h = uVar20 & 0xffffffff00000000 | var_14h;\n        }\n        goto code_r0x00402960;\n    case 0x401b3f:\n        uVar13 = fcn.00402b2c(1);\n        uVar23 = fcn.00402b0a(2);\n        lpMultiByteStr = uVar23 >> 0x20;\n        (*_sym.imp.USER32.dll_wsprintfA)(noname_0_00, uVar13, uVar23);\n        break;\n    case 0x401b63:\n        ppiVar4 = *0x40b840;\n        if (fuLoad == 0) {\n            if (dwFileAttributes != 0) {\n                if (*0x40b840 != NULL) {\n                    fcn.00406141(noname_0_00, *0x40b840 + 1, unaff_EDI, unaff_ESI, unaff_EBX);\n                    *0x40b840 = *ppiVar14;\n                    goto code_r0x00401bd2;\n                }\n                goto code_r0x00402783;\n            }\n            ppiVar14 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, 0x404);\n            func_0x00406163(ppiVar14 + 1, var_34h);\n            *ppiVar14 = *0x40b840;\n            *0x40b840 = ppiVar14;\n        }\n        else {\n            do {\n                fuLoad = fuLoad - 1;\n                if (ppiVar4 == NULL) goto code_r0x0040233b;\n                ppiVar4 = *ppiVar4;\n            } while (fuLoad != 0);\n            if (ppiVar4 == NULL) goto code_r0x0040233b;\n            ppiVar4 = ppiVar4 + 1;\n            noname_0_00 = 0x40a400;\n            ppiVar14 = ppiVar4;\n            fcn.00406141(0x40a400, ppiVar4, unaff_EDI, unaff_ESI, unaff_EBX);\n            fcn.00406141(ppiVar4, *0x40b840 + 1, noname_0_00, ppiVar14, unaff_EDI);\ncode_r0x004028d6:\n            fcn.00406141(noname_0_00, ppiVar14, unaff_EDI, unaff_ESI, unaff_EBX);\n        }\n        break;\n    case 0x401c0a:\n        uVar23 = fcn.00402b0a(3);\n        uVar21 = fcn.00402b0a(4);\n        lpMultiByteStr = uVar23 >> 0x20;\n        hWndParent = uVar23;\n        if ((var_20h & 1) != 0) {\n            hWndParent = fcn.00402b2c(0x33);\n            lpMultiByteStr = uVar21 >> 0x20;\n            hWndChildAfter = uVar21;\n        }\n        if ((var_20h & 2) != 0) {\n            uVar10 = fcn.00402b2c(0x44);\n            lpMultiByteStr = uVar21 >> 0x20;\n            hWndChildAfter = uVar21;\n            uVar21 = uVar21 & 0xffffffff00000000 | uVar10;\n        }\n        if (var_38h == 0x21) {\n            uVar23 = fcn.00402b0a();\n            lpMultiByteStr = uVar21 >> 0x20;\n            hWndChildAfter = uVar21;\n            lpMultiByteStr = uVar23 >> 0x20;\n            uVar22 = fcn.00402b0a(2);\n            lpMultiByteStr = uVar22 >> 0x20;\n            if (var_20h >> 2 == 0) {\n                lpWideCharStr = (*_sym.imp.USER32.dll_SendMessageA)(uVar23, uVar22, hWndParent, hWndChildAfter);\n                uVar21 = CONCAT44(lpMultiByteStr, hWndChildAfter);\n            }\n            else {\n                iVar12 = (*_sym.imp.USER32.dll_SendMessageTimeoutA)\n                                   (uVar23, uVar22, hWndParent, hWndChildAfter, 0, var_20h >> 2, &lpWideCharStr);\n                uVar21 = CONCAT44(lpMultiByteStr, hWndChildAfter);\n                var_4h = iVar12 == 0;\n            }\n        }\n        else {\n            pcVar5 = fcn.00402b2c(1);\n            lpMultiByteStr = uVar21 >> 0x20;\n            hWndChildAfter = uVar21;\n            pcVar6 = fcn.00402b2c(0x12);\n            lpMultiByteStr = uVar21 >> 0x20;\n            hWndChildAfter = uVar21;\n            lpWideCharStr =\n                 (*_sym.imp.USER32.dll_FindWindowExA)\n                           (hWndParent, hWndChildAfter, -(*pcVar5 != '\\0') & pcVar5, -(*pcVar6 != '\\0') & pcVar6);\n            lpMultiByteStr = uVar21 >> 0x20;\n            hWndChildAfter = uVar21;\n        }\n        _var_14h = uVar21 & 0xffffffff00000000 | var_14h;\n        hWndChildAfter = uVar21;\n        dwFileAttributes = var_34h;\njoined_r0x00402716:\n        if (-1 < dwFileAttributes) goto code_r0x00402960;\n        break;\n    case 0x401cda:\n        uVar23 = fcn.00402b0a(0);\n        lpMultiByteStr = uVar23 >> 0x20;\n        iVar12 = (*_sym.imp.USER32.dll_IsWindow)(uVar23);\n        lpLastWriteTime = dwFileAttributes;\njoined_r0x00401a0c:\n        if (iVar12 == 0) {\n            return fuLoad;\n        }\n        return lpLastWriteTime;\n    case 0x401cfb:\n        uVar23 = fcn.00402b0a(2);\n        lpMultiByteStr = uVar23 >> 0x20;\n        uVar22 = fcn.00402b0a(1);\n        lpMultiByteStr = uVar22 >> 0x20;\n        (*_sym.imp.USER32.dll_GetDlgItem)(uVar22, uVar23);\n        goto code_r0x00402960;\n    case 0x401d20:\n        iVar12 = *0x424788 + dwFileAttributes;\n        uVar23 = fcn.00402b0a(0);\n        lpMultiByteStr = uVar23 >> 0x20;\n        (*_sym.imp.USER32.dll_SetWindowLongA)(uVar23, 0xffffffeb, iVar12);\n        break;\n    case 0x401d41:\n        if ((fuLoad & 0x100) == 0) {\n            uVar13 = (*_sym.imp.USER32.dll_GetDlgItem)(hWndParent, dwFileAttributes);\n            uVar23 = CONCAT44(lpMultiByteStr, uVar13);\n        }\n        else {\n            uVar23 = fcn.00402b0a(1);\n        }\n        hWndParent = fuLoad >> 0x1f;\n        uVar17 = fuLoad & 3;\n        uVar10 = fuLoad & 4;\n        hFile = fuLoad >> 0x1e & 1;\n        if ((fuLoad & 0x10000) == 0) {\n            lpWideCharStr = var_34h & 0xffff;\n        }\n        else {\n            lpWideCharStr = fcn.00402b2c(0);\n            lpMultiByteStr = uVar23 >> 0x20;\n            hWndChildAfter = uVar23;\n        }\n        hWndChildAfter = uVar23;\n        (*_sym.imp.USER32.dll_GetClientRect)(hWndChildAfter, &lpRect);\n        lpMultiByteStr = uVar23 >> 0x20;\n        hWndChildAfter = uVar23;\n        uVar13 = (*_sym.imp.USER32.dll_LoadImageA)\n                           (-(uVar10 != 0) & *0x424720, lpWideCharStr, uVar17, \n                            CONCAT22(var_50h._2_2_, var_50h) * hWndParent, \n                            CONCAT22(lpValueName._2_2_, lpValueName) * hFile, fuLoad & 0xfef0);\n        lpMultiByteStr = uVar23 >> 0x20;\n        hWndChildAfter = uVar23;\n        iVar12 = (*_sym.imp.USER32.dll_SendMessageA)(hWndChildAfter, 0x172, uVar17, uVar13);\n        lpMultiByteStr = uVar23 >> 0x20;\n        hWndChildAfter = uVar23;\n        if ((iVar12 != 0) && (uVar17 == 0)) {\n            (*_sym.imp.GDI32.dll_DeleteObject)(iVar12);\n            lpMultiByteStr = uVar23 >> 0x20;\n            hWndChildAfter = uVar23;\n        }\n        break;\n    case 0x401dff:\n        uVar13 = (*_sym.imp.USER32.dll_GetDC)(hWndParent);\n        uVar23 = fcn.00402b0a(2);\n        lpMultiByteStr = uVar23 >> 0x20;\n        uVar24 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(uVar13, 0x5a, 0x48);\n        *0x40b800 = (*_sym.imp.KERNEL32.dll_MulDiv)(uVar23, uVar24);\n        *0x40b800 = -*0x40b800;\n        (*_sym.imp.USER32.dll_ReleaseDC)(hWndParent, uVar13);\n        uVar21 = fcn.00402b0a(3);\n        *0x40b814 = var_24h & 1;\n        *0x40b817 = 1;\n        *0x40b815 = var_24h & 2;\n        *0x40b816 = var_24h & 4;\n        func_0x00406163(0x40b81c, dwFileAttributes);\n        lpMultiByteStr = uVar21 >> 0x20;\n        *0x40b810 = uVar21;\n        (*_sym.imp.GDI32.dll_CreateFontIndirectA)(0x40b800);\n        lpMultiByteStr = uVar21 >> 0x20;\n        _var_14h = uVar21 & 0xffffffff00000000 | var_14h;\n        *0x40b810 = uVar21;\n        goto code_r0x00402960;\n    case 0x401e8f:\n        uVar23 = fcn.00402b0a(0);\n        lpMultiByteStr = uVar23 >> 0x20;\n        uVar22 = fcn.00402b0a(1);\n        lpMultiByteStr = uVar22 >> 0x20;\n        if (lpLastWriteTime == 0) {\n            (*_sym.imp.USER32.dll_ShowWindow)();\n        }\n        else {\n            (*_sym.imp.USER32.dll_EnableWindow)(uVar23, uVar22);\n        }\n        break;\n    case 0x401ec3:\n        pcVar5 = fcn.00402b2c(0);\n        iVar12 = 0x31;\n        var_74h = fcn.00402b2c(0x31);\n        pcVar6 = fcn.00402b2c(0x22);\n        fcn.00402b2c(0x15);\n        fcn.00401423(0xffffffec);\n        var_80h = var_24h;\n        var_7ch = hWndParent;\n        lpFileOp = lpLastWriteTime;\n        var_78h = -(*pcVar5 != '\\0') & pcVar5;\n        var_6ch = 0x42a800;\n        var_70h = -(*pcVar6 != '\\0') & pcVar6;\n        iVar11 = fcn.00405823(&var_84h);\n        if (iVar11 == 0) goto code_r0x00402783;\n        if ((var_80h & 0x40) != 0) {\n            fcn.0040654e(CONCAT22(lpValueName._2_2_, lpValueName));\n            goto code_r0x00401f8d;\n        }\n        break;\n    case 0x401f48:\n        uVar13 = fcn.00402b2c(0);\n        fcn.00405268(0xffffffeb, uVar13);\n        iVar12 = fcn.004057e0(uVar13);\n        if (iVar12 == 0) goto code_r0x00402783;\n        if (fuLoad != 0) {\n            iVar11 = fcn.0040654e(iVar12);\n            if (dwFileAttributes < 0) {\n                if (iVar11 != 0) {\n                    var_4h = 1;\n                }\n            }\n            else {\n                func_0x0040609f(puVar16, iVar11);\n            }\n        }\ncode_r0x00401f8d:\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar12);\n        break;\n    case 0x401f98:\n        uVar13 = fcn.00402b2c(2);\n        hWndChildAfter = fcn.00406444(uVar13);\n        if (hWndChildAfter != NULL) {\n            func_0x0040609f(puVar16, hWndChildAfter[5]);\n            _var_14h = CONCAT44(lpMultiByteStr, var_14h);\n            goto code_r0x00402960;\n        }\n        *noname_0_00 = '\\0';\n        *puVar16 = '\\0';\n        goto code_r0x00402783;\n    case 0x401fc8:\n        hFile = fcn.00402b2c(0xffffffee);\n        pcVar7 = fcn.004064d9(9, hFile, &lpMultiByteStr);\n        lpWideCharStr = (*pcVar7)();\n        *noname_0_00 = '\\0';\n        *puVar16 = '\\0';\n        var_4h = 1;\n        if ((lpWideCharStr != 0) &&\n           (hWndChildAfter = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, lpWideCharStr),  hWndChildAfter != NULL)) {\n            var_40h = fcn.004064d9(10);\n            var_3ch = fcn.004064d9(0xb);\n            iVar12 = (*var_40h)(hFile, 0, lpWideCharStr, hWndChildAfter);\n            ppiVar14 = hWndChildAfter;\n            if ((iVar12 != 0) &&\n               (iVar12 = (*var_3ch)(hWndChildAfter, 0x40a014, &hWndParent, &lpValueName),  ppiVar14 = hWndChildAfter, \n               iVar12 != 0)) {\n                func_0x0040609f(noname_0_00, *(hWndParent + 8));\n                func_0x0040609f(puVar16, *(hWndParent + 0xc));\n                var_4h = 0;\n                ppiVar14 = hWndChildAfter;\n            }\ncode_r0x00401bd2:\n            (*_sym.imp.KERNEL32.dll_GlobalFree)(ppiVar14);\n        }\n        break;\n    case 0x402069:\n        var_4h = 1;\n        if (-1 < *0x4247f8) {\n            uVar13 = fcn.00402b2c(0xfffffff0);\n            hWndChildAfter = fcn.00402b2c(1);\n            if (((var_24h != 0) && (iVar12 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(uVar13),  iVar12 != 0)) ||\n               (iVar12 = (*_sym.imp.KERNEL32.dll_LoadLibraryExA)(uVar13, 0, 8),  iVar12 != 0)) {\n                pcVar7 = fcn.00406548(iVar12, hWndChildAfter);\n                if (pcVar7 == NULL) {\n                    fcn.00405268(0xfffffff7, hWndChildAfter);\n                }\n                else {\n                    var_4h = 0;\n                    if (fuLoad == 0) {\n                        (*pcVar7)(hWndParent, 0x400, 0x425000, 0x40b840, 0x40a000);\n                    }\n                    else {\n                        fcn.00401423(fuLoad);\n                        iVar11 = (*pcVar7)();\n                        if (iVar11 != 0) {\n                            var_4h = 1;\n                        }\n                    }\n                }\n                if ((lpLastWriteTime == 0) && (iVar11 = fcn.004038fe(iVar12),  iVar11 != 0)) {\n                    (*_sym.imp.KERNEL32.dll_FreeLibrary)(iVar12);\n                }\n                break;\n            }\n        }\n        goto code_r0x004022a4;\n    case 0x402138:\n        lpMultiByteStr = fcn.00402b2c(0xfffffff0);\n        arg_18h = 0xffffffdf;\n        lpWideCharStr = fcn.00402b2c();\n        uVar9 = 2;\n        var_44h = fcn.00402b2c();\n        uVar18 = 0xffffffcd;\n        var_40h = fcn.00402b2c();\n        uVar24 = 0x45;\n        uVar13 = fcn.00402b2c();\n        lpValueName._0_2_ = uVar13;\n        lpValueName._2_2_ = uVar13 >> 0x10;\n        var_88h = var_24h & 0xfff;\n        var_3ch = var_24h >> 0x10 & 0xffff;\n        uVar10 = var_24h >> 0xc & 7;\n        iVar12 = fcn.00405b46(lpWideCharStr, uVar24, uVar18, uVar9, arg_18h);\n        if (iVar12 == 0) {\n            fcn.00402b2c(0x21);\n        }\n        iVar12 = (*_sym.imp.ole32.dll_CoCreateInstance)(0x408410, 0, 1, 0x408400, &hWndChildAfter);\n        if (-1 < iVar12) {\n            hWndParent = (***hWndChildAfter)(hWndChildAfter, 0x408420, &hFile);\n            if (-1 < hWndParent) {\n                hWndParent = (*(*hWndChildAfter)[0x14])(hWndChildAfter, lpWideCharStr);\n                if ((var_24h & 0x8000) == 0) {\n                    (*(*hWndChildAfter)[9])(hWndChildAfter, 0x42a800);\n                }\n                if (uVar10 != 0) {\n                    (*(*hWndChildAfter)[0xf])(hWndChildAfter, uVar10);\n                }\n                (*(*hWndChildAfter)[0xd])(hWndChildAfter, var_3ch);\n                if (*var_40h != 0x0) {\n                    (*(*hWndChildAfter)[0x11])(hWndChildAfter, var_40h, var_88h);\n                }\n                (*(*hWndChildAfter)[0xb])(hWndChildAfter, var_44h);\n                (*(*hWndChildAfter)[7])(hWndChildAfter, CONCAT22(lpValueName._2_2_, lpValueName));\n                if (-1 < hWndParent) {\n                    hWndParent = 0x80004005;\n                    iVar12 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                       (0, 0, lpMultiByteStr, 0xffffffff, lpWideCharStr, 0x400);\n                    if (iVar12 != 0) {\n                        hWndParent = (**(*hFile + 0x18))(hFile, lpWideCharStr, 1);\n                    }\n                }\n                (**(*hFile + 8))(hFile);\n            }\n            (*(*hWndChildAfter)[2])(hWndChildAfter);\n            if (-1 < hWndParent) goto code_r0x004022a4;\n        }\n        var_4h = 1;\n        goto code_r0x004022a4;\n    case 0x4022b2:\n        iVar12 = fcn.00402b2c(0);\n        iVar11 = fcn.00402b2c(0x11);\n        hWndChildAfter = fcn.00402b2c(0x23);\n        iVar8 = fcn.00406444(iVar12);\n        if (iVar8 != 0) {\n            lpFileOp = hWndParent;\n            var_64h = 2;\n            iVar8 = fcn.00406157(iVar12);\n            *(iVar8 + 1 + iVar12) = 0;\n            iVar8 = fcn.00406157(iVar11);\n            *(iVar8 + 1 + iVar11) = 0;\n            var_50h._2_2_ = hWndChildAfter;\n            lpValueName._0_2_ = hWndChildAfter >> 0x10;\n            lpRect._0_2_ = fuLoad;\n            var_60h = iVar12;\n            var_5ch = iVar11;\n            fcn.00405268(0, hWndChildAfter);\n            iVar12 = (*_sym.imp.SHELL32.dll_SHFileOperationA)(&lpFileOp);\n            if (iVar12 == 0) break;\n        }\n        fcn.00405268(0xfffffff9, 0);\n        goto code_r0x00402783;\n    case 0x402334:\n        if (var_34h != 0xbadf00d) {\ncode_r0x0040233b:\n            uVar13 = func_0x00406163(0, 0xffffffe8, 0x200010);\ncode_r0x00402349:\n            func_0x0040585d(uVar13);\n            return 0x7fffffff;\n        }\n        *0x4247d4 = *0x4247d4 + 1;\n        break;\n    case 0x402363:\n        uVar24 = 0;\n        uVar18 = 0;\n        if (var_34h != 0) {\n            uVar24 = fcn.00402b2c(0);\n        }\n        if (dwFileAttributes != 0) {\n            uVar18 = fcn.00402b2c(0x11);\n        }\n        if (var_24h != 0) {\n            uVar13 = fcn.00402b2c(0x22);\n        }\n        uVar9 = fcn.00402b2c(0xffffffcd);\n        iVar12 = (*_sym.imp.KERNEL32.dll_WritePrivateProfileStringA)(uVar24, uVar18, uVar13, uVar9);\ncode_r0x004015ae:\n        bVar19 = iVar12 == 0;\ncode_r0x004015b0:\n        if (bVar19) goto code_r0x00402783;\n        break;\n    case 0x4023a7:\n        hWndChildAfter = hWndChildAfter & 0xffff | *0x40a010 << 0x10;\n        uVar13 = fcn.00402b2c(1);\n        lpMultiByteStr = fcn.00402b2c(0x12);\n        uVar24 = fcn.00402b2c(0xffffffdd);\n        (*_sym.imp.KERNEL32.dll_GetPrivateProfileStringA)\n                  (uVar13, lpMultiByteStr, &hWndChildAfter + 2, noname_0_00, 0x3ff, uVar24);\n        bVar19 = *noname_0_00 == '\\n';\ncode_r0x0040173b:\n        if (bVar19) {\ncode_r0x00402757:\n            var_4h = 1;\n            *noname_0_00 = '\\0';\n        }\n        break;\n    case 0x4023e8:\n        if (var_24h == 0) {\n            iVar11 = fcn.00402b6c(2);\n            if (iVar11 == 0) goto code_r0x00402783;\n            uVar13 = fcn.00402b2c(0x33);\n            iVar12 = (*_sym.imp.ADVAPI32.dll_RegDeleteValueA)(iVar11, uVar13);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar11);\n        }\n        else {\n            uVar13 = fcn.00402b2c(0x22);\n            iVar12 = fcn.00402bea(dwFileAttributes, uVar13, var_24h >> 1);\n        }\n        if (iVar12 != 0) goto code_r0x00402783;\n        break;\n    case 0x40243d:\n        lpMultiByteStr = var_20h;\n        uVar13 = fcn.00402b2c(2);\n        lpValueName._0_2_ = uVar13;\n        lpValueName._2_2_ = uVar13 >> 0x10;\n        uVar13 = fcn.00402b2c(0x11);\n        var_4h = 1;\n        hWndChildAfter = fcn.00402bbc(var_34h, uVar13, 2);\n        if (hWndChildAfter != NULL) {\n            uVar10 = 0;\n            if (var_24h == 1) {\n                fcn.00402b2c(0x23);\n                iVar12 = fcn.00406157(0x40ac00);\n                uVar10 = iVar12 + 1;\n            }\n            uVar23 = CONCAT44(var_44h, *0x40ac00);\n            if (var_24h == 4) {\n                uVar23 = fcn.00402b0a(3);\n                uVar10 = var_24h;\n            }\n            if (var_24h == 3) {\n                uVar10 = fcn.004030b5(lpLastWriteTime, 0, 0x40ac00, 0xc00);\n                var_44h = uVar23 >> 0x20;\n                *0x40ac00 = uVar23;\n            }\n            iVar12 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)\n                               (hWndChildAfter, CONCAT22(lpValueName._2_2_, lpValueName), 0, lpMultiByteStr, 0x40ac00, \n                                uVar10);\n            var_44h = uVar23 >> 0x20;\n            *0x40ac00 = uVar23;\n            ppiVar14 = hWndChildAfter;\n            if (iVar12 == 0) {\n                var_4h = 0;\n            }\ncode_r0x004025a9:\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(ppiVar14);\n            var_44h = uVar23 >> 0x20;\n            *0x40ac00 = uVar23;\n        }\n        break;\n    case 0x4024da:\n        ppiVar14 = fcn.00402b6c(0x20019);\n        uVar13 = fcn.00402b2c(0x33);\n        *noname_0_00 = '\\0';\n        if (ppiVar14 != NULL) {\n            lpMultiByteStr = 0x400;\n            iVar11 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)\n                               (ppiVar14, uVar13, 0, &hWndChildAfter, noname_0_00, &lpMultiByteStr);\n            if (iVar11 == 0) {\n                if (hWndChildAfter == 0x4) {\n                    var_4h = var_24h == 0;\n                    func_0x0040609f(noname_0_00, *noname_0_00);\n                    uVar23 = CONCAT44(var_44h, *0x40ac00);\n                    goto code_r0x004025a9;\n                }\n                if ((hWndChildAfter == 0x1) || (hWndChildAfter == 0x2)) {\n                    var_4h = var_24h;\n                    goto code_r0x004025a2;\n                }\n            }\n            *noname_0_00 = '\\0';\n            uVar23 = CONCAT44(var_44h, *0x40ac00);\n            var_4h = 1;\n            goto code_r0x004025a9;\n        }\n        goto code_r0x00402783;\n    case 0x40254c:\n        ppiVar14 = fcn.00402b6c(0x20019);\n        uVar23 = fcn.00402b0a(3);\n        lpMultiByteStr = uVar23 >> 0x20;\n        *noname_0_00 = '\\0';\n        if (ppiVar14 != NULL) {\n            hWndChildAfter = 0x3ff;\n            if (var_24h == 0) {\n                iVar11 = (*_sym.imp.ADVAPI32.dll_RegEnumValueA)\n                                   (ppiVar14, uVar23, noname_0_00, &hWndChildAfter, 0, 0, 0, 0);\n                if (iVar11 != 0) {\n                    var_4h = 1;\n                }\n            }\n            else {\n                (*_sym.imp.ADVAPI32.dll_RegEnumKeyA)(ppiVar14, uVar23, noname_0_00, 0x3ff);\n            }\ncode_r0x004025a2:\n            *(iVar12 + 0x4253ff) = 0;\n            uVar23 = CONCAT44(var_44h, *0x40ac00);\n            goto code_r0x004025a9;\n        }\n        goto code_r0x00402783;\n    case 0x4025b4:\n        iVar12 = fcn.004060b8(noname_0_00);\n        if (iVar12 != 0) goto code_r0x00401f8d;\n        break;\n    case 0x4025c8:\n        uVar13 = fcn.00402b2c(0xffffffed);\n        iVar12 = fcn.00405cda(uVar13, dwFileAttributes, fuLoad);\n        if (iVar12 == -1) goto code_r0x00402781;\ncode_r0x00402960:\n        func_0x0040609f(noname_0_00);\n        break;\n    case 0x4025ea:\n        if (fuLoad == 0) {\n            uVar13 = fcn.00402b2c(0x11);\n            uVar13 = fcn.00406157(uVar13);\n        }\n        else {\n            uVar13 = 1;\n            *0x40a800 = fcn.00402b0a(1);\n            lpMultiByteStr = extraout_EDX;\n        }\n        if (*noname_0_00 != '\\0') {\n            uVar24 = fcn.004060b8(noname_0_00);\n            iVar12 = fcn.00405d81(uVar24, 0x40a800, uVar13);\n            goto code_r0x004015ae;\n        }\n        goto code_r0x00402783;\n    case 0x402631:\n        hWndParent = 0;\n        uVar23 = fcn.00402b0a(2);\n        lpMultiByteStr = uVar23 >> 0x20;\n        lpWideCharStr = uVar23;\n        if (lpWideCharStr < 1) break;\n        if (0x3ff < lpWideCharStr) {\n            lpWideCharStr = 0x3ff;\n        }\n        iVar12 = hWndParent;\n        if (*noname_0_00 != '\\0') {\n            hWndChildAfter = hWndChildAfter & 0xffffff;\n            hFile = fcn.004060b8(noname_0_00);\n            iVar12 = hWndParent;\n            if (0 < lpWideCharStr) {\n                while (iVar11 = func_0x00405d52(hFile, &var_15h, 1),  iVar11 != 0) {\n                    if (lpLastWriteTime != 0) {\n                        func_0x0040609f(puVar16, var_15h);\n                        goto code_r0x004029c1;\n                    }\n                    if ((hWndChildAfter._3_1_ == 0xd) || (hWndChildAfter._3_1_ == 10)) {\n                        if ((hWndChildAfter._3_1_ == var_15h) || ((var_15h != 0xd && (var_15h != 10)))) {\n                            (*_sym.imp.KERNEL32.dll_SetFilePointer)(hFile, 0xffffffff, 0, 1);\n                        }\n                        else {\n                            *(iVar12 + puVar16) = var_15h;\n                            iVar12 = iVar12 + 1;\n                        }\n                        break;\n                    }\n                    *(iVar12 + puVar16) = var_15h;\n                    iVar12 = iVar12 + 1;\n                    hWndChildAfter = hWndChildAfter & 0xffffff | var_15h << 0x18;\n                    if ((var_15h == 0) || (lpWideCharStr <= iVar12)) break;\n                }\n            }\n        }\n        *(iVar12 + puVar16) = '\\0';\n        bVar19 = iVar12 == 0;\n        goto code_r0x004015b0;\n    case 0x4026ee:\n        if (*noname_0_00 != '\\0') {\n            uVar23 = fcn.00402b0a(2);\n            lpMultiByteStr = uVar23 >> 0x20;\n            uVar13 = fcn.004060b8(noname_0_00, uVar23, 0, lpLastWriteTime);\n            (*_sym.imp.KERNEL32.dll_SetFilePointer)(uVar13);\n            noname_0_00 = puVar16;\n            goto joined_r0x00402716;\n        }\n        break;\n    case 0x402721:\n        iVar12 = fcn.004060b8(noname_0_00);\n        if (iVar12 != 0) {\n            (*_sym.imp.KERNEL32.dll_FindClose)(iVar12);\n        }\n        break;\n    case 0x40273b:\n        iVar12 = fcn.004060b8(puVar16);\n        if ((iVar12 != 0) && (iVar12 = (*_sym.imp.KERNEL32.dll_FindNextFileA)(iVar12, &lpFindFileData),  iVar12 != 0)) {\ncode_r0x00402796:\n            ppiVar14 = &var_19ch;\n            goto code_r0x004028d6;\n        }\n        goto code_r0x00402757;\n    case 0x402765:\n        uVar13 = fcn.00402b2c(2);\n        iVar12 = (*_sym.imp.KERNEL32.dll_FindFirstFileA)(uVar13, &lpFindFileData);\n        if (iVar12 != -1) {\n            func_0x0040609f(puVar16, iVar12);\n            goto code_r0x00402796;\n        }\n        *puVar16 = '\\0';\ncode_r0x00402781:\n        *noname_0_00 = '\\0';\ncode_r0x00402783:\n        var_4h = 1;\n        break;\n    case 0x4027a3:\n        uVar24 = 0xfffffff0;\n        lpWideCharStr = -0x29a;\n        uVar13 = fcn.00402b2c();\n        lpValueName._0_2_ = uVar13;\n        lpValueName._2_2_ = uVar13 >> 0x10;\n        iVar12 = fcn.00405b46(uVar13, uVar24, unaff_EDI, unaff_ESI, unaff_EBX);\n        if (iVar12 == 0) {\n            fcn.00402b2c(0xffffffed);\n        }\n        fcn.00405cb5(uVar13);\n        hWndChildAfter = fcn.00405cda(uVar13, 0x40000000, 2);\n        pcVar7 = _sym.imp.KERNEL32.dll_GlobalAlloc;\n        if (hWndChildAfter != 0xffffffff) {\n            hFile = *0x424738;\n            iVar12 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, *0x424738);\n            if (iVar12 != 0) {\n                fcn.0040333c(0);\n                fcn.00403326(iVar12, hFile);\n                lpBuffer = (*pcVar7)(0x40, fuLoad);\n                lpMultiByteStr = lpBuffer;\n                if (lpBuffer != NULL) {\n                    fcn.004030b5(dwFileAttributes, 0, lpBuffer, fuLoad);\n                    for (; *lpBuffer != '\\0'; lpBuffer = lpBuffer + var_48h + 8) {\n                        var_48h = *lpBuffer;\n                        dwFileAttributes = lpBuffer[1] + iVar12;\n                        fcn.00405c95();\n                    }\n                    (*_sym.imp.KERNEL32.dll_GlobalFree)(lpMultiByteStr, dwFileAttributes);\n                }\n                fcn.00405d81(hWndChildAfter, iVar12, hFile);\n                (*_sym.imp.KERNEL32.dll_GlobalFree)(iVar12);\n                lpWideCharStr = fcn.004030b5(0xffffffff, hWndChildAfter, 0, 0);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hWndChildAfter);\n        }\n        if (lpWideCharStr < 0) {\n            (*_sym.imp.KERNEL32.dll_DeleteFileA)(CONCAT22(lpValueName._2_2_, lpValueName));\n            var_4h = 1;\n        }\ncode_r0x004022a4:\n        fcn.00401423();\n        break;\n    case 0x40289e:\n        _var_14h = fcn.00402b0a(0);\n        if (*0x42476c <= _var_14h) goto code_r0x00402783;\n        iVar12 = _var_14h * 0x418 + *0x424768;\n        if (-1 < fuLoad) {\n            noname_0_00 = puVar16;\n            if (fuLoad == 0) {\n                ppiVar14 = iVar12 + 0x18;\n                goto code_r0x004028d6;\n            }\n            goto code_r0x00402960;\n        }\n        fuLoad = -1 - fuLoad;\n        if (fuLoad == 0) {\n            func_0x00406163(iVar12 + 0x18, var_24h);\n            *(iVar12 + 9) = *(iVar12 + 9) | 1;\n        }\n        else {\n            uVar23 = fcn.00402b0a(1);\n            dwFileAttributes = uVar23;\n            lpValueName._0_2_ = uVar23 >> 0x20;\n            lpValueName._2_2_ = uVar23 >> 0x30;\n        }\n        *(iVar12 + fuLoad * 4) = dwFileAttributes;\n        if (lpLastWriteTime != 0) {\n            fcn.0040117d(var_14h);\n        }\n        break;\n    case 0x40292c:\n        uVar23 = fcn.00402b0a(0);\n        lpMultiByteStr = uVar23 >> 0x20;\n        uVar10 = uVar23;\n        if (0x1f < uVar10) goto code_r0x00402783;\n        if (lpLastWriteTime == 0) {\n            if (fuLoad == 0) {\n                func_0x00406163(puVar16, *(*0x424734 + 0x94 + uVar10 * 4));\n            }\n            else {\n                *(*0x424734 + 0x94 + uVar10 * 4) = dwFileAttributes;\n            }\n        }\n        else {\n            if (fuLoad == 0) {\n                fcn.004012e2(0);\n                noname_0_00 = puVar16;\n                _var_14h = CONCAT44(lpMultiByteStr, var_14h);\n                goto code_r0x00402960;\n            }\n            fcn.00401299(uVar10);\n            fcn.004011ef(0, 0);\n        }\n        break;\n    case 0x402993:\n        (*_sym.imp.USER32.dll_SendMessageA)(hWndParent, 0xb, *0x421d30 & var_34h, 0);\n        if (var_34h != 0) {\n            (*_sym.imp.USER32.dll_InvalidateRect)(hWndParent, 0, 0);\n        }\n        break;\n    case 0x4029c3:\n        goto code_r0x004029c3;\n    }\ncode_r0x004029b8:\n    *0x4247c8 = *0x4247c8 + var_4h;\ncode_r0x004029c1:\n    var_34h = 0;\ncode_r0x004029c3:\n    return var_34h;\n}\n",
        "token_count": 14839
    },
    "00402c2e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00402c2e(uint arg_8h, uint lpSubKey, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    uint var_10ch;\n    uint hKey;\n    \n    iVar1 = fcn.00405fc7(arg_8h, lpSubKey, CONCAT31((arg_10h & 0x300) >> 8, 8), &hKey);\n    pcVar2 = _sym.imp.ADVAPI32.dll_RegEnumKeyA;\n    if (iVar1 == 0) {\n        do {\n            iVar1 = (*pcVar2)(hKey, 0, &var_10ch, 0x105);\n            if (iVar1 != 0) break;\n            if ((arg_10h & 1) != 0) {\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n                return 0x3eb;\n            }\n            iVar1 = fcn.00402c2e(hKey, &var_10ch, arg_10h);\n        } while (iVar1 == 0);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n        pcVar2 = fcn.004064d9(3);\n        if (pcVar2 == NULL) {\n            iVar1 = (*_sym.imp.ADVAPI32.dll_RegDeleteKeyA)(arg_8h, lpSubKey);\n        }\n        else {\n            iVar1 = (*pcVar2)(arg_8h, lpSubKey, arg_10h & 0x300, 0);\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 367
    },
    "00402d75": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402d75(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    uint var_40h;\n    \n    if (arg_8h == 0) {\n        if (*0x41f8e4 == 0) {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n            if (*0x424730 < uVar1) {\n                if (*0x424728 == 0) {\n                    *0x41f8e4 = (*_sym.imp.USER32.dll_CreateDialogParamA)(*0x424720, 0x6f, 0, fcn.00402cdd, 0);\n                    (*_sym.imp.USER32.dll_ShowWindow)(*0x41f8e4, 5);\n                }\n                else if ((*0x4247f4 & 1) != 0) {\n                    uVar2 = fcn.00402d59();\n                    (*_sym.imp.USER32.dll_wsprintfA)(&var_40h, \"... %d%%\", uVar2);\n                    fcn.00405268(0, &var_40h);\n                }\n            }\n        }\n        else {\n            fcn.00406515(0);\n        }\n    }\n    else {\n        if (*0x41f8e4 != 0) {\n            (*_sym.imp.USER32.dll_DestroyWindow)(*0x41f8e4);\n        }\n        *0x41f8e4 = 0;\n    }\n    return;\n}\n",
        "token_count": 337
    },
    "00404236": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404236(int32_t arg_8h, uint hdc, uint hWnd)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    uint uVar3;\n    uint var_ch;\n    uint var_8h;\n    \n    if ((((arg_8h - 0x133U < 6) &&\n         (puVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(hWnd, 0xffffffeb),  pcVar1 = _sym.imp.USER32.dll_GetSysColor, \n         puVar2 != NULL)) && (puVar2[2] < 2)) && ((puVar2[4] < 3 && ((puVar2[5] & 0xffffffe0) == 0)))) {\n        uVar3 = *puVar2;\n        if ((puVar2[5] & 2) != 0) {\n            uVar3 = (*_sym.imp.USER32.dll_GetSysColor)(uVar3);\n        }\n        if ((*(puVar2 + 5) & 1) != 0) {\n            (*_sym.imp.GDI32.dll_SetTextColor)(hdc, uVar3);\n        }\n        (*_sym.imp.GDI32.dll_SetBkMode)(hdc, puVar2[4]);\n        var_8h = puVar2[1];\n        if ((*(puVar2 + 5) & 8) != 0) {\n            var_8h = (*pcVar1)(var_8h);\n        }\n        if ((*(puVar2 + 5) & 4) != 0) {\n            (*_sym.imp.GDI32.dll_SetBkColor)(hdc, var_8h);\n        }\n        if ((*(puVar2 + 5) & 0x10) != 0) {\n            var_ch = puVar2[2];\n            if (puVar2[3] != 0) {\n                (*_sym.imp.GDI32.dll_DeleteObject)(puVar2[3]);\n            }\n            uVar3 = (*_sym.imp.GDI32.dll_CreateBrushIndirect)(&var_ch);\n            puVar2[3] = uVar3;\n        }\n        return puVar2[3];\n    }\n    return 0;\n}\n",
        "token_count": 494
    },
    "0040433a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040433a(uint arg_8h, int32_t arg_ch, uint arg_10h, int32_t arg_14h)\n\n{\n    uint32_t *puVar1;\n    char cVar2;\n    code *pcVar3;\n    code *pcVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint uVar8;\n    uint32_t uVar9;\n    char *pcVar10;\n    char *var_ch;\n    int32_t var_8h;\n    code *var_4h;\n    \n    pcVar5 = _sym.imp.USER32.dll_SendMessageA;\n    pcVar3 = _sym.imp.USER32.dll_GetDlgItem;\n    if (arg_ch == 0x110) {\n        iVar7 = *(arg_14h + 0x30);\n        if (iVar7 < 0) {\n            iVar7 = *(*0x423efc - (iVar7 * 4 + 4));\n        }\n        cVar2 = *(iVar7 + *0x424778);\n        var_8h = 0;\n        pcVar10 = iVar7 + *0x424778 + 1;\n        var_4h = fcn.00404305;\n        uVar9 = ~*(arg_14h + 0x14) >> 5 & 1 | *(arg_14h + 0x14) & 1;\n        var_ch = pcVar10;\n        fcn.004041cf(arg_8h, 0x22, *(arg_14h + 0x34));\n        fcn.004041cf(arg_8h, 0x23, *(arg_14h + 0x38));\n        (*_sym.imp.USER32.dll_CheckDlgButton)(arg_8h, (uVar9 == 0) + 0x40a, 1);\n        fcn.004041f1(uVar9);\n        uVar6 = (*_sym.imp.USER32.dll_GetDlgItem)(arg_8h, 1000);\n        fcn.00404204(uVar6);\n        pcVar3 = _sym.imp.USER32.dll_SendMessageA;\n        (*_sym.imp.USER32.dll_SendMessageA)(uVar6, 0x45b, 1, 0);\n        iVar7 = *(*0x424734 + 0x68);\n        if (iVar7 < 0) {\n            iVar7 = (*_sym.imp.USER32.dll_GetSysColor)(-iVar7);\n        }\n        (*pcVar3)(uVar6, 0x443, 0, iVar7);\n        (*pcVar3)(uVar6, 0x445, 0, 0x4010000);\n        uVar8 = fcn.00406157(pcVar10);\n        (*pcVar3)(uVar6, 0x435, 0, uVar8);\n        *0x41fcfc = 0;\n        (*pcVar3)(uVar6, 0x449, cVar2, &var_ch);\n        *0x41fcfc = 0;\n        return 0;\n    }\n    if (arg_ch == 0x111) {\n        if (((arg_10h >> 0x10 != 0) || (*0x41fcfc != 0)) || (puVar1 = *0x420508 + 0x14,  (*puVar1 & 0x20) == 0))\n        goto code_r0x004045a7;\n        uVar6 = (*_sym.imp.USER32.dll_GetDlgItem)(arg_8h, 0x40a, 0xf0, 0, 0);\n        uVar9 = (*pcVar5)(uVar6);\n        *puVar1 = *puVar1 & 0xfffffffe | uVar9 & 1;\n        fcn.004041f1(uVar9 & 1);\n        fcn.004045ba();\n    }\n    if (arg_ch == 0x4e) {\n        uVar6 = (*pcVar3)(arg_8h, 1000);\n        if ((*(arg_14h + 8) == 0x70b) && (*(arg_14h + 0xc) == 0x201)) {\n            var_8h = *(arg_14h + 0x1c);\n            var_ch = *(arg_14h + 0x18);\n            var_4h = 0x4236c0;\n            if (var_8h - var_ch < 0x800) {\n                (*pcVar5)(uVar6, 1099, 0, &var_ch);\n                pcVar4 = _sym.imp.USER32.dll_LoadCursorA;\n                uVar6 = (*_sym.imp.USER32.dll_LoadCursorA)(0, 0x7f02);\n                pcVar3 = _sym.imp.USER32.dll_SetCursor;\n                (*_sym.imp.USER32.dll_SetCursor)(uVar6);\n                uVar8 = 1;\n                uVar6 = var_4h;\n                fcn.004045de(arg_8h, var_4h);\n                uVar6 = (*pcVar4)(0, 0x7f00, arg_8h, uVar6, uVar8);\n                (*pcVar3)(uVar6);\n            }\n        }\n        if ((*(arg_14h + 8) == 0x700) && (*(arg_14h + 0xc) == 0x100)) {\n            if (*(arg_14h + 0x10) == 0xd) {\n                (*pcVar5)(*0x424728, 0x111, 1, 0);\n            }\n            if (*(arg_14h + 0x10) == 0x1b) {\n                (*pcVar5)(*0x424728, 0x10, 0, 0);\n            }\n            return 1;\n        }\n    }\n    else if (arg_ch == 0x40b) {\n        *0x41fcfc = *0x41fcfc + 1;\n    }\ncode_r0x004045a7:\n    uVar6 = fcn.00404236(arg_ch, arg_10h, arg_14h);\n    return uVar6;\n}\n",
        "token_count": 1376
    },
    "00401389": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "log keystrokes via raw input data/18af53aa16f24c3fa3538f182ae5df5a"
        ],
        "decompiled_code": "\nuint fcn.00401389(int32_t param_1)\n\n{\n    int32_t *hWndChildAfter;\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_retaddr;\n    \n    while ((-1 < param_1 && (hWndChildAfter = param_1 * 0x1c + *0x424770,  *hWndChildAfter != 1))) {\n        iVar1 = fcn.00401434(hWndChildAfter);\n        if (iVar1 == 0x7fffffff) {\n            return 0x7fffffff;\n        }\n        iVar1 = fcn.0040136d();\n        if (iVar1 == 0) {\n            iVar2 = 1;\n            iVar1 = param_1 + 1;\n        }\n        else {\n            iVar1 = iVar1 + -1;\n            iVar2 = iVar1 - param_1;\n        }\n        param_1 = iVar1;\n        if (unaff_retaddr != 0) {\n            *0x423f0c = *0x423f0c + iVar2;\n            uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(*0x423f0c, 30000, *0x423ef4, 0);\n            (*_sym.imp.USER32.dll_SendMessageA)(0x4013a8, 0x402, uVar3);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 320
    },
    "00402bea": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402bea(uint arg_8h, char *arg_ch, uint32_t arg_10h)\n\n{\n    uint uVar1;\n    int32_t arg_8h_00;\n    \n    if (*arg_ch == '\\0') {\n        uVar1 = 0x3eb;\n    }\n    else {\n        arg_10h = arg_10h | 0x100020;\n        uVar1 = fcn.00402ba4(arg_8h, &arg_10h);\n        arg_8h_00 = fcn.00405f4c(uVar1);\n        if (arg_8h_00 == 0) {\n            uVar1 = 6;\n        }\n        else {\n            uVar1 = fcn.00402c2e(arg_8h_00, arg_ch, arg_10h);\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 201
    },
    "00402cdd": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402cdd(uint arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    char *pcVar2;\n    uint *arg_18h;\n    uint var_40h;\n    \n    if (arg_ch == 0x110) {\n        (*_sym.imp.USER32.dll_SetTimer)(arg_8h, 1, 0xfa, 0);\n        arg_ch = 0x113;\n    }\n    if (arg_ch == 0x113) {\n        uVar1 = fcn.00402d59();\n        pcVar2 = \"unpacking data: %d%%\";\n        if (*0x424734 == 0) {\n            pcVar2 = \"verifying installer: %d%%\";\n        }\n        (*_sym.imp.USER32.dll_wsprintfA)(&var_40h, pcVar2, uVar1);\n        arg_18h = &var_40h;\n        uVar1 = arg_8h;\n        (*_sym.imp.USER32.dll_SetWindowTextA)();\n        fcn.0040583b(arg_8h, 0x406, &var_40h, uVar1, arg_18h);\n    }\n    return 0;\n}\n",
        "token_count": 270
    },
    "004045ba": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.004045ba(void)\n\n{\n    uint uVar1;\n    \n    uVar1 = *0x41fcf8;\n    if (*0x4247cc == 0) {\n        uVar1 = *0x420d2c;\n    }\n    (*_sym.imp.USER32.dll_SendMessageA)(uVar1, 0xf4, 1, 1);\n    return;\n}\n",
        "token_count": 90
    },
    "004048c2": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint8_t * fcn.004048c2(int32_t param_1)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    uint8_t *puVar3;\n    \n    if (*(param_1 + 3) == '\\x01') {\n        return param_1 + 4;\n    }\n    puVar3 = param_1 + 4;\n    puVar2 = puVar3;\n    while( true ) {\n        if (*(param_1 + 2) != 0) {\n            *puVar3 = *puVar3 ^ *(param_1 + 2);\n        }\n        uVar1 = *puVar3;\n        *puVar3 = ~uVar1;\n        if (~uVar1 == 0) break;\n        puVar3 = puVar3 + 1;\n    }\n    *(param_1 + 3) = 1;\n    return puVar2;\n}\n",
        "token_count": 204
    },
    "00405cda": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2",
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nvoid __fastcall fcn.00405cda(uint8_t param_1)\n\n{\n    uint8_t in_AL;\n    int32_t unaff_EBP;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    uint var_700h;\n    uint var_394h;\n    uint var_24h;\n    \n    while( true ) {\n        *(unaff_EBP + -0x394 + *(unaff_EBP + -0x700)) = in_AL ^ param_1;\n        *(unaff_EBP + -0x394 + *(unaff_EBP + -0x700)) = ~*(unaff_EBP + -0x394 + *(unaff_EBP + -0x700));\n        *(unaff_EBP + -0x700) = *(unaff_EBP + -0x700) + 1;\n        if (4 < *(unaff_EBP + -0x700)) break;\n        in_AL = *(unaff_EBP + -0x394 + *(unaff_EBP + -0x700));\n        param_1 = *(unaff_EBP + -0x24);\n    }\n    fcn.004048b2();\n    *unaff_EDI = *unaff_ESI;\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 299
    },
    "00404661": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_48h\n\nuint * __cdecl\nfcn.00404661(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint noname_22, uint noname_23, uint noname_24, uint noname_25, uint arg_8h\n            , uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    uint unaff_ESI;\n    uint *puVar6;\n    uint *unaff_EDI;\n    uint *var_8h_2;\n    int32_t var_ch;\n    uint32_t var_10h;\n    int32_t var_14h;\n    uint var_1ch;\n    uint var_8h;\n    uint var_4h;\n    uint *puVar7;\n    uint noname_2_00;\n    uint *var_4ch;\n    uint var_48h;\n    uint *var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint *var_34h;\n    int32_t iStack32;\n    uint var_8h_3;\n    uint uStack8;\n    \n    iStack32 = *0x420508;\n    var_8h_3 = *(*0x420508 + 0x38);\n    puVar5 = *(*0x420508 + 0x3c) * 0x400 + 0x425000;\n    if (var_ch == 0x40b) {\n        func_0x00405841(0x3fb, puVar5);\n        unaff_EDI = puVar5;\n        fcn.004063ab();\n    }\n    if (var_ch == 0x110) {\n        noname_2_00 = 0x3fb;\n        puVar6 = var_8h_2;\n        uVar1 = (*_sym.imp.USER32.dll_GetDlgItem)();\n        iVar2 = fcn.00405b46(puVar5, puVar6, noname_2_00, unaff_EDI, unaff_ESI);\n        if (iVar2 != 0) {\n            iVar2 = fcn.00405b72(puVar5);\n            if (iVar2 == 0) {\n                fcn.00405ad9(puVar5);\n            }\n        }\n        *0x423ef8 = var_8h_2;\n        (*_sym.imp.USER32.dll_SetWindowTextA)(uVar1, puVar5);\n        var_3ch = *(var_14h + 0x34);\n        var_40h = 1;\n        var_44h = var_8h_2;\n        var_48h = 0x4046ee;\n        fcn.004041cf();\n        var_48h = *(var_14h + 0x30);\n        var_4ch = 0x14;\n        fcn.004041cf(var_8h_2);\n        fcn.00404204(uVar1);\n        unaff_EDI = 0x7;\n        pcVar3 = fcn.004064d9();\n        if (pcVar3 == NULL) goto code_r0x0040499d;\n        (*pcVar3)(uVar1, 1);\n    }\n    uVar1 = var_8h_3;\n    if (var_ch == 0x111) {\n        if ((var_10h & 0xffff) == 0x3fb) {\n            if (var_10h >> 0x10 != 0x300) goto code_r0x0040499d;\n            var_ch = 0x40f;\n        }\n        if ((var_10h & 0xffff) == 0x3e9) {\n            puVar6 = &fcn.00404661::var_48h;\n            for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            var_4ch = var_8h_2;\n            var_44h = 0x420d30;\n            var_38h = 0x4049b2;\n            var_34h = puVar5;\n            var_40h = func_0x00406163(0x420108, uVar1);\n            var_3ch = 0x41;\n            iVar2 = (*_sym.imp.SHELL32.dll_SHBrowseForFolderA)(&fcn.00404661::var_4ch);\n            if (iVar2 == 0) {\n                var_ch = 0x40f;\n            }\n            else {\n                (*_sym.imp.ole32.dll_CoTaskMemFree)(iVar2);\n                var_4ch = puVar5;\n                fcn.00405ad9();\n                if ((*(*0x424734 + 0x11c) != 0) && (puVar5 == 0x42a400)) {\n                    uVar1 = 0;\n                    func_0x00406163(0, *(*0x424734 + 0x11c));\n                    iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(0x4236c0, 0x420d30);\n                    if (iVar2 != 0) {\n                        var_4ch = puVar5;\n                        fcn.0040615d(uVar1, 0x4236c0);\n                    }\n                }\n                *0x420d20 = *0x420d20 + 1;\n                fcn.0040583b(var_8h_2, 0x3fb, puVar5, var_4ch, var_48h);\n                unaff_EDI = var_8h_2;\n            }\n        }\n    }\n    if ((var_ch == 0x40f) || (var_ch == 0x405)) {\n        uStack8 = 0;\n        var_8h_3 = 0;\n        puVar7 = 0x3fb;\n        puVar6 = puVar5;\n        func_0x00405841();\n        fcn.00405bc7(puVar5);\n        puVar5 = puVar7;\n        for (uVar4 = unaff_EDI & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar5 = *puVar6;\n            puVar6 = puVar6 + 1;\n            puVar5 = puVar5 + 1;\n        }\n        for (uVar4 = unaff_EDI >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar5 = *puVar6;\n            puVar6 = puVar6 + 1;\n            puVar5 = puVar5 + 1;\n        }\n        return puVar7;\n    }\ncode_r0x0040499d:\n    puVar5 = fcn.004048b2();\n    return puVar5;\n}\n",
        "token_count": 1711
    },
    "00404823": {
        "rules": [
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8",
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00404823(uint *arg_8h, uint *arg_ch, uint32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    \n    puVar2 = arg_8h;\n    for (uVar1 = arg_10h & 3; uVar1 != 0; uVar1 = uVar1 - 1) {\n        *puVar2 = *arg_ch;\n        arg_ch = arg_ch + 1;\n        puVar2 = puVar2 + 1;\n    }\n    for (arg_10h = arg_10h >> 2; arg_10h != 0; arg_10h = arg_10h - 1) {\n        *puVar2 = *arg_ch;\n        arg_ch = arg_ch + 1;\n        puVar2 = puVar2 + 1;\n    }\n    return arg_8h;\n}\n",
        "token_count": 206
    },
    "0040646b": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nvoid fcn.0040646b(void)\n\n{\n    uint arg_ch;\n    int32_t unaff_EBP;\n    uint var_78ch;\n    uint var_785h;\n    uint var_3a0h;\n    uint var_12ch;\n    uint var_28h;\n    uint arg_10h;\n    \n    *(unaff_EBP + -0x785) = 0x3c;\n    *(unaff_EBP + -0x784) = 0x30;\n    *(unaff_EBP + -0x783) = 0x3a;\n    *(unaff_EBP + -0x782) = 0x2d;\n    *(unaff_EBP + -0x781) = 0x71;\n    *(unaff_EBP + -0x780) = 0x3b;\n    *(unaff_EBP + -0x77f) = 0x33;\n    *(unaff_EBP + -0x77e) = 0x33;\n    *(unaff_EBP + -0x77d) = 0x5f;\n    arg_10h = 0xc;\n    arg_ch = fcn.004048c2(unaff_EBP + -0x78c);\n    fcn.00404823(unaff_EBP + -300 + *(unaff_EBP + -0x28), arg_ch, arg_10h);\n    *(unaff_EBP + -0x3a0) = unaff_EBP + -300;\n    *(unaff_EBP + -0x6fc) = *(unaff_EBP + -0x6fc) + 1;\n    *(unaff_EBP + -0x37c) = 0;\n    fcn.004048b2();\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 416
    },
    "004031bd": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004031bd(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EDI;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    param_1 = (*0x41f8dc - *0x40b848) + param_1;\n    *0x424730 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n    *0x424730 = *0x424730 + 500;\n    if (0 < param_1) {\n        fcn.0040333c(*0x41f8ec);\n        (*_sym.imp.KERNEL32.dll_SetFilePointer)(*0x40a01c, *0x40b848, 0);\n        *0x41f8d8 = 0;\n        *0x41f8e8 = param_1;\n        do {\n            iVar3 = 0x4000;\n            if (*0x41f8e0 - *0x41f8ec < 0x4001) {\n                iVar3 = *0x41f8e0 - *0x41f8ec;\n            }\n            iVar1 = fcn.00403326(0x4138d8, iVar3);\n            if (iVar1 == 0) {\n                return -1;\n            }\n            *0x41f8ec = *0x41f8ec + iVar3;\n            *0x40b868 = 0x4138d8;\n            *0x40b86c = iVar3;\n            do {\n                if ((*0x424734 != 0) && (*0x4247e0 == 0)) {\n                    *0x41f8d8 = (*0x41f8e8 - *0x41f8dc) + *0x40b848;\n                    fcn.00402d75(0);\n                }\n                *0x40b870 = 0x40b8d8;\n                *0x40b874 = 0x8000;\n                iVar1 = fcn.0040661e();\n                if (iVar1 < 0) {\n                    return -3;\n                }\n                iVar1 = *0x40b870 + -0x40b8d8;\n                if (iVar1 == 0) {\n                    if (*0x40b86c != 0) {\n                        return -3;\n                    }\n                    if (iVar3 == 0) {\n                        return -3;\n                    }\n                    break;\n                }\n                iVar4 = iVar1;\n                iVar2 = fcn.00405d81();\n                if (iVar2 == 0) {\n                    return iVar4;\n                }\n                *0x40b848 = *0x40b848 + iVar1;\n            } while (*0x40b86c != 0);\n        } while (0 < (*0x41f8dc - *0x40b848) + unaff_EDI);\n        (*_sym.imp.KERNEL32.dll_SetFilePointer)(*0x40a01c, *0x41f8dc, 0, 0);\n    }\n    fcn.00402d75(1);\n    return 0;\n}\n",
        "token_count": 702
    },
    "00402b2c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00402b2c(uint32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    \n    uVar1 = param_1;\n    if (param_1 < 0) {\n        uVar1 = -param_1;\n    }\n    uVar2 = func_0x00406163((uVar1 >> 4) * 0x400 + 0x40a400, *(*0x40b83c + (uVar1 & 0xf) * 4));\n    if (param_1 < 0) {\n        fcn.004063ab(uVar2);\n    }\n    return uVar2;\n}\n",
        "token_count": 150
    },
    "00402e14": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nchar * __cdecl fcn.00402e14(uint *arg_8h)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t *piVar6;\n    uint32_t uVar7;\n    uint arg_14h;\n    uint arg_18h;\n    uint uVar8;\n    uint uVar9;\n    uint arg_18h_00;\n    uint lpFileName;\n    uint32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t dwBytes;\n    uint32_t var_ch;\n    int32_t var_8h;\n    uint *var_4h;\n    \n    var_4h = NULL;\n    var_8h = 0;\n    *0x424730 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n    *0x424730 = *0x424730 + 1000;\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, 0x42bc00, 0x400);\n    arg_18h_00 = 3;\n    uVar9 = 0x80000000;\n    uVar8 = 0x42bc00;\n    puVar1 = fcn.00405cda();\n    if (puVar1 == 0xffffffff) {\n        *0x40a018 = puVar1;\n        return \"Error launching installer\";\n    }\n    arg_18h = 0x42bc00;\n    arg_14h = 0x42ac00;\n    *0x40a018 = puVar1;\n    fcn.00406141(0x42ac00, 0x42bc00, uVar8, uVar9, arg_18h_00);\n    uVar9 = 0x42ac00;\n    uVar8 = fcn.00405b20();\n    fcn.00406141(0x42c000, uVar8, uVar9, arg_14h, arg_18h);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetFileSize)(puVar1, 0);\n    *0x41f8e8 = uVar2;\n    for (; uVar2 != 0; uVar2 = uVar2 - uVar7) {\n        uVar3 = (-(*0x424738 != 0) & 0x7e00) + 0x200;\n        uVar7 = uVar2;\n        if (uVar3 <= uVar2) {\n            uVar7 = uVar3;\n        }\n        puVar1 = 0x4178d8;\n        iVar4 = fcn.00403326();\n        if (iVar4 == 0) {\n            fcn.00402d75(1);\n            goto code_r0x00403066;\n        }\n        if (*0x424738 == 0) {\n            puVar1 = &var_24h;\n            fcn.00405c95();\n            if (((((var_24h & 0xfffffff0) == 0) && (var_20h == -0x21524111)) && (var_14h == 0x74736e49)) &&\n               ((var_18h == 0x74666f73 && (var_1ch == 0x6c6c754e)))) {\n                arg_8h = arg_8h | var_24h;\n                *0x4247e0 = *0x4247e0 | arg_8h & 2;\n                *0x424738 = *0x41f8d8;\n                if (uVar2 < var_ch) goto code_r0x00403066;\n                if (((arg_8h & 8) == 0) && ((arg_8h & 4) != 0)) break;\n                var_8h = var_8h + 1;\n                uVar2 = var_ch - 4;\n                if (uVar2 < uVar7) {\n                    uVar7 = uVar2;\n                }\n            }\n        }\n        else if ((arg_8h & 2) == 0) {\n            fcn.00402d75(0);\n        }\n        if (uVar2 < *0x41f8e8) {\n            puVar5 = fcn.00406590();\n            puVar1 = var_4h;\n            var_4h = puVar5;\n        }\n        *0x41f8d8 = *0x41f8d8 + uVar7;\n    }\n    fcn.00402d75(1);\n    if (*0x424738 != 0) {\n        if (var_8h != 0) {\n            fcn.0040333c(*0x41f8d8, puVar1);\n            iVar4 = fcn.00403326(&arg_8h, 4);\n            if ((iVar4 == 0) || (var_4h != arg_8h)) goto code_r0x00403066;\n        }\n        puVar1 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, dwBytes);\n        fcn.004065fe();\n        fcn.00405d09(&lpFileName, 0x42b400);\n        *0x40a01c = (*_sym.imp.KERNEL32.dll_CreateFileA)(&lpFileName, 0xc0000000, 0, 0, 2, 0x4000100, 0);\n        if (*0x40a01c == -1) {\n            return \"Error writing temporary file. Make sure your temp folder is valid.\";\n        }\n        *0x41f8ec = fcn.0040333c(*0x424738 + 0x1c);\n        *0x41f8e0 = (*0x41f8ec - (~var_24h & 4)) + -0x1c + var_ch;\n        iVar4 = fcn.004030b5(0xffffffff, 0, puVar1, dwBytes);\n        if (iVar4 == dwBytes) {\n            *0x42473c = *puVar1;\n            if ((var_24h & 1) != 0) {\n                *0x424740 = *0x424740 + 1;\n            }\n            piVar6 = puVar1 + 0x11;\n            iVar4 = 8;\n            *0x424734 = puVar1;\n            do {\n                piVar6 = piVar6 + -2;\n                *piVar6 = *piVar6 + puVar1;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n            puVar1[0xf] = *0x41f8dc;\n            fcn.00405c95(0x424760, puVar1 + 1, 0x40);\n            return NULL;\n        }\n    }\ncode_r0x00403066:\n    return \n    \"Installer integrity check has failed. Common causes include\\nincomplete download and damaged media. Contact the\\ninstaller\\'s author to obtain a new copy.\\n\\nMore information at:\\nhttp://nsis.sf.net/NSIS_Error\"\n    ;\n}\n",
        "token_count": 1623
    },
    "004030b5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004030b5(int32_t arg_8h, uint arg_ch, int32_t lpBuffer, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t lpNumberOfBytesRead;\n    \n    if (-1 < arg_8h) {\n        *0x41f8dc = arg_8h + *0x424798;\n        (*_sym.imp.KERNEL32.dll_SetFilePointer)(*0x40a01c, *0x41f8dc, 0, 0);\n    }\n    iVar1 = fcn.004031bd(4);\n    if (iVar1 < 0) {\n        return iVar1;\n    }\n    iVar1 = func_0x00405d52(*0x40a01c, &arg_8h, 4);\n    if (iVar1 != 0) {\n        *0x41f8dc = *0x41f8dc + 4;\n        iVar1 = fcn.004031bd(arg_8h);\n        if (iVar1 < 0) {\n            return iVar1;\n        }\n        if (lpBuffer == 0) {\n            while( true ) {\n                if (arg_8h < 1) {\n                    return iVar1;\n                }\n                lpNumberOfBytesRead = arg_8h;\n                if (0x3fff < arg_8h) {\n                    lpNumberOfBytesRead = 0x4000;\n                }\n                iVar2 = func_0x00405d52(*0x40a01c, 0x4138d8, lpNumberOfBytesRead);\n                if (iVar2 == 0) break;\n                iVar2 = fcn.00405d81(arg_ch, 0x4138d8, lpNumberOfBytesRead);\n                if (iVar2 == 0) {\n                    return -2;\n                }\n                arg_8h = arg_8h - lpNumberOfBytesRead;\n                *0x41f8dc = *0x41f8dc + lpNumberOfBytesRead;\n                iVar1 = iVar1 + lpNumberOfBytesRead;\n            }\n        }\n        else {\n            iVar1 = arg_8h;\n            if (arg_14h <= arg_8h) {\n                iVar1 = arg_14h;\n            }\n            iVar1 = (*_sym.imp.KERNEL32.dll_ReadFile)(*0x40a01c, lpBuffer, iVar1, &lpNumberOfBytesRead, 0);\n            if (iVar1 != 0) {\n                *0x41f8dc = *0x41f8dc + lpNumberOfBytesRead;\n                return lpNumberOfBytesRead;\n            }\n        }\n    }\n    return -3;\n}\n",
        "token_count": 593
    },
    "00404305": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404305(int32_t arg_8h, uint arg_ch, uint arg_10h, int32_t *arg_14h)\n\n{\n    int32_t iVar1;\n    \n    (*_sym.imp.KERNEL32.dll_lstrcpynA)(arg_ch, *0x41fcfc + arg_8h, arg_10h);\n    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_ch);\n    *arg_14h = iVar1;\n    *0x41fcfc = *0x41fcfc + iVar1;\n    return 0;\n}\n",
        "token_count": 134
    },
    "00404884": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00404884(void)\n\n{\n    return;\n}\n",
        "token_count": 15
    },
    "004048b2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.004048b2(void)\n\n{\n    uint in_EAX;\n    \n    return in_EAX;\n}\n",
        "token_count": 26
    },
    "0040572e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040572e(void)\n\n{\n    code *UNRECOVERED_JUMPTABLE;\n    \n    // WARNING: Could not recover jumptable at 0x00405734. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*UNRECOVERED_JUMPTABLE)();\n    return;\n}\n",
        "token_count": 73
    },
    "004057ab": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain obfuscated stackstrings",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00405917) overlaps instruction at (ram,0x00405914)\n// \n\nvoid __cdecl fcn.004057ab(uint noname_0, uint noname_1, uint noname_2, uint arg_14h, uint arg_18h)\n\n{\n    uchar uVar1;\n    uint8_t uVar2;\n    uint in_EAX;\n    uint uVar4;\n    int32_t in_ECX;\n    int32_t iVar5;\n    uint32_t unaff_EBX;\n    uint *unaff_EDI;\n    uint *puVar6;\n    bool bVar7;\n    uint var_504h;\n    uint var_3d4h;\n    uint var_36ch;\n    uint var_24h;\n    char *pcVar3;\n    \n    for (; in_ECX != 0; in_ECX = in_ECX + -1) {\n        *unaff_EDI = in_EAX;\n        unaff_EDI = unaff_EDI + 1;\n    }\n    *unaff_EDI = in_EAX;\n    *(unaff_EDI + 2) = in_EAX;\n    *0xfffff4a9 = 0;\n    puVar6 = 0xfffff4aa;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    iVar5 = fcn.00404890();\n    *(iVar5 + 0x2ff845c6) = *(iVar5 + 0x2ff845c6) | iVar5 >> 8;\n    *0xfffff989 = '4';\n    *0xfffff641 = 0;\n    *0xfffff642 = 0;\n    *0xfffff643 = 0xaa;\n    *0xfffff644 = 0;\n    *0xfffff645 = 0x12;\n    *0xfffff646 = 0x30;\n    *0xfffff647 = 0x21;\n    *0xfffff648 = 6;\n    *0xfffff649 = 0x2c;\n    *0xfffff64a = 0x26;\n    *0xfffff64b = 0x21;\n    *0xfffff64c = 0x30;\n    *0xfffff64d = 0x38;\n    *0xfffff64e = 0x11;\n    *0xfffff64f = 0x3c;\n    *0xfffff650 = 0x27;\n    *0xfffff651 = 0x30;\n    *0xfffff652 = 0x36;\n    *0xfffff653 = 0x21;\n    *0xfffff654 = 0x3a;\n    *0xfffff655 = 0x27;\n    *0xfffff656 = 0x2c;\n    *0xfffff657 = 0x14;\n    *0xfffff658 = 0x55;\n    fcn.004048c2();\n    *0xfffff5d9 = fcn.00404877(*0xfffff9c1, *0xfffff9c5);\n    bVar7 = *0x10 == NULL;\n    uVar1 = fcn.004048b2();\n    *(puVar6 + 3) = uVar1;\n    LOCK();\n    if (!bVar7) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uVar2 = unaff_EBX + 1;\n    pcVar3 = unaff_EBX & 0xffffff00 | uVar2;\n    *pcVar3 = *pcVar3 + uVar2;\n    *0xfffff985 = (**0xfffff5d9)();\n    fcn.004048b2();\n    *0xfffff98e = 0;\n    *0xfffff98f = 0x1d;\n    *0xfffff990 = 0;\n    *0xfffff991 = 0xa5;\n    *0xfffff992 = 0x87;\n    *0xfffff993 = 0x96;\n    *0xfffff994 = 0xb6;\n    *0xfffff995 = 0x87;\n    *0xfffff996 = 0x8f;\n    *0xfffff997 = 0x92;\n    *0xfffff998 = 0xb2;\n    *0xfffff999 = 0x83;\n    *0xfffff99a = 0x96;\n    *0xfffff99b = 0x8a;\n    *0xfffff99c = 0xa3;\n    *0xfffff99d = 0xe2;\n    uVar4 = fcn.004048c2(0xfffff98d);\n    *0xfffff63d = fcn.00404877(*0xfffff9c1, *0xfffff9c5, uVar4);\n    *0xfffff45d = (**0xfffff63d)(0x104, 0xfffff359);\n    if (*(*0xfffff985 + -0x780) == '\\\\') {\n        *0xfffff985 = *0xfffff985 + -1;\n    }\n    if (*(*0xfffff45d + -0xca8) == '\\\\') {\n        *0xfffff45d = *0xfffff45d + -1;\n    }\n    *0xfffff675 = 0;\n    for (*0xfffff5dd = 0; *0xfffff5dd < 0x104; *0xfffff5dd = *0xfffff5dd + 1) {\n        if ((*(*0xfffff5dd + -0x987) & 0x80U) == 0) {\n            if (*(*0xfffff5dd + -0x987) == '\\\\') {\n                *0xfffff675 = *0xfffff5dd;\n            }\n            if (*(*0xfffff5dd + -0x987) == '\\0') break;\n        }\n        else {\n            *0xfffff5dd = *0xfffff5dd + 1;\n        }\n    }\n    *0xfffff33d = *0xfffff33d + *0xfffff629 + 1;\n    fcn.00404823(0xfffff77d, 0xfffff679, *0xfffff675);\n    *0xfffff33d = *0xfffff33d + 2;\n    *0xfffff9a9 = 0;\n    *0xfffff60d = 0;\n    *0xfffff631 = 0;\n    *0xfffff625 = 0;\n    *0xfffff639 = 0;\n    *0xfffff9a5 = *0xfffff9a5 + *0xfffff33d;\n    *0xfffff465 = *0xfffff9b5;\n    *0xfffff471 = *0xfffff9b5 + *(*0xfffff9b5 + 0x3c);\n    *0xfffff605 = *0xfffff9b5 + *(*0xfffff471 + 0x28);\n    *0xfffff989 = *0xfffff989 - *0xfffff33d;\n    fcn.00404890();\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 1661
    },
    "null": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00405909": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nvoid __fastcall fcn.00405909(uint param_1, ushort param_2)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    int32_t unaff_EBP;\n    \n    out(param_2, in_EAX);\n    *0xe2f045c6 = in_EAX;\n    uVar1 = fcn.004048c2(unaff_EBP + -0x1f);\n    uVar1 = fcn.00404877(*(unaff_EBP + 0x15), *(unaff_EBP + 0x19), uVar1);\n    *(unaff_EBP + -0x36f) = uVar1;\n    uVar1 = (**(unaff_EBP + -0x36f))(0x104, unaff_EBP + -0x653);\n    *(unaff_EBP + -0x54f) = uVar1;\n    if (*(unaff_EBP + -300 + *(unaff_EBP + -0x27)) == '\\\\') {\n        *(unaff_EBP + -0x27) = *(unaff_EBP + -0x27) + -1;\n    }\n    if (*(unaff_EBP + -0x654 + *(unaff_EBP + -0x54f)) == '\\\\') {\n        *(unaff_EBP + -0x54f) = *(unaff_EBP + -0x54f) + -1;\n    }\n    *(unaff_EBP + -0x337) = 0;\n    *(unaff_EBP + -0x3cf) = 0;\n    while (*(unaff_EBP + -0x3cf) < 0x104) {\n        if ((*(unaff_EBP + -0x333 + *(unaff_EBP + -0x3cf)) & 0x80U) == 0) {\n            if (*(unaff_EBP + -0x333 + *(unaff_EBP + -0x3cf)) == '\\\\') {\n                *(unaff_EBP + -0x337) = *(unaff_EBP + -0x3cf);\n            }\n            if (*(unaff_EBP + -0x333 + *(unaff_EBP + -0x3cf)) == '\\0') break;\n        }\n        else {\n            *(unaff_EBP + -0x3cf) = *(unaff_EBP + -0x3cf) + 1;\n        }\n        *(unaff_EBP + -0x3cf) = *(unaff_EBP + -0x3cf) + 1;\n    }\n    *(unaff_EBP + -0x66f) = *(unaff_EBP + -0x66f) + *(unaff_EBP + -899);\n    *(unaff_EBP + -0x66f) = *(unaff_EBP + -0x66f) + 1;\n    fcn.00404823(unaff_EBP + -0x22f, unaff_EBP + -0x333, *(unaff_EBP + -0x337));\n    *(unaff_EBP + -0x66f) = *(unaff_EBP + -0x66f) + 1;\n    *(unaff_EBP + -0x66f) = *(unaff_EBP + -0x66f) + 1;\n    *(unaff_EBP + -3) = 0;\n    *(unaff_EBP + -0x39f) = 0;\n    *(unaff_EBP + -0x37b) = 0;\n    *(unaff_EBP + -0x387) = 0;\n    *(unaff_EBP + -0x373) = 0;\n    *(unaff_EBP + -7) = *(unaff_EBP + -7) + *(unaff_EBP + -0x66f);\n    *(unaff_EBP + -0x547) = *(unaff_EBP + 9);\n    *(unaff_EBP + -0x53b) = *(unaff_EBP + -0x547) + *(*(unaff_EBP + -0x547) + 0x3c);\n    *(unaff_EBP + -0x3a7) = *(unaff_EBP + 9) + *(*(unaff_EBP + -0x53b) + 0x28);\n    *(unaff_EBP + -0x23) = *(unaff_EBP + -0x23) - *(unaff_EBP + -0x66f);\n    fcn.00404890();\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 1024
    },
    "004057c8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain obfuscated stackstrings",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00405917) overlaps instruction at (ram,0x00405914)\n// \n\nvoid __cdecl fcn.004057c8(uint noname_0, uint noname_1, uint noname_2, uint arg_14h, uint arg_18h)\n\n{\n    uchar uVar1;\n    uint8_t uVar2;\n    uint in_EAX;\n    int32_t iVar3;\n    uint uVar4;\n    uint32_t unaff_EBX;\n    int32_t unaff_EBP;\n    uint *unaff_EDI;\n    bool bVar6;\n    uint var_3d4h;\n    uint var_36ch;\n    uint var_24h;\n    char *pcVar5;\n    \n    *unaff_EDI = in_EAX;\n    *(unaff_EDI + 1) = in_EAX;\n    *(unaff_EDI + 6) = in_EAX;\n    iVar3 = fcn.00404890();\n    *(iVar3 + 0x2ff845c6) = *(iVar3 + 0x2ff845c6) | iVar3 >> 8;\n    *(unaff_EBP + -0x24) = 0x34;\n    *(unaff_EBP + -0x36c) = 0;\n    *(unaff_EBP + -0x36b) = 0;\n    *(unaff_EBP + -0x36a) = 0xaa;\n    *(unaff_EBP + -0x369) = 0;\n    *(unaff_EBP + -0x368) = 0x12;\n    *(unaff_EBP + -0x367) = 0x30;\n    *(unaff_EBP + -0x366) = 0x21;\n    *(unaff_EBP + -0x365) = 6;\n    *(unaff_EBP + -0x364) = 0x2c;\n    *(unaff_EBP + -0x363) = 0x26;\n    *(unaff_EBP + -0x362) = 0x21;\n    *(unaff_EBP + -0x361) = 0x30;\n    *(unaff_EBP + -0x360) = 0x38;\n    *(unaff_EBP + -0x35f) = 0x11;\n    *(unaff_EBP + -0x35e) = 0x3c;\n    *(unaff_EBP + -0x35d) = 0x27;\n    *(unaff_EBP + -0x35c) = 0x30;\n    *(unaff_EBP + -0x35b) = 0x36;\n    *(unaff_EBP + -0x35a) = 0x21;\n    *(unaff_EBP + -0x359) = 0x3a;\n    *(unaff_EBP + -0x358) = 0x27;\n    *(unaff_EBP + -0x357) = 0x2c;\n    *(unaff_EBP + -0x356) = 0x14;\n    *(unaff_EBP + -0x355) = 0x55;\n    fcn.004048c2();\n    uVar4 = fcn.00404877(*(unaff_EBP + 0x14), *(unaff_EBP + 0x18));\n    bVar6 = *0x10 == NULL;\n    *(unaff_EBP + -0x3d4) = uVar4;\n    uVar1 = fcn.004048b2();\n    *(unaff_EDI + 7) = uVar1;\n    LOCK();\n    if (!bVar6) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uVar2 = unaff_EBX + 1;\n    pcVar5 = unaff_EBX & 0xffffff00 | uVar2;\n    *pcVar5 = *pcVar5 + uVar2;\n    uVar4 = (**(unaff_EBP + -0x3d4))();\n    *(unaff_EBP + -0x28) = uVar4;\n    fcn.004048b2();\n    *(unaff_EBP + -0x1f) = 0;\n    *(unaff_EBP + -0x1e) = 0x1d;\n    *(unaff_EBP + -0x1d) = 0;\n    *(unaff_EBP + -0x1c) = 0xa5;\n    *(unaff_EBP + -0x1b) = 0x87;\n    *(unaff_EBP + -0x1a) = 0x96;\n    *(unaff_EBP + -0x19) = 0xb6;\n    *(unaff_EBP + -0x18) = 0x87;\n    *(unaff_EBP + -0x17) = 0x8f;\n    *(unaff_EBP + -0x16) = 0x92;\n    *(unaff_EBP + -0x15) = 0xb2;\n    *(unaff_EBP + -0x14) = 0x83;\n    *(unaff_EBP + -0x13) = 0x96;\n    *(unaff_EBP + -0x12) = 0x8a;\n    *(unaff_EBP + -0x11) = 0xa3;\n    *(unaff_EBP + -0x10) = 0xe2;\n    uVar4 = fcn.004048c2(unaff_EBP + -0x20);\n    uVar4 = fcn.00404877(*(unaff_EBP + 0x14), *(unaff_EBP + 0x18), uVar4);\n    *(unaff_EBP + -0x370) = uVar4;\n    uVar4 = (**(unaff_EBP + -0x370))(0x104, unaff_EBP + -0x654);\n    *(unaff_EBP + -0x550) = uVar4;\n    if (*(unaff_EBP + -0x12d + *(unaff_EBP + -0x28)) == '\\\\') {\n        *(unaff_EBP + -0x28) = *(unaff_EBP + -0x28) + -1;\n    }\n    if (*(unaff_EBP + -0x655 + *(unaff_EBP + -0x550)) == '\\\\') {\n        *(unaff_EBP + -0x550) = *(unaff_EBP + -0x550) + -1;\n    }\n    *(unaff_EBP + -0x338) = 0;\n    *(unaff_EBP + -0x3d0) = 0;\n    while (*(unaff_EBP + -0x3d0) < 0x104) {\n        if ((*(unaff_EBP + -0x334 + *(unaff_EBP + -0x3d0)) & 0x80U) == 0) {\n            if (*(unaff_EBP + -0x334 + *(unaff_EBP + -0x3d0)) == '\\\\') {\n                *(unaff_EBP + -0x338) = *(unaff_EBP + -0x3d0);\n            }\n            if (*(unaff_EBP + -0x334 + *(unaff_EBP + -0x3d0)) == '\\0') break;\n        }\n        else {\n            *(unaff_EBP + -0x3d0) = *(unaff_EBP + -0x3d0) + 1;\n        }\n        *(unaff_EBP + -0x3d0) = *(unaff_EBP + -0x3d0) + 1;\n    }\n    *(unaff_EBP + -0x670) = *(unaff_EBP + -0x670) + *(unaff_EBP + -900);\n    *(unaff_EBP + -0x670) = *(unaff_EBP + -0x670) + 1;\n    fcn.00404823(unaff_EBP + -0x230, unaff_EBP + -0x334, *(unaff_EBP + -0x338));\n    *(unaff_EBP + -0x670) = *(unaff_EBP + -0x670) + 1;\n    *(unaff_EBP + -0x670) = *(unaff_EBP + -0x670) + 1;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x3a0) = 0;\n    *(unaff_EBP + -0x37c) = 0;\n    *(unaff_EBP + -0x388) = 0;\n    *(unaff_EBP + -0x374) = 0;\n    *(unaff_EBP + -8) = *(unaff_EBP + -8) + *(unaff_EBP + -0x670);\n    *(unaff_EBP + -0x548) = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x53c) = *(unaff_EBP + -0x548) + *(*(unaff_EBP + -0x548) + 0x3c);\n    *(unaff_EBP + -0x3a8) = *(unaff_EBP + 8) + *(*(unaff_EBP + -0x53c) + 0x28);\n    *(unaff_EBP + -0x24) = *(unaff_EBP + -0x24) - *(unaff_EBP + -0x670);\n    fcn.00404890();\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 2179
    },
    "0040583b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain obfuscated stackstrings",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00405917) overlaps instruction at (ram,0x00405914)\n// \n\nvoid __cdecl fcn.0040583b(uint noname_0, uint noname_1, uint noname_2, uint arg_14h, uint arg_18h)\n\n{\n    uchar uVar1;\n    uint8_t uVar2;\n    uint uVar3;\n    code **in_ECX;\n    uint32_t unaff_EBX;\n    int32_t unaff_EBP;\n    uchar *unaff_EDI;\n    bool bVar5;\n    uint var_3d4h;\n    uint var_36ch;\n    uint var_35eh;\n    char *pcVar4;\n    \n    (**in_ECX)();\n    *(unaff_EBP + -0x35e) = 0x3c;\n    *(unaff_EBP + -0x35d) = 0x27;\n    *(unaff_EBP + -0x35c) = 0x30;\n    *(unaff_EBP + -0x35b) = 0x36;\n    *(unaff_EBP + -0x35a) = 0x21;\n    *(unaff_EBP + -0x359) = 0x3a;\n    *(unaff_EBP + -0x358) = 0x27;\n    *(unaff_EBP + -0x357) = 0x2c;\n    *(unaff_EBP + -0x356) = 0x14;\n    *(unaff_EBP + -0x355) = 0x55;\n    fcn.004048c2();\n    uVar3 = fcn.00404877(*(unaff_EBP + 0x14), *(unaff_EBP + 0x18));\n    bVar5 = *0x10 == NULL;\n    *(unaff_EBP + -0x3d4) = uVar3;\n    uVar1 = fcn.004048b2();\n    *unaff_EDI = uVar1;\n    LOCK();\n    if (!bVar5) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uVar2 = unaff_EBX + 1;\n    pcVar4 = unaff_EBX & 0xffffff00 | uVar2;\n    *pcVar4 = *pcVar4 + uVar2;\n    uVar3 = (**(unaff_EBP + -0x3d4))();\n    *(unaff_EBP + -0x28) = uVar3;\n    fcn.004048b2();\n    *(unaff_EBP + -0x1f) = 0;\n    *(unaff_EBP + -0x1e) = 0x1d;\n    *(unaff_EBP + -0x1d) = 0;\n    *(unaff_EBP + -0x1c) = 0xa5;\n    *(unaff_EBP + -0x1b) = 0x87;\n    *(unaff_EBP + -0x1a) = 0x96;\n    *(unaff_EBP + -0x19) = 0xb6;\n    *(unaff_EBP + -0x18) = 0x87;\n    *(unaff_EBP + -0x17) = 0x8f;\n    *(unaff_EBP + -0x16) = 0x92;\n    *(unaff_EBP + -0x15) = 0xb2;\n    *(unaff_EBP + -0x14) = 0x83;\n    *(unaff_EBP + -0x13) = 0x96;\n    *(unaff_EBP + -0x12) = 0x8a;\n    *(unaff_EBP + -0x11) = 0xa3;\n    *(unaff_EBP + -0x10) = 0xe2;\n    uVar3 = fcn.004048c2(unaff_EBP + -0x20);\n    uVar3 = fcn.00404877(*(unaff_EBP + 0x14), *(unaff_EBP + 0x18), uVar3);\n    *(unaff_EBP + -0x370) = uVar3;\n    uVar3 = (**(unaff_EBP + -0x370))(0x104, unaff_EBP + -0x654);\n    *(unaff_EBP + -0x550) = uVar3;\n    if (*(unaff_EBP + -0x12d + *(unaff_EBP + -0x28)) == '\\\\') {\n        *(unaff_EBP + -0x28) = *(unaff_EBP + -0x28) + -1;\n    }\n    if (*(unaff_EBP + -0x655 + *(unaff_EBP + -0x550)) == '\\\\') {\n        *(unaff_EBP + -0x550) = *(unaff_EBP + -0x550) + -1;\n    }\n    *(unaff_EBP + -0x338) = 0;\n    *(unaff_EBP + -0x3d0) = 0;\n    while (*(unaff_EBP + -0x3d0) < 0x104) {\n        if ((*(unaff_EBP + -0x334 + *(unaff_EBP + -0x3d0)) & 0x80U) == 0) {\n            if (*(unaff_EBP + -0x334 + *(unaff_EBP + -0x3d0)) == '\\\\') {\n                *(unaff_EBP + -0x338) = *(unaff_EBP + -0x3d0);\n            }\n            if (*(unaff_EBP + -0x334 + *(unaff_EBP + -0x3d0)) == '\\0') break;\n        }\n        else {\n            *(unaff_EBP + -0x3d0) = *(unaff_EBP + -0x3d0) + 1;\n        }\n        *(unaff_EBP + -0x3d0) = *(unaff_EBP + -0x3d0) + 1;\n    }\n    *(unaff_EBP + -0x670) = *(unaff_EBP + -0x670) + *(unaff_EBP + -900);\n    *(unaff_EBP + -0x670) = *(unaff_EBP + -0x670) + 1;\n    fcn.00404823(unaff_EBP + -0x230, unaff_EBP + -0x334, *(unaff_EBP + -0x338));\n    *(unaff_EBP + -0x670) = *(unaff_EBP + -0x670) + 1;\n    *(unaff_EBP + -0x670) = *(unaff_EBP + -0x670) + 1;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x3a0) = 0;\n    *(unaff_EBP + -0x37c) = 0;\n    *(unaff_EBP + -0x388) = 0;\n    *(unaff_EBP + -0x374) = 0;\n    *(unaff_EBP + -8) = *(unaff_EBP + -8) + *(unaff_EBP + -0x670);\n    *(unaff_EBP + -0x548) = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x53c) = *(unaff_EBP + -0x548) + *(*(unaff_EBP + -0x548) + 0x3c);\n    *(unaff_EBP + -0x3a8) = *(unaff_EBP + 8) + *(*(unaff_EBP + -0x53c) + 0x28);\n    *(unaff_EBP + -0x24) = *(unaff_EBP + -0x24) - *(unaff_EBP + -0x670);\n    fcn.00404890();\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 1822
    },
    "00405b46": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nvoid __cdecl fcn.00405b46(uint noname_0, uint noname_1, uint noname_2, uint arg_14h, uint arg_18h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    char cVar4;\n    uint var_66ch;\n    uint var_3c8h;\n    uint var_334h;\n    \n    fcn.004048c2();\n    uVar2 = fcn.00404877(*(unaff_EBP + 0x14), *(unaff_EBP + 0x18));\n    *(unaff_EBP + -0x3c8) = uVar2;\n    uVar2 = (**(unaff_EBP + -0x3c8))(unaff_EBP + -0x334, 0x80000000, 1, 0, 3, 0x80);\n    *(unaff_EBP + -0x66c) = uVar2;\n    if (*(unaff_EBP + -0x66c) != -1) {\n        uVar2 = (**(unaff_EBP + -0x33c))(*(unaff_EBP + -0x66c), 0);\n        *(unaff_EBP + -0x378) = uVar2;\n        uVar2 = (**(unaff_EBP + -0x67c))(*(unaff_EBP + -0x674), 8, *(unaff_EBP + -0x378));\n        *(unaff_EBP + -4) = uVar2;\n        fcn.004048b2();\n        *(unaff_EBP + -0x6dc) = 0;\n        *(unaff_EBP + -0x6db) = 0;\n        *(unaff_EBP + -0x6da) = 0x2c;\n        cVar4 = '\\0';\n        *(unaff_EBP + -0x6d9) = 0;\n        *(unaff_EBP + -0x6d8) = 0x81;\n        *(unaff_EBP + -0x6d7) = 0xb6;\n        *(unaff_EBP + -0x6d6) = 0xb2;\n        *(unaff_EBP + -0x6d5) = 0xb7;\n        *(unaff_EBP + -0x6d4) = 0x95;\n        *(unaff_EBP + -0x6d3) = 0xba;\n        *(unaff_EBP + -0x6d2) = 0xbf;\n        *(unaff_EBP + -0x6d1) = 0xb6;\n        *(unaff_EBP + -0x6d0) = 0xd3;\n        iVar3 = fcn.004048b2();\n        pcVar1 = swi(4);\n        if (cVar4 == '\\x01') {\n            iVar3 = (*pcVar1)();\n        }\n        *(unaff_EBP + -0x6db7b) = *(unaff_EBP + -0x6db7b) + -1;\n        (**(iVar3 + -0x18))();\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    return;\n}\n",
        "token_count": 750
    },
    "00405c95": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nvoid __fastcall fcn.00405c95(int32_t param_1)\n\n{\n    int32_t in_EAX;\n    int32_t unaff_EBP;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    uint unaff_retaddr;\n    uint var_700h;\n    uint var_394h;\n    \n    fcn.00404823(unaff_EBP + -0x394, param_1 + -0x1d + in_EAX, unaff_retaddr);\n    *(unaff_EBP + -0x700) = 0;\n    while (*(unaff_EBP + -0x700) < 5) {\n        *(unaff_EBP + -0x394 + *(unaff_EBP + -0x700)) =\n             *(unaff_EBP + -0x394 + *(unaff_EBP + -0x700)) ^ *(unaff_EBP + -0x24);\n        *(unaff_EBP + -0x394 + *(unaff_EBP + -0x700)) = ~*(unaff_EBP + -0x394 + *(unaff_EBP + -0x700));\n        *(unaff_EBP + -0x700) = *(unaff_EBP + -0x700) + 1;\n    }\n    fcn.004048b2();\n    *unaff_EDI = *unaff_ESI;\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 332
    },
    "00405f20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00405f20(void)\n\n{\n    int32_t in_EAX;\n    uint32_t *unaff_EBX;\n    int32_t unaff_EBP;\n    uint unaff_retaddr;\n    uint var_748h;\n    uint var_700h;\n    uint var_6f8h;\n    uint var_688h;\n    uint var_684h;\n    uint var_678h;\n    uint var_3ach;\n    uint var_38ch;\n    uint var_378h;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00404823(unaff_EBP + -0x684, *(unaff_EBP + -4) + -8 + in_EAX, unaff_retaddr);\n    *(unaff_EBP + -0x684) = *(unaff_EBP + -0x684) - *(unaff_EBP + -8);\n    fcn.00404823(unaff_EBP + -0x678, *(unaff_EBP + -4) + -4 + *(unaff_EBP + -0x378), 4);\n    *(unaff_EBP + -0x678) = *(unaff_EBP + -0x678) - *(unaff_EBP + -8);\n    fcn.00404823(unaff_EBP + -0x38c, *(unaff_EBP + -4) + *(unaff_EBP + -0x678), 4);\n    *(unaff_EBP + -0x3ac) = *(unaff_EBP + -0x678) + 4 + *(unaff_EBP + -0x38c);\n    fcn.00404823(unaff_EBP + -0x688, *(unaff_EBP + -4) + *(unaff_EBP + -0x3ac), 4);\n    *(unaff_EBP + -0x748) = *(unaff_EBP + -4) + 4 + *(unaff_EBP + -0x678);\n    *(unaff_EBP + -0x6f8) = *(unaff_EBP + -4) + 4 + *(unaff_EBP + -0x3ac);\n    *(unaff_EBP + -0x700) = 0;\n    while (*(unaff_EBP + -0x700) < *(unaff_EBP + -0x38c)) {\n        *(*(unaff_EBP + -0x748) + *(unaff_EBP + -0x700)) =\n             *(*(unaff_EBP + -0x748) + *(unaff_EBP + -0x700)) ^ *(unaff_EBP + -8);\n        *(*(unaff_EBP + -0x748) + *(unaff_EBP + -0x700)) = ~*(*(unaff_EBP + -0x748) + *(unaff_EBP + -0x700));\n        *(unaff_EBP + -0x700) = *(unaff_EBP + -0x700) + 1;\n    }\n    *(unaff_EBP + -0x700) = 0;\n    while (*(unaff_EBP + -0x700) < *(unaff_EBP + -0x688)) {\n        *(*(unaff_EBP + -0x6f8) + *(unaff_EBP + -0x700)) =\n             *(*(unaff_EBP + -0x6f8) + *(unaff_EBP + -0x700)) ^ *(unaff_EBP + -8);\n        *(*(unaff_EBP + -0x6f8) + *(unaff_EBP + -0x700)) = ~*(*(unaff_EBP + -0x6f8) + *(unaff_EBP + -0x700));\n        *(unaff_EBP + -0x700) = *(unaff_EBP + -0x700) + 1;\n    }\n    *(unaff_EBP + -0x714) = 0;\n    *(unaff_EBP + -0x713) = 0;\n    *(unaff_EBP + -0x712) = 0x71;\n    *(unaff_EBP + -0x711) = 0;\n    *(unaff_EBP + -0x710) = 200;\n    *(unaff_EBP + -0x70f) = 0xe2;\n    *(unaff_EBP + -0x70e) = 0xe1;\n    *(unaff_EBP + -0x70d) = 0xe1;\n    *(unaff_EBP + -0x70c) = 0xea;\n    *(unaff_EBP + -0x70b) = 200;\n    *(unaff_EBP + -0x70a) = 0xe7;\n    *(unaff_EBP + -0x709) = 0xf6;\n    *(unaff_EBP + -0x708) = 0xbc;\n    *(unaff_EBP + -0x707) = 0x8e;\n    fcn.004048b2();\n    *unaff_EBX = *unaff_EBX << 1 | *unaff_EBX < 0;\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 1183
    },
    "00405ff5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nvoid fcn.00405ff5(void)\n\n{\n    uint32_t *unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_748h;\n    uint var_714h;\n    uint var_700h;\n    uint var_6f8h;\n    uint var_688h;\n    uint var_38ch;\n    uint var_8h;\n    \n    while (*(unaff_EBP + -0x700) = *(unaff_EBP + -0x700) + 1,  *(unaff_EBP + -0x700) < *(unaff_EBP + -0x38c)) {\n        *(*(unaff_EBP + -0x748) + *(unaff_EBP + -0x700)) =\n             *(*(unaff_EBP + -0x748) + *(unaff_EBP + -0x700)) ^ *(unaff_EBP + -8);\n        *(*(unaff_EBP + -0x748) + *(unaff_EBP + -0x700)) = ~*(*(unaff_EBP + -0x748) + *(unaff_EBP + -0x700));\n    }\n    *(unaff_EBP + -0x700) = 0;\n    while (*(unaff_EBP + -0x700) < *(unaff_EBP + -0x688)) {\n        *(*(unaff_EBP + -0x6f8) + *(unaff_EBP + -0x700)) =\n             *(*(unaff_EBP + -0x6f8) + *(unaff_EBP + -0x700)) ^ *(unaff_EBP + -8);\n        *(*(unaff_EBP + -0x6f8) + *(unaff_EBP + -0x700)) = ~*(*(unaff_EBP + -0x6f8) + *(unaff_EBP + -0x700));\n        *(unaff_EBP + -0x700) = *(unaff_EBP + -0x700) + 1;\n    }\n    *(unaff_EBP + -0x714) = 0;\n    *(unaff_EBP + -0x713) = 0;\n    *(unaff_EBP + -0x712) = 0x71;\n    *(unaff_EBP + -0x711) = 0;\n    *(unaff_EBP + -0x710) = 200;\n    *(unaff_EBP + -0x70f) = 0xe2;\n    *(unaff_EBP + -0x70e) = 0xe1;\n    *(unaff_EBP + -0x70d) = 0xe1;\n    *(unaff_EBP + -0x70c) = 0xea;\n    *(unaff_EBP + -0x70b) = 200;\n    *(unaff_EBP + -0x70a) = 0xe7;\n    *(unaff_EBP + -0x709) = 0xf6;\n    *(unaff_EBP + -0x708) = 0xbc;\n    *(unaff_EBP + -0x707) = 0x8e;\n    fcn.004048b2();\n    *unaff_EBX = *unaff_EBX << 1 | *unaff_EBX < 0;\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 755
    },
    "00406157": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nvoid fcn.00406157(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint8_t in_CF;\n    uint8_t in_PF;\n    uint8_t in_AF;\n    uint8_t in_ZF;\n    uint8_t in_SF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_OF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    \n    *(unaff_EBP + -0x73d) = 0x99;\n    *(unaff_EBP + -0x73c) = 0xb1;\n    *(unaff_EBP + -0x73b) = 0x94;\n    *(unaff_EBP + -0x73a) = 0x9f;\n    *(unaff_EBP + -0x739) = 0x8f;\n    *(unaff_EBP + -0x738) = 0x9c;\n    *(unaff_EBP + -0x737) = 0x8f;\n    *(unaff_EBP + -0x736) = 0x84;\n    *(unaff_EBP + -0x735) = 0xbc;\n    *(unaff_EBP + -0x734) = 0xfd;\n    uVar1 = fcn.004048c2(unaff_EBP + -0x744, \n                         (in_NT & 1) * 0x4000 | (in_OF & 1) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n                         (in_SF & 1) * 0x80 | (in_ZF & 1) * 0x40 | (in_AF & 1) * 0x10 | (in_PF & 1) * 4 | in_CF & 1 |\n                         (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 |\n                         (in_AC & 1) * 0x40000);\n    uVar1 = fcn.00404877(*(unaff_EBP + 0x14), *(unaff_EBP + 0x18), uVar1);\n    *(unaff_EBP + -0x704) = uVar1;\n    *(unaff_EBP + -0x6f4) = 0;\n    *(unaff_EBP + -0x6f3) = 0;\n    *(unaff_EBP + -0x6f2) = 0x43;\n    *(unaff_EBP + -0x6f1) = 0;\n    *(unaff_EBP + -0x6f0) = 0xeb;\n    *(unaff_EBP + -0x6ef) = 0xce;\n    *(unaff_EBP + -0x6ee) = 0xd5;\n    *(unaff_EBP + -0x6ed) = 200;\n    *(unaff_EBP + -0x6ec) = 0xd9;\n    *(unaff_EBP + -0x6eb) = 0xfa;\n    *(unaff_EBP + -0x6ea) = 0xd5;\n    *(unaff_EBP + -0x6e9) = 0xd0;\n    *(unaff_EBP + -0x6e8) = 0xd9;\n    *(unaff_EBP + -0x6e7) = 0xbc;\n    fcn.004048b2();\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 859
    },
    "004063ab": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nvoid fcn.004063ab(void)\n\n{\n    uint arg_ch;\n    int32_t unaff_EBP;\n    uint var_77ch;\n    uint var_778h;\n    uint var_750h;\n    uint var_504h;\n    uint var_3a0h;\n    uint var_12ch;\n    uint arg_10h;\n    \n    *(unaff_EBP + -0x750) = 0x88;\n    *(unaff_EBP + -0x74f) = 0x89;\n    *(unaff_EBP + -0x74e) = 0x8d;\n    *(unaff_EBP + -0x74d) = 0xd5;\n    *(unaff_EBP + -0x74c) = 0x9f;\n    *(unaff_EBP + -0x74b) = 0x97;\n    *(unaff_EBP + -0x74a) = 0x97;\n    *(unaff_EBP + -0x749) = 0xfb;\n    fcn.004048c2(unaff_EBP + -0x77c);\n    *(unaff_EBP + -0x778) = *(unaff_EBP + -300);\n    arg_10h = 0x30;\n    arg_ch = fcn.004048c2(unaff_EBP + -0x77c);\n    fcn.00404823(unaff_EBP + -0x504, arg_ch, arg_10h);\n    *(unaff_EBP + -0x3a0) = unaff_EBP + -0x504;\n    *(unaff_EBP + -0x6fc) = *(unaff_EBP + -0x6fc) + 1;\n    *(unaff_EBP + -0x37c) = 0;\n    fcn.004048b2();\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 438
    },
    "00406515": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nvoid fcn.00406515(void)\n\n{\n    uint arg_ch;\n    uint8_t extraout_CL;\n    int32_t extraout_EDX;\n    int32_t unaff_EBP;\n    uint unaff_retaddr;\n    uint var_79ch;\n    uint var_796h;\n    uint var_654h;\n    uint var_550h;\n    \n    *(unaff_EBP + -0x796) = 0x80;\n    *(unaff_EBP + -0x795) = 0x81;\n    *(unaff_EBP + -0x794) = 0x9d;\n    *(unaff_EBP + -0x793) = 0x8a;\n    *(unaff_EBP + -0x792) = 0x9c;\n    *(unaff_EBP + -0x791) = 0xc1;\n    *(unaff_EBP + -0x790) = 0x8b;\n    *(unaff_EBP + -0x78f) = 0x83;\n    *(unaff_EBP + -0x78e) = 0x83;\n    *(unaff_EBP + -0x78d) = 0xef;\n    fcn.004048b2();\n    *(extraout_EDX + 0xc) = *(extraout_EDX + 0xc) >> (extraout_CL & 0x1f);\n    arg_ch = fcn.004048c2(unaff_EBP + -0x79c);\n    fcn.00404823(unaff_EBP + -0x654 + *(unaff_EBP + -0x550), arg_ch, unaff_retaddr);\n    *(unaff_EBP + -0x3a0) = unaff_EBP + -0x654;\n    *(unaff_EBP + -0x6fc) = *(unaff_EBP + -0x6fc) + 1;\n    *(unaff_EBP + -0x37c) = 0;\n    fcn.004048b2();\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 476
    },
    "0040661e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nvoid __fastcall fcn.0040661e(int32_t param_1)\n\n{\n    int32_t unaff_EBP;\n    uint16_t in_CS;\n    uint32_t in_stack_fffffffe;\n    uint32_t arg_ch;\n    uint in_stack_00000002;\n    uint var_338h;\n    uint var_230h;\n    \n    arg_ch = in_stack_fffffffe & 0xffff0000 | in_CS;\n    (*(param_1 + 0x50))();\n    fcn.00404823(unaff_EBP + -0x230 + *(unaff_EBP + -0x338), arg_ch, in_stack_00000002);\n    *(unaff_EBP + -0x6fc) = *(unaff_EBP + -0x6fc) + 1;\n    *(unaff_EBP + -0x37c) = 0;\n    fcn.004048b2();\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 231
    },
    "004038ae": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.004038ae(uint param_1)\n\n{\n    uint *puVar1;\n    \n    for (puVar1 = *0x41fcf4; puVar1 != NULL; puVar1 = *puVar1) {\n        (*puVar1[1])(param_1);\n    }\n    return;\n}\n",
        "token_count": 71
    },
    "004038c9": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.004038c9(void)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    \n    piVar2 = *0x41fcf4;\n    fcn.004038ae(0);\n    if (piVar2 != NULL) {\n        do {\n            piVar1 = *piVar2;\n            (*_sym.imp.KERNEL32.dll_FreeLibrary)(piVar2[2]);\n            (*_sym.imp.KERNEL32.dll_GlobalFree)(piVar2);\n            piVar2 = piVar1;\n        } while (piVar1 != NULL);\n    }\n    *0x41fcf4 = NULL;\n    return;\n}\n",
        "token_count": 147
    },
    "00404848": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404848(char *arg_8h, char *arg_ch)\n\n{\n    char cVar1;\n    uint var_4h;\n    \n    do {\n        cVar1 = *arg_8h;\n        if (cVar1 != *arg_ch) {\n            if (cVar1 < *arg_ch) {\n                return 1;\n            }\n            return 0xffffffff;\n        }\n        arg_8h = arg_8h + 1;\n        arg_ch = arg_ch + 1;\n    } while (cVar1 != '\\0');\n    return 0;\n}\n",
        "token_count": 131
    },
    "00405823": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nvoid fcn.00405823(void)\n\n{\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 41
    },
    "004060b8": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nvoid __fastcall fcn.004060b8(uint8_t *param_1)\n\n{\n    uint8_t in_AL;\n    uint32_t *unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_700h;\n    \n    while( true ) {\n        *param_1 = in_AL;\n        *(unaff_EBP + -0x700) = *(unaff_EBP + -0x700) + 1;\n        if (*(unaff_EBP + -0x688) <= *(unaff_EBP + -0x700)) break;\n        *(*(unaff_EBP + -0x6f8) + *(unaff_EBP + -0x700)) =\n             *(*(unaff_EBP + -0x6f8) + *(unaff_EBP + -0x700)) ^ *(unaff_EBP + -8);\n        in_AL = ~*(*(unaff_EBP + -0x6f8) + *(unaff_EBP + -0x700));\n        param_1 = *(unaff_EBP + -0x6f8) + *(unaff_EBP + -0x700);\n    }\n    *(unaff_EBP + -0x714) = 0;\n    *(unaff_EBP + -0x713) = 0;\n    *(unaff_EBP + -0x712) = 0x71;\n    *(unaff_EBP + -0x711) = 0;\n    *(unaff_EBP + -0x710) = 200;\n    *(unaff_EBP + -0x70f) = 0xe2;\n    *(unaff_EBP + -0x70e) = 0xe1;\n    *(unaff_EBP + -0x70d) = 0xe1;\n    *(unaff_EBP + -0x70c) = 0xea;\n    *(unaff_EBP + -0x70b) = 200;\n    *(unaff_EBP + -0x70a) = 0xe7;\n    *(unaff_EBP + -0x709) = 0xf6;\n    *(unaff_EBP + -0x708) = 0xbc;\n    *(unaff_EBP + -0x707) = 0x8e;\n    fcn.004048b2();\n    *unaff_EBX = *unaff_EBX << 1 | *unaff_EBX < 0;\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 563
    }
}