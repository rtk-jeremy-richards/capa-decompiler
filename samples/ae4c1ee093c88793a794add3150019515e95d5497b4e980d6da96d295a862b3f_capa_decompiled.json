{
    "10001030": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.10001030(void)\n\n{\n    code *pcVar1;\n    char *var_4h;\n    \n    *0x10027ad8 = (*_sym.imp.KERNEL32.dll_TlsAlloc)();\n    if (*0x10027ad8 != -1) {\n        fcn.1000791d(0x1001c070);\n        return;\n    }\n    var_4h = \"TlsAlloc() failed to create descriptor\";\n    fcn.10008371(&var_4h, 0x100248b8);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 140
    },
    "10001150": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_60h\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * fcn.10001150(int32_t *param_1, char *param_2)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint8_t *puVar4;\n    uchar *puVar5;\n    char cVar6;\n    uint32_t uVar7;\n    uint32_t extraout_ECX;\n    char *pcVar8;\n    uint32_t uVar9;\n    int32_t iVar10;\n    int32_t *in_FS_OFFSET;\n    bool bVar11;\n    ulong uVar12;\n    int32_t *var_8h;\n    char *var_ch_2;\n    uint var_10h;\n    uint var_ch;\n    code *var_60h;\n    code *var_4ch;\n    code *var_38h;\n    int32_t *var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    uint32_t var_18h;\n    uchar *var_11h;\n    int32_t var_ch_3;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x1001bc60;\n    var_ch_3 = *in_FS_OFFSET;\n    *0x10 = &stack0xffffff8c;\n    *in_FS_OFFSET = &var_ch_3;\n    uVar9 = 0;\n    var_1ch = 0;\n    if (*var_ch_2 == '\\0') {\n        var_18h = 0;\n    }\n    else {\n        pcVar8 = var_ch_2;\n        do {\n            cVar6 = *pcVar8;\n            pcVar8 = pcVar8 + 1;\n        } while (cVar6 != '\\0');\n        var_18h = pcVar8 - (var_ch_2 + 1);\n    }\n    iVar2 = *(*var_8h + 4);\n    var_20h = *(iVar2 + 0x24 + var_8h);\n    uVar7 = *(iVar2 + 0x20 + var_8h);\n    if ((var_20h < 0) || ((var_20h < 1 && (((uVar7 == 0 || (var_20h < 0)) || ((var_20h < 1 && (uVar7 <= var_18h))))))))\n    {\n        _var_24h = 0;\n        var_20h = 0;\n        var_24h = NULL;\n        iVar10 = var_24h;\n    }\n    else {\n        var_20h = var_20h - (uVar7 < var_18h);\n        iVar10 = uVar7 - var_18h;\n    }\n    piVar3 = *(iVar2 + 0x38 + var_8h);\n    _var_24h = _var_24h & 0xffffffff00000000 | ZEXT48(var_8h);\n    puVar5 = &stack0xffffff8c;\n    if (piVar3 != NULL) {\n        (**(*piVar3 + 4))();\n        puVar5 = stack0xffffffec;\n    }\n    stack0xffffffec = puVar5;\n    var_4h = 0;\n    if (((*(*(*var_8h + 4) + 0xc + var_8h) == 0) && (piVar3 = *(*(*var_8h + 4) + 0x3c + var_8h),  piVar3 != NULL)) &&\n       (piVar3 != var_8h)) {\n        fcn.10002a00();\n    }\n    bVar11 = *(var_8h + *(*var_8h + 4) + 0xc) == 0;\n    _var_24h = CONCAT14(bVar11, var_24h);\n    _var_24h = _var_24h & 0xffffff0000000000 | _var_24h;\n    if (!bVar11) {\n        uVar9 = 4;\n        goto code_r0x1000139e;\n    }\n    var_4h = 2;\n    if ((*(var_8h + *(*var_8h + 4) + 0x14) & 0x1c0) != 0x40) {\n        do {\n            if ((var_20h < 0) || ((var_20h < 1 && (iVar10 == 0)))) goto code_r0x100012ac;\n            var_11h._0_1_ = *(*(*var_8h + 4) + 0x40 + var_8h);\n            piVar3 = *(*(*var_8h + 4) + 0x38 + var_8h);\n            if (*piVar3[8] == 0) {\ncode_r0x10001295:\n                uVar7 = (**(*piVar3 + 0xc))(var_11h);\n            }\n            else {\n                iVar2 = *piVar3[0xc];\n                if (iVar2 < 1) goto code_r0x10001295;\n                *piVar3[0xc] = iVar2 + -1;\n                puVar4 = *piVar3[8];\n                *piVar3[8] = puVar4 + 1;\n                *puVar4 = var_11h;\n                uVar7 = var_11h;\n            }\n            if (uVar7 == 0xffffffff) goto code_r0x100012a6;\n            bVar11 = iVar10 != 0;\n            iVar10 = iVar10 + -1;\n            var_20h = var_20h + -1 + bVar11;\n        } while( true );\n    }\ncode_r0x100012b4:\n    uVar12 = (**(**(*(*var_8h + 4) + 0x38 + var_8h) + 0x24))(var_ch_2, var_18h, 0);\n    if ((uVar12 == var_18h) && (uVar12 >> 0x20 == 0)) {\n        while( true ) {\n            if ((var_20h < 0) || ((var_20h < 1 && (iVar10 == 0)))) goto code_r0x1000134b;\n            uVar1 = *(*(*var_8h + 4) + 0x40 + var_8h);\n            piVar3 = *(*(*var_8h + 4) + 0x38 + var_8h);\n            if ((*piVar3[8] == 0) || (*piVar3[0xc] < 1)) {\n                uVar7 = (**(*piVar3 + 0xc))(uVar1);\n            }\n            else {\n                *piVar3[0xc] = *piVar3[0xc] + -1;\n                puVar4 = *piVar3[8];\n                *piVar3[8] = puVar4 + 1;\n                *puVar4 = uVar1;\n                uVar7 = uVar1;\n            }\n            if (uVar7 == 0xffffffff) break;\n            bVar11 = iVar10 != 0;\n            iVar10 = iVar10 + -1;\n            var_20h = var_20h + -1 + bVar11;\n        }\n        uVar9 = 4;\n    }\n    else {\n        uVar9 = 4;\n    }\n    goto code_r0x1000134b;\ncode_r0x100012a6:\n    uVar9 = 4;\n    var_1ch = 4;\ncode_r0x100012ac:\n    if (uVar9 == 0) goto code_r0x100012b4;\ncode_r0x1000134b:\n    iVar2 = *(*var_8h + 4);\n    *(iVar2 + 0x20 + var_8h) = 0;\n    *(iVar2 + 0x24 + var_8h) = 0;\ncode_r0x1000139e:\n    var_4h = 1;\n    iVar2 = *(*var_8h + 4);\n    if (uVar9 != 0) {\n        uVar9 = *(var_8h + iVar2 + 0xc) | uVar9;\n        if (*(var_8h + iVar2 + 0x38) == 0) {\n            uVar9 = uVar9 | 4;\n        }\n        *(var_8h + iVar2 + 0xc) = uVar9 & 0x17;\n        uVar9 = *(var_8h + iVar2 + 0x10) & uVar9 & 0x17;\n        if (uVar9 != 0) {\n            if ((uVar9 & 4) != 0) {\n                fcn.10001940(1, 0x10026084, \"ios_base::badbit set\");\n                var_38h = vtable.std::ios_base::failure.0;\n                fcn.10008371(&var_38h, 0x10024960);\n                uVar9 = extraout_ECX;\n            }\n            if ((uVar9 & 2) != 0) {\n                fcn.10001940(1, 0x10026084, \"ios_base::failbit set\");\n                var_4ch = vtable.std::ios_base::failure.0;\n                fcn.10008371(&var_4ch, 0x10024960);\n            }\n            var_60h = 0x1001d384;\n            fcn.10001940(1, 0x10026084, \"ios_base::eofbit set\");\n            var_60h = vtable.std::ios_base::failure.0;\n            fcn.10008371(&var_60h, 0x10024960);\n        }\n    }\n    var_4h = 0xffffffff;\n    cVar6 = fcn.10005ea3();\n    if (cVar6 == '\\0') {\n        fcn.10002120();\n    }\n    piVar3 = *(*(*var_24h + 4) + 0x38 + var_24h);\n    if (piVar3 != NULL) {\n        (**(*piVar3 + 8))();\n    }\n    *in_FS_OFFSET = var_ch_3;\n    return var_8h;\n}\n",
        "token_count": 2323
    },
    "100015e0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.100015e0(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *arg_8h_00;\n    int32_t *in_FS_OFFSET;\n    uint32_t uVar4;\n    uint uVar5;\n    uint var_24h;\n    uint var_18h;\n    uint var_14h;\n    int32_t *var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x1001bcc8;\n    var_ch = *in_FS_OFFSET;\n    uVar2 = *0x100264f0 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    uVar5 = 0;\n    fcn.10005e24(0);\n    piVar1 = *0x10027b04;\n    var_4h = 0;\n    var_10h = *0x10027b04;\n    if (*0x10027b84 == 0) {\n        uVar4 = *0x10027b84;\n        fcn.10005e24(0);\n        if (*0x10027b84 == 0) {\n            *0x10027b74 = *0x10027b74 + 1;\n            *0x10027b84 = *0x10027b74;\n        }\n        fcn.10005e7f(uVar4, uVar5, uVar2);\n    }\n    uVar2 = *0x10027b84;\n    iVar3 = *arg_8h;\n    if (*0x10027b84 < *(iVar3 + 0xc)) {\n        arg_8h_00 = *(*(iVar3 + 8) + *0x10027b84 * 4);\n        if (arg_8h_00 != NULL) goto code_r0x100016dd;\n    }\n    else {\n        arg_8h_00 = NULL;\n    }\n    if (*(iVar3 + 0x14) == '\\0') {\ncode_r0x10001689:\n        if (arg_8h_00 != NULL) goto code_r0x100016dd;\n    }\n    else {\n        iVar3 = fcn.10006396();\n        if (uVar2 < *(iVar3 + 0xc)) {\n            arg_8h_00 = *(*(iVar3 + 8) + uVar2 * 4);\n            goto code_r0x10001689;\n        }\n    }\n    arg_8h_00 = piVar1;\n    if (piVar1 == NULL) {\n        iVar3 = fcn.10001e60(&var_10h, arg_8h);\n        if (iVar3 == -1) {\n            fcn.10008214(\"bad cast\");\n            fcn.10008371(&var_24h, 0x100249dc);\n        }\n        arg_8h_00 = var_10h;\n        *0x10027b04 = var_10h;\n        (**(*var_10h + 4))();\n        fcn.1000636e(arg_8h_00);\n    }\ncode_r0x100016dd:\n    fcn.10005e7f();\n    *in_FS_OFFSET = var_ch;\n    return arg_8h_00;\n}\n",
        "token_count": 768
    },
    "10001cf0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint * __thiscall fcn.10001cf0(uint *param_1, uint32_t param_2, int32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    int32_t *in_FS_OFFSET;\n    uint32_t var_8h;\n    int32_t var_ch_2;\n    uint var_10h;\n    uint var_ch;\n    uint var_18h;\n    uint *var_14h;\n    uint var_10h_2;\n    int32_t var_ch_3;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x1001bd90;\n    var_ch_3 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch_3;\n    uVar4 = var_8h | 0xf;\n    uVar5 = var_8h;\n    if (uVar4 != 0xffffffff) {\n        uVar1 = param_1[5];\n        uVar2 = uVar1 >> 1;\n        uVar5 = uVar4;\n        if ((uVar4 / 3 < uVar2) && (uVar5 = uVar2 + uVar1,  -uVar2 - 2 < uVar1)) {\n            uVar5 = 0xfffffffe;\n        }\n    }\n    var_4h = 0;\n    var_14h = NULL;\n    if ((uVar5 + 1 != 0) && (var_14h = fcn.1000779c(uVar5 + 1),  var_14h == NULL)) {\n        fcn.10005f63();\n        var_4h = CONCAT31(var_4h._1_3_, 2);\n        fcn.100022a0(var_8h + 1);\n        return 0x10001da5;\n    }\n    if (var_ch_2 != 0) {\n        puVar3 = param_1;\n        if (0xf < param_1[5]) {\n            puVar3 = *param_1;\n        }\n        if (var_ch_2 != 0) {\n            fcn.100087c0(var_14h, puVar3, var_ch_2);\n        }\n    }\n    if (0xf < param_1[5]) {\n        fcn.100077ed(*param_1);\n    }\n    *param_1 = 0;\n    *param_1 = var_14h;\n    param_1[5] = uVar5;\n    param_1[4] = var_ch_2;\n    if (0xf < uVar5) {\n        param_1 = var_14h;\n    }\n    *(param_1 + var_ch_2) = 0;\n    *in_FS_OFFSET = var_ch_3;\n    return var_14h;\n}\n",
        "token_count": 659
    },
    "10002120": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.10002120(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t extraout_ECX;\n    int32_t *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint32_t uStack96;\n    code *var_4ch;\n    code *var_38h;\n    code *var_24h;\n    uchar *puStack20;\n    int32_t var_ch_2;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x1001be20;\n    var_ch_2 = *in_FS_OFFSET;\n    uStack96 = *0x100264f0 ^ &stack0xfffffffc;\n    puStack20 = &stack0xffffffa0;\n    *in_FS_OFFSET = &fcn.10002120::var_ch_2;\n    var_4h = 0;\n    uVar2 = *(*param_1 + 4);\n    if (((*(uVar2 + 0xc + param_1) == 0) && ((*(uVar2 + 0x14 + param_1) & 2) != 0)) &&\n       (uVar2 = (**(**(uVar2 + 0x38 + param_1) + 0x34))(),  uVar2 == 0xffffffff)) {\n        iVar1 = *(*param_1 + 4);\n        uVar2 = *(iVar1 + 0xc + param_1) & 0x17 | 4;\n        *(param_1 + iVar1 + 0xc) = uVar2;\n        uVar3 = *(param_1 + iVar1 + 0x10) & uVar2;\n        if (uVar3 != 0) {\n            if ((uVar3 & 4) != 0) {\n                fcn.10001940(1, 0x10026084, \"ios_base::badbit set\");\n                var_24h = vtable.std::ios_base::failure.0;\n                fcn.10008371(&fcn.10002120::var_24h, 0x10024960);\n                uVar3 = extraout_ECX;\n            }\n            if ((uVar3 & 2) != 0) {\n                fcn.10001940(1, 0x10026084, \"ios_base::failbit set\");\n                var_38h = vtable.std::ios_base::failure.0;\n                fcn.10008371(&fcn.10002120::var_38h, 0x10024960);\n            }\n            fcn.10001940(1, 0x10026084, \"ios_base::eofbit set\");\n            var_4ch = vtable.std::ios_base::failure.0;\n            fcn.10008371(&fcn.10002120::var_4ch, 0x10024960);\n            return 0x10002234;\n        }\n    }\n    *in_FS_OFFSET = var_ch_2;\n    return uVar2;\n}\n",
        "token_count": 684
    },
    "100022a0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.100022a0(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    if ((arg_8h != 0) && (iVar2 = fcn.1000779c(arg_8h),  iVar2 == 0)) {\n        fcn.10005f63();\n        pcVar1 = swi(3);\n        iVar2 = (*pcVar1)();\n        return iVar2;\n    }\n    return iVar2;\n}\n",
        "token_count": 121
    },
    "10002a00": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * __fastcall fcn.10002a00(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    char cVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t extraout_ECX;\n    int32_t *in_FS_OFFSET;\n    char *arg_10h;\n    code *var_28h;\n    int32_t *var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x1001be50;\n    var_ch = *in_FS_OFFSET;\n    uVar3 = *0x100264f0 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    piVar1 = *(*(*param_1 + 4) + 0x38 + param_1);\n    if (piVar1 != NULL) {\n        var_14h = param_1;\n        (**(*piVar1 + 4))(uVar3);\n        var_4h = 0;\n        if (((*(*(*param_1 + 4) + 0xc + param_1) == 0) &&\n            (piVar1 = *(*(*param_1 + 4) + 0x3c + param_1),  piVar1 != NULL)) && (piVar1 != param_1)) {\n            fcn.10002a00();\n        }\n        var_10h._0_1_ = *(*(*param_1 + 4) + 0xc + param_1) == 0;\n        var_4h = 1;\n        if ((var_10h) && (iVar4 = (**(**(*(*param_1 + 4) + 0x38 + param_1) + 0x34))(),  iVar4 == -1)) {\n            iVar4 = *(*param_1 + 4);\n            uVar3 = *(iVar4 + 0xc + param_1) & 0x17 | 4;\n            *(param_1 + iVar4 + 0xc) = uVar3;\n            uVar3 = *(param_1 + iVar4 + 0x10) & uVar3;\n            if (uVar3 != 0) {\n                if ((uVar3 & 4) != 0) {\n                    fcn.10001940(1, 0x10026084, \"ios_base::badbit set\");\n                    var_28h = vtable.std::ios_base::failure.0;\n                    fcn.10008371(&var_28h, 0x10024960);\n                    uVar3 = extraout_ECX;\n                }\n                if ((uVar3 & 2) == 0) goto code_r0x10002b16;\n                arg_10h = \"ios_base::failbit set\";\n                do {\n                    fcn.10001940(1, 0x10026084, arg_10h);\n                    var_28h = vtable.std::ios_base::failure.0;\n                    fcn.10008371(&var_28h, 0x10024960);\ncode_r0x10002b16:\n                    arg_10h = \"ios_base::eofbit set\";\n                } while( true );\n            }\n        }\n        var_4h = 0xffffffff;\n        cVar2 = fcn.10005ea3();\n        if (cVar2 == '\\0') {\n            fcn.10002120();\n        }\n        piVar1 = *(*(*param_1 + 4) + 0x38 + param_1);\n        if (piVar1 != NULL) {\n            (**(*piVar1 + 8))();\n        }\n    }\n    *in_FS_OFFSET = var_ch;\n    return param_1;\n}\n",
        "token_count": 857
    },
    "10002dd0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_5ch\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * __thiscall fcn.10002dd0(int32_t *param_1, uint8_t param_2)\n\n{\n    int32_t *piVar1;\n    uint8_t *puVar2;\n    uchar *puVar3;\n    char cVar4;\n    int32_t iVar5;\n    uint32_t extraout_ECX;\n    uint32_t uVar6;\n    int32_t *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    uint var_ch;\n    code *var_5ch;\n    code *var_48h;\n    code *var_34h;\n    int32_t *var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    uchar *puStack20;\n    int32_t var_ch_2;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x1001be80;\n    var_ch_2 = *in_FS_OFFSET;\n    puStack20 = &stack0xffffff90;\n    *in_FS_OFFSET = &var_ch_2;\n    uVar6 = 0;\n    var_18h = 0;\n    piVar1 = *(*(*param_1 + 4) + 0x38 + param_1);\n    var_20h = param_1;\n    var_14h = param_1;\n    puVar3 = &stack0xffffff90;\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 4))();\n        puVar3 = puStack20;\n    }\n    puStack20 = puVar3;\n    var_4h = 0;\n    if (((*(*(*param_1 + 4) + 0xc + param_1) == 0) && (piVar1 = *(*(*param_1 + 4) + 0x3c + param_1),  piVar1 != NULL))\n       && (piVar1 != param_1)) {\n        fcn.10002a00();\n    }\n    var_1ch._0_1_ = *(*(*param_1 + 4) + 0xc + param_1) == 0;\n    if (var_1ch) {\n        piVar1 = *(*(*param_1 + 4) + 0x38 + param_1);\n        var_4h = 2;\n        if (*piVar1[8] != 0) {\n            iVar5 = *piVar1[0xc];\n            if (0 < iVar5) {\n                *piVar1[0xc] = iVar5 + -1;\n                puVar2 = *piVar1[8];\n                *piVar1[8] = puVar2 + 1;\n                *puVar2 = param_2;\n                if (param_2 == 0xffffffff) {\n                    uVar6 = 4;\n                }\n                goto code_r0x10002ef3;\n            }\n        }\n        iVar5 = (**(*piVar1 + 0xc))(param_2);\n        if (iVar5 == -1) {\n            uVar6 = 4;\n        }\n    }\n    else {\n        uVar6 = 4;\n    }\ncode_r0x10002ef3:\n    var_4h = 1;\n    iVar5 = *(*param_1 + 4);\n    if (uVar6 != 0) {\n        uVar6 = *(param_1 + iVar5 + 0xc) | uVar6;\n        if (*(param_1 + iVar5 + 0x38) == 0) {\n            uVar6 = uVar6 | 4;\n        }\n        *(param_1 + iVar5 + 0xc) = uVar6 & 0x17;\n        uVar6 = *(param_1 + iVar5 + 0x10) & uVar6 & 0x17;\n        if (uVar6 != 0) {\n            if ((uVar6 & 4) != 0) {\n                fcn.10001940(1, 0x10026084, \"ios_base::badbit set\");\n                var_34h = vtable.std::ios_base::failure.0;\n                fcn.10008371(&var_34h, 0x10024960);\n                uVar6 = extraout_ECX;\n            }\n            if ((uVar6 & 2) != 0) {\n                fcn.10001940(1, 0x10026084, \"ios_base::failbit set\");\n                var_48h = vtable.std::ios_base::failure.0;\n                fcn.10008371(&var_48h, 0x10024960);\n            }\n            var_5ch = 0x1001d384;\n            fcn.10001940(1, 0x10026084, \"ios_base::eofbit set\");\n            var_5ch = vtable.std::ios_base::failure.0;\n            fcn.10008371(&var_5ch, 0x10024960);\n        }\n    }\n    var_4h = 0xffffffff;\n    cVar4 = fcn.10005ea3();\n    if (cVar4 == '\\0') {\n        fcn.10002120();\n    }\n    piVar1 = *(*(*param_1 + 4) + 0x38 + param_1);\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 8))();\n    }\n    *in_FS_OFFSET = var_ch_2;\n    return param_1;\n}\n",
        "token_count": 1259
    },
    "10006620": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl fcn.10006620(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.1000a19e(0x14);\n    fcn.10005e24(0);\n    piVar1 = *0x10027c60;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = piVar1;\n    arg_8h_00 = fcn.10001b70();\n    iVar2 = fcn.10001f30(arg_8h_00);\n    if ((iVar2 == 0) && (piVar1 == NULL)) {\n        iVar2 = fcn.10006a19(unaff_EBP + -0x10, *(unaff_EBP + 8));\n        if (iVar2 == -1) {\n            fcn.10008214(\"bad cast\");\n            fcn.10008371(unaff_EBP + -0x20, 0x100249dc);\n        }\n        piVar1 = *(unaff_EBP + -0x10);\n        *0x10027c60 = piVar1;\n        (**(*piVar1 + 4))();\n        fcn.1000636e(piVar1);\n    }\n    fcn.10005e7f();\n    fcn.1000a17b();\n    return;\n}\n",
        "token_count": 404
    },
    "10008fa8": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.10008fa8(void)\n\n{\n    int32_t unaff_ESI;\n    \n    if ((unaff_ESI == 0) && (*0x1002695c != -1)) {\n        fcn.1000fad3();\n    }\n    return;\n}\n",
        "token_count": 61
    },
    "10009ec6": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.10009ec6(uint arg_8h, uint noname_1, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.1000e3b0(0x10024c98, 0x10);\n    if (*(*(unaff_EBP + 0x10) + 4) < 0x81) {\n        iVar4 = *(*(unaff_EBP + 8) + 8);\n    }\n    else {\n        iVar4 = *(*(unaff_EBP + 8) + 8);\n    }\n    *(unaff_EBP + -0x1c) = iVar4;\n    iVar3 = fcn.1000f923();\n    *(iVar3 + 0x90) = *(iVar3 + 0x90) + 1;\n    *(unaff_EBP + -4) = 0;\n    while (iVar4 != *(unaff_EBP + 0x14)) {\n        if ((iVar4 < 0) || (*(*(unaff_EBP + 0x10) + 4) <= iVar4)) {\n            fcn.1000fb3c();\n        }\n        iVar3 = *(unaff_EBP + 0x10);\n        iVar1 = *(iVar3 + 8);\n        uVar2 = *(iVar1 + iVar4 * 8);\n        *(unaff_EBP + -0x20) = uVar2;\n        *(unaff_EBP + -4) = 1;\n        if (*(iVar1 + 4 + iVar4 * 8) != 0) {\n            iVar1 = *(unaff_EBP + 8);\n            *(iVar1 + 8) = uVar2;\n            fcn.1000faf0(*(*(iVar3 + 8) + 4 + iVar4 * 8), iVar1, 0x103);\n        }\n        *(unaff_EBP + -4) = 0;\n        iVar4 = *(unaff_EBP + -0x20);\n        *(unaff_EBP + -0x1c) = iVar4;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.10009f85();\n    if (iVar4 != *(unaff_EBP + 0x14)) {\n        fcn.1000fb3c();\n    }\n    *(*(unaff_EBP + 8) + 8) = iVar4;\n    fcn.1000e3f5();\n    return;\n}\n",
        "token_count": 620
    },
    "1000b078": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.1000b078(uint arg_8h)\n\n{\n    uint8_t **ppuVar1;\n    uint8_t **arg_8h_00;\n    uint *puVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.1000e3b0(0x10024e60, 0xc);\n    iVar5 = 0;\n    *(unaff_EBP + -0x1c) = 0;\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == NULL) {\n        puVar2 = fcn.1000beaa();\n        *puVar2 = 0x16;\n        fcn.1000e79e();\n        goto code_r0x1000b15d;\n    }\n    fcn.100079d2(arg_8h_00);\n    *(unaff_EBP + -4) = 0;\n    if ((*(arg_8h_00 + 3) & 0x40) == 0) {\n        uVar3 = fcn.10013283(arg_8h_00);\n        if ((uVar3 == 0xffffffff) || (uVar3 == 0xfffffffe)) {\n            iVar4 = 0x10026988;\n        }\n        else {\n            iVar4 = (uVar3 & 0x1f) * 0x40 + *((uVar3 >> 5) * 4 + 0x100288c0);\n        }\n        if ((*(iVar4 + 0x24) & 0x7f) == 0) {\n            if ((uVar3 == 0xffffffff) || (uVar3 == 0xfffffffe)) {\n                iVar4 = 0x10026988;\n            }\n            else {\n                iVar4 = (uVar3 & 0x1f) * 0x40 + *((uVar3 >> 5) * 4 + 0x100288c0);\n            }\n            if ((*(iVar4 + 0x24) & 0x80) == 0) goto code_r0x1000b130;\n        }\n        puVar2 = fcn.1000beaa();\n        *puVar2 = 0x16;\n        fcn.1000e79e();\n        iVar5 = -1;\n        *(unaff_EBP + -0x1c) = 0xffffffff;\n    }\ncode_r0x1000b130:\n    if (iVar5 == 0) {\n        ppuVar1 = arg_8h_00 + 1;\n        *ppuVar1 = *ppuVar1 + -1;\n        if (*ppuVar1 < 0) {\n            uVar3 = fcn.10013e89(arg_8h_00);\n        }\n        else {\n            uVar3 = **arg_8h_00;\n            *arg_8h_00 = *arg_8h_00 + 1;\n        }\n        *(unaff_EBP + -0x1c) = uVar3;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.1000b169();\ncode_r0x1000b15d:\n    fcn.1000e3f5();\n    return;\n}\n",
        "token_count": 780
    },
    "1000b1c6": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.1000b1c6(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t *arg_8h_00;\n    uint *puVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.1000e3b0(0x10024e80, 0xc);\n    iVar5 = 0;\n    *(unaff_EBP + -0x1c) = 0;\n    arg_8h_00 = *(unaff_EBP + 0xc);\n    if (arg_8h_00 == NULL) {\n        puVar2 = fcn.1000beaa();\n        *puVar2 = 0x16;\n        fcn.1000e79e();\n        goto code_r0x1000b2b3;\n    }\n    fcn.100079d2(arg_8h_00);\n    *(unaff_EBP + -4) = 0;\n    if ((*(arg_8h_00 + 3) & 0x40) == 0) {\n        uVar3 = fcn.10013283(arg_8h_00);\n        if ((uVar3 == 0xffffffff) || (uVar3 == 0xfffffffe)) {\n            iVar4 = 0x10026988;\n        }\n        else {\n            iVar4 = (uVar3 & 0x1f) * 0x40 + *((uVar3 >> 5) * 4 + 0x100288c0);\n        }\n        if ((*(iVar4 + 0x24) & 0x7f) == 0) {\n            if ((uVar3 == 0xffffffff) || (uVar3 == 0xfffffffe)) {\n                iVar4 = 0x10026988;\n            }\n            else {\n                iVar4 = (uVar3 & 0x1f) * 0x40 + *((uVar3 >> 5) * 4 + 0x100288c0);\n            }\n            if ((*(iVar4 + 0x24) & 0x80) == 0) goto code_r0x1000b27e;\n        }\n        puVar2 = fcn.1000beaa();\n        *puVar2 = 0x16;\n        fcn.1000e79e();\n        iVar5 = -1;\n        *(unaff_EBP + -0x1c) = 0xffffffff;\n    }\ncode_r0x1000b27e:\n    if (iVar5 == 0) {\n        piVar1 = arg_8h_00 + 1;\n        *piVar1 = *piVar1 + -1;\n        if (*piVar1 < 0) {\n            uVar3 = fcn.100143fa(*(unaff_EBP + 8), arg_8h_00);\n        }\n        else {\n            uVar3 = *(unaff_EBP + 8);\n            **arg_8h_00 = uVar3;\n            uVar3 = uVar3 & 0xff;\n            *arg_8h_00 = *arg_8h_00 + 1;\n        }\n        *(unaff_EBP + -0x1c) = uVar3;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.1000b2bf();\ncode_r0x1000b2b3:\n    fcn.1000e3f5();\n    return;\n}\n",
        "token_count": 822
    },
    "null": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "1000f8ed": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.1000f8ed(int32_t arg_8h)\n\n{\n    if (*0x1002695c != -1) {\n        if (arg_8h == 0) {\n            arg_8h = fcn.1000b9bd(*0x1002695c);\n        }\n        fcn.1000b9dc(*0x1002695c, 0);\n        fcn.1000f7b8(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 112
    },
    "10019de4": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x1001a0ee)\n// WARNING: Removing unreachable block (ram,0x1001a0f7)\n// WARNING: Removing unreachable block (ram,0x1001a52b)\n// WARNING: Removing unreachable block (ram,0x1001a154)\n// WARNING: Removing unreachable block (ram,0x1001a172)\n// WARNING: Removing unreachable block (ram,0x1001a159)\n// WARNING: Removing unreachable block (ram,0x1001a160)\n// WARNING: Removing unreachable block (ram,0x1001a165)\n// WARNING: Removing unreachable block (ram,0x1001a175)\n// WARNING: Removing unreachable block (ram,0x1001a521)\n// WARNING: Removing unreachable block (ram,0x1001a17d)\n// WARNING: Removing unreachable block (ram,0x1001a182)\n// WARNING: Removing unreachable block (ram,0x1001a189)\n// WARNING: Removing unreachable block (ram,0x1001a18c)\n// WARNING: Removing unreachable block (ram,0x1001a1a4)\n// WARNING: Removing unreachable block (ram,0x1001a1a6)\n// WARNING: Removing unreachable block (ram,0x1001a1b0)\n// WARNING: Removing unreachable block (ram,0x1001a1b3)\n// WARNING: Removing unreachable block (ram,0x1001a1ba)\n// WARNING: Removing unreachable block (ram,0x1001a1bd)\n// WARNING: Removing unreachable block (ram,0x1001a513)\n// WARNING: Removing unreachable block (ram,0x1001a531)\n// WARNING: Removing unreachable block (ram,0x1001a1c9)\n// WARNING: Removing unreachable block (ram,0x1001a504)\n// WARNING: Removing unreachable block (ram,0x1001a1d5)\n// WARNING: Removing unreachable block (ram,0x1001a1e5)\n// WARNING: Removing unreachable block (ram,0x1001a1e7)\n// WARNING: Removing unreachable block (ram,0x1001a1f1)\n// WARNING: Removing unreachable block (ram,0x1001a1fa)\n// WARNING: Removing unreachable block (ram,0x1001a4ea)\n// WARNING: Removing unreachable block (ram,0x1001a205)\n// WARNING: Removing unreachable block (ram,0x1001a21c)\n// WARNING: Removing unreachable block (ram,0x1001a22e)\n// WARNING: Removing unreachable block (ram,0x1001a23f)\n// WARNING: Removing unreachable block (ram,0x1001a27e)\n// WARNING: Removing unreachable block (ram,0x1001a287)\n// WARNING: Removing unreachable block (ram,0x1001a4c7)\n// WARNING: Removing unreachable block (ram,0x1001a295)\n// WARNING: Removing unreachable block (ram,0x1001a2a7)\n// WARNING: Removing unreachable block (ram,0x1001a2ac)\n// WARNING: Removing unreachable block (ram,0x1001a2b9)\n// WARNING: Removing unreachable block (ram,0x1001a2bf)\n// WARNING: Removing unreachable block (ram,0x1001a2c5)\n// WARNING: Removing unreachable block (ram,0x1001a2d0)\n// WARNING: Removing unreachable block (ram,0x1001a2d5)\n// WARNING: Removing unreachable block (ram,0x1001a2e2)\n// WARNING: Removing unreachable block (ram,0x1001a2e7)\n// WARNING: Removing unreachable block (ram,0x1001a29f)\n// WARNING: Removing unreachable block (ram,0x1001a4de)\n// WARNING: Removing unreachable block (ram,0x1001a4e4)\n// WARNING: Removing unreachable block (ram,0x1001a2eb)\n// WARNING: Removing unreachable block (ram,0x1001a2f9)\n// WARNING: Removing unreachable block (ram,0x1001a300)\n// WARNING: Removing unreachable block (ram,0x1001a30c)\n// WARNING: Removing unreachable block (ram,0x1001a32c)\n// WARNING: Removing unreachable block (ram,0x1001a331)\n// WARNING: Removing unreachable block (ram,0x1001a336)\n// WARNING: Removing unreachable block (ram,0x1001a339)\n// WARNING: Removing unreachable block (ram,0x1001a340)\n// WARNING: Removing unreachable block (ram,0x1001a343)\n// WARNING: Removing unreachable block (ram,0x1001a34f)\n// WARNING: Removing unreachable block (ram,0x1001a358)\n// WARNING: Removing unreachable block (ram,0x1001a367)\n// WARNING: Removing unreachable block (ram,0x1001a37e)\n// WARNING: Removing unreachable block (ram,0x1001a382)\n// WARNING: Removing unreachable block (ram,0x1001a3b4)\n// WARNING: Removing unreachable block (ram,0x1001a3b9)\n// WARNING: Removing unreachable block (ram,0x1001a3c5)\n// WARNING: Removing unreachable block (ram,0x1001a3d4)\n// WARNING: Removing unreachable block (ram,0x1001a3da)\n// WARNING: Removing unreachable block (ram,0x1001a3db)\n// WARNING: Removing unreachable block (ram,0x1001a406)\n// WARNING: Removing unreachable block (ram,0x1001a410)\n// WARNING: Removing unreachable block (ram,0x1001a422)\n// WARNING: Removing unreachable block (ram,0x1001a426)\n// WARNING: Removing unreachable block (ram,0x1001a430)\n// WARNING: Removing unreachable block (ram,0x1001a43e)\n// WARNING: Removing unreachable block (ram,0x1001a47a)\n// WARNING: Removing unreachable block (ram,0x1001a446)\n// WARNING: Removing unreachable block (ram,0x1001a471)\n// WARNING: Removing unreachable block (ram,0x1001a451)\n// WARNING: Removing unreachable block (ram,0x1001a469)\n// WARNING: Removing unreachable block (ram,0x1001a462)\n// WARNING: Removing unreachable block (ram,0x1001a475)\n// WARNING: Removing unreachable block (ram,0x1001a47e)\n// WARNING: Removing unreachable block (ram,0x1001a481)\n// WARNING: Removing unreachable block (ram,0x1001a4ad)\n// WARNING: Removing unreachable block (ram,0x1001a48e)\n// WARNING: Removing unreachable block (ram,0x1001a4e7)\n// WARNING: Removing unreachable block (ram,0x1001a4f2)\n// WARNING: Removing unreachable block (ram,0x1001a536)\n// WARNING: Variable defined which should be unmapped: var_80h\n\nvoid __cdecl\nfcn.10019de4(uint arg_8h, uint arg_ch, char *arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            int32_t arg_24h)\n\n{\n    char cVar1;\n    uint *puVar2;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_3ch;\n    uint var_34h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_9h;\n    uint var_4h;\n    \n    if (arg_24h == 0) {\n        puVar2 = fcn.1000beaa();\n        *puVar2 = 0x16;\n        fcn.1000e79e();\n        fcn.10008362(arg_8h);\n        return;\n    }\n    for (; (((cVar1 = *arg_10h,  cVar1 == ' ' || (cVar1 == '\\t')) || (cVar1 == '\\n')) || (cVar1 == '\\r'));\n        arg_10h = arg_10h + 1) {\n    }\n    // WARNING: Could not recover jumptable at 0x10019e73. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (12 cases) at 0x1001a55c\n    (**0x1001a55c)();\n    return;\n}\n",
        "token_count": 1977
    },
    "10001940": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.10001940(uint arg_8h, uint arg_ch, char *arg_10h)\n\n{\n    char cVar1;\n    code **in_ECX;\n    int32_t arg_ch_00;\n    char *pcVar2;\n    int32_t *in_FS_OFFSET;\n    uint32_t var_28h;\n    uint var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x1001bd68;\n    var_ch = *in_FS_OFFSET;\n    var_10h = *0x100264f0 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    var_14h = 0xf;\n    var_18h = 0;\n    var_28h = var_28h & 0xffffff00;\n    if (*arg_10h == '\\0') {\n        arg_ch_00 = 0;\n    }\n    else {\n        pcVar2 = arg_10h;\n        do {\n            cVar1 = *pcVar2;\n            pcVar2 = pcVar2 + 1;\n        } while (cVar1 != '\\0');\n        arg_ch_00 = pcVar2 - (arg_10h + 1);\n    }\n    fcn.100025b0(arg_10h, arg_ch_00);\n    var_4h = 0;\n    fcn.100017c0(arg_8h, arg_ch, &var_28h);\n    if (0xf < var_14h) {\n        fcn.100077ed(var_28h);\n    }\n    *in_ECX = vtable.std::system_error.0;\n    *in_FS_OFFSET = var_ch;\n    fcn.10008362(arg_10h);\n    return;\n}\n",
        "token_count": 426
    },
    "10008334": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.10008334(int32_t param_1)\n\n{\n    if (*(param_1 + 8) != '\\0') {\n        fcn.1000812f(*(param_1 + 4));\n    }\n    *(param_1 + 4) = 0;\n    *(param_1 + 8) = 0;\n    return;\n}\n",
        "token_count": 81
    },
    "10001f30": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.10001f30(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    \n    iVar1 = *in_ECX;\n    if (arg_8h < *(iVar1 + 0xc)) {\n        iVar2 = *(*(iVar1 + 8) + arg_8h * 4);\n        if (iVar2 != 0) {\n            return iVar2;\n        }\n    }\n    else {\n        iVar2 = 0;\n    }\n    if (*(iVar1 + 0x14) != '\\0') {\n        iVar1 = fcn.10006396();\n        if (arg_8h < *(iVar1 + 0xc)) {\n            return *(*(iVar1 + 8) + arg_8h * 4);\n        }\n        iVar2 = 0;\n    }\n    return iVar2;\n}\n",
        "token_count": 204
    },
    "10001f70": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.10001f70(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    uint *in_ECX;\n    uint32_t uVar4;\n    \n    if (arg_8h == 0xffffffff) {\n        fcn.10005f94(\"string too long\");\n        pcVar2 = swi(3);\n        uVar3 = (*pcVar2)();\n        return uVar3;\n    }\n    uVar3 = in_ECX[5];\n    if (uVar3 < arg_8h) {\n        fcn.10001cf0(arg_8h, in_ECX[4]);\n        return arg_8h != 0;\n    }\n    if ((arg_ch != '\\0') && (arg_8h < 0x10)) {\n        uVar4 = in_ECX[4];\n        if (arg_8h < in_ECX[4]) {\n            uVar4 = arg_8h;\n        }\n        if (0xf < uVar3) {\n            uVar1 = *in_ECX;\n            if (uVar4 != 0) {\n                fcn.100087c0();\n            }\n            fcn.100077ed(uVar1);\n        }\n        in_ECX[4] = uVar4;\n        in_ECX[5] = 0xf;\n        *(uVar4 + in_ECX) = 0;\n        return arg_8h != 0;\n    }\n    if (arg_8h == 0) {\n        in_ECX[4] = 0;\n        if (0xf < uVar3) {\n            in_ECX = *in_ECX;\n        }\n        *in_ECX = 0;\n    }\n    return arg_8h != 0;\n}\n",
        "token_count": 406
    },
    "10002040": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.10002040(uint *arg_8h, uint arg_ch, uint noname_2, uint arg_14h, uint noname_4, uint noname_5, uint noname_6, \n            int32_t arg_24h, uint32_t arg_28h)\n\n{\n    uint arg_8h_00;\n    int32_t *in_FS_OFFSET;\n    uint arg_8h_01;\n    uint var_2ch;\n    uint var_28h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x1001bdf0;\n    var_ch = *in_FS_OFFSET;\n    var_10h = *0x100264f0 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    var_4h = 0;\n    if (arg_24h != 0) {\n        fcn.10002390(0x1001d2a0, 2);\n    }\n    arg_8h_00 = fcn.10002cc0(&var_28h);\n    arg_8h_01 = 0xffffffff;\n    var_4h = CONCAT31(var_4h._1_3_, 1);\n    fcn.100022d0(arg_8h_00, 0, 0xffffffff);\n    if (0xf < var_14h) {\n        fcn.100077ed(var_28h);\n    }\n    arg_8h[5] = 0xf;\n    arg_8h[4] = 0;\n    *arg_8h = 0;\n    if (arg_28h < 0x10) {\n        if (arg_24h + 1 != 0) {\n            fcn.10007ab0(arg_8h, &arg_14h, arg_24h + 1);\n        }\n    }\n    else {\n        *arg_8h = arg_14h;\n    }\n    arg_8h[4] = arg_24h;\n    arg_8h[5] = arg_28h;\n    *in_FS_OFFSET = var_ch;\n    fcn.10008362(arg_8h_01);\n    return;\n}\n",
        "token_count": 524
    },
    "10002250": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.10002250(uint arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    uint *in_ECX;\n    \n    if ((arg_8h != '\\0') && (0xf < in_ECX[5])) {\n        uVar1 = *in_ECX;\n        if (arg_ch != 0) {\n            fcn.100087c0();\n        }\n        fcn.100077ed(uVar1);\n    }\n    in_ECX[4] = arg_ch;\n    in_ECX[5] = 0xf;\n    *(arg_ch + in_ECX) = 0;\n    return;\n}\n",
        "token_count": 144
    },
    "100026d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.100026d0(uint32_t arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t in_ECX;\n    uint32_t uVar2;\n    char *in_stack_ffffffc8;\n    code *var_14h;\n    \n    *(in_ECX + 0xc) = arg_8h & 0x17;\n    uVar2 = *(in_ECX + 0x10) & arg_8h & 0x17;\n    if (uVar2 == 0) {\n        return;\n    }\n    if (arg_ch == '\\0') {\n        if ((uVar2 & 4) != 0) goto code_r0x1000270f;\n        if ((uVar2 & 2) == 0) goto code_r0x1000273d;\n    }\n    else {\n        fcn.10008371(0, 0);\ncode_r0x1000270f:\n        fcn.10001940(1, 0x10026084, \"ios_base::badbit set\");\n        var_14h = vtable.std::ios_base::failure.0;\n        fcn.10008371(&var_14h, 0x10024960);\n    }\n    in_stack_ffffffc8 = \"ios_base::failbit set\";\ncode_r0x1000273d:\n    fcn.10001940(1, 0x10026084, in_stack_ffffffc8);\n    var_14h = vtable.std::ios_base::failure.0;\n    fcn.10008371(&var_14h, 0x10024960);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 384
    },
    "10002b90": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuchar * __cdecl fcn.10002b90(uchar *arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    char *pcVar2;\n    char *arg_8h_00;\n    uint var_4h;\n    \n    pcVar2 = fcn.10006570(arg_ch);\n    arg_8h_00 = \"unknown error\";\n    if (pcVar2 != NULL) {\n        arg_8h_00 = pcVar2;\n    }\n    *(arg_8h + 0x14) = 0xf;\n    *(arg_8h + 0x10) = 0;\n    *arg_8h = 0;\n    if (*arg_8h_00 == '\\0') {\n        fcn.100025b0(arg_8h_00, 0);\n        return arg_8h;\n    }\n    pcVar2 = arg_8h_00;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.100025b0(arg_8h_00, pcVar2 - (arg_8h_00 + 1));\n    return arg_8h;\n}\n",
        "token_count": 276
    },
    "10002c00": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuchar * __cdecl fcn.10002c00(uchar *arg_8h, int32_t arg_ch)\n\n{\n    uint var_4h;\n    \n    if (arg_ch == 1) {\n        *(arg_8h + 0x14) = 0xf;\n        *(arg_8h + 0x10) = 0;\n        *arg_8h = 0;\n        fcn.100025b0(\"iostream stream error\", 0x15);\n        return arg_8h;\n    }\n    fcn.10002b90(arg_8h, arg_ch);\n    return arg_8h;\n}\n",
        "token_count": 139
    },
    "10002c50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuchar * __cdecl fcn.10002c50(uchar *arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    char *pcVar2;\n    char *arg_8h_00;\n    uint var_4h;\n    \n    pcVar2 = fcn.1000659a(arg_ch);\n    arg_8h_00 = \"unknown error\";\n    if (pcVar2 != NULL) {\n        arg_8h_00 = pcVar2;\n    }\n    *(arg_8h + 0x14) = 0xf;\n    *(arg_8h + 0x10) = 0;\n    *arg_8h = 0;\n    if (*arg_8h_00 == '\\0') {\n        fcn.100025b0(arg_8h_00, 0);\n        return arg_8h;\n    }\n    pcVar2 = arg_8h_00;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.100025b0(arg_8h_00, pcVar2 - (arg_8h_00 + 1));\n    return arg_8h;\n}\n",
        "token_count": 277
    },
    "10005240": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.10005240(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint32_t *puVar6;\n    int32_t *piVar7;\n    uint32_t *puVar8;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = arg_8h[1];\n    if (*(*arg_8h + 0x84) != 0) {\n        piVar7 = *(*arg_8h + 0x80) + iVar1;\n        iVar2 = (*_sym.imp.KERNEL32.dll_IsBadReadPtr)(piVar7, 0x14);\n        while ((iVar2 == 0 && (piVar7[3] != 0))) {\n            iVar2 = (*arg_8h[7])(piVar7[3] + iVar1, arg_8h[10]);\n            if (iVar2 == 0) {\n                (*_sym.imp.KERNEL32.dll_SetLastError)(0x7e);\n                return 0;\n            }\n            iVar3 = fcn.10005c10(arg_8h[2], arg_8h[3] * 4 + 4);\n            if (iVar3 == 0) {\n                (*arg_8h[9])(iVar2, arg_8h[10]);\n                (*_sym.imp.KERNEL32.dll_SetLastError)(0xe);\n                return 0;\n            }\n            arg_8h[2] = iVar3;\n            *(iVar3 + arg_8h[3] * 4) = iVar2;\n            arg_8h[3] = arg_8h[3] + 1;\n            if (*piVar7 == 0) {\n                puVar6 = piVar7[4] + iVar1;\n                puVar8 = puVar6;\n            }\n            else {\n                puVar6 = piVar7[4] + iVar1;\n                puVar8 = *piVar7 + iVar1;\n            }\n            uVar4 = *puVar8;\n            if (uVar4 != 0) {\n                iVar3 = puVar6 - puVar8;\n                do {\n                    if (uVar4 < 0) {\n                        uVar4 = uVar4 & 0xffff;\n                    }\n                    else {\n                        uVar4 = uVar4 + iVar1 + 2;\n                    }\n                    iVar5 = (*arg_8h[8])(iVar2, uVar4, arg_8h[10]);\n                    *(iVar3 + puVar8) = iVar5;\n                    if (iVar5 == 0) {\n                        (*arg_8h[9])(iVar2, arg_8h[10]);\n                        (*_sym.imp.KERNEL32.dll_SetLastError)(0x7f);\n                        return 0;\n                    }\n                    uVar4 = puVar8[1];\n                    puVar8 = puVar8 + 1;\n                } while (uVar4 != 0);\n            }\n            piVar7 = piVar7 + 5;\n            iVar2 = (*_sym.imp.KERNEL32.dll_IsBadReadPtr)(piVar7, 0x14);\n        }\n    }\n    return 1;\n}\n",
        "token_count": 726
    },
    "10005530": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.10005530(int32_t *arg_8h, int32_t *lpflOldProtect)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    \n    uVar1 = lpflOldProtect[2];\n    if (uVar1 == 0) {\n        return true;\n    }\n    uVar2 = lpflOldProtect[3];\n    if ((uVar2 & 0x2000000) != 0) {\n        if ((*lpflOldProtect == lpflOldProtect[1]) &&\n           (((lpflOldProtect[4] != 0 || (*(*arg_8h + 0x38) == arg_8h[0xc])) || (uVar1 % arg_8h[0xc] == 0)))) {\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(*lpflOldProtect, uVar1, 0x4000);\n        }\n        return true;\n    }\n    uVar3 = *((((uVar2 >> 0x1e & 1) + (uVar2 >> 0x1d & 1) * 2) * 2 - (uVar2 >> 0x1f)) * 4 + 0x1002608c);\n    if ((uVar2 & 0x4000000) != 0) {\n        uVar3 = uVar3 | 0x200;\n    }\n    iVar4 = (*_sym.imp.KERNEL32.dll_VirtualProtect)(*lpflOldProtect, uVar1, uVar3, &lpflOldProtect);\n    return iVar4 != 0;\n}\n",
        "token_count": 371
    },
    "10005730": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.10005730(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    if (arg_8h != NULL) {\n        if (arg_8h[4] != 0) {\n            (*(*(*arg_8h + 0x28) + arg_8h[1]))(arg_8h[1], 0, 0);\n        }\n        if (arg_8h[2] != 0) {\n            iVar3 = 0;\n            if (0 < arg_8h[3]) {\n                do {\n                    iVar1 = *(arg_8h[2] + iVar3 * 4);\n                    if (iVar1 != 0) {\n                        (*arg_8h[9])(iVar1, arg_8h[10]);\n                    }\n                    iVar3 = iVar3 + 1;\n                } while (iVar3 < arg_8h[3]);\n            }\n            fcn.10005950(arg_8h[2]);\n        }\n        if (arg_8h[1] != 0) {\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(arg_8h[1], 0, 0x8000);\n        }\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, arg_8h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    return;\n}\n",
        "token_count": 328
    },
    "100057f0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.100057f0(int32_t *arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint16_t *puVar5;\n    int32_t *piVar6;\n    uint32_t uVar7;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = arg_8h[1];\n    if (*(*arg_8h + 0x7c) != 0) {\n        iVar3 = *(*arg_8h + 0x78) + iVar1;\n        uVar4 = *(iVar3 + 0x18);\n        if ((uVar4 != 0) && (*(iVar3 + 0x14) != 0)) {\n            if (arg_ch >> 0x10 == 0) {\n                if (*(iVar3 + 0x10) <= (arg_ch & 0xffff)) {\n                    uVar4 = (arg_ch & 0xffff) - *(iVar3 + 0x10);\ncode_r0x1000589c:\n                    if (uVar4 < *(iVar3 + 0x14) || uVar4 == *(iVar3 + 0x14)) {\n                        return *(*(iVar3 + 0x1c) + uVar4 * 4 + iVar1) + iVar1;\n                    }\n                }\n            }\n            else {\n                uVar7 = 0;\n                piVar6 = *(iVar3 + 0x20) + iVar1;\n                puVar5 = *(iVar3 + 0x24) + iVar1;\n                if (*(iVar3 + 0x18) != 0) {\n                    do {\n                        iVar2 = fcn.10005dc0(arg_ch, *piVar6 + iVar1);\n                        if (iVar2 == 0) {\n                            uVar4 = *puVar5;\n                            goto code_r0x1000589c;\n                        }\n                        uVar7 = uVar7 + 1;\n                        piVar6 = piVar6 + 1;\n                        puVar5 = puVar5 + 1;\n                    } while (uVar7 < uVar4);\n                }\n            }\n            (*_sym.imp.KERNEL32.dll_SetLastError)(0x7f);\n            return 0;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_SetLastError)(0x7f);\n    return 0;\n}\n",
        "token_count": 543
    },
    "10005970": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl\nfcn.10005970(int16_t *arg_8h, uint arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t arg_8h_00;\n    code *pcVar4;\n    int32_t *piVar5;\n    int32_t *piVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uint lpSystemInfo;\n    int32_t var_28h;\n    int32_t var_8h;\n    uint var_4h;\n    \n    uVar7 = 0;\n    iVar1 = fcn.100053c0(arg_ch, 0x40);\n    if (iVar1 == 0) {\n        return NULL;\n    }\n    if (*arg_8h == 0x5a4d) {\n        iVar1 = fcn.100053c0(arg_ch, *(arg_8h + 0x1e) + 0xf8);\n        if (iVar1 == 0) {\n            return NULL;\n        }\n        piVar6 = *(arg_8h + 0x1e) + arg_8h;\n        if (((*piVar6 == 0x4550) && (*(piVar6 + 1) == 0x14c)) && ((*(piVar6 + 0xe) & 1) == 0)) {\n            uVar8 = *(piVar6 + 6);\n            if (uVar8 != 0) {\n                piVar5 = piVar6 + *(piVar6 + 5) + 0x24;\n                do {\n                    iVar1 = piVar5[1];\n                    if (iVar1 == 0) {\n                        iVar1 = piVar6[0xe];\n                    }\n                    if (uVar7 < *piVar5 + iVar1) {\n                        uVar7 = *piVar5 + iVar1;\n                    }\n                    piVar5 = piVar5 + 10;\n                    uVar8 = uVar8 - 1;\n                } while (uVar8 != 0);\n            }\n            (*_sym.imp.KERNEL32.dll_GetNativeSystemInfo)(&fcn.10005970::lpSystemInfo);\n            uVar8 = var_28h + -1 + piVar6[0x14] & ~(var_28h - 1U);\n            if (uVar8 == (var_28h + -1 + uVar7 & ~(var_28h - 1U))) {\n                iVar1 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(piVar6[0xd], uVar8, 0x3000, 4);\n                if ((iVar1 != 0) ||\n                   (var_8h = iVar1,  iVar1 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, uVar8, 0x3000, 4),  var_8h = iVar1\n                   ,  iVar1 != 0)) {\n                    var_8h = iVar1;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x34);\n                    piVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    if (piVar5 != NULL) {\n                        piVar5[1] = iVar1;\n                        piVar5[5] = *(piVar6 + 0x16) >> 0xd & 1;\n                        piVar5[7] = arg_10h;\n                        piVar5[8] = arg_14h;\n                        piVar5[9] = arg_18h;\n                        piVar5[10] = arg_1ch;\n                        piVar5[0xc] = var_28h;\n                        iVar3 = fcn.100053c0(arg_ch, piVar6[0x15]);\n                        if (iVar3 != 0) {\n                            arg_8h_00 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(iVar1, piVar6[0x15], 0x1000, 4);\n                            fcn.10005d90(arg_8h_00, arg_8h, piVar6[0x15]);\n                            iVar3 = var_8h;\n                            iVar1 = *(arg_8h + 0x1e);\n                            *piVar5 = iVar1 + arg_8h_00;\n                            *(iVar1 + arg_8h_00 + 0x34) = var_8h;\n                            iVar1 = fcn.100053f0(arg_8h, arg_ch, piVar6, piVar5);\n                            if (iVar1 != 0) {\n                                iVar1 = *(*piVar5 + 0x34) - piVar6[0xd];\n                                if (iVar1 == 0) {\n                                    piVar5[6] = 1;\n                                }\n                                else {\n                                    iVar1 = fcn.10005cb0(piVar5, iVar1);\n                                    piVar5[6] = iVar1;\n                                }\n                                uVar2 = 0x10005b66;\n                                iVar1 = fcn.10005240(piVar5);\n                                if (((iVar1 != 0) && (iVar1 = fcn.100055e0(0x10005b76),  iVar1 != 0)) &&\n                                   (piVar6 = piVar5,  iVar1 = fcn.100054e0(piVar5),  iVar1 != 0)) {\n                                    if (*(*piVar5 + 0x28) == 0) {\n                                        piVar5[0xb] = 0;\n                                        return piVar5;\n                                    }\n                                    pcVar4 = *(*piVar5 + 0x28) + iVar3;\n                                    if (piVar5[5] != 0) {\n                                        iVar1 = (*pcVar4)(0x10000000, 1, 0, piVar6, uVar2);\n                                        if (iVar1 == 0) {\n                                            (*_sym.imp.KERNEL32.dll_SetLastError)(0x45a);\n                                            fcn.10005730(piVar5);\n                                            return NULL;\n                                        }\n                                        piVar5[4] = 1;\n                                        return piVar5;\n                                    }\n                                    piVar5[0xb] = pcVar4;\n                                    return piVar5;\n                                }\n                            }\n                        }\n                        fcn.10005730(piVar5);\n                        return NULL;\n                    }\n                    (*_sym.imp.KERNEL32.dll_VirtualFree)(iVar1, 0, 0x8000);\n                }\n                (*_sym.imp.KERNEL32.dll_SetLastError)(0xe);\n                return NULL;\n            }\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_SetLastError)(0xc1);\n    return NULL;\n}\n",
        "token_count": 1511
    },
    "10005cb0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.10005cb0(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t *piVar6;\n    uint32_t uVar7;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar3 = arg_8h[1];\n    if (*(*arg_8h + 0xa4) == 0) {\n        return arg_ch == 0;\n    }\n    piVar6 = *(*arg_8h + 0xa0) + iVar3;\n    iVar4 = *piVar6;\n    while (iVar4 != 0) {\n        piVar1 = piVar6 + 1;\n        piVar5 = piVar6 + 2;\n        uVar7 = 0;\n        if ((*piVar1 - 8U & 0xfffffffe) != 0) {\n            do {\n                if ((*piVar5 & 0xf000) == 0x3000) {\n                    piVar2 = (*piVar5 & 0xfff) + iVar4 + iVar3;\n                    *piVar2 = *piVar2 + arg_ch;\n                }\n                uVar7 = uVar7 + 1;\n                piVar5 = piVar5 + 2;\n            } while (uVar7 < *piVar1 - 8U >> 1);\n        }\n        piVar6 = piVar6 + *piVar1;\n        iVar4 = *piVar6;\n    }\n    return true;\n}\n",
        "token_count": 368
    },
    "10006570": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.10006570(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    \n    piVar2 = 0x1001d6d0;\n    if (*0x1001d6d4 != 0) {\n        do {\n            if (*piVar2 == arg_8h) {\n                return piVar2[1];\n            }\n            piVar1 = piVar2 + 3;\n            piVar2 = piVar2 + 2;\n        } while (*piVar1 != 0);\n    }\n    return 0;\n}\n",
        "token_count": 140
    },
    "1000659a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.1000659a(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    \n    piVar2 = 0x1001d478;\n    if (*0x1001d47c != 0) {\n        do {\n            if (*piVar2 == arg_8h) {\n                return piVar2[1];\n            }\n            piVar1 = piVar2 + 3;\n            piVar2 = piVar2 + 2;\n        } while (*piVar1 != 0);\n    }\n    return 0;\n}\n",
        "token_count": 138
    },
    "100066b9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.100066b9(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint arg_ch_00;\n    uint arg_8h_00;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.1000a19e(8);\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    *(unaff_EBP + -0x10) = 0;\n    if (*(unaff_EBP + 0x10) != 0) {\n        *extraout_ECX = 0x1001e228;\n        extraout_ECX[2] = vtable.std::basic_ios_char__struct_std::char_traits_char__.0;\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x10) = 1;\n    }\n    arg_ch_00 = *(unaff_EBP + 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    *(extraout_ECX + *(*extraout_ECX + 4)) = vtable.std::basic_ostream_char__struct_std::char_traits_char__.0;\n    *(*(*extraout_ECX + 4) + -4 + extraout_ECX) = *(*extraout_ECX + 4) + -8;\n    fcn.10006d7b(arg_8h_00, arg_ch_00);\n    fcn.1000a17b();\n    return;\n}\n",
        "token_count": 375
    },
    "100067ae": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.100067ae(code **param_1)\n\n{\n    code *pcVar1;\n    uint unaff_ESI;\n    \n    *param_1 = vtable.std::basic_filebuf_char__struct_std::char_traits_char__.0;\n    if (param_1[0x14] != NULL) {\n        fcn.10006ba3();\n    }\n    if (*(param_1 + 0x13) != '\\0') {\n        fcn.10006cbc();\n    }\n    pcVar1 = param_1[0xd];\n    *param_1 = vtable.std::basic_streambuf_char__struct_std::char_traits_char__.0;\n    if (pcVar1 != NULL) {\n        fcn.10001b10(unaff_ESI);\n        fcn.100077ed(pcVar1);\n    }\n    return;\n}\n",
        "token_count": 185
    },
    "1000812f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.1000812f(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint uVar3;\n    \n    if (arg_8h != 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_HeapFree)(*0x10027f54, 0, arg_8h);\n        if (iVar1 == 0) {\n            puVar2 = fcn.1000beaa();\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar3 = fcn.1000bebd(uVar3);\n            *puVar2 = uVar3;\n        }\n    }\n    return;\n}\n",
        "token_count": 157
    },
    "1000850b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.1000850b(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_8h, uint arg_ch, uint noname_17, uint noname_18, uint arg_18h, uint arg_1ch, \n            uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    uint var_38h;\n    uint *var_34h;\n    uint *var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint *var_38h_2;\n    code *pcStack56;\n    uint32_t uStack52;\n    uint uStack48;\n    uint *puStack44;\n    uint uStack40;\n    uint uStack36;\n    uchar *puStack32;\n    uchar *var_18h_2;\n    int32_t var_14h_2;\n    uint *var_10h;\n    uint var_ch;\n    code *var_8h;\n    uint var_4h;\n    \n    var_18h_2 = &stack0xfffffffc;\n    puStack32 = &stack0xffffffc0;\n    if (var_34h == 0x123) {\n        *var_30h = 0x100085b4;\n        var_4h = 1;\n    }\n    else {\n        pcStack56 = fcn.10008405;\n        uStack52 = *0x100264f0 ^ &fcn.1000850b::var_38h_2;\n        uStack48 = var_24h;\n        puStack44 = var_30h;\n        uStack40 = var_20h;\n        uStack36 = var_1ch;\n        var_14h_2 = 0;\n        var_38h_2 = *in_FS_OFFSET;\n        *in_FS_OFFSET = &fcn.1000850b::var_38h_2;\n        var_4h = 1;\n        var_10h = var_34h;\n        var_ch = var_2ch;\n        iVar1 = fcn.1000f923();\n        var_8h = *(iVar1 + 0x80);\n        (*var_8h)(*var_34h, &fcn.1000850b::var_10h);\n        var_4h = 0;\n        if (var_14h_2 == 0) {\n            *in_FS_OFFSET = var_38h_2;\n        }\n        else {\n            *var_38h_2 = **in_FS_OFFSET;\n            *in_FS_OFFSET = var_38h_2;\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 698
    },
    "1000952a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.1000952a(uint noname_0, uint noname_1, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_1ch;\n    \n    *(unaff_EDI + -4) = *(unaff_EBP + -0x28);\n    fcn.10008711(*(unaff_EBP + -0x2c));\n    iVar1 = fcn.1000f923();\n    *(iVar1 + 0x88) = *(unaff_EBP + -0x30);\n    iVar1 = fcn.1000f923();\n    *(iVar1 + 0x8c) = *(unaff_EBP + -0x34);\n    if (((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&\n         ((unaff_ESI[5] == 0x19930520 || ((unaff_ESI[5] == 0x19930521 || (unaff_ESI[5] == 0x19930522)))))) &&\n        (*(unaff_EBP + -0x38) == 0)) &&\n       ((*(unaff_EBP + -0x1c) != 0 && (iVar1 = fcn.10008761(unaff_ESI[6]),  iVar1 != 0)))) {\n        fcn.1000930d(unaff_ESI);\n    }\n    return;\n}\n",
        "token_count": 381
    },
    "10009f85": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.10009f85(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.1000f923();\n    if (0 < *(iVar1 + 0x90)) {\n        iVar1 = fcn.1000f923();\n        *(iVar1 + 0x90) = *(iVar1 + 0x90) + -1;\n    }\n    return;\n}\n",
        "token_count": 89
    },
    "1000e24f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x1000e344: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x1000e349)\n// WARNING: Removing unreachable block (ram,0x1000e378)\n// WARNING: Removing unreachable block (ram,0x1000e34f)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.1000e24f(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t unaff_EBP;\n    int32_t *piVar7;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.1000e3b0(0x10024f20, 0x1c);\n    fcn.1000918e(8);\n    *(unaff_EBP + -4) = 0;\n    pcVar5 = _sym.imp.KERNEL32.dll_DecodePointer;\n    if (*0x10027f0c != 1) {\n        *0x10027f34 = 1;\n        *0x10027f30 = *(unaff_EBP + 0x10);\n        if (*(unaff_EBP + 0xc) == 0) {\n            piVar2 = (*_sym.imp.KERNEL32.dll_DecodePointer)(*0x10028c28);\n            *(unaff_EBP + -0x2c) = piVar2;\n            if (piVar2 != NULL) {\n                piVar3 = (*pcVar5)(*0x10028c24);\n                *(unaff_EBP + -0x1c) = piVar2;\n                *(unaff_EBP + -0x20) = piVar3;\n                do {\n                    *(unaff_EBP + -0x24) = piVar3;\n                    piVar7 = piVar3;\n                    do {\n                        do {\n                            piVar7 = piVar7 + -1;\n                            *(unaff_EBP + -0x24) = piVar7;\n                            if (piVar7 < piVar2) goto code_r0x1000e31b;\n                            iVar4 = (*_sym.imp.KERNEL32.dll_EncodePointer)(0);\n                        } while (*piVar7 == iVar4);\n                        if (piVar7 < piVar2) goto code_r0x1000e31b;\n                        pcVar5 = (*pcVar5)(*piVar7);\n                        iVar4 = (*_sym.imp.KERNEL32.dll_EncodePointer)(0);\n                        *piVar7 = iVar4;\n                        (*pcVar5)();\n                        pcVar5 = _sym.imp.KERNEL32.dll_DecodePointer;\n                        uVar6 = (*_sym.imp.KERNEL32.dll_DecodePointer)(*0x10028c28);\n                        *(unaff_EBP + -0x28) = uVar6;\n                        piVar3 = (*pcVar5)(*0x10028c24);\n                        piVar1 = *(unaff_EBP + -0x28);\n                    } while ((*(unaff_EBP + -0x1c) == piVar1) && (*(unaff_EBP + -0x20) == piVar3));\n                    *(unaff_EBP + -0x1c) = piVar1;\n                    *(unaff_EBP + -0x2c) = piVar1;\n                    *(unaff_EBP + -0x20) = piVar3;\n                    piVar2 = piVar1;\n                } while( true );\n            }\ncode_r0x1000e31b:\n            fcn.1000e1e5(0x1001d1a0, 0x1001d1b4);\n        }\n        fcn.1000e1e5(0x1001d1b8, 0x1001d1bc);\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    if (*(unaff_EBP + 0x10) != 0) {\n        fcn.100092f8(8);\n    }\n    return;\n}\n",
        "token_count": 961
    },
    "10019300": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_44h\n\nvoid __cdecl fcn.10019300(uint16_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint16_t uVar1;\n    uint16_t uVar2;\n    uint8_t uVar3;\n    bool bVar4;\n    bool bVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint8_t uVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    uint *puVar13;\n    int32_t iVar14;\n    int32_t iVar15;\n    uint32_t uVar16;\n    uint32_t uVar17;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    int32_t var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    uint var_1ch;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = *0x100264f0 ^ &stack0xfffffffc;\n    uVar1 = arg_8h[5];\n    iVar14 = 0;\n    uVar10 = uVar1 & 0x7fff;\n    uVar16 = *(arg_8h + 3);\n    iVar11 = uVar10 - 0x3fff;\n    var_10h = uVar16;\n    uVar17 = *(arg_8h + 1);\n    var_ch = uVar17;\n    uVar2 = *arg_8h;\n    var_8h = uVar2 << 0x10;\n    uVar3 = str.5_v_[1];\n    if (iVar11 == -0x3fff) {\n        iVar15 = 0;\n        iVar11 = 0;\n        do {\n            if ((&var_10h)[iVar11] != 0) {\n                var_10h = 0;\n                var_ch = 0;\n                var_8h = 0;\n                goto code_r0x10019375;\n            }\n            iVar11 = iVar11 + 1;\n        } while (iVar11 < 3);\n    }\n    else {\n        iVar6 = str.5_v_[0] + L'\\xffffffff';\n        bVar5 = false;\n        iVar15 = (str.5_v_[0] >> 0x1f & 0x1fU) + str.5_v_[0] >> 5;\n        uVar8 = 0x1f - (str.5_v_[0] & 0x1f);\n        if (((&var_10h)[iVar15] & 1 << (uVar8 & 0x1f)) != 0) {\n            uVar7 = (&var_10h)[iVar15] & ~(-1 << (uVar8 & 0x1f));\n            iVar12 = iVar15;\n            while (uVar7 == 0) {\n                iVar12 = iVar12 + 1;\n                if (2 < iVar12) goto code_r0x10019475;\n                uVar7 = (&var_10h)[iVar12];\n            }\n            iVar12 = (iVar6 >> 0x1f & 0x1fU) + iVar6 >> 5;\n            bVar5 = false;\n            uVar7 = 1 << (0x1f - (iVar6 & 0x1f) & 0x1f);\n            uVar9 = uVar7 + (&var_10h)[iVar12];\n            bVar4 = false;\n            if ((uVar9 < (&var_10h)[iVar12]) || (uVar9 < uVar7)) {\n                bVar4 = true;\n                bVar5 = true;\n            }\n            (&var_10h)[iVar12] = uVar9;\n            while ((iVar12 = iVar12 + -1,  -1 < iVar12 && (bVar4))) {\n                bVar4 = false;\n                bVar5 = false;\n                uVar7 = (&var_10h)[iVar12] + 1;\n                if ((uVar7 < (&var_10h)[iVar12]) || (uVar7 == 0)) {\n                    bVar4 = true;\n                    bVar5 = true;\n                }\n                (&var_10h)[iVar12] = uVar7;\n            }\n        }\ncode_r0x10019475:\n        (&var_10h)[iVar15] = (&var_10h)[iVar15] & -1 << (uVar8 & 0x1f);\n        iVar15 = iVar15 + 1;\n        if (iVar15 < 3) {\n            puVar13 = &var_10h + iVar15;\n            for (iVar12 = 3 - iVar15; iVar12 != 0; iVar12 = iVar12 + -1) {\n                *puVar13 = 0;\n                puVar13 = puVar13 + 1;\n            }\n        }\n        iVar15 = iVar11;\n        if (bVar5) {\n            iVar15 = uVar10 - 0x3ffe;\n        }\n        if (iVar15 < *0x1002737c - str.5_v_[0]) {\n            var_10h = 0;\n            var_ch = 0;\n            var_8h = 0;\n        }\n        else {\n            if (*0x1002737c < iVar15) {\n                if (iVar15 < *0x10027378) {\n                    var_10h = var_10h & 0x7fffffff;\n                    iVar15 = str.5_v_[3] + iVar15;\n                    iVar11 = str.5_v_[1] + (str.5_v_[1] >> 0x1f & 0x1fU) >> 5;\n                    uVar8 = uVar3 & 0x1f;\n                    var_20h = 0;\n                    iVar14 = 0;\n                    do {\n                        uVar16 = (&var_10h)[iVar14] >> uVar8 | var_20h;\n                        var_20h = ((&var_10h)[iVar14] & ~(-1 << uVar8)) << (0x20 - uVar8 & 0x1f);\n                        (&var_10h)[iVar14] = uVar16;\n                        iVar14 = iVar14 + 1;\n                    } while (iVar14 < 3);\n                    puVar13 = &var_8h + -iVar11;\n                    iVar14 = 2;\n                    do {\n                        if (iVar14 < iVar11) {\n                            (&var_10h)[iVar14] = 0;\n                        }\n                        else {\n                            (&var_10h)[iVar14] = *puVar13;\n                        }\n                        puVar13 = puVar13 + -1;\n                        iVar14 = iVar14 + -1;\n                    } while (-1 < iVar14);\n                }\n                else {\n                    var_ch = 0;\n                    var_8h = 0;\n                    var_10h = 0x80000000;\n                    iVar11 = str.5_v_[1] + (str.5_v_[1] >> 0x1f & 0x1fU) >> 5;\n                    uVar8 = uVar3 & 0x1f;\n                    var_20h = 0;\n                    do {\n                        uVar16 = (&var_10h)[iVar14] >> uVar8 | var_20h;\n                        var_20h = ((&var_10h)[iVar14] & ~(-1 << uVar8)) << (0x20 - uVar8 & 0x1f);\n                        (&var_10h)[iVar14] = uVar16;\n                        iVar14 = iVar14 + 1;\n                    } while (iVar14 < 3);\n                    puVar13 = &var_8h + -iVar11;\n                    iVar14 = 2;\n                    do {\n                        if (iVar14 < iVar11) {\n                            (&var_10h)[iVar14] = 0;\n                        }\n                        else {\n                            (&var_10h)[iVar14] = *puVar13;\n                        }\n                        puVar13 = puVar13 + -1;\n                        iVar14 = iVar14 + -1;\n                    } while (-1 < iVar14);\n                    iVar15 = str.5_v_[3] + *0x10027378;\n                }\n                goto code_r0x10019826;\n            }\n            iVar11 = *0x1002737c - iVar11;\n            var_10h = uVar16;\n            iVar15 = iVar11 + (iVar11 >> 0x1f & 0x1fU) >> 5;\n            var_ch = uVar17;\n            var_8h = uVar2 << 0x10;\n            uVar8 = iVar11 & 0x1f;\n            var_20h = 0;\n            do {\n                uVar16 = (&var_10h)[iVar14] >> uVar8 | var_20h;\n                var_20h = ((&var_10h)[iVar14] & ~(-1 << uVar8)) << (0x20 - uVar8 & 0x1f);\n                (&var_10h)[iVar14] = uVar16;\n                iVar14 = iVar14 + 1;\n            } while (iVar14 < 3);\n            puVar13 = &var_8h + -iVar15;\n            iVar11 = 2;\n            do {\n                if (iVar11 < iVar15) {\n                    (&var_10h)[iVar11] = 0;\n                }\n                else {\n                    (&var_10h)[iVar11] = *puVar13;\n                }\n                puVar13 = puVar13 + -1;\n                iVar11 = iVar11 + -1;\n            } while (-1 < iVar11);\n            iVar11 = (str.5_v_[0] >> 0x1f & 0x1fU) + str.5_v_[0] >> 5;\n            uVar8 = 0x1f - (str.5_v_[0] & 0x1f);\n            if (((&var_10h)[iVar11] & 1 << (uVar8 & 0x1f)) != 0) {\n                uVar16 = (&var_10h)[iVar11] & ~(-1 << (uVar8 & 0x1f));\n                iVar14 = iVar11;\n                while (uVar16 == 0) {\n                    iVar14 = iVar14 + 1;\n                    if (2 < iVar14) goto code_r0x10019630;\n                    uVar16 = (&var_10h)[iVar14];\n                }\n                iVar14 = (iVar6 >> 0x1f & 0x1fU) + iVar6 >> 5;\n                uVar16 = 1 << (0x1f - (iVar6 & 0x1f) & 0x1f);\n                bVar5 = false;\n                uVar17 = uVar16 + (&var_10h)[iVar14];\n                if ((uVar17 < (&var_10h)[iVar14]) || (uVar17 < uVar16)) {\n                    bVar5 = true;\n                }\n                (&var_10h)[iVar14] = uVar17;\n                while ((iVar14 = iVar14 + -1,  -1 < iVar14 && (bVar5))) {\n                    bVar5 = false;\n                    uVar16 = (&var_10h)[iVar14] + 1;\n                    if ((uVar16 < (&var_10h)[iVar14]) || (uVar16 == 0)) {\n                        bVar5 = true;\n                    }\n                    (&var_10h)[iVar14] = uVar16;\n                }\n            }\ncode_r0x10019630:\n            (&var_10h)[iVar11] = (&var_10h)[iVar11] & -1 << (uVar8 & 0x1f);\n            iVar11 = iVar11 + 1;\n            if (iVar11 < 3) {\n                puVar13 = &var_10h + iVar11;\n                for (iVar14 = 3 - iVar11; iVar14 != 0; iVar14 = iVar14 + -1) {\n                    *puVar13 = 0;\n                    puVar13 = puVar13 + 1;\n                }\n            }\n            iVar14 = str.5_v_[1] + L'\\x01';\n            iVar11 = iVar14 + (iVar14 >> 0x1f & 0x1fU) >> 5;\n            uVar8 = iVar14 & 0x1f;\n            var_20h = 0;\n            var_34h = 0;\n            do {\n                uVar16 = (&var_10h)[var_34h];\n                (&var_10h)[var_34h] = uVar16 >> uVar8 | var_20h;\n                var_20h = (uVar16 & ~(-1 << uVar8)) << (0x20 - uVar8 & 0x1f);\n                var_34h = var_34h + 1;\n            } while (var_34h < 3);\n            puVar13 = &var_8h + -iVar11;\n            iVar14 = 2;\n            do {\n                if (iVar14 < iVar11) {\n                    (&var_10h)[iVar14] = 0;\n                }\n                else {\n                    (&var_10h)[iVar14] = *puVar13;\n                }\n                puVar13 = puVar13 + -1;\n                iVar14 = iVar14 + -1;\n            } while (-1 < iVar14);\n        }\ncode_r0x10019375:\n        iVar15 = 0;\n    }\ncode_r0x10019826:\n    uVar16 = iVar15 << (0x1f - uVar3 & 0x1f) | -((uVar1 & 0x8000) != 0) & 0x80000000 | var_10h;\n    if (str.5_v_[2] == L'@') {\n        arg_ch[1] = uVar16;\n        *arg_ch = var_ch;\n    }\n    else if (str.5_v_[2] == L' ') {\n        *arg_ch = uVar16;\n    }\n    fcn.10008362(uVar1 & 0x8000);\n    return;\n}\n",
        "token_count": 3219
    },
    "10019872": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_44h\n\nvoid __cdecl fcn.10019872(uint16_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint16_t uVar1;\n    uint16_t uVar2;\n    uint8_t uVar3;\n    bool bVar4;\n    bool bVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint8_t uVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    uint *puVar13;\n    int32_t iVar14;\n    int32_t iVar15;\n    uint32_t uVar16;\n    uint32_t uVar17;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    int32_t var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    uint var_1ch;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = *0x100264f0 ^ &stack0xfffffffc;\n    uVar1 = arg_8h[5];\n    iVar14 = 0;\n    uVar10 = uVar1 & 0x7fff;\n    uVar16 = *(arg_8h + 3);\n    iVar11 = uVar10 - 0x3fff;\n    var_10h = uVar16;\n    uVar17 = *(arg_8h + 1);\n    var_ch = uVar17;\n    uVar2 = *arg_8h;\n    var_8h = uVar2 << 0x10;\n    uVar3 = *0x1002739c;\n    if (iVar11 == -0x3fff) {\n        iVar15 = 0;\n        iVar11 = 0;\n        do {\n            if ((&var_10h)[iVar11] != 0) {\n                var_10h = 0;\n                var_ch = 0;\n                var_8h = 0;\n                goto code_r0x100198e7;\n            }\n            iVar11 = iVar11 + 1;\n        } while (iVar11 < 3);\n    }\n    else {\n        iVar6 = *0x10027398 + -1;\n        bVar5 = false;\n        iVar15 = (*0x10027398 >> 0x1f & 0x1fU) + *0x10027398 >> 5;\n        uVar8 = 0x1f - (*0x10027398 & 0x1f);\n        if (((&var_10h)[iVar15] & 1 << (uVar8 & 0x1f)) != 0) {\n            uVar7 = (&var_10h)[iVar15] & ~(-1 << (uVar8 & 0x1f));\n            iVar12 = iVar15;\n            while (uVar7 == 0) {\n                iVar12 = iVar12 + 1;\n                if (2 < iVar12) goto code_r0x100199e7;\n                uVar7 = (&var_10h)[iVar12];\n            }\n            iVar12 = (iVar6 >> 0x1f & 0x1fU) + iVar6 >> 5;\n            bVar5 = false;\n            uVar7 = 1 << (0x1f - (iVar6 & 0x1f) & 0x1f);\n            uVar9 = uVar7 + (&var_10h)[iVar12];\n            bVar4 = false;\n            if ((uVar9 < (&var_10h)[iVar12]) || (uVar9 < uVar7)) {\n                bVar4 = true;\n                bVar5 = true;\n            }\n            (&var_10h)[iVar12] = uVar9;\n            while ((iVar12 = iVar12 + -1,  -1 < iVar12 && (bVar4))) {\n                bVar4 = false;\n                bVar5 = false;\n                uVar7 = (&var_10h)[iVar12] + 1;\n                if ((uVar7 < (&var_10h)[iVar12]) || (uVar7 == 0)) {\n                    bVar4 = true;\n                    bVar5 = true;\n                }\n                (&var_10h)[iVar12] = uVar7;\n            }\n        }\ncode_r0x100199e7:\n        (&var_10h)[iVar15] = (&var_10h)[iVar15] & -1 << (uVar8 & 0x1f);\n        iVar15 = iVar15 + 1;\n        if (iVar15 < 3) {\n            puVar13 = &var_10h + iVar15;\n            for (iVar12 = 3 - iVar15; iVar12 != 0; iVar12 = iVar12 + -1) {\n                *puVar13 = 0;\n                puVar13 = puVar13 + 1;\n            }\n        }\n        iVar15 = iVar11;\n        if (bVar5) {\n            iVar15 = uVar10 - 0x3ffe;\n        }\n        if (iVar15 < *0x10027394 - *0x10027398) {\n            var_10h = 0;\n            var_ch = 0;\n            var_8h = 0;\n        }\n        else {\n            if (*0x10027394 < iVar15) {\n                if (iVar15 < *0x10027390) {\n                    var_10h = var_10h & 0x7fffffff;\n                    iVar15 = *0x100273a4 + iVar15;\n                    iVar11 = *0x1002739c + (*0x1002739c >> 0x1f & 0x1fU) >> 5;\n                    uVar8 = uVar3 & 0x1f;\n                    var_20h = 0;\n                    iVar14 = 0;\n                    do {\n                        uVar16 = (&var_10h)[iVar14] >> uVar8 | var_20h;\n                        var_20h = ((&var_10h)[iVar14] & ~(-1 << uVar8)) << (0x20 - uVar8 & 0x1f);\n                        (&var_10h)[iVar14] = uVar16;\n                        iVar14 = iVar14 + 1;\n                    } while (iVar14 < 3);\n                    puVar13 = &var_8h + -iVar11;\n                    iVar14 = 2;\n                    do {\n                        if (iVar14 < iVar11) {\n                            (&var_10h)[iVar14] = 0;\n                        }\n                        else {\n                            (&var_10h)[iVar14] = *puVar13;\n                        }\n                        puVar13 = puVar13 + -1;\n                        iVar14 = iVar14 + -1;\n                    } while (-1 < iVar14);\n                }\n                else {\n                    var_ch = 0;\n                    var_8h = 0;\n                    var_10h = 0x80000000;\n                    iVar11 = *0x1002739c + (*0x1002739c >> 0x1f & 0x1fU) >> 5;\n                    uVar8 = uVar3 & 0x1f;\n                    var_20h = 0;\n                    do {\n                        uVar16 = (&var_10h)[iVar14] >> uVar8 | var_20h;\n                        var_20h = ((&var_10h)[iVar14] & ~(-1 << uVar8)) << (0x20 - uVar8 & 0x1f);\n                        (&var_10h)[iVar14] = uVar16;\n                        iVar14 = iVar14 + 1;\n                    } while (iVar14 < 3);\n                    puVar13 = &var_8h + -iVar11;\n                    iVar14 = 2;\n                    do {\n                        if (iVar14 < iVar11) {\n                            (&var_10h)[iVar14] = 0;\n                        }\n                        else {\n                            (&var_10h)[iVar14] = *puVar13;\n                        }\n                        puVar13 = puVar13 + -1;\n                        iVar14 = iVar14 + -1;\n                    } while (-1 < iVar14);\n                    iVar15 = *0x100273a4 + *0x10027390;\n                }\n                goto code_r0x10019d98;\n            }\n            iVar11 = *0x10027394 - iVar11;\n            var_10h = uVar16;\n            iVar15 = iVar11 + (iVar11 >> 0x1f & 0x1fU) >> 5;\n            var_ch = uVar17;\n            var_8h = uVar2 << 0x10;\n            uVar8 = iVar11 & 0x1f;\n            var_20h = 0;\n            do {\n                uVar16 = (&var_10h)[iVar14] >> uVar8 | var_20h;\n                var_20h = ((&var_10h)[iVar14] & ~(-1 << uVar8)) << (0x20 - uVar8 & 0x1f);\n                (&var_10h)[iVar14] = uVar16;\n                iVar14 = iVar14 + 1;\n            } while (iVar14 < 3);\n            puVar13 = &var_8h + -iVar15;\n            iVar11 = 2;\n            do {\n                if (iVar11 < iVar15) {\n                    (&var_10h)[iVar11] = 0;\n                }\n                else {\n                    (&var_10h)[iVar11] = *puVar13;\n                }\n                puVar13 = puVar13 + -1;\n                iVar11 = iVar11 + -1;\n            } while (-1 < iVar11);\n            iVar11 = (*0x10027398 >> 0x1f & 0x1fU) + *0x10027398 >> 5;\n            uVar8 = 0x1f - (*0x10027398 & 0x1f);\n            if (((&var_10h)[iVar11] & 1 << (uVar8 & 0x1f)) != 0) {\n                uVar16 = (&var_10h)[iVar11] & ~(-1 << (uVar8 & 0x1f));\n                iVar14 = iVar11;\n                while (uVar16 == 0) {\n                    iVar14 = iVar14 + 1;\n                    if (2 < iVar14) goto code_r0x10019ba2;\n                    uVar16 = (&var_10h)[iVar14];\n                }\n                iVar14 = (iVar6 >> 0x1f & 0x1fU) + iVar6 >> 5;\n                uVar16 = 1 << (0x1f - (iVar6 & 0x1f) & 0x1f);\n                bVar5 = false;\n                uVar17 = uVar16 + (&var_10h)[iVar14];\n                if ((uVar17 < (&var_10h)[iVar14]) || (uVar17 < uVar16)) {\n                    bVar5 = true;\n                }\n                (&var_10h)[iVar14] = uVar17;\n                while ((iVar14 = iVar14 + -1,  -1 < iVar14 && (bVar5))) {\n                    bVar5 = false;\n                    uVar16 = (&var_10h)[iVar14] + 1;\n                    if ((uVar16 < (&var_10h)[iVar14]) || (uVar16 == 0)) {\n                        bVar5 = true;\n                    }\n                    (&var_10h)[iVar14] = uVar16;\n                }\n            }\ncode_r0x10019ba2:\n            (&var_10h)[iVar11] = (&var_10h)[iVar11] & -1 << (uVar8 & 0x1f);\n            iVar11 = iVar11 + 1;\n            if (iVar11 < 3) {\n                puVar13 = &var_10h + iVar11;\n                for (iVar14 = 3 - iVar11; iVar14 != 0; iVar14 = iVar14 + -1) {\n                    *puVar13 = 0;\n                    puVar13 = puVar13 + 1;\n                }\n            }\n            iVar14 = *0x1002739c + 1;\n            iVar11 = iVar14 + (iVar14 >> 0x1f & 0x1fU) >> 5;\n            uVar8 = iVar14 & 0x1f;\n            var_20h = 0;\n            var_34h = 0;\n            do {\n                uVar16 = (&var_10h)[var_34h];\n                (&var_10h)[var_34h] = uVar16 >> uVar8 | var_20h;\n                var_20h = (uVar16 & ~(-1 << uVar8)) << (0x20 - uVar8 & 0x1f);\n                var_34h = var_34h + 1;\n            } while (var_34h < 3);\n            puVar13 = &var_8h + -iVar11;\n            iVar14 = 2;\n            do {\n                if (iVar14 < iVar11) {\n                    (&var_10h)[iVar14] = 0;\n                }\n                else {\n                    (&var_10h)[iVar14] = *puVar13;\n                }\n                puVar13 = puVar13 + -1;\n                iVar14 = iVar14 + -1;\n            } while (-1 < iVar14);\n        }\ncode_r0x100198e7:\n        iVar15 = 0;\n    }\ncode_r0x10019d98:\n    uVar16 = iVar15 << (0x1f - uVar3 & 0x1f) | -((uVar1 & 0x8000) != 0) & 0x80000000 | var_10h;\n    if (*0x100273a0 == 0x40) {\n        arg_ch[1] = uVar16;\n        *arg_ch = var_ch;\n    }\n    else if (*0x100273a0 == 0x20) {\n        *arg_ch = uVar16;\n    }\n    fcn.10008362(uVar1 & 0x8000);\n    return;\n}\n",
        "token_count": 3210
    },
    "10001e60": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.10001e60(int32_t *arg_8h, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    code *pcVar3;\n    code *pcVar4;\n    uint32_t uVar5;\n    code **ppcVar6;\n    code **ppcVar7;\n    bool bVar8;\n    int32_t *in_FS_OFFSET;\n    int32_t arg_8h_00;\n    uint var_54h;\n    uint var_20h;\n    uint var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x1001bdbb;\n    var_ch = *in_FS_OFFSET;\n    uVar5 = *0x100264f0 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    bVar8 = false;\n    var_10h = 0;\n    if ((arg_8h != NULL) && (*arg_8h == 0)) {\n        arg_8h_00 = 0x18;\n        ppcVar6 = fcn.1000779c(0x18);\n        var_4h = 0;\n        if (ppcVar6 == NULL) {\n            ppcVar6 = NULL;\n        }\n        else {\n            iVar1 = *arg_ch;\n            if (iVar1 == 0) {\n                arg_8h_00 = 0x1001d244;\n            }\n            else {\n                arg_8h_00 = *(iVar1 + 0x18);\n                if (arg_8h_00 == 0) {\n                    arg_8h_00 = iVar1 + 0x1c;\n                }\n            }\n            fcn.10001700(arg_8h_00);\n            ppcVar6[1] = NULL;\n            bVar8 = true;\n            *ppcVar6 = vtable.std::ctype_char_.0;\n            ppcVar7 = fcn.10005ff0(&var_20h);\n            pcVar2 = ppcVar7[1];\n            pcVar3 = ppcVar7[2];\n            pcVar4 = ppcVar7[3];\n            ppcVar6[2] = *ppcVar7;\n            ppcVar6[3] = pcVar2;\n            ppcVar6[4] = pcVar3;\n            ppcVar6[5] = pcVar4;\n        }\n        *arg_8h = ppcVar6;\n        if (bVar8) {\n            fcn.10001a50(arg_8h_00, uVar5);\n        }\n    }\n    *in_FS_OFFSET = var_ch;\n    return 2;\n}\n",
        "token_count": 618
    },
    "10006856": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.10006856(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    fcn.10006803();\n    if ((arg_8h & 1) != 0) {\n        fcn.100077ed(in_ECX + -8);\n    }\n    return in_ECX + -8;\n}\n",
        "token_count": 80
    },
    "10013535": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.10013535(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t arg_8h_00;\n    uint *puVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.1000e3b0(0x10025148, 0x10);\n    *(unaff_EBP + -0x1c) = 0;\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == 0xfffffffe) {\n        puVar1 = fcn.1000be76();\n        *puVar1 = 0;\n        puVar1 = fcn.1000beaa();\n        *puVar1 = 9;\n    }\n    else {\n        if ((arg_8h_00 < 0) || (*0x10028c1c <= arg_8h_00)) {\n            puVar1 = fcn.1000be76();\n            *puVar1 = 0;\n        }\n        else {\n            iVar3 = (arg_8h_00 & 0x1f) * 0x40;\n            if ((*(*((arg_8h_00 >> 5) * 4 + 0x100288c0) + 4 + iVar3) & 1) != 0) {\n                fcn.1001846c(arg_8h_00);\n                *(unaff_EBP + -4) = 0;\n                if ((*(*((arg_8h_00 >> 5) * 4 + 0x100288c0) + 4 + iVar3) & 1) == 0) {\n                    puVar1 = fcn.1000beaa();\n                    *puVar1 = 9;\n                    puVar1 = fcn.1000be76();\n                    *puVar1 = 0;\n                    uVar2 = 0xffffffff;\n                }\n                else {\n                    uVar2 = fcn.10013624(arg_8h_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                }\n                *(unaff_EBP + -0x1c) = uVar2;\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.100135fc();\n                goto code_r0x1001361e;\n            }\n            puVar1 = fcn.1000be76();\n            *puVar1 = 0;\n        }\n        puVar1 = fcn.1000beaa();\n        *puVar1 = 9;\n        fcn.1000e79e();\n    }\ncode_r0x1001361e:\n    fcn.1000e3f5();\n    return;\n}\n",
        "token_count": 652
    },
    "1001590f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.1001590f(int32_t arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    code *pcVar5;\n    code *pcVar6;\n    int32_t iVar7;\n    uint arg_8h_00;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    code *var_18h;\n    code *var_14h;\n    uint var_10h;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    pcVar6 = _sym.imp.KERNEL32.dll_EncodePointer;\n    var_4h = *0x100264f0 ^ &stack0xfffffffc;\n    var_1ch = arg_8h;\n    iVar7 = 0;\n    arg_8h_00 = 0;\n    var_20h = arg_ch;\n    pcVar1 = (*_sym.imp.KERNEL32.dll_EncodePointer)();\n    var_18h = pcVar1;\n    var_14h = fcn.1000ba2c();\n    if (*0x10028bc4 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryExW)(0x100225d4, 0, 0x800);\n        if (((iVar2 == 0) &&\n            ((iVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar2 != 0x57 ||\n             (iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryExW)(0x100225d4, 0, 0),  iVar2 == 0)))) ||\n           (iVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"MessageBoxW\"),  iVar3 == 0)) goto code_r0x10015ae4;\n        *0x10028bc4 = (*pcVar6)(iVar3);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"GetActiveWindow\");\n        *0x10028bc8 = (*pcVar6)(uVar4);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"GetLastActivePopup\");\n        *0x10028bcc = (*pcVar6)(uVar4);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"GetUserObjectInformationW\");\n        *0x10028bd4 = (*pcVar6)(uVar4);\n        pcVar1 = var_18h;\n        if (*0x10028bd4 != NULL) {\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"GetProcessWindowStation\");\n            *0x10028bd0 = (*pcVar6)(uVar4);\n            pcVar1 = var_18h;\n        }\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_IsDebuggerPresent)();\n    if (iVar2 == 0) {\n        if (var_14h != NULL) {\n            (*_sym.imp.KERNEL32.dll_DecodePointer)(*0x10028bc4);\n            goto code_r0x10015ae4;\n        }\n    }\n    else {\n        if (var_1ch != 0) {\n            (*_sym.imp.KERNEL32.dll_OutputDebugStringW)(var_1ch);\n        }\n        if (var_14h != NULL) goto code_r0x10015ae4;\n    }\n    pcVar6 = _sym.imp.KERNEL32.dll_DecodePointer;\n    if ((*0x10028bd0 == pcVar1) || (*0x10028bd4 == pcVar1)) {\ncode_r0x10015a9a:\n        if ((((*0x10028bc8 != pcVar1) && (pcVar5 = (*pcVar6)(*0x10028bc8),  pcVar5 != NULL)) &&\n            (iVar7 = (*pcVar5)(),  iVar7 != 0)) &&\n           ((*0x10028bcc != pcVar1 && (pcVar1 = (*pcVar6)(*0x10028bcc),  pcVar1 != NULL)))) {\n            iVar7 = (*pcVar1)(iVar7);\n        }\n    }\n    else {\n        var_14h = (*_sym.imp.KERNEL32.dll_DecodePointer)(*0x10028bd0);\n        var_18h = (*pcVar6)(*0x10028bd4);\n        if (((var_14h == NULL) || (var_18h == NULL)) ||\n           (((iVar2 = (*var_14h)(),  iVar2 != 0 && (iVar2 = (*var_18h)(iVar2, 1, &var_10h, 0xc, &var_24h),  iVar2 != 0))\n            && ((var_8h & 1) != 0)))) goto code_r0x10015a9a;\n        arg_10h = arg_10h | 0x200000;\n    }\n    pcVar6 = (*pcVar6)(*0x10028bc4);\n    if (pcVar6 != NULL) {\n        (*pcVar6)(iVar7, var_1ch, var_20h, arg_10h);\n    }\ncode_r0x10015ae4:\n    fcn.10008362(arg_8h_00);\n    return;\n}\n",
        "token_count": 1209
    },
    "100055e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nbool __cdecl fcn.100055e0(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t var_30h;\n    uint32_t var_2ch;\n    int32_t var_28h;\n    uint32_t var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    int32_t var_14h;\n    uint32_t var_10h;\n    uint var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    iVar2 = *arg_8h;\n    var_4h = *(iVar2 + 0x14) + 0x18 + iVar2;\n    var_30h = *(var_4h + 8);\n    var_2ch = ~(arg_8h[0xc] - 1U) & var_30h;\n    var_10h = var_2ch;\n    var_8h = var_30h;\n    iVar1 = fcn.100058c0(arg_8h, var_4h);\n    var_20h = 0;\n    var_1ch = 1;\n    uVar3 = *(var_4h + 0x24);\n    var_4h = var_4h + 0x28;\n    var_28h = iVar1;\n    var_24h = uVar3;\n    if (1 < *(iVar2 + 6)) {\n        do {\n            var_18h = *(var_4h + 8);\n            uVar4 = ~(arg_8h[0xc] - 1U) & var_18h;\n            var_28h = iVar1;\n            var_24h = uVar3;\n            var_14h = fcn.100058c0(arg_8h, var_4h);\n            if ((var_10h == uVar4) || (uVar4 < iVar1 + var_8h)) {\n                uVar4 = *(var_4h + 0x24);\n                if (((uVar4 & 0x2000000) == 0) || ((uVar3 & 0x2000000) == 0)) {\n                    uVar3 = (uVar3 | uVar4) & 0xfdffffff;\n                }\n                else {\n                    uVar3 = uVar3 | uVar4;\n                }\n                iVar1 = (var_14h - var_8h) + var_18h;\n            }\n            else {\n                iVar2 = fcn.10005530(arg_8h, &var_30h);\n                if (iVar2 == 0) {\n                    return false;\n                }\n                var_8h = var_18h;\n                uVar3 = *(var_4h + 0x24);\n                var_30h = var_18h;\n                iVar1 = var_14h;\n                var_2ch = uVar4;\n                var_10h = uVar4;\n            }\n            var_4h = var_4h + 0x28;\n            var_1ch = var_1ch + 1;\n            var_28h = iVar1;\n            var_24h = uVar3;\n        } while (var_1ch < *(*arg_8h + 6));\n    }\n    var_20h = 1;\n    iVar2 = fcn.10005530(arg_8h, &var_30h);\n    return iVar2 != 0;\n}\n",
        "token_count": 798
    },
    "10005d60": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.10005d60(int32_t *arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t *piVar2;\n    \n    if (arg_10h != 0) {\n        piVar2 = arg_8h;\n        for (uVar1 = arg_10h >> 2; uVar1 != 0; uVar1 = uVar1 - 1) {\n            *piVar2 = arg_ch * 0x1010101;\n            piVar2 = piVar2 + 1;\n        }\n        for (arg_10h = arg_10h & 3; arg_10h != 0; arg_10h = arg_10h - 1) {\n            *piVar2 = arg_ch * 0x1010101;\n            piVar2 = piVar2 + 1;\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 218
    },
    "100014a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.100014a0(uint *arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint *puVar1;\n    uint var_4h;\n    \n    puVar1 = fcn.100022d0(arg_10h, 0, 0xffffffff);\n    arg_8h[5] = 0xf;\n    arg_8h[4] = 0;\n    *arg_8h = 0;\n    if (puVar1[5] < 0x10) {\n        if (puVar1[4] + 1 != 0) {\n            fcn.10007ab0(arg_8h, puVar1, puVar1[4] + 1);\n        }\n    }\n    else {\n        *arg_8h = *puVar1;\n        *puVar1 = 0;\n    }\n    arg_8h[4] = puVar1[4];\n    arg_8h[5] = puVar1[5];\n    puVar1[5] = 0xf;\n    puVar1[4] = 0;\n    *puVar1 = 0;\n    return arg_8h;\n}\n",
        "token_count": 264
    },
    "10001520": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.10001520(uint *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    uint32_t arg_8h_00;\n    uint *puVar3;\n    int32_t *in_FS_OFFSET;\n    uint var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x1001bc99;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    arg_8h[5] = 0xf;\n    arg_8h[4] = 0;\n    *arg_8h = 0;\n    uVar1 = arg_8h[4];\n    var_4h = 0;\n    arg_8h_00 = *(arg_ch + 0x10) + *(arg_10h + 0x10);\n    if (((uVar1 <= arg_8h_00) && (arg_8h[5] != arg_8h_00)) && (cVar2 = fcn.10001f70(arg_8h_00, 1),  cVar2 != '\\0')) {\n        arg_8h[4] = uVar1;\n        puVar3 = arg_8h;\n        if (0xf < arg_8h[5]) {\n            puVar3 = *arg_8h;\n        }\n        *(puVar3 + uVar1) = 0;\n    }\n    fcn.100022d0(arg_ch, 0, 0xffffffff);\n    fcn.100022d0(arg_10h, 0, 0xffffffff);\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 403
    },
    "10001700": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.10001700(char *arg_8h)\n\n{\n    char *arg_ch;\n    int32_t in_ECX;\n    int32_t *in_FS_OFFSET;\n    code *var_1ch;\n    uint var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x1001bd3a;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.10005e24(0);\n    *(in_ECX + 4) = 0;\n    *(in_ECX + 8) = 0;\n    *(in_ECX + 0xc) = 0;\n    *(in_ECX + 0x10) = 0;\n    *(in_ECX + 0x14) = 0;\n    *(in_ECX + 0x18) = 0;\n    *(in_ECX + 0x1c) = 0;\n    *(in_ECX + 0x20) = 0;\n    *(in_ECX + 0x24) = 0;\n    *(in_ECX + 0x28) = 0;\n    *(in_ECX + 0x2c) = 0;\n    *(in_ECX + 0x30) = 0;\n    var_4h = 6;\n    arg_ch = arg_8h;\n    if (arg_8h == NULL) {\n        arg_8h = \"bad locale name\";\n        fcn.10008230(&arg_8h);\n        var_1ch = vtable.std::runtime_error.0;\n        arg_ch = fcn.10008371(&var_1ch, 0x1002490c);\n    }\n    fcn.10006471(in_ECX, arg_ch);\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 429
    },
    "100017c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.100017c0(code *arg_8h, code *arg_ch, uint arg_10h)\n\n{\n    code **in_ECX;\n    int32_t *in_FS_OFFSET;\n    uint noname_4;\n    uint noname_5;\n    uint32_t in_stack_ffffffb0;\n    uint32_t noname_6;\n    uint in_stack_ffffffb4;\n    uint in_stack_ffffffb8;\n    uint arg_8h_00;\n    uint *var_2ch;\n    uint var_28h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x1001bd68;\n    var_ch = *in_FS_OFFSET;\n    var_10h = *0x100264f0 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    noname_5 = 0xffffffff;\n    noname_4 = 0;\n    arg_8h_00 = 0;\n    noname_6 = in_stack_ffffffb0 & 0xffffff00;\n    fcn.10002480(arg_10h, 0, 0xffffffff);\n    var_2ch = fcn.10002040(&var_28h, arg_8h, arg_ch, arg_10h, noname_4, noname_5, noname_6, in_stack_ffffffb4, \n                           in_stack_ffffffb8);\n    var_4h = 0;\n    if (0xf < var_2ch[5]) {\n        var_2ch = *var_2ch;\n    }\n    fcn.10008230(&var_2ch);\n    *in_ECX = vtable.std::runtime_error.0;\n    if (0xf < var_14h) {\n        fcn.100077ed(var_28h);\n    }\n    in_ECX[3] = arg_8h;\n    *in_ECX = vtable.std::_System_error.0;\n    in_ECX[4] = arg_ch;\n    *in_FS_OFFSET = var_ch;\n    fcn.10008362(arg_8h_00);\n    return;\n}\n",
        "token_count": 509
    },
    "10001ca0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "allocate memory",
            "allocate RWX memory",
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.10001ca0(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0, arg_ch, 0x3000, 0x40, 0);\n    iVar2 = sub.KERNEL32.dll_VirtualAllocExNuma(uVar1);\n    if (iVar2 != 0) {\n        *0x1002607c = 0;\n    }\n    fcn.100087c0(iVar2, arg_8h, arg_ch);\n    return iVar2;\n}\n",
        "token_count": 143
    },
    "100022d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.100022d0(uint *arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    code *pcVar1;\n    char cVar2;\n    uint32_t uVar3;\n    int32_t **in_ECX;\n    int32_t **ppiVar4;\n    int32_t *piVar5;\n    \n    if (arg_8h[4] < arg_ch) {\n        fcn.10005fc2(\"invalid string position\");\n    }\n    else {\n        uVar3 = arg_8h[4] - arg_ch;\n        piVar5 = in_ECX[4];\n        if (uVar3 < arg_10h) {\n            arg_10h = uVar3;\n        }\n        if (arg_10h < -piVar5 - 1U) {\n            if ((arg_10h != 0) && (cVar2 = fcn.10001f70(piVar5 + arg_10h, 0),  cVar2 != '\\0')) {\n                if (0xf < arg_8h[5]) {\n                    arg_8h = *arg_8h;\n                }\n                ppiVar4 = in_ECX;\n                if (0xf < in_ECX[5]) {\n                    ppiVar4 = *in_ECX;\n                }\n                if (arg_10h != 0) {\n                    fcn.100087c0(in_ECX[4] + ppiVar4, arg_ch + arg_8h, arg_10h);\n                }\n                piVar5 = piVar5 + arg_10h;\n                in_ECX[4] = piVar5;\n                if (0xf < in_ECX[5]) {\n                    *(*in_ECX + piVar5) = 0;\n                    return;\n                }\n                *(in_ECX + piVar5) = 0;\n            }\n            return;\n        }\n    }\n    fcn.10005f94(\"string too long\");\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 455
    },
    "10002390": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.10002390(int32_t **arg_8h, uint32_t arg_ch)\n\n{\n    code *pcVar1;\n    char cVar2;\n    int32_t **ppiVar3;\n    int32_t **in_ECX;\n    int32_t *piVar4;\n    \n    if (arg_8h != NULL) {\n        piVar4 = in_ECX[5];\n        ppiVar3 = in_ECX;\n        if (0xf < piVar4) {\n            ppiVar3 = *in_ECX;\n        }\n        if (ppiVar3 <= arg_8h) {\n            ppiVar3 = in_ECX;\n            if (0xf < piVar4) {\n                ppiVar3 = *in_ECX;\n            }\n            if (arg_8h < in_ECX[4] + ppiVar3) {\n                if (piVar4 < 0x10) {\n                    fcn.100022d0(in_ECX, arg_8h - in_ECX, arg_ch);\n                    return;\n                }\n                fcn.100022d0(in_ECX, arg_8h - *in_ECX, arg_ch);\n                return;\n            }\n        }\n    }\n    piVar4 = in_ECX[4];\n    if (-piVar4 - 1U <= arg_ch) {\n        fcn.10005f94(\"string too long\");\n        pcVar1 = swi(3);\n        (*pcVar1)();\n        return;\n    }\n    if ((arg_ch != 0) && (cVar2 = fcn.10001f70(piVar4 + arg_ch, 0),  cVar2 != '\\0')) {\n        ppiVar3 = in_ECX;\n        if (0xf < in_ECX[5]) {\n            ppiVar3 = *in_ECX;\n        }\n        if (arg_ch != 0) {\n            fcn.100087c0(in_ECX[4] + ppiVar3, arg_8h, arg_ch);\n        }\n        piVar4 = piVar4 + arg_ch;\n        in_ECX[4] = piVar4;\n        if (0xf < in_ECX[5]) {\n            *(*in_ECX + piVar4) = 0;\n            return;\n        }\n        *(in_ECX + piVar4) = 0;\n    }\n    return;\n}\n",
        "token_count": 520
    },
    "10002480": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.10002480(int32_t **arg_8h, int32_t *arg_ch, int32_t *arg_10h)\n\n{\n    code *pcVar1;\n    int32_t **in_ECX;\n    int32_t **ppiVar2;\n    int32_t *piVar3;\n    \n    if (arg_8h[4] < arg_ch) {\n        fcn.10005fc2(\"invalid string position\");\n    }\n    else {\n        piVar3 = arg_8h[4] - arg_ch;\n        if (arg_10h < piVar3) {\n            piVar3 = arg_10h;\n        }\n        if (in_ECX != arg_8h) {\n            if (piVar3 != 0xffffffff) {\n                if (in_ECX[5] < piVar3) {\n                    fcn.10001cf0(piVar3, in_ECX[4]);\n                    if (piVar3 == NULL) {\n                        return;\n                    }\n                }\n                else if (piVar3 == NULL) {\n                    in_ECX[4] = NULL;\n                    if (0xf < in_ECX[5]) {\n                        **in_ECX = 0;\n                        return;\n                    }\n                    *in_ECX = 0;\n                    return;\n                }\n                if (0xf < arg_8h[5]) {\n                    arg_8h = *arg_8h;\n                }\n                ppiVar2 = in_ECX;\n                if (0xf < in_ECX[5]) {\n                    ppiVar2 = *in_ECX;\n                }\n                if (piVar3 != NULL) {\n                    fcn.100087c0(ppiVar2, arg_8h + arg_ch, piVar3);\n                }\n                in_ECX[4] = piVar3;\n                if (in_ECX[5] < 0x10) {\n                    *(in_ECX + piVar3) = 0;\n                    return;\n                }\n                *(*in_ECX + piVar3) = 0;\n                return;\n            }\n            goto code_r0x10002596;\n        }\n        piVar3 = piVar3 + arg_ch;\n        if (piVar3 <= in_ECX[4]) {\n            in_ECX[4] = piVar3;\n            if (0xf < in_ECX[5]) {\n                *(*in_ECX + piVar3) = 0;\n                fcn.10002960(0, arg_ch);\n                return;\n            }\n            *(in_ECX + piVar3) = 0;\n            fcn.10002960(0, arg_ch);\n            return;\n        }\n    }\n    fcn.10005fc2(\"invalid string position\");\ncode_r0x10002596:\n    fcn.10005f94(\"string too long\");\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 631
    },
    "100025b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.100025b0(int32_t **arg_8h, int32_t *arg_ch)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t **ppiVar3;\n    int32_t **in_ECX;\n    \n    if (arg_8h != NULL) {\n        piVar1 = in_ECX[5];\n        ppiVar3 = in_ECX;\n        if (0xf < piVar1) {\n            ppiVar3 = *in_ECX;\n        }\n        if (ppiVar3 <= arg_8h) {\n            ppiVar3 = in_ECX;\n            if (0xf < piVar1) {\n                ppiVar3 = *in_ECX;\n            }\n            if (arg_8h < in_ECX[4] + ppiVar3) {\n                if (0xf < piVar1) {\n                    fcn.10002480(in_ECX, arg_8h - *in_ECX, arg_ch);\n                    return;\n                }\n                fcn.10002480(in_ECX, arg_8h - in_ECX, arg_ch);\n                return;\n            }\n        }\n    }\n    if (arg_ch == 0xffffffff) {\n        fcn.10005f94(\"string too long\");\n        pcVar2 = swi(3);\n        (*pcVar2)();\n        return;\n    }\n    if (in_ECX[5] < arg_ch) {\n        fcn.10001cf0(arg_ch, in_ECX[4]);\n        if (arg_ch == NULL) {\n            return;\n        }\n    }\n    else if (arg_ch == NULL) {\n        in_ECX[4] = NULL;\n        if (0xf < in_ECX[5]) {\n            **in_ECX = 0;\n            return;\n        }\n        *in_ECX = 0;\n        return;\n    }\n    ppiVar3 = in_ECX;\n    if (0xf < in_ECX[5]) {\n        ppiVar3 = *in_ECX;\n    }\n    if (arg_ch != NULL) {\n        fcn.100087c0(ppiVar3, arg_8h, arg_ch);\n    }\n    in_ECX[4] = arg_ch;\n    if (in_ECX[5] < 0x10) {\n        *(in_ECX + arg_ch) = 0;\n        return;\n    }\n    *(*in_ECX + arg_ch) = 0;\n    return;\n}\n",
        "token_count": 541
    },
    "100026b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.100026b0(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *param_1;\n    if (iVar1 == 0) {\n        return 0x1001d244;\n    }\n    if (*(iVar1 + 0x18) != 0) {\n        return *(iVar1 + 0x18);\n    }\n    return iVar1 + 0x1c;\n}\n",
        "token_count": 102
    },
    "10002760": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.10002760(uint *arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.10006570(arg_ch);\n    *arg_8h = arg_ch;\n    if (iVar1 != 0) {\n        arg_8h[1] = 0x10026080;\n        return;\n    }\n    arg_8h[1] = 0x10026088;\n    return;\n}\n",
        "token_count": 104
    },
    "10002960": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.10002960(int32_t *arg_8h, uint32_t arg_ch)\n\n{\n    code *pcVar1;\n    int32_t **ppiVar2;\n    int32_t **in_ECX;\n    int32_t *piVar3;\n    \n    piVar3 = in_ECX[4];\n    if (piVar3 < arg_8h) {\n        fcn.10005fc2(\"invalid string position\");\n        pcVar1 = swi(3);\n        (*pcVar1)();\n        return;\n    }\n    if (arg_ch < piVar3 - arg_8h) {\n        if (arg_ch != 0) {\n            ppiVar2 = in_ECX;\n            if (0xf < in_ECX[5]) {\n                ppiVar2 = *in_ECX;\n            }\n            piVar3 = piVar3 - arg_ch;\n            if (piVar3 - arg_8h != 0) {\n                fcn.10007ab0(ppiVar2 + arg_8h, ppiVar2 + arg_8h + arg_ch, piVar3 - arg_8h);\n            }\n            in_ECX[4] = piVar3;\n            if (0xf < in_ECX[5]) {\n                *(*in_ECX + piVar3) = 0;\n                return;\n            }\n            *(in_ECX + piVar3) = 0;\n        }\n        return;\n    }\n    in_ECX[4] = arg_8h;\n    if (in_ECX[5] < 0x10) {\n        *(in_ECX + arg_8h) = 0;\n        return;\n    }\n    *(*in_ECX + arg_8h) = 0;\n    return;\n}\n",
        "token_count": 383
    },
    "10002d20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.10002d20(int32_t arg_8h, int32_t arg_ch, ushort *arg_10h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint var_4h;\n    \n    *0x10027ad0 = fcn.10008167(0x1eb);\n    iVar1 = 0;\n    do {\n        *(*0x10027ad0 + iVar1) = iVar1;\n        iVar1 = iVar1 + 1;\n    } while (iVar1 < 0x1eb);\n    uVar2 = 0;\n    *arg_10h = 0;\n    arg_10h = NULL;\n    uVar3 = 0;\n    do {\n        uVar3 = (*(*0x10027ad0 + arg_10h) + *(uVar2 + arg_8h) + uVar3) % 0x1eb & 0xff;\n        fcn.10003170(*0x10027ad0 + arg_10h, uVar3 + *0x10027ad0);\n        arg_10h = arg_10h + 1;\n        uVar2 = (uVar2 + 1) % arg_ch & 0xff;\n    } while (arg_10h < 0x1eb);\n    return;\n}\n",
        "token_count": 303
    },
    "10002ff0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.10002ff0(int32_t arg_8h, int32_t arg_ch, uint8_t *arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint arg_8h_00;\n    int32_t *piVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    int32_t *in_FS_OFFSET;\n    uint8_t *puVar6;\n    uint var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    uint32_t var_14h;\n    uint8_t var_fh;\n    uint8_t var_eh;\n    uint8_t var_dh;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x1001bea8;\n    var_ch = *in_FS_OFFSET;\n    uVar1 = *0x100264f0 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    if (0 < arg_ch) {\n        var_14h = arg_10h[1];\n        var_18h = *arg_10h;\n        var_1ch = 0x1eb;\n        iVar5 = 0;\n        do {\n            var_18h = (var_18h + 1) % 0x1eb;\n            var_eh = var_18h;\n            var_18h = var_18h & 0xff;\n            puVar6 = var_18h + *0x10027ad0;\n            var_14h = (*puVar6 + var_14h) % var_1ch;\n            var_fh = var_14h;\n            var_14h = var_14h & 0xff;\n            iVar2 = var_14h + *0x10027ad0;\n            fcn.10003170(puVar6, iVar2);\n            var_dh = (*(var_14h + *0x10027ad0) + *(var_18h + *0x10027ad0)) % 0x1eb;\n            fcn.10001150(0x10027c08, 0x1001d244, puVar6, iVar2, uVar1);\n            arg_8h_00 = fcn.10002b60(&var_20h);\n            var_4h = 0;\n            piVar3 = fcn.100015e0(arg_8h_00);\n            var_4h = 0xffffffff;\n            if (var_20h != NULL) {\n                puVar4 = (**(*var_20h + 8))();\n                if (puVar4 != NULL) {\n                    (***puVar4)(1);\n                }\n            }\n            uVar1 = (**(*piVar3 + 0x20))(10);\n            uVar1 = uVar1 & 0xff;\n            fcn.10002dd0();\n            fcn.10002a00();\n            iVar2 = iVar5 + 1;\n            puVar6 = (iVar5 - *0x1002607c) + arg_8h;\n            *puVar6 = *puVar6 ^ *(var_dh + *0x10027ad0);\n            iVar5 = iVar2;\n        } while (iVar2 < arg_ch);\n        *arg_10h = var_eh;\n        arg_10h[1] = var_fh;\n        *in_FS_OFFSET = var_ch;\n        return;\n    }\n    *arg_10h = *arg_10h;\n    arg_10h[1] = arg_10h[1];\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 835
    },
    "10003190": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.10003190(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uint arg_8h_00;\n    int32_t *piVar2;\n    uint *puVar3;\n    int32_t *in_FS_OFFSET;\n    int32_t *var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x1001bed8;\n    var_ch = *in_FS_OFFSET;\n    uVar1 = *0x100264f0 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    puVar3 = &var_10h;\n    arg_8h_00 = fcn.10002b60(puVar3);\n    var_4h = 0;\n    piVar2 = fcn.100015e0(arg_8h_00);\n    var_4h = 0xffffffff;\n    if (var_10h != NULL) {\n        puVar3 = (**(*var_10h + 8))(puVar3, uVar1);\n        if (puVar3 != NULL) {\n            (***puVar3)(1);\n        }\n    }\n    (**(*piVar2 + 0x20))(arg_8h);\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 307
    },
    "100053f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.100053f0(int32_t arg_8h, uint arg_ch, int32_t arg_10h, int32_t *arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar3 = *arg_14h;\n    iVar1 = arg_14h[1];\n    var_4h = 0;\n    if (*(iVar3 + 6) != 0) {\n        piVar4 = iVar3 + 0x28 + *(iVar3 + 0x14);\n        do {\n            if (*piVar4 == 0) {\n                iVar3 = *(arg_10h + 0x38);\n                if (0 < iVar3) {\n                    iVar2 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(piVar4[-1] + iVar1, iVar3, 0x1000, 4);\n                    if (iVar2 == 0) {\n                        return 0;\n                    }\n                    piVar4[-2] = piVar4[-1] + iVar1;\n                    fcn.10005d60(piVar4[-1] + iVar1, 0, iVar3);\n                }\n            }\n            else {\n                iVar3 = fcn.100053c0(arg_ch, piVar4[1] + *piVar4);\n                if ((iVar3 == 0) ||\n                   (iVar3 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(piVar4[-1] + iVar1, *piVar4, 0x1000, 4),  iVar3 == 0))\n                {\n                    return 0;\n                }\n                iVar3 = piVar4[-1];\n                fcn.10005d90(iVar3 + iVar1, piVar4[1] + arg_8h, *piVar4);\n                piVar4[-2] = iVar3 + iVar1;\n            }\n            piVar4 = piVar4 + 10;\n            var_4h = var_4h + 1;\n        } while (var_4h < *(*arg_14h + 6));\n    }\n    return 1;\n}\n",
        "token_count": 499
    },
    "10005c10": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.10005c10(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t arg_10h;\n    uint32_t arg_8h_00;\n    \n    arg_10h = arg_8h;\n    if ((arg_8h != 0) && (arg_10h = fcn.100057c0(arg_8h),  arg_ch <= arg_10h)) {\n        return arg_8h;\n    }\n    arg_8h_00 = fcn.10005930(arg_ch);\n    if ((arg_8h != 0) && (arg_8h_00 != 0)) {\n        fcn.10005d90(arg_8h_00, arg_8h, arg_10h);\n        fcn.10005950(arg_8h);\n    }\n    return arg_8h_00;\n}\n",
        "token_count": 199
    },
    "10008112": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.10008112(uint arg_8h)\n\n{\n    fcn.1000ebc2(arg_8h, 0, 10);\n    return;\n}\n",
        "token_count": 41
    },
    "10010fdf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.10010fdf(void)\n\n{\n    code **ppcVar1;\n    \n    for (ppcVar1 = 0x1002452c; ppcVar1 < 0x1002452c; ppcVar1 = ppcVar1 + 1) {\n        if (*ppcVar1 != NULL) {\n            (**ppcVar1)();\n        }\n    }\n    return;\n}\n",
        "token_count": 89
    },
    "10014da7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nfloat10 __cdecl fcn.10014da7(uint arg_8h, uint noname_1, uint arg_10h, uint arg_14h)\n\n{\n    float10 in_ST0;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    \n    fcn.10018fb9();\n    return in_ST0;\n}\n",
        "token_count": 89
    },
    "1001b4be": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.1001b4be(uint arg_8h)\n\n{\n    fcn.100192a3(arg_8h, 0, 10);\n    return;\n}\n",
        "token_count": 42
    },
    "1000878a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.1000878a(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = fcn.10009f9f(arg_8h, arg_ch, arg_10h, arg_14h, in_EAX, 0, 0, 0);\n    return uVar1;\n}\n",
        "token_count": 112
    },
    "10005e7f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.10005e7f(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *param_1;\n    if (iVar1 == 0) {\n        fcn.100092f8(0xc);\n        return;\n    }\n    if (iVar1 < 4) {\n        fcn.10007620(iVar1 * 0x18 + 0x10027b10);\n    }\n    return;\n}\n",
        "token_count": 105
    },
    "10005dc0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.10005dc0(uint8_t *arg_8h, uint8_t *arg_ch)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    \n    uVar2 = *arg_8h;\n    while ((uVar2 != 0 && (uVar2 == *arg_ch))) {\n        puVar1 = arg_8h + 1;\n        arg_8h = arg_8h + 1;\n        arg_ch = arg_ch + 1;\n        uVar2 = *puVar1;\n    }\n    return (*arg_ch < *arg_8h) - (*arg_8h < *arg_ch);\n}\n",
        "token_count": 152
    },
    "10005930": {
        "rules": [
            "allocate memory",
            "allocate RW memory"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.10005930(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, arg_8h, 0x3000, 4);\n    return;\n}\n",
        "token_count": 50
    },
    "1000bcf7": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.1000bcf7(uint dwMilliseconds)\n\n{\n    (*_sym.imp.KERNEL32.dll_Sleep)(dwMilliseconds);\n    return;\n}\n",
        "token_count": 36
    },
    "100192d2": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid fcn.100192d2(void)\n\n{\n    *0x10027368 = (*_sym.imp.KERNEL32.dll_CreateFileW)(L\"CONOUT$\", 0x40000000, 3, 0, 3, 0, 0);\n    return;\n}\n",
        "token_count": 63
    },
    "100054e0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.100054e0(int32_t *arg_8h)\n\n{\n    code **ppcVar1;\n    int32_t iVar2;\n    code **ppcVar3;\n    code *pcVar4;\n    \n    iVar2 = arg_8h[1];\n    if ((*(*arg_8h + 0xc0) != 0) && (ppcVar3 = *(*(*arg_8h + 0xc0) + 0xc + iVar2),  ppcVar3 != NULL)) {\n        pcVar4 = *ppcVar3;\n        while (pcVar4 != NULL) {\n            (*pcVar4)(iVar2, 1, 0);\n            ppcVar1 = ppcVar3 + 1;\n            ppcVar3 = ppcVar3 + 1;\n            pcVar4 = *ppcVar1;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 202
    },
    "10005d90": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.10005d90(uchar *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uchar *puVar1;\n    \n    if (arg_10h != 0) {\n        puVar1 = arg_8h;\n        do {\n            *puVar1 = puVar1[arg_ch - arg_8h];\n            arg_10h = arg_10h + -1;\n            puVar1 = puVar1 + 1;\n        } while (arg_10h != 0);\n    }\n    return;\n}\n",
        "token_count": 128
    },
    "1000fbcc": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.1000fbcc(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *arg_8h_00;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.1000e3b0(0x10025010, 0xc);\n    fcn.1000918e(0xe);\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = *0x100288b8;\n    iVar1 = *(unaff_EBP + 8);\n    iVar2 = *(iVar1 + 4);\n    if (iVar2 != 0) {\n        piVar3 = 0x100288b4;\n        do {\n            piVar4 = piVar3;\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 == NULL) goto code_r0x1000fc11;\n            piVar3 = arg_8h_00;\n        } while (*arg_8h_00 != iVar2);\n        piVar4[1] = arg_8h_00[1];\n        fcn.1000812f(arg_8h_00);\ncode_r0x1000fc11:\n        fcn.1000812f(*(iVar1 + 4));\n        *(iVar1 + 4) = 0;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.1000fc34();\n    fcn.1000e3f5();\n    return;\n}\n",
        "token_count": 403
    },
    "1000b9bd": {
        "rules": [
            "get thread local storage value"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.1000b9bd(uint arg_8h)\n\n{\n    if ((*0x10028c48 ^ *0x100264f0) != NULL) {\n        (*(*0x10028c48 ^ *0x100264f0))();\n        return;\n    }\n    (*_sym.imp.KERNEL32.dll_TlsGetValue)(arg_8h);\n    return;\n}\n",
        "token_count": 87
    }
}