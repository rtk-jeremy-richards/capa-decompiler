{
    "00409c50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00409c50(uint *param_1)\n\n{\n    *param_1 = 0x4017d8;\n    if (param_1[2] != 0) {\n        fcn.0040a51a(param_1[1]);\n    }\n    return;\n}\n",
        "token_count": 67
    },
    "null": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint main(void)\n\n{\n    int32_t iVar1;\n    uint var_a0h;\n    uint var_98h;\n    uint var_18h;\n    \n    if (*0x9689b0 == 3) {\n        fcn.0040ada9(0x80ede8, 0);\n        fcn.004081fd();\n        fcn.00409157(3, 1);\n        fcn.00409052(0x401528);\n        fcn.0040ac0c();\n        fcn.0040ab74(0);\n    }\n    *0x9689b0 = *0x4245a4;\n    iVar1 = 0;\n    do {\n        if (iVar1 == 0x1737) {\n            *0x9689b4 = *0x423008;\n        }\n        iVar1 = iVar1 + 1;\n    } while (iVar1 < 0x79a863);\n    fcn.004056a5();\n    return 0;\n}\n",
        "token_count": 220
    },
    "00405c50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t * __cdecl fcn.00405c50(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    char cVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040a424();\n    *(unaff_EBP + -0x10) = 0;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    if (*(unaff_EBP + 0x10) != 0) {\n        *extraout_ECX = 0x40175c;\n        fcn.00405b00();\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x10) = 1;\n    }\n    cVar1 = *(unaff_EBP + 0xc);\n    *(extraout_ECX + *(*extraout_ECX + 4)) = 0x401554;\n    if (cVar1 != '\\0') {\n        fcn.004097c5(*(*extraout_ECX + 4) + extraout_ECX);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 319
    },
    "00405d5a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00405d5a(uint32_t arg_8h)\n\n{\n    uint32_t in_EAX;\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if ((arg_8h != 0) && (in_EAX = fcn.00405c42(),  in_EAX <= arg_8h)) {\n        iVar1 = fcn.00405c42();\n        in_EAX = iVar1 + *(in_ECX + 0x14);\n        if (arg_8h < in_EAX) {\n            return CONCAT31(in_EAX >> 8, 1);\n        }\n    }\n    return in_EAX & 0xffffff00;\n}\n",
        "token_count": 156
    },
    "00405dce": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405dce(uint32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint var_ch;\n    \n    if (arg_8h == 0) {\n        arg_8h = 0;\n    }\n    else if (0xffffffff / arg_8h == 0) {\n        fcn.00404ea0(0);\n        fcn.0040a4c3(&var_ch, 0x421474);\n        pcVar1 = swi(3);\n        (*pcVar1)();\n        return;\n    }\n    fcn.0040a45e(arg_8h);\n    return;\n}\n",
        "token_count": 142
    },
    "004063d9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004063d9(uint arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint arg_ch_00;\n    uint arg_8h_00;\n    int32_t in_ECX;\n    \n    iVar1 = fcn.00405b2b();\n    if ((iVar1 != 0) && (uVar2 = fcn.00405b2b(),  *(in_ECX + 0x3c) < uVar2)) {\n        uVar3 = fcn.00405b2b();\n        *(in_ECX + 0x3c) = uVar3;\n    }\n    if (((arg_14h & 1) == 0) || (iVar4 = fcn.00405b25(),  iVar1 = *0x40179c,  iVar4 == 0)) {\n        iVar1 = *0x40179c;\n        if (((arg_14h & 2) != 0) && (iVar4 = fcn.00405b2b(),  iVar1 = *0x40179c,  iVar4 != 0)) {\n            if (arg_10h == 2) {\n                iVar4 = fcn.00405b1f();\n                arg_ch = arg_ch + (*(in_ECX + 0x3c) - iVar4);\n            }\n            else if (arg_10h == 1) {\n                iVar4 = fcn.00405b2b();\n                iVar5 = fcn.00405b1f();\n                arg_ch = arg_ch + (iVar4 - iVar5);\n            }\n            else if (arg_10h != 0) {\n                arg_ch = *0x40179c;\n            }\n            if ((-1 < arg_ch) && (iVar4 = fcn.00405b1f(),  arg_ch <= *(in_ECX + 0x3c) - iVar4)) {\n                iVar1 = fcn.00405b2b();\n                iVar4 = fcn.00405b1f();\n                fcn.00406165((arg_ch - iVar1) + iVar4);\n                iVar1 = arg_ch;\n            }\n        }\n        goto code_r0x00406571;\n    }\n    if (arg_10h == 2) {\n        iVar4 = fcn.00405b1f();\n        arg_ch = arg_ch + (*(in_ECX + 0x3c) - iVar4);\n    }\n    else if (arg_10h == 1) {\n        if ((arg_14h & 2) == 0) {\n            iVar4 = fcn.00405b25();\n            iVar5 = fcn.00405b1f();\n            arg_ch = arg_ch + (iVar4 - iVar5);\n        }\n        else {\ncode_r0x0040645f:\n            arg_ch = *0x40179c;\n        }\n    }\n    else if (arg_10h != 0) goto code_r0x0040645f;\n    if ((-1 < arg_ch) && (iVar4 = fcn.00405b1f(),  arg_ch <= *(in_ECX + 0x3c) - iVar4)) {\n        iVar1 = fcn.00405b25();\n        iVar4 = fcn.00405b1f();\n        fcn.00406132((arg_ch - iVar1) + iVar4);\n        iVar1 = arg_ch;\n        if (((arg_14h & 2) != 0) && (iVar4 = fcn.00405b2b(),  iVar4 != 0)) {\n            uVar3 = fcn.00405b5d();\n            arg_ch_00 = fcn.00405b25();\n            arg_8h_00 = fcn.0040625d();\n            fcn.00405b86(arg_8h_00, arg_ch_00, uVar3);\n        }\n    }\ncode_r0x00406571:\n    fcn.00406188(iVar1);\n    return arg_8h;\n}\n",
        "token_count": 931
    },
    "004067ed": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nint32_t fcn.004067ed(void)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = fcn.00406102();\n    if (uVar1 < 2) {\n        return 1;\n    }\n    return uVar1 - 1;\n}\n",
        "token_count": 62
    },
    "00406a0c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406a0c(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint *arg_ch_00;\n    uint arg_10h_00;\n    \n    if (arg_ch == 1) {\n        arg_ch_00 = &arg_10h;\n        iVar1 = fcn.00405c42();\n        fcn.00404eee(iVar1 + arg_8h, arg_ch_00);\n    }\n    else {\n        arg_10h_00 = arg_10h;\n        iVar1 = fcn.00405c42();\n        fcn.0040687b(iVar1 + arg_8h, arg_ch, arg_10h_00);\n    }\n    return;\n}\n",
        "token_count": 176
    },
    "00406db9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00406db9(uint32_t arg_8h)\n\n{\n    char cVar1;\n    uchar uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint arg_10h;\n    uint arg_8h_00;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    uchar *puVar10;\n    int32_t in_ECX;\n    bool bVar11;\n    int32_t in_stack_ffffffc0;\n    int32_t arg_10h_00;\n    uint32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    if (((*(in_ECX + 0x40) & 8) != 0) && (iVar3 = fcn.00405b2b(),  iVar3 != 0)) {\n        uVar5 = *(in_ECX + 0x3c);\n        uVar4 = fcn.00405b2b();\n        if (uVar4 < uVar5) {\n            arg_10h = fcn.00405b5d();\n            arg_8h_00 = fcn.0040625d();\n            fcn.00405b86(arg_8h_00, uVar5, arg_10h);\n        }\n    }\n    uVar5 = fcn.00406102();\n    var_ch = uVar5;\n    cVar1 = fcn.004060ee(&fcn.00406db9::var_ch, &fcn.00406db9::arg_8h);\n    if (cVar1 != '\\0') {\n        uVar5 = fcn.00406241(&fcn.00406db9::arg_8h);\n        return uVar5;\n    }\n    iVar3 = fcn.00405b2b();\n    if (iVar3 != 0) {\n        uVar4 = fcn.00405b5d();\n        uVar6 = fcn.00405b2b();\n        if (uVar6 < uVar4) goto code_r0x00406f6a;\n    }\n    if ((*(in_ECX + 0x40) & 2) != 0) {\n        return uVar5;\n    }\n    iVar3 = fcn.00405b2b();\n    if (iVar3 == 0) {\n        var_4h = 0;\n    }\n    else {\n        iVar3 = fcn.00405b5d();\n        iVar9 = fcn.00405b1f();\n        var_4h = iVar3 - iVar9;\n    }\n    uVar5 = var_4h;\n    var_ch = 0x20;\n    if (0x1f < var_4h >> 1) {\n        var_ch = var_4h >> 1;\n    }\n    iVar3 = 0;\n    var_8h = fcn.00405b1f();\n    uVar4 = var_ch;\n    if (var_ch != 0) {\n        do {\n            if (var_4h <= 0x7fffffff - uVar4) break;\n            uVar4 = uVar4 >> 1;\n        } while (uVar4 != 0);\n        if (uVar4 != 0) {\n            uVar5 = uVar4 + var_4h;\n            iVar3 = fcn.0040673c(uVar5);\n        }\n    }\n    bVar11 = var_4h == 0;\n    if (!bVar11) {\n        in_stack_ffffffc0 = 0x406ed8;\n        fcn.0040680e(iVar3, uVar5, var_8h, var_4h);\n        bVar11 = var_4h == 0;\n    }\n    iVar9 = iVar3;\n    if (bVar11) {\n        *(in_ECX + 0x3c) = iVar3;\n        fcn.00405b68(iVar3, iVar3 + uVar5);\n        if ((*(in_ECX + 0x40) & 4) != 0) {\ncode_r0x00406ef5:\n            in_stack_ffffffc0 = 0;\n        }\n    }\n    else {\n        *(in_ECX + 0x3c) = *(in_ECX + 0x3c) + (iVar3 - var_8h);\n        var_ch = iVar3 - var_8h;\n        arg_10h_00 = iVar3 + uVar5;\n        iVar7 = fcn.00405b2b();\n        iVar7 = iVar7 + var_ch;\n        iVar8 = fcn.0040625d();\n        fcn.00405b86(iVar8 + var_ch, iVar7, arg_10h_00);\n        if ((*(in_ECX + 0x40) & 4) != 0) goto code_r0x00406ef5;\n        iVar9 = fcn.00405b2b();\n        iVar9 = iVar9 + 1;\n        in_stack_ffffffc0 = fcn.00405b25();\n        in_stack_ffffffc0 = in_stack_ffffffc0 + var_ch;\n    }\n    fcn.00405b3c(iVar3, in_stack_ffffffc0, iVar9);\n    if ((*(in_ECX + 0x40) & 1) != 0) {\n        fcn.00405cc2(var_8h);\n    }\n    *(in_ECX + 0x40) = *(in_ECX + 0x40) | 1;\ncode_r0x00406f6a:\n    puVar10 = fcn.00406263();\n    uVar2 = fcn.004060d9(&fcn.00406db9::arg_8h);\n    *puVar10 = uVar2;\n    return arg_8h;\n}\n",
        "token_count": 1313
    },
    "00406f8e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406f8e(uint arg_8h, int32_t arg_ch)\n\n{\n    uint arg_10h;\n    int32_t in_ECX;\n    \n    if ((arg_8h != '\\0') && (0xf < *(in_ECX + 0x18))) {\n        arg_10h = *(in_ECX + 4);\n        if (arg_ch != 0) {\n            fcn.0040680e(in_ECX + 4, 0x10, arg_10h, arg_ch);\n        }\n        fcn.00405cc2(arg_10h);\n    }\n    *(in_ECX + 0x18) = 0xf;\n    fcn.0040675a(arg_ch);\n    return;\n}\n",
        "token_count": 168
    },
    "004070f0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004070f0(uint noname_0, uint *arg_ch, uint arg_10h, uint arg_14h, uint8_t *arg_18h, int32_t arg_1ch)\n\n{\n    if (arg_1ch != 0) {\n        fcn.004069df();\n        do {\n            fcn.00406ac3(*arg_18h);\n            arg_1ch = arg_1ch + -1;\n            arg_18h = arg_18h + 1;\n        } while (arg_1ch != 0);\n    }\n    *arg_ch = arg_10h;\n    arg_ch[1] = arg_14h;\n    return;\n}\n",
        "token_count": 157
    },
    "0040712f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040712f(uint noname_0, uint *arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, int32_t arg_1ch)\n\n{\n    if (arg_1ch != 0) {\n        fcn.004069df();\n        do {\n            fcn.00406ac3(arg_18h);\n            arg_1ch = arg_1ch + -1;\n        } while (arg_1ch != 0);\n    }\n    *arg_ch = arg_10h;\n    arg_ch[1] = arg_14h;\n    return;\n}\n",
        "token_count": 139
    },
    "00407163": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl\nfcn.00407163(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint arg_8h_00;\n    uint arg_10h;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint32_t uVar3;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    uint uVar4;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040a424();\n    *(unaff_EBP + -0x10) = &var_18h;\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    uVar3 = *(unaff_EBP + 8) | 0xf;\n    uVar2 = fcn.004067ed();\n    *(unaff_EBP + -0x1c) = uVar2;\n    if (uVar2 < uVar3) {\n        uVar3 = *(unaff_EBP + 8);\n    }\n    else {\n        uVar2 = *(extraout_ECX + 0x18);\n        *(unaff_EBP + -0x14) = uVar2;\n        *(unaff_EBP + -0x14) = *(unaff_EBP + -0x14) >> 1;\n        uVar1 = *(unaff_EBP + -0x14);\n        if ((uVar3 / 3 < uVar1) && (uVar2 <= *(unaff_EBP + -0x1c) - uVar1)) {\n            uVar3 = uVar1 + uVar2;\n        }\n    }\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = fcn.0040673c(uVar3 + 1);\n    if (*(unaff_EBP + 0xc) != 0) {\n        uVar4 = *(unaff_EBP + 0xc);\n        arg_10h = fcn.00405c42();\n        fcn.0040680e(arg_8h_00, uVar3 + 1, arg_10h, uVar4);\n    }\n    fcn.00406f8e(1, 0);\n    uVar4 = *(unaff_EBP + 0xc);\n    *(extraout_ECX + 4) = arg_8h_00;\n    *(extraout_ECX + 0x18) = uVar3;\n    fcn.0040675a(uVar4);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 698
    },
    "0040724f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040724f(uint arg_8h, uint *arg_ch, uint arg_10h, uint arg_14h, uint8_t *arg_18h, int32_t arg_1ch)\n\n{\n    uint32_t uVar1;\n    \n    if (arg_1ch != 0) {\n        fcn.004069df();\n        do {\n            uVar1 = fcn.00406a46(*arg_18h);\n            fcn.00406ac3(uVar1 & 0xff);\n            arg_1ch = arg_1ch + -1;\n            arg_18h = arg_18h + 1;\n        } while (arg_1ch != 0);\n    }\n    *arg_ch = arg_10h;\n    arg_ch[1] = arg_14h;\n    return;\n}\n",
        "token_count": 186
    },
    "004072a5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint * __cdecl\nfcn.004072a5(uint arg_8h, uint *arg_ch, uint arg_10h, uint arg_14h, int32_t arg_18h, int32_t arg_1ch, uint arg_20h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t arg_1ch_00;\n    uint var_10h;\n    uint var_8h;\n    \n    while( true ) {\n        iVar2 = fcn.0040a7c0(arg_18h, 0, arg_1ch);\n        arg_1ch_00 = arg_1ch;\n        if (iVar2 != 0) {\n            arg_1ch_00 = iVar2 - arg_18h;\n        }\n        puVar3 = fcn.0040724f(arg_8h, &var_8h, arg_10h, arg_14h, arg_18h, arg_1ch_00);\n        arg_10h = *puVar3;\n        arg_14h = puVar3[1];\n        if (arg_1ch - arg_1ch_00 == 0) break;\n        if (arg_20h != '\\0') {\n            puVar3 = fcn.0040712f(arg_8h, &var_10h, *puVar3, puVar3[1], arg_20h, 1);\n            arg_10h = *puVar3;\n            arg_14h = puVar3[1];\n        }\n        arg_18h = arg_18h + arg_1ch_00 + 1;\n        arg_1ch = (arg_1ch - arg_1ch_00) + -1;\n    }\n    uVar1 = *puVar3;\n    arg_ch[1] = puVar3[1];\n    *arg_ch = uVar1;\n    return arg_ch;\n}\n",
        "token_count": 428
    },
    "0040747f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0040747f(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    \n    uVar1 = fcn.004067ed();\n    if (uVar1 < arg_8h) {\n        fcn.00409a02();\n    }\n    if (*(in_ECX + 0x18) < arg_8h) {\n        fcn.00407163(arg_8h, *(in_ECX + 0x14), unaff_EDI, unaff_ESI, unaff_EBP, unaff_retaddr, arg_8h, arg_ch);\n    }\n    else if ((arg_ch == '\\0') || (0xf < arg_8h)) {\n        if (arg_8h == 0) {\n            fcn.0040675a(0);\n        }\n    }\n    else {\n        uVar1 = *(in_ECX + 0x14);\n        if (arg_8h < *(in_ECX + 0x14)) {\n            uVar1 = arg_8h;\n        }\n        fcn.00406f8e(1, uVar1);\n    }\n    return arg_8h != 0;\n}\n",
        "token_count": 302
    },
    "00407a69": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_a0h\n\nuint __cdecl fcn.00407a69(uint arg_8h, uint arg_ch)\n\n{\n    uint8_t uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_a0h;\n    uint var_2ch;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040a424();\n    *(unaff_EBP + -0x10) = 0;\n    piVar2 = *(unaff_EBP + 8);\n    if ((piVar2 != NULL) && (*piVar2 == 0)) {\n        iVar3 = fcn.0040a45e(0x18);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            iVar3 = 0;\n        }\n        else {\n            uVar4 = fcn.00407a4c(unaff_EBP + -0x2c);\n            *(unaff_EBP + -4) = 1;\n            *(unaff_EBP + -0x10) = 1;\n            uVar4 = fcn.00407713(uVar4);\n            *(unaff_EBP + -0x10) = 3;\n            iVar3 = fcn.00405f11(uVar4, 0);\n        }\n        uVar1 = *(unaff_EBP + -0x10);\n        *(unaff_EBP + -4) = 2;\n        *piVar2 = iVar3;\n        if ((uVar1 & 2) != 0) {\n            *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffffd;\n            fcn.0040776f();\n        }\n        if ((*(unaff_EBP + -0x10) & 1) != 0) {\n            fcn.004073e8();\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return 2;\n}\n",
        "token_count": 501
    },
    "00407d15": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_a0h\n\nuint __cdecl fcn.00407d15(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_a0h;\n    uint var_2ch;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040a424();\n    *(unaff_EBP + -0x10) = 0;\n    piVar1 = *(unaff_EBP + 8);\n    if ((piVar1 != NULL) && (*piVar1 == 0)) {\n        iVar2 = fcn.0040a45e(0x10);\n        *(unaff_EBP + 8) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            iVar2 = 0;\n        }\n        else {\n            uVar3 = fcn.00407a4c(unaff_EBP + -0x2c);\n            *(unaff_EBP + -4) = 1;\n            *(unaff_EBP + -0x10) = 1;\n            uVar3 = fcn.00407713(uVar3);\n            *(unaff_EBP + -0x10) = 3;\n            iVar2 = fcn.00406856(uVar3, 0);\n        }\n        *(unaff_EBP + -4) = 2;\n        *piVar1 = iVar2;\n        if ((*(unaff_EBP + -0x10) & 2) != 0) {\n            *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffffd;\n            fcn.0040776f();\n        }\n        if ((*(unaff_EBP + -0x10) & 1) != 0) {\n            fcn.004073e8();\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return 4;\n}\n",
        "token_count": 484
    },
    "00407fdc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407fdc(uint32_t arg_8h, uint arg_ch)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x28) == 0) {\n        arg_8h = arg_8h | 4;\n    }\n    fcn.00407e6f(arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 86
    },
    "004081d9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004081d9(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    \n    if (arg_8h != 0) {\n        uVar1 = fcn.00405163();\n        fcn.00407fdc(uVar1 | arg_8h, arg_ch);\n    }\n    return;\n}\n",
        "token_count": 82
    },
    "004083a6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_60h\n\nuint __cdecl\nfcn.004083a6(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h, uint arg_28h, uint arg_2ch, uint arg_30h)\n\n{\n    char cVar1;\n    uchar uVar2;\n    uint uVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    char *pcVar7;\n    char *pcVar8;\n    uint uVar9;\n    uint32_t uVar10;\n    int32_t unaff_EBP;\n    uint32_t uVar11;\n    uint *in_FS_OFFSET;\n    uint uVar12;\n    uint var_60h;\n    uint var_44h;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0040a424();\n    uVar3 = fcn.00405184(unaff_EBP + -0x20);\n    *(unaff_EBP + -4) = 0;\n    uVar3 = fcn.00408131(uVar3);\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(unaff_EBP + -0x18) = uVar3;\n    fcn.0040507f();\n    fcn.004075eb(unaff_EBP + -0x60);\n    *(unaff_EBP + -4) = 1;\n    uVar2 = fcn.004069e7();\n    *(unaff_EBP + -0x1c) = uVar2;\n    fcn.004073c7();\n    uVar3 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 2;\n    uVar2 = fcn.00406a46(0x30);\n    pcVar8 = *(unaff_EBP + 0x20);\n    *(unaff_EBP + -0x14) = uVar2;\n    if ((*pcVar8 == '+') || (*pcVar8 == '-')) {\n        *(unaff_EBP + 0x20) = 1;\n    }\n    else {\n        *(unaff_EBP + 0x20) = 0;\n    }\n    puVar4 = fcn.0040a79a();\n    *(unaff_EBP + -0x10) = **puVar4;\n    *(unaff_EBP + -0xf) = 0x65;\n    *(unaff_EBP + -0xe) = 0;\n    iVar5 = fcn.0040a7c0(pcVar8, 0x65, *(unaff_EBP + 0x30));\n    iVar6 = fcn.0040a7c0(pcVar8, *(unaff_EBP + -0x10), *(unaff_EBP + 0x30));\n    *(unaff_EBP + 8) = iVar6;\n    if (iVar6 == 0) {\n        *(unaff_EBP + 0x2c) = 0;\n    }\n    pcVar7 = fcn.00406a81();\n    if ((*pcVar7 != '\\x7f') && ('\\0' < *pcVar7)) {\n        fcn.004078be(pcVar8, *(unaff_EBP + 0x30));\n        if (iVar5 == 0) {\n            fcn.00407511(*(unaff_EBP + 0x2c), 0x30);\n        }\n        else {\n            if (*(unaff_EBP + 8) == 0) {\n                fcn.00407511(*(unaff_EBP + 0x24), 0x30);\n                *(unaff_EBP + 0x24) = 0;\n            }\n            fcn.00407561(iVar5 - pcVar8, *(unaff_EBP + 0x2c), 0x30);\n        }\n        if (*(unaff_EBP + 8) == 0) {\n            fcn.00407511(*(unaff_EBP + 0x24), 0x30);\n        }\n        else {\n            iVar5 = *(unaff_EBP + 8) - pcVar8;\n            fcn.00407561(iVar5 + 1, *(unaff_EBP + 0x28), 0x30);\n            fcn.00407561(iVar5, *(unaff_EBP + 0x24), 0x30);\n            *(unaff_EBP + 0x28) = 0;\n        }\n        *(unaff_EBP + 0x24) = 0;\n        pcVar8 = fcn.00406a81();\n        iVar5 = unaff_EBP + -0x10;\n        uVar12 = 0;\n        uVar9 = fcn.004069bc(0);\n        iVar6 = fcn.0040a870(uVar9, uVar12);\n        while (((cVar1 = *pcVar8,  cVar1 != '\\x7f' && ('\\0' < cVar1)) && (cVar1 < iVar6 - *(unaff_EBP + 0x20)))) {\n            iVar6 = iVar6 - cVar1;\n            iVar5 = iVar6;\n            fcn.00407561(iVar6, 1, 0);\n            if ('\\0' < pcVar8[1]) {\n                pcVar8 = pcVar8 + 1;\n            }\n        }\n        uVar9 = 0;\n        pcVar8 = fcn.004069bc(0);\n        *(unaff_EBP + 0x2c) = 0;\n        uVar9 = fcn.00405a35(uVar9, iVar5);\n        *(unaff_EBP + 0x30) = uVar9;\n    }\n    uVar11 = *(unaff_EBP + 0x24) + *(unaff_EBP + 0x28) + *(unaff_EBP + 0x2c) + *(unaff_EBP + 0x30);\n    uVar10 = fcn.004068a4();\n    if ((uVar10 < 1) || (uVar10 <= uVar11)) {\n        *(unaff_EBP + 8) = 0;\n    }\n    else {\n        *(unaff_EBP + 8) = uVar10 - uVar11;\n    }\n    uVar10 = fcn.00405180();\n    if ((uVar10 & 0x1c0) != 0x40) {\n        if (((uVar10 & 0x1c0) == 0x100) && (*(unaff_EBP + 0x20) != 0)) {\n            puVar4 = fcn.0040724f(uVar3, unaff_EBP + -0x28, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), pcVar8, 1);\n            *(unaff_EBP + 0x10) = *puVar4;\n            uVar9 = puVar4[1];\n            pcVar8 = pcVar8 + 1;\n            *(unaff_EBP + 0x30) = *(unaff_EBP + 0x30) + -1;\n            *(unaff_EBP + 0x14) = uVar9;\n        }\n        puVar4 = fcn.0040712f(uVar3, unaff_EBP + -0x28, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), *(unaff_EBP + 0x1c), \n                              *(unaff_EBP + 8));\n        *(unaff_EBP + 0x10) = *puVar4;\n        uVar9 = puVar4[1];\n        *(unaff_EBP + 8) = 0;\n        *(unaff_EBP + 0x14) = uVar9;\n    }\n    iVar5 = fcn.0040a7c0(pcVar8, *(unaff_EBP + -0x10), *(unaff_EBP + 0x30));\n    if (iVar5 != 0) {\n        iVar6 = (iVar5 - pcVar8) + 1;\n        puVar4 = fcn.004072a5(uVar3, unaff_EBP + -0x28, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), pcVar8, iVar5 - pcVar8\n                              , *(unaff_EBP + -0x1c));\n        *(unaff_EBP + 0x10) = *puVar4;\n        *(unaff_EBP + 0x14) = puVar4[1];\n        puVar4 = fcn.0040712f(uVar3, unaff_EBP + -0x28, *puVar4, puVar4[1], *(unaff_EBP + -0x14), *(unaff_EBP + 0x24));\n        *(unaff_EBP + 0x10) = *puVar4;\n        uVar9 = 1;\n        *(unaff_EBP + 0x14) = puVar4[1];\n        uVar10 = fcn.004069e2();\n        puVar4 = fcn.0040712f(uVar3, unaff_EBP + -0x28, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), uVar10 & 0xff, uVar9);\n        *(unaff_EBP + 0x10) = *puVar4;\n        *(unaff_EBP + 0x14) = puVar4[1];\n        puVar4 = fcn.0040712f(uVar3, unaff_EBP + -0x28, *puVar4, puVar4[1], *(unaff_EBP + -0x14), *(unaff_EBP + 0x28));\n        *(unaff_EBP + 0x10) = *puVar4;\n        uVar9 = puVar4[1];\n        pcVar8 = pcVar8 + iVar6;\n        *(unaff_EBP + 0x30) = *(unaff_EBP + 0x30) - iVar6;\n        *(unaff_EBP + 0x14) = uVar9;\n    }\n    iVar5 = fcn.0040a7c0(pcVar8, 0x65, *(unaff_EBP + 0x30));\n    if (iVar5 != 0) {\n        *(unaff_EBP + 0x24) = (iVar5 - pcVar8) + 1;\n        puVar4 = fcn.004072a5(uVar3, unaff_EBP + -0x28, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), pcVar8, iVar5 - pcVar8\n                              , *(unaff_EBP + -0x1c));\n        *(unaff_EBP + 0x10) = *puVar4;\n        *(unaff_EBP + 0x14) = puVar4[1];\n        puVar4 = fcn.0040712f(uVar3, unaff_EBP + -0x28, *puVar4, puVar4[1], *(unaff_EBP + -0x14), *(unaff_EBP + 0x2c));\n        *(unaff_EBP + 0x2c) = 0;\n        *(unaff_EBP + 0x10) = *puVar4;\n        *(unaff_EBP + 0x14) = puVar4[1];\n        uVar10 = fcn.00405180();\n        uVar9 = 0x401710;\n        if ((uVar10 & 4) == 0) {\n            uVar9 = 0x40170c;\n        }\n        puVar4 = fcn.0040724f(uVar3, unaff_EBP + -0x28, *puVar4, puVar4[1], uVar9, 1);\n        *(unaff_EBP + 0x10) = *puVar4;\n        *(unaff_EBP + 0x14) = puVar4[1];\n        pcVar8 = pcVar8 + *(unaff_EBP + 0x24);\n        *(unaff_EBP + 0x30) = *(unaff_EBP + 0x30) - *(unaff_EBP + 0x24);\n    }\n    puVar4 = fcn.004072a5(uVar3, unaff_EBP + -0x28, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), pcVar8, \n                          *(unaff_EBP + 0x30), *(unaff_EBP + -0x1c));\n    *(unaff_EBP + 0x10) = *puVar4;\n    *(unaff_EBP + 0x14) = puVar4[1];\n    puVar4 = fcn.0040712f(uVar3, unaff_EBP + -0x28, *puVar4, puVar4[1], *(unaff_EBP + -0x14), *(unaff_EBP + 0x2c));\n    uVar9 = *puVar4;\n    *(unaff_EBP + 0x10) = uVar9;\n    uVar12 = puVar4[1];\n    *(unaff_EBP + 0x14) = uVar12;\n    fcn.004068a8(0);\n    fcn.0040712f(uVar3, *(unaff_EBP + 0xc), uVar9, uVar12, *(unaff_EBP + 0x1c), *(unaff_EBP + 8));\n    fcn.004073e8();\n    fcn.004073e8();\n    uVar3 = *(unaff_EBP + 0xc);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 3181
    },
    "004087e9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_38h\n\nuint __cdecl\nfcn.004087e9(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    char cVar1;\n    uint uVar2;\n    uint arg_14h_00;\n    uint uVar3;\n    char *pcVar4;\n    int32_t arg_ch_00;\n    uint32_t uVar5;\n    uint *puVar6;\n    char *arg_18h_00;\n    int32_t unaff_EBP;\n    int32_t iVar7;\n    uint *in_FS_OFFSET;\n    uint var_38h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040a424();\n    uVar3 = fcn.00405184(unaff_EBP + -0x1c);\n    *(unaff_EBP + -4) = 0;\n    uVar3 = fcn.00408131(uVar3);\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(unaff_EBP + -0x18) = uVar3;\n    fcn.0040507f();\n    fcn.004075eb(unaff_EBP + -0x38);\n    arg_18h_00 = *(unaff_EBP + 0x20);\n    cVar1 = *arg_18h_00;\n    *(unaff_EBP + -4) = 1;\n    if ((cVar1 == '+') || (cVar1 == '-')) {\n        *(unaff_EBP + -0x10) = 1;\n    }\n    else if ((cVar1 == '0') && ((arg_18h_00[1] == 'x' || (arg_18h_00[1] == 'X')))) {\n        *(unaff_EBP + -0x10) = 2;\n    }\n    else {\n        *(unaff_EBP + -0x10) = 0;\n    }\n    pcVar4 = fcn.00406a81();\n    if ((*pcVar4 != '\\x7f') && ('\\0' < *pcVar4)) {\n        iVar7 = *(unaff_EBP + 0x24);\n        *(unaff_EBP + 0x20) = pcVar4;\n        while (((cVar1 = *pcVar4,  cVar1 != '\\x7f' && ('\\0' < cVar1)) && (cVar1 < iVar7 - *(unaff_EBP + -0x10)))) {\n            iVar7 = iVar7 - cVar1;\n            arg_ch_00 = (*(unaff_EBP + 0x24) - iVar7) + 1;\n            fcn.00409dda(arg_18h_00 + iVar7 + 1, arg_ch_00, arg_18h_00 + iVar7, arg_ch_00);\n            *(unaff_EBP + 0x24) = *(unaff_EBP + 0x24) + 1;\n            pcVar4 = *(unaff_EBP + 0x20) + 1;\n            arg_18h_00[iVar7] = '\\0';\n            if ('\\0' < *pcVar4) {\n                *(unaff_EBP + 0x20) = pcVar4;\n            }\n            pcVar4 = *(unaff_EBP + 0x20);\n        }\n    }\n    uVar5 = fcn.004068a4();\n    if ((uVar5 < 1) || (uVar5 < *(unaff_EBP + 0x24) || uVar5 == *(unaff_EBP + 0x24))) {\n        *(unaff_EBP + 0x20) = 0;\n    }\n    else {\n        *(unaff_EBP + 0x20) = uVar5 - *(unaff_EBP + 0x24);\n    }\n    uVar5 = fcn.00405180();\n    uVar3 = *(unaff_EBP + 8);\n    if ((uVar5 & 0x1c0) != 0x40) {\n        if ((uVar5 & 0x1c0) == 0x100) {\n            iVar7 = *(unaff_EBP + -0x10);\n            puVar6 = fcn.0040724f(uVar3, unaff_EBP + -0x14, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), arg_18h_00, iVar7)\n            ;\n            uVar2 = *puVar6;\n            *(unaff_EBP + 0x24) = *(unaff_EBP + 0x24) - iVar7;\n            *(unaff_EBP + 0x10) = uVar2;\n            *(unaff_EBP + 0x14) = puVar6[1];\n            arg_18h_00 = arg_18h_00 + iVar7;\n            puVar6 = fcn.0040712f(uVar3, unaff_EBP + -0x14, *puVar6, puVar6[1], *(unaff_EBP + 0x1c), *(unaff_EBP + 0x20)\n                                 );\n        }\n        else {\n            puVar6 = fcn.0040712f(uVar3, unaff_EBP + -0x14, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), \n                                  *(unaff_EBP + 0x1c), *(unaff_EBP + 0x20));\n        }\n        uVar2 = *puVar6;\n        *(unaff_EBP + 0x20) = 0;\n        *(unaff_EBP + 0x10) = uVar2;\n        *(unaff_EBP + 0x14) = puVar6[1];\n    }\n    uVar5 = fcn.004069e7();\n    puVar6 = fcn.004072a5(uVar3, unaff_EBP + -0x14, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), arg_18h_00, \n                          *(unaff_EBP + 0x24), uVar5 & 0xff);\n    uVar2 = *puVar6;\n    *(unaff_EBP + 0x10) = uVar2;\n    arg_14h_00 = puVar6[1];\n    *(unaff_EBP + 0x14) = arg_14h_00;\n    fcn.004068a8(0);\n    fcn.0040712f(uVar3, *(unaff_EBP + 0xc), uVar2, arg_14h_00, *(unaff_EBP + 0x1c), *(unaff_EBP + 0x20));\n    fcn.004073e8();\n    uVar3 = *(unaff_EBP + 0xc);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 1619
    },
    "00408c25": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00408c25(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    double dVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    uint32_t arg_28h;\n    unkbyte3 Stack0000001c;\n    uint32_t in_stack_0000001c;\n    int32_t arg_14h_00;\n    int32_t iStack140;\n    uint var_78h;\n    uint var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    iStack140 = fcn.00405a35();\n    arg_28h = 0;\n    if ((iStack140 < 1) && (uVar2 = fcn.00405180(),  (uVar2 & 0x2000) == 0)) {\n        iStack140 = 6;\n    }\n    else {\n        var_8h = 0x24;\n        if (0x24 < iStack140) goto code_r0x00408c64;\n    }\n    var_8h = iStack140;\ncode_r0x00408c64:\n    iStack140 = iStack140 - var_8h;\n    var_4h = 0;\n    uVar2 = fcn.00405180();\n    dVar1 = CONCAT44(in_stack_0000001c, arg_1ch);\n    if (((uVar2 & 0x3000) == 0x2000) && (*0x401748 * dVar1 != dVar1)) {\n        if (((0.0 < dVar1) << 8 | (dVar1 == 0.0) << 0xe) == 0) {\n            in_stack_0000001c = CONCAT13(1, Stack0000001c);\n            dVar1 = -dVar1;\n        }\n        else {\n            in_stack_0000001c = in_stack_0000001c & 0xffffff;\n        }\n        if (*0x401738 < dVar1 != (*0x401738 == dVar1)) {\n            do {\n                if (4999 < var_4h) break;\n                dVar1 = dVar1 / *0x401730;\n                var_4h = var_4h + 10;\n            } while (*0x401738 < dVar1 != (*0x401738 == dVar1));\n        }\n        if (0.0 < dVar1) {\n            for (; ((9 < iStack140 && (dVar1 <= *0x401728)) && (arg_28h < 5000)); arg_28h = arg_28h + 10) {\n                iStack140 = iStack140 + -10;\n                dVar1 = dVar1 * *0x401730;\n            }\n        }\n    }\n    arg_14h_00 = var_8h;\n    uVar3 = fcn.004068e2(var_ch, &arg_1ch, 0, uVar2);\n    uVar3 = fcn.0040a8b6(&var_78h, 0x6c, uVar3, arg_14h_00);\n    fcn.004083a6(var_ch, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, &var_78h, var_4h, arg_28h, iStack140, uVar3);\n    return arg_8h;\n}\n",
        "token_count": 787
    },
    "00408d75": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00408d75(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    double dVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    uint32_t arg_28h;\n    unkbyte3 Stack0000001c;\n    uint32_t in_stack_0000001c;\n    int32_t arg_14h_00;\n    int32_t iStack144;\n    uint var_7ch;\n    uint32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    iStack144 = fcn.00405a35();\n    arg_28h = 0;\n    if ((iStack144 < 1) && (uVar2 = fcn.00405180(),  (uVar2 & 0x2000) == 0)) {\n        iStack144 = 6;\n    }\n    else {\n        var_8h = 0x24;\n        if (0x24 < iStack144) goto code_r0x00408db4;\n    }\n    var_8h = iStack144;\ncode_r0x00408db4:\n    iStack144 = iStack144 - var_8h;\n    var_4h = 0;\n    var_10h = fcn.00405180();\n    if ((var_10h & 0x3000) == 0x2000) {\n        dVar1 = CONCAT44(in_stack_0000001c, arg_1ch);\n        if (0.0 <= dVar1) {\n            in_stack_0000001c = in_stack_0000001c & 0xffffff;\n        }\n        else {\n            in_stack_0000001c = CONCAT13(1, Stack0000001c);\n            dVar1 = -dVar1;\n        }\n        if (*0x401738 < dVar1 != (*0x401738 == dVar1)) {\n            do {\n                if (4999 < var_4h) break;\n                dVar1 = dVar1 / *0x401730;\n                var_4h = var_4h + 10;\n            } while (*0x401738 < dVar1 != (*0x401738 == dVar1));\n        }\n        if (0.0 < dVar1) {\n            for (; ((9 < iStack144 && (dVar1 <= *0x401728)) && (arg_28h < 5000)); arg_28h = arg_28h + 10) {\n                iStack144 = iStack144 + -10;\n                dVar1 = dVar1 * *0x401730;\n            }\n        }\n    }\n    arg_14h_00 = var_8h;\n    uVar3 = fcn.004068e2(var_ch, &arg_1ch, 0x4c, var_10h);\n    uVar3 = fcn.0040a8b6(&var_7ch, 0x6c, uVar3, arg_14h_00);\n    fcn.004083a6(var_ch, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, &var_7ch, var_4h, arg_28h, iStack144, uVar3);\n    return arg_8h;\n}\n",
        "token_count": 764
    },
    "00408f38": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t * __cdecl fcn.00408f38(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint arg_ch_00;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040a424();\n    *(unaff_EBP + -0x10) = 0;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    if (*(unaff_EBP + 0x10) != 0) {\n        *extraout_ECX = 0x401754;\n        fcn.00405b00();\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x10) = 1;\n    }\n    arg_ch_00 = *(unaff_EBP + 0xc);\n    *(extraout_ECX + *(*extraout_ECX + 4)) = 0x401564;\n    extraout_ECX[1] = 0;\n    fcn.004089c3(*(unaff_EBP + 8), arg_ch_00);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 333
    },
    "0040a131": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.0040a131(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_8h, uint arg_ch, uint noname_17, uint noname_18, uint arg_18h, uint arg_1ch, \n            uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    uint *var_8h_3;\n    uint *var_ch_2;\n    uint var_10h_2;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    uint var_38h;\n    uint *var_34h;\n    uint var_30h;\n    code *var_2ch;\n    uint *var_28h_2;\n    code *pcStack40;\n    uint32_t uStack36;\n    uint uStack32;\n    uint *puStack28;\n    uint uStack24;\n    uint uStack20;\n    uchar *puStack16;\n    uchar *var_8h_2;\n    int32_t var_4h_2;\n    \n    var_8h_2 = &stack0xfffffffc;\n    puStack16 = &stack0xffffffc0;\n    if (var_8h_3 == 0x123) {\n        *var_ch_2 = 0x40a1dc;\n        var_38h = 1;\n    }\n    else {\n        pcStack40 = fcn.0040a208;\n        uStack36 = *0x80d998 ^ &fcn.0040a131::var_28h_2;\n        uStack32 = var_24h;\n        puStack28 = var_ch_2;\n        uStack24 = var_20h;\n        uStack20 = var_1ch;\n        var_4h_2 = 0;\n        var_28h_2 = *in_FS_OFFSET;\n        *in_FS_OFFSET = &fcn.0040a131::var_28h_2;\n        var_34h = var_8h_3;\n        var_30h = var_10h_2;\n        iVar1 = fcn.0040fcfa();\n        var_2ch = *(iVar1 + 0x80);\n        (*var_2ch)(*var_8h_3, &fcn.0040a131::var_34h);\n        var_38h = 0;\n        if (var_4h_2 == 0) {\n            *in_FS_OFFSET = var_28h_2;\n        }\n        else {\n            *var_28h_2 = **in_FS_OFFSET;\n            *in_FS_OFFSET = var_28h_2;\n        }\n    }\n    return var_38h;\n}\n",
        "token_count": 724
    },
    "0040a51a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040a51a(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00410d98(0x421c90, 0xc);\n    iVar1 = *(unaff_EBP + 8);\n    if (iVar1 != 0) {\n        if (*0x96a900 == 3) {\n            fcn.0041029f(4);\n            *(unaff_EBP + -4) = 0;\n            arg_8h_00 = fcn.004102d2(iVar1);\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 != 0) {\n                fcn.00410302(arg_8h_00, iVar1);\n            }\n            *(unaff_EBP + -4) = 0xfffffffe;\n            fcn.0040a570();\n            if (*(unaff_EBP + -0x1c) != 0) goto code_r0x0040a5a2;\n            iVar1 = *(unaff_EBP + 8);\n        }\n        iVar1 = (*_sym.imp.KERNEL32.dll_HeapFree)(*0x968c74, 0, iVar1);\n        if (iVar1 == 0) {\n            puVar2 = fcn.0040bf88();\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar3 = fcn.0040bf46(uVar3);\n            *puVar2 = uVar3;\n        }\n    }\ncode_r0x0040a5a2:\n    fcn.00410ddd();\n    return;\n}\n",
        "token_count": 433
    },
    "0040aa48": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x0040ab3b: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x0040ab40)\n// WARNING: Removing unreachable block (ram,0x0040ab6e)\n// WARNING: Removing unreachable block (ram,0x0040ab46)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040aa48(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t unaff_EBP;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00410d98(0x421cb0, 0x18);\n    fcn.0041029f(8);\n    *(unaff_EBP + -4) = 0;\n    if (*0x968c34 != 1) {\n        *0x968c30 = 1;\n        *0x968c2c = *(unaff_EBP + 0x10);\n        if (*(unaff_EBP + 0xc) == 0) {\n            piVar1 = fcn.0040faae(*0x96a918);\n            *(unaff_EBP + -0x28) = piVar1;\n            if (piVar1 != NULL) {\n                piVar2 = fcn.0040faae(*0x96a914);\n                *(unaff_EBP + -0x24) = piVar2;\n                *(unaff_EBP + -0x1c) = piVar1;\n                *(unaff_EBP + -0x20) = piVar2;\n                while( true ) {\n                    piVar2 = piVar2 + -1;\n                    *(unaff_EBP + -0x24) = piVar2;\n                    if (piVar2 < piVar1) break;\n                    iVar3 = fcn.0040faa5();\n                    if (*piVar2 != iVar3) {\n                        if (piVar2 < piVar1) break;\n                        pcVar4 = fcn.0040faae(*piVar2);\n                        iVar3 = fcn.0040faa5();\n                        *piVar2 = iVar3;\n                        (*pcVar4)();\n                        iVar3 = fcn.0040faae(*0x96a918);\n                        piVar1 = fcn.0040faae(*0x96a914);\n                        if ((*(unaff_EBP + -0x1c) != iVar3) || (*(unaff_EBP + -0x20) != piVar1)) {\n                            *(unaff_EBP + -0x1c) = iVar3;\n                            *(unaff_EBP + -0x28) = iVar3;\n                            *(unaff_EBP + -0x20) = piVar1;\n                            *(unaff_EBP + -0x24) = piVar1;\n                            piVar2 = piVar1;\n                        }\n                        piVar1 = *(unaff_EBP + -0x28);\n                    }\n                }\n            }\n            fcn.0040a982(0x401218);\n        }\n        fcn.0040a982(0x401220);\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    if (*(unaff_EBP + 0x10) != 0) {\n        fcn.004101c5(8);\n    }\n    return;\n}\n",
        "token_count": 801
    },
    "0040c19b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040c19b(uint arg_8h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    int32_t in_ECX;\n    uint in_EDX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    ushort in_ES;\n    ushort in_CS;\n    ushort in_SS;\n    ushort in_DS;\n    ushort in_FS;\n    ushort in_GS;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint unaff_retaddr;\n    int32_t var_328h;\n    uint var_324h;\n    uint var_320h;\n    \n    if (in_ECX == *0x80d998) {\n        return;\n    }\n    *0x969478 = (in_NT & 1) * 0x4000 | SBORROW4(&stack0xfffffffc, 0x328) * 0x800 | (in_IF & 1) * 0x200 |\n                (in_TF & 1) * 0x100 | (&var_328h < 0) * 0x80 | (*0x10 == 0x32c) * 0x40 | (in_AF & 1) * 0x10 |\n                ((POPCOUNT(&var_328h & 0xff) & 1U) == 0) * 4 | &stack0xfffffffc < 0x328 | (in_ID & 1) * 0x200000 |\n                (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n    *0x96947c = &arg_8h;\n    *0x9693b8 = 0x10001;\n    *0x969360 = 0xc0000409;\n    *0x969364 = 1;\n    var_328h = *0x80d998;\n    var_324h = *0x80d99c;\n    *0x96936c = unaff_retaddr;\n    *0x969444 = in_GS;\n    *0x969448 = in_FS;\n    *0x96944c = in_ES;\n    *0x969450 = in_DS;\n    *0x969454 = unaff_EDI;\n    *0x969458 = unaff_ESI;\n    *0x96945c = unaff_EBX;\n    *0x969460 = in_EDX;\n    *0x969464 = in_ECX;\n    *0x969468 = in_EAX;\n    *0x96946c = unaff_EBP;\n    *0x969470 = unaff_retaddr;\n    *0x969474 = in_CS;\n    *0x969480 = in_SS;\n    *0x9693b0 = (*_sym.imp.KERNEL32.dll_IsDebuggerPresent)();\n    fcn.00410f8c(1);\n    (*_sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter)(0);\n    (*_sym.imp.KERNEL32.dll_UnhandledExceptionFilter)(0x403254);\n    if (*0x9693b0 == 0) {\n        fcn.00410f8c(1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0xc0000409);\n    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1);\n    return;\n}\n",
        "token_count": 818
    },
    "0040d456": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid fcn.0040d456(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040fcfa();\n    if (0 < *(iVar1 + 0x90)) {\n        iVar1 = fcn.0040fcfa();\n        *(iVar1 + 0x90) = *(iVar1 + 0x90) + -1;\n    }\n    return;\n}\n",
        "token_count": 89
    },
    "0040d731": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040d731(uint noname_0, uint noname_1, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_1ch;\n    \n    *(unaff_EDI + -4) = *(unaff_EBP + -0x24);\n    fcn.0040a36f(*(unaff_EBP + -0x28));\n    iVar1 = fcn.0040fcfa();\n    *(iVar1 + 0x88) = *(unaff_EBP + -0x2c);\n    iVar1 = fcn.0040fcfa();\n    *(iVar1 + 0x8c) = *(unaff_EBP + -0x30);\n    if ((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&\n        ((iVar1 = unaff_ESI[5],  iVar1 == 0x19930520 || ((iVar1 == 0x19930521 || (iVar1 == 0x19930522)))))) &&\n       ((*(unaff_EBP + -0x34) == 0 && (*(unaff_EBP + -0x1c) != 0)))) {\n        iVar1 = fcn.0040a348(unaff_ESI[6]);\n        if (iVar1 != 0) {\n            fcn.0040d4b6(unaff_ESI);\n        }\n    }\n    return;\n}\n",
        "token_count": 385
    },
    "004119f3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid fcn.004119f3(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) != 0) {\n        fcn.004101c5(0);\n    }\n    return;\n}\n",
        "token_count": 65
    },
    "0041772e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041772e(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x80d998 ^ &stack0xfffffffc;\n    fcn.0040afa0(arg_10h);\n    var_14h = fcn.0041c10b(&var_10h, &var_28h, arg_ch, 0, 0, 0, 0, &var_24h);\n    iVar1 = fcn.0041b683(&var_10h, arg_8h);\n    if ((var_14h & 3) == 0) {\n        if (iVar1 == 1) {\ncode_r0x00417787:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x004177c7;\n        }\n        if (iVar1 != 2) {\ncode_r0x004177b9:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x004177c7;\n        }\n    }\n    else if ((var_14h & 1) == 0) {\n        if ((var_14h & 2) == 0) goto code_r0x004177b9;\n        goto code_r0x00417787;\n    }\n    if (var_18h != '\\0') {\n        *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n    }\ncode_r0x004177c7:\n    fcn.0040c19b(unaff_EBX);\n    return;\n}\n",
        "token_count": 503
    },
    "004177d6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.004177d6(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x80d998 ^ &stack0xfffffffc;\n    fcn.0040afa0(arg_10h);\n    var_14h = fcn.0041c10b(&var_10h, &var_28h, arg_ch, 0, 0, 0, 0, &var_24h);\n    iVar1 = fcn.0041bbc7(&var_10h, arg_8h);\n    if ((var_14h & 3) == 0) {\n        if (iVar1 == 1) {\ncode_r0x0041782f:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x0041786f;\n        }\n        if (iVar1 != 2) {\ncode_r0x00417861:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x0041786f;\n        }\n    }\n    else if ((var_14h & 1) == 0) {\n        if ((var_14h & 2) == 0) goto code_r0x00417861;\n        goto code_r0x0041782f;\n    }\n    if (var_18h != '\\0') {\n        *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n    }\ncode_r0x0041786f:\n    fcn.0040c19b(unaff_EBX);\n    return;\n}\n",
        "token_count": 503
    },
    "0041aa0f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0041aa0f(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    uint uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    uint var_14h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.0040faa5();\n    var_4h = 0;\n    if (*0x9696d0 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x404418);\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if (iVar2 == 0) {\n            return 0;\n        }\n        arg_8h_00 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x40440c);\n        if (arg_8h_00 == 0) {\n            return 0;\n        }\n        *0x9696d0 = fcn.0040fa33(arg_8h_00);\n        uVar3 = (*pcVar4)(iVar2, 0x4043fc);\n        *0x9696d4 = fcn.0040fa33(uVar3);\n        uVar3 = (*pcVar4)(iVar2, 0x4043e8);\n        *0x9696d8 = fcn.0040fa33(uVar3);\n        uVar3 = (*pcVar4)(iVar2, 0x4043cc);\n        *0x9696e0 = fcn.0040fa33(uVar3);\n        if (*0x9696e0 != 0) {\n            uVar3 = (*pcVar4)(iVar2, 0x4043b4);\n            *0x9696dc = fcn.0040fa33(uVar3);\n        }\n    }\n    if ((*0x9696dc != iVar1) && (*0x9696e0 != iVar1)) {\n        pcVar4 = fcn.0040faae(*0x9696dc);\n        pcVar5 = fcn.0040faae(*0x9696e0);\n        if (((pcVar4 != NULL) && (pcVar5 != NULL)) &&\n           (((iVar2 = (*pcVar4)(),  iVar2 == 0 || (iVar2 = (*pcVar5)(iVar2, 1, &var_14h, 0xc, &var_8h),  iVar2 == 0)) ||\n            ((var_ch & 1) == 0)))) {\n            arg_10h = arg_10h | 0x200000;\n            goto code_r0x0041ab51;\n        }\n    }\n    if ((((*0x9696d4 != iVar1) && (pcVar4 = fcn.0040faae(*0x9696d4),  pcVar4 != NULL)) &&\n        (var_4h = (*pcVar4)(),  var_4h != 0)) &&\n       ((*0x9696d8 != iVar1 && (pcVar4 = fcn.0040faae(*0x9696d8),  pcVar4 != NULL)))) {\n        var_4h = (*pcVar4)(var_4h);\n    }\ncode_r0x0041ab51:\n    pcVar4 = fcn.0040faae(*0x9696d0);\n    if (pcVar4 == NULL) {\n        return 0;\n    }\n    uVar3 = (*pcVar4)(var_4h, arg_8h, arg_ch, arg_10h);\n    return uVar3;\n}\n",
        "token_count": 845
    },
    "0041b683": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041b683(uint16_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    bool bVar14;\n    uint var_2ch;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = arg_8h[5] & 0x8000;\n    uVar10 = *(arg_8h + 3);\n    var_20h = uVar10;\n    uVar3 = *(arg_8h + 1);\n    uVar2 = *arg_8h;\n    uVar11 = arg_8h[5] & 0x7fff;\n    iVar12 = uVar11 - 0x3fff;\n    var_1ch = uVar3;\n    var_18h = uVar2 << 0x10;\n    if (iVar12 == -0x3fff) {\n        iVar12 = 0;\n        iVar4 = 0;\n        do {\n            if ((&var_20h)[iVar4] != 0) {\n                var_20h = 0;\n                var_1ch = 0;\n                uVar5 = 2;\n                goto code_r0x0041bb84;\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 3);\n        uVar5 = 0;\n    }\n    else {\n        arg_8h = NULL;\n        iVar13 = str.5_v_[0] + L'\\xffffffff';\n        iVar4 = str.5_v_[0] + (str.5_v_[0] >> 0x1f & 0x1fU) >> 5;\n        uVar9 = str.5_v_[0] & 0x8000001f;\n        var_10h = iVar12;\n        var_ch = iVar4;\n        if (uVar9 < 0) {\n            uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;\n        }\n        puVar1 = &var_20h + iVar4;\n        uVar6 = 0x1f - uVar9;\n        var_8h = 0x1f - uVar9;\n        if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n            uVar9 = (&var_20h)[iVar4] & ~(-1 << (uVar6 & 0x1f));\n            while( true ) {\n                if (uVar9 != 0) {\n                    iVar4 = iVar13 + (iVar13 >> 0x1f & 0x1fU) >> 5;\n                    var_4h = 0;\n                    uVar9 = 1 << (0x1f - (iVar13 & 0x1f) & 0x1f);\n                    puVar7 = &var_20h + iVar4;\n                    arg_8h = *puVar7 + uVar9;\n                    if (arg_8h < *puVar7) goto code_r0x0041b7b8;\n                    bVar14 = arg_8h < uVar9;\n                    do {\n                        var_4h = 0;\n                        if (!bVar14) goto code_r0x0041b7bf;\ncode_r0x0041b7b8:\n                        do {\n                            var_4h = 1;\ncode_r0x0041b7bf:\n                            iVar4 = iVar4 + -1;\n                            *puVar7 = arg_8h;\n                            if ((iVar4 < 0) || (var_4h == 0)) {\n                                arg_8h = var_4h;\n                                goto code_r0x0041b7cd;\n                            }\n                            var_4h = 0;\n                            puVar7 = &var_20h + iVar4;\n                            arg_8h = *puVar7 + 1;\n                        } while (arg_8h < *puVar7);\n                        bVar14 = arg_8h == NULL;\n                    } while( true );\n                }\n                iVar4 = iVar4 + 1;\n                if (2 < iVar4) break;\n                uVar9 = (&var_20h)[iVar4];\n            }\n        }\ncode_r0x0041b7cd:\n        *puVar1 = *puVar1 & -1 << (var_8h & 0x1f);\n        iVar4 = var_ch + 1;\n        if (iVar4 < 3) {\n            puVar8 = &var_20h + iVar4;\n            for (iVar13 = 3 - iVar4; iVar13 != 0; iVar13 = iVar13 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n        }\n        if (arg_8h != NULL) {\n            iVar12 = uVar11 - 0x3ffe;\n        }\n        if (iVar12 < *0x80e844 - str.5_v_[0]) {\n            var_20h = 0;\n            var_1ch = 0;\n        }\n        else {\n            if (*0x80e844 < iVar12) {\n                if (iVar12 < *0x80e840) {\n                    var_20h = var_20h & 0x7fffffff;\n                    iVar12 = iVar12 + str.5_v_[3];\n                    iVar4 = str.5_v_[1] + (str.5_v_[1] >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = str.5_v_[1] & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        var_10h = (&var_20h)[arg_8h] & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = (&var_20h)[arg_8h] >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar13 = 2;\n                    puVar8 = &var_18h + -iVar4;\n                    do {\n                        if (iVar13 < iVar4) {\n                            (&var_20h)[iVar13] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar13] = *puVar8;\n                        }\n                        iVar13 = iVar13 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar13);\n                    uVar5 = 0;\n                }\n                else {\n                    var_1ch = 0;\n                    var_18h = 0;\n                    var_20h = 0x80000000;\n                    iVar12 = str.5_v_[1] + (str.5_v_[1] >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = str.5_v_[1] & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        uVar3 = (&var_20h)[arg_8h];\n                        var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar4 = 2;\n                    puVar8 = &var_18h + -iVar12;\n                    do {\n                        if (iVar4 < iVar12) {\n                            (&var_20h)[iVar4] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar4] = *puVar8;\n                        }\n                        iVar4 = iVar4 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar4);\n                    iVar12 = str.5_v_[3] + *0x80e840;\n                    uVar5 = 1;\n                }\n                goto code_r0x0041bb84;\n            }\n            var_10h = *0x80e844 - var_10h;\n            var_20h = uVar10;\n            var_1ch = uVar3;\n            iVar12 = var_10h + (var_10h >> 0x1f & 0x1fU) >> 5;\n            uVar10 = var_10h & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n            iVar4 = str.5_v_[0] + L'\\xffffffff';\n            iVar12 = str.5_v_[0] + (str.5_v_[0] >> 0x1f & 0x1fU) >> 5;\n            uVar10 = str.5_v_[0] & 0x8000001f;\n            var_ch = iVar12;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            uVar6 = 0x1f - uVar10;\n            puVar1 = &var_20h + iVar12;\n            var_10h = 0x1f - uVar10;\n            if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n                uVar10 = (&var_20h)[iVar12] & ~(-1 << (uVar6 & 0x1f));\n                while (uVar10 == 0) {\n                    iVar12 = iVar12 + 1;\n                    if (2 < iVar12) goto code_r0x0041b970;\n                    uVar10 = (&var_20h)[iVar12];\n                }\n                iVar12 = iVar4 + (iVar4 >> 0x1f & 0x1fU) >> 5;\n                bVar14 = false;\n                uVar11 = 1 << (0x1f - (iVar4 & 0x1f) & 0x1f);\n                uVar3 = (&var_20h)[iVar12];\n                uVar10 = uVar3 + uVar11;\n                if ((uVar10 < uVar3) || (uVar10 < uVar11)) {\n                    bVar14 = true;\n                }\n                (&var_20h)[iVar12] = uVar10;\n                while ((iVar12 = iVar12 + -1,  -1 < iVar12 && (bVar14))) {\n                    uVar3 = (&var_20h)[iVar12];\n                    uVar10 = uVar3 + 1;\n                    bVar14 = false;\n                    if ((uVar10 < uVar3) || (uVar10 == 0)) {\n                        bVar14 = true;\n                    }\n                    (&var_20h)[iVar12] = uVar10;\n                }\n            }\ncode_r0x0041b970:\n            *puVar1 = *puVar1 & -1 << (var_10h & 0x1f);\n            iVar12 = var_ch + 1;\n            if (iVar12 < 3) {\n                puVar8 = &var_20h + iVar12;\n                for (iVar4 = 3 - iVar12; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n            }\n            uVar10 = str.5_v_[1] + L'\\x01';\n            iVar12 = uVar10 + (uVar10 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = uVar10 & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n        }\n        iVar12 = 0;\n        uVar5 = 2;\n    }\ncode_r0x0041bb84:\n    var_20h = iVar12 << (0x1fU - str.5_v_[1] & 0x1f) | -(var_14h != 0) & 0x80000000 | var_20h;\n    if (str.5_v_[2] == L'@') {\n        arg_ch[1] = var_20h;\n        *arg_ch = var_1ch;\n    }\n    else if (str.5_v_[2] == L' ') {\n        *arg_ch = var_20h;\n    }\n    return uVar5;\n}\n",
        "token_count": 3672
    },
    "0041bbc7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041bbc7(uint16_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    bool bVar14;\n    uint var_2ch;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = arg_8h[5] & 0x8000;\n    uVar10 = *(arg_8h + 3);\n    var_20h = uVar10;\n    uVar3 = *(arg_8h + 1);\n    uVar2 = *arg_8h;\n    uVar11 = arg_8h[5] & 0x7fff;\n    iVar12 = uVar11 - 0x3fff;\n    var_1ch = uVar3;\n    var_18h = uVar2 << 0x10;\n    if (iVar12 == -0x3fff) {\n        iVar12 = 0;\n        iVar4 = 0;\n        do {\n            if ((&var_20h)[iVar4] != 0) {\n                var_20h = 0;\n                var_1ch = 0;\n                uVar5 = 2;\n                goto code_r0x0041c0c8;\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 3);\n        uVar5 = 0;\n    }\n    else {\n        arg_8h = NULL;\n        iVar13 = *0x80e860 - 1;\n        iVar4 = *0x80e860 + (*0x80e860 >> 0x1f & 0x1fU) >> 5;\n        uVar9 = *0x80e860 & 0x8000001f;\n        var_10h = iVar12;\n        var_ch = iVar4;\n        if (uVar9 < 0) {\n            uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;\n        }\n        puVar1 = &var_20h + iVar4;\n        uVar6 = 0x1f - uVar9;\n        var_8h = 0x1f - uVar9;\n        if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n            uVar9 = (&var_20h)[iVar4] & ~(-1 << (uVar6 & 0x1f));\n            while( true ) {\n                if (uVar9 != 0) {\n                    iVar4 = iVar13 + (iVar13 >> 0x1f & 0x1fU) >> 5;\n                    var_4h = 0;\n                    uVar9 = 1 << (0x1f - (iVar13 & 0x1f) & 0x1f);\n                    puVar7 = &var_20h + iVar4;\n                    arg_8h = *puVar7 + uVar9;\n                    if (arg_8h < *puVar7) goto code_r0x0041bcfc;\n                    bVar14 = arg_8h < uVar9;\n                    do {\n                        var_4h = 0;\n                        if (!bVar14) goto code_r0x0041bd03;\ncode_r0x0041bcfc:\n                        do {\n                            var_4h = 1;\ncode_r0x0041bd03:\n                            iVar4 = iVar4 + -1;\n                            *puVar7 = arg_8h;\n                            if ((iVar4 < 0) || (var_4h == 0)) {\n                                arg_8h = var_4h;\n                                goto code_r0x0041bd11;\n                            }\n                            var_4h = 0;\n                            puVar7 = &var_20h + iVar4;\n                            arg_8h = *puVar7 + 1;\n                        } while (arg_8h < *puVar7);\n                        bVar14 = arg_8h == NULL;\n                    } while( true );\n                }\n                iVar4 = iVar4 + 1;\n                if (2 < iVar4) break;\n                uVar9 = (&var_20h)[iVar4];\n            }\n        }\ncode_r0x0041bd11:\n        *puVar1 = *puVar1 & -1 << (var_8h & 0x1f);\n        iVar4 = var_ch + 1;\n        if (iVar4 < 3) {\n            puVar8 = &var_20h + iVar4;\n            for (iVar13 = 3 - iVar4; iVar13 != 0; iVar13 = iVar13 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n        }\n        if (arg_8h != NULL) {\n            iVar12 = uVar11 - 0x3ffe;\n        }\n        if (iVar12 < *0x80e85c - *0x80e860) {\n            var_20h = 0;\n            var_1ch = 0;\n        }\n        else {\n            if (*0x80e85c < iVar12) {\n                if (iVar12 < *0x80e858) {\n                    var_20h = var_20h & 0x7fffffff;\n                    iVar12 = iVar12 + *0x80e86c;\n                    iVar4 = *0x80e864 + (*0x80e864 >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = *0x80e864 & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        var_10h = (&var_20h)[arg_8h] & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = (&var_20h)[arg_8h] >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar13 = 2;\n                    puVar8 = &var_18h + -iVar4;\n                    do {\n                        if (iVar13 < iVar4) {\n                            (&var_20h)[iVar13] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar13] = *puVar8;\n                        }\n                        iVar13 = iVar13 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar13);\n                    uVar5 = 0;\n                }\n                else {\n                    var_1ch = 0;\n                    var_18h = 0;\n                    var_20h = 0x80000000;\n                    iVar12 = *0x80e864 + (*0x80e864 >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = *0x80e864 & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        uVar3 = (&var_20h)[arg_8h];\n                        var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar4 = 2;\n                    puVar8 = &var_18h + -iVar12;\n                    do {\n                        if (iVar4 < iVar12) {\n                            (&var_20h)[iVar4] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar4] = *puVar8;\n                        }\n                        iVar4 = iVar4 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar4);\n                    iVar12 = *0x80e86c + *0x80e858;\n                    uVar5 = 1;\n                }\n                goto code_r0x0041c0c8;\n            }\n            var_10h = *0x80e85c - var_10h;\n            var_20h = uVar10;\n            var_1ch = uVar3;\n            iVar12 = var_10h + (var_10h >> 0x1f & 0x1fU) >> 5;\n            uVar10 = var_10h & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n            iVar4 = *0x80e860 - 1;\n            iVar12 = *0x80e860 + (*0x80e860 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = *0x80e860 & 0x8000001f;\n            var_ch = iVar12;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            uVar6 = 0x1f - uVar10;\n            puVar1 = &var_20h + iVar12;\n            var_10h = 0x1f - uVar10;\n            if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n                uVar10 = (&var_20h)[iVar12] & ~(-1 << (uVar6 & 0x1f));\n                while (uVar10 == 0) {\n                    iVar12 = iVar12 + 1;\n                    if (2 < iVar12) goto code_r0x0041beb4;\n                    uVar10 = (&var_20h)[iVar12];\n                }\n                iVar12 = iVar4 + (iVar4 >> 0x1f & 0x1fU) >> 5;\n                bVar14 = false;\n                uVar11 = 1 << (0x1f - (iVar4 & 0x1f) & 0x1f);\n                uVar3 = (&var_20h)[iVar12];\n                uVar10 = uVar3 + uVar11;\n                if ((uVar10 < uVar3) || (uVar10 < uVar11)) {\n                    bVar14 = true;\n                }\n                (&var_20h)[iVar12] = uVar10;\n                while ((iVar12 = iVar12 + -1,  -1 < iVar12 && (bVar14))) {\n                    uVar3 = (&var_20h)[iVar12];\n                    uVar10 = uVar3 + 1;\n                    bVar14 = false;\n                    if ((uVar10 < uVar3) || (uVar10 == 0)) {\n                        bVar14 = true;\n                    }\n                    (&var_20h)[iVar12] = uVar10;\n                }\n            }\ncode_r0x0041beb4:\n            *puVar1 = *puVar1 & -1 << (var_10h & 0x1f);\n            iVar12 = var_ch + 1;\n            if (iVar12 < 3) {\n                puVar8 = &var_20h + iVar12;\n                for (iVar4 = 3 - iVar12; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n            }\n            uVar10 = *0x80e864 + 1;\n            iVar12 = uVar10 + (uVar10 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = uVar10 & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n        }\n        iVar12 = 0;\n        uVar5 = 2;\n    }\ncode_r0x0041c0c8:\n    var_20h = iVar12 << (0x1fU - *0x80e864 & 0x1f) | -(var_14h != 0) & 0x80000000 | var_20h;\n    if (*0x80e868 == 0x40) {\n        arg_ch[1] = var_20h;\n        *arg_ch = var_1ch;\n    }\n    else if (*0x80e868 == 0x20) {\n        *arg_ch = var_20h;\n    }\n    return uVar5;\n}\n",
        "token_count": 3649
    },
    "00404ec7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404ec7(uint32_t arg_8h)\n\n{\n    fcn.00404ebc();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "004050d1": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004050d1(uint32_t arg_8h)\n\n{\n    fcn.00405030();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 59
    },
    "00405116": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405116(uint32_t arg_8h)\n\n{\n    fcn.0040510b();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 59
    },
    "004051b5": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004051b5(uint32_t arg_8h)\n\n{\n    fcn.0040519e();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "00405a85": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405a85(uint32_t arg_8h)\n\n{\n    fcn.00405a48();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "00405bac": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00405bac(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint arg_8h;\n    \n    if ((*(param_1 + 0x40) & 1) != 0) {\n        iVar1 = fcn.00405b2b();\n        if (iVar1 == 0) {\n            iVar1 = fcn.00405b31();\n        }\n        else {\n            iVar1 = fcn.00405b5d();\n        }\n        iVar2 = fcn.00405b1f();\n        arg_8h = fcn.00405b1f(iVar1 - iVar2);\n        fcn.00405cc2(arg_8h);\n    }\n    fcn.00405b3c(0, 0, 0);\n    fcn.00405b68(0, 0);\n    *(param_1 + 0x40) = *(param_1 + 0x40) & 0xfffffffe;\n    *(param_1 + 0x3c) = 0;\n    return;\n}\n",
        "token_count": 246
    },
    "00405cd2": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00405cd2(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    if ((arg_8h & 1) == 0) {\n        uVar1 = 4;\n    }\n    if ((arg_8h & 2) == 0) {\n        uVar1 = uVar1 | 2;\n    }\n    if ((arg_8h & 8) != 0) {\n        uVar1 = uVar1 | 8;\n    }\n    if ((arg_8h & 4) != 0) {\n        uVar1 = uVar1 | 0x10;\n    }\n    return uVar1;\n}\n",
        "token_count": 162
    },
    "0040609a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040609a(uint32_t arg_8h)\n\n{\n    fcn.00406084();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 59
    },
    "00406584": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.00406584(uint arg_8h, uint arg_ch, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint32_t arg_24h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint arg_ch_00;\n    uint arg_8h_00;\n    int32_t in_ECX;\n    \n    iVar1 = fcn.00406273();\n    iVar2 = fcn.00405b2b();\n    if ((iVar2 != 0) && (uVar3 = fcn.00405b2b(),  *(in_ECX + 0x3c) < uVar3)) {\n        uVar4 = fcn.00405b2b();\n        *(in_ECX + 0x3c) = uVar4;\n    }\n    iVar2 = iVar1;\n    if (iVar1 != *0x40179c) {\n        iVar2 = *0x40179c;\n        if (((arg_24h & 1) == 0) || (iVar5 = fcn.00405b25(),  iVar5 == 0)) {\n            if (((arg_24h & 2) != 0) &&\n               (((iVar5 = fcn.00405b2b(),  iVar5 != 0 && (-1 < iVar1)) &&\n                (iVar5 = fcn.00405b1f(),  iVar1 <= *(in_ECX + 0x3c) - iVar5)))) {\n                iVar2 = fcn.00405b2b();\n                iVar5 = fcn.00405b1f();\n                fcn.00406165((iVar1 - iVar2) + iVar5);\n                iVar2 = iVar1;\n            }\n        }\n        else if ((-1 < iVar1) && (iVar5 = fcn.00405b1f(),  iVar1 <= *(in_ECX + 0x3c) - iVar5)) {\n            iVar2 = fcn.00405b25();\n            iVar5 = fcn.00405b1f();\n            fcn.00406132((iVar1 - iVar2) + iVar5);\n            iVar2 = iVar1;\n            if (((arg_24h & 2) != 0) && (iVar5 = fcn.00405b2b(),  iVar5 != 0)) {\n                uVar4 = fcn.00405b5d();\n                arg_ch_00 = fcn.00405b25();\n                arg_8h_00 = fcn.0040625d();\n                fcn.00405b86(arg_8h_00, arg_ch_00, uVar4);\n            }\n        }\n    }\n    fcn.00406188(iVar2);\n    return arg_8h;\n}\n",
        "token_count": 645
    },
    "00406698": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00406698(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    fcn.00405ac3();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52(in_ECX + -4);\n    }\n    return in_ECX + -4;\n}\n",
        "token_count": 82
    },
    "004066ba": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004066ba(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    fcn.00405ad6();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52(in_ECX + -8);\n    }\n    return in_ECX + -8;\n}\n",
        "token_count": 82
    },
    "004066dc": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004066dc(uint32_t arg_8h)\n\n{\n    fcn.004060b9();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 59
    },
    "004066fb": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004066fb(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    fcn.00405ae9();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52(in_ECX + -0xc);\n    }\n    return in_ECX + -0xc;\n}\n",
        "token_count": 84
    },
    "0040671d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040671d(uint32_t arg_8h)\n\n{\n    fcn.00406215();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 59
    },
    "004068c3": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004068c3(uint32_t arg_8h)\n\n{\n    fcn.004068b8();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "00407395": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407395(uint32_t arg_8h)\n\n{\n    fcn.0040737f();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 59
    },
    "004073f2": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004073f2(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    fcn.004073b4();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52(in_ECX + -0x54);\n    }\n    return in_ECX + -0x54;\n}\n",
        "token_count": 87
    },
    "004076b4": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004076b4(uint32_t arg_8h)\n\n{\n    fcn.0040769b();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "004076f4": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004076f4(uint32_t arg_8h)\n\n{\n    fcn.004076d3();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "004079f1": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004079f1(uint32_t arg_8h)\n\n{\n    fcn.004079e6();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "00407b38": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407b38(uint32_t arg_8h)\n\n{\n    fcn.00407b2d();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 61
    },
    "00407dbc": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_a4h\n\nuint __cdecl fcn.00407dbc(uint arg_8h, uint arg_ch)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t *piVar4;\n    uint *in_FS_OFFSET;\n    uint var_a4h;\n    uint var_30h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040a424();\n    piVar4 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = 0;\n    if ((piVar4 != NULL) && (*piVar4 == 0)) {\n        iVar2 = fcn.0040a45e(0x18);\n        *(unaff_EBP + -0x14) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            iVar2 = 0;\n        }\n        else {\n            uVar3 = fcn.00407a4c(unaff_EBP + -0x30);\n            *(unaff_EBP + -4) = 1;\n            *(unaff_EBP + -0x10) = 1;\n            uVar3 = fcn.00407713(uVar3);\n            *(unaff_EBP + -4) = 2;\n            *(unaff_EBP + -0x10) = 3;\n            iVar2 = fcn.00407336(uVar3, 0, 1);\n            piVar4 = *(unaff_EBP + 8);\n        }\n        uVar1 = *(unaff_EBP + -0x10);\n        *piVar4 = iVar2;\n        *(unaff_EBP + -4) = 3;\n        if ((uVar1 & 2) != 0) {\n            *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffffd;\n            fcn.0040776f();\n        }\n        if ((*(unaff_EBP + -0x10) & 1) != 0) {\n            fcn.004073e8();\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return 4;\n}\n",
        "token_count": 538
    },
    "0040a45e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a45e(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint var_ch;\n    \n    do {\n        iVar2 = fcn.0040e122(arg_8h);\n        if (iVar2 != 0) {\n            return;\n        }\n        iVar2 = fcn.004100cb(arg_8h);\n    } while (iVar2 != 0);\n    if ((*0x968bf8 & 1) == 0) {\n        *0x968bf8 = *0x968bf8 | 1;\n        fcn.0040a443();\n        fcn.0040c0f8(0x41f425);\n    }\n    fcn.00405e93(0x968bec);\n    fcn.0040a4c3(&var_ch, 0x421474);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 215
    },
    "004099db": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004099db(uint32_t arg_8h)\n\n{\n    uint *in_ECX;\n    \n    *in_ECX = 0x4017a4;\n    fcn.0040769b();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 81
    },
    "00409cb9": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409cb9(uint32_t arg_8h)\n\n{\n    fcn.00409c50();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "00409cda": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409cda(uint32_t arg_8h)\n\n{\n    uint *in_ECX;\n    \n    *in_ECX = 0x4017f8;\n    fcn.00409c50();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 82
    },
    "00409d11": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409d11(uint32_t arg_8h)\n\n{\n    fcn.00409d01();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "0040d2c1": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040d2c1(uint32_t arg_8h)\n\n{\n    uint *in_ECX;\n    \n    *in_ECX = 0x402190;\n    fcn.00409c50();\n    if ((arg_8h & 1) != 0) {\n        fcn.00409d52();\n    }\n    return;\n}\n",
        "token_count": 82
    },
    "004199f4": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004199f4(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00410d98(0x422148, 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == 0xfffffffe) {\n        puVar2 = fcn.0040bf9b();\n        *puVar2 = 0;\n        puVar2 = fcn.0040bf88();\n        *puVar2 = 9;\n    }\n    else {\n        if ((-1 < arg_8h_00) && (arg_8h_00 < *0x9697ac)) {\n            piVar1 = (arg_8h_00 >> 5) * 4 + 0x9697c0;\n            iVar4 = (arg_8h_00 & 0x1f) * 0x40;\n            if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n                fcn.0041de70(arg_8h_00);\n                *(unaff_EBP + -4) = 0;\n                if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                    puVar2 = fcn.0040bf88();\n                    *puVar2 = 9;\n                    puVar2 = fcn.0040bf9b();\n                    *puVar2 = 0;\n                    *(unaff_EBP + -0x1c) = 0xffffffff;\n                }\n                else {\n                    uVar3 = fcn.004192c1(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                    *(unaff_EBP + -0x1c) = uVar3;\n                }\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.00419ac6(0x422148);\n                goto code_r0x00419ac0;\n            }\n        }\n        puVar2 = fcn.0040bf9b();\n        *puVar2 = 0;\n        puVar2 = fcn.0040bf88();\n        *puVar2 = 9;\n        fcn.0040a6df(0, 0, 0, 0, 0);\n    }\ncode_r0x00419ac0:\n    fcn.00410ddd();\n    return;\n}\n",
        "token_count": 634
    },
    "004051d4": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nvoid fcn.004051d4(void)\n\n{\n    *0x80ede8 = 0x6d;\n    *0x80ede9 = 0x73;\n    *0x80eded = 0x33;\n    *0x80edf3 = 0;\n    *0x80edec = 0x67;\n    *0x80edf0 = 100;\n    *0x80edeb = 0x6d;\n    *0x80edf1 = 0x6c;\n    *0x80edef = 0x2e;\n    *0x80edf2 = 0x6c;\n    *0x80edee = 0x32;\n    *0x80edea = 0x69;\n    (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x80ede8);\n    return;\n}\n",
        "token_count": 194
    },
    "00405593": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nvoid fcn.00405593(void)\n\n{\n    uint var_4h;\n    \n    *0x80edee = 0x33;\n    *0x80edef = 0x32;\n    *0x80edf3 = 0x6c;\n    *0x80edeb = 0x6e;\n    *0x80ede8 = 0x6b;\n    *0x80edec = 0x65;\n    *0x80eded = 0x6c;\n    *0x80ede9 = 0x65;\n    *0x80edea = 0x72;\n    *0x80edf0 = 0x2e;\n    *0x80edf1 = 100;\n    *0x80edf2 = 0x6c;\n    *0x80edf4 = 0;\n    *0x966e2c = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x80ede8);\n    *0x80edf3 = 0x65;\n    *0x80ede9 = 0x69;\n    *0x80edec = 0x75;\n    *0x80edee = 0x6c;\n    *0x80eded = 0x61;\n    *0x80edf1 = 0x6f;\n    *0x80edf5 = 0x74;\n    *0x80ede8 = 0x56;\n    *0x80edf4 = 99;\n    *0x80edef = 0x50;\n    *0x80edf6 = 0;\n    *0x80edeb = 0x74;\n    *0x80edf2 = 0x74;\n    *0x80edea = 0x72;\n    *0x80edf0 = 0x72;\n    *0x80ede4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x966e2c, 0x80ede8);\n    (**0x80ede4)(*0x96332c, *0x9689b0, 0x40, &var_4h);\n    return;\n}\n",
        "token_count": 488
    },
    "004052a2": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004052a2(uint32_t *arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t unaff_ESI;\n    uint *unaff_EDI;\n    uint lpVolumeNameBuffer;\n    uint var_143ch;\n    uint lpBuffer;\n    uint lpszVolumeName;\n    uint var_43ch;\n    uint uStackY100;\n    uint uStackY96;\n    uint *puStackY92;\n    uint uStackY88;\n    uint *puStackY84;\n    uint uStackY80;\n    uint uStackY76;\n    uint *puStackY72;\n    uint uStackY68;\n    uint *var_3ch;\n    uint *var_38h;\n    uint *var_34h;\n    uint *nSize;\n    uint lpNumberOfCharsWritten;\n    uint *var_28h;\n    uint *var_24h;\n    int32_t var_20h;\n    uint *var_1ch;\n    int32_t var_18h;\n    uint *var_14h;\n    uint32_t var_10h;\n    uint *var_ch;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = 0x4052af;\n    fcn.0040a010();\n    var_4h = *arg_8h;\n    var_1ch = *arg_ch;\n    var_24h = arg_ch[1];\n    var_20h = arg_ch[2];\n    var_18h = arg_ch[3];\n    var_10h = 0xc6ef3720;\n    var_14h = 0x20;\n    var_ch = unaff_EDI;\n    var_8h = unaff_ESI;\n    do {\n        iVar2 = var_4h * 0x10;\n        if (*0x9689b0 == 5) {\n            var_10h = 0x405306;\n            (*_sym.imp.KERNEL32.dll_GetConsoleAliasExesLengthW)();\n        }\n        uVar1 = iVar2 + var_20h;\n        uVar3 = var_10h + var_4h;\n        uVar4 = var_4h >> 5;\n        if (*0x9689b0 == 0x1b) {\n            var_10h = 0;\n            var_14h = &fcn.004052a2::lpszVolumeName;\n            var_18h = 0;\n            var_1ch = 0x405334;\n            (*_sym.imp.KERNEL32.dll_FindNextVolumeW)();\n            var_1ch = NULL;\n            var_20h = 0;\n            var_24h = NULL;\n            var_28h = 0x40533d;\n            (*_sym.imp.KERNEL32.dll_GetSystemTimeAdjustment)();\n            var_28h = &fcn.004052a2::var_28h;\n            lpNumberOfCharsWritten = 0x405347;\n            (*_sym.imp.KERNEL32.dll_InterlockedDecrement)();\n            lpNumberOfCharsWritten = 0;\n            nSize = 0x40534e;\n            (*_sym.imp.KERNEL32.dll_LocalSize)();\n        }\n        *0x963330 = var_18h + uVar4 ^ uVar1 ^ uVar3;\n        var_14h = &fcn.004052a2::var_8h;\n        var_18h = 0x40537a;\n        var_10h = *0x963330;\n        var_ch = *0x963330;\n        fcn.00405243(var_14h, *0x963330);\n        if (*0x9689b0 == 0x839) {\n            var_18h = 0;\n            var_1ch = &fcn.004052a2::lpszVolumeName;\n            var_20h = 0;\n            var_24h = 0x405394;\n            sub.KERNEL32.dll_VerLanguageNameW();\n        }\n        uVar1 = var_8h;\n        if (*0x9689b0 == 0x78c) {\n            var_24h = &fcn.004052a2::nSize;\n            var_28h = &fcn.004052a2::lpBuffer;\n            lpNumberOfCharsWritten = 0x4053bc;\n            (*_sym.imp.KERNEL32.dll_GetComputerNameA)();\n            lpNumberOfCharsWritten = 0;\n            nSize = &fcn.004052a2::var_143ch;\n            var_34h = &fcn.004052a2::var_38h;\n            var_38h = &fcn.004052a2::var_3ch;\n            var_3ch = &fcn.004052a2::var_34h;\n            uStackY68 = 0;\n            puStackY72 = &fcn.004052a2::lpVolumeNameBuffer;\n            uStackY76 = 0x401260;\n            uStackY80 = 0x4053e3;\n            (*_sym.imp.KERNEL32.dll_GetVolumeInformationW)();\n            uStackY80 = 0;\n            puStackY84 = &fcn.004052a2::lpNumberOfCharsWritten;\n            uStackY88 = 0;\n            puStackY92 = &fcn.004052a2::var_43ch;\n            uStackY96 = 0;\n            uStackY100 = 0x4053f7;\n            (*_sym.imp.KERNEL32.dll_WriteConsoleA)();\n        }\n        *0x96333c = 0xffffffff;\n        *0x963338 = 0xff6b3619;\n        var_4h = var_4h - (var_1ch + uVar1 * 4 ^ var_8h + var_10h ^ (uVar1 >> 5) + var_24h);\n        var_24h = 0x9e3779b9;\n        var_ch = &fcn.004052a2::var_10h;\n        lpNumberOfCharsWritten = 0x405445;\n        fcn.00405234(var_ch, 0x9e3779b9);\n        var_14h = var_14h + -1;\n    } while (var_14h != NULL);\n    arg_8h[1] = uVar1;\n    *arg_8h = var_4h;\n    return;\n}\n",
        "token_count": 1513
    },
    "0040545d": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040545d(int32_t arg_8h, uint32_t arg_ch, uint arg_10h)\n\n{\n    if (*0x9689b0 == 0x516) {\n        (*_sym.imp.KERNEL32.dll_MoveFileWithProgressA)(0x4012d4, 0x4012c8, 0, 0, 0);\n    }\n    for (arg_ch = arg_ch >> 3; arg_ch != 0; arg_ch = arg_ch - 1) {\n        if (*0x9689b0 == 0x29) {\n            (*_sym.imp.KERNEL32.dll_CopyFileExA)(0, 0, 0, 0, 0, 0);\n        }\n        if (*0x9689b0 == 0x1c) {\n            (*_sym.imp.KERNEL32.dll_TlsGetValue)(0);\n            (*_sym.imp.KERNEL32.dll_EnumSystemCodePagesW)(0, 0);\n        }\n        fcn.004052a2(arg_8h, arg_10h);\n        arg_8h = arg_8h + 8;\n    }\n    return;\n}\n",
        "token_count": 259
    },
    "0040706c": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040706c(uint arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    *(in_ECX + 0x3c) = 0;\n    *(in_ECX + 0x40) = arg_10h;\n    if ((arg_ch != 0) && ((arg_10h & 6) != 6)) {\n        arg_8h_00 = fcn.0040673c(arg_ch);\n        fcn.0040680e(arg_8h_00, arg_ch, arg_8h, arg_ch);\n        arg_ch = arg_ch + arg_8h_00;\n        *(in_ECX + 0x3c) = arg_ch;\n        if ((*(in_ECX + 0x40) & 4) == 0) {\n            fcn.00405b3c(arg_8h_00, arg_8h_00, arg_ch);\n        }\n        if ((*(in_ECX + 0x40) & 2) == 0) {\n            iVar1 = arg_ch;\n            if ((*(in_ECX + 0x40) & 0x10) == 0) {\n                iVar1 = arg_8h_00;\n            }\n            fcn.00405b86(arg_8h_00, iVar1, arg_ch);\n            iVar1 = fcn.00405b25();\n            if (iVar1 == 0) {\n                fcn.00405b3c(arg_8h_00, 0, arg_8h_00);\n            }\n        }\n        *(in_ECX + 0x40) = *(in_ECX + 0x40) | 1;\n    }\n    return;\n}\n",
        "token_count": 409
    },
    "00407c6d": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nint32_t __cdecl fcn.00407c6d(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040a424();\n    fcn.004093af(0);\n    iVar1 = *0x9689b8;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = iVar1;\n    arg_8h_00 = fcn.00404f90();\n    iVar2 = fcn.00405097(arg_8h_00);\n    if ((iVar2 == 0) && (iVar2 = iVar1,  iVar1 == 0)) {\n        iVar2 = fcn.00407a69(unaff_EBP + -0x10, *(unaff_EBP + 8));\n        if (iVar2 == -1) {\n            fcn.00409c73(0x4016b8);\n            fcn.0040a4c3(unaff_EBP + -0x20, 0x42172c);\n        }\n        iVar2 = *(unaff_EBP + -0x10);\n        *0x9689b8 = iVar2;\n        fcn.00404fc5();\n        fcn.00405028();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004093d7();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 422
    },
    "00408089": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nint32_t __cdecl fcn.00408089(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040a424();\n    fcn.004093af(0);\n    iVar1 = *0x9689bc;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = iVar1;\n    arg_8h_00 = fcn.00404f90();\n    iVar2 = fcn.00405097(arg_8h_00);\n    if ((iVar2 == 0) && (iVar2 = iVar1,  iVar1 == 0)) {\n        iVar2 = fcn.00407d15(unaff_EBP + -0x10, *(unaff_EBP + 8));\n        if (iVar2 == -1) {\n            fcn.00409c73(0x4016b8);\n            fcn.0040a4c3(unaff_EBP + -0x20, 0x42172c);\n        }\n        iVar2 = *(unaff_EBP + -0x10);\n        *0x9689bc = iVar2;\n        fcn.00404fc5();\n        fcn.00405028();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004093d7();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 418
    },
    "00408131": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nint32_t __cdecl fcn.00408131(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040a424();\n    fcn.004093af(0);\n    iVar1 = *0x9689c0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = iVar1;\n    arg_8h_00 = fcn.00404f90();\n    iVar2 = fcn.00405097(arg_8h_00);\n    if ((iVar2 == 0) && (iVar2 = iVar1,  iVar1 == 0)) {\n        iVar2 = fcn.00407dbc(unaff_EBP + -0x10, *(unaff_EBP + 8));\n        if (iVar2 == -1) {\n            fcn.00409c73(0x4016b8);\n            fcn.0040a4c3(unaff_EBP + -0x20, 0x42172c);\n        }\n        iVar2 = *(unaff_EBP + -0x10);\n        *0x9689c0 = iVar2;\n        fcn.00404fc5();\n        fcn.00405028();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004093d7();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 419
    },
    "00408a0c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00408a0c(uint param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint arg_8h;\n    \n    arg_8h = 0;\n    cVar1 = fcn.00405172();\n    if (cVar1 == '\\0') {\n        fcn.00405a53();\n        iVar2 = fcn.00405b12();\n        if (iVar2 == -1) {\n            arg_8h = 4;\n        }\n    }\n    fcn.004081d9(arg_8h, 0);\n    return param_1;\n}\n",
        "token_count": 138
    },
    "00405264": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405264(uint32_t *arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint var_4h;\n    \n    *arg_8h = arg_10h ^ arg_ch;\n    return;\n}\n",
        "token_count": 61
    },
    "00405284": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405284(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    *arg_8h = *arg_8h + arg_ch;\n    return;\n}\n",
        "token_count": 46
    },
    "00405585": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00405585(void)\n\n{\n    return;\n}\n",
        "token_count": 15
    },
    "004056a5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.004056a5(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint lpStruct;\n    uint lpUserName;\n    uint lpVersionInformation;\n    uint lpCriticalSection;\n    uint pActCtx;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_28h;\n    uint lpLastWriteTime;\n    uint lpCurInstances;\n    uint lpLastAccessTime;\n    uint lpMaxCollectionCount;\n    uint lpState;\n    uint lpCreationTime;\n    int32_t lpCollectDataTimeout;\n    uint lpNumberOfCharsWritten;\n    \n    uVar3 = 0;\n    do {\n        if (uVar3 < 0x214cd) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(0);\n            (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        }\n    } while ((((uVar3 < 0x1e9d5e42) || (lpCollectDataTimeout == 0xad5cf7)) || (var_44h == 0xad4c41c)) &&\n            (uVar3 = uVar3 + 1,  uVar3 < 0x91be26a3));\n    iVar4 = 0;\n    do {\n        if (iVar4 == 0x420) {\n            *0x9689b0 = *0x9689b0 + 0x38d6;\n        }\n        if (*0x9689b0 == 0x7a) {\n            (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0);\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 0x40dece);\n    fcn.00405691();\n    uVar3 = 0;\n    if (*0x9689b0 != 0) {\n        do {\n            fcn.004054d6(uVar3);\n            if (*0x9689b0 == 0x1f) {\n                (*_sym.imp.KERNEL32.dll_AreFileApisANSI)();\n                (*_sym.imp.KERNEL32.dll_GetNamedPipeHandleStateA)\n                          (0, &lpState, &lpCurInstances, &lpMaxCollectionCount, &lpCollectDataTimeout, &lpUserName, 0);\n                (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(&lpNumberOfCharsWritten);\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *0x9689b0);\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_InterlockedExchange;\n    iVar4 = 0x5aedbe7;\n    do {\n        if (*0x9689b0 == 0x37) {\n            (*_sym.imp.KERNEL32.dll_GetConsoleAliasExesLengthA)();\n            (*_sym.imp.KERNEL32.dll_EnumCalendarInfoA)(0, 0, 0, 0);\n            (*_sym.imp.KERNEL32.dll_InterlockedCompareExchange)(&lpNumberOfCharsWritten, 0, 0);\n            (*_sym.imp.KERNEL32.dll_GetPrivateProfileStructW)(0x401430, 0x401400, &lpUserName, 0, 0x4013e8);\n            (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(&lpCriticalSection);\n            (*pcVar2)(0, 0);\n            (*_sym.imp.KERNEL32.dll_GetConsoleSelectionInfo)(&var_28h);\n            (*_sym.imp.KERNEL32.dll_LocalSize)(0);\n            (*_sym.imp.KERNEL32.dll_CancelDeviceWakeupRequest)(0);\n            (*_sym.imp.KERNEL32.dll_GetComputerNameA)(&lpStruct, &lpState);\n            (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(&var_40h);\n        }\n        iVar4 = iVar4 + -1;\n    } while (iVar4 != 0);\n    lpCollectDataTimeout = 0;\n    do {\n        if (*0x9689b0 == 0x2e) {\n            (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0);\n        }\n        if (lpCollectDataTimeout == 0x76069) {\n            *0x966e2c = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(0x80ede8);\n        }\n        lpCollectDataTimeout = lpCollectDataTimeout + 1;\n    } while (lpCollectDataTimeout < 0x1756bb);\n    *0x80ede8 = 0;\n    *0x80ede4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x966e2c, 0x80ede8);\n    iVar4 = 0;\n    do {\n        if (iVar4 == 0x1c) {\n            fcn.00405593();\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 0x3debc7);\n    fcn.0040545d(*0x96332c, *0x9689b0, 0x423010);\n    iVar4 = 0;\n    do {\n        if (*0x9689b0 == 0x10) {\n            (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(0);\n        }\n        if (iVar4 == 0x1e674) {\n            fcn.00405585();\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 0x3e4e2);\n    fcn.004051d4();\n    pcVar1 = _sym.imp.KERNEL32.dll_MoveFileWithProgressA;\n    if (*0x9689b0 == 0x1144) {\n        (*_sym.imp.KERNEL32.dll_FindNextVolumeW)(0, 0, 0);\n        (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(0x401474);\n        (*_sym.imp.KERNEL32.dll_CreateActCtxA)(&pActCtx);\n        (*_sym.imp.KERNEL32.dll_VerifyVersionInfoA)(&lpVersionInformation, 0, 0, 0);\n        (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(&lpNumberOfCharsWritten);\n        (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(0);\n        (*pcVar1)(0x4014a4, 0x40147c, 0, 0, 0);\n    }\n    if (*0x9689b0 == 0x1d) {\n        (*_sym.imp.KERNEL32.dll_WriteConsoleW)(0, 0, 0, &lpNumberOfCharsWritten, 0);\n        (*_sym.imp.KERNEL32.dll_GlobalFindAtomA)(0x4014d4);\n        (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0);\n        (*pcVar1)(0x40151c, 0x4014ec, 0, 0, 0);\n        (*_sym.imp.KERNEL32.dll_GetProcessAffinityMask)(0, 0, 0);\n        (*_sym.imp.KERNEL32.dll_GetACP)();\n        (*pcVar2)(&lpState, 0);\n        (*_sym.imp.KERNEL32.dll_GetPrivateProfileStructA)(0, 0, &lpStruct, 0, 0);\n        (*_sym.imp.KERNEL32.dll_GetVolumePathNameA)(0, 0, 0);\n        (*_sym.imp.KERNEL32.dll_GetConsoleAliasesLengthW)(0);\n        (*_sym.imp.KERNEL32.dll_GetFileTime)(0, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n        (*_sym.imp.KERNEL32.dll_GetStringTypeW)(0, 0, 0, 0);\n    }\n    fcn.0040557f();\n    return 0;\n}\n",
        "token_count": 1706
    },
    "00405cba": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00405cba(int32_t param_1)\n\n{\n    fcn.00409b07(*(param_1 + 4));\n    return;\n}\n",
        "token_count": 38
    },
    "00405d33": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00405d33(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00405a53();\n    if (iVar1 != 0) {\n        iVar1 = fcn.00405a53();\n        fcn.00409b17(*(iVar1 + 4));\n        return;\n    }\n    return;\n}\n",
        "token_count": 78
    },
    "00405edb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405edb(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    fcn.00404f11(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 63
    },
    "00405ef6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405ef6(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    fcn.00404f2d(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 65
    },
    "00405f53": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405f53(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    fcn.004091d2(arg_8h & 0xff, in_ECX + 8);\n    return;\n}\n",
        "token_count": 57
    },
    "00405f96": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405f96(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    fcn.00409896(arg_8h & 0xff, in_ECX + 8);\n    return;\n}\n",
        "token_count": 56
    },
    "00406165": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406165(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    **(in_ECX + 0x34) = **(in_ECX + 0x34) - arg_8h;\n    **(in_ECX + 0x24) = **(in_ECX + 0x24) + arg_8h;\n    return;\n}\n",
        "token_count": 92
    },
    "0040675a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nvoid __cdecl fcn.0040675a(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint *arg_ch;\n    uint var_1h;\n    \n    arg_ch = &var_1h;\n    *(in_ECX + 0x14) = arg_8h;\n    iVar1 = fcn.00405c42();\n    fcn.00404eee(iVar1 + arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 127
    },
    "004067d4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.004067d4(void)\n\n{\n    return 0x9249249;\n}\n",
        "token_count": 22
    },
    "004069bc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004069bc(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x14) <= arg_8h && arg_8h != *(in_ECX + 0x14)) {\n        fcn.0040a705();\n    }\n    iVar1 = fcn.00405c42();\n    return iVar1 + arg_8h;\n}\n",
        "token_count": 105
    },
    "00406b01": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl\nfcn.00406b01(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint arg_8h)\n\n{\n    uchar uVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h;\n    uint var_20h;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.0040a424();\n    *(unaff_EBP + -0x10) = &stack0xffffffe0;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    uVar2 = fcn.00406893();\n    *(unaff_EBP + 8) = uVar2;\n    *(extraout_ECX + 8) = 0;\n    *(extraout_ECX + 0x10) = 0;\n    *(extraout_ECX + 0x14) = 0;\n    *(unaff_EBP + -4) = 0;\n    fcn.00404f6c(unaff_EBP + -0x20);\n    uVar2 = fcn.00406a4e(*(*(unaff_EBP + 8) + 8));\n    *(extraout_ECX + 8) = uVar2;\n    uVar2 = fcn.00404f6c(unaff_EBP + -0x20);\n    uVar2 = fcn.00406898(0, uVar2);\n    uVar2 = fcn.00406a4e(uVar2);\n    *(extraout_ECX + 0x10) = uVar2;\n    uVar2 = fcn.00404f6c(unaff_EBP + -0x20);\n    uVar2 = fcn.0040689e(0, uVar2);\n    uVar2 = fcn.00406a4e(uVar2);\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(extraout_ECX + 0x14) = uVar2;\n    fcn.00404f6c(unaff_EBP + -0x20);\n    uVar1 = fcn.00406a46(***(unaff_EBP + 8));\n    *(extraout_ECX + 0xc) = uVar1;\n    fcn.00404f6c(unaff_EBP + -0x20);\n    uVar1 = fcn.00406a46(**(*(unaff_EBP + 8) + 4));\n    *(extraout_ECX + 0xd) = uVar1;\n    if (*(unaff_EBP + 0xc) != '\\0') {\n        fcn.00404f6c(unaff_EBP + -0x20);\n        uVar2 = fcn.00406a4e(0x40164d);\n        *(extraout_ECX + 8) = uVar2;\n        fcn.00404f6c(unaff_EBP + -0x20);\n        uVar1 = fcn.00406a46(0x2e);\n        *(extraout_ECX + 0xc) = uVar1;\n        fcn.00404f6c(unaff_EBP + -0x18);\n        uVar1 = fcn.00406a46(0x2c);\n        *(extraout_ECX + 0xd) = uVar1;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 886
    },
    "00406c52": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00406c52(uchar *arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    char cVar1;\n    uchar uVar2;\n    int32_t arg_8h_00;\n    uint arg_10h_00;\n    int32_t *in_ECX;\n    uchar *arg_8h_01;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    arg_8h_01 = arg_8h;\n    iVar3 = arg_10h;\n    if (0 < arg_10h) {\n        do {\n            arg_8h_00 = fcn.00406156();\n            if (arg_8h_00 < 1) {\n                arg_10h = (**(*in_ECX + 0x14))();\n                arg_8h = fcn.00406102();\n                cVar1 = fcn.004060ee(&arg_8h, &arg_10h);\n                if (cVar1 != '\\0') {\n                    return var_4h;\n                }\n                uVar2 = fcn.004060d9(&arg_10h);\n                *arg_8h_01 = uVar2;\n                arg_8h_01 = arg_8h_01 + 1;\n                var_4h = var_4h + 1;\n                iVar4 = -1;\n            }\n            else {\n                if (iVar3 < arg_8h_00) {\n                    arg_8h_00 = iVar3;\n                }\n                iVar4 = arg_8h_00;\n                arg_10h_00 = fcn.00405b25();\n                fcn.0040680e(arg_8h_01, arg_ch, arg_10h_00, iVar4);\n                var_4h = var_4h + arg_8h_00;\n                arg_8h_01 = arg_8h_01 + arg_8h_00;\n                iVar4 = -arg_8h_00;\n                fcn.00406132(arg_8h_00);\n            }\n            iVar3 = iVar3 + iVar4;\n        } while (0 < iVar3);\n    }\n    return var_4h;\n}\n",
        "token_count": 518
    },
    "00406cea": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00406cea(int32_t arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    int32_t iVar4;\n    int32_t arg_8h_00;\n    int32_t arg_10h;\n    int32_t arg_14h;\n    int32_t *var_8h;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    iVar4 = arg_ch;\n    var_8h = in_ECX;\n    if (0 < arg_ch) {\n        do {\n            iVar2 = fcn.00406179();\n            if (iVar2 < 1) {\n                iVar2 = *in_ECX;\n                uVar3 = fcn.004060e3(arg_8h);\n                arg_ch = (**(iVar2 + 4))(uVar3);\n                var_8h = fcn.00406102();\n                cVar1 = fcn.004060ee(&var_8h, &arg_ch);\n                if (cVar1 != '\\0') {\n                    return var_4h;\n                }\n                arg_8h = arg_8h + 1;\n                var_4h = var_4h + 1;\n                iVar2 = -1;\n            }\n            else {\n                arg_8h_00 = iVar2;\n                if (iVar4 < iVar2) {\n                    arg_8h_00 = iVar4;\n                }\n                arg_10h = arg_8h;\n                arg_14h = arg_8h_00;\n                uVar3 = fcn.00405b2b();\n                fcn.0040680e(uVar3, iVar2, arg_10h, arg_14h);\n                arg_8h = arg_8h + arg_8h_00;\n                var_4h = var_4h + arg_8h_00;\n                iVar2 = -arg_8h_00;\n                fcn.00406165(arg_8h_00);\n            }\n            iVar4 = iVar4 + iVar2;\n        } while (0 < iVar4);\n    }\n    return var_4h;\n}\n",
        "token_count": 496
    },
    "00406fdc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406fdc(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t arg_14h;\n    int32_t iVar2;\n    int32_t arg_ch_00;\n    int32_t iVar3;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x14) < arg_8h) {\n        fcn.00409a3a();\n    }\n    uVar1 = *(in_ECX + 0x14) - arg_8h;\n    if (uVar1 < arg_ch) {\n        arg_ch = uVar1;\n    }\n    if (arg_ch != 0) {\n        arg_14h = uVar1 - arg_ch;\n        iVar2 = fcn.00405c42();\n        iVar2 = iVar2 + arg_8h + arg_ch;\n        arg_ch_00 = *(in_ECX + 0x18) - arg_8h;\n        iVar3 = fcn.00405c42();\n        fcn.00406832(iVar3 + arg_8h, arg_ch_00, iVar2, arg_14h);\n        fcn.0040675a(*(in_ECX + 0x14) - arg_ch);\n    }\n    return;\n}\n",
        "token_count": 288
    },
    "00407511": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407511(uint32_t arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t in_ECX;\n    int32_t arg_8h_00;\n    \n    if (-*(in_ECX + 0x14) - 1U <= arg_8h) {\n        fcn.00409a02();\n    }\n    if (arg_8h != 0) {\n        arg_8h_00 = *(in_ECX + 0x14) + arg_8h;\n        cVar1 = fcn.0040747f(arg_8h_00, 0);\n        if (cVar1 != '\\0') {\n            fcn.00406a0c(*(in_ECX + 0x14), arg_8h, arg_ch);\n            fcn.0040675a(arg_8h_00);\n        }\n    }\n    return;\n}\n",
        "token_count": 203
    },
    "00407561": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407561(uint32_t arg_8h, uint32_t arg_ch, uint arg_10h)\n\n{\n    char cVar1;\n    int32_t arg_14h;\n    int32_t iVar2;\n    int32_t arg_ch_00;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t arg_8h_00;\n    \n    if (*(in_ECX + 0x14) < arg_8h) {\n        fcn.00409a3a();\n    }\n    if (-*(in_ECX + 0x14) - 1U <= arg_ch) {\n        fcn.00409a02();\n    }\n    if (arg_ch != 0) {\n        arg_8h_00 = *(in_ECX + 0x14) + arg_ch;\n        cVar1 = fcn.0040747f(arg_8h_00, 0);\n        if (cVar1 != '\\0') {\n            arg_14h = *(in_ECX + 0x14) - arg_8h;\n            iVar2 = fcn.00405c42();\n            iVar2 = iVar2 + arg_8h;\n            arg_ch_00 = (*(in_ECX + 0x18) - arg_8h) - arg_ch;\n            iVar3 = fcn.00405c42();\n            fcn.00406832(iVar3 + arg_8h + arg_ch, arg_ch_00, iVar2, arg_14h);\n            fcn.00406a0c(arg_8h, arg_ch, arg_10h);\n            fcn.0040675a(arg_8h_00);\n        }\n    }\n    return;\n}\n",
        "token_count": 379
    },
    "00407602": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407602(uint arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t arg_ch_00;\n    int32_t iVar6;\n    int32_t in_ECX;\n    \n    uVar3 = fcn.00405a35();\n    if (uVar3 < arg_ch) {\n        fcn.00409a3a();\n    }\n    iVar4 = fcn.00405a35();\n    if (iVar4 - arg_ch < arg_10h) {\n        arg_10h = iVar4 - arg_ch;\n    }\n    if ((-*(in_ECX + 0x14) - 1U <= arg_10h) || (*(in_ECX + 0x14) + arg_10h < *(in_ECX + 0x14))) {\n        fcn.00409a02();\n    }\n    if (arg_10h != 0) {\n        iVar4 = *(in_ECX + 0x14) + arg_10h;\n        cVar2 = fcn.0040747f(iVar4, 0);\n        if (cVar2 != '\\0') {\n            iVar1 = *(in_ECX + 0x14);\n            iVar5 = fcn.00405c42();\n            iVar5 = iVar5 + arg_ch;\n            arg_ch_00 = *(in_ECX + 0x18) - iVar1;\n            iVar6 = fcn.00405c42();\n            fcn.0040680e(iVar6 + iVar1, arg_ch_00, iVar5, arg_10h);\n            fcn.0040675a(iVar4);\n        }\n    }\n    return;\n}\n",
        "token_count": 409
    },
    "004077c6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004077c6(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint arg_8h_00;\n    int32_t in_ECX;\n    uint arg_ch_00;\n    uint32_t arg_14h;\n    \n    uVar2 = fcn.00405a35();\n    if (uVar2 < arg_ch) {\n        fcn.00409a3a();\n    }\n    iVar3 = fcn.00405a35();\n    uVar2 = iVar3 - arg_ch;\n    if (arg_10h < iVar3 - arg_ch) {\n        uVar2 = arg_10h;\n    }\n    if (in_ECX == arg_8h) {\n        fcn.00406fdc(uVar2 + arg_ch, 0xffffffff);\n        fcn.00406fdc(0, arg_ch);\n    }\n    else {\n        cVar1 = fcn.0040747f(uVar2, 0);\n        if (cVar1 != '\\0') {\n            arg_14h = uVar2;\n            iVar3 = fcn.00405c42();\n            iVar3 = iVar3 + arg_ch;\n            arg_ch_00 = *(in_ECX + 0x18);\n            arg_8h_00 = fcn.00405c42();\n            fcn.0040680e(arg_8h_00, arg_ch_00, iVar3, arg_14h);\n            fcn.0040675a(uVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 366
    },
    "004078be": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004078be(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    int32_t iVar3;\n    int32_t arg_ch_00;\n    int32_t iVar4;\n    int32_t in_ECX;\n    \n    cVar2 = fcn.00405d5a(arg_8h);\n    if (cVar2 == '\\0') {\n        if ((-*(in_ECX + 0x14) - 1U <= arg_ch) || (*(in_ECX + 0x14) + arg_ch < *(in_ECX + 0x14))) {\n            fcn.00409a02();\n        }\n        if (arg_ch != 0) {\n            iVar3 = *(in_ECX + 0x14) + arg_ch;\n            cVar2 = fcn.0040747f(iVar3, 0);\n            if (cVar2 != '\\0') {\n                iVar1 = *(in_ECX + 0x14);\n                arg_ch_00 = *(in_ECX + 0x18) - iVar1;\n                iVar4 = fcn.00405c42();\n                fcn.0040680e(iVar4 + iVar1, arg_ch_00, arg_8h, arg_ch);\n                fcn.0040675a(iVar3);\n            }\n        }\n    }\n    else {\n        iVar3 = fcn.00405c42();\n        fcn.00407602(in_ECX, arg_8h - iVar3, arg_ch);\n    }\n    return;\n}\n",
        "token_count": 351
    },
    "00407a4c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00407a4c(uint arg_8h)\n\n{\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    fcn.0040794c(*in_ECX + 0x18);\n    return arg_8h;\n}\n",
        "token_count": 62
    },
    "00407bc1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint * __cdecl fcn.00407bc1(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040a424();\n    arg_8h_00 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00409bf3(arg_8h_00);\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = 0x401678;\n    fcn.0040794c(arg_8h_00 + 0xc);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 249
    },
    "00407f24": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint * __cdecl fcn.00407f24(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040a424();\n    arg_8h_00 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00409bf3(arg_8h_00);\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = 0x401684;\n    fcn.0040794c(arg_8h_00 + 0xc);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 249
    },
    "00407ff8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00407ff8(uint32_t arg_8h)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    \n    *(in_ECX + 0xc) = 0;\n    *(in_ECX + 0x10) = 0;\n    *(in_ECX + 0x14) = 0;\n    if (arg_8h == 0) {\n        uVar1 = 0;\n    }\n    else {\n        uVar2 = fcn.004067d4();\n        if (uVar2 < arg_8h) {\n            fcn.00407b88();\n        }\n        iVar3 = fcn.004067dc(arg_8h);\n        *(in_ECX + 0xc) = iVar3;\n        *(in_ECX + 0x10) = iVar3;\n        *(in_ECX + 0x14) = arg_8h * 0x1c + iVar3;\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 243
    },
    "00408a51": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t __cdecl fcn.00408a51(uint arg_8h)\n\n{\n    uint uVar1;\n    char cVar2;\n    uchar uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040a424();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00405cfe(*(unaff_EBP + 8));\n    *(unaff_EBP + -4) = 0;\n    cVar2 = fcn.00405167();\n    if (cVar2 != '\\0') {\n        iVar4 = fcn.00405cb6();\n        if (iVar4 != 0) {\n            fcn.00405cb6();\n            fcn.00408a0c();\n        }\n    }\n    uVar3 = fcn.00405167();\n    uVar1 = *(unaff_EBP + -0xc);\n    *(extraout_ECX + 4) = uVar3;\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 322
    },
    "00408abf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00408abf(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint uVar1;\n    uint in_ECX;\n    uint var_48h;\n    uint var_8h;\n    \n    uVar1 = fcn.00405180();\n    uVar1 = fcn.00406947(in_ECX, &var_8h, 0x401714, uVar1);\n    uVar1 = fcn.0040a8b6(&var_48h, 0x40, uVar1, arg_1ch);\n    fcn.004087e9(in_ECX, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, &var_48h, uVar1);\n    return arg_8h;\n}\n",
        "token_count": 203
    },
    "00408b17": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00408b17(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint uVar1;\n    uint in_ECX;\n    uint var_48h;\n    uint var_8h;\n    \n    uVar1 = fcn.00405180();\n    uVar1 = fcn.00406947(in_ECX, &var_8h, 0x401718, uVar1);\n    uVar1 = fcn.0040a8b6(&var_48h, 0x40, uVar1, arg_1ch);\n    fcn.004087e9(in_ECX, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, &var_48h, uVar1);\n    return arg_8h;\n}\n",
        "token_count": 203
    },
    "00408b6f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.00408b6f(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    uint uVar1;\n    uint uVar2;\n    uint in_ECX;\n    uint var_40h;\n    \n    uVar2 = arg_1ch;\n    uVar1 = fcn.00405180(arg_1ch, arg_20h);\n    uVar1 = fcn.00406947(in_ECX, &arg_1ch, 0x40171c, uVar1);\n    uVar2 = fcn.0040a8b6(&var_40h, 0x40, uVar1, uVar2);\n    fcn.004087e9(in_ECX, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, &var_40h, uVar2);\n    return arg_8h;\n}\n",
        "token_count": 228
    },
    "00408bca": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.00408bca(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    uint uVar1;\n    uint uVar2;\n    uint in_ECX;\n    uint var_40h;\n    \n    uVar2 = arg_1ch;\n    uVar1 = fcn.00405180(arg_1ch, arg_20h);\n    uVar1 = fcn.00406947(in_ECX, &arg_1ch, 0x401720, uVar1);\n    uVar2 = fcn.0040a8b6(&var_40h, 0x40, uVar1, uVar2);\n    fcn.004087e9(in_ECX, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, &var_40h, uVar2);\n    return arg_8h;\n}\n",
        "token_count": 226
    },
    "00408eb4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00408eb4(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint arg_24h;\n    uint in_ECX;\n    uint var_40h;\n    \n    arg_24h = fcn.0040a8b6(&var_40h, 0x40, 0x401750, arg_1ch);\n    fcn.004087e9(in_ECX, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, &var_40h, arg_24h);\n    return arg_8h;\n}\n",
        "token_count": 158
    },
    "00408ef5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid fcn.00408ef5(void)\n\n{\n    uint32_t uVar1;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_4h;\n    uint var_ch;\n    uint var_10h;\n    \n    fcn.0040a424();\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = &var_ch;\n    uVar1 = fcn.00405180();\n    if ((uVar1 & 2) != 0) {\n        fcn.00408a0c();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 169
    },
    "00409052": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_30h\n\nint32_t * fcn.00409052(void)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    uint uVar3;\n    uint *puVar4;\n    uint32_t uVar5;\n    int32_t *arg_8h;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_18h;\n    uint var_10h;\n    uint var_38h;\n    uint var_30h;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h_2;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040a424();\n    *(unaff_EBP + -0x18) = 0;\n    *(unaff_EBP + -0x10) = &stack0xffffffc8;\n    *(unaff_EBP + -0x14) = arg_8h;\n    fcn.00408a51(arg_8h);\n    *(unaff_EBP + -4) = 0;\n    cVar2 = fcn.00405c08();\n    if (cVar2 != '\\0') {\n        uVar3 = fcn.00405184(unaff_EBP + -0x1c);\n        *(unaff_EBP + -4) = 1;\n        uVar3 = fcn.00408089(uVar3);\n        *(unaff_EBP + -0x20) = uVar3;\n        fcn.0040507f();\n        iVar1 = *(*arg_8h + 4);\n        *(unaff_EBP + -4) = 2;\n        uVar3 = fcn.00405a53();\n        puVar4 = fcn.00405c2d(uVar3);\n        uVar3 = *(unaff_EBP + 8);\n        uVar5 = fcn.00405afc();\n        fcn.00405c0c(unaff_EBP + -0x38, *puVar4, puVar4[1], iVar1 + arg_8h, uVar5 & 0xff, uVar3);\n        cVar2 = fcn.00405c3f();\n        if (cVar2 != '\\0') {\n            *(unaff_EBP + -0x18) = 4;\n        }\n        *(unaff_EBP + -4) = 0;\n    }\n    fcn.004081d9(*(unaff_EBP + -0x18), 0);\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00409015();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return arg_8h;\n}\n",
        "token_count": 643
    },
    "0040ab74": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040ab74(uint arg_8h)\n\n{\n    fcn.0040aa48(arg_8h, 0, 0);\n    return;\n}\n",
        "token_count": 41
    },
    "0040ad23": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040ad23(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00410d98(0x421cd0, 0xc);\n    if (*(unaff_EBP + 0xc) == 0) {\n        puVar1 = fcn.0040bf88();\n        *puVar1 = 0x16;\n        fcn.0040a6df(0, 0, 0, 0, 0);\n    }\n    else {\n        uVar2 = fcn.00411c3b();\n        fcn.00411d53(0, uVar2);\n        *(unaff_EBP + -4) = 0;\n        uVar2 = fcn.00411c3b(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n        uVar2 = (**(unaff_EBP + 8))(uVar2);\n        *(unaff_EBP + -0x1c) = uVar2;\n        *(unaff_EBP + -4) = 0xfffffffe;\n        fcn.0040ad9a();\n    }\n    fcn.00410ddd();\n    return;\n}\n",
        "token_count": 341
    },
    "0040ada9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040ada9(uint arg_8h, uint arg_ch)\n\n{\n    fcn.0040ad23(fcn.00411eba, arg_8h, 0, &arg_ch);\n    return;\n}\n",
        "token_count": 53
    },
    "0040f9f7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nfloat10 __cdecl fcn.0040f9f7(uint arg_8h, uint noname_1, uint arg_10h, uint arg_14h)\n\n{\n    float10 in_ST0;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    \n    fcn.00418eab();\n    return in_ST0;\n}\n",
        "token_count": 91
    },
    "00411516": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0041152a)\n// WARNING: Removing unreachable block (ram,0x00411530)\n// WARNING: Removing unreachable block (ram,0x00411532)\n\nvoid fcn.00411516(void)\n\n{\n    return;\n}\n",
        "token_count": 61
    },
    "004054d6": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get hostname",
            "get OS version",
            "get common file path"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004054d6(int32_t arg_8h)\n\n{\n    uint var_c9ch;\n    uint lpBuffer;\n    uint lpVersionInformation;\n    \n    if (*0x9689b0 == 0x37) {\n        (*_sym.imp.KERNEL32.dll_GetComputerNameExA)(0, 0, 0);\n        (*_sym.imp.KERNEL32.dll_FindResourceW)(0, 0x401350, 0x4012e8);\n        (*_sym.imp.KERNEL32.dll_lstrlenW)(0x401394);\n        (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0x4013a0);\n        (*_sym.imp.KERNEL32.dll_GetWindowsDirectoryA)(&lpBuffer, 0);\n        (*_sym.imp.KERNEL32.dll_MapViewOfFileEx)(0, 0, 0, 0, 0, 0);\n        (*_sym.imp.KERNEL32.dll_GlobalGetAtomNameW)(0, &var_c9ch, 0);\n        (*_sym.imp.KERNEL32.dll_DebugBreak)();\n        (*_sym.imp.KERNEL32.dll_LocalUnlock)(0);\n        (*_sym.imp.KERNEL32.dll_VerifyVersionInfoA)(&lpVersionInformation, 0, 0, 0);\n    }\n    *(*0x96332c + arg_8h) = *(*0x9689b4 + 0x38d6 + arg_8h);\n    return;\n}\n",
        "token_count": 320
    },
    "00405d8a": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00405d8a(int32_t param_1)\n\n{\n    *(param_1 + 0x10) = param_1 + 8;\n    *(param_1 + 0x14) = param_1 + 0xc;\n    *(param_1 + 0x20) = param_1 + 0x18;\n    *(param_1 + 0x24) = param_1 + 0x1c;\n    *(param_1 + 0x30) = param_1 + 0x28;\n    *(param_1 + 0x34) = param_1 + 0x2c;\n    fcn.00405b68(0, 0);\n    fcn.00405b3c(0, 0, 0);\n    return;\n}\n",
        "token_count": 181
    },
    "00407f93": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00407f93(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    *(param_1 + 0x24) = 0;\n    *(param_1 + 4) = 0;\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0x201;\n    *(param_1 + 0x14) = 6;\n    *(param_1 + 0x18) = 0;\n    *(param_1 + 0x1c) = 0;\n    *(param_1 + 0x20) = 0;\n    fcn.00407f82(0);\n    iVar1 = fcn.0040a45e(4);\n    if (iVar1 == 0) {\n        uVar2 = 0;\n    }\n    else {\n        uVar2 = fcn.0040504c();\n    }\n    *(param_1 + 0x24) = uVar2;\n    return;\n}\n",
        "token_count": 237
    },
    "0041ed1f": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid fcn.0041ed1f(void)\n\n{\n    *0x80edd0 = (*_sym.imp.KERNEL32.dll_CreateFileA)(0x4044fc, 0x40000000, 3, 0, 3, 0, 0);\n    return;\n}\n",
        "token_count": 65
    },
    "00406a4e": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406a4e(char *arg_8h)\n\n{\n    char cVar1;\n    char *pcVar2;\n    char *pcVar3;\n    \n    pcVar2 = arg_8h;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    pcVar2 = pcVar2 + (1 - (arg_8h + 1));\n    pcVar3 = fcn.004099a8(pcVar2);\n    for (; pcVar2 != NULL; pcVar2 = pcVar2 + -1) {\n        *pcVar3 = *arg_8h;\n        pcVar3 = pcVar3 + 1;\n        arg_8h = arg_8h + 1;\n    }\n    return;\n}\n",
        "token_count": 189
    },
    "00407e6f": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_94h\n\nvoid __cdecl fcn.00407e6f(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t extraout_ECX;\n    uint32_t extraout_ECX_00;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_94h;\n    int32_t arg_8h_00;\n    uint in_stack_ffffff74;\n    uint var_6ch;\n    uint var_50h;\n    uint var_28h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040a424();\n    uVar1 = *(unaff_EBP + 8) & 0x17;\n    *(extraout_ECX + 8) = uVar1;\n    uVar1 = *(extraout_ECX + 0xc) & uVar1;\n    if (uVar1 == 0) {\n        *in_FS_OFFSET = *(unaff_EBP + -0xc);\n        return;\n    }\n    uVar2 = 0;\n    if (*(unaff_EBP + 0xc) == '\\0') goto code_r0x00407ea1;\n    in_stack_ffffff74 = 0;\n    arg_8h_00 = 0;\n    do {\n        while( true ) {\n            fcn.0040a4c3(arg_8h_00, in_stack_ffffff74);\n            uVar1 = extraout_ECX_00;\ncode_r0x00407ea1:\n            if ((uVar1 & 4) == 0) break;\n            fcn.00407b57(0x4016f4);\n            *(unaff_EBP + -4) = uVar2;\ncode_r0x00407eb6:\n            fcn.00407b12(unaff_EBP + -0x28);\n            arg_8h_00 = unaff_EBP + -0x50;\n        }\n        uVar2 = 2;\n        if ((uVar1 & 2) != 0) {\n            fcn.00407b57(0x4016dc);\n            *(unaff_EBP + -4) = 1;\n            goto code_r0x00407eb6;\n        }\n        fcn.00407b57(0x4016c4);\n        *(unaff_EBP + -4) = 2;\n        fcn.00407b12(unaff_EBP + -0x6c);\n        arg_8h_00 = unaff_EBP + -0x94;\n    } while( true );\n}\n",
        "token_count": 586
    },
    "004099a8": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.004099a8(uint param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uchar auStack16 [12];\n    \n    do {\n        iVar2 = fcn.0040e122(param_1);\n        if (iVar2 != 0) {\n            return;\n        }\n        iVar2 = fcn.004100cb(param_1);\n    } while (iVar2 != 0);\n    if ((*0x968bf8 & 1) == 0) {\n        *0x968bf8 = *0x968bf8 | 1;\n        fcn.0040a443();\n        fcn.0040c0f8(0x41f425);\n    }\n    fcn.00405e93(0x968bec);\n    fcn.0040a4c3(auStack16, 0x421474);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 213
    },
    "0040e1ec": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040e1ec(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *arg_8h_00;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00410d98(0x421f18, 0xc);\n    fcn.0041029f(0xe);\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = *0x968c58;\n    iVar1 = *(unaff_EBP + 8);\n    iVar2 = *(iVar1 + 4);\n    if (iVar2 != 0) {\n        piVar3 = 0x968c54;\n        do {\n            piVar4 = piVar3;\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 == NULL) goto code_r0x0040e230;\n            piVar3 = arg_8h_00;\n        } while (*arg_8h_00 != iVar2);\n        piVar4[1] = arg_8h_00[1];\n        fcn.0040a51a(arg_8h_00);\ncode_r0x0040e230:\n        fcn.0040a51a(*(iVar1 + 4));\n        *(iVar1 + 4) = 0;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.0040e253();\n    fcn.00410ddd();\n    return;\n}\n",
        "token_count": 399
    }
}